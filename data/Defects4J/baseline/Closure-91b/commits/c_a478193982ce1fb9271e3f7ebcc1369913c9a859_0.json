{"sha": "a478193982ce1fb9271e3f7ebcc1369913c9a859", "log": "Add a debugging option for variable renaming. Bug fixes for direct calls on the arguments array.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n       default:\n         throw new RuntimeException(\"Unknown compilation level.\");\n     }\n+  }\n+\n+  public void setDebugOptionsForCompilationLevel(CompilerOptions options) {\n+    options.anonymousFunctionNaming = AnonymousFunctionNamingPolicy.UNMAPPED;\n+    options.generatePseudoNames = true;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n       renameVars(options_.renamePrefix,\n           options_.variableRenaming == VariableRenamingPolicy.LOCAL,\n           options_.anonymousFunctionNaming,\n+          options_.generatePseudoNames,\n           prevVariableMap);\n     }\n \n \n   void renameVars(String renamePrefix, boolean renameLocalVarsOnly,\n       AnonymousFunctionNamingPolicy anonFunctionNamePolicy,\n+      boolean generatePseudoNames,\n       VariableMap prevVariableMap) {\n     logger_.info(\"Renaming vars\");\n     startPass(\"renameVars\");\n     RenameVars rn = new RenameVars(\n         this, renamePrefix,\n         renameLocalVarsOnly, preserveAnonymousFunctionNames,\n+        generatePseudoNames,\n         prevVariableMap,\n         anonFunctionNamePolicy.getReservedCharacters(),\n         getPassConfig().getExportedNames());\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   /** Controls label renaming. */\n   public boolean labelRenaming;\n \n-  /** Generate pseudo names for properties (for debugging purposes) */\n+  /**\n+   * Generate pseudo names for variables and properties for debugging purposes.\n+   */\n   public boolean generatePseudoNames;\n \n   /** Specifies a prefix for all globals */\n--- a/src/com/google/javascript/jscomp/ConcreteType.java\n+++ b/src/com/google/javascript/jscomp/ConcreteType.java\n    */\n   static class ConcreteFunctionType extends ConcreteType {\n     /** Name used for the call slot (see {@code getCallSlot}). */\n-    static final String CALL_SLOT_NAME = \"$call\";\n+    static final String CALL_SLOT_NAME = \":call\";\n \n     /** Name used for the this slot (see {@code getThisSlot}). */\n-    static final String THIS_SLOT_NAME = \"$this\";\n+    static final String THIS_SLOT_NAME = \":this\";\n \n     /** Name used for the return slot (see {@code getReturnSlot}). */\n-    static final String RETURN_SLOT_NAME = \"$return\";\n+    static final String RETURN_SLOT_NAME = \":return\";\n \n     private final Factory factory;\n     private final Node declaration;\n--- a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n+++ b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n     // determine the real highestIndex.\n     for (Node ref : currentArgumentsAccess) {\n \n+      Node getElem = ref.getParent();\n+      \n       // Bail on anything but argument[c] access where c is a constant.\n       // TODO(user): We might not need to bail out all the time, there might\n       // be more cases that we can cover.\n-      if (ref.getParent().getType() != Token.GETELEM) {\n+      if (getElem.getType() != Token.GETELEM) {\n         return false;\n       }\n \n         // it is never 'callee'.\n         return false; // Give up.\n       }\n+      \n+      Node getElemParent = getElem.getParent();\n+      // When we have argument[0](), replacing it with a() is semantically\n+      // different if argument[0] is a function call that refers to 'this'\n+      if (NodeUtil.isCall(getElemParent) &&\n+          getElemParent.getFirstChild() == getElem) {\n+        // TODO(user): We can consider using .call() if aliasing that\n+        // argument allows shorter alias for other arguments.\n+        return false;\n+      }\n \n       // Replace the highest index if we see an access that has a higher index\n       // than all the one we saw before.\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n    */\n   private boolean preserveAnonymousFunctionNames;\n \n+  /** Generate pseudo names for variables for debugging purposes */\n+  private boolean generatePseudoNames;\n+\n   /** Characters that shouldn't be used in variable names. */\n   private final char[] reservedCharacters;\n \n       String prefix,\n       boolean localRenamingOnly,\n       boolean preserveAnonymousFunctionNames,\n+      boolean generatePseudoNames,\n       VariableMap prevUsedRenameMap,\n       @Nullable char[] reservedCharacters,\n       @Nullable Set<String> reservedNames) {\n     this.prefix = prefix == null ? \"\" : prefix;\n     this.localRenamingOnly = localRenamingOnly;\n     this.preserveAnonymousFunctionNames = preserveAnonymousFunctionNames;\n+    this.generatePseudoNames = generatePseudoNames;\n     this.prevUsedRenameMap = prevUsedRenameMap;\n     this.reservedCharacters = reservedCharacters;\n     if (reservedNames == null) {\n \n     // Rename the globals!\n     for (Node n : globalNameNodes) {\n-      String oldName = n.getString();\n-      Assignment a = assignments.get(oldName);\n-\n+      String newName = getNewGlobalName(n);\n       // Note: if newName is null, then oldName is an extern.\n-      if (a.newName != null) {\n-        n.setString(a.newName);\n-        changed = changed || !a.newName.equals(oldName);\n+      if (newName != null) {\n+        n.setString(newName);\n+        changed = true;\n       }\n     }\n \n     // Rename the locals!\n     int count = 0;\n     for (Node n : localNameNodes) {\n-      String oldName = localTempNames.get(count);\n-      Assignment a = assignments.get(oldName);\n-      n.setString(a.newName);\n-      changed = changed || !a.newName.equals(oldName);\n+      String newName = getNewLocalName(n, count);\n+      if (newName != null) {\n+        n.setString(newName);\n+        changed = true;\n+      }\n       count++;\n     }\n \n     // Lastly, write the name assignments to the debug log.\n     compiler.addToDebugLog(\"JS var assignments:\\n\" + assignmentLog);\n     assignmentLog = null;\n+  }\n+\n+  private String getNewGlobalName(Node n) {\n+    String oldName = n.getString();\n+    Assignment a = assignments.get(oldName);\n+    if (a.newName != null && !a.newName.equals(oldName)) {\n+      if (generatePseudoNames) {\n+        return getPseudoName(oldName);\n+      }\n+      return a.newName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private String getNewLocalName(Node n, int index) {\n+    String oldTempName = localTempNames.get(index);\n+    Assignment a = assignments.get(oldTempName);\n+    if (!a.newName.equals(oldTempName)) {\n+      if (generatePseudoNames) {\n+        return getPseudoName(n.getString());\n+      }\n+      return a.newName;\n+    }\n+    return null;\n+  }\n+\n+  private String getPseudoName(String s) {\n+    Preconditions.checkState(generatePseudoNames);\n+    // Variable names should be in a different name space than\n+    // property pseudo names.\n+    return '$' + s + \"$$\";\n   }\n \n   /**\n         // For local variable, we make the assignment right away.\n         newName = localNameGenerator.generateNextName();\n         finalizeNameAssignment(a, newName);\n-\n       } else {\n         // For non-local variable, delay finalizing the name assignment\n         // until we know how many new names we'll have of length 2, 3, etc.\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n       put(\"enum\", Annotation.ENUM).\n       put(\"export\", Annotation.EXPORT).\n       put(\"extends\", Annotation.EXTENDS).\n+      put(\"externs\", Annotation.EXTERNS).\n       put(\"fileoverview\", Annotation.FILE_OVERVIEW).\n       put(\"final\", Annotation.CONSTANT).\n       put(\"hidden\", Annotation.HIDDEN).\n     DESC,\n     ENUM,\n     EXTENDS,\n+    EXTERNS,\n     EXPORT,\n     FILE_OVERVIEW,\n     HIDDEN,\n                   token = eatTokensUntilEOL();\n                   continue retry;\n \n+                case EXTERNS:\n+                  if (!jsdocBuilder.recordExterns()) {\n+                    parser.addWarning(\"msg.jsdoc.externs\",\n+                        stream.getLineno(), stream.getCharno());\n+                  }\n+                  token = eatTokensUntilEOL();\n+                  continue retry;\n+\n                 case EXTENDS:\n                 case IMPLEMENTS:\n                   skipEOLs();\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n   private static final int MASK_FILEOVERVIEW  = 0x00001000; // @fileoverview\n   private static final int MASK_IMPLICITCAST  = 0x00002000; // @implicitCast\n   private static final int MASK_NOSIDEEFFECTS = 0x00004000; // @nosideeffects\n+  private static final int MASK_EXTERNS       = 0x00008000; // @externs\n \n   // 3 bit type field stored in the top 3 bits of the most significant\n   // nibble.\n     setFlag(value, MASK_NOSIDEEFFECTS);\n   }\n \n+  void setExterns(boolean value) {\n+    setFlag(value, MASK_EXTERNS);\n+  }\n+\n   private void setFlag(boolean value, int mask) {\n     if (value) {\n       bitset |= mask;\n     return getFlag(MASK_NOSIDEEFFECTS);\n   }\n \n+  /**\n+   * Returns whether the {@code @externs} annotation is present on this\n+   * {@link JSDocInfo}.\n+   */\n+  public boolean isExterns() {\n+    return getFlag(MASK_EXTERNS);\n+  }\n+\n   private boolean getFlag(int mask) {\n     return (bitset & mask) != 0x00;\n   }\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n    * fileoverview tag.\n    */\n   public boolean isPopulatedWithFileOverview() {\n-    return isPopulated() && currentInfo.hasFileOverview();\n+    return isPopulated() &&\n+        (currentInfo.hasFileOverview() || currentInfo.isExterns());\n   }\n \n   /**\n   }\n \n   /**\n+   * Records that the {@link JSDocInfo} being built should have its\n+   * {@link JSDocInfo#isExterns()} flag set to {@code true}.\n+   */\n+  public boolean recordExterns() {\n+    if (!currentInfo.isExterns()) {\n+      currentInfo.setExterns(true);\n+      populated = true;\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  /**\n    * Whether the {@link JSDocInfo} being built will have its\n    * {@link JSDocInfo#isInterface()} flag set to {@code true}.\n    */\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n \n package com.google.javascript.rhino.jstype;\n \n-import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n-\n+import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Multimaps;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.ScriptRuntime;\n import com.google.javascript.rhino.Token;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n import java.io.Serializable;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n \n /**\n  * The type registry is used to resolve named types.\n \n   // All the unresolved named types.\n   private final Multimap<StaticScope<JSType>, NamedType> unresolvedNamedTypes =\n-      Multimaps.newArrayListMultimap();\n+      ArrayListMultimap.create();\n \n   // All the resolved named types.\n   private final Multimap<StaticScope<JSType>, NamedType> resolvedNamedTypes =\n-      Multimaps.newArrayListMultimap();\n+      ArrayListMultimap.create();\n \n   // NamedType warns about unresolved types in the last generation.\n   private boolean lastGeneration = true;\n--- a/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java\n+++ b/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java\n     testSame(\n         \"function f() { arguments[0]; var x = 'callee'; arguments[x].length}\");\n   }\n+  \n+  public void testNoOptimizationWhenArgumentIsUsedAsFunctionCall() {\n+    testSame(\"function f() {arguments[0]()}\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/RenameLocalVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameLocalVarsTest.java\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n-    return new RenameVars(compiler, prefix, true, false, null, null, null);\n+    return new RenameVars(\n+        compiler, prefix, true, false, false, null, null, null);\n   }\n \n   public void testRenameSimple() {\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n   private boolean localRenamingOnly = false;\n   private boolean preserveAnonymousFunctionNames = false;\n   private boolean useGoogleCodingConvention = true;\n+  private boolean generatePseudoNames = false;\n \n   @Override\n   protected CodingConvention getCodingConvention() {\n     } else {\n       return renameVars = new RenameVars(compiler, prefix,\n           localRenamingOnly, preserveAnonymousFunctionNames,\n+          generatePseudoNames,\n           previouslyUsedMap, null, null);\n     }\n   }\n     withClosurePass = false;\n     localRenamingOnly = false;\n     preserveAnonymousFunctionNames = false;\n+    generatePseudoNames = false;\n   }\n \n   public void testRenameSimple() {\n          \"var d = function(a,     b,    c        ){}\");\n   }\n \n+  public void testPseudoNames() {\n+    generatePseudoNames = false;\n+    // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n+    test(\"var foo = function(a, b, c){}\",\n+         \"var d = function(a, b, c){}\");\n+    \n+    generatePseudoNames = true;\n+    test(\"var foo = function(a, b, c){}\",\n+         \"var $foo$$ = function($a$$, $b$$, $c$$){}\");\n+  }  \n+  \n   private void testRenameMapUsingOldMap(String input, String expected,\n                                         VariableMap expectedMap) {\n     previouslyUsedMap = renameVars.getVariableMap();\n           new ProcessClosurePrimitives(compiler, CheckLevel.WARNING, true);\n       closurePass.process(externs, root);\n       renameVars = new RenameVars(compiler, prefix,\n-          false, false, previouslyUsedMap, null,\n+          false, false, false, previouslyUsedMap, null,\n           closurePass.getExportedVariableNames());\n       renameVars.process(externs, root);\n     }", "timestamp": 1259684933, "metainfo": ""}