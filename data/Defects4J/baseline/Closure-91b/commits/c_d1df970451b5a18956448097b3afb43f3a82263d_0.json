{"sha": "d1df970451b5a18956448097b3afb43f3a82263d", "log": "Change on 2010/06/09 by nicksantos          be clear that \"assigned once\" means \"assigned once in lifetime\"         fixes issue 174.          R=johnlenz         DELTA=125  (113 added, 0 deleted, 12 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=26002   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n           collector.getReferenceCollection(aliasVar);\n       if (aliasRefs.isWellDefined()\n           && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnce()) {\n+          && aliasRefs.isAssignedOnceInLifetime()) {\n         // The alias is well-formed, so do the inlining now.\n         int size = aliasRefs.references.size();\n         Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n           // another pass that handles unused variables much more elegantly.\n           if (referenceInfo != null && referenceInfo.references.size() >= 2 &&\n               referenceInfo.isWellDefined() &&\n-              referenceInfo.isAssignedOnce()) {\n+              referenceInfo.isAssignedOnceInLifetime()) {\n             Reference init = referenceInfo.getInitializingReference();\n             Node value = init.getAssignedValue();\n             if (value != null && value.getType() == Token.NAME) {\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!staleVars.contains(v) && referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnce()) {\n+          referenceInfo.isAssignedOnceInLifetime()) {\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n           Node nameNode = refs.get(i).getNameNode();\n         return false;\n       }\n \n-      if (!refInfo.isAssignedOnce()) {\n+      if (!refInfo.isAssignedOnceInLifetime()) {\n         return false;\n       }\n \n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n     }\n \n     /**\n-     * @return Whether the variable is only assigned a value once.\n-     */\n-    boolean isAssignedOnce() {\n-      boolean assigned = false;\n+     * @return Whether the variable is only assigned a value once for its\n+     *     lifetime.\n+     */\n+    boolean isAssignedOnceInLifetime() {\n+      Reference ref = getOneAndOnlyAssignment();\n+      if (ref == null) {\n+        return false;\n+      }\n+\n+      // Make sure this assignment is not in a loop.\n+      for (BasicBlock block = ref.getBasicBlock();\n+           block != null; block = block.getParent()) {\n+        if (block.isFunction) {\n+          break;\n+        } else if (block.isLoop) {\n+          return false;\n+        }\n+      }\n+\n+      return true;\n+    }\n+\n+    /**\n+     * @return The one and only assignment. Returns if there are 0 or 2+\n+     *    assignments.\n+     */\n+    private Reference getOneAndOnlyAssignment() {\n+      Reference assignment = null;\n       int size = references.size();\n       for (int i = 0; i < size; i++) {\n         Reference ref = references.get(i);\n         if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n-          if (!assigned) {\n-            assigned = true;\n+          if (assignment == null) {\n+            assignment = ref;\n           } else {\n-            return false;\n+            return null;\n           }\n         }\n       }\n-      return assigned;\n+      return assignment;\n     }\n \n     /**\n     }\n \n    /**\n-    * @return For an assignment, variable declaration, or function declaration \n+    * @return For an assignment, variable declaration, or function declaration\n     * return the assigned value, otherwise null.\n     */\n     Node getAssignedValue() {\n     private final boolean isHoisted;\n \n     /**\n+     * Whether this block denotes a function scope.\n+     */\n+    private final boolean isFunction;\n+\n+    /**\n+     * Whether this block denotes a loop.\n+     */\n+    private final boolean isLoop;\n+\n+    /**\n      * Creates a new block.\n      * @param parent The containing block.\n      * @param root The root node of the block.\n \n       // only named functions may be hoisted.\n       this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);\n+\n+      this.isFunction = root.getType() == Token.FUNCTION;\n+\n+      if (root.getParent() != null) {\n+        int pType = root.getParent().getType();\n+        this.isLoop = pType == Token.DO ||\n+            pType == Token.WHILE ||\n+            pType == Token.FOR;\n+      } else {\n+        this.isLoop = false;\n+      }\n     }\n \n     BasicBlock getParent() {\n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n          \"var x; x = this.foo(); this.bar(); function f() { this.baz(x); }\");\n   }\n \n+  public void testInlineAliasesInLoop() {\n+    test(\n+        \"function f() { \" +\n+        \"  var x = extern();\" +\n+        \"  for (var i = 0; i < 5; i++) {\" +\n+        \"    (function() {\" +\n+        \"       var y = x; window.setTimeout(function() { extern(y); }, 0);\" +\n+        \"     })();\" +\n+        \"  }\" +\n+        \"}\",\n+        \"function f() { \" +\n+        \"  var x = extern();\" +\n+        \"  for (var i = 0; i < 5; i++) {\" +\n+        \"    (function() {\" +\n+        \"       window.setTimeout(function() { extern(x); }, 0);\" +\n+        \"     })();\" +\n+        \"  }\" +\n+        \"}\");\n+  }\n+\n+  public void testNoInlineAliasesInLoop() {\n+    testSame(\n+        \"function f() { \" +\n+        \"  for (var i = 0; i < 5; i++) {\" +\n+        \"    var x = extern();\" +\n+        \"    (function() {\" +\n+        \"       var y = x; window.setTimeout(function() { extern(y); }, 0);\" +\n+        \"     })();\" +\n+        \"  }\" +\n+        \"}\");\n+  }\n+\n   public void testNoInlineAliases1() {\n     testSame(\n         \"var x = this.foo(); this.bar(); var y = x; x = 3; this.baz(y);\");", "timestamp": 1276200758, "metainfo": ""}