{"sha": "9afca869d4236594514b8461d771af9999c8a989", "log": "Better type checking for switch/case conditions.  Customizable input delimiters.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n           if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n             cb.append(\"\\n\");  // Make sure that the label starts on a new line\n           }\n-          cb.append(\"// Input \")\n-            .append(String.valueOf(inputSeqNum))\n+          Preconditions.checkState(root.getType() == Token.SCRIPT);\n+          \n+          String delimiter = options_.inputDelimiter;\n+          \n+          String sourceName = (String)root.getProp(Node.SOURCENAME_PROP);\n+          Preconditions.checkState(sourceName != null);\n+          Preconditions.checkState(!sourceName.isEmpty());\n+          \n+          delimiter = delimiter.replaceAll(\"%name%\", sourceName)\n+            .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+\n+          cb.append(delimiter)\n             .append(\"\\n\");\n         }\n         if (root.getJSDocInfo() != null &&\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Prints a separator comment before each js script */\n   public boolean printInputDelimiter;\n+\n+  /** The string to use as the separator for printInputDelimiter */\n+  public String inputDelimiter = \"// Input %num%\";\n \n   /** Where to save a report of global name usage */\n   public String reportPath;\n--- a/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n   public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n       FlowScope blindScope, boolean outcome) {\n     // Check for the typeof operator.\n-    switch (condition.getType()) {\n+    int operatorToken = condition.getType();\n+    switch (operatorToken) {\n       case Token.EQ:\n       case Token.NE:\n       case Token.SHEQ:\n       case Token.SHNE:\n-        Node left = condition.getFirstChild();\n-        Node right = condition.getLastChild();\n+      case Token.CASE:\n+        Node left;\n+        Node right;\n+        if (operatorToken == Token.CASE) {\n+          left = condition.getParent().getFirstChild(); // the switch condition\n+          right = condition.getFirstChild();\n+        } else {\n+          left = condition.getFirstChild();\n+          right = condition.getLastChild();\n+        }\n+\n         Node typeOfNode = null;\n         Node stringNode = null;\n         if (left.getType() == Token.TYPEOF && right.getType() == Token.STRING) {\n           Node operandNode = typeOfNode.getFirstChild();\n           JSType operandType = getTypeIfRefinable(operandNode, blindScope);\n           if (operandType != null) {\n-            boolean resultEqualsValue = condition.getType() == Token.EQ ||\n-                                        condition.getType() == Token.SHEQ;\n+            boolean resultEqualsValue = operatorToken == Token.EQ ||\n+                operatorToken == Token.SHEQ || operatorToken == Token.CASE;\n             if (!outcome) {\n               resultEqualsValue = !resultEqualsValue;\n             }\n           }\n         }\n     }\n-    switch (condition.getType()) {\n+    switch (operatorToken) {\n       case Token.AND:\n         if (outcome) {\n           return caseAndOrNotShortCircuiting(condition.getFirstChild(),\n               condition.getFirstChild().getString(), blindScope);\n         }\n         break;\n+\n+      case Token.CASE:\n+        Node left =\n+            condition.getParent().getFirstChild(); // the switch condition\n+        Node right = condition.getFirstChild();\n+        if (outcome) {\n+          return caseEquality(left, right, blindScope, SHEQ);\n+        } else {\n+          return caseEquality(left, right, blindScope, SHNE);\n+        }\n     }\n     return nextPreciserScopeKnowingConditionOutcome(\n         condition, blindScope, outcome);\n \n   private FlowScope caseEquality(Node condition, FlowScope blindScope,\n       Function<TypePair, TypePair> merging) {\n-    Node left = condition.getFirstChild();\n-    Node right = condition.getLastChild();\n-\n+    return caseEquality(condition.getFirstChild(), condition.getLastChild(),\n+                        blindScope, merging);\n+  }\n+\n+  private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,\n+      Function<TypePair, TypePair> merging) {\n     // left type\n     JSType leftType = getTypeIfRefinable(left, blindScope);\n     boolean leftIsRefineable;\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n           if (condition == null) {\n             condition = NodeUtil.getConditionExpression(source);\n             if (condition == null && source.getType() == Token.CASE) {\n-              condition = createSwitchCaseConditionExpression(source);\n+              condition = source;\n+\n+              // conditionFlowScope is cached from previous iterations\n+              // of the loop.\n+              if (conditionFlowScope == null) {\n+                conditionFlowScope = traverse(\n+                    condition.getFirstChild(), output.createChildFlowScope());\n+              }\n             }\n           }\n \n     return result;\n   }\n \n-  /**\n-   * Given the case node of some switch(x) {... case y: ...} statement,\n-   * constructs and returns the condition x === y.\n-   */\n-  private Node createSwitchCaseConditionExpression(Node caseNode) {\n-    Node switchNode = findSwitchFromCase(caseNode);\n-    Node switchExpressionNode = switchNode.getFirstChild();\n-    Node caseExpressionNode = caseNode.getFirstChild();\n-    return new Node(Token.SHEQ, switchExpressionNode.cloneTree(),\n-        caseExpressionNode.cloneTree());\n-  }\n-\n-  /**\n-   * Finds the switch node associated with a case node.\n-   */\n-  private Node findSwitchFromCase(Node caseNode) {\n-    for (DiGraphNode<Node, Branch> gn :\n-        getCfg().getDirectedPredNodes(caseNode)) {\n-      Node n = gn.getValue();\n-      switch (n.getType()) {\n-        case Token.SWITCH:\n-          return n;\n-        case Token.CASE:\n-          return findSwitchFromCase(n);\n-      }\n-    }\n-    throw new IllegalArgumentException(\"ill-formed case node\");\n-  }\n-\n   private FlowScope traverse(Node n, FlowScope scope) {\n     switch (n.getType()) {\n       case Token.ASSIGN:\n         if (n.getFirstChild().getType() == Token.GETPROP) {\n           ensurePropertyDeclared(n.getFirstChild());\n         }\n+        break;\n+\n+      case Token.SWITCH:\n+        scope = traverse(n.getFirstChild(), scope);\n         break;\n \n       case Token.VAR:\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n     testTypes(\"/** @type {(Number,Null)} */\" +\n         \"var a = new Number(5);\" +\n         \"switch (a) { case 5:break; case null:break; }\");\n+  }\n+\n+  public void testSwitchCase7() throws Exception {\n+    // This really tests the inference inside the case.\n+    testTypes(\n+        \"/**\\n\" +\n+        \" * @param {number} x\\n\" +\n+        \" * @return {number}\\n\" +\n+        \" */\\n\" +\n+        \"function g(x) { return 5; }\" +\n+        \"function f() {\" +\n+        \"  var x = {};\" +\n+        \"  x.foo = '3';\" +\n+        \"  switch (3) { case g(x.foo): return 3; }\" +\n+        \"}\",\n+        \"actual parameter 1 of g does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testSwitchCase8() throws Exception {\n+    // This really tests the inference inside the switch clause.\n+    testTypes(\n+        \"/**\\n\" +\n+        \" * @param {number} x\\n\" +\n+        \" * @return {number}\\n\" +\n+        \" */\\n\" +\n+        \"function g(x) { return 5; }\" +\n+        \"function f() {\" +\n+        \"  var x = {};\" +\n+        \"  x.foo = '3';\" +\n+        \"  switch (g(x.foo)) { case 3: return 3; }\" +\n+        \"}\",\n+        \"actual parameter 1 of g does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n   }\n \n   public void testNoTypeCheck1() throws Exception {", "timestamp": 1264192184, "metainfo": ""}