{"sha": "b67116eec83f769036f7354eb0270141edc8e5fa", "log": "Fix for template issue: Create synthetic blocks before and after the template markers to prevent the motion of the end marker within the block.  R=nicksantos DELTA=215  (128 added, 43 deleted, 44 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=168005   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CreateSyntheticBlocks.java\n+++ b/src/com/google/javascript/jscomp/CreateSyntheticBlocks.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.ArrayDeque;\n import java.util.Deque;\n+import java.util.List;\n+\n+import javax.annotation.Nullable;\n \n /**\n- * Creates synthetic blocks to prevent {@link FoldConstants} from moving code\n+ * Creates synthetic blocks to optimizations from moving code\n  * past markers in the source.\n  *\n  *\n+ * @author johnlenz@google.com (John Lenz)\n  */\n class CreateSyntheticBlocks implements CompilerPass {\n   static final DiagnosticType UNMATCHED_START_MARKER = DiagnosticType.warning(\n   static final DiagnosticType UNMATCHED_END_MARKER = DiagnosticType.warning(\n       \"JSC_UNMATCHED_END_MARKER\", \"Unmatched {1} - {0} not in the same block\");\n \n-  private static class StartMarker {\n-    /** Records the source name for errors about unmatched start markers. */\n-    final String sourceName;\n-\n-    /** Records the node for errors about unmatched start markers. */\n-    final Node node;\n-\n-    /**\n-     * Records the ancestor block's child for insertion of a synthetic block.\n-     */\n-    final Node ancestorBlockChild;\n-\n-    /** Records the ancestor block for insertion of a synthetic block. */\n-    final Node ancestorBlock;\n-\n-    private StartMarker(String sourceName, Node n, Node ancestorBlockChild,\n-        Node ancestorBlock) {\n-      this.sourceName = sourceName;\n-      node = n;\n-      this.ancestorBlockChild = ancestorBlockChild;\n-      this.ancestorBlock = ancestorBlock;\n-    }\n-  }\n+  static final DiagnosticType INVALID_MARKER_USAGE = DiagnosticType.warning(\n+      \"JSC_INVALID_MARKER_USAGE\", \"Marker {0} can only be used in a simple \"\n+           + \"call expression\");\n \n   private final AbstractCompiler compiler;\n \n   /**\n    * Markers can be nested.\n    */\n-  private Deque<StartMarker> startMarkerStack;\n+  private final Deque<Node> markerStack = new ArrayDeque<Node>();\n+\n+  private final List<Marker> validMarkers = Lists.newArrayList();\n+\n+  private class Marker {\n+    final Node startMarker;\n+    final Node endMarker;\n+    public Marker(Node startMarker, Node endMarker) {\n+      this.startMarker = startMarker;\n+      this.endMarker = endMarker;\n+    }\n+  }\n \n   public CreateSyntheticBlocks(AbstractCompiler compiler,\n       String startMarkerName, String endMarkerName) {\n     this.compiler = compiler;\n     this.startMarkerName = startMarkerName;\n     this.endMarkerName = endMarkerName;\n-    startMarkerStack = new ArrayDeque<StartMarker>();\n   }\n \n   @Override\n   public void process(Node externs, Node root) {\n+    // Find and validate the markers.\n     NodeTraversal.traverse(compiler, root, new Callback());\n \n-    for (StartMarker startMarker : startMarkerStack) {\n-      compiler.report(JSError.make(startMarker.sourceName, startMarker.node,\n+    // Complain about any unmatched markers.\n+    for (Node node : markerStack) {\n+      compiler.report(\n+          JSError.make(NodeUtil.getSourceName(node),\n+          node,\n           UNMATCHED_START_MARKER, startMarkerName));\n+    }\n+\n+    // Add the block for the valid marker sets.\n+    for (Marker marker : validMarkers) {\n+      addBlocks(marker);\n+    }\n+  }\n+\n+  /**\n+   * @param marker The marker to add synthetic blocks for.\n+   */\n+  private void addBlocks(Marker marker) {\n+    // Add block around the template section so that it looks like this:\n+    //  BLOCK (synthetic)\n+    //    START\n+    //      BLOCK (synthetic)\n+    //        BODY\n+    //    END\n+    // This prevents the start or end markers from mingling with the code\n+    // in the block body.\n+\n+\n+    Node originalParent = marker.endMarker.getParent();\n+    Node outerBlock = new Node(Token.BLOCK);\n+    outerBlock.setIsSyntheticBlock(true);\n+    originalParent.addChildBefore(outerBlock, marker.startMarker);\n+\n+    Node innerBlock = new Node(Token.BLOCK);\n+    innerBlock.setIsSyntheticBlock(true);\n+    // Move everything after the start Node up to the end Node into the inner\n+    // block.\n+    moveSiblingExclusive(originalParent, innerBlock,\n+        marker.startMarker,\n+        marker.endMarker);\n+\n+    // Add the start node.\n+    outerBlock.addChildToBack(originalParent.removeChildAfter(outerBlock));\n+    // Add the inner block\n+    outerBlock.addChildToBack(innerBlock);\n+    // and finally the end node.\n+    outerBlock.addChildToBack(originalParent.removeChildAfter(outerBlock));\n+\n+    compiler.reportCodeChange();\n+  }\n+\n+  /**\n+   * Move the Nodes between start and end from the source block to the\n+   * destination block. If start is null, move the first child of the block.\n+   * If end is null, move the last child of the block.\n+   */\n+  private void moveSiblingExclusive(\n+      Node src, Node dest, @Nullable Node start, @Nullable Node end) {\n+    while (childAfter(src, start) != end) {\n+      Node child = removeChildAfter(src, start);\n+      dest.addChildToBack(child);\n+    }\n+  }\n+\n+  /**\n+   * Like Node.getNext, that null is used to signal the child before the\n+   * block.\n+   */\n+  private Node childAfter(Node parent, @Nullable Node siblingBefore) {\n+    if (siblingBefore == null) {\n+      return parent.getFirstChild();\n+    } else {\n+      return siblingBefore.getNext();\n+    }\n+  }\n+\n+  /**\n+   * Like removeChildAfter, the firstChild is removed\n+   */\n+  private Node removeChildAfter(Node parent, @Nullable Node siblingBefore) {\n+    if (siblingBefore == null) {\n+      return parent.removeFirstChild();\n+    } else {\n+      return parent.removeChildAfter(siblingBefore);\n     }\n   }\n \n   private class Callback extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.NAME || parent.getType() != Token.CALL) {\n-        return;\n-      }\n-\n-      if (startMarkerName.equals(n.getString())) {\n-        // Record information needed for insertion of a synthetic block or\n-        // warning about an unmatched start marker.\n-        Node ancestorBlockChild = n;\n-        Node ancestorBlock = null;\n-        for (Node ancestor : n.getAncestors()) {\n-          int type = ancestor.getType();\n-          if (type == Token.SCRIPT || type == Token.BLOCK) {\n-            ancestorBlock = ancestor;\n-            break;\n-          }\n-          ancestorBlockChild = ancestor;\n+      if (n.getType() != Token.CALL\n+          || n.getFirstChild().getType() != Token.NAME) {\n+        return;\n+      }\n+\n+      Node callTarget = n.getFirstChild();\n+      String callName = callTarget.getString();\n+\n+      if (startMarkerName.equals(callName)) {\n+        if (parent.getType() != Token.EXPR_RESULT) {\n+          compiler.report(\n+              t.makeError(n, INVALID_MARKER_USAGE, startMarkerName));\n+          return;\n         }\n-\n-        startMarkerStack.push(new StartMarker(t.getSourceName(), n,\n-            ancestorBlockChild, ancestorBlock));\n-      }\n-\n-      if (!endMarkerName.equals(n.getString())) {\n-        return;\n-      }\n-\n-      if (startMarkerStack.isEmpty()) {\n+        markerStack.push(parent);\n+        return;\n+      }\n+\n+      if (!endMarkerName.equals(callName)) {\n+        return;\n+      }\n+\n+      Node endMarkerNode = parent;\n+      if (endMarkerNode.getType() != Token.EXPR_RESULT) {\n+        compiler.report(\n+            t.makeError(n, INVALID_MARKER_USAGE, endMarkerName));\n+        return;\n+      }\n+\n+      if (markerStack.isEmpty()) {\n         compiler.report(t.makeError(n, UNMATCHED_END_MARKER,\n             startMarkerName, endMarkerName));\n         return;\n       }\n \n-      StartMarker startMarker = startMarkerStack.pop();\n-\n-      Node endMarkerAncestorBlockChild = n;\n-      for (Node ancestor : n.getAncestors()) {\n-        int type = ancestor.getType();\n-        if (type == Token.SCRIPT || type == Token.BLOCK) {\n-          if (ancestor != startMarker.ancestorBlock) {\n-            // The end marker isn't in the same block as the start marker.\n-            compiler.report(t.makeError(n, UNMATCHED_END_MARKER,\n-                startMarkerName, endMarkerName));\n-            return;\n-          }\n-          break;\n-        }\n-        endMarkerAncestorBlockChild = ancestor;\n-      }\n-\n-      Node block = new Node(Token.BLOCK);\n-      block.setIsSyntheticBlock(true);\n-      startMarker.ancestorBlock.addChildAfter(block,\n-          startMarker.ancestorBlockChild);\n-      Node removedNode = null;\n-      do {\n-        // Move the nodes into the synthetic block.\n-        removedNode = startMarker.ancestorBlock.removeChildAfter(block);\n-        block.addChildToBack(removedNode);\n-      } while (removedNode != endMarkerAncestorBlockChild);\n-\n-      compiler.reportCodeChange();\n+      Node startMarkerNode = markerStack.pop();\n+      if (endMarkerNode.getParent() != startMarkerNode.getParent()) {\n+        // The end marker isn't in the same block as the start marker.\n+        compiler.report(t.makeError(n, UNMATCHED_END_MARKER,\n+            startMarkerName, endMarkerName));\n+        return;\n+      }\n+\n+      // This is a valid marker set add it to the list of markers to process.\n+      validMarkers.add(new Marker(startMarkerNode, endMarkerNode));\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/ant/CompileTask.java\n+++ b/src/com/google/javascript/jscomp/ant/CompileTask.java\n     Result result = compiler.compile(externs, sources, options);\n     if (result.success) {\n       writeResult(compiler.toSource());\n-    } else {\n-      throw new BuildException(\"Compilation failed.\");\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n  * Tests for {@link CreateSyntheticBlocks}\n  *\n  *\n+ * @author johnlenz@google.com (John Lenz)\n  */\n public class CreateSyntheticBlocksTest extends CompilerTestCase {\n   private static final String START_MARKER = \"startMarker\";\n             externs, js);\n         NodeTraversal.traverse(compiler, js, new MinimizeExitPoints(compiler));\n \n-        new PeepholeOptimizationsPass(compiler, new\n-            PeepholeRemoveDeadCode()).process(externs, js);\n+        new PeepholeOptimizationsPass(compiler,\n+            new PeepholeRemoveDeadCode(),\n+            new PeepholeSubstituteAlternateSyntax(),\n+            new PeepholeFoldConstants())\n+            .process(externs, js);\n+        new MinimizeExitPoints(compiler).process(externs, js);\n \n         new Denormalize(compiler).process(externs, js);\n       }\n     return 1;\n   }\n \n+  // TODO(johnlenz): Add tests to the IntegrationTest.\n+\n   public void testFold1() {\n     test(\"function() { if (x) return; y(); }\",\n-         \"function(){if(!x)y()}\");\n+         \"function(){x||y()}\");\n   }\n \n   public void testFoldWithMarkers1() {\n     testSame(\"function(){startMarker();if(x)return;endMarker();y()}\");\n   }\n \n+  public void testFoldWithMarkers1a() {\n+    testSame(\"function(){startMarker();if(x)return;endMarker()}\");\n+  }\n+\n   public void testFold2() {\n     test(\"function() { if (x) return; y(); if (a) return; b(); }\",\n-         \"function(){if(!x){y();if(!a)b()}}\");\n+         \"function(){if(!x){y();a||b()}}\");\n   }\n \n   public void testFoldWithMarkers2() {\n          CreateSyntheticBlocks.UNMATCHED_END_MARKER);\n   }\n \n+  public void testInvalid1() {\n+    test(\"startMarker() && true\",\n+        \"startMarker()&&1\", null,\n+         CreateSyntheticBlocks.INVALID_MARKER_USAGE);\n+  }\n+\n+  public void testInvalid2() {\n+    test(\"false && endMarker()\",\n+        \"\", null,\n+         CreateSyntheticBlocks.INVALID_MARKER_USAGE);\n+  }\n+\n+\n   public void testDenormalize() {\n     testSame(\"startMarker();for(;;);endMarker()\");\n   }", "timestamp": 1282172527, "metainfo": ""}