{"sha": "4c84e204cbce349f3c5722750561b91607d3fcae", "log": "CODEC-222 Fluent interface for HmacUtils Initial implementation  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/digest/HmacUtils.java\n+++ b/src/main/java/org/apache/commons/codec/digest/HmacUtils.java\n \n package org.apache.commons.codec.digest;\n \n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.nio.ByteBuffer;\n import java.security.InvalidKeyException;\n import java.security.Key;\n import java.security.NoSuchAlgorithmException;\n import javax.crypto.Mac;\n import javax.crypto.spec.SecretKeySpec;\n \n+import org.apache.commons.codec.binary.Hex;\n import org.apache.commons.codec.binary.StringUtils;\n \n /**\n  * Simplifies common {@link javax.crypto.Mac} tasks. This class is immutable and thread-safe.\n- *\n+ * However the Mac may not be.\n  * <p>\n- * <strong>Note: Not all JCE implementations supports all algorithms. If not supported, an IllegalArgumentException is\n+ * <strong>Note: Not all JCE implementations support all algorithms. If not supported, an IllegalArgumentException is\n  * thrown.</strong>\n- * </p>\n- *\n+ * <p>\n+ * Sample usage:\n+ * <pre>\n+ * byte[] key = {1,2,3,4}; // don't use this!\n+ * String valueToDigest = \"The quick brown fox jumps over the lazy dog\";\n+ * byte[] hmac = HmacUtils.use(HmacAlgorithms.HMAC_SHA_224).key(key).update(valueToDigest).doFinal();\n+ * // Mac re-use\n+ * HmacUtils hm1 = HmacUtils.use(HmacAlgorithms.HMAC_SHA_1).key(key);\n+ * String hexPom = hm1.update(new File(\"pom.xml\")).doFinalHex();\n+ * String hexNot = hm1.update(new File(\"NOTICE.txt\")).doFinalHex();\n+ * // Mac key update\n+ * String algo = \"HmacNew\";\n+ * HmacUtils hm2 = HmacUtils.use(algo).key(key);\n+ * byte[] key2 = {1,2,3,4,5}; // don't use this either!\n+ * String hexPom2 = hm2.update(new File(\"pom.xml\")).doFinalHex();\n+ * String hexNot2 = hm2.key(key2).update(new File(\"NOTICE.txt\")).doFinalHex();\n+ * </pre>\n  * @since 1.10\n  * @version $Id$\n  */\n         mac.update(StringUtils.getBytesUtf8(valueToDigest));\n         return mac;\n     }\n+\n+    HmacUtils() { // TODO why does test code try to instantiate this?\n+        this(null);\n+    }\n+\n+    // Fluent interface\n+\n+    private final Mac mac;\n+\n+    private HmacUtils(final Mac mac) {\n+        this.mac = mac;\n+    }\n+\n+\n+    /**\n+     * Creates an instance using the provided {@link Mac}\n+     * If necessary, the\n+     * key must be provided using the {@link #key(byte[])} method\n+     * before it can be used further.\n+     *\n+     * @param algorithm to be used.\n+     * @return the instance\n+     * @since 1.11\n+     */\n+    public static HmacUtils use(final Mac mac) {\n+        return new HmacUtils(mac);\n+    }\n+\n+    /**\n+     * Creates an instance using the provided algorithm type.\n+     * The key must be provided using the {@link #key(byte[])} method\n+     * before it can be used further.\n+     *\n+     * @param algorithm to be used.\n+     * @return the instance\n+     * @since 1.11\n+     */\n+    public static HmacUtils use(final String algorithm) {\n+        try {\n+            return new HmacUtils(Mac.getInstance(algorithm));\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates an instance using the provided algorithm type.\n+     * The key must be provided using the {@link #key(byte[])} method\n+     * before it can be used further.\n+     *\n+     * @param algorithm to be used.\n+     * @return the instance\n+     * @since 1.11\n+     */\n+    public static HmacUtils use(final HmacAlgorithms algorithm) {\n+        return use(algorithm.getName());\n+    }\n+\n+    /**\n+     * Updates the stored {@link Mac} with the new key.\n+     * This resets the Mac ready for re-use.\n+     *\n+     * @param key the new key\n+     * @return this instance\n+     * @since 1.11\n+     */\n+    public HmacUtils key(byte[] key) {\n+        final SecretKeySpec keySpec = new SecretKeySpec(key, mac.getAlgorithm());\n+        try {\n+            mac.init(keySpec);\n+        } catch (InvalidKeyException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Updates the stored {@link Mac} with the value.\n+     *\n+     * @param valueToDigest\n+     *            the value to update the {@link Mac} with (maybe null or empty)\n+     * @return the updated instance\n+     * @throws IllegalStateException\n+     *             if the Mac was not initialized\n+     * @since 1.11\n+     */\n+    public HmacUtils update(final byte[] valueToDigest) {\n+        mac.update(valueToDigest);\n+        return this;\n+    }\n+    \n+    /**\n+     * Updates the stored {@link Mac} with the value.\n+     *\n+     * @param valueToDigest\n+     *            the value to update the {@link Mac} with (maybe null or empty)\n+     * @return the updated instance\n+     * @throws IllegalStateException\n+     *             if the Mac was not initialized\n+     * @since 1.11\n+     */\n+    public HmacUtils update(final ByteBuffer valueToDigest) {\n+        mac.update(valueToDigest);\n+        return this;\n+    }\n+    \n+    /**\n+     * Updates the stored {@link Mac} with the value.\n+     * String is converted to bytes using the UTF-8 charset.\n+     * @param valueToDigest\n+     *            the value to update the {@link Mac} with.\n+     * @return the updated instance\n+     * @throws IllegalStateException\n+     *             if the Mac was not initialized\n+     * @since 1.11\n+     */\n+    public HmacUtils update(final String valueToDigest) {\n+        mac.update(StringUtils.getBytesUtf8(valueToDigest));\n+        return this;\n+    }\n+    \n+    /**\n+     * Updates the stored {@link Mac} with the value.\n+     *\n+     * @param valueToDigest\n+     *            the value to update the {@link Mac} with\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return the updated instance\n+     * @throws IOException\n+     *             If an I/O error occurs.\n+     * @throws IllegalStateException\n+     *             If the Mac was not initialized\n+     * @since 1.11\n+     */\n+    public HmacUtils update(final InputStream valueToDigest) throws IOException {\n+        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n+        int read;\n+\n+        while ((read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH) ) > -1) {\n+            mac.update(buffer, 0, read);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Updates the stored {@link Mac} with the value.\n+     *\n+     * @param valueToDigest\n+     *            the value to update the {@link Mac} with\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return the updated instance\n+     * @throws IOException\n+     *             If an I/O error occurs.\n+     * @throws IllegalStateException\n+     *             If the Mac was not initialized\n+     * @since 1.11\n+     */\n+    public HmacUtils update(final File valueToDigest) throws IOException {\n+        final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(valueToDigest));\n+        try {\n+            return update(stream);\n+        } finally {\n+            stream.close();\n+        }\n+    }\n+\n+    /**\n+     * Finishes the MAC operation and returns the result.\n+     * The Mac can be re-used to produce further results from the same key.\n+     * Or the key can be reset and the Mac reused.\n+     *\n+     * @return the result as a byte array\n+     * @since 1.11\n+     */\n+    public byte[] doFinal() {\n+        return mac.doFinal();\n+    }\n+\n+    /**\n+     * Finishes the MAC operation and returns the result.\n+     * The Mac can be re-used to produce further results from the same key.\n+     * Or the key can be reset and the Mac reused.\n+     *\n+     * @return the result as a Hex String\n+     * @since 1.11\n+     */\n+    public String doFinalHex() {\n+        return Hex.encodeHexString(mac.doFinal());\n+    }\n+\n }", "timestamp": 1463657600, "metainfo": ""}