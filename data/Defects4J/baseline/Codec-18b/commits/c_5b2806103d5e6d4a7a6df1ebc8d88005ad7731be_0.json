{"sha": "5b2806103d5e6d4a7a6df1ebc8d88005ad7731be", "log": "[CODEC-192] Add Daitch\u2013Mokotoff Soundex.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.language;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * Encodes a string into a Daitch-Mokotoff Soundex value.\n+ * <p>\n+ * The Daitch-Mokotoff Soundex algorithm is a refinement of the Russel and American Soundex algorithms, yielding greater\n+ * accuracy in matching especially Slavish and Yiddish surnames with similar pronunciation but differences in spelling.\n+ * <p>\n+ * The main differences compared to the other soundex variants are:\n+ * <ul>\n+ * <li>coded names are 6 digits long\n+ * <li>the initial character of the name is coded\n+ * <li>rules to encoded multi-character n-grams\n+ * <li>multiple possible encodings for the same name (branching)\n+ * </ul>\n+ * <p>\n+ * This implementation supports branching, depending on the used method:\n+ * <ul>\n+ * <li>{@link #encode(String)} - branching disabled, only the first code will be returned\n+ * <li>{@link #soundex(String)} - branching enabled, all codes will be returned, separated by '|'\n+ * </ul>\n+ * <p>\n+ * Note: this implementation has additional branching rules compared to the original description of the algorithm. The\n+ * rules can be customized by overriding the default rules contained in the resource file\n+ * {@code org/apache/commons/codec/language/dmrules.txt}.\n+ * <p>\n+ * This class is thread-safe.\n+ *\n+ * @see Soundex\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Daitch%E2%80%93Mokotoff_Soundex\"> Wikipedia - Daitch-Mokotoff Soundex</a>\n+ * @see <a href=\"http://www.avotaynu.com/soundex.htm\">Avotaynu - Soundexing and Genealogy</a>\n+ *\n+ * @version $Id$\n+ * @since 1.10\n+ */\n+public class DaitchMokotoffSoundex implements StringEncoder {\n+\n+    /**\n+     * Inner class representing a branch during DM soundex encoding.\n+     */\n+    private static final class Branch {\n+        private final StringBuilder builder;\n+        private String cachedString;\n+        private String lastReplacement;\n+\n+        private Branch() {\n+            builder = new StringBuilder();\n+            lastReplacement = null;\n+            cachedString = null;\n+        }\n+\n+        /**\n+         * Creates a new branch, identical to this branch.\n+         *\n+         * @return a new, identical branch\n+         */\n+        public Branch createBranch() {\n+            final Branch branch = new Branch();\n+            branch.builder.append(toString());\n+            branch.lastReplacement = this.lastReplacement;\n+            return branch;\n+        }\n+\n+        @Override\n+        public boolean equals(final Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (!(other instanceof Branch)) {\n+                return false;\n+            }\n+\n+            return toString().equals(((Branch) other).toString());\n+        }\n+\n+        /**\n+         * Finish this branch by appending '0's until the maximum code length has been reached.\n+         */\n+        public void finish() {\n+            while (builder.length() < MAX_LENGTH) {\n+                builder.append('0');\n+                cachedString = null;\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return toString().hashCode();\n+        }\n+\n+        /**\n+         * Process the next replacement to be added to this branch.\n+         *\n+         * @param replacement\n+         *            the next replacement to append\n+         * @param forceAppend\n+         *            indicates if the default processing shall be overridden\n+         */\n+        public void processNextReplacement(final String replacement, final boolean forceAppend) {\n+            final boolean append = lastReplacement == null || !lastReplacement.endsWith(replacement) || forceAppend;\n+\n+            if (append && builder.length() < MAX_LENGTH) {\n+                builder.append(replacement);\n+                // remove all characters after the maximum length\n+                if (builder.length() > MAX_LENGTH) {\n+                    builder.delete(MAX_LENGTH, builder.length());\n+                }\n+                cachedString = null;\n+            }\n+\n+            lastReplacement = replacement;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (cachedString == null) {\n+                cachedString = builder.toString();\n+            }\n+            return cachedString;\n+        }\n+    }\n+\n+    // static identifiers used during parsing of the rule file\n+\n+    /**\n+     * Inner class for storing rules.\n+     */\n+    private static final class Rule {\n+        private final String pattern;\n+        private final String[] replacementAtStart;\n+        private final String[] replacementBeforeVowel;\n+        private final String[] replacementDefault;\n+\n+        protected Rule(final String pattern, final String replacementAtStart, final String replacementBeforeVowel,\n+                final String replacementDefault) {\n+            this.pattern = pattern;\n+            this.replacementAtStart = replacementAtStart.split(\"\\\\|\");\n+            this.replacementBeforeVowel = replacementBeforeVowel.split(\"\\\\|\");\n+            this.replacementDefault = replacementDefault.split(\"\\\\|\");\n+        }\n+\n+        public int getPatternLength() {\n+            return pattern.length();\n+        }\n+\n+        public String[] getReplacements(final String context, final boolean atStart) {\n+            if (atStart) {\n+                return replacementAtStart;\n+            }\n+\n+            final int nextIndex = getPatternLength();\n+            final boolean nextCharIsVowel = nextIndex < context.length() ? isVowel(context.charAt(nextIndex)) : false;\n+            if (nextCharIsVowel) {\n+                return replacementBeforeVowel;\n+            }\n+\n+            return replacementDefault;\n+        }\n+\n+        private boolean isVowel(final char ch) {\n+            return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';\n+        }\n+\n+        public boolean matches(final String context) {\n+            return context.startsWith(pattern);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s=(%s,%s,%s)\", pattern, Arrays.asList(replacementAtStart),\n+                    Arrays.asList(replacementBeforeVowel), Arrays.asList(replacementDefault));\n+        }\n+    }\n+\n+    private static final String COMMENT = \"//\";\n+    private static final String DOUBLE_QUOTE = \"\\\"\";\n+    /** Folding rules. */\n+    private static final Map<Character, Character> FOLDINGS = new HashMap<Character, Character>();\n+\n+    /** The code length of a DM soundex value. */\n+    private static final int MAX_LENGTH = 6;\n+    private static final String MULTILINE_COMMENT_END = \"*/\";\n+\n+    private static final String MULTILINE_COMMENT_START = \"/*\";\n+\n+    /** The resource file containing the replacement and folding rules */\n+    private static final String RESOURCE_FILE = \"org/apache/commons/codec/language/dmrules.txt\";\n+\n+    /** Transformation rules indexed by the first character of their pattern. */\n+    private static final Map<Character, List<Rule>> RULES = new HashMap<Character, List<Rule>>();\n+\n+    static {\n+        final InputStream rulesIS = DaitchMokotoffSoundex.class.getClassLoader().getResourceAsStream(RESOURCE_FILE);\n+        if (rulesIS == null) {\n+            throw new IllegalArgumentException(\"Unable to load resource: \" + RESOURCE_FILE);\n+        }\n+\n+        final Scanner scanner = new Scanner(rulesIS, CharEncoding.UTF_8);\n+        parseRules(scanner, RESOURCE_FILE, RULES, FOLDINGS);\n+        scanner.close();\n+\n+        // sort RULES by pattern length in descending order\n+        for (final Map.Entry<Character, List<Rule>> rule : RULES.entrySet()) {\n+            final List<Rule> ruleList = rule.getValue();\n+            Collections.sort(ruleList, new Comparator<Rule>() {\n+                @Override\n+                public int compare(final Rule rule1, final Rule rule2) {\n+                    return rule2.getPatternLength() - rule1.getPatternLength();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void parseRules(final Scanner scanner, final String location,\n+            final Map<Character, List<Rule>> ruleMapping, final Map<Character, Character> asciiFoldings) {\n+        int currentLine = 0;\n+        boolean inMultilineComment = false;\n+\n+        while (scanner.hasNextLine()) {\n+            currentLine++;\n+            final String rawLine = scanner.nextLine();\n+            String line = rawLine;\n+\n+            if (inMultilineComment) {\n+                if (line.endsWith(MULTILINE_COMMENT_END)) {\n+                    inMultilineComment = false;\n+                }\n+                continue;\n+            }\n+\n+            if (line.startsWith(MULTILINE_COMMENT_START)) {\n+                inMultilineComment = true;\n+            } else {\n+                // discard comments\n+                final int cmtI = line.indexOf(COMMENT);\n+                if (cmtI >= 0) {\n+                    line = line.substring(0, cmtI);\n+                }\n+\n+                // trim leading-trailing whitespace\n+                line = line.trim();\n+\n+                if (line.length() == 0) {\n+                    continue; // empty lines can be safely skipped\n+                }\n+\n+                if (line.contains(\"=\")) {\n+                    // folding\n+                    final String[] parts = line.split(\"=\");\n+                    if (parts.length != 2) {\n+                        throw new IllegalArgumentException(\"Malformed folding statement split into \" + parts.length +\n+                                \" parts: \" + rawLine + \" in \" + location);\n+                    } else {\n+                        final String leftCharacter = parts[0];\n+                        final String rightCharacter = parts[1];\n+\n+                        if (leftCharacter.length() != 1 || rightCharacter.length() != 1) {\n+                            throw new IllegalArgumentException(\"Malformed folding statement - \" +\n+                                    \"patterns are not single characters: \" + rawLine + \" in \" + location);\n+                        }\n+\n+                        asciiFoldings.put(leftCharacter.charAt(0), rightCharacter.charAt(0));\n+                    }\n+                } else {\n+                    // rule\n+                    final String[] parts = line.split(\"\\\\s+\");\n+                    if (parts.length != 4) {\n+                        throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length +\n+                                \" parts: \" + rawLine + \" in \" + location);\n+                    } else {\n+                        try {\n+                            final String pattern = stripQuotes(parts[0]);\n+                            final String replacement1 = stripQuotes(parts[1]);\n+                            final String replacement2 = stripQuotes(parts[2]);\n+                            final String replacement3 = stripQuotes(parts[3]);\n+\n+                            final Rule r = new Rule(pattern, replacement1, replacement2, replacement3);\n+                            final char patternKey = r.pattern.charAt(0);\n+                            List<Rule> rules = ruleMapping.get(patternKey);\n+                            if (rules == null) {\n+                                rules = new ArrayList<Rule>();\n+                                ruleMapping.put(patternKey, rules);\n+                            }\n+                            rules.add(r);\n+                        } catch (final IllegalArgumentException e) {\n+                            throw new IllegalStateException(\n+                                    \"Problem parsing line '\" + currentLine + \"' in \" + location, e);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static String stripQuotes(String str) {\n+        if (str.startsWith(DOUBLE_QUOTE)) {\n+            str = str.substring(1);\n+        }\n+\n+        if (str.endsWith(DOUBLE_QUOTE)) {\n+            str = str.substring(0, str.length() - 1);\n+        }\n+\n+        return str;\n+    }\n+\n+    /** Whether to use ascii folding prior to encoding. */\n+    private final boolean folding;\n+\n+    /**\n+     * Creates a new instance with ascii-folding enabled.\n+     */\n+    public DaitchMokotoffSoundex() {\n+        this(true);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     * <p>\n+     * With ascii-folding enabled, certain accented characters will be transformed to equivalent ascii characters, e.g.\n+     * \u00e8 -&gt; e.\n+     *\n+     * @param folding\n+     *            if ascii-folding shall be performed before encoding\n+     */\n+    public DaitchMokotoffSoundex(final boolean folding) {\n+        this.folding = folding;\n+    }\n+\n+    /**\n+     * Performs a cleanup of the input string before the actual soundex transformation.\n+     * <p>\n+     * Removes all whitespace characters and performs ascii folding if enabled.\n+     *\n+     * @param input\n+     *            the input string to cleanup\n+     * @return a cleaned up string\n+     */\n+    private String cleanup(final String input) {\n+        final StringBuilder sb = new StringBuilder();\n+        for (char ch : input.toCharArray()) {\n+            if (Character.isWhitespace(ch)) {\n+                continue;\n+            }\n+\n+            ch = Character.toLowerCase(ch);\n+            if (folding && FOLDINGS.containsKey(ch)) {\n+                ch = FOLDINGS.get(ch);\n+            }\n+            sb.append(ch);\n+        }\n+        return sb.toString();\n+    }\n+\n+    // -- BEGIN STATIC METHODS --//\n+\n+    /**\n+     * Encodes an Object using the Daitch-Mokotoff soundex algorithm without branching.\n+     * <p>\n+     * This method is provided in order to satisfy the requirements of the Encoder interface, and will throw an\n+     * EncoderException if the supplied object is not of type java.lang.String.\n+     *\n+     * @see #soundex(String)\n+     *\n+     * @param obj\n+     *            Object to encode\n+     * @return An object (of type java.lang.String) containing the DM soundex code, which corresponds to the String\n+     *         supplied.\n+     * @throws EncoderException\n+     *             if the parameter supplied is not of type java.lang.String\n+     * @throws IllegalArgumentException\n+     *             if a character is not mapped\n+     */\n+    @Override\n+    public Object encode(final Object obj) throws EncoderException {\n+        if (!(obj instanceof String)) {\n+            throw new EncoderException(\n+                    \"Parameter supplied to DaitchMokotoffSoundex encode is not of type java.lang.String\");\n+        }\n+        return encode((String) obj);\n+    }\n+\n+    /**\n+     * Encodes a String using the Daitch-Mokotoff soundex algorithm without branching.\n+     *\n+     * @see #soundex(String)\n+     *\n+     * @param str\n+     *            A String object to encode\n+     * @return A DM Soundex code corresponding to the String supplied\n+     * @throws IllegalArgumentException\n+     *             if a character is not mapped\n+     */\n+    @Override\n+    public String encode(final String source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        return soundex(source, false)[0];\n+    }\n+\n+    // -- BEGIN INNER CLASSES --//\n+\n+    /**\n+     * Encodes a String using the Daitch-Mokotoff soundex algorithm with branching.\n+     * <p>\n+     * In case a string is encoded into multiple codes (see branching rules), the result will contain all codes,\n+     * separated by '|'.\n+     * <p>\n+     * Example: the name \"AUERBACH\" is encoded as both\n+     * <ul>\n+     * <li>097400</li>\n+     * <li>097500</li>\n+     * </ul>\n+     * Thus the result will be \"097400|097500\".\n+     *\n+     * @param str\n+     *            A String object to encode\n+     * @return A string containing a set of DM Soundex codes corresponding to the String supplied\n+     * @throws IllegalArgumentException\n+     *             if a character is not mapped\n+     */\n+    public String soundex(final String source) {\n+        final String[] branches = soundex(source, true);\n+        final StringBuilder sb = new StringBuilder();\n+        int index = 0;\n+        for (final String branch : branches) {\n+            sb.append(branch);\n+            if (++index < branches.length) {\n+                sb.append('|');\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Perform the actual DM soundex algorithm on the input string.\n+     *\n+     * @param source\n+     *            A String object to encode\n+     * @param branching\n+     *            If branching shall be performed\n+     * @return A string array containing all DM Soundex codes corresponding to the String supplied depending on the\n+     *         selected branching mode\n+     */\n+    private String[] soundex(final String source, final boolean branching) {\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        final String input = cleanup(source);\n+\n+        final Set<Branch> currentBranches = new LinkedHashSet<Branch>();\n+        currentBranches.add(new Branch());\n+\n+        char lastChar = '\\0';\n+        for (int index = 0; index < input.length(); index++) {\n+            final char ch = input.charAt(index);\n+\n+            // ignore whitespace inside a name\n+            if (Character.isWhitespace(ch)) {\n+                continue;\n+            }\n+\n+            final String inputContext = input.substring(index);\n+            final List<Rule> rules = RULES.get(ch);\n+            if (rules == null) {\n+                continue;\n+            }\n+\n+            // use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access\n+            @SuppressWarnings(\"unchecked\")\n+            final List<Branch> nextBranches = branching ? new ArrayList<Branch>() : Collections.EMPTY_LIST;\n+\n+            for (final Rule rule : rules) {\n+                if (rule.matches(inputContext)) {\n+                    if (branching) {\n+                        nextBranches.clear();\n+                    }\n+                    final String[] replacements = rule.getReplacements(inputContext, lastChar == '\\0');\n+                    final boolean branchingRequired = replacements.length > 1 && branching;\n+\n+                    for (final Branch branch : currentBranches) {\n+                        for (final String nextReplacement : replacements) {\n+                            // if we have multiple replacements, always create a new branch\n+                            final Branch nextBranch = branchingRequired ? branch.createBranch() : branch;\n+\n+                            // special rule: occurrences of mn or nm are treated differently\n+                            final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm');\n+\n+                            nextBranch.processNextReplacement(nextReplacement, force);\n+\n+                            if (branching) {\n+                                nextBranches.add(nextBranch);\n+                            } else {\n+                                break;\n+                            }\n+                        }\n+                    }\n+\n+                    if (branching) {\n+                        currentBranches.clear();\n+                        currentBranches.addAll(nextBranches);\n+                    }\n+                    index += rule.getPatternLength() - 1;\n+                    break;\n+                }\n+            }\n+\n+            lastChar = ch;\n+        }\n+\n+        final String[] result = new String[currentBranches.size()];\n+        int index = 0;\n+        for (final Branch branch : currentBranches) {\n+            branch.finish();\n+            result[index++] = branch.toString();\n+        }\n+\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/DaitchMokotoffSoundexTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.language;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Tests {@link DaitchMokotoffSoundex}.\n+ * <p>\n+ * Keep this file in UTF-8 encoding for proper Javadoc processing.\n+ * </p>\n+ *\n+ * @since 1.10\n+ */\n+public class DaitchMokotoffSoundexTest extends StringEncoderAbstractTest<DaitchMokotoffSoundex> {\n+\n+    @Override\n+    protected DaitchMokotoffSoundex createStringEncoder() {\n+        return new DaitchMokotoffSoundex();\n+    }\n+\n+    @Test\n+    public void testAccentedCharacterFolding() {\n+        Assert.assertEquals(\"294795\", this.getStringEncoder().soundex(\"Stra\u00dfburg\"));\n+        Assert.assertEquals(\"294795\", this.getStringEncoder().soundex(\"Strasburg\"));\n+\n+        Assert.assertEquals(\"095600\", this.getStringEncoder().soundex(\"\u00c9regon\"));\n+        Assert.assertEquals(\"095600\", this.getStringEncoder().soundex(\"Eregon\"));\n+    }\n+\n+    @Test\n+    public void testAdjacentCodes() {\n+        // AKSSOL\n+        // A-KS-S-O-L\n+        // 0-54-4---8 -> wrong\n+        // 0-54-----8 -> correct\n+        Assert.assertEquals(\"054800\", this.getStringEncoder().soundex(\"AKSSOL\"));\n+\n+        // GERSCHFELD\n+        // G-E-RS-CH-F-E-L-D\n+        // 5--4/94-5/4-7-8-3 -> wrong\n+        // 5--4/94-5/--7-8-3 -> correct\n+        Assert.assertEquals(\"547830|545783|594783|594578\", this.getStringEncoder().soundex(\"GERSCHFELD\"));\n+    }\n+\n+    public void testEncodeBasic() {\n+        // same as above, but without branching\n+        Assert.assertEquals(\"097400\", this.getStringEncoder().encode(\"AUERBACH\"));\n+        Assert.assertEquals(\"097400\", this.getStringEncoder().encode(\"OHRBACH\"));\n+        Assert.assertEquals(\"874400\", this.getStringEncoder().encode(\"LIPSHITZ\"));\n+        Assert.assertEquals(\"874400\", this.getStringEncoder().encode(\"LIPPSZYC\"));\n+        Assert.assertEquals(\"876450\", this.getStringEncoder().encode(\"LEWINSKY\"));\n+        Assert.assertEquals(\"876450\", this.getStringEncoder().encode(\"LEVINSKI\"));\n+        Assert.assertEquals(\"486740\", this.getStringEncoder().encode(\"SZLAMAWICZ\"));\n+        Assert.assertEquals(\"486740\", this.getStringEncoder().encode(\"SHLAMOVITZ\"));\n+    }\n+\n+    @Test\n+    public void testEncodeIgnoreApostrophes() throws EncoderException {\n+        this.checkEncodingVariations(\"079600\", new String[] { \"OBrien\", \"'OBrien\", \"O'Brien\", \"OB'rien\", \"OBr'ien\",\n+                \"OBri'en\", \"OBrie'n\", \"OBrien'\" });\n+    }\n+\n+    /**\n+     * Test data from http://www.myatt.demon.co.uk/sxalg.htm\n+     *\n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testEncodeIgnoreHyphens() throws EncoderException {\n+        this.checkEncodingVariations(\"565463\", new String[] { \"KINGSMITH\", \"-KINGSMITH\", \"K-INGSMITH\", \"KI-NGSMITH\",\n+                \"KIN-GSMITH\", \"KING-SMITH\", \"KINGS-MITH\", \"KINGSM-ITH\", \"KINGSMI-TH\", \"KINGSMIT-H\", \"KINGSMITH-\" });\n+    }\n+\n+    @Test\n+    public void testEncodeIgnoreTrimmable() {\n+        Assert.assertEquals(\"746536\", this.getStringEncoder().encode(\" \\t\\n\\r Washington \\t\\n\\r \"));\n+        Assert.assertEquals(\"746536\", this.getStringEncoder().encode(\"Washington\"));\n+    }\n+\n+    /**\n+     * Examples from http://www.jewishgen.org/infofiles/soundex.html\n+     */\n+    @Test\n+    public void testSoundexBasic() {\n+        Assert.assertEquals(\"583600\", this.getStringEncoder().soundex(\"GOLDEN\"));\n+        Assert.assertEquals(\"087930\", this.getStringEncoder().soundex(\"Alpert\"));\n+        Assert.assertEquals(\"791900\", this.getStringEncoder().soundex(\"Breuer\"));\n+        Assert.assertEquals(\"579000\", this.getStringEncoder().soundex(\"Haber\"));\n+        Assert.assertEquals(\"665600\", this.getStringEncoder().soundex(\"Mannheim\"));\n+        Assert.assertEquals(\"664000\", this.getStringEncoder().soundex(\"Mintz\"));\n+        Assert.assertEquals(\"370000\", this.getStringEncoder().soundex(\"Topf\"));\n+        Assert.assertEquals(\"586660\", this.getStringEncoder().soundex(\"Kleinmann\"));\n+        Assert.assertEquals(\"769600\", this.getStringEncoder().soundex(\"Ben Aron\"));\n+\n+        Assert.assertEquals(\"097400|097500\", this.getStringEncoder().soundex(\"AUERBACH\"));\n+        Assert.assertEquals(\"097400|097500\", this.getStringEncoder().soundex(\"OHRBACH\"));\n+        Assert.assertEquals(\"874400\", this.getStringEncoder().soundex(\"LIPSHITZ\"));\n+        Assert.assertEquals(\"874400|874500\", this.getStringEncoder().soundex(\"LIPPSZYC\"));\n+        Assert.assertEquals(\"876450\", this.getStringEncoder().soundex(\"LEWINSKY\"));\n+        Assert.assertEquals(\"876450\", this.getStringEncoder().soundex(\"LEVINSKI\"));\n+        Assert.assertEquals(\"486740\", this.getStringEncoder().soundex(\"SZLAMAWICZ\"));\n+        Assert.assertEquals(\"486740\", this.getStringEncoder().soundex(\"SHLAMOVITZ\"));\n+    }\n+\n+    /**\n+     * Examples from http://www.avotaynu.com/soundex.htm\n+     */\n+    @Test\n+    public void testSoundexBasic2() {\n+        Assert.assertEquals(\"467000|567000\", this.getStringEncoder().soundex(\"Ceniow\"));\n+        Assert.assertEquals(\"467000\", this.getStringEncoder().soundex(\"Tsenyuv\"));\n+        Assert.assertEquals(\"587400|587500\", this.getStringEncoder().soundex(\"Holubica\"));\n+        Assert.assertEquals(\"587400\", this.getStringEncoder().soundex(\"Golubitsa\"));\n+        Assert.assertEquals(\"746480|794648\", this.getStringEncoder().soundex(\"Przemysl\"));\n+        Assert.assertEquals(\"746480\", this.getStringEncoder().soundex(\"Pshemeshil\"));\n+        Assert.assertEquals(\"944744|944745|944754|944755|945744|945745|945754|945755\",\n+                this.getStringEncoder().soundex(\"Rosochowaciec\"));\n+        Assert.assertEquals(\"945744\", this.getStringEncoder().soundex(\"Rosokhovatsets\"));\n+    }\n+\n+    /**\n+     * Examples from http://en.wikipedia.org/wiki/Daitch%E2%80%93Mokotoff_Soundex\n+     */\n+    @Test\n+    public void testSoundexBasic3() {\n+        Assert.assertEquals(\"734000|739400\", this.getStringEncoder().soundex(\"Peters\"));\n+        Assert.assertEquals(\"734600|739460\", this.getStringEncoder().soundex(\"Peterson\"));\n+        Assert.assertEquals(\"645740\", this.getStringEncoder().soundex(\"Moskowitz\"));\n+        Assert.assertEquals(\"645740\", this.getStringEncoder().soundex(\"Moskovitz\"));\n+        Assert.assertEquals(\"154600|145460|454600|445460\", this.getStringEncoder().soundex(\"Jackson\"));\n+        Assert.assertEquals(\"154654|154645|154644|145465|145464|454654|454645|454644|445465|445464\", this\n+                .getStringEncoder().soundex(\"Jackson-Jackson\"));\n+    }\n+\n+    @Test\n+    public void testSpecialRomanianCharacters() {\n+        Assert.assertEquals(\"364000|464000\", this.getStringEncoder().soundex(\"\u0163amas\")); // t-cedilla\n+        Assert.assertEquals(\"364000|464000\", this.getStringEncoder().soundex(\"\u021bamas\")); // t-comma\n+    }\n+\n+}", "timestamp": 1415067492, "metainfo": ""}