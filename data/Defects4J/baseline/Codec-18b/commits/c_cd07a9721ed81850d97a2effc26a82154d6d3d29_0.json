{"sha": "cd07a9721ed81850d97a2effc26a82154d6d3d29", "log": "Javadoc 8.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java\n      * <p>\n      * When encoding the line length is 0 (no chunking).\n      * </p>\n-     * @param useHex if <code>true</code> then use Base32 Hex alphabet\n+     * @param useHex if {@code true} then use Base32 Hex alphabet\n      */\n     public Base32(final boolean useHex) {\n         this(0, null, useHex, PAD_DEFAULT);\n      * <p>\n      * When encoding the line length is 0 (no chunking).\n      * </p>\n-     * @param useHex if <code>true</code> then use Base32 Hex alphabet\n+     * @param useHex if {@code true} then use Base32 Hex alphabet\n      * @param pad byte used as padding byte.\n      */\n     public Base32(final boolean useHex, final byte pad) {\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n      * @param useHex\n-     *            if <code>true</code>, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n+     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n      * @throws IllegalArgumentException\n      *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n      *             lineLength &gt; 0 and lineSeparator is null.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n      * @param useHex\n-     *            if <code>true</code>, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n+     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n      * @param pad byte used as padding byte.\n      * @throws IllegalArgumentException\n      *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n     }\n \n     /**\n-     * Returns whether or not the <code>octet</code> is in the Base32 alphabet.\n+     * Returns whether or not the {@code octet} is in the Base32 alphabet.\n      *\n      * @param octet\n      *            The value to test\n-     * @return <code>true</code> if the value is defined in the the Base32 alphabet <code>false</code> otherwise.\n+     * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.\n      */\n     @Override\n     public boolean isInAlphabet(final byte octet) {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/digest/HmacAlgorithms.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.digest;\n+\n+/**\n+ * Standard {@link HmacSHA512} algorithm names from the <cite>Java Cryptography Architecture Standard Algorithm Name\n+ * Documentation</cite>.\n+ *\n+ * <p>\n+ * <strong>Note: Not all JCE implementations supports all algorithms in this enum.</strong>\n+ * </p>\n+ *\n+ * @see <a href=\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/StandardNames.html\">Java Cryptography\n+ *      Architecture Standard Algorithm Name Documentation</a>\n+ * @since 1.10\n+ * @version $Id$\n+ */\n+public enum HmacAlgorithms {\n+\n+    /**\n+     * The HmacMD5 Message Authentication Code (MAC) algorithm specified in RFC 2104 and RFC 1321.\n+     * <p>\n+     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n+     * </p>\n+     */\n+    HMAC_MD5(\"HmacMD5\"),\n+\n+    /**\n+     * The HmacSHA1 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.\n+     * <p>\n+     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n+     * </p>\n+     */\n+    HMAC_SHA_1(\"HmacSHA1\"),\n+\n+    /**\n+     * The HmacSHA256 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.\n+     * <p>\n+     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n+     * </p>\n+     */\n+    HMAC_SHA_256(\"HmacSHA256\"),\n+\n+    /**\n+     * The HmacSHA384 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.\n+     * <p>\n+     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n+     * </p>\n+     */\n+    HMAC_SHA_384(\"HmacSHA384\"),\n+\n+    /**\n+     * The HmacSHA512 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.\n+     * <p>\n+     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n+     * </p>\n+     */\n+    HMAC_SHA_512(\"HmacSHA512\");\n+\n+    private final String algorithm;\n+\n+    private HmacAlgorithms(final String algorithm) {\n+        this.algorithm = algorithm;\n+    }\n+\n+    /**\n+     * The algorithm name\n+     *\n+     * @see <a\n+     *      href=\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunJCEProvider\">Java\n+     *      Cryptography Architecture Sun Providers Documentation</a>\n+     * @return The algorithm name (\"HmacSHA512\" for example)\n+     */\n+    @Override\n+    public String toString() {\n+        return algorithm;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/digest/HmacUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.digest;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.codec.binary.StringUtils;\n+\n+/**\n+ * Simplifies common {@link javax.crypto.Mac} tasks. This class is immutable and thread-safe.\n+ *\n+ *\n+ * <p>\n+ * <strong>Note: Not all JCE implementations supports all algorithms. If not supported, an IllegalArgumentException is\n+ * thrown.</strong>\n+ * </p>\n+ *\n+ * @since 1.10\n+ * @version $Id$\n+ */\n+public final class HmacUtils {\n+\n+    private static final int STREAM_BUFFER_LENGTH = 1024;\n+\n+    /**\n+     * Returns an initialized <code>Mac</code> for the HmacMD5 algorithm.\n+     * <p>\n+     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n+     * </p>\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @return A Mac instance initialized with the given key.\n+     * @see Mac#getInstance(String)\n+     * @see Mac#init(SecretKeySpec)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static Mac getHmacMd5(final byte[] key) {\n+        return getInitializedMac(HmacAlgorithms.HMAC_MD5, key);\n+    }\n+\n+    /**\n+     * Returns an initialized <code>Mac</code> for the HmacSHA1 algorithm.\n+     * <p>\n+     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n+     * </p>\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @return A Mac instance initialized with the given key.\n+     * @see Mac#getInstance(String)\n+     * @see Mac#init(SecretKeySpec)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static Mac getHmacSha1(final byte[] key) {\n+        return getInitializedMac(HmacAlgorithms.HMAC_SHA_1, key);\n+    }\n+\n+    /**\n+     * Returns an initialized <code>Mac</code> for the HmacSHA256 algorithm.\n+     * <p>\n+     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n+     * </p>\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @return A Mac instance initialized with the given key.\n+     * @see Mac#getInstance(String)\n+     * @see Mac#init(SecretKeySpec)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static Mac getHmacSha256(final byte[] key) {\n+        return getInitializedMac(HmacAlgorithms.HMAC_SHA_256, key);\n+    }\n+\n+    /**\n+     * Returns an initialized <code>Mac</code> for the HmacSHA384 algorithm.\n+     * <p>\n+     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n+     * </p>\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @return A Mac instance initialized with the given key.\n+     * @see Mac#getInstance(String)\n+     * @see Mac#init(SecretKeySpec)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static Mac getHmacSha384(final byte[] key) {\n+        return getInitializedMac(HmacAlgorithms.HMAC_SHA_384, key);\n+    }\n+\n+    /**\n+     * Returns an initialized <code>Mac</code> for the HmacSHA512 algorithm.\n+     * <p>\n+     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n+     * </p>\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @return A Mac instance initialized with the given key.\n+     * @see Mac#getInstance(String)\n+     * @see Mac#init(SecretKeySpec)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static Mac getHmacSha512(final byte[] key) {\n+        return getInitializedMac(HmacAlgorithms.HMAC_SHA_512, key);\n+    }\n+\n+    /**\n+     * Returns an initialized <code>Mac</code> for the given <code>algorithm</code>.\n+     *\n+     * @param algorithm\n+     *            the name of the algorithm requested. See <a href=\n+     *            \"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\" >Appendix\n+     *            A in the Java Cryptography Architecture Reference Guide</a> for information about standard algorithm\n+     *            names.\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @return A Mac instance initialized with the given key.\n+     * @see Mac#getInstance(String)\n+     * @see Mac#init(SecretKeySpec)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static Mac getInitializedMac(final HmacAlgorithms algorithm, final byte[] key) {\n+        return getInitializedMac(algorithm.toString(), key);\n+    }\n+\n+    /**\n+     * Returns an initialized <code>Mac</code> for the given <code>algorithm</code>.\n+     *\n+     * @param algorithm\n+     *            the name of the algorithm requested. See <a href=\n+     *            \"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\" >Appendix\n+     *            A in the Java Cryptography Architecture Reference Guide</a> for information about standard algorithm\n+     *            names.\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @return A Mac instance initialized with the given key.\n+     * @see Mac#getInstance(String)\n+     * @see Mac#init(SecretKeySpec)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static Mac getInitializedMac(final String algorithm, final byte[] key) {\n+\n+        if (key == null) {\n+            throw new IllegalArgumentException(\"Null key\");\n+        }\n+\n+        try {\n+            final SecretKeySpec keySpec = new SecretKeySpec(key, algorithm);\n+            final Mac mac = Mac.getInstance(algorithm);\n+            mac.init(keySpec);\n+            return mac;\n+        } catch (final NoSuchAlgorithmException e) {\n+            throw new IllegalArgumentException(e);\n+        } catch (final InvalidKeyException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    // hmacMd5\n+\n+    /**\n+     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacMD5 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacMd5(final byte[] key, final byte[] valueToDigest) {\n+        try {\n+            return getHmacMd5(key).doFinal(valueToDigest);\n+        } catch (final IllegalStateException e) {\n+            // cannot happen\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return HmacMD5 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacMd5(final byte[] key, final InputStream valueToDigest) throws IOException {\n+        return updateHmac(getHmacMd5(key), valueToDigest).doFinal();\n+    }\n+\n+    /**\n+     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacMD5 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacMd5(final String key, final String valueToDigest) {\n+        return hmacMd5(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacMd5Hex(final byte[] key, final byte[] valueToDigest) {\n+        return Hex.encodeHexString(hmacMd5(key, valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacMd5Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\n+        return Hex.encodeHexString(hmacMd5(key, valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacMd5Hex(final String key, final String valueToDigest) {\n+        return Hex.encodeHexString(hmacMd5(key, valueToDigest));\n+    }\n+\n+    // hmacSha1\n+\n+    /**\n+     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA1 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha1(final byte[] key, final byte[] valueToDigest) {\n+        try {\n+            return getHmacSha1(key).doFinal(valueToDigest);\n+        } catch (final IllegalStateException e) {\n+            // cannot happen\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return HmacSHA1 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha1(final byte[] key, final InputStream valueToDigest) throws IOException {\n+        return updateHmac(getHmacSha1(key), valueToDigest).doFinal();\n+    }\n+\n+    /**\n+     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA1 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha1(final String key, final String valueToDigest) {\n+        return hmacSha1(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha1Hex(final byte[] key, final byte[] valueToDigest) {\n+        return Hex.encodeHexString(hmacSha1(key, valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha1Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\n+        return Hex.encodeHexString(hmacSha1(key, valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha1Hex(final String key, final String valueToDigest) {\n+        return Hex.encodeHexString(hmacSha1(key, valueToDigest));\n+    }\n+\n+    // hmacSha256\n+\n+    /**\n+     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA256 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha256(final byte[] key, final byte[] valueToDigest) {\n+        try {\n+            return getHmacSha256(key).doFinal(valueToDigest);\n+        } catch (final IllegalStateException e) {\n+            // cannot happen\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return HmacSHA256 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha256(final byte[] key, final InputStream valueToDigest) throws IOException {\n+        return updateHmac(getHmacSha256(key), valueToDigest).doFinal();\n+    }\n+\n+    /**\n+     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA256 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha256(final String key, final String valueToDigest) {\n+        return hmacSha256(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha256Hex(final byte[] key, final byte[] valueToDigest) {\n+        return Hex.encodeHexString(hmacSha256(key, valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha256Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\n+        return Hex.encodeHexString(hmacSha256(key, valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha256Hex(final String key, final String valueToDigest) {\n+        return Hex.encodeHexString(hmacSha256(key, valueToDigest));\n+    }\n+\n+    // hmacSha384\n+\n+    /**\n+     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA384 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha384(final byte[] key, final byte[] valueToDigest) {\n+        try {\n+            return getHmacSha384(key).doFinal(valueToDigest);\n+        } catch (final IllegalStateException e) {\n+            // cannot happen\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return HmacSHA384 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha384(final byte[] key, final InputStream valueToDigest) throws IOException {\n+        return updateHmac(getHmacSha384(key), valueToDigest).doFinal();\n+    }\n+\n+    /**\n+     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA384 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha384(final String key, final String valueToDigest) {\n+        return hmacSha384(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha384Hex(final byte[] key, final byte[] valueToDigest) {\n+        return Hex.encodeHexString(hmacSha384(key, valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha384Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\n+        return Hex.encodeHexString(hmacSha384(key, valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha384Hex(final String key, final String valueToDigest) {\n+        return Hex.encodeHexString(hmacSha384(key, valueToDigest));\n+    }\n+\n+    // hmacSha512\n+\n+    /**\n+     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA512 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha512(final byte[] key, final byte[] valueToDigest) {\n+        try {\n+            return getHmacSha512(key).doFinal(valueToDigest);\n+        } catch (final IllegalStateException e) {\n+            // cannot happen\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /**\n+     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return HmacSHA512 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha512(final byte[] key, final InputStream valueToDigest) throws IOException {\n+        return updateHmac(getHmacSha512(key), valueToDigest).doFinal();\n+    }\n+\n+    /**\n+     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA512 MAC for the given key and value\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static byte[] hmacSha512(final String key, final String valueToDigest) {\n+        return hmacSha512(StringUtils.getBytesUtf8(key), StringUtils.getBytesUtf8(valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha512Hex(final byte[] key, final byte[] valueToDigest) {\n+        return Hex.encodeHexString(hmacSha512(key, valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha512Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\n+        return Hex.encodeHexString(hmacSha512(key, valueToDigest));\n+    }\n+\n+    /**\n+     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\n+     *\n+     * @param key\n+     *            They key for the keyed digest (must not be null)\n+     * @param valueToDigest\n+     *            The value (data) which should to digest (maybe empty or null)\n+     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)\n+     * @throws IllegalArgumentException\n+     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n+     */\n+    public static String hmacSha512Hex(final String key, final String valueToDigest) {\n+        return Hex.encodeHexString(hmacSha512(key, valueToDigest));\n+    }\n+\n+    // update\n+\n+    /**\n+     * Updates the given {@link Mac}. This generates a digest for valueToDigest and the key the Mac was initialized\n+     *\n+     * @param mac\n+     *            the initialized {@link Mac} to update\n+     * @param valueToDigest\n+     *            the value to update the {@link Mac} with (maybe null or empty)\n+     * @return the updated {@link Mac}\n+     * @throws IllegalStateException\n+     *             if the Mac was not initialized\n+     * @since 1.x\n+     */\n+    public static Mac updateHmac(final Mac mac, final byte[] valueToDigest) {\n+        mac.reset();\n+        mac.update(valueToDigest);\n+        return mac;\n+    }\n+\n+    /**\n+     * Updates the given {@link Mac}. This generates a digest for valueToDigest and the key the Mac was initialized\n+     *\n+     * @param mac\n+     *            the initialized {@link Mac} to update\n+     * @param valueToDigest\n+     *            the value to update the {@link Mac} with\n+     *            <p>\n+     *            The InputStream must not be null and will not be closed\n+     *            </p>\n+     * @return the updated {@link Mac}\n+     * @throws IllegalStateException\n+     *             if the Mac was not initialized\n+     * @since 1.x\n+     */\n+    public static Mac updateHmac(final Mac mac, final InputStream valueToDigest) throws IOException {\n+        mac.reset();\n+        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n+        int read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH);\n+\n+        while (read > -1) {\n+            mac.update(buffer, 0, read);\n+            read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH);\n+        }\n+\n+        return mac;\n+    }\n+\n+    /**\n+     * Updates the given {@link Mac}. This generates a digest for valueToDigest and the key the Mac was initialized\n+     *\n+     * @param mac\n+     *            the initialized {@link Mac} to update\n+     * @param valueToDigest\n+     *            the value to update the {@link Mac} with (maybe null or empty)\n+     * @return the updated {@link Mac}\n+     * @throws IllegalStateException\n+     *             if the Mac was not initialized\n+     * @since 1.x\n+     */\n+    public static Mac updateHmac(final Mac mac, final String valueToDigest) {\n+        mac.reset();\n+        mac.update(StringUtils.getBytesUtf8(valueToDigest));\n+        return mac;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/digest/HmacUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.codec.binary.StringUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Tests HmacUtils methods.\n+ *\n+ * @version $Id$\n+ */\n+public class HmacUtilsTest {\n+    private static final String STANDARD_KEY_STRING = \"key\";\n+    private static final byte[] STANDARD_KEY_BYTES = STANDARD_KEY_STRING.getBytes();\n+    private static final byte[] STANDARD_MD5_RESULT_BYTES = new byte[] { -128, 7, 7, 19, 70, 62, 119, 73, -71, 12, 45,\n+            -62, 73, 17, -30, 117 };\n+    private static final String STANDARD_MD5_RESULT_STRING = \"80070713463e7749b90c2dc24911e275\";\n+    private static final String STANDARD_PHRASE_STRING = \"The quick brown fox jumps over the lazy dog\";\n+    private static final byte[] STANDARD_PHRASE_BYTES = STANDARD_PHRASE_STRING.getBytes();\n+    private static final byte[] STANDARD_SHA1_RESULT_BYTES = new byte[] { -34, 124, -101, -123, -72, -73, -118, -90,\n+            -68, -118, 122, 54, -9, 10, -112, 112, 28, -99, -76, -39 };\n+    private static final String STANDARD_SHA1_RESULT_STRING = \"de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9\";\n+    private static final byte[] STANDARD_SHA256_RESULT_BYTES = new byte[] { -9, -68, -125, -12, 48, 83, -124, 36, -79,\n+            50, -104, -26, -86, 111, -79, 67, -17, 77, 89, -95, 73, 70, 23, 89, -105, 71, -99, -68, 45, 26, 60, -40 };\n+    private static final String STANDARD_SHA256_RESULT_STRING = \"f7bc83f430538424b13298e6aa6fb143ef4d59a14946175997479dbc2d1a3cd8\";\n+    private static final byte[] STANDARD_SHA384_RESULT_BYTES = new byte[] { -41, -12, 114, 126, 44, 11, 57, -82, 15,\n+            30, 64, -52, -106, -10, 2, 66, -43, -73, -128, 24, 65, -50, -90, -4, 89, 44, 93, 62, 26, -27, 7, 0, 88, 42,\n+            -106, -49, 53, -31, -27, 84, -103, 95, -28, -32, 51, -127, -62, 55 };\n+    private static final String STANDARD_SHA384_RESULT_STRING = \"D7F4727E2C0B39AE0F1E40CC96F60242D5B7801841CEA6FC592C5D3E1AE50700582A96CF35E1E554995FE4E03381C237\"\n+            .toLowerCase();\n+    private static final byte[] STANDARD_SHA512_RESULT_BYTES = new byte[] { -76, 42, -16, -112, 87, -70, -63, -30, -44,\n+            23, 8, -28, -118, -112, 46, 9, -75, -1, 127, 18, -85, 66, -118, 79, -24, 102, 83, -57, 61, -46, 72, -5,\n+            -126, -7, 72, -91, 73, -9, -73, -111, -91, -76, 25, 21, -18, 77, 30, -61, -109, 83, 87, -28, -30, 49, 114,\n+            80, -48, 55, 42, -6, 46, -66, -21, 58 };\n+    private static final String STANDARD_SHA512_RESULT_STRING = \"B42AF09057BAC1E2D41708E48A902E09B5FF7F12AB428A4FE86653C73DD248FB82F948A549F7B791A5B41915EE4D1EC3935357E4E2317250D0372AFA2EBEEB3A\"\n+            .toLowerCase();\n+\n+    @Test\n+    public void testConstructor() {\n+        assertNotNull(new HmacUtils());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testEmptyKey() {\n+        HmacUtils.getHmacMd5(new byte[] {});\n+    }\n+\n+    @Test\n+    public void testGetHMac() throws IOException {\n+        Assert.assertArrayEquals(STANDARD_MD5_RESULT_BYTES,\n+                HmacUtils.getHmacMd5(STANDARD_KEY_BYTES).doFinal(STANDARD_PHRASE_BYTES));\n+        Assert.assertArrayEquals(STANDARD_SHA1_RESULT_BYTES,\n+                HmacUtils.getHmacSha1(STANDARD_KEY_BYTES).doFinal(STANDARD_PHRASE_BYTES));\n+        Assert.assertArrayEquals(STANDARD_SHA256_RESULT_BYTES,\n+                HmacUtils.getHmacSha256(STANDARD_KEY_BYTES).doFinal(STANDARD_PHRASE_BYTES));\n+        Assert.assertArrayEquals(STANDARD_SHA384_RESULT_BYTES,\n+                HmacUtils.getHmacSha384(STANDARD_KEY_BYTES).doFinal(STANDARD_PHRASE_BYTES));\n+        Assert.assertArrayEquals(STANDARD_SHA512_RESULT_BYTES,\n+                HmacUtils.getHmacSha512(STANDARD_KEY_BYTES).doFinal(STANDARD_PHRASE_BYTES));\n+    }\n+\n+    @Test\n+    public void testHmacMd5Hex() throws IOException {\n+        assertEquals(\"80070713463e7749b90c2dc24911e275\",\n+                HmacUtils.hmacMd5Hex(STANDARD_KEY_STRING, \"The quick brown fox jumps over the lazy dog\"));\n+        assertEquals(\"750c783e6ab0b503eaa86e310a5db738\", HmacUtils.hmacMd5Hex(\"Jefe\", \"what do ya want for nothing?\"));\n+        assertEquals(\n+                \"750c783e6ab0b503eaa86e310a5db738\",\n+                HmacUtils.hmacMd5Hex(\"Jefe\".getBytes(),\n+                        new ByteArrayInputStream(\"what do ya want for nothing?\".getBytes())));\n+    }\n+\n+    @Test\n+    public void testHmacSha1Hex() throws IOException {\n+        assertEquals(STANDARD_SHA1_RESULT_STRING, HmacUtils.hmacSha1Hex(STANDARD_KEY_STRING, STANDARD_PHRASE_STRING));\n+        assertEquals(\"f42bb0eeb018ebbd4597ae7213711ec60760843f\", HmacUtils.hmacSha1Hex(STANDARD_KEY_STRING, \"\"));\n+        assertEquals(\"effcdf6ae5eb2fa2d27416d5f184df9c259a7c79\",\n+                HmacUtils.hmacSha1Hex(\"Jefe\", \"what do ya want for nothing?\"));\n+        assertEquals(\n+                \"effcdf6ae5eb2fa2d27416d5f184df9c259a7c79\",\n+                HmacUtils.hmacSha1Hex(\"Jefe\".getBytes(),\n+                        new ByteArrayInputStream(\"what do ya want for nothing?\".getBytes())));\n+    }\n+\n+    @Test\n+    public void testHmacSha1UpdateWithByteArray() throws IOException {\n+        final Mac mac = HmacUtils.getHmacSha1(STANDARD_KEY_BYTES);\n+        HmacUtils.updateHmac(mac, STANDARD_PHRASE_BYTES);\n+        assertEquals(STANDARD_SHA1_RESULT_STRING, Hex.encodeHexString(mac.doFinal()));\n+        HmacUtils.updateHmac(mac, \"\".getBytes());\n+        assertEquals(\"f42bb0eeb018ebbd4597ae7213711ec60760843f\", Hex.encodeHexString(mac.doFinal()));\n+    }\n+\n+    @Test\n+    public void testHmacSha1UpdateWithInpustream() throws IOException {\n+        final Mac mac = HmacUtils.getHmacSha1(STANDARD_KEY_BYTES);\n+        HmacUtils.updateHmac(mac, new ByteArrayInputStream(STANDARD_PHRASE_BYTES));\n+        assertEquals(STANDARD_SHA1_RESULT_STRING, Hex.encodeHexString(mac.doFinal()));\n+        HmacUtils.updateHmac(mac, new ByteArrayInputStream(\"\".getBytes()));\n+        assertEquals(\"f42bb0eeb018ebbd4597ae7213711ec60760843f\", Hex.encodeHexString(mac.doFinal()));\n+    }\n+\n+    @Test\n+    public void testHmacSha1UpdateWithString() throws IOException {\n+        final Mac mac = HmacUtils.getHmacSha1(STANDARD_KEY_BYTES);\n+        HmacUtils.updateHmac(mac, STANDARD_PHRASE_STRING);\n+        assertEquals(STANDARD_SHA1_RESULT_STRING, Hex.encodeHexString(mac.doFinal()));\n+        HmacUtils.updateHmac(mac, \"\");\n+        assertEquals(\"f42bb0eeb018ebbd4597ae7213711ec60760843f\", Hex.encodeHexString(mac.doFinal()));\n+    }\n+\n+    @Test\n+    public void testInitializedMac() throws IOException {\n+        final Mac md5Mac = HmacUtils.getInitializedMac(HmacAlgorithms.HMAC_MD5, STANDARD_KEY_BYTES);\n+        final Mac md5Mac2 = HmacUtils.getInitializedMac(\"HmacMD5\", STANDARD_KEY_BYTES);\n+        Assert.assertArrayEquals(STANDARD_MD5_RESULT_BYTES, HmacUtils.updateHmac(md5Mac, STANDARD_PHRASE_STRING)\n+                .doFinal());\n+        Assert.assertArrayEquals(STANDARD_MD5_RESULT_BYTES, HmacUtils.updateHmac(md5Mac2, STANDARD_PHRASE_STRING)\n+                .doFinal());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testInitializedMacNullAlgo() throws IOException {\n+        HmacUtils.getInitializedMac((String) null, STANDARD_KEY_BYTES);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testInitializedMacNullKey() throws IOException {\n+        HmacUtils.getInitializedMac(HmacAlgorithms.HMAC_MD5, null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testInternalNoSuchAlgorithmException() {\n+        HmacUtils.getInitializedMac(\"Bogus Bogus\", StringUtils.getBytesUtf8(\"akey\"));\n+    }\n+\n+    @Test\n+    public void testMd5HMac() throws IOException {\n+        Assert.assertArrayEquals(STANDARD_MD5_RESULT_BYTES,\n+                HmacUtils.hmacMd5(STANDARD_KEY_BYTES, STANDARD_PHRASE_BYTES));\n+        Assert.assertArrayEquals(STANDARD_MD5_RESULT_BYTES,\n+                HmacUtils.hmacMd5(STANDARD_KEY_BYTES, new ByteArrayInputStream(STANDARD_PHRASE_BYTES)));\n+        Assert.assertArrayEquals(STANDARD_MD5_RESULT_BYTES,\n+                HmacUtils.hmacMd5(STANDARD_KEY_STRING, STANDARD_PHRASE_STRING));\n+        Assert.assertEquals(STANDARD_MD5_RESULT_STRING, HmacUtils.hmacMd5Hex(STANDARD_KEY_BYTES, STANDARD_PHRASE_BYTES));\n+        Assert.assertEquals(STANDARD_MD5_RESULT_STRING,\n+                HmacUtils.hmacMd5Hex(STANDARD_KEY_BYTES, new ByteArrayInputStream(STANDARD_PHRASE_BYTES)));\n+        Assert.assertEquals(STANDARD_MD5_RESULT_STRING,\n+                HmacUtils.hmacMd5Hex(STANDARD_KEY_STRING, STANDARD_PHRASE_STRING));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testMd5HMacFail() throws IOException {\n+        HmacUtils.hmacMd5((byte[]) null, STANDARD_PHRASE_BYTES);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testNullKey() {\n+        HmacUtils.getHmacMd5(null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testSecretKeySpecAllowsEmtyKeys() {\n+        new SecretKeySpec(new byte[] {}, \"HmacMD5\");\n+    }\n+\n+    @Test\n+    public void testSha1HMac() throws IOException {\n+        Assert.assertArrayEquals(STANDARD_SHA1_RESULT_BYTES,\n+                HmacUtils.hmacSha1(STANDARD_KEY_BYTES, STANDARD_PHRASE_BYTES));\n+        Assert.assertArrayEquals(STANDARD_SHA1_RESULT_BYTES,\n+                HmacUtils.hmacSha1(STANDARD_KEY_BYTES, new ByteArrayInputStream(STANDARD_PHRASE_BYTES)));\n+        Assert.assertArrayEquals(STANDARD_SHA1_RESULT_BYTES,\n+                HmacUtils.hmacSha1(STANDARD_KEY_STRING, STANDARD_PHRASE_STRING));\n+        Assert.assertEquals(STANDARD_SHA1_RESULT_STRING,\n+                HmacUtils.hmacSha1Hex(STANDARD_KEY_BYTES, STANDARD_PHRASE_BYTES));\n+        Assert.assertEquals(STANDARD_SHA1_RESULT_STRING,\n+                HmacUtils.hmacSha1Hex(STANDARD_KEY_BYTES, new ByteArrayInputStream(STANDARD_PHRASE_BYTES)));\n+        Assert.assertEquals(STANDARD_SHA1_RESULT_STRING,\n+                HmacUtils.hmacSha1Hex(STANDARD_KEY_STRING, STANDARD_PHRASE_STRING));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testSha1HMacFail() throws IOException {\n+        HmacUtils.hmacSha1((byte[]) null, STANDARD_PHRASE_BYTES);\n+    }\n+\n+    @Test\n+    public void testSha256HMac() throws IOException {\n+        Assert.assertArrayEquals(STANDARD_SHA256_RESULT_BYTES,\n+                HmacUtils.hmacSha256(STANDARD_KEY_BYTES, STANDARD_PHRASE_BYTES));\n+        Assert.assertArrayEquals(STANDARD_SHA256_RESULT_BYTES,\n+                HmacUtils.hmacSha256(STANDARD_KEY_BYTES, new ByteArrayInputStream(STANDARD_PHRASE_BYTES)));\n+        Assert.assertArrayEquals(STANDARD_SHA256_RESULT_BYTES,\n+                HmacUtils.hmacSha256(STANDARD_KEY_STRING, STANDARD_PHRASE_STRING));\n+        Assert.assertEquals(STANDARD_SHA256_RESULT_STRING,\n+                HmacUtils.hmacSha256Hex(STANDARD_KEY_BYTES, STANDARD_PHRASE_BYTES));\n+        Assert.assertEquals(STANDARD_SHA256_RESULT_STRING,\n+                HmacUtils.hmacSha256Hex(STANDARD_KEY_BYTES, new ByteArrayInputStream(STANDARD_PHRASE_BYTES)));\n+        Assert.assertEquals(STANDARD_SHA256_RESULT_STRING,\n+                HmacUtils.hmacSha256Hex(STANDARD_KEY_STRING, STANDARD_PHRASE_STRING));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testSha256HMacFail() throws IOException {\n+        HmacUtils.hmacSha256((byte[]) null, STANDARD_PHRASE_BYTES);\n+    }\n+\n+    @Test\n+    public void testSha384HMac() throws IOException {\n+        Assert.assertArrayEquals(STANDARD_SHA384_RESULT_BYTES,\n+                HmacUtils.hmacSha384(STANDARD_KEY_BYTES, STANDARD_PHRASE_BYTES));\n+        Assert.assertArrayEquals(STANDARD_SHA384_RESULT_BYTES,\n+                HmacUtils.hmacSha384(STANDARD_KEY_BYTES, new ByteArrayInputStream(STANDARD_PHRASE_BYTES)));\n+        Assert.assertArrayEquals(STANDARD_SHA384_RESULT_BYTES,\n+                HmacUtils.hmacSha384(STANDARD_KEY_STRING, STANDARD_PHRASE_STRING));\n+        Assert.assertEquals(STANDARD_SHA384_RESULT_STRING,\n+                HmacUtils.hmacSha384Hex(STANDARD_KEY_BYTES, STANDARD_PHRASE_BYTES));\n+        Assert.assertEquals(STANDARD_SHA384_RESULT_STRING,\n+                HmacUtils.hmacSha384Hex(STANDARD_KEY_BYTES, new ByteArrayInputStream(STANDARD_PHRASE_BYTES)));\n+        Assert.assertEquals(STANDARD_SHA384_RESULT_STRING,\n+                HmacUtils.hmacSha384Hex(STANDARD_KEY_STRING, STANDARD_PHRASE_STRING));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testSha384HMacFail() throws IOException {\n+        HmacUtils.hmacSha384((byte[]) null, STANDARD_PHRASE_BYTES);\n+    }\n+\n+    @Test\n+    public void testSha512HMac() throws IOException {\n+        Assert.assertArrayEquals(STANDARD_SHA512_RESULT_BYTES,\n+                HmacUtils.hmacSha512(STANDARD_KEY_BYTES, STANDARD_PHRASE_BYTES));\n+        Assert.assertArrayEquals(STANDARD_SHA512_RESULT_BYTES,\n+                HmacUtils.hmacSha512(STANDARD_KEY_BYTES, new ByteArrayInputStream(STANDARD_PHRASE_BYTES)));\n+        Assert.assertArrayEquals(STANDARD_SHA512_RESULT_BYTES,\n+                HmacUtils.hmacSha512(STANDARD_KEY_STRING, STANDARD_PHRASE_STRING));\n+        Assert.assertEquals(STANDARD_SHA512_RESULT_STRING,\n+                HmacUtils.hmacSha512Hex(STANDARD_KEY_BYTES, STANDARD_PHRASE_BYTES));\n+        Assert.assertEquals(STANDARD_SHA512_RESULT_STRING,\n+                HmacUtils.hmacSha512Hex(STANDARD_KEY_BYTES, new ByteArrayInputStream(STANDARD_PHRASE_BYTES)));\n+        Assert.assertEquals(STANDARD_SHA512_RESULT_STRING,\n+                HmacUtils.hmacSha512Hex(STANDARD_KEY_STRING, STANDARD_PHRASE_STRING));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testSha512HMacFail() throws IOException {\n+        HmacUtils.hmacSha512((byte[]) null, STANDARD_PHRASE_BYTES);\n+    }\n+}", "timestamp": 1408748168, "metainfo": ""}