{"sha": "ea515a8d142e060b70844a040a94c71439171bf5", "log": "Javadoc typo.   ", "commit": "\n--- a/src/java/org/apache/commons/codec/base64/Base64.java\n+++ b/src/java/org/apache/commons/codec/base64/Base64.java\n-/*\n- * ====================================================================\n- *\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 2003 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n- *\n- * 4. The names \"The Jakarta Project\", \"HttpClient\", and \"Apache Software\n- *    Foundation\" must not be used to endorse or promote products derived\n- *    from this software without prior written permission. For written\n- *    permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\"\n- *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http://www.apache.org/>.\n- *\n- */\n-\n-package org.apache.commons.codec.base64;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStreamWriter;\n-import java.io.UnsupportedEncodingException;\n-\n-/**\n- * <p>Base64 encoder and decoder.</p>\n- * <p>\n- * This class provides encoding/decoding methods for\n- * the Base64 encoding as defined by RFC 2045,\n- * N. Freed and N. Borenstein.\n-y * RFC 2045: Multipurpose Internet Mail Extensions (MIME)\n- * Part One: Format of Internet Message Bodies. Reference\n- * 1996. Available at: http://www.ietf.org/rfc/rfc2045.txt\n- * </p>\n- * @author Jeffrey Rodriguez\n- * @version $Revision: 1.3 $ $Date: 2003/06/18 18:43:56 $\n- *\n- * @deprecated This class has been replaced by \n- *             {@link org.apache.commons.codec.binary.Base64}\n- */\n-public final class Base64 {\n-\n-    /**\n-     * The default character encoding\n-     */\n-    protected static final String DEFAULT_CHAR_ENCODING = \"ISO-8859-1\";\n-\n-    /**\n-     * The bsae length\n-     */\n-    static final int BASELENGTH = 255;\n-\n-    /**\n-     * Lookup length\n-     */\n-    static final int LOOKUPLENGTH = 64;\n-\n-    /**\n-     * Used to calculate the number of bits in a byte.\n-     */\n-    static final int EIGHTBIT = 8;\n-\n-    /**\n-     * Used when encoding something which has fewer than 24 bits\n-     */\n-    static final int SIXTEENBIT = 16;\n-\n-    /**\n-     * Constant used to determine how many bits data contains\n-     */\n-    static final int TWENTYFOURBITGROUP = 24;\n-\n-    /**\n-     * Used to get the number of Quadruples\n-     */\n-    static final int FOURBYTE = 4;\n-\n-    /**\n-     * Used to test the sign of a byte\n-     */\n-    static final int SIGN = -128;\n-    \n-    /**\n-     * Byte used to pad output\n-     */\n-    static final byte PAD = (byte) '=';\n-\n-    /**\n-     * Create arrays to hold the base64 characters and a \n-     * lookup for base64 chars\n-     */\n-    private static byte[] base64Alphabet = new byte[BASELENGTH];\n-\n-    /**\n-     * An empty array of type byte\n-     */\n-    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n-    \n-    /**\n-     * Lookup table\n-     */\n-    private static byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n-\n-    static {\n-\n-        for (int i = 0; i < BASELENGTH; i++) {\n-            base64Alphabet[i] = -1;\n-        }\n-        for (int i = 'Z'; i >= 'A'; i--) {\n-            base64Alphabet[i] = (byte) (i - 'A');\n-        }\n-        for (int i = 'z'; i >= 'a'; i--) {\n-            base64Alphabet[i] = (byte) (i - 'a' + 26);\n-        }\n-\n-        for (int i = '9'; i >= '0'; i--) {\n-            base64Alphabet[i] = (byte) (i - '0' + 52);\n-        }\n-\n-        base64Alphabet['+'] = 62;\n-        base64Alphabet['/'] = 63;\n-\n-        for (int i = 0; i <= 25; i++) {\n-            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n-        }\n-\n-        for (int i = 26,  j = 0; i <= 51; i++, j++) {\n-            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n-        }\n-\n-        for (int i = 52,  j = 0; i <= 61; i++, j++) {\n-            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n-        }\n-\n-        lookUpBase64Alphabet[62] = (byte) '+';\n-        lookUpBase64Alphabet[63] = (byte) '/';\n-\n-    }\n-\n-    /**\n-     * Tests to see whether the bytes of this string are\n-     * Base64\n-     *\n-     * @param isValidString String to test\n-     * @return trus if String is base64\n-     */\n-    public static boolean isBase64(String isValidString) {\n-        return (isBase64(isValidString.getBytes()));\n-    }\n-\n-    /**\n-     * Tests a byte to see whether it falls within the Base64\n-     * alphabet (or if it is a padding character).\n-     *\n-     * @param octect byte to test\n-     * @return true if byte is in alphabet or padding\n-     */\n-    public static boolean isBase64(byte octect) {\n-        // Should we ignore white space?\n-        return (octect == PAD || base64Alphabet[octect] != -1);\n-    }\n-\n-    /**\n-     * Tests byte array to see if all characters are within the\n-     * Base64 alphabet\n-     *\n-     * @param arrayOctect A byte[] to test\n-     * @return true if all data falls within the Base64 alphabet OR if the\n-     *         array is empty.\n-     */\n-    public static boolean isBase64(byte[] arrayOctect) {\n-        int length = arrayOctect.length;\n-        if (length == 0) {\n-            return true;\n-        }\n-        for (int i = 0; i < length; i++) {\n-            if (!Base64.isBase64(arrayOctect[i])) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Encodes hex octects into Base64\n-     *\n-     * @param binaryData Array containing binaryData\n-     * @return Base64-encoded array\n-     */\n-    public static byte[] encode(byte[] binaryData) {\n-        if (binaryData == null) {\n-            binaryData = EMPTY_BYTE_ARRAY;\n-        }\n-\n-        int lengthDataBits = binaryData.length * EIGHTBIT;\n-        int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n-        int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;\n-        byte encodedData[] = null;\n-\n-\n-        if (fewerThan24bits != 0) {\n-            //data not divisible by 24 bit\n-            encodedData = new byte[(numberTriplets + 1) * 4];\n-        } else {\n-            // 16 or 8 bit \n-            encodedData = new byte[numberTriplets * 4];\n-        }\n-\n-        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n-\n-        int encodedIndex = 0;\n-        int dataIndex = 0;\n-        int i = 0;\n-        for (i = 0; i < numberTriplets; i++) {\n-\n-            dataIndex = i * 3;\n-            b1 = binaryData[dataIndex];\n-            b2 = binaryData[dataIndex + 1];\n-            b3 = binaryData[dataIndex + 2];\n-\n-            l = (byte) (b2 & 0x0f);\n-            k = (byte) (b1 & 0x03);\n-\n-            encodedIndex = i * 4;\n-            byte val1 = ((b1 & SIGN) == 0) \n-                ? (byte) (b1 >> 2) \n-                : (byte) ((b1) >> 2 ^ 0xc0);\n-\n-            byte val2 = ((b2 & SIGN) == 0) \n-                ? (byte) (b2 >> 4) \n-                : (byte) ((b2) >> 4 ^ 0xf0);\n-\n-            byte val3 = ((b3 & SIGN) == 0) \n-                ? (byte) (b3 >> 6) \n-                : (byte) ((b3) >> 6 ^ 0xfc);\n-\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 \n-                                                                 | (k << 4)];\n-            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) \n-                                                                 | val3];\n-            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n-        }\n-\n-        // form integral number of 6-bit groups\n-        dataIndex = i * 3;\n-        encodedIndex = i * 4;\n-        if (fewerThan24bits == EIGHTBIT) {\n-            b1 = binaryData[dataIndex];\n-            k = (byte) (b1 & 0x03);\n-            byte val1 = ((b1 & SIGN) == 0) \n-                ? (byte) (b1 >> 2) \n-                : (byte) ((b1) >> 2 ^ 0xc0);\n-\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n-            encodedData[encodedIndex + 2] = PAD;\n-            encodedData[encodedIndex + 3] = PAD;\n-        } else if (fewerThan24bits == SIXTEENBIT) {\n-            b1 = binaryData[dataIndex];\n-            b2 = binaryData[dataIndex + 1];\n-            l = (byte) (b2 & 0x0f);\n-            k = (byte) (b1 & 0x03);\n-\n-            byte val1 = ((b1 & SIGN) == 0) \n-                ? (byte) (b1 >> 2) \n-                : (byte) ((b1) >> 2 ^ 0xc0);\n-\n-            byte val2 = ((b2 & SIGN) == 0) \n-                ? (byte) (b2 >> 4) \n-                : (byte) ((b2) >> 4 ^ 0xf0);\n-\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 \n-                                                                 | (k << 4)];\n-            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n-            encodedData[encodedIndex + 3] = PAD;\n-        }\n-        return encodedData;\n-    }\n-\n-\n-    /**\n-     * Returns the base64 encoding of String.  First the String is\n-     * converted to byte[], using the character encoding of\n-     * <code>ISO-8859-1</code>.\n-     *\n-     * @param data String of data to convert\n-     * @return Base64-encoded String\n-     */\n-    public static String encode(String data) {\n-         try {\n-             return encode(data, DEFAULT_CHAR_ENCODING);\n-         } catch (UnsupportedEncodingException uee) {\n-             throw new IllegalStateException(uee.toString());\n-         }\n-     }\n-\n-\n-    /**\n-     * Returns the base64 encoding of String (by first converting to\n-     * byte[], using the specified <code>charEncoding</code>).  The\n-     * return value is also a String.  The Default\n-     * <code>codeEncoding</chode> is <code>ISO-8859-1</code>.\n-     *\n-     * @param data String of data to convert\n-     * @param charEncoding the character encoding to use when converting\n-     *                     a String to a byte[]\n-     * @return Base64-encoded String\n-     * @throws UnsupportedEncodingException\n-     */\n-    public static String encode(String data, String charEncoding)\n-        throws UnsupportedEncodingException {\n-\n-        // Check arguments\n-        if (data == null) {\n-            data = \"\";\n-        }\n-        if (charEncoding == null) {\n-            charEncoding = DEFAULT_CHAR_ENCODING;\n-        }\n-\n-        // Convert to byte[]\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        OutputStreamWriter osw = new OutputStreamWriter(bos, charEncoding);\n-        try {\n-            osw.write(data);\n-        } catch (IOException ioe) {\n-            throw new RuntimeException(ioe.toString());\n-        }\n-\n-        // Encode\n-        byte[] encodedData = encode(bos.toByteArray());\n-\n-        // Convert to String\n-        if (encodedData == null) {\n-            return \"\";\n-        }\n-        bos = new ByteArrayOutputStream(encodedData.length);\n-        try {\n-            bos.write(encodedData);\n-        } catch (IOException ioe) {\n-            throw new RuntimeException(ioe.toString());\n-        }\n-\n-        return bos.toString(charEncoding);\n-    }\n-\n-    /**\n-     * Decodes Base64 data into octects\n-     *\n-     * @param base64Data Byte array containing Base64 data\n-     * @return Array containing decoded data.\n-     */\n-    public static byte[] decode(byte[] base64Data) {\n-        // Should we throw away anything not in base64Data ?\n-\n-        // handle the edge case, so we don't have to worry about it later\n-        if (base64Data.length == 0) {\n-            return EMPTY_BYTE_ARRAY;\n-        }\n-\n-        int numberQuadruple = base64Data.length / FOURBYTE;\n-        byte decodedData[] = null;\n-        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n-\n-        int encodedIndex = 0;\n-        int dataIndex = 0;\n-        {\n-            // this block sizes the output array properly - rlw\n-            int lastData = base64Data.length;\n-            // ignore the '=' padding\n-            while (base64Data[lastData - 1] == PAD) {\n-                if (--lastData == 0) {\n-                    return EMPTY_BYTE_ARRAY;\n-                }\n-            }\n-            decodedData = new byte[lastData - numberQuadruple];\n-        }\n-\n-        for (int i = 0; i < numberQuadruple; i++) {\n-            dataIndex = i * 4;\n-            marker0 = base64Data[dataIndex + 2];\n-            marker1 = base64Data[dataIndex + 3];\n-\n-            b1 = base64Alphabet[base64Data[dataIndex]];\n-            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n-\n-            if (marker0 != PAD && marker1 != PAD) {\n-                //No PAD e.g 3cQl\n-                b3 = base64Alphabet[marker0];\n-                b4 = base64Alphabet[marker1];\n-\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) \n-                                                        | ((b3 >> 2) & 0xf));\n-                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n-            } else if (marker0 == PAD) {\n-                //Two PAD e.g. 3c[Pad][Pad]\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-            } else if (marker1 == PAD) {\n-                //One PAD e.g. 3cQ[Pad]\n-                b3 = base64Alphabet[marker0];\n-\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) \n-                                                        | ((b3 >> 2) & 0xf));\n-            }\n-            encodedIndex += 3;\n-        }\n-        return decodedData;\n-    }\n-\n-}\n-\n+/*\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"HttpClient\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.codec.base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.UnsupportedEncodingException;\n+\n+/**\n+ * <p>Base64 encoder and decoder.</p>\n+ * <p>\n+ * This class provides encoding/decoding methods for\n+ * the Base64 encoding as defined by RFC 2045,\n+ * N. Freed and N. Borenstein.\n+ * RFC 2045: Multipurpose Internet Mail Extensions (MIME)\n+ * Part One: Format of Internet Message Bodies. Reference\n+ * 1996. Available at: http://www.ietf.org/rfc/rfc2045.txt\n+ * </p>\n+ * @author Jeffrey Rodriguez\n+ * @version $Revision: 1.4 $ $Date: 2003/07/20 19:09:02 $\n+ *\n+ * @deprecated This class has been replaced by \n+ *             {@link org.apache.commons.codec.binary.Base64}\n+ */\n+public final class Base64 {\n+\n+    /**\n+     * The default character encoding\n+     */\n+    protected static final String DEFAULT_CHAR_ENCODING = \"ISO-8859-1\";\n+\n+    /**\n+     * The bsae length\n+     */\n+    static final int BASELENGTH = 255;\n+\n+    /**\n+     * Lookup length\n+     */\n+    static final int LOOKUPLENGTH = 64;\n+\n+    /**\n+     * Used to calculate the number of bits in a byte.\n+     */\n+    static final int EIGHTBIT = 8;\n+\n+    /**\n+     * Used when encoding something which has fewer than 24 bits\n+     */\n+    static final int SIXTEENBIT = 16;\n+\n+    /**\n+     * Constant used to determine how many bits data contains\n+     */\n+    static final int TWENTYFOURBITGROUP = 24;\n+\n+    /**\n+     * Used to get the number of Quadruples\n+     */\n+    static final int FOURBYTE = 4;\n+\n+    /**\n+     * Used to test the sign of a byte\n+     */\n+    static final int SIGN = -128;\n+    \n+    /**\n+     * Byte used to pad output\n+     */\n+    static final byte PAD = (byte) '=';\n+\n+    /**\n+     * Create arrays to hold the base64 characters and a \n+     * lookup for base64 chars\n+     */\n+    private static byte[] base64Alphabet = new byte[BASELENGTH];\n+\n+    /**\n+     * An empty array of type byte\n+     */\n+    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+    \n+    /**\n+     * Lookup table\n+     */\n+    private static byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n+\n+    static {\n+\n+        for (int i = 0; i < BASELENGTH; i++) {\n+            base64Alphabet[i] = -1;\n+        }\n+        for (int i = 'Z'; i >= 'A'; i--) {\n+            base64Alphabet[i] = (byte) (i - 'A');\n+        }\n+        for (int i = 'z'; i >= 'a'; i--) {\n+            base64Alphabet[i] = (byte) (i - 'a' + 26);\n+        }\n+\n+        for (int i = '9'; i >= '0'; i--) {\n+            base64Alphabet[i] = (byte) (i - '0' + 52);\n+        }\n+\n+        base64Alphabet['+'] = 62;\n+        base64Alphabet['/'] = 63;\n+\n+        for (int i = 0; i <= 25; i++) {\n+            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n+        }\n+\n+        for (int i = 26,  j = 0; i <= 51; i++, j++) {\n+            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n+        }\n+\n+        for (int i = 52,  j = 0; i <= 61; i++, j++) {\n+            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n+        }\n+\n+        lookUpBase64Alphabet[62] = (byte) '+';\n+        lookUpBase64Alphabet[63] = (byte) '/';\n+\n+    }\n+\n+    /**\n+     * Tests to see whether the bytes of this string are\n+     * Base64\n+     *\n+     * @param isValidString String to test\n+     * @return trus if String is base64\n+     */\n+    public static boolean isBase64(String isValidString) {\n+        return (isBase64(isValidString.getBytes()));\n+    }\n+\n+    /**\n+     * Tests a byte to see whether it falls within the Base64\n+     * alphabet (or if it is a padding character).\n+     *\n+     * @param octect byte to test\n+     * @return true if byte is in alphabet or padding\n+     */\n+    public static boolean isBase64(byte octect) {\n+        // Should we ignore white space?\n+        return (octect == PAD || base64Alphabet[octect] != -1);\n+    }\n+\n+    /**\n+     * Tests byte array to see if all characters are within the\n+     * Base64 alphabet\n+     *\n+     * @param arrayOctect A byte[] to test\n+     * @return true if all data falls within the Base64 alphabet OR if the\n+     *         array is empty.\n+     */\n+    public static boolean isBase64(byte[] arrayOctect) {\n+        int length = arrayOctect.length;\n+        if (length == 0) {\n+            return true;\n+        }\n+        for (int i = 0; i < length; i++) {\n+            if (!Base64.isBase64(arrayOctect[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Encodes hex octects into Base64\n+     *\n+     * @param binaryData Array containing binaryData\n+     * @return Base64-encoded array\n+     */\n+    public static byte[] encode(byte[] binaryData) {\n+        if (binaryData == null) {\n+            binaryData = EMPTY_BYTE_ARRAY;\n+        }\n+\n+        int lengthDataBits = binaryData.length * EIGHTBIT;\n+        int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n+        int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;\n+        byte encodedData[] = null;\n+\n+\n+        if (fewerThan24bits != 0) {\n+            //data not divisible by 24 bit\n+            encodedData = new byte[(numberTriplets + 1) * 4];\n+        } else {\n+            // 16 or 8 bit \n+            encodedData = new byte[numberTriplets * 4];\n+        }\n+\n+        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n+\n+        int encodedIndex = 0;\n+        int dataIndex = 0;\n+        int i = 0;\n+        for (i = 0; i < numberTriplets; i++) {\n+\n+            dataIndex = i * 3;\n+            b1 = binaryData[dataIndex];\n+            b2 = binaryData[dataIndex + 1];\n+            b3 = binaryData[dataIndex + 2];\n+\n+            l = (byte) (b2 & 0x0f);\n+            k = (byte) (b1 & 0x03);\n+\n+            encodedIndex = i * 4;\n+            byte val1 = ((b1 & SIGN) == 0) \n+                ? (byte) (b1 >> 2) \n+                : (byte) ((b1) >> 2 ^ 0xc0);\n+\n+            byte val2 = ((b2 & SIGN) == 0) \n+                ? (byte) (b2 >> 4) \n+                : (byte) ((b2) >> 4 ^ 0xf0);\n+\n+            byte val3 = ((b3 & SIGN) == 0) \n+                ? (byte) (b3 >> 6) \n+                : (byte) ((b3) >> 6 ^ 0xfc);\n+\n+            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n+            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 \n+                                                                 | (k << 4)];\n+            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) \n+                                                                 | val3];\n+            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n+        }\n+\n+        // form integral number of 6-bit groups\n+        dataIndex = i * 3;\n+        encodedIndex = i * 4;\n+        if (fewerThan24bits == EIGHTBIT) {\n+            b1 = binaryData[dataIndex];\n+            k = (byte) (b1 & 0x03);\n+            byte val1 = ((b1 & SIGN) == 0) \n+                ? (byte) (b1 >> 2) \n+                : (byte) ((b1) >> 2 ^ 0xc0);\n+\n+            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n+            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n+            encodedData[encodedIndex + 2] = PAD;\n+            encodedData[encodedIndex + 3] = PAD;\n+        } else if (fewerThan24bits == SIXTEENBIT) {\n+            b1 = binaryData[dataIndex];\n+            b2 = binaryData[dataIndex + 1];\n+            l = (byte) (b2 & 0x0f);\n+            k = (byte) (b1 & 0x03);\n+\n+            byte val1 = ((b1 & SIGN) == 0) \n+                ? (byte) (b1 >> 2) \n+                : (byte) ((b1) >> 2 ^ 0xc0);\n+\n+            byte val2 = ((b2 & SIGN) == 0) \n+                ? (byte) (b2 >> 4) \n+                : (byte) ((b2) >> 4 ^ 0xf0);\n+\n+            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n+            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 \n+                                                                 | (k << 4)];\n+            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n+            encodedData[encodedIndex + 3] = PAD;\n+        }\n+        return encodedData;\n+    }\n+\n+\n+    /**\n+     * Returns the base64 encoding of String.  First the String is\n+     * converted to byte[], using the character encoding of\n+     * <code>ISO-8859-1</code>.\n+     *\n+     * @param data String of data to convert\n+     * @return Base64-encoded String\n+     */\n+    public static String encode(String data) {\n+         try {\n+             return encode(data, DEFAULT_CHAR_ENCODING);\n+         } catch (UnsupportedEncodingException uee) {\n+             throw new IllegalStateException(uee.toString());\n+         }\n+     }\n+\n+\n+    /**\n+     * Returns the base64 encoding of String (by first converting to\n+     * byte[], using the specified <code>charEncoding</code>).  The\n+     * return value is also a String.  The Default\n+     * <code>codeEncoding</chode> is <code>ISO-8859-1</code>.\n+     *\n+     * @param data String of data to convert\n+     * @param charEncoding the character encoding to use when converting\n+     *                     a String to a byte[]\n+     * @return Base64-encoded String\n+     * @throws UnsupportedEncodingException\n+     */\n+    public static String encode(String data, String charEncoding)\n+        throws UnsupportedEncodingException {\n+\n+        // Check arguments\n+        if (data == null) {\n+            data = \"\";\n+        }\n+        if (charEncoding == null) {\n+            charEncoding = DEFAULT_CHAR_ENCODING;\n+        }\n+\n+        // Convert to byte[]\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        OutputStreamWriter osw = new OutputStreamWriter(bos, charEncoding);\n+        try {\n+            osw.write(data);\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe.toString());\n+        }\n+\n+        // Encode\n+        byte[] encodedData = encode(bos.toByteArray());\n+\n+        // Convert to String\n+        if (encodedData == null) {\n+            return \"\";\n+        }\n+        bos = new ByteArrayOutputStream(encodedData.length);\n+        try {\n+            bos.write(encodedData);\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe.toString());\n+        }\n+\n+        return bos.toString(charEncoding);\n+    }\n+\n+    /**\n+     * Decodes Base64 data into octects\n+     *\n+     * @param base64Data Byte array containing Base64 data\n+     * @return Array containing decoded data.\n+     */\n+    public static byte[] decode(byte[] base64Data) {\n+        // Should we throw away anything not in base64Data ?\n+\n+        // handle the edge case, so we don't have to worry about it later\n+        if (base64Data.length == 0) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+\n+        int numberQuadruple = base64Data.length / FOURBYTE;\n+        byte decodedData[] = null;\n+        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n+\n+        int encodedIndex = 0;\n+        int dataIndex = 0;\n+        {\n+            // this block sizes the output array properly - rlw\n+            int lastData = base64Data.length;\n+            // ignore the '=' padding\n+            while (base64Data[lastData - 1] == PAD) {\n+                if (--lastData == 0) {\n+                    return EMPTY_BYTE_ARRAY;\n+                }\n+            }\n+            decodedData = new byte[lastData - numberQuadruple];\n+        }\n+\n+        for (int i = 0; i < numberQuadruple; i++) {\n+            dataIndex = i * 4;\n+            marker0 = base64Data[dataIndex + 2];\n+            marker1 = base64Data[dataIndex + 3];\n+\n+            b1 = base64Alphabet[base64Data[dataIndex]];\n+            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n+\n+            if (marker0 != PAD && marker1 != PAD) {\n+                //No PAD e.g 3cQl\n+                b3 = base64Alphabet[marker0];\n+                b4 = base64Alphabet[marker1];\n+\n+                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n+                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) \n+                                                        | ((b3 >> 2) & 0xf));\n+                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n+            } else if (marker0 == PAD) {\n+                //Two PAD e.g. 3c[Pad][Pad]\n+                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n+            } else if (marker1 == PAD) {\n+                //One PAD e.g. 3cQ[Pad]\n+                b3 = base64Alphabet[marker0];\n+\n+                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n+                decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) \n+                                                        | ((b3 >> 2) & 0xf));\n+            }\n+            encodedIndex += 3;\n+        }\n+        return decodedData;\n+    }\n+\n+}\n+", "timestamp": 1058728142, "metainfo": ""}