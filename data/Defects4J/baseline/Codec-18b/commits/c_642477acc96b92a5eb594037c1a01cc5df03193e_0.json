{"sha": "642477acc96b92a5eb594037c1a01cc5df03193e", "log": "[CODEC-63] Merged duplicate unit tests, added algorithm outline to class description  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/language/Nysiis.java\n+++ b/src/main/java/org/apache/commons/codec/language/Nysiis.java\n  * \n  * Encodes a string into a NYSIIS value. NYSIIS is an encoding used to relate similar names, but can also be used as a\n  * general purpose scheme to find word with similar phonemes.\n- * \n+ *\n  * <p>\n  * NYSIIS features an accuracy increase of 2.7% over the traditional Soundex algorithm.\n  * </p>\n- * \n+ *\n+ * <p>Algorithm description:\n+ * <pre>\n+ * 1. Transcode first characters of name\n+ *   1a. MAC ->   MCC\n+ *   1b. KN  ->   NN\n+ *   1c. K   ->   C\n+ *   1d. PH  ->   FF\n+ *   1e. PF  ->   FF\n+ *   1f. SCH ->   SSS\n+ * 2. Transcode last characters of name\n+ *   2a. EE, IE          ->   Y\n+ *   2b. DT,RT,RD,NT,ND  ->   D\n+ * 3. First character of key = first character of name\n+ * 4. Transcode remaining characters by following these rules, incrementing by one character each time\n+ *   4a. EV  ->   AF  else A,E,I,O,U -> A\n+ *   4b. Q   ->   G\n+ *   4c. Z   ->   S\n+ *   4d. M   ->   N\n+ *   4e. KN  ->   N   else K -> C\n+ *   4f. SCH ->   SSS\n+ *   4g. PH  ->   FF\n+ *   4h. H   ->   If previous or next is nonvowel, previous\n+ *   4i. W   ->   If previous is vowel, previous\n+ *   4j. Add current to key if current != last key character\n+ * 5. If last character is S, remove it\n+ * 6. If last characters are AY, replace with Y\n+ * 7. If last character is A, remove it\n+ * 8. Collapse all strings of repeated characters\n+ * 9. Add original first character of name as first character of key\n+ * </pre></p>\n+ *\n  * @see <a href=\"http://en.wikipedia.org/wiki/NYSIIS\">http://en.wikipedia.org/wiki/NYSIIS</a>\n  * @see <a href=\"http://www.dropby.com/NYSIIS.html\">http://www.dropby.com/NYSIIS.html</a>\n  * @see Soundex\n  */\n public class Nysiis implements StringEncoder {\n \n-    private static final char[] CHARS_A = new char[] { 'A' };\n-    private static final char[] CHARS_AF = new char[] { 'A', 'F' };\n-    private static final char[] CHARS_C = new char[] { 'C' };\n-    private static final char[] CHARS_FF = new char[] { 'F', 'F' };\n-    private static final char[] CHARS_G = new char[] { 'G' };\n-    private static final char[] CHARS_N = new char[] { 'N' };\n-    private static final char[] CHARS_NN = new char[] { 'N', 'N' };\n-    private static final char[] CHARS_S = new char[] { 'S' };\n+    private static final char[] CHARS_A   = new char[] { 'A' };\n+    private static final char[] CHARS_AF  = new char[] { 'A', 'F' };\n+    private static final char[] CHARS_C   = new char[] { 'C' };\n+    private static final char[] CHARS_FF  = new char[] { 'F', 'F' };\n+    private static final char[] CHARS_G   = new char[] { 'G' };\n+    private static final char[] CHARS_N   = new char[] { 'N' };\n+    private static final char[] CHARS_NN  = new char[] { 'N', 'N' };\n+    private static final char[] CHARS_S   = new char[] { 'S' };\n     private static final char[] CHARS_SSS = new char[] { 'S', 'S', 'S' };\n-    \n-    private static final Pattern PAT_MAC = Pattern.compile(\"^MAC\");\n-    private static final Pattern PAT_KN = Pattern.compile(\"^KN\");\n-    private static final Pattern PAT_K = Pattern.compile(\"^K\");\n-    private static final Pattern PAT_PH_PF = Pattern.compile(\"^(PH|PF)\");\n-    private static final Pattern PAT_SCH = Pattern.compile(\"^SCH\");\n-    private static final Pattern PAT_EE_IE = Pattern.compile(\"(EE|IE)$\");\n+\n+    private static final Pattern PAT_MAC    = Pattern.compile(\"^MAC\");\n+    private static final Pattern PAT_KN     = Pattern.compile(\"^KN\");\n+    private static final Pattern PAT_K      = Pattern.compile(\"^K\");\n+    private static final Pattern PAT_PH_PF  = Pattern.compile(\"^(PH|PF)\");\n+    private static final Pattern PAT_SCH    = Pattern.compile(\"^SCH\");\n+    private static final Pattern PAT_EE_IE  = Pattern.compile(\"(EE|IE)$\");\n     private static final Pattern PAT_DT_ETC = Pattern.compile(\"(DT|RT|RD|NT|ND)$\");\n-    \n+\n     private static final char SPACE = ' ';\n     private static final int TRUE_LENGTH = 6;\n \n--- a/src/test/java/org/apache/commons/codec/language/NysiisTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/NysiisTest.java\n \n package org.apache.commons.codec.language;\n \n-import java.util.Arrays;\n-import java.util.List;\n-\n import org.apache.commons.codec.EncoderException;\n import org.apache.commons.codec.StringEncoder;\n import org.apache.commons.codec.StringEncoderAbstractTest;\n         this.encodeAll(new String[] { \"Dane\", \"Dean\", \"Dionne\" }, \"DAN\");\n     }\n \n+    /**\n+     * Tests data gathered from around the internet.\n+     * \n+     * @see <a href=\"http://www.dropby.com/NYSIISTextStrings.html\">http://www.dropby.com/NYSIISTextStrings.html</a>\n+     * @throws EncoderException\n+     */\n     @Test\n     public void testDropBy() throws EncoderException {\n-        this.assertEncodings(\n+        // Explanation of differences between this implementation and the one at dropby.com is\n+        // prepended to the test string. The referenced rules refer to the outlined steps the\n+        // class description for Nysiis.\n+\n+        this.assertEncodings(\n+                // 1. Transcode first characters of name\n                 new String[] { \"MACINTOSH\", \"MCANT\" },\n-                new String[] { \"KNUTH\", \"NAT\"   },\n-                new String[] { \"KOEHN\", \"CAN\" },\n-                new String[] { \"PHILLIPSON\", \"FALAPSAN\" },\n-                new String[] { \"PFEISTER\", \"FASTAR\" },\n+                // violates 4j: the second N should not be added, as the first\n+                //              key char is already a N\n+                new String[] { \"KNUTH\", \"NAT\" },           // Original: NNAT; modified: NATH\n+                // O and E are transcoded to A because of rule 4a\n+                // H also to A because of rule 4h\n+                // the N gets mysteriously lost, maybe because of a wrongly implemented rule 4h\n+                // that skips the next char in such a case?\n+                // the remaining A is removed because of rule 7\n+                new String[] { \"KOEHN\", \"CAN\" },           // Original: C\n+                // violates 4j: see also KNUTH\n+                new String[] { \"PHILLIPSON\", \"FALAPSAN\" }, // Original: FFALAP[SAN]\n+                // violates 4j: see also KNUTH\n+                new String[] { \"PFEISTER\", \"FASTAR\" },     // Original: FFASTA[R]\n+                // violates 4j: see also KNUTH\n+                new String[] { \"SCHOENHOEFT\", \"SANAFT\" },  // Original: SSANAF[T]\n+                // 2. Transcode last characters of name:\n                 new String[] { \"MCKEE\", \"MCY\" },\n                 new String[] { \"MACKIE\", \"MCY\" },\n                 new String[] { \"HEITSCHMIDT\", \"HATSNAD\" },\n                 new String[] { \"HURD\", \"HAD\" },\n                 new String[] { \"HUNT\", \"HAD\" },\n                 new String[] { \"WESTERLUND\", \"WASTARLAD\" },\n-                new String[] { \"CASSTEVENS\", \"CASTAFAN\" },\n-                new String[] { \"VASQUEZ\", \"VASG\" },\n-                new String[] { \"FRAZIER\", \"FRASAR\" },\n-                new String[] { \"BOWMAN\", \"BANAN\" },\n-                new String[] { \"RICKERT\", \"RACAD\" },\n-                new String[] { \"DEUTSCH\", \"DAT\" },\n-                new String[] { \"WESTPHAL\", \"WASTFAL\" },\n-                new String[] { \"SHRIVER\", \"SRAVAR\" },\n-                new String[] { \"KUHL\", \"CAL\" },\n-                new String[] { \"RAWSON\", \"RASAN\" },\n-                new String[] { \"JILES\", \"JAL\" },\n-                new String[] { \"CARRAWAY\", \"CARY\" },\n-                new String[] { \"YAMADA\", \"YANAD\" });\n-    }\n-\n-    /**\n-     * Tests data gathered from around the internets.\n-     * \n-     * @throws EncoderException\n-     */\n-    @Test\n-    public void testDropBy2() throws EncoderException {\n-        // Explanation of differences between this implementation and the one at dropby.com.\n-        //\n-        // Algorithm (taken from www.dropby.com/NYSIIS.html):\n-        //\n-        // 1.  Transcode first characters of name:\n-        //    MAC >   MCC\n-        //    KN  >   NN\n-        //    K   >   C\n-        //    PH  >   FF\n-        //    PF  >   FF\n-        //    SCH >   SSS\n-        //\n-        // 2.  Transcode last characters of name:\n-        //    EE, IE  >   Y\n-        //    DT,RT,RD,NT,ND  >   D\n-        //\n-        // 3.  First character of key = first character of name.\n-        //\n-        // 4.  Transcode remaining characters by following these rules, incrementing by one character each time:\n-        //   4a.   EV  >   AF  else A,E,I,O,U > A\n-        //   4b.   Q   >   G\n-        //   4c.   Z   >   S\n-        //   4d.   M   >   N\n-        //   4e.   KN  >   N   else K > C\n-        //   4f.   SCH >   SSS\n-        //   4g.   PH  >   FF\n-        //   4h.   H   >   If previous or next is nonvowel, previous\n-        //   4i.   W   >   If previous is vowel, previous\n-        //   4j.   Add current to key if current != last key character\n-        //\n-        // 5.  If last character is S, remove it\n-        // 6.  If last characters are AY, replace with Y\n-        // 7.  If last character is A, remove it\n-        // 8.  Collapse all strings of repeated characters\n-        // 9.  Add original first character of name as first character of key\n-\n-        this.assertEncodings(\n-                // http://www.dropby.com/indexLF.html?content=/NYSIIS.html\n-                // 1. Transcode first characters of name\n-                new String[] { \"MACINTOSH\", \"MCANT\" },\n-                // violates 4j: the second N should not be added, as the first\n-                //              key char is already a N\n-                new String[] { \"KNUTH\", \"NAT\" }, // Original: NNAT; modified: NATH\n-                // O and E are transcoded to A because of rule 4a\n-                // H also to A because of rule 4h\n-                // the N gets mysteriously lost, maybe because of a wrongly implemented rule 4h\n-                // that skips the next char in such a case?\n-                // the remaining A is removed because of rule 7\n-                new String[] { \"KOEHN\", \"CAN\" }, // Original: C\n-                // violates 4j: see also KNUTH\n-                new String[] { \"PHILLIPSON\", \"FALAPSAN\" }, // Original: FFALAP[SAN]\n-                // violates 4j: see also KNUTH\n-                new String[] { \"PFEISTER\", \"FASTAR\" }, // Original: FFASTA[R]\n-                // violates 4j: see also KNUTH\n-                new String[] { \"SCHOENHOEFT\", \"SANAFT\" }, // Original: SSANAF[T]\n-                // http://www.dropby.com/indexLF.html?content=/NYSIIS.html\n-                // 2.Transcode last characters of name: \n-                new String[] { \"MCKEE\", \"MCY\" },\n-                new String[] { \"MACKIE\", \"MCY\" },\n-                new String[] { \"HEITSCHMIDT\", \"HATSNAD\" },\n-                new String[] { \"BART\", \"BAD\" },\n-                new String[] { \"HURD\", \"HAD\" },\n-                new String[] { \"HUNT\", \"HAD\" },\n-                new String[] { \"WESTERLUND\", \"WASTARLAD\" },\n-                // http://www.dropby.com/indexLF.html?content=/NYSIIS.html\n-                // 4. Transcode remaining characters by following these rules, incrementing by one character each time: \n+                // 4. Transcode remaining characters by following these rules,\n+                //    incrementing by one character each time:\n                 new String[] { \"CASSTEVENS\", \"CASTAFAN\" },\n                 new String[] { \"VASQUEZ\", \"VASG\" },\n                 new String[] { \"FRAZIER\", \"FRASAR\" },\n                 // violates 5: the last S is not removed\n                 // when comparing to DEUTS, which is phonetically similar\n                 // the result it also DAT, which is correct for DEUTSCH too imo\n-                new String[] { \"DEUTSCH\", \"DAT\" }, // Original: DATS\n+                new String[] { \"DEUTSCH\", \"DAT\" },         // Original: DATS\n                 new String[] { \"WESTPHAL\", \"WASTFAL\" },\n                 // violates 4h: the H should be transcoded to S and thus ignored as\n                 // the first key character is also S\n-                new String[] { \"SHRIVER\", \"SRAVAR\" }, // Original: SHRAVA[R]\n+                new String[] { \"SHRIVER\", \"SRAVAR\" },      // Original: SHRAVA[R]\n                 // same as KOEHN, the L gets mysteriously lost\n-                new String[] { \"KUHL\", \"CAL\" }, // Original: C\n+                new String[] { \"KUHL\", \"CAL\" },            // Original: C\n                 new String[] { \"RAWSON\", \"RASAN\" },\n                 // If last character is S, remove it\n                 new String[] { \"JILES\", \"JAL\" },\n                 // violates 6: if the last two characters are AY, remove A\n-                new String[] { \"CARRAWAY\", \"CARY\" }, // Original: CARAY\n+                new String[] { \"CARRAWAY\", \"CARY\" },       // Original: CARAY\n                 new String[] { \"YAMADA\", \"YANAD\" });\n     }\n ", "timestamp": 1331317329, "metainfo": ""}