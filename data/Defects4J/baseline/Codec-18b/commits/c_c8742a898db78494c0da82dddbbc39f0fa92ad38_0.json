{"sha": "c8742a898db78494c0da82dddbbc39f0fa92ad38", "log": "reverting r1447443 while we discuss it  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64.java\n         }\n     }\n \n-    @Override\n-    public byte[] decode(final byte[] pArray) {\n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n-        }\n-        return ApacheModifiedMiGBase64.decode(pArray);\n-    }\n-\n-    @Override\n-    public byte[] encode(final byte[] pArray) {\n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n-        }\n-        return ApacheModifiedMiGBase64.encodeToByte(\n-                pArray, lineSeparator != null, isUrlSafe(), Integer.MAX_VALUE, lineSeparator, lineLength\n-        );\n-    }\n-\n-\n     /**\n      * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n      * method treats whitespace as valid.\n      * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\n      */\n     public static String encodeBase64String(final byte[] binaryData) {\n-        return ApacheModifiedMiGBase64.encodeToString(\n-                binaryData, false, false, Integer.MAX_VALUE\n-        );\n+        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String encodeBase64URLSafeString(final byte[] binaryData) {\n-        return ApacheModifiedMiGBase64.encodeToString(\n-                binaryData, false, true, Integer.MAX_VALUE\n-        );\n+        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n     }\n \n     /**\n      */\n     public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,\n                                       final boolean urlSafe, final int maxResultSize) {\n-        return ApacheModifiedMiGBase64.encodeToByte(\n-                binaryData, isChunked, urlSafe, maxResultSize\n-        );\n-    }\n-\n+        if (binaryData == null || binaryData.length == 0) {\n+            return binaryData;\n+        }\n+\n+        // Create this so can use the super-class method\n+        // Also ensures that the same roundings are performed by the ctor and the code\n+        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n+        final long len = b64.getEncodedLength(binaryData);\n+        if (len > maxResultSize) {\n+            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n+                len +\n+                \") than the specified maximum size of \" +\n+                maxResultSize);\n+        }\n+\n+        return b64.encode(binaryData);\n+    }\n \n     /**\n      * Decodes a Base64 String into octets\n      * @since 1.4\n      */\n     public static byte[] decodeBase64(final String base64String) {\n-        if (base64String == null) { return null; }\n-        if (\"\".equals(base64String)) { return new byte[0]; }\n-\n-        return ApacheModifiedMiGBase64.decode(base64String.toCharArray());\n+        return new Base64().decode(base64String);\n     }\n \n     /**\n      * @return Array containing decoded data.\n      */\n     public static byte[] decodeBase64(final byte[] base64Data) {\n-        if (base64Data == null || base64Data.length == 0) { return base64Data; }\n-\n-        return ApacheModifiedMiGBase64.decode(base64Data);\n+        return new Base64().decode(base64Data);\n     }\n \n     // Implementation of the Encoder Interface", "timestamp": 1361241918, "metainfo": ""}