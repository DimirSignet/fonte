{"sha": "114830d0f1c0ae96b9b546849e2766694fd3e1e4", "log": "Refactor: Use byte[] from ensureBufferSize() instead of always deferencing it from the context.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64.java\n             if (0 == context.modulus && lineLength == 0) {\n                 return; // no leftovers to process and not using chunking\n             }\n-            ensureBufferSize(encodeSize, context);\n+            final byte[] buffer = ensureBufferSize(encodeSize, context);\n             int savedPos = context.pos;\n             switch (context.modulus) { // 0-2\n                 case 1 : // 8 bits = 6 + 2\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n-                ensureBufferSize(encodeSize, context);\n+                final byte[] buffer = ensureBufferSize(encodeSize, context);\n                 context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n                 int b = in[inPos++];\n                 if (b < 0) {\n             context.eof = true;\n         }\n         for (int i = 0; i < inAvail; i++) {\n-            ensureBufferSize(decodeSize, context);\n+            final byte[] buffer = ensureBufferSize(decodeSize, context);\n             byte b = in[inPos++];\n             if (b == PAD) {\n                 // We're done.\n                         context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n                         context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n                         if (context.modulus == 0) {\n-                            context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\n-                            context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n-                            context.buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);\n+                            buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\n+                            buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n+                            buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);\n                         }\n                     }\n                 }\n         // EOF (-1) and first time '=' character is encountered in stream.\n         // This approach makes the '=' padding characters completely optional.\n         if (context.eof && context.modulus != 0) {\n-            ensureBufferSize(decodeSize, context);\n+            final byte[] buffer = ensureBufferSize(decodeSize, context);\n \n             // We have some spare bits remaining\n             // Output all whole multiples of 8 bits and ignore the rest\n            //       break;\n                 case 2 : // 12 bits = 8 + 4\n                     context.ibitWorkArea = context.ibitWorkArea >> 4; // dump the extra 4 bits\n-                    context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\n+                    buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\n                     break;\n                 case 3 : // 18 bits = 8 + 8 + 2\n                     context.ibitWorkArea = context.ibitWorkArea >> 2; // dump 2 bits\n-                    context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n-                    context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\n+                    buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\n                     break;\n             }\n         }", "timestamp": 1346337605, "metainfo": ""}