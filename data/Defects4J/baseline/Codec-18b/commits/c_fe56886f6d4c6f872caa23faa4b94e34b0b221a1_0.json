{"sha": "fe56886f6d4c6f872caa23faa4b94e34b0b221a1", "log": "[CODEC-130] Base64InputStream.skip skips underlying stream, not output. Better exception information. Less verbose code with a single return. Order methods AB.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\n  */\n public class BaseNCodecInputStream extends FilterInputStream {\n \n+    private final BaseNCodec baseNCodec;\n+\n     private final boolean doEncode;\n-\n-    private final BaseNCodec baseNCodec;\n \n     private final byte[] singleByte = new byte[1];\n \n         this.baseNCodec = baseNCodec;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,\n+     * <code>1</code> otherwise\n+     */\n+    public int available() throws IOException {\n+        // Note: the logic is similar to the InflaterInputStream:\n+        //       as long as we have not reached EOF, indicate that there is more\n+        //       data available. As we do not know for sure how much data is left,\n+        //       just return 1 as a safe guess.\n+\n+        // use the EOF flag of the underlying codec instance\n+        return baseNCodec.eof ? 0 : 1;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @return false\n+     */\n+    @Override\n+    public boolean markSupported() {\n+        return false; // not an easy job to support marks\n+    }\n     /**\n      * Reads one <code>byte</code> from this input stream.\n      * \n             return readLen;\n         }\n     }\n-    /**\n-     * {@inheritDoc}\n-     * \n-     * @return false\n-     */\n-    @Override\n-    public boolean markSupported() {\n-        return false; // not an easy job to support marks\n-    }\n \n     /**\n      * {@inheritDoc}\n     @Override\n     public long skip(long n) throws IOException {\n         if (n < 0) {\n-            throw new IllegalArgumentException(\"Negative skip length\");\n+            throw new IllegalArgumentException(\"Negative skip length: \" + n);\n         }\n \n         // skip in chunks of 512 bytes\n \n         return total;\n     }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,\n-     * <code>1</code> otherwise\n-     */\n-    public int available() throws IOException {\n-        // Note: the logic is similar to the InflaterInputStream:\n-        //       as long as we have not reached EOF, indicate that there is more\n-        //       data available. As we do not know for sure how much data is left,\n-        //       just return 1 as a safe guess.\n-\n-        // use the EOF flag of the underlying codec instance\n-        if (baseNCodec.eof) {\n-            return 0;\n-        } else {\n-            return 1;\n-        }\n-    }\n }", "timestamp": 1332186480, "metainfo": ""}