{"sha": "2c13032a16e37b7bc9e0272d25fc185b5c82b42e", "log": "[CODEC-105] ArrayIndexOutOfBoundsException when doing multiple reads() on encoding b64InputStream. https://issues.apache.org/jira/browse/CODEC-105  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n     int readResults(byte[] b, int bPos, int bAvail) {\n         if (buffer != null) {\n             int len = Math.min(avail(), bAvail);\n-            if (buffer != b) {\n-                System.arraycopy(buffer, readPos, b, bPos, len);\n-                readPos += len;\n-                if (readPos >= pos) {\n-                    buffer = null;\n-                }\n-            } else {\n-                // Re-using the original consumer's output array is only\n-                // allowed for one round.\n+            System.arraycopy(buffer, readPos, b, bPos, len);\n+            readPos += len;\n+            if (readPos >= pos) {\n                 buffer = null;\n             }\n             return len;\n         }\n         return eof ? -1 : 0;\n-    }\n-\n-    /**\n-     * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n-     * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n-     * \n-     * @param out\n-     *            byte[] array to buffer directly to.\n-     * @param outPos\n-     *            Position to start buffering into.\n-     * @param outAvail\n-     *            Amount of bytes available for direct buffering.\n-     */\n-    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n-        // We can re-use consumer's original output array under\n-        // special circumstances, saving on some System.arraycopy().\n-        if (out != null && out.length == outAvail) {\n-            buffer = out;\n-            pos = outPos;\n-            readPos = outPos;\n-        }\n     }\n \n     /**\n                     }\n                     break;\n             }\n-            if (lineLength > 0 && pos > 0) {\n+            // Don't want to append the CRLF two times in a row, so make sure previous\n+            // character is not from CRLF!\n+            byte b = lineSeparator[lineSeparator.length - 1];\n+            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n                 System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         if (pArray == null || pArray.length == 0) {\n             return pArray;\n         }\n-        long len = (pArray.length * 3) / 4;\n-        byte[] buf = new byte[(int) len];\n-        setInitialBuffer(buf, 0, buf.length);\n         decode(pArray, 0, pArray.length);\n         decode(pArray, 0, -1); // Notify decoder of EOF.\n-\n-        // Would be nice to just return buf (like we sometimes do in the encode\n-        // logic), but we have no idea what the line-length was (could even be\n-        // variable).  So we cannot determine ahead of time exactly how big an\n-        // array is necessary.  Hence the need to construct a 2nd byte array to\n-        // hold the final result:\n-\n         byte[] result = new byte[pos];\n         readResults(result, 0, result.length);\n         return result;\n         if (pArray == null || pArray.length == 0) {\n             return pArray;\n         }\n-        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n-        byte[] buf = new byte[(int) len];\n-        setInitialBuffer(buf, 0, buf.length);\n         encode(pArray, 0, pArray.length);\n         encode(pArray, 0, -1); // Notify encoder of EOF.\n-        // Encoder might have resized, even though it was unnecessary.\n-        if (buffer != buf) {\n-            readResults(buf, 0, buf.length);\n-        }\n-        // In URL-SAFE mode we skip the padding characters, so sometimes our\n-        // final length is a bit smaller.\n-        if (isUrlSafe() && pos < buf.length) {\n-            byte[] smallerBuf = new byte[pos];\n-            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n-            buf = smallerBuf;\n-        }\n-        return buf;        \n+        byte[] buf = new byte[pos - readPos];\n+        readResults(buf, 0, buf.length);\n+        return buf;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n                 if (!base64.hasData()) {\n                     byte[] buf = new byte[doEncode ? 4096 : 8192];\n                     int c = in.read(buf);\n-                    // A little optimization to avoid System.arraycopy()\n-                    // when possible.\n-                    if (c > 0 && b.length == len) {\n-                        base64.setInitialBuffer(b, offset, len);\n-                    }\n                     if (doEncode) {\n                         base64.encode(buf, 0, c);\n                     } else {\n--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n \n import java.io.BufferedReader;\n import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.util.Arrays;\n      */\n     public Base64InputStreamTest(String name) {\n         super(name);\n+    }\n+\n+    /**\n+     * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.\n+     */\n+    public void testCodec105() throws IOException {\n+        Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\n+        for (int i = 0; i < 5; i++) {\n+            in.read();\n+        }\n     }\n \n     /**\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/binary/Codec105ErrorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * Emits three line-feeds '\\n' in a row, one at a time, and then EOF.\n+ * \n+ * Recreates the bug described in CODEC-105.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @since 1.5\n+ */\n+public class Codec105ErrorInputStream extends InputStream {\n+    private static final int EOF = -1;\n+\n+    int countdown = 3;\n+\n+    public int read() throws IOException {\n+        if (this.countdown-- > 0) {\n+            return '\\n';\n+        } else {\n+            return EOF;\n+        }\n+    }\n+\n+    public int read(byte b[], int pos, int len) throws IOException {\n+        if (this.countdown-- > 0) {\n+            b[pos] = '\\n';\n+            return 1;\n+        } else {\n+            return EOF;\n+        }\n+    }\n+}", "timestamp": 1295829969, "metainfo": ""}