{"sha": "1573a121c4fa7b39f4f49691cc5fde3cccf4c7a1", "log": "[CODEC-125] Implement a Beider-Morse phonetic matching codec. First commit. Thank you to Matthew Pocock for the contribution. TODO: PMD rules show code that needs to be changed to use StringBuffer in PhoneticEngine.  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * <p>\n+ * Encodes strings into their Beider-Morse phonetic encoding.\n+ * </p>\n+ * <p>\n+ * Beider-Morse phonetic encodings are optimised for family names. However, they may be useful for a wide range of words.\n+ * </p>\n+ * <p>\n+ * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it is mutable, and may not be\n+ * thread-safe. If you require a guaranteed thread-safe encoding then use {@link PhoneticEngine} directly.\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+public class BeiderMorseEncoder implements StringEncoder {\n+    // a cached object\n+    private PhoneticEngine engine = new PhoneticEngine(NameType.GENERIC, RuleType.APPROX, true);\n+\n+    public Object encode(Object source) throws EncoderException {\n+        if (!(source instanceof String)) {\n+            throw new EncoderException(\"BeiderMorseEncoder encode parameter is not of type String\");\n+        }\n+        return encode((String) source);\n+    }\n+\n+    public String encode(String source) throws EncoderException {\n+        if (source == null) {\n+            return null;\n+        }\n+        return this.engine.encode(source);\n+    }\n+\n+    /**\n+     * Gets the name type currently in operation.\n+     * \n+     * @return the NameType currently being used\n+     */\n+    public NameType getNameType() {\n+        return this.engine.getNameType();\n+    }\n+\n+    /**\n+     * Gets the rule type currently in operation.\n+     * \n+     * @return the RuleType currently being used\n+     */\n+    public RuleType getRuleType() {\n+        return this.engine.getRuleType();\n+    }\n+\n+    /**\n+     * Discovers if multiple possible encodings are concatenated.\n+     * \n+     * @return true if multiple encodings are concatenated, false if just the first one is returned\n+     */\n+    public boolean isConcat() {\n+        return this.engine.isConcat();\n+    }\n+\n+    /**\n+     * Sets how multiple possible phonetic encodings are combined.\n+     * \n+     * @param concat\n+     *            true if multiple encodings are to be combined with a '|', false if just the first one is to be considered\n+     */\n+    public void setConcat(boolean concat) {\n+        this.engine = new PhoneticEngine(this.engine.getNameType(), this.engine.getRuleType(), concat);\n+    }\n+\n+    /**\n+     * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phoentic encodings optimized for Ashkenazi or\n+     * Sephardic Jewish family names.\n+     * \n+     * @param nameType\n+     *            the NameType in use\n+     */\n+    public void setNameType(NameType nameType) {\n+        this.engine = new PhoneticEngine(nameType, this.engine.getRuleType(), this.engine.isConcat());\n+    }\n+\n+    /**\n+     * Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.\n+     * \n+     * @param ruleType\n+     *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches\n+     */\n+    public void setRuleType(RuleType ruleType) {\n+        this.engine = new PhoneticEngine(this.engine.getNameType(), ruleType, this.engine.isConcat());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/language/bm/Lang.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * <p>\n+ * Language guessing utility.\n+ * </p>\n+ * <p>\n+ * This class encapsulates rules used to guess the possible languages that a word originates from. This is done by reference to a whole\n+ * series of rules distributed in resource files.\n+ * </p>\n+ * <p>\n+ * Instances of this class are typically managed through the static factory method instance(). Unless you are developing your own language\n+ * guessing rules, you will not need to interact with this class directly.\n+ * </p>\n+ * <p>\n+ * This class is intended to be immutable and thread-safe.\n+ * </p>\n+ * <h2>Lang resources</h2\n+ * <p>\n+ * Language guessing rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically named\n+ * following the pattern: <blockquote>org/apache/commons/codec/language/bm/lang.txt</blockquote> The format of these resources is the\n+ * following:\n+ * </p>\n+ * <ul>\n+ * <li><b>Rules:</b> whitespace separated strings. There should be 3 columns to each row, and these will be interpreted as:\n+ * <ol>\n+ * <li>pattern: a regular expression.</li>\n+ * <li>languages: a '+'-separated list of languages.</li>\n+ * <li>acceptOnMatch: 'true' or 'false' indicating if a match rules in or rules out the language.</li>\n+ * </ol>\n+ * </li>\n+ * <li><b>End-of-line comments:</b> Any occurance of '//' will cause all text following on that line to be discarded as a comment.</li>\n+ * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip all content until a\n+ * line ending in '*' and '/' is found.</li>\n+ * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n+ * </ul>\n+ * <p/>\n+ * Port of lang.php\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+public class Lang {\n+\n+    private static class LangRule {\n+        private boolean acceptOnMatch;\n+        private Set<String> languages;\n+        private Pattern pattern;\n+\n+        private LangRule(Pattern pattern, Set<String> languages, boolean acceptOnMatch) {\n+            this.pattern = pattern;\n+            this.languages = languages;\n+            this.acceptOnMatch = acceptOnMatch;\n+        }\n+\n+        public boolean matches(String txt) {\n+            return this.pattern.matcher(txt).find();\n+        }\n+    }\n+\n+    private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class);\n+\n+    private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/lang.txt\";\n+\n+    static {\n+        for (NameType s : NameType.values()) {\n+            Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.instance(s)));\n+        }\n+    }\n+\n+    /**\n+     * Gets a Lang instance for one of the supported NameTypes.\n+     * \n+     * @param nameType\n+     *            the NameType to look up\n+     * @return a Lang encapsulating the language guessing rules for that name type\n+     */\n+    public static Lang instance(NameType nameType) {\n+        return Langs.get(nameType);\n+    }\n+\n+    /**\n+     * <p>\n+     * Loads language rules from a resource.\n+     * </p>\n+     * <p>\n+     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method. You will only need to call this\n+     * yourself if you are developing custom language mapping rules.\n+     * </p>\n+     * \n+     * @param languageRulesResourceName\n+     *            the fully-qualified resource name to load\n+     * @param languages\n+     *            the languages that these rules will support\n+     * @return a Lang encapsulating the loaded language-guessing rules.\n+     */\n+    public static Lang loadFromResource(String languageRulesResourceName, Languages languages) {\n+        List<LangRule> rules = new ArrayList<LangRule>();\n+        InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\n+\n+        if (lRulesIS == null) {\n+            throw new IllegalStateException(\"Unable to resolve required resource:\" + LANGUAGE_RULES_RN);\n+        }\n+\n+        Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\n+        boolean inExtendedComment = false;\n+        while (scanner.hasNextLine()) {\n+            String rawLine = scanner.nextLine();\n+            String line = rawLine;\n+\n+            if (inExtendedComment) {\n+                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n+                    inExtendedComment = false;\n+                } else {\n+                    // discard doc comment line\n+                }\n+            } else {\n+                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n+                    inExtendedComment = true;\n+                } else {\n+                    // discard comments\n+                    int cmtI = line.indexOf(ResourceConstants.CMT);\n+                    if (cmtI >= 0) {\n+                        // System.err.println(\"index of comment: \" + cmtI);\n+                        line = line.substring(0, cmtI);\n+                    }\n+\n+                    // trim leading-trailing whitespace\n+                    line = line.trim();\n+\n+                    if (line.length() == 0)\n+                        continue; // empty lines can be safely skipped\n+\n+                    // split it up\n+                    String[] parts = line.split(\"\\\\s+\");\n+                    // System.err.println(\"part count: \" + parts.length);\n+\n+                    if (parts.length != 3) {\n+                        // fixme: we really need to log this somewhere\n+                        System.err.println(\"Warning: malformed line '\" + rawLine + \"'\");\n+                        continue;\n+                    }\n+\n+                    Pattern pattern = Pattern.compile(parts[0]);\n+                    String[] langs = parts[1].split(\"\\\\+\");\n+                    boolean accept = parts[2].equals(\"true\");\n+\n+                    rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\n+                }\n+            }\n+        }\n+\n+        return new Lang(rules, languages);\n+    }\n+\n+    private final Languages languages;\n+    private final List<LangRule> rules;\n+\n+    private Lang(List<LangRule> rules, Languages languages) {\n+        this.rules = Collections.unmodifiableList(rules);\n+        this.languages = languages;\n+    }\n+\n+    /**\n+     * Guesses the language of a word.\n+     * \n+     * @param text\n+     *            the word\n+     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match\n+     */\n+    public String guessLanguage(String text) {\n+        Set<String> ls = guessLanguages(text);\n+        if (ls.size() == 1) {\n+            return ls.iterator().next();\n+        } else {\n+            return Languages.ANY;\n+        }\n+    }\n+\n+    /**\n+     * Guesses the languages of a word.\n+     * \n+     * @param text\n+     *            the word\n+     * @return a Set of Strings of language names that are potential matches for the word\n+     */\n+    public Set<String> guessLanguages(String text) {\n+        text = text.toLowerCase(); // todo: locale?\n+        // System.out.println(\"Testing text: '\" + text + \"'\");\n+\n+        Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n+        for (LangRule rule : this.rules) {\n+            if (rule.matches(text)) {\n+                // System.out.println(\"Rule \" + rule.pattern + \" matches \" + text);\n+                if (rule.acceptOnMatch) {\n+                    // System.out.println(\"Retaining \" + rule.languages);\n+                    langs.retainAll(rule.languages);\n+                } else {\n+                    // System.out.println(\"Removing \" + rule.languages);\n+                    langs.removeAll(rule.languages);\n+                }\n+                // System.out.println(\"Current languages: \" + langs);\n+            } else {\n+                // System.out.println(\"Rule \" + rule.pattern + \" does not match \" + text);\n+            }\n+        }\n+\n+        return langs;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/language/bm/Languages.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+\n+/**\n+ * <p>\n+ * Language codes.\n+ * </p>\n+ * <p>\n+ * Language codes are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically named following the\n+ * pattern:\n+ * </p>\n+ * <blockquote>org/apache/commons/codec/language/bm/${{@link NameType#getName()} languages.txt</blockquote>\n+ * <p>\n+ * The format of these resources is the following:\n+ * </p>\n+ * <ul>\n+ * <li><b>Language:</b> a single string containing no whitespace</li>\n+ * <li><b>End-of-line comments:</b> Any occurance of '//' will cause all text following on that line to be discarded as a comment.</li>\n+ * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip all content until a\n+ * line ending in '*' and '/' is found.</li>\n+ * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n+ * </ul>\n+ * <p>\n+ * Ported from language.php\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+public class Languages {\n+\n+    public static final String ANY = \"any\";\n+\n+    private static final Map<NameType, Languages> LANGUAGES = new EnumMap<NameType, Languages>(NameType.class);\n+\n+    static {\n+        for (NameType s : NameType.values()) {\n+            LANGUAGES.put(s, instance(langResourceName(s)));\n+        }\n+    }\n+\n+    public static Languages instance(NameType nameType) {\n+        return LANGUAGES.get(nameType);\n+    }\n+\n+    public static Languages instance(String languagesResourceName) {\n+        // read languages list\n+        Set<String> ls = new HashSet<String>();\n+        InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName);\n+\n+        if (langIS == null) {\n+            throw new IllegalArgumentException(\"Unable to resolve required resource: \" + languagesResourceName);\n+        }\n+\n+        Scanner lsScanner = new Scanner(langIS, ResourceConstants.ENCODING);\n+        boolean inExtendedComment = false;\n+        while (lsScanner.hasNextLine()) {\n+            String line = lsScanner.nextLine().trim();\n+            if (inExtendedComment) {\n+                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n+                    inExtendedComment = false;\n+                } else {\n+                    // skip\n+                }\n+            } else {\n+                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n+                    inExtendedComment = true;\n+                } else if (line.length() > 0) {\n+                    ls.add(line);\n+                } else {\n+                    // skip blank lines\n+                }\n+            }\n+        }\n+\n+        return new Languages(Collections.unmodifiableSet(ls));\n+    }\n+\n+    private static String langResourceName(NameType nameType) {\n+        return String.format(\"org/apache/commons/codec/language/bm/%s_languages.txt\", nameType.getName());\n+    }\n+\n+    private final Set<String> languages;\n+\n+    private Languages(Set<String> languages) {\n+        this.languages = languages;\n+    }\n+\n+    public Set<String> getLanguages() {\n+        return this.languages;\n+    }\n+\n+    // // The original code mapped sets of languages to unique numerical codes - this doesn't seem to be needed in this impl\n+    // public static Languages instance(String languagesResourceName)\n+    // {\n+    // // read languages list\n+    // Map<String, Integer> ls = new HashMap<String, Integer>();\n+    // InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName);\n+    //\n+    // if(langIS == null)\n+    // throw new IllegalArgumentException(\"Unable to resolve required resource: \" + languagesResourceName);\n+    //\n+    // Scanner lsScanner = new Scanner(langIS);\n+    // int i = 0;\n+    // while(lsScanner.hasNextLine()) {\n+    // String line = lsScanner.nextLine();\n+    // i++;\n+    // ls.put(line.trim(), i^2);\n+    // }\n+    //\n+    // return new Languages(Collections.unmodifiableSet(ls.keySet()), Collections.unmodifiableMap(ls));\n+    // }\n+    //\n+    // // todo: phoneticutils.php: LanguageIndex, LanguageName, LanguageCode, LanguageIndexFromCode\n+    //\n+    //\n+    // private final Set<String> languages;\n+    // private final Map<String, Integer> language_codes;\n+    //\n+    // private Languages(Set<String> languages, Map<String, Integer> language_codes) {\n+    // this.languages = languages;\n+    // this.language_codes = language_codes;\n+    // }\n+    //\n+    // public Set<String> getLanguages() {\n+    // return languages;\n+    // }\n+    //\n+    // public Map<String, Integer> getLanguage_codes() {\n+    // return language_codes;\n+    // }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/language/bm/NameType.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+/**\n+ * Supported types of names. Unless you are matching particular family names, use {@link #GENERIC}.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+public enum NameType {\n+    /** Ashkenazi family names */\n+    ASHKENAZI(\"ash\"),\n+    /** Generic names and words */\n+    GENERIC(\"gen\"),\n+    /** Sephardic family names */\n+    SEPHARDIC(\"sep\");\n+\n+    private final String name;\n+\n+    NameType(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Gets the short version of the name type.\n+     * \n+     * @return the NameType short string\n+     */\n+    public String getName() {\n+        return this.name;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * <p>\n+ * Conversion of words into potential phonetic representations.\n+ * </p>\n+ * <p>\n+ * This is a two-stage process. Firstly, the word is converted into a phonetic representation that takes into account the likely source\n+ * language. Next, this phonetic representation is converted into a pan-european 'average' representation, allowing comparison between\n+ * different versions of essentially the same word from different languages.\n+ * </p>\n+ * <p>\n+ * This class is intentionally immutable. If you wish to alter the settings for a PhoneticEngine, you must make a new one with the updated\n+ * settings. This makes the class thread-safe.\n+ * </p>\n+ * <p>\n+ * Ported from phoneticengine.php\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+public class PhoneticEngine {\n+    private static final Map<NameType, Set<String>> namePfxs = new EnumMap<NameType, Set<String>>(NameType.class);\n+\n+    static {\n+        namePfxs.put(NameType.ASHKENAZI,\n+                Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\"))));\n+        namePfxs.put(NameType.SEPHARDIC, Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\",\n+                \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n+        namePfxs.put(NameType.GENERIC, Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\",\n+                \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n+    }\n+\n+    private final Lang lang;\n+\n+    private final NameType nameType;\n+\n+    private final RuleType ruleType;\n+\n+    private final boolean concat;\n+\n+    /**\n+     * Generates a new, fully-configured phonetic engine.\n+     * \n+     * @param nameType\n+     *            the type of names it will use\n+     * @param ruleType\n+     *            the type of rules it will apply\n+     * @param concat\n+     *            if it will concatenate multiple encodings\n+     */\n+    public PhoneticEngine(NameType nameType, RuleType ruleType, boolean concat) {\n+        if (ruleType == RuleType.RULES) {\n+            throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES);\n+        }\n+        this.nameType = nameType;\n+        this.ruleType = ruleType;\n+        this.concat = concat;\n+        this.lang = Lang.instance(nameType);\n+    }\n+\n+    /**\n+     * Gets the Lang language guessing rules being used.\n+     * \n+     * @return the Lang in use\n+     */\n+    public Lang getLang() {\n+        return this.lang;\n+    }\n+\n+    /**\n+     * Gets the NameType being used.\n+     * \n+     * @return the NameType in use\n+     */\n+    public NameType getNameType() {\n+        return this.nameType;\n+    }\n+\n+    /**\n+     * Gets the RuleType being used.\n+     * \n+     * @return the RuleType in use\n+     */\n+    public RuleType getRuleType() {\n+        return this.ruleType;\n+    }\n+\n+    /**\n+     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n+     * \n+     * @return true if multiple phonetic encodings are returned, false if just the first is.\n+     */\n+    public boolean isConcat() {\n+        return this.concat;\n+    }\n+\n+    /**\n+     * Encodes a string to its phonetic representation.\n+     * \n+     * @param input\n+     *            the String to encode\n+     * @return the encoding of the input\n+     */\n+    public String encode(String input) {\n+        Set<String> languageArg = this.lang.guessLanguages(input);\n+        return phoneticUtf8(input, languageArg);\n+    }\n+\n+    /**\n+     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.\n+     * \n+     * @param input\n+     *            String to phoneticise; a String with dashes or spaces separating each word\n+     * @param languageArg\n+     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the input\n+     */\n+    public String phoneticUtf8(String input, final Set<String> languageArg) {\n+        List<Rule> rules = Rule.instance(this.nameType, RuleType.RULES, languageArg);\n+        List<Rule> finalRules1 = Rule.instance(this.nameType, this.ruleType, \"common\");\n+        List<Rule> finalRules2 = Rule.instance(this.nameType, this.ruleType, languageArg);\n+\n+        // tidy the input\n+        // lower case is a locale-dependent operation\n+        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n+\n+        if (this.nameType == NameType.GENERIC) {\n+            for (String l : namePfxs.get(this.nameType)) {\n+                // handle generic prefixes\n+                if (input.startsWith(l + \" \")) {\n+                    // check for any prefix in the words list\n+                    String remainder = input.substring(l.length() + 1); // input without the prefix\n+                    String combined = l + remainder; // input with prefix without space\n+                    return encode(remainder) + \"-\" + encode(combined);\n+                }\n+                // fixme: this case is invariant on l\n+                else if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) // check for d'\n+                {\n+                    String remainder = input.substring(2);\n+                    String combined = \"d\" + remainder;\n+                    return encode(remainder) + \"-\" + encode(combined);\n+                }\n+            }\n+        }\n+\n+        final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n+        final List<String> words2 = new ArrayList<String>();\n+\n+        switch (this.nameType) {\n+        case SEPHARDIC:\n+            for (String aWord : words) {\n+                String[] parts = aWord.split(\"'\");\n+                String lastPart = parts[parts.length - 1];\n+                words2.add(lastPart);\n+            }\n+            words2.removeAll(namePfxs.get(this.nameType));\n+            break;\n+        case ASHKENAZI:\n+            words2.addAll(words);\n+            words2.removeAll(namePfxs.get(this.nameType));\n+            break;\n+        case GENERIC:\n+            words2.addAll(words);\n+            break;\n+        default:\n+            throw new IllegalStateException(\"Unreachable case: \" + this.nameType);\n+        }\n+\n+        if (this.concat) {\n+            // concat mode enabled\n+            input = join(words2, \" \");\n+        } else if (words2.size() == 1) {\n+            // not a multi-word name\n+            input = words.iterator().next();\n+        } else {\n+            // encode each word in a multi-word name separately (normally used for approx matches)\n+            StringBuilder result = new StringBuilder();\n+            for (String word : words2) {\n+                result.append(\"-\").append(encode(word));\n+            }\n+            // return the result without the leading \"-\"\n+            return result.substring(1);\n+        }\n+\n+        String phonetic = \"\";\n+\n+        // loop over each char in the input - we will handle the increment manually\n+        for (int i = 0; i < input.length();) {\n+            RulesApplication rulesApplication = new RulesApplication(rules, languageArg, input, phonetic, i).invoke();\n+            i = rulesApplication.getI();\n+            phonetic = rulesApplication.getPhonetic();\n+        }\n+\n+        phonetic = applyFinalRules(phonetic, finalRules1, languageArg, false);\n+        phonetic = applyFinalRules(phonetic, finalRules2, languageArg, true);\n+\n+        return phonetic;\n+    }\n+\n+    private String removeDuplicateAlternates(final String phonetic) {\n+        List<String> altArray = splitOnPipe(phonetic);\n+\n+        String result = \"|\";\n+        for (String alt : altArray) {\n+            if (!result.contains(\"|\" + alt + \"|\")) {\n+                result += (alt + \"|\");\n+            }\n+        }\n+\n+        result = result.substring(1, result.length() - 1);\n+        return result;\n+    }\n+\n+    private String normalizeLanguageAttributes(String text, final boolean strip) {\n+        // this is applied to a single alternative at a time -- not to a parenthisized list\n+        // it removes all embedded bracketed attributes, logically-ands them together, and places them at the end.\n+\n+        // however if strip is true, this can indeed remove embedded bracketed attributes from a parenthesized list\n+\n+        Set<String> langs = new HashSet<String>();\n+\n+        int bracketStart;\n+        while ((bracketStart = text.indexOf('[')) != -1) {\n+            int bracketEnd = text.indexOf(']', bracketStart);\n+            if (bracketEnd == -1) {\n+                throw new IllegalArgumentException(\"no closing square bracket in: \" + text);\n+            }\n+\n+            String body = text.substring(bracketStart + 1, bracketEnd);\n+            langs.addAll(Arrays.asList(body.split(\"[+]\")));\n+            text = text.substring(0, bracketStart) + text.substring(bracketEnd + 1);\n+        }\n+\n+        if (langs.isEmpty() || strip) {\n+            return text;\n+        } else if (langs.contains(Languages.ANY)) {\n+            return \"[\" + Languages.ANY + \"]\";\n+        } else {\n+            return text + \"[\" + (join(langs, \"+\")) + \"]\";\n+        }\n+    }\n+\n+    private String applyFinalRules(String phonetic, List<Rule> finalRules, Set<String> languageArg, boolean strip) {\n+        if (finalRules == null) {\n+            throw new NullPointerException(\"finalRules can not be null\");\n+        }\n+        if (finalRules.isEmpty()) {\n+            return phonetic;\n+        }\n+\n+        phonetic = expand(phonetic);\n+        // must protect | in [] as split takes a regex, not a string literal\n+        List<String> phoneticArray = splitOnPipe(phonetic);\n+\n+        for (int k = 0; k < phoneticArray.size(); k++) {\n+            // log(\"k: \" + k);\n+\n+            String aPhonetic = phoneticArray.get(k);\n+            String phonetic2 = \"\";\n+\n+            String phoneticx = normalizeLanguageAttributes(aPhonetic, true);\n+            for (int i = 0; i < aPhonetic.length();) {\n+                // we will handle the increment manually\n+                if (aPhonetic.substring(i, i + 1).equals(\"[\")) {\n+                    int attribStart = i;\n+                    i++;\n+                    while (true) {\n+                        i++;\n+                        String nextChar = aPhonetic.substring(i, i + 1);\n+                        if (nextChar.equals(\"]\")) {\n+                            phonetic2 += aPhonetic.substring(attribStart, i);\n+                            break;\n+                        }\n+                    }\n+\n+                    continue;\n+                }\n+\n+                RulesApplication rulesApplication = new RulesApplication(finalRules, languageArg, phoneticx, phonetic2, i).invoke();\n+                boolean found = rulesApplication.isFound();\n+                phonetic2 = rulesApplication.getPhonetic();\n+\n+                if (!found) {\n+                    phonetic2 += aPhonetic.substring(i, i + 1);\n+                }\n+\n+                i = rulesApplication.getI();\n+            }\n+\n+            phoneticArray.set(k, expand(phonetic2));\n+        }\n+\n+        phonetic = join(phoneticArray, \"|\");\n+        if (strip) {\n+            phonetic = normalizeLanguageAttributes(phonetic, true);\n+        }\n+        if (!phonetic.contains(\"|\")) {\n+            phonetic = \"(\" + removeDuplicateAlternates(phonetic) + \")\";\n+        }\n+\n+        return phonetic;\n+    }\n+\n+    private String expand(String phonetic) {\n+        int altStart = phonetic.indexOf('(');\n+        if (altStart == -1) {\n+            return normalizeLanguageAttributes(phonetic, false);\n+        }\n+\n+        String prefix = phonetic.substring(0, altStart);\n+        altStart++;\n+        int altEnd = phonetic.indexOf(')');\n+        String altString = phonetic.substring(altStart, altEnd);\n+        altEnd++;\n+        String suffix = phonetic.substring(altEnd);\n+        List<String> altArray = splitOnPipe(altString);\n+\n+        String result = \"\";\n+        for (String alt : altArray) {\n+            String alternate = expand(prefix + alt + suffix);\n+            if (alternate.length() != 0 && !alternate.equals(\"[any]\")) {\n+                if (result.length() > 0) {\n+                    result += \"|\";\n+                }\n+                result += alternate;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private String applyRuleIfCompatible(String phonetic, String target, Set<String> languageArg) {\n+        // tests for compatible language rules\n+        // to do so, apply the rule, expand the results, and detect alternatives with incompatible attributes\n+        // then drop each alternative that has incompatible attributes and keep those that are compatible\n+        // if there are no compatible alternatives left, return false\n+        // otherwise return the compatible alternatives\n+\n+        String candidate = phonetic + target;\n+        if (!candidate.contains(\"[\")) {\n+            return candidate;\n+        }\n+\n+        candidate = expand(candidate);\n+        List<String> candidateArray = splitOnPipe(candidate);\n+\n+        candidate = \"\";\n+        boolean found = false;\n+\n+        for (String thisCandidate : candidateArray) {\n+            if (!languageArg.contains(Languages.ANY)) {\n+                thisCandidate = normalizeLanguageAttributes(thisCandidate + \"[\" + languageArg + \"]\", false);\n+            }\n+\n+            if (!thisCandidate.equals(\"[0]\")) {\n+                found = true;\n+                if (candidate.length() != 0) {\n+                    candidate += \"|\";\n+                }\n+                candidate += thisCandidate;\n+            }\n+        }\n+\n+        if (!found) {\n+            return null; // eugh!\n+        }\n+        if (candidate.contains(\"|\")) {\n+            candidate = \"(\" + candidate + \")\";\n+        }\n+\n+        return candidate;\n+    }\n+\n+    private static String join(Iterable<String> strings, String sep) {\n+        StringBuilder sb = new StringBuilder();\n+        Iterator<String> si = strings.iterator();\n+        if (si.hasNext()) {\n+            sb.append(si.next());\n+        }\n+        while (si.hasNext()) {\n+            sb.append(sep).append(si.next());\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    private static List<String> splitOnPipe(String str) {\n+        List<String> res = new ArrayList<String>();\n+\n+        while (true) {\n+            int i = str.indexOf('|');\n+            if (i < 0) {\n+                res.add(str);\n+                break;\n+            }\n+\n+            res.add(str.substring(0, i));\n+            str = str.substring(i + 1);\n+        }\n+\n+        return res;\n+    }\n+\n+    private class RulesApplication {\n+        private final List<Rule> finalRules;\n+        private final Set<String> languageArg;\n+        private final String input;\n+\n+        private String phonetic;\n+        private int i;\n+        private boolean found;\n+\n+        public RulesApplication(List<Rule> finalRules, Set<String> languageArg, String input, String phonetic, int i) {\n+            if (finalRules == null) {\n+                throw new NullPointerException(\"The finalRules argument must not be null\");\n+            }\n+            this.finalRules = finalRules;\n+            this.languageArg = languageArg;\n+            this.phonetic = phonetic;\n+            this.input = input;\n+            this.i = i;\n+        }\n+\n+        public String getPhonetic() {\n+            return this.phonetic;\n+        }\n+\n+        public int getI() {\n+            return this.i;\n+        }\n+\n+        public boolean isFound() {\n+            return this.found;\n+        }\n+\n+        public RulesApplication invoke() {\n+            this.found = false;\n+            int patternLength = 0;\n+            RULES: for (Rule rule : this.finalRules) {\n+                String pattern = rule.getPattern();\n+                patternLength = pattern.length();\n+                // log(\"trying pattern: \" + pattern);\n+\n+                if (!rule.patternAndContextMatches(this.input, this.i) || !rule.languageMatches(this.languageArg)) {\n+                    // log(\"no match\");\n+                    continue RULES;\n+                }\n+\n+                String candidate = applyRuleIfCompatible(this.phonetic, rule.getPhoneme(), this.languageArg);\n+\n+                if (candidate == null || candidate.length() == 0) {\n+                    // log(\"no candidate\");\n+                    continue RULES;\n+                }\n+                this.phonetic = candidate;\n+                this.found = true;\n+                break RULES;\n+            }\n+\n+            if (!this.found) {\n+                patternLength = 1;\n+            }\n+\n+            this.i += patternLength;\n+            return this;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/language/bm/ResourceConstants.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+/**\n+ * Constants used to process resource files.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+class ResourceConstants {\n+\n+    static final String CMT = \"//\";\n+    static final String ENCODING = \"UTF-8\";\n+    static final String EXT_CMT_END = \"*/\";\n+    static final String EXT_CMT_START = \"/*\";\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/language/bm/Rule.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * <p>\n+ * A phoneme rule.\n+ * </p>\n+ * <p>\n+ * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply and a logical flag indicating if\n+ * all lanugages must be in play. A rule matches if:\n+ * <ul>\n+ * <li>the pattern matches at the current position</li>\n+ * <li>the string up until the beginning of the pattern matches the left context</li>\n+ * <li>the string from the end of the pattern matches the right context</li>\n+ * <li>logical is ALL and all languages are in scope; or</li>\n+ * <li>logical is any other value and at least one language is in scope</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user to explicitly construct their\n+ * own.\n+ * </p>\n+ * <p>\n+ * Rules are immutable and thread-safe.\n+ * <h2>Rules resources</h2>\n+ * <p>\n+ * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically named following the pattern:\n+ * <blockquote>org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt</blockquote>\n+ * </p>\n+ * <p>\n+ * The format of these resources is the following:\n+ * <ul>\n+ * <li><b>Rules:</b> whitespace separated, double-quoted strings. There should be 4 columns to each row, and these will be interpreted as:\n+ * <ol>\n+ * <li>pattern</li>\n+ * <li>left context</li>\n+ * <li>right context</li>\n+ * <li>phoneme</li>\n+ * </ol>\n+ * </li>\n+ * <li><b>End-of-line comments:</b> Any occurance of '//' will cause all text following on that line to be discarded as a comment.</li>\n+ * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip all content until a\n+ * line ending in '*' and '/' is found.</li>\n+ * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n+ * </ul>\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+public class Rule {\n+    private static final String DOUBLE_QUOTE = \"\\\"\";\n+\n+    public static final String ALL = \"ALL\";\n+\n+    private static final String HASH_INCLUDE = \"#include\";\n+\n+    private static final Map<NameType, Map<RuleType, Map<String, List<Rule>>>> RULES = new EnumMap<NameType, Map<RuleType, Map<String, List<Rule>>>>(\n+            NameType.class);\n+\n+    static {\n+        for (NameType s : NameType.values()) {\n+            Map<RuleType, Map<String, List<Rule>>> rts = new EnumMap<RuleType, Map<String, List<Rule>>>(RuleType.class);\n+\n+            for (RuleType rt : RuleType.values()) {\n+                Map<String, List<Rule>> rs = new HashMap<String, List<Rule>>();\n+\n+                Languages ls = Languages.instance(s);\n+                for (String l : ls.getLanguages()) {\n+                    rs.put(l, parseRules(mkScanner(s, rt, l)));\n+                }\n+                if (!rt.equals(RuleType.RULES)) {\n+                    rs.put(\"common\", parseRules(mkScanner(s, rt, \"common\")));\n+                }\n+\n+                rts.put(rt, Collections.unmodifiableMap(rs));\n+            }\n+\n+            RULES.put(s, Collections.unmodifiableMap(rts));\n+        }\n+    }\n+\n+    /**\n+     * Gets rules for a combination of name type, rule type and languages.\n+     * \n+     * @param nameType\n+     *            the NameType to consider\n+     * @param rt\n+     *            the RuleType to consider\n+     * @param langs\n+     *            the set of languages to consider\n+     * @return a list of Rules that apply\n+     */\n+    public static List<Rule> instance(NameType nameType, RuleType rt, Set<String> langs) {\n+        if (langs.size() == 1) {\n+            return instance(nameType, rt, langs.iterator().next());\n+        } else {\n+            return instance(nameType, rt, \"any\");\n+        }\n+    }\n+\n+    /**\n+     * Gets rules for a combination of name type, rule type and a single language.\n+     * \n+     * @param nameType\n+     *            the NameType to consider\n+     * @param rt\n+     *            the RuleType to consider\n+     * @param lang\n+     *            the language to consider\n+     * @return a list rules for a combination of name type, rule type and a single language.\n+     */\n+    public static List<Rule> instance(NameType nameType, RuleType rt, String lang) {\n+        List<Rule> rules = RULES.get(nameType).get(rt).get(lang);\n+\n+        if (rules == null) {\n+            throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\", nameType.getName(), rt.getName(), lang));\n+        }\n+\n+        return rules;\n+    }\n+\n+    private static Scanner mkScanner(NameType nameType, RuleType rt, String lang) {\n+        String resName = String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\", nameType.getName(), rt.getName(), lang);\n+        InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n+\n+        if (rulesIS == null) {\n+            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n+        }\n+\n+        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n+    }\n+\n+    private static Scanner mkScanner(String lang) {\n+        String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\n+        InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n+\n+        if (rulesIS == null) {\n+            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n+        }\n+\n+        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n+    }\n+\n+    private static List<Rule> parseRules(Scanner scanner) {\n+        List<Rule> lines = new ArrayList<Rule>();\n+\n+        boolean inMultilineComment = false;\n+        while (scanner.hasNextLine()) {\n+            String rawLine = scanner.nextLine();\n+            String line = rawLine;\n+\n+            if (inMultilineComment) {\n+                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n+                    inMultilineComment = false;\n+                } else {\n+                    // skip\n+                }\n+            } else {\n+                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n+                    inMultilineComment = true;\n+                } else {\n+                    // discard comments\n+                    int cmtI = line.indexOf(ResourceConstants.CMT);\n+                    if (cmtI >= 0) {\n+                        line = line.substring(0, cmtI);\n+                    }\n+\n+                    // trim leading-trailing whitespace\n+                    line = line.trim();\n+\n+                    if (line.length() == 0)\n+                        continue; // empty lines can be safely skipped\n+\n+                    if (line.startsWith(HASH_INCLUDE)) {\n+                        // include statement\n+                        String incl = line.substring(HASH_INCLUDE.length()).trim();\n+                        if (incl.contains(\" \")) {\n+                            System.err.println(\"Warining: malformed import statement: \" + rawLine);\n+                        } else {\n+                            lines.addAll(parseRules(mkScanner(incl)));\n+                        }\n+                    } else {\n+                        // rule\n+                        String[] parts = line.split(\"\\\\s+\");\n+                        if (parts.length != 4) {\n+                            System.err.println(\"Warning: malformed rule statement split into \" + parts.length + \" parts: \" + rawLine);\n+                        } else {\n+                            String pat = stripQuotes(parts[0]);\n+                            String lCon = stripQuotes(parts[1]);\n+                            String rCon = stripQuotes(parts[2]);\n+                            String ph = stripQuotes(parts[3]);\n+                            Rule r = new Rule(pat, lCon, rCon, ph, Collections.<String> emptySet(), \"\"); // guessing last 2 parameters\n+                            lines.add(r);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return lines;\n+    }\n+\n+    private static String stripQuotes(String str) {\n+        if (str.startsWith(DOUBLE_QUOTE)) {\n+            str = str.substring(1);\n+        }\n+\n+        if (str.endsWith(DOUBLE_QUOTE)) {\n+            str = str.substring(0, str.length() - 1);\n+        }\n+\n+        return str;\n+    }\n+\n+    private Set<String> language;\n+\n+    private Pattern lContext;\n+\n+    private String logical;\n+\n+    private String pattern;\n+\n+    private String phoneme;\n+\n+    private Pattern rContext;\n+\n+    /**\n+     * Creates a new rule.\n+     * \n+     * @param pattern\n+     *            the pattern\n+     * @param lContext\n+     *            the left context\n+     * @param rContext\n+     *            the right context\n+     * @param phoneme\n+     *            the resulting phoneme\n+     * @param language\n+     *            the required languages\n+     * @param logical\n+     *            flag to indicate if all or only some languages must be in scope\n+     */\n+    public Rule(String pattern, String lContext, String rContext, String phoneme, Set<String> language, String logical) {\n+        this.pattern = pattern;\n+        this.lContext = Pattern.compile(lContext + \"$\");\n+        this.rContext = Pattern.compile(\"^\" + rContext + \".*\");\n+        this.phoneme = phoneme;\n+        this.language = language;\n+        this.logical = logical;\n+    }\n+\n+    /**\n+     * Gets the languages that must be in scope. Not all rules apply in every language.\n+     * \n+     * @return a Set of Strings giving the relevant languages\n+     */\n+    public Set<String> getLanguage() {\n+        return this.language;\n+    }\n+\n+    /**\n+     * Gets the left context. This is a regular expression that must match to the left of the pattern.\n+     * \n+     * @return the left context Pattern\n+     */\n+    public Pattern getLContext() {\n+        return this.lContext;\n+    }\n+\n+    /**\n+     * Gets the logical combinator for the languages. ALL means all languages must be in scope for the rule to apply. Any other value means\n+     * that any one language must be in scope for the rule to apply.\n+     * \n+     * @return the logical combinator String\n+     */\n+    public String getLogical() {\n+        return this.logical;\n+    }\n+\n+    /**\n+     * Gets the pattern. This is a string-literal that must exactly match.\n+     * \n+     * @return the pattern\n+     */\n+    public String getPattern() {\n+        return this.pattern;\n+    }\n+\n+    /**\n+     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n+     * \n+     * @return the phoneme\n+     */\n+    public String getPhoneme() {\n+        return this.phoneme;\n+    }\n+\n+    /**\n+     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n+     * \n+     * @return the right context Pattern\n+     */\n+    public Pattern getRContext() {\n+        return this.rContext;\n+    }\n+\n+    /**\n+     * Decides if the language restriction for this rule applies.\n+     * \n+     * @param languageArg\n+     *            a Set of Strings giving the names of the languages in scope\n+     * @return true if these satistfy the language and logical restrictions on this rule, false otherwise\n+     */\n+    public boolean languageMatches(Set<String> languageArg) {\n+        if (!languageArg.contains(Languages.ANY) && !this.language.isEmpty()) {\n+            if (ALL.equals(this.logical) && !languageArg.containsAll(this.language)) {\n+                return false;\n+            } else {\n+                Set<String> isect = new HashSet<String>(languageArg);\n+                isect.retainAll(this.language);\n+                return !isect.isEmpty();\n+            }\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Decides if the pattern and context match the input starting at a position.\n+     * \n+     * @param input\n+     *            the input String\n+     * @param i\n+     *            the int position within the input\n+     * @return true if the pattern and left/right context match, false otherwise\n+     */\n+    public boolean patternAndContextMatches(String input, int i) {\n+        if (i < 0)\n+            throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n+\n+        int patternLength = this.pattern.length();\n+        int ipl = i + patternLength;\n+\n+        if (ipl > input.length()) {\n+            // not enough room for the pattern to match\n+            return false;\n+        }\n+\n+        boolean patternMatches = input.substring(i, ipl).equals(this.pattern);\n+        boolean rContextMatches = this.rContext.matcher(input.substring(ipl)).find();\n+        boolean lContextMatches = this.lContext.matcher(input.substring(0, i)).find();\n+\n+        return patternMatches && rContextMatches && lContextMatches;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/language/bm/RuleType.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+/**\n+ * Types of rule.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+public enum RuleType {\n+\n+    APPROX(\"approx\"), EXACT(\"exact\"), RULES(\"rules\");\n+\n+    private final String name;\n+\n+    RuleType(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.Collections;\n+\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Test;\n+\n+/**\n+ * Tests BeiderMorseEncoder.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+public class BeiderMorseEncoderTest extends StringEncoderAbstractTest {\n+    @Override\n+    protected StringEncoder createStringEncoder() {\n+        return new BeiderMorseEncoder();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void invalidLangResourceShouldRaiseException() {\n+        Lang.loadFromResource(\"thisIsAMadeUpResourceName\", Languages.instance(NameType.GENERIC));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void invalidLangShouldRaiseException() {\n+        Rule.instance(NameType.GENERIC, RuleType.APPROX, \"noSuchLanguage\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void invalidLanguageResourceShouldRaiseException() {\n+        Languages.instance(\"thereIsNoSuchLanguage\");\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void negativeIndexForRuleMatchShouldRaiseException() {\n+        Rule r = new Rule(\"a\", \"\", \"\", \"\", Collections.<String> emptySet(), \"bob\");\n+        r.patternAndContextMatches(\"bob\", -1);\n+    }\n+\n+    @Test\n+    public void setConcat() {\n+        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        bmpm.setConcat(false);\n+        assertEquals(\"Should be able to set concat to false\", false, bmpm.isConcat());\n+    }\n+\n+    @Test\n+    public void setNameTypeAsh() {\n+        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        bmpm.setNameType(NameType.ASHKENAZI);\n+        assertEquals(\"Name type should have been set to ash\", NameType.ASHKENAZI, bmpm.getNameType());\n+    }\n+\n+    @Test\n+    public void setRuleTypeExact() {\n+        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        bmpm.setRuleType(RuleType.EXACT);\n+        assertEquals(\"Rule type should have been set to exact\", RuleType.EXACT, bmpm.getRuleType());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void setRuleTypeToRulesShouldRaiseException() {\n+        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        bmpm.setRuleType(RuleType.RULES);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/language/bm/LanguageGuessingTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests guessLanguages API.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+@RunWith(Parameterized.class)\n+public class LanguageGuessingTest {\n+\n+    private static String EXACT = \"exact\";\n+    private static String ONE_OF = \"one of\";\n+\n+    @Parameterized.Parameters\n+    public static List<Object[]> data() {\n+        return Arrays.asList(new Object[][] {\n+                { \"Renault\", \"french\", EXACT },\n+                { \"Mickiewicz\", \"polish\", EXACT },\n+                { \"Thompson\", \"english\", ONE_OF }, // this also hits german and greeklatin\n+                { \"Nu\u00f1ez\", \"spanish\", EXACT }, { \"Carvalho\", \"portuguese\", EXACT }, { \"\u010capek\", \"czech\", EXACT },\n+                { \"Sjneijder\", \"dutch\", EXACT }, { \"Klausewitz\", \"german\", EXACT }, { \"K\u00fc\u00e7\u00fck\", \"turkish\", EXACT },\n+                { \"Giacometti\", \"italian\", EXACT }, { \"Nagy\", \"hungarian\", EXACT }, { \"Ceau\u015fescu\", \"romanian\", EXACT },\n+                { \"Angelopoulos\", \"greeklatin\", EXACT }, { \"\u0391\u03b3\u03b3\u03b5\u03bb\u03cc\u03c0\u03bf\u03c5\u03bb\u03bf\u03c2\", \"greek\", EXACT }, { \"\u041f\u0443\u0448\u043a\u0438\u043d\", \"cyrillic\", EXACT },\n+                { \"\u05db\u05d4\u05df\", \"hebrew\", EXACT } });\n+    }\n+\n+    private final String exactness;\n+\n+    private final Lang lang = Lang.instance(NameType.GENERIC);\n+    private final String language;\n+    private final String name;\n+\n+    public LanguageGuessingTest(String name, String language, String exactness) {\n+        this.name = name;\n+        this.language = language;\n+        this.exactness = exactness;\n+    }\n+\n+    @Test\n+    public void testLanguageGuessing() {\n+        Set<String> guesses = this.lang.guessLanguages(this.name);\n+        String guess = this.lang.guessLanguage(this.name);\n+\n+        assertTrue(\"language predicted for name '\" + this.name + \"' is wrong: \" + guesses + \" should contain '\" + this.language + \"'\",\n+                guesses.contains(this.language));\n+\n+        if (this.exactness.equals(EXACT)) {\n+            assertEquals(\"language predicted for name '\" + this.name + \"' is wrong\", this.language, guess);\n+        } else {\n+            // System.out.println(\"warning: test case that maps to multiple languages: '\" +\n+            // name + \"':\" + language + \" ~> \" + guesses);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/language/bm/PhoneticTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests PhoneticEngine.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+@RunWith(Parameterized.class)\n+public class PhoneticTest {\n+\n+    @Parameterized.Parameters\n+    public static List<Object[]> data() {\n+        return Arrays\n+                .asList(new Object[] { \"Renault\", \"rinolt|rino|rinDlt|rinalt|rinult|rinD|rina|rinu\", NameType.GENERIC, RuleType.APPROX,\n+                        true },\n+                        new Object[] { \"Renault\", \"rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult\", NameType.ASHKENAZI, RuleType.APPROX, true },\n+                        new Object[] { \"Renault\", \"(rinDlt)\", NameType.SEPHARDIC, RuleType.APPROX, true },\n+                        new Object[] { \"SntJohn-Smith\", \"(sntjonsmit)\", NameType.GENERIC, RuleType.EXACT, true },\n+                        new Object[] { \"d'ortley\", \"ortlaj|ortlej|ortlaj|ortlej-dortlaj|dortlej|dortlaj|dortlej\", NameType.GENERIC,\n+                                RuleType.EXACT, true },\n+                        new Object[] {\n+                                \"van helsing\",\n+                                \"helSink|helsink|helzink|xelSink|xelsink|xelzink|HelSink|Helsink|Helzink-vanhelSink|vanhelsink|vanhelzink|vanjelSink|vanjelsink|vanjelzink|fanhelSink|fanhelsink|fanhelzink|fanjelSink|fanjelsink|fanjelzink|banhelSink|banhelsink|banhelzink|banjelSink|banjelsink|banjelzink\",\n+                                NameType.GENERIC, RuleType.EXACT, false });\n+    }\n+\n+    private final boolean concat;\n+    private final String name;\n+    private final NameType nameType;\n+    private final String phoneticExpected;\n+    private final RuleType ruleType;\n+\n+    public PhoneticTest(String name, String phoneticExpected, NameType nameType, RuleType ruleType, boolean concat) {\n+        this.name = name;\n+        this.phoneticExpected = phoneticExpected;\n+        this.nameType = nameType;\n+        this.ruleType = ruleType;\n+        this.concat = concat;\n+    }\n+\n+    @Test(timeout = 10000L)\n+    public void testPhonetic() {\n+        PhoneticEngine engine = new PhoneticEngine(this.nameType, this.ruleType, this.concat);\n+\n+        String phoneticActual = engine.encode(this.name);\n+\n+        assertEquals(\"phoneme incorrect\", this.phoneticExpected, phoneticActual);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/language/bm/RuleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests Rule.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ */\n+@RunWith(Parameterized.class)\n+public class RuleTest {\n+\n+    @Parameterized.Parameters\n+    public static List<Object[]> data() {\n+        return Arrays.asList(\n+                new Object[] { \"matching language sets with ALL\",\n+                        new Rule(\"e\", \"\", \"\", \"o\", new HashSet<String>(Arrays.asList(\"english\", \"french\")), Rule.ALL),\n+                        new HashSet<String>(Arrays.asList(\"english\", \"french\")), true },\n+                new Object[] { \"non-matching language sets with ALL\",\n+                        new Rule(\"e\", \"\", \"\", \"o\", new HashSet<String>(Arrays.asList(\"english\", \"french\")), Rule.ALL),\n+                        new HashSet<String>(Arrays.asList(\"english\")), false });\n+    }\n+\n+    private final String caseName;\n+    private final boolean expected;\n+    private final Set<String> langs;\n+    private final Rule rule;\n+\n+    public RuleTest(String caseName, Rule rule, Set<String> langs, boolean expected) {\n+        this.caseName = caseName;\n+        this.rule = rule;\n+        this.langs = langs;\n+        this.expected = expected;\n+    }\n+\n+    @Test\n+    public void rule() {\n+        assertEquals(this.caseName, this.expected, this.rule.languageMatches(this.langs));\n+    }\n+\n+}", "timestamp": 1311733751, "metainfo": ""}