{"sha": "09f58fbc8956b05aec9cdc7ce9d153639917f24d", "log": "Fix some Checkstyle issues.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java\n     private static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n \n     /**\n-     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 Alphabet\" (as specified in\n-     * Table 3 of RFC 2045) into their 5-bit positive integer equivalents. Characters that are not in the Base32\n+     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 Alphabet\" (as specified\n+     * in Table 3 of RFC 2045) into their 5-bit positive integer equivalents. Characters that are not in the Base32\n      * alphabet but fall within the bounds of the array are translated to -1.\n-     *\n      */\n     private static final byte[] DECODE_TABLE = {\n          //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n     };\n \n     /**\n-     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 |Hex Alphabet\" (as specified in\n-     * Table 3 of RFC 2045) into their 5-bit positive integer equivalents. Characters that are not in the Base32 Hex\n-     * alphabet but fall within the bounds of the array are translated to -1.\n-     *\n+     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 |Hex Alphabet\" (as\n+     * specified in Table 3 of RFC 2045) into their 5-bit positive integer equivalents. Characters that are not in the\n+     * Base32 Hex alphabet but fall within the bounds of the array are translated to -1.\n      */\n     private static final byte[] HEX_DECODE_TABLE = {\n          //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n     };\n \n     /**\n-     * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Hex Alphabet\"\n-     * equivalents as specified in Table 3 of RFC 2045.\n+     * This array is a lookup table that translates 5-bit positive integer index values into their\n+     * \"Base32 Hex Alphabet\" equivalents as specified in Table 3 of RFC 2045.\n      */\n     private static final byte[] HEX_ENCODE_TABLE = {\n             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n      * Place holder for the bytes we're dealing with for our based logic.\n      * Bitwise operations store and extract the encoding or decoding from this variable.\n      */\n+\n     /**\n      * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n      * <code>decodeSize = {@link #BYTES_PER_ENCODED_BLOCK} - 1 + lineSeparator.length;</code>\n      * </p>\n      *\n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 8).\n-     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n+     *            8). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            decoding.\n      */\n     public Base32(int lineLength) {\n         this(lineLength, CHUNK_SEPARATOR);\n      * </p>\n      *\n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 8).\n-     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n+     *            8). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n      * @throws IllegalArgumentException\n      * </p>\n      *\n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 8).\n-     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n+     *            8). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n-     * @param useHex if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n+     * @param useHex\n+     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n      * @throws IllegalArgumentException\n-     *             The provided lineSeparator included some Base32 characters. That's not going to work!\n-     *             Or the lineLength > 0 and lineSeparator is null.\n+     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n+     *             lineLength > 0 and lineSeparator is null.\n      */\n     public Base32(int lineLength, byte[] lineSeparator, boolean useHex) {\n         super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK,\n                     int result = this.decodeTable[b];\n                     if (result >= 0) {\n                         context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n-                        context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; // collect decoded bytes\n+                        // collect decoded bytes\n+                        context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n                         if (context.modulus == 0) { // we can output the 5 bytes\n                             context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\n                             context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n--- a/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\n+++ b/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\n import org.apache.commons.codec.StringEncoder;\n \n /**\n- * Encodes a string into a double metaphone value.\n- * This Implementation is based on the algorithm by <CITE>Lawrence Philips</CITE>.\n+ * Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence\n+ * Philips</CITE>.\n+ * <p>\n+ * This class is conditionally thread-safe. The instance field {@link #maxCodeLen} is mutable\n+ * {@link #setMaxCodeLen(int)} but is not volatile, and accesses are not synchronized. If an instance of the class is\n+ * shared between threads, the caller needs to ensure that suitable synchronization is used to ensure safe publication\n+ * of the value between threads, and must not invoke {@link #setMaxCodeLen(int)} after initial setup.\n  *\n  * @see <a href=\"http://drdobbs.com/184401251?pgno=2\">Original Article</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/Metaphone\">http://en.wikipedia.org/wiki/Metaphone</a>\n- *\n- * This class is conditionally thread-safe.\n- * The instance field {@link #maxCodeLen} is mutable {@link #setMaxCodeLen(int)}\n- * but is not volatile, and accesses are not synchronized.\n- * If an instance of the class is shared between threads, the caller needs to ensure that suitable synchronization\n- * is used to ensure safe publication of the value between threads, and must not invoke {@link #setMaxCodeLen(int)}\n- * after initial setup.\n  *\n  * @version $Id$\n  */", "timestamp": 1346170392, "metainfo": ""}