{"sha": "034c04194dba4a3d8b7282940f3f99ade6bf9a95", "log": "[CODEC-130] Base64InputStream.skip skips underlying stream, not output. Add tests for skip(long) edge cases.  ", "commit": "\n--- a/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n \n package org.apache.commons.codec.binary;\n \n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n  */\n public class Base64InputStreamTest {\n \n-    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n-\n-    private final static byte[] LF = {(byte) '\\n'};\n+    /**\n+     * Decodes to {0, 0, 0, 255, 255, 255}\n+     */\n+    private static final String ENCODED_B64 = \"AAAA////\";\n+\n+    private final static byte[] CRLF = { (byte) '\\r', (byte) '\\n' };\n+\n+    private final static byte[] LF = { (byte) '\\n' };\n \n     private static final String STRING_FIXTURE = \"Hello World\";\n \n     }\n \n     /**\n-     * Test for the CODEC-101 bug:  InputStream.read(byte[]) should never return 0\n-     * because Java's builtin InputStreamReader hates that.\n-     *\n-     * @throws Exception for some failure scenarios.\n+     * Test for the CODEC-101 bug: InputStream.read(byte[]) should never return 0 because Java's builtin InputStreamReader hates that.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n      */\n     @Test\n     public void testCodec101() throws Exception {\n     }\n \n     /**\n-     * Another test for the CODEC-101 bug:\n-     * In commons-codec-1.4 this test shows InputStreamReader explicitly hating an\n+     * Another test for the CODEC-101 bug: In commons-codec-1.4 this test shows InputStreamReader explicitly hating an\n      * InputStream.read(byte[]) return of 0:\n-     *\n-     * java.io.IOException: Underlying input stream returned zero bytes\n-     * at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268)\n-     * at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)\n-     * at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)\n-     * at java.io.InputStreamReader.read(InputStreamReader.java:167)\n-     * at java.io.BufferedReader.fill(BufferedReader.java:136)\n-     * at java.io.BufferedReader.readLine(BufferedReader.java:299)\n-     * at java.io.BufferedReader.readLine(BufferedReader.java:362)\n-     * at org.apache.commons.codec.binary.Base64InputStreamTest.testInputStreamReader(Base64InputStreamTest.java:75)\n-     *\n-     * But in commons-codec-1.5 it's fixed.  :-)\n-     *\n-     * @throws Exception for some failure scenarios.\n+     * \n+     * java.io.IOException: Underlying input stream returned zero bytes at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268) at\n+     * sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158) at\n+     * java.io.InputStreamReader.read(InputStreamReader.java:167) at java.io.BufferedReader.fill(BufferedReader.java:136) at\n+     * java.io.BufferedReader.readLine(BufferedReader.java:299) at java.io.BufferedReader.readLine(BufferedReader.java:362) at\n+     * org.apache.commons.codec.binary.Base64InputStreamTest.testInputStreamReader(Base64InputStreamTest.java:75)\n+     * \n+     * But in commons-codec-1.5 it's fixed. :-)\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n      */\n     @Test\n     public void testInputStreamReader() throws Exception {\n     }\n \n     /**\n-     * Test the Base64InputStream implementation against the special NPE inducing input\n-     * identified in the CODEC-98 bug.\n-     *\n-     * @throws Exception for some failure scenarios.\n+     * Test the Base64InputStream implementation against the special NPE inducing input identified in the CODEC-98 bug.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n      */\n     @Test\n     public void testCodec98NPE() throws Exception {\n         byte[] decodedBytes = Base64TestData.streamToBytes(stream, new byte[1024]);\n \n         String decoded = StringUtils.newStringUtf8(decodedBytes);\n-        assertEquals(\n-            \"codec-98 NPE Base64InputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n-        );\n+        assertEquals(\"codec-98 NPE Base64InputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded);\n     }\n \n     /**\n \n         // Single Byte test.\n         encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n-        decoded = new byte[]{(byte) 0};\n+        decoded = new byte[] { (byte) 0 };\n         testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n \n         // OpenSSL interop test.\n \n         // Single Byte test.\n         encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n-        decoded = new byte[]{(byte) 0};\n+        decoded = new byte[] { (byte) 0 };\n         testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n \n         // OpenSSL interop test.\n     }\n \n     /**\n-     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n+     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n      * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode\n-     * over and over again.\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode over and over\n+     * again.\n      * \n      * @param encoded\n      *            base64 encoded data\n     }\n \n     /**\n-     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n+     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n      * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode\n-     * over and over again.\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode over and over\n+     * again.\n      * \n      * @param encoded\n      *            base64 encoded data\n     public void testMarkSupported() throws Exception {\n         byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         // Always returns false for now.\n         assertFalse(\"Base64InputStream.markSupported() is false\", in.markSupported());\n     }\n         byte[] buf = new byte[1024];\n         int bytesRead = 0;\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         bytesRead = in.read(buf, 0, 0);\n         assertEquals(\"Base64InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n     }\n     public void testReadNull() throws Exception {\n         byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         try {\n             in.read(null, 0, 0);\n             fail(\"Base64InputStream.read(null, 0, 0) to throw a NullPointerException\");\n         byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         byte[] buf = new byte[1024];\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n \n         try {\n             in.read(buf, -1, 0);\n             // Expected\n         }\n     }\n+\n+    /**\n+     * Tests skipping as a noop\n+     * \n+     * @throws Throwable\n+     */\n+    @Test\n+    public void testSkipNone() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        Base64InputStream b64stream = new Base64InputStream(ins);\n+        byte[] actualBytes = new byte[6];\n+        assertEquals(0, b64stream.skip(0));\n+        b64stream.read(actualBytes, 0, actualBytes.length);\n+        assertArrayEquals(actualBytes, new byte[] { 0, 0, 0, (byte) 255, (byte) 255, (byte) 255 });\n+        // End of stream reached\n+        assertEquals(-1, b64stream.read());\n+    }\n+\n+    /**\n+     * Tests skipping past the end of a stream.\n+     * \n+     * @throws Throwable\n+     */\n+    @Test\n+    public void testSkipPastEnd() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        Base64InputStream b64stream = new Base64InputStream(ins);\n+        assertEquals(8, b64stream.skip(10));\n+        // End of stream reached\n+        assertEquals(-1, b64stream.read());\n+        assertEquals(-1, b64stream.read());\n+    }\n+\n+    /**\n+     * Tests skipping to the end of a stream.\n+     * \n+     * @throws Throwable\n+     */\n+    @Test\n+    public void testSkipToEnd() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        Base64InputStream b64stream = new Base64InputStream(ins);\n+        assertEquals(8, b64stream.skip(8));\n+        // End of stream reached\n+        assertEquals(-1, b64stream.read());\n+        assertEquals(-1, b64stream.read());\n+    }\n }", "timestamp": 1317059012, "metainfo": ""}