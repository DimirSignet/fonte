{"sha": "1078329ade725b36e3617dd7c6dd7a714810795c", "log": "Removed all checkstyle violations from Base64, and the language encoders.  Most of the checkstyle violations fixed were violations dealing with the placement of operators on a newline instead of on the end of the previous line.   ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n   * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n   * @author Tim O'Brien\n   * @since 1.0-dev\n-  * @version $Id: Base64.java,v 1.10 2003/10/05 21:45:49 tobrien Exp $\n+  * @version $Id: Base64.java,v 1.11 2003/10/12 19:48:15 tobrien Exp $\n   */\n public class Base64 implements BinaryEncoder, BinaryDecoder {\n \n         Object result;\n \n         if (!(pObject instanceof byte[])) {\n-            throw new DecoderException(\n-                \"Parameter supplied to \"\n-                    + \"Base64 \"\n-                    + \"decode is not a byte[]\");\n+            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[]\");\n         } else {\n             result = decode((byte[]) pObject);\n         }\n         if (isChunked) {\n \n             nbrChunks =\n-                (CHUNK_SEPARATOR.length == 0\n-                    ? 0\n-                    : (int) Math.ceil((float) encodedDataLength / CHUNK_SIZE));\n+                (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLength / CHUNK_SIZE));\n             encodedDataLength += nbrChunks * CHUNK_SEPARATOR.length;\n         }\n \n             k = (byte) (b1 & 0x03);\n \n             byte val1 =\n-                ((b1 & SIGN) == 0)\n-                    ? (byte) (b1 >> 2)\n-                    : (byte) ((b1) >> 2 ^ 0xc0);\n+                ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n             byte val2 =\n-                ((b2 & SIGN) == 0)\n-                    ? (byte) (b2 >> 4)\n-                    : (byte) ((b2) >> 4 ^ 0xf0);\n+                ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n             byte val3 =\n-                ((b3 & SIGN) == 0)\n-                    ? (byte) (b3 >> 6)\n-                    : (byte) ((b3) >> 6 ^ 0xfc);\n+                ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n \n             encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n             //log.debug( \"val2 = \" + val2 );\n                         CHUNK_SEPARATOR.length);\n                     chunksSoFar++;\n                     nextSeparatorIndex =\n-                        (CHUNK_SIZE * (chunksSoFar + 1))\n-                            + (chunksSoFar * CHUNK_SEPARATOR.length);\n+                        (CHUNK_SIZE * (chunksSoFar + 1)) + \n+                        (chunksSoFar * CHUNK_SEPARATOR.length);\n                     encodedIndex += CHUNK_SEPARATOR.length;\n                 }\n             }\n             //log.debug(\"b1=\" + b1);\n             //log.debug(\"b1<<2 = \" + (b1>>2) );\n             byte val1 =\n-                ((b1 & SIGN) == 0)\n-                    ? (byte) (b1 >> 2)\n-                    : (byte) ((b1) >> 2 ^ 0xc0);\n+                ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n             encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n             encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n             encodedData[encodedIndex + 2] = PAD;\n             k = (byte) (b1 & 0x03);\n \n             byte val1 =\n-                ((b1 & SIGN) == 0)\n-                    ? (byte) (b1 >> 2)\n-                    : (byte) ((b1) >> 2 ^ 0xc0);\n+                ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n             byte val2 =\n-                ((b2 & SIGN) == 0)\n-                    ? (byte) (b2 >> 4)\n-                    : (byte) ((b2) >> 4 ^ 0xf0);\n+                ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n \n             encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n             encodedData[encodedIndex + 1] =\n \n         if (!(pObject instanceof byte[])) {\n             throw new EncoderException(\n-                \"Parameter supplied to \"\n-                    + \"Base64 \"\n-                    + \"encode is not a byte[]\");\n+                \"Parameter supplied to Base64 encode is not a byte[]\");\n         } else {\n             result = encode((byte[]) pObject);\n         }\n--- a/src/java/org/apache/commons/codec/language/Metaphone.java\n+++ b/src/java/org/apache/commons/codec/language/Metaphone.java\n  * @author wbrogden@bga.com\n  * @author bayard@generationjava.com\n  * @author Tim O'Brien\n- * @version $Id: Metaphone.java,v 1.7 2003/10/05 21:45:48 tobrien Exp $\n+ * @version $Id: Metaphone.java,v 1.8 2003/10/12 19:48:14 tobrien Exp $\n  */\n public class Metaphone implements StringEncoder {\n \n     public String metaphone(String txt) {\n         int mtsz = 0  ;\n         boolean hard = false ;\n-        if ((txt == null) \n-            || (txt.length() == 0)) {\n+        if ((txt == null) || (txt.length() == 0)) {\n             return \"\" ;\n         }\n         // single character is itself\n         int wdsz = local.length();\n         int n = 0 ;\n \n-        while ((mtsz < maxCodeLen) // max code size of 4 works well\n-               && (n < wdsz)) {\n+        while ((mtsz < maxCodeLen) && (n < wdsz)) { // max code size of 4 works well\n             char symb = local.charAt(n) ;\n             // remove duplicate letters except C\n-            if ((symb != 'C') \n-                && (n > 0) && (local.charAt(n - 1) == symb)) {\n+            if ((symb != 'C') && (n > 0) && (local.charAt(n - 1) == symb)) {\n                 n++ ;\n             } else { // not dup\n                 switch(symb) {\n                     }\n                     break ; // only use vowel if leading char\n                 case 'B' :\n-                    if ((n > 0) \n-                        && !(n + 1 == wdsz) // not MB at end of word\n-                        && (local.charAt(n - 1) == 'M')) {\n+                    if ((n > 0) && !(n + 1 == wdsz) && (local.charAt(n - 1) == 'M')) { // not MB at end of word \n                         code.append(symb);\n                     } else {\n                         code.append(symb);\n                     break;\n                 case 'C' : // lots of C special cases\n                     /* discard if SCI, SCE or SCY */\n-                    if ((n > 0) \n-                        && (local.charAt(n - 1) == 'S') \n-                        && (n + 1 < wdsz) \n-                        && (frontv.indexOf(local.charAt(n + 1)) >= 0)) { \n+                    if ((n > 0) && (local.charAt(n - 1) == 'S') && (n + 1 < wdsz) && (frontv.indexOf(local.charAt(n + 1)) >= 0)) { \n                         break ;\n                     }\n                     tmpS = local.toString();\n                     if (tmpS.indexOf(\"CIA\", n) == n) { // \"CIA\" -> X\n                         code.append('X'); mtsz++; break ;\n                     }\n-                    if ((n + 1 < wdsz) \n-                        && (frontv.indexOf(local.charAt(n + 1)) >= 0)) {\n+                    if ((n + 1 < wdsz) && (frontv.indexOf(local.charAt(n + 1)) >= 0)) {\n                         code.append('S');\n                         mtsz++; \n                         break ; // CI,CE,CY -> S\n                     }\n-                    if ((n > 0) \n-                        && (tmpS.indexOf(\"SCH\", n - 1) == n - 1)) { // SCH->sk\n+                    if ((n > 0) && (tmpS.indexOf(\"SCH\", n - 1) == n - 1)) { // SCH->sk\n                         code.append('K') ; \n                         mtsz++;\n                         break ;\n                     }\n                     if (tmpS.indexOf(\"CH\", n) == n) { // detect CH\n-                        if ((n == 0) \n-                            && (wdsz >= 3)     // CH consonant -> K consonant\n-                            && (vowels.indexOf(local.charAt(2)) < 0)) {\n+                        if ((n == 0) && (wdsz >= 3) && (vowels.indexOf(local.charAt(2)) < 0)) { // CH consonant -> K consonant\n                             code.append('K');\n                         } else { \n                             code.append('X'); // CHvowel -> X\n                     }\n                     break ;\n                 case 'D' :\n-                    if ((n + 2 < wdsz)   // DGE DGI DGY -> J\n-                        && (local.charAt(n + 1) == 'G')\n-                        && (frontv.indexOf(local.charAt(n + 2)) >= 0)) {\n+                    if ((n + 2 < wdsz)   && (local.charAt(n + 1) == 'G') && (frontv.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J \n                         code.append('J'); n += 2 ;\n                     } else { \n                         code.append('T');\n                     mtsz++;\n                     break ;\n                 case 'G' : // GH silent at end or before consonant\n-                    if ((n + 2 == wdsz)\n-                        && (local.charAt(n + 1) == 'H')) {\n+                    if ((n + 2 == wdsz) && (local.charAt(n + 1) == 'H')) {\n                         break;\n                     }\n-                    if ((n + 2 < wdsz) \n-                        && (local.charAt(n + 1) == 'H')\n-                        && (vowels.indexOf(local.charAt(n + 2)) < 0)) {\n+                    if ((n + 2 < wdsz) && (local.charAt(n + 1) == 'H') && (vowels.indexOf(local.charAt(n + 2)) < 0)) {\n                         break;\n                     }\n                     tmpS = local.toString();\n-                    if ((n > 0) \n-                        && (tmpS.indexOf(\"GN\", n) == n)\n-                        || (tmpS.indexOf(\"GNED\", n) == n)) {\n+                    if ((n > 0) && (tmpS.indexOf(\"GN\", n) == n) || (tmpS.indexOf(\"GNED\", n) == n)) {\n                         break; // silent G\n                     }\n-                    if ((n > 0) \n-                        && (local.charAt(n - 1) == 'G')) {\n+                    if ((n > 0) && (local.charAt(n - 1) == 'G')) {\n                         hard = true ;\n                     } else {\n                         hard = false ;\n                     }\n-                    if ((n + 1 < wdsz) \n-                        && (frontv.indexOf(local.charAt(n + 1)) >= 0)\n-                        && (!hard)) {\n+                    if ((n + 1 < wdsz) && (frontv.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {\n                         code.append('J');\n                     } else {\n                         code.append('K');\n                     if (n + 1 == wdsz) {\n                         break ; // terminal H\n                     }\n-                    if ((n > 0) \n-                        && (varson.indexOf(local.charAt(n - 1)) >= 0)) {\n+                    if ((n > 0) && (varson.indexOf(local.charAt(n - 1)) >= 0)) {\n                         break;\n                     }\n                     if (vowels.indexOf(local.charAt(n + 1)) >= 0) {\n                     mtsz++ ;\n                     break ;\n                 case 'P' :\n-                    if ((n + 1 < wdsz) \n-                        && (local.charAt(n + 1) == 'H')) {\n+                    if ((n + 1 < wdsz) && (local.charAt(n + 1) == 'H')) {\n                         // PH -> F\n                         code.append('F');\n                     } else {\n                     break;\n                 case 'S' :\n                     tmpS = local.toString();\n-                    if ((tmpS.indexOf(\"SH\", n) == n) \n-                        || (tmpS.indexOf(\"SIO\", n) == n) \n-                        || (tmpS.indexOf(\"SIA\", n) == n)) {\n+                    if ((tmpS.indexOf(\"SH\", n) == n) || (tmpS.indexOf(\"SIO\", n) == n) || (tmpS.indexOf(\"SIA\", n) == n)) {\n                         code.append('X');\n                     } else {\n                         code.append('S');\n                     break;\n                 case 'T' :\n                     tmpS = local.toString(); // TIA TIO -> X\n-                    if ((tmpS.indexOf(\"TIA\", n) == n) \n-                        || (tmpS.indexOf(\"TIO\", n) == n)) {\n+                    if ((tmpS.indexOf(\"TIA\", n) == n) || (tmpS.indexOf(\"TIO\", n) == n)) {\n                         code.append('X'); \n                         mtsz++; \n                         break;\n                 case 'V' :\n                     code.append('F'); mtsz++;break ;\n                 case 'W' : case 'Y' : // silent if not followed by vowel\n-                    if ((n + 1 < wdsz) \n-                     && (vowels.indexOf(local.charAt(n + 1)) >= 0)) {\n+                    if ((n + 1 < wdsz) && (vowels.indexOf(local.charAt(n + 1)) >= 0)) {\n                         code.append(symb);\n                         mtsz++;\n                     }\n     public Object encode(Object pObject) throws EncoderException {\n         Object result;\n         if (!(pObject instanceof java.lang.String)) {\n-            throw new EncoderException(\"Parameter supplied to Metaphone \" \n-                                       + \"encode is not of type \" \n-                                       + \"java.lang.String\"); \n+            throw new EncoderException(\"Parameter supplied to Metaphone encode is not of type java.lang.String\"); \n         } else {\n             result = metaphone((String) pObject);\n         }\n--- a/src/java/org/apache/commons/codec/language/RefinedSoundex.java\n+++ b/src/java/org/apache/commons/codec/language/RefinedSoundex.java\n  * \n  * @author Tim O'Brien\n  * @author ggregory@seagullsw.com\n- * @version $Id: RefinedSoundex.java,v 1.9 2003/10/05 21:45:48 tobrien Exp $\n+ * @version $Id: RefinedSoundex.java,v 1.10 2003/10/12 19:48:14 tobrien Exp $\n  */\n public class RefinedSoundex implements StringEncoder {\n \n     public Object encode(Object pObject) throws EncoderException {\n         Object result;\n         if (!(pObject instanceof java.lang.String)) {\n-            throw new EncoderException(\"Parameter supplied to \" \n-                                       + \"RefinedSoundex \" \n-                                       + \"encode is not of type \" \n-                                       + \"java.lang.String\"); \n+            throw new EncoderException(\"Parameter supplied to RefinedSoundex encode is not of type java.lang.String\"); \n         } else {\n             result = soundex((String) pObject);\n         }\n--- a/src/java/org/apache/commons/codec/language/Soundex.java\n+++ b/src/java/org/apache/commons/codec/language/Soundex.java\n  * @author bayard@generationjava.com\n  * @author Tim O'Brien\n  * @author ggregory@seagullsw.com\n- * @version $Id: Soundex.java,v 1.8 2003/10/05 21:45:48 tobrien Exp $\n+ * @version $Id: Soundex.java,v 1.9 2003/10/12 19:48:15 tobrien Exp $\n  */\n public class Soundex implements StringEncoder {\n \n         int incount = 1, count = 1;\n         out[0] = Character.toUpperCase(str.charAt(0));\n         last = getMappingCode(str.charAt(0));\n-        while ((incount < str.length()) \n-              && (mapped = getMappingCode(str.charAt(incount++))) != 0 \n-              && (count < maxLength)) {\n+        while ((incount < str.length()) && (mapped = getMappingCode(str.charAt(incount++))) != 0 && (count < maxLength)) {\n                 if ((mapped != '0') && (mapped != last)) {\n                     out[count++] = mapped;\n                 }\n         Object result;\n \n         if (!(pObject instanceof java.lang.String)) {\n-            throw new EncoderException(\"Parameter supplied to \" \n-                                       + \"Soundex \" \n-                                       + \"encode is not of type \" \n-                                       + \"java.lang.String\"); \n+            throw new EncoderException(\"Parameter supplied to Soundex encode is not of type java.lang.String\"); \n         } else {\n             result = soundex((String) pObject);\n         }", "timestamp": 1065988095, "metainfo": ""}