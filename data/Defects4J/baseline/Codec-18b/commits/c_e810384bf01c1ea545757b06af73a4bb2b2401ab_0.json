{"sha": "e810384bf01c1ea545757b06af73a4bb2b2401ab", "log": "More refactoring  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/java/org/apache/commons/codec/binary/Base32.java\n     /**\n      * Chunk separator per RFC 2045 section 2.1.\n      *\n-     * <p>\n-     * N.B. The next major release may break compatibility and make this field private.\n-     * </p>\n-     * \n      * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n      */\n     private static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n             'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n             'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n     };\n-\n-    /**\n-     * Byte used to pad output.\n-     */\n-    private static final byte PAD = '=';\n \n     /**\n      * This array is a lookup table that translates Unicode characters drawn from the \"Base32 Alphabet\" (as specified in\n     /** Mask used to extract 5 bits, used when encoding Base32 bytes */\n     private static final int MASK_5BITS = 0x1f;\n \n-    /** Mask used to extract 8 bits, used in decoding Base32 bytes */\n-    private static final int MASK_8BITS = 0xff;\n-\n     // The static final fields above are used for the original static byte[] methods on Base32.\n     // The private member fields below are used with the new streaming approach, which requires\n     // some state be preserved between calls of encode() and decode().\n      */\n     private final byte[] encodeTable;\n \n+    /**\n+     * Decode table to use.\n+     */\n     private final byte[] decodeTable;\n-    /**\n-     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the Base32\n-     * encoded data.\n-     */\n-    private final int lineLength;\n \n     /**\n      * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n \n     /**\n      * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n-     * <code>decodeSize = 3 + lineSeparator.length;</code>\n-     * TODO 3?\n+     * <code>decodeSize = {@link BYTES_PER_ENCODED_BLOCK} - 1 + lineSeparator.length;</code>\n      */\n     private final int decodeSize;\n \n     /**\n      * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n-     * <code>encodeSize = 4 + lineSeparator.length;</code>\n-     * TODO 4? is that BYTES_PER_ENCODED_BLOCK? - probably yes\n+     * <code>encodeSize = {@link BYTES_PER_ENCODED_BLOCK} + lineSeparator.length;</code>\n      */\n     private final int encodeSize;\n \n      * @param useHex if <code>true</code>, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n      * @throws IllegalArgumentException\n      *             The provided lineSeparator included some Base32 characters. That's not going to work!\n+     *             Or the lineLength > 0 and lineSeparator is null.\n      */\n     public Base32(int lineLength, byte[] lineSeparator, boolean useHex) {\n-        if (lineSeparator == null) {\n-            lineLength = 0;  // disable chunk-separating\n-            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n-        }\n-        this.lineLength = lineLength > 0 ? (lineLength / BYTES_PER_ENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK : 0;\n-        this.lineSeparator = new byte[lineSeparator.length];\n-        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n-        if (lineLength > 0) {\n-            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n-        } else {\n-            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n-        }\n-        this.decodeSize = this.encodeSize - 1;\n-        if (containsBase32Byte(lineSeparator)) {\n-            String sep = StringUtils.newStringUtf8(lineSeparator);\n-            throw new IllegalArgumentException(\"lineSeperator must not contain Base32 characters: [\" + sep + \"]\");\n-        }\n+        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, \n+                lineLength, \n+                lineSeparator == null ? 0 : lineSeparator.length);\n         if (useHex){\n             this.encodeTable = BASE32HEX_ENCODE_TABLE;\n             this.decodeTable = BASE32HEX_DECODE_TABLE;            \n             this.encodeTable = BASE32_ENCODE_TABLE;\n             this.decodeTable = BASE32_DECODE_TABLE;            \n         }\n+        if (lineLength > 0) {\n+            if (lineSeparator == null) {\n+                throw new IllegalArgumentException(\"lineLength \"+lineLength+\" > 0, but lineSeparator is null\");\n+            }\n+            // Must be done after initialising the tables\n+            if (containsAlphabetOrPad(lineSeparator)) {\n+                String sep = StringUtils.newStringUtf8(lineSeparator);\n+                throw new IllegalArgumentException(\"lineSeperator must not contain Base32 characters: [\" + sep + \"]\");\n+            }\n+            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n+            this.lineSeparator = new byte[lineSeparator.length];\n+            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n+        } else {\n+            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n+            this.lineSeparator = null;\n+        }\n+        this.decodeSize = this.encodeSize - 1;\n     }\n \n     /**\n      * \n      * @param octet\n      *            The value to test\n-     * @return <code>true</code> if the value is defined in the the Base32 alphabet (or pad), <code>false</code> otherwise.\n-     */\n-    public boolean isBase32(byte octet) {\n-        return octet == PAD || (octet >= 0 && octet < BASE32_DECODE_TABLE.length && BASE32_DECODE_TABLE[octet] != -1);\n-    }\n-\n-    /**\n-     * Returns whether or not the <code>octet</code> is in the Base32 Hex alphabet.\n-     * \n-     * @param octet\n-     *            The value to test\n-     * @return <code>true</code> if the value is defined in the the Base32 Hex alphabet (or pad), <code>false</code> otherwise.\n-     */\n-    public boolean isBase32Hex(byte octet) {\n-        return octet == PAD || (octet >= 0 && octet < BASE32HEX_DECODE_TABLE.length && BASE32HEX_DECODE_TABLE[octet] != -1);\n-    }\n-\n-    /**\n-     * Tests a given String to see if it contains only valid characters within the Base32 alphabet. Currently the\n-     * method treats whitespace as valid.\n-     * \n-     * @param base32\n-     *            String to test\n-     * @return <code>true</code> if all characters in the String are valid characters in the Base32 alphabet or if\n-     *         the String is empty; <code>false</code>, otherwise\n-     */\n-    public boolean isBase32(String base32) {\n-        return isBase32(StringUtils.getBytesUtf8(base32));\n-    }\n-\n-    /**\n-     * Tests a given byte array to see if it contains only valid characters within the Base32 alphabet. Currently the\n-     * method treats whitespace as valid.\n-     * \n-     * @param arrayOctet\n-     *            byte array to test\n-     * @return <code>true</code> if all bytes are valid characters in the Base32 alphabet or if the byte array is empty;\n-     *         <code>false</code>, otherwise\n-     */    \n-    public boolean isBase32(byte[] arrayOctet) {\n-        for (int i = 0; i < arrayOctet.length; i++) {\n-            if (!isBase32(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-    \n-    /**\n-     * Tests a given byte array to see if it contains any characters within the Base32 alphabet.\n-     * Does not allow white-space.\n-     * \n-     * @param arrayOctet\n-     *            byte array to test\n-     * @return <code>true</code> if any byte is a valid character in the Base32 alphabet; <code>false</code> otherwise\n-     */\n-    private boolean containsBase32Byte(byte[] arrayOctet) {\n-        for (int i = 0; i < arrayOctet.length; i++) {\n-            if (isBase32(arrayOctet[i])) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Encodes binary data using the Base32 algorithm but does not chunk the output.\n-     * \n-     * @param binaryData\n-     *            binary data to encode\n-     * @return byte[] containing Base32 characters in their UTF-8 representation.\n-     */\n-    public static byte[] encodeBase32(byte[] binaryData) {\n-        return encodeBase32(binaryData, false);\n-    }\n-\n-    /**\n-     * Encodes binary data using the Base32 algorithm but does not chunk the output.\n-     *\n-     * @param binaryData\n-     *            binary data to encode\n-     * @return String containing Base32 characters.\n-     */    \n-    public static String encodeBase32String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase32(binaryData, false));\n-    }\n-    \n-    /**\n-     * Encodes binary data using the Base32 algorithm but does not chunk the output.\n-     *\n-     * @param binaryData\n-     *            binary data to encode\n-     * @return String containing Base32Hex characters.\n-     */    \n-    public static String encodeBase32HexString(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase32Hex(binaryData, false));\n-    }\n-    \n-    /**\n-     * Encodes binary data using the Base32 algorithm and chunks the encoded output into 76 character blocks\n-     * \n-     * @param binaryData\n-     *            binary data to encode\n-     * @return Base32 characters chunked in 76 character blocks\n-     */\n-    public static byte[] encodeBase32Chunked(byte[] binaryData) {\n-        return encodeBase32(binaryData, true);\n-    }\n-\n-    /**\n-     * Encodes binary data using the Base32 algorithm, optionally chunking the output into 76 character blocks.\n-     * \n-     * @param binaryData\n-     *            Array containing binary data to encode.\n-     * @param isChunked\n-     *            if <code>true</code> this encoder will chunk the Base32 output into 76 character blocks\n-     * @return Base32-encoded data.\n-     * @throws IllegalArgumentException\n-     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n-     */\n-    public static byte[] encodeBase32(byte[] binaryData, boolean isChunked) {\n-        return encodeBase32(binaryData, isChunked, Integer.MAX_VALUE);\n-    }\n-\n-    /**\n-     * Encodes binary data using the Base32 Hex algorithm, optionally chunking the output into 76 character blocks.\n-     * \n-     * @param binaryData\n-     *            Array containing binary data to encode.\n-     * @param isChunked\n-     *            if <code>true</code> this encoder will chunk the Base32 output into 76 character blocks\n-     * @return Base32Hex-encoded data.\n-     * @throws IllegalArgumentException\n-     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n-     */\n-    public static byte[] encodeBase32Hex(byte[] binaryData, boolean isChunked) {\n-        return encodeBase32Hex(binaryData, isChunked, Integer.MAX_VALUE);\n-    }\n-\n-    /**\n-     * Encodes binary data using the Base32 algorithm, optionally chunking the output into 76 character blocks.\n-     * \n-     * @param binaryData\n-     *            Array containing binary data to encode.\n-     * @param isChunked\n-     *            if <code>true</code> this encoder will chunk the Base32 output into 76 character blocks\n-     * @param maxResultSize\n-     *            The maximum result size to accept.\n-     * @return Base32-encoded data.\n-     * @throws IllegalArgumentException\n-     *             Thrown when the input array needs an output array bigger than maxResultSize\n-     */\n-    public static byte[] encodeBase32(byte[] binaryData, boolean isChunked, int maxResultSize) {\n-        if (binaryData == null || binaryData.length == 0) {\n-            return binaryData;\n-        }\n-\n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n-        if (len > maxResultSize) {\n-            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n-                len +\n-                \") than the specified maxium size of \" +\n-                maxResultSize);\n-        }\n-                \n-        Base32 b64 = isChunked ? new Base32(MIME_CHUNK_SIZE, CHUNK_SEPARATOR) : new Base32();\n-        return b64.encode(binaryData);\n-    }\n-\n-    /**\n-     * Encodes binary data using the Base32Hex algorithm, optionally chunking the output into 76 character blocks.\n-     * \n-     * @param binaryData\n-     *            Array containing binary data to encode.\n-     * @param isChunked\n-     *            if <code>true</code> this encoder will chunk the Base32 output into 76 character blocks\n-     * @param maxResultSize\n-     *            The maximum result size to accept.\n-     * @return Base32Hex-encoded data.\n-     * @throws IllegalArgumentException\n-     *             Thrown when the input array needs an output array bigger than maxResultSize\n-     */\n-    public static byte[] encodeBase32Hex(byte[] binaryData, boolean isChunked, int maxResultSize) {\n-        if (binaryData == null || binaryData.length == 0) {\n-            return binaryData;\n-        }\n-\n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n-        if (len > maxResultSize) {\n-            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n-                len +\n-                \") than the specified maxium size of \" +\n-                maxResultSize);\n-        }\n-                \n-        Base32 b64 = isChunked ? new Base32(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, true) : new Base32(true);\n-        return b64.encode(binaryData);\n-    }\n-\n-    /**\n-     * Decodes a Base32 String into octets\n-     *\n-     * @param base32String\n-     *            String containing Base32 data\n-     * @return Array containing decoded data.\n-     */\n-    public static byte[] decodeBase32(String base32String) {\n-        return new Base32().decode(base32String);\n-    }\n-\n-    /**\n-     * Decodes Base32 data into octets\n-     * \n-     * @param base32Data\n-     *            Byte array containing Base32 data\n-     * @return Array containing decoded data.\n-     */\n-    public static byte[] decodeBase32(byte[] base32Data) {\n-        return new Base32().decode(base32Data);\n-    }\n-\n-    /**\n-     * Decodes a Base32 Hex String into octets\n-     *\n-     * @param base32HexString\n-     *            String containing Base32Hex data\n-     * @return Array containing decoded data.\n-     */\n-    public static byte[] decodeBase32Hex(String base32HexString) {\n-        return new Base32(true).decode(base32HexString);\n-    }\n-\n-    /**\n-     * Decodes Base32 Hex data into octets\n-     * \n-     * @param base32HexData\n-     *            Byte array containing Base32Hex data\n-     * @return Array containing decoded data.\n-     */\n-    public static byte[] decodeBase32Hex(byte[] base32HexData) {\n-        return new Base32(true).decode(base32HexData);\n+     * @return <code>true</code> if the value is defined in the the Base32 alphabet <code>false</code> otherwise.\n+     */\n+    public boolean isInAlphabet(byte octet) {\n+        return (octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1);\n     }\n \n     /**\n         // encoding.\n         if (inAvail < 0) {\n             eof = true;\n-            if (buffer == null || buffer.length - pos < encodeSize) {\n-                resizeBuffer();\n-            }\n+            if (0 == modulus) {\n+                return; // no leftovers to process\n+            }\n+            ensureBufferSize(encodeSize);\n             switch (modulus) { // % 5\n                 case 1 : // Only 1 octet; take top 5 bits then remainder\n-                    buffer[pos++] = encodeTable[(int)(x >> 3) & MASK_5BITS]; // 8-1*5 = 3\n-                    buffer[pos++] = encodeTable[(int)(x << 2) & MASK_5BITS]; // 5-3=2\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; // 5-3=2\n                     buffer[pos++] = PAD;\n                     buffer[pos++] = PAD;\n                     buffer[pos++] = PAD;\n                     break;\n     \n                 case 2 : // 2 octets = 16 bits to use\n-                    buffer[pos++] = encodeTable[(int)(x >> 11) & MASK_5BITS]; // 16-1*5 = 11\n-                    buffer[pos++] = encodeTable[(int)(x >>  6) & MASK_5BITS]; // 16-2*5 = 6\n-                    buffer[pos++] = encodeTable[(int)(x >>  1) & MASK_5BITS]; // 16-3*5 = 1\n-                    buffer[pos++] = encodeTable[(int)(x <<  4) & MASK_5BITS]; // 5-1 = 4\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\n                     buffer[pos++] = PAD;\n                     buffer[pos++] = PAD;\n                     buffer[pos++] = PAD;\n                     buffer[pos++] = PAD;\n                     break;\n                 case 3 : // 3 octets = 24 bits to use\n-                    buffer[pos++] = encodeTable[(int)(x >> 19) & MASK_5BITS]; // 24-1*5 = 19\n-                    buffer[pos++] = encodeTable[(int)(x >> 14) & MASK_5BITS]; // 24-2*5 = 14\n-                    buffer[pos++] = encodeTable[(int)(x >>  9) & MASK_5BITS]; // 24-3*5 = 9\n-                    buffer[pos++] = encodeTable[(int)(x >>  4) & MASK_5BITS]; // 24-4*5 = 4\n-                    buffer[pos++] = encodeTable[(int)(x <<  1) & MASK_5BITS]; // 5-4 = 1\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\n                     buffer[pos++] = PAD;\n                     buffer[pos++] = PAD;\n                     buffer[pos++] = PAD;\n                     break;\n                 case 4 : // 4 octets = 32 bits to use\n-                    buffer[pos++] = encodeTable[(int)(x >> 27) & MASK_5BITS]; // 32-1*5 = 27\n-                    buffer[pos++] = encodeTable[(int)(x >> 22) & MASK_5BITS]; // 32-2*5 = 22\n-                    buffer[pos++] = encodeTable[(int)(x >> 17) & MASK_5BITS]; // 32-3*5 = 17\n-                    buffer[pos++] = encodeTable[(int)(x >> 12) & MASK_5BITS]; // 32-4*5 = 12\n-                    buffer[pos++] = encodeTable[(int)(x >>  7) & MASK_5BITS]; // 32-5*5 =  7\n-                    buffer[pos++] = encodeTable[(int)(x >>  2) & MASK_5BITS]; // 32-6*5 =  2\n-                    buffer[pos++] = encodeTable[(int)(x <<  3) & MASK_5BITS]; // 5-2 = 3\n-                    buffer[pos++] = PAD;\n-                    break;\n-            }\n-            // Don't want to append the CRLF two times in a row, so make sure previous\n-            // character is not from CRLF!\n-            byte b = lineSeparator[lineSeparator.length - 1];\n-            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\n+                    buffer[pos++] = PAD;\n+                    break;\n+            }\n+            if (lineLength > 0){ // add chunk separator if required\n                 System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n-            }\n+            }            \n         } else {\n             for (int i = 0; i < inAvail; i++) {\n-                if (buffer == null || buffer.length - pos < encodeSize) {\n-                    resizeBuffer();\n-                }\n+                ensureBufferSize(encodeSize);\n                 modulus = (++modulus) % BITS_PER_ENCODED_CHAR;\n                 int b = in[inPos++];\n                 if (b < 0) {\n                     b += 256;\n                 }\n-                x = (x << 8) + b; // ??\n+                bitWorkArea = (bitWorkArea << 8) + b; // ??\n                 if (0 == modulus) { // we have enough bytes to create our output \n-                    buffer[pos++] = encodeTable[(int)(x >> 35) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(x >> 30) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(x >> 25) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(x >> 20) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(x >> 15) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(x >> 10) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(x >> 5) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)x & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 35) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 30) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 25) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 20) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 15) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 10) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 5) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)bitWorkArea & MASK_5BITS];\n                     currentLinePos += BYTES_PER_ENCODED_BLOCK;\n                     if (lineLength > 0 && lineLength <= currentLinePos) {\n                         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n             eof = true;\n         }\n         for (int i = 0; i < inAvail; i++) {\n-            if (buffer == null || buffer.length - pos < decodeSize) {\n-                resizeBuffer();\n-            }\n             byte b = in[inPos++];\n             if (b == PAD) {\n                 // We're done.\n                 eof = true;\n                 break;\n             } else {\n+                ensureBufferSize(decodeSize);\n                 if (b >= 0 && b < this.decodeTable.length) {\n                     int result = this.decodeTable[b];\n                     if (result >= 0) {\n                         modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK;\n-                        x = (x << BITS_PER_ENCODED_CHAR) + result; // collect decoded bytes\n+                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_CHAR) + result; // collect decoded bytes\n                         if (modulus == 0) { // we can output the 5 bytes\n-                            buffer[pos++] = (byte) ((x >> 32) & MASK_8BITS);\n-                            buffer[pos++] = (byte) ((x >> 24) & MASK_8BITS);\n-                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n-                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n-                            buffer[pos++] = (byte) (x & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                            buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);\n                         }\n                     }\n                 }\n         // Two forms of EOF as far as Base32 decoder is concerned: actual\n         // EOF (-1) and first time '=' character is encountered in stream.\n         // This approach makes the '=' padding characters completely optional.\n-        if (eof && modulus != 0) {\n-            if (buffer == null || buffer.length - pos < decodeSize) {\n-                resizeBuffer();\n-            }\n+        if (eof && modulus >= 2) { // if modulus < 2, nothing to do\n+            ensureBufferSize(decodeSize);\n     \n             //  we ignore partial bytes, i.e. only multiples of 8 count\n             switch (modulus) {\n                 case 2 : // 10 bits, drop 2 and output one byte\n-                    buffer[pos++] = (byte) ((x >> 2) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);\n                     break;\n                 case 3 : // 15 bits, drop 7 and output 1 byte\n-                    buffer[pos++] = (byte) ((x >> 7) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);\n                     break;\n                 case 4 : // 20 bits = 2*8 + 4\n-                    x = x >> 4; // drop 4 bits\n-                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n+                    bitWorkArea = bitWorkArea >> 4; // drop 4 bits\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n                     break;\n                 case 5 : // 25bits = 3*8 + 1\n-                    x = x >> 1;\n-                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n+                    bitWorkArea = bitWorkArea >> 1;\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n                     break;\n                 case 6 : // 30bits = 3*8 + 6\n-                    x = x >> 6;\n-                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n+                    bitWorkArea = bitWorkArea >> 6;\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n                     break;\n                 case 7 : // 35 = 4*8 +3\n-                    x = x >> 3;\n-                    buffer[pos++] = (byte) ((x >> 24) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n-                    break;\n-            }\n-        }\n-    }\n-\n-  /**\n-  * Pre-calculates the amount of space needed to Base32-encode the supplied array.\n-  *\n-  * @param pArray byte[] array which will later be encoded\n-  * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n-  *        chunkSeparator (e.g. CRLF).\n-  * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n-  *\n-  * @return amount of space needed to encoded the supplied array.  Returns\n-  *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n-  */\n- private static long getEncodeLength(byte[] pArray, int chunkSize,\n-         byte[] chunkSeparator) {\n-             // Base32 always encodes to multiples of 8 (BYTES_PER_ENCODED_CHUNK).\n-             chunkSize = (chunkSize / BYTES_PER_ENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK;\n-         \n-             long len = (pArray.length * BYTES_PER_ENCODED_BLOCK) / BYTES_PER_UNENCODED_BLOCK;\n-             long mod = len % BYTES_PER_ENCODED_BLOCK;\n-             if (mod != 0) {\n-                 len += BYTES_PER_ENCODED_BLOCK - mod;\n-             }\n-             if (chunkSize > 0) {\n-                 boolean lenChunksPerfectly = len % chunkSize == 0;\n-                 len += (len / chunkSize) * chunkSeparator.length;\n-                 if (!lenChunksPerfectly) {\n-                     len += chunkSeparator.length;\n-                 }\n-             }\n-             return len;\n-         }\n-\n+                    bitWorkArea = bitWorkArea >> 3;\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    break;\n+            }\n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/codec/binary/BaseNCodec.java\n+++ b/src/java/org/apache/commons/codec/binary/BaseNCodec.java\n \n     private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n \n+    /**\n+     * Defines the default buffer size - currently {@value}\n+     * - must be large enough for at least one encoded block+separator\n+     */\n     private static final int DEFAULT_BUFFER_SIZE = 8192;\n+\n+    /** Mask used to extract 8 bits, used in decoding bytes */\n+    protected static final int MASK_8BITS = 0xff;\n+\n+    /**\n+     * Byte used to pad output.\n+     */\n+    protected final byte PAD = '='; // instance variable just in case it needs to vary later\n+\n+    /** Number of bytes in each full block of unencoded data, e.g. 4 for Base64 and 5 for Base32 */\n+    private final int unencodedBlockSize;\n+\n+    /** Number of bytes in each full block of encoded data, e.g. 3 for Base64 and 8 for Base32 */\n+    private final int encodedBlockSize;\n+\n+    /**\n+     * Chunksize for encoding. Not used when decoding. \n+     * A value of zero or less implies no chunking of the encoded data.\n+     * Rounded down to nearest multiple of encodedBlockSize.\n+     */\n+    protected final int lineLength;\n+    \n+    /**\n+     * Size of chunk separator. Not used unless {@link #lineLength} > 0. \n+     */\n+    private final int chunkSeparatorLength;\n+\n     /**\n      * Buffer for streaming.\n      */\n     protected boolean eof;\n \n     /**\n-     * Place holder for the bytes we're dealing with for our based logic. Bitwise operations store and extract the\n-     * encoding or decoding from this variable.\n-     */\n-    protected long x;\n+     * Place holder for the bytes we're dealing with for our based logic. \n+     * Bitwise operations store and extract the encoding or decoding from this variable.\n+     */\n+    protected long bitWorkArea;\n \n     /**\n      * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n      */\n     protected int modulus;\n \n-    protected BaseNCodec(){\n+    /**\n+     * Note <code>lineLength</code> is rounded down to the nearest multiple of {@link encodedBlockSize}\n+     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\n+     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\n+     * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\n+     * @param chunkSeparatorLength the chunk separator length, if relevant\n+     */\n+    protected BaseNCodec(int unencodedBlockSize, int encodedBlockSize, int lineLength, int chunkSeparatorLength){\n+        this.unencodedBlockSize = unencodedBlockSize;\n+        this.encodedBlockSize = encodedBlockSize;\n+        this.lineLength = (lineLength > 0  && chunkSeparatorLength > 0) ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;\n+        this.chunkSeparatorLength = chunkSeparatorLength;\n     }\n \n     /**\n         return buffer != null ? pos - readPos : 0;\n     }\n \n-    /** Doubles our buffer. */\n-    protected void resizeBuffer() {\n+    /**\n+     * Get the default buffer size. Can be overridden.\n+     * \n+     * @return {@link DEFAULT_BUFFER_RESIZE_SIZE}\n+     */\n+    protected int getDefaultBufferSize() {\n+        return DEFAULT_BUFFER_SIZE;\n+    }\n+\n+    /** Increases our buffer by the {@link DEFAULT_BUFFER_RESIZE_FACTOR}. */\n+    private void resizeBuffer() {\n         if (buffer == null) {\n-            buffer = new byte[DEFAULT_BUFFER_SIZE];\n+            buffer = new byte[getDefaultBufferSize()];\n             pos = 0;\n             readPos = 0;\n         } else {\n     }\n \n     /**\n-     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n-     * bytes. Returns how many bytes were actually extracted.\n+     * Ensure that the buffer has room for <code>size</code> bytes\n+     * \n+     * @param size minimum spare space required\n+     */\n+    protected void ensureBufferSize(int size){\n+        if ((buffer == null) || (buffer.length < pos + size)){\n+            resizeBuffer();\n+        }\n+    }\n+\n+    /**\n+     * Extracts buffered data into the provided byte[] array, starting at position bPos, \n+     * up to a maximum of bAvail bytes. Returns how many bytes were actually extracted.\n      * \n      * @param b\n      *            byte[] array to extract the buffered data into.\n             System.arraycopy(buffer, readPos, b, bPos, len);\n             readPos += len;\n             if (readPos >= pos) {\n-                buffer = null;\n+                buffer = null; // so hasData() will return false, and this method can return -1\n             }\n             return len;\n         }\n     }\n \n     /**\n-     * Resets this Base32 object to its initial newly constructed state.\n+     * Resets this object to its initial newly constructed state.\n      */\n     private void reset() {\n         buffer = null;\n         modulus = 0;\n         eof = false;\n     }\n-    /**\n-     * Encodes an Object using the Base32 algorithm. This method is provided in order to satisfy the requirements of the\n+\n+    /**\n+     * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of the\n      * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n      * \n      * @param pObject\n      *            Object to encode\n-     * @return An object (of type byte[]) containing the Base32 encoded data which corresponds to the byte[] supplied.\n+     * @return An object (of type byte[]) containing the Base-N encoded data which corresponds to the byte[] supplied.\n      * @throws EncoderException\n      *             if the parameter supplied is not of type byte[]\n      */\n     public Object encode(Object pObject) throws EncoderException {\n         if (!(pObject instanceof byte[])) {\n-            throw new EncoderException(\"Parameter supplied to Base32 encode is not a byte[]\");\n+            throw new EncoderException(\"Parameter supplied to Base-N encode is not a byte[]\");\n         }\n         return encode((byte[]) pObject);\n     }\n-    /**\n-     * Encodes a byte[] containing binary data, into a String containing characters in the Base32 alphabet.\n+\n+    /**\n+     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.\n      *\n      * @param pArray\n      *            a byte array containing binary data\n-     * @return A String containing only Base32 character data\n+     * @return A String containing only Base-N character data\n      */\n     public String encodeToString(byte[] pArray) {\n         return StringUtils.newStringUtf8(encode(pArray));\n     }\n-    /**\n-     * Decodes an Object using the Base32 algorithm. This method is provided in order to satisfy the requirements of the\n+\n+    /**\n+     * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of the\n      * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n      * \n      * @param pObject\n         } else if (pObject instanceof String) {\n             return decode((String) pObject);\n         } else {\n-            throw new DecoderException(\"Parameter supplied to Base32 decode is not a byte[] or a String\");\n-        }\n-    }\n-    /**\n-     * Decodes a String containing characters in the Base32 alphabet.\n+            throw new DecoderException(\"Parameter supplied to Base-N decode is not a byte[] or a String\");\n+        }\n+    }\n+\n+    /**\n+     * Decodes a String containing characters in the Base-N alphabet.\n      *\n      * @param pArray\n-     *            A String containing Base32 character data\n+     *            A String containing Base-N character data\n      * @return a byte array containing binary data\n      */\n     public byte[] decode(String pArray) {\n         return decode(StringUtils.getBytesUtf8(pArray));\n     }\n-    /**\n-     * Decodes a byte[] containing characters in the Base32 alphabet.\n+\n+    /**\n+     * Decodes a byte[] containing characters in the Base-N alphabet.\n      * \n      * @param pArray\n-     *            A byte array containing Base32 character data\n+     *            A byte array containing Base-N character data\n      * @return a byte array containing binary data\n      */\n     public byte[] decode(byte[] pArray) {\n         readResults(result, 0, result.length);\n         return result;\n     }\n-    /**\n-     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base32 alphabet.\n+\n+    /**\n+     * Encodes a byte[] containing binary data, into a byte[] containing characters in the alphabet.\n      * \n      * @param pArray\n      *            a byte array containing binary data\n-     * @return A byte array containing only Base32 character data\n+     * @return A byte array containing only the basen alphabetic character data\n      */\n     public byte[] encode(byte[] pArray) {\n         reset();        \n         return buf;\n     }\n     \n+    /**\n+     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.\n+     * Uses UTF8 encoding.\n+     * \n+     * @param pArray a byte array containing binary data\n+     * @return String containing only character data in the appropriate alphabet.\n+    */\n+    public String encodeAsString(byte[] pArray){\n+        return StringUtils.newStringUtf8(encode(pArray));\n+    }\n+\n     abstract void encode(byte[] pArray, int i, int length);  // package protected for access from I/O streams\n \n     abstract void decode(byte[] pArray, int i, int length); // package protected for access from I/O streams\n+    \n+    /**\n+     * Returns whether or not the <code>octet</code> is in the current alphabet.\n+     * Does not allow whitespace or pad.\n+     * \n+     * @param octet The value to test\n+     * \n+     * @return <code>true</code> if the value is defined in the current alphabet, <code>false</code> otherwise.\n+     */\n+    protected abstract boolean isInAlphabet(byte b);\n+    \n+    /**\n+     * Tests a given byte array to see if it contains only valid characters within the alphabet.\n+     * The method optionally treats whitespace and pad as valid.\n+     * \n+     * @param arrayOctet byte array to test\n+     * @param allowWSPad if <code>true</code>, then whitespace and PAD are also allowed\n+     * \n+     * @return <code>true</code> if all bytes are valid characters in the alphabet or if the byte array is empty;\n+     *         <code>false</code>, otherwise\n+     */    \n+    public boolean isInAlphabet(byte[] arrayOctet, boolean allowWSPad) {\n+        for (int i = 0; i < arrayOctet.length; i++) {\n+            if (!isInAlphabet(arrayOctet[i]) &&\n+                    (!allowWSPad || (arrayOctet[i] != PAD) && !isWhiteSpace(arrayOctet[i]))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Tests a given String to see if it contains only valid characters within the alphabet. \n+     * The method treats whitespace and PAD as valid.\n+     * \n+     * @param basen String to test\n+     * @return <code>true</code> if all characters in the String are valid characters in the alphabet or if\n+     *         the String is empty; <code>false</code>, otherwise\n+     * @see #isInAlphabet(byte[], boolean)\n+     */\n+    public boolean isInAlphabet(String basen) {\n+        return isInAlphabet(StringUtils.getBytesUtf8(basen), true);\n+    }\n+\n+    /**\n+     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.\n+     * \n+     * Intended for use in checking line-ending arrays\n+     * \n+     * @param arrayOctet\n+     *            byte array to test\n+     * @return <code>true</code> if any byte is a valid character in the alphabet or PAD; <code>false</code> otherwise\n+     */\n+    protected boolean containsAlphabetOrPad(byte[] arrayOctet) {\n+        if (arrayOctet == null) {\n+            return false;\n+        }\n+        for (int i = 0; i < arrayOctet.length; i++) {\n+            if (PAD == arrayOctet[i] || isInAlphabet(arrayOctet[i])) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Calculates the amount of space needed to encode the supplied array.\n+     *\n+     * @param pArray byte[] array which will later be encoded\n+     *\n+     * @return amount of space needed to encoded the supplied array.  Returns\n+     *         a long since a max-len array will require > Integer.MAX_VALUE\n+     */\n+    public long getEncodedLength(byte[] pArray) {\n+        // Calculate non-chunked size - rounded up to allow for padding\n+        long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * encodedBlockSize;\n+        if (lineLength > 0) { // We're using chunking\n+            // Round up to nearest multiple\n+            len += ((len + lineLength-1) / lineLength) * chunkSeparatorLength;\n+        }\n+        return len;\n+    }\n }\n--- a/src/test/org/apache/commons/codec/binary/Base32Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base32Test.java\n  */\n \n package org.apache.commons.codec.binary;\n+\n+import java.util.Arrays;\n \n import junit.framework.TestCase;\n \n \n \n     public void testBase32Samples() throws Exception {\n+        Base32 codec = new Base32();\n         for (int i = 0; i < BASE32_TEST_CASES.length; i++) {\n-                assertEquals(BASE32_TEST_CASES[i][1], Base32.encodeBase32String(BASE32_TEST_CASES[i][0].getBytes(\"UTF-8\")));\n+                assertEquals(BASE32_TEST_CASES[i][1], codec.encodeAsString(BASE32_TEST_CASES[i][0].getBytes(\"UTF-8\")));\n         }\n     }\n \n     public void testBase32HexSamples() throws Exception {\n+        Base32 codec = new Base32(true);\n         for (int i = 0; i < BASE32HEX_TEST_CASES.length; i++) {\n-                assertEquals(BASE32HEX_TEST_CASES[i][1], Base32.encodeBase32HexString(BASE32HEX_TEST_CASES[i][0].getBytes(\"UTF-8\")));\n+                assertEquals(BASE32HEX_TEST_CASES[i][1], codec.encodeAsString(BASE32HEX_TEST_CASES[i][0].getBytes(\"UTF-8\")));\n         }\n     }\n \n+    public void testSingleCharEncoding() {\n+        for (int i = 0; i < 20; i++) {\n+            Base32 codec = new Base32();\n+            byte unencoded[] = new byte[i];\n+            byte allInOne[] = codec.encode(unencoded);\n+            codec = new Base32();\n+            for (int j=0; j< unencoded.length; j++) {\n+                codec.encode(unencoded, j, 1);\n+            }\n+            codec.encode(unencoded, 0, -1);\n+            byte singly[] = new byte[allInOne.length];\n+            int bytes = codec.readResults(singly, 0, 100);\n+            if (!Arrays.equals(allInOne, singly)){\n+                fail();\n+            }\n+        }\n+    }\n+\n+    public void testRandomBytes() {\n+        for (int i = 0; i < 20; i++) {\n+            Base32 codec = new Base32();\n+            byte[][] b = Base32TestData.randomData(codec, i);\n+            assertEquals(\"\"+i+\" \"+codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));\n+            //assertEquals(b[0],codec.decode(b[1]));\n+        }\n+    }\n+    public void testRandomBytesChunked() {\n+        for (int i = 0; i < 20; i++) {\n+            Base32 codec = new Base32(10);\n+            byte[][] b = Base32TestData.randomData(codec, i);\n+            assertEquals(\"\"+i+\" \"+codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));\n+            //assertEquals(b[0],codec.decode(b[1]));\n+        }\n+    }\n+    public void testRandomBytesHex() {\n+        for (int i = 0; i < 20; i++) {\n+            Base32 codec = new Base32(true);\n+            byte[][] b = Base32TestData.randomData(codec, i);\n+            assertEquals(\"\"+i+\" \"+codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));\n+            //assertEquals(b[0],codec.decode(b[1]));\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/binary/BaseNCodecTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import junit.framework.TestCase;\n+\n+public class BaseNCodecTest extends TestCase {\n+\n+    BaseNCodec codec;\n+    \n+    public void setUp(){\n+        codec = new BaseNCodec(0, 0, 0, 0) {\n+            protected boolean isInAlphabet(byte b) {\n+                return b=='O' || b == 'K'; // allow OK\n+            }\n+            \n+            void encode(byte[] pArray, int i, int length) {\n+            }\n+            \n+            void decode(byte[] pArray, int i, int length) {\n+            }\n+        };        \n+    }\n+\n+    public void testBaseNCodec() {\n+        assertNotNull(codec);\n+    }\n+\n+//    public void testHasData() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    public void testAvail() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    public void testEnsureBufferSize() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    public void testReadResults() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+    public void testIsWhiteSpace() {\n+        assertTrue(BaseNCodec.isWhiteSpace((byte) ' '));\n+        assertTrue(BaseNCodec.isWhiteSpace((byte) '\\n'));\n+        assertTrue(BaseNCodec.isWhiteSpace((byte) '\\r'));\n+        assertTrue(BaseNCodec.isWhiteSpace((byte) '\\t'));\n+    }\n+//\n+//    public void testEncodeObject() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    public void testEncodeToString() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    public void testDecodeObject() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    public void testDecodeString() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    public void testDecodeByteArray() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    public void testEncodeByteArray() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    public void testEncodeAsString() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    public void testEncodeByteArrayIntInt() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    public void testDecodeByteArrayIntInt() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+    public void testIsInAlphabetByte() {\n+        assertFalse(codec.isInAlphabet((byte) 0));\n+        assertFalse(codec.isInAlphabet((byte) 'a'));\n+        assertTrue(codec.isInAlphabet((byte) 'O'));\n+        assertTrue(codec.isInAlphabet((byte) 'K'));\n+    }\n+\n+    public void testIsInAlphabetByteArrayBoolean() {\n+        assertTrue(codec.isInAlphabet(new byte[]{}, false));\n+        assertTrue(codec.isInAlphabet(new byte[]{'O'}, false));\n+        assertFalse(codec.isInAlphabet(new byte[]{'O',' '}, false));\n+        assertFalse(codec.isInAlphabet(new byte[]{' '}, false));\n+        assertTrue(codec.isInAlphabet(new byte[]{}, true));\n+        assertTrue(codec.isInAlphabet(new byte[]{'O'}, true));\n+        assertTrue(codec.isInAlphabet(new byte[]{'O',' '}, true));\n+        assertTrue(codec.isInAlphabet(new byte[]{' '}, true));\n+    }\n+\n+    public void testIsInAlphabetString() {\n+        assertTrue(codec.isInAlphabet(\"OK\"));\n+        assertTrue(codec.isInAlphabet(\"O=K= \\t\\n\\r\"));\n+    }\n+\n+    public void testContainsAlphabetOrPad() {\n+        assertTrue(codec.containsAlphabetOrPad(\"OK\".getBytes()));\n+        assertTrue(codec.containsAlphabetOrPad(\"OK \".getBytes()));\n+        assertFalse(codec.containsAlphabetOrPad(\"ok \".getBytes()));\n+        assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD}));\n+    }\n+\n+//    public void testGetEncodedLength() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+}", "timestamp": 1296156484, "metainfo": ""}