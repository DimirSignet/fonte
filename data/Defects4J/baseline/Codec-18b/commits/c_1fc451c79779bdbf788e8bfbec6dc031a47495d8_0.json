{"sha": "1fc451c79779bdbf788e8bfbec6dc031a47495d8", "log": "[CODEC-130] Provided implementation of skip and available for BaseNCodecInputStream, added unit tests.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\n         return false; // not an easy job to support marks\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws IllegalArgumentException if the provided skip length is negative\n+     */\n+    @Override\n+    public long skip(long n) throws IOException {\n+        if (n < 0) {\n+            throw new IllegalArgumentException(\"Negative skip length\");\n+        }\n+\n+        // skip in chunks of 512 bytes\n+        final byte[] b = new byte[512];\n+        final int max = (int) Math.min(n, Integer.MAX_VALUE);\n+        int total = 0;\n+\n+        while (total < max) {\n+            int len = max - total;\n+            if (len > b.length) {\n+                len = b.length;\n+            }\n+            len = read(b, 0, len);\n+            if (len == EOF) {\n+                break;\n+            }\n+            total += len;\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,\n+     * <code>1</code> otherwise\n+     */\n+    public int available() throws IOException {\n+        // Note: the logic is similar to the InflaterInputStream:\n+        //       as long as we have not reached EOF, indicate that there is more\n+        //       data available. As we do not know for sure how much data is left,\n+        //       just return 1 as a safe guess.\n+\n+        // use the EOF flag of the underlying codec instance\n+        if (baseNCodec.eof) {\n+            return 0;\n+        } else {\n+            return 1;\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java\n import java.io.InputStream;\n import java.util.Arrays;\n \n-import org.junit.Ignore;\n import org.junit.Test;\n \n public class Base32InputStreamTest {\n      * Tests the problem reported in CODEC-130. Missing / wrong implementation of skip.\n      */\n     @Test\n-    @Ignore\n     public void testCodec130() throws IOException {\n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         Base32OutputStream base32os = new Base32OutputStream(bos);\n     // }\n \n     /**\n+     * Tests skipping past the end of a stream.\n+     * \n+     * @throws Throwable\n+     */\n+    @Test\n+    public void testAvailable() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        Base32InputStream b32stream = new Base32InputStream(ins);\n+        assertEquals(1, b32stream.available());\n+        assertEquals(3, b32stream.skip(10));\n+        // End of stream reached\n+        assertEquals(0, b32stream.available());\n+        assertEquals(-1, b32stream.read());\n+        assertEquals(-1, b32stream.read());\n+        assertEquals(0, b32stream.available());\n+    }\n+\n+    /**\n      * Tests the Base32InputStream implementation against empty input.\n      * \n      * @throws Exception\n     }\n \n     /**\n+     * Tests skipping number of characters larger than the internal buffer.\n+     * \n+     * @throws Throwable\n+     */\n+    @Test\n+    public void testSkipBig() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        Base32InputStream b32stream = new Base32InputStream(ins);\n+        assertEquals(3, b32stream.skip(1024));\n+        // End of stream reached\n+        assertEquals(-1, b32stream.read());\n+        assertEquals(-1, b32stream.read());\n+    }\n+\n+    /**\n      * Tests skipping past the end of a stream.\n      * \n      * @throws Throwable\n     public void testSkipPastEnd() throws Throwable {\n         InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n         Base32InputStream b32stream = new Base32InputStream(ins);\n-        assertEquals(8, b32stream.skip(10));\n+        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded\n+        assertEquals(3, b32stream.skip(10));\n         // End of stream reached\n         assertEquals(-1, b32stream.read());\n         assertEquals(-1, b32stream.read());\n     public void testSkipToEnd() throws Throwable {\n         InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n         Base32InputStream b32stream = new Base32InputStream(ins);\n-        assertEquals(8, b32stream.skip(8));\n+        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded\n+        assertEquals(3, b32stream.skip(3));\n         // End of stream reached\n         assertEquals(-1, b32stream.read());\n         assertEquals(-1, b32stream.read());\n     }\n+\n+    /**\n+     * Tests if negative arguments to skip are handled correctly.\n+     *\n+     * @throws Throwable\n+     */\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testSkipWrongArgument() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        Base32InputStream b32stream = new Base32InputStream(ins);\n+        b32stream.skip(-10);\n+    }\n }\n--- a/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n import java.io.InputStreamReader;\n import java.util.Arrays;\n \n-import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n      * Tests the problem reported in CODEC-130. Missing / wrong implementation of skip.\n      */\n     @Test\n-    @Ignore\n     public void testCodec130() throws IOException {\n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         Base64OutputStream base64os = new Base64OutputStream(bos);\n \n         String decoded = StringUtils.newStringUtf8(decodedBytes);\n         assertEquals(\"codec-98 NPE Base64InputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded);\n+    }\n+\n+    /**\n+     * Tests skipping past the end of a stream.\n+     *\n+     * @throws Throwable\n+     */\n+    @Test\n+    public void testAvailable() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        Base64InputStream b64stream = new Base64InputStream(ins);\n+        assertEquals(1, b64stream.available());\n+        assertEquals(6, b64stream.skip(10));\n+        // End of stream reached\n+        assertEquals(0, b64stream.available());\n+        assertEquals(-1, b64stream.read());\n+        assertEquals(-1, b64stream.read());\n+        assertEquals(0, b64stream.available());\n     }\n \n     /**\n     }\n \n     /**\n+     * Tests skipping number of characters larger than the internal buffer.\n+     *\n+     * @throws Throwable\n+     */\n+    @Test\n+    public void testSkipBig() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        Base64InputStream b64stream = new Base64InputStream(ins);\n+        assertEquals(6, b64stream.skip(1024));\n+        // End of stream reached\n+        assertEquals(-1, b64stream.read());\n+        assertEquals(-1, b64stream.read());\n+    }\n+\n+    /**\n      * Tests skipping as a noop\n      * \n      * @throws Throwable\n     public void testSkipPastEnd() throws Throwable {\n         InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n         Base64InputStream b64stream = new Base64InputStream(ins);\n-        assertEquals(8, b64stream.skip(10));\n+        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded\n+        assertEquals(6, b64stream.skip(10));\n         // End of stream reached\n         assertEquals(-1, b64stream.read());\n         assertEquals(-1, b64stream.read());\n     public void testSkipToEnd() throws Throwable {\n         InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n         Base64InputStream b64stream = new Base64InputStream(ins);\n-        assertEquals(8, b64stream.skip(8));\n+        // due to CODEC-130, skip now skips correctly decoded characters rather than encoded\n+        assertEquals(6, b64stream.skip(6));\n         // End of stream reached\n         assertEquals(-1, b64stream.read());\n         assertEquals(-1, b64stream.read());\n     }\n+\n+    /**\n+     * Tests if negative arguments to skip are handled correctly.\n+     *\n+     * @throws Throwable\n+     */\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testSkipWrongArgument() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        Base64InputStream b64stream = new Base64InputStream(ins);\n+        b64stream.skip(-10);\n+    }\n }", "timestamp": 1332182022, "metainfo": ""}