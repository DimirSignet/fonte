{"sha": "c5154bc584847d19e75c421b71e2f3499164d2a9", "log": "[CODEC-194] Support java.nio.ByteBuffer in org.apache.commons.codec.binary.Hex.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/Hex.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Hex.java\n \n package org.apache.commons.codec.binary;\n \n+import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n \n import org.apache.commons.codec.BinaryDecoder;\n     }\n \n     /**\n+     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order.\n+     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n+     * given byte.\n+     *\n+     * @param data\n+     *            a byte buffer to convert to Hex characters\n+     * @return A char[] containing hexadecimal characters\n+     * @since 1.11\n+     */\n+    public static char[] encodeHex(final ByteBuffer data) {\n+        return encodeHex(data, true);\n+    }\n+\n+    /**\n      * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n      * The returned array will be double the length of the passed array, as it takes two characters to represent any\n      * given byte.\n      * @since 1.4\n      */\n     public static char[] encodeHex(final byte[] data, final boolean toLowerCase) {\n+        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\n+    }\n+\n+    /**\n+     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order.\n+     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n+     * given byte.\n+     *\n+     * @param data\n+     *            a byte buffer to convert to Hex characters\n+     * @param toLowerCase\n+     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase\n+     * @return A char[] containing hexadecimal characters\n+     * @since 1.11\n+     */\n+    public static char[] encodeHex(final ByteBuffer data, final boolean toLowerCase) {\n         return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\n     }\n \n     }\n \n     /**\n+     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order.\n+     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n+     * given byte.\n+     *\n+     * @param data\n+     *            a byte buffer to convert to Hex characters\n+     * @param toDigits\n+     *            the output alphabet\n+     * @return A char[] containing hexadecimal characters\n+     * @since 1.11\n+     */\n+    protected static char[] encodeHex(final ByteBuffer data, final char[] toDigits) {\n+        return encodeHex(data.array(), toDigits);\n+    }\n+\n+    /**\n      * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\n      * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n      *\n      * @since 1.4\n      */\n     public static String encodeHexString(final byte[] data) {\n+        return new String(encodeHex(data));\n+    }\n+\n+    /**\n+     * Converts a byte buffer into a String representing the hexadecimal values of each byte in order. The returned\n+     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n+     *\n+     * @param data\n+     *            a byte buffer to convert to Hex characters\n+     * @return A String containing hexadecimal characters\n+     * @since 1.11\n+     */\n+    public static String encodeHexString(final ByteBuffer data) {\n         return new String(encodeHex(data));\n     }\n \n     }\n \n     /**\n+     * Converts a buffer of character bytes representing hexadecimal values into an array of bytes of those same values.\n+     * The returned array will be half the length of the passed array, as it takes two characters to represent any given\n+     * byte. An exception is thrown if the passed char array has an odd number of elements.\n+     *\n+     * @param buffer\n+     *            An array of character bytes containing hexadecimal digits\n+     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n+     * @throws DecoderException\n+     *             Thrown if an odd number of characters is supplied to this function\n+     * @see #decodeHex(char[])\n+     * @since 1.11\n+     */\n+    public byte[] decode(final ByteBuffer buffer) throws DecoderException {\n+        return decodeHex(new String(buffer.array(), getCharset()).toCharArray());\n+    }\n+\n+    /**\n      * Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those\n      * same values. The returned array will be half the length of the passed String or array, as it takes two characters\n      * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.\n      *\n      * @param object\n-     *            A String or, an array of character bytes containing hexadecimal digits\n+     *            A String, ByteBuffer, byte[], or an array of character bytes containing hexadecimal digits\n      * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n      * @throws DecoderException\n      *             Thrown if an odd number of characters is supplied to this function or the object is not a String or\n      */\n     @Override\n     public Object decode(final Object object) throws DecoderException {\n-        try {\n-            final char[] charArray = object instanceof String ? ((String) object).toCharArray() : (char[]) object;\n-            return decodeHex(charArray);\n-        } catch (final ClassCastException e) {\n-            throw new DecoderException(e.getMessage(), e);\n+        if (object instanceof String) {\n+            return decode(((String) object).toCharArray());\n+        } else if (object instanceof byte[]) {\n+            return decode((byte[]) object);\n+        } else if (object instanceof ByteBuffer) {\n+            return decode((ByteBuffer) object);\n+        } else {\n+            try {\n+                return decodeHex((char[]) object);\n+            } catch (final ClassCastException e) {\n+                throw new DecoderException(e.getMessage(), e);\n+            }\n         }\n     }\n \n     }\n \n     /**\n+     * Converts byte buffer into an array of bytes for the characters representing the hexadecimal values of each\n+     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to\n+     * represent any given byte.\n+     * <p>\n+     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by\n+     * {@link #getCharset()}.\n+     * </p>\n+     *\n+     * @param array\n+     *            a byte buffer to convert to Hex characters\n+     * @return A byte[] containing the bytes of the hexadecimal characters\n+     * @see #encodeHex(byte[])\n+     * @since 1.11\n+     */\n+    public byte[] encode(final ByteBuffer array) {\n+        return encodeHexString(array).getBytes(this.getCharset());\n+    }\n+\n+    /**\n      * Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each\n      * byte in order. The returned array will be double the length of the passed String or array, as it takes two\n      * characters to represent any given byte.\n      * </p>\n      *\n      * @param object\n-     *            a String, or byte[] to convert to Hex characters\n+     *            a String, ByteBuffer, or byte[] to convert to Hex characters\n      * @return A char[] containing hexadecimal characters\n      * @throws EncoderException\n      *             Thrown if the given object is not a String or byte[]\n      */\n     @Override\n     public Object encode(final Object object) throws EncoderException {\n-        try {\n-            final byte[] byteArray = object instanceof String ?\n-                                   ((String) object).getBytes(this.getCharset()) : (byte[]) object;\n-            return encodeHex(byteArray);\n-        } catch (final ClassCastException e) {\n-            throw new EncoderException(e.getMessage(), e);\n-        }\n+        byte[] byteArray;\n+        if (object instanceof String) {\n+            byteArray = ((String) object).getBytes(this.getCharset());\n+        } else if (object instanceof ByteBuffer) {\n+            byteArray = ((ByteBuffer) object).array();\n+        } else {\n+            try {\n+                byteArray = (byte[]) object;\n+            } catch (final ClassCastException e) {\n+                throw new EncoderException(e.getMessage(), e);\n+            }\n+        }\n+        return encodeHex(byteArray);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n package org.apache.commons.codec.binary;\n \n import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n \n import org.apache.commons.codec.CharEncoding;\n     }\n \n     /**\n+     * Calls {@link String#getBytes(Charset)}\n+     *\n+     * @param string\n+     *            The string to encode (if null, return null).\n+     * @param charset\n+     *            The {@link Charset} to encode the <code>String</code>\n+     * @return the encoded bytes\n+     * @since 1.11\n+     */\n+    private static ByteBuffer getByteBuffer(final String string, final Charset charset) {\n+        if (string == null) {\n+            return null;\n+        }\n+        return ByteBuffer.wrap(string.getBytes(charset));\n+    }\n+\n+    /**\n+     * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte\n+     * array.\n+     *\n+     * @param string\n+     *            the String to encode, may be <code>null</code>\n+     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n+     * @throws NullPointerException\n+     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n+     *             required by the Java platform specification.\n+     * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getBytesUnchecked(String, String)\n+     * @since 1.11\n+     */\n+    public static ByteBuffer getByteBufferUtf8(final String string) {\n+        return getByteBuffer(string, Charsets.UTF_8);\n+    }\n+\n+    /**\n      * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n      * byte array.\n      *\n--- a/src/test/java/org/apache/commons/codec/binary/HexTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/HexTest.java\n import java.util.Arrays;\n import java.util.Random;\n \n+import org.apache.commons.codec.Charsets;\n import org.apache.commons.codec.DecoderException;\n import org.apache.commons.codec.EncoderException;\n import org.junit.Assert;\n      * @throws UnsupportedEncodingException\n      * @throws DecoderException\n      */\n-    private void testCustomCharset(final String name, final String parent) throws UnsupportedEncodingException, DecoderException {\n+    private void testCustomCharset(final String name, final String parent) throws UnsupportedEncodingException,\n+            DecoderException {\n         if (charsetSanityCheck(name) == false) {\n             return;\n         }\n         Assert.assertTrue(Arrays.equals(expectedHexStringBytes, actualEncodedBytes));\n         // test 2\n         String actualStringFromBytes = new String(actualEncodedBytes, name);\n-        assertEquals(name + \", expectedHexString=\" + expectedHexString + \", actualStringFromBytes=\" + actualStringFromBytes,\n-                expectedHexString, actualStringFromBytes);\n+        assertEquals(name + \", expectedHexString=\" + expectedHexString + \", actualStringFromBytes=\" +\n+                actualStringFromBytes, expectedHexString, actualStringFromBytes);\n         // second test:\n         final Hex utf8Codec = new Hex();\n         expectedHexString = \"48656c6c6f20576f726c64\";\n         assertEquals(name, sourceString, actualStringFromBytes);\n     }\n \n-    @Test(expected=UnsupportedCharsetException.class)\n+    @Test(expected = UnsupportedCharsetException.class)\n     public void testCustomCharsetBadName() {\n         new Hex(BAD_ENCODING_NAME);\n     }\n     }\n \n     @Test\n+    public void testDecodeByteBufferEmpty() throws DecoderException {\n+        assertTrue(Arrays.equals(new byte[0], new Hex().decode(ByteBuffer.allocate(0))));\n+    }\n+\n+    @Test\n     public void testDecodeCharArrayEmpty() throws DecoderException {\n         assertTrue(Arrays.equals(new byte[0], Hex.decodeHex(new char[0])));\n     }\n     @Test\n     public void testDecodeByteArrayOddCharacters() {\n         try {\n-            new Hex().decode(new byte[]{65});\n+            new Hex().decode(new byte[] { 65 });\n             fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n         } catch (final DecoderException e) {\n             // Expected exception\n     }\n \n     @Test\n+    public void testDecodeByteBufferOddCharacters() {\n+        ByteBuffer buffer = ByteBuffer.allocate(1);\n+        buffer.put((byte) 65);\n+        try {\n+            new Hex().decode(buffer);\n+            fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n+        } catch (final DecoderException e) {\n+            // Expected exception\n+        }\n+    }\n+\n+    @Test\n     public void testDecodeClassCastException() {\n         try {\n-            new Hex().decode(new int[]{65});\n+            new Hex().decode(new int[] { 65 });\n             fail(\"An exception wasn't thrown when trying to decode.\");\n         } catch (final DecoderException e) {\n             // Expected exception\n \n     @Test\n     public void testDecodeHexCharArrayOddCharacters1() {\n-        checkDecodeHexCharArrayOddCharacters(new char[]{'A'});\n+        checkDecodeHexCharArrayOddCharacters(new char[] { 'A' });\n     }\n \n     @Test\n     public void testDecodeHexCharArrayOddCharacters3() {\n-        checkDecodeHexCharArrayOddCharacters(new char[]{'A', 'B', 'C'});\n+        checkDecodeHexCharArrayOddCharacters(new char[] { 'A', 'B', 'C' });\n     }\n \n     @Test\n     public void testDecodeHexCharArrayOddCharacters5() {\n-        checkDecodeHexCharArrayOddCharacters(new char[]{'A', 'B', 'C', 'D', 'E'});\n+        checkDecodeHexCharArrayOddCharacters(new char[] { 'A', 'B', 'C', 'D', 'E' });\n     }\n \n     @Test\n     }\n \n     @Test\n+    public void testDecodeByteArrayObjectEmpty() throws DecoderException {\n+        assertTrue(Arrays.equals(new byte[0], (byte[]) new Hex().decode((Object) new byte[0])));\n+    }\n+\n+    @Test\n+    public void testDecodeByteBufferObjectEmpty() throws DecoderException {\n+        assertTrue(Arrays.equals(new byte[0], (byte[]) new Hex().decode((Object) ByteBuffer.allocate(0))));\n+    }\n+\n+    @Test\n     public void testEncodeClassCastException() {\n         try {\n-            new Hex().encode(new int[]{65});\n+            new Hex().encode(new int[] { 65 });\n             fail(\"An exception wasn't thrown when trying to encode.\");\n         } catch (final EncoderException e) {\n             // Expected exception\n     public void testEncodeHexByteArrayEmpty() throws EncoderException {\n         assertTrue(Arrays.equals(new char[0], Hex.encodeHex(new byte[0])));\n         assertTrue(Arrays.equals(new byte[0], new Hex().encode(new byte[0])));\n+    }\n+\n+    @Test\n+    public void testEncodeHexByteBufferEmpty() throws EncoderException {\n+        assertTrue(Arrays.equals(new char[0], Hex.encodeHex(ByteBuffer.allocate(0))));\n+        assertTrue(Arrays.equals(new byte[0], new Hex().encode(ByteBuffer.allocate(0))));\n     }\n \n     @Test\n     }\n \n     @Test\n+    public void testEncodeHexByteBufferHelloWorldLowerCaseHex() {\n+        final ByteBuffer b = StringUtils.getByteBufferUtf8(\"Hello World\");\n+        final String expected = \"48656c6c6f20576f726c64\";\n+        char[] actual;\n+        actual = Hex.encodeHex(b);\n+        assertEquals(expected, new String(actual));\n+        actual = Hex.encodeHex(b, true);\n+        assertEquals(expected, new String(actual));\n+        actual = Hex.encodeHex(b, false);\n+        assertFalse(expected.equals(new String(actual)));\n+    }\n+\n+    @Test\n     public void testEncodeHexByteArrayHelloWorldUpperCaseHex() {\n         final byte[] b = StringUtils.getBytesUtf8(\"Hello World\");\n         final String expected = \"48656C6C6F20576F726C64\";\n     }\n \n     @Test\n+    public void testEncodeHexByteBufferHelloWorldUpperCaseHex() {\n+        final ByteBuffer b = StringUtils.getByteBufferUtf8(\"Hello World\");\n+        final String expected = \"48656C6C6F20576F726C64\";\n+        char[] actual;\n+        actual = Hex.encodeHex(b);\n+        assertFalse(expected.equals(new String(actual)));\n+        actual = Hex.encodeHex(b, true);\n+        assertFalse(expected.equals(new String(actual)));\n+        actual = Hex.encodeHex(b, false);\n+        assertTrue(expected.equals(new String(actual)));\n+    }\n+\n+    @Test\n     public void testEncodeHexByteArrayZeroes() {\n         final char[] c = Hex.encodeHex(new byte[36]);\n         assertEquals(\"000000000000000000000000000000000000000000000000000000000000000000000000\", new String(c));\n     }\n \n     @Test\n+    public void testEncodeHexByteBufferZeroes() {\n+        final char[] c = Hex.encodeHex(ByteBuffer.allocate(36));\n+        assertEquals(\"000000000000000000000000000000000000000000000000000000000000000000000000\", new String(c));\n+    }\n+\n+    @Test\n     public void testEncodeStringEmpty() throws EncoderException {\n         assertTrue(Arrays.equals(new char[0], (char[]) new Hex().encode(\"\")));\n+    }\n+\n+    @Test\n+    public void testGetCharset() throws UnsupportedEncodingException, DecoderException {\n+        Assert.assertEquals(Charsets.UTF_8, new Hex(Charsets.UTF_8).getCharset());\n+    }\n+\n+    @Test\n+    public void testGetCharsetName() throws UnsupportedEncodingException, DecoderException {\n+        Assert.assertEquals(Charsets.UTF_8.name(), new Hex(Charsets.UTF_8).getCharsetName());\n+    }\n+\n+    @Test\n+    public void testEncodeByteArrayEmpty() throws EncoderException {\n+        assertTrue(Arrays.equals(new byte[0], new Hex().encode(new byte[0])));\n+    }\n+\n+    @Test\n+    public void testEncodeByteArrayObjectEmpty() throws EncoderException {\n+        assertTrue(Arrays.equals(new char[0], (char[]) new Hex().encode((Object) new byte[0])));\n+    }\n+\n+    @Test\n+    public void testEncodeByteBufferEmpty() throws EncoderException {\n+        assertTrue(Arrays.equals(new byte[0], new Hex().encode(ByteBuffer.allocate(0))));\n+    }\n+\n+    @Test\n+    public void testEncodeByteBufferObjectEmpty() throws EncoderException {\n+        assertTrue(Arrays.equals(new char[0], (char[]) new Hex().encode((Object) ByteBuffer.allocate(0))));\n     }\n \n     @Test", "timestamp": 1415633342, "metainfo": ""}