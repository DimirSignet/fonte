{"sha": "facbc3a39c5eb2ce190c1ec597015da47c51b2c8", "log": "[CODEC-132] BeiderMorseEncoder OOM issues  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n \n     /**\n      * Gets the name type currently in operation.\n-     * \n+     *\n      * @return the NameType currently being used\n      */\n     public NameType getNameType() {\n \n     /**\n      * Gets the rule type currently in operation.\n-     * \n+     *\n      * @return the RuleType currently being used\n      */\n     public RuleType getRuleType() {\n \n     /**\n      * Discovers if multiple possible encodings are concatenated.\n-     * \n+     *\n      * @return true if multiple encodings are concatenated, false if just the first one is returned\n      */\n     public boolean isConcat() {\n \n     /**\n      * Sets how multiple possible phonetic encodings are combined.\n-     * \n+     *\n      * @param concat\n      *            true if multiple encodings are to be combined with a '|', false if just the first one is to be considered\n      */\n     public void setConcat(boolean concat) {\n-        this.engine = new PhoneticEngine(this.engine.getNameType(), this.engine.getRuleType(), concat);\n+        this.engine = new PhoneticEngine(this.engine.getNameType(),\n+                                         this.engine.getRuleType(),\n+                                         concat,\n+                                         this.engine.getMaxPhonemes());\n     }\n \n     /**\n      * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phoentic encodings optimized for Ashkenazi or\n      * Sephardic Jewish family names.\n-     * \n+     *\n      * @param nameType\n      *            the NameType in use\n      */\n     public void setNameType(NameType nameType) {\n-        this.engine = new PhoneticEngine(nameType, this.engine.getRuleType(), this.engine.isConcat());\n+        this.engine = new PhoneticEngine(nameType,\n+                                         this.engine.getRuleType(),\n+                                         this.engine.isConcat(),\n+                                         this.engine.getMaxPhonemes());\n     }\n \n     /**\n      * Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.\n-     * \n+     *\n      * @param ruleType\n      *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches\n      */\n     public void setRuleType(RuleType ruleType) {\n-        this.engine = new PhoneticEngine(this.engine.getNameType(), ruleType, this.engine.isConcat());\n+        this.engine = new PhoneticEngine(this.engine.getNameType(),\n+                                         ruleType,\n+                                         this.engine.isConcat(),\n+                                         this.engine.getMaxPhonemes());\n+    }\n+\n+    /**\n+     * Sets the number of maximum of phonemes that shall be considered by the engine.\n+     *\n+     * @param maxPhonemes\n+     *            the maximum number of phonemes returned by the engine\n+     */\n+    public void setMaxPhonemes(int maxPhonemes) {\n+        this.engine = new PhoneticEngine(this.engine.getNameType(),\n+                                         this.engine.getRuleType(),\n+                                         this.engine.isConcat(),\n+                                         maxPhonemes);\n     }\n \n }\n--- a/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n          * incompatible.\n          *\n          * @param phonemeExpr   the expression to apply\n+         * @param maxPhonemes   the maximum number of phonemes to build up\n          * @return  a new phoneme builder containing the results of <code>phonemeExpr</code> applied to each phoneme\n          *      in turn\n          */\n-        public PhonemeBuilder apply(Rule.PhonemeExpr phonemeExpr) {\n+        public PhonemeBuilder apply(Rule.PhonemeExpr phonemeExpr, int maxPhonemes) {\n             Set<Rule.Phoneme> newPhonemes = new HashSet<Rule.Phoneme>();\n \n-            for (Rule.Phoneme left : this.phonemes) {\n+            EXPR: for (Rule.Phoneme left : this.phonemes) {\n                 for (Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n                     Rule.Phoneme join = left.join(right);\n                     if (!join.getLanguages().isEmpty()) {\n-                        newPhonemes.add(join);\n+                        if (newPhonemes.size() < maxPhonemes) {\n+                            newPhonemes.add(join);\n+                        } else {\n+                            break EXPR;\n+                        }\n                     }\n                 }\n             }\n \n         private PhonemeBuilder phonemeBuilder;\n         private int i;\n+        private int maxPhonemes;\n         private boolean found;\n \n-        public RulesApplication(List<Rule> finalRules, CharSequence input, PhonemeBuilder phonemeBuilder, int i) {\n+        public RulesApplication(List<Rule> finalRules, CharSequence input,\n+                                PhonemeBuilder phonemeBuilder, int i, int maxPhonemes) {\n             if (finalRules == null) {\n                 throw new NullPointerException(\"The finalRules argument must not be null\");\n             }\n             this.phonemeBuilder = phonemeBuilder;\n             this.input = input;\n             this.i = i;\n+            this.maxPhonemes = maxPhonemes;\n         }\n \n         public int getI() {\n                     continue RULES;\n                 }\n \n-                this.phonemeBuilder = this.phonemeBuilder.apply(rule.getPhoneme());\n+                this.phonemeBuilder = this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\n                 this.found = true;\n                 break RULES;\n             }\n         return sb.toString();\n     }\n \n+    private static final int DEFAULT_MAX_PHONEMES = 20;\n+\n     private final Lang lang;\n \n     private final NameType nameType;\n \n     private final boolean concat;\n \n+    private final int maxPhonemes;\n+\n     /**\n      * Generates a new, fully-configured phonetic engine.\n-     * \n+     *\n      * @param nameType\n      *            the type of names it will use\n      * @param ruleType\n      *            if it will concatenate multiple encodings\n      */\n     public PhoneticEngine(NameType nameType, RuleType ruleType, boolean concat) {\n+        this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);\n+    }\n+\n+    /**\n+     * Generates a new, fully-configured phonetic engine.\n+     *\n+     * @param nameType\n+     *            the type of names it will use\n+     * @param ruleType\n+     *            the type of rules it will apply\n+     * @param concat\n+     *            if it will concatenate multiple encodings\n+     * @param maxPhonemes\n+     *            the maximum number of phonemes that will be handled\n+     */\n+    public PhoneticEngine(NameType nameType, RuleType ruleType, boolean concat, int maxPhonemes) {\n         if (ruleType == RuleType.RULES) {\n             throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES);\n         }\n         this.ruleType = ruleType;\n         this.concat = concat;\n         this.lang = Lang.instance(nameType);\n+        this.maxPhonemes = maxPhonemes;\n     }\n \n     /**\n             // System.err.println(\"Expanding: \" + phonemeText);\n \n             for (int i = 0; i < phonemeText.length();) {\n-                RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i).invoke();\n+                RulesApplication rulesApplication =\n+                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\n                 boolean found = rulesApplication.isFound();\n                 subBuilder = rulesApplication.getPhonemeBuilder();\n \n         // loop over each char in the input - we will handle the increment manually\n         CharSequence inputCache = cacheSubSequence(input);\n         for (int i = 0; i < inputCache.length();) {\n-            RulesApplication rulesApplication = new RulesApplication(rules, inputCache, phonemeBuilder, i).invoke();\n+            RulesApplication rulesApplication =\n+                    new RulesApplication(rules, inputCache, phonemeBuilder, i, maxPhonemes).invoke();\n             i = rulesApplication.getI();\n             phonemeBuilder = rulesApplication.getPhonemeBuilder();\n             // System.err.println(input + \" \" + i + \": \" + phonemeBuilder.makeString());\n     public boolean isConcat() {\n         return this.concat;\n     }\n+\n+    /**\n+     * Gets the maximum number of phonemes the engine will calculate for a given input.\n+     *\n+     * @return the maximum number of phonemes\n+     */\n+    public int getMaxPhonemes() {\n+        return this.maxPhonemes;\n+    }\n }\n--- a/src/test/java/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.codec.EncoderException;\n import org.apache.commons.codec.StringEncoder;\n     public void testAllChars() throws EncoderException {\n         BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n         for (char c = Character.MIN_VALUE; c < Character.MAX_VALUE; c++) {\n-            bmpm.encode(\"\" + c);\n+            bmpm.encode(Character.toString(c));\n         }\n     }\n \n     public void testAsciiEncodeNotEmpty1Letter() throws EncoderException {\n         BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n         for (char c = 'a'; c <= 'z'; c++) {\n-            final String value = \"\" + c;\n+            final String value = Character.toString(c);\n             final String valueU = value.toUpperCase();\n             assertNotEmpty(bmpm, value);\n             assertNotEmpty(bmpm, valueU);\n     public void testNegativeIndexForRuleMatchIndexOutOfBoundsException() {\n         Rule r = new Rule(\"a\", \"\", \"\", new Rule.Phoneme(\"\", Languages.ANY_LANGUAGE));\n         r.patternAndContextMatches(\"bob\", -1);\n+    }\n+\n+    @Test\n+    public void testOOM() throws EncoderException {\n+        String phrase = \"200697900'-->&#1913348150;</  bceaeef >aadaabcf\\\"aedfbff<!--\\'-->?>cae\"\n+                + \"cfaaa><?&#<!--</script>&lang&fc;aadeaf?>>&bdquo<    cc =\\\"abff\\\"    /></   afe  >\"\n+                + \"<script><!-- f(';<    cf aefbeef = \\\"bfabadcf\\\" ebbfeedd = fccabeb >\";\n+\n+        BeiderMorseEncoder encoder = new BeiderMorseEncoder();\n+        encoder.setNameType(NameType.GENERIC);\n+        encoder.setRuleType(RuleType.EXACT);\n+        encoder.setMaxPhonemes(10);\n+\n+        String phonemes = encoder.encode(phrase);\n+        assertTrue(phonemes.length() > 0);\n+\n+        String[] phonemeArr = phonemes.split(\"\\\\|\");\n+        assertTrue(phonemeArr.length <= 10);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineTest.java\n package org.apache.commons.codec.language.bm;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n import java.util.Arrays;\n import java.util.List;\n     @Parameterized.Parameters\n     public static List<Object[]> data() {\n         return Arrays\n-                .asList(new Object[] {\n-                        \"Renault\",\n-                        \"rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult\",\n-                        NameType.GENERIC,\n-                        RuleType.APPROX,\n-                        true },\n-                        new Object[] { \"Renault\", \"rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult\", NameType.ASHKENAZI, RuleType.APPROX, true },\n-                        new Object[] { \"Renault\", \"rinDlt\", NameType.SEPHARDIC, RuleType.APPROX, true },\n-                        new Object[] { \"SntJohn-Smith\", \"sntjonsmit\", NameType.GENERIC, RuleType.EXACT, true },\n-                        new Object[] { \"d'ortley\", \"(ortlaj|ortlej)-(dortlaj|dortlej)\", NameType.GENERIC, RuleType.EXACT, true },\n+                .asList(new Object[] { \"Renault\", \"rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult\", NameType.GENERIC, RuleType.APPROX, true, 10 },\n+                        new Object[] { \"Renault\", \"rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult\", NameType.ASHKENAZI, RuleType.APPROX, true, 10 },\n+                        new Object[] { \"Renault\", \"rYnDlt\", NameType.ASHKENAZI, RuleType.APPROX, true, 1 },\n+                        new Object[] { \"Renault\", \"rinDlt\", NameType.SEPHARDIC, RuleType.APPROX, true, 10 },\n+                        new Object[] { \"SntJohn-Smith\", \"sntjonsmit\", NameType.GENERIC, RuleType.EXACT, true, 10 },\n+                        new Object[] { \"d'ortley\", \"(ortlaj|ortlej)-(dortlaj|dortlej)\", NameType.GENERIC, RuleType.EXACT, true, 10 },\n                         new Object[] {\n                                 \"van helsing\",\n                                 \"(elSink|elsink|helSink|helsink|helzink|xelsink)-(banhelsink|fanhelsink|fanhelzink|vanhelsink|vanhelzink|vanjelsink)\",\n                                 NameType.GENERIC,\n                                 RuleType.EXACT,\n-                                false });\n+                                false, 10 });\n     }\n \n     private final boolean concat;\n     private final NameType nameType;\n     private final String phoneticExpected;\n     private final RuleType ruleType;\n+    private final int maxPhonemes;\n \n-    public PhoneticEngineTest(String name, String phoneticExpected, NameType nameType, RuleType ruleType, boolean concat) {\n+    public PhoneticEngineTest(String name, String phoneticExpected, NameType nameType,\n+                              RuleType ruleType, boolean concat, int maxPhonemes) {\n         this.name = name;\n         this.phoneticExpected = phoneticExpected;\n         this.nameType = nameType;\n         this.ruleType = ruleType;\n         this.concat = concat;\n+        this.maxPhonemes = maxPhonemes;\n     }\n \n     @Test(timeout = 10000L)\n     public void testEncode() {\n-        PhoneticEngine engine = new PhoneticEngine(this.nameType, this.ruleType, this.concat);\n+        PhoneticEngine engine = new PhoneticEngine(this.nameType, this.ruleType, this.concat, this.maxPhonemes);\n \n         String phoneticActual = engine.encode(this.name);\n \n         //System.err.println(\"expecting: \" + this.phoneticExpected);\n         //System.err.println(\"actual:    \" + phoneticActual);\n         assertEquals(\"phoneme incorrect\", this.phoneticExpected, phoneticActual);\n+\n+        if (this.concat) {\n+            String[] split = phoneticActual.split(\"\\\\|\");\n+            assertTrue(split.length <= this.maxPhonemes);\n+        } else {\n+            String[] words = phoneticActual.split(\"-\");\n+            for (String word : words) {\n+                String[] split = word.split(\"\\\\|\");\n+                assertTrue(split.length <= this.maxPhonemes);\n+            }\n+        }\n     }\n }", "timestamp": 1331154179, "metainfo": ""}