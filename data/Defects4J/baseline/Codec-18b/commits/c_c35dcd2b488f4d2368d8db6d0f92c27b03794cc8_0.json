{"sha": "c35dcd2b488f4d2368d8db6d0f92c27b03794cc8", "log": "Apply patch based on https://issues.apache.org/jira/secure/attachment/12488362/acz.patch for [CODEC-125]  ", "commit": "\n--- a/src/java/org/apache/commons/codec/language/bm/Lang.java\n+++ b/src/java/org/apache/commons/codec/language/bm/Lang.java\n             }\n         }\n \n-        return Languages.LanguageSet.from(langs);\n+        Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\n+        if (ls.equals(Languages.NO_LANGUAGES)) {\n+            return Languages.ANY_LANGUAGE;\n+        } else {\n+            return ls;\n+        }\n     }\n }\n--- a/src/java/org/apache/commons/codec/language/bm/Languages.java\n+++ b/src/java/org/apache/commons/codec/language/bm/Languages.java\n  * @since 2.0\n  */\n public class Languages {\n+\n+    /**\n+     * A set of languages.\n+     */\n+    public static abstract class LanguageSet {\n+        public static LanguageSet from(Set<String> langs) {\n+            if (langs.isEmpty()) {\n+                return NO_LANGUAGES;\n+            } else {\n+                return new SomeLanguages(langs);\n+            }\n+        }\n+\n+        public abstract boolean contains(String language);\n+\n+        public abstract String getAny();\n+\n+        public abstract boolean isEmpty();\n+\n+        public abstract boolean isSingleton();\n+\n+        public abstract LanguageSet restrictTo(LanguageSet other);\n+    }\n+\n+    /**\n+     * Some languages, explicitly enumerated.\n+     */\n+    public static class SomeLanguages extends LanguageSet {\n+        private final Set<String> languages;\n+\n+        private SomeLanguages(Set<String> languages) {\n+            this.languages = Collections.unmodifiableSet(languages);\n+        }\n+\n+        @Override\n+        public boolean contains(String language) {\n+            return this.languages.contains(language);\n+        }\n+\n+        @Override\n+        public String getAny() {\n+            return this.languages.iterator().next();\n+        }\n+\n+        public Set<String> getLanguages() {\n+            return this.languages;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return this.languages.isEmpty();\n+        }\n+\n+        @Override\n+        public boolean isSingleton() {\n+            return this.languages.size() == 1;\n+        }\n+\n+        @Override\n+        public LanguageSet restrictTo(LanguageSet other) {\n+            if (other == NO_LANGUAGES) {\n+                return other;\n+            } else if (other == ANY_LANGUAGE) {\n+                return this;\n+            } else {\n+                SomeLanguages sl = (SomeLanguages) other;\n+                Set<String> ls = new HashSet<String>(this.languages);\n+                ls.retainAll(sl.languages);\n+                return from(ls);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Languages(\" + languages.toString() + \")\";\n+        }\n+\n+    }\n \n     public static final String ANY = \"any\";\n \n \n     private final Set<String> languages;\n \n+    /**\n+     * No languages at all.\n+     */\n+    public static final LanguageSet NO_LANGUAGES = new LanguageSet() {\n+        @Override\n+        public boolean contains(String language) {\n+            return false;\n+        }\n+\n+        @Override\n+        public String getAny() {\n+            throw new NoSuchElementException(\"Can't fetch any language from the empty language set.\");\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean isSingleton() {\n+            return false;\n+        }\n+\n+        @Override\n+        public LanguageSet restrictTo(LanguageSet other) {\n+            return this;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"NO_LANGUAGES\";\n+        }\n+    };\n+\n+    /**\n+     * Any/all languages.\n+     */\n+    public static final LanguageSet ANY_LANGUAGE = new LanguageSet() {\n+        @Override\n+        public boolean contains(String language) {\n+            return true;\n+        }\n+\n+        @Override\n+        public String getAny() {\n+            throw new NoSuchElementException(\"Can't fetch any language from the any language set.\");\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isSingleton() {\n+            return false;\n+        }\n+\n+        @Override\n+        public LanguageSet restrictTo(LanguageSet other) {\n+            return other;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ANY_LANGUAGE\";\n+        }\n+    };\n+\n     private Languages(Set<String> languages) {\n         this.languages = languages;\n     }\n     public Set<String> getLanguages() {\n         return this.languages;\n     }\n-\n-    /**\n-     * A set of languages.\n-     */\n-    public static abstract class LanguageSet {\n-        public abstract LanguageSet restrictTo(LanguageSet other);\n-\n-        public static LanguageSet from(Set<String> langs) {\n-            if (langs.isEmpty()) {\n-                return NO_LANGUAGES;\n-            } else {\n-                return new SomeLanguages(langs);\n-            }\n-        }\n-\n-        public abstract boolean contains(String language);\n-\n-        public abstract boolean isSingleton();\n-\n-        public abstract String getAny();\n-\n-        public abstract boolean isEmpty();\n-    }\n-\n-    /**\n-     * No languages at all.\n-     */\n-    public static final LanguageSet NO_LANGUAGES = new LanguageSet() {\n-        @Override\n-        public LanguageSet restrictTo(LanguageSet other) {\n-            return this;\n-        }\n-\n-        @Override\n-        public boolean contains(String language) {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean isSingleton() {\n-            return false;\n-        }\n-\n-        @Override\n-        public String getAny() {\n-            throw new NoSuchElementException(\"Can't fetch any language from the empty language set.\");\n-        }\n-\n-        @Override\n-        public boolean isEmpty() {\n-            return true;\n-        }\n-    };\n-\n-    /**\n-     * Any/all languages.\n-     */\n-    public static final LanguageSet ANY_LANGUAGE = new LanguageSet() {\n-        @Override\n-        public LanguageSet restrictTo(LanguageSet other) {\n-            return other;\n-        }\n-\n-        @Override\n-        public boolean contains(String language) {\n-            return true;\n-        }\n-\n-        @Override\n-        public boolean isSingleton() {\n-            return false;\n-        }\n-\n-        @Override\n-        public String getAny() {\n-            throw new NoSuchElementException(\"Can't fetch any language from the any language set.\");\n-        }\n-\n-        @Override\n-        public boolean isEmpty() {\n-            return false;\n-        }\n-    };\n-\n-    /**\n-     * Some languages, explicitly enumerated.\n-     */\n-    public static class SomeLanguages extends LanguageSet {\n-        private final Set<String> languages;\n-\n-        private SomeLanguages(Set<String> languages) {\n-            this.languages = Collections.unmodifiableSet(languages);\n-        }\n-\n-        public Set<String> getLanguages() {\n-            return this.languages;\n-        }\n-\n-        @Override\n-        public LanguageSet restrictTo(LanguageSet other) {\n-            if (other == NO_LANGUAGES) {\n-                return other;\n-            } else if (other == ANY_LANGUAGE) {\n-                return this;\n-            } else {\n-                SomeLanguages sl = (SomeLanguages) other;\n-                Set<String> ls = new HashSet<String>(this.languages);\n-                ls.retainAll(sl.languages);\n-                return from(ls);\n-            }\n-        }\n-\n-        @Override\n-        public boolean contains(String language) {\n-            return this.languages.contains(language);\n-        }\n-\n-        @Override\n-        public boolean isSingleton() {\n-            return this.languages.size() == 1;\n-        }\n-\n-        @Override\n-        public String getAny() {\n-            return this.languages.iterator().next();\n-        }\n-\n-        @Override\n-        public boolean isEmpty() {\n-            return this.languages.isEmpty();\n-        }\n-    }\n }\n--- a/src/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n  * @since 2.0\n  */\n public class PhoneticEngine {\n+    static class PhonemeBuilder {\n+\n+        public static PhonemeBuilder empty(Languages.LanguageSet languages) {\n+            return new PhonemeBuilder(Collections.singleton(new Rule.Phoneme(\"\", languages)));\n+        }\n+\n+        private final Set<Rule.Phoneme> phonemes;\n+\n+        private PhonemeBuilder(Set<Rule.Phoneme> phonemes) {\n+            this.phonemes = phonemes;\n+        }\n+\n+        public PhonemeBuilder append(String str) {\n+            Set<Rule.Phoneme> newPhonemes = new HashSet<Rule.Phoneme>();\n+\n+            for (Rule.Phoneme ph : this.phonemes) {\n+                newPhonemes.add(ph.append(str));\n+            }\n+\n+            return new PhonemeBuilder(newPhonemes);\n+        }\n+\n+        public PhonemeBuilder apply(Rule.PhonemeExpr phonemeExpr) {\n+            Set<Rule.Phoneme> newPhonemes = new HashSet<Rule.Phoneme>();\n+\n+            for (Rule.Phoneme left : this.phonemes) {\n+                for (Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n+                    Rule.Phoneme join = left.join(right);\n+                    if (!join.getLanguages().isEmpty()) {\n+                        newPhonemes.add(join);\n+                    }\n+                }\n+            }\n+\n+            return new PhonemeBuilder(newPhonemes);\n+        }\n+\n+        public Set<Rule.Phoneme> getPhonemes() {\n+            return this.phonemes;\n+        }\n+\n+        public String makeString() {\n+            List<String> sorted = new ArrayList<String>();\n+\n+            for (Rule.Phoneme ph : this.phonemes) {\n+                sorted.add(ph.getPhonemeText());\n+            }\n+\n+            Collections.sort(sorted);\n+            StringBuilder sb = new StringBuilder();\n+\n+            for (String ph : sorted) {\n+                if (sb.length() > 0)\n+                    sb.append(\"|\");\n+                sb.append(ph);\n+            }\n+\n+            return sb.toString();\n+        }\n+    }\n+\n+    private static class RulesApplication {\n+        private final List<Rule> finalRules;\n+        private final String input;\n+\n+        private PhonemeBuilder phonemeBuilder;\n+        private int i;\n+        private boolean found;\n+\n+        public RulesApplication(List<Rule> finalRules, String input, PhonemeBuilder phonemeBuilder, int i) {\n+            if (finalRules == null) {\n+                throw new NullPointerException(\"The finalRules argument must not be null\");\n+            }\n+            this.finalRules = finalRules;\n+            this.phonemeBuilder = phonemeBuilder;\n+            this.input = input;\n+            this.i = i;\n+        }\n+\n+        public int getI() {\n+            return this.i;\n+        }\n+\n+        public PhonemeBuilder getPhonemeBuilder() {\n+            return this.phonemeBuilder;\n+        }\n+\n+        public RulesApplication invoke() {\n+            this.found = false;\n+            int patternLength = 0;\n+            RULES: for (Rule rule : this.finalRules) {\n+                String pattern = rule.getPattern();\n+                patternLength = pattern.length();\n+                // log(\"trying pattern: \" + pattern);\n+\n+                if (!rule.patternAndContextMatches(this.input, this.i)) {\n+                    // log(\"no match\");\n+                    continue RULES;\n+                }\n+\n+                this.phonemeBuilder = this.phonemeBuilder.apply(rule.getPhoneme());\n+                this.found = true;\n+                break RULES;\n+            }\n+\n+            if (!this.found) {\n+                patternLength = 1;\n+            }\n+\n+            this.i += patternLength;\n+            return this;\n+        }\n+\n+        public boolean isFound() {\n+            return this.found;\n+        }\n+    }\n+\n     private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class);\n \n     static {\n                 \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n     }\n \n+    private static String join(Iterable<String> strings, String sep) {\n+        StringBuilder sb = new StringBuilder();\n+        Iterator<String> si = strings.iterator();\n+        if (si.hasNext()) {\n+            sb.append(si.next());\n+        }\n+        while (si.hasNext()) {\n+            sb.append(sep).append(si.next());\n+        }\n+\n+        return sb.toString();\n+    }\n+\n     private final Lang lang;\n \n     private final NameType nameType;\n         this.lang = Lang.instance(nameType);\n     }\n \n-    /**\n-     * Gets the Lang language guessing rules being used.\n-     * \n-     * @return the Lang in use\n-     */\n-    public Lang getLang() {\n-        return this.lang;\n-    }\n-\n-    /**\n-     * Gets the NameType being used.\n-     * \n-     * @return the NameType in use\n-     */\n-    public NameType getNameType() {\n-        return this.nameType;\n-    }\n-\n-    /**\n-     * Gets the RuleType being used.\n-     * \n-     * @return the RuleType in use\n-     */\n-    public RuleType getRuleType() {\n-        return this.ruleType;\n-    }\n-\n-    /**\n-     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n-     * \n-     * @return true if multiple phonetic encodings are returned, false if just the first is.\n-     */\n-    public boolean isConcat() {\n-        return this.concat;\n+    private PhonemeBuilder applyFinalRules(PhonemeBuilder phonemeBuilder, List<Rule> finalRules, Languages.LanguageSet languageSet,\n+            boolean strip) {\n+        if (finalRules == null) {\n+            throw new NullPointerException(\"finalRules can not be null\");\n+        }\n+        if (finalRules.isEmpty()) {\n+            return phonemeBuilder;\n+        }\n+\n+        Set<Rule.Phoneme> phonemes = new HashSet<Rule.Phoneme>();\n+\n+        for (Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n+            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n+            String phonemeText = phoneme.getPhonemeText();\n+            // System.err.println(\"Expanding: \" + phonemeText);\n+\n+            for (int i = 0; i < phonemeText.length();) {\n+                RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i).invoke();\n+                boolean found = rulesApplication.isFound();\n+                subBuilder = rulesApplication.getPhonemeBuilder();\n+\n+                if (!found) {\n+                    // System.err.println(\"Not found. Appending as-is\");\n+                    subBuilder = subBuilder.append(phonemeText.substring(i, i + 1));\n+                }\n+\n+                i = rulesApplication.getI();\n+\n+                // System.err.println(phonemeText + \" \" + i + \": \" + subBuilder.makeString());\n+            }\n+\n+            // System.err.println(\"Expanded to: \" + subBuilder.makeString());\n+\n+            phonemes.addAll(subBuilder.getPhonemes());\n+        }\n+\n+        return new PhonemeBuilder(phonemes);\n     }\n \n     /**\n     public String encode(String input) {\n         Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\n         return phoneticUtf8(input, languageSet);\n+    }\n+\n+    /**\n+     * Gets the Lang language guessing rules being used.\n+     * \n+     * @return the Lang in use\n+     */\n+    public Lang getLang() {\n+        return this.lang;\n+    }\n+\n+    /**\n+     * Gets the NameType being used.\n+     * \n+     * @return the NameType in use\n+     */\n+    public NameType getNameType() {\n+        return this.nameType;\n+    }\n+\n+    /**\n+     * Gets the RuleType being used.\n+     * \n+     * @return the RuleType in use\n+     */\n+    public RuleType getRuleType() {\n+        return this.ruleType;\n+    }\n+\n+    /**\n+     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n+     * \n+     * @return true if multiple phonetic encodings are returned, false if just the first is.\n+     */\n+    public boolean isConcat() {\n+        return this.concat;\n     }\n \n     /**\n \n         return phonemeBuilder.makeString();\n     }\n-\n-    private PhonemeBuilder applyFinalRules(PhonemeBuilder phonemeBuilder, List<Rule> finalRules, Languages.LanguageSet languageSet,\n-            boolean strip) {\n-        if (finalRules == null) {\n-            throw new NullPointerException(\"finalRules can not be null\");\n-        }\n-        if (finalRules.isEmpty()) {\n-            return phonemeBuilder;\n-        }\n-\n-        Set<Rule.Phoneme> phonemes = new HashSet<Rule.Phoneme>();\n-\n-        for (Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n-            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n-            String phonemeText = phoneme.getPhonemeText();\n-            // System.err.println(\"Expanding: \" + phonemeText);\n-\n-            for (int i = 0; i < phonemeText.length();) {\n-                RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i).invoke();\n-                boolean found = rulesApplication.isFound();\n-                subBuilder = rulesApplication.getPhonemeBuilder();\n-\n-                if (!found) {\n-                    // System.err.println(\"Not found. Appending as-is\");\n-                    subBuilder = subBuilder.append(phonemeText.substring(i, i + 1));\n-                }\n-\n-                i = rulesApplication.getI();\n-\n-                // System.err.println(phonemeText + \" \" + i + \": \" + subBuilder.makeString());\n-            }\n-\n-            // System.err.println(\"Expanded to: \" + subBuilder.makeString());\n-\n-            phonemes.addAll(subBuilder.getPhonemes());\n-        }\n-\n-        return new PhonemeBuilder(phonemes);\n-    }\n-\n-    private static String join(Iterable<String> strings, String sep) {\n-        StringBuilder sb = new StringBuilder();\n-        Iterator<String> si = strings.iterator();\n-        if (si.hasNext()) {\n-            sb.append(si.next());\n-        }\n-        while (si.hasNext()) {\n-            sb.append(sep).append(si.next());\n-        }\n-\n-        return sb.toString();\n-    }\n-\n-    private static class RulesApplication {\n-        private final List<Rule> finalRules;\n-        private final String input;\n-\n-        private PhonemeBuilder phonemeBuilder;\n-        private int i;\n-        private boolean found;\n-\n-        public RulesApplication(List<Rule> finalRules, String input, PhonemeBuilder phonemeBuilder, int i) {\n-            if (finalRules == null) {\n-                throw new NullPointerException(\"The finalRules argument must not be null\");\n-            }\n-            this.finalRules = finalRules;\n-            this.phonemeBuilder = phonemeBuilder;\n-            this.input = input;\n-            this.i = i;\n-        }\n-\n-        public PhonemeBuilder getPhonemeBuilder() {\n-            return this.phonemeBuilder;\n-        }\n-\n-        public int getI() {\n-            return this.i;\n-        }\n-\n-        public boolean isFound() {\n-            return this.found;\n-        }\n-\n-        public RulesApplication invoke() {\n-            this.found = false;\n-            int patternLength = 0;\n-            RULES: for (Rule rule : this.finalRules) {\n-                String pattern = rule.getPattern();\n-                patternLength = pattern.length();\n-                // log(\"trying pattern: \" + pattern);\n-\n-                if (!rule.patternAndContextMatches(this.input, this.i)) {\n-                    // log(\"no match\");\n-                    continue RULES;\n-                }\n-\n-                this.phonemeBuilder = this.phonemeBuilder.apply(rule.getPhoneme());\n-                this.found = true;\n-                break RULES;\n-            }\n-\n-            if (!this.found) {\n-                patternLength = 1;\n-            }\n-\n-            this.i += patternLength;\n-            return this;\n-        }\n-    }\n-\n-    static class PhonemeBuilder {\n-\n-        public static PhonemeBuilder empty(Languages.LanguageSet languages) {\n-            return new PhonemeBuilder(Collections.singleton(new Rule.Phoneme(\"\", languages)));\n-        }\n-\n-        private final Set<Rule.Phoneme> phonemes;\n-\n-        private PhonemeBuilder(Set<Rule.Phoneme> phonemes) {\n-            this.phonemes = phonemes;\n-        }\n-\n-        public Set<Rule.Phoneme> getPhonemes() {\n-            return this.phonemes;\n-        }\n-\n-        public PhonemeBuilder apply(Rule.PhonemeExpr phonemeExpr) {\n-            Set<Rule.Phoneme> newPhonemes = new HashSet<Rule.Phoneme>();\n-\n-            for (Rule.Phoneme left : this.phonemes) {\n-                for (Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n-                    Rule.Phoneme join = left.join(right);\n-                    if (!join.getLanguages().isEmpty()) {\n-                        newPhonemes.add(join);\n-                    }\n-                }\n-            }\n-\n-            return new PhonemeBuilder(newPhonemes);\n-        }\n-\n-        public String makeString() {\n-            List<String> sorted = new ArrayList<String>();\n-\n-            for (Rule.Phoneme ph : this.phonemes) {\n-                sorted.add(ph.getPhonemeText());\n-            }\n-\n-            Collections.sort(sorted);\n-            StringBuilder sb = new StringBuilder();\n-\n-            for (String ph : sorted) {\n-                if (sb.length() > 0)\n-                    sb.append(\"|\");\n-                sb.append(ph);\n-            }\n-\n-            return sb.toString();\n-        }\n-\n-        public PhonemeBuilder append(String str) {\n-            Set<Rule.Phoneme> newPhonemes = new HashSet<Rule.Phoneme>();\n-\n-            for (Rule.Phoneme ph : this.phonemes) {\n-                newPhonemes.add(ph.append(str));\n-            }\n-\n-            return new PhonemeBuilder(newPhonemes);\n-        }\n-    }\n }\n--- a/src/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/java/org/apache/commons/codec/language/bm/Rule.java\n  * @since 2.0\n  */\n public class Rule {\n+    public static class Phoneme implements PhonemeExpr {\n+        private final String phonemeText;\n+        private final Languages.LanguageSet languages;\n+\n+        public Phoneme(String phonemeText, Languages.LanguageSet languages) {\n+            this.phonemeText = phonemeText;\n+            this.languages = languages;\n+        }\n+\n+        public Phoneme append(String str) {\n+            return new Phoneme(this.phonemeText + str, this.languages);\n+        }\n+\n+        public Languages.LanguageSet getLanguages() {\n+            return this.languages;\n+        }\n+\n+        public Iterable<Phoneme> getPhonemes() {\n+            return Collections.singleton(this);\n+        }\n+\n+        public String getPhonemeText() {\n+            return this.phonemeText;\n+        }\n+\n+        public Phoneme join(Phoneme right) {\n+            return new Phoneme(this.phonemeText + right.phonemeText, this.languages.restrictTo(right.languages));\n+        }\n+    }\n+\n+    public interface PhonemeExpr {\n+        Iterable<Phoneme> getPhonemes();\n+    }\n+\n+    public static class PhonemeList implements PhonemeExpr {\n+        private final List<Phoneme> phonemes;\n+\n+        public PhonemeList(List<Phoneme> phonemes) {\n+            this.phonemes = phonemes;\n+        }\n+\n+        public List<Phoneme> getPhonemes() {\n+            return this.phonemes;\n+        }\n+    }\n+\n     public static final String ALL = \"ALL\";\n \n     private static final String DOUBLE_QUOTE = \"\\\"\";\n         }\n \n         return rules;\n+    }\n+\n+    private static Phoneme parsePhoneme(String ph) {\n+        int open = ph.indexOf(\"[\");\n+        if (open >= 0) {\n+            if (!ph.endsWith(\"]\")) {\n+                throw new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\");\n+            }\n+            String before = ph.substring(0, open);\n+            String in = ph.substring(open + 1, ph.length() - 1);\n+            Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\n+\n+            return new Phoneme(before, Languages.LanguageSet.from(langs));\n+        } else {\n+            return new Phoneme(ph, Languages.ANY_LANGUAGE);\n+        }\n+    }\n+\n+    private static PhonemeExpr parsePhonemeExpr(String ph) {\n+        if (ph.startsWith(\"(\")) { // we have a bracketed list of options\n+            if (!ph.endsWith(\")\")) {\n+                throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\");\n+            }\n+\n+            List<Phoneme> phs = new ArrayList<Phoneme>();\n+            String body = ph.substring(1, ph.length() - 1);\n+            for (String part : body.split(\"[|]\")) {\n+                phs.add(parsePhoneme(part));\n+            }\n+            if (body.startsWith(\"|\") || body.endsWith(\"|\")) {\n+                phs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE));\n+            }\n+\n+            return new PhonemeList(phs);\n+        } else {\n+            return parsePhoneme(ph);\n+        }\n     }\n \n     private static List<Rule> parseRules(Scanner scanner) {\n         return str;\n     }\n \n-    private static PhonemeExpr parsePhonemeExpr(String ph) {\n-        if (ph.startsWith(\"(\")) { // we have a bracketed list of options\n-            if (!ph.endsWith(\")\")) {\n-                throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\");\n-            }\n-\n-            List<Phoneme> phs = new ArrayList<Phoneme>();\n-            String body = ph.substring(1, ph.length() - 1);\n-            for (String part : body.split(\"[|]\")) {\n-                phs.add(parsePhoneme(part));\n-            }\n-            if (body.startsWith(\"|\") || body.endsWith(\"|\")) {\n-                phs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE));\n-            }\n-\n-            return new PhonemeList(phs);\n-        } else {\n-            return parsePhoneme(ph);\n-        }\n-    }\n-\n-    private static Phoneme parsePhoneme(String ph) {\n-        int open = ph.indexOf(\"[\");\n-        if (open >= 0) {\n-            if (!ph.endsWith(\"]\")) {\n-                throw new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\");\n-            }\n-            String before = ph.substring(0, open);\n-            String in = ph.substring(open + 1, ph.length() - 1);\n-            Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\n-\n-            return new Phoneme(before, Languages.LanguageSet.from(langs));\n-        } else {\n-            return new Phoneme(ph, Languages.ANY_LANGUAGE);\n-        }\n-    }\n-\n     private final Pattern lContext;\n \n     private final String pattern;\n      */\n     public Pattern getLContext() {\n         return this.lContext;\n-    }\n-\n-    /**\n-     * Gets the pattern. This is a string-literal that must exactly match.\n-     * \n-     * @return the pattern\n-     */\n-    public String getPattern() {\n-        return this.pattern;\n-    }\n-\n-    /**\n-     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n-     * \n-     * @return the phoneme\n-     */\n-    public PhonemeExpr getPhoneme() {\n-        return this.phoneme;\n-    }\n-\n-    /**\n-     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n-     * \n-     * @return the right context Pattern\n-     */\n-    public Pattern getRContext() {\n-        return this.rContext;\n     }\n \n     // /**\n     // }\n \n     /**\n+     * Gets the pattern. This is a string-literal that must exactly match.\n+     * \n+     * @return the pattern\n+     */\n+    public String getPattern() {\n+        return this.pattern;\n+    }\n+\n+    /**\n+     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n+     * \n+     * @return the phoneme\n+     */\n+    public PhonemeExpr getPhoneme() {\n+        return this.phoneme;\n+    }\n+\n+    /**\n+     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n+     * \n+     * @return the right context Pattern\n+     */\n+    public Pattern getRContext() {\n+        return this.rContext;\n+    }\n+\n+    /**\n      * Decides if the pattern and context match the input starting at a position.\n      * \n      * @param input\n \n         return patternMatches && rContextMatches && lContextMatches;\n     }\n-\n-    public interface PhonemeExpr {\n-        Iterable<Phoneme> getPhonemes();\n-    }\n-\n-    public static class Phoneme implements PhonemeExpr {\n-        private final String phonemeText;\n-        private final Languages.LanguageSet languages;\n-\n-        public Phoneme(String phonemeText, Languages.LanguageSet languages) {\n-            this.phonemeText = phonemeText;\n-            this.languages = languages;\n-        }\n-\n-        public String getPhonemeText() {\n-            return this.phonemeText;\n-        }\n-\n-        public Languages.LanguageSet getLanguages() {\n-            return this.languages;\n-        }\n-\n-        public Iterable<Phoneme> getPhonemes() {\n-            return Collections.singleton(this);\n-        }\n-\n-        public Phoneme join(Phoneme right) {\n-            return new Phoneme(this.phonemeText + right.phonemeText, this.languages.restrictTo(right.languages));\n-        }\n-\n-        public Phoneme append(String str) {\n-            return new Phoneme(this.phonemeText + str, this.languages);\n-        }\n-    }\n-\n-    public static class PhonemeList implements PhonemeExpr {\n-        private final List<Phoneme> phonemes;\n-\n-        public PhonemeList(List<Phoneme> phonemes) {\n-            this.phonemes = phonemes;\n-        }\n-\n-        public List<Phoneme> getPhonemes() {\n-            return this.phonemes;\n-        }\n-    }\n }\n--- a/src/test/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n+++ b/src/test/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n import org.apache.commons.codec.StringEncoder;\n import org.apache.commons.codec.StringEncoderAbstractTest;\n import org.junit.Assert;\n-import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n         return new BeiderMorseEncoder();\n     }\n \n-    @Ignore\n     @Test\n     public void testEncodeAtz() throws EncoderException {\n         BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n         bmpm.setNameType(NameType.GENERIC);\n         bmpm.setRuleType(RuleType.APPROX);\n-        Assert.assertFalse(bmpm.encode(\"\u00e1cz\").equals(\"\"));\n-        Assert.assertFalse(bmpm.encode(\"\u00e1tz\").equals(\"\"));\n+        String[] names = { \"\u00e1cz\", \"\u00e1tz\" };\n+        for (String name : names) {\n+            Assert.assertFalse(bmpm.encode(name).equals(\"\"));\n+\n+        }\n     }\n \n     /**\n         Languages.instance(\"thereIsNoSuchLanguage\");\n     }\n \n+    // @Ignore\n     @Test(timeout = 10000L)\n     public void testLongestEnglishSurname() throws EncoderException {\n         BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n         bmpm.setRuleType(RuleType.RULES);\n     }\n \n-    @Test(timeout = 10000L)\n+    @Test(timeout = 20000L)\n     public void testSpeedCheck() throws EncoderException {\n         char[] chars = new char[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'o', 'u' };\n         BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n--- a/src/test/org/apache/commons/codec/language/bm/LanguageGuessingTest.java\n+++ b/src/test/org/apache/commons/codec/language/bm/LanguageGuessingTest.java\n                 { \"Sjneijder\", \"dutch\", EXACT }, { \"Klausewitz\", \"german\", EXACT }, { \"K\u00fc\u00e7\u00fck\", \"turkish\", EXACT },\n                 { \"Giacometti\", \"italian\", EXACT }, { \"Nagy\", \"hungarian\", EXACT }, { \"Ceau\u015fescu\", \"romanian\", EXACT },\n                 { \"Angelopoulos\", \"greeklatin\", EXACT }, { \"\u0391\u03b3\u03b3\u03b5\u03bb\u03cc\u03c0\u03bf\u03c5\u03bb\u03bf\u03c2\", \"greek\", EXACT }, { \"\u041f\u0443\u0448\u043a\u0438\u043d\", \"cyrillic\", EXACT },\n-                { \"\u05db\u05d4\u05df\", \"hebrew\", EXACT } });\n+                { \"\u05db\u05d4\u05df\", \"hebrew\", EXACT }, { \"\u00e1cz\", \"any\", EXACT }, { \"\u00e1tz\", \"any\", EXACT } });\n     }\n \n     private final String exactness;\n--- a/src/test/org/apache/commons/codec/language/bm/PhoneticEngineTest.java\n+++ b/src/test/org/apache/commons/codec/language/bm/PhoneticEngineTest.java\n \n     @Parameterized.Parameters\n     public static List<Object[]> data() {\n-        return Arrays\n-                .asList(new Object[] { \"Renault\", \"rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult\", NameType.GENERIC, RuleType.APPROX,\n-                        true },\n-                        new Object[] { \"Renault\", \"rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult\", NameType.ASHKENAZI, RuleType.APPROX, true },\n-                        new Object[] { \"Renault\", \"rinDlt\", NameType.SEPHARDIC, RuleType.APPROX, true },\n-                        new Object[] { \"SntJohn-Smith\", \"sntjonsmit\", NameType.GENERIC, RuleType.EXACT, true },\n-                        new Object[] { \"d'ortley\", \"ortlaj|ortlaj|ortlej|ortlej-dortlaj|dortlaj|dortlej|dortlej\", NameType.GENERIC,\n-                                RuleType.EXACT, true },\n-                        new Object[] {\n-                                \"van helsing\",\n-                                \"elSink|elsink|helSink|helsink|helzink|xelsink-banhelsink|fanhelsink|fanhelzink|vanhelsink|vanhelzink|vanjelsink\",\n-                                NameType.GENERIC, RuleType.EXACT, false });\n+        return Arrays.asList(new Object[] { \"Renault\", \"rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult\", NameType.GENERIC,\n+                RuleType.APPROX, true }, new Object[] { \"Renault\", \"rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult\", NameType.ASHKENAZI,\n+                RuleType.APPROX, true }, new Object[] { \"Renault\", \"rinDlt\", NameType.SEPHARDIC, RuleType.APPROX, true }, new Object[] {\n+                \"SntJohn-Smith\", \"sntjonsmit\", NameType.GENERIC, RuleType.EXACT, true }, new Object[] { \"d'ortley\",\n+                \"ortlaj|ortlaj|ortlej|ortlej-dortlaj|dortlaj|dortlej|dortlej\", NameType.GENERIC, RuleType.EXACT, true }, new Object[] {\n+                \"van helsing\",\n+                \"elSink|elsink|helSink|helsink|helzink|xelsink-banhelsink|fanhelsink|fanhelzink|vanhelsink|vanhelzink|vanjelsink\",\n+                NameType.GENERIC, RuleType.EXACT, false });\n     }\n \n     private final boolean concat;\n         String phoneticActual = engine.encode(this.name);\n \n         System.err.println(\"expecting: \" + this.phoneticExpected);\n-        System.err.println(\"actual: \" + phoneticActual);\n+        System.err.println(\"actual:    \" + phoneticActual);\n         assertEquals(\"phoneme incorrect\", this.phoneticExpected, phoneticActual);\n     }\n }\n--- a/src/test/org/apache/commons/codec/language/bm/RuleTest.java\n+++ b/src/test/org/apache/commons/codec/language/bm/RuleTest.java\n  * @author Apache Software Foundation\n  * @since 2.0\n  */\n-//@RunWith(Parameterized.class)\n+// @RunWith(Parameterized.class)\n public class RuleTest {\n \n     @Parameterized.Parameters\n     public static List<Object[]> data() {\n         return Arrays.asList(\n-                new Object[] { \"matching language sets with ALL\",\n-                        new Rule(\"e\", \"\", \"\", new Rule.Phoneme(\"o\", Languages.LanguageSet.from(\n-                                new HashSet<String>(Arrays.asList(\"english\", \"french\"))))),\n-                        new HashSet<String>(Arrays.asList(\"english\", \"french\")), true },\n-                new Object[] { \"non-matching language sets with ALL\",\n-                        new Rule(\"e\", \"\", \"\", new Rule.Phoneme(\"o\", Languages.LanguageSet.from(\n-                                new HashSet<String>(Arrays.asList(\"english\", \"french\"))))),\n-                        new HashSet<String>(Arrays.asList(\"english\")), false });\n+                new Object[] {\n+                        \"matching language sets with ALL\",\n+                        new Rule(\"e\", \"\", \"\", new Rule.Phoneme(\"o\", Languages.LanguageSet.from(new HashSet<String>(Arrays.asList(\"english\",\n+                                \"french\"))))), new HashSet<String>(Arrays.asList(\"english\", \"french\")), true },\n+                new Object[] {\n+                        \"non-matching language sets with ALL\",\n+                        new Rule(\"e\", \"\", \"\", new Rule.Phoneme(\"o\", Languages.LanguageSet.from(new HashSet<String>(Arrays.asList(\"english\",\n+                                \"french\"))))), new HashSet<String>(Arrays.asList(\"english\")), false });\n     }\n \n     private final String caseName;\n         this.expected = expected;\n     }\n \n-//    @Test\n-//    public void testRuleLanguageMatches() {\n-//        assertEquals(this.caseName, this.expected, this.rule.languageMatches(this.langs));\n-//    }\n+    // @Test\n+    // public void testRuleLanguageMatches() {\n+    // assertEquals(this.caseName, this.expected, this.rule.languageMatches(this.langs));\n+    // }\n \n }", "timestamp": 1312147545, "metainfo": ""}