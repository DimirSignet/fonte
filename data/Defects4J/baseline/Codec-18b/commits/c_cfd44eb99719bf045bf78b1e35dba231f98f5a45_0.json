{"sha": "cfd44eb99719bf045bf78b1e35dba231f98f5a45", "log": "[CODEC-180] Patch from Ville Skytt\u00e4 applied and then some (well, just one more). Fix Javadoc 1.8.0 errors.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/CharEncoding.java\n+++ b/src/main/java/org/apache/commons/codec/CharEncoding.java\n  * </p>\n  *\n  * <ul>\n- * <li><code>US-ASCII</code><br/>\n+ * <li><code>US-ASCII</code><br>\n  * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</li>\n- * <li><code>ISO-8859-1</code><br/>\n+ * <li><code>ISO-8859-1</code><br>\n  * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</li>\n- * <li><code>UTF-8</code><br/>\n+ * <li><code>UTF-8</code><br>\n  * Eight-bit Unicode Transformation Format.</li>\n- * <li><code>UTF-16BE</code><br/>\n+ * <li><code>UTF-16BE</code><br>\n  * Sixteen-bit Unicode Transformation Format, big-endian byte order.</li>\n- * <li><code>UTF-16LE</code><br/>\n+ * <li><code>UTF-16LE</code><br>\n  * Sixteen-bit Unicode Transformation Format, little-endian byte order.</li>\n- * <li><code>UTF-16</code><br/>\n+ * <li><code>UTF-16</code><br>\n  * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n  * accepted on input, big-endian used on output.)</li>\n  * </ul>\n--- a/src/main/java/org/apache/commons/codec/Charsets.java\n+++ b/src/main/java/org/apache/commons/codec/Charsets.java\n  * </p>\n  *\n  * <ul>\n- * <li><code>US-ASCII</code><br/>\n+ * <li><code>US-ASCII</code><br>\n  * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</li>\n- * <li><code>ISO-8859-1</code><br/>\n+ * <li><code>ISO-8859-1</code><br>\n  * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</li>\n- * <li><code>UTF-8</code><br/>\n+ * <li><code>UTF-8</code><br>\n  * Eight-bit Unicode Transformation Format.</li>\n- * <li><code>UTF-16BE</code><br/>\n+ * <li><code>UTF-16BE</code><br>\n  * Sixteen-bit Unicode Transformation Format, big-endian byte order.</li>\n- * <li><code>UTF-16LE</code><br/>\n+ * <li><code>UTF-16LE</code><br>\n  * Sixteen-bit Unicode Transformation Format, little-endian byte order.</li>\n- * <li><code>UTF-16</code><br/>\n+ * <li><code>UTF-16</code><br>\n  * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n  * accepted on input, big-endian used on output.)</li>\n  * </ul>\n--- a/src/main/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java\n  *\n  * <p>\n  * The class can be parameterized in the following manner with various constructors:\n+ * </p>\n  * <ul>\n  * <li>Whether to use the \"base32hex\" variant instead of the default \"base32\"</li>\n  * <li>Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of\n  * 8 in the encoded data.\n  * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n  * </ul>\n- * </p>\n  * <p>\n  * This class operates directly on byte streams, and not character streams.\n  * </p>\n     private final byte[] encodeTable;\n \n     /**\n-     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n+     * Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.\n      */\n     private final byte[] lineSeparator;\n \n      *\n      * @param lineLength\n      *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n-     *            8). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n      *            decoding.\n      */\n     public Base32(final int lineLength) {\n      *\n      * @param lineLength\n      *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n-     *            8). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n      *            decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n      *\n      * @param lineLength\n      *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n-     *            8). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n      *            decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n      *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n      * @throws IllegalArgumentException\n      *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n-     *             lineLength > 0 and lineSeparator is null.\n+     *             lineLength &gt; 0 and lineSeparator is null.\n      */\n     public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n         super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK,\n--- a/src/main/java/org/apache/commons/codec/binary/Base32InputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32InputStream.java\n      *            true if we should encode all data read from us, false if we should decode.\n      * @param lineLength\n      *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n-     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode is\n      *            false, lineLength is ignored.\n      * @param lineSeparator\n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n-     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n+     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n     public Base32InputStream(final InputStream in, final boolean doEncode,\n                              final int lineLength, final byte[] lineSeparator) {\n--- a/src/main/java/org/apache/commons/codec/binary/Base32OutputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32OutputStream.java\n      *            true if we should encode all data written to us, false if we should decode.\n      * @param lineLength\n      *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n-     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode is\n      *            false, lineLength is ignored.\n      * @param lineSeparator\n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n-     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n+     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n     public Base32OutputStream(final OutputStream out, final boolean doEncode,\n                               final int lineLength, final byte[] lineSeparator) {\n--- a/src/main/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64.java\n  * </p>\n  * <p>\n  * The class can be parameterized in the following manner with various constructors:\n+ * </p>\n  * <ul>\n  * <li>URL-safe mode: Default off.</li>\n  * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n  * 4 in the encoded data.\n  * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n  * </ul>\n- * </p>\n  * <p>\n  * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only\n  * encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252,\n     private final byte[] decodeTable = DECODE_TABLE;\n \n     /**\n-     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n+     * Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.\n      */\n     private final byte[] lineSeparator;\n \n      *\n      * @param lineLength\n      *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n-     *            4). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n      *            decoding.\n      * @since 1.4\n      */\n      *\n      * @param lineLength\n      *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n-     *            4). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n      *            decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n      *\n      * @param lineLength\n      *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n-     *            4). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n      *            decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n--- a/src/main/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64InputStream.java\n      *            true if we should encode all data read from us, false if we should decode.\n      * @param lineLength\n      *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n-     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode is\n      *            false, lineLength is ignored.\n      * @param lineSeparator\n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n-     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n+     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n     public Base64InputStream(final InputStream in, final boolean doEncode,\n                              final int lineLength, final byte[] lineSeparator) {\n--- a/src/main/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64OutputStream.java\n      *            true if we should encode all data written to us, false if we should decode.\n      * @param lineLength\n      *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n-     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode is\n      *            false, lineLength is ignored.\n      * @param lineSeparator\n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n-     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n+     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n     public Base64OutputStream(final OutputStream out, final boolean doEncode,\n                               final int lineLength, final byte[] lineSeparator) {\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n \n         /**\n          * Variable tracks how many characters have been written to the current line. Only used when encoding. We use\n-         * it to make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n+         * it to make sure each encoded line never goes beyond lineLength (if lineLength &gt; 0).\n          */\n         int currentLinePos;\n \n     protected final int lineLength;\n \n     /**\n-     * Size of chunk separator. Not used unless {@link #lineLength} > 0.\n+     * Size of chunk separator. Not used unless {@link #lineLength} &gt; 0.\n      */\n     private final int chunkSeparatorLength;\n \n      * @param pArray byte[] array which will later be encoded\n      *\n      * @return amount of space needed to encoded the supplied array.\n-     * Returns a long since a max-len array will require > Integer.MAX_VALUE\n+     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE\n      */\n     public long getEncodedLength(final byte[] pArray) {\n         // Calculate non-chunked size - rounded up to allow for padding\n--- a/src/main/java/org/apache/commons/codec/digest/Crypt.java\n+++ b/src/main/java/org/apache/commons/codec/digest/Crypt.java\n      * Example:\n      *\n      * <pre>\n-     *      crypt(\"secret\", \"$1$xxxx\") => \"$1$xxxx$aMkevjfEIpa35Bh3G4bAc.\"\n-     *      crypt(\"secret\", \"xx\") => \"xxWAum7tHdIUw\"\n+     *      crypt(\"secret\", \"$1$xxxx\") =&gt; \"$1$xxxx$aMkevjfEIpa35Bh3G4bAc.\"\n+     *      crypt(\"secret\", \"xx\") =&gt; \"xxWAum7tHdIUw\"\n      * </pre>\n      * <p>\n      * This method comes in a variation that accepts a byte[] array to support input strings that are not encoded in\n--- a/src/main/java/org/apache/commons/codec/digest/DigestUtils.java\n+++ b/src/main/java/org/apache/commons/codec/digest/DigestUtils.java\n      *\n      * @param algorithm\n      *            the name of the algorithm requested. See <a\n-     *            href=\"http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA\">Appendix A in the Java\n-     *            Cryptography Architecture API Specification & Reference</a> for information about standard algorithm\n+     *            href=\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\">Appendix A in the Java\n+     *            Cryptography Architecture Reference Guide</a> for information about standard algorithm\n      *            names.\n      * @return A digest instance.\n      * @see MessageDigest#getInstance(String)\n--- a/src/main/java/org/apache/commons/codec/digest/Md5Crypt.java\n+++ b/src/main/java/org/apache/commons/codec/digest/Md5Crypt.java\n  * <p>\n  * Based on the public domain (\"beer-ware\") C implementation from Poul-Henning Kamp which was found at: <a\n  * href=\"http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/libcrypt/crypt-md5.c?rev=1.1;content-type=text%2Fplain\">\n- * crypt-md5.c @ freebsd.org</a><br/>\n+ * crypt-md5.c @ freebsd.org</a><br>\n  * <p>\n  * Source:\n  *\n--- a/src/main/java/org/apache/commons/codec/language/ColognePhonetic.java\n+++ b/src/main/java/org/apache/commons/codec/language/ColognePhonetic.java\n  * href=\"http://en.wikipedia.org/wiki/Germanic_umlaut\">germanic umlauts</a>, removal of non alphabetical characters) the\n  * letters of the supplied text are replaced by their phonetic code according to the following table.\n  * <table border=\"1\">\n+ * <caption style=\"caption-side: bottom\"><small><i>(Source: <a href=\"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik#Buchstabencodes\">Wikipedia (de):\n+ * K&ouml;lner Phonetik -- Buchstabencodes</a>)</i></small></caption>\n  * <tbody>\n  * <tr>\n  * <th>Letter</th>\n  * </tr>\n  * </tbody>\n  * </table>\n- * <p>\n- * <small><i>(Source: <a href= \"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik#Buchstabencodes\" >Wikipedia (de):\n- * K&ouml;lner Phonetik -- Buchstabencodes</a>)</i></small>\n- * </p>\n  *\n  * <h4>Example:</h4>\n  *\n--- a/src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java\n+++ b/src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java\n     }\n \n     /**\n-     * Gets the first & last 3 letters of a name (if > 6 characters) Else just returns the name.\n+     * Gets the first and last 3 letters of a name (if &gt; 6 characters) Else just returns the name.\n      *\n      * <h2>API Usage</h2>\n      * <p>\n      *\n      * @param name\n      *            The string to get the substrings from\n-     * @return Annexed first & last 3 letters of input word.\n+     * @return Annexed first and last 3 letters of input word.\n      */\n     String getFirst3Last3(final String name) {\n         final int nameLength = name.length();\n--- a/src/main/java/org/apache/commons/codec/language/Nysiis.java\n+++ b/src/main/java/org/apache/commons/codec/language/Nysiis.java\n  * Algorithm description:\n  * <pre>\n  * 1. Transcode first characters of name\n- *   1a. MAC ->   MCC\n- *   1b. KN  ->   NN\n- *   1c. K   ->   C\n- *   1d. PH  ->   FF\n- *   1e. PF  ->   FF\n- *   1f. SCH ->   SSS\n+ *   1a. MAC -&gt;   MCC\n+ *   1b. KN  -&gt;   NN\n+ *   1c. K   -&gt;   C\n+ *   1d. PH  -&gt;   FF\n+ *   1e. PF  -&gt;   FF\n+ *   1f. SCH -&gt;   SSS\n  * 2. Transcode last characters of name\n- *   2a. EE, IE          ->   Y\n- *   2b. DT,RT,RD,NT,ND  ->   D\n+ *   2a. EE, IE          -&gt;   Y\n+ *   2b. DT,RT,RD,NT,ND  -&gt;   D\n  * 3. First character of key = first character of name\n  * 4. Transcode remaining characters by following these rules, incrementing by one character each time\n- *   4a. EV  ->   AF  else A,E,I,O,U -> A\n- *   4b. Q   ->   G\n- *   4c. Z   ->   S\n- *   4d. M   ->   N\n- *   4e. KN  ->   N   else K -> C\n- *   4f. SCH ->   SSS\n- *   4g. PH  ->   FF\n- *   4h. H   ->   If previous or next is nonvowel, previous\n- *   4i. W   ->   If previous is vowel, previous\n+ *   4a. EV  -&gt;   AF  else A,E,I,O,U -&gt; A\n+ *   4b. Q   -&gt;   G\n+ *   4c. Z   -&gt;   S\n+ *   4d. M   -&gt;   N\n+ *   4e. KN  -&gt;   N   else K -&gt; C\n+ *   4f. SCH -&gt;   SSS\n+ *   4g. PH  -&gt;   FF\n+ *   4h. H   -&gt;   If previous or next is nonvowel, previous\n+ *   4i. W   -&gt;   If previous is vowel, previous\n  *   4j. Add current to key if current != last key character\n  * 5. If last character is S, remove it\n  * 6. If last characters are AY, replace with Y\n--- a/src/main/java/org/apache/commons/codec/net/URLCodec.java\n+++ b/src/main/java/org/apache/commons/codec/net/URLCodec.java\n  * This class is immutable and thread-safe.\n  *\n  * @see <a href=\"http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1\">Chapter 17.13.4 Form content types</a>\n- *           of the <a href=\"http://www.w3.org/TR/html4/\">HTML 4.01 Specification<a>\n+ *           of the <a href=\"http://www.w3.org/TR/html4/\">HTML 4.01 Specification</a>\n  *\n  * @since 1.2\n  * @version $Id$", "timestamp": 1391197086, "metainfo": ""}