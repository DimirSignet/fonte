{"sha": "39d5df29fb768fd257f9d328b99f00bc69ec864a", "log": "[CODEC-187] Apply patch to make BeiderMorse phonetic engine compatible with v3.3 of the reference implementation.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n  * encodings as they consider a wider range of possible, approximate phonetic interpretations of the original word.\n  * Down-stream applications may wish to further process the encoding for indexing or lookup purposes, for example, by\n  * splitting on pipe (<code>|</code>) and indexing under each of these alternatives.\n+ * <p>\n+ * <b>Note</b>: this version of the Beider-Morse encoding is equivalent with v3.3 of the reference implementation.\n  *\n  * @see <a href=\"http://stevemorse.org/phonetics/bmpm.htm\">Beider-Morse Phonetic Matching</a>\n  * @see <a href=\"http://stevemorse.org/phoneticinfo.htm\">Reference implementation</a>\n+ *\n  * @since 1.6\n  * @version $Id$\n  */\n--- a/src/main/java/org/apache/commons/codec/language/bm/Lang.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Lang.java\n \n     private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class);\n \n-    private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/lang.txt\";\n+    private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/%s_lang.txt\";\n \n     static {\n         for (final NameType s : NameType.values()) {\n-            Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s)));\n+            Langs.put(s, loadFromResource(String.format(LANGUAGE_RULES_RN, s.getName()), Languages.getInstance(s)));\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/codec/language/bm/Languages.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Languages.java\n         public abstract boolean isSingleton();\n \n         public abstract LanguageSet restrictTo(LanguageSet other);\n+\n+        public abstract LanguageSet merge(LanguageSet other);\n     }\n \n     /**\n                     if (sl.languages.contains(lang)) {\n                         ls.add(lang);\n                     }\n+                }\n+                return from(ls);\n+            }\n+        }\n+\n+        @Override\n+        public LanguageSet merge(final LanguageSet other) {\n+            if (other == NO_LANGUAGES) {\n+                return this;\n+            } else if (other == ANY_LANGUAGE) {\n+                return other;\n+            } else {\n+                final SomeLanguages sl = (SomeLanguages) other;\n+                final Set<String> ls = new HashSet<String>(languages);\n+                for (String lang : sl.languages) {\n+                  ls.add(lang);\n                 }\n                 return from(ls);\n             }\n         }\n \n         @Override\n+        public LanguageSet merge(final LanguageSet other) {\n+            return other;\n+        }\n+\n+        @Override\n         public String toString() {\n             return \"NO_LANGUAGES\";\n         }\n         }\n \n         @Override\n+        public LanguageSet merge(final LanguageSet other) {\n+            return other;\n+        }\n+\n+        @Override\n         public String toString() {\n             return \"ANY_LANGUAGE\";\n         }\n--- a/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n-import java.util.TreeSet;\n+import java.util.TreeMap;\n \n import org.apache.commons.codec.language.bm.Languages.LanguageSet;\n import org.apache.commons.codec.language.bm.Rule.Phoneme;\n             return phonemeBuilder;\n         }\n \n-        final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n+        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =\n+            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n \n         for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n             PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n                 i = rulesApplication.getI();\n             }\n \n-            phonemes.addAll(subBuilder.getPhonemes());\n-        }\n-\n-        return new PhonemeBuilder(phonemes);\n+            // the phonemes map orders the phonemes only based on their text, but ignores the language set\n+            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise\n+            // phonemes with the same text but different language set get lost\n+            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {\n+                if (phonemes.containsKey(newPhoneme)) {\n+                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);\n+                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\n+                    phonemes.put(mergedPhoneme, mergedPhoneme);\n+                } else {\n+                    phonemes.put(newPhoneme, newPhoneme);\n+                }\n+            }\n+        }\n+\n+        return new PhonemeBuilder(phonemes.keySet());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n             return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),\n                                this.languages.restrictTo(right.languages));\n         }\n+\n+        /**\n+         * Returns a new Phoneme with the same text but a union of its\n+         * current language set and the given one.\n+         *\n+         * @param lang the language set to merge\n+         * @return a new Phoneme\n+         */\n+        public Phoneme mergeWithLanguage(final LanguageSet lang) {\n+          return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return phonemeText.toString() + \"[\" + languages + \"]\";\n+        }\n     }\n \n     public interface PhonemeExpr {\n                                         sb.append(\"Rule\");\n                                         sb.append(\"{line=\").append(myLine);\n                                         sb.append(\", loc='\").append(loc).append('\\'');\n+                                        sb.append(\", pat='\").append(pat).append('\\'');\n+                                        sb.append(\", lcon='\").append(lCon).append('\\'');\n+                                        sb.append(\", rcon='\").append(rCon).append('\\'');\n                                         sb.append('}');\n                                         return sb.toString();\n                                     }\n--- a/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineRegressionTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineRegressionTest.java\n \n package org.apache.commons.codec.language.bm;\n \n-import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.*;\n \n import java.util.Arrays;\n import java.util.HashSet;\n         Map<String, String> args = new TreeMap<String, String>();\n         args.put(\"nameType\", \"GENERIC\");\n         args.put(\"ruleType\", \"APPROX\");\n+\n         assertEquals(encode(args, true, \"abram\"), \"Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom\");\n-\n-        args.put(\"nameType\", \"ASHKENAZI\");\n-        args.put(\"ruleType\", \"APPROX\");\n+        assertEquals(encode(args, true, \"Bendzin\"), \"bndzn|bntsn|bnzn|vndzn|vntsn\");\n+\n+        args.put(\"nameType\", \"ASHKENAZI\");\n+        args.put(\"ruleType\", \"APPROX\");\n+\n         assertEquals(encode(args, true, \"abram\"), \"Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom\");\n+        assertEquals(encode(args, true, \"Halpern\"), \"YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn\");\n+\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineTest.java\n \n package org.apache.commons.codec.language.bm;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.*;\n \n import java.util.Arrays;\n import java.util.List;\n     public static List<Object[]> data() {\n         return Arrays\n                 .asList(new Object[] { \"Renault\", \"rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult\", NameType.GENERIC, RuleType.APPROX, Boolean.TRUE, TEN },\n-                        new Object[] { \"Renault\", \"rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult\", NameType.ASHKENAZI, RuleType.APPROX, Boolean.TRUE, TEN },\n-                        new Object[] { \"Renault\", \"rYnDlt\", NameType.ASHKENAZI, RuleType.APPROX, Boolean.TRUE, Integer.valueOf(1) },\n+                        new Object[] { \"Renault\", \"rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinolt|rinult\", NameType.ASHKENAZI, RuleType.APPROX, Boolean.TRUE, TEN },\n+                        new Object[] { \"Renault\", \"rinDlt\", NameType.ASHKENAZI, RuleType.APPROX, Boolean.TRUE, Integer.valueOf(1) },\n                         new Object[] { \"Renault\", \"rinDlt\", NameType.SEPHARDIC, RuleType.APPROX, Boolean.TRUE, TEN },\n                         new Object[] { \"SntJohn-Smith\", \"sntjonsmit\", NameType.GENERIC, RuleType.EXACT, Boolean.TRUE, TEN },\n                         new Object[] { \"d'ortley\", \"(ortlaj|ortlej)-(dortlaj|dortlej)\", NameType.GENERIC, RuleType.EXACT, Boolean.TRUE, TEN },", "timestamp": 1404590318, "metainfo": ""}