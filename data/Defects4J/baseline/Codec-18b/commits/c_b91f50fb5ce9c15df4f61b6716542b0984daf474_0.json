{"sha": "b91f50fb5ce9c15df4f61b6716542b0984daf474", "log": "[CODEC-174] Small (2.3%) but consistent performance gain with this patch from https://issues.apache.org/jira/secure/attachment/12612838/CODEC-174-delete-subsequence-cache-and-use-String.patch. The nicer aspect of the patch is that it simplifies the code.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n     }\n \n     /**\n-     * This is a performance hack to avoid overhead associated with very frequent CharSequence.subSequence calls.\n-     *\n-     * @param cached the character sequence to cache\n-     * @return a <code>CharSequence</code> that internally caches subSequence values\n-     */\n-    private static CharSequence cacheSubSequence(final CharSequence cached) {\n-        // return cached;\n-        final CharSequence[][] cache = new CharSequence[cached.length()][cached.length()];\n-        return new CharSequence() {\n-            @Override\n-            public char charAt(final int index) {\n-                return cached.charAt(index);\n-            }\n-\n-            @Override\n-            public int length() {\n-                return cached.length();\n-            }\n-\n-            @Override\n-            public CharSequence subSequence(final int start, final int end) {\n-                if (start == end) {\n-                    return \"\";\n-                }\n-\n-                CharSequence res = cache[start][end - 1];\n-                if (res == null) {\n-                    res = cached.subSequence(start, end);\n-                    cache[start][end - 1] = res;\n-                }\n-                return res;\n-            }\n-        };\n-    }\n-\n-    /**\n      * Joins some strings with an internal separator.\n      * @param strings   Strings to join\n      * @param sep       String to separate them with\n \n         for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n             PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n-            final CharSequence phonemeText = cacheSubSequence(phoneme.getPhonemeText());\n+            final String phonemeText = phoneme.getPhonemeText().toString();\n \n             for (int i = 0; i < phonemeText.length();) {\n                 final RulesApplication rulesApplication =\n         PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n \n         // loop over each char in the input - we will handle the increment manually\n-        final CharSequence inputCache = cacheSubSequence(input);\n-        for (int i = 0; i < inputCache.length();) {\n+        for (int i = 0; i < input.length();) {\n             final RulesApplication rulesApplication =\n-                    new RulesApplication(rules, inputCache, phonemeBuilder, i, maxPhonemes).invoke();\n+                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\n             i = rulesApplication.getI();\n             phonemeBuilder = rulesApplication.getPhonemeBuilder();\n         }", "timestamp": 1384289553, "metainfo": ""}