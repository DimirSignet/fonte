{"sha": "b5657da870ca0947c7de4bf94b4b2cc5e23b3698", "log": "Apply documentation patch from Matthew Pocock. Thank you Matthew!  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n  * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it is mutable, and may not be\n  * thread-safe. If you require a guaranteed thread-safe encoding then use {@link PhoneticEngine} directly.\n  * </p>\n+ *\n+ * <h2>Encoding overview</h2>\n+ *\n+ * <p>\n+ * Beider-Morse phonetic encodings is a multi-step process. Firstly, a table of rules is consulted to guess what\n+ * language the word comes from. For example, if it ends in \"<code>ault</code>\" then it infers that the word is French. Next,\n+ * the word is translated into a phonetic representation using a language-specific phonetics table. Some runs of letters\n+ * can be pronounced in multiple ways, and a single run of letters may be potentially broken up into phonemes at\n+ * different places, so this stage results in a set of possible language-specific phonetic representations. Lastly,\n+ * this language-specific phonetic representation is processed by a table of rules that re-writes it phonetically taking\n+ * into account systematic pronunciation differences between languages, to move it towards a pan-indo-european phonetic\n+ * representation. Again, sometimes there are multiple ways this could be done and sometimes things that can be\n+ * pronounced in several ways in the source language have only one way to represent them in this average phonetic\n+ * language, so the result is again a set of phonetic spellings.\n+ * </p>\n+ *\n+ * <p>\n+ * Some names are treated as having multiple parts. This can be due to two things. Firstly, they may be hyphenated. In\n+ * this case, each individual hyphenated word is encoded, and then these are combined end-to-end for the final encoding.\n+ * Secondly, some names have standard prefixes, for example, \"<code>Mac/Mc</code>\" in Scottish (English) names. As sometimes it is\n+ * ambiguous whether the prefix is intended or is an accident of the spelling, the word is encoded once with the prefix\n+ * and once without it. The resulting encoding contains one and then the other result.\n+ * </p>\n+ *\n+ *\n+ * <h2>Encoding format</h2>\n+ *\n+ * Individual phonetic spellings of an input word are represented in upper- and lower-case roman characters. Where there\n+ * are multiple possible phonetic representations, these are joined with a pipe (<code>|</code>) character. If multiple hyphenated\n+ * words where found, or if the word may contain a name prefix, each encoded word is placed in elipses and these blocks\n+ * are then joined with hyphens. For example, \"<code>d'ortley</code>\" has a possible prefix. The form without prefix encodes to\n+ * \"<code>ortlaj|ortlej</code>\", while the form with prefix encodes to \"<code>dortlaj|dortlej</code>\". Thus, the full, combined encoding is\n+ * \"<code>(ortlaj|ortlej)-(dortlaj|dortlej)</code>\".\n+ *\n+ * <p>\n+ * The encoded forms are often quite a bit longer than the input strings. This is because a single input may have many\n+ * potential phonetic interpretations. For example, \"<code>Renault</code>\" encodes to\n+ * \"<code>rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult</code>\". The <code>APPROX</code> rules will tend to produce larger\n+ * encodings as they consider a wider range of possible, approximate phonetic interpretations of the original word.\n+ * Down-stream applications may wish to further process the encoding for indexing or lookup purposes, for example, by\n+ * splitting on pipe (<code>|</code>) and indexing under each of these alternatives.\n+ * </p>\n  * \n  * @author Apache Software Foundation\n  * @since 1.6\n  */\n public class BeiderMorseEncoder implements StringEncoder {\n+    // implementation note: This class is a spring-friendly facade to PhoneticEngine. It allows read/write configuration\n+    // of an immutable PhoneticEngine instance that will be delegated to for the actual encoding.\n+\n     // a cached object\n     private PhoneticEngine engine = new PhoneticEngine(NameType.GENERIC, RuleType.APPROX, true);\n \n--- a/src/main/java/org/apache/commons/codec/language/bm/Lang.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Lang.java\n  * @since 1.6\n  */\n public class Lang {\n+    // implementation note: This class is divided into two sections. The first part is a static factory interface that\n+    // exposes the LANGUAGE_RULES_RN resource as a Lang instance. The second part is the Lang instance methods that\n+    // encapsulate a particular language-guessing rule table and the language guessing itself.\n+    //\n+    // It may make sense in the future to expose the private constructor to allow power users to build custom language-\n+    // guessing rules, perhaps by marking it protected and allowing sub-classing. However, the vast majority of users\n+    // should be strongly encouraged to use the static factory <code>instance</code> method to get their Lang instances.\n \n     private static final class LangRule {\n         private final boolean acceptOnMatch;\n--- a/src/main/java/org/apache/commons/codec/language/bm/Languages.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Languages.java\n  * @since 1.6\n  */\n public class Languages {\n+    // implementation note: This class is divided into two sections. The first part is a static factory interface that\n+    // exposes org/apache/commons/codec/language/bm/%s_languages.txt for %s in NameType.* as a list of supported\n+    // languages, and a second part that provides instance methods for accessing this set fo supported languages.\n \n     /**\n      * A set of languages.\n--- a/src/main/java/org/apache/commons/codec/language/bm/NameType.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/NameType.java\n package org.apache.commons.codec.language.bm;\n \n /**\n- * Supported types of names. Unless you are matching particular family names, use {@link #GENERIC}.\n+ * Supported types of names. Unless you are matching particular family names, use {@link #GENERIC}. The\n+ * <code>GENERIC</code> NameType should work reasonably well for non-name words. The other encodings are specifically\n+ * tuned to family names, and may not work well at all for general text.\n  * \n  * @author Apache Software Foundation\n  * @since 1.6\n--- a/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n  */\n public class PhoneticEngine {\n \n+    /**\n+     * Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside this package,\n+     * and probably not outside the {@link PhoneticEngine} class.\n+     *\n+     * @author Apache Software Foundation\n+     * @since 1.6\n+     */\n     static final class PhonemeBuilder {\n \n+        /**\n+         * An empty builder where all phonemes must come from some set of languages. This will contain a single\n+         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new\n+         * phoneme from scratch.\n+         *\n+         * @param languages the set of languages\n+         * @return  a new, empty phoneme builder\n+         */\n         public static PhonemeBuilder empty(Languages.LanguageSet languages) {\n             return new PhonemeBuilder(Collections.singleton(new Rule.Phoneme(\"\", languages)));\n         }\n             this.phonemes = phonemes;\n         }\n \n+        /**\n+         * Create a new phoneme builder containing all phonemes in this one extended by <code>str</code>.\n+         *\n+         * @param str   the characters to append to the phonemes\n+         * @return  a new phoneme builder lenghened by <code>str</code>\n+         */\n         public PhonemeBuilder append(CharSequence str) {\n             Set<Rule.Phoneme> newPhonemes = new HashSet<Rule.Phoneme>();\n \n             return new PhonemeBuilder(newPhonemes);\n         }\n \n+        /**\n+         * Create a new phoneme builder containing the application of the expression to all phonemes in this builder.\n+         *\n+         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\n+         * incompatible.\n+         *\n+         * @param phonemeExpr   the expression to apply\n+         * @return  a new phoneme builder containing the results of <code>phonemeExpr</code> applied to each phoneme\n+         *      in turn\n+         */\n         public PhonemeBuilder apply(Rule.PhonemeExpr phonemeExpr) {\n             Set<Rule.Phoneme> newPhonemes = new HashSet<Rule.Phoneme>();\n \n             return new PhonemeBuilder(newPhonemes);\n         }\n \n+        /**\n+         * The underlying phoneme set. Please don't mutate.\n+         *\n+         * @return  the phoneme set\n+         */\n         public Set<Rule.Phoneme> getPhonemes() {\n             return this.phonemes;\n         }\n \n+        /**\n+         * Stringify the phoneme set. This produces a single string of the strings of each phoneme, joined with a pipe.\n+         * This is explicitly provied in place of toString as it is a potentially expensive operation, which should be\n+         * avoided when debugging.\n+         *\n+         * @return  the stringified phoneme set\n+         */\n         public String makeString() {\n \n             StringBuilder sb = new StringBuilder();\n         }\n     }\n \n+    /**\n+     * A function closure capturing the application of a list of rules to an input sequence at a particular offset.\n+     * After invocation, the values <code>i</code> and <code>found</code> are updated. <code>i</code> points to the\n+     * index of the next char in <code>input</code> that must be processed next (the input up to that index having been\n+     * processed already), and <code>found</code> indicates if a matching rule was found or not. In the case where a\n+     * matching rule was found, <code>phonemeBuilder</code> is replaced with a new buidler containing the phonemes\n+     * updated by the matching rule.\n+     *\n+     * @author Apache Software Foundation\n+     * @since 1.6\n+     */\n     private static final class RulesApplication {\n         private final List<Rule> finalRules;\n         private final CharSequence input;\n             return this.phonemeBuilder;\n         }\n \n+        /**\n+         * This invokes the rules. It loops over the rules list, stopping at the first one that has a matching context\n+         * and pattern. It then applies this rule to the phoneme builder to produce updated phonemes. If there was no\n+         * match, <code>i</code> is advanced one and the character is silently dropped from the phonetic spelling.\n+         *\n+         * @return <code>this</code>\n+         */\n         public RulesApplication invoke() {\n             this.found = false;\n             int patternLength = 0;\n                 \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n     }\n \n+    /**\n+     * This is a performance hack to avoid overhead associated with very frequent CharSequence.subSequence calls.\n+     *\n+     * @param cached the character sequence to cache\n+     * @return a <code>CharSequence</code> that internally memoises subSequence values\n+     */\n     private static CharSequence cacheSubSequence(final CharSequence cached) {\n         // return cached;\n         final CharSequence[][] cache = new CharSequence[cached.length()][cached.length()];\n         };\n     }\n \n+    /**\n+     * Join some strings with an internal separater.\n+     * @param strings   Strings to join\n+     * @param sep       String to separate them with\n+     * @return          a single String consisting of each element of <code>strings</code> interlieved by <code>sep</code>\n+     */\n     private static String join(Iterable<String> strings, String sep) {\n         StringBuilder sb = new StringBuilder();\n         Iterator<String> si = strings.iterator();\n         this.lang = Lang.instance(nameType);\n     }\n \n+    /**\n+     * Apply the final rules to convert from a language-specific phonetic representation to a language-independent\n+     * representation.\n+     *\n+     * @param phonemeBuilder\n+     * @param finalRules\n+     * @return\n+     */\n     private PhonemeBuilder applyFinalRules(PhonemeBuilder phonemeBuilder, List<Rule> finalRules) {\n         if (finalRules == null) {\n             throw new NullPointerException(\"finalRules can not be null\");\n      */\n     public String encode(String input, final Languages.LanguageSet languageSet) {\n         final List<Rule> rules = Rule.getInstance(this.nameType, RuleType.RULES, languageSet);\n+        // rules common across many (all) languages\n         final List<Rule> finalRules1 = Rule.getInstance(this.nameType, this.ruleType, \"common\");\n+        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\n         final List<Rule> finalRules2 = Rule.getInstance(this.nameType, this.ruleType, languageSet);\n+\n         // System.err.println(\"Languages: \" + languageSet);\n         // System.err.println(\"Rules: \" + rules);\n \n         final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n         final List<String> words2 = new ArrayList<String>();\n \n+        // special-case handling of word prefixes based upon the name type\n         switch (this.nameType) {\n         case SEPHARDIC:\n             for (String aWord : words) {\n             // System.err.println(input + \" \" + i + \": \" + phonemeBuilder.makeString());\n         }\n \n-        // System.err.println(\"Applying general rules\");\n+        // Apply the general rules\n         phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n-        // System.err.println(\"Now got: \" + phonemeBuilder.makeString());\n-        // System.err.println(\"Applying language-specific rules\");\n+        // Apply the language-specific rules\n         phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n-        // System.err.println(\"Now got: \" + phonemeBuilder.makeString());\n-        // System.err.println(\"Done\");\n \n         return phonemeBuilder.makeString();\n     }\n--- a/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n     }\n \n     /**\n-     * Decides if the pattern and context match the input starting at a position.\n+     * Decides if the pattern and context match the input starting at a position. It is a match if the\n+     * <code>lContext</code> matches <code>input</code> up to <code>i</code>, <code>pattern</code> matches at i and\n+     * <code>rContext</code> matches from the end of the match of <code>pattern</code> to the end of <code>input</code>.\n      * \n      * @param input\n      *            the input String\n             return false;\n         }\n \n+        // fixme: this is a readability/speed trade-off - these 3 expressions should be inlined for speed to avoid\n+        // evaluating latter ones if earlier ones have already failed, but that would make the code a lot harder to\n+        // read\n         boolean patternMatches = input.subSequence(i, ipl).equals(this.pattern);\n         boolean rContextMatches = this.rContext.isMatch(input.subSequence(ipl, input.length()));\n         boolean lContextMatches = this.lContext.isMatch(input.subSequence(0, i));\n--- a/src/main/java/org/apache/commons/codec/language/bm/RuleType.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/RuleType.java\n  */\n public enum RuleType {\n \n-    APPROX(\"approx\"), EXACT(\"exact\"), RULES(\"rules\");\n+    /** Approximate rules, which will lead to the largest number of phonetic interpretations. */\n+    APPROX(\"approx\"),\n+    /** Exact rules, which will lead to a minimum number of phonetic interpretations. */\n+    EXACT(\"exact\"),\n+    /** For internal use only. Please use {@link #APPROX} or {@link #EXACT}. */\n+    RULES(\"rules\");\n \n     private final String name;\n ", "timestamp": 1321217947, "metainfo": ""}