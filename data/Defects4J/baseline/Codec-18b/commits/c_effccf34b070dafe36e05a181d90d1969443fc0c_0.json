{"sha": "effccf34b070dafe36e05a181d90d1969443fc0c", "log": "bitWorkArea needs to be in implementation class Allow static access to default pad Fix bug in Base32 chunking and add some tests  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/java/org/apache/commons/codec/binary/Base32.java\n     private final int encodeSize;\n \n     /**\n+     * Place holder for the bytes we're dealing with for our based logic. \n+     * Bitwise operations store and extract the encoding or decoding from this variable.\n+     */\n+    private long bitWorkArea;\n+\n+    /**\n      * Creates a Base32 codec used for decoding and encoding.\n      * <p>\n      * When encoding the line length is 0 (no chunking).\n         // encoding.\n         if (inAvail < 0) {\n             eof = true;\n-            if (0 == modulus) {\n-                return; // no leftovers to process\n+            if (0 == modulus && lineLength == 0) {\n+                return; // no leftovers to process and not using chunking\n             }\n             ensureBufferSize(encodeSize);\n+            int savedPos = pos;\n             switch (modulus) { // % 5\n                 case 1 : // Only 1 octet; take top 5 bits then remainder\n                     buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\n                     buffer[pos++] = PAD;\n                     break;\n             }\n-            if (lineLength > 0){ // add chunk separator if required\n+            currentLinePos += pos - savedPos; // keep track of current line position\n+            // if currentPos == 0 we are at the start of a line, so don't add CRLF\n+            if (lineLength > 0 && currentLinePos > 0){ // add chunk separator if required\n                 System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }            \n         } else {\n             for (int i = 0; i < inAvail; i++) {\n                 ensureBufferSize(encodeSize);\n-                modulus = (++modulus) % BITS_PER_ENCODED_BYTE;\n+                modulus = (++modulus) % BYTES_PER_UNENCODED_BLOCK;\n                 int b = in[inPos++];\n                 if (b < 0) {\n                     b += 256;\n--- a/src/java/org/apache/commons/codec/binary/BaseNCodec.java\n+++ b/src/java/org/apache/commons/codec/binary/BaseNCodec.java\n     /**\n      * Byte used to pad output.\n      */\n-    protected final byte PAD = '='; // instance variable just in case it needs to vary later\n+    protected static final byte PAD_DEFAULT = '='; // Allow static access to default\n+    \n+    protected final byte PAD = PAD_DEFAULT; // instance variable just in case it needs to vary later\n \n     /** Number of bytes in each full block of unencoded data, e.g. 4 for Base64 and 5 for Base32 */\n     private final int unencodedBlockSize;\n      * and must be thrown away.\n      */\n     protected boolean eof;\n-\n-    /**\n-     * Place holder for the bytes we're dealing with for our based logic. \n-     * Bitwise operations store and extract the encoding or decoding from this variable.\n-     */\n-    protected long bitWorkArea;\n \n     /**\n      * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n--- a/src/test/org/apache/commons/codec/binary/Base32Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base32Test.java\n     };\n \n \n+    private static final String [][] BASE32_TEST_CASES_CHUNKED = { //Chunked\n+        {\"\"       ,\"\"},\n+        {\"f\"      ,\"MY======\\r\\n\"},\n+        {\"fo\"     ,\"MZXQ====\\r\\n\"},\n+        {\"foo\"    ,\"MZXW6===\\r\\n\"},\n+        {\"foob\"   ,\"MZXW6YQ=\\r\\n\"},\n+        {\"fooba\"  ,\"MZXW6YTB\\r\\n\"},\n+        {\"foobar\" ,\"MZXW6YTBOI======\\r\\n\"},\n+    };\n+\n     public void testBase32Samples() throws Exception {\n         Base32 codec = new Base32();\n         for (int i = 0; i < BASE32_TEST_CASES.length; i++) {\n         for (int i = 0; i < BASE32HEX_TEST_CASES.length; i++) {\n                 assertEquals(BASE32HEX_TEST_CASES[i][1], codec.encodeAsString(BASE32HEX_TEST_CASES[i][0].getBytes(\"UTF-8\")));\n         }\n+    }\n+\n+    public void testBase32Chunked () throws Exception {\n+        Base32 codec = new Base32(20);\n+        for (int i = 0; i < BASE32_TEST_CASES_CHUNKED.length; i++) {\n+                assertEquals(BASE32_TEST_CASES_CHUNKED[i][1], codec.encodeAsString(BASE32_TEST_CASES_CHUNKED[i][0].getBytes(\"UTF-8\")));\n+        }        \n     }\n \n     public void testSingleCharEncoding() {", "timestamp": 1296177376, "metainfo": ""}