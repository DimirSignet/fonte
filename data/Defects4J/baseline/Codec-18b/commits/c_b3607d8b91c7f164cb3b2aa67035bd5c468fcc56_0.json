{"sha": "b3607d8b91c7f164cb3b2aa67035bd5c468fcc56", "log": "[CODEC-73] Hex: Make string2byte conversions indepedent of platform default encoding. Also refactor DigestUtils to call a new method on Hex.  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Hex.java\n+++ b/src/java/org/apache/commons/codec/binary/Hex.java\n \n package org.apache.commons.codec.binary;\n \n+import java.io.UnsupportedEncodingException;\n+\n import org.apache.commons.codec.BinaryDecoder;\n import org.apache.commons.codec.BinaryEncoder;\n+import org.apache.commons.codec.CharEncoding;\n import org.apache.commons.codec.DecoderException;\n import org.apache.commons.codec.EncoderException;\n \n /**\n- * Hex encoder and decoder.\n+ * Hex encoder and decoder. The charset used for certain operation can be set, the default is set in\n+ * {@link #DEFAULT_CHARSET_NAME}\n  * \n  * @since 1.1\n  * @author Apache Software Foundation\n  */\n public class Hex implements BinaryEncoder, BinaryDecoder {\n \n-    /** \n-     * Used to build output as Hex \n-     */\n-    private static final char[] DIGITS_LOWER = {\n-        '0', '1', '2', '3', '4', '5', '6', '7',\n-           '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n-    };\n-\n-    /** \n-     * Used to build output as Hex \n-     */\n-    private static final char[] DIGITS_UPPER = {\n-        '0', '1', '2', '3', '4', '5', '6', '7',\n-           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n-    };\n-\n-    /**\n-     * Converts an array of characters representing hexadecimal values into an\n-     * array of bytes of those same values. The returned array will be half the\n-     * length of the passed array, as it takes two characters to represent any\n-     * given byte. An exception is thrown if the passed char array has an odd\n-     * number of elements.\n-     * \n-     * @param data An array of characters containing hexadecimal digits\n-     * @return A byte array containing binary data decoded from\n-     *         the supplied char array.\n-     * @throws DecoderException Thrown if an odd number or illegal of characters \n-     *         is supplied\n+    /**\n+     * Default charset name is {@link CharEncoding#UTF_8}\n+     */\n+    public static final String DEFAULT_CHARSET_NAME = CharEncoding.UTF_8;\n+\n+    /**\n+     * Used to build output as Hex\n+     */\n+    private static final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n+\n+    /**\n+     * Used to build output as Hex\n+     */\n+    private static final char[] DIGITS_UPPER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n+\n+    /**\n+     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The\n+     * returned array will be half the length of the passed array, as it takes two characters to represent any given\n+     * byte. An exception is thrown if the passed char array has an odd number of elements.\n+     * \n+     * @param data\n+     *            An array of characters containing hexadecimal digits\n+     * @return A byte array containing binary data decoded from the supplied char array.\n+     * @throws DecoderException\n+     *             Thrown if an odd number or illegal of characters is supplied\n      */\n     public static byte[] decodeHex(char[] data) throws DecoderException {\n \n     }\n \n     /**\n-     * Converts a hexadecimal character to an integer.\n-     *  \n-     * @param ch A character to convert to an integer digit\n-     * @param index The index of the character in the source\n-     * @return An integer\n-     * @throws DecoderException Thrown if ch is an illegal hex character\n-     */\n-    protected static int toDigit(char ch, int index) throws DecoderException {\n-        int digit = Character.digit(ch, 16);\n-        if (digit == -1) {\n-            throw new DecoderException(\"Illegal hexadecimal charcter \" + ch + \" at index \" + index);\n-        }\n-        return digit;\n-    }\n-\n-    /**\n      * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n      * The returned array will be double the length of the passed array, as it takes two characters to represent any\n      * given byte.\n     }\n \n     /**\n-     * Converts an array of character bytes representing hexadecimal values into an\n-     * array of bytes of those same values. The returned array will be half the\n-     * length of the passed array, as it takes two characters to represent any\n-     * given byte. An exception is thrown if the passed char array has an odd\n-     * number of elements.\n-     * \n-     * @param array An array of character bytes containing hexadecimal digits\n-     * @return A byte array containing binary data decoded from\n-     *         the supplied byte array (representing characters).\n-     * @throws DecoderException Thrown if an odd number of characters is supplied\n-     *                   to this function\n+     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\n+     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n+     * \n+     * @param data\n+     *            a byte[] to convert to Hex characters\n+     * @return A String containing hexadecimal characters\n+     * @since 1.4\n+     */\n+    public static String encodeHexString(byte[] data) {\n+        return new String(encodeHex(data));\n+    }\n+\n+    /**\n+     * Converts a hexadecimal character to an integer.\n+     * \n+     * @param ch\n+     *            A character to convert to an integer digit\n+     * @param index\n+     *            The index of the character in the source\n+     * @return An integer\n+     * @throws DecoderException\n+     *             Thrown if ch is an illegal hex character\n+     */\n+    protected static int toDigit(char ch, int index) throws DecoderException {\n+        int digit = Character.digit(ch, 16);\n+        if (digit == -1) {\n+            throw new DecoderException(\"Illegal hexadecimal charcter \" + ch + \" at index \" + index);\n+        }\n+        return digit;\n+    }\n+\n+    private String charsetName = DEFAULT_CHARSET_NAME;\n+\n+    /**\n+     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET_NAME}\n+     */\n+    public Hex() {\n+        // use default encoding\n+    }\n+\n+    /**\n+     * Creates a new codec with the given charset name.\n+     * \n+     * @param csName\n+     *            the charset name.\n+     */\n+    public Hex(String csName) {\n+        setCharsetName(csName);\n+    }\n+\n+    /**\n+     * Converts an array of character bytes representing hexadecimal values into an array of bytes of those same values.\n+     * The returned array will be half the length of the passed array, as it takes two characters to represent any given\n+     * byte. An exception is thrown if the passed char array has an odd number of elements.\n+     * \n+     * @param array\n+     *            An array of character bytes containing hexadecimal digits\n+     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n+     * @throws DecoderException\n+     *             Thrown if an odd number of characters is supplied to this function\n      * @see #decodeHex(char[])\n      */\n     public byte[] decode(byte[] array) throws DecoderException {\n-        return decodeHex(new String(array).toCharArray());\n-    }\n-    \n-    /**\n-     * Converts a String or an array of character bytes representing hexadecimal values into an\n-     * array of bytes of those same values. The returned array will be half the\n-     * length of the passed String or array, as it takes two characters to represent any\n-     * given byte. An exception is thrown if the passed char array has an odd\n-     * number of elements.\n-     * \n-     * @param object A String or, an array of character bytes containing hexadecimal digits\n-     * @return A byte array containing binary data decoded from\n-     *         the supplied byte array (representing characters).\n-     * @throws DecoderException Thrown if an odd number of characters is supplied\n-     *                   to this function or the object is not a String or char[]\n+        try {\n+            return decodeHex(new String(array, getCharsetName()).toCharArray());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new DecoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those\n+     * same values. The returned array will be half the length of the passed String or array, as it takes two characters\n+     * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.\n+     * \n+     * @param object\n+     *            A String or, an array of character bytes containing hexadecimal digits\n+     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n+     * @throws DecoderException\n+     *             Thrown if an odd number of characters is supplied to this function or the object is not a String or\n+     *             char[]\n      * @see #decodeHex(char[])\n      */\n     public Object decode(Object object) throws DecoderException {\n     }\n \n     /**\n-     * Converts an array of bytes into an array of bytes for the characters representing the\n-     * hexadecimal values of each byte in order. The returned array will be\n-     * double the length of the passed array, as it takes two characters to\n+     * Converts an array of bytes into an array of bytes for the characters representing the hexadecimal values of each\n+     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to\n      * represent any given byte.\n-     *\n-     * @param array a byte[] to convert to Hex characters\n+     * <p>\n+     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by\n+     * {@link #getCharsetName()}.\n+     * </p>\n+     * \n+     * @param array\n+     *            a byte[] to convert to Hex characters\n      * @return A byte[] containing the bytes of the hexadecimal characters\n+     * @throws IllegalStateException\n+     *             if the charsetName is invalid. This API throws {@link IllegalStateException} instead of\n+     *             {@link UnsupportedEncodingException} for backward compatibility.\n      * @see #encodeHex(byte[])\n      */\n     public byte[] encode(byte[] array) {\n-        return new String(encodeHex(array)).getBytes();\n-    }\n-\n-    /**\n-     * Converts a String or an array of bytes into an array of characters representing the\n-     * hexadecimal values of each byte in order. The returned array will be\n-     * double the length of the passed String or array, as it takes two characters to\n-     * represent any given byte.\n-     *\n-     * @param object a String, or byte[] to convert to Hex characters\n+        return StringUtils.getBytesUnchecked(encodeHexString(array), getCharsetName());\n+    }\n+\n+    /**\n+     * Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each\n+     * byte in order. The returned array will be double the length of the passed String or array, as it takes two\n+     * characters to represent any given byte.\n+     * <p>\n+     * The conversion from hexadecimal characters to bytes to be encoded to performed with the charset named by\n+     * {@link #getCharsetName()}.\n+     * </p>\n+     * \n+     * @param object\n+     *            a String, or byte[] to convert to Hex characters\n      * @return A char[] containing hexadecimal characters\n-     * @throws EncoderException Thrown if the given object is not a String or byte[]\n+     * @throws EncoderException\n+     *             Thrown if the given object is not a String or byte[]\n      * @see #encodeHex(byte[])\n      */\n-    public Object encode(Object object) throws EncoderException {    \n+    public Object encode(Object object) throws EncoderException {\n         try {\n-            byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;\n+            byte[] byteArray = object instanceof String ? ((String) object).getBytes(getCharsetName()) : (byte[]) object;\n             return encodeHex(byteArray);\n         } catch (ClassCastException e) {\n             throw new EncoderException(e.getMessage(), e);\n-        }\n-    }\n-\n+        } catch (UnsupportedEncodingException e) {\n+            throw new EncoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Gets the charset name.\n+     * \n+     * @return the charset name.\n+     */\n+    public String getCharsetName() {\n+        return this.charsetName;\n+    }\n+\n+    /**\n+     * Sets the charset name.\n+     * \n+     * @param charsetName\n+     *            the charset name.\n+     */\n+    public void setCharsetName(String charsetName) {\n+        this.charsetName = charsetName;\n+    }\n+\n+    public String toString() {\n+        return super.toString() + \"[charsetName=\" + this.charsetName + \"]\";\n+    }\n }\n-\n--- a/src/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/java/org/apache/commons/codec/binary/StringUtils.java\n      * @throws IllegalStateException\n      *             Thrown when the charset is missing, which should be never according the the Java specification.\n      * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n-     * @see #getSupportedBytes(String, String)\n+     * @see #getBytesUnchecked(String, String)\n      */\n     public static byte[] getBytesIso8859_1(String string) {\n-        return StringUtils.getSupportedBytes(string, CharEncoding.ISO_8859_1);\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.ISO_8859_1);\n     }\n \n     /**\n      * @throws IllegalStateException\n      *             Thrown when the charset is missing, which should be never according the the Java specification.\n      * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n-     * @see #getSupportedBytes(String, String)\n+     * @see #getBytesUnchecked(String, String)\n      */\n     public static byte[] getBytesUsAscii(String string) {\n-        return StringUtils.getSupportedBytes(string, CharEncoding.US_ASCII);\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.US_ASCII);\n     }\n \n     /**\n      * @throws IllegalStateException\n      *             Thrown when the charset is missing, which should be never according the the Java specification.\n      * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n-     * @see #getSupportedBytes(String, String)\n+     * @see #getBytesUnchecked(String, String)\n      */\n     public static byte[] getBytesUtf16(String string) {\n-        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16);\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16);\n     }\n \n     /**\n      * @throws IllegalStateException\n      *             Thrown when the charset is missing, which should be never according the the Java specification.\n      * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n-     * @see #getSupportedBytes(String, String)\n+     * @see #getBytesUnchecked(String, String)\n      */\n     public static byte[] getBytesUtf16Be(String string) {\n-        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16BE);\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16BE);\n     }\n \n     /**\n      * @throws IllegalStateException\n      *             Thrown when the charset is missing, which should be never according the the Java specification.\n      * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n-     * @see #getSupportedBytes(String, String)\n+     * @see #getBytesUnchecked(String, String)\n      */\n     public static byte[] getBytesUtf16Le(String string) {\n-        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16LE);\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16LE);\n     }\n \n     /**\n      * @throws IllegalStateException\n      *             Thrown when the charset is missing, which should be never according the the Java specification.\n      * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n-     * @see #getSupportedBytes(String, String)\n+     * @see #getBytesUnchecked(String, String)\n      */\n     public static byte[] getBytesUtf8(String string) {\n-        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_8);\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n     }\n \n     /**\n      * @see CharEncoding\n      * @see String#getBytes(String)\n      */\n-    public static byte[] getSupportedBytes(String string, String charsetName) {\n+    public static byte[] getBytesUnchecked(String string, String charsetName) {\n         if (string == null) {\n             return null;\n         }\n--- a/src/java/org/apache/commons/codec/digest/DigestUtils.java\n+++ b/src/java/org/apache/commons/codec/digest/DigestUtils.java\n      * @return MD5 digest as a hex string\n      */\n     public static String md5Hex(byte[] data) {\n-        return new String(Hex.encodeHex(md5(data)));\n+        return Hex.encodeHexString(md5(data));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String md5Hex(InputStream data) throws IOException {\n-        return new String(Hex.encodeHex(md5(data)));\n+        return Hex.encodeHexString(md5(data));\n     }\n \n     /**\n      * @return MD5 digest as a hex string\n      */\n     public static String md5Hex(String data) {\n-        return new String(Hex.encodeHex(md5(data)));\n+        return Hex.encodeHexString(md5(data));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String sha256Hex(byte[] data) {\n-        return new String(Hex.encodeHex(sha256(data)));\n+        return Hex.encodeHexString(sha256(data));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String sha256Hex(InputStream data) throws IOException {\n-        return new String(Hex.encodeHex(sha256(data)));\n+        return Hex.encodeHexString(sha256(data));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String sha256Hex(String data) {\n-        return new String(Hex.encodeHex(sha256(data)));\n+        return Hex.encodeHexString(sha256(data));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String sha384Hex(byte[] data) {\n-        return new String(Hex.encodeHex(sha384(data)));\n+        return Hex.encodeHexString(sha384(data));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String sha384Hex(InputStream data) throws IOException {\n-        return new String(Hex.encodeHex(sha384(data)));\n+        return Hex.encodeHexString(sha384(data));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String sha384Hex(String data) {\n-        return new String(Hex.encodeHex(sha384(data)));\n+        return Hex.encodeHexString(sha384(data));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String sha512Hex(byte[] data) {\n-        return new String(Hex.encodeHex(sha512(data)));\n+        return Hex.encodeHexString(sha512(data));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String sha512Hex(InputStream data) throws IOException {\n-        return new String(Hex.encodeHex(sha512(data)));\n+        return Hex.encodeHexString(sha512(data));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String sha512Hex(String data) {\n-        return new String(Hex.encodeHex(sha512(data)));\n+        return Hex.encodeHexString(sha512(data));\n     }\n \n     /**\n      * @return SHA-1 digest as a hex string\n      */\n     public static String shaHex(byte[] data) {\n-        return new String(Hex.encodeHex(sha(data)));\n+        return Hex.encodeHexString(sha(data));\n     }\n \n     /**\n      * @since 1.4\n      */\n     public static String shaHex(InputStream data) throws IOException {\n-        return new String(Hex.encodeHex(sha(data)));\n+        return Hex.encodeHexString(sha(data));\n     }\n \n     /**\n      * @return SHA-1 digest as a hex string\n      */\n     public static String shaHex(String data) {\n-        return new String(Hex.encodeHex(sha(data)));\n+        return Hex.encodeHexString(sha(data));\n     }\n }\n--- a/src/test/org/apache/commons/codec/binary/Base64Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java\n             // Very important debugging output should anyone\n             // ever need to delve closely into this stuff.\n             if (false) {\n-                System.out.println(\"reference: [\" + new String(Hex.encodeHex(ids[i])) + \"]\");\n+                System.out.println(\"reference: [\" + Hex.encodeHexString(ids[i]) + \"]\");\n                 System.out.println(\"standard:  [\" +\n-                    new String(Hex.encodeHex(decodedStandard)) +\n+                        Hex.encodeHexString(decodedStandard) +\n                     \"] From: [\" +\n                     StringUtils.newStringUtf8(standard[i]) +\n                     \"]\");\n                 System.out.println(\"safe1:     [\" +\n-                    new String(Hex.encodeHex(decodedUrlSafe1)) +\n+                        Hex.encodeHexString(decodedUrlSafe1) +\n                     \"] From: [\" +\n                     StringUtils.newStringUtf8(urlSafe1[i]) +\n                     \"]\");\n                 System.out.println(\"safe2:     [\" +\n-                    new String(Hex.encodeHex(decodedUrlSafe2)) +\n+                        Hex.encodeHexString(decodedUrlSafe2) +\n                     \"] From: [\" +\n                     StringUtils.newStringUtf8(urlSafe2[i]) +\n                     \"]\");\n                 System.out.println(\"safe3:     [\" +\n-                    new String(Hex.encodeHex(decodedUrlSafe3)) +\n+                        Hex.encodeHexString(decodedUrlSafe3) +\n                     \"] From: [\" +\n                     StringUtils.newStringUtf8(urlSafe3[i]) +\n                     \"]\");\n--- a/src/test/org/apache/commons/codec/binary/HexTest.java\n+++ b/src/test/org/apache/commons/codec/binary/HexTest.java\n \n package org.apache.commons.codec.binary;\n \n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.Charset;\n import java.util.Arrays;\n+import java.util.Iterator;\n import java.util.Random;\n-\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import junit.framework.Assert;\n import junit.framework.TestCase;\n \n import org.apache.commons.codec.DecoderException;\n  * @author Apache Software Foundation\n  * @version $Id$\n  */\n-\n public class HexTest extends TestCase {\n+\n+    private final static boolean LOG = false;\n \n     public HexTest(String name) {\n         super(name);\n     }\n-    \n+\n+    /**\n+     * @param data\n+     */\n+    private void checkDecodeHexOddCharacters(char[] data) {\n+        try {\n+            Hex.decodeHex(data);\n+            fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n+        } catch (DecoderException e) {\n+            // Expected exception\n+        }\n+    }\n+\n+    private void log(String s) {\n+        if (LOG) {\n+            System.out.println(s);\n+        }\n+    }\n+\n+    public void testCustomCharset() throws UnsupportedEncodingException, DecoderException {\n+        SortedMap map = Charset.availableCharsets();\n+        Set keys = map.keySet();\n+        Iterator iterator = keys.iterator();\n+        log(\"testCustomCharset: Checking \" + keys.size() + \" charsets...\");\n+        while (iterator.hasNext()) {\n+            String name = (String) iterator.next();\n+            testCustomCharset(name, \"testCustomCharset\");\n+        }\n+    }\n+\n+    /**\n+     * @param name\n+     * @param parent\n+     *            TODO\n+     * @throws UnsupportedEncodingException\n+     * @throws DecoderException\n+     */\n+    private void testCustomCharset(String name, String parent) throws UnsupportedEncodingException, DecoderException {\n+        if (charsetSanityCheck(name) == false) {\n+            log(\"Interesting Java charset oddity: Charset sanity check failed for \" + name);\n+            return;\n+        }\n+        log(parent + \"=\" + name);\n+        Hex customCodec = new Hex(name);\n+        // source data\n+        String sourceString = \"Hello World\";\n+        byte[] sourceBytes = sourceString.getBytes(name);\n+        // test 1\n+        // encode source to hex string to bytes with charset\n+        byte[] actualEncodedBytes = customCodec.encode(sourceBytes);\n+        // encode source to hex string...\n+        String expectedHexString = Hex.encodeHexString(sourceBytes);\n+        // ... and get the bytes in the expected charset\n+        byte[] expectedHexStringBytes = expectedHexString.getBytes(name);\n+        Assert.assertTrue(Arrays.equals(expectedHexStringBytes, actualEncodedBytes));\n+        // test 2\n+        String actualStringFromBytes = new String(actualEncodedBytes, name);\n+        assertEquals(name + \", expectedHexString=\" + expectedHexString + \", actualStringFromBytes=\" + actualStringFromBytes,\n+                expectedHexString, actualStringFromBytes);\n+        // second test:\n+        Hex utf8Codec = new Hex();\n+        expectedHexString = \"48656c6c6f20576f726c64\";\n+        byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString);\n+        actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharsetName());\n+        // sanity check:\n+        assertEquals(name, sourceString, actualStringFromBytes);\n+        // actual check:\n+        byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes);\n+        actualStringFromBytes = new String(decodedCustomBytes, name);\n+        assertEquals(name, sourceString, actualStringFromBytes);\n+    }\n+\n+    private boolean charsetSanityCheck(String name) {\n+        final String source = \"the quick brown dog jumped over the lazy fox\";\n+        try {\n+            byte[] bytes = source.getBytes(name);\n+            String str = new String(bytes, name);\n+            return source.equals(str);\n+        } catch (UnsupportedEncodingException e) {\n+            // Should NEVER happen since we are getting the name from the Charset class.\n+            if (LOG) {\n+                e.printStackTrace();\n+            }\n+            return false;\n+        } catch (UnsupportedOperationException e) {\n+            // Happens with:\n+            // x-JIS0208 on Windows XP and Java Sun 1.6.0_14\n+            if (LOG) {\n+                e.printStackTrace();\n+            }\n+            return false;\n+        }\n+    }\n+\n     public void testDecodeArrayOddCharacters() {\n         try {\n-            new Hex().decode(new byte[] { 65 });\n+            new Hex().decode(new byte[]{65});\n             fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n-        }\n-        catch (DecoderException e) {\n+        } catch (DecoderException e) {\n             // Expected exception\n         }\n     }\n         try {\n             new Hex().decode(\"q0\");\n             fail(\"An exception wasn't thrown when trying to decode an illegal character\");\n-        }\n-        catch (DecoderException e) {\n+        } catch (DecoderException e) {\n             // Expected exception\n         }\n     }\n         try {\n             new Hex().decode(\"0q\");\n             fail(\"An exception wasn't thrown when trying to decode an illegal character\");\n-        }\n-        catch (DecoderException e) {\n+        } catch (DecoderException e) {\n             // Expected exception\n         }\n     }\n \n     public void testDecodeClassCastException() {\n         try {\n-            new Hex().decode(new int[] { 65 });\n+            new Hex().decode(new int[]{65});\n             fail(\"An exception wasn't thrown when trying to decode.\");\n-        }\n-        catch (DecoderException e) {\n-            // Expected exception\n-        }\n-    }\n-\n-    public void testDecodeHexOddCharacters() {\n-        try {\n-            Hex.decodeHex(new char[] { 'A' });\n-            fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n-        }\n-        catch (DecoderException e) {\n-            // Expected exception\n-        }\n+        } catch (DecoderException e) {\n+            // Expected exception\n+        }\n+    }\n+\n+    public void testDecodeHexOddCharacters1() {\n+        checkDecodeHexOddCharacters(new char[]{'A'});\n+    }\n+\n+    public void testDecodeHexOddCharacters3() {\n+        checkDecodeHexOddCharacters(new char[]{'A', 'B', 'C'});\n+    }\n+\n+    public void testDecodeHexOddCharacters5() {\n+        checkDecodeHexOddCharacters(new char[]{'A', 'B', 'C', 'D', 'E'});\n     }\n \n     public void testDecodeStringOddCharacters() {\n         try {\n             new Hex().decode(\"6\");\n             fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n-        }\n-        catch (DecoderException e) {\n+        } catch (DecoderException e) {\n             // Expected exception\n         }\n     }\n     public void testDencodeEmpty() throws DecoderException {\n         assertTrue(Arrays.equals(new byte[0], Hex.decodeHex(new char[0])));\n         assertTrue(Arrays.equals(new byte[0], new Hex().decode(new byte[0])));\n-        assertTrue(Arrays.equals(new byte[0], (byte[])new Hex().decode(\"\")));\n-    }\n-    \n+        assertTrue(Arrays.equals(new byte[0], (byte[]) new Hex().decode(\"\")));\n+    }\n+\n     public void testEncodeClassCastException() {\n         try {\n-            new Hex().encode(new int[] { 65 });\n+            new Hex().encode(new int[]{65});\n             fail(\"An exception wasn't thrown when trying to encode.\");\n-        }\n-        catch (EncoderException e) {\n+        } catch (EncoderException e) {\n             // Expected exception\n         }\n     }\n             char[] encodedChars = Hex.encodeHex(data);\n             byte[] decodedBytes = Hex.decodeHex(encodedChars);\n             assertTrue(Arrays.equals(data, decodedBytes));\n-            \n+\n             // instance API with array parameter\n             byte[] encodedStringBytes = hex.encode(data);\n             decodedBytes = hex.decode(encodedStringBytes);\n \n             // instance API with char[] (Object) parameter\n             String dataString = new String(encodedChars);\n-            char[] encodedStringChars = (char[])hex.encode(dataString);\n-            decodedBytes = (byte[])hex.decode(encodedStringChars);\n-            assertTrue(Arrays.equals(dataString.getBytes(), decodedBytes));\n+            char[] encodedStringChars = (char[]) hex.encode(dataString);\n+            decodedBytes = (byte[]) hex.decode(encodedStringChars);\n+            assertTrue(Arrays.equals(StringUtils.getBytesUtf8(dataString), decodedBytes));\n \n             // instance API with String (Object) parameter\n             dataString = new String(encodedChars);\n-            encodedStringChars = (char[])hex.encode(dataString);\n-            decodedBytes = (byte[])hex.decode(new String(encodedStringChars));\n-            assertTrue(Arrays.equals(dataString.getBytes(), decodedBytes));\n+            encodedStringChars = (char[]) hex.encode(dataString);\n+            decodedBytes = (byte[]) hex.decode(new String(encodedStringChars));\n+            assertTrue(Arrays.equals(StringUtils.getBytesUtf8(dataString), decodedBytes));\n         }\n     }\n \n     public void testEncodeEmpty() throws EncoderException {\n         assertTrue(Arrays.equals(new char[0], Hex.encodeHex(new byte[0])));\n         assertTrue(Arrays.equals(new byte[0], new Hex().encode(new byte[0])));\n-        assertTrue(Arrays.equals(new char[0], (char[])new Hex().encode(\"\")));\n+        assertTrue(Arrays.equals(new char[0], (char[]) new Hex().encode(\"\")));\n     }\n \n     public void testEncodeZeroes() {\n         char[] c = Hex.encodeHex(new byte[36]);\n-        assertEquals(\n-            \"000000000000000000000000000000000000\"\n-                + \"000000000000000000000000000000000000\",\n-            new String(c));\n+        assertEquals(\"000000000000000000000000000000000000000000000000000000000000000000000000\", new String(c));\n     }\n \n     public void testHelloWorldLowerCaseHex() {\n-        byte[] b = \"Hello World\".getBytes();\n+        byte[] b = StringUtils.getBytesUtf8(\"Hello World\");\n         final String expected = \"48656c6c6f20576f726c64\";\n         char[] actual;\n         actual = Hex.encodeHex(b);\n     }\n \n     public void testHelloWorldUpperCaseHex() {\n-        byte[] b = \"Hello World\".getBytes();\n+        byte[] b = StringUtils.getBytesUtf8(\"Hello World\");\n         final String expected = \"48656C6C6F20576F726C64\";\n         char[] actual;\n         actual = Hex.encodeHex(b);\n         actual = Hex.encodeHex(b, false);\n         assertTrue(expected.equals(new String(actual)));\n     }\n+\n+    public void testRequiredCharset() throws UnsupportedEncodingException, DecoderException {\n+        testCustomCharset(\"UTF-8\", \"testRequiredCharset\");\n+        testCustomCharset(\"UTF-16\", \"testRequiredCharset\");\n+        testCustomCharset(\"UTF-16BE\", \"testRequiredCharset\");\n+        testCustomCharset(\"UTF-16LE\", \"testRequiredCharset\");\n+        testCustomCharset(\"US-ASCII\", \"testRequiredCharset\");\n+        testCustomCharset(\"ISO8859_1\", \"testRequiredCharset\");\n+    }\n }\n--- a/src/test/org/apache/commons/codec/binary/StringUtilsTest.java\n+++ b/src/test/org/apache/commons/codec/binary/StringUtilsTest.java\n \n     public void testGetBytesIso8859_1() throws UnsupportedEncodingException {\n         String charsetName = \"ISO-8859-1\";\n-        testGetSupportedBytes(charsetName);\n+        testGetBytesUnchecked(charsetName);\n         byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n         byte[] actual = StringUtils.getBytesIso8859_1(STRING_FIXTURE);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n     }\n \n+    private void testGetBytesUnchecked(String charsetName) throws UnsupportedEncodingException {\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUnchecked(STRING_FIXTURE, charsetName);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n     public void testGetBytesUsAscii() throws UnsupportedEncodingException {\n         String charsetName = \"US-ASCII\";\n-        testGetSupportedBytes(charsetName);\n+        testGetBytesUnchecked(charsetName);\n         byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n         byte[] actual = StringUtils.getBytesUsAscii(STRING_FIXTURE);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n \n     public void testGetBytesUtf16() throws UnsupportedEncodingException {\n         String charsetName = \"UTF-16\";\n-        testGetSupportedBytes(charsetName);\n+        testGetBytesUnchecked(charsetName);\n         byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n         byte[] actual = StringUtils.getBytesUtf16(STRING_FIXTURE);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n \n     public void testGetBytesUtf16Be() throws UnsupportedEncodingException {\n         String charsetName = \"UTF-16BE\";\n-        testGetSupportedBytes(charsetName);\n+        testGetBytesUnchecked(charsetName);\n         byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n         byte[] actual = StringUtils.getBytesUtf16Be(STRING_FIXTURE);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n \n     public void testGetBytesUtf16Le() throws UnsupportedEncodingException {\n         String charsetName = \"UTF-16LE\";\n-        testGetSupportedBytes(charsetName);\n+        testGetBytesUnchecked(charsetName);\n         byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n         byte[] actual = StringUtils.getBytesUtf16Le(STRING_FIXTURE);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n \n     public void testGetBytesUtf8() throws UnsupportedEncodingException {\n         String charsetName = \"UTF-8\";\n-        testGetSupportedBytes(charsetName);\n+        testGetBytesUnchecked(charsetName);\n         byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n         byte[] actual = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n     }\n \n-    private void testGetSupportedBytes(String charsetName) throws UnsupportedEncodingException {\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringUtils.getSupportedBytes(STRING_FIXTURE, charsetName);\n-        Assert.assertTrue(Arrays.equals(expected, actual));\n-    }\n-\n-    public void testGetSupportedBytesBadEnc() {\n+    public void testGetBytesUncheckedBadName() {\n         try {\n-            StringUtils.getSupportedBytes(STRING_FIXTURE, \"UNKNOWN\");\n+            StringUtils.getBytesUnchecked(STRING_FIXTURE, \"UNKNOWN\");\n             Assert.fail(\"Expected \" + IllegalStateException.class.getName());\n         } catch (IllegalStateException e) {\n             // Expected", "timestamp": 1249502154, "metainfo": ""}