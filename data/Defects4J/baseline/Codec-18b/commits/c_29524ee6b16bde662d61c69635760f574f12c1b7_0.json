{"sha": "29524ee6b16bde662d61c69635760f574f12c1b7", "log": "[CODEC-125] Implement a Beider-Morse phonetic matching codec. Applied patch https://issues.apache.org/jira/secure/attachment/12489755/fightingMemoryChurn.patch  ", "commit": "\n--- a/src/java/org/apache/commons/codec/language/bm/Lang.java\n+++ b/src/java/org/apache/commons/codec/language/bm/Lang.java\n import java.util.EnumMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n import java.util.Scanner;\n import java.util.Set;\n  */\n public class Lang {\n \n-    private static class LangRule {\n+    private static final class LangRule {\n         private final boolean acceptOnMatch;\n         private final Set<String> languages;\n         private final Pattern pattern;\n      */\n     public String guessLanguage(String text) {\n         Languages.LanguageSet ls = guessLanguages(text);\n-        return ls.isSingleton() ? ls.getAny() : Languages.ANY; \n+        return ls.isSingleton() ? ls.getAny() : Languages.ANY;\n     }\n \n     /**\n      * @return a Set of Strings of language names that are potential matches for the input word\n      */\n     public Languages.LanguageSet guessLanguages(String input) {\n-        String text = input.toLowerCase(); // todo: locale?\n+        String text = input.toLowerCase(Locale.ENGLISH);\n         // System.out.println(\"Testing text: '\" + text + \"'\");\n \n         Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n--- a/src/java/org/apache/commons/codec/language/bm/Languages.java\n+++ b/src/java/org/apache/commons/codec/language/bm/Languages.java\n      * A set of languages.\n      */\n     public static abstract class LanguageSet {\n-        \n+\n         public static LanguageSet from(Set<String> langs) {\n-            return langs.isEmpty() ? NO_LANGUAGES : new SomeLanguages(langs);  \n+            return langs.isEmpty() ? NO_LANGUAGES : new SomeLanguages(langs);\n         }\n \n         public abstract boolean contains(String language);\n     /**\n      * Some languages, explicitly enumerated.\n      */\n-    public static class SomeLanguages extends LanguageSet {\n+    public static final class SomeLanguages extends LanguageSet {\n         private final Set<String> languages;\n \n         private SomeLanguages(Set<String> languages) {\n                 return this;\n             } else {\n                 SomeLanguages sl = (SomeLanguages) other;\n-                Set<String> ls = new HashSet<String>(this.languages);\n-                ls.retainAll(sl.languages);\n-                return from(ls);\n+                if (sl.languages.containsAll(languages)) {\n+                    return this;\n+                } else {\n+                    Set<String> ls = new HashSet<String>(this.languages);\n+                    ls.retainAll(sl.languages);\n+                    return from(ls);\n+                }\n             }\n         }\n \n--- a/src/java/org/apache/commons/codec/language/bm/NameType.java\n+++ b/src/java/org/apache/commons/codec/language/bm/NameType.java\n  * @since 2.0\n  */\n public enum NameType {\n-    \n+\n     /** Ashkenazi family names */\n     ASHKENAZI(\"ash\"),\n-    \n+\n     /** Generic names and words */\n     GENERIC(\"gen\"),\n-    \n+\n     /** Sephardic family names */\n     SEPHARDIC(\"sep\");\n \n--- a/src/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n  */\n public class PhoneticEngine {\n \n-    static class PhonemeBuilder {\n+    static final class PhonemeBuilder {\n \n         public static PhonemeBuilder empty(Languages.LanguageSet languages) {\n             return new PhonemeBuilder(Collections.singleton(new Rule.Phoneme(\"\", languages)));\n         }\n     }\n \n-    private static class RulesApplication {\n+    private static final class RulesApplication {\n         private final List<Rule> finalRules;\n         private final CharSequence input;\n \n                 \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n     }\n \n+    private static CharSequence cacheSubSequence(final CharSequence cached) {\n+        // return cached;\n+        final CharSequence[][] cache = new CharSequence[cached.length()][cached.length()];\n+        return new CharSequence() {\n+            public char charAt(int index) {\n+                return cached.charAt(index);\n+            }\n+\n+            public int length() {\n+                return cached.length();\n+            }\n+\n+            public CharSequence subSequence(int start, int end) {\n+                if (start == end)\n+                    return \"\";\n+\n+                CharSequence res = cache[start][end - 1];\n+                if (res == null) {\n+                    res = cached.subSequence(start, end);\n+                    cache[start][end - 1] = res;\n+                }\n+                return res;\n+            }\n+        };\n+    }\n+\n     private static String join(Iterable<String> strings, String sep) {\n         StringBuilder sb = new StringBuilder();\n         Iterator<String> si = strings.iterator();\n \n         for (Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n             PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n-            CharSequence phonemeText = phoneme.getPhonemeText();\n+            CharSequence phonemeText = cacheSubSequence(phoneme.getPhonemeText());\n             // System.err.println(\"Expanding: \" + phonemeText);\n \n             for (int i = 0; i < phonemeText.length();) {\n             }\n \n             // System.err.println(\"Expanded to: \" + subBuilder.makeString());\n-\n+            // System.err.println(\"phenomes in collection of type: \" + subBuilder.getPhonemes().getClass());\n             phonemes.addAll(subBuilder.getPhonemes());\n         }\n \n         PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n \n         // loop over each char in the input - we will handle the increment manually\n-        for (int i = 0; i < input.length();) {\n-            RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i).invoke();\n+        CharSequence inputCache = cacheSubSequence(input);\n+        for (int i = 0; i < inputCache.length();) {\n+            RulesApplication rulesApplication = new RulesApplication(rules, inputCache, phonemeBuilder, i).invoke();\n             i = rulesApplication.getI();\n             phonemeBuilder = rulesApplication.getPhonemeBuilder();\n             // System.err.println(input + \" \" + i + \": \" + phonemeBuilder.makeString());\n--- a/src/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/java/org/apache/commons/codec/language/bm/Rule.java\n  */\n public class Rule {\n \n-    private static class AppendableCharSeqeuence implements CharSequence {\n-\n-        private final CharSequence left;\n-        private final CharSequence right;\n-        private final int length;\n-        private String contentCache = null;\n-\n-        private AppendableCharSeqeuence(CharSequence left, CharSequence right) {\n-            this.left = left;\n-            this.right = right;\n-            this.length = left.length() + right.length();\n-        }\n-\n-        public void buildString(StringBuilder sb) {\n-            if (left instanceof AppendableCharSeqeuence) {\n-                ((AppendableCharSeqeuence) left).buildString(sb);\n-            } else {\n-                sb.append(left);\n-            }\n-            if (right instanceof AppendableCharSeqeuence) {\n-                ((AppendableCharSeqeuence) right).buildString(sb);\n-            } else {\n-                sb.append(right);\n-            }\n-        }\n-\n-        public char charAt(int index) {\n-            // int lLength = left.length();\n-            // if(index < lLength) return left.charAt(index);\n-            // else return right.charAt(index - lLength);\n-            return toString().charAt(index);\n-        }\n-\n-        public int length() {\n-            return length;\n-        }\n-\n-        public CharSequence subSequence(int start, int end) {\n-            // int lLength = left.length();\n-            // if(start > lLength) return right.subSequence(start - lLength, end - lLength);\n-            // else if(end <= lLength) return left.subSequence(start, end);\n-            // else {\n-            // CharSequence newLeft = left.subSequence(start, lLength);\n-            // CharSequence newRight = right.subSequence(0, end - lLength);\n-            // return new AppendableCharSeqeuence(newLeft, newRight);\n-            // }\n-            return toString().subSequence(start, end);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            if (contentCache == null) {\n-                StringBuilder sb = new StringBuilder();\n-                buildString(sb);\n-                contentCache = sb.toString();\n-                // System.err.println(\"Materialized string: \" + contentCache);\n-            }\n-            return contentCache;\n-        }\n-    }\n-\n-    public static class Phoneme implements PhonemeExpr, Comparable<Phoneme> {\n+    public static final class Phoneme implements PhonemeExpr, Comparable<Phoneme> {\n \n         private final CharSequence phonemeText;\n         private final Languages.LanguageSet languages;\n         }\n \n         public Phoneme append(CharSequence str) {\n-            return new Phoneme(new AppendableCharSeqeuence(this.phonemeText, str), this.languages);\n+            return new Phoneme(this.phonemeText.toString() + str.toString(), this.languages);\n         }\n \n         public int compareTo(Phoneme o) {\n         }\n \n         public Phoneme join(Phoneme right) {\n-            return new Phoneme(new AppendableCharSeqeuence(this.phonemeText, right.phonemeText), this.languages.restrictTo(right.languages));\n+            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(), this.languages.restrictTo(right.languages));\n         }\n     }\n \n         Iterable<Phoneme> getPhonemes();\n     }\n \n-    public static class PhonemeList implements PhonemeExpr {\n+    public static final class PhonemeList implements PhonemeExpr {\n         private final List<Phoneme> phonemes;\n \n         public PhonemeList(List<Phoneme> phonemes) {\n     }\n \n     /**\n-     * A minimal wrapper around the functionality of Matcher that we use, to allow for alternate implementations.\n-     */\n-    public static interface RMatcher {\n-        boolean find();\n-    }\n-\n-    /**\n-     * Always returns true.\n-     */\n-    private static class TrueRMatcher implements RMatcher {\n-\n-        private static TrueRMatcher INSTANCE = new TrueRMatcher();\n-\n-        /**\n-         * Always returns true.\n-         */\n-        public boolean find() {\n+     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\n+     */\n+    public static interface RPattern {\n+        boolean isMatch(CharSequence input);\n+    }\n+\n+    public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {\n+        public boolean isMatch(CharSequence input) {\n             return true;\n         }\n-\n-    }\n-\n-    private static class AllStringsRMatcher implements RPattern {\n-\n-        private static AllStringsRMatcher INSTANCE = new AllStringsRMatcher();\n-\n-        public RMatcher matcher(CharSequence input) {\n-            return TrueRMatcher.INSTANCE;\n-        }\n-\n-    }\n-\n-    /**\n-     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\n-     */\n-    public static interface RPattern {\n-        RMatcher matcher(CharSequence input);\n-    }\n+    };\n \n     public static final String ALL = \"ALL\";\n \n                 if (content.length() == 0) {\n                     // empty\n                     return new RPattern() {\n-                        public RMatcher matcher(final CharSequence input) {\n-                            return new RMatcher() {\n-                                public boolean find() {\n-                                    return input.length() == 0;\n-                                }\n-                            };\n+                        public boolean isMatch(CharSequence input) {\n+                            return input.length() == 0;\n                         }\n                     };\n                 } else {\n                     return new RPattern() {\n-                        public RMatcher matcher(final CharSequence input) {\n-                            return new RMatcher() {\n-                                public boolean find() {\n-                                    return input.equals(content);\n-                                }\n-                            };\n+                        public boolean isMatch(CharSequence input) {\n+                            return input.equals(content);\n                         }\n                     };\n                 }\n             } else if ((startsWith || endsWith) && content.length() == 0) {\n                 // matches every string\n-                return AllStringsRMatcher.INSTANCE;\n+                return ALL_STRINGS_RMATCHER;\n             } else if (startsWith) {\n                 // matches from start\n                 return new RPattern() {\n-                    public RMatcher matcher(final CharSequence input) {\n-                        return new RMatcher() {\n-                            public boolean find() {\n-                                return startsWith(input, content);\n-                            }\n-                        };\n+                    public boolean isMatch(CharSequence input) {\n+                        return startsWith(input, content);\n                     }\n                 };\n             } else if (endsWith) {\n                 // matches from start\n                 return new RPattern() {\n-                    public RMatcher matcher(final CharSequence input) {\n-                        return new RMatcher() {\n-                            public boolean find() {\n-                                return endsWith(input, content);\n-                            }\n-                        };\n+                    public boolean isMatch(CharSequence input) {\n+                        return endsWith(input, content);\n                     }\n                 };\n             }\n                     if (startsWith && endsWith) {\n                         // exact match\n                         return new RPattern() {\n-                            public RMatcher matcher(final CharSequence input) {\n-                                return new RMatcher() {\n-                                    public boolean find() {\n-                                        return input.length() == 1 && (contains(bContent, input.charAt(0)) == shouldMatch);\n-                                    }\n-                                };\n+                            public boolean isMatch(CharSequence input) {\n+                                return input.length() == 1 && (contains(bContent, input.charAt(0)) == shouldMatch);\n                             }\n                         };\n                     } else if (startsWith) {\n                         // first char\n                         return new RPattern() {\n-                            public RMatcher matcher(final CharSequence input) {\n-                                return new RMatcher() {\n-                                    public boolean find() {\n-                                        return input.length() > 0 && (contains(bContent, input.charAt(0)) == shouldMatch);\n-                                    }\n-                                };\n+                            public boolean isMatch(CharSequence input) {\n+                                return input.length() > 0 && (contains(bContent, input.charAt(0)) == shouldMatch);\n                             }\n                         };\n                     } else if (endsWith) {\n                         // last char\n                         return new RPattern() {\n-                            public RMatcher matcher(final CharSequence input) {\n-                                return new RMatcher() {\n-                                    public boolean find() {\n-                                        return input.length() > 0 && (contains(bContent, input.charAt(input.length() - 1)) == shouldMatch);\n-                                    }\n-                                };\n+                            public boolean isMatch(CharSequence input) {\n+                                return input.length() > 0 && (contains(bContent, input.charAt(input.length() - 1)) == shouldMatch);\n                             }\n                         };\n                     }\n         return new RPattern() {\n             Pattern pattern = Pattern.compile(regex);\n \n-            public RMatcher matcher(CharSequence input) {\n-                final Matcher matcher = pattern.matcher(input);\n-                return new RMatcher() {\n-                    public boolean find() {\n-                        return matcher.find();\n-                    }\n-                };\n+            public boolean isMatch(CharSequence input) {\n+                Matcher matcher = pattern.matcher(input);\n+                return matcher.find();\n             }\n         };\n     }\n         }\n \n         boolean patternMatches = input.subSequence(i, ipl).equals(this.pattern);\n-        boolean rContextMatches = this.rContext.matcher(input.subSequence(ipl, input.length())).find();\n-        boolean lContextMatches = this.lContext.matcher(input.subSequence(0, i)).find();\n+        boolean rContextMatches = this.rContext.isMatch(input.subSequence(ipl, input.length()));\n+        boolean lContextMatches = this.lContext.isMatch(input.subSequence(0, i));\n \n         return patternMatches && rContextMatches && lContextMatches;\n     }\n--- a/src/test/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n+++ b/src/test/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n \n import static org.junit.Assert.assertEquals;\n \n-import java.util.Random;\n-\n import org.apache.commons.codec.EncoderException;\n import org.apache.commons.codec.StringEncoder;\n import org.apache.commons.codec.StringEncoderAbstractTest;\n     }\n \n     /**\n-     * (Un)luckily, the worse performing test because of the data in {@link TEST_CHARS}\n+     * (Un)luckily, the worse performing test because of the data in {@link #TEST_CHARS}\n      * \n      * @throws EncoderException\n      */\n         }\n     }\n \n-    /**\n-     * Another odd performance edge case.\n-     * \n-     * @throws EncoderException\n-     */\n-    @Test(/* timeout = 20000L */)\n-    public void testSpeedCheckAZ() throws EncoderException {\n+    @Test\n+    public void testSpeedCheck2() throws EncoderException {\n+        BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n+        String phrase = \"ItstheendoftheworldasweknowitandIfeelfine\";\n+\n+        for (int i = 1; i <= phrase.length(); i++) {\n+            bmpm.encode(phrase.subSequence(0, i));\n+        }\n+    }\n+\n+    @Test\n+    public void testSpeedCheck3() throws EncoderException {\n         BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n         String phrase = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\";\n+\n         for (int i = 1; i <= phrase.length(); i++) {\n             bmpm.encode(phrase.subSequence(0, i));\n         }\n     }\n-\n-    /**\n-     * Runs between 1.6 and 13 seconds at length 40 for me (Gary Gregory, 2011/08/06)\n-     * \n-     * @throws EncoderException\n-     */\n-    @Test(/* timeout = 20000L */)\n-    public void testSpeedCheckRandom() throws EncoderException {\n-        BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n-        StringBuffer stringBuffer = new StringBuffer();\n-        Random rand = new Random();\n-        stringBuffer.append(TEST_CHARS[rand.nextInt(TEST_CHARS.length)]);\n-        for (int i = 0; i < 40; i++) {\n-            bmpm.encode(stringBuffer.toString());\n-            stringBuffer.append(TEST_CHARS[rand.nextInt(TEST_CHARS.length)]);\n-        }\n-    }\n }\n--- a/src/test/org/apache/commons/codec/language/bm/RuleTest.java\n+++ b/src/test/org/apache/commons/codec/language/bm/RuleTest.java\n             }\n         }\n     }\n+\n+    @Test\n+    public void subSequenceWorks() {\n+        // AppendableCharSequence is private to Rule. We can only make it through a Phoneme.\n+\n+        Rule.Phoneme a = new Rule.Phoneme(\"a\", null);\n+        Rule.Phoneme b = new Rule.Phoneme(\"b\", null);\n+        Rule.Phoneme cd = new Rule.Phoneme(\"cd\", null);\n+        Rule.Phoneme ef = new Rule.Phoneme(\"ef\", null);\n+        Rule.Phoneme ghi = new Rule.Phoneme(\"ghi\", null);\n+        Rule.Phoneme jkl = new Rule.Phoneme(\"jkl\", null);\n+\n+        assertEquals('a', a.getPhonemeText().charAt(0));\n+        assertEquals('b', b.getPhonemeText().charAt(0));\n+        assertEquals('c', cd.getPhonemeText().charAt(0));\n+        assertEquals('d', cd.getPhonemeText().charAt(1));\n+        assertEquals('e', ef.getPhonemeText().charAt(0));\n+        assertEquals('f', ef.getPhonemeText().charAt(1));\n+        assertEquals('g', ghi.getPhonemeText().charAt(0));\n+        assertEquals('h', ghi.getPhonemeText().charAt(1));\n+        assertEquals('i', ghi.getPhonemeText().charAt(2));\n+        assertEquals('j', jkl.getPhonemeText().charAt(0));\n+        assertEquals('k', jkl.getPhonemeText().charAt(1));\n+        assertEquals('l', jkl.getPhonemeText().charAt(2));\n+\n+        Rule.Phoneme a_b = a.append(b.getPhonemeText());\n+        assertEquals('a', a_b.getPhonemeText().charAt(0));\n+        assertEquals('b', a_b.getPhonemeText().charAt(1));\n+        assertEquals(\"ab\", a_b.getPhonemeText().subSequence(0, 2).toString());\n+        assertEquals(\"a\", a_b.getPhonemeText().subSequence(0, 1).toString());\n+        assertEquals(\"b\", a_b.getPhonemeText().subSequence(1, 2).toString());\n+\n+        Rule.Phoneme cd_ef = cd.append(ef.getPhonemeText());\n+        assertEquals('c', cd_ef.getPhonemeText().charAt(0));\n+        assertEquals('d', cd_ef.getPhonemeText().charAt(1));\n+        assertEquals('e', cd_ef.getPhonemeText().charAt(2));\n+        assertEquals('f', cd_ef.getPhonemeText().charAt(3));\n+        assertEquals(\"c\", cd_ef.getPhonemeText().subSequence(0, 1).toString());\n+        assertEquals(\"d\", cd_ef.getPhonemeText().subSequence(1, 2).toString());\n+        assertEquals(\"e\", cd_ef.getPhonemeText().subSequence(2, 3).toString());\n+        assertEquals(\"f\", cd_ef.getPhonemeText().subSequence(3, 4).toString());\n+        assertEquals(\"cd\", cd_ef.getPhonemeText().subSequence(0, 2).toString());\n+        assertEquals(\"de\", cd_ef.getPhonemeText().subSequence(1, 3).toString());\n+        assertEquals(\"ef\", cd_ef.getPhonemeText().subSequence(2, 4).toString());\n+        assertEquals(\"cde\", cd_ef.getPhonemeText().subSequence(0, 3).toString());\n+        assertEquals(\"def\", cd_ef.getPhonemeText().subSequence(1, 4).toString());\n+        assertEquals(\"cdef\", cd_ef.getPhonemeText().subSequence(0, 4).toString());\n+\n+        Rule.Phoneme a_b_cd = a.append(b.getPhonemeText()).append(cd.getPhonemeText());\n+        assertEquals('a', a_b_cd.getPhonemeText().charAt(0));\n+        assertEquals('b', a_b_cd.getPhonemeText().charAt(1));\n+        assertEquals('c', a_b_cd.getPhonemeText().charAt(2));\n+        assertEquals('d', a_b_cd.getPhonemeText().charAt(3));\n+        assertEquals(\"a\", a_b_cd.getPhonemeText().subSequence(0, 1).toString());\n+        assertEquals(\"b\", a_b_cd.getPhonemeText().subSequence(1, 2).toString());\n+        assertEquals(\"c\", a_b_cd.getPhonemeText().subSequence(2, 3).toString());\n+        assertEquals(\"d\", a_b_cd.getPhonemeText().subSequence(3, 4).toString());\n+        assertEquals(\"ab\", a_b_cd.getPhonemeText().subSequence(0, 2).toString());\n+        assertEquals(\"bc\", a_b_cd.getPhonemeText().subSequence(1, 3).toString());\n+        assertEquals(\"cd\", a_b_cd.getPhonemeText().subSequence(2, 4).toString());\n+        assertEquals(\"abc\", a_b_cd.getPhonemeText().subSequence(0, 3).toString());\n+        assertEquals(\"bcd\", a_b_cd.getPhonemeText().subSequence(1, 4).toString());\n+        assertEquals(\"abcd\", a_b_cd.getPhonemeText().subSequence(0, 4).toString());\n+    }\n }", "timestamp": 1312843644, "metainfo": ""}