{"sha": "ad12e19e614e92f824746c199ebfc31228a8c33c", "log": "CODEC-88 Initial implementation of Base32 codec. Derived from Base64 code. Not complete: intend to add base64 hex version, and the API may not be final Test cases to follow  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/binary/Base32.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import org.apache.commons.codec.BinaryDecoder;\n+import org.apache.commons.codec.BinaryEncoder;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+\n+/**\n+ * Provides Base32 encoding and decoding as defined by RFC 4648.\n+ * \n+ *                               <b>Initial implementation. API may change. Incomplete.</b>\n+ *  \n+ * <p>\n+ * The class can be parameterized in the following manner with various constructors:\n+ * <ul>\n+ * <li>Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of\n+ * 8 in the encoded data.\n+ * \n+ * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * </p>\n+ * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n+ * \n+ * @since 1.5\n+ * @version $Revision$\n+ */\n+public class Base32 implements BinaryEncoder, BinaryDecoder {\n+\n+    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 8192;\n+\n+    /**\n+     * BASE32 characters are 5 bits in length. \n+     * They are formed by taking a block of five octets to form a 40-bit string, \n+     * which is converted into eight BASE32 characters.\n+     */\n+    private static final int BITS_PER_ENCODED_CHAR = 5;\n+    private static final int BYTES_PER_UNENCODED_BLOCK = 5;\n+    private static final int BYTES_PER_ENCODED_BLOCK = 8;\n+\n+\n+    /**\n+     *  MIME chunk size per RFC 2045 section 6.8.\n+     * \n+     * <p>\n+     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n+     * equal signs.\n+     * </p>\n+     * \n+     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n+     */\n+    public static final int MIME_CHUNK_SIZE = 76;\n+\n+    /**\n+     * PEM chunk size per RFC 1421 section 4.3.2.4.\n+     * \n+     * <p>\n+     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n+     * equal signs.\n+     * </p>\n+     * \n+     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n+     */\n+    public static final int PEM_CHUNK_SIZE = 64;\n+\n+    /**\n+     * Chunk separator per RFC 2045 section 2.1.\n+     *\n+     * <p>\n+     * N.B. The next major release may break compatibility and make this field private.\n+     * </p>\n+     * \n+     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n+     */\n+    private static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n+\n+    /**\n+     * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Alphabet\"\n+     * equivalents as specified in Table 3 of RFC 2045.\n+     */\n+    private static final byte[] STANDARD_ENCODE_TABLE = {\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            '2', '3', '4', '5', '6', '7',\n+    };\n+\n+    /**\n+     * Byte used to pad output.\n+     */\n+    private static final byte PAD = '=';\n+\n+    /**\n+     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 Alphabet\" (as specified in\n+     * Table 3 of RFC 2045) into their 5-bit positive integer equivalents. Characters that are not in the Base32\n+     * alphabet but fall within the bounds of the array are translated to -1.\n+     * \n+     */\n+    private static final byte[] DECODE_TABLE = {\n+         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 63, // 20-2f\n+            -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n+            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 40-4f A-N\n+            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,                     // 50-5a O-Z\n+    };\n+\n+    /** Mask used to extract 5 bits, used when encoding Base32 bytes */\n+    private static final int MASK_5BITS = 0x1f;\n+\n+    /** Mask used to extract 8 bits, used in decoding Base32 bytes */\n+    private static final int MASK_8BITS = 0xff;\n+\n+    // The static final fields above are used for the original static byte[] methods on Base32.\n+    // The private member fields below are used with the new streaming approach, which requires\n+    // some state be preserved between calls of encode() and decode().\n+\n+    /**\n+     * Encode table to use.\n+     */\n+    private final byte[] encodeTable;\n+\n+    /**\n+     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the Base32\n+     * encoded data.\n+     */\n+    private final int lineLength;\n+\n+    /**\n+     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n+     */\n+    private final byte[] lineSeparator;\n+\n+    /**\n+     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n+     * <code>decodeSize = 3 + lineSeparator.length;</code>\n+     * TODO 3?\n+     */\n+    private final int decodeSize;\n+\n+    /**\n+     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n+     * <code>encodeSize = 4 + lineSeparator.length;</code>\n+     * TODO 4? is that BYTES_PER_ENCODED_BLOCK? - probably yes\n+     */\n+    private final int encodeSize;\n+\n+    /**\n+     * Buffer for streaming.\n+     */\n+    private byte[] buffer;\n+\n+    /**\n+     * Position where next character should be written in the buffer.\n+     */\n+    private int pos;\n+\n+    /**\n+     * Position where next character should be read from the buffer.\n+     */\n+    private int readPos;\n+\n+    /**\n+     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n+     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n+     */\n+    private int currentLinePos;\n+\n+    /**\n+     * Writes to the buffer only occur after every 5 reads when encoding, and every 8 reads when decoding. This variable\n+     * helps track that.\n+     */\n+    private int modulus;\n+\n+    /**\n+     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base32 object becomes useless,\n+     * and must be thrown away.\n+     */\n+    private boolean eof;\n+\n+    /**\n+     * Place holder for the 8 bytes we're dealing with for our Base32 logic. Bitwise operations store and extract the\n+     * Base32 encoding or decoding from this variable.\n+     */\n+    private long x; // 64 bits; enough for 40 bits i.e. 5 octets unencoded\n+\n+    /**\n+     * Creates a Base32 codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length is 0 (no chunking).\n+     * </p>\n+     * \n+     */\n+    public Base32() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Creates a Base32 codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length is given in the constructor, the line separator is CRLF.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 8).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     */\n+    public Base32(int lineLength) {\n+        this(lineLength, CHUNK_SEPARATOR);\n+    }\n+\n+    /**\n+     * Creates a Base32 codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length and line separator are given in the constructor.\n+     * </p>\n+     * <p>\n+     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 8).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     * @param lineSeparator\n+     *            Each line of encoded data will end with this sequence of bytes.\n+     * @throws IllegalArgumentException\n+     *             The provided lineSeparator included some Base32 characters. That's not going to work!\n+     */\n+    public Base32(int lineLength, byte[] lineSeparator) {\n+        if (lineSeparator == null) {\n+            lineLength = 0;  // disable chunk-separating\n+            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n+        }\n+        this.lineLength = lineLength > 0 ? (lineLength / BYTES_PER_ENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK : 0;\n+        this.lineSeparator = new byte[lineSeparator.length];\n+        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n+        if (lineLength > 0) {\n+            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n+        } else {\n+            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n+        }\n+        this.decodeSize = this.encodeSize - 1;\n+        if (containsBase32Byte(lineSeparator)) {\n+            String sep = StringUtils.newStringUtf8(lineSeparator);\n+            throw new IllegalArgumentException(\"lineSeperator must not contain Base32 characters: [\" + sep + \"]\");\n+        }\n+        this.encodeTable = STANDARD_ENCODE_TABLE; // TODO - encodeTable could perhaps be removed, but might be useful if merging with Base64\n+    }\n+\n+    /**\n+     * Returns true if this Base32 object has buffered data for reading.\n+     * \n+     * @return true if there is Base32 object still available for reading.\n+     */\n+    boolean hasData() {\n+        return this.buffer != null;\n+    }\n+\n+    /**\n+     * Returns the amount of buffered data available for reading.\n+     * \n+     * @return The amount of buffered data available for reading.\n+     */\n+    int avail() {\n+        return buffer != null ? pos - readPos : 0;\n+    }\n+\n+    /** Doubles our buffer. */\n+    private void resizeBuffer() {\n+        if (buffer == null) {\n+            buffer = new byte[DEFAULT_BUFFER_SIZE];\n+            pos = 0;\n+            readPos = 0;\n+        } else {\n+            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n+            System.arraycopy(buffer, 0, b, 0, buffer.length);\n+            buffer = b;\n+        }\n+    }\n+\n+    /**\n+     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n+     * bytes. Returns how many bytes were actually extracted.\n+     * \n+     * @param b\n+     *            byte[] array to extract the buffered data into.\n+     * @param bPos\n+     *            position in byte[] array to start extraction at.\n+     * @param bAvail\n+     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n+     * @return The number of bytes successfully extracted into the provided byte[] array.\n+     */\n+    int readResults(byte[] b, int bPos, int bAvail) {\n+        if (buffer != null) {\n+            int len = Math.min(avail(), bAvail);\n+            System.arraycopy(buffer, readPos, b, bPos, len);\n+            readPos += len;\n+            if (readPos >= pos) {\n+                buffer = null;\n+            }\n+            return len;\n+        }\n+        return eof ? -1 : 0;\n+    }\n+\n+    /**\n+     * <p>\n+     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n+     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n+     * remaining bytes (if not multiple of 5).\n+     * </p>\n+     * \n+     * @param in\n+     *            byte[] array of binary data to Base32 encode.\n+     * @param inPos\n+     *            Position to start reading data from.\n+     * @param inAvail\n+     *            Amount of bytes available from input for encoding.\n+     */\n+    void encode(byte[] in, int inPos, int inAvail) {\n+        if (eof) {\n+            return;\n+        }\n+        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n+        // encoding.\n+        if (inAvail < 0) {\n+            eof = true;\n+            if (buffer == null || buffer.length - pos < encodeSize) {\n+                resizeBuffer();\n+            }\n+            switch (modulus) { // % 5\n+                case 1 : // Only 1 octet; take top 5 bits then remainder\n+                    buffer[pos++] = encodeTable[(int)(x >> 3) & MASK_5BITS]; // 8-1*5 = 3\n+                    buffer[pos++] = encodeTable[(int)(x << 2) & MASK_5BITS]; // 5-3=2\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    break;\n+\n+                case 2 : // 2 octets = 16 bits to use\n+                    buffer[pos++] = encodeTable[(int)(x >> 11) & MASK_5BITS]; // 16-1*5 = 11\n+                    buffer[pos++] = encodeTable[(int)(x >>  6) & MASK_5BITS]; // 16-2*5 = 6\n+                    buffer[pos++] = encodeTable[(int)(x >>  1) & MASK_5BITS]; // 16-3*5 = 1\n+                    buffer[pos++] = encodeTable[(int)(x <<  4) & MASK_5BITS]; // 5-1 = 4\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    break;\n+                case 3 : // 3 octets = 24 bits to use\n+                    buffer[pos++] = encodeTable[(int)(x >> 19) & MASK_5BITS]; // 24-1*5 = 19\n+                    buffer[pos++] = encodeTable[(int)(x >> 14) & MASK_5BITS]; // 24-2*5 = 14\n+                    buffer[pos++] = encodeTable[(int)(x >>  9) & MASK_5BITS]; // 24-3*5 = 9\n+                    buffer[pos++] = encodeTable[(int)(x >>  4) & MASK_5BITS]; // 24-4*5 = 4\n+                    buffer[pos++] = encodeTable[(int)(x <<  1) & MASK_5BITS]; // 5-4 = 1\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    break;\n+                case 4 : // 4 octets = 32 bits to use\n+                    buffer[pos++] = encodeTable[(int)(x >> 27) & MASK_5BITS]; // 32-1*5 = 27\n+                    buffer[pos++] = encodeTable[(int)(x >> 22) & MASK_5BITS]; // 32-2*5 = 22\n+                    buffer[pos++] = encodeTable[(int)(x >> 17) & MASK_5BITS]; // 32-3*5 = 17\n+                    buffer[pos++] = encodeTable[(int)(x >> 12) & MASK_5BITS]; // 32-4*5 = 12\n+                    buffer[pos++] = encodeTable[(int)(x >>  7) & MASK_5BITS]; // 32-5*5 =  7\n+                    buffer[pos++] = encodeTable[(int)(x >>  2) & MASK_5BITS]; // 32-6*5 =  2\n+                    buffer[pos++] = encodeTable[(int)(x <<  3) & MASK_5BITS]; // 5-2 = 3\n+                    buffer[pos++] = PAD;\n+                    break;\n+            }\n+            // Don't want to append the CRLF two times in a row, so make sure previous\n+            // character is not from CRLF!\n+            byte b = lineSeparator[lineSeparator.length - 1];\n+            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n+                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n+                pos += lineSeparator.length;\n+            }\n+        } else {\n+            for (int i = 0; i < inAvail; i++) {\n+                if (buffer == null || buffer.length - pos < encodeSize) {\n+                    resizeBuffer();\n+                }\n+                modulus = (++modulus) % BITS_PER_ENCODED_CHAR;\n+                int b = in[inPos++];\n+                if (b < 0) {\n+                    b += 256;\n+                }\n+                x = (x << 8) + b; // ??\n+                if (0 == modulus) { // we have enough bytes to create our output \n+                    buffer[pos++] = encodeTable[(int)(x >> 35) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(x >> 30) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(x >> 25) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(x >> 20) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(x >> 15) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(x >> 10) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(x >> 5) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)x & MASK_5BITS];\n+                    currentLinePos += BYTES_PER_ENCODED_BLOCK;\n+                    if (lineLength > 0 && lineLength <= currentLinePos) {\n+                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n+                        pos += lineSeparator.length;\n+                        currentLinePos = 0;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n+     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n+     * call is not necessary when decoding, but it doesn't hurt, either.\n+     * </p>\n+     * <p>\n+     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n+     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n+     * garbage-out philosophy: it will not check the provided data for validity.\n+     * </p>\n+     * \n+     * @param in\n+     *            byte[] array of ascii data to Base32 decode.\n+     * @param inPos\n+     *            Position to start reading data from.\n+     * @param inAvail\n+     *            Amount of bytes available from input for encoding.\n+     *\n+     * Output is written to {@link #buffer} as 8-bit octets, using {@link pos} as the buffer position\n+     */\n+    void decode(byte[] in, int inPos, int inAvail) { // package protected for access from I/O streams\n+        if (eof) {\n+            return;\n+        }\n+        if (inAvail < 0) {\n+            eof = true;\n+        }\n+        for (int i = 0; i < inAvail; i++) {\n+            if (buffer == null || buffer.length - pos < decodeSize) {\n+                resizeBuffer();\n+            }\n+            byte b = in[inPos++];\n+            if (b == PAD) {\n+                // We're done.\n+                eof = true;\n+                break;\n+            } else {\n+                if (b >= 0 && b < DECODE_TABLE.length) {\n+                    int result = DECODE_TABLE[b];\n+                    if (result >= 0) {\n+                        modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK;\n+                        x = (x << BITS_PER_ENCODED_CHAR) + result; // collect decoded bytes\n+                        if (modulus == 0) { // we can output the 5 bytes\n+                            buffer[pos++] = (byte) ((x >> 32) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((x >> 24) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n+                            buffer[pos++] = (byte) (x & MASK_8BITS);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Two forms of EOF as far as Base32 decoder is concerned: actual\n+        // EOF (-1) and first time '=' character is encountered in stream.\n+        // This approach makes the '=' padding characters completely optional.\n+        if (eof && modulus != 0) {\n+            if (buffer == null || buffer.length - pos < decodeSize) {\n+                resizeBuffer();\n+            }\n+\n+            //  we ignore partial bytes, i.e. only multiples of 8 count\n+            switch (modulus) {\n+                case 2 : // 10 bits, drop 2 and output one byte\n+                    buffer[pos++] = (byte) ((x >> 2) & MASK_8BITS);\n+                    break;\n+                case 3 : // 15 bits, drop 7 and output 1 byte\n+                    buffer[pos++] = (byte) ((x >> 7) & MASK_8BITS);\n+                    break;\n+                case 4 : // 20 bits = 2*8 + 4\n+                    x = x >> 4; // drop 4 bits\n+                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n+                    break;\n+                case 5 : // 25bits = 3*8 + 1\n+                    x = x >> 1;\n+                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n+                    break;\n+                case 6 : // 30bits = 3*8 + 6\n+                    x = x >> 6;\n+                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n+                    break;\n+                case 7 : // 35 = 4*8 +3\n+                    x = x >> 3;\n+                    buffer[pos++] = (byte) ((x >> 24) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns whether or not the <code>octet</code> is in the Base32 alphabet.\n+     * \n+     * @param octet\n+     *            The value to test\n+     * @return <code>true</code> if the value is defined in the the Base32 alphabet (or pad), <code>false</code> otherwise.\n+     */\n+    public static boolean isBase32(byte octet) {\n+        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n+    }\n+\n+    /**\n+     * Tests a given String to see if it contains only valid characters within the Base32 alphabet. Currently the\n+     * method treats whitespace as valid.\n+     * \n+     * @param base32\n+     *            String to test\n+     * @return <code>true</code> if all characters in the String are valid characters in the Base32 alphabet or if\n+     *         the String is empty; <code>false</code>, otherwise\n+     */\n+    public static boolean isBase32(String base32) {\n+        return isBase32(StringUtils.getBytesUtf8(base32));\n+    }\n+\n+    /**\n+     * Tests a given byte array to see if it contains only valid characters within the Base32 alphabet. Currently the\n+     * method treats whitespace as valid.\n+     * \n+     * @param arrayOctet\n+     *            byte array to test\n+     * @return <code>true</code> if all bytes are valid characters in the Base32 alphabet or if the byte array is empty;\n+     *         <code>false</code>, otherwise\n+     */    \n+    public static boolean isBase32(byte[] arrayOctet) {\n+        for (int i = 0; i < arrayOctet.length; i++) {\n+            if (!isBase32(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Tests a given byte array to see if it contains only valid characters within the Base32 alphabet.\n+     * Does not allow white-space.\n+     * \n+     * @param arrayOctet\n+     *            byte array to test\n+     * @return <code>true</code> if any byte is a valid character in the Base32 alphabet; <code>false</code> otherwise\n+     */\n+    private static boolean containsBase32Byte(byte[] arrayOctet) {\n+        for (int i = 0; i < arrayOctet.length; i++) {\n+            if (isBase32(arrayOctet[i])) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Encodes binary data using the Base32 algorithm but does not chunk the output.\n+     * \n+     * @param binaryData\n+     *            binary data to encode\n+     * @return byte[] containing Base32 characters in their UTF-8 representation.\n+     */\n+    public static byte[] encodeBase32(byte[] binaryData) {\n+        return encodeBase32(binaryData, false);\n+    }\n+\n+    /**\n+     * Encodes binary data using the Base32 algorithm but does not chunk the output.\n+     *\n+     * @param binaryData\n+     *            binary data to encode\n+     * @return String containing Base32 characters.\n+     */    \n+    public static String encodeBase32String(byte[] binaryData) {\n+        return StringUtils.newStringUtf8(encodeBase32(binaryData, false));\n+    }\n+    \n+    /**\n+     * Encodes binary data using the Base32 algorithm and chunks the encoded output into 76 character blocks\n+     * \n+     * @param binaryData\n+     *            binary data to encode\n+     * @return Base32 characters chunked in 76 character blocks\n+     */\n+    public static byte[] encodeBase32Chunked(byte[] binaryData) {\n+        return encodeBase32(binaryData, true);\n+    }\n+\n+    /**\n+     * Decodes an Object using the Base32 algorithm. This method is provided in order to satisfy the requirements of the\n+     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n+     * \n+     * @param pObject\n+     *            Object to decode\n+     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n+     * @throws DecoderException\n+     *             if the parameter supplied is not of type byte[]\n+     */\n+    public Object decode(Object pObject) throws DecoderException {        \n+        if (pObject instanceof byte[]) {\n+            return decode((byte[]) pObject);\n+        } else if (pObject instanceof String) {\n+            return decode((String) pObject);\n+        } else {\n+            throw new DecoderException(\"Parameter supplied to Base32 decode is not a byte[] or a String\");\n+        }\n+    }\n+\n+    /**\n+     * Decodes a String containing characters in the Base32 alphabet.\n+     *\n+     * @param pArray\n+     *            A String containing Base32 character data\n+     * @return a byte array containing binary data\n+     * @since 1.4\n+     */\n+    public byte[] decode(String pArray) {\n+        return decode(StringUtils.getBytesUtf8(pArray));\n+    }\n+\n+    /**\n+     * Decodes a byte[] containing characters in the Base32 alphabet.\n+     * \n+     * @param pArray\n+     *            A byte array containing Base32 character data\n+     * @return a byte array containing binary data\n+     */\n+    public byte[] decode(byte[] pArray) {\n+        reset();\n+        if (pArray == null || pArray.length == 0) {\n+            return pArray;\n+        }\n+        decode(pArray, 0, pArray.length);\n+        decode(pArray, 0, -1); // Notify decoder of EOF.\n+        byte[] result = new byte[pos];\n+        readResults(result, 0, result.length);\n+        return result;\n+    }\n+\n+    /**\n+     * Encodes binary data using the Base32 algorithm, optionally chunking the output into 76 character blocks.\n+     * \n+     * @param binaryData\n+     *            Array containing binary data to encode.\n+     * @param isChunked\n+     *            if <code>true</code> this encoder will chunk the Base32 output into 76 character blocks\n+     * @return Base32-encoded data.\n+     * @throws IllegalArgumentException\n+     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n+     */\n+    public static byte[] encodeBase32(byte[] binaryData, boolean isChunked) {\n+        return encodeBase32(binaryData, isChunked, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Encodes binary data using the Base32 algorithm, optionally chunking the output into 76 character blocks.\n+     * \n+     * @param binaryData\n+     *            Array containing binary data to encode.\n+     * @param isChunked\n+     *            if <code>true</code> this encoder will chunk the Base32 output into 76 character blocks\n+     * @param maxResultSize\n+     *            The maximum result size to accept.\n+     * @return Base32-encoded data.\n+     * @throws IllegalArgumentException\n+     *             Thrown when the input array needs an output array bigger than maxResultSize\n+     * @since 1.4\n+     */\n+    public static byte[] encodeBase32(byte[] binaryData, boolean isChunked, int maxResultSize) {\n+        if (binaryData == null || binaryData.length == 0) {\n+            return binaryData;\n+        }\n+\n+        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+        if (len > maxResultSize) {\n+            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n+                len +\n+                \") than the specified maxium size of \" +\n+                maxResultSize);\n+        }\n+                \n+        Base32 b64 = isChunked ? new Base32(MIME_CHUNK_SIZE, CHUNK_SEPARATOR) : new Base32(0, CHUNK_SEPARATOR);\n+        return b64.encode(binaryData);\n+    }\n+\n+    /**\n+     * Decodes a Base32 String into octets\n+     *\n+     * @param base32String\n+     *            String containing Base32 data\n+     * @return Array containing decoded data.\n+     */\n+    public static byte[] decodeBase32(String base32String) {\n+        return new Base32().decode(base32String);\n+    }\n+\n+    /**\n+     * Decodes Base32 data into octets\n+     * \n+     * @param base32Data\n+     *            Byte array containing Base32 data\n+     * @return Array containing decoded data.\n+     */\n+    public static byte[] decodeBase32(byte[] base32Data) {\n+        return new Base32().decode(base32Data);\n+    }\n+\n+    /**\n+     * Checks if a byte value is whitespace or not.\n+     * \n+     * @param byteToCheck\n+     *            the byte to check\n+     * @return true if byte is whitespace, false otherwise\n+     */\n+    private static boolean isWhiteSpace(byte byteToCheck) {\n+        switch (byteToCheck) {\n+            case ' ' :\n+            case '\\n' :\n+            case '\\r' :\n+            case '\\t' :\n+                return true;\n+            default :\n+                return false;\n+        }\n+    }\n+\n+    // Implementation of the Encoder Interface\n+\n+    /**\n+     * Encodes an Object using the Base32 algorithm. This method is provided in order to satisfy the requirements of the\n+     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n+     * \n+     * @param pObject\n+     *            Object to encode\n+     * @return An object (of type byte[]) containing the Base32 encoded data which corresponds to the byte[] supplied.\n+     * @throws EncoderException\n+     *             if the parameter supplied is not of type byte[]\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (!(pObject instanceof byte[])) {\n+            throw new EncoderException(\"Parameter supplied to Base32 encode is not a byte[]\");\n+        }\n+        return encode((byte[]) pObject);\n+    }\n+\n+    /**\n+     * Encodes a byte[] containing binary data, into a String containing characters in the Base32 alphabet.\n+     *\n+     * @param pArray\n+     *            a byte array containing binary data\n+     * @return A String containing only Base32 character data\n+     */    \n+    public String encodeToString(byte[] pArray) {\n+        return StringUtils.newStringUtf8(encode(pArray));\n+    }\n+\n+    /**\n+     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base32 alphabet.\n+     * \n+     * @param pArray\n+     *            a byte array containing binary data\n+     * @return A byte array containing only Base32 character data\n+     */\n+    public byte[] encode(byte[] pArray) {\n+        reset();        \n+        if (pArray == null || pArray.length == 0) {\n+            return pArray;\n+        }\n+        encode(pArray, 0, pArray.length);\n+        encode(pArray, 0, -1); // Notify encoder of EOF.\n+        byte[] buf = new byte[pos - readPos];\n+        readResults(buf, 0, buf.length);\n+        return buf;\n+    }\n+\n+    /**\n+     * Pre-calculates the amount of space needed to Base32-encode the supplied array.\n+     *\n+     * @param pArray byte[] array which will later be encoded\n+     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n+     *        chunkSeparator (e.g. CRLF).\n+     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n+     *\n+     * @return amount of space needed to encoded the supplied array.  Returns\n+     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n+     */\n+    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n+        // Base32 always encodes to multiples of 8 (BYTES_PER_ENCODED_CHUNK).\n+        chunkSize = (chunkSize / BYTES_PER_ENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK;\n+\n+        long len = (pArray.length * BYTES_PER_ENCODED_BLOCK) / BYTES_PER_UNENCODED_BLOCK;\n+        long mod = len % BYTES_PER_ENCODED_BLOCK;\n+        if (mod != 0) {\n+            len += BYTES_PER_ENCODED_BLOCK - mod;\n+        }\n+        if (chunkSize > 0) {\n+            boolean lenChunksPerfectly = len % chunkSize == 0;\n+            len += (len / chunkSize) * chunkSeparator.length;\n+            if (!lenChunksPerfectly) {\n+                len += chunkSeparator.length;\n+            }\n+        }\n+        return len;\n+    }\n+\n+    /**\n+     * Resets this Base32 object to its initial newly constructed state.\n+     */\n+    private void reset() {\n+        buffer = null;\n+        pos = 0;\n+        readPos = 0;\n+        currentLinePos = 0;\n+        modulus = 0;\n+        eof = false;\n+    }\n+\n+}", "timestamp": 1296034711, "metainfo": ""}