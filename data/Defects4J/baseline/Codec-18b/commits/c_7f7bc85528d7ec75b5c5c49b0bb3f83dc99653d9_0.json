{"sha": "7f7bc85528d7ec75b5c5c49b0bb3f83dc99653d9", "log": "Fix checkstyle issues (line lengths).  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64.java\n  * </ul>\n  * </p>\n  * <p>\n- * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n- * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only\n+ * encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252,\n+ * UTF-8, etc).\n  * </p>\n  * <p>\n  * This class is thread-safe.\n     };\n \n     /**\n-     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n-     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n+     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified\n+     * in Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n      * alphabet but fall within the bounds of the array are translated to -1.\n      *\n      * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n-     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n+     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is\n+     * STANDARD_ENCODE_TABLE.\n      * </p>\n      *\n      * <p>\n      * </p>\n      *\n      * @param urlSafe\n-     *            if {@code true}, URL-safe encoding is used. In most cases this should be set to\n-     *            {@code false}.\n+     *            if {@code true}, URL-safe encoding is used. In most cases this should be set to {@code false}.\n      * @since 1.4\n      */\n     public Base64(boolean urlSafe) {\n      * </p>\n      *\n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n-     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n+     *            4). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            decoding.\n      * @since 1.4\n      */\n     public Base64(int lineLength) {\n      * </p>\n      *\n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n-     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n+     *            4). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n      * @throws IllegalArgumentException\n      * </p>\n      *\n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n-     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n+     *            4). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n      * @param urlSafe\n      *            Position to start reading data from.\n      * @param inAvail\n      *            Amount of bytes available from input for encoding.\n-     * @param context the context to be used\n+     * @param context\n+     *            the context to be used\n      */\n     @Override\n     void encode(byte[] in, int inPos, int inAvail, Context context) {\n             int savedPos = context.pos;\n             switch (context.modulus) { // 0-2\n                 case 1 : // 8 bits = 6 + 2\n-                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS]; // top 6 bits\n-                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS]; // remaining 2\n+                    // top 6 bits:\n+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];\n+                    // remaining 2:\n+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];\n                     // URL-SAFE skips the padding to further reduce size.\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         context.buffer[context.pos++] = PAD;\n      *            Position to start reading data from.\n      * @param inAvail\n      *            Amount of bytes available from input for encoding.\n-     * @param context the context to be used\n+     * @param context\n+     *            the context to be used\n      */\n     @Override\n     void decode(byte[] in, int inPos, int inAvail, Context context) {\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n         boolean eof;\n \n         /**\n-         * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n-         * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n+         * Variable tracks how many characters have been written to the current line. Only used when encoding. We use\n+         * it to make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n          */\n         int currentLinePos;\n \n         /**\n-         * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding.\n-         * This variable helps track that.\n+         * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding. This\n+         * variable helps track that.\n          */\n         int modulus;\n \n      * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\n      * @param chunkSeparatorLength the chunk separator length, if relevant\n      */\n-    protected BaseNCodec(int unencodedBlockSize, int encodedBlockSize, int lineLength, int chunkSeparatorLength){\n+    protected BaseNCodec(int unencodedBlockSize, int encodedBlockSize, int lineLength, int chunkSeparatorLength) {\n         this.unencodedBlockSize = unencodedBlockSize;\n         this.encodedBlockSize = encodedBlockSize;\n-        this.lineLength = (lineLength > 0  && chunkSeparatorLength > 0) ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;\n+        final boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\n+        this.lineLength = useChunking ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;\n         this.chunkSeparatorLength = chunkSeparatorLength;\n     }\n \n     }\n \n     /**\n-     * Extracts buffered data into the provided byte[] array, starting at position bPos,\n-     * up to a maximum of bAvail bytes. Returns how many bytes were actually extracted.\n+     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n+     * bytes. Returns how many bytes were actually extracted.\n+     * <p>\n+     * Package protected for access from I/O streams.\n      *\n      * @param b\n      *            byte[] array to extract the buffered data into.\n      *            position in byte[] array to start extraction at.\n      * @param bAvail\n      *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n-     * @param context the context to be used\n+     * @param context\n+     *            the context to be used\n      * @return The number of bytes successfully extracted into the provided byte[] array.\n      */\n-    int readResults(byte[] b, int bPos, int bAvail, Context context) {  // package protected for access from I/O streams\n+    int readResults(byte[] b, int bPos, int bAvail, Context context) {\n         if (context.buffer != null) {\n             int len = Math.min(available(context), bAvail);\n             System.arraycopy(context.buffer, context.readPos, b, bPos, len);\n     }\n \n     /**\n-     * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of the\n-     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n+     * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of\n+     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n      *\n      * @param obj\n      *            Object to encode\n     }\n \n     /**\n-     * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of the\n-     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n+     * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of\n+     * the Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n      *\n      * @param obj\n      *            Object to decode\n-     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n+     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String\n+     *         supplied.\n      * @throws DecoderException\n      *             if the parameter supplied is not of type byte[]\n      */\n         return buf;\n     }\n \n-    abstract void encode(byte[] pArray, int i, int length, Context context);  // package protected for access from I/O streams\n-\n-    abstract void decode(byte[] pArray, int i, int length, Context context); // package protected for access from I/O streams\n+    // package protected for access from I/O streams\n+    abstract void encode(byte[] pArray, int i, int length, Context context);\n+\n+    // package protected for access from I/O streams\n+    abstract void decode(byte[] pArray, int i, int length, Context context);\n \n     /**\n      * Returns whether or not the <code>octet</code> is in the current alphabet.", "timestamp": 1346333472, "metainfo": ""}