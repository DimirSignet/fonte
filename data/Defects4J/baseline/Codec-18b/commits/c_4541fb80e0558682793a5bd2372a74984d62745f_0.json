{"sha": "4541fb80e0558682793a5bd2372a74984d62745f", "log": "Checkstyle fixes.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n /**\n  * Encodes strings into their Beider-Morse phonetic encoding.\n  * <p>\n- * Beider-Morse phonetic encodings are optimised for family names. However, they may be useful for a wide range of words.\n+ * Beider-Morse phonetic encodings are optimised for family names. However, they may be useful for a wide range\n+ * of words.\n  * <p>\n  * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it\n  * is mutable, and may not be thread-safe. If you require a guaranteed thread-safe encoding then use\n  * If multiple hyphenated words where found, or if the word may contain a name prefix, each encoded word is placed\n  * in elipses and these blocks are then joined with hyphens. For example, \"<code>d'ortley</code>\" has a possible\n  * prefix. The form without prefix encodes to \"<code>ortlaj|ortlej</code>\", while the form with prefix encodes to\n- * \"<code>dortlaj|dortlej</code>\". Thus, the full, combined encoding is \"<code>(ortlaj|ortlej)-(dortlaj|dortlej)</code>\".\n+ * \"<code>dortlaj|dortlej</code>\". Thus, the full, combined encoding is \"{@code (ortlaj|ortlej)-(dortlaj|dortlej)}\".\n  * <p>\n  * The encoded forms are often quite a bit longer than the input strings. This is because a single input may have many\n  * potential phonetic interpretations. For example, \"<code>Renault</code>\" encodes to\n      * Sets how multiple possible phonetic encodings are combined.\n      *\n      * @param concat\n-     *            true if multiple encodings are to be combined with a '|', false if just the first one is to be considered\n+     *            true if multiple encodings are to be combined with a '|', false if just the first one is\n+     *            to be considered\n      */\n     public void setConcat(boolean concat) {\n         this.engine = new PhoneticEngine(this.engine.getNameType(),\n--- a/src/main/java/org/apache/commons/codec/language/bm/Languages.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Languages.java\n  * The format of these resources is the following:\n  * <ul>\n  * <li><b>Language:</b> a single string containing no whitespace</li>\n- * <li><b>End-of-line comments:</b> Any occurance of '//' will cause all text following on that line to be discarded as a comment.</li>\n- * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip all content until a\n- * line ending in '*' and '/' is found.</li>\n+ * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be\n+ * discarded as a comment.</li>\n+ * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode.\n+ * This will skip all content until a line ending in '*' and '/' is found.</li>\n  * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n  * </ul>\n  * <p>\n--- a/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n \n     static {\n         NAME_PREFIXES.put(NameType.ASHKENAZI,\n-                Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\"))));\n-        NAME_PREFIXES.put(NameType.SEPHARDIC, Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\",\n-                \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n-        NAME_PREFIXES.put(NameType.GENERIC, Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\",\n-                \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n+                Collections.unmodifiableSet(\n+                        new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\"))));\n+        NAME_PREFIXES.put(NameType.SEPHARDIC,\n+                Collections.unmodifiableSet(\n+                        new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\",\n+                                                          \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n+        NAME_PREFIXES.put(NameType.GENERIC,\n+                Collections.unmodifiableSet(\n+                        new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\", \"de la\", \"della\",\n+                                                          \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n     }\n \n     /**\n      * Joins some strings with an internal separator.\n      * @param strings   Strings to join\n      * @param sep       String to separate them with\n-     * @return          a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>\n+     * @return a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>\n      */\n     private static String join(Iterable<String> strings, String sep) {\n         StringBuilder sb = new StringBuilder();\n      * @param input\n      *            String to phoneticise; a String with dashes or spaces separating each word\n      * @param languageSet\n-     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the input\n+     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations\n+     *   of the input\n      */\n     public String encode(String input, final Languages.LanguageSet languageSet) {\n         final List<Rule> rules = Rule.getInstance(this.nameType, RuleType.RULES, languageSet);\n--- a/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n         }\n \n         public Phoneme join(Phoneme right) {\n-            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(), this.languages.restrictTo(right.languages));\n+            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),\n+                               this.languages.restrictTo(right.languages));\n         }\n     }\n \n \n     private static final String HASH_INCLUDE = \"#include\";\n \n-    private static final Map<NameType, Map<RuleType, Map<String, List<Rule>>>> RULES = new EnumMap<NameType, Map<RuleType, Map<String, List<Rule>>>>(\n-            NameType.class);\n+    private static final Map<NameType, Map<RuleType, Map<String, List<Rule>>>> RULES =\n+            new EnumMap<NameType, Map<RuleType, Map<String, List<Rule>>>>(NameType.class);\n \n     static {\n         for (NameType s : NameType.values()) {\n     }\n \n     private static String createResourceName(NameType nameType, RuleType rt, String lang) {\n-        return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\", nameType.getName(), rt.getName(), lang);\n+        return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\",\n+                             nameType.getName(), rt.getName(), lang);\n     }\n \n     private static Scanner createScanner(NameType nameType, RuleType rt, String lang) {\n      * @return a list of Rules that apply\n      */\n     public static List<Rule> getInstance(NameType nameType, RuleType rt, Languages.LanguageSet langs) {\n-        return langs.isSingleton() ? getInstance(nameType, rt, langs.getAny()) : getInstance(nameType, rt, Languages.ANY);\n+        return langs.isSingleton() ? getInstance(nameType, rt, langs.getAny()) :\n+                                     getInstance(nameType, rt, Languages.ANY);\n     }\n \n     /**\n         List<Rule> rules = RULES.get(nameType).get(rt).get(lang);\n \n         if (rules == null) {\n-            throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\", nameType.getName(), rt.getName(), lang));\n+            throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\",\n+                                               nameType.getName(), rt.getName(), lang));\n         }\n \n         return rules;\n                         String[] parts = line.split(\"\\\\s+\");\n                         if (parts.length != 4) {\n                             // FIXME: consider throwing an IllegalStateException like in parsePhonemeExpr\n-                            // System.err.println(\"Warning: malformed rule statement split into \" + parts.length + \" parts: \" + rawLine);\n+//                            System.err.println(\"Warning: malformed rule statement split into \" + parts.length +\n+//                                               \" parts: \" + rawLine);\n                         } else {\n                             try {\n                                 String pat = stripQuotes(parts[0]);\n                         return new RPattern() {\n                             @Override\n                             public boolean isMatch(CharSequence input) {\n-                                return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n+                                return input.length() > 0 &&\n+                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n                             }\n                         };\n                     }", "timestamp": 1346275789, "metainfo": ""}