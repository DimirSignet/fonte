{"sha": "79a585cc2945f4f26f0a2d02bd66f58c2182d369", "log": "Javadoc fixes for Beider-Morse Encoder / Phonetic engine, removed debug prints.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n import org.apache.commons.codec.StringEncoder;\n \n /**\n- * <p>\n  * Encodes strings into their Beider-Morse phonetic encoding.\n- * </p>\n  * <p>\n  * Beider-Morse phonetic encodings are optimised for family names. However, they may be useful for a wide range of words.\n- * </p>\n  * <p>\n- * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it is mutable, and may not be\n- * thread-safe. If you require a guaranteed thread-safe encoding then use {@link PhoneticEngine} directly.\n- * </p>\n- *\n- * <h2>Encoding overview</h2>\n- *\n+ * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it\n+ * is mutable, and may not be thread-safe. If you require a guaranteed thread-safe encoding then use\n+ * {@link PhoneticEngine} directly.\n+ * <p>\n+ * <b>Encoding overview</b>\n  * <p>\n  * Beider-Morse phonetic encodings is a multi-step process. Firstly, a table of rules is consulted to guess what\n- * language the word comes from. For example, if it ends in \"<code>ault</code>\" then it infers that the word is French. Next,\n- * the word is translated into a phonetic representation using a language-specific phonetics table. Some runs of letters\n- * can be pronounced in multiple ways, and a single run of letters may be potentially broken up into phonemes at\n- * different places, so this stage results in a set of possible language-specific phonetic representations. Lastly,\n- * this language-specific phonetic representation is processed by a table of rules that re-writes it phonetically taking\n- * into account systematic pronunciation differences between languages, to move it towards a pan-indo-european phonetic\n- * representation. Again, sometimes there are multiple ways this could be done and sometimes things that can be\n- * pronounced in several ways in the source language have only one way to represent them in this average phonetic\n- * language, so the result is again a set of phonetic spellings.\n- * </p>\n- *\n+ * language the word comes from. For example, if it ends in \"<code>ault</code>\" then it infers that the word is French.\n+ * Next, the word is translated into a phonetic representation using a language-specific phonetics table. Some\n+ * runs of letters can be pronounced in multiple ways, and a single run of letters may be potentially broken up\n+ * into phonemes at different places, so this stage results in a set of possible language-specific phonetic\n+ * representations. Lastly, this language-specific phonetic representation is processed by a table of rules that\n+ * re-writes it phonetically taking into account systematic pronunciation differences between languages, to move\n+ * it towards a pan-indo-european phonetic representation. Again, sometimes there are multiple ways this could be\n+ * done and sometimes things that can be pronounced in several ways in the source language have only one way to\n+ * represent them in this average phonetic language, so the result is again a set of phonetic spellings.\n  * <p>\n- * Some names are treated as having multiple parts. This can be due to two things. Firstly, they may be hyphenated. In\n- * this case, each individual hyphenated word is encoded, and then these are combined end-to-end for the final encoding.\n- * Secondly, some names have standard prefixes, for example, \"<code>Mac/Mc</code>\" in Scottish (English) names. As sometimes it is\n- * ambiguous whether the prefix is intended or is an accident of the spelling, the word is encoded once with the prefix\n- * and once without it. The resulting encoding contains one and then the other result.\n- * </p>\n- *\n- *\n- * <h2>Encoding format</h2>\n- *\n- * Individual phonetic spellings of an input word are represented in upper- and lower-case roman characters. Where there\n- * are multiple possible phonetic representations, these are joined with a pipe (<code>|</code>) character. If multiple hyphenated\n- * words where found, or if the word may contain a name prefix, each encoded word is placed in elipses and these blocks\n- * are then joined with hyphens. For example, \"<code>d'ortley</code>\" has a possible prefix. The form without prefix encodes to\n- * \"<code>ortlaj|ortlej</code>\", while the form with prefix encodes to \"<code>dortlaj|dortlej</code>\". Thus, the full, combined encoding is\n- * \"<code>(ortlaj|ortlej)-(dortlaj|dortlej)</code>\".\n- *\n+ * Some names are treated as having multiple parts. This can be due to two things. Firstly, they may be hyphenated.\n+ * In this case, each individual hyphenated word is encoded, and then these are combined end-to-end for the final\n+ * encoding. Secondly, some names have standard prefixes, for example, \"<code>Mac/Mc</code>\" in Scottish (English)\n+ * names. As sometimes it is ambiguous whether the prefix is intended or is an accident of the spelling, the word\n+ * is encoded once with the prefix and once without it. The resulting encoding contains one and then the other result.\n+ * <p>\n+ * <b>Encoding format</b>\n+ * <p>\n+ * Individual phonetic spellings of an input word are represented in upper- and lower-case roman characters. Where\n+ * there are multiple possible phonetic representations, these are joined with a pipe (<code>|</code>) character.\n+ * If multiple hyphenated words where found, or if the word may contain a name prefix, each encoded word is placed\n+ * in elipses and these blocks are then joined with hyphens. For example, \"<code>d'ortley</code>\" has a possible\n+ * prefix. The form without prefix encodes to \"<code>ortlaj|ortlej</code>\", while the form with prefix encodes to\n+ * \"<code>dortlaj|dortlej</code>\". Thus, the full, combined encoding is \"<code>(ortlaj|ortlej)-(dortlaj|dortlej)</code>\".\n  * <p>\n  * The encoded forms are often quite a bit longer than the input strings. This is because a single input may have many\n  * potential phonetic interpretations. For example, \"<code>Renault</code>\" encodes to\n  * encodings as they consider a wider range of possible, approximate phonetic interpretations of the original word.\n  * Down-stream applications may wish to further process the encoding for indexing or lookup purposes, for example, by\n  * splitting on pipe (<code>|</code>) and indexing under each of these alternatives.\n- * </p>\n  *\n  * @since 1.6\n  */\n     }\n \n     /**\n-     * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phoentic encodings optimized for Ashkenazi or\n-     * Sephardic Jewish family names.\n+     * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phonetic encodings\n+     * optimized for Ashkenazi or Sephardic Jewish family names.\n      *\n      * @param nameType\n      *            the NameType in use\n--- a/src/main/java/org/apache/commons/codec/language/bm/Lang.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Lang.java\n import java.util.regex.Pattern;\n \n /**\n- * <p>\n  * Language guessing utility.\n- * </p>\n- * <p>\n- * This class encapsulates rules used to guess the possible languages that a word originates from. This is done by reference to a whole\n- * series of rules distributed in resource files.\n- * </p>\n- * <p>\n- * Instances of this class are typically managed through the static factory method instance(). Unless you are developing your own language\n- * guessing rules, you will not need to interact with this class directly.\n- * </p>\n+ * <p>\n+ * This class encapsulates rules used to guess the possible languages that a word originates from. This is\n+ * done by reference to a whole series of rules distributed in resource files.\n+ * <p>\n+ * Instances of this class are typically managed through the static factory method instance().\n+ * Unless you are developing your own language guessing rules, you will not need to interact with this class directly.\n  * <p>\n  * This class is intended to be immutable and thread-safe.\n- * </p>\n- * <h2>Lang resources</h2\n- * <p>\n- * Language guessing rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically named\n- * following the pattern: <blockquote>org/apache/commons/codec/language/bm/lang.txt</blockquote> The format of these resources is the\n- * following:\n- * </p>\n+ * <p>\n+ * <b>Lang resources</b>\n+ * <p>\n+ * Language guessing rules are typically loaded from resource files. These are UTF-8 encoded text files.\n+ * They are systematically named following the pattern:\n+ * <blockquote>org/apache/commons/codec/language/bm/lang.txt</blockquote>\n+ * The format of these resources is the following:\n  * <ul>\n- * <li><b>Rules:</b> whitespace separated strings. There should be 3 columns to each row, and these will be interpreted as:\n+ * <li><b>Rules:</b> whitespace separated strings.\n+ * There should be 3 columns to each row, and these will be interpreted as:\n  * <ol>\n  * <li>pattern: a regular expression.</li>\n  * <li>languages: a '+'-separated list of languages.</li>\n  * <li>acceptOnMatch: 'true' or 'false' indicating if a match rules in or rules out the language.</li>\n  * </ol>\n  * </li>\n- * <li><b>End-of-line comments:</b> Any occurance of '//' will cause all text following on that line to be discarded as a comment.</li>\n- * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip all content until a\n- * line ending in '*' and '/' is found.</li>\n+ * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be\n+ * discarded as a comment.</li>\n+ * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode.\n+ * This will skip all content until a line ending in '*' and '/' is found.</li>\n  * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n  * </ul>\n- * <p/>\n+ * <p>\n  * Port of lang.php\n  *\n  * @since 1.6\n     }\n \n     /**\n+     * Loads language rules from a resource.\n      * <p>\n-     * Loads language rules from a resource.\n-     * </p>\n-     * <p>\n-     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method. You will only need to call this\n-     * yourself if you are developing custom language mapping rules.\n-     * </p>\n+     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.\n+     * You will only need to call this yourself if you are developing custom language mapping rules.\n      *\n      * @param languageRulesResourceName\n      *            the fully-qualified resource name to load\n                     // discard comments\n                     int cmtI = line.indexOf(ResourceConstants.CMT);\n                     if (cmtI >= 0) {\n-                        // System.err.println(\"index of comment: \" + cmtI);\n                         line = line.substring(0, cmtI);\n                     }\n \n \n                     // split it up\n                     String[] parts = line.split(\"\\\\s+\");\n-                    // System.err.println(\"part count: \" + parts.length);\n \n                     if (parts.length != 3) {\n-                        // fixme: we really need to log this somewhere\n-                        System.err.println(\"Warning: malformed line '\" + rawLine + \"'\");\n+                        // FIXME: consider throwing an IllegalStateException like in Rule\n+                        // System.err.println(\"Warning: malformed line '\" + rawLine + \"'\");\n                         continue;\n                     }\n \n      */\n     public Languages.LanguageSet guessLanguages(String input) {\n         String text = input.toLowerCase(Locale.ENGLISH);\n-        // System.out.println(\"Testing text: '\" + text + \"'\");\n \n         Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n         for (LangRule rule : this.rules) {\n             if (rule.matches(text)) {\n-                // System.out.println(\"Rule \" + rule.pattern + \" matches \" + text);\n                 if (rule.acceptOnMatch) {\n-                    // System.out.println(\"Retaining \" + rule.languages);\n                     langs.retainAll(rule.languages);\n                 } else {\n-                    // System.out.println(\"Removing \" + rule.languages);\n                     langs.removeAll(rule.languages);\n                 }\n-                // System.out.println(\"Current languages: \" + langs);\n-            } else {\n-                // System.out.println(\"Rule \" + rule.pattern + \" does not match \" + text);\n             }\n         }\n \n--- a/src/main/java/org/apache/commons/codec/language/bm/Languages.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Languages.java\n import java.util.Set;\n \n /**\n+ * Language codes.\n  * <p>\n- * Language codes.\n- * </p>\n- * <p>\n- * Language codes are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically named following the\n- * pattern:\n- * </p>\n+ * Language codes are typically loaded from resource files. These are UTF-8 encoded text files. They are\n+ * systematically named following the pattern:\n  * <blockquote>org/apache/commons/codec/language/bm/${{@link NameType#getName()} languages.txt</blockquote>\n  * <p>\n  * The format of these resources is the following:\n- * </p>\n  * <ul>\n  * <li><b>Language:</b> a single string containing no whitespace</li>\n  * <li><b>End-of-line comments:</b> Any occurance of '//' will cause all text following on that line to be discarded as a comment.</li>\n  * </ul>\n  * <p>\n  * Ported from language.php\n- * </p>\n  *\n  * @since 1.6\n  *\n--- a/src/main/java/org/apache/commons/codec/language/bm/NameType.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/NameType.java\n \n /**\n  * Supported types of names. Unless you are matching particular family names, use {@link #GENERIC}. The\n- * <code>GENERIC</code> NameType should work reasonably well for non-name words. The other encodings are specifically\n- * tuned to family names, and may not work well at all for general text.\n+ * <code>GENERIC</code> NameType should work reasonably well for non-name words. The other encodings are\n+ * specifically tuned to family names, and may not work well at all for general text.\n  *\n  * @since 1.6\n  */\n--- a/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n import java.util.TreeSet;\n \n /**\n+ * Converts words into potential phonetic representations.\n  * <p>\n- * Converts words into potential phonetic representations.\n- * </p>\n+ * This is a two-stage process. Firstly, the word is converted into a phonetic representation that takes\n+ * into account the likely source language. Next, this phonetic representation is converted into a\n+ * pan-european 'average' representation, allowing comparison between different versions of essentially\n+ * the same word from different languages.\n  * <p>\n- * This is a two-stage process. Firstly, the word is converted into a phonetic representation that takes into account the likely source\n- * language. Next, this phonetic representation is converted into a pan-european 'average' representation, allowing comparison between\n- * different versions of essentially the same word from different languages.\n- * </p>\n- * <p>\n- * This class is intentionally immutable. If you wish to alter the settings for a PhoneticEngine, you must make a new one with the updated\n- * settings. This makes the class thread-safe.\n- * </p>\n+ * This class is intentionally immutable. If you wish to alter the settings for a PhoneticEngine, you\n+ * must make a new one with the updated settings. This makes the class thread-safe.\n  * <p>\n  * Ported from phoneticengine.php\n- * </p>\n  *\n  * @since 1.6\n  */\n public class PhoneticEngine {\n \n     /**\n-     * Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside this package,\n-     * and probably not outside the {@link PhoneticEngine} class.\n+     * Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside\n+     * this package, and probably not outside the {@link PhoneticEngine} class.\n      *\n      * @since 1.6\n      */\n \n         /**\n          * Creates a new phoneme builder containing the application of the expression to all phonemes in this builder.\n-         *\n+         * <p>\n          * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\n          * incompatible.\n          *\n         }\n \n         /**\n-         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme, joined with a pipe.\n-         * This is explicitly provied in place of toString as it is a potentially expensive operation, which should be\n-         * avoided when debugging.\n+         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,\n+         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially\n+         * expensive operation, which should be avoided when debugging.\n          *\n          * @return  the stringified phoneme set\n          */\n      * After invocation, the values <code>i</code> and <code>found</code> are updated. <code>i</code> points to the\n      * index of the next char in <code>input</code> that must be processed next (the input up to that index having been\n      * processed already), and <code>found</code> indicates if a matching rule was found or not. In the case where a\n-     * matching rule was found, <code>phonemeBuilder</code> is replaced with a new buidler containing the phonemes\n+     * matching rule was found, <code>phonemeBuilder</code> is replaced with a new builder containing the phonemes\n      * updated by the matching rule.\n      *\n      * Although this class is not thread-safe (it has mutable unprotected fields), it is not shared between threads\n         public RulesApplication invoke() {\n             this.found = false;\n             int patternLength = 0;\n-            RULES: for (Rule rule : this.finalRules) {\n+            for (Rule rule : this.finalRules) {\n                 String pattern = rule.getPattern();\n                 patternLength = pattern.length();\n-                // log(\"trying pattern: \" + pattern);\n \n                 if (!rule.patternAndContextMatches(this.input, this.i)) {\n-                    // log(\"no match\");\n-                    continue RULES;\n+                    continue;\n                 }\n \n                 this.phonemeBuilder = this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\n                 this.found = true;\n-                break RULES;\n+                break;\n             }\n \n             if (!this.found) {\n      * This is a performance hack to avoid overhead associated with very frequent CharSequence.subSequence calls.\n      *\n      * @param cached the character sequence to cache\n-     * @return a <code>CharSequence</code> that internally memoises subSequence values\n+     * @return a <code>CharSequence</code> that internally caches subSequence values\n      */\n     private static CharSequence cacheSubSequence(final CharSequence cached) {\n         // return cached;\n      * Joins some strings with an internal separator.\n      * @param strings   Strings to join\n      * @param sep       String to separate them with\n-     * @return          a single String consisting of each element of <code>strings</code> interlieved by <code>sep</code>\n+     * @return          a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>\n      */\n     private static String join(Iterable<String> strings, String sep) {\n         StringBuilder sb = new StringBuilder();\n     }\n \n     /**\n-     * Applies the final rules to convert from a language-specific phonetic representation to a language-independent\n-     * representation.\n+     * Applies the final rules to convert from a language-specific phonetic representation to a\n+     * language-independent representation.\n      *\n      * @param phonemeBuilder\n      * @param finalRules\n         for (Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n             PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n             CharSequence phonemeText = cacheSubSequence(phoneme.getPhonemeText());\n-            // System.err.println(\"Expanding: \" + phonemeText);\n \n             for (int i = 0; i < phonemeText.length();) {\n                 RulesApplication rulesApplication =\n                 subBuilder = rulesApplication.getPhonemeBuilder();\n \n                 if (!found) {\n-                    // System.err.println(\"Not found. Appending as-is\");\n+                    // not found, appending as-is\n                     subBuilder = subBuilder.append(phonemeText.subSequence(i, i + 1));\n                 }\n \n                 i = rulesApplication.getI();\n-\n-                // System.err.println(phonemeText + \" \" + i + \": \" + subBuilder.makeString());\n-            }\n-\n-            // System.err.println(\"Expanded to: \" + subBuilder.makeString());\n-            // System.err.println(\"phenomes in collection of type: \" + subBuilder.getPhonemes().getClass());\n+            }\n+\n             phonemes.addAll(subBuilder.getPhonemes());\n         }\n \n         final List<Rule> finalRules1 = Rule.getInstance(this.nameType, this.ruleType, \"common\");\n         // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\n         final List<Rule> finalRules2 = Rule.getInstance(this.nameType, this.ruleType, languageSet);\n-\n-        // System.err.println(\"Languages: \" + languageSet);\n-        // System.err.println(\"Rules: \" + rules);\n \n         // tidy the input\n         // lower case is a locale-dependent operation\n                     new RulesApplication(rules, inputCache, phonemeBuilder, i, maxPhonemes).invoke();\n             i = rulesApplication.getI();\n             phonemeBuilder = rulesApplication.getPhonemeBuilder();\n-            // System.err.println(input + \" \" + i + \": \" + phonemeBuilder.makeString());\n         }\n \n         // Apply the general rules\n     /**\n      * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n      *\n-     * @return true if multiple phonetic encodings are returned, false if just the first is.\n+     * @return true if multiple phonetic encodings are returned, false if just the first is\n      */\n     public boolean isConcat() {\n         return this.concat;\n--- a/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n import java.util.regex.Pattern;\n \n /**\n+ * A phoneme rule.\n  * <p>\n- * A phoneme rule.\n- * </p>\n- * <p>\n- * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply and a logical flag indicating if\n- * all lanugages must be in play. A rule matches if:\n+ * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply\n+ * and a logical flag indicating if all languages must be in play. A rule matches if:\n  * <ul>\n  * <li>the pattern matches at the current position</li>\n  * <li>the string up until the beginning of the pattern matches the left context</li>\n  * <li>logical is ALL and all languages are in scope; or</li>\n  * <li>logical is any other value and at least one language is in scope</li>\n  * </ul>\n- * </p>\n  * <p>\n- * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user to explicitly construct their\n- * own.\n- * </p>\n+ * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user\n+ * to explicitly construct their own.\n  * <p>\n  * Rules are immutable and thread-safe.\n- * <h2>Rules resources</h2>\n  * <p>\n- * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically named following the pattern:\n+ * <b>Rules resources</b>\n+ * <p>\n+ * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically\n+ * named following the pattern:\n  * <blockquote>org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt</blockquote>\n- * </p>\n  * <p>\n  * The format of these resources is the following:\n  * <ul>\n- * <li><b>Rules:</b> whitespace separated, double-quoted strings. There should be 4 columns to each row, and these will be interpreted as:\n+ * <li><b>Rules:</b> whitespace separated, double-quoted strings. There should be 4 columns to each row, and these\n+ * will be interpreted as:\n  * <ol>\n  * <li>pattern</li>\n  * <li>left context</li>\n  * <li>phoneme</li>\n  * </ol>\n  * </li>\n- * <li><b>End-of-line comments:</b> Any occurance of '//' will cause all text following on that line to be discarded as a comment.</li>\n- * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip all content until a\n- * line ending in '*' and '/' is found.</li>\n+ * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be discarded\n+ * as a comment.</li>\n+ * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip\n+ * all content until a line ending in '*' and '/' is found.</li>\n  * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n  * </ul>\n- * </p>\n  *\n  * @since 1.6\n  */\n                         // include statement\n                         String incl = line.substring(HASH_INCLUDE.length()).trim();\n                         if (incl.contains(\" \")) {\n-                            System.err.println(\"Warining: malformed import statement: \" + rawLine);\n+                            // FIXME: consider throwing an IllegalStateException like in parsePhonemeExpr\n+                            // System.err.println(\"Warning: malformed import statement: \" + rawLine);\n                         } else {\n                             lines.addAll(parseRules(createScanner(incl), location + \"->\" + incl));\n                         }\n                         // rule\n                         String[] parts = line.split(\"\\\\s+\");\n                         if (parts.length != 4) {\n-                            System.err.println(\"Warning: malformed rule statement split into \" + parts.length + \" parts: \" + rawLine);\n+                            // FIXME: consider throwing an IllegalStateException like in parsePhonemeExpr\n+                            // System.err.println(\"Warning: malformed rule statement split into \" + parts.length + \" parts: \" + rawLine);\n                         } else {\n                             try {\n                                 String pat = stripQuotes(parts[0]);\n             }\n         }\n \n-        // System.out.println(\"Couldn't optimize regex: \" + regex);\n         return new RPattern() {\n             Pattern pattern = Pattern.compile(regex);\n ", "timestamp": 1345752090, "metainfo": ""}