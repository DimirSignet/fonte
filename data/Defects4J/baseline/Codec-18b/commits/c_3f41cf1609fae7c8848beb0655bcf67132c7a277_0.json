{"sha": "3f41cf1609fae7c8848beb0655bcf67132c7a277", "log": "[CODEC-96] Base64 encode() method is no longer thread-safe, breaking clients using it as a shared BinaryEncoder  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java\n  * This class operates directly on byte streams, and not character streams.\n  * </p>\n  * <p>\n- * This class is not thread-safe. Each thread should use its own instance.\n+ * This class is thread-safe.\n  * </p>\n  * \n  * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n      * Place holder for the bytes we're dealing with for our based logic. \n      * Bitwise operations store and extract the encoding or decoding from this variable.\n      */\n-    private long bitWorkArea;\n-\n     /**\n      * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n      * <code>decodeSize = {@link #BYTES_PER_ENCODED_BLOCK} - 1 + lineSeparator.length;</code>\n      *            Position to start reading data from.\n      * @param inAvail\n      *            Amount of bytes available from input for encoding.\n+     * @param context the context to be used\n      *\n      * Output is written to {@link #buffer} as 8-bit octets, using {@link #pos} as the buffer position\n      */\n     @Override\n-    void decode(byte[] in, int inPos, int inAvail) { // package protected for access from I/O streams\n-        if (eof) {\n+    void decode(byte[] in, int inPos, int inAvail, Context context) { // package protected for access from I/O streams\n+        if (context.eof) {\n             return;\n         }\n         if (inAvail < 0) {\n-            eof = true;\n+            context.eof = true;\n         }\n         for (int i = 0; i < inAvail; i++) {\n             byte b = in[inPos++];\n             if (b == PAD) {\n                 // We're done.\n-                eof = true;\n+                context.eof = true;\n                 break;\n             } else {\n-                ensureBufferSize(decodeSize);\n+                ensureBufferSize(decodeSize, context);\n                 if (b >= 0 && b < this.decodeTable.length) {\n                     int result = this.decodeTable[b];\n                     if (result >= 0) {\n-                        modulus = (modulus+1) % BYTES_PER_ENCODED_BLOCK;\n-                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result; // collect decoded bytes\n-                        if (modulus == 0) { // we can output the 5 bytes\n-                            buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);\n-                            buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);\n-                            buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n-                            buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                            buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);\n+                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n+                        context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; // collect decoded bytes\n+                        if (context.modulus == 0) { // we can output the 5 bytes\n+                            context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\n+                            context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n+                            context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n+                            context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n+                            context.buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\n                         }\n                     }\n                 }\n         // Two forms of EOF as far as Base32 decoder is concerned: actual\n         // EOF (-1) and first time '=' character is encountered in stream.\n         // This approach makes the '=' padding characters completely optional.\n-        if (eof && modulus >= 2) { // if modulus < 2, nothing to do\n-            ensureBufferSize(decodeSize);\n+        if (context.eof && context.modulus >= 2) { // if modulus < 2, nothing to do\n+            ensureBufferSize(decodeSize, context);\n     \n             //  we ignore partial bytes, i.e. only multiples of 8 count\n-            switch (modulus) {\n+            switch (context.modulus) {\n                 case 2 : // 10 bits, drop 2 and output one byte\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);\n                     break;\n                 case 3 : // 15 bits, drop 7 and output 1 byte\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);\n                     break;\n                 case 4 : // 20 bits = 2*8 + 4\n-                    bitWorkArea = bitWorkArea >> 4; // drop 4 bits\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    context.lbitWorkArea = context.lbitWorkArea >> 4; // drop 4 bits\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                     break;\n                 case 5 : // 25bits = 3*8 + 1\n-                    bitWorkArea = bitWorkArea >> 1;\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    context.lbitWorkArea = context.lbitWorkArea >> 1;\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                     break;\n                 case 6 : // 30bits = 3*8 + 6\n-                    bitWorkArea = bitWorkArea >> 6;\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    context.lbitWorkArea = context.lbitWorkArea >> 6;\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                     break;\n                 case 7 : // 35 = 4*8 +3\n-                    bitWorkArea = bitWorkArea >> 3;\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    context.lbitWorkArea = context.lbitWorkArea >> 3;\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\n                     break;\n             }\n         }\n      *            Position to start reading data from.\n      * @param inAvail\n      *            Amount of bytes available from input for encoding.\n+     * @param context the context to be used\n      */\n     @Override\n-    void encode(byte[] in, int inPos, int inAvail) { // package protected for access from I/O streams\n-        if (eof) {\n+    void encode(byte[] in, int inPos, int inAvail, Context context) { // package protected for access from I/O streams\n+        if (context.eof) {\n             return;\n         }\n         // inAvail < 0 is how we're informed of EOF in the underlying data we're\n         // encoding.\n         if (inAvail < 0) {\n-            eof = true;\n-            if (0 == modulus && lineLength == 0) {\n+            context.eof = true;\n+            if (0 == context.modulus && lineLength == 0) {\n                 return; // no leftovers to process and not using chunking\n             }\n-            ensureBufferSize(encodeSize);\n-            int savedPos = pos;\n-            switch (modulus) { // % 5\n+            ensureBufferSize(encodeSize, context);\n+            int savedPos = context.pos;\n+            switch (context.modulus) { // % 5\n                 case 1 : // Only 1 octet; take top 5 bits then remainder\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; // 5-3=2\n-                    buffer[pos++] = PAD;\n-                    buffer[pos++] = PAD;\n-                    buffer[pos++] = PAD;\n-                    buffer[pos++] = PAD;\n-                    buffer[pos++] = PAD;\n-                    buffer[pos++] = PAD;\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; // 5-3=2\n+                    context.buffer[context.pos++] = PAD;\n+                    context.buffer[context.pos++] = PAD;\n+                    context.buffer[context.pos++] = PAD;\n+                    context.buffer[context.pos++] = PAD;\n+                    context.buffer[context.pos++] = PAD;\n+                    context.buffer[context.pos++] = PAD;\n                     break;\n     \n                 case 2 : // 2 octets = 16 bits to use\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\n-                    buffer[pos++] = PAD;\n-                    buffer[pos++] = PAD;\n-                    buffer[pos++] = PAD;\n-                    buffer[pos++] = PAD;\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\n+                    context.buffer[context.pos++] = PAD;\n+                    context.buffer[context.pos++] = PAD;\n+                    context.buffer[context.pos++] = PAD;\n+                    context.buffer[context.pos++] = PAD;\n                     break;\n                 case 3 : // 3 octets = 24 bits to use\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\n-                    buffer[pos++] = PAD;\n-                    buffer[pos++] = PAD;\n-                    buffer[pos++] = PAD;\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\n+                    context.buffer[context.pos++] = PAD;\n+                    context.buffer[context.pos++] = PAD;\n+                    context.buffer[context.pos++] = PAD;\n                     break;\n                 case 4 : // 4 octets = 32 bits to use\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\n-                    buffer[pos++] = PAD;\n-                    break;\n-            }\n-            currentLinePos += pos - savedPos; // keep track of current line position\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\n+                    context.buffer[context.pos++] = PAD;\n+                    break;\n+            }\n+            context.currentLinePos += context.pos - savedPos; // keep track of current line position\n             // if currentPos == 0 we are at the start of a line, so don't add CRLF\n-            if (lineLength > 0 && currentLinePos > 0){ // add chunk separator if required\n-                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n-                pos += lineSeparator.length;\n+            if (lineLength > 0 && context.currentLinePos > 0){ // add chunk separator if required\n+                System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);\n+                context.pos += lineSeparator.length;\n             }            \n         } else {\n             for (int i = 0; i < inAvail; i++) {\n-                ensureBufferSize(encodeSize);\n-                modulus = (modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n+                ensureBufferSize(encodeSize, context);\n+                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n                 int b = in[inPos++];\n                 if (b < 0) {\n                     b += 256;\n                 }\n-                bitWorkArea = (bitWorkArea << 8) + b; // BITS_PER_BYTE\n-                if (0 == modulus) { // we have enough bytes to create our output \n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 35) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 30) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 25) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 20) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 15) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 10) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 5) & MASK_5BITS];\n-                    buffer[pos++] = encodeTable[(int)bitWorkArea & MASK_5BITS];\n-                    currentLinePos += BYTES_PER_ENCODED_BLOCK;\n-                    if (lineLength > 0 && lineLength <= currentLinePos) {\n-                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n-                        pos += lineSeparator.length;\n-                        currentLinePos = 0;\n+                context.lbitWorkArea = (context.lbitWorkArea << 8) + b; // BITS_PER_BYTE\n+                if (0 == context.modulus) { // we have enough bytes to create our output \n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];\n+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];\n+                    context.buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];\n+                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\n+                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\n+                        System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);\n+                        context.pos += lineSeparator.length;\n+                        context.currentLinePos = 0;\n                     }\n                 }\n             }\n--- a/src/main/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64.java\n  * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n  * </p>\n  * <p>\n- * This class is not thread-safe. Each thread should use its own instance.\n+ * This class is thread-safe.\n  * </p>\n  * \n  * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n      * <code>encodeSize = 4 + lineSeparator.length;</code>\n      */\n     private final int encodeSize;\n-\n-    /**\n-     * Place holder for the bytes we're dealing with for our based logic. \n-     * Bitwise operations store and extract the encoding or decoding from this variable.\n-     */\n-    private int bitWorkArea;\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n      *            Position to start reading data from.\n      * @param inAvail\n      *            Amount of bytes available from input for encoding.\n+     * @param context the context to be used\n      */\n     @Override\n-    void encode(byte[] in, int inPos, int inAvail) {\n-        if (eof) {\n+    void encode(byte[] in, int inPos, int inAvail, Context context) {\n+        if (context.eof) {\n             return;\n         }\n         // inAvail < 0 is how we're informed of EOF in the underlying data we're\n         // encoding.\n         if (inAvail < 0) {\n-            eof = true;\n-            if (0 == modulus && lineLength == 0) {\n+            context.eof = true;\n+            if (0 == context.modulus && lineLength == 0) {\n                 return; // no leftovers to process and not using chunking\n             }\n-            ensureBufferSize(encodeSize);\n-            int savedPos = pos;\n-            switch (modulus) { // 0-2\n+            ensureBufferSize(encodeSize, context);\n+            int savedPos = context.pos;\n+            switch (context.modulus) { // 0-2\n                 case 1 : // 8 bits = 6 + 2\n-                    buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS]; // top 6 bits\n-                    buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS]; // remaining 2 \n+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS]; // top 6 bits\n+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS]; // remaining 2 \n                     // URL-SAFE skips the padding to further reduce size.\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n-                        buffer[pos++] = PAD;\n-                        buffer[pos++] = PAD;\n+                        context.buffer[context.pos++] = PAD;\n+                        context.buffer[context.pos++] = PAD;\n                     }\n                     break;\n \n                 case 2 : // 16 bits = 6 + 6 + 4\n-                    buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];\n-                    buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];\n-                    buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];\n+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];\n+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];\n+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];\n                     // URL-SAFE skips the padding to further reduce size.\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n-                        buffer[pos++] = PAD;\n+                        context.buffer[context.pos++] = PAD;\n                     }\n                     break;\n             }\n-            currentLinePos += pos - savedPos; // keep track of current line position\n+            context.currentLinePos += context.pos - savedPos; // keep track of current line position\n             // if currentPos == 0 we are at the start of a line, so don't add CRLF\n-            if (lineLength > 0 && currentLinePos > 0) { \n-                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n-                pos += lineSeparator.length;\n+            if (lineLength > 0 && context.currentLinePos > 0) { \n+                System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);\n+                context.pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n-                ensureBufferSize(encodeSize);\n-                modulus = (modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n+                ensureBufferSize(encodeSize, context);\n+                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n                 int b = in[inPos++];\n                 if (b < 0) {\n                     b += 256;\n                 }\n-                bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE\n-                if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n-                    buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];\n-                    buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];\n-                    buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];\n-                    buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];\n-                    currentLinePos += BYTES_PER_ENCODED_BLOCK;\n-                    if (lineLength > 0 && lineLength <= currentLinePos) {\n-                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n-                        pos += lineSeparator.length;\n-                        currentLinePos = 0;\n+                context.ibitWorkArea = (context.ibitWorkArea << 8) + b; //  BITS_PER_BYTE\n+                if (0 == context.modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];\n+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];\n+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];\n+                    context.buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];\n+                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\n+                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\n+                        System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);\n+                        context.pos += lineSeparator.length;\n+                        context.currentLinePos = 0;\n                     }\n                 }\n             }\n      *            Position to start reading data from.\n      * @param inAvail\n      *            Amount of bytes available from input for encoding.\n+     * @param context the context to be used\n      */\n     @Override\n-    void decode(byte[] in, int inPos, int inAvail) {\n-        if (eof) {\n+    void decode(byte[] in, int inPos, int inAvail, Context context) {\n+        if (context.eof) {\n             return;\n         }\n         if (inAvail < 0) {\n-            eof = true;\n+            context.eof = true;\n         }\n         for (int i = 0; i < inAvail; i++) {\n-            ensureBufferSize(decodeSize);\n+            ensureBufferSize(decodeSize, context);\n             byte b = in[inPos++];\n             if (b == PAD) {\n                 // We're done.\n-                eof = true;\n+                context.eof = true;\n                 break;\n             } else {\n                 if (b >= 0 && b < DECODE_TABLE.length) {\n                     int result = DECODE_TABLE[b];\n                     if (result >= 0) {\n-                        modulus = (modulus+1) % BYTES_PER_ENCODED_BLOCK;\n-                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n-                        if (modulus == 0) {\n-                            buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n-                            buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                            buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);\n+                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n+                        context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n+                        if (context.modulus == 0) {\n+                            context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\n+                            context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n+                            context.buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);\n                         }\n                     }\n                 }\n         // Two forms of EOF as far as base64 decoder is concerned: actual\n         // EOF (-1) and first time '=' character is encountered in stream.\n         // This approach makes the '=' padding characters completely optional.\n-        if (eof && modulus != 0) {\n-            ensureBufferSize(decodeSize);\n+        if (context.eof && context.modulus != 0) {\n+            ensureBufferSize(decodeSize, context);\n             \n             // We have some spare bits remaining\n             // Output all whole multiples of 8 bits and ignore the rest\n-            switch (modulus) {\n+            switch (context.modulus) {\n            //   case 1: // 6 bits - ignore entirely\n            //       break;\n                 case 2 : // 12 bits = 8 + 4\n-                    bitWorkArea = bitWorkArea >> 4; // dump the extra 4 bits\n-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    context.ibitWorkArea = context.ibitWorkArea >> 4; // dump the extra 4 bits\n+                    context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\n                     break;\n                 case 3 : // 18 bits = 8 + 8 + 2\n-                    bitWorkArea = bitWorkArea >> 2; // dump 2 bits\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    context.ibitWorkArea = context.ibitWorkArea >> 2; // dump 2 bits\n+                    context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n+                    context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\n                     break;\n             }\n         }\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n  * Abstract superclass for Base-N encoders and decoders.\n  *\n  * <p>\n- * This class is not thread-safe.\n- * Each thread should use its own instance.\n+ * This class is thread-safe.\n  * </p>\n  */\n public abstract class BaseNCodec implements BinaryEncoder, BinaryDecoder {\n+\n+    /**\n+     * Holds thread context so classes can be thread-safe.\n+     * \n+     * This class is not itself thread-safe; each thread must allocate its own copy.\n+     * \n+     * @since 1.7\n+     */\n+    static class Context {\n+\n+        /**\n+         * Place holder for the bytes we're dealing with for our based logic. \n+         * Bitwise operations store and extract the encoding or decoding from this variable.\n+         */\n+        int ibitWorkArea;\n+\n+        /**\n+         * Place holder for the bytes we're dealing with for our based logic. \n+         * Bitwise operations store and extract the encoding or decoding from this variable.\n+         */\n+        long lbitWorkArea;\n+\n+        /**\n+         * Buffer for streaming.\n+         */\n+        byte[] buffer;\n+\n+        /**\n+         * Position where next character should be written in the buffer.\n+         */\n+        int pos;\n+\n+        /**\n+         * Position where next character should be read from the buffer.\n+         */\n+        int readPos;\n+\n+        /**\n+         * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,\n+         * and must be thrown away.\n+         */\n+        boolean eof;\n+\n+        /**\n+         * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n+         * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n+         */\n+        int currentLinePos;\n+\n+        /**\n+         * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding.\n+         * This variable helps track that.\n+         */\n+        int modulus;\n+\n+        Context() {\n+        }\n+    }\n \n     /**\n      * EOF\n      * Size of chunk separator. Not used unless {@link #lineLength} > 0. \n      */\n     private final int chunkSeparatorLength;\n-\n-    /**\n-     * Buffer for streaming.\n-     */\n-    protected byte[] buffer;\n-\n-    /**\n-     * Position where next character should be written in the buffer.\n-     */\n-    protected int pos;\n-\n-    /**\n-     * Position where next character should be read from the buffer.\n-     */\n-    private int readPos;\n-\n-    /**\n-     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,\n-     * and must be thrown away.\n-     */\n-    protected boolean eof;\n-\n-    /**\n-     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n-     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n-     */\n-    protected int currentLinePos;\n-\n-    /**\n-     * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding.\n-     * This variable helps track that.\n-     */\n-    protected int modulus;\n \n     /**\n      * Note <code>lineLength</code> is rounded down to the nearest multiple of {@link #encodedBlockSize}\n     /**\n      * Returns true if this object has buffered data for reading.\n      *\n+     * @param context the context to be used\n      * @return true if there is data still available for reading.\n      */\n-    boolean hasData() {  // package protected for access from I/O streams\n-        return this.buffer != null;\n+    boolean hasData(Context context) {  // package protected for access from I/O streams\n+        return context.buffer != null;\n     }\n \n     /**\n      * Returns the amount of buffered data available for reading.\n      *\n+     * @param context the context to be used\n      * @return The amount of buffered data available for reading.\n      */\n-    int available() {  // package protected for access from I/O streams\n-        return buffer != null ? pos - readPos : 0;\n+    int available(Context context) {  // package protected for access from I/O streams\n+        return context.buffer != null ? context.pos - context.readPos : 0;\n     }\n \n     /**\n         return DEFAULT_BUFFER_SIZE;\n     }\n \n-    /** Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}. */\n-    private void resizeBuffer() {\n-        if (buffer == null) {\n-            buffer = new byte[getDefaultBufferSize()];\n-            pos = 0;\n-            readPos = 0;\n+    /** \n+     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.\n+     * @param context the context to be used\n+     */\n+    private void resizeBuffer(Context context) {\n+        if (context.buffer == null) {\n+            context.buffer = new byte[getDefaultBufferSize()];\n+            context.pos = 0;\n+            context.readPos = 0;\n         } else {\n-            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n-            System.arraycopy(buffer, 0, b, 0, buffer.length);\n-            buffer = b;\n+            byte[] b = new byte[context.buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n+            System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\n+            context.buffer = b;\n         }\n     }\n \n      * Ensure that the buffer has room for <code>size</code> bytes\n      *\n      * @param size minimum spare space required\n-     */\n-    protected void ensureBufferSize(int size){\n-        if ((buffer == null) || (buffer.length < pos + size)){\n-            resizeBuffer();\n+     * @param context the context to be used\n+     */\n+    protected void ensureBufferSize(int size, Context context){\n+        if ((context.buffer == null) || (context.buffer.length < context.pos + size)){\n+            resizeBuffer(context);\n         }\n     }\n \n      *            position in byte[] array to start extraction at.\n      * @param bAvail\n      *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n+     * @param context the context to be used\n      * @return The number of bytes successfully extracted into the provided byte[] array.\n      */\n-    int readResults(byte[] b, int bPos, int bAvail) {  // package protected for access from I/O streams\n-        if (buffer != null) {\n-            int len = Math.min(available(), bAvail);\n-            System.arraycopy(buffer, readPos, b, bPos, len);\n-            readPos += len;\n-            if (readPos >= pos) {\n-                buffer = null; // so hasData() will return false, and this method can return -1\n+    int readResults(byte[] b, int bPos, int bAvail, Context context) {  // package protected for access from I/O streams\n+        if (context.buffer != null) {\n+            int len = Math.min(available(context), bAvail);\n+            System.arraycopy(context.buffer, context.readPos, b, bPos, len);\n+            context.readPos += len;\n+            if (context.readPos >= context.pos) {\n+                context.buffer = null; // so hasData() will return false, and this method can return -1\n             }\n             return len;\n         }\n-        return eof ? EOF : 0;\n+        return context.eof ? EOF : 0;\n     }\n \n     /**\n     }\n \n     /**\n-     * Resets this object to its initial newly constructed state.\n-     */\n-    private void reset() {\n-        buffer = null;\n-        pos = 0;\n-        readPos = 0;\n-        currentLinePos = 0;\n-        modulus = 0;\n-        eof = false;\n-    }\n-\n-    /**\n      * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of the\n      * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n      *\n      * @return a byte array containing binary data\n      */\n     public byte[] decode(byte[] pArray) {\n-        reset();\n+        Context context = new Context();\n         if (pArray == null || pArray.length == 0) {\n             return pArray;\n         }\n-        decode(pArray, 0, pArray.length);\n-        decode(pArray, 0, EOF); // Notify decoder of EOF.\n-        byte[] result = new byte[pos];\n-        readResults(result, 0, result.length);\n+        decode(pArray, 0, pArray.length, context);\n+        decode(pArray, 0, EOF, context); // Notify decoder of EOF.\n+        byte[] result = new byte[context.pos];\n+        readResults(result, 0, result.length, context);\n         return result;\n     }\n \n      * @return A byte array containing only the basen alphabetic character data\n      */\n     public byte[] encode(byte[] pArray) {\n-        reset();        \n+        Context context = new Context();\n         if (pArray == null || pArray.length == 0) {\n             return pArray;\n         }\n-        encode(pArray, 0, pArray.length);\n-        encode(pArray, 0, EOF); // Notify encoder of EOF.\n-        byte[] buf = new byte[pos - readPos];\n-        readResults(buf, 0, buf.length);\n+        encode(pArray, 0, pArray.length, context);\n+        encode(pArray, 0, EOF, context); // Notify encoder of EOF.\n+        byte[] buf = new byte[context.pos - context.readPos];\n+        readResults(buf, 0, buf.length, context);\n         return buf;\n     }\n     \n         return StringUtils.newStringUtf8(encode(pArray));\n     }\n \n-    abstract void encode(byte[] pArray, int i, int length);  // package protected for access from I/O streams\n-\n-    abstract void decode(byte[] pArray, int i, int length); // package protected for access from I/O streams\n+    abstract void encode(byte[] pArray, int i, int length, Context context);  // package protected for access from I/O streams\n+\n+    abstract void decode(byte[] pArray, int i, int length, Context context); // package protected for access from I/O streams\n     \n     /**\n      * Returns whether or not the <code>octet</code> is in the current alphabet.\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\n import java.io.IOException;\n import java.io.InputStream;\n \n+import org.apache.commons.codec.binary.BaseNCodec.Context;\n+\n /**\n  * Abstract superclass for Base-N input streams.\n  * \n \n     private final byte[] singleByte = new byte[1];\n \n+    private Context context = new Context();\n+\n     protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {\n         super(in);\n         this.doEncode = doEncode;\n         //       data available. As we do not know for sure how much data is left,\n         //       just return 1 as a safe guess.\n \n-        // use the EOF flag of the underlying codec instance\n-        return baseNCodec.eof ? 0 : 1;\n+        return context.eof ? 0 : 1;\n     }\n \n     /**\n              This is a fix for CODEC-101\n             */\n             while (readLen == 0) {\n-                if (!baseNCodec.hasData()) {\n+                if (!baseNCodec.hasData(context)) {\n                     byte[] buf = new byte[doEncode ? 4096 : 8192];\n                     int c = in.read(buf);\n                     if (doEncode) {\n-                        baseNCodec.encode(buf, 0, c);\n+                        baseNCodec.encode(buf, 0, c, context);\n                     } else {\n-                        baseNCodec.decode(buf, 0, c);\n+                        baseNCodec.decode(buf, 0, c, context);\n                     }\n                 }\n-                readLen = baseNCodec.readResults(b, offset, len);\n+                readLen = baseNCodec.readResults(b, offset, len, context);\n             }\n             return readLen;\n         }\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java\n import java.io.IOException;\n import java.io.OutputStream;\n \n+import org.apache.commons.codec.binary.BaseNCodec.Context;\n+\n /**\n  * Abstract superclass for Base-N output streams.\n  * \n \n     private final byte[] singleByte = new byte[1];\n \n+    private Context context = new Context();\n+\n+    // TODO should this be protected?\n     public BaseNCodecOutputStream(OutputStream out, BaseNCodec basedCodec, boolean doEncode) {\n         super(out);\n         this.baseNCodec = basedCodec;\n             throw new IndexOutOfBoundsException();\n         } else if (len > 0) {\n             if (doEncode) {\n-                baseNCodec.encode(b, offset, len);\n+                baseNCodec.encode(b, offset, len, context);\n             } else {\n-                baseNCodec.decode(b, offset, len);\n+                baseNCodec.decode(b, offset, len, context);\n             }\n             flush(false);\n         }\n      *             if an I/O error occurs.\n      */\n     private void flush(boolean propogate) throws IOException {\n-        int avail = baseNCodec.available();\n+        int avail = baseNCodec.available(context);\n         if (avail > 0) {\n             byte[] buf = new byte[avail];\n-            int c = baseNCodec.readResults(buf, 0, avail);\n+            int c = baseNCodec.readResults(buf, 0, avail, context);\n             if (c > 0) {\n                 out.write(buf, 0, c);\n             }\n     public void close() throws IOException {\n         // Notify encoder of EOF (-1).\n         if (doEncode) {\n-            baseNCodec.encode(singleByte, 0, EOF);\n+            baseNCodec.encode(singleByte, 0, EOF, context);\n         } else {\n-            baseNCodec.decode(singleByte, 0, EOF);\n+            baseNCodec.decode(singleByte, 0, EOF, context);\n         }\n         flush();\n         out.close();\n--- a/src/test/java/org/apache/commons/codec/binary/Base32Test.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32Test.java\n     public void testSingleCharEncoding() {\n         for (int i = 0; i < 20; i++) {\n             Base32 codec = new Base32();\n+            BaseNCodec.Context context = new BaseNCodec.Context();\n             byte unencoded[] = new byte[i];\n             byte allInOne[] = codec.encode(unencoded);\n             codec = new Base32();\n             for (int j=0; j< unencoded.length; j++) {\n-                codec.encode(unencoded, j, 1);\n+                codec.encode(unencoded, j, 1, context);\n             }\n-            codec.encode(unencoded, 0, -1);\n+            codec.encode(unencoded, 0, -1, context);\n             byte singly[] = new byte[allInOne.length];\n-            codec.readResults(singly, 0, 100);\n+            codec.readResults(singly, 0, 100, context);\n             if (!Arrays.equals(allInOne, singly)){\n                 fail();\n             }\n--- a/src/test/java/org/apache/commons/codec/binary/BaseNCodecTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/BaseNCodecTest.java\n             }\n             \n             @Override\n-            void encode(byte[] pArray, int i, int length) {\n+            void encode(byte[] pArray, int i, int length, Context context) {\n             }\n             \n             @Override\n-            void decode(byte[] pArray, int i, int length) {\n+            void decode(byte[] pArray, int i, int length, Context context) {\n             }\n         };        \n     }", "timestamp": 1333473835, "metainfo": ""}