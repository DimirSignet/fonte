{"sha": "b29483fc494c5b5cbf2c347685af6ab9a233e43f", "log": "Refactor but do not create new methods (presumably for performance). Start to simplify use of Context and what feels like side-effect programming. Also ends-up reducing line complexity (length) which makes Checksyle happy.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java\n             if (0 == context.modulus && lineLength == 0) {\n                 return; // no leftovers to process and not using chunking\n             }\n-            ensureBufferSize(encodeSize, context);\n+            final byte[] buffer = ensureBufferSize(encodeSize, context);\n             int savedPos = context.pos;\n             switch (context.modulus) { // % 5\n                 case 1 : // Only 1 octet; take top 5 bits then remainder\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; // 5-3=2\n-                    context.buffer[context.pos++] = PAD;\n-                    context.buffer[context.pos++] = PAD;\n-                    context.buffer[context.pos++] = PAD;\n-                    context.buffer[context.pos++] = PAD;\n-                    context.buffer[context.pos++] = PAD;\n-                    context.buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; // 5-3=2\n+                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = PAD;\n                     break;\n \n                 case 2 : // 2 octets = 16 bits to use\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\n-                    context.buffer[context.pos++] = PAD;\n-                    context.buffer[context.pos++] = PAD;\n-                    context.buffer[context.pos++] = PAD;\n-                    context.buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\n+                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = PAD;\n                     break;\n                 case 3 : // 3 octets = 24 bits to use\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\n-                    context.buffer[context.pos++] = PAD;\n-                    context.buffer[context.pos++] = PAD;\n-                    context.buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\n+                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = PAD;\n                     break;\n                 case 4 : // 4 octets = 32 bits to use\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\n-                    context.buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\n+                    buffer[context.pos++] = PAD;\n                     break;\n             }\n             context.currentLinePos += context.pos - savedPos; // keep track of current line position\n             // if currentPos == 0 we are at the start of a line, so don't add CRLF\n             if (lineLength > 0 && context.currentLinePos > 0){ // add chunk separator if required\n-                System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);\n+                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                 context.pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n-                ensureBufferSize(encodeSize, context);\n+                final byte[] buffer = ensureBufferSize(encodeSize, context);\n                 context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n                 int b = in[inPos++];\n                 if (b < 0) {\n                 }\n                 context.lbitWorkArea = (context.lbitWorkArea << 8) + b; // BITS_PER_BYTE\n                 if (0 == context.modulus) { // we have enough bytes to create our output\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];\n-                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];\n-                    context.buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];\n+                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];\n+                    buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];\n                     context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\n                     if (lineLength > 0 && lineLength <= context.currentLinePos) {\n-                        System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);\n+                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\n                         context.pos += lineSeparator.length;\n                         context.currentLinePos = 0;\n                     }\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n      * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.\n      * @param context the context to be used\n      */\n-    private void resizeBuffer(Context context) {\n+    private byte[] resizeBuffer(Context context) {\n         if (context.buffer == null) {\n             context.buffer = new byte[getDefaultBufferSize()];\n             context.pos = 0;\n             System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\n             context.buffer = b;\n         }\n+        return context.buffer;\n     }\n \n     /**\n      * @param size minimum spare space required\n      * @param context the context to be used\n      */\n-    protected void ensureBufferSize(int size, Context context){\n+    protected byte[] ensureBufferSize(int size, Context context){\n         if ((context.buffer == null) || (context.buffer.length < context.pos + size)){\n-            resizeBuffer(context);\n-        }\n+            return resizeBuffer(context);\n+        }\n+        return context.buffer;\n     }\n \n     /**", "timestamp": 1346335014, "metainfo": ""}