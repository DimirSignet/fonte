{"sha": "05f878016d583b58806e59de862fca60e2e69d67", "log": "Statement unnecessarily nested within else clause.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java\n                 // We're done.\n                 context.eof = true;\n                 break;\n-            } else {\n-                final byte[] buffer = ensureBufferSize(decodeSize, context);\n-                if (b >= 0 && b < this.decodeTable.length) {\n-                    final int result = this.decodeTable[b];\n-                    if (result >= 0) {\n-                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n-                        // collect decoded bytes\n-                        context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n-                        if (context.modulus == 0) { // we can output the 5 bytes\n-                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\n-                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n-                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n-                            buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n-                            buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\n-                        }\n+            }\n+            final byte[] buffer = ensureBufferSize(decodeSize, context);\n+            if (b >= 0 && b < this.decodeTable.length) {\n+                final int result = this.decodeTable[b];\n+                if (result >= 0) {\n+                    context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n+                    // collect decoded bytes\n+                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n+                    if (context.modulus == 0) { // we can output the 5 bytes\n+                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\n+                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\n+                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\n+                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\n+                        buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\n                     }\n                 }\n             }\n--- a/src/main/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64.java\n                 // We're done.\n                 context.eof = true;\n                 break;\n-            } else {\n-                if (b >= 0 && b < DECODE_TABLE.length) {\n-                    final int result = DECODE_TABLE[b];\n-                    if (result >= 0) {\n-                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n-                        context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n-                        if (context.modulus == 0) {\n-                            buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\n-                            buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n-                            buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);\n-                        }\n+            }\n+            if (b >= 0 && b < DECODE_TABLE.length) {\n+                final int result = DECODE_TABLE[b];\n+                if (result >= 0) {\n+                    context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\n+                    context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n+                    if (context.modulus == 0) {\n+                        buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\n+                        buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n+                        buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);\n                     }\n                 }\n             }\n--- a/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java\n+++ b/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java\n                     if (parts.length != 2) {\n                         throw new IllegalArgumentException(\"Malformed folding statement split into \" + parts.length +\n                                 \" parts: \" + rawLine + \" in \" + location);\n-                    } else {\n-                        final String leftCharacter = parts[0];\n-                        final String rightCharacter = parts[1];\n-\n-                        if (leftCharacter.length() != 1 || rightCharacter.length() != 1) {\n-                            throw new IllegalArgumentException(\"Malformed folding statement - \" +\n-                                    \"patterns are not single characters: \" + rawLine + \" in \" + location);\n-                        }\n-\n-                        asciiFoldings.put(leftCharacter.charAt(0), rightCharacter.charAt(0));\n-                    }\n+                    }\n+                    final String leftCharacter = parts[0];\n+                    final String rightCharacter = parts[1];\n+\n+                    if (leftCharacter.length() != 1 || rightCharacter.length() != 1) {\n+                        throw new IllegalArgumentException(\"Malformed folding statement - \" +\n+                                \"patterns are not single characters: \" + rawLine + \" in \" + location);\n+                    }\n+\n+                    asciiFoldings.put(leftCharacter.charAt(0), rightCharacter.charAt(0));\n                 } else {\n                     // rule\n                     final String[] parts = line.split(\"\\\\s+\");\n                     if (parts.length != 4) {\n                         throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length +\n                                 \" parts: \" + rawLine + \" in \" + location);\n-                    } else {\n-                        try {\n-                            final String pattern = stripQuotes(parts[0]);\n-                            final String replacement1 = stripQuotes(parts[1]);\n-                            final String replacement2 = stripQuotes(parts[2]);\n-                            final String replacement3 = stripQuotes(parts[3]);\n-\n-                            final Rule r = new Rule(pattern, replacement1, replacement2, replacement3);\n-                            final char patternKey = r.pattern.charAt(0);\n-                            List<Rule> rules = ruleMapping.get(patternKey);\n-                            if (rules == null) {\n-                                rules = new ArrayList<Rule>();\n-                                ruleMapping.put(patternKey, rules);\n-                            }\n-                            rules.add(r);\n-                        } catch (final IllegalArgumentException e) {\n-                            throw new IllegalStateException(\n-                                    \"Problem parsing line '\" + currentLine + \"' in \" + location, e);\n+                    }\n+                    try {\n+                        final String pattern = stripQuotes(parts[0]);\n+                        final String replacement1 = stripQuotes(parts[1]);\n+                        final String replacement2 = stripQuotes(parts[2]);\n+                        final String replacement3 = stripQuotes(parts[3]);\n+\n+                        final Rule r = new Rule(pattern, replacement1, replacement2, replacement3);\n+                        final char patternKey = r.pattern.charAt(0);\n+                        List<Rule> rules = ruleMapping.get(patternKey);\n+                        if (rules == null) {\n+                            rules = new ArrayList<Rule>();\n+                            ruleMapping.put(patternKey, rules);\n                         }\n+                        rules.add(r);\n+                    } catch (final IllegalArgumentException e) {\n+                        throw new IllegalStateException(\n+                                \"Problem parsing line '\" + currentLine + \"' in \" + location, e);\n                     }\n                 }\n             }\n--- a/src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java\n+++ b/src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java\n             final String firstThree = name.substring(0, THREE);\n             final String lastThree = name.substring(nameLength - THREE, nameLength);\n             return firstThree + lastThree;\n-        } else {\n-            return name;\n-        }\n+        }\n+        return name;\n     }\n \n     /**\n         // Final bit - subtract longest string from 6 and return this int value\n         if (strA.length() > strB.length()) {\n             return Math.abs(SIX - strA.length());\n-        } else {\n-            return Math.abs(SIX - strB.length());\n-        }\n+        }\n+        return Math.abs(SIX - strB.length());\n     }\n \n     /**\n         // return isVowel(firstLetter) ? (firstLetter + name) : name;\n         if (isVowel(firstLetter)) {\n             return firstLetter + name;\n-        } else {\n-            return name;\n-        }\n+        }\n+        return name;\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/language/Nysiis.java\n+++ b/src/main/java/org/apache/commons/codec/language/Nysiis.java\n         if (curr == 'K') {\n             if (next == 'N') {\n                 return CHARS_NN;\n-            } else {\n-                return CHARS_C;\n-            }\n+            }\n+            return CHARS_C;\n         }\n \n         // 4. SCH -> SSS\n--- a/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n             final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\n \n             return new Phoneme(before, Languages.LanguageSet.from(langs));\n-        } else {\n-            return new Phoneme(ph, Languages.ANY_LANGUAGE);\n-        }\n+        }\n+        return new Phoneme(ph, Languages.ANY_LANGUAGE);\n     }\n \n     private static PhonemeExpr parsePhonemeExpr(final String ph) {\n             }\n \n             return new PhonemeList(phs);\n-        } else {\n-            return parsePhoneme(ph);\n-        }\n+        }\n+        return parsePhoneme(ph);\n     }\n \n     private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {\n                         if (incl.contains(\" \")) {\n                             throw new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" +\n                                                                location);\n-                        } else {\n-                            lines.putAll(parseRules(createScanner(incl), location + \"->\" + incl));\n                         }\n+                        lines.putAll(parseRules(createScanner(incl), location + \"->\" + incl));\n                     } else {\n                         // rule\n                         final String[] parts = line.split(\"\\\\s+\");\n                         if (parts.length != 4) {\n                             throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length +\n                                                                \" parts: \" + rawLine + \" in \" + location);\n-                        } else {\n-                            try {\n-                                final String pat = stripQuotes(parts[0]);\n-                                final String lCon = stripQuotes(parts[1]);\n-                                final String rCon = stripQuotes(parts[2]);\n-                                final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\n-                                final int cLine = currentLine;\n-                                final Rule r = new Rule(pat, lCon, rCon, ph) {\n-                                    private final int myLine = cLine;\n-                                    private final String loc = location;\n-\n-                                    @Override\n-                                    public String toString() {\n-                                        final StringBuilder sb = new StringBuilder();\n-                                        sb.append(\"Rule\");\n-                                        sb.append(\"{line=\").append(myLine);\n-                                        sb.append(\", loc='\").append(loc).append('\\'');\n-                                        sb.append(\", pat='\").append(pat).append('\\'');\n-                                        sb.append(\", lcon='\").append(lCon).append('\\'');\n-                                        sb.append(\", rcon='\").append(rCon).append('\\'');\n-                                        sb.append('}');\n-                                        return sb.toString();\n-                                    }\n-                                };\n-                                final String patternKey = r.pattern.substring(0,1);\n-                                List<Rule> rules = lines.get(patternKey);\n-                                if (rules == null) {\n-                                    rules = new ArrayList<Rule>();\n-                                    lines.put(patternKey, rules);\n+                        }\n+                        try {\n+                            final String pat = stripQuotes(parts[0]);\n+                            final String lCon = stripQuotes(parts[1]);\n+                            final String rCon = stripQuotes(parts[2]);\n+                            final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\n+                            final int cLine = currentLine;\n+                            final Rule r = new Rule(pat, lCon, rCon, ph) {\n+                                private final int myLine = cLine;\n+                                private final String loc = location;\n+\n+                                @Override\n+                                public String toString() {\n+                                    final StringBuilder sb = new StringBuilder();\n+                                    sb.append(\"Rule\");\n+                                    sb.append(\"{line=\").append(myLine);\n+                                    sb.append(\", loc='\").append(loc).append('\\'');\n+                                    sb.append(\", pat='\").append(pat).append('\\'');\n+                                    sb.append(\", lcon='\").append(lCon).append('\\'');\n+                                    sb.append(\", rcon='\").append(rCon).append('\\'');\n+                                    sb.append('}');\n+                                    return sb.toString();\n                                 }\n-                                rules.add(r);\n-                            } catch (final IllegalArgumentException e) {\n-                                throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" +\n-                                                                location, e);\n+                            };\n+                            final String patternKey = r.pattern.substring(0,1);\n+                            List<Rule> rules = lines.get(patternKey);\n+                            if (rules == null) {\n+                                rules = new ArrayList<Rule>();\n+                                lines.put(patternKey, rules);\n                             }\n+                            rules.add(r);\n+                        } catch (final IllegalArgumentException e) {\n+                            throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" +\n+                                                            location, e);\n                         }\n                     }\n                 }\n                             return input.length() == 0;\n                         }\n                     };\n-                } else {\n-                    return new RPattern() {\n-                        @Override\n-                        public boolean isMatch(final CharSequence input) {\n-                            return input.equals(content);\n-                        }\n-                    };\n                 }\n+                return new RPattern() {\n+                    @Override\n+                    public boolean isMatch(final CharSequence input) {\n+                        return input.equals(content);\n+                    }\n+                };\n             } else if ((startsWith || endsWith) && content.length() == 0) {\n                 // matches every string\n                 return ALL_STRINGS_RMATCHER;\n--- a/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n+++ b/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n                                   final ByteArrayOutputStream buffer) {\n         if (encode) {\n             return encodeQuotedPrintable(b, buffer);\n-        } else {\n-            buffer.write(b);\n-            return 1;\n-        }\n+        }\n+        buffer.write(b);\n+        return 1;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/codec/binary/Codec105ErrorInputStream.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Codec105ErrorInputStream.java\n     public int read() throws IOException {\n         if (this.countdown-- > 0) {\n             return '\\n';\n-        } else {\n-            return EOF;\n         }\n+        return EOF;\n     }\n \n     @Override\n         if (this.countdown-- > 0) {\n             b[pos] = '\\n';\n             return 1;\n-        } else {\n-            return EOF;\n         }\n+        return EOF;\n     }\n }\n--- a/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineRegressionTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineRegressionTest.java\n         */\n         if (languageSet == null) {\n             return engine.encode(input);\n-        } else {\n-            return engine.encode(input, languageSet);\n         }\n+        return engine.encode(input, languageSet);\n     }\n }", "timestamp": 1453079336, "metainfo": ""}