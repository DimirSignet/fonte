{"sha": "ab1ee1b68b15234b62a840c4b1f6d2485d771450", "log": "Use final where possible.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/Charsets.java\n+++ b/src/main/java/org/apache/commons/codec/Charsets.java\n      *            A charset or null.\n      * @return the given Charset or the default Charset if the given Charset is null\n      */\n-    public static Charset toCharset(Charset charset) {\n+    public static Charset toCharset(final Charset charset) {\n         return charset == null ? Charset.defaultCharset() : charset;\n     }\n \n      * @throws java.nio.charset.UnsupportedCharsetException\n      *             If the named charset is unavailable\n      */\n-    public static Charset toCharset(String charset) {\n+    public static Charset toCharset(final String charset) {\n         return charset == null ? Charset.defaultCharset() : Charset.forName(charset);\n     }\n \n--- a/src/main/java/org/apache/commons/codec/DecoderException.java\n+++ b/src/main/java/org/apache/commons/codec/DecoderException.java\n      * @param message\n      *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n      */\n-    public DecoderException(String message) {\n+    public DecoderException(final String message) {\n         super(message);\n     }\n \n      *            value is permitted, and indicates that the cause is nonexistent or unknown.\n      * @since 1.4\n      */\n-    public DecoderException(String message, Throwable cause) {\n+    public DecoderException(final String message, final Throwable cause) {\n         super(message, cause);\n     }\n \n      *            value is permitted, and indicates that the cause is nonexistent or unknown.\n      * @since 1.4\n      */\n-    public DecoderException(Throwable cause) {\n+    public DecoderException(final Throwable cause) {\n         super(cause);\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/StringEncoderComparator.java\n+++ b/src/main/java/org/apache/commons/codec/StringEncoderComparator.java\n      * @param stringEncoder\n      *            the StringEncoder used for comparisons.\n      */\n-    public StringEncoderComparator(StringEncoder stringEncoder) {\n+    public StringEncoderComparator(final StringEncoder stringEncoder) {\n         this.stringEncoder = stringEncoder;\n     }\n \n      * @see Comparable\n      */\n     @Override\n-    public int compare(Object o1, Object o2) {\n+    public int compare(final Object o1, final Object o2) {\n \n         int compareCode = 0;\n \n         try {\n-            Comparable s1 = (Comparable) this.stringEncoder.encode(o1);\n-            Comparable s2 = (Comparable) this.stringEncoder.encode(o2);\n+            final Comparable s1 = (Comparable) this.stringEncoder.encode(o1);\n+            final Comparable s2 = (Comparable) this.stringEncoder.encode(o2);\n             compareCode = s1.compareTo(s2);\n-        } catch (EncoderException ee) {\n+        } catch (final EncoderException ee) {\n             compareCode = 0;\n         }\n         return compareCode;\n--- a/src/main/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java\n      * </p>\n      * @param useHex if {@code true} then use Base32 Hex alphabet\n      */\n-    public Base32(boolean useHex) {\n+    public Base32(final boolean useHex) {\n         this(0, null, useHex);\n     }\n \n      *            8). If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when\n      *            decoding.\n      */\n-    public Base32(int lineLength) {\n+    public Base32(final int lineLength) {\n         this(lineLength, CHUNK_SEPARATOR);\n     }\n \n      * @throws IllegalArgumentException\n      *             The provided lineSeparator included some Base32 characters. That's not going to work!\n      */\n-    public Base32(int lineLength, byte[] lineSeparator) {\n+    public Base32(final int lineLength, final byte[] lineSeparator) {\n         this(lineLength, lineSeparator, false);\n     }\n \n      *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n      *             lineLength > 0 and lineSeparator is null.\n      */\n-    public Base32(int lineLength, byte[] lineSeparator, boolean useHex) {\n+    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n         super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK,\n                 lineLength,\n                 lineSeparator == null ? 0 : lineSeparator.length);\n             }\n             // Must be done after initializing the tables\n             if (containsAlphabetOrPad(lineSeparator)) {\n-                String sep = StringUtils.newStringUtf8(lineSeparator);\n+                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                 throw new IllegalArgumentException(\"lineSeparator must not contain Base32 characters: [\" + sep + \"]\");\n             }\n             this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n      * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position\n      */\n     @Override\n-    void decode(byte[] in, int inPos, int inAvail, Context context) { // package protected for access from I/O streams\n+    void decode(final byte[] in, int inPos, final int inAvail, final Context context) { // package protected for access from I/O streams\n         if (context.eof) {\n             return;\n         }\n      * @param context the context to be used\n      */\n     @Override\n-    void encode(byte[] in, int inPos, int inAvail, Context context) { // package protected for access from I/O streams\n+    void encode(final byte[] in, int inPos, final int inAvail, final Context context) { // package protected for access from I/O streams\n         if (context.eof) {\n             return;\n         }\n      * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.\n      */\n     @Override\n-    public boolean isInAlphabet(byte octet) {\n+    public boolean isInAlphabet(final byte octet) {\n         return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/binary/Base32InputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32InputStream.java\n      * @param in\n      *            InputStream to wrap.\n      */\n-    public Base32InputStream(InputStream in) {\n+    public Base32InputStream(final InputStream in) {\n         this(in, false);\n     }\n \n      * @param doEncode\n      *            true if we should encode all data read from us, false if we should decode.\n      */\n-    public Base32InputStream(InputStream in, boolean doEncode) {\n+    public Base32InputStream(final InputStream in, final boolean doEncode) {\n         super(in, new Base32(false), doEncode);\n     }\n \n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n      *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n-    public Base32InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+    public Base32InputStream(final InputStream in, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {\n         super(in, new Base32(lineLength, lineSeparator), doEncode);\n     }\n \n--- a/src/main/java/org/apache/commons/codec/binary/Base32OutputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32OutputStream.java\n      * @param out\n      *            OutputStream to wrap.\n      */\n-    public Base32OutputStream(OutputStream out) {\n+    public Base32OutputStream(final OutputStream out) {\n         this(out, true);\n     }\n \n      * @param doEncode\n      *            true if we should encode all data written to us, false if we should decode.\n      */\n-    public Base32OutputStream(OutputStream out, boolean doEncode) {\n+    public Base32OutputStream(final OutputStream out, final boolean doEncode) {\n         super(out, new Base32(false), doEncode);\n     }\n \n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n      *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n-    public Base32OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+    public Base32OutputStream(final OutputStream out, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {\n         super(out, new Base32(lineLength, lineSeparator), doEncode);\n     }\n \n--- a/src/main/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64.java\n      *            if {@code true}, URL-safe encoding is used. In most cases this should be set to {@code false}.\n      * @since 1.4\n      */\n-    public Base64(boolean urlSafe) {\n+    public Base64(final boolean urlSafe) {\n         this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n     }\n \n      *            decoding.\n      * @since 1.4\n      */\n-    public Base64(int lineLength) {\n+    public Base64(final int lineLength) {\n         this(lineLength, CHUNK_SEPARATOR);\n     }\n \n      *             Thrown when the provided lineSeparator included some base64 characters.\n      * @since 1.4\n      */\n-    public Base64(int lineLength, byte[] lineSeparator) {\n+    public Base64(final int lineLength, final byte[] lineSeparator) {\n         this(lineLength, lineSeparator, false);\n     }\n \n      *             The provided lineSeparator included some base64 characters. That's not going to work!\n      * @since 1.4\n      */\n-    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n+    public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe) {\n         super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK,\n                 lineLength,\n                 lineSeparator == null ? 0 : lineSeparator.length);\n         // @see test case Base64Test.testConstructors()\n         if (lineSeparator != null) {\n             if (containsAlphabetOrPad(lineSeparator)) {\n-                String sep = StringUtils.newStringUtf8(lineSeparator);\n+                final String sep = StringUtils.newStringUtf8(lineSeparator);\n                 throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n             }\n             if (lineLength > 0){ // null line-sep forces no chunking rather than throwing IAE\n      *            the context to be used\n      */\n     @Override\n-    void encode(byte[] in, int inPos, int inAvail, Context context) {\n+    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\n         if (context.eof) {\n             return;\n         }\n      *            the context to be used\n      */\n     @Override\n-    void decode(byte[] in, int inPos, int inAvail, Context context) {\n+    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\n         if (context.eof) {\n             return;\n         }\n      * @deprecated 1.5 Use {@link #isBase64(byte[])}, will be removed in 2.0.\n      */\n     @Deprecated\n-    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n+    public static boolean isArrayByteBase64(final byte[] arrayOctet) {\n         return isBase64(arrayOctet);\n     }\n \n      * @return {@code true} if the value is defined in the the base 64 alphabet, {@code false} otherwise.\n      * @since 1.4\n      */\n-    public static boolean isBase64(byte octet) {\n+    public static boolean isBase64(final byte octet) {\n         return octet == PAD_DEFAULT || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n     }\n \n      *         the String is empty; {@code false}, otherwise\n      *  @since 1.5\n      */\n-    public static boolean isBase64(String base64) {\n+    public static boolean isBase64(final String base64) {\n         return isBase64(StringUtils.getBytesUtf8(base64));\n     }\n \n      *         {@code false}, otherwise\n      * @since 1.5\n      */\n-    public static boolean isBase64(byte[] arrayOctet) {\n+    public static boolean isBase64(final byte[] arrayOctet) {\n         for (int i = 0; i < arrayOctet.length; i++) {\n             if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                 return false;\n      *            binary data to encode\n      * @return byte[] containing Base64 characters in their UTF-8 representation.\n      */\n-    public static byte[] encodeBase64(byte[] binaryData) {\n+    public static byte[] encodeBase64(final byte[] binaryData) {\n         return encodeBase64(binaryData, false);\n     }\n \n      * @return String containing Base64 characters.\n      * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\n      */\n-    public static String encodeBase64String(byte[] binaryData) {\n+    public static String encodeBase64String(final byte[] binaryData) {\n         return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n     }\n \n      * @return byte[] containing Base64 characters in their UTF-8 representation.\n      * @since 1.4\n      */\n-    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n+    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {\n         return encodeBase64(binaryData, false, true);\n     }\n \n      * @return String containing Base64 characters\n      * @since 1.4\n      */\n-    public static String encodeBase64URLSafeString(byte[] binaryData) {\n+    public static String encodeBase64URLSafeString(final byte[] binaryData) {\n         return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n     }\n \n      *            binary data to encode\n      * @return Base64 characters chunked in 76 character blocks\n      */\n-    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n+    public static byte[] encodeBase64Chunked(final byte[] binaryData) {\n         return encodeBase64(binaryData, true);\n     }\n \n      * @throws IllegalArgumentException\n      *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n      */\n-    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n+    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked) {\n         return encodeBase64(binaryData, isChunked, false);\n     }\n \n      *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n      * @since 1.4\n      */\n-    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n+    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe) {\n         return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n     }\n \n      *             Thrown when the input array needs an output array bigger than maxResultSize\n      * @since 1.4\n      */\n-    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n+    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe, final int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n         // Create this so can use the super-class method\n         // Also ensures that the same roundings are performed by the ctor and the code\n-        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n-        long len = b64.getEncodedLength(binaryData);\n+        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n+        final long len = b64.getEncodedLength(binaryData);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n      * @return Array containing decoded data.\n      * @since 1.4\n      */\n-    public static byte[] decodeBase64(String base64String) {\n+    public static byte[] decodeBase64(final String base64String) {\n         return new Base64().decode(base64String);\n     }\n \n      *            Byte array containing Base64 data\n      * @return Array containing decoded data.\n      */\n-    public static byte[] decodeBase64(byte[] base64Data) {\n+    public static byte[] decodeBase64(final byte[] base64Data) {\n         return new Base64().decode(base64Data);\n     }\n \n      * @return A BigInteger\n      * @since 1.4\n      */\n-    public static BigInteger decodeInteger(byte[] pArray) {\n+    public static BigInteger decodeInteger(final byte[] pArray) {\n         return new BigInteger(1, decodeBase64(pArray));\n     }\n \n      *             if null is passed in\n      * @since 1.4\n      */\n-    public static byte[] encodeInteger(BigInteger bigInt) {\n+    public static byte[] encodeInteger(final BigInteger bigInt) {\n         if (bigInt == null) {\n             throw new NullPointerException(\"encodeInteger called with null parameter\");\n         }\n      *            <code>BigInteger</code> to be converted\n      * @return a byte array representation of the BigInteger parameter\n      */\n-    static byte[] toIntegerBytes(BigInteger bigInt) {\n+    static byte[] toIntegerBytes(final BigInteger bigInt) {\n         int bitlen = bigInt.bitLength();\n         // round bitlen\n         bitlen = ((bitlen + 7) >> 3) << 3;\n-        byte[] bigBytes = bigInt.toByteArray();\n+        final byte[] bigBytes = bigInt.toByteArray();\n \n         if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n             return bigBytes;\n             startSrc = 1;\n             len--;\n         }\n-        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n-        byte[] resizedBytes = new byte[bitlen / 8];\n+        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n+        final byte[] resizedBytes = new byte[bitlen / 8];\n         System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n         return resizedBytes;\n     }\n      * @return {@code true} if the value is defined in the the Base64 alphabet {@code false} otherwise.\n      */\n     @Override\n-    protected boolean isInAlphabet(byte octet) {\n+    protected boolean isInAlphabet(final byte octet) {\n         return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n     }\n \n--- a/src/main/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64InputStream.java\n      * @param in\n      *            InputStream to wrap.\n      */\n-    public Base64InputStream(InputStream in) {\n+    public Base64InputStream(final InputStream in) {\n         this(in, false);\n     }\n \n      * @param doEncode\n      *            true if we should encode all data read from us, false if we should decode.\n      */\n-    public Base64InputStream(InputStream in, boolean doEncode) {\n+    public Base64InputStream(final InputStream in, final boolean doEncode) {\n         super(in, new Base64(false), doEncode);\n     }\n \n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n      *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n-    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+    public Base64InputStream(final InputStream in, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {\n         super(in, new Base64(lineLength, lineSeparator), doEncode);\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64OutputStream.java\n      * @param out\n      *            OutputStream to wrap.\n      */\n-    public Base64OutputStream(OutputStream out) {\n+    public Base64OutputStream(final OutputStream out) {\n         this(out, true);\n     }\n \n      * @param doEncode\n      *            true if we should encode all data written to us, false if we should decode.\n      */\n-    public Base64OutputStream(OutputStream out, boolean doEncode) {\n+    public Base64OutputStream(final OutputStream out, final boolean doEncode) {\n         super(out,new Base64(false), doEncode);\n     }\n \n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n      *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n-    public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+    public Base64OutputStream(final OutputStream out, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {\n         super(out, new Base64(lineLength, lineSeparator), doEncode);\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n      * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\n      * @param chunkSeparatorLength the chunk separator length, if relevant\n      */\n-    protected BaseNCodec(int unencodedBlockSize, int encodedBlockSize, int lineLength, int chunkSeparatorLength) {\n+    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength) {\n         this.unencodedBlockSize = unencodedBlockSize;\n         this.encodedBlockSize = encodedBlockSize;\n         final boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\n      * @param context the context to be used\n      * @return true if there is data still available for reading.\n      */\n-    boolean hasData(Context context) {  // package protected for access from I/O streams\n+    boolean hasData(final Context context) {  // package protected for access from I/O streams\n         return context.buffer != null;\n     }\n \n      * @param context the context to be used\n      * @return The amount of buffered data available for reading.\n      */\n-    int available(Context context) {  // package protected for access from I/O streams\n+    int available(final Context context) {  // package protected for access from I/O streams\n         return context.buffer != null ? context.pos - context.readPos : 0;\n     }\n \n      * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.\n      * @param context the context to be used\n      */\n-    private byte[] resizeBuffer(Context context) {\n+    private byte[] resizeBuffer(final Context context) {\n         if (context.buffer == null) {\n             context.buffer = new byte[getDefaultBufferSize()];\n             context.pos = 0;\n             context.readPos = 0;\n         } else {\n-            byte[] b = new byte[context.buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n+            final byte[] b = new byte[context.buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n             System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\n             context.buffer = b;\n         }\n      * @param size minimum spare space required\n      * @param context the context to be used\n      */\n-    protected byte[] ensureBufferSize(int size, Context context){\n+    protected byte[] ensureBufferSize(final int size, final Context context){\n         if ((context.buffer == null) || (context.buffer.length < context.pos + size)){\n             return resizeBuffer(context);\n         }\n      *            the context to be used\n      * @return The number of bytes successfully extracted into the provided byte[] array.\n      */\n-    int readResults(byte[] b, int bPos, int bAvail, Context context) {\n+    int readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {\n         if (context.buffer != null) {\n-            int len = Math.min(available(context), bAvail);\n+            final int len = Math.min(available(context), bAvail);\n             System.arraycopy(context.buffer, context.readPos, b, bPos, len);\n             context.readPos += len;\n             if (context.readPos >= context.pos) {\n      *            the byte to check\n      * @return true if byte is whitespace, false otherwise\n      */\n-    protected static boolean isWhiteSpace(byte byteToCheck) {\n+    protected static boolean isWhiteSpace(final byte byteToCheck) {\n         switch (byteToCheck) {\n             case ' ' :\n             case '\\n' :\n      *             if the parameter supplied is not of type byte[]\n      */\n     @Override\n-    public Object encode(Object obj) throws EncoderException {\n+    public Object encode(final Object obj) throws EncoderException {\n         if (!(obj instanceof byte[])) {\n             throw new EncoderException(\"Parameter supplied to Base-N encode is not a byte[]\");\n         }\n      *            a byte array containing binary data\n      * @return A String containing only Base-N character data\n      */\n-    public String encodeToString(byte[] pArray) {\n+    public String encodeToString(final byte[] pArray) {\n         return StringUtils.newStringUtf8(encode(pArray));\n     }\n \n      * @param pArray a byte array containing binary data\n      * @return String containing only character data in the appropriate alphabet.\n     */\n-    public String encodeAsString(byte[] pArray){\n+    public String encodeAsString(final byte[] pArray){\n         return StringUtils.newStringUtf8(encode(pArray));\n     }\n \n      *             if the parameter supplied is not of type byte[]\n      */\n     @Override\n-    public Object decode(Object obj) throws DecoderException {\n+    public Object decode(final Object obj) throws DecoderException {\n         if (obj instanceof byte[]) {\n             return decode((byte[]) obj);\n         } else if (obj instanceof String) {\n      *            A String containing Base-N character data\n      * @return a byte array containing binary data\n      */\n-    public byte[] decode(String pArray) {\n+    public byte[] decode(final String pArray) {\n         return decode(StringUtils.getBytesUtf8(pArray));\n     }\n \n      * @return a byte array containing binary data\n      */\n     @Override\n-    public byte[] decode(byte[] pArray) {\n+    public byte[] decode(final byte[] pArray) {\n         if (pArray == null || pArray.length == 0) {\n             return pArray;\n         }\n-        Context context = new Context();\n+        final Context context = new Context();\n         decode(pArray, 0, pArray.length, context);\n         decode(pArray, 0, EOF, context); // Notify decoder of EOF.\n-        byte[] result = new byte[context.pos];\n+        final byte[] result = new byte[context.pos];\n         readResults(result, 0, result.length, context);\n         return result;\n     }\n      * @return A byte array containing only the basen alphabetic character data\n      */\n     @Override\n-    public byte[] encode(byte[] pArray) {\n+    public byte[] encode(final byte[] pArray) {\n         if (pArray == null || pArray.length == 0) {\n             return pArray;\n         }\n-        Context context = new Context();\n+        final Context context = new Context();\n         encode(pArray, 0, pArray.length, context);\n         encode(pArray, 0, EOF, context); // Notify encoder of EOF.\n-        byte[] buf = new byte[context.pos - context.readPos];\n+        final byte[] buf = new byte[context.pos - context.readPos];\n         readResults(buf, 0, buf.length, context);\n         return buf;\n     }\n      * @return {@code true} if all bytes are valid characters in the alphabet or if the byte array is empty;\n      *         {@code false}, otherwise\n      */\n-    public boolean isInAlphabet(byte[] arrayOctet, boolean allowWSPad) {\n+    public boolean isInAlphabet(final byte[] arrayOctet, final boolean allowWSPad) {\n         for (int i = 0; i < arrayOctet.length; i++) {\n             if (!isInAlphabet(arrayOctet[i]) &&\n                     (!allowWSPad || (arrayOctet[i] != PAD) && !isWhiteSpace(arrayOctet[i]))) {\n      *         the String is empty; {@code false}, otherwise\n      * @see #isInAlphabet(byte[], boolean)\n      */\n-    public boolean isInAlphabet(String basen) {\n+    public boolean isInAlphabet(final String basen) {\n         return isInAlphabet(StringUtils.getBytesUtf8(basen), true);\n     }\n \n      *            byte array to test\n      * @return {@code true} if any byte is a valid character in the alphabet or PAD; {@code false} otherwise\n      */\n-    protected boolean containsAlphabetOrPad(byte[] arrayOctet) {\n+    protected boolean containsAlphabetOrPad(final byte[] arrayOctet) {\n         if (arrayOctet == null) {\n             return false;\n         }\n-        for (byte element : arrayOctet) {\n+        for (final byte element : arrayOctet) {\n             if (PAD == element || isInAlphabet(element)) {\n                 return true;\n             }\n      * @return amount of space needed to encoded the supplied array.\n      * Returns a long since a max-len array will require > Integer.MAX_VALUE\n      */\n-    public long getEncodedLength(byte[] pArray) {\n+    public long getEncodedLength(final byte[] pArray) {\n         // Calculate non-chunked size - rounded up to allow for padding\n         // cast to long is needed to avoid possibility of overflow\n         long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * (long) encodedBlockSize;\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\n \n     private final Context context = new Context();\n \n-    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {\n+    protected BaseNCodecInputStream(final InputStream in, final BaseNCodec baseNCodec, final boolean doEncode) {\n         super(in);\n         this.doEncode = doEncode;\n         this.baseNCodec = baseNCodec;\n      * @since 1.7\n      */\n     @Override\n-    public synchronized void mark(int readLimit) {\n+    public synchronized void mark(final int readLimit) {\n     }\n \n     /**\n      *             if offset, len or buffer size are invalid\n      */\n     @Override\n-    public int read(byte b[], int offset, int len) throws IOException {\n+    public int read(final byte b[], final int offset, final int len) throws IOException {\n         if (b == null) {\n             throw new NullPointerException();\n         } else if (offset < 0 || len < 0) {\n             */\n             while (readLen == 0) {\n                 if (!baseNCodec.hasData(context)) {\n-                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n-                    int c = in.read(buf);\n+                    final byte[] buf = new byte[doEncode ? 4096 : 8192];\n+                    final int c = in.read(buf);\n                     if (doEncode) {\n                         baseNCodec.encode(buf, 0, c, context);\n                     } else {\n      * @since 1.7\n      */\n     @Override\n-    public long skip(long n) throws IOException {\n+    public long skip(final long n) throws IOException {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"Negative skip length: \" + n);\n         }\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java\n     private final Context context = new Context();\n \n     // TODO should this be protected?\n-    public BaseNCodecOutputStream(OutputStream out, BaseNCodec basedCodec, boolean doEncode) {\n+    public BaseNCodecOutputStream(final OutputStream out, final BaseNCodec basedCodec, final boolean doEncode) {\n         super(out);\n         this.baseNCodec = basedCodec;\n         this.doEncode = doEncode;\n      *             if an I/O error occurs.\n      */\n     @Override\n-    public void write(int i) throws IOException {\n+    public void write(final int i) throws IOException {\n         singleByte[0] = (byte) i;\n         write(singleByte, 0, 1);\n     }\n      *             if offset, len or buffer size are invalid\n      */\n     @Override\n-    public void write(byte b[], int offset, int len) throws IOException {\n+    public void write(final byte b[], final int offset, final int len) throws IOException {\n         if (b == null) {\n             throw new NullPointerException();\n         } else if (offset < 0 || len < 0) {\n      * @throws IOException\n      *             if an I/O error occurs.\n      */\n-    private void flush(boolean propogate) throws IOException {\n-        int avail = baseNCodec.available(context);\n+    private void flush(final boolean propogate) throws IOException {\n+        final int avail = baseNCodec.available(context);\n         if (avail > 0) {\n-            byte[] buf = new byte[avail];\n-            int c = baseNCodec.readResults(buf, 0, avail, context);\n+            final byte[] buf = new byte[avail];\n+            final int c = baseNCodec.readResults(buf, 0, avail, context);\n             if (c > 0) {\n                 out.write(buf, 0, c);\n             }\n--- a/src/main/java/org/apache/commons/codec/binary/BinaryCodec.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BinaryCodec.java\n      * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n      */\n     @Override\n-    public byte[] encode(byte[] raw) {\n+    public byte[] encode(final byte[] raw) {\n         return toAsciiBytes(raw);\n     }\n \n      * @see org.apache.commons.codec.Encoder#encode(Object)\n      */\n     @Override\n-    public Object encode(Object raw) throws EncoderException {\n+    public Object encode(final Object raw) throws EncoderException {\n         if (!(raw instanceof byte[])) {\n             throw new EncoderException(\"argument not a byte array\");\n         }\n      * @see org.apache.commons.codec.Decoder#decode(Object)\n      */\n     @Override\n-    public Object decode(Object ascii) throws DecoderException {\n+    public Object decode(final Object ascii) throws DecoderException {\n         if (ascii == null) {\n             return EMPTY_BYTE_ARRAY;\n         }\n      * @see org.apache.commons.codec.Decoder#decode(Object)\n      */\n     @Override\n-    public byte[] decode(byte[] ascii) {\n+    public byte[] decode(final byte[] ascii) {\n         return fromAscii(ascii);\n     }\n \n      * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n      * @see org.apache.commons.codec.Decoder#decode(Object)\n      */\n-    public byte[] toByteArray(String ascii) {\n+    public byte[] toByteArray(final String ascii) {\n         if (ascii == null) {\n             return EMPTY_BYTE_ARRAY;\n         }\n      *                  each char represents an ASCII '0' or '1'\n      * @return the raw encoded binary where each bit corresponds to a char in the char array argument\n      */\n-    public static byte[] fromAscii(char[] ascii) {\n+    public static byte[] fromAscii(final char[] ascii) {\n         if (ascii == null || ascii.length == 0) {\n             return EMPTY_BYTE_ARRAY;\n         }\n         // get length/8 times bytes with 3 bit shifts to the right of the length\n-        byte[] l_raw = new byte[ascii.length >> 3];\n+        final byte[] l_raw = new byte[ascii.length >> 3];\n         /*\n          * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n          * loop.\n      *                  each byte represents an ASCII '0' or '1'\n      * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n      */\n-    public static byte[] fromAscii(byte[] ascii) {\n+    public static byte[] fromAscii(final byte[] ascii) {\n         if (isEmpty(ascii)) {\n             return EMPTY_BYTE_ARRAY;\n         }\n         // get length/8 times bytes with 3 bit shifts to the right of the length\n-        byte[] l_raw = new byte[ascii.length >> 3];\n+        final byte[] l_raw = new byte[ascii.length >> 3];\n         /*\n          * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n          * loop.\n      *            the source array\n      * @return {@code true} if the given array is {@code null} or empty (size 0.)\n      */\n-    private static boolean isEmpty(byte[] array) {\n+    private static boolean isEmpty(final byte[] array) {\n         return array == null || array.length == 0;\n     }\n \n      * @return an array of 0 and 1 character bytes for each bit of the argument\n      * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n      */\n-    public static byte[] toAsciiBytes(byte[] raw) {\n+    public static byte[] toAsciiBytes(final byte[] raw) {\n         if (isEmpty(raw)) {\n             return EMPTY_BYTE_ARRAY;\n         }\n         // get 8 times the bytes with 3 bit shifts to the left of the length\n-        byte[] l_ascii = new byte[raw.length << 3];\n+        final byte[] l_ascii = new byte[raw.length << 3];\n         /*\n          * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n          * loop.\n      * @return an array of 0 and 1 characters for each bit of the argument\n      * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n      */\n-    public static char[] toAsciiChars(byte[] raw) {\n+    public static char[] toAsciiChars(final byte[] raw) {\n         if (isEmpty(raw)) {\n             return EMPTY_CHAR_ARRAY;\n         }\n         // get 8 times the bytes with 3 bit shifts to the left of the length\n-        char[] l_ascii = new char[raw.length << 3];\n+        final char[] l_ascii = new char[raw.length << 3];\n         /*\n          * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n          * loop.\n      * @return a String of 0 and 1 characters representing the binary data\n      * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n      */\n-    public static String toAsciiString(byte[] raw) {\n+    public static String toAsciiString(final byte[] raw) {\n         return new String(toAsciiChars(raw));\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/binary/Hex.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Hex.java\n      * @throws DecoderException\n      *             Thrown if an odd number or illegal of characters is supplied\n      */\n-    public static byte[] decodeHex(char[] data) throws DecoderException {\n-\n-        int len = data.length;\n+    public static byte[] decodeHex(final char[] data) throws DecoderException {\n+\n+        final int len = data.length;\n \n         if ((len & 0x01) != 0) {\n             throw new DecoderException(\"Odd number of characters.\");\n         }\n \n-        byte[] out = new byte[len >> 1];\n+        final byte[] out = new byte[len >> 1];\n \n         // two characters form the hex value.\n         for (int i = 0, j = 0; j < len; i++) {\n      *            a byte[] to convert to Hex characters\n      * @return A char[] containing hexadecimal characters\n      */\n-    public static char[] encodeHex(byte[] data) {\n+    public static char[] encodeHex(final byte[] data) {\n         return encodeHex(data, true);\n     }\n \n      * @return A char[] containing hexadecimal characters\n      * @since 1.4\n      */\n-    public static char[] encodeHex(byte[] data, boolean toLowerCase) {\n+    public static char[] encodeHex(final byte[] data, final boolean toLowerCase) {\n         return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\n     }\n \n      * @return A char[] containing hexadecimal characters\n      * @since 1.4\n      */\n-    protected static char[] encodeHex(byte[] data, char[] toDigits) {\n-        int l = data.length;\n-        char[] out = new char[l << 1];\n+    protected static char[] encodeHex(final byte[] data, final char[] toDigits) {\n+        final int l = data.length;\n+        final char[] out = new char[l << 1];\n         // two characters form the hex value.\n         for (int i = 0, j = 0; i < l; i++) {\n             out[j++] = toDigits[(0xF0 & data[i]) >>> 4];\n      * @return A String containing hexadecimal characters\n      * @since 1.4\n      */\n-    public static String encodeHexString(byte[] data) {\n+    public static String encodeHexString(final byte[] data) {\n         return new String(encodeHex(data));\n     }\n \n      * @throws DecoderException\n      *             Thrown if ch is an illegal hex character\n      */\n-    protected static int toDigit(char ch, int index) throws DecoderException {\n-        int digit = Character.digit(ch, 16);\n+    protected static int toDigit(final char ch, final int index) throws DecoderException {\n+        final int digit = Character.digit(ch, 16);\n         if (digit == -1) {\n             throw new DecoderException(\"Illegal hexadecimal character \" + ch + \" at index \" + index);\n         }\n      *            the charset.\n      * @since 1.7\n      */\n-    public Hex(Charset charset) {\n+    public Hex(final Charset charset) {\n         this.charset = charset;\n     }\n \n      * @since 1.4\n      * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n      */\n-    public Hex(String charsetName) {\n+    public Hex(final String charsetName) {\n         this(Charset.forName(charsetName));\n     }\n \n      * @see #decodeHex(char[])\n      */\n     @Override\n-    public byte[] decode(byte[] array) throws DecoderException {\n+    public byte[] decode(final byte[] array) throws DecoderException {\n         return decodeHex(new String(array, getCharset()).toCharArray());\n     }\n \n      * @see #decodeHex(char[])\n      */\n     @Override\n-    public Object decode(Object object) throws DecoderException {\n+    public Object decode(final Object object) throws DecoderException {\n         try {\n-            char[] charArray = object instanceof String ? ((String) object).toCharArray() : (char[]) object;\n+            final char[] charArray = object instanceof String ? ((String) object).toCharArray() : (char[]) object;\n             return decodeHex(charArray);\n-        } catch (ClassCastException e) {\n+        } catch (final ClassCastException e) {\n             throw new DecoderException(e.getMessage(), e);\n         }\n     }\n      * @see #encodeHex(byte[])\n      */\n     @Override\n-    public byte[] encode(byte[] array) {\n+    public byte[] encode(final byte[] array) {\n         return encodeHexString(array).getBytes(this.getCharset());\n     }\n \n      * @see #encodeHex(byte[])\n      */\n     @Override\n-    public Object encode(Object object) throws EncoderException {\n+    public Object encode(final Object object) throws EncoderException {\n         try {\n-            byte[] byteArray = object instanceof String ?\n+            final byte[] byteArray = object instanceof String ?\n                                    ((String) object).getBytes(this.getCharset()) : (byte[]) object;\n             return encodeHex(byteArray);\n-        } catch (ClassCastException e) {\n+        } catch (final ClassCastException e) {\n             throw new EncoderException(e.getMessage(), e);\n         }\n     }\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n      *            The {@link Charset} to encode the {@code String}\n      * @return the encoded bytes\n      */\n-    private static byte[] getBytes(String string, Charset charset) {\n+    private static byte[] getBytes(final String string, final Charset charset) {\n         if (string == null) {\n             return null;\n         }\n      * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n      * @see #getBytesUnchecked(String, String)\n      */\n-    public static byte[] getBytesIso8859_1(String string) {\n+    public static byte[] getBytesIso8859_1(final String string) {\n         return getBytes(string, Charsets.ISO_8859_1);\n     }\n \n      * @see CharEncoding\n      * @see String#getBytes(String)\n      */\n-    public static byte[] getBytesUnchecked(String string, String charsetName) {\n+    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\n         if (string == null) {\n             return null;\n         }\n         try {\n             return string.getBytes(charsetName);\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw StringUtils.newIllegalStateException(charsetName, e);\n         }\n     }\n      * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n      * @see #getBytesUnchecked(String, String)\n      */\n-    public static byte[] getBytesUsAscii(String string) {\n+    public static byte[] getBytesUsAscii(final String string) {\n         return getBytes(string, Charsets.US_ASCII);\n     }\n \n      * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n      * @see #getBytesUnchecked(String, String)\n      */\n-    public static byte[] getBytesUtf16(String string) {\n+    public static byte[] getBytesUtf16(final String string) {\n         return getBytes(string, Charsets.UTF_16);\n     }\n \n      * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n      * @see #getBytesUnchecked(String, String)\n      */\n-    public static byte[] getBytesUtf16Be(String string) {\n+    public static byte[] getBytesUtf16Be(final String string) {\n         return getBytes(string, Charsets.UTF_16BE);\n     }\n \n      * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n      * @see #getBytesUnchecked(String, String)\n      */\n-    public static byte[] getBytesUtf16Le(String string) {\n+    public static byte[] getBytesUtf16Le(final String string) {\n         return getBytes(string, Charsets.UTF_16LE);\n     }\n \n      * @see <a href=\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n      * @see #getBytesUnchecked(String, String)\n      */\n-    public static byte[] getBytesUtf8(String string) {\n+    public static byte[] getBytesUtf8(final String string) {\n         return getBytes(string, Charsets.UTF_8);\n     }\n \n-    private static IllegalStateException newIllegalStateException(String charsetName, UnsupportedEncodingException e) {\n+    private static IllegalStateException newIllegalStateException(final String charsetName, final UnsupportedEncodingException e) {\n         return new IllegalStateException(charsetName + \": \" + e);\n     }\n \n      *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      */\n-    private static String newString(byte[] bytes, Charset charset) {\n+    private static String newString(final byte[] bytes, final Charset charset) {\n         return bytes == null ? null : new String(bytes, charset);\n     }\n \n      * @see CharEncoding\n      * @see String#String(byte[], String)\n      */\n-    public static String newString(byte[] bytes, String charsetName) {\n+    public static String newString(final byte[] bytes, final String charsetName) {\n         if (bytes == null) {\n             return null;\n         }\n         try {\n             return new String(bytes, charsetName);\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw StringUtils.newIllegalStateException(charsetName, e);\n         }\n     }\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n-    public static String newStringIso8859_1(byte[] bytes) {\n+    public static String newStringIso8859_1(final byte[] bytes) {\n         return new String(bytes, Charsets.ISO_8859_1);\n     }\n \n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n-    public static String newStringUsAscii(byte[] bytes) {\n+    public static String newStringUsAscii(final byte[] bytes) {\n         return new String(bytes, Charsets.US_ASCII);\n     }\n \n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n-    public static String newStringUtf16(byte[] bytes) {\n+    public static String newStringUtf16(final byte[] bytes) {\n         return new String(bytes, Charsets.UTF_16);\n     }\n \n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n-    public static String newStringUtf16Be(byte[] bytes) {\n+    public static String newStringUtf16Be(final byte[] bytes) {\n         return new String(bytes, Charsets.UTF_16BE);\n     }\n \n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n-    public static String newStringUtf16Le(byte[] bytes) {\n+    public static String newStringUtf16Le(final byte[] bytes) {\n         return new String(bytes, Charsets.UTF_16LE);\n     }\n \n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n-    public static String newStringUtf8(byte[] bytes) {\n+    public static String newStringUtf8(final byte[] bytes) {\n         return newString(bytes, Charsets.UTF_8);\n     }\n \n--- a/src/main/java/org/apache/commons/codec/digest/B64.java\n+++ b/src/main/java/org/apache/commons/codec/digest/B64.java\n      * @param buffer\n      *            Where the output chars is appended to.\n      */\n-    static void b64from24bit(byte b2, byte b1, byte b0, int outLen, StringBuilder buffer) {\n+    static void b64from24bit(final byte b2, final byte b1, final byte b0, final int outLen, final StringBuilder buffer) {\n         // The bit masking is necessary because the JVM byte type is signed!\n         int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff);\n         // It's effectively a \"for\" loop but kept to resemble the original C code.\n      * @param num\n      *            Number of chars to generate.\n      */\n-    static String getRandomSalt(int num) {\n-        StringBuilder saltString = new StringBuilder();\n+    static String getRandomSalt(final int num) {\n+        final StringBuilder saltString = new StringBuilder();\n         for (int i = 1; i <= num; i++) {\n             saltString.append(B64T.charAt(new Random().nextInt(B64T.length())));\n         }\n--- a/src/main/java/org/apache/commons/codec/digest/Crypt.java\n+++ b/src/main/java/org/apache/commons/codec/digest/Crypt.java\n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n-    public static String crypt(byte[] keyBytes) {\n+    public static String crypt(final byte[] keyBytes) {\n         return crypt(keyBytes, null);\n     }\n \n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n-    public static String crypt(byte[] keyBytes, String salt) {\n+    public static String crypt(final byte[] keyBytes, final String salt) {\n         if (salt == null) {\n             return Sha2Crypt.sha512Crypt(keyBytes);\n         } else if (salt.startsWith(Sha2Crypt.SHA512_PREFIX)) {\n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n-    public static String crypt(String key) {\n+    public static String crypt(final String key) {\n         return crypt(key, null);\n     }\n \n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught. *\n      */\n-    public static String crypt(String key, String salt) {\n+    public static String crypt(final String key, final String salt) {\n         return crypt(key.getBytes(Charsets.UTF_8), salt);\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/digest/DigestUtils.java\n+++ b/src/main/java/org/apache/commons/codec/digest/DigestUtils.java\n      * @throws IOException\n      *             On error reading from the stream\n      */\n-    private static byte[] digest(MessageDigest digest, InputStream data) throws IOException {\n-        byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n+    private static byte[] digest(final MessageDigest digest, final InputStream data) throws IOException {\n+        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n         int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n \n         while (read > -1) {\n      * @throws IllegalArgumentException\n      *             when a {@link NoSuchAlgorithmException} is caught.\n      */\n-    public static MessageDigest getDigest(String algorithm) {\n+    public static MessageDigest getDigest(final String algorithm) {\n         try {\n             return MessageDigest.getInstance(algorithm);\n-        } catch (NoSuchAlgorithmException e) {\n+        } catch (final NoSuchAlgorithmException e) {\n             throw new IllegalArgumentException(e);\n         }\n     }\n      * @return MD2 digest\n      * @since 1.7\n      */\n-    public static byte[] md2(byte[] data) {\n+    public static byte[] md2(final byte[] data) {\n         return getMd2Digest().digest(data);\n     }\n \n      *             On error reading from the stream\n      * @since 1.7\n      */\n-    public static byte[] md2(InputStream data) throws IOException {\n+    public static byte[] md2(final InputStream data) throws IOException {\n         return digest(getMd2Digest(), data);\n     }\n \n      * @return MD2 digest\n      * @since 1.7\n      */\n-    public static byte[] md2(String data) {\n+    public static byte[] md2(final String data) {\n         return md2(StringUtils.getBytesUtf8(data));\n     }\n \n      * @return MD2 digest as a hex string\n      * @since 1.7\n      */\n-    public static String md2Hex(byte[] data) {\n+    public static String md2Hex(final byte[] data) {\n         return Hex.encodeHexString(md2(data));\n     }\n \n      *             On error reading from the stream\n      * @since 1.7\n      */\n-    public static String md2Hex(InputStream data) throws IOException {\n+    public static String md2Hex(final InputStream data) throws IOException {\n         return Hex.encodeHexString(md2(data));\n     }\n \n      * @return MD2 digest as a hex string\n      * @since 1.7\n      */\n-    public static String md2Hex(String data) {\n+    public static String md2Hex(final String data) {\n         return Hex.encodeHexString(md2(data));\n     }\n \n      *            Data to digest\n      * @return MD5 digest\n      */\n-    public static byte[] md5(byte[] data) {\n+    public static byte[] md5(final byte[] data) {\n         return getMd5Digest().digest(data);\n     }\n \n      *             On error reading from the stream\n      * @since 1.4\n      */\n-    public static byte[] md5(InputStream data) throws IOException {\n+    public static byte[] md5(final InputStream data) throws IOException {\n         return digest(getMd5Digest(), data);\n     }\n \n      *            Data to digest\n      * @return MD5 digest\n      */\n-    public static byte[] md5(String data) {\n+    public static byte[] md5(final String data) {\n         return md5(StringUtils.getBytesUtf8(data));\n     }\n \n      *            Data to digest\n      * @return MD5 digest as a hex string\n      */\n-    public static String md5Hex(byte[] data) {\n+    public static String md5Hex(final byte[] data) {\n         return Hex.encodeHexString(md5(data));\n     }\n \n      *             On error reading from the stream\n      * @since 1.4\n      */\n-    public static String md5Hex(InputStream data) throws IOException {\n+    public static String md5Hex(final InputStream data) throws IOException {\n         return Hex.encodeHexString(md5(data));\n     }\n \n      *            Data to digest\n      * @return MD5 digest as a hex string\n      */\n-    public static String md5Hex(String data) {\n+    public static String md5Hex(final String data) {\n         return Hex.encodeHexString(md5(data));\n     }\n \n      * @deprecated Use {@link #sha1(byte[])}\n      */\n     @Deprecated\n-    public static byte[] sha(byte[] data) {\n+    public static byte[] sha(final byte[] data) {\n         return sha1(data);\n     }\n \n      * @deprecated Use {@link #sha1(InputStream)}\n      */\n     @Deprecated\n-    public static byte[] sha(InputStream data) throws IOException {\n+    public static byte[] sha(final InputStream data) throws IOException {\n         return sha1(data);\n     }\n \n      * @deprecated Use {@link #sha1(String)}\n      */\n     @Deprecated\n-    public static byte[] sha(String data) {\n+    public static byte[] sha(final String data) {\n         return sha1(data);\n     }\n \n      * @return SHA-1 digest\n      * @since 1.7\n      */\n-    public static byte[] sha1(byte[] data) {\n+    public static byte[] sha1(final byte[] data) {\n         return getSha1Digest().digest(data);\n     }\n \n      *             On error reading from the stream\n      * @since 1.7\n      */\n-    public static byte[] sha1(InputStream data) throws IOException {\n+    public static byte[] sha1(final InputStream data) throws IOException {\n         return digest(getSha1Digest(), data);\n     }\n \n      *            Data to digest\n      * @return SHA-1 digest\n      */\n-    public static byte[] sha1(String data) {\n+    public static byte[] sha1(final String data) {\n         return sha1(StringUtils.getBytesUtf8(data));\n     }\n \n      * @return SHA-1 digest as a hex string\n      * @since 1.7\n      */\n-    public static String sha1Hex(byte[] data) {\n+    public static String sha1Hex(final byte[] data) {\n         return Hex.encodeHexString(sha1(data));\n     }\n \n      *             On error reading from the stream\n      * @since 1.7\n      */\n-    public static String sha1Hex(InputStream data) throws IOException {\n+    public static String sha1Hex(final InputStream data) throws IOException {\n         return Hex.encodeHexString(sha1(data));\n     }\n \n      * @return SHA-1 digest as a hex string\n      * @since 1.7\n      */\n-    public static String sha1Hex(String data) {\n+    public static String sha1Hex(final String data) {\n         return Hex.encodeHexString(sha1(data));\n     }\n \n      * @return SHA-256 digest\n      * @since 1.4\n      */\n-    public static byte[] sha256(byte[] data) {\n+    public static byte[] sha256(final byte[] data) {\n         return getSha256Digest().digest(data);\n     }\n \n      *             On error reading from the stream\n      * @since 1.4\n      */\n-    public static byte[] sha256(InputStream data) throws IOException {\n+    public static byte[] sha256(final InputStream data) throws IOException {\n         return digest(getSha256Digest(), data);\n     }\n \n      * @return SHA-256 digest\n      * @since 1.4\n      */\n-    public static byte[] sha256(String data) {\n+    public static byte[] sha256(final String data) {\n         return sha256(StringUtils.getBytesUtf8(data));\n     }\n \n      * @return SHA-256 digest as a hex string\n      * @since 1.4\n      */\n-    public static String sha256Hex(byte[] data) {\n+    public static String sha256Hex(final byte[] data) {\n         return Hex.encodeHexString(sha256(data));\n     }\n \n      *             On error reading from the stream\n      * @since 1.4\n      */\n-    public static String sha256Hex(InputStream data) throws IOException {\n+    public static String sha256Hex(final InputStream data) throws IOException {\n         return Hex.encodeHexString(sha256(data));\n     }\n \n      * @return SHA-256 digest as a hex string\n      * @since 1.4\n      */\n-    public static String sha256Hex(String data) {\n+    public static String sha256Hex(final String data) {\n         return Hex.encodeHexString(sha256(data));\n     }\n \n      * @return SHA-384 digest\n      * @since 1.4\n      */\n-    public static byte[] sha384(byte[] data) {\n+    public static byte[] sha384(final byte[] data) {\n         return getSha384Digest().digest(data);\n     }\n \n      *             On error reading from the stream\n      * @since 1.4\n      */\n-    public static byte[] sha384(InputStream data) throws IOException {\n+    public static byte[] sha384(final InputStream data) throws IOException {\n         return digest(getSha384Digest(), data);\n     }\n \n      * @return SHA-384 digest\n      * @since 1.4\n      */\n-    public static byte[] sha384(String data) {\n+    public static byte[] sha384(final String data) {\n         return sha384(StringUtils.getBytesUtf8(data));\n     }\n \n      * @return SHA-384 digest as a hex string\n      * @since 1.4\n      */\n-    public static String sha384Hex(byte[] data) {\n+    public static String sha384Hex(final byte[] data) {\n         return Hex.encodeHexString(sha384(data));\n     }\n \n      *             On error reading from the stream\n      * @since 1.4\n      */\n-    public static String sha384Hex(InputStream data) throws IOException {\n+    public static String sha384Hex(final InputStream data) throws IOException {\n         return Hex.encodeHexString(sha384(data));\n     }\n \n      * @return SHA-384 digest as a hex string\n      * @since 1.4\n      */\n-    public static String sha384Hex(String data) {\n+    public static String sha384Hex(final String data) {\n         return Hex.encodeHexString(sha384(data));\n     }\n \n      * @return SHA-512 digest\n      * @since 1.4\n      */\n-    public static byte[] sha512(byte[] data) {\n+    public static byte[] sha512(final byte[] data) {\n         return getSha512Digest().digest(data);\n     }\n \n      *             On error reading from the stream\n      * @since 1.4\n      */\n-    public static byte[] sha512(InputStream data) throws IOException {\n+    public static byte[] sha512(final InputStream data) throws IOException {\n         return digest(getSha512Digest(), data);\n     }\n \n      * @return SHA-512 digest\n      * @since 1.4\n      */\n-    public static byte[] sha512(String data) {\n+    public static byte[] sha512(final String data) {\n         return sha512(StringUtils.getBytesUtf8(data));\n     }\n \n      * @return SHA-512 digest as a hex string\n      * @since 1.4\n      */\n-    public static String sha512Hex(byte[] data) {\n+    public static String sha512Hex(final byte[] data) {\n         return Hex.encodeHexString(sha512(data));\n     }\n \n      *             On error reading from the stream\n      * @since 1.4\n      */\n-    public static String sha512Hex(InputStream data) throws IOException {\n+    public static String sha512Hex(final InputStream data) throws IOException {\n         return Hex.encodeHexString(sha512(data));\n     }\n \n      * @return SHA-512 digest as a hex string\n      * @since 1.4\n      */\n-    public static String sha512Hex(String data) {\n+    public static String sha512Hex(final String data) {\n         return Hex.encodeHexString(sha512(data));\n     }\n \n      * @deprecated Use {@link #sha1Hex(byte[])}\n      */\n     @Deprecated\n-    public static String shaHex(byte[] data) {\n+    public static String shaHex(final byte[] data) {\n         return sha1Hex(data);\n     }\n \n      * @deprecated Use {@link #sha1Hex(InputStream)}\n      */\n     @Deprecated\n-    public static String shaHex(InputStream data) throws IOException {\n+    public static String shaHex(final InputStream data) throws IOException {\n         return sha1Hex(data);\n     }\n \n      * @deprecated Use {@link #sha1Hex(String)}\n      */\n     @Deprecated\n-    public static String shaHex(String data) {\n+    public static String shaHex(final String data) {\n         return sha1Hex(data);\n     }\n \n      * @return the updated {@link MessageDigest}\n      * @since 1.7\n      */\n-    public static MessageDigest updateDigest(final MessageDigest messageDigest, byte[] valueToDigest) {\n+    public static MessageDigest updateDigest(final MessageDigest messageDigest, final byte[] valueToDigest) {\n         messageDigest.update(valueToDigest);\n         return messageDigest;\n     }\n--- a/src/main/java/org/apache/commons/codec/digest/Md5Crypt.java\n+++ b/src/main/java/org/apache/commons/codec/digest/Md5Crypt.java\n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught. *\n      */\n-    public static String apr1Crypt(byte[] keyBytes) {\n+    public static String apr1Crypt(final byte[] keyBytes) {\n         return apr1Crypt(keyBytes, APR1_PREFIX + B64.getRandomSalt(8));\n     }\n \n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n-    public static String apr1Crypt(byte[] keyBytes, String salt) {\n+    public static String apr1Crypt(final byte[] keyBytes, String salt) {\n         // to make the md5Crypt regex happy\n         if (salt != null && !salt.startsWith(APR1_PREFIX)) {\n             salt = APR1_PREFIX + salt;\n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n-    public static String apr1Crypt(String keyBytes) {\n+    public static String apr1Crypt(final String keyBytes) {\n         return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8));\n     }\n \n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n-    public static String apr1Crypt(String keyBytes, String salt) {\n+    public static String apr1Crypt(final String keyBytes, final String salt) {\n         return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8), salt);\n     }\n \n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n-    public static String md5Crypt(byte[] keyBytes, String salt) {\n+    public static String md5Crypt(final byte[] keyBytes, final String salt) {\n         return md5Crypt(keyBytes, salt, MD5_PREFIX);\n     }\n \n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n     public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {\n-        int keyLen = keyBytes.length;\n+        final int keyLen = keyBytes.length;\n \n         // Extract the real salt from the given string which can be a complete hash string.\n         String saltString;\n             }\n             saltString = m.group(1);\n         }\n-        byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n-\n-        MessageDigest ctx = DigestUtils.getMd5Digest();\n+        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n+\n+        final MessageDigest ctx = DigestUtils.getMd5Digest();\n \n         /*\n          * The password first, since that is what is most unknown\n          * Then something really weird...\n          */\n         ii = keyLen;\n-        int j = 0;\n+        final int j = 0;\n         while (ii > 0) {\n             if ((ii & 1) == 1) {\n                 ctx.update(finalb[j]);\n         /*\n          * Now make the output string\n          */\n-        StringBuilder passwd = new StringBuilder(prefix + saltString + \"$\");\n+        final StringBuilder passwd = new StringBuilder(prefix + saltString + \"$\");\n         finalb = ctx.digest();\n \n         /*\n--- a/src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java\n+++ b/src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java\n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n-    public static String sha256Crypt(byte[] keyBytes) {\n+    public static String sha256Crypt(final byte[] keyBytes) {\n         return sha256Crypt(keyBytes, null);\n     }\n \n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n-    public static String sha256Crypt(byte[] keyBytes, String salt) {\n+    public static String sha256Crypt(final byte[] keyBytes, String salt) {\n         if (salt == null) {\n             salt = SHA256_PREFIX + B64.getRandomSalt(8);\n         }\n      *             when a {@link NoSuchAlgorithmException} is caught\n      * @see MessageDigestAlgorithms\n      */\n-    private static String sha2Crypt(byte[] keyBytes, String salt, String saltPrefix, int blocksize, String algorithm) {\n-\n-        int keyLen = keyBytes.length;\n+    private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {\n+\n+        final int keyLen = keyBytes.length;\n \n         // Extracts effective salt and the number of rounds from the given salt.\n         int rounds = ROUNDS_DEFAULT;\n             throw new IllegalArgumentException(\"Salt must not be null\");\n         }\n \n-        Matcher m = SALT_PATTERN.matcher(salt);\n+        final Matcher m = SALT_PATTERN.matcher(salt);\n         if (m == null || !m.find()) {\n             throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n         }\n             rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));\n             roundsCustom = true;\n         }\n-        String saltString = m.group(4);\n-        byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n-        int saltLen = saltBytes.length;\n+        final String saltString = m.group(4);\n+        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n+        final int saltLen = saltBytes.length;\n \n         // 1. start digest A\n         // Prepare for the real work.\n         /*\n          * Create byte sequence P.\n          */\n-        byte[] pBytes = new byte[keyLen];\n+        final byte[] pBytes = new byte[keyLen];\n         int cp = 0;\n         while (cp < keyLen - blocksize) {\n             System.arraycopy(tempResult, 0, pBytes, cp, blocksize);\n          * Create byte sequence S.\n          */\n         // Remark: The salt is limited to 16 chars, how does this make sense?\n-        byte[] sBytes = new byte[saltLen];\n+        final byte[] sBytes = new byte[saltLen];\n         cp = 0;\n         while (cp < saltLen - blocksize) {\n             System.arraycopy(tempResult, 0, sBytes, cp, blocksize);\n         /*\n          * Now we can construct the result string. It consists of three parts.\n          */\n-        StringBuilder buffer = new StringBuilder(saltPrefix);\n+        final StringBuilder buffer = new StringBuilder(saltPrefix);\n         if (roundsCustom) {\n             buffer.append(ROUNDS_PREFIX);\n             buffer.append(rounds);\n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n-    public static String sha512Crypt(byte[] keyBytes) {\n+    public static String sha512Crypt(final byte[] keyBytes) {\n         return sha512Crypt(keyBytes, null);\n     }\n \n      * @throws RuntimeException\n      *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n      */\n-    public static String sha512Crypt(byte[] keyBytes, String salt) {\n+    public static String sha512Crypt(final byte[] keyBytes, String salt) {\n         if (salt == null) {\n             salt = SHA512_PREFIX + B64.getRandomSalt(8);\n         }\n--- a/src/main/java/org/apache/commons/codec/digest/UnixCrypt.java\n+++ b/src/main/java/org/apache/commons/codec/digest/UnixCrypt.java\n      *            plaintext password\n      * @return a 13 character string starting with the salt string\n      */\n-    public static String crypt(byte[] original) {\n+    public static String crypt(final byte[] original) {\n         return crypt(original, null);\n     }\n \n      * @throws IllegalArgumentException\n      *             if the salt does not match the allowed pattern\n      */\n-    public static String crypt(byte[] original, String salt) {\n+    public static String crypt(final byte[] original, String salt) {\n         if (salt == null) {\n-            Random randomGenerator = new Random();\n-            int numSaltChars = SALT_CHARS.length;\n+            final Random randomGenerator = new Random();\n+            final int numSaltChars = SALT_CHARS.length;\n             salt = \"\" + SALT_CHARS[randomGenerator.nextInt(numSaltChars)] +\n                     SALT_CHARS[randomGenerator.nextInt(numSaltChars)];\n         } else if (!salt.matches(\"^[\" + B64.B64T + \"]{2,}$\")) {\n             throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n         }\n \n-        StringBuilder buffer = new StringBuilder(\"             \");\n-        char charZero = salt.charAt(0);\n-        char charOne = salt.charAt(1);\n+        final StringBuilder buffer = new StringBuilder(\"             \");\n+        final char charZero = salt.charAt(0);\n+        final char charOne = salt.charAt(1);\n         buffer.setCharAt(0, charZero);\n         buffer.setCharAt(1, charOne);\n-        int eSwap0 = CON_SALT[charZero];\n-        int eSwap1 = CON_SALT[charOne] << 4;\n-        byte key[] = new byte[8];\n+        final int eSwap0 = CON_SALT[charZero];\n+        final int eSwap1 = CON_SALT[charOne] << 4;\n+        final byte key[] = new byte[8];\n         for (int i = 0; i < key.length; i++) {\n             key[i] = 0;\n         }\n \n         for (int i = 0; i < key.length && i < original.length; i++) {\n-            int iChar = original[i];\n+            final int iChar = original[i];\n             key[i] = (byte) (iChar << 1);\n         }\n \n-        int schedule[] = desSetKey(key);\n-        int out[] = body(schedule, eSwap0, eSwap1);\n-        byte b[] = new byte[9];\n+        final int schedule[] = desSetKey(key);\n+        final int out[] = body(schedule, eSwap0, eSwap1);\n+        final byte b[] = new byte[9];\n         intToFourBytes(out[0], b, 0);\n         intToFourBytes(out[1], b, 4);\n         b[8] = 0;\n      *            plaintext password\n      * @return a 13 character string starting with the salt string\n      */\n-    public static String crypt(String original) {\n+    public static String crypt(final String original) {\n         return crypt(original.getBytes(Charsets.UTF_8));\n     }\n \n      * @throws IllegalArgumentException\n      *             if the salt does not match the allowed pattern\n      */\n-    public static String crypt(String original, String salt) {\n+    public static String crypt(final String original, final String salt) {\n         return crypt(original.getBytes(Charsets.UTF_8), salt);\n     }\n \n-    private static int[] body(int schedule[], int eSwap0, int eSwap1) {\n+    private static int[] body(final int schedule[], final int eSwap0, final int eSwap1) {\n         int left = 0;\n         int right = 0;\n         int t = 0;\n         t = right;\n         right = left >>> 1 | left << 31;\n         left = t >>> 1 | t << 31;\n-        int results[] = new int[2];\n+        final int results[] = new int[2];\n         permOp(right, left, 1, 0x55555555, results);\n         right = results[0];\n         left = results[1];\n         permOp(right, left, 4, 0xf0f0f0f, results);\n         right = results[0];\n         left = results[1];\n-        int out[] = new int[2];\n+        final int out[] = new int[2];\n         out[0] = left;\n         out[1] = right;\n         return out;\n     }\n \n-    private static int byteToUnsigned(byte b) {\n-        int value = b;\n+    private static int byteToUnsigned(final byte b) {\n+        final int value = b;\n         return value < 0 ? value + 256 : value;\n     }\n \n-    private static int dEncrypt(int el, int r, int s, int e0, int e1, int sArr[]) {\n+    private static int dEncrypt(int el, final int r, final int s, final int e0, final int e1, final int sArr[]) {\n         int v = r ^ r >>> 16;\n         int u = v & e0;\n         v &= e1;\n         return el;\n     }\n \n-    private static int[] desSetKey(byte key[]) {\n-        int schedule[] = new int[32];\n+    private static int[] desSetKey(final byte key[]) {\n+        final int schedule[] = new int[32];\n         int c = fourBytesToInt(key, 0);\n         int d = fourBytesToInt(key, 4);\n-        int results[] = new int[2];\n+        final int results[] = new int[2];\n         permOp(d, c, 4, 0xf0f0f0f, results);\n         d = results[0];\n         c = results[1];\n             int s = SKB[0][c & 0x3f] | SKB[1][c >>> 6 & 0x3 | c >>> 7 & 0x3c] |\n                     SKB[2][c >>> 13 & 0xf | c >>> 14 & 0x30] |\n                     SKB[3][c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38];\n-            int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] |\n+            final int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] |\n                     SKB[7][d >>> 21 & 0xf | d >>> 22 & 0x30];\n             schedule[j++] = (t << 16 | s & 0xffff);\n             s = s >>> 16 | t & 0xffff0000;\n         return schedule;\n     }\n \n-    private static int fourBytesToInt(byte b[], int offset) {\n+    private static int fourBytesToInt(final byte b[], int offset) {\n         int value = byteToUnsigned(b[offset++]);\n         value |= byteToUnsigned(b[offset++]) << 8;\n         value |= byteToUnsigned(b[offset++]) << 16;\n         return value;\n     }\n \n-    private static int hPermOp(int a, int n, int m) {\n-        int t = (a << 16 - n ^ a) & m;\n+    private static int hPermOp(int a, final int n, final int m) {\n+        final int t = (a << 16 - n ^ a) & m;\n         a = a ^ t ^ t >>> 16 - n;\n         return a;\n     }\n \n-    private static void intToFourBytes(int iValue, byte b[], int offset) {\n+    private static void intToFourBytes(final int iValue, final byte b[], int offset) {\n         b[offset++] = (byte) (iValue & 0xff);\n         b[offset++] = (byte) (iValue >>> 8 & 0xff);\n         b[offset++] = (byte) (iValue >>> 16 & 0xff);\n         b[offset++] = (byte) (iValue >>> 24 & 0xff);\n     }\n \n-    private static void permOp(int a, int b, int n, int m, int results[]) {\n-        int t = (a >>> n ^ b) & m;\n+    private static void permOp(int a, int b, final int n, final int m, final int results[]) {\n+        final int t = (a >>> n ^ b) & m;\n         a ^= t << n;\n         b ^= t;\n         results[0] = a;\n--- a/src/main/java/org/apache/commons/codec/language/AbstractCaverphone.java\n+++ b/src/main/java/org/apache/commons/codec/language/AbstractCaverphone.java\n      *             if the parameter supplied is not of type java.lang.String\n      */\n     @Override\n-    public Object encode(Object source) throws EncoderException {\n+    public Object encode(final Object source) throws EncoderException {\n         if (!(source instanceof String)) {\n             throw new EncoderException(\"Parameter supplied to Caverphone encode is not of type java.lang.String\");\n         }\n      * @return {@code true} if the encodings of these strings are identical, {@code false} otherwise.\n      * @throws EncoderException\n      */\n-    public boolean isEncodeEqual(String str1, String str2) throws EncoderException {\n+    public boolean isEncodeEqual(final String str1, final String str2) throws EncoderException {\n         return this.encode(str1).equals(this.encode(str2));\n     }\n \n--- a/src/main/java/org/apache/commons/codec/language/Caverphone.java\n+++ b/src/main/java/org/apache/commons/codec/language/Caverphone.java\n      *            String the source string\n      * @return A caverphone code for the given String\n      */\n-    public String caverphone(String source) {\n+    public String caverphone(final String source) {\n         return this.encoder.encode(source);\n     }\n \n      *             if the parameter supplied is not of type java.lang.String\n      */\n     @Override\n-    public Object encode(Object obj) throws EncoderException {\n+    public Object encode(final Object obj) throws EncoderException {\n         if (!(obj instanceof String)) {\n             throw new EncoderException(\"Parameter supplied to Caverphone encode is not of type java.lang.String\");\n         }\n      * @return The caverphone code corresponding to the String supplied\n      */\n     @Override\n-    public String encode(String str) {\n+    public String encode(final String str) {\n         return this.caverphone(str);\n     }\n \n      *            Second of two strings to compare\n      * @return {@code true} if the caverphones of these strings are identical, {@code false} otherwise.\n      */\n-    public boolean isCaverphoneEqual(String str1, String str2) {\n+    public boolean isCaverphoneEqual(final String str1, final String str2) {\n         return this.caverphone(str1).equals(this.caverphone(str2));\n     }\n \n--- a/src/main/java/org/apache/commons/codec/language/Caverphone1.java\n+++ b/src/main/java/org/apache/commons/codec/language/Caverphone1.java\n      * @return A caverphone code for the given String\n      */\n     @Override\n-    public String encode(String source) {\n+    public String encode(final String source) {\n         String txt = source;\n         if (txt == null || txt.length() == 0) {\n             return SIX_1;\n--- a/src/main/java/org/apache/commons/codec/language/Caverphone2.java\n+++ b/src/main/java/org/apache/commons/codec/language/Caverphone2.java\n      * @return A caverphone code for the given String\n      */\n     @Override\n-    public String encode(String source) {\n+    public String encode(final String source) {\n         String txt = source;\n         if (txt == null || txt.length() == 0) {\n             return TEN_1;\n--- a/src/main/java/org/apache/commons/codec/language/ColognePhonetic.java\n+++ b/src/main/java/org/apache/commons/codec/language/ColognePhonetic.java\n \n         protected int length = 0;\n \n-        public CologneBuffer(char[] data) {\n+        public CologneBuffer(final char[] data) {\n             this.data = data;\n             this.length = data.length;\n         }\n \n-        public CologneBuffer(int buffSize) {\n+        public CologneBuffer(final int buffSize) {\n             this.data = new char[buffSize];\n             this.length = 0;\n         }\n \n     private class CologneOutputBuffer extends CologneBuffer {\n \n-        public CologneOutputBuffer(int buffSize) {\n+        public CologneOutputBuffer(final int buffSize) {\n             super(buffSize);\n         }\n \n-        public void addRight(char chr) {\n+        public void addRight(final char chr) {\n             data[length] = chr;\n             length++;\n         }\n \n         @Override\n-        protected char[] copyData(int start, final int length) {\n-            char[] newData = new char[length];\n+        protected char[] copyData(final int start, final int length) {\n+            final char[] newData = new char[length];\n             System.arraycopy(data, start, newData, 0, length);\n             return newData;\n         }\n \n     private class CologneInputBuffer extends CologneBuffer {\n \n-        public CologneInputBuffer(char[] data) {\n+        public CologneInputBuffer(final char[] data) {\n             super(data);\n         }\n \n-        public void addLeft(char ch) {\n+        public void addLeft(final char ch) {\n             length++;\n             data[getNextPos()] = ch;\n         }\n \n         @Override\n-        protected char[] copyData(int start, final int length) {\n-            char[] newData = new char[length];\n+        protected char[] copyData(final int start, final int length) {\n+            final char[] newData = new char[length];\n             System.arraycopy(data, data.length - this.length + start, newData, 0, length);\n             return newData;\n         }\n         }\n \n         public char removeNext() {\n-            char ch = getNextChar();\n+            final char ch = getNextChar();\n             length--;\n             return ch;\n         }\n     /*\n      * Returns whether the array contains the key, or not.\n      */\n-    private static boolean arrayContains(char[] arr, char key) {\n-        for (char element : arr) {\n+    private static boolean arrayContains(final char[] arr, final char key) {\n+        for (final char element : arr) {\n             if (element == key) {\n                 return true;\n             }\n \n         text = preprocess(text);\n \n-        CologneOutputBuffer output = new CologneOutputBuffer(text.length() * 2);\n-        CologneInputBuffer input = new CologneInputBuffer(text.toCharArray());\n+        final CologneOutputBuffer output = new CologneOutputBuffer(text.length() * 2);\n+        final CologneInputBuffer input = new CologneInputBuffer(text.toCharArray());\n \n         char nextChar;\n \n     }\n \n     @Override\n-    public Object encode(Object object) throws EncoderException {\n+    public Object encode(final Object object) throws EncoderException {\n         if (!(object instanceof String)) {\n             throw new EncoderException(\"This method's parameter was expected to be of the type \" +\n                 String.class.getName() +\n     }\n \n     @Override\n-    public String encode(String text) {\n+    public String encode(final String text) {\n         return colognePhonetic(text);\n     }\n \n-    public boolean isEncodeEqual(String text1, String text2) {\n+    public boolean isEncodeEqual(final String text1, final String text2) {\n         return colognePhonetic(text1).equals(colognePhonetic(text2));\n     }\n \n     private String preprocess(String text) {\n         text = text.toUpperCase(Locale.GERMAN);\n \n-        char[] chrs = text.toCharArray();\n+        final char[] chrs = text.toCharArray();\n \n         for (int index = 0; index < chrs.length; index++) {\n             if (chrs[index] > 'Z') {\n-                for (char[] element : PREPROCESS_MAP) {\n+                for (final char[] element : PREPROCESS_MAP) {\n                     if (chrs[index] == element[0]) {\n                         chrs[index] = element[1];\n                         break;\n--- a/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\n+++ b/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\n      * @param value String to encode\n      * @return an encoded string\n      */\n-    public String doubleMetaphone(String value) {\n+    public String doubleMetaphone(final String value) {\n         return doubleMetaphone(value, false);\n     }\n \n      * @param alternate use alternate encode\n      * @return an encoded string\n      */\n-    public String doubleMetaphone(String value, boolean alternate) {\n+    public String doubleMetaphone(String value, final boolean alternate) {\n         value = cleanInput(value);\n         if (value == null) {\n             return null;\n         }\n \n-        boolean slavoGermanic = isSlavoGermanic(value);\n+        final boolean slavoGermanic = isSlavoGermanic(value);\n         int index = isSilentStart(value) ? 1 : 0;\n \n-        DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n+        final DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n \n         while (!result.isComplete() && index <= value.length() - 1) {\n             switch (value.charAt(index)) {\n      * @throws EncoderException encode parameter is not of type String\n      */\n     @Override\n-    public Object encode(Object obj) throws EncoderException {\n+    public Object encode(final Object obj) throws EncoderException {\n         if (!(obj instanceof String)) {\n             throw new EncoderException(\"DoubleMetaphone encode parameter is not of type String\");\n         }\n      * @return An encoded String\n      */\n     @Override\n-    public String encode(String value) {\n+    public String encode(final String value) {\n         return doubleMetaphone(value);\n     }\n \n      *          {@code false} otherwise.\n      * @see #isDoubleMetaphoneEqual(String,String,boolean)\n      */\n-    public boolean isDoubleMetaphoneEqual(String value1, String value2) {\n+    public boolean isDoubleMetaphoneEqual(final String value1, final String value2) {\n         return isDoubleMetaphoneEqual(value1, value2, false);\n     }\n \n      * @return {@code true} if the encoded <code>String</code>s are equal;\n      *          {@code false} otherwise.\n      */\n-    public boolean isDoubleMetaphoneEqual(String value1, String value2, boolean alternate) {\n+    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\n         return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n     }\n \n      * Sets the maxCodeLen.\n      * @param maxCodeLen The maxCodeLen to set\n      */\n-    public void setMaxCodeLen(int maxCodeLen) {\n+    public void setMaxCodeLen(final int maxCodeLen) {\n         this.maxCodeLen = maxCodeLen;\n     }\n \n     /**\n      * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases.\n      */\n-    private int handleAEIOUY(DoubleMetaphoneResult result, int index) {\n+    private int handleAEIOUY(final DoubleMetaphoneResult result, final int index) {\n         if (index == 0) {\n             result.append('A');\n         }\n     /**\n      * Handles 'C' cases.\n      */\n-    private int handleC(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleC(final String value, final DoubleMetaphoneResult result, int index) {\n         if (conditionC0(value, index)) {  // very confusing, moved out\n             result.append('K');\n             index += 2;\n     /**\n      * Handles 'CC' cases.\n      */\n-    private int handleCC(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleCC(final String value, final DoubleMetaphoneResult result, int index) {\n         if (contains(value, index + 2, 1, \"I\", \"E\", \"H\") &&\n             !contains(value, index + 2, 2, \"HU\")) {\n             //-- \"bellocchio\" but not \"bacchus\" --//\n     /**\n      * Handles 'CH' cases.\n      */\n-    private int handleCH(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleCH(final String value, final DoubleMetaphoneResult result, final int index) {\n         if (index > 0 && contains(value, index, 4, \"CHAE\")) {   // Michael\n             result.append('K', 'X');\n             return index + 2;\n     /**\n      * Handles 'D' cases.\n      */\n-    private int handleD(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleD(final String value, final DoubleMetaphoneResult result, int index) {\n         if (contains(value, index, 2, \"DG\")) {\n             //-- \"Edge\" --//\n             if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n     /**\n      * Handles 'G' cases.\n      */\n-    private int handleG(String value, DoubleMetaphoneResult result, int index, boolean slavoGermanic) {\n+    private int handleG(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\n         if (charAt(value, index + 1) == 'H') {\n             index = handleGH(value, result, index);\n         } else if (charAt(value, index + 1) == 'N') {\n     /**\n      * Handles 'GH' cases.\n      */\n-    private int handleGH(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleGH(final String value, final DoubleMetaphoneResult result, int index) {\n         if (index > 0 && !isVowel(charAt(value, index - 1))) {\n             result.append('K');\n             index += 2;\n     /**\n      * Handles 'H' cases.\n      */\n-    private int handleH(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleH(final String value, final DoubleMetaphoneResult result, int index) {\n         //-- only keep if first & before vowel or between 2 vowels --//\n         if ((index == 0 || isVowel(charAt(value, index - 1))) &&\n             isVowel(charAt(value, index + 1))) {\n     /**\n      * Handles 'J' cases.\n      */\n-    private int handleJ(String value, DoubleMetaphoneResult result, int index, boolean slavoGermanic) {\n+    private int handleJ(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\n         if (contains(value, index, 4, \"JOSE\") || contains(value, 0, 4, \"SAN \")) {\n                 //-- obvious Spanish, \"Jose\", \"San Jacinto\" --//\n                 if ((index == 0 && (charAt(value, index + 4) == ' ') ||\n     /**\n      * Handles 'L' cases.\n      */\n-    private int handleL(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleL(final String value, final DoubleMetaphoneResult result, int index) {\n         if (charAt(value, index + 1) == 'L') {\n             if (conditionL0(value, index)) {\n                 result.appendPrimary('L');\n     /**\n      * Handles 'P' cases.\n      */\n-    private int handleP(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleP(final String value, final DoubleMetaphoneResult result, int index) {\n         if (charAt(value, index + 1) == 'H') {\n             result.append('F');\n             index += 2;\n     /**\n      * Handles 'R' cases.\n      */\n-    private int handleR(String value, DoubleMetaphoneResult result, int index, boolean slavoGermanic) {\n+    private int handleR(final String value, final DoubleMetaphoneResult result, final int index, final boolean slavoGermanic) {\n         if (index == value.length() - 1 && !slavoGermanic &&\n             contains(value, index - 2, 2, \"IE\") &&\n             !contains(value, index - 4, 2, \"ME\", \"MA\")) {\n     /**\n      * Handles 'S' cases.\n      */\n-    private int handleS(String value, DoubleMetaphoneResult result, int index, boolean slavoGermanic) {\n+    private int handleS(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\n         if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n             //-- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\n             index++;\n     /**\n      * Handles 'SC' cases.\n      */\n-    private int handleSC(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleSC(final String value, final DoubleMetaphoneResult result, final int index) {\n         if (charAt(value, index + 2) == 'H') {\n             //-- Schlesinger's rule --//\n             if (contains(value, index + 3, 2, \"OO\", \"ER\", \"EN\", \"UY\", \"ED\", \"EM\")) {\n     /**\n      * Handles 'T' cases.\n      */\n-    private int handleT(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleT(final String value, final DoubleMetaphoneResult result, int index) {\n         if (contains(value, index, 4, \"TION\")) {\n             result.append('X');\n             index += 3;\n     /**\n      * Handles 'W' cases.\n      */\n-    private int handleW(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleW(final String value, final DoubleMetaphoneResult result, int index) {\n         if (contains(value, index, 2, \"WR\")) {\n             //-- can also be in middle of word --//\n             result.append('R');\n     /**\n      * Handles 'X' cases.\n      */\n-    private int handleX(String value, DoubleMetaphoneResult result, int index) {\n+    private int handleX(final String value, final DoubleMetaphoneResult result, int index) {\n         if (index == 0) {\n             result.append('S');\n             index++;\n     /**\n      * Handles 'Z' cases.\n      */\n-    private int handleZ(String value, DoubleMetaphoneResult result, int index, boolean slavoGermanic) {\n+    private int handleZ(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\n         if (charAt(value, index + 1) == 'H') {\n             //-- Chinese pinyin e.g. \"zhao\" or Angelina \"Zhang\" --//\n             result.append('J');\n     /**\n      * Complex condition 0 for 'C'.\n      */\n-    private boolean conditionC0(String value, int index) {\n+    private boolean conditionC0(final String value, final int index) {\n         if (contains(value, index, 4, \"CHIA\")) {\n             return true;\n         } else if (index <= 1) {\n         } else if (!contains(value, index - 1, 3, \"ACH\")) {\n             return false;\n         } else {\n-            char c = charAt(value, index + 2);\n+            final char c = charAt(value, index + 2);\n             return (c != 'I' && c != 'E') ||\n                     contains(value, index - 2, 6, \"BACHER\", \"MACHER\");\n         }\n     /**\n      * Complex condition 0 for 'CH'.\n      */\n-    private boolean conditionCH0(String value, int index) {\n+    private boolean conditionCH0(final String value, final int index) {\n         if (index != 0) {\n             return false;\n         } else if (!contains(value, index + 1, 5, \"HARAC\", \"HARIS\") &&\n     /**\n      * Complex condition 1 for 'CH'.\n      */\n-    private boolean conditionCH1(String value, int index) {\n+    private boolean conditionCH1(final String value, final int index) {\n         return ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) ||\n                 contains(value, index - 2, 6, \"ORCHES\", \"ARCHIT\", \"ORCHID\") ||\n                 contains(value, index + 2, 1, \"T\", \"S\") ||\n     /**\n      * Complex condition 0 for 'L'.\n      */\n-    private boolean conditionL0(String value, int index) {\n+    private boolean conditionL0(final String value, final int index) {\n         if (index == value.length() - 3 &&\n             contains(value, index - 1, 4, \"ILLO\", \"ILLA\", \"ALLE\")) {\n             return true;\n     /**\n      * Complex condition 0 for 'M'.\n      */\n-    private boolean conditionM0(String value, int index) {\n+    private boolean conditionM0(final String value, final int index) {\n         if (charAt(value, index + 1) == 'M') {\n             return true;\n         }\n      * Determines whether or not a value is of slavo-germanic orgin. A value is\n      * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n      */\n-    private boolean isSlavoGermanic(String value) {\n+    private boolean isSlavoGermanic(final String value) {\n         return value.indexOf('W') > -1 || value.indexOf('K') > -1 ||\n             value.indexOf(\"CZ\") > -1 || value.indexOf(\"WITZ\") > -1;\n     }\n     /**\n      * Determines whether or not a character is a vowel or not\n      */\n-    private boolean isVowel(char ch) {\n+    private boolean isVowel(final char ch) {\n         return VOWELS.indexOf(ch) != -1;\n     }\n \n      * return {@code true} if the value starts with any of 'GN', 'KN',\n      * 'PN', 'WR' or 'PS'.\n      */\n-    private boolean isSilentStart(String value) {\n+    private boolean isSilentStart(final String value) {\n         boolean result = false;\n-        for (String element : SILENT_START) {\n+        for (final String element : SILENT_START) {\n             if (value.startsWith(element)) {\n                 result = true;\n                 break;\n      * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n      * of a default.\n      */\n-    protected char charAt(String value, int index) {\n+    protected char charAt(final String value, final int index) {\n         if (index < 0 || index >= value.length()) {\n             return Character.MIN_VALUE;\n         }\n      * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\n      * matching up to length <code>length</code>.\n      */\n-    protected static boolean contains(String value, int start, int length,\n-                                      String... criteria) {\n+    protected static boolean contains(final String value, final int start, final int length,\n+                                      final String... criteria) {\n         boolean result = false;\n         if (start >= 0 && start + length <= value.length()) {\n-            String target = value.substring(start, start + length);\n-\n-            for (String element : criteria) {\n+            final String target = value.substring(start, start + length);\n+\n+            for (final String element : criteria) {\n                 if (target.equals(element)) {\n                     result = true;\n                     break;\n         private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());\n         private final int maxLength;\n \n-        public DoubleMetaphoneResult(int maxLength) {\n+        public DoubleMetaphoneResult(final int maxLength) {\n             this.maxLength = maxLength;\n         }\n \n-        public void append(char value) {\n+        public void append(final char value) {\n             appendPrimary(value);\n             appendAlternate(value);\n         }\n \n-        public void append(char primary, char alternate) {\n+        public void append(final char primary, final char alternate) {\n             appendPrimary(primary);\n             appendAlternate(alternate);\n         }\n \n-        public void appendPrimary(char value) {\n+        public void appendPrimary(final char value) {\n             if (this.primary.length() < this.maxLength) {\n                 this.primary.append(value);\n             }\n         }\n \n-        public void appendAlternate(char value) {\n+        public void appendAlternate(final char value) {\n             if (this.alternate.length() < this.maxLength) {\n                 this.alternate.append(value);\n             }\n         }\n \n-        public void append(String value) {\n+        public void append(final String value) {\n             appendPrimary(value);\n             appendAlternate(value);\n         }\n \n-        public void append(String primary, String alternate) {\n+        public void append(final String primary, final String alternate) {\n             appendPrimary(primary);\n             appendAlternate(alternate);\n         }\n \n-        public void appendPrimary(String value) {\n-            int addChars = this.maxLength - this.primary.length();\n+        public void appendPrimary(final String value) {\n+            final int addChars = this.maxLength - this.primary.length();\n             if (value.length() <= addChars) {\n                 this.primary.append(value);\n             } else {\n             }\n         }\n \n-        public void appendAlternate(String value) {\n-            int addChars = this.maxLength - this.alternate.length();\n+        public void appendAlternate(final String value) {\n+            final int addChars = this.maxLength - this.alternate.length();\n             if (value.length() <= addChars) {\n                 this.alternate.append(value);\n             } else {\n--- a/src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java\n+++ b/src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java\n     String cleanName(final String name) {\n         String upperName = name.toUpperCase(Locale.ENGLISH);\n \n-        String[] charsToTrim = { \"\\\\-\", \"[&]\", \"\\\\'\", \"\\\\.\", \"[\\\\,]\" };\n-        for (String str : charsToTrim) {\n+        final String[] charsToTrim = { \"\\\\-\", \"[&]\", \"\\\\'\", \"\\\\.\", \"[\\\\,]\" };\n+        for (final String str : charsToTrim) {\n             upperName = upperName.replaceAll(str, EMPTY);\n         }\n \n      * @return Annexed first & last 3 letters of input word.\n      */\n     String getFirst3Last3(final String name) {\n-        int nameLength = name.length();\n+        final int nameLength = name.length();\n \n         if (nameLength > SIX) {\n-            String firstThree = name.substring(0, THREE);\n-            String lastThree = name.substring(nameLength - THREE, nameLength);\n+            final String firstThree = name.substring(0, THREE);\n+            final String lastThree = name.substring(nameLength - THREE, nameLength);\n             return firstThree + lastThree;\n         } else {\n             return name;\n \n         // 5. Obtain the minimum rating value by calculating the length sum of the\n         // encoded Strings and sending it down.\n-        int sumLength = Math.abs(name1.length() + name2.length());\n+        final int sumLength = Math.abs(name1.length() + name2.length());\n         int minRating = 0;\n         minRating = getMinRating(sumLength);\n \n         // 6. Process the encoded Strings from left to right and remove any\n         // identical characters found from both Strings respectively.\n-        int count = leftToRightThenRightToLeftProcessing(name1, name2);\n+        final int count = leftToRightThenRightToLeftProcessing(name1, name2);\n \n         // 7. Each PNI item that has a similarity rating equal to or greater than\n         // the min is considered to be a good candidate match\n      *            The letter under investiagtion\n      * @return True if a vowel, else false\n      */\n-    boolean isVowel(String letter) {\n+    boolean isVowel(final String letter) {\n         return letter.equalsIgnoreCase(\"E\") || letter.equalsIgnoreCase(\"A\") || letter.equalsIgnoreCase(\"O\") || letter.equalsIgnoreCase(\"I\") ||\n                 letter.equalsIgnoreCase(\"U\");\n     }\n      *            name2\n      * @return\n      */\n-    int leftToRightThenRightToLeftProcessing(String name1, String name2) {\n-        char[] name1Char = name1.toCharArray();\n-        char[] name2Char = name2.toCharArray();\n-\n-        int name1Size = name1.length() - 1;\n-        int name2Size = name2.length() - 1;\n+    int leftToRightThenRightToLeftProcessing(final String name1, final String name2) {\n+        final char[] name1Char = name1.toCharArray();\n+        final char[] name2Char = name2.toCharArray();\n+\n+        final int name1Size = name1.length() - 1;\n+        final int name2Size = name2.length() - 1;\n \n         String name1LtRStart = EMPTY;\n         String name1LtREnd = EMPTY;\n         }\n \n         // Char arrays -> string & remove extraneous space\n-        String strA = new String(name1Char).replaceAll(\"\\\\s+\", EMPTY);\n-        String strB = new String(name2Char).replaceAll(\"\\\\s+\", EMPTY);\n+        final String strA = new String(name1Char).replaceAll(\"\\\\s+\", EMPTY);\n+        final String strB = new String(name2Char).replaceAll(\"\\\\s+\", EMPTY);\n \n         // Final bit - subtract longest string from 6 and return this int value\n         if (strA.length() > strB.length()) {\n             return null;\n         }\n \n-        StringBuilder sb = new StringBuilder();\n-        int n = accentedWord.length();\n+        final StringBuilder sb = new StringBuilder();\n+        final int n = accentedWord.length();\n \n         for (int i = 0; i < n; i++) {\n-            char c = accentedWord.charAt(i);\n-            int pos = UNICODE.indexOf(c);\n+            final char c = accentedWord.charAt(i);\n+            final int pos = UNICODE.indexOf(c);\n             if (pos > -1) {\n                 sb.append(PLAIN_ASCII.charAt(pos));\n             } else {\n      *            String to have double consonants removed\n      * @return Single consonant word\n      */\n-    String removeDoubleConsonants(String name) {\n-        String[] dblCnstArray = new String[] { \"BB\", \"CC\", \"DD\", \"FF\", \"GG\", \"HH\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"PP\", \"QQ\", \"RR\", \"SS\", \"TT\", \"VV\",\n+    String removeDoubleConsonants(final String name) {\n+        final String[] dblCnstArray = new String[] { \"BB\", \"CC\", \"DD\", \"FF\", \"GG\", \"HH\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"PP\", \"QQ\", \"RR\", \"SS\", \"TT\", \"VV\",\n                 \"WW\", \"XX\", \"YY\", \"ZZ\" };\n \n         String replacedName = name.toUpperCase();\n-        for (String dc : dblCnstArray) {\n+        for (final String dc : dblCnstArray) {\n             if (replacedName.contains(dc)) {\n-                String singleLetter = dc.substring(0, 1);\n+                final String singleLetter = dc.substring(0, 1);\n                 replacedName = replacedName.replace(dc, singleLetter);\n             }\n         }\n      */\n     String removeVowels(String name) {\n         // Extract first letter\n-        String firstLetter = name.substring(0, 1);\n+        final String firstLetter = name.substring(0, 1);\n \n         name = name.replaceAll(\"A\", EMPTY);\n         name = name.replaceAll(\"E\", EMPTY);\n--- a/src/main/java/org/apache/commons/codec/language/Metaphone.java\n+++ b/src/main/java/org/apache/commons/codec/language/Metaphone.java\n      * @param txt String to find the metaphone code for\n      * @return A metaphone code corresponding to the String supplied\n      */\n-    public String metaphone(String txt) {\n+    public String metaphone(final String txt) {\n         boolean hard = false;\n         if (txt == null || txt.length() == 0) {\n             return \"\";\n             return txt.toUpperCase(java.util.Locale.ENGLISH);\n         }\n \n-        char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\n-\n-        StringBuilder local = new StringBuilder(40); // manipulate\n-        StringBuilder code = new StringBuilder(10); //   output\n+        final char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\n+\n+        final StringBuilder local = new StringBuilder(40); // manipulate\n+        final StringBuilder code = new StringBuilder(10); //   output\n         // handle initial 2 characters exceptions\n         switch(inwd[0]) {\n         case 'K':\n             local.append(inwd);\n         } // now local has working string with initials fixed\n \n-        int wdsz = local.length();\n+        final int wdsz = local.length();\n         int n = 0;\n \n         while (code.length() < this.getMaxCodeLen() &&\n                n < wdsz ) { // max code size of 4 works well\n-            char symb = local.charAt(n);\n+            final char symb = local.charAt(n);\n             // remove duplicate letters except C\n             if (symb != 'C' && isPreviousChar( local, n, symb ) ) {\n                 n++;\n         return code.toString();\n     }\n \n-    private boolean isVowel(StringBuilder string, int index) {\n+    private boolean isVowel(final StringBuilder string, final int index) {\n         return VOWELS.indexOf(string.charAt(index)) >= 0;\n     }\n \n-    private boolean isPreviousChar(StringBuilder string, int index, char c) {\n+    private boolean isPreviousChar(final StringBuilder string, final int index, final char c) {\n         boolean matches = false;\n         if( index > 0 &&\n             index < string.length() ) {\n         return matches;\n     }\n \n-    private boolean isNextChar(StringBuilder string, int index, char c) {\n+    private boolean isNextChar(final StringBuilder string, final int index, final char c) {\n         boolean matches = false;\n         if( index >= 0 &&\n             index < string.length() - 1 ) {\n         return matches;\n     }\n \n-    private boolean regionMatch(StringBuilder string, int index, String test) {\n+    private boolean regionMatch(final StringBuilder string, final int index, final String test) {\n         boolean matches = false;\n         if( index >= 0 &&\n             index + test.length() - 1 < string.length() ) {\n-            String substring = string.substring( index, index + test.length());\n+            final String substring = string.substring( index, index + test.length());\n             matches = substring.equals( test );\n         }\n         return matches;\n     }\n \n-    private boolean isLastChar(int wdsz, int n) {\n+    private boolean isLastChar(final int wdsz, final int n) {\n         return n + 1 == wdsz;\n     }\n \n      *                          of type java.lang.String\n      */\n     @Override\n-    public Object encode(Object obj) throws EncoderException {\n+    public Object encode(final Object obj) throws EncoderException {\n         if (!(obj instanceof String)) {\n             throw new EncoderException(\"Parameter supplied to Metaphone encode is not of type java.lang.String\");\n         }\n      * @return The metaphone code corresponding to the String supplied\n      */\n     @Override\n-    public String encode(String str) {\n+    public String encode(final String str) {\n         return metaphone(str);\n     }\n \n      * @return {@code true} if the metaphones of these strings are identical,\n      *        {@code false} otherwise.\n      */\n-    public boolean isMetaphoneEqual(String str1, String str2) {\n+    public boolean isMetaphoneEqual(final String str1, final String str2) {\n         return metaphone(str1).equals(metaphone(str2));\n     }\n \n      * Sets the maxCodeLen.\n      * @param maxCodeLen The maxCodeLen to set\n      */\n-    public void setMaxCodeLen(int maxCodeLen) { this.maxCodeLen = maxCodeLen; }\n+    public void setMaxCodeLen(final int maxCodeLen) { this.maxCodeLen = maxCodeLen; }\n \n }\n--- a/src/main/java/org/apache/commons/codec/language/Nysiis.java\n+++ b/src/main/java/org/apache/commons/codec/language/Nysiis.java\n      *            if a character is not mapped\n      */\n     @Override\n-    public Object encode(Object obj) throws EncoderException {\n+    public Object encode(final Object obj) throws EncoderException {\n         if (!(obj instanceof String)) {\n             throw new EncoderException(\"Parameter supplied to Nysiis encode is not of type java.lang.String\");\n         }\n      *            if a character is not mapped\n      */\n     @Override\n-    public String encode(String str) {\n+    public String encode(final String str) {\n         return this.nysiis(str);\n     }\n \n         str = PAT_DT_ETC.matcher(str).replaceFirst(\"D\");\n \n         // First character of key = first character of name.\n-        StringBuilder key = new StringBuilder(str.length());\n+        final StringBuilder key = new StringBuilder(str.length());\n         key.append(str.charAt(0));\n \n         // Transcode remaining characters, incrementing by one character each time\n--- a/src/main/java/org/apache/commons/codec/language/RefinedSoundex.java\n+++ b/src/main/java/org/apache/commons/codec/language/RefinedSoundex.java\n      *                  Mapping array to use when finding the corresponding code for\n      *                  a given character\n      */\n-    public RefinedSoundex(char[] mapping) {\n+    public RefinedSoundex(final char[] mapping) {\n         this.soundexMapping = new char[mapping.length];\n         System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n     }\n      *            Mapping string to use when finding the corresponding code for a given character\n      * @since 1.4\n      */\n-    public RefinedSoundex(String mapping) {\n+    public RefinedSoundex(final String mapping) {\n         this.soundexMapping = mapping.toCharArray();\n     }\n \n      *                  if an error occurs encoding one of the strings\n      * @since 1.3\n      */\n-    public int difference(String s1, String s2) throws EncoderException {\n+    public int difference(final String s1, final String s2) throws EncoderException {\n         return SoundexUtils.difference(this, s1, s2);\n     }\n \n      *                  if the parameter supplied is not of type java.lang.String\n      */\n     @Override\n-    public Object encode(Object obj) throws EncoderException {\n+    public Object encode(final Object obj) throws EncoderException {\n         if (!(obj instanceof String)) {\n             throw new EncoderException(\"Parameter supplied to RefinedSoundex encode is not of type java.lang.String\");\n         }\n      * @return A Soundex code corresponding to the String supplied\n      */\n     @Override\n-    public String encode(String str) {\n+    public String encode(final String str) {\n         return soundex(str);\n     }\n \n      *                  char to get mapping for\n      * @return A character (really a numeral) to return for the given char\n      */\n-    char getMappingCode(char c) {\n+    char getMappingCode(final char c) {\n         if (!Character.isLetter(c)) {\n             return 0;\n         }\n             return str;\n         }\n \n-        StringBuilder sBuf = new StringBuilder();\n+        final StringBuilder sBuf = new StringBuilder();\n         sBuf.append(str.charAt(0));\n \n         char last, current;\n--- a/src/main/java/org/apache/commons/codec/language/Soundex.java\n+++ b/src/main/java/org/apache/commons/codec/language/Soundex.java\n      * @param mapping\n      *                  Mapping array to use when finding the corresponding code for a given character\n      */\n-    public Soundex(char[] mapping) {\n+    public Soundex(final char[] mapping) {\n         this.soundexMapping = new char[mapping.length];\n         System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n     }\n      *            Mapping string to use when finding the corresponding code for a given character\n      * @since 1.4\n      */\n-    public Soundex(String mapping) {\n+    public Soundex(final String mapping) {\n         this.soundexMapping = mapping.toCharArray();\n     }\n \n      *                  if an error occurs encoding one of the strings\n      * @since 1.3\n      */\n-    public int difference(String s1, String s2) throws EncoderException {\n+    public int difference(final String s1, final String s2) throws EncoderException {\n         return SoundexUtils.difference(this, s1, s2);\n     }\n \n      *                  if a character is not mapped\n      */\n     @Override\n-    public Object encode(Object obj) throws EncoderException {\n+    public Object encode(final Object obj) throws EncoderException {\n         if (!(obj instanceof String)) {\n             throw new EncoderException(\"Parameter supplied to Soundex encode is not of type java.lang.String\");\n         }\n      *                  if a character is not mapped\n      */\n     @Override\n-    public String encode(String str) {\n+    public String encode(final String str) {\n         return soundex(str);\n     }\n \n      * @throws IllegalArgumentException\n      *                  if the character is not mapped\n      */\n-    private char getMappingCode(String str, int index) {\n+    private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n-        char mappedChar = this.map(str.charAt(index));\n+        final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            char hwChar = str.charAt(index - 1);\n+            final char hwChar = str.charAt(index - 1);\n             if ('H' == hwChar || 'W' == hwChar) {\n-                char preHWChar = str.charAt(index - 2);\n-                char firstCode = this.map(preHWChar);\n+                final char preHWChar = str.charAt(index - 2);\n+                final char firstCode = this.map(preHWChar);\n                 if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n      * @throws IllegalArgumentException\n      *                  Thrown if <code>ch</code> is not mapped.\n      */\n-    private char map(char ch) {\n-        int index = ch - 'A';\n+    private char map(final char ch) {\n+        final int index = ch - 'A';\n         if (index < 0 || index >= this.getSoundexMapping().length) {\n             throw new IllegalArgumentException(\"The character is not mapped: \" + ch);\n         }\n      *                  The maxLength to set\n      */\n     @Deprecated\n-    public void setMaxLength(int maxLength) {\n+    public void setMaxLength(final int maxLength) {\n         this.maxLength = maxLength;\n     }\n \n         if (str.length() == 0) {\n             return str;\n         }\n-        char out[] = {'0', '0', '0', '0'};\n+        final char out[] = {'0', '0', '0', '0'};\n         char last, mapped;\n         int incount = 1, count = 1;\n         out[0] = str.charAt(0);\n--- a/src/main/java/org/apache/commons/codec/language/SoundexUtils.java\n+++ b/src/main/java/org/apache/commons/codec/language/SoundexUtils.java\n      *                  The String to clean.\n      * @return A clean String.\n      */\n-    static String clean(String str) {\n+    static String clean(final String str) {\n         if (str == null || str.length() == 0) {\n             return str;\n         }\n-        int len = str.length();\n-        char[] chars = new char[len];\n+        final int len = str.length();\n+        final char[] chars = new char[len];\n         int count = 0;\n         for (int i = 0; i < len; i++) {\n             if (Character.isLetter(str.charAt(i))) {\n      * @throws EncoderException\n      *                  if an error occurs encoding one of the strings\n      */\n-    static int difference(StringEncoder encoder, String s1, String s2) throws EncoderException {\n+    static int difference(final StringEncoder encoder, final String s1, final String s2) throws EncoderException {\n         return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\n     }\n \n      * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n      *          MS T-SQL DIFFERENCE</a>\n      */\n-    static int differenceEncoded(String es1, String es2) {\n+    static int differenceEncoded(final String es1, final String es2) {\n \n         if (es1 == null || es2 == null) {\n             return 0;\n         }\n-        int lengthToMatch = Math.min(es1.length(), es2.length());\n+        final int lengthToMatch = Math.min(es1.length(), es2.length());\n         int diff = 0;\n         for (int i = 0; i < lengthToMatch; i++) {\n             if (es1.charAt(i) == es2.charAt(i)) {\n--- a/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n     private PhoneticEngine engine = new PhoneticEngine(NameType.GENERIC, RuleType.APPROX, true);\n \n     @Override\n-    public Object encode(Object source) throws EncoderException {\n+    public Object encode(final Object source) throws EncoderException {\n         if (!(source instanceof String)) {\n             throw new EncoderException(\"BeiderMorseEncoder encode parameter is not of type String\");\n         }\n     }\n \n     @Override\n-    public String encode(String source) throws EncoderException {\n+    public String encode(final String source) throws EncoderException {\n         if (source == null) {\n             return null;\n         }\n      *            true if multiple encodings are to be combined with a '|', false if just the first one is\n      *            to be considered\n      */\n-    public void setConcat(boolean concat) {\n+    public void setConcat(final boolean concat) {\n         this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                          this.engine.getRuleType(),\n                                          concat,\n      * @param nameType\n      *            the NameType in use\n      */\n-    public void setNameType(NameType nameType) {\n+    public void setNameType(final NameType nameType) {\n         this.engine = new PhoneticEngine(nameType,\n                                          this.engine.getRuleType(),\n                                          this.engine.isConcat(),\n      * @param ruleType\n      *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches\n      */\n-    public void setRuleType(RuleType ruleType) {\n+    public void setRuleType(final RuleType ruleType) {\n         this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                          ruleType,\n                                          this.engine.isConcat(),\n      *            the maximum number of phonemes returned by the engine\n      * @since 1.7\n      */\n-    public void setMaxPhonemes(int maxPhonemes) {\n+    public void setMaxPhonemes(final int maxPhonemes) {\n         this.engine = new PhoneticEngine(this.engine.getNameType(),\n                                          this.engine.getRuleType(),\n                                          this.engine.isConcat(),\n--- a/src/main/java/org/apache/commons/codec/language/bm/Lang.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Lang.java\n         private final Set<String> languages;\n         private final Pattern pattern;\n \n-        private LangRule(Pattern pattern, Set<String> languages, boolean acceptOnMatch) {\n+        private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch) {\n             this.pattern = pattern;\n             this.languages = languages;\n             this.acceptOnMatch = acceptOnMatch;\n         }\n \n-        public boolean matches(String txt) {\n+        public boolean matches(final String txt) {\n             return this.pattern.matcher(txt).find();\n         }\n     }\n     private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/lang.txt\";\n \n     static {\n-        for (NameType s : NameType.values()) {\n+        for (final NameType s : NameType.values()) {\n             Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s)));\n         }\n     }\n      *            the NameType to look up\n      * @return a Lang encapsulating the language guessing rules for that name type\n      */\n-    public static Lang instance(NameType nameType) {\n+    public static Lang instance(final NameType nameType) {\n         return Langs.get(nameType);\n     }\n \n      *            the languages that these rules will support\n      * @return a Lang encapsulating the loaded language-guessing rules.\n      */\n-    public static Lang loadFromResource(String languageRulesResourceName, Languages languages) {\n-        List<LangRule> rules = new ArrayList<LangRule>();\n-        InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\n+    public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\n+        final List<LangRule> rules = new ArrayList<LangRule>();\n+        final InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\n \n         if (lRulesIS == null) {\n             throw new IllegalStateException(\"Unable to resolve required resource:\" + LANGUAGE_RULES_RN);\n         }\n \n-        Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\n+        final Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\n         boolean inExtendedComment = false;\n         while (scanner.hasNextLine()) {\n-            String rawLine = scanner.nextLine();\n+            final String rawLine = scanner.nextLine();\n             String line = rawLine;\n \n             if (inExtendedComment) {\n                     inExtendedComment = true;\n                 } else {\n                     // discard comments\n-                    int cmtI = line.indexOf(ResourceConstants.CMT);\n+                    final int cmtI = line.indexOf(ResourceConstants.CMT);\n                     if (cmtI >= 0) {\n                         line = line.substring(0, cmtI);\n                     }\n                     }\n \n                     // split it up\n-                    String[] parts = line.split(\"\\\\s+\");\n+                    final String[] parts = line.split(\"\\\\s+\");\n \n                     if (parts.length != 3) {\n                         throw new IllegalArgumentException(\"Malformed line '\" + rawLine + \"' in language resource '\" +\n                                                            languageRulesResourceName + \"'\");\n                     }\n \n-                    Pattern pattern = Pattern.compile(parts[0]);\n-                    String[] langs = parts[1].split(\"\\\\+\");\n-                    boolean accept = parts[2].equals(\"true\");\n+                    final Pattern pattern = Pattern.compile(parts[0]);\n+                    final String[] langs = parts[1].split(\"\\\\+\");\n+                    final boolean accept = parts[2].equals(\"true\");\n \n                     rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\n                 }\n     private final Languages languages;\n     private final List<LangRule> rules;\n \n-    private Lang(List<LangRule> rules, Languages languages) {\n+    private Lang(final List<LangRule> rules, final Languages languages) {\n         this.rules = Collections.unmodifiableList(rules);\n         this.languages = languages;\n     }\n      *            the word\n      * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match\n      */\n-    public String guessLanguage(String text) {\n-        Languages.LanguageSet ls = guessLanguages(text);\n+    public String guessLanguage(final String text) {\n+        final Languages.LanguageSet ls = guessLanguages(text);\n         return ls.isSingleton() ? ls.getAny() : Languages.ANY;\n     }\n \n      *            the word\n      * @return a Set of Strings of language names that are potential matches for the input word\n      */\n-    public Languages.LanguageSet guessLanguages(String input) {\n-        String text = input.toLowerCase(Locale.ENGLISH);\n-\n-        Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n-        for (LangRule rule : this.rules) {\n+    public Languages.LanguageSet guessLanguages(final String input) {\n+        final String text = input.toLowerCase(Locale.ENGLISH);\n+\n+        final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n+        for (final LangRule rule : this.rules) {\n             if (rule.matches(text)) {\n                 if (rule.acceptOnMatch) {\n                     langs.retainAll(rule.languages);\n             }\n         }\n \n-        Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\n+        final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\n         return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/language/bm/Languages.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Languages.java\n      */\n     public static abstract class LanguageSet {\n \n-        public static LanguageSet from(Set<String> langs) {\n+        public static LanguageSet from(final Set<String> langs) {\n             return langs.isEmpty() ? NO_LANGUAGES : new SomeLanguages(langs);\n         }\n \n     public static final class SomeLanguages extends LanguageSet {\n         private final Set<String> languages;\n \n-        private SomeLanguages(Set<String> languages) {\n+        private SomeLanguages(final Set<String> languages) {\n             this.languages = Collections.unmodifiableSet(languages);\n         }\n \n         @Override\n-        public boolean contains(String language) {\n+        public boolean contains(final String language) {\n             return this.languages.contains(language);\n         }\n \n         }\n \n         @Override\n-        public LanguageSet restrictTo(LanguageSet other) {\n+        public LanguageSet restrictTo(final LanguageSet other) {\n             if (other == NO_LANGUAGES) {\n                 return other;\n             } else if (other == ANY_LANGUAGE) {\n                 return this;\n             } else {\n-                SomeLanguages sl = (SomeLanguages) other;\n+                final SomeLanguages sl = (SomeLanguages) other;\n                 if (sl.languages.containsAll(languages)) {\n                     return this;\n                 } else {\n-                    Set<String> ls = new HashSet<String>(this.languages);\n+                    final Set<String> ls = new HashSet<String>(this.languages);\n                     ls.retainAll(sl.languages);\n                     return from(ls);\n                 }\n     private static final Map<NameType, Languages> LANGUAGES = new EnumMap<NameType, Languages>(NameType.class);\n \n     static {\n-        for (NameType s : NameType.values()) {\n+        for (final NameType s : NameType.values()) {\n             LANGUAGES.put(s, getInstance(langResourceName(s)));\n         }\n     }\n \n-    public static Languages getInstance(NameType nameType) {\n+    public static Languages getInstance(final NameType nameType) {\n         return LANGUAGES.get(nameType);\n     }\n \n-    public static Languages getInstance(String languagesResourceName) {\n+    public static Languages getInstance(final String languagesResourceName) {\n         // read languages list\n-        Set<String> ls = new HashSet<String>();\n-        InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName);\n+        final Set<String> ls = new HashSet<String>();\n+        final InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName);\n \n         if (langIS == null) {\n             throw new IllegalArgumentException(\"Unable to resolve required resource: \" + languagesResourceName);\n         }\n \n-        Scanner lsScanner = new Scanner(langIS, ResourceConstants.ENCODING);\n+        final Scanner lsScanner = new Scanner(langIS, ResourceConstants.ENCODING);\n         boolean inExtendedComment = false;\n         while (lsScanner.hasNextLine()) {\n-            String line = lsScanner.nextLine().trim();\n+            final String line = lsScanner.nextLine().trim();\n             if (inExtendedComment) {\n                 if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n                     inExtendedComment = false;\n         return new Languages(Collections.unmodifiableSet(ls));\n     }\n \n-    private static String langResourceName(NameType nameType) {\n+    private static String langResourceName(final NameType nameType) {\n         return String.format(\"org/apache/commons/codec/language/bm/%s_languages.txt\", nameType.getName());\n     }\n \n      */\n     public static final LanguageSet NO_LANGUAGES = new LanguageSet() {\n         @Override\n-        public boolean contains(String language) {\n+        public boolean contains(final String language) {\n             return false;\n         }\n \n         }\n \n         @Override\n-        public LanguageSet restrictTo(LanguageSet other) {\n+        public LanguageSet restrictTo(final LanguageSet other) {\n             return this;\n         }\n \n      */\n     public static final LanguageSet ANY_LANGUAGE = new LanguageSet() {\n         @Override\n-        public boolean contains(String language) {\n+        public boolean contains(final String language) {\n             return true;\n         }\n \n         }\n \n         @Override\n-        public LanguageSet restrictTo(LanguageSet other) {\n+        public LanguageSet restrictTo(final LanguageSet other) {\n             return other;\n         }\n \n         }\n     };\n \n-    private Languages(Set<String> languages) {\n+    private Languages(final Set<String> languages) {\n         this.languages = languages;\n     }\n \n--- a/src/main/java/org/apache/commons/codec/language/bm/NameType.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/NameType.java\n \n     private final String name;\n \n-    NameType(String name) {\n+    NameType(final String name) {\n         this.name = name;\n     }\n \n--- a/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n          * @param languages the set of languages\n          * @return  a new, empty phoneme builder\n          */\n-        public static PhonemeBuilder empty(Languages.LanguageSet languages) {\n+        public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\n             return new PhonemeBuilder(Collections.singleton(new Rule.Phoneme(\"\", languages)));\n         }\n \n         private final Set<Rule.Phoneme> phonemes;\n \n-        private PhonemeBuilder(Set<Rule.Phoneme> phonemes) {\n+        private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {\n             this.phonemes = phonemes;\n         }\n \n          * @param str   the characters to append to the phonemes\n          * @return  a new phoneme builder lenghtened by <code>str</code>\n          */\n-        public PhonemeBuilder append(CharSequence str) {\n-            Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>();\n-\n-            for (Rule.Phoneme ph : this.phonemes) {\n+        public PhonemeBuilder append(final CharSequence str) {\n+            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>();\n+\n+            for (final Rule.Phoneme ph : this.phonemes) {\n                 newPhonemes.add(ph.append(str));\n             }\n \n          * @return  a new phoneme builder containing the results of <code>phonemeExpr</code> applied to each phoneme\n          *      in turn\n          */\n-        public PhonemeBuilder apply(Rule.PhonemeExpr phonemeExpr, int maxPhonemes) {\n-            Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>();\n-\n-            EXPR: for (Rule.Phoneme left : this.phonemes) {\n-                for (Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n-                    Rule.Phoneme join = left.join(right);\n+        public PhonemeBuilder apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\n+            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>();\n+\n+            EXPR: for (final Rule.Phoneme left : this.phonemes) {\n+                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n+                    final Rule.Phoneme join = left.join(right);\n                     if (!join.getLanguages().isEmpty()) {\n                         if (newPhonemes.size() < maxPhonemes) {\n                             newPhonemes.add(join);\n         public String makeString() {\n             final StringBuilder sb = new StringBuilder();\n \n-            for (Rule.Phoneme ph : this.phonemes) {\n+            for (final Rule.Phoneme ph : this.phonemes) {\n                 if (sb.length() > 0) {\n                     sb.append(\"|\");\n                 }\n \n         private PhonemeBuilder phonemeBuilder;\n         private int i;\n-        private int maxPhonemes;\n+        private final int maxPhonemes;\n         private boolean found;\n \n-        public RulesApplication(List<Rule> finalRules, CharSequence input,\n-                                PhonemeBuilder phonemeBuilder, int i, int maxPhonemes) {\n+        public RulesApplication(final List<Rule> finalRules, final CharSequence input,\n+                                final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {\n             if (finalRules == null) {\n                 throw new NullPointerException(\"The finalRules argument must not be null\");\n             }\n         public RulesApplication invoke() {\n             this.found = false;\n             int patternLength = 0;\n-            for (Rule rule : this.finalRules) {\n-                String pattern = rule.getPattern();\n+            for (final Rule rule : this.finalRules) {\n+                final String pattern = rule.getPattern();\n                 patternLength = pattern.length();\n \n                 if (!rule.patternAndContextMatches(this.input, this.i)) {\n         final CharSequence[][] cache = new CharSequence[cached.length()][cached.length()];\n         return new CharSequence() {\n             @Override\n-            public char charAt(int index) {\n+            public char charAt(final int index) {\n                 return cached.charAt(index);\n             }\n \n             }\n \n             @Override\n-            public CharSequence subSequence(int start, int end) {\n+            public CharSequence subSequence(final int start, final int end) {\n                 if (start == end) {\n                     return \"\";\n                 }\n      * @param sep       String to separate them with\n      * @return a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>\n      */\n-    private static String join(Iterable<String> strings, String sep) {\n-        StringBuilder sb = new StringBuilder();\n-        Iterator<String> si = strings.iterator();\n+    private static String join(final Iterable<String> strings, final String sep) {\n+        final StringBuilder sb = new StringBuilder();\n+        final Iterator<String> si = strings.iterator();\n         if (si.hasNext()) {\n             sb.append(si.next());\n         }\n      * @param concat\n      *            if it will concatenate multiple encodings\n      */\n-    public PhoneticEngine(NameType nameType, RuleType ruleType, boolean concat) {\n+    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\n         this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);\n     }\n \n      *            the maximum number of phonemes that will be handled\n      * @since 1.7\n      */\n-    public PhoneticEngine(NameType nameType, RuleType ruleType, boolean concat, int maxPhonemes) {\n+    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat, final int maxPhonemes) {\n         if (ruleType == RuleType.RULES) {\n             throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES);\n         }\n      * @param finalRules the final rules to apply\n      * @return the resulting phonemes\n      */\n-    private PhonemeBuilder applyFinalRules(PhonemeBuilder phonemeBuilder, List<Rule> finalRules) {\n+    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder, final List<Rule> finalRules) {\n         if (finalRules == null) {\n             throw new NullPointerException(\"finalRules can not be null\");\n         }\n             return phonemeBuilder;\n         }\n \n-        Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n-\n-        for (Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n+        final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n+\n+        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n             PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n-            CharSequence phonemeText = cacheSubSequence(phoneme.getPhonemeText());\n+            final CharSequence phonemeText = cacheSubSequence(phoneme.getPhonemeText());\n \n             for (int i = 0; i < phonemeText.length();) {\n-                RulesApplication rulesApplication =\n+                final RulesApplication rulesApplication =\n                         new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\n-                boolean found = rulesApplication.isFound();\n+                final boolean found = rulesApplication.isFound();\n                 subBuilder = rulesApplication.getPhonemeBuilder();\n \n                 if (!found) {\n      *            the String to encode\n      * @return the encoding of the input\n      */\n-    public String encode(String input) {\n-        Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\n+    public String encode(final String input) {\n+        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\n         return encode(input, languageSet);\n     }\n \n \n         if (this.nameType == NameType.GENERIC) {\n             if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d'\n-                String remainder = input.substring(2);\n-                String combined = \"d\" + remainder;\n+                final String remainder = input.substring(2);\n+                final String combined = \"d\" + remainder;\n                 return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n             }\n-            for (String l : NAME_PREFIXES.get(this.nameType)) {\n+            for (final String l : NAME_PREFIXES.get(this.nameType)) {\n                 // handle generic prefixes\n                 if (input.startsWith(l + \" \")) {\n                     // check for any prefix in the words list\n-                    String remainder = input.substring(l.length() + 1); // input without the prefix\n-                    String combined = l + remainder; // input with prefix without space\n+                    final String remainder = input.substring(l.length() + 1); // input without the prefix\n+                    final String combined = l + remainder; // input with prefix without space\n                     return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n                 }\n             }\n         // special-case handling of word prefixes based upon the name type\n         switch (this.nameType) {\n         case SEPHARDIC:\n-            for (String aWord : words) {\n-                String[] parts = aWord.split(\"'\");\n-                String lastPart = parts[parts.length - 1];\n+            for (final String aWord : words) {\n+                final String[] parts = aWord.split(\"'\");\n+                final String lastPart = parts[parts.length - 1];\n                 words2.add(lastPart);\n             }\n             words2.removeAll(NAME_PREFIXES.get(this.nameType));\n             input = words.iterator().next();\n         } else {\n             // encode each word in a multi-word name separately (normally used for approx matches)\n-            StringBuilder result = new StringBuilder();\n-            for (String word : words2) {\n+            final StringBuilder result = new StringBuilder();\n+            for (final String word : words2) {\n                 result.append(\"-\").append(encode(word));\n             }\n             // return the result without the leading \"-\"\n         PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n \n         // loop over each char in the input - we will handle the increment manually\n-        CharSequence inputCache = cacheSubSequence(input);\n+        final CharSequence inputCache = cacheSubSequence(input);\n         for (int i = 0; i < inputCache.length();) {\n-            RulesApplication rulesApplication =\n+            final RulesApplication rulesApplication =\n                     new RulesApplication(rules, inputCache, phonemeBuilder, i, maxPhonemes).invoke();\n             i = rulesApplication.getI();\n             phonemeBuilder = rulesApplication.getPhonemeBuilder();\n--- a/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n     public static final class Phoneme implements PhonemeExpr {\n         public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() {\n             @Override\n-            public int compare(Phoneme o1, Phoneme o2) {\n+            public int compare(final Phoneme o1, final Phoneme o2) {\n                 for (int i = 0; i < o1.phonemeText.length(); i++) {\n                     if (i >= o2.phonemeText.length()) {\n                         return +1;\n                     }\n-                    int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\n+                    final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\n                     if (c != 0) {\n                         return c;\n                     }\n         private final CharSequence phonemeText;\n         private final Languages.LanguageSet languages;\n \n-        public Phoneme(CharSequence phonemeText, Languages.LanguageSet languages) {\n+        public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {\n             this.phonemeText = phonemeText;\n             this.languages = languages;\n         }\n \n-        public Phoneme append(CharSequence str) {\n+        public Phoneme append(final CharSequence str) {\n             return new Phoneme(this.phonemeText.toString() + str.toString(), this.languages);\n         }\n \n             return this.phonemeText;\n         }\n \n-        public Phoneme join(Phoneme right) {\n+        public Phoneme join(final Phoneme right) {\n             return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),\n                                this.languages.restrictTo(right.languages));\n         }\n     public static final class PhonemeList implements PhonemeExpr {\n         private final List<Phoneme> phonemes;\n \n-        public PhonemeList(List<Phoneme> phonemes) {\n+        public PhonemeList(final List<Phoneme> phonemes) {\n             this.phonemes = phonemes;\n         }\n \n \n     public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {\n         @Override\n-        public boolean isMatch(CharSequence input) {\n+        public boolean isMatch(final CharSequence input) {\n             return true;\n         }\n     };\n             new EnumMap<NameType, Map<RuleType, Map<String, List<Rule>>>>(NameType.class);\n \n     static {\n-        for (NameType s : NameType.values()) {\n-            Map<RuleType, Map<String, List<Rule>>> rts = new EnumMap<RuleType, Map<String, List<Rule>>>(RuleType.class);\n-\n-            for (RuleType rt : RuleType.values()) {\n-                Map<String, List<Rule>> rs = new HashMap<String, List<Rule>>();\n-\n-                Languages ls = Languages.getInstance(s);\n-                for (String l : ls.getLanguages()) {\n+        for (final NameType s : NameType.values()) {\n+            final Map<RuleType, Map<String, List<Rule>>> rts = new EnumMap<RuleType, Map<String, List<Rule>>>(RuleType.class);\n+\n+            for (final RuleType rt : RuleType.values()) {\n+                final Map<String, List<Rule>> rs = new HashMap<String, List<Rule>>();\n+\n+                final Languages ls = Languages.getInstance(s);\n+                for (final String l : ls.getLanguages()) {\n                     try {\n                         rs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l)));\n-                    } catch (IllegalStateException e) {\n+                    } catch (final IllegalStateException e) {\n                         throw new IllegalStateException(\"Problem processing \" + createResourceName(s, rt, l), e);\n                     }\n                 }\n         }\n     }\n \n-    private static boolean contains(CharSequence chars, char input) {\n+    private static boolean contains(final CharSequence chars, final char input) {\n         for (int i = 0; i < chars.length(); i++) {\n             if (chars.charAt(i) == input) {\n                 return true;\n         return false;\n     }\n \n-    private static String createResourceName(NameType nameType, RuleType rt, String lang) {\n+    private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {\n         return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\",\n                              nameType.getName(), rt.getName(), lang);\n     }\n \n-    private static Scanner createScanner(NameType nameType, RuleType rt, String lang) {\n-        String resName = createResourceName(nameType, rt, lang);\n-        InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n+    private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {\n+        final String resName = createResourceName(nameType, rt, lang);\n+        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n \n         if (rulesIS == null) {\n             throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n         return new Scanner(rulesIS, ResourceConstants.ENCODING);\n     }\n \n-    private static Scanner createScanner(String lang) {\n-        String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\n-        InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n+    private static Scanner createScanner(final String lang) {\n+        final String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\n+        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n \n         if (rulesIS == null) {\n             throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n         return new Scanner(rulesIS, ResourceConstants.ENCODING);\n     }\n \n-    private static boolean endsWith(CharSequence input, CharSequence suffix) {\n+    private static boolean endsWith(final CharSequence input, final CharSequence suffix) {\n         if (suffix.length() > input.length()) {\n             return false;\n         }\n      *            the set of languages to consider\n      * @return a list of Rules that apply\n      */\n-    public static List<Rule> getInstance(NameType nameType, RuleType rt, Languages.LanguageSet langs) {\n+    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs) {\n         return langs.isSingleton() ? getInstance(nameType, rt, langs.getAny()) :\n                                      getInstance(nameType, rt, Languages.ANY);\n     }\n      *            the language to consider\n      * @return a list rules for a combination of name type, rule type and a single language.\n      */\n-    public static List<Rule> getInstance(NameType nameType, RuleType rt, String lang) {\n-        List<Rule> rules = RULES.get(nameType).get(rt).get(lang);\n+    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {\n+        final List<Rule> rules = RULES.get(nameType).get(rt).get(lang);\n \n         if (rules == null) {\n             throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\",\n         return rules;\n     }\n \n-    private static Phoneme parsePhoneme(String ph) {\n-        int open = ph.indexOf(\"[\");\n+    private static Phoneme parsePhoneme(final String ph) {\n+        final int open = ph.indexOf(\"[\");\n         if (open >= 0) {\n             if (!ph.endsWith(\"]\")) {\n                 throw new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\");\n             }\n-            String before = ph.substring(0, open);\n-            String in = ph.substring(open + 1, ph.length() - 1);\n-            Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\n+            final String before = ph.substring(0, open);\n+            final String in = ph.substring(open + 1, ph.length() - 1);\n+            final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\n \n             return new Phoneme(before, Languages.LanguageSet.from(langs));\n         } else {\n         }\n     }\n \n-    private static PhonemeExpr parsePhonemeExpr(String ph) {\n+    private static PhonemeExpr parsePhonemeExpr(final String ph) {\n         if (ph.startsWith(\"(\")) { // we have a bracketed list of options\n             if (!ph.endsWith(\")\")) {\n                 throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\");\n             }\n \n-            List<Phoneme> phs = new ArrayList<Phoneme>();\n-            String body = ph.substring(1, ph.length() - 1);\n-            for (String part : body.split(\"[|]\")) {\n+            final List<Phoneme> phs = new ArrayList<Phoneme>();\n+            final String body = ph.substring(1, ph.length() - 1);\n+            for (final String part : body.split(\"[|]\")) {\n                 phs.add(parsePhoneme(part));\n             }\n             if (body.startsWith(\"|\") || body.endsWith(\"|\")) {\n     }\n \n     private static List<Rule> parseRules(final Scanner scanner, final String location) {\n-        List<Rule> lines = new ArrayList<Rule>();\n+        final List<Rule> lines = new ArrayList<Rule>();\n         int currentLine = 0;\n \n         boolean inMultilineComment = false;\n         while (scanner.hasNextLine()) {\n             currentLine++;\n-            String rawLine = scanner.nextLine();\n+            final String rawLine = scanner.nextLine();\n             String line = rawLine;\n \n             if (inMultilineComment) {\n                     inMultilineComment = true;\n                 } else {\n                     // discard comments\n-                    int cmtI = line.indexOf(ResourceConstants.CMT);\n+                    final int cmtI = line.indexOf(ResourceConstants.CMT);\n                     if (cmtI >= 0) {\n                         line = line.substring(0, cmtI);\n                     }\n \n                     if (line.startsWith(HASH_INCLUDE)) {\n                         // include statement\n-                        String incl = line.substring(HASH_INCLUDE.length()).trim();\n+                        final String incl = line.substring(HASH_INCLUDE.length()).trim();\n                         if (incl.contains(\" \")) {\n                             throw new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" +\n                                                                location);\n                         }\n                     } else {\n                         // rule\n-                        String[] parts = line.split(\"\\\\s+\");\n+                        final String[] parts = line.split(\"\\\\s+\");\n                         if (parts.length != 4) {\n                             throw new IllegalArgumentException(\"Malformed rule statement split into \" + parts.length +\n                                                                \" parts: \" + rawLine + \" in \" + location);\n                         } else {\n                             try {\n-                                String pat = stripQuotes(parts[0]);\n-                                String lCon = stripQuotes(parts[1]);\n-                                String rCon = stripQuotes(parts[2]);\n-                                PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\n+                                final String pat = stripQuotes(parts[0]);\n+                                final String lCon = stripQuotes(parts[1]);\n+                                final String rCon = stripQuotes(parts[2]);\n+                                final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\n                                 final int cLine = currentLine;\n-                                Rule r = new Rule(pat, lCon, rCon, ph) {\n+                                final Rule r = new Rule(pat, lCon, rCon, ph) {\n                                     private final int myLine = cLine;\n                                     private final String loc = location;\n \n                                     }\n                                 };\n                                 lines.add(r);\n-                            } catch (IllegalArgumentException e) {\n+                            } catch (final IllegalArgumentException e) {\n                                 throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" +\n                                                                 location, e);\n                             }\n      * @return an RPattern that will match this regex\n      */\n     private static RPattern pattern(final String regex) {\n-        boolean startsWith = regex.startsWith(\"^\");\n-        boolean endsWith = regex.endsWith(\"$\");\n+        final boolean startsWith = regex.startsWith(\"^\");\n+        final boolean endsWith = regex.endsWith(\"$\");\n         final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\n-        boolean boxes = content.contains(\"[\");\n+        final boolean boxes = content.contains(\"[\");\n \n         if (!boxes) {\n             if (startsWith && endsWith) {\n                     // empty\n                     return new RPattern() {\n                         @Override\n-                        public boolean isMatch(CharSequence input) {\n+                        public boolean isMatch(final CharSequence input) {\n                             return input.length() == 0;\n                         }\n                     };\n                 } else {\n                     return new RPattern() {\n                         @Override\n-                        public boolean isMatch(CharSequence input) {\n+                        public boolean isMatch(final CharSequence input) {\n                             return input.equals(content);\n                         }\n                     };\n                 // matches from start\n                 return new RPattern() {\n                     @Override\n-                    public boolean isMatch(CharSequence input) {\n+                    public boolean isMatch(final CharSequence input) {\n                         return startsWith(input, content);\n                     }\n                 };\n                 // matches from start\n                 return new RPattern() {\n                     @Override\n-                    public boolean isMatch(CharSequence input) {\n+                    public boolean isMatch(final CharSequence input) {\n                         return endsWith(input, content);\n                     }\n                 };\n             }\n         } else {\n-            boolean startsWithBox = content.startsWith(\"[\");\n-            boolean endsWithBox = content.endsWith(\"]\");\n+            final boolean startsWithBox = content.startsWith(\"[\");\n+            final boolean endsWithBox = content.endsWith(\"]\");\n \n             if (startsWithBox && endsWithBox) {\n                 String boxContent = content.substring(1, content.length() - 1);\n                 if (!boxContent.contains(\"[\")) {\n                     // box containing alternatives\n-                    boolean negate = boxContent.startsWith(\"^\");\n+                    final boolean negate = boxContent.startsWith(\"^\");\n                     if (negate) {\n                         boxContent = boxContent.substring(1);\n                     }\n                         // exact match\n                         return new RPattern() {\n                             @Override\n-                            public boolean isMatch(CharSequence input) {\n+                            public boolean isMatch(final CharSequence input) {\n                                 return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\n                             }\n                         };\n                         // first char\n                         return new RPattern() {\n                             @Override\n-                            public boolean isMatch(CharSequence input) {\n+                            public boolean isMatch(final CharSequence input) {\n                                 return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\n                             }\n                         };\n                         // last char\n                         return new RPattern() {\n                             @Override\n-                            public boolean isMatch(CharSequence input) {\n+                            public boolean isMatch(final CharSequence input) {\n                                 return input.length() > 0 &&\n                                        contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\n                             }\n             Pattern pattern = Pattern.compile(regex);\n \n             @Override\n-            public boolean isMatch(CharSequence input) {\n-                Matcher matcher = pattern.matcher(input);\n+            public boolean isMatch(final CharSequence input) {\n+                final Matcher matcher = pattern.matcher(input);\n                 return matcher.find();\n             }\n         };\n     }\n \n-    private static boolean startsWith(CharSequence input, CharSequence prefix) {\n+    private static boolean startsWith(final CharSequence input, final CharSequence prefix) {\n         if (prefix.length() > input.length()) {\n             return false;\n         }\n      * @param phoneme\n      *            the resulting phoneme\n      */\n-    public Rule(String pattern, String lContext, String rContext, PhonemeExpr phoneme) {\n+    public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {\n         this.pattern = pattern;\n         this.lContext = pattern(lContext + \"$\");\n         this.rContext = pattern(\"^\" + rContext);\n      *            the int position within the input\n      * @return true if the pattern and left/right context match, false otherwise\n      */\n-    public boolean patternAndContextMatches(CharSequence input, int i) {\n+    public boolean patternAndContextMatches(final CharSequence input, final int i) {\n         if (i < 0) {\n             throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n         }\n \n-        int patternLength = this.pattern.length();\n-        int ipl = i + patternLength;\n+        final int patternLength = this.pattern.length();\n+        final int ipl = i + patternLength;\n \n         if (ipl > input.length()) {\n             // not enough room for the pattern to match\n--- a/src/main/java/org/apache/commons/codec/language/bm/RuleType.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/RuleType.java\n \n     private final String name;\n \n-    RuleType(String name) {\n+    RuleType(final String name) {\n         this.name = name;\n     }\n \n--- a/src/main/java/org/apache/commons/codec/net/BCodec.java\n+++ b/src/main/java/org/apache/commons/codec/net/BCodec.java\n     }\n \n     @Override\n-    protected byte[] doEncoding(byte[] bytes) {\n+    protected byte[] doEncoding(final byte[] bytes) {\n         if (bytes == null) {\n             return null;\n         }\n     }\n \n     @Override\n-    protected byte[] doDecoding(byte[] bytes) {\n+    protected byte[] doDecoding(final byte[] bytes) {\n         if (bytes == null) {\n             return null;\n         }\n         }\n         try {\n             return this.encodeText(value, charset);\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw new EncoderException(e.getMessage(), e);\n         }\n     }\n      *             thrown if a failure condition is encountered during the encoding process.\n      */\n     @Override\n-    public String encode(String value) throws EncoderException {\n+    public String encode(final String value) throws EncoderException {\n         if (value == null) {\n             return null;\n         }\n      *             A decoder exception is thrown if a failure condition is encountered during the decode process.\n      */\n     @Override\n-    public String decode(String value) throws DecoderException {\n+    public String decode(final String value) throws DecoderException {\n         if (value == null) {\n             return null;\n         }\n         try {\n             return this.decodeText(value);\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw new DecoderException(e.getMessage(), e);\n         }\n     }\n      *             thrown if a failure condition is encountered during the encoding process.\n      */\n     @Override\n-    public Object encode(Object value) throws EncoderException {\n+    public Object encode(final Object value) throws EncoderException {\n         if (value == null) {\n             return null;\n         } else if (value instanceof String) {\n      *             during the decode process.\n      */\n     @Override\n-    public Object decode(Object value) throws DecoderException {\n+    public Object decode(final Object value) throws DecoderException {\n         if (value == null) {\n             return null;\n         } else if (value instanceof String) {\n--- a/src/main/java/org/apache/commons/codec/net/QCodec.java\n+++ b/src/main/java/org/apache/commons/codec/net/QCodec.java\n     }\n \n     @Override\n-    protected byte[] doEncoding(byte[] bytes) {\n+    protected byte[] doEncoding(final byte[] bytes) {\n         if (bytes == null) {\n             return null;\n         }\n-        byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n+        final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n         if (this.encodeBlanks) {\n             for (int i = 0; i < data.length; i++) {\n                 if (data[i] == BLANK) {\n     }\n \n     @Override\n-    protected byte[] doDecoding(byte[] bytes) throws DecoderException {\n+    protected byte[] doDecoding(final byte[] bytes) throws DecoderException {\n         if (bytes == null) {\n             return null;\n         }\n         boolean hasUnderscores = false;\n-        for (byte b : bytes) {\n+        for (final byte b : bytes) {\n             if (b == UNDERSCORE) {\n                 hasUnderscores = true;\n                 break;\n             }\n         }\n         if (hasUnderscores) {\n-            byte[] tmp = new byte[bytes.length];\n+            final byte[] tmp = new byte[bytes.length];\n             for (int i = 0; i < bytes.length; i++) {\n-                byte b = bytes[i];\n+                final byte b = bytes[i];\n                 if (b != UNDERSCORE) {\n                     tmp[i] = b;\n                 } else {\n         }\n         try {\n             return encodeText(str, charset);\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw new EncoderException(e.getMessage(), e);\n         }\n     }\n      *             thrown if a failure condition is encountered during the encoding process.\n      */\n     @Override\n-    public String encode(String str) throws EncoderException {\n+    public String encode(final String str) throws EncoderException {\n         if (str == null) {\n             return null;\n         }\n      *             A decoder exception is thrown if a failure condition is encountered during the decode process.\n      */\n     @Override\n-    public String decode(String str) throws DecoderException {\n+    public String decode(final String str) throws DecoderException {\n         if (str == null) {\n             return null;\n         }\n         try {\n             return decodeText(str);\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw new DecoderException(e.getMessage(), e);\n         }\n     }\n      *             thrown if a failure condition is encountered during the encoding process.\n      */\n     @Override\n-    public Object encode(Object obj) throws EncoderException {\n+    public Object encode(final Object obj) throws EncoderException {\n         if (obj == null) {\n             return null;\n         } else if (obj instanceof String) {\n      *             during the decode process.\n      */\n     @Override\n-    public Object decode(Object obj) throws DecoderException {\n+    public Object decode(final Object obj) throws DecoderException {\n         if (obj == null) {\n             return null;\n         } else if (obj instanceof String) {\n      * @param b\n      *            {@code true} if SPACE characters are to be transformed, {@code false} otherwise\n      */\n-    public void setEncodeBlanks(boolean b) {\n+    public void setEncodeBlanks(final boolean b) {\n         this.encodeBlanks = b;\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n+++ b/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n      *            the default string charset to use.\n      * @since 1.7\n      */\n-    public QuotedPrintableCodec(Charset charset) {\n+    public QuotedPrintableCodec(final Charset charset) {\n         this.charset = charset;\n     }\n \n      *\n      * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n      */\n-    public QuotedPrintableCodec(String charsetName)\n+    public QuotedPrintableCodec(final String charsetName)\n             throws IllegalCharsetNameException, IllegalArgumentException, UnsupportedCharsetException {\n         this(Charset.forName(charsetName));\n     }\n      * @param buffer\n      *            the buffer to write to\n      */\n-    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n+    private static final void encodeQuotedPrintable(final int b, final ByteArrayOutputStream buffer) {\n         buffer.write(ESCAPE_CHAR);\n-        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n-        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n+        final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n+        final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n         buffer.write(hex1);\n         buffer.write(hex2);\n     }\n      *            array of bytes to be encoded\n      * @return array of bytes containing quoted-printable data\n      */\n-    public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n+    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {\n         if (bytes == null) {\n             return null;\n         }\n         if (printable == null) {\n             printable = PRINTABLE_CHARS;\n         }\n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        for (byte c : bytes) {\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        for (final byte c : bytes) {\n             int b = c;\n             if (b < 0) {\n                 b = 256 + b;\n      * @throws DecoderException\n      *             Thrown if quoted-printable decoding is unsuccessful\n      */\n-    public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n+    public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {\n         if (bytes == null) {\n             return null;\n         }\n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n         for (int i = 0; i < bytes.length; i++) {\n-            int b = bytes[i];\n+            final int b = bytes[i];\n             if (b == ESCAPE_CHAR) {\n                 try {\n-                    int u = Utils.digit16(bytes[++i]);\n-                    int l = Utils.digit16(bytes[++i]);\n+                    final int u = Utils.digit16(bytes[++i]);\n+                    final int l = Utils.digit16(bytes[++i]);\n                     buffer.write((char) ((u << 4) + l));\n-                } catch (ArrayIndexOutOfBoundsException e) {\n+                } catch (final ArrayIndexOutOfBoundsException e) {\n                     throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n                 }\n             } else {\n      * @return array of bytes containing quoted-printable data\n      */\n     @Override\n-    public byte[] encode(byte[] bytes) {\n+    public byte[] encode(final byte[] bytes) {\n         return encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n     }\n \n      *             Thrown if quoted-printable decoding is unsuccessful\n      */\n     @Override\n-    public byte[] decode(byte[] bytes) throws DecoderException {\n+    public byte[] decode(final byte[] bytes) throws DecoderException {\n         return decodeQuotedPrintable(bytes);\n     }\n \n      * @see #getCharset()\n      */\n     @Override\n-    public String encode(String str) throws EncoderException {\n+    public String encode(final String str) throws EncoderException {\n         return this.encode(str, getCharset());\n     }\n \n      *             Thrown if quoted-printable decoding is unsuccessful\n      * @since 1.7\n      */\n-    public String decode(String str, Charset charset) throws DecoderException {\n+    public String decode(final String str, final Charset charset) throws DecoderException {\n         if (str == null) {\n             return null;\n         }\n      * @throws UnsupportedEncodingException\n      *             Thrown if charset is not supported\n      */\n-    public String decode(String str, String charset) throws DecoderException, UnsupportedEncodingException {\n+    public String decode(final String str, final String charset) throws DecoderException, UnsupportedEncodingException {\n         if (str == null) {\n             return null;\n         }\n      * @see #getCharset()\n      */\n     @Override\n-    public String decode(String str) throws DecoderException {\n+    public String decode(final String str) throws DecoderException {\n         return this.decode(str, this.getCharset());\n     }\n \n      *             unsuccessful\n      */\n     @Override\n-    public Object encode(Object obj) throws EncoderException {\n+    public Object encode(final Object obj) throws EncoderException {\n         if (obj == null) {\n             return null;\n         } else if (obj instanceof byte[]) {\n      *             condition is encountered during the decode process.\n      */\n     @Override\n-    public Object decode(Object obj) throws DecoderException {\n+    public Object decode(final Object obj) throws DecoderException {\n         if (obj == null) {\n             return null;\n         } else if (obj instanceof byte[]) {\n      * @return quoted-printable string\n      * @since 1.7\n      */\n-    public String encode(String str, Charset charset) {\n+    public String encode(final String str, final Charset charset) {\n         if (str == null) {\n             return null;\n         }\n      * @throws UnsupportedEncodingException\n      *             Thrown if the charset is not supported\n      */\n-    public String encode(String str, String charset) throws UnsupportedEncodingException {\n+    public String encode(final String str, final String charset) throws UnsupportedEncodingException {\n         if (str == null) {\n             return null;\n         }\n--- a/src/main/java/org/apache/commons/codec/net/RFC1522Codec.java\n+++ b/src/main/java/org/apache/commons/codec/net/RFC1522Codec.java\n         if (text == null) {\n             return null;\n         }\n-        StringBuilder buffer = new StringBuilder();\n+        final StringBuilder buffer = new StringBuilder();\n         buffer.append(PREFIX);\n         buffer.append(charset);\n         buffer.append(SEP);\n         buffer.append(this.getEncoding());\n         buffer.append(SEP);\n-        byte [] rawData = this.doEncoding(text.getBytes(charset));\n+        final byte [] rawData = this.doEncoding(text.getBytes(charset));\n         buffer.append(StringUtils.newStringUsAscii(rawData));\n         buffer.append(POSTFIX);\n         return buffer.toString();\n         if (!text.startsWith(PREFIX) || !text.endsWith(POSTFIX)) {\n             throw new DecoderException(\"RFC 1522 violation: malformed encoded content\");\n         }\n-        int terminator = text.length() - 2;\n+        final int terminator = text.length() - 2;\n         int from = 2;\n         int to = text.indexOf(SEP, from);\n         if (to == terminator) {\n             throw new DecoderException(\"RFC 1522 violation: charset token not found\");\n         }\n-        String charset = text.substring(from, to);\n+        final String charset = text.substring(from, to);\n         if (charset.equals(\"\")) {\n             throw new DecoderException(\"RFC 1522 violation: charset not specified\");\n         }\n         if (to == terminator) {\n             throw new DecoderException(\"RFC 1522 violation: encoding token not found\");\n         }\n-        String encoding = text.substring(from, to);\n+        final String encoding = text.substring(from, to);\n         if (!getEncoding().equalsIgnoreCase(encoding)) {\n             throw new DecoderException(\"This codec cannot decode \" + encoding + \" encoded content\");\n         }\n--- a/src/main/java/org/apache/commons/codec/net/URLCodec.java\n+++ b/src/main/java/org/apache/commons/codec/net/URLCodec.java\n      *\n      * @param charset the default string charset to use.\n      */\n-    public URLCodec(String charset) {\n+    public URLCodec(final String charset) {\n         super();\n         this.charset = charset;\n     }\n      *            array of bytes to convert to URL safe characters\n      * @return array of bytes containing URL safe characters\n      */\n-    public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {\n+    public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {\n         if (bytes == null) {\n             return null;\n         }\n             urlsafe = WWW_FORM_URL;\n         }\n \n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        for (byte c : bytes) {\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        for (final byte c : bytes) {\n             int b = c;\n             if (b < 0) {\n                 b = 256 + b;\n                 buffer.write(b);\n             } else {\n                 buffer.write(ESCAPE_CHAR);\n-                char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n-                char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n+                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n+                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n                 buffer.write(hex1);\n                 buffer.write(hex2);\n             }\n      * @throws DecoderException\n      *             Thrown if URL decoding is unsuccessful\n      */\n-    public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {\n+    public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {\n         if (bytes == null) {\n             return null;\n         }\n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n         for (int i = 0; i < bytes.length; i++) {\n-            int b = bytes[i];\n+            final int b = bytes[i];\n             if (b == '+') {\n                 buffer.write(' ');\n             } else if (b == ESCAPE_CHAR) {\n                 try {\n-                    int u = Utils.digit16(bytes[++i]);\n-                    int l = Utils.digit16(bytes[++i]);\n+                    final int u = Utils.digit16(bytes[++i]);\n+                    final int l = Utils.digit16(bytes[++i]);\n                     buffer.write((char) ((u << 4) + l));\n-                } catch (ArrayIndexOutOfBoundsException e) {\n+                } catch (final ArrayIndexOutOfBoundsException e) {\n                     throw new DecoderException(\"Invalid URL encoding: \", e);\n                 }\n             } else {\n      * @return array of bytes containing URL safe characters\n      */\n     @Override\n-    public byte[] encode(byte[] bytes) {\n+    public byte[] encode(final byte[] bytes) {\n         return encodeUrl(WWW_FORM_URL, bytes);\n     }\n \n      *             Thrown if URL decoding is unsuccessful\n      */\n     @Override\n-    public byte[] decode(byte[] bytes) throws DecoderException {\n+    public byte[] decode(final byte[] bytes) throws DecoderException {\n         return decodeUrl(bytes);\n     }\n \n      * @throws UnsupportedEncodingException\n      *             Thrown if charset is not supported\n      */\n-    public String encode(String str, String charset) throws UnsupportedEncodingException {\n+    public String encode(final String str, final String charset) throws UnsupportedEncodingException {\n         if (str == null) {\n             return null;\n         }\n      * @see #getDefaultCharset()\n      */\n     @Override\n-    public String encode(String str) throws EncoderException {\n+    public String encode(final String str) throws EncoderException {\n         if (str == null) {\n             return null;\n         }\n         try {\n             return encode(str, getDefaultCharset());\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw new EncoderException(e.getMessage(), e);\n         }\n     }\n      * @throws UnsupportedEncodingException\n      *             Thrown if charset is not supported\n      */\n-    public String decode(String str, String charset) throws DecoderException, UnsupportedEncodingException {\n+    public String decode(final String str, final String charset) throws DecoderException, UnsupportedEncodingException {\n         if (str == null) {\n             return null;\n         }\n      * @see #getDefaultCharset()\n      */\n     @Override\n-    public String decode(String str) throws DecoderException {\n+    public String decode(final String str) throws DecoderException {\n         if (str == null) {\n             return null;\n         }\n         try {\n             return decode(str, getDefaultCharset());\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             throw new DecoderException(e.getMessage(), e);\n         }\n     }\n      *             Thrown if URL encoding is not applicable to objects of this type or if encoding is unsuccessful\n      */\n     @Override\n-    public Object encode(Object obj) throws EncoderException {\n+    public Object encode(final Object obj) throws EncoderException {\n         if (obj == null) {\n             return null;\n         } else if (obj instanceof byte[]) {\n      *             condition is encountered during the decode process.\n      */\n     @Override\n-    public Object decode(Object obj) throws DecoderException {\n+    public Object decode(final Object obj) throws DecoderException {\n         if (obj == null) {\n             return null;\n         } else if (obj instanceof byte[]) {\n--- a/src/main/java/org/apache/commons/codec/net/Utils.java\n+++ b/src/main/java/org/apache/commons/codec/net/Utils.java\n      * @throws DecoderException\n      *             Thrown when the byte is not valid per {@link Character#digit(char,int)}\n      */\n-    static int digit16(byte b) throws DecoderException {\n-        int i = Character.digit((char) b, 16);\n+    static int digit16(final byte b) throws DecoderException {\n+        final int i = Character.digit((char) b, 16);\n         if (i == -1) {\n             throw new DecoderException(\"Invalid URL encoding: not a valid digit (radix \" + URLCodec.RADIX + \"): \" + b);\n         }\n--- a/src/test/java/org/apache/commons/codec/BinaryEncoderAbstractTest.java\n+++ b/src/test/java/org/apache/commons/codec/BinaryEncoderAbstractTest.java\n \n     @Test\n     public void testEncodeEmpty() throws Exception {\n-        BinaryEncoder encoder = makeEncoder();\n+        final BinaryEncoder encoder = makeEncoder();\n         encoder.encode(new byte[0]);\n     }\n \n     @Test\n     public void testEncodeNull() throws Exception {\n-        BinaryEncoder encoder = makeEncoder();\n+        final BinaryEncoder encoder = makeEncoder();\n         try {\n             encoder.encode(null);\n-        } catch (EncoderException ee) {\n+        } catch (final EncoderException ee) {\n             // An exception should be thrown\n         }\n     }\n--- a/src/test/java/org/apache/commons/codec/DecoderExceptionTest.java\n+++ b/src/test/java/org/apache/commons/codec/DecoderExceptionTest.java\n \n     @Test\n     public void testConstructor0() {\n-        DecoderException e = new DecoderException();\n+        final DecoderException e = new DecoderException();\n         assertNull(e.getMessage());\n         assertNull(e.getCause());\n     }\n \n     @Test\n     public void testConstructorString() {\n-        DecoderException e = new DecoderException(MSG);\n+        final DecoderException e = new DecoderException(MSG);\n         assertEquals(MSG, e.getMessage());\n         assertNull(e.getCause());\n     }\n \n     @Test\n     public void testConstructorStringThrowable() {\n-        DecoderException e = new DecoderException(MSG, t);\n+        final DecoderException e = new DecoderException(MSG, t);\n         assertEquals(MSG, e.getMessage());\n         assertEquals(t, e.getCause());\n     }\n \n     @Test\n     public void testConstructorThrowable() {\n-        DecoderException e = new DecoderException(t);\n+        final DecoderException e = new DecoderException(t);\n         assertEquals(t.getClass().getName(), e.getMessage());\n         assertEquals(t, e.getCause());\n     }\n--- a/src/test/java/org/apache/commons/codec/EncoderExceptionTest.java\n+++ b/src/test/java/org/apache/commons/codec/EncoderExceptionTest.java\n \n     @Test\n     public void testConstructor0() {\n-        EncoderException e = new EncoderException();\n+        final EncoderException e = new EncoderException();\n         assertNull(e.getMessage());\n         assertNull(e.getCause());\n     }\n \n     @Test\n     public void testConstructorString() {\n-        EncoderException e = new EncoderException(MSG);\n+        final EncoderException e = new EncoderException(MSG);\n         assertEquals(MSG, e.getMessage());\n         assertNull(e.getCause());\n     }\n \n     @Test\n     public void testConstructorStringThrowable() {\n-        EncoderException e = new EncoderException(MSG, t);\n+        final EncoderException e = new EncoderException(MSG, t);\n         assertEquals(MSG, e.getMessage());\n         assertEquals(t, e.getCause());\n     }\n \n     @Test\n     public void testConstructorThrowable() {\n-        EncoderException e = new EncoderException(t);\n+        final EncoderException e = new EncoderException(t);\n         assertEquals(t.getClass().getName(), e.getMessage());\n         assertEquals(t, e.getCause());\n     }\n--- a/src/test/java/org/apache/commons/codec/StringEncoderAbstractTest.java\n+++ b/src/test/java/org/apache/commons/codec/StringEncoderAbstractTest.java\n \n     protected T stringEncoder = this.createStringEncoder();\n \n-    public void checkEncoding(String expected, String source) throws EncoderException {\n+    public void checkEncoding(final String expected, final String source) throws EncoderException {\n         Assert.assertEquals(\"Source: \" + source, expected, this.getStringEncoder().encode(source));\n     }\n \n-    protected void checkEncodings(String[][] data) throws EncoderException {\n-        for (String[] element : data) {\n+    protected void checkEncodings(final String[][] data) throws EncoderException {\n+        for (final String[] element : data) {\n             this.checkEncoding(element[1], element[0]);\n         }\n     }\n \n-    protected void checkEncodingVariations(String expected, String data[]) throws EncoderException {\n-        for (String element : data) {\n+    protected void checkEncodingVariations(final String expected, final String data[]) throws EncoderException {\n+        for (final String element : data) {\n             this.checkEncoding(expected, element);\n         }\n     }\n \n     @Test\n     public void testEncodeEmpty() throws Exception {\n-        Encoder encoder = this.getStringEncoder();\n+        final Encoder encoder = this.getStringEncoder();\n         encoder.encode(\"\");\n         encoder.encode(\" \");\n         encoder.encode(\"\\t\");\n \n     @Test\n     public void testEncodeNull() throws Exception {\n-        StringEncoder encoder = this.getStringEncoder();\n+        final StringEncoder encoder = this.getStringEncoder();\n         try {\n             encoder.encode(null);\n-        } catch (EncoderException ee) {\n+        } catch (final EncoderException ee) {\n             // An exception should be thrown\n         }\n     }\n     public void testEncodeWithInvalidObject() throws Exception {\n         boolean exceptionThrown = false;\n         try {\n-            StringEncoder encoder = this.getStringEncoder();\n+            final StringEncoder encoder = this.getStringEncoder();\n             encoder.encode(new Float(3.4));\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             exceptionThrown = true;\n         }\n         Assert.assertTrue(\"An exception was not thrown when we tried to encode \" + \"a Float object\", exceptionThrown);\n \n     @Test\n     public void testLocaleIndependence() throws Exception {\n-        StringEncoder encoder = this.getStringEncoder();\n+        final StringEncoder encoder = this.getStringEncoder();\n \n-        String[] data = {\"I\", \"i\",};\n+        final String[] data = {\"I\", \"i\",};\n \n-        Locale orig = Locale.getDefault();\n-        Locale[] locales = {Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault()};\n+        final Locale orig = Locale.getDefault();\n+        final Locale[] locales = {Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault()};\n \n         try {\n-            for (String element : data) {\n+            for (final String element : data) {\n                 String ref = null;\n                 for (int j = 0; j < locales.length; j++) {\n                     Locale.setDefault(locales[j]);\n                         String cur = null;\n                         try {\n                             cur = encoder.encode(element);\n-                        } catch (Exception e) {\n+                        } catch (final Exception e) {\n                             Assert.fail(Locale.getDefault().toString() + \": \" + e.getMessage());\n                         }\n                         Assert.assertEquals(Locale.getDefault().toString() + \": \", ref, cur);\n--- a/src/test/java/org/apache/commons/codec/StringEncoderComparatorTest.java\n+++ b/src/test/java/org/apache/commons/codec/StringEncoderComparatorTest.java\n \n     @Test\n     public void testComparatorWithSoundex() throws Exception {\n-        StringEncoderComparator sCompare =\n+        final StringEncoderComparator sCompare =\n             new StringEncoderComparator( new Soundex() );\n \n         assertTrue( \"O'Brien and O'Brian didn't come out with \" +\n \n     @Test\n     public void testComparatorWithDoubleMetaphone() throws Exception {\n-        StringEncoderComparator sCompare = new StringEncoderComparator(new DoubleMetaphone());\n+        final StringEncoderComparator sCompare = new StringEncoderComparator(new DoubleMetaphone());\n \n-        String[] testArray = { \"Jordan\", \"Sosa\", \"Prior\", \"Pryor\" };\n-        List<String> testList = Arrays.asList(testArray);\n+        final String[] testArray = { \"Jordan\", \"Sosa\", \"Prior\", \"Pryor\" };\n+        final List<String> testList = Arrays.asList(testArray);\n \n-        String[] controlArray = { \"Jordan\", \"Prior\", \"Pryor\", \"Sosa\" };\n+        final String[] controlArray = { \"Jordan\", \"Prior\", \"Pryor\", \"Sosa\" };\n \n         Collections.sort(testList, sCompare);\n \n-        String[] resultArray = testList.toArray(new String[0]);\n+        final String[] resultArray = testList.toArray(new String[0]);\n \n         for (int i = 0; i < resultArray.length; i++) {\n             assertEquals(\"Result Array not Equal to Control Array at index: \" + i, controlArray[i], resultArray[i]);\n \n     @Test\n     public void testComparatorWithDoubleMetaphoneAndInvalidInput() throws Exception {\n-        StringEncoderComparator sCompare =\n+        final StringEncoderComparator sCompare =\n             new StringEncoderComparator( new DoubleMetaphone() );\n \n-        int compare = sCompare.compare(new Double(3.0), Long.valueOf(3));\n+        final int compare = sCompare.compare(new Double(3.0), Long.valueOf(3));\n         assertEquals( \"Trying to compare objects that make no sense to the underlying encoder should return a zero compare code\",\n                                 0, compare);\n     }\n--- a/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java\n      */\n     @Test\n     public void testCodec130() throws IOException {\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        Base32OutputStream base32os = new Base32OutputStream(bos);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final Base32OutputStream base32os = new Base32OutputStream(bos);\n \n         base32os.write(StringUtils.getBytesUtf8(STRING_FIXTURE));\n         base32os.close();\n \n-        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n-        Base32InputStream ins = new Base32InputStream(bis);\n+        final ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n+        final Base32InputStream ins = new Base32InputStream(bis);\n \n         // we skip the first character read from the reader\n         ins.skip(1);\n-        byte[] decodedBytes = Base32TestData.streamToBytes(ins, new byte[64]);\n-        String str = StringUtils.newStringUtf8(decodedBytes);\n+        final byte[] decodedBytes = Base32TestData.streamToBytes(ins, new byte[64]);\n+        final String str = StringUtils.newStringUtf8(decodedBytes);\n \n         assertEquals(STRING_FIXTURE.substring(1), str);\n     }\n      */\n     @Test\n     public void testCodec105() throws IOException {\n-        Base32InputStream in = new Base32InputStream(new Codec105ErrorInputStream(), true, 0, null);\n+        final Base32InputStream in = new Base32InputStream(new Codec105ErrorInputStream(), true, 0, null);\n         try {\n             for (int i = 0; i < 5; i++) {\n                 in.read();\n      */\n     @Test\n     public void testAvailable() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n-        Base32InputStream b32stream = new Base32InputStream(ins);\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        final Base32InputStream b32stream = new Base32InputStream(ins);\n         assertEquals(1, b32stream.available());\n         assertEquals(3, b32stream.skip(10));\n         // End of stream reached\n         testBase32EmptyInputStream(BaseNCodec.PEM_CHUNK_SIZE);\n     }\n \n-    private void testBase32EmptyInputStream(int chuckSize) throws Exception {\n-        byte[] emptyEncoded = new byte[0];\n-        byte[] emptyDecoded = new byte[0];\n+    private void testBase32EmptyInputStream(final int chuckSize) throws Exception {\n+        final byte[] emptyEncoded = new byte[0];\n+        final byte[] emptyDecoded = new byte[0];\n         testByteByByte(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n         testByChunk(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n     }\n         // testByChunk(encoded, decoded, 0, LF);\n \n         // test random data of sizes 0 thru 150\n-        BaseNCodec codec = new Base32();\n+        final BaseNCodec codec = new Base32();\n         for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base32TestData.randomData(codec, i);\n+            final byte[][] randomData = Base32TestData.randomData(codec, i);\n             encoded = randomData[1];\n             decoded = randomData[0];\n             testByChunk(encoded, decoded, 0, LF);\n         // testByteByByte(encoded, decoded, 0, LF);\n \n         // test random data of sizes 0 thru 150\n-        BaseNCodec codec = new Base32();\n+        final BaseNCodec codec = new Base32();\n         for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base32TestData.randomData(codec, i);\n+            final byte[][] randomData = Base32TestData.randomData(codec, i);\n             encoded = randomData[1];\n             decoded = randomData[0];\n             testByteByByte(encoded, decoded, 0, LF);\n      * @throws Exception\n      *             Usually signifies a bug in the Base32 commons-codec implementation.\n      */\n-    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+    private void testByChunk(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n \n         // Start with encode.\n         InputStream in;\n      * @throws Exception\n      *             Usually signifies a bug in the Base32 commons-codec implementation.\n      */\n-    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+    private void testByteByByte(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n \n         // Start with encode.\n         InputStream in;\n      */\n     @Test\n     public void testMarkSupported() throws Exception {\n-        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n+        final byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        final Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         // Always returns false for now.\n         assertFalse(\"Base32InputStream.markSupported() is false\", in.markSupported());\n         in.close();\n      */\n     @Test\n     public void testRead0() throws Exception {\n-        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n-        byte[] buf = new byte[1024];\n+        final byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        final byte[] buf = new byte[1024];\n         int bytesRead = 0;\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        final Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         bytesRead = in.read(buf, 0, 0);\n         assertEquals(\"Base32InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n         in.close();\n      */\n     @Test\n     public void testReadNull() throws Exception {\n-        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n+        final byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        final Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         try {\n             in.read(null, 0, 0);\n             fail(\"Base32InputStream.read(null, 0, 0) to throw a NullPointerException\");\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             // Expected\n         }\n         in.close();\n      */\n     @Test\n     public void testReadOutOfBounds() throws Exception {\n-        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n-        byte[] buf = new byte[1024];\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n+        final byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        final byte[] buf = new byte[1024];\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        final Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n \n         try {\n             in.read(buf, -1, 0);\n             fail(\"Expected Base32InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // Expected\n         }\n \n         try {\n             in.read(buf, 0, -1);\n             fail(\"Expected Base32InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // Expected\n         }\n \n         try {\n             in.read(buf, buf.length + 1, 0);\n             fail(\"Base32InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // Expected\n         }\n \n         try {\n             in.read(buf, buf.length - 1, 2);\n             fail(\"Base32InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // Expected\n         }\n         in.close();\n      */\n     @Test\n     public void testSkipNone() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n-        Base32InputStream b32stream = new Base32InputStream(ins);\n-        byte[] actualBytes = new byte[6];\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        final Base32InputStream b32stream = new Base32InputStream(ins);\n+        final byte[] actualBytes = new byte[6];\n         assertEquals(0, b32stream.skip(0));\n         b32stream.read(actualBytes, 0, actualBytes.length);\n         assertArrayEquals(actualBytes, new byte[] { 102, 111, 111, 0, 0, 0 });\n      */\n     @Test\n     public void testSkipBig() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n-        Base32InputStream b32stream = new Base32InputStream(ins);\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        final Base32InputStream b32stream = new Base32InputStream(ins);\n         assertEquals(3, b32stream.skip(1024));\n         // End of stream reached\n         assertEquals(-1, b32stream.read());\n      */\n     @Test\n     public void testSkipPastEnd() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n-        Base32InputStream b32stream = new Base32InputStream(ins);\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        final Base32InputStream b32stream = new Base32InputStream(ins);\n         // due to CODEC-130, skip now skips correctly decoded characters rather than encoded\n         assertEquals(3, b32stream.skip(10));\n         // End of stream reached\n      */\n     @Test\n     public void testSkipToEnd() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n-        Base32InputStream b32stream = new Base32InputStream(ins);\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        final Base32InputStream b32stream = new Base32InputStream(ins);\n         // due to CODEC-130, skip now skips correctly decoded characters rather than encoded\n         assertEquals(3, b32stream.skip(3));\n         // End of stream reached\n      */\n     @Test(expected=IllegalArgumentException.class)\n     public void testSkipWrongArgument() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n-        Base32InputStream b32stream = new Base32InputStream(ins);\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        final Base32InputStream b32stream = new Base32InputStream(ins);\n         b32stream.skip(-10);\n         b32stream.close();\n     }\n--- a/src/test/java/org/apache/commons/codec/binary/Base32OutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32OutputStreamTest.java\n         testBase32EmptyOutputStream(BaseNCodec.PEM_CHUNK_SIZE);\n     }\n \n-    private void testBase32EmptyOutputStream(int chunkSize) throws Exception {\n-        byte[] emptyEncoded = new byte[0];\n-        byte[] emptyDecoded = new byte[0];\n+    private void testBase32EmptyOutputStream(final int chunkSize) throws Exception {\n+        final byte[] emptyEncoded = new byte[0];\n+        final byte[] emptyDecoded = new byte[0];\n         testByteByByte(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n         testByChunk(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n     }\n //        testByChunk(encoded, decoded, 0, LF);\n \n         // test random data of sizes 0 thru 150\n-        BaseNCodec codec = new Base32();\n+        final BaseNCodec codec = new Base32();\n         for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base32TestData.randomData(codec, i);\n+            final byte[][] randomData = Base32TestData.randomData(codec, i);\n             encoded = randomData[1];\n             decoded = randomData[0];\n             testByChunk(encoded, decoded, 0, LF);\n //        testByteByByte(encoded, decoded, 0, LF);\n \n         // test random data of sizes 0 thru 150\n-        BaseNCodec codec = new Base32();\n+        final BaseNCodec codec = new Base32();\n         for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base32TestData.randomData(codec, i);\n+            final byte[][] randomData = Base32TestData.randomData(codec, i);\n             encoded = randomData[1];\n             decoded = randomData[0];\n             testByteByByte(encoded, decoded, 0, LF);\n      * @throws Exception\n      *             Usually signifies a bug in the Base32 commons-codec implementation.\n      */\n-    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+    private void testByChunk(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n \n         // Start with encode.\n         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n      * @throws Exception\n      *             Usually signifies a bug in the Base32 commons-codec implementation.\n      */\n-    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+    private void testByteByByte(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n \n         // Start with encode.\n         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n         OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator);\n-        for (byte element : decoded) {\n+        for (final byte element : decoded) {\n             out.write(element);\n         }\n         out.close();\n         // Now let's try decode.\n         byteOut = new ByteArrayOutputStream();\n         out = new Base32OutputStream(byteOut, false);\n-        for (byte element : encoded) {\n+        for (final byte element : encoded) {\n             out.write(element);\n         }\n         out.close();\n         // Now let's try decode with tonnes of flushes.\n         byteOut = new ByteArrayOutputStream();\n         out = new Base32OutputStream(byteOut, false);\n-        for (byte element : encoded) {\n+        for (final byte element : encoded) {\n             out.write(element);\n             out.flush();\n         }\n             out = new Base32OutputStream(out, false);\n             out = new Base32OutputStream(out, true, chunkSize, seperator);\n         }\n-        for (byte element : decoded) {\n+        for (final byte element : decoded) {\n             out.write(element);\n         }\n         out.close();\n      */\n     @Test\n     public void testWriteOutOfBounds() throws Exception {\n-        byte[] buf = new byte[1024];\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        Base32OutputStream out = new Base32OutputStream(bout);\n+        final byte[] buf = new byte[1024];\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final Base32OutputStream out = new Base32OutputStream(bout);\n \n         try {\n             out.write(buf, -1, 1);\n             fail(\"Expected Base32OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n+        } catch (final IndexOutOfBoundsException ioobe) {\n             // Expected\n         }\n \n         try {\n             out.write(buf, 1, -1);\n             fail(\"Expected Base32OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n+        } catch (final IndexOutOfBoundsException ioobe) {\n             // Expected\n         }\n \n         try {\n             out.write(buf, buf.length + 1, 0);\n             fail(\"Expected Base32OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n+        } catch (final IndexOutOfBoundsException ioobe) {\n             // Expected\n         }\n \n         try {\n             out.write(buf, buf.length - 1, 2);\n             fail(\"Expected Base32OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n+        } catch (final IndexOutOfBoundsException ioobe) {\n             // Expected\n         }\n         out.close();\n      */\n     @Test\n     public void testWriteToNullCoverage() throws Exception {\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        Base32OutputStream out = new Base32OutputStream(bout);\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final Base32OutputStream out = new Base32OutputStream(bout);\n         try {\n             out.write(null, 0, 0);\n             fail(\"Expcted Base32OutputStream.write(null) to throw a NullPointerException\");\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             // Expected\n         }\n         out.close();\n--- a/src/test/java/org/apache/commons/codec/binary/Base32Test.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32Test.java\n \n     @Test\n     public void testBase32Samples() throws Exception {\n-        Base32 codec = new Base32();\n-        for (String[] element : BASE32_TEST_CASES) {\n+        final Base32 codec = new Base32();\n+        for (final String[] element : BASE32_TEST_CASES) {\n                 assertEquals(element[1], codec.encodeAsString(element[0].getBytes(Charsets.UTF_8)));\n         }\n     }\n \n     @Test\n     public void testBase32HexSamples() throws Exception {\n-        Base32 codec = new Base32(true);\n-        for (String[] element : BASE32HEX_TEST_CASES) {\n+        final Base32 codec = new Base32(true);\n+        for (final String[] element : BASE32HEX_TEST_CASES) {\n                 assertEquals(element[1], codec.encodeAsString(element[0].getBytes(Charsets.UTF_8)));\n         }\n     }\n \n     @Test\n     public void testBase32Chunked () throws Exception {\n-        Base32 codec = new Base32(20);\n-        for (String[] element : BASE32_TEST_CASES_CHUNKED) {\n+        final Base32 codec = new Base32(20);\n+        for (final String[] element : BASE32_TEST_CASES_CHUNKED) {\n                 assertEquals(element[1], codec.encodeAsString(element[0].getBytes(Charsets.UTF_8)));\n         }\n     }\n     public void testSingleCharEncoding() {\n         for (int i = 0; i < 20; i++) {\n             Base32 codec = new Base32();\n-            BaseNCodec.Context context = new BaseNCodec.Context();\n-            byte unencoded[] = new byte[i];\n-            byte allInOne[] = codec.encode(unencoded);\n+            final BaseNCodec.Context context = new BaseNCodec.Context();\n+            final byte unencoded[] = new byte[i];\n+            final byte allInOne[] = codec.encode(unencoded);\n             codec = new Base32();\n             for (int j=0; j< unencoded.length; j++) {\n                 codec.encode(unencoded, j, 1, context);\n             }\n             codec.encode(unencoded, 0, -1, context);\n-            byte singly[] = new byte[allInOne.length];\n+            final byte singly[] = new byte[allInOne.length];\n             codec.readResults(singly, 0, 100, context);\n             if (!Arrays.equals(allInOne, singly)){\n                 fail();\n     @Test\n     public void testRandomBytes() {\n         for (int i = 0; i < 20; i++) {\n-            Base32 codec = new Base32();\n-            byte[][] b = Base32TestData.randomData(codec, i);\n+            final Base32 codec = new Base32();\n+            final byte[][] b = Base32TestData.randomData(codec, i);\n             assertEquals(\"\"+i+\" \"+codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));\n             //assertEquals(b[0],codec.decode(b[1]));\n         }\n     @Test\n     public void testRandomBytesChunked() {\n         for (int i = 0; i < 20; i++) {\n-            Base32 codec = new Base32(10);\n-            byte[][] b = Base32TestData.randomData(codec, i);\n+            final Base32 codec = new Base32(10);\n+            final byte[][] b = Base32TestData.randomData(codec, i);\n             assertEquals(\"\"+i+\" \"+codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));\n             //assertEquals(b[0],codec.decode(b[1]));\n         }\n     @Test\n     public void testRandomBytesHex() {\n         for (int i = 0; i < 20; i++) {\n-            Base32 codec = new Base32(true);\n-            byte[][] b = Base32TestData.randomData(codec, i);\n+            final Base32 codec = new Base32(true);\n+            final byte[][] b = Base32TestData.randomData(codec, i);\n             assertEquals(\"\"+i+\" \"+codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));\n             //assertEquals(b[0],codec.decode(b[1]));\n         }\n--- a/src/test/java/org/apache/commons/codec/binary/Base32TestData.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32TestData.java\n                 lastRead = status[LAST_READ_KEY];\n             }\n             if (buf.length != size) {\n-                byte[] smallerBuf = new byte[size];\n+                final byte[] smallerBuf = new byte[size];\n                 System.arraycopy(buf, 0, smallerBuf, 0, size);\n                 buf = smallerBuf;\n             }\n     }\n \n     private static byte[] resizeArray(final byte[] bytes) {\n-        byte[] biggerBytes = new byte[bytes.length * 2];\n+        final byte[] biggerBytes = new byte[bytes.length * 2];\n         System.arraycopy(bytes, 0, biggerBytes, 0, bytes.length);\n         return biggerBytes;\n     }\n      * @param size amount of random data to generate and encode\n      * @return two byte[] arrays:  [0] = decoded, [1] = encoded\n      */\n-    static byte[][] randomData(BaseNCodec codec, int size) {\n-        Random r = new Random();\n-        byte[] decoded = new byte[size];\n+    static byte[][] randomData(final BaseNCodec codec, final int size) {\n+        final Random r = new Random();\n+        final byte[] decoded = new byte[size];\n         r.nextBytes(decoded);\n-        byte[] encoded = codec.encode(decoded);\n+        final byte[] encoded = codec.encode(decoded);\n         return new byte[][] {decoded, encoded};\n     }\n \n      * @param c byte to look for\n      * @return true if bytes contains c, false otherwise\n      */\n-    static boolean bytesContain(byte[] bytes, byte c) {\n-        for (byte b : bytes) {\n+    static boolean bytesContain(final byte[] bytes, final byte c) {\n+        for (final byte b : bytes) {\n             if (b == c) { return true; }\n         }\n         return false;\n--- a/src/test/java/org/apache/commons/codec/binary/Base64Codec13Test.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64Codec13Test.java\n \n     /* These strings were generated from random byte[] arrays fed into commons-codec-1.3.jar */\n     private static void initSTRINGS() {\n-        String[] s = STRINGS;\n+        final String[] s = STRINGS;\n         s[0] = \"\";\n         s[1] = \"uA==\";\n         s[2] = \"z9w=\";\n \n     /* These are chunked versions of the strings above (chunked by commons-codec-1.3.jar) */\n     private static void initCHUNKED_STRINGS() {\n-        String[] c = CHUNKED_STRINGS;\n+        final String[] c = CHUNKED_STRINGS;\n         c[0] = \"\";\n         c[1] = \"uA==\\r\\n\";\n         c[2] = \"z9w=\\r\\n\";\n \n     /* Here are the randomly generated byte[] arrays we generated to exercise commons-codec-1.3.jar */\n     private static void initBYTES() {\n-        byte[][] b = BYTES;\n+        final byte[][] b = BYTES;\n         b[0] = new byte[]{};\n         b[1] = new byte[]{-72};\n         b[2] = new byte[]{-49, -36};\n      */\n     @Test\n     public void testEncoder() throws EncoderException {\n-        Encoder enc = new Base64();\n-        for (int i = 0; i < STRINGS.length; i++) {\n-            if (STRINGS[i] != null) {\n-                byte[] base64 = utf8(STRINGS[i]);\n-                byte[] binary = BYTES[i];\n-                boolean b = Arrays.equals(base64, (byte[]) enc.encode(binary));\n+        final Encoder enc = new Base64();\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                final byte[] base64 = utf8(STRINGS[i]);\n+                final byte[] binary = BYTES[i];\n+                final boolean b = Arrays.equals(base64, (byte[]) enc.encode(binary));\n                 assertTrue(\"Encoder test-\" + i, b);\n             }\n         }\n      */\n     @Test\n     public void testDecoder() throws DecoderException {\n-        Decoder dec = new Base64();\n-        for (int i = 0; i < STRINGS.length; i++) {\n-            if (STRINGS[i] != null) {\n-                byte[] base64 = utf8(STRINGS[i]);\n-                byte[] binary = BYTES[i];\n-                boolean b = Arrays.equals(binary, (byte[]) dec.decode(base64));\n+        final Decoder dec = new Base64();\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                final byte[] base64 = utf8(STRINGS[i]);\n+                final byte[] binary = BYTES[i];\n+                final boolean b = Arrays.equals(binary, (byte[]) dec.decode(base64));\n                 assertTrue(\"Decoder test-\" + i, b);\n             }\n         }\n      */\n     @Test\n     public void testBinaryEncoder() throws EncoderException {\n-        BinaryEncoder enc = new Base64();\n-        for (int i = 0; i < STRINGS.length; i++) {\n-            if (STRINGS[i] != null) {\n-                byte[] base64 = utf8(STRINGS[i]);\n-                byte[] binary = BYTES[i];\n-                boolean b = Arrays.equals(base64, enc.encode(binary));\n+        final BinaryEncoder enc = new Base64();\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                final byte[] base64 = utf8(STRINGS[i]);\n+                final byte[] binary = BYTES[i];\n+                final boolean b = Arrays.equals(base64, enc.encode(binary));\n                 assertTrue(\"BinaryEncoder test-\" + i, b);\n             }\n         }\n      */\n     @Test\n     public void testBinaryDecoder() throws DecoderException {\n-        BinaryDecoder dec = new Base64();\n-        for (int i = 0; i < STRINGS.length; i++) {\n-            if (STRINGS[i] != null) {\n-                byte[] base64 = utf8(STRINGS[i]);\n-                byte[] binary = BYTES[i];\n-                boolean b = Arrays.equals(binary, dec.decode(base64));\n+        final BinaryDecoder dec = new Base64();\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                final byte[] base64 = utf8(STRINGS[i]);\n+                final byte[] binary = BYTES[i];\n+                final boolean b = Arrays.equals(binary, dec.decode(base64));\n                 assertTrue(\"BinaryDecoder test-\" + i, b);\n             }\n         }\n     public void testStaticEncode() throws EncoderException {\n         for (int i = 0; i < STRINGS.length; i++) {\n             if (STRINGS[i] != null) {\n-                byte[] base64 = utf8(STRINGS[i]);\n-                byte[] binary = BYTES[i];\n-                boolean b = Arrays.equals(base64, Base64.encodeBase64(binary));\n+                final byte[] base64 = utf8(STRINGS[i]);\n+                final byte[] binary = BYTES[i];\n+                final boolean b = Arrays.equals(base64, Base64.encodeBase64(binary));\n                 assertTrue(\"static Base64.encodeBase64() test-\" + i, b);\n             }\n         }\n     public void testStaticDecode() throws DecoderException {\n         for (int i = 0; i < STRINGS.length; i++) {\n             if (STRINGS[i] != null) {\n-                byte[] base64 = utf8(STRINGS[i]);\n-                byte[] binary = BYTES[i];\n-                boolean b = Arrays.equals(binary, Base64.decodeBase64(base64));\n+                final byte[] base64 = utf8(STRINGS[i]);\n+                final byte[] binary = BYTES[i];\n+                final boolean b = Arrays.equals(binary, Base64.decodeBase64(base64));\n                 assertTrue(\"static Base64.decodeBase64() test-\" + i, b);\n             }\n         }\n     public void testStaticEncodeChunked() throws EncoderException {\n         for (int i = 0; i < STRINGS.length; i++) {\n             if (STRINGS[i] != null) {\n-                byte[] base64Chunked = utf8(CHUNKED_STRINGS[i]);\n-                byte[] binary = BYTES[i];\n-                boolean b = Arrays.equals(base64Chunked, Base64.encodeBase64Chunked(binary));\n+                final byte[] base64Chunked = utf8(CHUNKED_STRINGS[i]);\n+                final byte[] binary = BYTES[i];\n+                final boolean b = Arrays.equals(base64Chunked, Base64.encodeBase64Chunked(binary));\n                 assertTrue(\"static Base64.encodeBase64Chunked() test-\" + i, b);\n             }\n         }\n     public void testStaticDecodeChunked() throws DecoderException {\n         for (int i = 0; i < STRINGS.length; i++) {\n             if (STRINGS[i] != null) {\n-                byte[] base64Chunked = utf8(CHUNKED_STRINGS[i]);\n-                byte[] binary = BYTES[i];\n-                boolean b = Arrays.equals(binary, Base64.decodeBase64(base64Chunked));\n+                final byte[] base64Chunked = utf8(CHUNKED_STRINGS[i]);\n+                final byte[] binary = BYTES[i];\n+                final boolean b = Arrays.equals(binary, Base64.decodeBase64(base64Chunked));\n                 assertTrue(\"static Base64.decodeBase64Chunked() test-\" + i, b);\n             }\n         }\n     }\n \n-    private static byte[] utf8(String s) {\n+    private static byte[] utf8(final String s) {\n \n         // We would use commons-codec-1.4.jar own utility method for this, but we\n         // need this class to be able to run against commons-codec-1.3.jar, hence the\n--- a/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n      */\n     @Test\n     public void testCodec130() throws IOException {\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        Base64OutputStream base64os = new Base64OutputStream(bos);\n+        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        final Base64OutputStream base64os = new Base64OutputStream(bos);\n \n         base64os.write(StringUtils.getBytesUtf8(STRING_FIXTURE));\n         base64os.close();\n \n-        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n-        Base64InputStream ins = new Base64InputStream(bis);\n+        final ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n+        final Base64InputStream ins = new Base64InputStream(bis);\n \n         // we skip the first character read from the reader\n         ins.skip(1);\n-        byte[] decodedBytes = Base64TestData.streamToBytes(ins, new byte[64]);\n-        String str = StringUtils.newStringUtf8(decodedBytes);\n+        final byte[] decodedBytes = Base64TestData.streamToBytes(ins, new byte[64]);\n+        final String str = StringUtils.newStringUtf8(decodedBytes);\n \n         assertEquals(STRING_FIXTURE.substring(1), str);\n     }\n      */\n     @Test\n     public void testCodec105() throws IOException {\n-        Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\n+        final Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\n         try {\n             for (int i = 0; i < 5; i++) {\n                 in.read();\n      */\n     @Test\n     public void testCodec101() throws Exception {\n-        byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n-        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n-        Base64InputStream in = new Base64InputStream(bais);\n-        byte[] result = new byte[8192];\n+        final byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n+        final ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n+        final Base64InputStream in = new Base64InputStream(bais);\n+        final byte[] result = new byte[8192];\n         int c = in.read(result);\n         assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n \n      */\n     @Test\n     public void testInputStreamReader() throws Exception {\n-        byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n-        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n-        Base64InputStream in = new Base64InputStream(bais);\n-        InputStreamReader isr = new InputStreamReader(in);\n-        BufferedReader br = new BufferedReader(isr);\n-        String line = br.readLine();\n+        final byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n+        final ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n+        final Base64InputStream in = new Base64InputStream(bais);\n+        final InputStreamReader isr = new InputStreamReader(in);\n+        final BufferedReader br = new BufferedReader(isr);\n+        final String line = br.readLine();\n         assertNotNull(\"Codec101:  InputStreamReader works!\", line);\n         br.close();\n     }\n      */\n     @Test\n     public void testCodec98NPE() throws Exception {\n-        byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n-        ByteArrayInputStream data = new ByteArrayInputStream(codec98);\n-        Base64InputStream stream = new Base64InputStream(data);\n+        final byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n+        final ByteArrayInputStream data = new ByteArrayInputStream(codec98);\n+        final Base64InputStream stream = new Base64InputStream(data);\n \n         // This line causes an NPE in commons-codec-1.4.jar:\n-        byte[] decodedBytes = Base64TestData.streamToBytes(stream, new byte[1024]);\n-\n-        String decoded = StringUtils.newStringUtf8(decodedBytes);\n+        final byte[] decodedBytes = Base64TestData.streamToBytes(stream, new byte[1024]);\n+\n+        final String decoded = StringUtils.newStringUtf8(decodedBytes);\n         assertEquals(\"codec-98 NPE Base64InputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded);\n     }\n \n      */\n     @Test\n     public void testAvailable() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n-        Base64InputStream b64stream = new Base64InputStream(ins);\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        final Base64InputStream b64stream = new Base64InputStream(ins);\n         assertEquals(1, b64stream.available());\n         assertEquals(6, b64stream.skip(10));\n         // End of stream reached\n         testBase64EmptyInputStream(BaseNCodec.PEM_CHUNK_SIZE);\n     }\n \n-    private void testBase64EmptyInputStream(int chuckSize) throws Exception {\n-        byte[] emptyEncoded = new byte[0];\n-        byte[] emptyDecoded = new byte[0];\n+    private void testBase64EmptyInputStream(final int chuckSize) throws Exception {\n+        final byte[] emptyEncoded = new byte[0];\n+        final byte[] emptyDecoded = new byte[0];\n         testByteByByte(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n         testByChunk(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n     }\n         testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF);\n \n         // Single Line test.\n-        String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+        final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n         encoded = StringUtils.getBytesUtf8(singleLine);\n         decoded = Base64TestData.DECODED;\n         testByChunk(encoded, decoded, 0, LF);\n \n         // test random data of sizes 0 thru 150\n         for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base64TestData.randomData(i, false);\n+            final byte[][] randomData = Base64TestData.randomData(i, false);\n             encoded = randomData[1];\n             decoded = randomData[0];\n             testByChunk(encoded, decoded, 0, LF);\n         testByteByByte(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF);\n \n         // Single Line test.\n-        String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+        final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n         encoded = StringUtils.getBytesUtf8(singleLine);\n         decoded = Base64TestData.DECODED;\n         testByteByByte(encoded, decoded, 0, LF);\n \n         // test random data of sizes 0 thru 150\n         for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base64TestData.randomData(i, false);\n+            final byte[][] randomData = Base64TestData.randomData(i, false);\n             encoded = randomData[1];\n             decoded = randomData[0];\n             testByteByByte(encoded, decoded, 0, LF);\n      * @throws Exception\n      *             Usually signifies a bug in the Base64 commons-codec implementation.\n      */\n-    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+    private void testByChunk(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n \n         // Start with encode.\n         InputStream in;\n      * @throws Exception\n      *             Usually signifies a bug in the Base64 commons-codec implementation.\n      */\n-    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+    private void testByteByByte(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n \n         // Start with encode.\n         InputStream in;\n      */\n     @Test\n     public void testMarkSupported() throws Exception {\n-        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n+        final byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        final Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         // Always returns false for now.\n         assertFalse(\"Base64InputStream.markSupported() is false\", in.markSupported());\n         in.close();\n      */\n     @Test\n     public void testRead0() throws Exception {\n-        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n-        byte[] buf = new byte[1024];\n+        final byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        final byte[] buf = new byte[1024];\n         int bytesRead = 0;\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        final Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         bytesRead = in.read(buf, 0, 0);\n         assertEquals(\"Base64InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n         in.close();\n      */\n     @Test\n     public void testReadNull() throws Exception {\n-        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n+        final byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        final Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         try {\n             in.read(null, 0, 0);\n             fail(\"Base64InputStream.read(null, 0, 0) to throw a NullPointerException\");\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             // Expected\n         }\n         in.close();\n      */\n     @Test\n     public void testReadOutOfBounds() throws Exception {\n-        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n-        byte[] buf = new byte[1024];\n-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n+        final byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        final byte[] buf = new byte[1024];\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        final Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n \n         try {\n             in.read(buf, -1, 0);\n             fail(\"Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // Expected\n         }\n \n         try {\n             in.read(buf, 0, -1);\n             fail(\"Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // Expected\n         }\n \n         try {\n             in.read(buf, buf.length + 1, 0);\n             fail(\"Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // Expected\n         }\n \n         try {\n             in.read(buf, buf.length - 1, 2);\n             fail(\"Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // Expected\n         }\n         in.close();\n      */\n     @Test\n     public void testSkipBig() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n-        Base64InputStream b64stream = new Base64InputStream(ins);\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        final Base64InputStream b64stream = new Base64InputStream(ins);\n         assertEquals(6, b64stream.skip(Integer.MAX_VALUE));\n         // End of stream reached\n         assertEquals(-1, b64stream.read());\n      */\n     @Test\n     public void testSkipNone() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n-        Base64InputStream b64stream = new Base64InputStream(ins);\n-        byte[] actualBytes = new byte[6];\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        final Base64InputStream b64stream = new Base64InputStream(ins);\n+        final byte[] actualBytes = new byte[6];\n         assertEquals(0, b64stream.skip(0));\n         b64stream.read(actualBytes, 0, actualBytes.length);\n         assertArrayEquals(actualBytes, new byte[] { 0, 0, 0, (byte) 255, (byte) 255, (byte) 255 });\n      */\n     @Test\n     public void testSkipPastEnd() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n-        Base64InputStream b64stream = new Base64InputStream(ins);\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        final Base64InputStream b64stream = new Base64InputStream(ins);\n         // due to CODEC-130, skip now skips correctly decoded characters rather than encoded\n         assertEquals(6, b64stream.skip(10));\n         // End of stream reached\n      */\n     @Test\n     public void testSkipToEnd() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n-        Base64InputStream b64stream = new Base64InputStream(ins);\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        final Base64InputStream b64stream = new Base64InputStream(ins);\n         // due to CODEC-130, skip now skips correctly decoded characters rather than encoded\n         assertEquals(6, b64stream.skip(6));\n         // End of stream reached\n      */\n     @Test(expected=IllegalArgumentException.class)\n     public void testSkipWrongArgument() throws Throwable {\n-        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n-        Base64InputStream b64stream = new Base64InputStream(ins);\n+        final InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n+        final Base64InputStream b64stream = new Base64InputStream(ins);\n         b64stream.skip(-10);\n         b64stream.close();\n     }\n--- a/src/test/java/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n      */\n     @Test\n     public void testCodec98NPE() throws Exception {\n-        byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n-        byte[] codec98_1024 = new byte[1024];\n+        final byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n+        final byte[] codec98_1024 = new byte[1024];\n         System.arraycopy(codec98, 0, codec98_1024, 0, codec98.length);\n-        ByteArrayOutputStream data = new ByteArrayOutputStream(1024);\n-        Base64OutputStream stream = new Base64OutputStream(data, false);\n+        final ByteArrayOutputStream data = new ByteArrayOutputStream(1024);\n+        final Base64OutputStream stream = new Base64OutputStream(data, false);\n         stream.write(codec98_1024, 0, 1024);\n         stream.close();\n \n-        byte[] decodedBytes = data.toByteArray();\n-        String decoded = StringUtils.newStringUtf8(decodedBytes);\n+        final byte[] decodedBytes = data.toByteArray();\n+        final String decoded = StringUtils.newStringUtf8(decodedBytes);\n         assertEquals(\n             \"codec-98 NPE Base64OutputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n         );\n         testBase64EmptyOutputStream(BaseNCodec.PEM_CHUNK_SIZE);\n     }\n \n-    private void testBase64EmptyOutputStream(int chunkSize) throws Exception {\n-        byte[] emptyEncoded = new byte[0];\n-        byte[] emptyDecoded = new byte[0];\n+    private void testBase64EmptyOutputStream(final int chunkSize) throws Exception {\n+        final byte[] emptyEncoded = new byte[0];\n+        final byte[] emptyDecoded = new byte[0];\n         testByteByByte(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n         testByChunk(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n     }\n         testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF);\n \n         // Single Line test.\n-        String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+        final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n         encoded = StringUtils.getBytesUtf8(singleLine);\n         decoded = Base64TestData.DECODED;\n         testByChunk(encoded, decoded, 0, LF);\n \n         // test random data of sizes 0 thru 150\n         for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base64TestData.randomData(i, false);\n+            final byte[][] randomData = Base64TestData.randomData(i, false);\n             encoded = randomData[1];\n             decoded = randomData[0];\n             testByChunk(encoded, decoded, 0, LF);\n         testByteByByte(encoded, decoded, 64, LF);\n \n         // Single Line test.\n-        String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+        final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n         encoded = StringUtils.getBytesUtf8(singleLine);\n         decoded = Base64TestData.DECODED;\n         testByteByByte(encoded, decoded, 0, LF);\n \n         // test random data of sizes 0 thru 150\n         for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base64TestData.randomData(i, false);\n+            final byte[][] randomData = Base64TestData.randomData(i, false);\n             encoded = randomData[1];\n             decoded = randomData[0];\n             testByteByByte(encoded, decoded, 0, LF);\n      * @throws Exception\n      *             Usually signifies a bug in the Base64 commons-codec implementation.\n      */\n-    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+    private void testByChunk(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n \n         // Start with encode.\n         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n      * @throws Exception\n      *             Usually signifies a bug in the Base64 commons-codec implementation.\n      */\n-    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+    private void testByteByByte(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n \n         // Start with encode.\n         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n-        for (byte element : decoded) {\n+        for (final byte element : decoded) {\n             out.write(element);\n         }\n         out.close();\n         // Now let's try decode.\n         byteOut = new ByteArrayOutputStream();\n         out = new Base64OutputStream(byteOut, false);\n-        for (byte element : encoded) {\n+        for (final byte element : encoded) {\n             out.write(element);\n         }\n         out.close();\n         // Now let's try decode with tonnes of flushes.\n         byteOut = new ByteArrayOutputStream();\n         out = new Base64OutputStream(byteOut, false);\n-        for (byte element : encoded) {\n+        for (final byte element : encoded) {\n             out.write(element);\n             out.flush();\n         }\n             out = new Base64OutputStream(out, false);\n             out = new Base64OutputStream(out, true, chunkSize, seperator);\n         }\n-        for (byte element : decoded) {\n+        for (final byte element : decoded) {\n             out.write(element);\n         }\n         out.close();\n      */\n     @Test\n     public void testWriteOutOfBounds() throws Exception {\n-        byte[] buf = new byte[1024];\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        Base64OutputStream out = new Base64OutputStream(bout);\n+        final byte[] buf = new byte[1024];\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final Base64OutputStream out = new Base64OutputStream(bout);\n \n         try {\n             out.write(buf, -1, 1);\n             fail(\"Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n+        } catch (final IndexOutOfBoundsException ioobe) {\n             // Expected\n         }\n \n         try {\n             out.write(buf, 1, -1);\n             fail(\"Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n+        } catch (final IndexOutOfBoundsException ioobe) {\n             // Expected\n         }\n \n         try {\n             out.write(buf, buf.length + 1, 0);\n             fail(\"Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n+        } catch (final IndexOutOfBoundsException ioobe) {\n             // Expected\n         }\n \n         try {\n             out.write(buf, buf.length - 1, 2);\n             fail(\"Expected Base64OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ioobe) {\n+        } catch (final IndexOutOfBoundsException ioobe) {\n             // Expected\n         }\n         out.close();\n      */\n     @Test\n     public void testWriteToNullCoverage() throws Exception {\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        Base64OutputStream out = new Base64OutputStream(bout);\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final Base64OutputStream out = new Base64OutputStream(bout);\n         try {\n             out.write(null, 0, 0);\n             fail(\"Expcted Base64OutputStream.write(null) to throw a NullPointerException\");\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             // Expected\n         } finally {\n             out.close();\n--- a/src/test/java/org/apache/commons/codec/binary/Base64Test.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64Test.java\n      */\n     @Test\n     public void testIsStringBase64() {\n-        String nullString = null;\n-        String emptyString = \"\";\n-        String validString = \"abc===defg\\n\\r123456\\r789\\r\\rABC\\n\\nDEF==GHI\\r\\nJKL==============\";\n-        String invalidString = validString + (char)0; // append null character\n+        final String nullString = null;\n+        final String emptyString = \"\";\n+        final String validString = \"abc===defg\\n\\r123456\\r789\\r\\rABC\\n\\nDEF==GHI\\r\\nJKL==============\";\n+        final String invalidString = validString + (char)0; // append null character\n \n         try {\n             Base64.isBase64(nullString);\n             fail(\"Base64.isStringBase64() should not be null-safe.\");\n-        } catch (NullPointerException npe) {\n+        } catch (final NullPointerException npe) {\n             assertNotNull(\"Base64.isStringBase64() should not be null-safe.\", npe);\n         }\n \n      */\n     @Test\n     public void testBase64() {\n-        String content = \"Hello World\";\n+        final String content = \"Hello World\";\n         String encodedContent;\n         byte[] encodedBytes = Base64.encodeBase64(StringUtils.getBytesUtf8(content));\n         encodedContent = StringUtils.newStringUtf8(encodedBytes);\n         assertEquals(\"encoding hello world\", \"SGVsbG8gV29ybGQ=\", encodedContent);\n \n         // bogus characters to decode (to skip actually) {e-acute*6}\n-        byte[] decode = b64.decode(\"SGVsbG{\\u00e9\\u00e9\\u00e9\\u00e9\\u00e9\\u00e9}8gV29ybGQ=\");\n-        String decodeString = StringUtils.newStringUtf8(decode);\n+        final byte[] decode = b64.decode(\"SGVsbG{\\u00e9\\u00e9\\u00e9\\u00e9\\u00e9\\u00e9}8gV29ybGQ=\");\n+        final String decodeString = StringUtils.newStringUtf8(decode);\n         assertEquals(\"decode hello world\", \"Hello World\", decodeString);\n     }\n \n      */\n     @Test\n     public void testChunkedEncodeMultipleOf76() {\n-        byte[] expectedEncode = Base64.encodeBase64(Base64TestData.DECODED, true);\n+        final byte[] expectedEncode = Base64.encodeBase64(Base64TestData.DECODED, true);\n         // convert to \"\\r\\n\" so we're equal to the old openssl encoding test stored\n         // in Base64TestData.ENCODED_76_CHARS_PER_LINE:\n-        String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll(\"\\n\", \"\\r\\n\");\n-        byte[] actualEncode = StringUtils.getBytesUtf8(actualResult);\n+        final String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll(\"\\n\", \"\\r\\n\");\n+        final byte[] actualEncode = StringUtils.getBytesUtf8(actualResult);\n         assertTrue(\"chunkedEncodeMultipleOf76\", Arrays.equals(expectedEncode, actualEncode));\n     }\n \n      */\n     @Test\n     public void testCodec68() {\n-        byte[] x = new byte[]{'n', 'A', '=', '=', (byte) 0x9c};\n+        final byte[] x = new byte[]{'n', 'A', '=', '=', (byte) 0x9c};\n         Base64.decodeBase64(x);\n     }\n \n     @Test\n     public void testCodeInteger1() {\n-        String encodedInt1 = \"li7dzDacuo67Jg7mtqEm2TRuOMU=\";\n-        BigInteger bigInt1 = new BigInteger(\"85739377120809420210425962799\" + \"0318636601332086981\");\n+        final String encodedInt1 = \"li7dzDacuo67Jg7mtqEm2TRuOMU=\";\n+        final BigInteger bigInt1 = new BigInteger(\"85739377120809420210425962799\" + \"0318636601332086981\");\n \n         assertEquals(encodedInt1, new String(Base64.encodeInteger(bigInt1)));\n         assertEquals(bigInt1, Base64.decodeInteger(encodedInt1.getBytes(Charsets.UTF_8)));\n \n     @Test\n     public void testCodeInteger2() {\n-        String encodedInt2 = \"9B5ypLY9pMOmtxCeTDHgwdNFeGs=\";\n-        BigInteger bigInt2 = new BigInteger(\"13936727572861167254666467268\" + \"91466679477132949611\");\n+        final String encodedInt2 = \"9B5ypLY9pMOmtxCeTDHgwdNFeGs=\";\n+        final BigInteger bigInt2 = new BigInteger(\"13936727572861167254666467268\" + \"91466679477132949611\");\n \n         assertEquals(encodedInt2, new String(Base64.encodeInteger(bigInt2)));\n         assertEquals(bigInt2, Base64.decodeInteger(encodedInt2.getBytes(Charsets.UTF_8)));\n \n     @Test\n     public void testCodeInteger3() {\n-        String encodedInt3 = \"FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2\" + \"rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg==\";\n-        BigInteger bigInt3 = new BigInteger(\"10806548154093873461951748545\"\n+        final String encodedInt3 = \"FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2\" + \"rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg==\";\n+        final BigInteger bigInt3 = new BigInteger(\"10806548154093873461951748545\"\n             + \"1196989136416448805819079363524309897749044958112417136240557\"\n             + \"4495062430572478766856090958495998158114332651671116876320938126\");\n \n \n     @Test\n     public void testCodeInteger4() {\n-        String encodedInt4 = \"ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI\"\n+        final String encodedInt4 = \"ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI\"\n             + \"4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o\"\n             + \"DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv\"\n             + \"Q0=\";\n-        BigInteger bigInt4 = new BigInteger(\"80624726256040348115552042320\"\n+        final BigInteger bigInt4 = new BigInteger(\"80624726256040348115552042320\"\n             + \"6968135001872753709424419772586693950232350200555646471175944\"\n             + \"519297087885987040810778908507262272892702303774422853675597\"\n             + \"748008534040890923814202286633163248086055216976551456088015\"\n         try {\n             Base64.encodeInteger(null);\n             fail(\"Exception not thrown when passing in null to encodeInteger(BigInteger)\");\n-        } catch (NullPointerException npe) {\n+        } catch (final NullPointerException npe) {\n             // expected\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             fail(\"Incorrect Exception caught when passing in null to encodeInteger(BigInteger)\");\n         }\n     }\n         try {\n             base64 = new Base64(-1, new byte[]{'A'}); // TODO do we need to check sep if len = -1?\n             fail(\"Should have rejected attempt to use 'A' as a line separator\");\n-        } catch (IllegalArgumentException ignored) {\n+        } catch (final IllegalArgumentException ignored) {\n             // Expected\n         }\n         try {\n             base64 = new Base64(64, new byte[]{'A'});\n             fail(\"Should have rejected attempt to use 'A' as a line separator\");\n-        } catch (IllegalArgumentException ignored) {\n+        } catch (final IllegalArgumentException ignored) {\n             // Expected\n         }\n         try {\n             base64 = new Base64(64, new byte[]{'='});\n             fail(\"Should have rejected attempt to use '=' as a line separator\");\n-        } catch (IllegalArgumentException ignored) {\n+        } catch (final IllegalArgumentException ignored) {\n             // Expected\n         }\n         base64 = new Base64(64, new byte[]{'$'}); // OK\n         try {\n             base64 = new Base64(64, new byte[]{'A', '$'});\n             fail(\"Should have rejected attempt to use 'A$' as a line separator\");\n-        } catch (IllegalArgumentException ignored) {\n+        } catch (final IllegalArgumentException ignored) {\n             // Expected\n         }\n         base64 = new Base64(64, new byte[]{' ', '$', '\\n', '\\r', '\\t'}); // OK\n \n     @Test\n     public void testConstructor_Int_ByteArray_Boolean() {\n-        Base64 base64 = new Base64(65, new byte[]{'\\t'}, false);\n-        byte[] encoded = base64.encode(Base64TestData.DECODED);\n+        final Base64 base64 = new Base64(65, new byte[]{'\\t'}, false);\n+        final byte[] encoded = base64.encode(Base64TestData.DECODED);\n         String expectedResult = Base64TestData.ENCODED_64_CHARS_PER_LINE;\n         expectedResult = expectedResult.replace('\\n', '\\t');\n-        String result = StringUtils.newStringUtf8(encoded);\n+        final String result = StringUtils.newStringUtf8(encoded);\n         assertEquals(\"new Base64(65, \\\\t, false)\", expectedResult, result);\n     }\n \n     @Test\n     public void testConstructor_Int_ByteArray_Boolean_UrlSafe() {\n         // url-safe variation\n-        Base64 base64 = new Base64(64, new byte[]{'\\t'}, true);\n-        byte[] encoded = base64.encode(Base64TestData.DECODED);\n+        final Base64 base64 = new Base64(64, new byte[]{'\\t'}, true);\n+        final byte[] encoded = base64.encode(Base64TestData.DECODED);\n         String expectedResult = Base64TestData.ENCODED_64_CHARS_PER_LINE;\n         expectedResult = expectedResult.replaceAll(\"=\", \"\"); // url-safe has no == padding.\n         expectedResult = expectedResult.replace('\\n', '\\t');\n         expectedResult = expectedResult.replace('+', '-');\n         expectedResult = expectedResult.replace('/', '_');\n-        String result = StringUtils.newStringUtf8(encoded);\n+        final String result = StringUtils.newStringUtf8(encoded);\n         assertEquals(\"new Base64(64, \\\\t, true)\", result, expectedResult);\n     }\n \n     @Test\n     public void testDecodeWithWhitespace() throws Exception {\n \n-        String orig = \"I am a late night coder.\";\n-\n-        byte[] encodedArray = Base64.encodeBase64(orig.getBytes(Charsets.UTF_8));\n-        StringBuilder intermediate = new StringBuilder(new String(encodedArray));\n+        final String orig = \"I am a late night coder.\";\n+\n+        final byte[] encodedArray = Base64.encodeBase64(orig.getBytes(Charsets.UTF_8));\n+        final StringBuilder intermediate = new StringBuilder(new String(encodedArray));\n \n         intermediate.insert(2, ' ');\n         intermediate.insert(5, '\\t');\n         intermediate.insert(10, '\\r');\n         intermediate.insert(15, '\\n');\n \n-        byte[] encodedWithWS = intermediate.toString().getBytes(Charsets.UTF_8);\n-        byte[] decodedWithWS = Base64.decodeBase64(encodedWithWS);\n-\n-        String dest = new String(decodedWithWS);\n+        final byte[] encodedWithWS = intermediate.toString().getBytes(Charsets.UTF_8);\n+        final byte[] decodedWithWS = Base64.decodeBase64(encodedWithWS);\n+\n+        final String dest = new String(decodedWithWS);\n \n         assertEquals(\"Dest string doesn't equal the original\", orig, dest);\n     }\n     @Test\n     public void testEncodeDecodeRandom() {\n         for (int i = 1; i < 5; i++) {\n-            byte[] data = new byte[this.getRandom().nextInt(10000) + 1];\n+            final byte[] data = new byte[this.getRandom().nextInt(10000) + 1];\n             this.getRandom().nextBytes(data);\n-            byte[] enc = Base64.encodeBase64(data);\n+            final byte[] enc = Base64.encodeBase64(data);\n             assertTrue(Base64.isBase64(enc));\n-            byte[] data2 = Base64.decodeBase64(enc);\n+            final byte[] data2 = Base64.decodeBase64(enc);\n             assertTrue(Arrays.equals(data, data2));\n         }\n     }\n     @Test\n     public void testEncodeDecodeSmall() {\n         for (int i = 0; i < 12; i++) {\n-            byte[] data = new byte[i];\n+            final byte[] data = new byte[i];\n             this.getRandom().nextBytes(data);\n-            byte[] enc = Base64.encodeBase64(data);\n+            final byte[] enc = Base64.encodeBase64(data);\n             assertTrue(\"\\\"\" + new String(enc) + \"\\\" is Base64 data.\", Base64.isBase64(enc));\n-            byte[] data2 = Base64.decodeBase64(enc);\n+            final byte[] data2 = Base64.decodeBase64(enc);\n             assertTrue(toString(data) + \" equals \" + toString(data2), Arrays.equals(data, data2));\n         }\n     }\n \n     @Test\n     public void testCodec112() { // size calculation assumes always chunked\n-        byte[] in = new byte[] {0};\n-        byte[] out=Base64.encodeBase64(in);\n+        final byte[] in = new byte[] {0};\n+        final byte[] out=Base64.encodeBase64(in);\n         Base64.encodeBase64(in, false, false, out.length);\n     }\n \n-    private void testEncodeOverMaxSize(int maxSize) throws Exception {\n+    private void testEncodeOverMaxSize(final int maxSize) throws Exception {\n         try {\n             Base64.encodeBase64(Base64TestData.DECODED, true, false, maxSize);\n             fail(\"Expected \" + IllegalArgumentException.class.getName());\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // Expected\n         }\n     }\n      */\n     @Test\n     public void testIsUrlSafe() {\n-        Base64 base64Standard = new Base64(false);\n-        Base64 base64URLSafe = new Base64(true);\n+        final Base64 base64Standard = new Base64(false);\n+        final Base64 base64URLSafe = new Base64(true);\n \n         assertFalse(\"Base64.isUrlSafe=false\", base64Standard.isUrlSafe());\n         assertTrue(\"Base64.isUrlSafe=true\", base64URLSafe.isUrlSafe());\n \n-        byte[] whiteSpace = {' ', '\\n', '\\r', '\\t'};\n+        final byte[] whiteSpace = {' ', '\\n', '\\r', '\\t'};\n         assertTrue(\"Base64.isBase64(whiteSpace)=true\", Base64.isBase64(whiteSpace));\n     }\n \n     @Test\n     public void testNonBase64Test() throws Exception {\n \n-        byte[] bArray = {'%'};\n+        final byte[] bArray = {'%'};\n \n         assertFalse(\"Invalid Base64 array was incorrectly validated as \" + \"an array of Base64 encoded data\", Base64\n                 .isBase64(bArray));\n \n         try {\n-            Base64 b64 = new Base64();\n-            byte[] result = b64.decode(bArray);\n+            final Base64 b64 = new Base64();\n+            final byte[] result = b64.decode(bArray);\n \n             assertEquals(\"The result should be empty as the test encoded content did \" + \"not contain any valid base 64 characters\",\n                     0, result.length);\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             fail(\"Exception was thrown when trying to decode \"\n                 + \"invalid base64 encoded data - RFC 2045 requires that all \"\n                 + \"non base64 character be discarded, an exception should not\"\n \n     @Test\n     public void testObjectDecodeWithInvalidParameter() throws Exception {\n-        Base64 b64 = new Base64();\n+        final Base64 b64 = new Base64();\n \n         try {\n             b64.decode(Integer.valueOf(5));\n             fail(\"decode(Object) didn't throw an exception when passed an Integer object\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // ignored\n         }\n \n     @Test\n     public void testObjectDecodeWithValidParameter() throws Exception {\n \n-        String original = \"Hello World!\";\n-        Object o = Base64.encodeBase64(original.getBytes(Charsets.UTF_8));\n-\n-        Base64 b64 = new Base64();\n-        Object oDecoded = b64.decode(o);\n-        byte[] baDecoded = (byte[]) oDecoded;\n-        String dest = new String(baDecoded);\n+        final String original = \"Hello World!\";\n+        final Object o = Base64.encodeBase64(original.getBytes(Charsets.UTF_8));\n+\n+        final Base64 b64 = new Base64();\n+        final Object oDecoded = b64.decode(o);\n+        final byte[] baDecoded = (byte[]) oDecoded;\n+        final String dest = new String(baDecoded);\n \n         assertEquals(\"dest string does not equal original\", original, dest);\n     }\n \n     @Test\n     public void testObjectEncodeWithInvalidParameter() throws Exception {\n-        Base64 b64 = new Base64();\n+        final Base64 b64 = new Base64();\n         try {\n             b64.encode(\"Yadayadayada\");\n             fail(\"encode(Object) didn't throw an exception when passed a String object\");\n-        } catch (EncoderException e) {\n+        } catch (final EncoderException e) {\n             // Expected\n         }\n     }\n     @Test\n     public void testObjectEncodeWithValidParameter() throws Exception {\n \n-        String original = \"Hello World!\";\n-        Object origObj = original.getBytes(Charsets.UTF_8);\n-\n-        Base64 b64 = new Base64();\n-        Object oEncoded = b64.encode(origObj);\n-        byte[] bArray = Base64.decodeBase64((byte[]) oEncoded);\n-        String dest = new String(bArray);\n+        final String original = \"Hello World!\";\n+        final Object origObj = original.getBytes(Charsets.UTF_8);\n+\n+        final Base64 b64 = new Base64();\n+        final Object oEncoded = b64.encode(origObj);\n+        final byte[] bArray = Base64.decodeBase64((byte[]) oEncoded);\n+        final String dest = new String(bArray);\n \n         assertEquals(\"dest string does not equal original\", original, dest);\n     }\n \n     @Test\n     public void testObjectEncode() throws Exception {\n-        Base64 b64 = new Base64();\n+        final Base64 b64 = new Base64();\n         assertEquals(\"SGVsbG8gV29ybGQ=\", new String(b64.encode(\"Hello World\".getBytes(Charsets.UTF_8))));\n     }\n \n     public void testPairs() {\n         assertEquals(\"AAA=\", new String(Base64.encodeBase64(new byte[]{0, 0})));\n         for (int i = -128; i <= 127; i++) {\n-            byte test[] = {(byte) i, (byte) i};\n+            final byte test[] = {(byte) i, (byte) i};\n             assertTrue(Arrays.equals(test, Base64.decodeBase64(Base64.encodeBase64(test))));\n         }\n     }\n      */\n     @Test\n     public void testRfc4648Section10DecodeWithCrLf() {\n-        String CRLF = StringUtils.newStringUsAscii(Base64.CHUNK_SEPARATOR);\n+        final String CRLF = StringUtils.newStringUsAscii(Base64.CHUNK_SEPARATOR);\n         assertEquals(\"\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"\" + CRLF)));\n         assertEquals(\"f\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zg==\" + CRLF)));\n         assertEquals(\"fo\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zm8=\" + CRLF)));\n         testDecodeEncode(\"Zm9vYmFy\");\n     }\n \n-    private void testDecodeEncode(String encodedText) {\n-        String decodedText = StringUtils.newStringUsAscii(Base64.decodeBase64(encodedText));\n-        String encodedText2 = Base64.encodeBase64String(StringUtils.getBytesUtf8(decodedText));\n+    private void testDecodeEncode(final String encodedText) {\n+        final String decodedText = StringUtils.newStringUsAscii(Base64.decodeBase64(encodedText));\n+        final String encodedText2 = Base64.encodeBase64String(StringUtils.getBytesUtf8(decodedText));\n         assertEquals(encodedText, encodedText2);\n     }\n \n         testEncodeDecode(\"foobar\");\n     }\n \n-    private void testEncodeDecode(String plainText) {\n-        String encodedText = Base64.encodeBase64String(StringUtils.getBytesUtf8(plainText));\n-        String decodedText = StringUtils.newStringUsAscii(Base64.decodeBase64(encodedText));\n+    private void testEncodeDecode(final String plainText) {\n+        final String encodedText = Base64.encodeBase64String(StringUtils.getBytesUtf8(plainText));\n+        final String decodedText = StringUtils.newStringUsAscii(Base64.decodeBase64(encodedText));\n         assertEquals(plainText, decodedText);\n     }\n \n         assertEquals(\"Zw==\", new String(Base64.encodeBase64(new byte[]{(byte) 103})));\n         assertEquals(\"aA==\", new String(Base64.encodeBase64(new byte[]{(byte) 104})));\n         for (int i = -128; i <= 127; i++) {\n-            byte test[] = {(byte) i};\n+            final byte test[] = {(byte) i};\n             assertTrue(Arrays.equals(test, Base64.decodeBase64(Base64.encodeBase64(test))));\n         }\n     }\n     public void testUrlSafe() {\n         // test random data of sizes 0 thru 150\n         for (int i = 0; i <= 150; i++) {\n-            byte[][] randomData = Base64TestData.randomData(i, true);\n-            byte[] encoded = randomData[1];\n-            byte[] decoded = randomData[0];\n-            byte[] result = Base64.decodeBase64(encoded);\n+            final byte[][] randomData = Base64TestData.randomData(i, true);\n+            final byte[] encoded = randomData[1];\n+            final byte[] decoded = randomData[0];\n+            final byte[] result = Base64.decodeBase64(encoded);\n             assertTrue(\"url-safe i=\" + i, Arrays.equals(decoded, result));\n             assertFalse(\"url-safe i=\" + i + \" no '='\", Base64TestData.bytesContain(encoded, (byte) '='));\n             assertFalse(\"url-safe i=\" + i + \" no '\\\\'\", Base64TestData.bytesContain(encoded, (byte) '\\\\'));\n     public void testUUID() throws DecoderException {\n         // The 4 UUID's below contains mixtures of + and / to help us test the\n         // URL-SAFE encoding mode.\n-        byte[][] ids = new byte[4][];\n+        final byte[][] ids = new byte[4][];\n \n         // ids[0] was chosen so that it encodes with at least one +.\n         ids[0] = Hex.decodeHex(\"94ed8d0319e4493399560fb67404d370\".toCharArray());\n         // right at the beginning.\n         ids[3] = Hex.decodeHex(\"ff7f8fc01cdb471a8c8b5a9306183fe8\".toCharArray());\n \n-        byte[][] standard = new byte[4][];\n+        final byte[][] standard = new byte[4][];\n         standard[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg+2dATTcA==\");\n         standard[1] = StringUtils.getBytesUtf8(\"K/fMJwH+Q5e0nr7tWsxwkA==\");\n         standard[2] = StringUtils.getBytesUtf8(\"ZL4VS2/6QCWNGgEojnwxyg==\");\n         standard[3] = StringUtils.getBytesUtf8(\"/3+PwBzbRxqMi1qTBhg/6A==\");\n \n-        byte[][] urlSafe1 = new byte[4][];\n+        final byte[][] urlSafe1 = new byte[4][];\n         // regular padding (two '==' signs).\n         urlSafe1[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA==\");\n         urlSafe1[1] = StringUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA==\");\n         urlSafe1[2] = StringUtils.getBytesUtf8(\"ZL4VS2_6QCWNGgEojnwxyg==\");\n         urlSafe1[3] = StringUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A==\");\n \n-        byte[][] urlSafe2 = new byte[4][];\n+        final byte[][] urlSafe2 = new byte[4][];\n         // single padding (only one '=' sign).\n         urlSafe2[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA=\");\n         urlSafe2[1] = StringUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA=\");\n         urlSafe2[2] = StringUtils.getBytesUtf8(\"ZL4VS2_6QCWNGgEojnwxyg=\");\n         urlSafe2[3] = StringUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A=\");\n \n-        byte[][] urlSafe3 = new byte[4][];\n+        final byte[][] urlSafe3 = new byte[4][];\n         // no padding (no '=' signs).\n         urlSafe3[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA\");\n         urlSafe3[1] = StringUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA\");\n         urlSafe3[3] = StringUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A\");\n \n         for (int i = 0; i < 4; i++) {\n-            byte[] encodedStandard = Base64.encodeBase64(ids[i]);\n-            byte[] encodedUrlSafe = Base64.encodeBase64URLSafe(ids[i]);\n-            byte[] decodedStandard = Base64.decodeBase64(standard[i]);\n-            byte[] decodedUrlSafe1 = Base64.decodeBase64(urlSafe1[i]);\n-            byte[] decodedUrlSafe2 = Base64.decodeBase64(urlSafe2[i]);\n-            byte[] decodedUrlSafe3 = Base64.decodeBase64(urlSafe3[i]);\n+            final byte[] encodedStandard = Base64.encodeBase64(ids[i]);\n+            final byte[] encodedUrlSafe = Base64.encodeBase64URLSafe(ids[i]);\n+            final byte[] decodedStandard = Base64.decodeBase64(standard[i]);\n+            final byte[] decodedUrlSafe1 = Base64.decodeBase64(urlSafe1[i]);\n+            final byte[] decodedUrlSafe2 = Base64.decodeBase64(urlSafe2[i]);\n+            final byte[] decodedUrlSafe3 = Base64.decodeBase64(urlSafe3[i]);\n \n             // Very important debugging output should anyone\n             // ever need to delve closely into this stuff.\n \n     @Test\n     public void testByteToStringVariations() throws DecoderException {\n-        Base64 base64 = new Base64(0);\n-        byte[] b1 = StringUtils.getBytesUtf8(\"Hello World\");\n-        byte[] b2 = new byte[0];\n-        byte[] b3 = null;\n-        byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n+        final Base64 base64 = new Base64(0);\n+        final byte[] b1 = StringUtils.getBytesUtf8(\"Hello World\");\n+        final byte[] b2 = new byte[0];\n+        final byte[] b3 = null;\n+        final byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n \n         assertEquals(\"byteToString Hello World\", \"SGVsbG8gV29ybGQ=\", base64.encodeToString(b1));\n         assertEquals(\"byteToString static Hello World\", \"SGVsbG8gV29ybGQ=\", Base64.encodeBase64String(b1));\n \n     @Test\n     public void testStringToByteVariations() throws DecoderException {\n-        Base64 base64 = new Base64();\n-        String s1 = \"SGVsbG8gV29ybGQ=\\r\\n\";\n-        String s2 = \"\";\n-        String s3 = null;\n-        String s4a = \"K/fMJwH+Q5e0nr7tWsxwkA==\\r\\n\";\n-        String s4b = \"K_fMJwH-Q5e0nr7tWsxwkA\";\n-        byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n+        final Base64 base64 = new Base64();\n+        final String s1 = \"SGVsbG8gV29ybGQ=\\r\\n\";\n+        final String s2 = \"\";\n+        final String s3 = null;\n+        final String s4a = \"K/fMJwH+Q5e0nr7tWsxwkA==\\r\\n\";\n+        final String s4b = \"K_fMJwH-Q5e0nr7tWsxwkA\";\n+        final byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n \n         assertEquals(\"StringToByte Hello World\", \"Hello World\", StringUtils.newStringUtf8(base64.decode(s1)));\n         assertEquals(\"StringToByte Hello World\", \"Hello World\", StringUtils.newStringUtf8((byte[])base64.decode((Object)s1)));\n         assertTrue(\"StringToByte static-url-safe UUID\", Arrays.equals(b4, Base64.decodeBase64(s4b)));\n     }\n \n-    private String toString(byte[] data) {\n-        StringBuilder buf = new StringBuilder();\n+    private String toString(final byte[] data) {\n+        final StringBuilder buf = new StringBuilder();\n         for (int i = 0; i < data.length; i++) {\n             buf.append(data[i]);\n             if (i != data.length - 1) {\n     public void testHugeLineSeparator() {\n         final int BaseNCodec_DEFAULT_BUFFER_SIZE = 8192;\n         final int Base64_BYTES_PER_ENCODED_BLOCK = 4;\n-        byte[] baLineSeparator = new byte[BaseNCodec_DEFAULT_BUFFER_SIZE * 4 - 3];\n-        Base64 b64 = new Base64(Base64_BYTES_PER_ENCODED_BLOCK, baLineSeparator);\n-        String strOriginal = \"Hello World\";\n-        String strDecoded = new String(b64.decode(b64.encode(StringUtils.getBytesUtf8(strOriginal))));\n+        final byte[] baLineSeparator = new byte[BaseNCodec_DEFAULT_BUFFER_SIZE * 4 - 3];\n+        final Base64 b64 = new Base64(Base64_BYTES_PER_ENCODED_BLOCK, baLineSeparator);\n+        final String strOriginal = \"Hello World\";\n+        final String strDecoded = new String(b64.decode(b64.encode(StringUtils.getBytesUtf8(strOriginal))));\n         assertEquals(\"testDEFAULT_BUFFER_SIZE\", strOriginal, strDecoded);\n     }\n \n--- a/src/test/java/org/apache/commons/codec/binary/Base64TestData.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64TestData.java\n                 lastRead = status[LAST_READ_KEY];\n             }\n             if (buf.length != size) {\n-                byte[] smallerBuf = new byte[size];\n+                final byte[] smallerBuf = new byte[size];\n                 System.arraycopy(buf, 0, smallerBuf, 0, size);\n                 buf = smallerBuf;\n             }\n     }\n \n     private static byte[] resizeArray(final byte[] bytes) {\n-        byte[] biggerBytes = new byte[bytes.length * 2];\n+        final byte[] biggerBytes = new byte[bytes.length * 2];\n         System.arraycopy(bytes, 0, biggerBytes, 0, bytes.length);\n         return biggerBytes;\n     }\n      * @param urlSafe true if encoding be urlSafe\n      * @return two byte[] arrays:  [0] = decoded, [1] = encoded\n      */\n-    static byte[][] randomData(int size, boolean urlSafe) {\n-        Random r = new Random();\n-        byte[] decoded = new byte[size];\n+    static byte[][] randomData(final int size, final boolean urlSafe) {\n+        final Random r = new Random();\n+        final byte[] decoded = new byte[size];\n         r.nextBytes(decoded);\n-        byte[] encoded = urlSafe ? Base64.encodeBase64URLSafe(decoded) : Base64.encodeBase64(decoded);\n+        final byte[] encoded = urlSafe ? Base64.encodeBase64URLSafe(decoded) : Base64.encodeBase64(decoded);\n         return new byte[][] {decoded, encoded};\n     }\n \n      * @param c byte to look for\n      * @return true if bytes contains c, false otherwise\n      */\n-    static boolean bytesContain(byte[] bytes, byte c) {\n-        for (byte b : bytes) {\n+    static boolean bytesContain(final byte[] bytes, final byte c) {\n+        for (final byte b : bytes) {\n             if (b == c) { return true; }\n         }\n         return false;\n--- a/src/test/java/org/apache/commons/codec/binary/BaseNCodecTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/BaseNCodecTest.java\n     public void setUp() {\n         codec = new BaseNCodec(0, 0, 0, 0) {\n             @Override\n-            protected boolean isInAlphabet(byte b) {\n+            protected boolean isInAlphabet(final byte b) {\n                 return b=='O' || b == 'K'; // allow OK\n             }\n \n             @Override\n-            void encode(byte[] pArray, int i, int length, Context context) {\n+            void encode(final byte[] pArray, final int i, final int length, final Context context) {\n             }\n \n             @Override\n-            void decode(byte[] pArray, int i, int length, Context context) {\n+            void decode(final byte[] pArray, final int i, final int length, final Context context) {\n             }\n         };\n     }\n--- a/src/test/java/org/apache/commons/codec/binary/BinaryCodecTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/BinaryCodecTest.java\n     public void testDecodeObjectException() {\n         try {\n             this.instance.decode(new Object());\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // all is well.\n             return;\n         }\n      * @param encodeMe\n      *            data to encode and compare\n      */\n-    void assertDecodeObject(byte[] bits, String encodeMe) throws DecoderException {\n+    void assertDecodeObject(final byte[] bits, final String encodeMe) throws DecoderException {\n         byte[] decoded;\n         decoded = (byte[]) instance.decode(encodeMe);\n         assertEquals(new String(bits), new String(decoded));\n      */\n     @Test\n     public void testEncodeObjectNull() throws Exception {\n-        Object obj = new byte[0];\n+        final Object obj = new byte[0];\n         assertEquals(0, ((char[]) instance.encode(obj)).length);\n     }\n \n     public void testEncodeObjectException() {\n         try {\n             instance.encode(\"\");\n-        } catch (EncoderException e) {\n+        } catch (final EncoderException e) {\n             // all is well.\n             return;\n         }\n--- a/src/test/java/org/apache/commons/codec/binary/Codec105ErrorInputStream.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Codec105ErrorInputStream.java\n     }\n \n     @Override\n-    public int read(byte b[], int pos, int len) throws IOException {\n+    public int read(final byte b[], final int pos, final int len) throws IOException {\n         if (this.countdown-- > 0) {\n             b[pos] = '\\n';\n             return 1;\n--- a/src/test/java/org/apache/commons/codec/binary/HexTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/HexTest.java\n \n     private final static boolean LOG = false;\n \n-    private boolean charsetSanityCheck(String name) {\n+    private boolean charsetSanityCheck(final String name) {\n         final String source = \"the quick brown dog jumped over the lazy fox\";\n         try {\n-            byte[] bytes = source.getBytes(name);\n-            String str = new String(bytes, name);\n-            boolean equals = source.equals(str);\n+            final byte[] bytes = source.getBytes(name);\n+            final String str = new String(bytes, name);\n+            final boolean equals = source.equals(str);\n             if (equals == false) {\n                 // Here with:\n                 //\n                 log(\"FAILED charsetSanityCheck=Interesting Java charset oddity: Roundtrip failed for \" + name);\n             }\n             return equals;\n-        } catch (UnsupportedEncodingException e) {\n+        } catch (final UnsupportedEncodingException e) {\n             // Should NEVER happen since we are getting the name from the Charset class.\n             if (LOG) {\n                 log(\"FAILED charsetSanityCheck=\" + name + \", e=\" + e);\n                 log(e);\n             }\n             return false;\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // Caught here with:\n             // x-JISAutoDetect on Windows XP and Java Sun 1.4.2_19 x86 32-bits\n             // x-JISAutoDetect on Windows XP and Java Sun 1.5.0_17 x86 32-bits\n     /**\n      * @param data\n      */\n-    private void checkDecodeHexOddCharacters(char[] data) {\n+    private void checkDecodeHexOddCharacters(final char[] data) {\n         try {\n             Hex.decodeHex(data);\n             fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n-        } catch (DecoderException e) {\n-            // Expected exception\n-        }\n-    }\n-\n-    private void log(String s) {\n+        } catch (final DecoderException e) {\n+            // Expected exception\n+        }\n+    }\n+\n+    private void log(final String s) {\n         if (LOG) {\n             System.out.println(s);\n             System.out.flush();\n         }\n     }\n \n-    private void log(Throwable t) {\n+    private void log(final Throwable t) {\n         if (LOG) {\n             t.printStackTrace(System.out);\n             System.out.flush();\n \n     @Test\n     public void testCustomCharset() throws UnsupportedEncodingException, DecoderException {\n-        for (String name : Charset.availableCharsets().keySet()) {\n+        for (final String name : Charset.availableCharsets().keySet()) {\n             testCustomCharset(name, \"testCustomCharset\");\n         }\n     }\n      * @throws UnsupportedEncodingException\n      * @throws DecoderException\n      */\n-    private void testCustomCharset(String name, String parent) throws UnsupportedEncodingException, DecoderException {\n+    private void testCustomCharset(final String name, final String parent) throws UnsupportedEncodingException, DecoderException {\n         if (charsetSanityCheck(name) == false) {\n             return;\n         }\n         log(parent + \"=\" + name);\n-        Hex customCodec = new Hex(name);\n+        final Hex customCodec = new Hex(name);\n         // source data\n-        String sourceString = \"Hello World\";\n-        byte[] sourceBytes = sourceString.getBytes(name);\n+        final String sourceString = \"Hello World\";\n+        final byte[] sourceBytes = sourceString.getBytes(name);\n         // test 1\n         // encode source to hex string to bytes with charset\n-        byte[] actualEncodedBytes = customCodec.encode(sourceBytes);\n+        final byte[] actualEncodedBytes = customCodec.encode(sourceBytes);\n         // encode source to hex string...\n         String expectedHexString = Hex.encodeHexString(sourceBytes);\n         // ... and get the bytes in the expected charset\n-        byte[] expectedHexStringBytes = expectedHexString.getBytes(name);\n+        final byte[] expectedHexStringBytes = expectedHexString.getBytes(name);\n         Assert.assertTrue(Arrays.equals(expectedHexStringBytes, actualEncodedBytes));\n         // test 2\n         String actualStringFromBytes = new String(actualEncodedBytes, name);\n         assertEquals(name + \", expectedHexString=\" + expectedHexString + \", actualStringFromBytes=\" + actualStringFromBytes,\n                 expectedHexString, actualStringFromBytes);\n         // second test:\n-        Hex utf8Codec = new Hex();\n+        final Hex utf8Codec = new Hex();\n         expectedHexString = \"48656c6c6f20576f726c64\";\n-        byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString);\n+        final byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString);\n         actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharset());\n         // sanity check:\n         assertEquals(name, sourceString, actualStringFromBytes);\n         // actual check:\n-        byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes);\n+        final byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes);\n         actualStringFromBytes = new String(decodedCustomBytes, name);\n         assertEquals(name, sourceString, actualStringFromBytes);\n     }\n         try {\n             new Hex().decode(new byte[]{65});\n             fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected exception\n         }\n     }\n         try {\n             new Hex().decode(\"q0\");\n             fail(\"An exception wasn't thrown when trying to decode an illegal character\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected exception\n         }\n     }\n         try {\n             new Hex().decode(\"0q\");\n             fail(\"An exception wasn't thrown when trying to decode an illegal character\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected exception\n         }\n     }\n         try {\n             new Hex().decode(new int[]{65});\n             fail(\"An exception wasn't thrown when trying to decode.\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected exception\n         }\n     }\n         try {\n             new Hex().decode(\"6\");\n             fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected exception\n         }\n     }\n         try {\n             new Hex().encode(new int[]{65});\n             fail(\"An exception wasn't thrown when trying to encode.\");\n-        } catch (EncoderException e) {\n+        } catch (final EncoderException e) {\n             // Expected exception\n         }\n     }\n \n     @Test\n     public void testEncodeDecodeRandom() throws DecoderException, EncoderException {\n-        Random random = new Random();\n-\n-        Hex hex = new Hex();\n+        final Random random = new Random();\n+\n+        final Hex hex = new Hex();\n         for (int i = 5; i > 0; i--) {\n-            byte[] data = new byte[random.nextInt(10000) + 1];\n+            final byte[] data = new byte[random.nextInt(10000) + 1];\n             random.nextBytes(data);\n \n             // static API\n-            char[] encodedChars = Hex.encodeHex(data);\n+            final char[] encodedChars = Hex.encodeHex(data);\n             byte[] decodedBytes = Hex.decodeHex(encodedChars);\n             assertTrue(Arrays.equals(data, decodedBytes));\n \n             // instance API with array parameter\n-            byte[] encodedStringBytes = hex.encode(data);\n+            final byte[] encodedStringBytes = hex.encode(data);\n             decodedBytes = hex.decode(encodedStringBytes);\n             assertTrue(Arrays.equals(data, decodedBytes));\n \n \n     @Test\n     public void testEncodeZeroes() {\n-        char[] c = Hex.encodeHex(new byte[36]);\n+        final char[] c = Hex.encodeHex(new byte[36]);\n         assertEquals(\"000000000000000000000000000000000000000000000000000000000000000000000000\", new String(c));\n     }\n \n     @Test\n     public void testHelloWorldLowerCaseHex() {\n-        byte[] b = StringUtils.getBytesUtf8(\"Hello World\");\n+        final byte[] b = StringUtils.getBytesUtf8(\"Hello World\");\n         final String expected = \"48656c6c6f20576f726c64\";\n         char[] actual;\n         actual = Hex.encodeHex(b);\n \n     @Test\n     public void testHelloWorldUpperCaseHex() {\n-        byte[] b = StringUtils.getBytesUtf8(\"Hello World\");\n+        final byte[] b = StringUtils.getBytesUtf8(\"Hello World\");\n         final String expected = \"48656C6C6F20576F726C64\";\n         char[] actual;\n         actual = Hex.encodeHex(b);\n--- a/src/test/java/org/apache/commons/codec/binary/StringUtilsTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/StringUtilsTest.java\n \n     @Test\n     public void testGetBytesIso8859_1() throws UnsupportedEncodingException {\n-        String charsetName = \"ISO-8859-1\";\n-        testGetBytesUnchecked(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringUtils.getBytesIso8859_1(STRING_FIXTURE);\n-        Assert.assertTrue(Arrays.equals(expected, actual));\n-    }\n-\n-    private void testGetBytesUnchecked(String charsetName) throws UnsupportedEncodingException {\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringUtils.getBytesUnchecked(STRING_FIXTURE, charsetName);\n+        final String charsetName = \"ISO-8859-1\";\n+        testGetBytesUnchecked(charsetName);\n+        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        final byte[] actual = StringUtils.getBytesIso8859_1(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    private void testGetBytesUnchecked(final String charsetName) throws UnsupportedEncodingException {\n+        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        final byte[] actual = StringUtils.getBytesUnchecked(STRING_FIXTURE, charsetName);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n     }\n \n     @Test\n     public void testGetBytesUsAscii() throws UnsupportedEncodingException {\n-        String charsetName = \"US-ASCII\";\n-        testGetBytesUnchecked(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringUtils.getBytesUsAscii(STRING_FIXTURE);\n+        final String charsetName = \"US-ASCII\";\n+        testGetBytesUnchecked(charsetName);\n+        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        final byte[] actual = StringUtils.getBytesUsAscii(STRING_FIXTURE);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n     }\n \n     @Test\n     public void testGetBytesUtf16() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16\";\n-        testGetBytesUnchecked(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringUtils.getBytesUtf16(STRING_FIXTURE);\n+        final String charsetName = \"UTF-16\";\n+        testGetBytesUnchecked(charsetName);\n+        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        final byte[] actual = StringUtils.getBytesUtf16(STRING_FIXTURE);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n     }\n \n     @Test\n     public void testGetBytesUtf16Be() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16BE\";\n-        testGetBytesUnchecked(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringUtils.getBytesUtf16Be(STRING_FIXTURE);\n+        final String charsetName = \"UTF-16BE\";\n+        testGetBytesUnchecked(charsetName);\n+        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        final byte[] actual = StringUtils.getBytesUtf16Be(STRING_FIXTURE);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n     }\n \n     @Test\n     public void testGetBytesUtf16Le() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16LE\";\n-        testGetBytesUnchecked(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringUtils.getBytesUtf16Le(STRING_FIXTURE);\n+        final String charsetName = \"UTF-16LE\";\n+        testGetBytesUnchecked(charsetName);\n+        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        final byte[] actual = StringUtils.getBytesUtf16Le(STRING_FIXTURE);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n     }\n \n     @Test\n     public void testGetBytesUtf8() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-8\";\n-        testGetBytesUnchecked(charsetName);\n-        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n-        byte[] actual = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        final String charsetName = \"UTF-8\";\n+        testGetBytesUnchecked(charsetName);\n+        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        final byte[] actual = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         Assert.assertTrue(Arrays.equals(expected, actual));\n     }\n \n         try {\n             StringUtils.getBytesUnchecked(STRING_FIXTURE, \"UNKNOWN\");\n             Assert.fail(\"Expected \" + IllegalStateException.class.getName());\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n             // Expected\n         }\n     }\n         Assert.assertNull(StringUtils.getBytesUnchecked(null, \"UNKNOWN\"));\n     }\n \n-    private void testNewString(String charsetName) throws UnsupportedEncodingException {\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringUtils.newString(BYTES_FIXTURE, charsetName);\n+    private void testNewString(final String charsetName) throws UnsupportedEncodingException {\n+        final String expected = new String(BYTES_FIXTURE, charsetName);\n+        final String actual = StringUtils.newString(BYTES_FIXTURE, charsetName);\n         Assert.assertEquals(expected, actual);\n     }\n \n         try {\n             StringUtils.newString(BYTES_FIXTURE, \"UNKNOWN\");\n             Assert.fail(\"Expected \" + IllegalStateException.class.getName());\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n             // Expected\n         }\n     }\n \n     @Test\n     public void testNewStringIso8859_1() throws UnsupportedEncodingException {\n-        String charsetName = \"ISO-8859-1\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringUtils.newStringIso8859_1(BYTES_FIXTURE);\n+        final String charsetName = \"ISO-8859-1\";\n+        testNewString(charsetName);\n+        final String expected = new String(BYTES_FIXTURE, charsetName);\n+        final String actual = StringUtils.newStringIso8859_1(BYTES_FIXTURE);\n         Assert.assertEquals(expected, actual);\n     }\n \n     @Test\n     public void testNewStringUsAscii() throws UnsupportedEncodingException {\n-        String charsetName = \"US-ASCII\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringUtils.newStringUsAscii(BYTES_FIXTURE);\n+        final String charsetName = \"US-ASCII\";\n+        testNewString(charsetName);\n+        final String expected = new String(BYTES_FIXTURE, charsetName);\n+        final String actual = StringUtils.newStringUsAscii(BYTES_FIXTURE);\n         Assert.assertEquals(expected, actual);\n     }\n \n     @Test\n     public void testNewStringUtf16() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringUtils.newStringUtf16(BYTES_FIXTURE);\n+        final String charsetName = \"UTF-16\";\n+        testNewString(charsetName);\n+        final String expected = new String(BYTES_FIXTURE, charsetName);\n+        final String actual = StringUtils.newStringUtf16(BYTES_FIXTURE);\n         Assert.assertEquals(expected, actual);\n     }\n \n     @Test\n     public void testNewStringUtf16Be() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16BE\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE_16BE, charsetName);\n-        String actual = StringUtils.newStringUtf16Be(BYTES_FIXTURE_16BE);\n+        final String charsetName = \"UTF-16BE\";\n+        testNewString(charsetName);\n+        final String expected = new String(BYTES_FIXTURE_16BE, charsetName);\n+        final String actual = StringUtils.newStringUtf16Be(BYTES_FIXTURE_16BE);\n         Assert.assertEquals(expected, actual);\n     }\n \n     @Test\n     public void testNewStringUtf16Le() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-16LE\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE_16LE, charsetName);\n-        String actual = StringUtils.newStringUtf16Le(BYTES_FIXTURE_16LE);\n+        final String charsetName = \"UTF-16LE\";\n+        testNewString(charsetName);\n+        final String expected = new String(BYTES_FIXTURE_16LE, charsetName);\n+        final String actual = StringUtils.newStringUtf16Le(BYTES_FIXTURE_16LE);\n         Assert.assertEquals(expected, actual);\n     }\n \n     @Test\n     public void testNewStringUtf8() throws UnsupportedEncodingException {\n-        String charsetName = \"UTF-8\";\n-        testNewString(charsetName);\n-        String expected = new String(BYTES_FIXTURE, charsetName);\n-        String actual = StringUtils.newStringUtf8(BYTES_FIXTURE);\n+        final String charsetName = \"UTF-8\";\n+        testNewString(charsetName);\n+        final String expected = new String(BYTES_FIXTURE, charsetName);\n+        final String actual = StringUtils.newStringUtf8(BYTES_FIXTURE);\n         Assert.assertEquals(expected, actual);\n     }\n }\n--- a/src/test/java/org/apache/commons/codec/digest/Apr1CryptTest.java\n+++ b/src/test/java/org/apache/commons/codec/digest/Apr1CryptTest.java\n     @Test\n     public void testApr1CryptBytes() {\n         // random salt\n-        byte[] keyBytes = new byte[] { '!', 'b', 'c', '.' };\n-        String hash = Md5Crypt.apr1Crypt(keyBytes);\n+        final byte[] keyBytes = new byte[] { '!', 'b', 'c', '.' };\n+        final String hash = Md5Crypt.apr1Crypt(keyBytes);\n         assertEquals(hash, Md5Crypt.apr1Crypt(\"!bc.\", hash));\n \n         // An empty Bytearray equals an empty String\n     @Test\n     public void testApr1CryptWithoutSalt() {\n         // Without salt, a random is generated\n-        String hash = Md5Crypt.apr1Crypt(\"secret\");\n+        final String hash = Md5Crypt.apr1Crypt(\"secret\");\n         assertTrue(hash.matches(\"^\\\\$apr1\\\\$[a-zA-Z0-9\\\\./]{8}\\\\$[a-zA-Z0-9\\\\./]{22}$\"));\n-        String hash2 = Md5Crypt.apr1Crypt(\"secret\");\n+        final String hash2 = Md5Crypt.apr1Crypt(\"secret\");\n         assertNotSame(hash, hash2);\n     }\n \n--- a/src/test/java/org/apache/commons/codec/digest/B64Test.java\n+++ b/src/test/java/org/apache/commons/codec/digest/B64Test.java\n \n     @Test\n     public void testB64from24bit() {\n-        StringBuilder buffer = new StringBuilder(\"\");\n+        final StringBuilder buffer = new StringBuilder(\"\");\n         B64.b64from24bit((byte) 8, (byte) 16, (byte) 64, 2, buffer);\n         B64.b64from24bit((byte) 7, (byte) 77, (byte) 120, 4, buffer);\n         assertEquals(\"./spo/\", buffer.toString());\n--- a/src/test/java/org/apache/commons/codec/digest/CryptTest.java\n+++ b/src/test/java/org/apache/commons/codec/digest/CryptTest.java\n \n     @Test\n     public void testCryptWithBytes() {\n-        byte[] keyBytes = new byte[] { 'b', 'y', 't', 'e' };\n-        String hash = Crypt.crypt(keyBytes);\n+        final byte[] keyBytes = new byte[] { 'b', 'y', 't', 'e' };\n+        final String hash = Crypt.crypt(keyBytes);\n         assertEquals(hash, Crypt.crypt(\"byte\", hash));\n     }\n \n--- a/src/test/java/org/apache/commons/codec/digest/Sha256CryptTest.java\n+++ b/src/test/java/org/apache/commons/codec/digest/Sha256CryptTest.java\n \n     @Test\n     public void testSha256LargetThanBlocksize() {\n-        byte[] buffer = new byte[200];\n+        final byte[] buffer = new byte[200];\n         Arrays.fill(buffer, 0, 200, (byte)'A');\n         assertEquals(\"$5$abc$HbF3RRc15OwNKB/RZZ5F.1I6zsLcKXHQoSdB9Owx/Q8\", Sha2Crypt.sha256Crypt(buffer, \"$5$abc\"));\n     }\n--- a/src/test/java/org/apache/commons/codec/digest/Sha512CryptTest.java\n+++ b/src/test/java/org/apache/commons/codec/digest/Sha512CryptTest.java\n \n     @Test\n     public void testSha256LargetThanBlocksize() {\n-        byte[] buffer = new byte[200];\n+        final byte[] buffer = new byte[200];\n         Arrays.fill(buffer, 0, 200, (byte)'A');\n         assertEquals(\"$6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1\", Sha2Crypt.sha512Crypt(buffer, \"$6$abc\"));\n     }\n--- a/src/test/java/org/apache/commons/codec/digest/UnixCryptTest.java\n+++ b/src/test/java/org/apache/commons/codec/digest/UnixCryptTest.java\n \n     @Test\n     public void testUnixCryptWithoutSalt() {\n-        String hash = UnixCrypt.crypt(\"foo\");\n+        final String hash = UnixCrypt.crypt(\"foo\");\n         assertTrue(hash.matches(\"^[a-zA-Z0-9./]{13}$\"));\n-        String hash2 = UnixCrypt.crypt(\"foo\");\n+        final String hash2 = UnixCrypt.crypt(\"foo\");\n         assertNotSame(hash, hash2);\n     }\n }\n--- a/src/test/java/org/apache/commons/codec/language/Caverphone1Test.java\n+++ b/src/test/java/org/apache/commons/codec/language/Caverphone1Test.java\n \n     @Test\n     public void testEndMb() throws EncoderException {\n-        String[][] data = {{\"mb\", \"M11111\"}, {\"mbmb\", \"MPM111\"}};\n+        final String[][] data = {{\"mb\", \"M11111\"}, {\"mbmb\", \"MPM111\"}};\n         this.checkEncodings(data);\n     }\n \n      */\n     @Test\n     public void testIsCaverphoneEquals() throws EncoderException {\n-        Caverphone1 caverphone = new Caverphone1();\n+        final Caverphone1 caverphone = new Caverphone1();\n         Assert.assertFalse(\"Caverphone encodings should not be equal\", caverphone.isEncodeEqual(\"Peter\", \"Stevenson\"));\n         Assert.assertTrue(\"Caverphone encodings should be equal\", caverphone.isEncodeEqual(\"Peter\", \"Peady\"));\n     }\n      */\n     @Test\n     public void testSpecificationV1Examples() throws EncoderException {\n-        String[][] data = {{\"David\", \"TFT111\"}, {\"Whittle\", \"WTL111\"}};\n+        final String[][] data = {{\"David\", \"TFT111\"}, {\"Whittle\", \"WTL111\"}};\n         this.checkEncodings(data);\n     }\n \n      */\n     @Test\n     public void testWikipediaExamples() throws EncoderException {\n-        String[][] data = {{\"Lee\", \"L11111\"}, {\"Thompson\", \"TMPSN1\"}};\n+        final String[][] data = {{\"Lee\", \"L11111\"}, {\"Thompson\", \"TMPSN1\"}};\n         this.checkEncodings(data);\n     }\n \n--- a/src/test/java/org/apache/commons/codec/language/Caverphone2Test.java\n+++ b/src/test/java/org/apache/commons/codec/language/Caverphone2Test.java\n      */\n     @Test\n     public void testCaverphoneRevisitedExamples() throws EncoderException {\n-        String[][] data = {{\"Stevenson\", \"STFNSN1111\"}, {\"Peter\", \"PTA1111111\"}};\n+        final String[][] data = {{\"Stevenson\", \"STFNSN1111\"}, {\"Peter\", \"PTA1111111\"}};\n         this.checkEncodings(data);\n     }\n \n \n     @Test\n     public void testEndMb() throws EncoderException {\n-        String[][] data = {{\"mb\", \"M111111111\"}, {\"mbmb\", \"MPM1111111\"}};\n+        final String[][] data = {{\"mb\", \"M111111111\"}, {\"mbmb\", \"MPM1111111\"}};\n         this.checkEncodings(data);\n     }\n \n     // Caverphone Revisited\n     @Test\n     public void testIsCaverphoneEquals() throws EncoderException {\n-        Caverphone2 caverphone = new Caverphone2();\n+        final Caverphone2 caverphone = new Caverphone2();\n         Assert.assertFalse(\"Caverphone encodings should not be equal\", caverphone.isEncodeEqual(\"Peter\", \"Stevenson\"));\n         Assert.assertTrue(\"Caverphone encodings should be equal\", caverphone.isEncodeEqual(\"Peter\", \"Peady\"));\n     }\n \n     @Test\n     public void testSpecificationExamples() throws EncoderException {\n-        String[][] data = {\n+        final String[][] data = {\n             {\"Peter\", \"PTA1111111\"},\n             {\"ready\", \"RTA1111111\"},\n             {\"social\", \"SSA1111111\"},\n--- a/src/test/java/org/apache/commons/codec/language/ColognePhoneticTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/ColognePhoneticTest.java\n \n     @Test\n     public void testEdgeCases() throws EncoderException {\n-        String[][] data = {\n+        final String[][] data = {\n             {\"a\", \"0\"},\n             {\"e\", \"0\"},\n             {\"i\", \"0\"},\n \n     @Test\n     public void testExamples() throws EncoderException {\n-        String[][] data = {\n+        final String[][] data = {\n             {\"m\\u00DCller\", \"657\"}, // m\u00dcller - why upper case U-umlaut?\n             {\"schmidt\", \"862\"},\n             {\"schneider\", \"8627\"},\n \n     @Test\n     public void testHyphen() throws EncoderException {\n-        String[][] data = {{\"bergisch-gladbach\", \"174845214\"},\n+        final String[][] data = {{\"bergisch-gladbach\", \"174845214\"},\n                 {\"M\\u00fcller-L\\u00fcdenscheidt\", \"65752682\"}}; // M\u00fcller-L\u00fcdenscheidt\n         this.checkEncodings(data);\n     }\n \n     @Test\n     public void testIsEncodeEquals() {\n-        String[][] data = {\n+        final String[][] data = {\n             {\"Meyer\", \"M\\u00fcller\"}, // M\u00fcller\n             {\"Meyer\", \"Mayr\"},\n             {\"house\", \"house\"},\n             {\"ganz\", \"Gans\"},\n             {\"ganz\", \"G\\u00e4nse\"}, // G\u00e4nse\n             {\"Miyagi\", \"Miyako\"}};\n-        for (String[] element : data) {\n+        for (final String[] element : data) {\n             this.getStringEncoder().isEncodeEqual(element[1], element[0]);\n         }\n     }\n \n     @Test\n     public void testVariationsMella() throws EncoderException {\n-        String data[] = {\"mella\", \"milah\", \"moulla\", \"mellah\", \"muehle\", \"mule\"};\n+        final String data[] = {\"mella\", \"milah\", \"moulla\", \"mellah\", \"muehle\", \"mule\"};\n         this.checkEncodingVariations(\"65\", data);\n     }\n \n     @Test\n     public void testVariationsMeyer() throws EncoderException {\n-        String data[] = {\"Meier\", \"Maier\", \"Mair\", \"Meyer\", \"Meyr\", \"Mejer\", \"Major\"};\n+        final String data[] = {\"Meier\", \"Maier\", \"Mair\", \"Meyer\", \"Meyr\", \"Mejer\", \"Major\"};\n         this.checkEncodingVariations(\"67\", data);\n     }\n }\n--- a/src/test/java/org/apache/commons/codec/language/DoubleMetaphone2Test.java\n+++ b/src/test/java/org/apache/commons/codec/language/DoubleMetaphone2Test.java\n         {\"weikersheim\", \"AKRS\", \"FKRS\"},\n         {\"zhao\", \"J\", \"J\"}};\n \n-    private void checkDoubleMetaphone(int typeIndex, boolean alternate) {\n+    private void checkDoubleMetaphone(final int typeIndex, final boolean alternate) {\n         for (int i = 0; i < TEST_DATA.length; i++) {\n-            String value = TEST_DATA[i][0];\n+            final String value = TEST_DATA[i][0];\n             assertEquals(\"Test [\" + i + \"]=\" + value, TEST_DATA[i][typeIndex], this.getStringEncoder().doubleMetaphone(value, alternate));\n         }\n     }\n--- a/src/test/java/org/apache/commons/codec/language/DoubleMetaphoneTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/DoubleMetaphoneTest.java\n     /**\n      * Tests encoding APIs in one place.\n      */\n-    private void assertDoubleMetaphone(String expected, String source) {\n+    private void assertDoubleMetaphone(final String expected, final String source) {\n         assertEquals(expected, this.getStringEncoder().encode(source));\n         try {\n             assertEquals(expected, this.getStringEncoder().encode((Object) source));\n-        } catch (EncoderException e) {\n+        } catch (final EncoderException e) {\n             fail(\"Unexpected expection: \" + e);\n         }\n         assertEquals(expected, this.getStringEncoder().doubleMetaphone(source));\n     /**\n      * Tests encoding APIs in one place.\n      */\n-    public void assertDoubleMetaphoneAlt(String expected, String source) {\n+    public void assertDoubleMetaphoneAlt(final String expected, final String source) {\n         assertEquals(expected, this.getStringEncoder().doubleMetaphone(source, true));\n     }\n \n-    public void doubleMetaphoneEqualTest(String[][] pairs, boolean useAlternate) {\n+    public void doubleMetaphoneEqualTest(final String[][] pairs, final boolean useAlternate) {\n         this.validateFixture(pairs);\n-        for (String[] pair : pairs) {\n-            String name0 = pair[0];\n-            String name1 = pair[1];\n-            String failMsg = \"Expected match between \" + name0 + \" and \" + name1 + \" (use alternate: \" + useAlternate + \")\";\n+        for (final String[] pair : pairs) {\n+            final String name0 = pair[0];\n+            final String name1 = pair[1];\n+            final String failMsg = \"Expected match between \" + name0 + \" and \" + name1 + \" (use alternate: \" + useAlternate + \")\";\n             assertTrue(failMsg, this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, useAlternate));\n             assertTrue(failMsg, this.getStringEncoder().isDoubleMetaphoneEqual(name1, name0, useAlternate));\n             if (!useAlternate) {\n         }\n     }\n \n-    public void doubleMetaphoneNotEqualTest(boolean alternate) {\n+    public void doubleMetaphoneNotEqualTest(final boolean alternate) {\n         assertFalse(this.getStringEncoder().isDoubleMetaphoneEqual(\"Brain\", \"Band\", alternate));\n         assertFalse(this.getStringEncoder().isDoubleMetaphoneEqual(\"Band\", \"Brain\", alternate));\n \n      */\n     @Test\n     public void testSetMaxCodeLength() {\n-        String value = \"jumped\";\n-\n-        DoubleMetaphone doubleMetaphone = new DoubleMetaphone();\n+        final String value = \"jumped\";\n+\n+        final DoubleMetaphone doubleMetaphone = new DoubleMetaphone();\n \n         // Sanity check of default settings\n         assertEquals(\"Default Max Code Length\", 4, doubleMetaphone.getMaxCodeLen());\n \n     @Test\n     public void testIsDoubleMetaphoneEqualBasic() {\n-        String[][] testFixture = new String[][] { { \"Case\", \"case\" }, {\n+        final String[][] testFixture = new String[][] { { \"Case\", \"case\" }, {\n                 \"CASE\", \"Case\" }, {\n                 \"caSe\", \"cAsE\" }, {\n                 \"cookie\", \"quick\" }, {\n \n     @Test\n     public void testIsDoubleMetaphoneEqualExtended2() {\n-        String[][] testFixture = new String[][] { { \"Jablonski\", \"Yablonsky\" }\n+        final String[][] testFixture = new String[][] { { \"Jablonski\", \"Yablonsky\" }\n         };\n         //doubleMetaphoneEqualTest(testFixture, false);\n         doubleMetaphoneEqualTest(testFixture, true);\n     @Test\n     public void testIsDoubleMetaphoneEqualExtended3() {\n         this.validateFixture(FIXTURE);\n-        StringBuilder failures = new StringBuilder();\n-        StringBuilder matches = new StringBuilder();\n-        String cr = System.getProperty(\"line.separator\");\n+        final StringBuilder failures = new StringBuilder();\n+        final StringBuilder matches = new StringBuilder();\n+        final String cr = System.getProperty(\"line.separator\");\n         matches.append(\"private static final String[][] MATCHES = {\" + cr);\n         int failCount = 0;\n         for (int i = 0; i < FIXTURE.length; i++) {\n-            String name0 = FIXTURE[i][0];\n-            String name1 = FIXTURE[i][1];\n-            boolean match1 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, false);\n-            boolean match2 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, true);\n+            final String name0 = FIXTURE[i][0];\n+            final String name1 = FIXTURE[i][1];\n+            final boolean match1 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, false);\n+            final boolean match2 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, true);\n             if (match1 == false && match2 == false) {\n-                String failMsg = \"[\" + i + \"] \" + name0 + \" and \" + name1 + cr;\n+                final String failMsg = \"[\" + i + \"] \" + name0 + \" and \" + name1 + cr;\n                 failures.append(failMsg);\n                 failCount++;\n             } else {\n     public void testIsDoubleMetaphoneEqualWithMATCHES() {\n         this.validateFixture(MATCHES);\n         for (int i = 0; i < MATCHES.length; i++) {\n-            String name0 = MATCHES[i][0];\n-            String name1 = MATCHES[i][1];\n-            boolean match1 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, false);\n-            boolean match2 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, true);\n+            final String name0 = MATCHES[i][0];\n+            final String name1 = MATCHES[i][1];\n+            final boolean match1 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, false);\n+            final boolean match2 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, true);\n             if (match1 == false && match2 == false) {\n                 fail(\"Expected match [\" + i + \"] \" + name0 + \" and \" + name1);\n             }\n         assertTrue(this.getStringEncoder().isDoubleMetaphoneEqual(\"\\u00f1\", \"N\")); // n-tilde\n     }\n \n-    public void validateFixture(String[][] pairs) {\n+    public void validateFixture(final String[][] pairs) {\n         if (pairs.length == 0) {\n             fail(\"Test fixture is empty\");\n         }\n--- a/src/test/java/org/apache/commons/codec/language/MetaphoneTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/MetaphoneTest.java\n  */\n public class MetaphoneTest extends StringEncoderAbstractTest<Metaphone> {\n \n-    public void assertIsMetaphoneEqual(String source, String[] matches) {\n+    public void assertIsMetaphoneEqual(final String source, final String[] matches) {\n         // match source to all matches\n-        for (String matche : matches) {\n+        for (final String matche : matches) {\n             assertTrue(\"Source: \" + source + \", should have same Metaphone as: \" + matche,\n                        this.getStringEncoder().isMetaphoneEqual(source, matche));\n         }\n         // match to each other\n-        for (String matche : matches) {\n-            for (String matche2 : matches) {\n+        for (final String matche : matches) {\n+            for (final String matche2 : matches) {\n                 assertTrue(this.getStringEncoder().isMetaphoneEqual(matche, matche2));\n             }\n         }\n     }\n \n-    public void assertMetaphoneEqual(String[][] pairs) {\n+    public void assertMetaphoneEqual(final String[][] pairs) {\n         this.validateFixture(pairs);\n-        for (String[] pair : pairs) {\n-            String name0 = pair[0];\n-            String name1 = pair[1];\n-            String failMsg = \"Expected match between \" + name0 + \" and \" + name1;\n+        for (final String[] pair : pairs) {\n+            final String name0 = pair[0];\n+            final String name1 = pair[1];\n+            final String failMsg = \"Expected match between \" + name0 + \" and \" + name1;\n             assertTrue(failMsg, this.getStringEncoder().isMetaphoneEqual(name0, name1));\n             assertTrue(failMsg, this.getStringEncoder().isMetaphoneEqual(name1, name0));\n         }\n         assertEquals( \"AKSKSK\", this.getStringEncoder().metaphone(\"AXEAXEAXE\") );\n     }\n \n-    public void validateFixture(String[][] pairs) {\n+    public void validateFixture(final String[][] pairs) {\n         if (pairs.length == 0) {\n             fail(\"Test fixture is empty\");\n         }\n--- a/src/test/java/org/apache/commons/codec/language/NysiisTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/NysiisTest.java\n      *            expected encoding.\n      * @throws EncoderException\n      */\n-    private void assertEncodings(String[]... testValues) throws EncoderException {\n-        for (String[] arr : testValues) {\n+    private void assertEncodings(final String[]... testValues) throws EncoderException {\n+        for (final String[] arr : testValues) {\n             Assert.assertEquals(\"Problem with \" + arr[0], arr[1], this.fullNysiis.encode(arr[0]));\n         }\n     }\n         return new Nysiis();\n     }\n \n-    private void encodeAll(String[] strings, String expectedEncoding) throws EncoderException {\n-        for (String string : strings) {\n+    private void encodeAll(final String[] strings, final String expectedEncoding) throws EncoderException {\n+        for (final String string : strings) {\n             Assert.assertEquals(\"Problem with \" + string, expectedEncoding, getStringEncoder().encode(string));\n         }\n     }\n \n     @Test\n     public void testTrueVariant() {\n-        Nysiis encoder = new Nysiis(true);\n-\n-        String encoded = encoder.encode(\"WESTERLUND\");\n+        final Nysiis encoder = new Nysiis(true);\n+\n+        final String encoded = encoder.encode(\"WESTERLUND\");\n         Assert.assertTrue(encoded.length() <= 6);\n         Assert.assertEquals(\"WASTAR\", encoded);\n     }\n--- a/src/test/java/org/apache/commons/codec/language/RefinedSoundexTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/RefinedSoundexTest.java\n \n     @Test\n     public void testGetMappingCodeNonLetter() {\n-        char code = this.getStringEncoder().getMappingCode('#');\n+        final char code = this.getStringEncoder().getMappingCode('#');\n         assertEquals(\"Code does not equals zero\", 0, code);\n     }\n \n--- a/src/test/java/org/apache/commons/codec/language/SoundexTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/SoundexTest.java\n                 //         uppercase E-acute\n                 Assert.assertEquals(\"\\u00c9000\", this.getStringEncoder().encode(\"\\u00e9\"));\n                 Assert.fail(\"Expected IllegalArgumentException not thrown\");\n-            } catch (IllegalArgumentException e) {\n+            } catch (final IllegalArgumentException e) {\n                 // expected\n             }\n         } else {\n                 //         uppercase O-umlaut\n                 Assert.assertEquals(\"\\u00d6000\", this.getStringEncoder().encode(\"\\u00f6\"));\n                 Assert.fail(\"Expected IllegalArgumentException not thrown\");\n-            } catch (IllegalArgumentException e) {\n+            } catch (final IllegalArgumentException e) {\n                 // expected\n             }\n         } else {\n--- a/src/test/java/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n public class BeiderMorseEncoderTest extends StringEncoderAbstractTest {\n     private static final char[] TEST_CHARS = new char[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'o', 'u' };\n \n-    private void assertNotEmpty(BeiderMorseEncoder bmpm, final String value) throws EncoderException {\n+    private void assertNotEmpty(final BeiderMorseEncoder bmpm, final String value) throws EncoderException {\n         Assert.assertFalse(value, bmpm.encode(value).equals(\"\"));\n     }\n \n     private BeiderMorseEncoder createGenericApproxEncoder() {\n-        BeiderMorseEncoder encoder = new BeiderMorseEncoder();\n+        final BeiderMorseEncoder encoder = new BeiderMorseEncoder();\n         encoder.setNameType(NameType.GENERIC);\n         encoder.setRuleType(RuleType.APPROX);\n         return encoder;\n      */\n     @Test\n     public void testAllChars() throws EncoderException {\n-        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        final BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n         for (char c = Character.MIN_VALUE; c < Character.MAX_VALUE; c++) {\n             bmpm.encode(Character.toString(c));\n         }\n \n     @Test\n     public void testAsciiEncodeNotEmpty1Letter() throws EncoderException {\n-        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        final BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n         for (char c = 'a'; c <= 'z'; c++) {\n             final String value = Character.toString(c);\n             final String valueU = value.toUpperCase();\n \n     @Test\n     public void testAsciiEncodeNotEmpty2Letters() throws EncoderException {\n-        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        final BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n         for (char c1 = 'a'; c1 <= 'z'; c1++) {\n             for (char c2 = 'a'; c2 <= 'z'; c2++) {\n                 final String value = new String(new char[] { c1, c2 });\n \n     @Test\n     public void testEncodeAtzNotEmpty() throws EncoderException {\n-        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        final BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n         //String[] names = { \"\u00e1cz\", \"\u00e1tz\", \"Ign\u00e1cz\", \"Ign\u00e1tz\", \"Ign\u00e1c\" };\n-        String[] names = { \"\\u00e1cz\", \"\\u00e1tz\", \"Ign\\u00e1cz\", \"Ign\\u00e1tz\", \"Ign\\u00e1c\" };\n-        for (String name : names) {\n+        final String[] names = { \"\\u00e1cz\", \"\\u00e1tz\", \"Ign\\u00e1cz\", \"Ign\\u00e1tz\", \"Ign\\u00e1c\" };\n+        for (final String name : names) {\n             assertNotEmpty(bmpm, name);\n         }\n     }\n      */\n     @Test\n     public void testEncodeGna() throws EncoderException {\n-        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        final BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n         bmpm.encode(\"gna\");\n     }\n \n \n     @Test(timeout = 10000L)\n     public void testLongestEnglishSurname() throws EncoderException {\n-        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        final BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n         bmpm.encode(\"MacGhilleseatheanaich\");\n     }\n \n     @Test(expected = IndexOutOfBoundsException.class)\n     public void testNegativeIndexForRuleMatchIndexOutOfBoundsException() {\n-        Rule r = new Rule(\"a\", \"\", \"\", new Rule.Phoneme(\"\", Languages.ANY_LANGUAGE));\n+        final Rule r = new Rule(\"a\", \"\", \"\", new Rule.Phoneme(\"\", Languages.ANY_LANGUAGE));\n         r.patternAndContextMatches(\"bob\", -1);\n     }\n \n     @Test\n     public void testOOM() throws EncoderException {\n-        String phrase = \"200697900'-->&#1913348150;</  bceaeef >aadaabcf\\\"aedfbff<!--\\'-->?>cae\"\n+        final String phrase = \"200697900'-->&#1913348150;</  bceaeef >aadaabcf\\\"aedfbff<!--\\'-->?>cae\"\n                 + \"cfaaa><?&#<!--</script>&lang&fc;aadeaf?>>&bdquo<    cc =\\\"abff\\\"    /></   afe  >\"\n                 + \"<script><!-- f(';<    cf aefbeef = \\\"bfabadcf\\\" ebbfeedd = fccabeb >\";\n \n-        BeiderMorseEncoder encoder = new BeiderMorseEncoder();\n+        final BeiderMorseEncoder encoder = new BeiderMorseEncoder();\n         encoder.setNameType(NameType.GENERIC);\n         encoder.setRuleType(RuleType.EXACT);\n         encoder.setMaxPhonemes(10);\n \n-        String phonemes = encoder.encode(phrase);\n+        final String phonemes = encoder.encode(phrase);\n         assertTrue(phonemes.length() > 0);\n \n-        String[] phonemeArr = phonemes.split(\"\\\\|\");\n+        final String[] phonemeArr = phonemes.split(\"\\\\|\");\n         assertTrue(phonemeArr.length <= 10);\n     }\n \n     @Test\n     public void testSetConcat() {\n-        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        final BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n         bmpm.setConcat(false);\n         assertFalse(\"Should be able to set concat to false\", bmpm.isConcat());\n     }\n \n     @Test\n     public void testSetNameTypeAsh() {\n-        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        final BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n         bmpm.setNameType(NameType.ASHKENAZI);\n         assertEquals(\"Name type should have been set to ash\", NameType.ASHKENAZI, bmpm.getNameType());\n     }\n \n     @Test\n     public void testSetRuleTypeExact() {\n-        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        final BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n         bmpm.setRuleType(RuleType.EXACT);\n         assertEquals(\"Rule type should have been set to exact\", RuleType.EXACT, bmpm.getRuleType());\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testSetRuleTypeToRulesIllegalArgumentException() {\n-        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        final BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n         bmpm.setRuleType(RuleType.RULES);\n     }\n \n      */\n     @Test(/* timeout = 20000L */)\n     public void testSpeedCheck() throws EncoderException {\n-        BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n-        StringBuilder stringBuffer = new StringBuilder();\n+        final BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n+        final StringBuilder stringBuffer = new StringBuilder();\n         stringBuffer.append(TEST_CHARS[0]);\n         for (int i = 0, j = 1; i < 40; i++, j++) {\n             if (j == TEST_CHARS.length) {\n \n     @Test\n     public void testSpeedCheck2() throws EncoderException {\n-        BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n-        String phrase = \"ItstheendoftheworldasweknowitandIfeelfine\";\n+        final BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n+        final String phrase = \"ItstheendoftheworldasweknowitandIfeelfine\";\n \n         for (int i = 1; i <= phrase.length(); i++) {\n             bmpm.encode(phrase.subSequence(0, i));\n \n     @Test\n     public void testSpeedCheck3() throws EncoderException {\n-        BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n-        String phrase = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\";\n+        final BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n+        final String phrase = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\";\n \n         for (int i = 1; i <= phrase.length(); i++) {\n             bmpm.encode(phrase.subSequence(0, i));\n--- a/src/test/java/org/apache/commons/codec/language/bm/LanguageGuessingTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/bm/LanguageGuessingTest.java\n     private final String language;\n     private final String name;\n \n-    public LanguageGuessingTest(String name, String language, String exactness) {\n+    public LanguageGuessingTest(final String name, final String language, final String exactness) {\n         this.name = name;\n         this.language = language;\n         this.exactness = exactness;\n \n     @Test\n     public void testLanguageGuessing() {\n-        Languages.LanguageSet guesses = this.lang.guessLanguages(this.name);\n+        final Languages.LanguageSet guesses = this.lang.guessLanguages(this.name);\n \n         assertTrue(\"language predicted for name '\" + this.name + \"' is wrong: \" + guesses + \" should contain '\" + this.language + \"'\",\n                 guesses.contains(this.language));\n--- a/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineRegressionTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineRegressionTest.java\n      * Making a JUnit test out of it to protect Solr from possible future\n      * regressions in Commons-Codec.\n      */\n-    private static String encode(Map<String, String> args, boolean concat, String input) {\n+    private static String encode(final Map<String, String> args, final boolean concat, final String input) {\n         Languages.LanguageSet languageSet;\n         PhoneticEngine engine;\n \n         // PhoneticEngine = NameType + RuleType + concat\n         // we use common-codec's defaults: GENERIC + APPROX + true\n-        String nameTypeArg = args.get(\"nameType\");\n-        NameType nameType = (nameTypeArg == null) ? NameType.GENERIC : NameType.valueOf(nameTypeArg);\n-\n-        String ruleTypeArg = args.get(\"ruleType\");\n-        RuleType ruleType = (ruleTypeArg == null) ? RuleType.APPROX : RuleType.valueOf(ruleTypeArg);\n+        final String nameTypeArg = args.get(\"nameType\");\n+        final NameType nameType = (nameTypeArg == null) ? NameType.GENERIC : NameType.valueOf(nameTypeArg);\n+\n+        final String ruleTypeArg = args.get(\"ruleType\");\n+        final RuleType ruleType = (ruleTypeArg == null) ? RuleType.APPROX : RuleType.valueOf(ruleTypeArg);\n \n         engine = new PhoneticEngine(nameType, ruleType, concat);\n \n         // LanguageSet: defaults to automagic, otherwise a comma-separated list.\n-        String languageSetArg = args.get(\"languageSet\");\n+        final String languageSetArg = args.get(\"languageSet\");\n         if (languageSetArg == null || languageSetArg.equals(\"auto\")) {\n             languageSet = null;\n         } else {\n--- a/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineTest.java\n     private final RuleType ruleType;\n     private final int maxPhonemes;\n \n-    public PhoneticEngineTest(String name, String phoneticExpected, NameType nameType,\n-                              RuleType ruleType, boolean concat, int maxPhonemes) {\n+    public PhoneticEngineTest(final String name, final String phoneticExpected, final NameType nameType,\n+                              final RuleType ruleType, final boolean concat, final int maxPhonemes) {\n         this.name = name;\n         this.phoneticExpected = phoneticExpected;\n         this.nameType = nameType;\n \n     @Test(timeout = 10000L)\n     public void testEncode() {\n-        PhoneticEngine engine = new PhoneticEngine(this.nameType, this.ruleType, this.concat, this.maxPhonemes);\n+        final PhoneticEngine engine = new PhoneticEngine(this.nameType, this.ruleType, this.concat, this.maxPhonemes);\n \n-        String phoneticActual = engine.encode(this.name);\n+        final String phoneticActual = engine.encode(this.name);\n \n         //System.err.println(\"expecting: \" + this.phoneticExpected);\n         //System.err.println(\"actual:    \" + phoneticActual);\n         assertEquals(\"phoneme incorrect\", this.phoneticExpected, phoneticActual);\n \n         if (this.concat) {\n-            String[] split = phoneticActual.split(\"\\\\|\");\n+            final String[] split = phoneticActual.split(\"\\\\|\");\n             assertTrue(split.length <= this.maxPhonemes);\n         } else {\n-            String[] words = phoneticActual.split(\"-\");\n-            for (String word : words) {\n-                String[] split = word.split(\"\\\\|\");\n+            final String[] words = phoneticActual.split(\"-\");\n+            for (final String word : words) {\n+                final String[] split = word.split(\"\\\\|\");\n                 assertTrue(split.length <= this.maxPhonemes);\n             }\n         }\n--- a/src/test/java/org/apache/commons/codec/language/bm/RuleTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/bm/RuleTest.java\n public class RuleTest {\n     private static class NegativeIntegerBaseMatcher extends BaseMatcher<Integer> {\n         @Override\n-        public void describeTo(Description description) {\n+        public void describeTo(final Description description) {\n             description.appendText(\"value should be negative\");\n         }\n \n         @Override\n-        public boolean matches(Object item) {\n+        public boolean matches(final Object item) {\n             return ((Integer) item).intValue() < 0;\n         }\n     }\n \n     private Rule.Phoneme[][] makePhonemes() {\n-        String[][] words = {\n+        final String[][] words = {\n                 { \"rinD\", \"rinDlt\", \"rina\", \"rinalt\", \"rino\", \"rinolt\", \"rinu\", \"rinult\" },\n                 { \"dortlaj\", \"dortlej\", \"ortlaj\", \"ortlej\", \"ortlej-dortlaj\" } };\n-        Rule.Phoneme[][] phonemes = new Rule.Phoneme[words.length][];\n+        final Rule.Phoneme[][] phonemes = new Rule.Phoneme[words.length][];\n \n         for (int i = 0; i < words.length; i++) {\n-            String[] words_i = words[i];\n-            Rule.Phoneme[] phonemes_i = phonemes[i] = new Rule.Phoneme[words_i.length];\n+            final String[] words_i = words[i];\n+            final Rule.Phoneme[] phonemes_i = phonemes[i] = new Rule.Phoneme[words_i.length];\n             for (int j = 0; j < words_i.length; j++) {\n                 phonemes_i[j] = new Rule.Phoneme(words_i[j], Languages.NO_LANGUAGES);\n             }\n \n     @Test\n     public void testPhonemeComparedToLaterIsNegative() {\n-        for (Rule.Phoneme[] phs : makePhonemes()) {\n+        for (final Rule.Phoneme[] phs : makePhonemes()) {\n             for (int i = 0; i < phs.length; i++) {\n                 for (int j = i + 1; j < phs.length; j++) {\n-                    int c = Rule.Phoneme.COMPARATOR.compare(phs[i], phs[j]);\n+                    final int c = Rule.Phoneme.COMPARATOR.compare(phs[i], phs[j]);\n \n                     assertThat(\"Comparing \" + phs[i].getPhonemeText() + \" to \" + phs[j].getPhonemeText() + \" should be negative\", Integer.valueOf(c),\n                             new NegativeIntegerBaseMatcher());\n \n     @Test\n     public void testPhonemeComparedToSelfIsZero() {\n-        for (Rule.Phoneme[] phs : makePhonemes()) {\n-            for (Rule.Phoneme ph : phs) {\n+        for (final Rule.Phoneme[] phs : makePhonemes()) {\n+            for (final Rule.Phoneme ph : phs) {\n                 assertEquals(\"Phoneme compared to itself should be zero: \" + ph.getPhonemeText(), 0,\n                         Rule.Phoneme.COMPARATOR.compare(ph, ph));\n             }\n     public void testSubSequenceWorks() {\n         // AppendableCharSequence is private to Rule. We can only make it through a Phoneme.\n \n-        Rule.Phoneme a = new Rule.Phoneme(\"a\", null);\n-        Rule.Phoneme b = new Rule.Phoneme(\"b\", null);\n-        Rule.Phoneme cd = new Rule.Phoneme(\"cd\", null);\n-        Rule.Phoneme ef = new Rule.Phoneme(\"ef\", null);\n-        Rule.Phoneme ghi = new Rule.Phoneme(\"ghi\", null);\n-        Rule.Phoneme jkl = new Rule.Phoneme(\"jkl\", null);\n+        final Rule.Phoneme a = new Rule.Phoneme(\"a\", null);\n+        final Rule.Phoneme b = new Rule.Phoneme(\"b\", null);\n+        final Rule.Phoneme cd = new Rule.Phoneme(\"cd\", null);\n+        final Rule.Phoneme ef = new Rule.Phoneme(\"ef\", null);\n+        final Rule.Phoneme ghi = new Rule.Phoneme(\"ghi\", null);\n+        final Rule.Phoneme jkl = new Rule.Phoneme(\"jkl\", null);\n \n         assertEquals('a', a.getPhonemeText().charAt(0));\n         assertEquals('b', b.getPhonemeText().charAt(0));\n         assertEquals('k', jkl.getPhonemeText().charAt(1));\n         assertEquals('l', jkl.getPhonemeText().charAt(2));\n \n-        Rule.Phoneme a_b = a.append(b.getPhonemeText());\n+        final Rule.Phoneme a_b = a.append(b.getPhonemeText());\n         assertEquals('a', a_b.getPhonemeText().charAt(0));\n         assertEquals('b', a_b.getPhonemeText().charAt(1));\n         assertEquals(\"ab\", a_b.getPhonemeText().subSequence(0, 2).toString());\n         assertEquals(\"a\", a_b.getPhonemeText().subSequence(0, 1).toString());\n         assertEquals(\"b\", a_b.getPhonemeText().subSequence(1, 2).toString());\n \n-        Rule.Phoneme cd_ef = cd.append(ef.getPhonemeText());\n+        final Rule.Phoneme cd_ef = cd.append(ef.getPhonemeText());\n         assertEquals('c', cd_ef.getPhonemeText().charAt(0));\n         assertEquals('d', cd_ef.getPhonemeText().charAt(1));\n         assertEquals('e', cd_ef.getPhonemeText().charAt(2));\n         assertEquals(\"def\", cd_ef.getPhonemeText().subSequence(1, 4).toString());\n         assertEquals(\"cdef\", cd_ef.getPhonemeText().subSequence(0, 4).toString());\n \n-        Rule.Phoneme a_b_cd = a.append(b.getPhonemeText()).append(cd.getPhonemeText());\n+        final Rule.Phoneme a_b_cd = a.append(b.getPhonemeText()).append(cd.getPhonemeText());\n         assertEquals('a', a_b_cd.getPhonemeText().charAt(0));\n         assertEquals('b', a_b_cd.getPhonemeText().charAt(1));\n         assertEquals('c', a_b_cd.getPhonemeText().charAt(2));\n--- a/src/test/java/org/apache/commons/codec/net/BCodecTest.java\n+++ b/src/test/java/org/apache/commons/codec/net/BCodecTest.java\n     static final int RUSSIAN_STUFF_UNICODE[] =\n         { 0x412, 0x441, 0x435, 0x43C, 0x5F, 0x43F, 0x440, 0x438, 0x432, 0x435, 0x442 };\n \n-    private String constructString(int[] unicodeChars) {\n-        StringBuilder buffer = new StringBuilder();\n+    private String constructString(final int[] unicodeChars) {\n+        final StringBuilder buffer = new StringBuilder();\n         if (unicodeChars != null) {\n-            for (int unicodeChar : unicodeChars) {\n+            for (final int unicodeChar : unicodeChars) {\n                 buffer.append((char) unicodeChar);\n             }\n         }\n \n     @Test\n     public void testNullInput() throws Exception {\n-        BCodec bcodec = new BCodec();\n+        final BCodec bcodec = new BCodec();\n         assertNull(bcodec.doDecoding(null));\n         assertNull(bcodec.doEncoding(null));\n     }\n     @Test\n     public void testUTF8RoundTrip() throws Exception {\n \n-        String ru_msg = constructString(RUSSIAN_STUFF_UNICODE);\n-        String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE);\n+        final String ru_msg = constructString(RUSSIAN_STUFF_UNICODE);\n+        final String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE);\n \n-        BCodec bcodec = new BCodec(CharEncoding.UTF_8);\n+        final BCodec bcodec = new BCodec(CharEncoding.UTF_8);\n \n         assertEquals(\"=?UTF-8?B?0JLRgdC10Lxf0L/RgNC40LLQtdGC?=\", bcodec.encode(ru_msg));\n         assertEquals(\"=?UTF-8?B?R3LDvGV6aV96w6Rtw6Q=?=\", bcodec.encode(ch_msg));\n \n     @Test\n     public void testBasicEncodeDecode() throws Exception {\n-        BCodec bcodec = new BCodec();\n-        String plain = \"Hello there\";\n-        String encoded = bcodec.encode(plain);\n+        final BCodec bcodec = new BCodec();\n+        final String plain = \"Hello there\";\n+        final String encoded = bcodec.encode(plain);\n         assertEquals(\"Basic B encoding test\", \"=?UTF-8?B?SGVsbG8gdGhlcmU=?=\", encoded);\n         assertEquals(\"Basic B decoding test\", plain, bcodec.decode(encoded));\n     }\n \n     @Test\n     public void testEncodeDecodeNull() throws Exception {\n-        BCodec bcodec = new BCodec();\n+        final BCodec bcodec = new BCodec();\n         assertNull(\"Null string B encoding test\", bcodec.encode((String) null));\n         assertNull(\"Null string B decoding test\", bcodec.decode((String) null));\n     }\n \n     @Test\n     public void testEncodeStringWithNull() throws Exception {\n-        BCodec bcodec = new BCodec();\n-        String test = null;\n-        String result = bcodec.encode(test, \"charset\");\n+        final BCodec bcodec = new BCodec();\n+        final String test = null;\n+        final String result = bcodec.encode(test, \"charset\");\n         assertEquals(\"Result should be null\", null, result);\n     }\n \n     @Test\n     public void testDecodeStringWithNull() throws Exception {\n-        BCodec bcodec = new BCodec();\n-        String test = null;\n-        String result = bcodec.decode(test);\n+        final BCodec bcodec = new BCodec();\n+        final String test = null;\n+        final String result = bcodec.decode(test);\n         assertEquals(\"Result should be null\", null, result);\n     }\n \n     @Test\n     public void testEncodeObjects() throws Exception {\n-        BCodec bcodec = new BCodec();\n-        String plain = \"what not\";\n-        String encoded = (String) bcodec.encode((Object) plain);\n+        final BCodec bcodec = new BCodec();\n+        final String plain = \"what not\";\n+        final String encoded = (String) bcodec.encode((Object) plain);\n \n         assertEquals(\"Basic B encoding test\", \"=?UTF-8?B?d2hhdCBub3Q=?=\", encoded);\n \n-        Object result = bcodec.encode((Object) null);\n+        final Object result = bcodec.encode((Object) null);\n         assertEquals(\"Encoding a null Object should return null\", null, result);\n \n         try {\n-            Object dObj = new Double(3.0);\n+            final Object dObj = new Double(3.0);\n             bcodec.encode(dObj);\n             fail(\"Trying to url encode a Double object should cause an exception.\");\n-        } catch (EncoderException ee) {\n+        } catch (final EncoderException ee) {\n             // Exception expected, test segment passes.\n         }\n     }\n \n     @Test\n     public void testDecodeObjects() throws Exception {\n-        BCodec bcodec = new BCodec();\n-        String decoded = \"=?UTF-8?B?d2hhdCBub3Q=?=\";\n-        String plain = (String) bcodec.decode((Object) decoded);\n+        final BCodec bcodec = new BCodec();\n+        final String decoded = \"=?UTF-8?B?d2hhdCBub3Q=?=\";\n+        final String plain = (String) bcodec.decode((Object) decoded);\n         assertEquals(\"Basic B decoding test\", \"what not\", plain);\n \n-        Object result = bcodec.decode((Object) null);\n+        final Object result = bcodec.decode((Object) null);\n         assertEquals(\"Decoding a null Object should return null\", null, result);\n \n         try {\n-            Object dObj = new Double(3.0);\n+            final Object dObj = new Double(3.0);\n             bcodec.decode(dObj);\n             fail(\"Trying to url encode a Double object should cause an exception.\");\n-        } catch (DecoderException ee) {\n+        } catch (final DecoderException ee) {\n             // Exception expected, test segment passes.\n         }\n     }\n--- a/src/test/java/org/apache/commons/codec/net/QCodecTest.java\n+++ b/src/test/java/org/apache/commons/codec/net/QCodecTest.java\n         0x432, 0x435, 0x442\n     };\n \n-    private String constructString(int [] unicodeChars) {\n-        StringBuilder buffer = new StringBuilder();\n+    private String constructString(final int [] unicodeChars) {\n+        final StringBuilder buffer = new StringBuilder();\n         if (unicodeChars != null) {\n-            for (int unicodeChar : unicodeChars) {\n+            for (final int unicodeChar : unicodeChars) {\n                 buffer.append((char)unicodeChar);\n             }\n         }\n \n     @Test\n     public void testNullInput() throws Exception {\n-        QCodec qcodec = new QCodec();\n+        final QCodec qcodec = new QCodec();\n         assertNull(qcodec.doDecoding(null));\n         assertNull(qcodec.doEncoding(null));\n     }\n     @Test\n     public void testUTF8RoundTrip() throws Exception {\n \n-        String ru_msg = constructString(RUSSIAN_STUFF_UNICODE);\n-        String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE);\n-\n-        QCodec qcodec = new QCodec(CharEncoding.UTF_8);\n+        final String ru_msg = constructString(RUSSIAN_STUFF_UNICODE);\n+        final String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE);\n+\n+        final QCodec qcodec = new QCodec(CharEncoding.UTF_8);\n \n         assertEquals(\n             \"=?UTF-8?Q?=D0=92=D1=81=D0=B5=D0=BC=5F=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82?=\",\n \n     @Test\n     public void testBasicEncodeDecode() throws Exception {\n-        QCodec qcodec = new QCodec();\n-        String plain = \"= Hello there =\\r\\n\";\n-        String encoded = qcodec.encode(plain);\n+        final QCodec qcodec = new QCodec();\n+        final String plain = \"= Hello there =\\r\\n\";\n+        final String encoded = qcodec.encode(plain);\n         assertEquals(\"Basic Q encoding test\",\n             \"=?UTF-8?Q?=3D Hello there =3D=0D=0A?=\", encoded);\n         assertEquals(\"Basic Q decoding test\",\n \n     @Test\n     public void testUnsafeEncodeDecode() throws Exception {\n-        QCodec qcodec = new QCodec();\n-        String plain = \"?_=\\r\\n\";\n-        String encoded = qcodec.encode(plain);\n+        final QCodec qcodec = new QCodec();\n+        final String plain = \"?_=\\r\\n\";\n+        final String encoded = qcodec.encode(plain);\n         assertEquals(\"Unsafe chars Q encoding test\",\n             \"=?UTF-8?Q?=3F=5F=3D=0D=0A?=\", encoded);\n         assertEquals(\"Unsafe chars Q decoding test\",\n \n     @Test\n     public void testEncodeDecodeNull() throws Exception {\n-        QCodec qcodec = new QCodec();\n+        final QCodec qcodec = new QCodec();\n         assertNull(\"Null string Q encoding test\",\n             qcodec.encode((String)null));\n         assertNull(\"Null string Q decoding test\",\n \n     @Test\n     public void testEncodeStringWithNull() throws Exception {\n-        QCodec qcodec = new QCodec();\n-        String test = null;\n-        String result = qcodec.encode( test, \"charset\" );\n+        final QCodec qcodec = new QCodec();\n+        final String test = null;\n+        final String result = qcodec.encode( test, \"charset\" );\n         assertEquals(\"Result should be null\", null, result);\n     }\n \n     @Test\n     public void testDecodeStringWithNull() throws Exception {\n-        QCodec qcodec = new QCodec();\n-        String test = null;\n-        String result = qcodec.decode( test );\n+        final QCodec qcodec = new QCodec();\n+        final String test = null;\n+        final String result = qcodec.decode( test );\n         assertEquals(\"Result should be null\", null, result);\n     }\n \n \n     @Test\n     public void testEncodeObjects() throws Exception {\n-        QCodec qcodec = new QCodec();\n-        String plain = \"1+1 = 2\";\n-        String encoded = (String) qcodec.encode((Object) plain);\n+        final QCodec qcodec = new QCodec();\n+        final String plain = \"1+1 = 2\";\n+        final String encoded = (String) qcodec.encode((Object) plain);\n         assertEquals(\"Basic Q encoding test\",\n             \"=?UTF-8?Q?1+1 =3D 2?=\", encoded);\n \n-        Object result = qcodec.encode((Object) null);\n+        final Object result = qcodec.encode((Object) null);\n         assertEquals( \"Encoding a null Object should return null\", null, result);\n \n         try {\n-            Object dObj = new Double(3.0);\n+            final Object dObj = new Double(3.0);\n             qcodec.encode( dObj );\n             fail( \"Trying to url encode a Double object should cause an exception.\");\n-        } catch (EncoderException ee) {\n+        } catch (final EncoderException ee) {\n             // Exception expected, test segment passes.\n         }\n     }\n \n     @Test\n     public void testDecodeObjects() throws Exception {\n-        QCodec qcodec = new QCodec();\n-        String decoded = \"=?UTF-8?Q?1+1 =3D 2?=\";\n-        String plain = (String) qcodec.decode((Object) decoded);\n+        final QCodec qcodec = new QCodec();\n+        final String decoded = \"=?UTF-8?Q?1+1 =3D 2?=\";\n+        final String plain = (String) qcodec.decode((Object) decoded);\n         assertEquals(\"Basic Q decoding test\",\n             \"1+1 = 2\", plain);\n \n-        Object result = qcodec.decode((Object) null);\n+        final Object result = qcodec.decode((Object) null);\n         assertEquals( \"Decoding a null Object should return null\", null, result);\n \n         try {\n-            Object dObj = new Double(3.0);\n+            final Object dObj = new Double(3.0);\n             qcodec.decode( dObj );\n             fail( \"Trying to url encode a Double object should cause an exception.\");\n-        } catch (DecoderException ee) {\n+        } catch (final DecoderException ee) {\n             // Exception expected, test segment passes.\n         }\n     }\n \n     @Test\n     public void testEncodeDecodeBlanks() throws Exception {\n-        String plain = \"Mind those pesky blanks\";\n-        String encoded1 = \"=?UTF-8?Q?Mind those pesky blanks?=\";\n-        String encoded2 = \"=?UTF-8?Q?Mind_those_pesky_blanks?=\";\n-        QCodec qcodec = new QCodec();\n+        final String plain = \"Mind those pesky blanks\";\n+        final String encoded1 = \"=?UTF-8?Q?Mind those pesky blanks?=\";\n+        final String encoded2 = \"=?UTF-8?Q?Mind_those_pesky_blanks?=\";\n+        final QCodec qcodec = new QCodec();\n         qcodec.setEncodeBlanks(false);\n         String s = qcodec.encode(plain);\n         assertEquals(\"Blanks encoding with the Q codec test\", encoded1, s);\n \n     @Test\n     public void testLetUsMakeCloverHappy() throws Exception {\n-        QCodec qcodec = new QCodec();\n+        final QCodec qcodec = new QCodec();\n         qcodec.setEncodeBlanks(true);\n         assertTrue(qcodec.isEncodeBlanks());\n         qcodec.setEncodeBlanks(false);\n--- a/src/test/java/org/apache/commons/codec/net/QuotedPrintableCodecTest.java\n+++ b/src/test/java/org/apache/commons/codec/net/QuotedPrintableCodecTest.java\n         0x432, 0x435, 0x442\n     };\n \n-    private String constructString(int [] unicodeChars) {\n-        StringBuilder buffer = new StringBuilder();\n+    private String constructString(final int [] unicodeChars) {\n+        final StringBuilder buffer = new StringBuilder();\n         if (unicodeChars != null) {\n-            for (int unicodeChar : unicodeChars) {\n+            for (final int unicodeChar : unicodeChars) {\n                 buffer.append((char)unicodeChar);\n             }\n         }\n     @Test\n     public void testUTF8RoundTrip() throws Exception {\n \n-        String ru_msg = constructString(RUSSIAN_STUFF_UNICODE);\n-        String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE);\n-\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final String ru_msg = constructString(RUSSIAN_STUFF_UNICODE);\n+        final String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE);\n+\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n \n         assertEquals(\n             \"=D0=92=D1=81=D0=B5=D0=BC_=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82\",\n \n     @Test\n     public void testBasicEncodeDecode() throws Exception {\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n-        String plain = \"= Hello there =\\r\\n\";\n-        String encoded = qpcodec.encode(plain);\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final String plain = \"= Hello there =\\r\\n\";\n+        final String encoded = qpcodec.encode(plain);\n         assertEquals(\"Basic quoted-printable encoding test\",\n             \"=3D Hello there =3D=0D=0A\", encoded);\n         assertEquals(\"Basic quoted-printable decoding test\",\n \n     @Test\n     public void testSafeCharEncodeDecode() throws Exception {\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n-        String plain = \"abc123_-.*~!@#$%^&()+{}\\\"\\\\;:`,/[]\";\n-        String encoded = qpcodec.encode(plain);\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final String plain = \"abc123_-.*~!@#$%^&()+{}\\\"\\\\;:`,/[]\";\n+        final String encoded = qpcodec.encode(plain);\n         assertEquals(\"Safe chars quoted-printable encoding test\",\n             plain, encoded);\n         assertEquals(\"Safe chars quoted-printable decoding test\",\n \n     @Test\n     public void testUnsafeEncodeDecode() throws Exception {\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n-        String plain = \"=\\r\\n\";\n-        String encoded = qpcodec.encode(plain);\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final String plain = \"=\\r\\n\";\n+        final String encoded = qpcodec.encode(plain);\n         assertEquals(\"Unsafe chars quoted-printable encoding test\",\n             \"=3D=0D=0A\", encoded);\n         assertEquals(\"Unsafe chars quoted-printable decoding test\",\n \n     @Test\n     public void testEncodeDecodeNull() throws Exception {\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n         assertNull(\"Null string quoted-printable encoding test\",\n             qpcodec.encode((String)null));\n         assertNull(\"Null string quoted-printable decoding test\",\n \n     @Test\n     public void testDecodeInvalid() throws Exception {\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n         try {\n             qpcodec.decode(\"=\");\n             fail(\"DecoderException should have been thrown\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected. Move on\n         }\n         try {\n             qpcodec.decode(\"=A\");\n             fail(\"DecoderException should have been thrown\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected. Move on\n         }\n         try {\n             qpcodec.decode(\"=WW\");\n             fail(\"DecoderException should have been thrown\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected. Move on\n         }\n     }\n \n     @Test\n     public void testEncodeNull() throws Exception {\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n-        byte[] plain = null;\n-        byte[] encoded = qpcodec.encode(plain);\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final byte[] plain = null;\n+        final byte[] encoded = qpcodec.encode(plain);\n         assertEquals(\"Encoding a null string should return null\",\n             null, encoded);\n     }\n \n     @Test\n     public void testEncodeUrlWithNullBitSet() throws Exception {\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n-        String plain = \"1+1 = 2\";\n-        String encoded = new String(QuotedPrintableCodec.\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final String plain = \"1+1 = 2\";\n+        final String encoded = new String(QuotedPrintableCodec.\n             encodeQuotedPrintable(null, plain.getBytes(Charsets.UTF_8)));\n         assertEquals(\"Basic quoted-printable encoding test\",\n             \"1+1 =3D 2\", encoded);\n \n     @Test\n     public void testDecodeWithNullArray() throws Exception {\n-        byte[] plain = null;\n-        byte[] result = QuotedPrintableCodec.decodeQuotedPrintable( plain );\n+        final byte[] plain = null;\n+        final byte[] result = QuotedPrintableCodec.decodeQuotedPrintable( plain );\n         assertEquals(\"Result should be null\", null, result);\n     }\n \n     @Test\n     public void testEncodeStringWithNull() throws Exception {\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n-        String test = null;\n-        String result = qpcodec.encode( test, \"charset\" );\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final String test = null;\n+        final String result = qpcodec.encode( test, \"charset\" );\n         assertEquals(\"Result should be null\", null, result);\n     }\n \n     @Test\n     public void testDecodeStringWithNull() throws Exception {\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n-        String test = null;\n-        String result = qpcodec.decode( test, \"charset\" );\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final String test = null;\n+        final String result = qpcodec.decode( test, \"charset\" );\n         assertEquals(\"Result should be null\", null, result);\n     }\n \n     @Test\n     public void testEncodeObjects() throws Exception {\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n-        String plain = \"1+1 = 2\";\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final String plain = \"1+1 = 2\";\n         String encoded = (String) qpcodec.encode((Object) plain);\n         assertEquals(\"Basic quoted-printable encoding test\",\n             \"1+1 =3D 2\", encoded);\n \n-        byte[] plainBA = plain.getBytes(Charsets.UTF_8);\n-        byte[] encodedBA = (byte[]) qpcodec.encode((Object) plainBA);\n+        final byte[] plainBA = plain.getBytes(Charsets.UTF_8);\n+        final byte[] encodedBA = (byte[]) qpcodec.encode((Object) plainBA);\n         encoded = new String(encodedBA);\n         assertEquals(\"Basic quoted-printable encoding test\",\n             \"1+1 =3D 2\", encoded);\n \n-        Object result = qpcodec.encode((Object) null);\n+        final Object result = qpcodec.encode((Object) null);\n         assertEquals( \"Encoding a null Object should return null\", null, result);\n \n         try {\n-            Object dObj = new Double(3.0);\n+            final Object dObj = new Double(3.0);\n             qpcodec.encode( dObj );\n             fail( \"Trying to url encode a Double object should cause an exception.\");\n-        } catch (EncoderException ee) {\n+        } catch (final EncoderException ee) {\n             // Exception expected, test segment passes.\n         }\n     }\n \n     @Test\n     public void testDecodeObjects() throws Exception {\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n-        String plain = \"1+1 =3D 2\";\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        final String plain = \"1+1 =3D 2\";\n         String decoded = (String) qpcodec.decode((Object) plain);\n         assertEquals(\"Basic quoted-printable decoding test\",\n             \"1+1 = 2\", decoded);\n \n-        byte[] plainBA = plain.getBytes(Charsets.UTF_8);\n-        byte[] decodedBA = (byte[]) qpcodec.decode((Object) plainBA);\n+        final byte[] plainBA = plain.getBytes(Charsets.UTF_8);\n+        final byte[] decodedBA = (byte[]) qpcodec.decode((Object) plainBA);\n         decoded = new String(decodedBA);\n         assertEquals(\"Basic quoted-printable decoding test\",\n             \"1+1 = 2\", decoded);\n \n-        Object result = qpcodec.decode((Object) null);\n+        final Object result = qpcodec.decode((Object) null);\n         assertEquals( \"Decoding a null Object should return null\", null, result);\n \n         try {\n-            Object dObj = new Double(3.0);\n+            final Object dObj = new Double(3.0);\n             qpcodec.decode( dObj );\n             fail( \"Trying to url encode a Double object should cause an exception.\");\n-        } catch (DecoderException ee) {\n+        } catch (final DecoderException ee) {\n             // Exception expected, test segment passes.\n         }\n     }\n \n     @Test\n     public void testDefaultEncoding() throws Exception {\n-        String plain = \"Hello there!\";\n-        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(\"UnicodeBig\");\n+        final String plain = \"Hello there!\";\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(\"UnicodeBig\");\n         qpcodec.encode(plain); // To work around a weird quirk in Java 1.2.2\n-        String encoded1 = qpcodec.encode(plain, \"UnicodeBig\");\n-        String encoded2 = qpcodec.encode(plain);\n+        final String encoded1 = qpcodec.encode(plain, \"UnicodeBig\");\n+        final String encoded2 = qpcodec.encode(plain);\n         assertEquals(encoded1, encoded2);\n     }\n \n      * @see <a href=\"https://issues.apache.org/jira/browse/CODEC-121\">CODEC-121</a>\n      */\n     public void testSoftLineBreakDecode() throws Exception {\n-        String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics is the most beautiful branch of philosophy.\";\n-        String expected = \"If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy.\";\n+        final String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics is the most beautiful branch of philosophy.\";\n+        final String expected = \"If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy.\";\n         assertEquals(expected, new QuotedPrintableCodec().decode(qpdata));\n     }\n \n      * @see <a href=\"https://issues.apache.org/jira/browse/CODEC-121\">CODEC-121</a>\n      */\n     public void testSoftLineBreakEncode() throws Exception {\n-        String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics is the most beautiful branch of philosophy.\";\n-        String expected = \"If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy.\";\n+        final String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics is the most beautiful branch of philosophy.\";\n+        final String expected = \"If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy.\";\n         assertEquals(qpdata, new QuotedPrintableCodec().encode(expected));\n     }\n }\n--- a/src/test/java/org/apache/commons/codec/net/RFC1522CodecTest.java\n+++ b/src/test/java/org/apache/commons/codec/net/RFC1522CodecTest.java\n     static class RFC1522TestCodec extends RFC1522Codec {\n \n         @Override\n-        protected byte[] doDecoding(byte[] bytes) {\n+        protected byte[] doDecoding(final byte[] bytes) {\n             return bytes;\n         }\n \n         @Override\n-        protected byte[] doEncoding(byte[] bytes) {\n+        protected byte[] doEncoding(final byte[] bytes) {\n             return bytes;\n         }\n \n \n     @Test\n     public void testNullInput() throws Exception {\n-        RFC1522TestCodec testcodec = new RFC1522TestCodec();\n+        final RFC1522TestCodec testcodec = new RFC1522TestCodec();\n         assertNull(testcodec.decodeText(null));\n         assertNull(testcodec.encodeText(null, CharEncoding.UTF_8));\n     }\n \n-    private void assertExpectedDecoderException(String s) throws Exception {\n-        RFC1522TestCodec testcodec = new RFC1522TestCodec();\n+    private void assertExpectedDecoderException(final String s) throws Exception {\n+        final RFC1522TestCodec testcodec = new RFC1522TestCodec();\n         try {\n             testcodec.decodeText(s);\n             fail(\"DecoderException should have been thrown\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected.\n         }\n     }\n--- a/src/test/java/org/apache/commons/codec/net/URLCodecTest.java\n+++ b/src/test/java/org/apache/commons/codec/net/URLCodecTest.java\n         0x432, 0x435, 0x442\n     };\n \n-    private void validateState(URLCodec urlCodec) {\n+    private void validateState(final URLCodec urlCodec) {\n         // no tests for now.\n     }\n \n-    private String constructString(int [] unicodeChars) {\n-        StringBuilder buffer = new StringBuilder();\n+    private String constructString(final int [] unicodeChars) {\n+        final StringBuilder buffer = new StringBuilder();\n         if (unicodeChars != null) {\n-            for (int unicodeChar : unicodeChars) {\n+            for (final int unicodeChar : unicodeChars) {\n                 buffer.append((char)unicodeChar);\n             }\n         }\n     @Test\n     public void testUTF8RoundTrip() throws Exception {\n \n-        String ru_msg = constructString(RUSSIAN_STUFF_UNICODE);\n-        String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE);\n-\n-        URLCodec urlCodec = new URLCodec();\n+        final String ru_msg = constructString(RUSSIAN_STUFF_UNICODE);\n+        final String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE);\n+\n+        final URLCodec urlCodec = new URLCodec();\n         this.validateState(urlCodec);\n \n         assertEquals(\n \n     @Test\n     public void testBasicEncodeDecode() throws Exception {\n-        URLCodec urlCodec = new URLCodec();\n-        String plain = \"Hello there!\";\n-        String encoded = urlCodec.encode(plain);\n+        final URLCodec urlCodec = new URLCodec();\n+        final String plain = \"Hello there!\";\n+        final String encoded = urlCodec.encode(plain);\n         assertEquals(\"Basic URL encoding test\",\n             \"Hello+there%21\", encoded);\n         assertEquals(\"Basic URL decoding test\",\n \n     @Test\n     public void testSafeCharEncodeDecode() throws Exception {\n-        URLCodec urlCodec = new URLCodec();\n-        String plain = \"abc123_-.*\";\n-        String encoded = urlCodec.encode(plain);\n+        final URLCodec urlCodec = new URLCodec();\n+        final String plain = \"abc123_-.*\";\n+        final String encoded = urlCodec.encode(plain);\n         assertEquals(\"Safe chars URL encoding test\",\n             plain, encoded);\n         assertEquals(\"Safe chars URL decoding test\",\n \n     @Test\n     public void testUnsafeEncodeDecode() throws Exception {\n-        URLCodec urlCodec = new URLCodec();\n-        String plain = \"~!@#$%^&()+{}\\\"\\\\;:`,/[]\";\n-        String encoded = urlCodec.encode(plain);\n+        final URLCodec urlCodec = new URLCodec();\n+        final String plain = \"~!@#$%^&()+{}\\\"\\\\;:`,/[]\";\n+        final String encoded = urlCodec.encode(plain);\n         assertEquals(\"Unsafe chars URL encoding test\",\n             \"%7E%21%40%23%24%25%5E%26%28%29%2B%7B%7D%22%5C%3B%3A%60%2C%2F%5B%5D\", encoded);\n         assertEquals(\"Unsafe chars URL decoding test\",\n \n     @Test\n     public void testEncodeDecodeNull() throws Exception {\n-        URLCodec urlCodec = new URLCodec();\n+        final URLCodec urlCodec = new URLCodec();\n         assertNull(\"Null string URL encoding test\",\n             urlCodec.encode((String)null));\n         assertNull(\"Null string URL decoding test\",\n \n     @Test\n     public void testDecodeInvalid() throws Exception {\n-        URLCodec urlCodec = new URLCodec();\n+        final URLCodec urlCodec = new URLCodec();\n         try {\n             urlCodec.decode(\"%\");\n             fail(\"DecoderException should have been thrown\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected. Move on\n         }\n         try {\n             urlCodec.decode(\"%A\");\n             fail(\"DecoderException should have been thrown\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected. Move on\n         }\n         try {\n             // Bad 1st char after %\n             urlCodec.decode(\"%WW\");\n             fail(\"DecoderException should have been thrown\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected. Move on\n         }\n         try {\n             // Bad 2nd char after %\n             urlCodec.decode(\"%0W\");\n             fail(\"DecoderException should have been thrown\");\n-        } catch (DecoderException e) {\n+        } catch (final DecoderException e) {\n             // Expected. Move on\n         }\n         this.validateState(urlCodec);\n \n     @Test\n     public void testDecodeInvalidContent() throws UnsupportedEncodingException, DecoderException {\n-        String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE);\n-        URLCodec urlCodec = new URLCodec();\n-        byte[] input = ch_msg.getBytes(\"ISO-8859-1\");\n-        byte[] output = urlCodec.decode(input);\n+        final String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE);\n+        final URLCodec urlCodec = new URLCodec();\n+        final byte[] input = ch_msg.getBytes(\"ISO-8859-1\");\n+        final byte[] output = urlCodec.decode(input);\n         assertEquals(input.length, output.length);\n         for (int i = 0; i < input.length; i++) {\n             assertEquals(input[i], output[i]);\n \n     @Test\n     public void testEncodeNull() throws Exception {\n-        URLCodec urlCodec = new URLCodec();\n-        byte[] plain = null;\n-        byte[] encoded = urlCodec.encode(plain);\n+        final URLCodec urlCodec = new URLCodec();\n+        final byte[] plain = null;\n+        final byte[] encoded = urlCodec.encode(plain);\n         assertEquals(\"Encoding a null string should return null\",\n             null, encoded);\n         this.validateState(urlCodec);\n \n     @Test\n     public void testEncodeUrlWithNullBitSet() throws Exception {\n-        URLCodec urlCodec = new URLCodec();\n-        String plain = \"Hello there!\";\n-        String encoded = new String( URLCodec.encodeUrl(null, plain.getBytes(Charsets.UTF_8)));\n+        final URLCodec urlCodec = new URLCodec();\n+        final String plain = \"Hello there!\";\n+        final String encoded = new String( URLCodec.encodeUrl(null, plain.getBytes(Charsets.UTF_8)));\n         assertEquals(\"Basic URL encoding test\",\n             \"Hello+there%21\", encoded);\n         assertEquals(\"Basic URL decoding test\",\n \n     @Test\n     public void testDecodeWithNullArray() throws Exception {\n-        byte[] plain = null;\n-        byte[] result = URLCodec.decodeUrl( plain );\n+        final byte[] plain = null;\n+        final byte[] result = URLCodec.decodeUrl( plain );\n         assertEquals(\"Result should be null\", null, result);\n     }\n \n     @Test\n     public void testEncodeStringWithNull() throws Exception {\n-        URLCodec urlCodec = new URLCodec();\n-        String test = null;\n-        String result = urlCodec.encode( test, \"charset\" );\n+        final URLCodec urlCodec = new URLCodec();\n+        final String test = null;\n+        final String result = urlCodec.encode( test, \"charset\" );\n         assertEquals(\"Result should be null\", null, result);\n     }\n \n     @Test\n     public void testDecodeStringWithNull() throws Exception {\n-        URLCodec urlCodec = new URLCodec();\n-        String test = null;\n-        String result = urlCodec.decode( test, \"charset\" );\n+        final URLCodec urlCodec = new URLCodec();\n+        final String test = null;\n+        final String result = urlCodec.decode( test, \"charset\" );\n         assertEquals(\"Result should be null\", null, result);\n     }\n \n     @Test\n     public void testEncodeObjects() throws Exception {\n-        URLCodec urlCodec = new URLCodec();\n-        String plain = \"Hello there!\";\n+        final URLCodec urlCodec = new URLCodec();\n+        final String plain = \"Hello there!\";\n         String encoded = (String) urlCodec.encode((Object) plain);\n         assertEquals(\"Basic URL encoding test\",\n             \"Hello+there%21\", encoded);\n \n-        byte[] plainBA = plain.getBytes(Charsets.UTF_8);\n-        byte[] encodedBA = (byte[]) urlCodec.encode((Object) plainBA);\n+        final byte[] plainBA = plain.getBytes(Charsets.UTF_8);\n+        final byte[] encodedBA = (byte[]) urlCodec.encode((Object) plainBA);\n         encoded = new String(encodedBA);\n         assertEquals(\"Basic URL encoding test\",\n             \"Hello+there%21\", encoded);\n \n-        Object result = urlCodec.encode((Object) null);\n+        final Object result = urlCodec.encode((Object) null);\n         assertEquals( \"Encoding a null Object should return null\", null, result);\n \n         try {\n-            Object dObj = new Double(3.0);\n+            final Object dObj = new Double(3.0);\n             urlCodec.encode( dObj );\n             fail( \"Trying to url encode a Double object should cause an exception.\");\n-        } catch (EncoderException ee) {\n+        } catch (final EncoderException ee) {\n             // Exception expected, test segment passes.\n         }\n         this.validateState(urlCodec);\n \n     @Test\n     public void testInvalidEncoding() {\n-        URLCodec urlCodec = new URLCodec(\"NONSENSE\");\n-        String plain = \"Hello there!\";\n+        final URLCodec urlCodec = new URLCodec(\"NONSENSE\");\n+        final String plain = \"Hello there!\";\n         try {\n             urlCodec.encode(plain);\n             fail(\"We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked.\");\n-        } catch (EncoderException ee) {\n+        } catch (final EncoderException ee) {\n             // Exception expected, test segment passes.\n         }\n         try {\n             urlCodec.decode(plain);\n             fail(\"We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked.\");\n-        } catch (DecoderException ee) {\n+        } catch (final DecoderException ee) {\n             // Exception expected, test segment passes.\n         }\n         this.validateState(urlCodec);\n \n     @Test\n     public void testDecodeObjects() throws Exception {\n-        URLCodec urlCodec = new URLCodec();\n-        String plain = \"Hello+there%21\";\n+        final URLCodec urlCodec = new URLCodec();\n+        final String plain = \"Hello+there%21\";\n         String decoded = (String) urlCodec.decode((Object) plain);\n         assertEquals(\"Basic URL decoding test\",\n             \"Hello there!\", decoded);\n \n-        byte[] plainBA = plain.getBytes(Charsets.UTF_8);\n-        byte[] decodedBA = (byte[]) urlCodec.decode((Object) plainBA);\n+        final byte[] plainBA = plain.getBytes(Charsets.UTF_8);\n+        final byte[] decodedBA = (byte[]) urlCodec.decode((Object) plainBA);\n         decoded = new String(decodedBA);\n         assertEquals(\"Basic URL decoding test\",\n             \"Hello there!\", decoded);\n \n-        Object result = urlCodec.decode((Object) null);\n+        final Object result = urlCodec.decode((Object) null);\n         assertEquals( \"Decoding a null Object should return null\", null, result);\n \n         try {\n-            Object dObj = new Double(3.0);\n+            final Object dObj = new Double(3.0);\n             urlCodec.decode( dObj );\n             fail( \"Trying to url encode a Double object should cause an exception.\");\n-        } catch (DecoderException ee) {\n+        } catch (final DecoderException ee) {\n             // Exception expected, test segment passes.\n         }\n         this.validateState(urlCodec);\n \n     @Test\n     public void testDefaultEncoding() throws Exception {\n-        String plain = \"Hello there!\";\n-        URLCodec urlCodec = new URLCodec(\"UnicodeBig\");\n+        final String plain = \"Hello there!\";\n+        final URLCodec urlCodec = new URLCodec(\"UnicodeBig\");\n         urlCodec.encode(plain); // To work around a weird quirk in Java 1.2.2\n-        String encoded1 = urlCodec.encode(plain, \"UnicodeBig\");\n-        String encoded2 = urlCodec.encode(plain);\n+        final String encoded1 = urlCodec.encode(plain, \"UnicodeBig\");\n+        final String encoded2 = urlCodec.encode(plain);\n         assertEquals(encoded1, encoded2);\n         this.validateState(urlCodec);\n     }", "timestamp": 1357574885, "metainfo": ""}