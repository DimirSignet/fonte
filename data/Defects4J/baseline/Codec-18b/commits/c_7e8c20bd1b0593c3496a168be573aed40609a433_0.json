{"sha": "7e8c20bd1b0593c3496a168be573aed40609a433", "log": "[CODEC-121] QuotedPrintableCodec does not support soft line break per the 'quoted-printable' example on Wikipedia. Apply patch with minor modifications.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n+++ b/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n  * to ensure the integrity of the data should the message pass through a character- translating, and/or line-wrapping\n  * gateway.\n  * </p>\n- * \n- * <p>\n- * Note:\n- * </p>\n- * <p>\n- * Rules #3, #4, and #5 of the quoted-printable spec are not implemented yet because the complete quoted-printable spec\n- * does not lend itself well into the byte[] oriented codec framework. Complete the codec once the streamable codec\n- * framework is ready. The motivation behind providing the codec in a partial form is that it can already come in handy\n- * for those applications that do not require quoted-printable line formatting (rules #3, #4, #5), for instance Q codec.\n- * </p>\n- * \n+ *\n  * @see <a href=\"http://www.ietf.org/rfc/rfc1521.txt\"> RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One:\n  *          Mechanisms for Specifying and Describing the Format of Internet Message Bodies </a>\n- * \n+ *\n  * @author Apache Software Foundation\n  * @since 1.3\n  * @version $Id$\n     private static final byte TAB = 9;\n \n     private static final byte SPACE = 32;\n+\n+    private static final byte CR = 13;\n+\n+    private static final byte LF = 10;\n+\n+    /** Safe line length for quoted printable encoded text. */\n+    private static final int SAFE_LENGTH = 73;\n+\n     // Static initializer for printable chars collection\n     static {\n         // alpha characters\n      * Encodes byte into its quoted-printable representation.\n      * \n      * @param b\n-     *                  byte to encode\n+     *            byte to encode\n      * @param buffer\n-     *                  the buffer to write to\n-     */\n-    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n+     *            the buffer to write to\n+     * @return The number of bytes written to the <code>buffer</code>\n+     */\n+    private static final int encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n         buffer.write(ESCAPE_CHAR);\n         char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n         char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n         buffer.write(hex1);\n         buffer.write(hex2);\n+        return 3;\n+    }\n+\n+    /**\n+     * Return the byte at position <code>index</code> of the byte array and\n+     * make sure it is unsigned.\n+     *\n+     * @param index\n+     *                  position in the array\n+     * @param bytes\n+     *                  the byte array\n+     * @return the unsigned octet at position <code>index</code> from the array\n+     */\n+    private static int getUnsignedOctet(final int index, final byte[] bytes) {\n+        int b = bytes[index];\n+        if (b < 0) {\n+            b = 256 + b;\n+        }\n+        return b;\n+    }\n+\n+    /**\n+     * Write a byte to the buffer.\n+     *\n+     * @param b\n+     *                  byte to write\n+     * @param encode\n+     *                  indicates whether the octet shall be encoded\n+     * @param buffer\n+     *                  the buffer to write to\n+     * @return the number of bytes that have been written to the buffer\n+     */\n+    private static int encodeByte(final int b, final boolean encode,\n+                                  final ByteArrayOutputStream buffer) {\n+        if (encode) {\n+            return encodeQuotedPrintable(b, buffer);\n+        } else {\n+            buffer.write(b);\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the given byte is whitespace.\n+     *\n+     * @param b\n+     *                  byte to be checked\n+     * @return <code>true</code> if the byte is either a space or tab character\n+     */\n+    private static boolean isWhitespace(final int b) {\n+        return b == SPACE || b == TAB;\n     }\n \n     /**\n      * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n-     * \n-     * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n-     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n-     * </p>\n-     * \n+     *\n+     * <p>\n+     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5)\n+     * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\n+     * </p>\n+     *\n      * @param printable\n      *                  bitset of characters deemed quoted-printable\n      * @param bytes\n             printable = PRINTABLE_CHARS;\n         }\n         ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        for (byte c : bytes) {\n-            int b = c;\n-            if (b < 0) {\n-                b = 256 + b;\n+        int pos = 1;\n+        // encode up to buffer.length - 3, the last three octets will be treated\n+        // separately for simplification of note #3\n+        for (int i = 0; i < bytes.length - 3; i++) {\n+            int b = getUnsignedOctet(i, bytes);\n+            if (pos < SAFE_LENGTH) {\n+                // up to this length it is safe to add any byte, encoded or not\n+                pos += encodeByte(b, !printable.get(b), buffer);\n+            } else {\n+                // rule #3: whitespace at the end of a line *must* be encoded\n+                encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\n+\n+                // rule #5: soft line break\n+                buffer.write(ESCAPE_CHAR);\n+                buffer.write(CR);\n+                buffer.write(LF);\n+                pos = 1;\n             }\n-            if (printable.get(b)) {\n-                buffer.write(b);\n-            } else {\n-                encodeQuotedPrintable(b, buffer);\n-            }\n-        }\n+        }\n+\n+        // rule #3: whitespace at the end of a line *must* be encoded\n+        // if we would do a soft break line after this octet, encode whitespace\n+        int b = getUnsignedOctet(bytes.length - 3, bytes);\n+        boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);\n+        pos += encodeByte(b, encode, buffer);\n+\n+        // note #3: '=' *must not* be the ultimate or penultimate character\n+        // simplification: if < 6 bytes left, do a soft line break as we may need\n+        //                 exactly 6 bytes space for the last 2 bytes\n+        if (pos > SAFE_LENGTH - 2) {\n+            buffer.write(ESCAPE_CHAR);\n+            buffer.write(CR);\n+            buffer.write(LF);\n+        }\n+        for (int i = bytes.length - 2; i < bytes.length; i++) {\n+            b = getUnsignedOctet(i, bytes);\n+            // rule #3: trailing whitespace shall be encoded\n+            encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));\n+            encodeByte(b, encode, buffer);\n+        }\n+\n         return buffer.toByteArray();\n     }\n \n     /**\n-     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted\n-     * back to their original representation.\n-     * \n-     * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n-     * RFC 1521.\n-     * </p>\n-     * \n+     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are\n+     * converted back to their original representation.\n+     *\n+     * <p>\n+     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n+     * defined in RFC 1521.\n+     * </p>\n+     *\n      * @param bytes\n      *                  array of quoted-printable characters\n      * @return array of original bytes\n         }\n         ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n         for (int i = 0; i < bytes.length; i++) {\n-            int b = bytes[i];\n+            final int b = bytes[i];\n             if (b == ESCAPE_CHAR) {\n                 try {\n-                    int u = Utils.digit16(bytes[++i]);\n+                    // if the next octet is a CR we have found a soft line break\n+                    if (bytes[++i] == CR) {\n+                        continue;\n+                    }\n+                    int u = Utils.digit16(bytes[i]);\n                     int l = Utils.digit16(bytes[++i]);\n                     buffer.write((char) ((u << 4) + l));\n                 } catch (ArrayIndexOutOfBoundsException e) {\n                     throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n                 }\n-            } else {\n+            } else if (b != CR && b != LF) {\n+                // every other octet is appended except for CR & LF\n                 buffer.write(b);\n             }\n         }\n      * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n      * \n      * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n-     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n+     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5)\n+     * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\n      * </p>\n      * \n      * @param bytes\n      * back to their original representation.\n      * \n      * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n-     * RFC 1521.\n+     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #2)\n+     * as defined in RFC 1521.\n      * </p>\n      * \n      * @param bytes\n      * Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped.\n      * \n      * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n-     * RFC 1521 and is suitable for encoding binary data.\n+     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #2)\n+     * as defined in RFC 1521 and is suitable for encoding binary data.\n      * </p>\n      * \n      * @param pString\n      * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n      * \n      * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n-     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n+     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #2)\n+     * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\n      * </p>\n      * \n      * @param pString\n--- a/src/test/java/org/apache/commons/codec/net/QuotedPrintableCodecTest.java\n+++ b/src/test/java/org/apache/commons/codec/net/QuotedPrintableCodecTest.java\n import org.apache.commons.codec.CharEncoding;\n import org.apache.commons.codec.DecoderException;\n import org.apache.commons.codec.EncoderException;\n-import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n     }\n \n     @Test\n-    @Ignore\n-    /**\n-     * The QuotedPrintableCodec documentation states that this is not supported.\n-     *  \n-     * @throws Exception\n-     * @see <a href=\"https://issues.apache.org/jira/browse/CODEC-121\">CODEC-121</a>\n-     */\n     public void testSoftLineBreakDecode() throws Exception {\n-        String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics is the most beautiful branch of philosophy.\";\n-        String expected = \"If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy.\";\n-        assertEquals(expected, new QuotedPrintableCodec().decode(qpdata));\n-    }\n-\n-    @Test\n-    @Ignore\n-    /**\n-     * The QuotedPrintableCodec documentation states that this is not supported.\n-     *  \n-     * @throws Exception\n-     * @see <a href=\"https://issues.apache.org/jira/browse/CODEC-121\">CODEC-121</a>\n-     */\n+        String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics \" +\n+                \"is the most beautiful branch of philosophy.\";\n+        String expected = \"If you believe that truth=beauty, then surely mathematics \" +\n+                \"is the most beautiful branch of philosophy.\";\n+\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        assertEquals(expected, qpcodec.decode(qpdata));\n+\n+        String encoded = qpcodec.encode(expected);\n+        assertEquals(expected, qpcodec.decode(encoded));\n+    }\n+\n+    @Test\n     public void testSoftLineBreakEncode() throws Exception {\n-        String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics is the most beautiful branch of philosophy.\";\n-        String expected = \"If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy.\";\n-        assertEquals(qpdata, new QuotedPrintableCodec().encode(expected));\n-    }\n+        String qpdata = \"If you believe that truth=3Dbeauty, then surely mathematics is the most \" +\n+                \"b=\\r\\neautiful branch of philosophy.\";\n+        String expected = \"If you believe that truth=beauty, then surely mathematics is the most \" +\n+                \"beautiful branch of philosophy.\";\n+\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        assertEquals(qpdata, qpcodec.encode(expected));\n+\n+        String decoded = qpcodec.decode(qpdata);\n+        assertEquals(qpdata, qpcodec.encode(decoded));\n+    }\n+\n+    @Test\n+    public void testSkipNotEncodedCRLF() throws Exception {\n+        String qpdata = \"CRLF in an\\n encoded text should be=20=\\r\\n\\rskipped in the\\r decoding.\";\n+        String expected = \"CRLF in an encoded text should be skipped in the decoding.\";\n+\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        assertEquals(expected, qpcodec.decode(qpdata));\n+\n+        String encoded = qpcodec.encode(expected);\n+        assertEquals(expected, qpcodec.decode(encoded));\n+    }\n+\n+    @Test\n+    public void testTrailingSpecial() throws Exception {\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+\n+        String plain =\"This is a example of a quoted-printable text file. This might contain sp=cial chars.\";\n+        String expected = \"This is a example of a quoted-printable text file. This might contain sp=3D=\\r\\ncial chars.\";\n+        assertEquals(expected, qpcodec.encode(plain));\n+\n+        plain =\"This is a example of a quoted-printable text file. This might contain ta\\tbs as well.\";\n+        expected = \"This is a example of a quoted-printable text file. This might contain ta=09=\\r\\nbs as well.\";\n+        assertEquals(expected, qpcodec.encode(plain));\n+    }\n+\n+    @Test\n+    public void testUltimateSoftBreak() throws Exception {\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+\n+        String plain =\"This is a example of a quoted-printable text file. There is no end to it\\t\";\n+        String expected = \"This is a example of a quoted-printable text file. There is no end to i=\\r\\nt=09\";\n+\n+        assertEquals(expected, qpcodec.encode(plain));\n+\n+        plain =\"This is a example of a quoted-printable text file. There is no end to it \";\n+        expected = \"This is a example of a quoted-printable text file. There is no end to i=\\r\\nt=20\";\n+\n+        assertEquals(expected, qpcodec.encode(plain));\n+\n+        // whitespace before soft break\n+        plain =\"This is a example of a quoted-printable text file. There is no end to   \";\n+        expected = \"This is a example of a quoted-printable text file. There is no end to=20=\\r\\n =20\";\n+\n+        assertEquals(expected, qpcodec.encode(plain));\n+\n+        // non-printable character before soft break\n+        plain =\"This is a example of a quoted-printable text file. There is no end to=  \";\n+        expected = \"This is a example of a quoted-printable text file. There is no end to=3D=\\r\\n =20\";\n+\n+        assertEquals(expected, qpcodec.encode(plain));\n+    }\n+\n+    @Test\n+    public void testFinalBytes() throws Exception {\n+        // whitespace, but does not need to be encoded\n+        String plain =\"This is a example of a quoted=printable text file. There is no tt\";\n+        String expected = \"This is a example of a quoted=3Dprintable text file. There is no tt\";\n+\n+        assertEquals(expected, new QuotedPrintableCodec().encode(plain));\n+    }\n+\n }", "timestamp": 1331134441, "metainfo": ""}