{"sha": "717ff5c9380bafc945340c4ff46ef8b5129e0359", "log": "Eclipse warns that files are not closed  ", "commit": "\n--- a/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java\n         assertEquals(-1, b32stream.read());\n         assertEquals(-1, b32stream.read());\n         assertEquals(0, b32stream.available());\n+        b32stream.close();\n     }\n \n     /**\n     private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n \n         // Start with encode.\n-        InputStream in = new ByteArrayInputStream(decoded);\n-        in = new Base32InputStream(in, true, chunkSize, seperator);\n+        InputStream in;\n+        \n+        in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator);\n         byte[] output = Base32TestData.streamToBytes(in);\n \n         assertEquals(\"EOF\", -1, in.read());\n         assertTrue(\"Streaming base32 encode\", Arrays.equals(output, encoded));\n \n         // Now let's try decode.\n-        in = new ByteArrayInputStream(encoded);\n-        in = new Base32InputStream(in);\n+        in = new Base32InputStream(new ByteArrayInputStream(encoded));\n         output = Base32TestData.streamToBytes(in);\n \n         assertEquals(\"EOF\", -1, in.read());\n         assertEquals(\"EOF\", -1, in.read());\n         assertEquals(\"Still EOF\", -1, in.read());\n         assertTrue(\"Streaming base32 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+        in.close();\n     }\n \n     /**\n     private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n \n         // Start with encode.\n-        InputStream in = new ByteArrayInputStream(decoded);\n-        in = new Base32InputStream(in, true, chunkSize, seperator);\n+        InputStream in;\n+        in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator);\n         byte[] output = new byte[encoded.length];\n         for (int i = 0; i < output.length; i++) {\n             output[i] = (byte) in.read();\n         assertEquals(\"Still EOF\", -1, in.read());\n         assertTrue(\"Streaming base32 encode\", Arrays.equals(output, encoded));\n \n+        in.close();\n+\n         // Now let's try decode.\n-        in = new ByteArrayInputStream(encoded);\n-        in = new Base32InputStream(in);\n+        in = new Base32InputStream(new ByteArrayInputStream(encoded));\n         output = new byte[decoded.length];\n         for (int i = 0; i < output.length; i++) {\n             output[i] = (byte) in.read();\n         assertEquals(\"Still EOF\", -1, in.read());\n         assertTrue(\"Streaming base32 decode\", Arrays.equals(output, decoded));\n \n+        in.close();\n+ \n         // I always wanted to do this! (wrap encoder with decoder etc etc).\n         in = new ByteArrayInputStream(decoded);\n         for (int i = 0; i < 10; i++) {\n         Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         // Always returns false for now.\n         assertFalse(\"Base32InputStream.markSupported() is false\", in.markSupported());\n+        in.close();\n     }\n \n     /**\n         Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         bytesRead = in.read(buf, 0, 0);\n         assertEquals(\"Base32InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n+        in.close();\n     }\n \n     /**\n         } catch (NullPointerException e) {\n             // Expected\n         }\n+        in.close();\n     }\n \n     /**\n         } catch (IndexOutOfBoundsException e) {\n             // Expected\n         }\n+        in.close();\n     }\n \n     /**\n         assertArrayEquals(actualBytes, new byte[] { 102, 111, 111, 0, 0, 0 });\n         // End of stream reached\n         assertEquals(-1, b32stream.read());\n+        b32stream.close();\n     }\n \n     /**\n         // End of stream reached\n         assertEquals(-1, b32stream.read());\n         assertEquals(-1, b32stream.read());\n+        b32stream.close();\n     }\n \n     /**\n         // End of stream reached\n         assertEquals(-1, b32stream.read());\n         assertEquals(-1, b32stream.read());\n-    }\n+        b32stream.close();\n+}\n \n     /**\n      * Tests skipping to the end of a stream.\n         // End of stream reached\n         assertEquals(-1, b32stream.read());\n         assertEquals(-1, b32stream.read());\n+        b32stream.close();\n     }\n \n     /**\n         InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n         Base32InputStream b32stream = new Base32InputStream(ins);\n         b32stream.skip(-10);\n+        b32stream.close();\n     }\n }\n--- a/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n \n         c = in.read(result);\n         assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n+        in.close();\n     }\n \n     /**\n         BufferedReader br = new BufferedReader(isr);\n         String line = br.readLine();\n         assertNotNull(\"Codec101:  InputStreamReader works!\", line);\n+        br.close();\n     }\n \n     /**\n         assertEquals(-1, b64stream.read());\n         assertEquals(-1, b64stream.read());\n         assertEquals(0, b64stream.available());\n+        b64stream.close();\n     }\n \n     /**\n     private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n \n         // Start with encode.\n-        InputStream in = new ByteArrayInputStream(decoded);\n-        in = new Base64InputStream(in, true, chunkSize, seperator);\n+        InputStream in;\n+        in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator);\n         byte[] output = Base64TestData.streamToBytes(in);\n \n         assertEquals(\"EOF\", -1, in.read());\n         assertEquals(\"Still EOF\", -1, in.read());\n         assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n \n+        in.close();\n+        \n         // Now let's try decode.\n-        in = new ByteArrayInputStream(encoded);\n-        in = new Base64InputStream(in);\n+        in = new Base64InputStream(new ByteArrayInputStream(encoded));\n         output = Base64TestData.streamToBytes(in);\n \n         assertEquals(\"EOF\", -1, in.read());\n         assertEquals(\"EOF\", -1, in.read());\n         assertEquals(\"Still EOF\", -1, in.read());\n         assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+        in.close();\n     }\n \n     /**\n     private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n \n         // Start with encode.\n-        InputStream in = new ByteArrayInputStream(decoded);\n-        in = new Base64InputStream(in, true, chunkSize, seperator);\n+        InputStream in;\n+        in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator);\n         byte[] output = new byte[encoded.length];\n         for (int i = 0; i < output.length; i++) {\n             output[i] = (byte) in.read();\n         assertEquals(\"Still EOF\", -1, in.read());\n         assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n \n+        in.close();\n         // Now let's try decode.\n-        in = new ByteArrayInputStream(encoded);\n-        in = new Base64InputStream(in);\n+        in = new Base64InputStream(new ByteArrayInputStream(encoded));\n         output = new byte[decoded.length];\n         for (int i = 0; i < output.length; i++) {\n             output[i] = (byte) in.read();\n         assertEquals(\"Still EOF\", -1, in.read());\n         assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n \n+        in.close();\n+        \n         // I always wanted to do this! (wrap encoder with decoder etc etc).\n         in = new ByteArrayInputStream(decoded);\n         for (int i = 0; i < 10; i++) {\n         assertEquals(\"EOF\", -1, in.read());\n         assertEquals(\"Still EOF\", -1, in.read());\n         assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+        in.close();\n     }\n \n     /**\n         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         // Always returns false for now.\n         assertFalse(\"Base64InputStream.markSupported() is false\", in.markSupported());\n+        in.close();\n     }\n \n     /**\n         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         bytesRead = in.read(buf, 0, 0);\n         assertEquals(\"Base64InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n+        in.close();\n     }\n \n     /**\n         } catch (NullPointerException e) {\n             // Expected\n         }\n+        in.close();\n     }\n \n     /**\n         } catch (IndexOutOfBoundsException e) {\n             // Expected\n         }\n+        in.close();\n     }\n \n     /**\n         // End of stream reached\n         assertEquals(-1, b64stream.read());\n         assertEquals(-1, b64stream.read());\n+        b64stream.close();\n     }\n \n     /**\n         assertArrayEquals(actualBytes, new byte[] { 0, 0, 0, (byte) 255, (byte) 255, (byte) 255 });\n         // End of stream reached\n         assertEquals(-1, b64stream.read());\n+        b64stream.close();\n     }\n \n     /**\n         // End of stream reached\n         assertEquals(-1, b64stream.read());\n         assertEquals(-1, b64stream.read());\n+        b64stream.close();\n     }\n \n     /**\n         // End of stream reached\n         assertEquals(-1, b64stream.read());\n         assertEquals(-1, b64stream.read());\n+        b64stream.close();\n     }\n \n     /**\n         InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));\n         Base64InputStream b64stream = new Base64InputStream(ins);\n         b64stream.skip(-10);\n+        b64stream.close();\n     }\n }", "timestamp": 1346347297, "metainfo": ""}