{"sha": "9b140df6364d65493360b305db916ca54d0a3813", "log": "Checkstyle: Line is longer than 120 characters.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n /**\n  * Encodes strings into their Beider-Morse phonetic encoding.\n  * <p>\n- * Beider-Morse phonetic encodings are optimised for family names. However, they may be useful for a wide range\n- * of words.\n+ * Beider-Morse phonetic encodings are optimised for family names. However, they may be useful for a wide range of\n+ * words.\n  * <p>\n- * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it\n- * is mutable, and may not be thread-safe. If you require a guaranteed thread-safe encoding then use\n- * {@link PhoneticEngine} directly.\n+ * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it is mutable,\n+ * and may not be thread-safe. If you require a guaranteed thread-safe encoding then use {@link PhoneticEngine}\n+ * directly.\n  * <p>\n  * <b>Encoding overview</b>\n  * <p>\n  * Beider-Morse phonetic encodings is a multi-step process. Firstly, a table of rules is consulted to guess what\n  * language the word comes from. For example, if it ends in \"<code>ault</code>\" then it infers that the word is French.\n- * Next, the word is translated into a phonetic representation using a language-specific phonetics table. Some\n- * runs of letters can be pronounced in multiple ways, and a single run of letters may be potentially broken up\n- * into phonemes at different places, so this stage results in a set of possible language-specific phonetic\n- * representations. Lastly, this language-specific phonetic representation is processed by a table of rules that\n- * re-writes it phonetically taking into account systematic pronunciation differences between languages, to move\n- * it towards a pan-indo-european phonetic representation. Again, sometimes there are multiple ways this could be\n- * done and sometimes things that can be pronounced in several ways in the source language have only one way to\n- * represent them in this average phonetic language, so the result is again a set of phonetic spellings.\n+ * Next, the word is translated into a phonetic representation using a language-specific phonetics table. Some runs of\n+ * letters can be pronounced in multiple ways, and a single run of letters may be potentially broken up into phonemes at\n+ * different places, so this stage results in a set of possible language-specific phonetic representations. Lastly, this\n+ * language-specific phonetic representation is processed by a table of rules that re-writes it phonetically taking into\n+ * account systematic pronunciation differences between languages, to move it towards a pan-indo-european phonetic\n+ * representation. Again, sometimes there are multiple ways this could be done and sometimes things that can be\n+ * pronounced in several ways in the source language have only one way to represent them in this average phonetic\n+ * language, so the result is again a set of phonetic spellings.\n  * <p>\n- * Some names are treated as having multiple parts. This can be due to two things. Firstly, they may be hyphenated.\n- * In this case, each individual hyphenated word is encoded, and then these are combined end-to-end for the final\n- * encoding. Secondly, some names have standard prefixes, for example, \"<code>Mac/Mc</code>\" in Scottish (English)\n- * names. As sometimes it is ambiguous whether the prefix is intended or is an accident of the spelling, the word\n- * is encoded once with the prefix and once without it. The resulting encoding contains one and then the other result.\n+ * Some names are treated as having multiple parts. This can be due to two things. Firstly, they may be hyphenated. In\n+ * this case, each individual hyphenated word is encoded, and then these are combined end-to-end for the final encoding.\n+ * Secondly, some names have standard prefixes, for example, \"<code>Mac/Mc</code>\" in Scottish (English) names. As\n+ * sometimes it is ambiguous whether the prefix is intended or is an accident of the spelling, the word is encoded once\n+ * with the prefix and once without it. The resulting encoding contains one and then the other result.\n  * <p>\n  * <b>Encoding format</b>\n  * <p>\n- * Individual phonetic spellings of an input word are represented in upper- and lower-case roman characters. Where\n- * there are multiple possible phonetic representations, these are joined with a pipe (<code>|</code>) character.\n- * If multiple hyphenated words where found, or if the word may contain a name prefix, each encoded word is placed\n- * in elipses and these blocks are then joined with hyphens. For example, \"<code>d'ortley</code>\" has a possible\n- * prefix. The form without prefix encodes to \"<code>ortlaj|ortlej</code>\", while the form with prefix encodes to\n- * \"<code>dortlaj|dortlej</code>\". Thus, the full, combined encoding is \"<code>(ortlaj|ortlej)-(dortlaj|dortlej)</code>\".\n+ * Individual phonetic spellings of an input word are represented in upper- and lower-case roman characters. Where there\n+ * are multiple possible phonetic representations, these are joined with a pipe (<code>|</code>) character. If multiple\n+ * hyphenated words where found, or if the word may contain a name prefix, each encoded word is placed in elipses and\n+ * these blocks are then joined with hyphens. For example, \"<code>d'ortley</code>\" has a possible prefix. The form\n+ * without prefix encodes to \"<code>ortlaj|ortlej</code>\", while the form with prefix encodes to \"\n+ * <code>dortlaj|dortlej</code>\". Thus, the full, combined encoding is \"<code>(ortlaj|ortlej)-(dortlaj|dortlej)</code>\".\n  * <p>\n  * The encoded forms are often quite a bit longer than the input strings. This is because a single input may have many\n- * potential phonetic interpretations. For example, \"<code>Renault</code>\" encodes to\n- * \"<code>rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult</code>\". The <code>APPROX</code> rules will tend to produce larger\n+ * potential phonetic interpretations. For example, \"<code>Renault</code>\" encodes to \"\n+ * <code>rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult</code>\". The <code>APPROX</code> rules will tend to produce larger\n  * encodings as they consider a wider range of possible, approximate phonetic interpretations of the original word.\n  * Down-stream applications may wish to further process the encoding for indexing or lookup purposes, for example, by\n  * splitting on pipe (<code>|</code>) and indexing under each of these alternatives.", "timestamp": 1414372311, "metainfo": ""}