{"sha": "d74fc31604c805a47c44d7853f63a3b06ad6c016", "log": "Fix for CODEC-101:  java.io.InputStreamReader hates it when InputStream.read(byte[]) returns a zero.  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n         } else if (len == 0) {\n             return 0;\n         } else {\n-            if (!base64.hasData()) {\n-                byte[] buf = new byte[doEncode ? 4096 : 8192];\n-                int c = in.read(buf);\n-                // A little optimization to avoid System.arraycopy()\n-                // when possible.\n-                if (c > 0 && b.length == len) {\n-                    base64.setInitialBuffer(b, offset, len);\n+            int readLen = 0;\n+            /*\n+             Rationale for while-loop on (readLen == 0):\n+             -----\n+             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n+             rare case where it returns 0, we just keep trying.\n+\n+             This is essentially an undocumented contract for InputStream\n+             implementors that want their code to work properly with\n+             java.io.InputStreamReader, since the latter hates it when\n+             InputStream.read(byte[]) returns a zero.  Unfortunately our\n+             readResults() call must return 0 if a large amount of the data\n+             being decoded was non-base64, so this while-loop enables proper\n+             interop with InputStreamReader for that scenario.\n+             -----\n+             This is a fix for CODEC-101\n+            */\n+            while (readLen == 0) {\n+                if (!base64.hasData()) {\n+                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n+                    int c = in.read(buf);\n+                    // A little optimization to avoid System.arraycopy()\n+                    // when possible.\n+                    if (c > 0 && b.length == len) {\n+                        base64.setInitialBuffer(b, offset, len);\n+                    }\n+                    if (doEncode) {\n+                        base64.encode(buf, 0, c);\n+                    } else {\n+                        base64.decode(buf, 0, c);\n+                    }\n                 }\n-                if (doEncode) {\n-                    base64.encode(buf, 0, c);\n-                } else {\n-                    base64.decode(buf, 0, c);\n-                }\n+                readLen = base64.readResults(b, offset, len);\n             }\n-            return base64.readResults(b, offset, len);\n+            return readLen;\n         }\n     }\n \n--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n     }\n \n     /**\n+     * Test for the CODEC-101 bug:  InputStream.read(byte[]) should never return 0\n+     * because Java's builtin InputStreamReader hates that.\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+    public void testCodec101() throws Exception {\n+        byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n+        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n+        Base64InputStream in = new Base64InputStream(bais);\n+        byte[] result = new byte[8192];\n+        int c = in.read(result);\n+        assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n+\n+        c = in.read(result);\n+        assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n+    }\n+\n+    /**\n      * Test the Base64InputStream implementation against the special NPE inducing input\n      * identified in the CODEC-98 bug.\n      *\n--- a/src/test/org/apache/commons/codec/binary/Base64TestData.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64TestData.java\n  * @since 1.4\n  */\n public class Base64TestData {\n+\n+    public static final String CODEC_101_MULTIPLE_OF_3 = \"123\";\n \n     public static final String CODEC_98_NPE\n         = \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM\";", "timestamp": 1295637591, "metainfo": ""}