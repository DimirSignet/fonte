{"sha": "56219f1c3da9fb118c5e7a02525da397ee4f0f88", "log": "Move Nysiis into the main code base.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/Nysiis.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * THIS CLASS LIVES IN THE TEST DIRECTORY UNTIL IT IS FULLY BAKED. \n+ * \n+ * Encodes a string into a NYSIIS value. NYSIIS is an encoding used to relate similar names, but can also be used as a\n+ * general purpose scheme to find word with similar phonemes.\n+ * \n+ * <p>\n+ * NYSIIS features an accuracy increase of 2.7% over the traditional Soundex algorithm.\n+ * </p>\n+ * \n+ * @see <a href=\"http://en.wikipedia.org/wiki/NYSIIS\">http://en.wikipedia.org/wiki/NYSIIS</a>\n+ * @see <a href=\"http://www.dropby.com/NYSIIS.html\">http://www.dropby.com/NYSIIS.html</a>\n+ * @see Soundex\n+ * @version $Id: Nysiis.java 669755 2008-06-20 01:21:52Z sebb $\n+ */\n+public class Nysiis implements StringEncoder {\n+\n+    private static final char[] CHARS_A = new char[] { 'A' };\n+    private static final char[] CHARS_AF = new char[] { 'A', 'F' };\n+    private static final char[] CHARS_C = new char[] { 'C' };\n+    private static final char[] CHARS_FF = new char[] { 'F', 'F' };\n+    private static final char[] CHARS_G = new char[] { 'G' };\n+    private static final char[] CHARS_N = new char[] { 'N' };\n+    private static final char[] CHARS_NN = new char[] { 'N', 'N' };\n+    private static final char[] CHARS_S = new char[] { 'S' };\n+    private static final char[] CHARS_SSS = new char[] { 'S', 'S', 'S' };\n+    private static final char SPACE = ' ';\n+    private static final int TRUE_LENGTH = 6;\n+\n+    /**\n+     * Tests if the given character is a vowel.\n+     * \n+     * @param c\n+     *            the character to test\n+     * @return <code>true</code> if the character is a vowel, <code>false</code> otherwise\n+     */\n+    private static boolean isVowel(final char c) {\n+        return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n+    }\n+\n+    /**\n+     * Transcodes the remaining parts of the String. The method operates on a sliding window, looking at 4 characters at\n+     * a time: [i-1, i, i+1, i+2].\n+     * \n+     * @param prev\n+     *            the previous character\n+     * @param curr\n+     *            the current character\n+     * @param next\n+     *            the next character\n+     * @param aNext\n+     *            the after next character\n+     * @return a transcoded array of characters, starting from the current position\n+     */\n+    private static char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext) {\n+        // 1. EV -> AF\n+        if (curr == 'E' && next == 'V') {\n+            return CHARS_AF;\n+        }\n+\n+        // A, E, I, O, U -> A\n+        if (isVowel(curr)) {\n+            return CHARS_A;\n+        }\n+\n+        // 2. Q -> G, Z -> S, M -> N\n+        if (curr == 'Q') {\n+            return CHARS_G;\n+        } else if (curr == 'Z') {\n+            return CHARS_S;\n+        } else if (curr == 'M') {\n+            return CHARS_N;\n+        }\n+\n+        // 3. KN -> NN else K -> C\n+        if (curr == 'K') {\n+            if (next == 'N') {\n+                return CHARS_NN;\n+            } else {\n+                return CHARS_C;\n+            }\n+        }\n+\n+        // 4. SCH -> SSS\n+        if (curr == 'S' && next == 'C' && aNext == 'H') {\n+            return CHARS_SSS;\n+        }\n+\n+        // PH -> FF\n+        if (curr == 'P' && next == 'H') {\n+            return CHARS_FF;\n+        }\n+\n+        // 5. H -> If previous or next is a non vowel, previous.\n+        if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) {\n+            return new char[] { prev };\n+        }\n+\n+        // 6. W -> If previous is vowel, previous.\n+        if (curr == 'W' && isVowel(prev)) {\n+            return new char[] { prev };\n+        }\n+\n+        return new char[] { curr };\n+    }\n+\n+    private final boolean trueLength;\n+\n+    public Nysiis() {\n+        this(true);\n+    }\n+\n+    public Nysiis(boolean trueLength) {\n+        this.trueLength = trueLength;\n+    }\n+\n+    /**\n+     * Encodes an Object using the NYSIIS algorithm. This method is provided in order to satisfy the requirements of the\n+     * Encoder interface, and will throw an {@link EncoderException} if the supplied object is not of type\n+     * {@link String}.\n+     * \n+     * @param pObject\n+     *            Object to encode\n+     * @return An object (or a {@link String}) containing the NYSIIS code which corresponds to the given String.\n+     * @throws EncoderException\n+     *             if the parameter supplied is not of a {@link String}\n+     * @throws IllegalArgumentException\n+     *             if a character is not mapped\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (!(pObject instanceof String)) {\n+            throw new EncoderException(\"Parameter supplied to Nysiis encode is not of type java.lang.String\");\n+        }\n+        return this.nysiis((String) pObject);\n+    }\n+\n+    /**\n+     * Encodes a String using the NYSIIS algorithm.\n+     * \n+     * @param pString\n+     *            A String object to encode\n+     * @return A Nysiis code corresponding to the String supplied\n+     * @throws IllegalArgumentException\n+     *             if a character is not mapped\n+     */\n+    public String encode(String pString) {\n+        return this.nysiis(pString);\n+    }\n+\n+    public boolean isTrueLength() {\n+        return this.trueLength;\n+    }\n+\n+    /**\n+     * Retrieves the NYSIIS code for a given String object.\n+     * \n+     * @param str\n+     *            String to encode using the NYSIIS algorithm\n+     * @return A NYSIIS code for the String supplied\n+     */\n+    public String nysiis(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        // Use the same clean rules as Soundex\n+        str = SoundexUtils.clean(str);\n+\n+        if (str.length() == 0) {\n+            return str;\n+        }\n+\n+        // Translate first characters of name:\n+        // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\n+        str = str.replaceFirst(\"^MAC\", \"MCC\");\n+        str = str.replaceFirst(\"^KN\", \"NN\");\n+        str = str.replaceFirst(\"^K\", \"C\");\n+        str = str.replaceFirst(\"^(PH|PF)\", \"FF\");\n+        str = str.replaceFirst(\"^SCH\", \"SSS\");\n+\n+        // Translate last characters of name:\n+        // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\n+        str = str.replaceFirst(\"(EE|IE)$\", \"Y\");\n+        str = str.replaceFirst(\"(DT|RT|RD|NT|ND)$\", \"D\");\n+\n+        // First character of key = first character of name.\n+        StringBuffer key = new StringBuffer(str.length());\n+        key.append(str.charAt(0));\n+\n+        // Transcode remaining characters, incrementing by one character each time\n+        final char[] chars = str.toCharArray();\n+        final int len = chars.length;\n+\n+        for (int i = 1; i < len; i++) {\n+            final char next = i < len - 1 ? chars[i + 1] : SPACE;\n+            final char aNext = i < len - 2 ? chars[i + 2] : SPACE;\n+            final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);\n+            System.arraycopy(transcoded, 0, chars, i, transcoded.length);\n+\n+            // only append the current char to the key if it is different from the last one\n+            if (chars[i] != chars[i - 1]) {\n+                key.append(chars[i]);\n+            }\n+        }\n+\n+        if (key.length() > 1) {\n+            char lastChar = key.charAt(key.length() - 1);\n+\n+            // If last character is S, remove it.\n+            if (lastChar == 'S') {\n+                key.deleteCharAt(key.length() - 1);\n+                lastChar = key.charAt(key.length() - 1);\n+            }\n+\n+            if (key.length() > 2) {\n+                final char last2Char = key.charAt(key.length() - 2);\n+                // If last characters are AY, replace with Y.\n+                if (last2Char == 'A' && lastChar == 'Y') {\n+                    key.deleteCharAt(key.length() - 2);\n+                }\n+            }\n+\n+            // If last character is A, remove it.\n+            if (lastChar == 'A') {\n+                key.deleteCharAt(key.length() - 1);\n+            }\n+        }\n+\n+        final String string = key.toString();\n+        return this.isTrueLength() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;\n+    }\n+\n+}", "timestamp": 1331244338, "metainfo": ""}