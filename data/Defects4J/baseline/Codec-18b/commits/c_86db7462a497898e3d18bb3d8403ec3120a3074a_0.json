{"sha": "86db7462a497898e3d18bb3d8403ec3120a3074a", "log": "Added Base32Hex implementation, and enabled the basic tests Many more tests needed  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/java/org/apache/commons/codec/binary/Base32.java\n      * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Alphabet\"\n      * equivalents as specified in Table 3 of RFC 2045.\n      */\n-    private static final byte[] STANDARD_ENCODE_TABLE = {\n+    private static final byte[] BASE32_ENCODE_TABLE = {\n             'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n             'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n             '2', '3', '4', '5', '6', '7',\n     };\n \n     /**\n+     * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Hex Alphabet\"\n+     * equivalents as specified in Table 3 of RFC 2045.\n+     */\n+    private static final byte[] BASE32HEX_ENCODE_TABLE = {\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', \n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n+    };\n+\n+    /**\n      * Byte used to pad output.\n      */\n     private static final byte PAD = '=';\n      * alphabet but fall within the bounds of the array are translated to -1.\n      * \n      */\n-    private static final byte[] DECODE_TABLE = {\n+    private static final byte[] BASE32_DECODE_TABLE = {\n          //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,                     // 50-5a O-Z\n     };\n \n+    /**\n+     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 |Hex Alphabet\" (as specified in\n+     * Table 3 of RFC 2045) into their 5-bit positive integer equivalents. Characters that are not in the Base32 Hex\n+     * alphabet but fall within the bounds of the array are translated to -1.\n+     * \n+     */\n+    private static final byte[] BASE32HEX_DECODE_TABLE = {\n+         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 63, // 20-2f\n+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n+            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-N\n+            25, 26, 27, 28, 29, 30, 31, 32,                                 // 50-57 O-V\n+    };\n+\n     /** Mask used to extract 5 bits, used when encoding Base32 bytes */\n     private static final int MASK_5BITS = 0x1f;\n \n      * Encode table to use.\n      */\n     private final byte[] encodeTable;\n+    \n+    private final byte[] decodeTable; // need different decode table to support Hex version\n \n     /**\n      * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the Base32\n      * \n      */\n     public Base32() {\n-        this(0);\n+        this(false);\n+    }\n+\n+    /**\n+     * Creates a Base32 codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length is 0 (no chunking).\n+     * </p>\n+     * @param useHex if <code>true</code> then use Base32 Hex alphabet\n+     */\n+    public Base32(boolean useHex) {\n+        this(0, null, useHex);\n     }\n \n     /**\n      *             The provided lineSeparator included some Base32 characters. That's not going to work!\n      */\n     public Base32(int lineLength, byte[] lineSeparator) {\n+        this(lineLength, lineSeparator, false);\n+    }\n+    \n+    /**\n+     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length and line separator are given in the constructor.\n+     * </p>\n+     * <p>\n+     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 8).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     * @param lineSeparator\n+     *            Each line of encoded data will end with this sequence of bytes.\n+     * @param useHex if <code>true</code>, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n+     * @throws IllegalArgumentException\n+     *             The provided lineSeparator included some Base32 characters. That's not going to work!\n+     */\n+    public Base32(int lineLength, byte[] lineSeparator, boolean useHex) {\n         if (lineSeparator == null) {\n             lineLength = 0;  // disable chunk-separating\n             lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n             String sep = StringUtils.newStringUtf8(lineSeparator);\n             throw new IllegalArgumentException(\"lineSeperator must not contain Base32 characters: [\" + sep + \"]\");\n         }\n-        this.encodeTable = STANDARD_ENCODE_TABLE; // TODO - encodeTable could perhaps be removed, but might be useful if merging with Base64\n+        if (useHex){\n+            this.encodeTable = BASE32HEX_ENCODE_TABLE;\n+            this.decodeTable = BASE32HEX_DECODE_TABLE;            \n+        } else {\n+            this.encodeTable = BASE32_ENCODE_TABLE;\n+            this.decodeTable = BASE32_DECODE_TABLE;            \n+        }\n     }\n \n     /**\n                 eof = true;\n                 break;\n             } else {\n-                if (b >= 0 && b < DECODE_TABLE.length) {\n-                    int result = DECODE_TABLE[b];\n+                if (b >= 0 && b < this.decodeTable.length) {\n+                    int result = this.decodeTable[b];\n                     if (result >= 0) {\n                         modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK;\n                         x = (x << BITS_PER_ENCODED_CHAR) + result; // collect decoded bytes\n      * @return <code>true</code> if the value is defined in the the Base32 alphabet (or pad), <code>false</code> otherwise.\n      */\n     public static boolean isBase32(byte octet) {\n-        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n+        return octet == PAD || (octet >= 0 && octet < BASE32_DECODE_TABLE.length && BASE32_DECODE_TABLE[octet] != -1);\n+    }\n+\n+    /**\n+     * Returns whether or not the <code>octet</code> is in the Base32 Hex alphabet.\n+     * \n+     * @param octet\n+     *            The value to test\n+     * @return <code>true</code> if the value is defined in the the Base32 Hex alphabet (or pad), <code>false</code> otherwise.\n+     */\n+    public static boolean isBase32Hex(byte octet) {\n+        return octet == PAD || (octet >= 0 && octet < BASE32HEX_DECODE_TABLE.length && BASE32HEX_DECODE_TABLE[octet] != -1);\n     }\n \n     /**\n     }\n     \n     /**\n+     * Encodes binary data using the Base32 algorithm but does not chunk the output.\n+     *\n+     * @param binaryData\n+     *            binary data to encode\n+     * @return String containing Base32Hex characters.\n+     */    \n+    public static String encodeBase32HexString(byte[] binaryData) {\n+        return StringUtils.newStringUtf8(encodeBase32Hex(binaryData, false));\n+    }\n+    \n+    /**\n      * Encodes binary data using the Base32 algorithm and chunks the encoded output into 76 character blocks\n      * \n      * @param binaryData\n      * @param pArray\n      *            A String containing Base32 character data\n      * @return a byte array containing binary data\n-     * @since 1.4\n      */\n     public byte[] decode(String pArray) {\n         return decode(StringUtils.getBytesUtf8(pArray));\n      */\n     public static byte[] encodeBase32(byte[] binaryData, boolean isChunked) {\n         return encodeBase32(binaryData, isChunked, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Encodes binary data using the Base32 Hex algorithm, optionally chunking the output into 76 character blocks.\n+     * \n+     * @param binaryData\n+     *            Array containing binary data to encode.\n+     * @param isChunked\n+     *            if <code>true</code> this encoder will chunk the Base32 output into 76 character blocks\n+     * @return Base32Hex-encoded data.\n+     * @throws IllegalArgumentException\n+     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n+     */\n+    public static byte[] encodeBase32Hex(byte[] binaryData, boolean isChunked) {\n+        return encodeBase32Hex(binaryData, isChunked, Integer.MAX_VALUE);\n     }\n \n     /**\n      * @return Base32-encoded data.\n      * @throws IllegalArgumentException\n      *             Thrown when the input array needs an output array bigger than maxResultSize\n-     * @since 1.4\n      */\n     public static byte[] encodeBase32(byte[] binaryData, boolean isChunked, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n                 maxResultSize);\n         }\n                 \n-        Base32 b64 = isChunked ? new Base32(MIME_CHUNK_SIZE, CHUNK_SEPARATOR) : new Base32(0, CHUNK_SEPARATOR);\n+        Base32 b64 = isChunked ? new Base32(MIME_CHUNK_SIZE, CHUNK_SEPARATOR) : new Base32();\n+        return b64.encode(binaryData);\n+    }\n+\n+    /**\n+     * Encodes binary data using the Base32Hex algorithm, optionally chunking the output into 76 character blocks.\n+     * \n+     * @param binaryData\n+     *            Array containing binary data to encode.\n+     * @param isChunked\n+     *            if <code>true</code> this encoder will chunk the Base32 output into 76 character blocks\n+     * @param maxResultSize\n+     *            The maximum result size to accept.\n+     * @return Base32Hex-encoded data.\n+     * @throws IllegalArgumentException\n+     *             Thrown when the input array needs an output array bigger than maxResultSize\n+     */\n+    public static byte[] encodeBase32Hex(byte[] binaryData, boolean isChunked, int maxResultSize) {\n+        if (binaryData == null || binaryData.length == 0) {\n+            return binaryData;\n+        }\n+\n+        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+        if (len > maxResultSize) {\n+            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n+                len +\n+                \") than the specified maxium size of \" +\n+                maxResultSize);\n+        }\n+                \n+        Base32 b64 = isChunked ? new Base32(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, true) : new Base32(true);\n         return b64.encode(binaryData);\n     }\n \n      */\n     public static byte[] decodeBase32(byte[] base32Data) {\n         return new Base32().decode(base32Data);\n+    }\n+\n+    /**\n+     * Decodes a Base32 Hex String into octets\n+     *\n+     * @param base32HexString\n+     *            String containing Base32Hex data\n+     * @return Array containing decoded data.\n+     */\n+    public static byte[] decodeBase32Hex(String base32HexString) {\n+        return new Base32(true).decode(base32HexString);\n+    }\n+\n+    /**\n+     * Decodes Base32 Hex data into octets\n+     * \n+     * @param base32HexData\n+     *            Byte array containing Base32Hex data\n+     * @return Array containing decoded data.\n+     */\n+    public static byte[] decodeBase32Hex(byte[] base32HexData) {\n+        return new Base32(true).decode(base32HexData);\n     }\n \n     /**\n--- a/src/test/org/apache/commons/codec/binary/Base32Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base32Test.java\n \n     public void testBase32HexSamples() throws Exception {\n         for (int i = 0; i < BASE32HEX_TEST_CASES.length; i++) {\n-//                assertEquals(BASE32HEX_TEST_CASES[i][1], Base32.encodeBase32HexString(BASE32HEX_TEST_CASES[i][0].getBytes(\"UTF-8\")));\n+                assertEquals(BASE32HEX_TEST_CASES[i][1], Base32.encodeBase32HexString(BASE32HEX_TEST_CASES[i][0].getBytes(\"UTF-8\")));\n         }\n     }\n ", "timestamp": 1296038588, "metainfo": ""}