{"sha": "c6fadeeac0487a158234cf5d59a144f67bd68e93", "log": "New classes for Base32 rework  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/binary/Base32InputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.InputStream;\n+\n+/**\n+ * Provides Base32 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * constructor.\n+ * <p>\n+ * The default behaviour of the Base32InputStream is to DECODE, whereas the default behaviour of the Base32OutputStream\n+ * is to ENCODE, but this behaviour can be overridden by using a different constructor.\n+ * </p>\n+ * <p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * </p>\n+ * \n+ * @version $Revision$\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n+ * @since 1.5\n+ */\n+public class Base32InputStream extends BasedCodecInputStream {\n+\n+    /**\n+     * Creates a Base32InputStream such that all data read is Base32-decoded from the original provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     */\n+    public Base32InputStream(InputStream in) {\n+        this(in, false);\n+    }\n+\n+    /**\n+     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n+     * provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data read from us, false if we should decode.\n+     */\n+    public Base32InputStream(InputStream in, boolean doEncode) {\n+        super(in, new Base32(false), doEncode);\n+    }\n+\n+    /**\n+     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n+     * provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data read from us, false if we should decode.\n+     * @param lineLength\n+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            false, lineLength is ignored.\n+     * @param lineSeparator\n+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n+     */\n+    public Base32InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+        super(in, new Base32(lineLength, lineSeparator), doEncode);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/binary/Base32OutputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.OutputStream;\n+\n+/**\n+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * constructor.\n+ * <p>\n+ * The default behaviour of the Base64OutputStream is to ENCODE, whereas the default behaviour of the Base64InputStream\n+ * is to DECODE. But this behaviour can be overridden by using a different constructor.\n+ * </p>\n+ * <p>\n+ * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n+ * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n+ * </p>\n+ * <p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @since 1.4\n+ */\n+public class Base32OutputStream extends BasedCodecOutputStream {\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     */\n+    public Base32OutputStream(OutputStream out) {\n+        this(out, true);\n+    }\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n+     * original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data written to us, false if we should decode.\n+     */\n+    public Base32OutputStream(OutputStream out, boolean doEncode) {\n+        super(out, new Base32(false), doEncode);\n+    }\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n+     * original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data written to us, false if we should decode.\n+     * @param lineLength\n+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            false, lineLength is ignored.\n+     * @param lineSeparator\n+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n+     */\n+    public Base32OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+        super(out, new Base32(lineLength, lineSeparator), doEncode);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/binary/BasedCodec.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import org.apache.commons.codec.BinaryDecoder;\n+import org.apache.commons.codec.BinaryEncoder;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+\n+public abstract class BasedCodec implements BinaryEncoder, BinaryDecoder {\n+\n+    /**\n+     *  MIME chunk size per RFC 2045 section 6.8.\n+     * \n+     * <p>\n+     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n+     * equal signs.\n+     * </p>\n+     * \n+     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n+     */\n+    public static final int MIME_CHUNK_SIZE = 76;\n+\n+    /**\n+     * PEM chunk size per RFC 1421 section 4.3.2.4.\n+     * \n+     * <p>\n+     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n+     * equal signs.\n+     * </p>\n+     * \n+     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n+     */\n+    public static final int PEM_CHUNK_SIZE = 64;\n+\n+    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 8192;\n+    /**\n+     * Buffer for streaming.\n+     */\n+    protected byte[] buffer;\n+\n+    /**\n+     * Position where next character should be written in the buffer.\n+     */\n+    protected int pos;\n+\n+    /**\n+     * Position where next character should be read from the buffer.\n+     */\n+    private int readPos;\n+\n+    /**\n+     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,\n+     * and must be thrown away.\n+     */\n+    protected boolean eof;\n+\n+    /**\n+     * Place holder for the bytes we're dealing with for our based logic. Bitwise operations store and extract the\n+     * encoding or decoding from this variable.\n+     */\n+    protected long x;\n+\n+    /**\n+     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n+     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n+     */\n+    protected int currentLinePos;\n+\n+    /**\n+     * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding.\n+     * This variable helps track that.\n+     */\n+    protected int modulus;\n+\n+    protected BasedCodec(){\n+    }\n+\n+    /**\n+     * Returns true if this object has buffered data for reading.\n+     * \n+     * @return true if there is data still available for reading.\n+     */\n+    boolean hasData() {  // package protected for access from I/O streams\n+        return this.buffer != null;\n+    }\n+\n+    /**\n+     * Returns the amount of buffered data available for reading.\n+     * \n+     * @return The amount of buffered data available for reading.\n+     */\n+    int avail() {  // package protected for access from I/O streams\n+        return buffer != null ? pos - readPos : 0;\n+    }\n+\n+    /** Doubles our buffer. */\n+    protected void resizeBuffer() {\n+        if (buffer == null) {\n+            buffer = new byte[DEFAULT_BUFFER_SIZE];\n+            pos = 0;\n+            readPos = 0;\n+        } else {\n+            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n+            System.arraycopy(buffer, 0, b, 0, buffer.length);\n+            buffer = b;\n+        }\n+    }\n+\n+    /**\n+     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n+     * bytes. Returns how many bytes were actually extracted.\n+     * \n+     * @param b\n+     *            byte[] array to extract the buffered data into.\n+     * @param bPos\n+     *            position in byte[] array to start extraction at.\n+     * @param bAvail\n+     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n+     * @return The number of bytes successfully extracted into the provided byte[] array.\n+     */\n+    int readResults(byte[] b, int bPos, int bAvail) {  // package protected for access from I/O streams\n+        if (buffer != null) {\n+            int len = Math.min(avail(), bAvail);\n+            System.arraycopy(buffer, readPos, b, bPos, len);\n+            readPos += len;\n+            if (readPos >= pos) {\n+                buffer = null;\n+            }\n+            return len;\n+        }\n+        return eof ? -1 : 0;\n+    }\n+\n+    /**\n+     * Checks if a byte value is whitespace or not.\n+     * Whitespace is taken to mean: space, tab, CR, LF\n+     * @param byteToCheck\n+     *            the byte to check\n+     * @return true if byte is whitespace, false otherwise\n+     */\n+    protected static boolean isWhiteSpace(byte byteToCheck) {\n+        switch (byteToCheck) {\n+            case ' ' :\n+            case '\\n' :\n+            case '\\r' :\n+            case '\\t' :\n+                return true;\n+            default :\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Resets this Base32 object to its initial newly constructed state.\n+     */\n+    private void reset() {\n+        buffer = null;\n+        pos = 0;\n+        readPos = 0;\n+        currentLinePos = 0;\n+        modulus = 0;\n+        eof = false;\n+    }\n+    /**\n+     * Encodes an Object using the Base32 algorithm. This method is provided in order to satisfy the requirements of the\n+     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n+     * \n+     * @param pObject\n+     *            Object to encode\n+     * @return An object (of type byte[]) containing the Base32 encoded data which corresponds to the byte[] supplied.\n+     * @throws EncoderException\n+     *             if the parameter supplied is not of type byte[]\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (!(pObject instanceof byte[])) {\n+            throw new EncoderException(\"Parameter supplied to Base32 encode is not a byte[]\");\n+        }\n+        return encode((byte[]) pObject);\n+    }\n+    /**\n+     * Encodes a byte[] containing binary data, into a String containing characters in the Base32 alphabet.\n+     *\n+     * @param pArray\n+     *            a byte array containing binary data\n+     * @return A String containing only Base32 character data\n+     */\n+    public String encodeToString(byte[] pArray) {\n+        return StringUtils.newStringUtf8(encode(pArray));\n+    }\n+    /**\n+     * Decodes an Object using the Base32 algorithm. This method is provided in order to satisfy the requirements of the\n+     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n+     * \n+     * @param pObject\n+     *            Object to decode\n+     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n+     * @throws DecoderException\n+     *             if the parameter supplied is not of type byte[]\n+     */\n+    public Object decode(Object pObject) throws DecoderException {        \n+        if (pObject instanceof byte[]) {\n+            return decode((byte[]) pObject);\n+        } else if (pObject instanceof String) {\n+            return decode((String) pObject);\n+        } else {\n+            throw new DecoderException(\"Parameter supplied to Base32 decode is not a byte[] or a String\");\n+        }\n+    }\n+    /**\n+     * Decodes a String containing characters in the Base32 alphabet.\n+     *\n+     * @param pArray\n+     *            A String containing Base32 character data\n+     * @return a byte array containing binary data\n+     */\n+    public byte[] decode(String pArray) {\n+        return decode(StringUtils.getBytesUtf8(pArray));\n+    }\n+    /**\n+     * Decodes a byte[] containing characters in the Base32 alphabet.\n+     * \n+     * @param pArray\n+     *            A byte array containing Base32 character data\n+     * @return a byte array containing binary data\n+     */\n+    public byte[] decode(byte[] pArray) {\n+        reset();\n+        if (pArray == null || pArray.length == 0) {\n+            return pArray;\n+        }\n+        decode(pArray, 0, pArray.length);\n+        decode(pArray, 0, -1); // Notify decoder of EOF.\n+        byte[] result = new byte[pos];\n+        readResults(result, 0, result.length);\n+        return result;\n+    }\n+    /**\n+     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base32 alphabet.\n+     * \n+     * @param pArray\n+     *            a byte array containing binary data\n+     * @return A byte array containing only Base32 character data\n+     */\n+    public byte[] encode(byte[] pArray) {\n+        reset();        \n+        if (pArray == null || pArray.length == 0) {\n+            return pArray;\n+        }\n+        encode(pArray, 0, pArray.length);\n+        encode(pArray, 0, -1); // Notify encoder of EOF.\n+        byte[] buf = new byte[pos - readPos];\n+        readResults(buf, 0, buf.length);\n+        return buf;\n+    }\n+    \n+    abstract void encode(byte[] pArray, int i, int length);  // package protected for access from I/O streams\n+\n+    abstract void decode(byte[] pArray, int i, int length); // package protected for access from I/O streams\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/binary/BasedCodecInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+public class BasedCodecInputStream extends FilterInputStream {\n+\n+    private final boolean doEncode;\n+\n+    private final BasedCodec basedCodec;\n+\n+    private final byte[] singleByte = new byte[1];\n+\n+    protected BasedCodecInputStream(InputStream in, BasedCodec basedCodec, boolean doEncode) {\n+        super(in);\n+        this.doEncode = doEncode;\n+        this.basedCodec = basedCodec;\n+    }\n+\n+    /**\n+     * Reads one <code>byte</code> from this input stream.\n+     * \n+     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     */\n+    public int read() throws IOException {\n+        int r = read(singleByte, 0, 1);\n+        while (r == 0) {\n+            r = read(singleByte, 0, 1);\n+        }\n+        if (r > 0) {\n+            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n+     * from this InputStream.\n+     * \n+     * @param b\n+     *            destination byte array\n+     * @param offset\n+     *            where to start writing the bytes\n+     * @param len\n+     *            maximum number of bytes to read\n+     * \n+     * @return number of bytes read\n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     * @throws NullPointerException\n+     *             if the byte array parameter is null\n+     * @throws IndexOutOfBoundsException\n+     *             if offset, len or buffer size are invalid\n+     */\n+    public int read(byte b[], int offset, int len) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (offset < 0 || len < 0) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (offset > b.length || offset + len > b.length) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (len == 0) {\n+            return 0;\n+        } else {\n+            int readLen = 0;\n+            /*\n+             Rationale for while-loop on (readLen == 0):\n+             -----\n+             Base32.readResults() usually returns > 0 or EOF (-1).  In the\n+             rare case where it returns 0, we just keep trying.\n+\n+             This is essentially an undocumented contract for InputStream\n+             implementors that want their code to work properly with\n+             java.io.InputStreamReader, since the latter hates it when\n+             InputStream.read(byte[]) returns a zero.  Unfortunately our\n+             readResults() call must return 0 if a large amount of the data\n+             being decoded was non-base32, so this while-loop enables proper\n+             interop with InputStreamReader for that scenario.\n+             -----\n+             This is a fix for CODEC-101\n+            */\n+            while (readLen == 0) {\n+                if (!basedCodec.hasData()) {\n+                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n+                    int c = in.read(buf);\n+                    if (doEncode) {\n+                        basedCodec.encode(buf, 0, c);\n+                    } else {\n+                        basedCodec.decode(buf, 0, c);\n+                    }\n+                }\n+                readLen = basedCodec.readResults(b, offset, len);\n+            }\n+            return readLen;\n+        }\n+    }\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @return false\n+     */\n+    public boolean markSupported() {\n+        return false; // not an easy job to support marks\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/binary/BasedCodecOutputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+public class BasedCodecOutputStream extends FilterOutputStream {\n+\n+    private final boolean doEncode;\n+\n+    private final BasedCodec basedCodec;\n+\n+    private final byte[] singleByte = new byte[1];\n+\n+    public BasedCodecOutputStream(OutputStream out, BasedCodec basedCodec, boolean doEncode) {\n+        super(out);\n+        this.basedCodec = basedCodec;\n+        this.doEncode = doEncode;\n+    }\n+\n+    /**\n+     * Writes the specified <code>byte</code> to this output stream.\n+     * \n+     * @param i\n+     *            source byte\n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     */\n+    public void write(int i) throws IOException {\n+        singleByte[0] = (byte) i;\n+        write(singleByte, 0, 1);\n+    }\n+\n+    /**\n+     * Writes <code>len</code> bytes from the specified <code>b</code> array starting at <code>offset</code> to this\n+     * output stream.\n+     * \n+     * @param b\n+     *            source byte array\n+     * @param offset\n+     *            where to start reading the bytes\n+     * @param len\n+     *            maximum number of bytes to write\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     * @throws NullPointerException\n+     *             if the byte array parameter is null\n+     * @throws IndexOutOfBoundsException\n+     *             if offset, len or buffer size are invalid\n+     */\n+    public void write(byte b[], int offset, int len) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (offset < 0 || len < 0) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (offset > b.length || offset + len > b.length) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (len > 0) {\n+            if (doEncode) {\n+                basedCodec.encode(b, offset, len);\n+            } else {\n+                basedCodec.decode(b, offset, len);\n+            }\n+            flush(false);\n+        }\n+    }\n+\n+    /**\n+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propogate is\n+     * true, the wrapped stream will also be flushed.\n+     * \n+     * @param propogate\n+     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     */\n+    private void flush(boolean propogate) throws IOException {\n+        int avail = basedCodec.avail();\n+        if (avail > 0) {\n+            byte[] buf = new byte[avail];\n+            int c = basedCodec.readResults(buf, 0, avail);\n+            if (c > 0) {\n+                out.write(buf, 0, c);\n+            }\n+        }\n+        if (propogate) {\n+            out.flush();\n+        }\n+    }\n+\n+    /**\n+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     */\n+    public void flush() throws IOException {\n+        flush(true);\n+    }\n+\n+    /**\n+     * Closes this output stream and releases any system resources associated with the stream.\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     */\n+    public void close() throws IOException {\n+        // Notify encoder of EOF (-1).\n+        if (doEncode) {\n+            basedCodec.encode(singleByte, 0, -1);\n+        } else {\n+            basedCodec.decode(singleByte, 0, -1);\n+        }\n+        flush();\n+        out.close();\n+    }\n+\n+}", "timestamp": 1296055542, "metainfo": ""}