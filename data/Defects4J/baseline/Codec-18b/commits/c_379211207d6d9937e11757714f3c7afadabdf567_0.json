{"sha": "379211207d6d9937e11757714f3c7afadabdf567", "log": "<action dev=\"ggregory\" type=\"add\" issue=\"CODEC-181\" due-to=\"Ivan Martinez-Ortiz\">Make possible to provide padding byte to BaseNCodec in constructor</action>  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java\n      * <p>\n      * When encoding the line length is 0 (no chunking).\n      * </p>\n+     * @param pad byte used as padding byte.\n+     */\n+    public Base32(final byte pad) {\n+        this(false, pad);\n+    }\n+\n+    /**\n+     * Creates a Base32 codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length is 0 (no chunking).\n+     * </p>\n      * @param useHex if {@code true} then use Base32 Hex alphabet\n      */\n     public Base32(final boolean useHex) {\n-        this(0, null, useHex);\n+        this(0, null, useHex, PAD_DEFAULT);\n+    }\n+\n+    /**\n+     * Creates a Base32 codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length is 0 (no chunking).\n+     * </p>\n+     * @param useHex if {@code true} then use Base32 Hex alphabet\n+     * @param pad byte used as padding byte.\n+     */\n+    public Base32(final boolean useHex, final byte pad) {\n+        this(0, null, useHex, pad);\n     }\n \n     /**\n      *             The provided lineSeparator included some Base32 characters. That's not going to work!\n      */\n     public Base32(final int lineLength, final byte[] lineSeparator) {\n-        this(lineLength, lineSeparator, false);\n+        this(lineLength, lineSeparator, false, PAD_DEFAULT);\n     }\n \n     /**\n      *             lineLength &gt; 0 and lineSeparator is null.\n      */\n     public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\n-        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK,\n-                lineLength,\n-                lineSeparator == null ? 0 : lineSeparator.length);\n-        if (useHex){\n+        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\n+    }\n+\n+    /**\n+     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length and line separator are given in the constructor.\n+     * </p>\n+     * <p>\n+     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n+     * </p>\n+     *\n+     * @param lineLength\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\n+     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n+     *            decoding.\n+     * @param lineSeparator\n+     *            Each line of encoded data will end with this sequence of bytes.\n+     * @param useHex\n+     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n+     * @param pad byte used as padding byte.\n+     * @throws IllegalArgumentException\n+     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\n+     *             lineLength &gt; 0 and lineSeparator is null.\n+     */\n+    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\n+        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\n+                lineSeparator == null ? 0 : lineSeparator.length, pad);\n+        if (useHex) {\n             this.encodeTable = HEX_ENCODE_TABLE;\n             this.decodeTable = HEX_DECODE_TABLE;\n         } else {\n         }\n         if (lineLength > 0) {\n             if (lineSeparator == null) {\n-                throw new IllegalArgumentException(\"lineLength \"+lineLength+\" > 0, but lineSeparator is null\");\n+                throw new IllegalArgumentException(\"lineLength \" + lineLength + \" > 0, but lineSeparator is null\");\n             }\n             // Must be done after initializing the tables\n             if (containsAlphabetOrPad(lineSeparator)) {\n             this.lineSeparator = null;\n         }\n         this.decodeSize = this.encodeSize - 1;\n+\n+        if (isInAlphabet(pad) || isWhiteSpace(pad)) {\n+            throw new IllegalArgumentException(\"pad must not be in alphabet or whitespace\");\n+        }\n     }\n \n     /**\n         }\n         for (int i = 0; i < inAvail; i++) {\n             final byte b = in[inPos++];\n-            if (b == PAD) {\n+            if (b == pad) {\n                 // We're done.\n                 context.eof = true;\n                 break;\n                 case 1 : // Only 1 octet; take top 5 bits then remainder\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; // 5-3=2\n-                    buffer[context.pos++] = PAD;\n-                    buffer[context.pos++] = PAD;\n-                    buffer[context.pos++] = PAD;\n-                    buffer[context.pos++] = PAD;\n-                    buffer[context.pos++] = PAD;\n-                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = pad;\n+                    buffer[context.pos++] = pad;\n+                    buffer[context.pos++] = pad;\n+                    buffer[context.pos++] = pad;\n+                    buffer[context.pos++] = pad;\n+                    buffer[context.pos++] = pad;\n                     break;\n                 case 2 : // 2 octets = 16 bits to use\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\n-                    buffer[context.pos++] = PAD;\n-                    buffer[context.pos++] = PAD;\n-                    buffer[context.pos++] = PAD;\n-                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = pad;\n+                    buffer[context.pos++] = pad;\n+                    buffer[context.pos++] = pad;\n+                    buffer[context.pos++] = pad;\n                     break;\n                 case 3 : // 3 octets = 24 bits to use\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\n-                    buffer[context.pos++] = PAD;\n-                    buffer[context.pos++] = PAD;\n-                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = pad;\n+                    buffer[context.pos++] = pad;\n+                    buffer[context.pos++] = pad;\n                     break;\n                 case 4 : // 4 octets = 32 bits to use\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\n                     buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\n-                    buffer[context.pos++] = PAD;\n+                    buffer[context.pos++] = pad;\n                     break;\n                 default:\n                     throw new IllegalStateException(\"Impossible modulus \"+context.modulus);\n--- a/src/main/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64.java\n                     buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];\n                     // URL-SAFE skips the padding to further reduce size.\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n-                        buffer[context.pos++] = PAD;\n-                        buffer[context.pos++] = PAD;\n+                        buffer[context.pos++] = pad;\n+                        buffer[context.pos++] = pad;\n                     }\n                     break;\n \n                     buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];\n                     // URL-SAFE skips the padding to further reduce size.\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n-                        buffer[context.pos++] = PAD;\n+                        buffer[context.pos++] = pad;\n                     }\n                     break;\n                 default:\n         for (int i = 0; i < inAvail; i++) {\n             final byte[] buffer = ensureBufferSize(decodeSize, context);\n             final byte b = in[inPos++];\n-            if (b == PAD) {\n+            if (b == pad) {\n                 // We're done.\n                 context.eof = true;\n                 break;\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n      */\n     protected static final byte PAD_DEFAULT = '='; // Allow static access to default\n \n+    /**\n+     * @deprecated Use {@link #pad}. Will be removed in 2.0.\n+     */\n+    @Deprecated\n     protected final byte PAD = PAD_DEFAULT; // instance variable just in case it needs to vary later\n+\n+    protected final byte pad; // instance variable just in case it needs to vary later\n \n     /** Number of bytes in each full block of unencoded data, e.g. 4 for Base64 and 5 for Base32 */\n     private final int unencodedBlockSize;\n      */\n     protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,\n                          final int lineLength, final int chunkSeparatorLength) {\n+        this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, PAD_DEFAULT);\n+    }\n+\n+    /**\n+     * Note <code>lineLength</code> is rounded down to the nearest multiple of {@link #encodedBlockSize}\n+     * If <code>chunkSeparatorLength</code> is zero, then chunking is disabled.\n+     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\n+     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\n+     * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\n+     * @param chunkSeparatorLength the chunk separator length, if relevant\n+     * @param pad byte used as padding byte.\n+     */\n+    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,\n+                         final int lineLength, final int chunkSeparatorLength, final byte pad) {\n         this.unencodedBlockSize = unencodedBlockSize;\n         this.encodedBlockSize = encodedBlockSize;\n         final boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\n         this.lineLength = useChunking ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;\n         this.chunkSeparatorLength = chunkSeparatorLength;\n+\n+        this.pad = pad;\n     }\n \n     /**\n     public boolean isInAlphabet(final byte[] arrayOctet, final boolean allowWSPad) {\n         for (int i = 0; i < arrayOctet.length; i++) {\n             if (!isInAlphabet(arrayOctet[i]) &&\n-                    (!allowWSPad || (arrayOctet[i] != PAD) && !isWhiteSpace(arrayOctet[i]))) {\n+                    (!allowWSPad || (arrayOctet[i] != pad) && !isWhiteSpace(arrayOctet[i]))) {\n                 return false;\n             }\n         }\n             return false;\n         }\n         for (final byte element : arrayOctet) {\n-            if (PAD == element || isInAlphabet(element)) {\n+            if (pad == element || isInAlphabet(element)) {\n                 return true;\n             }\n         }\n--- a/src/test/java/org/apache/commons/codec/binary/Base32Test.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32Test.java\n         {\"foobar\" ,\"MZXW6YTBOI======\\r\\n\"},\n     };\n \n+    private static final String [][] BASE32_PAD_TEST_CASES = { // RFC 4648\n+        {\"\"       ,\"\"},\n+        {\"f\"      ,\"MY%%%%%%\"},\n+        {\"fo\"     ,\"MZXQ%%%%\"},\n+        {\"foo\"    ,\"MZXW6%%%\"},\n+        {\"foob\"   ,\"MZXW6YQ%\"},\n+        {\"fooba\"  ,\"MZXW6YTB\"},\n+        {\"foobar\" ,\"MZXW6YTBOI%%%%%%\"},\n+    };\n+    \n     @Test\n     public void testBase32Samples() throws Exception {\n         final Base32 codec = new Base32();\n             //assertEquals(b[0],codec.decode(b[1]));\n         }\n     }\n+    \n+    @Test\n+    public void testBase32SamplesNonDefaultPadding() throws Exception {\n+        final Base32 codec = new Base32((byte)0x25); // '%' <=> 0x25\n+        \n+        for (final String[] element : BASE32_PAD_TEST_CASES) {\n+                assertEquals(element[1], codec.encodeAsString(element[0].getBytes(Charsets.UTF_8)));\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/codec/binary/BaseNCodecTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/BaseNCodecTest.java\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertEquals;\n \n import org.junit.Before;\n import org.junit.Test;\n         assertTrue(codec.containsAlphabetOrPad(\"OK\".getBytes()));\n         assertTrue(codec.containsAlphabetOrPad(\"OK \".getBytes()));\n         assertFalse(codec.containsAlphabetOrPad(\"ok \".getBytes()));\n-        assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD}));\n+        assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.pad}));\n     }\n \n //    @Test\n //    public void testGetEncodedLength() {\n //        fail(\"Not yet implemented\");\n //    }\n+    \n+    @Test\n+    public void testProvidePaddingByte() {\n+        // Given\n+    \tcodec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) {\n+            @Override\n+            protected boolean isInAlphabet(final byte b) {\n+                return b=='O' || b == 'K'; // allow OK\n+            }\n+\n+            @Override\n+            void encode(final byte[] pArray, final int i, final int length, final Context context) {\n+            }\n+\n+            @Override\n+            void decode(final byte[] pArray, final int i, final int length, final Context context) {\n+            }\n+        };\n+        \n+        // When\n+        byte actualPaddingByte = codec.pad;\n+        \n+        // Then\n+        assertEquals(0x25, actualPaddingByte);\n+    }\n }", "timestamp": 1393270695, "metainfo": ""}