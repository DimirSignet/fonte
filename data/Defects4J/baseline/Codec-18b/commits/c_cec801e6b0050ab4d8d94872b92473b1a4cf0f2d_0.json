{"sha": "cec801e6b0050ab4d8d94872b92473b1a4cf0f2d", "log": "Fix failing test \"gna\": org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.testEncodeGna()  ", "commit": "\n--- a/src/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n      * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the input\n      */\n     public String phoneticUtf8(String input, final Set<String> languageSet) {\n-        List<Rule> rules = Rule.instance(this.nameType, RuleType.RULES, languageSet);\n-        List<Rule> finalRules1 = Rule.instance(this.nameType, this.ruleType, \"common\");\n-        List<Rule> finalRules2 = Rule.instance(this.nameType, this.ruleType, languageSet);\n+        final List<Rule> rules = Rule.instance(this.nameType, RuleType.RULES, languageSet);\n+        final List<Rule> finalRules1 = Rule.instance(this.nameType, this.ruleType, \"common\");\n+        final List<Rule> finalRules2 = Rule.instance(this.nameType, this.ruleType, languageSet);\n+        // System.err.println(\"Languages: \" + languageSet);\n+        // System.err.println(\"Rules: \" + rules);\n \n         // tidy the input\n         // lower case is a locale-dependent operation\n         String prefix = phonetic.substring(0, altStart);\n         altStart++;\n         int altEnd = phonetic.indexOf(')');\n+\n+        if (altEnd < altStart) {\n+            throw new IllegalArgumentException(\"Phonetic string has a close-bracket before the first open-bracket\");\n+        }\n+        \n         String altString = phonetic.substring(altStart, altEnd);\n         altEnd++;\n         String suffix = phonetic.substring(altEnd);\n--- a/src/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/java/org/apache/commons/codec/language/bm/Rule.java\n import java.util.Map;\n import java.util.Scanner;\n import java.util.Set;\n+import java.util.Stack;\n import java.util.regex.Pattern;\n \n /**\n  * @since 2.0\n  */\n public class Rule {\n+    public static final String ALL = \"ALL\";\n+\n     private static final String DOUBLE_QUOTE = \"\\\"\";\n-\n-    public static final String ALL = \"ALL\";\n \n     private static final String HASH_INCLUDE = \"#include\";\n \n \n                 Languages ls = Languages.instance(s);\n                 for (String l : ls.getLanguages()) {\n-                    rs.put(l, parseRules(mkScanner(s, rt, l)));\n+                    try {\n+                        rs.put(l, parseRules(createScanner(s, rt, l)));\n+                    } catch (IllegalStateException e) {\n+                        throw new IllegalStateException(\"Problem processing \" + createResourceName(s, rt, l), e);\n+                    }\n                 }\n                 if (!rt.equals(RuleType.RULES)) {\n-                    rs.put(\"common\", parseRules(mkScanner(s, rt, \"common\")));\n+                    rs.put(\"common\", parseRules(createScanner(s, rt, \"common\")));\n                 }\n \n                 rts.put(rt, Collections.unmodifiableMap(rs));\n \n             RULES.put(s, Collections.unmodifiableMap(rts));\n         }\n+    }\n+\n+    private static String createResourceName(NameType nameType, RuleType rt, String lang) {\n+        return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\", nameType.getName(), rt.getName(), lang);\n+    }\n+\n+    private static Scanner createScanner(NameType nameType, RuleType rt, String lang) {\n+        String resName = createResourceName(nameType, rt, lang);\n+        InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n+\n+        if (rulesIS == null) {\n+            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n+        }\n+\n+        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n+    }\n+\n+    private static Scanner createScanner(String lang) {\n+        String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\n+        InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n+\n+        if (rulesIS == null) {\n+            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n+        }\n+\n+        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n     }\n \n     /**\n         return rules;\n     }\n \n-    private static Scanner mkScanner(NameType nameType, RuleType rt, String lang) {\n-        String resName = String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\", nameType.getName(), rt.getName(), lang);\n-        InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n-\n-        if (rulesIS == null) {\n-            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n-        }\n-\n-        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n-    }\n-\n-    private static Scanner mkScanner(String lang) {\n-        String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\n-        InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n-\n-        if (rulesIS == null) {\n-            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n-        }\n-\n-        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n-    }\n-\n     private static List<Rule> parseRules(Scanner scanner) {\n         List<Rule> lines = new ArrayList<Rule>();\n+        int currentLine = 0;\n \n         boolean inMultilineComment = false;\n         while (scanner.hasNextLine()) {\n+            currentLine++;\n             String rawLine = scanner.nextLine();\n             String line = rawLine;\n \n                         if (incl.contains(\" \")) {\n                             System.err.println(\"Warining: malformed import statement: \" + rawLine);\n                         } else {\n-                            lines.addAll(parseRules(mkScanner(incl)));\n+                            lines.addAll(parseRules(createScanner(incl)));\n                         }\n                     } else {\n                         // rule\n                             String lCon = stripQuotes(parts[1]);\n                             String rCon = stripQuotes(parts[2]);\n                             String ph = stripQuotes(parts[3]);\n+                            try {\n+                                validatePhenome(ph);\n+                            } catch (IllegalArgumentException e) {\n+                                throw new IllegalStateException(\"Problem parsing line \" + currentLine, e);\n+                            }\n                             Rule r = new Rule(pat, lCon, rCon, ph, Collections.<String> emptySet(), \"\"); // guessing last 2 parameters\n                             lines.add(r);\n                         }\n         }\n \n         return str;\n+    }\n+\n+    private static void validatePhenome(CharSequence ph) {\n+        Stack<Character> stack = new Stack<Character>();\n+        for (int i = 0; i < ph.length(); i++) {\n+            switch (ph.charAt(i)) {\n+            case '(':\n+                stack.push('(');\n+                break;\n+            case '[':\n+                stack.push('[');\n+                break;\n+            case ')': {\n+                if (stack.isEmpty())\n+                    throw new IllegalArgumentException(\"Closing ')' at \" + i + \" without an opening '('\" + \" in \" + ph);\n+                char c = stack.pop();\n+                if (c != '(')\n+                    throw new IllegalArgumentException(\"Closing ')' does not pair with opening '\" + c + \"' at \" + i + \" in \" + ph);\n+                break;\n+            }\n+            case ']': {\n+                if (stack.isEmpty())\n+                    throw new IllegalArgumentException(\"Closing ']' at \" + i + \" without an opening '['\" + \" in \" + ph);\n+                char c = stack.pop();\n+                if (c != '[')\n+                    throw new IllegalArgumentException(\"Closing ']' does not pair with opening '\" + c + \"' at \" + i + \" in \" + ph);\n+                break;\n+            }\n+            default:\n+                break;\n+            }\n+        }\n+        if (!stack.isEmpty())\n+            throw new IllegalArgumentException(\"Bracket(s) opened without corresponding closes: \" + stack + \" in \" + ph);\n     }\n \n     private final Set<String> languages;\n--- a/src/test/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n+++ b/src/test/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n      * \n      * @throws EncoderException\n      */\n-    @Ignore\n+    // @Ignore\n     @Test\n     public void testEncodeGna() throws EncoderException {\n         BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n     }\n \n     @Ignore\n-    @Test\n+    @Test(timeout = 10000L)\n     public void testLongestEnglishSurname() throws EncoderException {\n         BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n         bmpm.setNameType(NameType.GENERIC);\n     }\n \n     @Ignore\n-    @Test\n+    @Test(timeout = 10000L)\n     public void testSpeedCheck() throws EncoderException {\n         char[] chars = new char[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'o', 'u' };\n         BeiderMorseEncoder bmpm = new BeiderMorseEncoder();", "timestamp": 1311796068, "metainfo": ""}