{"sha": "21015931d11bae2a37e390ff70ae55606a692ac1", "log": "[CODEC-130] Base64InputStream.skip skips underlying stream, not output. Add tests for skip(long) edge cases for the Base32 version of the code.  ", "commit": "\n--- a/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java\n \n package org.apache.commons.codec.binary;\n \n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n \n public class Base32InputStreamTest {\n \n-    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n-\n-    private final static byte[] LF = {(byte) '\\n'};\n+    private static final String ENCODED_FOO = \"MZXW6===\";\n+\n+    private final static byte[] CRLF = { (byte) '\\r', (byte) '\\n' };\n+\n+    private final static byte[] LF = { (byte) '\\n' };\n \n     /**\n      * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.\n         }\n     }\n \n-//    /**\n-//     * Test for the CODEC-101 bug:  InputStream.read(byte[]) should never return 0\n-//     * because Java's builtin InputStreamReader hates that.\n-//     *\n-//     * @throws Exception for some failure scenarios.\n-//     */\n-//    @Test\n-//    public void testCodec101() throws Exception {\n-//        byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);\n-//        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n-//        Base32InputStream in = new Base32InputStream(bais);\n-//        byte[] result = new byte[8192];\n-//        int c = in.read(result);\n-//        assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n-//\n-//        c = in.read(result);\n-//        assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n-//    }\n-\n-    /**\n-     * Another test for the CODEC-101 bug:\n-     * In commons-codec-1.4 this test shows InputStreamReader explicitly hating an\n+    // /**\n+    // * Test for the CODEC-101 bug: InputStream.read(byte[]) should never return 0\n+    // * because Java's builtin InputStreamReader hates that.\n+    // *\n+    // * @throws Exception for some failure scenarios.\n+    // */\n+    // @Test\n+    // public void testCodec101() throws Exception {\n+    // byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);\n+    // ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n+    // Base32InputStream in = new Base32InputStream(bais);\n+    // byte[] result = new byte[8192];\n+    // int c = in.read(result);\n+    // assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n+    //\n+    // c = in.read(result);\n+    // assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n+    // }\n+\n+    /**\n+     * Another test for the CODEC-101 bug: In commons-codec-1.4 this test shows InputStreamReader explicitly hating an\n      * InputStream.read(byte[]) return of 0:\n-     *\n-     * java.io.IOException: Underlying input stream returned zero bytes\n-     * at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268)\n-     * at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)\n-     * at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)\n-     * at java.io.InputStreamReader.read(InputStreamReader.java:167)\n-     * at java.io.BufferedReader.fill(BufferedReader.java:136)\n-     * at java.io.BufferedReader.readLine(BufferedReader.java:299)\n-     * at java.io.BufferedReader.readLine(BufferedReader.java:362)\n-     * at org.apache.commons.codec.binary.Base32InputStreamTest.testInputStreamReader(Base32InputStreamTest.java:75)\n-     *\n-     * But in commons-codec-1.5 it's fixed.  :-)\n-     *\n-     * @throws Exception for some failure scenarios.\n-     */\n-//    @Test\n-//    public void testInputStreamReader() throws Exception {\n-//        byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);\n-//        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n-//        Base32InputStream in = new Base32InputStream(bais);\n-//        InputStreamReader isr = new InputStreamReader(in);\n-//        BufferedReader br = new BufferedReader(isr);\n-//        String line = br.readLine();\n-//        assertNotNull(\"Codec101:  InputStreamReader works!\", line);\n-//    }\n-\n-    /**\n-     * Test the Base32InputStream implementation against the special NPE inducing input\n-     * identified in the CODEC-98 bug.\n-     *\n-     * @throws Exception for some failure scenarios.\n-     */\n-//    @Test\n-//    public void testCodec98NPE() throws Exception {\n-//        byte[] codec98 = StringUtils.getBytesUtf8(Base32TestData.CODEC_98_NPE);\n-//        ByteArrayInputStream data = new ByteArrayInputStream(codec98);\n-//        Base32InputStream stream = new Base32InputStream(data);\n-//\n-//        // This line causes an NPE in commons-codec-1.4.jar:\n-//        byte[] decodedBytes = Base32TestData.streamToBytes(stream, new byte[1024]);\n-//\n-//        String decoded = StringUtils.newStringUtf8(decodedBytes);\n-//        assertEquals(\n-//            \"codec-98 NPE Base32InputStream\", Base32TestData.CODEC_98_NPE_DECODED, decoded\n-//        );\n-//    }\n+     * \n+     * java.io.IOException: Underlying input stream returned zero bytes at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268) at\n+     * sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158) at\n+     * java.io.InputStreamReader.read(InputStreamReader.java:167) at java.io.BufferedReader.fill(BufferedReader.java:136) at\n+     * java.io.BufferedReader.readLine(BufferedReader.java:299) at java.io.BufferedReader.readLine(BufferedReader.java:362) at\n+     * org.apache.commons.codec.binary.Base32InputStreamTest.testInputStreamReader(Base32InputStreamTest.java:75)\n+     * \n+     * But in commons-codec-1.5 it's fixed. :-)\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    // @Test\n+    // public void testInputStreamReader() throws Exception {\n+    // byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);\n+    // ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n+    // Base32InputStream in = new Base32InputStream(bais);\n+    // InputStreamReader isr = new InputStreamReader(in);\n+    // BufferedReader br = new BufferedReader(isr);\n+    // String line = br.readLine();\n+    // assertNotNull(\"Codec101:  InputStreamReader works!\", line);\n+    // }\n+\n+    /**\n+     * Test the Base32InputStream implementation against the special NPE inducing input identified in the CODEC-98 bug.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    // @Test\n+    // public void testCodec98NPE() throws Exception {\n+    // byte[] codec98 = StringUtils.getBytesUtf8(Base32TestData.CODEC_98_NPE);\n+    // ByteArrayInputStream data = new ByteArrayInputStream(codec98);\n+    // Base32InputStream stream = new Base32InputStream(data);\n+    //\n+    // // This line causes an NPE in commons-codec-1.4.jar:\n+    // byte[] decodedBytes = Base32TestData.streamToBytes(stream, new byte[1024]);\n+    //\n+    // String decoded = StringUtils.newStringUtf8(decodedBytes);\n+    // assertEquals(\n+    // \"codec-98 NPE Base32InputStream\", Base32TestData.CODEC_98_NPE_DECODED, decoded\n+    // );\n+    // }\n \n     /**\n      * Tests the Base32InputStream implementation against empty input.\n \n         // Single Byte test.\n         encoded = StringUtils.getBytesUtf8(\"AA======\\r\\n\");\n-        decoded = new byte[]{(byte) 0};\n+        decoded = new byte[] { (byte) 0 };\n         testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n \n-//        // OpenSSL interop test.\n-//        encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE);\n-//        decoded = Base32TestData.DECODED;\n-//        testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF);\n-//\n-//        // Single Line test.\n-//        String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n-//        encoded = StringUtils.getBytesUtf8(singleLine);\n-//        decoded = Base32TestData.DECODED;\n-//        testByChunk(encoded, decoded, 0, LF);\n+        // // OpenSSL interop test.\n+        // encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE);\n+        // decoded = Base32TestData.DECODED;\n+        // testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF);\n+        //\n+        // // Single Line test.\n+        // String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+        // encoded = StringUtils.getBytesUtf8(singleLine);\n+        // decoded = Base32TestData.DECODED;\n+        // testByChunk(encoded, decoded, 0, LF);\n \n         // test random data of sizes 0 thru 150\n         BaseNCodec codec = new Base32();\n \n         // Single Byte test.\n         encoded = StringUtils.getBytesUtf8(\"AA======\\r\\n\");\n-        decoded = new byte[]{(byte) 0};\n+        decoded = new byte[] { (byte) 0 };\n         testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n \n-//        // Single Line test.\n-//        String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n-//        encoded = StringUtils.getBytesUtf8(singleLine);\n-//        decoded = Base32TestData.DECODED;\n-//        testByteByByte(encoded, decoded, 0, LF);\n+        // // Single Line test.\n+        // String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+        // encoded = StringUtils.getBytesUtf8(singleLine);\n+        // decoded = Base32TestData.DECODED;\n+        // testByteByByte(encoded, decoded, 0, LF);\n \n         // test random data of sizes 0 thru 150\n         BaseNCodec codec = new Base32();\n     }\n \n     /**\n-     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n+     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n      * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode\n-     * over and over again.\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode over and over\n+     * again.\n      * \n      * @param encoded\n      *            base32 encoded data\n     }\n \n     /**\n-     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n+     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n      * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode\n-     * over and over again.\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode over and over\n+     * again.\n      * \n      * @param encoded\n      *            base32 encoded data\n     public void testMarkSupported() throws Exception {\n         byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         // Always returns false for now.\n         assertFalse(\"Base32InputStream.markSupported() is false\", in.markSupported());\n     }\n         byte[] buf = new byte[1024];\n         int bytesRead = 0;\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         bytesRead = in.read(buf, 0, 0);\n         assertEquals(\"Base32InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n     }\n     public void testReadNull() throws Exception {\n         byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n         try {\n             in.read(null, 0, 0);\n             fail(\"Base32InputStream.read(null, 0, 0) to throw a NullPointerException\");\n         byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n         byte[] buf = new byte[1024];\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });\n \n         try {\n             in.read(buf, -1, 0);\n             // Expected\n         }\n     }\n+\n+    /**\n+     * Tests skipping as a noop\n+     * \n+     * @throws Throwable\n+     */\n+    @Test\n+    public void testSkipNone() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        Base32InputStream b32stream = new Base32InputStream(ins);\n+        byte[] actualBytes = new byte[6];\n+        assertEquals(0, b32stream.skip(0));\n+        b32stream.read(actualBytes, 0, actualBytes.length);\n+        assertArrayEquals(actualBytes, new byte[] { 102, 111, 111, 0, 0, 0 });\n+        // End of stream reached\n+        assertEquals(-1, b32stream.read());\n+    }\n+\n+    /**\n+     * Tests skipping past the end of a stream.\n+     * \n+     * @throws Throwable\n+     */\n+    @Test\n+    public void testSkipPastEnd() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        Base32InputStream b32stream = new Base32InputStream(ins);\n+        assertEquals(8, b32stream.skip(10));\n+        // End of stream reached\n+        assertEquals(-1, b32stream.read());\n+        assertEquals(-1, b32stream.read());\n+    }\n+\n+    /**\n+     * Tests skipping to the end of a stream.\n+     * \n+     * @throws Throwable\n+     */\n+    @Test\n+    public void testSkipToEnd() throws Throwable {\n+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));\n+        Base32InputStream b32stream = new Base32InputStream(ins);\n+        assertEquals(8, b32stream.skip(8));\n+        // End of stream reached\n+        assertEquals(-1, b32stream.read());\n+        assertEquals(-1, b32stream.read());\n+    }\n }", "timestamp": 1317059646, "metainfo": ""}