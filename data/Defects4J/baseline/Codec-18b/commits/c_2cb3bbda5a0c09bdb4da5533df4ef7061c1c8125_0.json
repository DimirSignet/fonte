{"sha": "2cb3bbda5a0c09bdb4da5533df4ef7061c1c8125", "log": "[CODEC-146] Added regression tests for PhoneticEngine. Thanks to Julius Davies.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineRegressionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * Tests PhoneticEngine and Languages.LanguageSet in ways very similar to code found in solr-3.6.0.\n+ *\n+ * @since 1.7\n+ */\n+public class PhoneticEngineRegressionTest {\n+\n+    @Test\n+    public void testSolrGENERIC() {\n+        Map<String, String> args;\n+\n+        // concat is true, ruleType is EXACT\n+        args = new TreeMap<String, String>();\n+        args.put(\"nameType\", \"GENERIC\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo\");\n+        args.put(\"ruleType\", \"EXACT\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"anZelo|andZelo|angelo|anhelo|anjelo|anxelo\");\n+        assertEquals(encode(args, true, \"D'Angelo\"), \"(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"andZelo|angelo|anxelo\");\n+        assertEquals(encode(args, true, \"1234\"), \"\");\n+\n+        // concat is false, ruleType is EXACT\n+        args = new TreeMap<String, String>();\n+        assertEquals(encode(args, false, \"Angelo\"), \"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo\");\n+        args.put(\"ruleType\", \"EXACT\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"anZelo|andZelo|angelo|anhelo|anjelo|anxelo\");\n+        assertEquals(encode(args, false, \"D'Angelo\"), \"(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"andZelo|angelo|anxelo\");\n+        assertEquals(encode(args, false, \"1234\"), \"\");\n+\n+        // concat is true, ruleType is APPROX\n+        args = new TreeMap<String, String>();\n+        assertEquals(encode(args, true, \"Angelo\"), \"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo\");\n+        args.put(\"ruleType\", \"APPROX\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo\");\n+        assertEquals(encode(args, true, \"D'Angelo\"), \"(agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo)-(dagilo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongilo|doniilo|donilo|donxilo|donzilo)\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"angilo|anxilo|anzilo|ongilo|onxilo|onzilo\");\n+        assertEquals(encode(args, true, \"1234\"), \"\");\n+\n+        // concat is false, ruleType is APPROX\n+        args = new TreeMap<String, String>();\n+        assertEquals(encode(args, false, \"Angelo\"), \"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo\");\n+        args.put(\"ruleType\", \"APPROX\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo\");\n+        assertEquals(encode(args, false, \"D'Angelo\"), \"(agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo)-(dagilo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongilo|doniilo|donilo|donxilo|donzilo)\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"angilo|anxilo|anzilo|ongilo|onxilo|onzilo\");\n+        assertEquals(encode(args, false, \"1234\"), \"\");\n+    }\n+\n+    @Test\n+    public void testSolrASHKENAZI() {\n+        Map<String, String> args;\n+\n+        // concat is true, ruleType is EXACT\n+        args = new TreeMap<String, String>();\n+        args.put(\"nameType\", \"ASHKENAZI\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO\");\n+        args.put(\"ruleType\", \"EXACT\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"andZelo|angelo|anhelo|anxelo\");\n+        assertEquals(encode(args, true, \"D'Angelo\"), \"dandZelo|dangelo|danhelo|danxelo\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"angelo|anxelo\");\n+        assertEquals(encode(args, true, \"1234\"), \"\");\n+\n+        // concat is false, ruleType is EXACT\n+        args = new TreeMap<String, String>();\n+        args.put(\"nameType\", \"ASHKENAZI\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO\");\n+        args.put(\"ruleType\", \"EXACT\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"andZelo|angelo|anhelo|anxelo\");\n+        assertEquals(encode(args, false, \"D'Angelo\"), \"dandZelo|dangelo|danhelo|danxelo\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"angelo|anxelo\");\n+        assertEquals(encode(args, false, \"1234\"), \"\");\n+\n+        // concat is true, ruleType is APPROX\n+        args = new TreeMap<String, String>();\n+        args.put(\"nameType\", \"ASHKENAZI\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO\");\n+        args.put(\"ruleType\", \"APPROX\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO\");\n+        assertEquals(encode(args, true, \"D'Angelo\"), \"dAnElO|dAnSelO|dAngElO|dAngzelO|dAnkselO|dAnzelO\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"AnSelO|AngElO|AngzelO|AnkselO\");\n+        assertEquals(encode(args, true, \"1234\"), \"\");\n+\n+        // concat is false, ruleType is APPROX\n+        args = new TreeMap<String, String>();\n+        args.put(\"nameType\", \"ASHKENAZI\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO\");\n+        args.put(\"ruleType\", \"APPROX\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO\");\n+        assertEquals(encode(args, false, \"D'Angelo\"), \"dAnElO|dAnSelO|dAngElO|dAngzelO|dAnkselO|dAnzelO\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"AnSelO|AngElO|AngzelO|AnkselO\");\n+        assertEquals(encode(args, false, \"1234\"), \"\");\n+    }\n+\n+    @Test\n+    public void testSolrSEPHARDIC() {\n+        Map<String, String> args;\n+\n+        // concat is true, ruleType is EXACT\n+        args = new TreeMap<String, String>();\n+        args.put(\"nameType\", \"SEPHARDIC\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu\");\n+        args.put(\"ruleType\", \"EXACT\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"anZelo|andZelo|anxelo\");\n+        assertEquals(encode(args, true, \"D'Angelo\"), \"anZelo|andZelo|anxelo\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"andZelo|anxelo\");\n+        assertEquals(encode(args, true, \"1234\"), \"\");\n+\n+        // concat is false, ruleType is EXACT\n+        args = new TreeMap<String, String>();\n+        args.put(\"nameType\", \"SEPHARDIC\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu\");\n+        args.put(\"ruleType\", \"EXACT\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"anZelo|andZelo|anxelo\");\n+        assertEquals(encode(args, false, \"D'Angelo\"), \"danZelo|dandZelo|danxelo\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"andZelo|anxelo\");\n+        assertEquals(encode(args, false, \"1234\"), \"\");\n+\n+        // concat is true, ruleType is APPROX\n+        args = new TreeMap<String, String>();\n+        args.put(\"nameType\", \"SEPHARDIC\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu\");\n+        args.put(\"ruleType\", \"APPROX\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu\");\n+        assertEquals(encode(args, true, \"D'Angelo\"), \"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, true, \"Angelo\"), \"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu\");\n+        assertEquals(encode(args, true, \"1234\"), \"\");\n+\n+        // concat is false, ruleType is APPROX\n+        args = new TreeMap<String, String>();\n+        args.put(\"nameType\", \"SEPHARDIC\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu\");\n+        args.put(\"ruleType\", \"APPROX\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu\");\n+        assertEquals(encode(args, false, \"D'Angelo\"), \"danhila|danhilu|danzila|danzilu|nhila|nhilu|nzila|nzilu\");\n+        args.put(\"languageSet\", \"italian,greek,spanish\");\n+        assertEquals(encode(args, false, \"Angelo\"), \"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu\");\n+        assertEquals(encode(args, false, \"1234\"), \"\");\n+    }\n+\n+    /**\n+     * This code is similar in style to code found in Solr:\n+     * solr/core/src/java/org/apache/solr/analysis/BeiderMorseFilterFactory.java\n+     *\n+     * Making a JUnit test out of it to protect Solr from possible future\n+     * regressions in Commons-Codec.\n+     */\n+    private static String encode(Map<String, String> args, boolean concat, String input) {\n+        Languages.LanguageSet languageSet;\n+        PhoneticEngine engine;\n+\n+        // PhoneticEngine = NameType + RuleType + concat\n+        // we use common-codec's defaults: GENERIC + APPROX + true\n+        String nameTypeArg = args.get(\"nameType\");\n+        NameType nameType = (nameTypeArg == null) ? NameType.GENERIC : NameType.valueOf(nameTypeArg);\n+\n+        String ruleTypeArg = args.get(\"ruleType\");\n+        RuleType ruleType = (ruleTypeArg == null) ? RuleType.APPROX : RuleType.valueOf(ruleTypeArg);\n+\n+        engine = new PhoneticEngine(nameType, ruleType, concat);\n+\n+        // LanguageSet: defaults to automagic, otherwise a comma-separated list.\n+        String languageSetArg = args.get(\"languageSet\");\n+        if (languageSetArg == null || languageSetArg.equals(\"auto\")) {\n+            languageSet = null;\n+        } else {\n+            languageSet = Languages.LanguageSet.from(new HashSet<String>(Arrays.asList(languageSetArg.split(\",\"))));\n+        }\n+\n+        /*\n+            org/apache/lucene/analysis/phonetic/BeiderMorseFilter.java (lines 96-98) does this:\n+\n+            encoded = (languages == null)\n+                ? engine.encode(termAtt.toString())\n+                : engine.encode(termAtt.toString(), languages);\n+\n+            Hence our approach, below:\n+        */\n+        if (languageSet == null) {\n+            return engine.encode(input);\n+        } else {\n+            return engine.encode(input, languageSet);\n+        }\n+    }\n+}", "timestamp": 1345753244, "metainfo": ""}