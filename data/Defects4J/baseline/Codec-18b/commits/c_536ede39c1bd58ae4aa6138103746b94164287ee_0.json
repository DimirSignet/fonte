{"sha": "536ede39c1bd58ae4aa6138103746b94164287ee", "log": "Cleanup of throws clauses in new crypt classes. Additional javadoc fixes.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/digest/Crypt.java\n+++ b/src/main/java/org/apache/commons/codec/digest/Crypt.java\n  */\n package org.apache.commons.codec.digest;\n \n+import java.security.NoSuchAlgorithmException;\n+\n import org.apache.commons.codec.Charsets;\n \n /**\n  * GNU libc crypt(3) compatible hash method.\n  * <p>\n  * See {@link #crypt(String, String)} for further details.\n- *\n- * <p>This class is immutable and thread-safe.</p>\n+ * <p>\n+ * This class is immutable and thread-safe.\n  *\n  * @version $Id$\n  * @since 1.7\n      * @param keyBytes\n      *            plaintext password\n      * @return hash value\n+     * @throws NoSuchAlgorithmException if no algorithm implementation is available\n      */\n-    public static String crypt(byte[] keyBytes) throws Exception {\n+    public static String crypt(byte[] keyBytes) throws NoSuchAlgorithmException {\n         return crypt(keyBytes, null);\n     }\n \n     /**\n      * Encrypts a password in a crypt(3) compatible way.\n      * <p>\n-     * A random salt and the default algorithm (currently SHA-512) are used. See\n-     * {@link #crypt(String, String)} for details.\n+     * If no salt is provided, a random salt and the default algorithm (currently SHA-512) will be used.\n+     * See {@link #crypt(String, String)} for details.\n      *\n      * @param keyBytes\n      *            plaintext password\n      * @param salt\n      *            salt value\n      * @return hash value\n+     * @throws IllegalArgumentException if the salt does not match the allowed pattern\n+     * @throws NoSuchAlgorithmException if no algorithm implementation is available\n      */\n-    public static String crypt(byte[] keyBytes, String salt) throws Exception {\n+    public static String crypt(byte[] keyBytes, String salt) throws NoSuchAlgorithmException {\n         if (salt == null) {\n             return Sha2Crypt.sha512Crypt(keyBytes);\n         } else if (salt.startsWith(Sha2Crypt.SHA512_PREFIX)) {\n      * @param key\n      *            plaintext password\n      * @return hash value\n+     * @throws NoSuchAlgorithmException if no algorithm implementation is available\n      */\n-    public static String crypt(String key) throws Exception {\n+    public static String crypt(String key) throws NoSuchAlgorithmException {\n         return crypt(key, null);\n     }\n \n     /**\n      * Encrypts a password in a crypt(3) compatible way.\n-     *\n      * <p>\n      * The exact algorithm depends on the format of the salt string:\n      * <ul>\n      * </ul>\n      * The magic strings \"$apr1$\" and \"$2a$\" are not recognised by this method as its\n      * output should be identical with that of the libc implementation.\n-     *\n      * <p>\n      * The rest of the salt string is drawn from the set [a-zA-Z0-9./] and is cut at the\n      * maximum length of if a \"$\" sign is encountered. It is therefore valid to enter a\n      * complete hash value as salt to e.g. verify a password with:\n-     *\n      * <pre>\n      *      storedPwd.equals(crypt(enteredPwd, storedPwd))\n      * </pre>\n-     *\n      * <p>\n      * The resulting string starts with the marker string ($6$), continues with the salt\n      * value and ends with a \"$\" sign followed by the actual hash value. For DES the string\n      * <li>MD5: 34 chars\n      * <li>DES: 13 chars\n      * </ul>\n-     *\n      * <p>\n      * Example:\n-     *\n      * <pre>\n      *      crypt(\"secret\", \"$1$xxxx\") => \"$1$xxxx$aMkevjfEIpa35Bh3G4bAc.\"\n      *      crypt(\"secret\", \"xx\") => \"xxWAum7tHdIUw\"\n      * </pre>\n-     *\n      * <p>\n      * This method comes in a variation that accepts a byte[] array to support input strings that\n      * are not encoded in UTF-8 but e.g. in ISO-8859-1 where equal characters result in different byte values.\n      * @param salt\n      *            salt value\n      * @return hash value, i.e. encrypted password including the salt string\n+     * @throws IllegalArgumentException if the salt does not match the allowed pattern\n+     * @throws NoSuchAlgorithmException if no algorithm implementation is available\n      */\n-    public static String crypt(String key, String salt) throws Exception {\n+    public static String crypt(String key, String salt) throws NoSuchAlgorithmException {\n         return crypt(key.getBytes(Charsets.UTF_8), salt);\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/digest/Md5Crypt.java\n+++ b/src/main/java/org/apache/commons/codec/digest/Md5Crypt.java\n package org.apache.commons.codec.digest;\n \n import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n import java.util.Arrays;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n  * The libc crypt() \"$1$\" and Apache \"$apr1$\" MD5-based hash algorithm.\n  * <p>\n  * Based on the public domain (\"beer-ware\") C implementation from Poul-Henning Kamp which was found at:\n- * </p>\n- * <p>\n- * http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/libcrypt/crypt-md5.c?rev=1.1;content-type=text%2Fplain<br/>\n- * Source: $FreeBSD: src/lib/libcrypt/crypt-md5.c,v 1.1 1999/01/21 13:50:09 brandon Exp $\n- * </p>\n- * <p>Conversion to Kotlin and from there to Java in 2012.</p>\n- *\n- * <p>The C style comments are from the original C code, the ones with \"//\" from the port.</p>\n- *\n- * <p>This class is immutable and thread-safe.</p>\n+ * <a href=\"http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/libcrypt/crypt-md5.c?rev=1.1;content-type=text%2Fplain\">\n+ * crypt-md5.c @ freebsd.org</a><br/>\n+ * <p>\n+ * Source:\n+ * <pre>$FreeBSD: src/lib/libcrypt/crypt-md5.c,v 1.1 1999/01/21 13:50:09 brandon Exp $</pre>\n+ * <p>\n+ * Conversion to Kotlin and from there to Java in 2012.\n+ * <p>\n+ * The C style comments are from the original C code, the ones with \"//\" from the port.\n+ * <p>\n+ * This class is immutable and thread-safe.\n  *\n  * @version $Id$\n  * @since 1.7\n  */\n public class Md5Crypt {\n \n-    /**\n-     * The Identifier of the Apache variant.\n-     */\n+    /** The Identifier of the Apache variant. */\n     static final String APR1_PREFIX = \"$apr1$\";\n \n-    /**\n-     * The number of bytes of the final hash.\n-     */\n+    /** The number of bytes of the final hash. */\n     private static final int BLOCKSIZE = 16;\n \n-    /**\n-     * The MessageDigest MD5_ALGORITHM.\n-     */\n+    /** The MessageDigest MD5_ALGORITHM. */\n     private static final String MD5_ALGORITHM = \"MD5\";\n \n-    /**\n-     * The Identifier of this crypt() variant.\n-     */\n+    /** The Identifier of this crypt() variant. */\n     static final String MD5_PREFIX = \"$1$\";\n \n-    /**\n-     * The number of rounds of the big loop.\n-     */\n+    /** The number of rounds of the big loop. */\n     private static final int ROUNDS = 1000;\n \n-    /** See {@link #apr1Crypt(String, String)} for details. */\n-    public static String apr1Crypt(byte[] keyBytes) throws Exception {\n+    /**\n+     * See {@link #apr1Crypt(String, String)} for details.\n+     *\n+     * @throws NoSuchAlgorithmException if no \"MD5\" algorithm implementation is available\n+     */\n+    public static String apr1Crypt(byte[] keyBytes) throws NoSuchAlgorithmException {\n         return apr1Crypt(keyBytes, APR1_PREFIX + B64.getRandomSalt(8));\n     }\n \n-    /** See {@link #apr1Crypt(String, String)} for details. */\n-    public static String apr1Crypt(byte[] keyBytes, String salt) throws Exception {\n+    /**\n+     * See {@link #apr1Crypt(String, String)} for details.\n+     *\n+     * @throws IllegalArgumentException if the salt does not match the allowed pattern\n+     * @throws NoSuchAlgorithmException if no \"MD5\" algorithm implementation is available\n+     */\n+    public static String apr1Crypt(byte[] keyBytes, String salt) throws NoSuchAlgorithmException {\n         // to make the md5Crypt regex happy\n         if (salt != null && !salt.startsWith(APR1_PREFIX)) {\n             salt = APR1_PREFIX + salt;\n         return Md5Crypt.md5Crypt(keyBytes, salt, APR1_PREFIX);\n     }\n \n-    /** See {@link #apr1Crypt(String, String)} for details. */\n-    public static String apr1Crypt(String keyBytes) throws Exception {\n+    /**\n+     * See {@link #apr1Crypt(String, String)} for details.\n+     *\n+     * @throws NoSuchAlgorithmException if no \"MD5\" algorithm implementation is available\n+     */\n+    public static String apr1Crypt(String keyBytes) throws NoSuchAlgorithmException {\n         return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8));\n     }\n \n      *            salt string including the prefix and optionally garbage at the end.\n      *            Will be generated randomly if null.\n      * @return computed hash value\n-     */\n-    public static String apr1Crypt(String keyBytes, String salt) throws Exception {\n+     * @throws IllegalArgumentException if the salt does not match the allowed pattern\n+     * @throws NoSuchAlgorithmException if no \"MD5\" algorithm implementation is available\n+     */\n+    public static String apr1Crypt(String keyBytes, String salt) throws NoSuchAlgorithmException {\n         return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8), salt);\n     }\n \n      * Generates a libc6 crypt() compatible \"$1$\" hash value.\n      * <p>\n      * See {@link Crypt#crypt(String, String)} for details.\n-     */\n-    public static String md5Crypt(final byte[] keyBytes) throws Exception {\n+     *\n+     * @throws NoSuchAlgorithmException if no \"MD5\" algorithm implementation is available\n+     */\n+    public static String md5Crypt(final byte[] keyBytes) throws NoSuchAlgorithmException {\n         return md5Crypt(keyBytes, MD5_PREFIX + B64.getRandomSalt(8));\n     }\n \n      *            salt string including the prefix and optionally garbage at the end.\n      *            Will be generated randomly if null.\n      * @return computed hash value\n-     */\n-    public static String md5Crypt(byte[] keyBytes, String salt) throws Exception {\n+     * @throws IllegalArgumentException if the salt does not match the allowed pattern\n+     * @throws NoSuchAlgorithmException if no \"MD5\" algorithm implementation is available\n+     */\n+    public static String md5Crypt(byte[] keyBytes, String salt) throws NoSuchAlgorithmException {\n         return md5Crypt(keyBytes, salt, MD5_PREFIX);\n     }\n \n      * Generates a libc6 crypt() \"$1$\" or Apache htpasswd \"$apr1$\" hash value.\n      * <p>\n      * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details.\n-     */\n-    public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) throws Exception {\n+     *\n+     * @throws IllegalArgumentException if the salt does not match the allowed pattern\n+     * @throws NoSuchAlgorithmException if no \"MD5\" algorithm implementation is available\n+     */\n+    public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix)\n+            throws NoSuchAlgorithmException {\n         int keyLen = keyBytes.length;\n \n         // Extract the real salt from the given string which can be a complete hash string.\n         if (salt == null) {\n             saltString = B64.getRandomSalt(8);\n         } else {\n-            Pattern p = Pattern.compile(\"^\" + prefix.replace(\"$\", \"\\\\$\") + \"([\\\\.\\\\/a-zA-Z0-9]{1,8}).*\");\n-            Matcher m = p.matcher(salt);\n+            final Pattern p = Pattern.compile(\"^\" + prefix.replace(\"$\", \"\\\\$\") + \"([\\\\.\\\\/a-zA-Z0-9]{1,8}).*\");\n+            final Matcher m = p.matcher(salt);\n             if (m == null || !m.find()) {\n                 throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n             }\n--- a/src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java\n+++ b/src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java\n package org.apache.commons.codec.digest;\n \n import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n import java.util.Arrays;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n+import org.apache.commons.codec.Charsets;\n+\n /**\n  * SHA2-based Unix crypt implementation.\n- *\n  * <p>\n  * Based on the C implementation released into the Public Domain by Ulrich Drepper &lt;drepper@redhat.com&gt;\n  * http://www.akkadia.org/drepper/SHA-crypt.txt\n- * </p>\n- *\n  * <p>\n- * Conversion to Kotlin and from there to Java in 2012 by Christian Hammers &lt;ch@lathspell.de&gt; and likewise put\n- * into the Public Domain.\n- * </p>\n- *\n- * <p>This class is immutable and thread-safe.</p>\n+ * Conversion to Kotlin and from there to Java in 2012 by Christian Hammers &lt;ch@lathspell.de&gt;\n+ * and likewise put into the Public Domain.\n+ * <p>\n+ * This class is immutable and thread-safe.\n  *\n  * @version $Id$\n  * @since 1.7\n  */\n public class Sha2Crypt {\n \n-    /**\n-     * Default number of rounds if not explicitly specified.\n-     */\n+    /** Default number of rounds if not explicitly specified. */\n     private static final int ROUNDS_DEFAULT = 5000;\n \n-    /**\n-     * Maximum number of rounds.\n-     */\n+    /** Maximum number of rounds. */\n     private static final int ROUNDS_MAX = 999999999;\n \n-    /**\n-     * Minimum number of rounds.\n-     */\n+    /** Minimum number of rounds. */\n     private static final int ROUNDS_MIN = 1000;\n \n-    /**\n-     * Prefix for optional rounds specification.\n-     */\n+    /** Prefix for optional rounds specification. */\n     private static final String ROUNDS_PREFIX = \"rounds=\";\n \n-    /**\n-     * The MessageDigest algorithm.\n-     */\n+    /** The SHA-256 MessageDigest algorithm. */\n     private static final String SHA256_ALGORITHM = \"SHA-256\";\n \n-    /**\n-     * The number of bytes the final hash value will have.\n-     */\n+    /** The number of bytes the final hash value will have (SHA-256 variant). */\n     private static final int SHA256_BLOCKSIZE = 32;\n \n-    /**\n-     * The prefixes that can be used to identify this crypt() variant.\n-     */\n+    /** The prefixes that can be used to identify this crypt() variant (SHA-256). */\n     static final String SHA256_PREFIX = \"$5$\";\n \n+    /** The SHA-512 MessageDigest algorithm. */\n     private static final String SHA512_ALGORITHM = \"SHA-512\";\n \n+    /** The number of bytes the final hash value will have (SHA-512 variant). */\n     private static final int SHA512_BLOCKSIZE = 64;\n \n+    /** The prefixes that can be used to identify this crypt() variant (SHA-512). */\n     static final String SHA512_PREFIX = \"$6$\";\n+\n+    /** The pattern to match valid salt values. */\n+    private static final Pattern SALT_PATTERN =\n+            Pattern.compile(\"^\\\\$([56])\\\\$(rounds=(\\\\d+)\\\\$)?([\\\\.\\\\/a-zA-Z0-9]{1,16}).*\");\n \n     /**\n      * Generates a libc crypt() compatible \"$5$\" hash value with random salt.\n      * <p>\n      * See {@link Crypt#crypt(String, String)} for details.\n+     *\n+     * @throws NoSuchAlgorithmException if no \"SHA-256\" algorithm implementation is available\n      */\n-    public static String sha256Crypt(byte[] keyBytes) throws Exception {\n+    public static String sha256Crypt(byte[] keyBytes) throws NoSuchAlgorithmException {\n         return sha256Crypt(keyBytes, null);\n     }\n \n      * Generates a libc6 crypt() compatible \"$5$\" hash value.\n      * <p>\n      * See {@link Crypt#crypt(String, String)} for details.\n+     *\n+     * @throws IllegalArgumentException if the salt does not match the allowed pattern\n+     * @throws NoSuchAlgorithmException if no \"SHA-256\" algorithm implementation is available\n      */\n-    public static String sha256Crypt(byte[] keyBytes, String salt) throws Exception {\n+    public static String sha256Crypt(byte[] keyBytes, String salt) throws NoSuchAlgorithmException {\n         if (salt == null) {\n             salt = SHA256_PREFIX + B64.getRandomSalt(8);\n         }\n      *\n      * @param keyBytes\n      *            plaintext that should be hashed\n-     * @param salt_string\n+     * @param salt\n      *            real salt value without prefix or \"rounds=\"\n      * @param saltPrefix\n      *            either $5$ or $6$\n      * @param algorithm\n      *            {@link MessageDigest} algorithm identifier string\n      * @return complete hash value including prefix and salt\n+     * @throws IllegalArgumentException if the given salt is {@code null} or does not match the allowed pattern\n+     * @throws NoSuchAlgorithmException if no implementation for the given algorithm is available\n      */\n     private static String sha2Crypt(byte[] keyBytes, String salt, String saltPrefix, int blocksize, String algorithm)\n-            throws Exception {\n+            throws NoSuchAlgorithmException {\n+\n         int keyLen = keyBytes.length;\n \n         // Extracts effective salt and the number of rounds from the given salt.\n         int rounds = ROUNDS_DEFAULT;\n         boolean roundsCustom = false;\n         if (salt == null) {\n-            throw new IllegalArgumentException(\"Invalid salt value: null\");\n-        }\n-        Pattern p = Pattern.compile(\"^\\\\$([56])\\\\$(rounds=(\\\\d+)\\\\$)?([\\\\.\\\\/a-zA-Z0-9]{1,16}).*\");\n-        Matcher m = p.matcher(salt);\n+            throw new IllegalArgumentException(\"Salt must not be null\");\n+        }\n+\n+        Matcher m = SALT_PATTERN.matcher(salt);\n         if (m == null || !m.find()) {\n             throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n         }\n             roundsCustom = true;\n         }\n         String saltString = m.group(4);\n-        byte[] saltBytes = saltString.getBytes(\"UTF-8\");\n+        byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n         int saltLen = saltBytes.length;\n \n         // 1. start digest A\n         // The loop uses a digest as input. In the first round it is the\n         // digest produced in step 12. In the latter steps it is the digest\n         // produced in step 21.h. The following text uses the notation\n-        // \"digest A/C\" to desribe this behavior.\n+        // \"digest A/C\" to describe this behavior.\n         /*\n          * Repeatedly run the collected hash value through sha512 to burn CPU cycles.\n          */\n         /*\n          * Now we can construct the result string. It consists of three parts.\n          */\n-        StringBuilder buffer = new StringBuilder(saltPrefix +\n-                (roundsCustom ? ROUNDS_PREFIX + rounds + \"$\" : \"\") + saltString + \"$\");\n+        StringBuilder buffer = new StringBuilder(saltPrefix);\n+        if (roundsCustom) {\n+            buffer.append(ROUNDS_PREFIX);\n+            buffer.append(rounds);\n+            buffer.append(\"$\");\n+        }\n+        buffer.append(saltString);\n+        buffer.append(\"$\");\n \n         // e) the base-64 encoded final C digest. The encoding used is as\n         // follows:\n      * Generates a libc crypt() compatible \"$6$\" hash value with random salt.\n      * <p>\n      * See {@link Crypt#crypt(String, String)} for details.\n+     *\n+     * @throws NoSuchAlgorithmException if no \"SHA-512\" algorithm implementation is available\n      */\n-    public static String sha512Crypt(byte[] keyBytes) throws Exception {\n+    public static String sha512Crypt(byte[] keyBytes) throws NoSuchAlgorithmException {\n         return sha512Crypt(keyBytes, null);\n     }\n \n      * Generates a libc6 crypt() compatible \"$6$\" hash value.\n      * <p>\n      * See {@link Crypt#crypt(String, String)} for details.\n+     *\n+     * @throws IllegalArgumentException if the salt does not match the allowed pattern\n+     * @throws NoSuchAlgorithmException if no \"SHA-512\" algorithm implementation is available\n      */\n-    public static String sha512Crypt(byte[] keyBytes, String salt) throws Exception {\n+    public static String sha512Crypt(byte[] keyBytes, String salt) throws NoSuchAlgorithmException {\n         if (salt == null) {\n             salt = SHA512_PREFIX + B64.getRandomSalt(8);\n         }\n--- a/src/main/java/org/apache/commons/codec/digest/UnixCrypt.java\n+++ b/src/main/java/org/apache/commons/codec/digest/UnixCrypt.java\n \n /**\n  * Unix crypt(3) algorithm implementation.\n- *\n- * <p>This class only implements the traditional 56 bit DES based algorithm. Please\n+ * <p>\n+ * This class only implements the traditional 56 bit DES based algorithm. Please\n  * use DigestUtils.crypt() for a method that distinguishes between all the\n- * algorithms supported in the current glibc's crypt().</p>\n- *\n- * <p>The Java implementation was taken from the JetSpeed Portal project (see\n- * org.apache.jetspeed.services.security.ldap.UnixCrypt).</p>\n- *\n- * <p>This class is slightly incompatible if the given salt contains characters\n- * that are not part of the allowed range [a-zA-Z0-9./].</p>\n- *\n- * <p>This class is immutable and thread-safe.</p>\n+ * algorithms supported in the current glibc's crypt().\n+ * <p>\n+ * The Java implementation was taken from the JetSpeed Portal project (see\n+ * org.apache.jetspeed.services.security.ldap.UnixCrypt).\n+ * <p>\n+ * This class is slightly incompatible if the given salt contains characters\n+ * that are not part of the allowed range [a-zA-Z0-9./].\n+ * <p>\n+ * This class is immutable and thread-safe.\n  *\n  * @version $Id$\n  * @since 1.7\n             0x8000000, 0x8200020, 32768, 0x208020\n         }\n     };\n+\n+    /**\n+     * Generates a crypt(3) compatible hash using the DES algorithm.\n+     * <p>\n+     * As no salt is given, a random one will be used.\n+     *\n+     * @param original\n+     *             plaintext password\n+     * @return a 13 character string starting with the salt string\n+     */\n+    public static String crypt(byte[] original) {\n+        return crypt(original, null);\n+    }\n+\n+    /**\n+     * Generates a crypt(3) compatible hash using the DES algorithm.\n+     * <p>\n+     * Using unspecified characters as salt results incompatible hash values.\n+     *\n+     * @param original\n+     *             plaintext password\n+     * @param salt\n+     *             a two character string drawn from [a-zA-Z0-9./] or null for a random one\n+     * @return a 13 character string starting with the salt string\n+     * @throws IllegalArgumentException if the salt does not match the allowed pattern\n+     */\n+    public static String crypt(byte[] original, String salt) {\n+        if (salt == null) {\n+            Random randomGenerator = new Random();\n+            int numSaltChars = SALT_CHARS.length;\n+            salt = \"\" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] +\n+                   SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];\n+        } else if (!salt.matches(\"^[\" + B64.B64T + \"]{2,}$\")) {\n+            throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n+        }\n+\n+        for (; salt.length() < 2; salt = salt + \"A\") {\n+            // NOOP\n+        }\n+\n+        StringBuilder buffer = new StringBuilder(\"             \");\n+        char charZero = salt.charAt(0);\n+        char charOne = salt.charAt(1);\n+        buffer.setCharAt(0, charZero);\n+        buffer.setCharAt(1, charOne);\n+        int eSwap0 = CON_SALT[charZero];\n+        int eSwap1 = CON_SALT[charOne] << 4;\n+        byte key[] = new byte[8];\n+        for (int i = 0; i < key.length; i++) {\n+            key[i] = 0;\n+        }\n+\n+        for (int i = 0; i < key.length && i < original.length; i++) {\n+            int iChar = original[i];\n+            key[i] = (byte) (iChar << 1);\n+        }\n+\n+        int schedule[] = desSetKey(key);\n+        int out[] = body(schedule, eSwap0, eSwap1);\n+        byte b[] = new byte[9];\n+        intToFourBytes(out[0], b, 0);\n+        intToFourBytes(out[1], b, 4);\n+        b[8] = 0;\n+        int i = 2;\n+        int y = 0;\n+        int u = 128;\n+        for (; i < 13; i++) {\n+            int j = 0;\n+            int c = 0;\n+            for (; j < 6; j++) {\n+                c <<= 1;\n+                if ((b[y] & u) != 0) {\n+                    c |= 0x1;\n+                }\n+                u >>>= 1;\n+                if (u == 0) {\n+                    y++;\n+                    u = 128;\n+                }\n+                buffer.setCharAt(i, (char) COV2CHAR[c]);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * Generates a crypt(3) compatible hash using the DES algorithm.\n+     * <p>\n+     * As no salt is given, a random one is used.\n+     *\n+     * @param original\n+     *             plaintext password\n+     * @return a 13 character string starting with the salt string\n+     */\n+    public static String crypt(String original) {\n+        return crypt(original.getBytes(Charsets.UTF_8));\n+    }\n+\n+    /**\n+     * Generates a crypt(3) compatible hash using the DES algorithm.\n+     *\n+     * @param original\n+     *             plaintext password\n+     * @param salt\n+     *             a two character string drawn from [a-zA-Z0-9./] or null for a random one\n+     * @return a 13 character string starting with the salt string\n+     * @throws IllegalArgumentException if the salt does not match the allowed pattern\n+     */\n+    public static String crypt(String original, String salt) {\n+        return crypt(original.getBytes(Charsets.UTF_8), salt);\n+    }\n \n     private static int[] body(int schedule[], int eSwap0, int eSwap1) {\n         int left = 0;\n         results[1] = b;\n     }\n \n-    /**\n-     * Generates a crypt(3) compatible hash using the DES algorithm.\n-     * <p>\n-     * As no salt is given, a random one will be used.\n-     *\n-     * @param original\n-     *             plaintext password\n-     * @return a 13 character string starting with the salt string\n-     */\n-    public static String crypt(byte[] original) {\n-        return crypt(original, null);\n-    }\n-\n-    /**\n-     * Generates a crypt(3) compatible hash using the DES algorithm.\n-     * <p>\n-     * Using unspecified characters as salt results incompatible hash values.\n-     *\n-     * @param original\n-     *             plaintext password\n-     * @param salt\n-     *             a two character string drawn from [a-zA-Z0-9./] or null for a random one\n-     * @return a 13 character string starting with the salt string\n-     */\n-    public static String crypt(byte[] original, String salt) {\n-        if (salt == null) {\n-            Random randomGenerator = new Random();\n-            int numSaltChars = SALT_CHARS.length;\n-            salt = \"\" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];\n-        } else if (!salt.matches(\"^[\" + B64.B64T + \"]{2,}$\")) {\n-            throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n-        }\n-\n-        for (; salt.length() < 2; salt = salt + \"A\") {\n-            // NOOP\n-        }\n-        StringBuilder buffer = new StringBuilder(\"             \");\n-        char charZero = salt.charAt(0);\n-        char charOne = salt.charAt(1);\n-        buffer.setCharAt(0, charZero);\n-        buffer.setCharAt(1, charOne);\n-        int eSwap0 = CON_SALT[charZero];\n-        int eSwap1 = CON_SALT[charOne] << 4;\n-        byte key[] = new byte[8];\n-        for (int i = 0; i < key.length; i++) {\n-            key[i] = 0;\n-        }\n-\n-        for (int i = 0; i < key.length && i < original.length; i++) {\n-            int iChar = original[i];\n-            key[i] = (byte) (iChar << 1);\n-        }\n-\n-        int schedule[] = desSetKey(key);\n-        int out[] = body(schedule, eSwap0, eSwap1);\n-        byte b[] = new byte[9];\n-        intToFourBytes(out[0], b, 0);\n-        intToFourBytes(out[1], b, 4);\n-        b[8] = 0;\n-        int i = 2;\n-        int y = 0;\n-        int u = 128;\n-        for (; i < 13; i++) {\n-            int j = 0;\n-            int c = 0;\n-            for (; j < 6; j++) {\n-                c <<= 1;\n-                if ((b[y] & u) != 0) {\n-                    c |= 0x1;\n-                }\n-                u >>>= 1;\n-                if (u == 0) {\n-                    y++;\n-                    u = 128;\n-                }\n-                buffer.setCharAt(i, (char) COV2CHAR[c]);\n-            }\n-        }\n-        return buffer.toString();\n-    }\n-\n-    /**\n-     * Generates a crypt(3) compatible hash using the DES algorithm.\n-     * <p>\n-     * As no salt is given, a random one is used.\n-     *\n-     * @param original\n-     *             plaintext password\n-     * @return a 13 character string starting with the salt string\n-     */\n-    public static String crypt(String original) throws Exception {\n-        return crypt(original.getBytes(Charsets.UTF_8));\n-    }\n-\n-    /**\n-     * Generates a crypt(3) compatible hash using the DES algorithm.\n-     *\n-     * @param original\n-     *             plaintext password\n-     * @param salt\n-     *             a two character string drawn from [a-zA-Z0-9./] or null for a random one\n-     * @return a 13 character string starting with the salt string\n-     */\n-    public static String crypt(String original, String salt) throws Exception {\n-        return crypt(original.getBytes(Charsets.UTF_8), salt);\n-    }\n-\n }\n--- a/src/test/java/org/apache/commons/codec/digest/Apr1CryptTest.java\n+++ b/src/test/java/org/apache/commons/codec/digest/Apr1CryptTest.java\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n+\n+import java.security.NoSuchAlgorithmException;\n+\n+import org.apache.commons.codec.Charsets;\n import org.junit.Test;\n \n public class Apr1CryptTest {\n \n     @Test\n-    public void testApr1CryptStrings() throws Exception {\n+    public void testApr1CryptStrings() throws NoSuchAlgorithmException {\n         // A random example using htpasswd\n         assertEquals(\"$apr1$TqI9WECO$LHZB2DqRlk9nObiB6vJG9.\", Md5Crypt.apr1Crypt(\"secret\", \"$apr1$TqI9WECO\"));\n         // empty data\n     }\n \n     @Test\n-    public void testApr1CryptBytes() throws Exception {\n+    public void testApr1CryptBytes() throws NoSuchAlgorithmException {\n         // An empty Bytearray equals an empty String\n         assertEquals(\"$apr1$foo$P27KyD1htb4EllIPEYhqi0\", Md5Crypt.apr1Crypt(new byte[0], \"$apr1$foo\"));\n         // UTF-8 stores \\u00e4 \"a with diaeresis\" as two bytes 0xc3 0xa4.\n         assertEquals(\"$apr1$./$EeFrYzWWbmTyGdf4xULYc.\", Md5Crypt.apr1Crypt(\"t\\u00e4st\", \"$apr1$./$\"));\n         // ISO-8859-1 stores \"a with diaeresis\" as single byte 0xe4.\n-        assertEquals(\"$apr1$./$kCwT1pY9qXAJElYG9q1QE1\", Md5Crypt.apr1Crypt(\"t\\u00e4st\".getBytes(\"ISO-8859-1\"), \"$apr1$./$\"));\n+        assertEquals(\"$apr1$./$kCwT1pY9qXAJElYG9q1QE1\", Md5Crypt.apr1Crypt(\"t\\u00e4st\".getBytes(Charsets.ISO_8859_1), \"$apr1$./$\"));\n     }\n \n     @Test\n-    public void testApr1CryptExplicitCall() throws Exception {\n+    public void testApr1CryptExplicitCall() throws NoSuchAlgorithmException {\n         // When explicitly called the prefix is optional\n         assertEquals(\"$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1\", Md5Crypt.apr1Crypt(\"secret\", \"1234\"));\n         // When explicitly called without salt, a random one will be used.\n     }\n \n     @Test(expected = NullPointerException.class)\n-    public void testApr1CryptNullData() throws Exception {\n+    public void testApr1CryptNullData() throws NoSuchAlgorithmException {\n         Md5Crypt.apr1Crypt((byte[]) null);\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void testApr1CryptWithEmptySalt() throws Exception {\n+    public void testApr1CryptWithEmptySalt() throws NoSuchAlgorithmException {\n         Md5Crypt.apr1Crypt(\"secret\".getBytes(), \"\");\n     }\n }\n--- a/src/test/java/org/apache/commons/codec/digest/CryptTest.java\n+++ b/src/test/java/org/apache/commons/codec/digest/CryptTest.java\n package org.apache.commons.codec.digest;\n \n import static org.junit.Assert.assertTrue;\n+\n+import java.security.NoSuchAlgorithmException;\n+\n import org.junit.Test;\n \n public class CryptTest {\n \n     @Test\n-    public void testDefaultCryptVariant() throws Exception {\n+    public void testDefaultCryptVariant() throws NoSuchAlgorithmException {\n         // If salt is null or completely omitted, a random \"$6$\" is used.\n         assertTrue(Crypt.crypt(\"secret\").startsWith(\"$6$\"));\n         assertTrue(Crypt.crypt(\"secret\", null).startsWith(\"$6$\"));\n      * hash would not be verifyable with other implementations of crypt().\n      */\n     @Test(expected = IllegalArgumentException.class)\n-    public void testCryptWithEmptySalt() throws Exception {\n+    public void testCryptWithEmptySalt() throws NoSuchAlgorithmException {\n         Crypt.crypt(\"secret\", \"\");\n     }\n \n--- a/src/test/java/org/apache/commons/codec/digest/Md5CryptTest.java\n+++ b/src/test/java/org/apache/commons/codec/digest/Md5CryptTest.java\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n+\n+import java.security.NoSuchAlgorithmException;\n+\n+import org.apache.commons.codec.Charsets;\n import org.junit.Test;\n \n public class Md5CryptTest {\n \n     @Test\n-    public void testMd5CryptStrings() throws Exception {\n+    public void testMd5CryptStrings() throws NoSuchAlgorithmException {\n         // empty data\n         assertEquals(\"$1$foo$9mS5ExwgIECGE5YKlD5o91\", Crypt.crypt(\"\", \"$1$foo\"));\n         // salt gets cut at dollar sign\n     }\n \n     @Test\n-    public void testMd5CryptBytes() throws Exception {\n+    public void testMd5CryptBytes() throws NoSuchAlgorithmException {\n         // An empty Bytearray equals an empty String\n         assertEquals(\"$1$foo$9mS5ExwgIECGE5YKlD5o91\", Crypt.crypt(new byte[0], \"$1$foo\"));\n         // UTF-8 stores \\u00e4 \"a with diaeresis\" as two bytes 0xc3 0xa4.\n         assertEquals(\"$1$./$52agTEQZs877L9jyJnCNZ1\", Crypt.crypt(\"t\\u00e4st\", \"$1$./$\"));\n         // ISO-8859-1 stores \"a with diaeresis\" as single byte 0xe4.\n-        assertEquals(\"$1$./$J2UbKzGe0Cpe63WZAt6p//\", Crypt.crypt(\"t\\u00e4st\".getBytes(\"ISO-8859-1\"), \"$1$./$\"));\n+        assertEquals(\"$1$./$J2UbKzGe0Cpe63WZAt6p//\", Crypt.crypt(\"t\\u00e4st\".getBytes(Charsets.ISO_8859_1), \"$1$./$\"));\n     }\n \n     @Test\n-    public void testMd5CryptExplicitCall() throws Exception {\n+    public void testMd5CryptExplicitCall() throws NoSuchAlgorithmException {\n         assertTrue(Md5Crypt.md5Crypt(\"secret\".getBytes()).matches(\"^\\\\$1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\"));\n         assertTrue(Md5Crypt.md5Crypt(\"secret\".getBytes(), null).matches(\"^\\\\$1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\"));\n     }\n \n     @Test(expected = NullPointerException.class)\n-    public void testMd5CryptNullData() throws Exception {\n+    public void testMd5CryptNullData() throws NoSuchAlgorithmException {\n         Md5Crypt.md5Crypt((byte[]) null);\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void testMd5CryptWithEmptySalt() throws Exception {\n+    public void testMd5CryptWithEmptySalt() throws NoSuchAlgorithmException {\n         Md5Crypt.md5Crypt(\"secret\".getBytes(), \"\");\n     }\n }\n--- a/src/test/java/org/apache/commons/codec/digest/Sha256CryptTest.java\n+++ b/src/test/java/org/apache/commons/codec/digest/Sha256CryptTest.java\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n+\n+import java.security.NoSuchAlgorithmException;\n+\n+import org.apache.commons.codec.Charsets;\n import org.junit.Test;\n \n public class Sha256CryptTest {\n \n     @Test\n-    public void testSha256CryptStrings() throws Exception {\n+    public void testSha256CryptStrings() throws NoSuchAlgorithmException {\n         // empty data\n         assertEquals(\"$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B\", Crypt.crypt(\"\", \"$5$foo\"));\n         // salt gets cut at dollar sign\n     }\n \n     @Test\n-    public void testSha256CryptBytes() throws Exception {\n+    public void testSha256CryptBytes() throws NoSuchAlgorithmException {\n         // An empty Bytearray equals an empty String\n         assertEquals(\"$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B\", Crypt.crypt(new byte[0], \"$5$foo\"));\n         // UTF-8 stores \\u00e4 \"a with diaeresis\" as two bytes 0xc3 0xa4.\n         assertEquals(\"$5$./$iH66LwY5sTDTdHeOxq5nvNDVAxuoCcyH/y6Ptte82P8\", Crypt.crypt(\"t\\u00e4st\", \"$5$./$\"));\n         // ISO-8859-1 stores \"a with diaeresis\" as single byte 0xe4.\n-        assertEquals(\"$5$./$qx5gFfCzjuWUOvsDDy.5Nor3UULPIqLVBZhgGNS0c14\", Crypt.crypt(\"t\\u00e4st\".getBytes(\"ISO-8859-1\"), \"$5$./$\"));\n+        assertEquals(\"$5$./$qx5gFfCzjuWUOvsDDy.5Nor3UULPIqLVBZhgGNS0c14\", Crypt.crypt(\"t\\u00e4st\".getBytes(Charsets.ISO_8859_1), \"$5$./$\"));\n     }\n \n     @Test\n-    public void testSha256CryptExplicitCall() throws Exception {\n+    public void testSha256CryptExplicitCall() throws NoSuchAlgorithmException {\n         assertTrue(Sha2Crypt.sha256Crypt(\"secret\".getBytes()).matches(\"^\\\\$5\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\"));\n         assertTrue(Sha2Crypt.sha256Crypt(\"secret\".getBytes(), null).matches(\"^\\\\$5\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\"));\n     }\n \n     @Test(expected = NullPointerException.class)\n-    public void testSha256CryptNullData() throws Exception {\n+    public void testSha256CryptNullData() throws NoSuchAlgorithmException {\n         Sha2Crypt.sha256Crypt((byte[]) null);\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void testSha256CryptWithEmptySalt() throws Exception {\n+    public void testSha256CryptWithEmptySalt() throws NoSuchAlgorithmException {\n         Sha2Crypt.sha256Crypt(\"secret\".getBytes(), \"\");\n     }\n }\n--- a/src/test/java/org/apache/commons/codec/digest/Sha512CryptTest.java\n+++ b/src/test/java/org/apache/commons/codec/digest/Sha512CryptTest.java\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n+\n+import java.security.NoSuchAlgorithmException;\n+\n+import org.apache.commons.codec.Charsets;\n import org.junit.Test;\n \n public class Sha512CryptTest {\n \n     @Test\n-    public void testSha512CryptStrings() throws Exception {\n+    public void testSha512CryptStrings() throws NoSuchAlgorithmException {\n         // empty data\n         assertEquals(\"$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/\", Crypt.crypt(\"\", \"$6$foo\"));\n         // salt gets cut at dollar sign\n     }\n \n     @Test\n-    public void testSha512CryptBytes() throws Exception {\n+    public void testSha512CryptBytes() throws NoSuchAlgorithmException {\n         // An empty Bytearray equals an empty String\n         assertEquals(\"$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/\", Crypt.crypt(new byte[0], \"$6$foo\"));\n         // UTF-8 stores \\u00e4 \"a with diaeresis\" as two bytes 0xc3 0xa4.\n         assertEquals(\"$6$./$fKtWqslQkwI8ZxjdWoeS.jHHrte97bZxiwB5gwCRHX6LG62fUhT6Bb5MRrjWvieh0C/gxh8ItFuTsVy80VrED1\", Crypt.crypt(\"t\\u00e4st\", \"$6$./$\"));\n         // ISO-8859-1 stores \"a with diaeresis\" as single byte 0xe4.\n-        assertEquals(\"$6$./$L49DSK.d2df/LxGLJQMyS5A/Um.TdHqgc46j5FpScEPlqQHP5dEazltaDNDZ6UEs2mmNI6kPwtH/rsP9g5zBI.\", Crypt.crypt(\"t\\u00e4st\".getBytes(\"ISO-8859-1\"), \"$6$./$\"));\n+        assertEquals(\"$6$./$L49DSK.d2df/LxGLJQMyS5A/Um.TdHqgc46j5FpScEPlqQHP5dEazltaDNDZ6UEs2mmNI6kPwtH/rsP9g5zBI.\", Crypt.crypt(\"t\\u00e4st\".getBytes(Charsets.ISO_8859_1), \"$6$./$\"));\n     }\n \n     @Test\n-    public void testSha512CryptExplicitCall() throws Exception {\n+    public void testSha512CryptExplicitCall() throws NoSuchAlgorithmException {\n         assertTrue(Sha2Crypt.sha512Crypt(\"secret\".getBytes()).matches(\"^\\\\$6\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\"));\n         assertTrue(Sha2Crypt.sha512Crypt(\"secret\".getBytes(), null).matches(\"^\\\\$6\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\"));\n     }\n \n     @Test(expected = NullPointerException.class)\n-    public void testSha512CryptNullData() throws Exception {\n+    public void testSha512CryptNullData() throws NoSuchAlgorithmException {\n         Sha2Crypt.sha512Crypt((byte[]) null);\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void testSha512CryptWithEmptySalt() throws Exception {\n+    public void testSha512CryptWithEmptySalt() throws NoSuchAlgorithmException {\n         Sha2Crypt.sha512Crypt(\"secret\".getBytes(), \"\");\n     }\n }\n--- a/src/test/java/org/apache/commons/codec/digest/UnixCryptTest.java\n+++ b/src/test/java/org/apache/commons/codec/digest/UnixCryptTest.java\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n+\n+import java.security.NoSuchAlgorithmException;\n+\n+import org.apache.commons.codec.Charsets;\n import org.junit.Test;\n \n public class UnixCryptTest {\n \n     @Test\n-    public void testUnixCryptStrings() throws Exception {\n+    public void testUnixCryptStrings() throws NoSuchAlgorithmException {\n         // trivial test\n         assertEquals(\"xxWAum7tHdIUw\", Crypt.crypt(\"secret\", \"xx\"));\n         // empty data\n     }\n \n     @Test\n-    public void testUnixCryptBytes() throws Exception {\n+    public void testUnixCryptBytes() throws NoSuchAlgorithmException {\n         // An empty Bytearray equals an empty String\n         assertEquals(\"12UFlHxel6uMM\", Crypt.crypt(new byte[0], \"12\"));\n         // UTF-8 stores \\u00e4 \"a with diaeresis\" as two bytes 0xc3 0xa4.\n         assertEquals(\"./287bds2PjVw\", Crypt.crypt(\"t\\u00e4st\", \"./\"));\n         // ISO-8859-1 stores \"a with diaeresis\" as single byte 0xe4.\n-        assertEquals(\"./bLIFNqo9XKQ\", Crypt.crypt(\"t\\u00e4st\".getBytes(\"ISO-8859-1\"), \"./\"));\n+        assertEquals(\"./bLIFNqo9XKQ\", Crypt.crypt(\"t\\u00e4st\".getBytes(Charsets.ISO_8859_1), \"./\"));\n         assertEquals(\"./bLIFNqo9XKQ\", Crypt.crypt(new byte[]{(byte) 0x74, (byte) 0xe4, (byte) 0x73, (byte) 0x74}, \"./\"));\n     }\n \n      * Unimplemented \"$foo$\" salt prefixes would be threated as UnixCrypt salt.\n      */\n     @Test(expected = IllegalArgumentException.class)\n-    public void testUnicCryptInvalidSalt() throws Exception {\n+    public void testUnicCryptInvalidSalt() {\n         UnixCrypt.crypt(\"secret\", \"$a\");\n     }\n \n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void testUnixCryptWithEmptySalt() throws Exception {\n+    public void testUnixCryptWithEmptySalt() {\n         UnixCrypt.crypt(\"secret\", \"\");\n     }\n }", "timestamp": 1345236138, "metainfo": ""}