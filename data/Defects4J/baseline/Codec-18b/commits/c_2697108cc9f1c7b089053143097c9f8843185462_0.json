{"sha": "2697108cc9f1c7b089053143097c9f8843185462", "log": "Added unit test for CODEC-130.  ", "commit": "\n--- a/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n+import java.io.BufferedInputStream;\n import java.io.BufferedReader;\n import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.util.Arrays;\n \n+import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n     private final static byte[] LF = { (byte) '\\n' };\n \n     private static final String STRING_FIXTURE = \"Hello World\";\n+\n+    /**\n+     * Tests the problem reported in CODEC-130. Missing / wrong implementation of skip.\n+     */\n+    @Test\n+    @Ignore\n+    public void testCodec130() throws IOException {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        Base64OutputStream base64os = new Base64OutputStream(bos);\n+\n+        base64os.write(\"Hello World!\".getBytes());\n+\n+        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n+        Base64InputStream ins = new Base64InputStream(bis);\n+\n+        // we skip the first character read from the reader\n+        ins.skip(1);\n+        StringBuffer sb = new StringBuffer();\n+        int len = 0;\n+        byte[] bytes = new byte[10];\n+        while ((len = ins.read(bytes)) != -1) {\n+            String s = new String(bytes, 0, len, \"iso-8859-1\");\n+            sb.append(s);\n+        }\n+        String str = sb.toString();\n+\n+        assertEquals(\"ello World!\", str);\n+    }\n \n     /**\n      * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.", "timestamp": 1332009134, "metainfo": ""}