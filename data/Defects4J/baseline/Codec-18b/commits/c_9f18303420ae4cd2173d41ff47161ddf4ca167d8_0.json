{"sha": "9f18303420ae4cd2173d41ff47161ddf4ca167d8", "log": "Remove last Javadoc warning.  ", "commit": "\n--- a/src/java/org/apache/commons/codec/language/ColognePhonetic.java\n+++ b/src/java/org/apache/commons/codec/language/ColognePhonetic.java\n  * <li>\n  * <h3>Step 3:</h3>\n  * Removal of all codes \u201c0\u201d except at the beginning. This means that two or more identical consecutive digits can occur\n- *  if they occur after removing the \"0\" digits.\n+ * if they occur after removing the \"0\" digits.\n  * \n  * <h4>Example:</h4>\n  * {@code \"6050750206802\" => \"65752682\"}</li>\n  * \n  * </ul>\n  * \n- * @see <a href=\"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\"><span\n- *      style=\"font-variant:small-caps\">Wikipedia</span> (de): <i>K\u00f6lner Phonetik</i></a> (a German description of the\n- *      algorithm and more sources)\n+ * @see <a href=\"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\">Wikipedia (de): K\u00f6lner Phonetik (in German)</a>\n  * @author Apache Software Foundation\n  * @since 1.5\n  */\n     private abstract class CologneBuffer {\n \n         protected final char[] data;\n-        \n+\n         protected int length = 0;\n \n         public CologneBuffer(char[] data) {\n         protected int getNextPos() {\n             return data.length - length;\n         }\n-        \n+\n         public char removeNext() {\n             char ch = getNextChar();\n             length--;\n         }\n     }\n \n-    private static final char[][] PREPROCESS_MAP = new char[][] {\n-            { '\\u00C4', 'A' },     // \u00c4\n-            { '\\u00DC', 'U' },     // \u00dc\n-            { '\\u00D6', 'O' },     // \u00d6\n-            { '\\u00DF', 'S' }      // \u00df\n+    private static final char[][] PREPROCESS_MAP = new char[][]{{'\\u00C4', 'A'}, // \u00c4\n+        {'\\u00DC', 'U'}, // \u00dc\n+        {'\\u00D6', 'O'}, // \u00d6\n+        {'\\u00DF', 'S'} // \u00df\n     };\n \n     /*\n \n     /**\n      * <p>\n-     * <b>colognePhonetic()</b> is the actual implementations of the <i>K\u00f6lner\n-     * Phonetik</i> algorithm.\n+     * <b>colognePhonetic()</b> is the actual implementations of the <i>K\u00f6lner Phonetik</i> algorithm.\n      * </p>\n      * <p>\n-     * In contrast to the initial description of the algorithm, this\n-     * implementation does the encoding in one pass.\n+     * In contrast to the initial description of the algorithm, this implementation does the encoding in one pass.\n      * </p>\n      * \n      * @param text\n-     * @return the corresponding encoding according to the <i>K\u00f6lner\n-     *         Phonetik</i> algorithm\n+     * @return the corresponding encoding according to the <i>K\u00f6lner Phonetik</i> algorithm\n      */\n     public String colognePhonetic(String text) {\n         if (text == null) {\n                 nextChar = '-';\n             }\n \n-            if (arrayContains(new char[] { 'A', 'E', 'I', 'J', 'O', 'U', 'Y' }, chr)) {\n+            if (arrayContains(new char[]{'A', 'E', 'I', 'J', 'O', 'U', 'Y'}, chr)) {\n                 code = '0';\n             } else if (chr == 'H' || chr < 'A' || chr > 'Z') {\n                 if (lastCode == '/') {\n                 code = '-';\n             } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {\n                 code = '1';\n-            } else if ((chr == 'D' || chr == 'T') && !arrayContains(new char[] { 'S', 'C', 'Z' }, nextChar)) {\n+            } else if ((chr == 'D' || chr == 'T') && !arrayContains(new char[]{'S', 'C', 'Z'}, nextChar)) {\n                 code = '2';\n-            } else if (arrayContains(new char[] { 'W', 'F', 'P', 'V' }, chr)) {\n+            } else if (arrayContains(new char[]{'W', 'F', 'P', 'V'}, chr)) {\n                 code = '3';\n-            } else if (arrayContains(new char[] { 'G', 'K', 'Q' }, chr)) {\n+            } else if (arrayContains(new char[]{'G', 'K', 'Q'}, chr)) {\n                 code = '4';\n-            } else if (chr == 'X' && !arrayContains(new char[] { 'C', 'K', 'Q' }, lastChar)) {\n+            } else if (chr == 'X' && !arrayContains(new char[]{'C', 'K', 'Q'}, lastChar)) {\n                 code = '4';\n                 input.addLeft('S');\n                 rightLength++;\n                 code = '8';\n             } else if (chr == 'C') {\n                 if (lastCode == '/') {\n-                    if (arrayContains(new char[] { 'A', 'H', 'K', 'L', 'O', 'Q', 'R', 'U', 'X' }, nextChar)) {\n+                    if (arrayContains(new char[]{'A', 'H', 'K', 'L', 'O', 'Q', 'R', 'U', 'X'}, nextChar)) {\n                         code = '4';\n                     } else {\n                         code = '8';\n                     }\n                 } else {\n-                    if (arrayContains(new char[] { 'S', 'Z' }, lastChar) || \n-                            !arrayContains(new char[] { 'A', 'H', 'O', 'U', 'K', 'Q', 'X' }, nextChar)) {\n+                    if (arrayContains(new char[]{'S', 'Z'}, lastChar) ||\n+                        !arrayContains(new char[]{'A', 'H', 'O', 'U', 'K', 'Q', 'X'}, nextChar)) {\n                         code = '8';\n                     } else {\n                         code = '4';\n                     }\n                 }\n-            } else if (arrayContains(new char[] { 'T', 'D', 'X' }, chr)) {\n+            } else if (arrayContains(new char[]{'T', 'D', 'X'}, chr)) {\n                 code = '8';\n             } else if (chr == 'R') {\n                 code = '7';\n \n     public Object encode(Object object) throws EncoderException {\n         if (!(object instanceof String)) {\n-            throw new EncoderException(\n-                    \"This method\u2019s parameter was expected to be of the type \" + String.class.getName() + \n-                    \". But actually it was of the type \" + object.getClass().getName() + \".\");\n+            throw new EncoderException(\"This method\u2019s parameter was expected to be of the type \" +\n+                String.class.getName() +\n+                \". But actually it was of the type \" +\n+                object.getClass().getName() +\n+                \".\");\n         }\n         return encode((String) object);\n     }\n     }\n \n     /*\n-     * Converts the string to upper case and replaces germanic umlauts, and the\n-     * \u201c\u00df\u201d.\n+     * Converts the string to upper case and replaces germanic umlauts, and the \u201c\u00df\u201d.\n      */\n     private String preprocess(String text) {\n         text = text.toUpperCase(Locale.GERMAN);", "timestamp": 1299805349, "metainfo": ""}