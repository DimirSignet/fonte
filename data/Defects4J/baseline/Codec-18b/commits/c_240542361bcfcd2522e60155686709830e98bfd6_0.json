{"sha": "240542361bcfcd2522e60155686709830e98bfd6", "log": "Adding Falk Meyer's Cologne Phonetic implementation, a Soundex like algorithm for German words - CODEC-106  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/language/ColognePhonetic.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import java.util.Locale;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * <h1>ColognePhonetic</h1>\n+ * \n+ * <p>\n+ * <b>ColognePhonetic</b> provides an implementation of the <a\n+ * href=\"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\">\u201cK\u00f6lner\n+ * Phonetic\u201d</a> (cologne phonetic) algorithm issued by Hans Joachim Postel in\n+ * 1969.\n+ * </p>\n+ * \n+ * <p>\n+ * The <i>K\u00f6lner Phonetik</i> is a phonetic algorithm which is optimized for the\n+ * German language. It is related to the well-known soundex algorithm.\n+ * </p>\n+ * \n+ * <h2>Algorithm</h2>\n+ * \n+ * <ul>\n+ * \n+ * <li>\n+ * <h3>First step:</h3>\n+ * After a preprocessing (convertion to upper case, transcription of <a\n+ * href=\"http://en.wikipedia.org/wiki/Germanic_umlaut\">germanic umlauts</a>,\n+ * removal of non alphabetical characters) the letters of the supplied text are\n+ * replaced by their phonetic code according to the folowing table.\n+ * <table border=\"1\">\n+ * <tbody>\n+ * <tr>\n+ * <th>Letter</th>\n+ * <th>Context</th>\n+ * <th align=\"center\">Code</th>\n+ * </tr>\n+ * <tr>\n+ * <td>A, E, I, J, O, U, Y</td>\n+ * <td></td>\n+ * <td align=\"center\">0</td>\n+ * </tr>\n+ * <tr>\n+ * \n+ * <td>H</td>\n+ * <td></td>\n+ * <td align=\"center\">-</td>\n+ * </tr>\n+ * <tr>\n+ * <td>B</td>\n+ * <td></td>\n+ * <td rowspan=\"2\" align=\"center\">1</td>\n+ * </tr>\n+ * <tr>\n+ * <td>P</td>\n+ * <td>not before H</td>\n+ * \n+ * </tr>\n+ * <tr>\n+ * <td>D, T</td>\n+ * <td>not before C, S, Z</td>\n+ * <td align=\"center\">2</td>\n+ * </tr>\n+ * <tr>\n+ * <td>F, V, W</td>\n+ * <td></td>\n+ * <td rowspan=\"2\" align=\"center\">3</td>\n+ * </tr>\n+ * <tr>\n+ * \n+ * <td>P</td>\n+ * <td>before H</td>\n+ * </tr>\n+ * <tr>\n+ * <td>G, K, Q</td>\n+ * <td></td>\n+ * <td rowspan=\"3\" align=\"center\">4</td>\n+ * </tr>\n+ * <tr>\n+ * <td rowspan=\"2\">C</td>\n+ * <td>at onset before A, H, K, L, O, Q, R, U, X</td>\n+ * \n+ * </tr>\n+ * <tr>\n+ * <td>before A, H, K, O, Q, U, X except after S, Z</td>\n+ * </tr>\n+ * <tr>\n+ * <td>X</td>\n+ * <td>not after C, K, Q</td>\n+ * <td align=\"center\">48</td>\n+ * </tr>\n+ * <tr>\n+ * <td>L</td>\n+ * <td></td>\n+ * \n+ * <td align=\"center\">5</td>\n+ * </tr>\n+ * <tr>\n+ * <td>M, N</td>\n+ * <td></td>\n+ * <td align=\"center\">6</td>\n+ * </tr>\n+ * <tr>\n+ * <td>R</td>\n+ * <td></td>\n+ * <td align=\"center\">7</td>\n+ * </tr>\n+ * \n+ * <tr>\n+ * <td>S, Z</td>\n+ * <td></td>\n+ * <td rowspan=\"6\" align=\"center\">8</td>\n+ * </tr>\n+ * <tr>\n+ * <td rowspan=\"3\">C</td>\n+ * <td>after S, Z</td>\n+ * </tr>\n+ * <tr>\n+ * <td>at onset except before A, H, K, L, O, Q, R, U, X</td>\n+ * </tr>\n+ * \n+ * <tr>\n+ * <td>not before A, H, K, O, Q, U, X</td>\n+ * </tr>\n+ * <tr>\n+ * <td>D, T</td>\n+ * <td>before C, S, Z</td>\n+ * </tr>\n+ * <tr>\n+ * <td>X</td>\n+ * <td>after C, K, Q</td>\n+ * </tr>\n+ * </tbody>\n+ * </table>\n+ * <p>\n+ * <small><i>(Source: <a href=\n+ * \"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik#Buchstabencodes\"\n+ * >Wikipedia (de): K\u00f6lner Phonetik \u2013 Buchstabencodes</a>)</i></small>\n+ * </p>\n+ * \n+ * <h4>Example:</h4>\n+ * \n+ * {@code \"M\u00fcller-L\u00fcdenscheidt\" => \"MULLERLUDENSCHEIDT\" => \"6005507500206880022\"}\n+ * \n+ * </li>\n+ * \n+ * <li>\n+ * <h3>Second step:</h3>\n+ * Removal of all doubly codes.\n+ * <h4>Example:</h4>\n+ * {@code \"6005507500206880022\" => \"6050750206802\"}</li>\n+ * \n+ * <li>\n+ * <h3>Third step:</h3>\n+ * Removal of all codes \u201c0\u201d except at the beginning\n+ * \n+ * <h4>Example:</h4>\n+ * {@code \"6050750206802\" => \"65752682\"}</li>\n+ * \n+ * </ul>\n+ * \n+ * @see<ul> <li><a\n+ *          href=\"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\"><span\n+ *          style=\"font-variant:small-caps\">Wikipedia</span> (de): <i>K\u00f6lner\n+ *          Phonetik</i></a>\u2014for German description of the algorithm and more\n+ *          sources.</li> <li>{@linkplain #colognePhonetic(String)}\u2014for the\n+ *          description of the actual implementation</li> <li>\n+ *          {@linkplain #isCologneEqual(String, String)}</li> <li>\n+ *          {@linkplain StringEncoder}\u2014for the interface implemented by this\n+ *          class</li> </ul>\n+ * \n+ * @author Falk Meyer, IT2media\n+ * @version beta 2010/9/13\n+ */\n+\n+public class ColognePhonetic implements StringEncoder {\n+\n+    private class CologneLeftBuffer implements CharSequence {\n+\n+        private final char[] data;\n+        private int length = 0;\n+\n+        public CologneLeftBuffer(int buffSize) {\n+            data = new char[buffSize];\n+        }\n+\n+        public CologneLeftBuffer(char[] data) {\n+            this.data = data;\n+            this.length = data.length;\n+        }\n+\n+        public int length() {\n+            return length;\n+        }\n+\n+        public char charAt(int index) {\n+            if (index < length) {\n+                return data[index];\n+            } else {\n+                throw new IndexOutOfBoundsException();\n+            }\n+        }\n+\n+        public CharSequence subSequence(int start, int end) {\n+            final int length = end - start;\n+\n+            char[] retData = copyData(start, length);\n+\n+            return new CologneLeftBuffer(retData);\n+        }\n+\n+        private char[] copyData(int start, final int length) {\n+            char[] retData = new char[length];\n+\n+            System.arraycopy(data, start, retData, 0, length);\n+            return retData;\n+        }\n+\n+        public char getLast() {\n+            return data[length - 1];\n+        }\n+\n+        public void putRight(char chr) {\n+            data[length] = chr;\n+            length++;\n+        }\n+\n+        public char dropLast() {\n+            length--;\n+            return data[length];\n+        }\n+\n+        public String toString() {\n+            return new String(copyData(0, length));\n+        }\n+    }\n+\n+    private class CologneRightBuffer implements CharSequence {\n+\n+        private int length = 0;\n+        private final char[] data;\n+\n+        public CologneRightBuffer(int buffSize) {\n+            data = new char[buffSize];\n+        }\n+\n+        public CologneRightBuffer(char[] data) {\n+            this.data = data;\n+            this.length = data.length;\n+        }\n+\n+        public int length() {\n+            return length;\n+        }\n+\n+        public char charAt(int index) {\n+            if (index < length) {\n+                return data[data.length - length + index];\n+            } else {\n+                throw new IndexOutOfBoundsException();\n+            }\n+        }\n+\n+        public CharSequence subSequence(int start, int end) {\n+            final int length = end - start;\n+            char[] newData = copyData(start, length);\n+\n+            return new CologneRightBuffer(newData);\n+        }\n+\n+        private char[] copyData(int start, final int length) {\n+            char[] newData = new char[length];\n+\n+            System.arraycopy(data, data.length - this.length + start, newData,\n+                    0, length);\n+            return newData;\n+        }\n+\n+        public void putLeft(char chr) {\n+            length++;\n+            data[data.length - length] = chr;\n+        }\n+\n+        public char getNext() {\n+            return data[data.length - length];\n+        }\n+\n+        public char dropNext() {\n+            char ret = data[data.length - length];\n+            length--;\n+\n+            return ret;\n+        }\n+\n+        public String toString() {\n+            return new String(copyData(0, length));\n+        }\n+\n+    }\n+\n+    private static final char[][] PRE_REPLACEMENTS = new char[][] {\n+            new char[] { '\\u00C4', 'A' },     // \u00c4\n+            new char[] { '\\u00DC', 'U' },     // \u00dc\n+            new char[] { '\\u00D6', 'O' },     // \u00d6\n+            new char[] { '\\u00DF', 'S' }      // \u00df\n+    };\n+\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (!(pObject instanceof String)) {\n+            throw new EncoderException(\n+                    \"This method\u2019s parameter was expected to be of the type \"\n+                            + String.class.getName()\n+                            + \". But actually it was of the type \"\n+                            + pObject.getClass().getName() + \".\");\n+        }\n+\n+        return encode((String) pObject);\n+    }\n+\n+    public String encode(String text) {\n+        return colognePhonetic(text);\n+    }\n+\n+    /**\n+     * <p>\n+     * <b>colognePhonetic()</b> is the actual implementations of the <i>K\u00f6lner\n+     * Phonetik</i> algorithm.\n+     * </p>\n+     * <p>\n+     * In contrast to the initial description of the algorithm, this\n+     * implementation does the encoding in one pass.\n+     * </p>\n+     * \n+     * @param text\n+     * @return the corresponding encoding according to the <i>K\u00f6lner\n+     *         Phonetik</i> algorithm\n+     */\n+\n+    public String colognePhonetic(String text) {\n+        if (text == null) {\n+            return null;\n+        }\n+\n+        text = preProcess(text);\n+\n+        CologneLeftBuffer left = new CologneLeftBuffer(text.length() * 2);\n+        CologneRightBuffer right = new CologneRightBuffer(text.toCharArray());\n+\n+        char nextChar;\n+\n+        char lastChar = '-';\n+        char lastCode = '/';\n+        char code;\n+        char chr;\n+\n+        int rightLength = right.length();\n+\n+        while (rightLength > 0) {\n+            chr = right.dropNext();\n+\n+            if ((rightLength = right.length()) > 0) {\n+                nextChar = right.getNext();\n+            } else {\n+                nextChar = '-';\n+            }\n+\n+            if (arrayContains(new char[] { 'E', 'I', 'A', 'U', 'O', 'Y' }, chr)) {\n+                code = '0';\n+            } else if (chr == 'H' || chr < 'A' || chr > 'Z') {\n+                if (lastCode == '/') {\n+                    continue;\n+                }\n+                code = '-';\n+            } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {\n+                code = '1';\n+            } else if ((chr == 'D' || chr == 'T')\n+                    && !arrayContains(new char[] { 'S', 'C', 'Z' }, nextChar)) {\n+                code = '2';\n+            } else if (arrayContains(new char[] { 'W', 'F', 'P', 'V' }, chr)) {\n+                code = '3';\n+            } else if (arrayContains(new char[] { 'G', 'K', 'Q' }, chr)) {\n+                code = '4';\n+            } else if (chr == 'X'\n+                    && !arrayContains(new char[] { 'C', 'K', 'Q' }, lastChar)) {\n+                code = '4';\n+                right.putLeft('S');\n+                rightLength++;\n+            } else if (chr == 'S' || chr == 'Z') {\n+                code = '8';\n+            } else if (chr == 'C') {\n+                if (lastCode == '/') {\n+                    if (arrayContains(new char[] { 'A', 'H', 'L', 'O', 'R',\n+                            'U', 'K', 'X', 'Q' }, nextChar)) {\n+                        code = '4';\n+                    } else {\n+                        code = '8';\n+                    }\n+                } else {\n+                    if (arrayContains(new char[] { 'S', 'Z' }, lastChar)\n+                            || !arrayContains(new char[] { 'A', 'H', 'O', 'U',\n+                                    'K', 'Q', 'X' }, nextChar)) {\n+                        code = '8';\n+                    } else {\n+                        code = '4';\n+                    }\n+                }\n+            } else if (arrayContains(new char[] { 'T', 'D', 'X' }, chr)) {\n+                code = '8';\n+            } else if (chr == 'R') {\n+                code = '7';\n+            } else if (chr == 'L') {\n+                code = '5';\n+            } else if (chr == 'M' || chr == 'N') {\n+                code = '6';\n+            } else {\n+                code = chr;\n+            }\n+\n+            if (code != '-'\n+                    && (lastCode != code && (code != '0' || lastCode == '/')\n+                            || code < '0' || code > '8')) {\n+                left.putRight(code);\n+            }\n+\n+            lastChar = chr;\n+            lastCode = code;\n+        }\n+\n+        return left.toString();\n+    }\n+\n+    /*\n+     * Returns whether the array contains the key, or not.\n+     */\n+    private static boolean arrayContains(char[] arr, char key) {\n+        for (int i = 0; i < arr.length; i++) {\n+            if (arr[i] == key) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /*\n+     * Converts the string to upper case and replaces germanic umlauts, and the\n+     * \u201c\u00df\u201d.\n+     */\n+    private String preProcess(String text) {\n+        text = text.toUpperCase(Locale.GERMAN);\n+\n+        char[] chrs = text.toCharArray();\n+\n+        for (int index = 0; index < chrs.length; index++) {\n+            if (chrs[index] > 'Z') {\n+                for (int replacement = 0; replacement < PRE_REPLACEMENTS.length; replacement++) {\n+                    if (chrs[index] == PRE_REPLACEMENTS[replacement][0]) {\n+                        chrs[index] = PRE_REPLACEMENTS[replacement][1];\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        text = new String(chrs);\n+\n+        return text;\n+    }\n+\n+    public boolean isCologneEqual(String text1, String text2) {\n+        return colognePhonetic(text1).equals(colognePhonetic(text2));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/language/ColognePhoneticTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+\n+public class ColognePhoneticTest extends StringEncoderAbstractTest {\n+\n+    public ColognePhoneticTest(String name) {\n+        super(name);\n+    }\n+\n+    protected StringEncoder makeEncoder() {\n+        return new ColognePhonetic();\n+    }\n+\n+    public void testExamples() {\n+        ColognePhonetic koellePhon = new ColognePhonetic();\n+        String[][] data = { { \"M\u00fcller-L\u00fcdenscheidt\", \"65752682\" },\n+                { \"Breschnew\", \"17863\" }, { \"Wikipedia\", \"3412\" } };\n+\n+        for (int i = 0; i < data.length; i++) {\n+            assertEquals(data[i][1], koellePhon.colognePhonetic(data[i][0]));\n+        }\n+    }\n+\n+    public void testBorderCases() {\n+        ColognePhonetic koellePhon = new ColognePhonetic();\n+\n+        String[][] data = { { \"a\", \"0\" }, { \"e\", \"0\" }, { \"i\", \"0\" },\n+                { \"o\", \"0\" }, { \"u\", \"0\" }, { \"\\u00E4\", \"0\" }, { \"\\u00F6\", \"0\" },\n+                { \"\\u00FC\", \"0\" }, { \"aa\", \"0\" }, { \"ha\", \"0\" }, { \"h\", \"\" },\n+                { \"aha\", \"0\" }, { \"b\", \"1\" }, { \"p\", \"1\" }, { \"ph\", \"3\" },\n+                { \"f\", \"3\" }, { \"v\", \"3\" }, { \"w\", \"3\" }, { \"g\", \"4\" },\n+                { \"k\", \"4\" }, { \"q\", \"4\" }, { \"x\", \"48\" }, { \"ax\", \"048\" },\n+                { \"cx\", \"48\" }, { \"l\", \"5\" }, { \"cl\", \"45\" }, { \"acl\", \"085\" },\n+                { \"mn\", \"6\" }, { \"r\", \"7\" } };\n+\n+        for (int i = 0; i < data.length; i++) {\n+            assertEquals(\"Failed to correctly convert element of index: \" + i,\n+                         data[i][1], koellePhon.colognePhonetic(data[i][0]));\n+        }\n+    }\n+\n+    public void testIsCologneEquals() {\n+        ColognePhonetic koellePhon = new ColognePhonetic();\n+        assertFalse(\"Cologne-phonetic encodings should not be equal\",\n+                koellePhon.isCologneEqual(\"Meyer\", \"M\u00fcller\"));\n+        assertTrue(\"Cologne-phonetic encodings should be equal\",\n+                koellePhon.isCologneEqual(\"Meyer\", \"Mayr\"));\n+    }\n+}", "timestamp": 1284698768, "metainfo": ""}