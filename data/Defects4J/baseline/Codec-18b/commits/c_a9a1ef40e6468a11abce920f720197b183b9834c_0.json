{"sha": "a9a1ef40e6468a11abce920f720197b183b9834c", "log": "[CODEC-174] Apply patch https://issues.apache.org/jira/secure/attachment/12611963/CODEC-174-change-rules-storage-to-Map.patch. Thanks to Thomas Champagne.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n      * @since 1.6\n      */\n     private static final class RulesApplication {\n-        private final List<Rule> finalRules;\n+        private final Map<String, List<Rule>> finalRules;\n         private final CharSequence input;\n \n         private PhonemeBuilder phonemeBuilder;\n         private final int maxPhonemes;\n         private boolean found;\n \n-        public RulesApplication(final List<Rule> finalRules, final CharSequence input,\n+        public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input,\n                                 final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {\n             if (finalRules == null) {\n                 throw new NullPointerException(\"The finalRules argument must not be null\");\n          */\n         public RulesApplication invoke() {\n             this.found = false;\n-            int patternLength = 0;\n-            for (final Rule rule : this.finalRules) {\n-                final String pattern = rule.getPattern();\n-                patternLength = pattern.length();\n-\n-                if (!rule.patternAndContextMatches(this.input, this.i)) {\n-                    continue;\n-                }\n-\n-                this.phonemeBuilder = this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\n-                this.found = true;\n-                break;\n+            int patternLength = 1;\n+            List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\n+            if (rules != null) {\n+            \tfor (Rule rule : rules) {\n+\t            \tfinal String pattern = rule.getPattern();\n+\t                patternLength = pattern.length();\n+\t            \tif (rule.patternAndContextMatches(this.input, this.i)) {\n+\t\t                this.phonemeBuilder = this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\n+\t\t                this.found = true;\n+\t\t                break;\n+\t            \t}\n+            \t}\n             }\n \n             if (!this.found) {\n      * @param finalRules the final rules to apply\n      * @return the resulting phonemes\n      */\n-    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder, final List<Rule> finalRules) {\n+    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder, final Map<String, List<Rule>> finalRules) {\n         if (finalRules == null) {\n             throw new NullPointerException(\"finalRules can not be null\");\n         }\n      *   of the input\n      */\n     public String encode(String input, final Languages.LanguageSet languageSet) {\n-        final List<Rule> rules = Rule.getInstance(this.nameType, RuleType.RULES, languageSet);\n+        final Map<String, List<Rule>> rules = Rule.getInstance(this.nameType, RuleType.RULES, languageSet);\n         // rules common across many (all) languages\n-        final List<Rule> finalRules1 = Rule.getInstance(this.nameType, this.ruleType, \"common\");\n+        final Map<String, List<Rule>> finalRules1 = Rule.getInstance(this.nameType, this.ruleType, \"common\");\n         // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\n-        final List<Rule> finalRules2 = Rule.getInstance(this.nameType, this.ruleType, languageSet);\n+        final Map<String, List<Rule>> finalRules2 = Rule.getInstance(this.nameType, this.ruleType, languageSet);\n \n         // tidy the input\n         // lower case is a locale-dependent operation\n--- a/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n \n     private static final String HASH_INCLUDE = \"#include\";\n \n-    private static final Map<NameType, Map<RuleType, Map<String, List<Rule>>>> RULES =\n-            new EnumMap<NameType, Map<RuleType, Map<String, List<Rule>>>>(NameType.class);\n+    private static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES =\n+            new EnumMap<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>>(NameType.class);\n \n     static {\n         for (final NameType s : NameType.values()) {\n-            final Map<RuleType, Map<String, List<Rule>>> rts =\n-                    new EnumMap<RuleType, Map<String, List<Rule>>>(RuleType.class);\n+            final Map<RuleType, Map<String, Map<String, List<Rule>>>> rts =\n+                    new EnumMap<RuleType, Map<String, Map<String, List<Rule>>>>(RuleType.class);\n \n             for (final RuleType rt : RuleType.values()) {\n-                final Map<String, List<Rule>> rs = new HashMap<String, List<Rule>>();\n+                final Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>();\n \n                 final Languages ls = Languages.getInstance(s);\n                 for (final String l : ls.getLanguages()) {\n      *            the set of languages to consider\n      * @return a list of Rules that apply\n      */\n-    public static List<Rule> getInstance(final NameType nameType, final RuleType rt,\n+    public static Map<String, List<Rule>> getInstance(final NameType nameType, final RuleType rt,\n                                          final Languages.LanguageSet langs) {\n         return langs.isSingleton() ? getInstance(nameType, rt, langs.getAny()) :\n                                      getInstance(nameType, rt, Languages.ANY);\n      *            the language to consider\n      * @return a list rules for a combination of name type, rule type and a single language.\n      */\n-    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {\n-        final List<Rule> rules = RULES.get(nameType).get(rt).get(lang);\n+    public static Map<String, List<Rule>> getInstance(final NameType nameType, final RuleType rt, final String lang) {\n+        final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\n \n         if (rules == null) {\n             throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\",\n         }\n     }\n \n-    private static List<Rule> parseRules(final Scanner scanner, final String location) {\n-        final List<Rule> lines = new ArrayList<Rule>();\n+    private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {\n+        final Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>();\n         int currentLine = 0;\n \n         boolean inMultilineComment = false;\n                             throw new IllegalArgumentException(\"Malformed import statement '\" + rawLine + \"' in \" +\n                                                                location);\n                         } else {\n-                            lines.addAll(parseRules(createScanner(incl), location + \"->\" + incl));\n+                            lines.putAll(parseRules(createScanner(incl), location + \"->\" + incl));\n                         }\n                     } else {\n                         // rule\n                                         return sb.toString();\n                                     }\n                                 };\n-                                lines.add(r);\n+                                String patternKey = r.pattern.substring(0,1);\n+                                List<Rule> rules = lines.get(patternKey);\n+                                if (rules == null) {\n+                                \trules = new ArrayList<Rule>();\n+                                \tlines.put(patternKey, rules);\n+                                }\n+                                rules.add(r);\n                             } catch (final IllegalArgumentException e) {\n                                 throw new IllegalStateException(\"Problem parsing line '\" + currentLine + \"' in \" +\n                                                                 location, e);\n--- a/src/test/java/org/apache/commons/codec/language/bm/PhoneticEnginePerformanceTest.java\n+++ b/src/test/java/org/apache/commons/codec/language/bm/PhoneticEnginePerformanceTest.java\n /**\n  * Tests performance for {@link PhoneticEngine}.\n  * <p>\n- * See <a href=\"https://issues.apache.org/jira/browse/CODEC-174\">[CODEC-174] Improve performance of Beider Morse encoder</a>.\n+ * See <a href=\"https://issues.apache.org/jira/browse/CODEC-174\">[CODEC-174] Improve performance of Beider Morse\n+ * encoder</a>.\n  * </p>\n  * <p>\n- * Results for November 7, 2013, SVN revision 1539678.\n+ * Results for November 7, 2013, project SVN revision 1539678.\n  * </p>\n  * <ol>\n  * <li>Time for encoding 80,000 times the input 'Angelo': 33,039 millis.</li>\n  * <li>Time for encoding 80,000 times the input 'Angelo': 32,297 millis.</li>\n  * <li>Time for encoding 80,000 times the input 'Angelo': 32,857 millis.</li>\n- * <li>Time for encoding 80,000 times the input 'Angelo': 31,561 millis.</li>\n+ * <li>Time for encoding 80,000 times the input 'Angelo': <b>31,561 millis.</b></li>\n  * <li>Time for encoding 80,000 times the input 'Angelo': 32,665 millis.</li>\n  * <li>Time for encoding 80,000 times the input 'Angelo': 32,215 millis.</li>\n+ * </ol>\n+ * <p>\n+ * On this file's revision 1539678, with patch <a\n+ * href=\"https://issues.apache.org/jira/secure/attachment/12611963/CODEC-174-change-rules-storage-to-Map.patch\"\n+ * >CODEC-174-change-rules-storage-to-Map</a>:\n+ * </p>\n+ * <ol>\n+ * <li>Time for encoding 80,000 times the input 'Angelo': 18,196 millis.</li>\n+ * <li>Time for encoding 80,000 times the input 'Angelo': 13,858 millis.</li>\n+ * <li>Time for encoding 80,000 times the input 'Angelo': 13,644 millis.</li>\n+ * <li>Time for encoding 80,000 times the input 'Angelo': <b>13,591 millis.</b></li>\n+ * <li>Time for encoding 80,000 times the input 'Angelo': 13,861 millis.</li>\n+ * <li>Time for encoding 80,000 times the input 'Angelo': 13,696 millis.</li>\n  * </ol>\n  */\n public class PhoneticEnginePerformanceTest {", "timestamp": 1383854047, "metainfo": ""}