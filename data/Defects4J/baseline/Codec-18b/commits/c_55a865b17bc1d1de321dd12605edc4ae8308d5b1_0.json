{"sha": "55a865b17bc1d1de321dd12605edc4ae8308d5b1", "log": "Fix checkstyle warnings.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/StringEncoderComparator.java\n+++ b/src/main/java/org/apache/commons/codec/StringEncoderComparator.java\n  *\n  * @version $Id$\n  */\n+@SuppressWarnings(\"rawtypes\")\n public class StringEncoderComparator implements Comparator {\n \n     /**\n      * @return the Comparable.compareTo() return code or 0 if an encoding error was caught.\n      * @see Comparable\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public int compare(final Object o1, final Object o2) {\n \n--- a/src/main/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java\n      * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position\n      */\n     @Override\n-    void decode(final byte[] in, int inPos, final int inAvail, final Context context) { // package protected for access from I/O streams\n+    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\n+        // package protected for access from I/O streams\n+\n         if (context.eof) {\n             return;\n         }\n      * @param context the context to be used\n      */\n     @Override\n-    void encode(final byte[] in, int inPos, final int inAvail, final Context context) { // package protected for access from I/O streams\n+    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\n+        // package protected for access from I/O streams\n+\n         if (context.eof) {\n             return;\n         }\n--- a/src/main/java/org/apache/commons/codec/binary/Base32InputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32InputStream.java\n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n      *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n-    public Base32InputStream(final InputStream in, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {\n+    public Base32InputStream(final InputStream in, final boolean doEncode,\n+                             final int lineLength, final byte[] lineSeparator) {\n         super(in, new Base32(lineLength, lineSeparator), doEncode);\n     }\n \n--- a/src/main/java/org/apache/commons/codec/binary/Base32OutputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32OutputStream.java\n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n      *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n-    public Base32OutputStream(final OutputStream out, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {\n+    public Base32OutputStream(final OutputStream out, final boolean doEncode,\n+                              final int lineLength, final byte[] lineSeparator) {\n         super(out, new Base32(lineLength, lineSeparator), doEncode);\n     }\n \n--- a/src/main/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64.java\n      *             Thrown when the input array needs an output array bigger than maxResultSize\n      * @since 1.4\n      */\n-    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe, final int maxResultSize) {\n+    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,\n+                                      final boolean urlSafe, final int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n--- a/src/main/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64InputStream.java\n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n      *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n-    public Base64InputStream(final InputStream in, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {\n+    public Base64InputStream(final InputStream in, final boolean doEncode,\n+                             final int lineLength, final byte[] lineSeparator) {\n         super(in, new Base64(lineLength, lineSeparator), doEncode);\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64OutputStream.java\n      *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n      *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n-    public Base64OutputStream(final OutputStream out, final boolean doEncode, final int lineLength, final byte[] lineSeparator) {\n+    public Base64OutputStream(final OutputStream out, final boolean doEncode,\n+                              final int lineLength, final byte[] lineSeparator) {\n         super(out, new Base64(lineLength, lineSeparator), doEncode);\n     }\n }\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n      * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\n      * @param chunkSeparatorLength the chunk separator length, if relevant\n      */\n-    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength) {\n+    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,\n+                         final int lineLength, final int chunkSeparatorLength) {\n         this.unencodedBlockSize = unencodedBlockSize;\n         this.encodedBlockSize = encodedBlockSize;\n         final boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n         return getBytes(string, Charsets.UTF_8);\n     }\n \n-    private static IllegalStateException newIllegalStateException(final String charsetName, final UnsupportedEncodingException e) {\n+    private static IllegalStateException newIllegalStateException(final String charsetName,\n+                                                                  final UnsupportedEncodingException e) {\n         return new IllegalStateException(charsetName + \": \" + e);\n     }\n \n--- a/src/main/java/org/apache/commons/codec/digest/B64.java\n+++ b/src/main/java/org/apache/commons/codec/digest/B64.java\n      * @param buffer\n      *            Where the output chars is appended to.\n      */\n-    static void b64from24bit(final byte b2, final byte b1, final byte b0, final int outLen, final StringBuilder buffer) {\n+    static void b64from24bit(final byte b2, final byte b1, final byte b0, final int outLen,\n+                             final StringBuilder buffer) {\n         // The bit masking is necessary because the JVM byte type is signed!\n         int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff);\n         // It's effectively a \"for\" loop but kept to resemble the original C code.\n--- a/src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java\n+++ b/src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java\n      *             when a {@link NoSuchAlgorithmException} is caught\n      * @see MessageDigestAlgorithms\n      */\n-    private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {\n+    private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix,\n+                                    final int blocksize, final String algorithm) {\n \n         final int keyLen = keyBytes.length;\n \n--- a/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\n+++ b/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\n     /**\n      * Handles 'G' cases.\n      */\n-    private int handleG(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\n+    private int handleG(final String value, final DoubleMetaphoneResult result, int index,\n+                        final boolean slavoGermanic) {\n         if (charAt(value, index + 1) == 'H') {\n             index = handleGH(value, result, index);\n         } else if (charAt(value, index + 1) == 'N') {\n     /**\n      * Handles 'J' cases.\n      */\n-    private int handleJ(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\n+    private int handleJ(final String value, final DoubleMetaphoneResult result, int index,\n+                        final boolean slavoGermanic) {\n         if (contains(value, index, 4, \"JOSE\") || contains(value, 0, 4, \"SAN \")) {\n                 //-- obvious Spanish, \"Jose\", \"San Jacinto\" --//\n                 if ((index == 0 && (charAt(value, index + 4) == ' ') ||\n     /**\n      * Handles 'R' cases.\n      */\n-    private int handleR(final String value, final DoubleMetaphoneResult result, final int index, final boolean slavoGermanic) {\n+    private int handleR(final String value, final DoubleMetaphoneResult result, final int index,\n+                        final boolean slavoGermanic) {\n         if (index == value.length() - 1 && !slavoGermanic &&\n             contains(value, index - 2, 2, \"IE\") &&\n             !contains(value, index - 4, 2, \"ME\", \"MA\")) {\n     /**\n      * Handles 'S' cases.\n      */\n-    private int handleS(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\n+    private int handleS(final String value, final DoubleMetaphoneResult result, int index,\n+                        final boolean slavoGermanic) {\n         if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n             //-- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\n             index++;\n     /**\n      * Handles 'Z' cases.\n      */\n-    private int handleZ(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\n+    private int handleZ(final String value, final DoubleMetaphoneResult result, int index,\n+                        final boolean slavoGermanic) {\n         if (charAt(value, index + 1) == 'H') {\n             //-- Chinese pinyin e.g. \"zhao\" or Angelina \"Zhang\" --//\n             result.append('J');\n--- a/src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java\n+++ b/src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n  *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n     /**\n      * Constants used mainly for the min rating value.\n      */\n-    private static final int ONE = 1, TWO = 2, THREE = 3, FOUR = 4, FIVE = 5, SIX = 6, SEVEN = 7, EIGHT = 8, ELEVEN = 11, TWELVE = 12;\n+    private static final int ONE = 1, TWO = 2, THREE = 3, FOUR = 4, FIVE = 5, SIX = 6, SEVEN = 7, EIGHT = 8,\n+                             ELEVEN = 11, TWELVE = 12;\n \n     /**\n      * The plain letter equivalent of the accented letters.\n      */\n-    private static final String PLAIN_ASCII = \"AaEeIiOoUu\" // grave\n-            + \"AaEeIiOoUuYy\" // acute\n-            + \"AaEeIiOoUuYy\" // circumflex\n-            + \"AaOoNn\" // tilde\n-            + \"AaEeIiOoUuYy\" // umlaut\n-            + \"Aa\" // ring\n-            + \"Cc\" // cedilla\n-            + \"OoUu\"; // double acute\n+    private static final String PLAIN_ASCII = \"AaEeIiOoUu\" + // grave\n+            \"AaEeIiOoUuYy\" + // acute\n+            \"AaEeIiOoUuYy\" + // circumflex\n+            \"AaOoNn\" + // tilde\n+            \"AaEeIiOoUuYy\" + // umlaut\n+            \"Aa\" + // ring\n+            \"Cc\" + // cedilla\n+            \"OoUu\"; // double acute\n \n     /**\n      * Unicode characters corresponding to various accented letters. For example: \\u00DA is U acute etc...\n      */\n-    private static final String UNICODE = \"\\u00C0\\u00E0\\u00C8\\u00E8\\u00CC\\u00EC\\u00D2\\u00F2\\u00D9\\u00F9\"\n-            + \"\\u00C1\\u00E1\\u00C9\\u00E9\\u00CD\\u00ED\\u00D3\\u00F3\\u00DA\\u00FA\\u00DD\\u00FD\"\n-            + \"\\u00C2\\u00E2\\u00CA\\u00EA\\u00CE\\u00EE\\u00D4\\u00F4\\u00DB\\u00FB\\u0176\\u0177\" + \"\\u00C3\\u00E3\\u00D5\\u00F5\\u00D1\\u00F1\"\n-            + \"\\u00C4\\u00E4\\u00CB\\u00EB\\u00CF\\u00EF\\u00D6\\u00F6\\u00DC\\u00FC\\u0178\\u00FF\" + \"\\u00C5\\u00E5\" + \"\\u00C7\\u00E7\"\n-            + \"\\u0150\\u0151\\u0170\\u0171\";\n-\n-    private static final String[] DOUBLE_CONSONANT = new String[] { \"BB\", \"CC\", \"DD\", \"FF\", \"GG\", \"HH\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"PP\", \"QQ\", \"RR\", \"SS\", \"TT\", \"VV\",\n-            \"WW\", \"XX\", \"YY\", \"ZZ\" };\n+    private static final String UNICODE = \"\\u00C0\\u00E0\\u00C8\\u00E8\\u00CC\\u00EC\\u00D2\\u00F2\\u00D9\\u00F9\" +\n+            \"\\u00C1\\u00E1\\u00C9\\u00E9\\u00CD\\u00ED\\u00D3\\u00F3\\u00DA\\u00FA\\u00DD\\u00FD\" +\n+            \"\\u00C2\\u00E2\\u00CA\\u00EA\\u00CE\\u00EE\\u00D4\\u00F4\\u00DB\\u00FB\\u0176\\u0177\" +\n+            \"\\u00C3\\u00E3\\u00D5\\u00F5\\u00D1\\u00F1\" +\n+            \"\\u00C4\\u00E4\\u00CB\\u00EB\\u00CF\\u00EF\\u00D6\\u00F6\\u00DC\\u00FC\\u0178\\u00FF\" +\n+            \"\\u00C5\\u00E5\" + \"\\u00C7\\u00E7\" + \"\\u0150\\u0151\\u0170\\u0171\";\n+\n+    private static final String[] DOUBLE_CONSONANT =\n+            new String[] { \"BB\", \"CC\", \"DD\", \"FF\", \"GG\", \"HH\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"PP\", \"QQ\", \"RR\", \"SS\",\n+                           \"TT\", \"VV\", \"WW\", \"XX\", \"YY\", \"ZZ\" };\n \n     /**\n      * Cleans up a name: 1. Upper-cases everything 2. Removes some common punctuation 3. Removes accents 4. Removes any\n     @Override\n     public final Object encode(final Object pObject) throws EncoderException {\n         if (!(pObject instanceof String)) {\n-            throw new EncoderException(\"Parameter supplied to Match Rating Approach encoder is not of type java.lang.String\");\n+            throw new EncoderException(\n+                    \"Parameter supplied to Match Rating Approach encoder is not of type java.lang.String\");\n         }\n         return encode((String) pObject);\n     }\n      * @return True if a vowel, else false\n      */\n     boolean isVowel(final String letter) {\n-        return letter.equalsIgnoreCase(\"E\") || letter.equalsIgnoreCase(\"A\") || letter.equalsIgnoreCase(\"O\") || letter.equalsIgnoreCase(\"I\") ||\n-                letter.equalsIgnoreCase(\"U\");\n+        return letter.equalsIgnoreCase(\"E\") || letter.equalsIgnoreCase(\"A\") || letter.equalsIgnoreCase(\"O\") ||\n+               letter.equalsIgnoreCase(\"I\") || letter.equalsIgnoreCase(\"U\");\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n      *            the maximum number of phonemes that will be handled\n      * @since 1.7\n      */\n-    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat, final int maxPhonemes) {\n+    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat,\n+                          final int maxPhonemes) {\n         if (ruleType == RuleType.RULES) {\n             throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES);\n         }\n--- a/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n \n     static {\n         for (final NameType s : NameType.values()) {\n-            final Map<RuleType, Map<String, List<Rule>>> rts = new EnumMap<RuleType, Map<String, List<Rule>>>(RuleType.class);\n+            final Map<RuleType, Map<String, List<Rule>>> rts =\n+                    new EnumMap<RuleType, Map<String, List<Rule>>>(RuleType.class);\n \n             for (final RuleType rt : RuleType.values()) {\n                 final Map<String, List<Rule>> rs = new HashMap<String, List<Rule>>();\n      *            the set of languages to consider\n      * @return a list of Rules that apply\n      */\n-    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs) {\n+    public static List<Rule> getInstance(final NameType nameType, final RuleType rt,\n+                                         final Languages.LanguageSet langs) {\n         return langs.isSingleton() ? getInstance(nameType, rt, langs.getAny()) :\n                                      getInstance(nameType, rt, Languages.ANY);\n     }", "timestamp": 1358604592, "metainfo": ""}