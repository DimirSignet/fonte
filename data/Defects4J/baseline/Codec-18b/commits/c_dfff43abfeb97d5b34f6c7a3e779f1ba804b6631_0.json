{"sha": "dfff43abfeb97d5b34f6c7a3e779f1ba804b6631", "log": "Sort methods AB.  ", "commit": "\n--- a/src/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n     }\n \n     /**\n-     * Gets the Lang language guessing rules being used.\n-     * \n-     * @return the Lang in use\n-     */\n-    public Lang getLang() {\n-        return this.lang;\n-    }\n-\n-    /**\n-     * Gets the NameType being used.\n-     * \n-     * @return the NameType in use\n-     */\n-    public NameType getNameType() {\n-        return this.nameType;\n-    }\n-\n-    /**\n-     * Gets the RuleType being used.\n-     * \n-     * @return the RuleType in use\n-     */\n-    public RuleType getRuleType() {\n-        return this.ruleType;\n-    }\n-\n-    /**\n-     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n-     * \n-     * @return true if multiple phonetic encodings are returned, false if just the first is.\n-     */\n-    public boolean isConcat() {\n-        return this.concat;\n-    }\n-\n-    /**\n      * Encodes an input string into an output phonetic representation, given a set of possible origin languages.\n      * \n      * @param input\n \n         return phonemeBuilder.makeString();\n     }\n+\n+    /**\n+     * Gets the Lang language guessing rules being used.\n+     * \n+     * @return the Lang in use\n+     */\n+    public Lang getLang() {\n+        return this.lang;\n+    }\n+\n+    /**\n+     * Gets the NameType being used.\n+     * \n+     * @return the NameType in use\n+     */\n+    public NameType getNameType() {\n+        return this.nameType;\n+    }\n+\n+    /**\n+     * Gets the RuleType being used.\n+     * \n+     * @return the RuleType in use\n+     */\n+    public RuleType getRuleType() {\n+        return this.ruleType;\n+    }\n+\n+    /**\n+     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n+     * \n+     * @return true if multiple phonetic encodings are returned, false if just the first is.\n+     */\n+    public boolean isConcat() {\n+        return this.concat;\n+    }\n }\n--- a/src/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/java/org/apache/commons/codec/language/bm/Rule.java\n  */\n public class Rule {\n \n+    private static class AppendableCharSeqeuence implements CharSequence {\n+        \n+        private final CharSequence left;\n+        private final CharSequence right;\n+        private final int length;\n+        private String contentCache = null;\n+\n+        private AppendableCharSeqeuence(CharSequence left, CharSequence right) {\n+            this.left = left;\n+            this.right = right;\n+            this.length = left.length() + right.length();\n+        }\n+\n+        public void buildString(StringBuilder sb) {\n+            if (left instanceof AppendableCharSeqeuence) {\n+                ((AppendableCharSeqeuence) left).buildString(sb);\n+            } else {\n+                sb.append(left);\n+            }\n+            if (right instanceof AppendableCharSeqeuence) {\n+                ((AppendableCharSeqeuence) right).buildString(sb);\n+            } else {\n+                sb.append(right);\n+            }\n+        }\n+\n+        public char charAt(int index) {\n+            // int lLength = left.length();\n+            // if(index < lLength) return left.charAt(index);\n+            // else return right.charAt(index - lLength);\n+            return toString().charAt(index);\n+        }\n+\n+        public int length() {\n+            return length;\n+        }\n+\n+        public CharSequence subSequence(int start, int end) {\n+            // int lLength = left.length();\n+            // if(start > lLength) return right.subSequence(start - lLength, end - lLength);\n+            // else if(end <= lLength) return left.subSequence(start, end);\n+            // else {\n+            // CharSequence newLeft = left.subSequence(start, lLength);\n+            // CharSequence newRight = right.subSequence(0, end - lLength);\n+            // return new AppendableCharSeqeuence(newLeft, newRight);\n+            // }\n+            return toString().subSequence(start, end);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (contentCache == null) {\n+                StringBuilder sb = new StringBuilder();\n+                buildString(sb);\n+                contentCache = sb.toString();\n+                // System.err.println(\"Materialized string: \" + contentCache);\n+            }\n+            return contentCache;\n+        }\n+    }\n+\n     public static class Phoneme implements PhonemeExpr, Comparable<Phoneme> {\n \n         private final CharSequence phonemeText;\n \n         public Phoneme append(CharSequence str) {\n             return new Phoneme(new AppendableCharSeqeuence(this.phonemeText, str), this.languages);\n-        }\n-\n-        public Languages.LanguageSet getLanguages() {\n-            return this.languages;\n-        }\n-\n-        public Iterable<Phoneme> getPhonemes() {\n-            return Collections.singleton(this);\n-        }\n-\n-        public CharSequence getPhonemeText() {\n-            return this.phonemeText;\n-        }\n-\n-        public Phoneme join(Phoneme right) {\n-            return new Phoneme(new AppendableCharSeqeuence(this.phonemeText, right.phonemeText), this.languages.restrictTo(right.languages));\n         }\n \n         public int compareTo(Phoneme o) {\n \n             return 0;\n         }\n+\n+        public Languages.LanguageSet getLanguages() {\n+            return this.languages;\n+        }\n+\n+        public Iterable<Phoneme> getPhonemes() {\n+            return Collections.singleton(this);\n+        }\n+\n+        public CharSequence getPhonemeText() {\n+            return this.phonemeText;\n+        }\n+\n+        public Phoneme join(Phoneme right) {\n+            return new Phoneme(new AppendableCharSeqeuence(this.phonemeText, right.phonemeText), this.languages.restrictTo(right.languages));\n+        }\n     }\n \n     public interface PhonemeExpr {\n         public List<Phoneme> getPhonemes() {\n             return this.phonemes;\n         }\n+    }\n+\n+    /**\n+     * A minimal wrapper around the functionality of Matcher that we use, to allow for alternate implementations.\n+     */\n+    public static interface RMatcher {\n+        public boolean find();\n+    }\n+\n+    /**\n+     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\n+     */\n+    public static interface RPattern {\n+        public RMatcher matcher(CharSequence input);\n     }\n \n     public static final String ALL = \"ALL\";\n         }\n     }\n \n+    private static boolean contains(CharSequence chars, char input) {\n+        for (int i = 0; i < chars.length(); i++) {\n+            if (chars.charAt(i) == input) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     private static String createResourceName(NameType nameType, RuleType rt, String lang) {\n         return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\", nameType.getName(), rt.getName(), lang);\n     }\n         }\n \n         return new Scanner(rulesIS, ResourceConstants.ENCODING);\n+    }\n+\n+    private static boolean endsWith(CharSequence input, CharSequence suffix) {\n+        if (suffix.length() > input.length()) {\n+            return false;\n+        }\n+        for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) {\n+            if (input.charAt(i) != suffix.charAt(j)) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n         }\n \n         return lines;\n-    }\n-\n-    private static String stripQuotes(String str) {\n-        if (str.startsWith(DOUBLE_QUOTE)) {\n-            str = str.substring(1);\n-        }\n-\n-        if (str.endsWith(DOUBLE_QUOTE)) {\n-            str = str.substring(0, str.length() - 1);\n-        }\n-\n-        return str;\n-    }\n-\n-    private final RPattern lContext;\n-\n-    private final String pattern;\n-\n-    private final PhonemeExpr phoneme;\n-\n-    private final RPattern rContext;\n-\n-    /**\n-     * Creates a new rule.\n-     * \n-     * @param pattern\n-     *            the pattern\n-     * @param lContext\n-     *            the left context\n-     * @param rContext\n-     *            the right context\n-     * @param phoneme\n-     *            the resulting phoneme\n-     */\n-    public Rule(String pattern, String lContext, String rContext, PhonemeExpr phoneme) {\n-        this.pattern = pattern;\n-        this.lContext = pattern(lContext + \"$\");\n-        this.rContext = pattern(\"^\" + rContext);\n-        this.phoneme = phoneme;\n-    }\n-\n-    /**\n-     * Gets the left context. This is a regular expression that must match to the left of the pattern.\n-     * \n-     * @return the left context Pattern\n-     */\n-    public RPattern getLContext() {\n-        return this.lContext;\n-    }\n-\n-    /**\n-     * Gets the pattern. This is a string-literal that must exactly match.\n-     * \n-     * @return the pattern\n-     */\n-    public String getPattern() {\n-        return this.pattern;\n-    }\n-\n-    /**\n-     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n-     * \n-     * @return the phoneme\n-     */\n-    public PhonemeExpr getPhoneme() {\n-        return this.phoneme;\n-    }\n-\n-    /**\n-     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n-     * \n-     * @return the right context Pattern\n-     */\n-    public RPattern getRContext() {\n-        return this.rContext;\n-    }\n-\n-    /**\n-     * Decides if the pattern and context match the input starting at a position.\n-     * \n-     * @param input\n-     *            the input String\n-     * @param i\n-     *            the int position within the input\n-     * @return true if the pattern and left/right context match, false otherwise\n-     */\n-    public boolean patternAndContextMatches(CharSequence input, int i) {\n-        if (i < 0)\n-            throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n-\n-        int patternLength = this.pattern.length();\n-        int ipl = i + patternLength;\n-\n-        if (ipl > input.length()) {\n-            // not enough room for the pattern to match\n-            return false;\n-        }\n-\n-        boolean patternMatches = input.subSequence(i, ipl).equals(this.pattern);\n-        boolean rContextMatches = this.rContext.matcher(input.subSequence(ipl, input.length())).find();\n-        boolean lContextMatches = this.lContext.matcher(input.subSequence(0, i)).find();\n-\n-        return patternMatches && rContextMatches && lContextMatches;\n-    }\n-\n-    /**\n-     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\n-     */\n-    public static interface RPattern {\n-        public RMatcher matcher(CharSequence input);\n-    }\n-\n-    /**\n-     * A minimal wrapper around the functionality of Matcher that we use, to allow for alternate implementations.\n-     */\n-    public static interface RMatcher {\n-        public boolean find();\n     }\n \n     /**\n         return true;\n     }\n \n-    private static boolean endsWith(CharSequence input, CharSequence suffix) {\n-        if (suffix.length() > input.length()) {\n+    private static String stripQuotes(String str) {\n+        if (str.startsWith(DOUBLE_QUOTE)) {\n+            str = str.substring(1);\n+        }\n+\n+        if (str.endsWith(DOUBLE_QUOTE)) {\n+            str = str.substring(0, str.length() - 1);\n+        }\n+\n+        return str;\n+    }\n+\n+    private final RPattern lContext;\n+\n+    private final String pattern;\n+\n+    private final PhonemeExpr phoneme;\n+\n+    private final RPattern rContext;\n+\n+    /**\n+     * Creates a new rule.\n+     * \n+     * @param pattern\n+     *            the pattern\n+     * @param lContext\n+     *            the left context\n+     * @param rContext\n+     *            the right context\n+     * @param phoneme\n+     *            the resulting phoneme\n+     */\n+    public Rule(String pattern, String lContext, String rContext, PhonemeExpr phoneme) {\n+        this.pattern = pattern;\n+        this.lContext = pattern(lContext + \"$\");\n+        this.rContext = pattern(\"^\" + rContext);\n+        this.phoneme = phoneme;\n+    }\n+\n+    /**\n+     * Gets the left context. This is a regular expression that must match to the left of the pattern.\n+     * \n+     * @return the left context Pattern\n+     */\n+    public RPattern getLContext() {\n+        return this.lContext;\n+    }\n+\n+    /**\n+     * Gets the pattern. This is a string-literal that must exactly match.\n+     * \n+     * @return the pattern\n+     */\n+    public String getPattern() {\n+        return this.pattern;\n+    }\n+\n+    /**\n+     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n+     * \n+     * @return the phoneme\n+     */\n+    public PhonemeExpr getPhoneme() {\n+        return this.phoneme;\n+    }\n+\n+    /**\n+     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n+     * \n+     * @return the right context Pattern\n+     */\n+    public RPattern getRContext() {\n+        return this.rContext;\n+    }\n+\n+    /**\n+     * Decides if the pattern and context match the input starting at a position.\n+     * \n+     * @param input\n+     *            the input String\n+     * @param i\n+     *            the int position within the input\n+     * @return true if the pattern and left/right context match, false otherwise\n+     */\n+    public boolean patternAndContextMatches(CharSequence input, int i) {\n+        if (i < 0)\n+            throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n+\n+        int patternLength = this.pattern.length();\n+        int ipl = i + patternLength;\n+\n+        if (ipl > input.length()) {\n+            // not enough room for the pattern to match\n             return false;\n         }\n-        for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) {\n-            if (input.charAt(i) != suffix.charAt(j)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private static boolean contains(CharSequence chars, char input) {\n-        for (int i = 0; i < chars.length(); i++) {\n-            if (chars.charAt(i) == input) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private static class AppendableCharSeqeuence implements CharSequence {\n-        \n-        private final CharSequence left;\n-        private final CharSequence right;\n-        private final int length;\n-        private String contentCache = null;\n-\n-        private AppendableCharSeqeuence(CharSequence left, CharSequence right) {\n-            this.left = left;\n-            this.right = right;\n-            this.length = left.length() + right.length();\n-        }\n-\n-        public int length() {\n-            return length;\n-        }\n-\n-        public char charAt(int index) {\n-            // int lLength = left.length();\n-            // if(index < lLength) return left.charAt(index);\n-            // else return right.charAt(index - lLength);\n-            return toString().charAt(index);\n-        }\n-\n-        public CharSequence subSequence(int start, int end) {\n-            // int lLength = left.length();\n-            // if(start > lLength) return right.subSequence(start - lLength, end - lLength);\n-            // else if(end <= lLength) return left.subSequence(start, end);\n-            // else {\n-            // CharSequence newLeft = left.subSequence(start, lLength);\n-            // CharSequence newRight = right.subSequence(0, end - lLength);\n-            // return new AppendableCharSeqeuence(newLeft, newRight);\n-            // }\n-            return toString().subSequence(start, end);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            if (contentCache == null) {\n-                StringBuilder sb = new StringBuilder();\n-                buildString(sb);\n-                contentCache = sb.toString();\n-                // System.err.println(\"Materialized string: \" + contentCache);\n-            }\n-            return contentCache;\n-        }\n-\n-        public void buildString(StringBuilder sb) {\n-            if (left instanceof AppendableCharSeqeuence) {\n-                ((AppendableCharSeqeuence) left).buildString(sb);\n-            } else {\n-                sb.append(left);\n-            }\n-            if (right instanceof AppendableCharSeqeuence) {\n-                ((AppendableCharSeqeuence) right).buildString(sb);\n-            } else {\n-                sb.append(right);\n-            }\n-        }\n+\n+        boolean patternMatches = input.subSequence(i, ipl).equals(this.pattern);\n+        boolean rContextMatches = this.rContext.matcher(input.subSequence(ipl, input.length())).find();\n+        boolean lContextMatches = this.lContext.matcher(input.subSequence(0, i)).find();\n+\n+        return patternMatches && rContextMatches && lContextMatches;\n     }\n }", "timestamp": 1312598191, "metainfo": ""}