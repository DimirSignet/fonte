{"sha": "35cbae7087f2fef6dcf38c3d4fcac0b4d62cb1eb", "log": "[CODEC-129] Use standard Maven directory layout.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/BinaryDecoder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+/**\n+ * Defines common decoding methods for byte array decoders.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public interface BinaryDecoder extends Decoder {\n+\n+    /**\n+     * Decodes a byte array and returns the results as a byte array. \n+     *\n+     * @param source A byte array which has been encoded with the\n+     *      appropriate encoder\n+     * \n+     * @return a byte array that contains decoded content\n+     * \n+     * @throws DecoderException A decoder exception is thrown\n+     *          if a Decoder encounters a failure condition during\n+     *          the decode process.\n+     */\n+    byte[] decode(byte[] source) throws DecoderException;\n+}  \n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/BinaryEncoder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+/**\n+ * Defines common encoding methods for byte array encoders.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public interface BinaryEncoder extends Encoder {\n+    \n+    /**\n+     * Encodes a byte array and return the encoded data\n+     * as a byte array.\n+     * \n+     * @param source Data to be encoded\n+     *\n+     * @return A byte array containing the encoded data\n+     * \n+     * @throws EncoderException thrown if the Encoder\n+     *      encounters a failure condition during the\n+     *      encoding process.\n+     */\n+    byte[] encode(byte[] source) throws EncoderException;\n+}  \n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/CharEncoding.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+/**\n+ * Character encoding names required of every implementation of the Java platform.\n+ * \n+ * From the Java documentation <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard\n+ * charsets</a>:\n+ * <p>\n+ * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n+ * release documentation for your implementation to see if any other encodings are supported. Consult the release\n+ * documentation for your implementation to see if any other encodings are supported. </cite>\n+ * </p>\n+ * \n+ * <ul>\n+ * <li><code>US-ASCII</code><br/>\n+ * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</li>\n+ * <li><code>ISO-8859-1</code><br/>\n+ * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</li>\n+ * <li><code>UTF-8</code><br/>\n+ * Eight-bit Unicode Transformation Format.</li>\n+ * <li><code>UTF-16BE</code><br/>\n+ * Sixteen-bit Unicode Transformation Format, big-endian byte order.</li>\n+ * <li><code>UTF-16LE</code><br/>\n+ * Sixteen-bit Unicode Transformation Format, little-endian byte order.</li>\n+ * <li><code>UTF-16</code><br/>\n+ * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n+ * accepted on input, big-endian used on output.)</li>\n+ * </ul>\n+ * \n+ * This perhaps would best belong in the [lang] project. Even if a similar interface is defined in [lang], it is not\n+ * foreseen that [codec] would be made to depend on [lang].\n+ * \n+ * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+ * @author Apache Software Foundation\n+ * @since 1.4\n+ * @version $Id$\n+ */\n+public class CharEncoding {\n+    /**\n+     * CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1. </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String ISO_8859_1 = \"ISO-8859-1\";\n+\n+    /**\n+     * <p>\n+     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String US_ASCII = \"US-ASCII\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n+     * (either order accepted on input, big-endian used on output)\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String UTF_16 = \"UTF-16\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String UTF_16BE = \"UTF-16BE\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String UTF_16LE = \"UTF-16LE\";\n+\n+    /**\n+     * <p>\n+     * Eight-bit Unicode Transformation Format.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public static final String UTF_8 = \"UTF-8\";\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/Decoder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+/**\n+ * <p>Provides the highest level of abstraction for Decoders.\n+ * This is the sister interface of {@link Encoder}.  All\n+ * Decoders implement this common generic interface.</p>\n+ * \n+ * <p>Allows a user to pass a generic Object to any Decoder \n+ * implementation in the codec package.</p>\n+ * \n+ * <p>One of the two interfaces at the center of the codec package.</p>\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public interface Decoder {\n+\n+    /**\n+     * Decodes an \"encoded\" Object and returns a \"decoded\"\n+     * Object.  Note that the implementation of this\n+     * interface will try to cast the Object parameter\n+     * to the specific type expected by a particular Decoder\n+     * implementation.  If a {@link ClassCastException} occurs\n+     * this decode method will throw a DecoderException.\n+     * \n+     * @param source the object to decode\n+     * \n+     * @return a 'decoded\" object\n+     * \n+     * @throws DecoderException a decoder exception can\n+     * be thrown for any number of reasons.  Some good\n+     * candidates are that the parameter passed to this\n+     * method is null, a param cannot be cast to the\n+     * appropriate type for a specific encoder.\n+     */\n+    Object decode(Object source) throws DecoderException;\n+}  \n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/DecoderException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+/**\n+ * Thrown when there is a failure condition during the decoding process. This exception is thrown when a {@link Decoder}\n+ * encounters a decoding specific exception such as invalid data, or characters outside of the expected range.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class DecoderException extends Exception {\n+\n+    /**\n+     * Declares the Serial Version Uid.\n+     * \n+     * @see <a href=\"http://c2.com/cgi/wiki?AlwaysDeclareSerialVersionUid\">Always Declare Serial Version Uid</a>\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\n+     * subsequently be initialized by a call to {@link #initCause}.\n+     * \n+     * @since 1.4\n+     */\n+    public DecoderException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n+     * be initialized by a call to {@link #initCause}.\n+     * \n+     * @param message\n+     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n+     */\n+    public DecoderException(String message) {\n+        super(message);\n+    }\n+\n+    /**\n+     * Constructsa new exception with the specified detail message and cause.\n+     * \n+     * <p>\n+     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n+     * exception's detail message.\n+     * </p>\n+     * \n+     * @param message\n+     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n+     * @param cause\n+     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n+     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n+     * @since 1.4\n+     */\n+    public DecoderException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    /**\n+     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n+     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n+     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n+     * \n+     * @param cause\n+     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n+     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n+     * @since 1.4\n+     */\n+    public DecoderException(Throwable cause) {\n+        super(cause);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/Encoder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+/**\n+ * <p>Provides the highest level of abstraction for Encoders.\n+ * This is the sister interface of {@link Decoder}.  Every implementation of\n+ * Encoder provides this common generic interface which allows a user to pass a \n+ * generic Object to any Encoder implementation in the codec package.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public interface Encoder {\n+    \n+    /**\n+     * Encodes an \"Object\" and returns the encoded content \n+     * as an Object.  The Objects here may just be <code>byte[]</code>\n+     * or <code>String</code>s depending on the implementation used.\n+     *   \n+     * @param source An object to encode\n+     * \n+     * @return An \"encoded\" Object\n+     * \n+     * @throws EncoderException an encoder exception is\n+     *  thrown if the encoder experiences a failure\n+     *  condition during the encoding process.\n+     */\n+    Object encode(Object source) throws EncoderException;\n+}  \n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/EncoderException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+/**\n+ * Thrown when there is a failure condition during the encoding process. This exception is thrown when an\n+ * {@link Encoder} encounters a encoding specific exception such as invalid data, inability to calculate a checksum,\n+ * characters outside of the expected range.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class EncoderException extends Exception {\n+\n+    /**\n+     * Declares the Serial Version Uid.\n+     * \n+     * @see <a href=\"http://c2.com/cgi/wiki?AlwaysDeclareSerialVersionUid\">Always Declare Serial Version Uid</a>\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\n+     * subsequently be initialized by a call to {@link #initCause}.\n+     * \n+     * @since 1.4\n+     */\n+    public EncoderException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n+     * be initialized by a call to {@link #initCause}.\n+     * \n+     * @param message\n+     *            a useful message relating to the encoder specific error.\n+     */\n+    public EncoderException(String message) {\n+        super(message);\n+    }\n+\n+    /**\n+     * Constructs a new exception with the specified detail message and cause.\n+     * \n+     * <p>\n+     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\n+     * exception's detail message.\n+     * </p>\n+     * \n+     * @param message\n+     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n+     * @param cause\n+     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n+     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n+     * @since 1.4\n+     */\n+    public EncoderException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    /**\n+     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n+     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\n+     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n+     * \n+     * @param cause\n+     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\n+     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n+     * @since 1.4\n+     */\n+    public EncoderException(Throwable cause) {\n+        super(cause);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/StringDecoder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+/**\n+ * Defines common decoding methods for String decoders.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public interface StringDecoder extends Decoder {\n+    \n+    /**\n+     * Decodes a String and returns a String.\n+     * \n+     * @param source the String to decode\n+     * \n+     * @return the encoded String\n+     * \n+     * @throws DecoderException thrown if there is\n+     *  an error condition during the Encoding process.\n+     */\n+    String decode(String source) throws DecoderException;\n+}  \n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/StringEncoder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+/**\n+ * Defines common encoding methods for String encoders.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public interface StringEncoder extends Encoder {\n+    \n+    /**\n+     * Encodes a String and returns a String.\n+     * \n+     * @param source the String to encode\n+     * \n+     * @return the encoded String\n+     * \n+     * @throws EncoderException thrown if there is\n+     *  an error condition during the encoding process.\n+     */\n+    String encode(String source) throws EncoderException;\n+}  \n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/StringEncoderComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+import java.util.Comparator;\n+\n+/**\n+ * Compares Strings using a {@link StringEncoder}. This comparator is used to sort Strings by an encoding scheme such as\n+ * Soundex, Metaphone, etc. This class can come in handy if one need to sort Strings by an encoded form of a name such\n+ * as Soundex.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class StringEncoderComparator implements Comparator {\n+\n+    /**\n+     * Internal encoder instance.\n+     */\n+    private final StringEncoder stringEncoder;\n+\n+    /**\n+     * Constructs a new instance with the given algorithm.\n+     * \n+     * @param stringEncoder\n+     *            the StringEncoder used for comparisons.\n+     */\n+    public StringEncoderComparator(StringEncoder stringEncoder) {\n+        this.stringEncoder = stringEncoder;\n+    }\n+\n+    /**\n+     * Compares two strings based not on the strings themselves, but on an encoding of the two strings using the\n+     * StringEncoder this Comparator was created with.\n+     * \n+     * If an {@link EncoderException} is encountered, return <code>0</code>.\n+     * \n+     * @param o1\n+     *            the object to compare\n+     * @param o2\n+     *            the object to compare to\n+     * @return the Comparable.compareTo() return code or 0 if an encoding error was caught.\n+     * @see Comparable\n+     */\n+    public int compare(Object o1, Object o2) {\n+\n+        int compareCode = 0;\n+\n+        try {\n+            Comparable s1 = (Comparable) this.stringEncoder.encode(o1);\n+            Comparable s2 = (Comparable) this.stringEncoder.encode(o2);\n+            compareCode = s1.compareTo(s2);\n+        } catch (EncoderException ee) {\n+            compareCode = 0;\n+        }\n+        return compareCode;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+/**\n+ * Provides Base32 encoding and decoding as defined by <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>.\n+ * \n+ * <p>\n+ * The class can be parameterized in the following manner with various constructors:\n+ * <ul>\n+ * <li>Whether to use the \"base32hex\" variant instead of the default \"base32\"</li>\n+ * <li>Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of\n+ * 8 in the encoded data.\n+ * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * This class operates directly on byte streams, and not character streams.\n+ * </p>\n+ * <p>\n+ * This class is not thread-safe. Each thread should use its own instance.\n+ * </p>\n+ * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n+ * \n+ * @since 1.5\n+ * @version $Revision$\n+ */\n+public class Base32 extends BaseNCodec {\n+\n+    /**\n+     * BASE32 characters are 5 bits in length. \n+     * They are formed by taking a block of five octets to form a 40-bit string, \n+     * which is converted into eight BASE32 characters.\n+     */\n+    private static final int BITS_PER_ENCODED_BYTE = 5;\n+    private static final int BYTES_PER_ENCODED_BLOCK = 8;\n+    private static final int BYTES_PER_UNENCODED_BLOCK = 5;\n+\n+    /**\n+     * Chunk separator per RFC 2045 section 2.1.\n+     *\n+     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n+     */\n+    private static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n+\n+    /**\n+     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 Alphabet\" (as specified in\n+     * Table 3 of RFC 2045) into their 5-bit positive integer equivalents. Characters that are not in the Base32\n+     * alphabet but fall within the bounds of the array are translated to -1.\n+     * \n+     */\n+    private static final byte[] DECODE_TABLE = {\n+         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 63, // 20-2f\n+            -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n+            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 40-4f A-N\n+            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,                     // 50-5a O-Z\n+    };\n+\n+    /**\n+     * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Alphabet\"\n+     * equivalents as specified in Table 3 of RFC 2045.\n+     */\n+    private static final byte[] ENCODE_TABLE = {\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            '2', '3', '4', '5', '6', '7',\n+    };\n+\n+    /**\n+     * This array is a lookup table that translates Unicode characters drawn from the \"Base32 |Hex Alphabet\" (as specified in\n+     * Table 3 of RFC 2045) into their 5-bit positive integer equivalents. Characters that are not in the Base32 Hex\n+     * alphabet but fall within the bounds of the array are translated to -1.\n+     * \n+     */\n+    private static final byte[] HEX_DECODE_TABLE = {\n+         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 63, // 20-2f\n+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n+            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-N\n+            25, 26, 27, 28, 29, 30, 31, 32,                                 // 50-57 O-V\n+    };\n+\n+    /**\n+     * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Hex Alphabet\"\n+     * equivalents as specified in Table 3 of RFC 2045.\n+     */\n+    private static final byte[] HEX_ENCODE_TABLE = {\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', \n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n+    };\n+\n+    /** Mask used to extract 5 bits, used when encoding Base32 bytes */\n+    private static final int MASK_5BITS = 0x1f;\n+\n+    // The static final fields above are used for the original static byte[] methods on Base32.\n+    // The private member fields below are used with the new streaming approach, which requires\n+    // some state be preserved between calls of encode() and decode().\n+\n+    /**\n+     * Place holder for the bytes we're dealing with for our based logic. \n+     * Bitwise operations store and extract the encoding or decoding from this variable.\n+     */\n+    private long bitWorkArea;\n+\n+    /**\n+     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n+     * <code>decodeSize = {@link #BYTES_PER_ENCODED_BLOCK} - 1 + lineSeparator.length;</code>\n+     */\n+    private final int decodeSize;\n+\n+    /**\n+     * Decode table to use.\n+     */\n+    private final byte[] decodeTable;\n+\n+    /**\n+     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n+     * <code>encodeSize = {@link #BYTES_PER_ENCODED_BLOCK} + lineSeparator.length;</code>\n+     */\n+    private final int encodeSize;\n+\n+    /**\n+     * Encode table to use.\n+     */\n+    private final byte[] encodeTable;\n+\n+    /**\n+     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n+     */\n+    private final byte[] lineSeparator;\n+\n+    /**\n+     * Creates a Base32 codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length is 0 (no chunking).\n+     * </p>\n+     * \n+     */\n+    public Base32() {\n+        this(false);\n+    }\n+\n+    /**\n+     * Creates a Base32 codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length is 0 (no chunking).\n+     * </p>\n+     * @param useHex if <code>true</code> then use Base32 Hex alphabet\n+     */\n+    public Base32(boolean useHex) {\n+        this(0, null, useHex);\n+    }\n+\n+    /**\n+     * Creates a Base32 codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length is given in the constructor, the line separator is CRLF.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 8).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     */\n+    public Base32(int lineLength) {\n+        this(lineLength, CHUNK_SEPARATOR);\n+    }\n+\n+    /**\n+     * Creates a Base32 codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length and line separator are given in the constructor.\n+     * </p>\n+     * <p>\n+     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 8).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     * @param lineSeparator\n+     *            Each line of encoded data will end with this sequence of bytes.\n+     * @throws IllegalArgumentException\n+     *             The provided lineSeparator included some Base32 characters. That's not going to work!\n+     */\n+    public Base32(int lineLength, byte[] lineSeparator) {\n+        this(lineLength, lineSeparator, false);\n+    }\n+    \n+    /**\n+     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\n+     * <p>\n+     * When encoding the line length and line separator are given in the constructor.\n+     * </p>\n+     * <p>\n+     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 8).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     * @param lineSeparator\n+     *            Each line of encoded data will end with this sequence of bytes.\n+     * @param useHex if <code>true</code>, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n+     * @throws IllegalArgumentException\n+     *             The provided lineSeparator included some Base32 characters. That's not going to work!\n+     *             Or the lineLength > 0 and lineSeparator is null.\n+     */\n+    public Base32(int lineLength, byte[] lineSeparator, boolean useHex) {\n+        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, \n+                lineLength, \n+                lineSeparator == null ? 0 : lineSeparator.length);\n+        if (useHex){\n+            this.encodeTable = HEX_ENCODE_TABLE;\n+            this.decodeTable = HEX_DECODE_TABLE;            \n+        } else {\n+            this.encodeTable = ENCODE_TABLE;\n+            this.decodeTable = DECODE_TABLE;            \n+        }\n+        if (lineLength > 0) {\n+            if (lineSeparator == null) {\n+                throw new IllegalArgumentException(\"lineLength \"+lineLength+\" > 0, but lineSeparator is null\");\n+            }\n+            // Must be done after initializing the tables\n+            if (containsAlphabetOrPad(lineSeparator)) {\n+                String sep = StringUtils.newStringUtf8(lineSeparator);\n+                throw new IllegalArgumentException(\"lineSeparator must not contain Base32 characters: [\" + sep + \"]\");\n+            }\n+            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n+            this.lineSeparator = new byte[lineSeparator.length];\n+            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n+        } else {\n+            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n+            this.lineSeparator = null;\n+        }\n+        this.decodeSize = this.encodeSize - 1;\n+    }\n+\n+    /**\n+     * <p>\n+     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n+     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n+     * call is not necessary when decoding, but it doesn't hurt, either.\n+     * </p>\n+     * <p>\n+     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n+     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n+     * garbage-out philosophy: it will not check the provided data for validity.\n+     * </p>\n+     * \n+     * @param in\n+     *            byte[] array of ascii data to Base32 decode.\n+     * @param inPos\n+     *            Position to start reading data from.\n+     * @param inAvail\n+     *            Amount of bytes available from input for encoding.\n+     *\n+     * Output is written to {@link #buffer} as 8-bit octets, using {@link #pos} as the buffer position\n+     */\n+    @Override\n+    void decode(byte[] in, int inPos, int inAvail) { // package protected for access from I/O streams\n+        if (eof) {\n+            return;\n+        }\n+        if (inAvail < 0) {\n+            eof = true;\n+        }\n+        for (int i = 0; i < inAvail; i++) {\n+            byte b = in[inPos++];\n+            if (b == PAD) {\n+                // We're done.\n+                eof = true;\n+                break;\n+            } else {\n+                ensureBufferSize(decodeSize);\n+                if (b >= 0 && b < this.decodeTable.length) {\n+                    int result = this.decodeTable[b];\n+                    if (result >= 0) {\n+                        modulus = (modulus+1) % BYTES_PER_ENCODED_BLOCK;\n+                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result; // collect decoded bytes\n+                        if (modulus == 0) { // we can output the 5 bytes\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                            buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    \n+        // Two forms of EOF as far as Base32 decoder is concerned: actual\n+        // EOF (-1) and first time '=' character is encountered in stream.\n+        // This approach makes the '=' padding characters completely optional.\n+        if (eof && modulus >= 2) { // if modulus < 2, nothing to do\n+            ensureBufferSize(decodeSize);\n+    \n+            //  we ignore partial bytes, i.e. only multiples of 8 count\n+            switch (modulus) {\n+                case 2 : // 10 bits, drop 2 and output one byte\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);\n+                    break;\n+                case 3 : // 15 bits, drop 7 and output 1 byte\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);\n+                    break;\n+                case 4 : // 20 bits = 2*8 + 4\n+                    bitWorkArea = bitWorkArea >> 4; // drop 4 bits\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    break;\n+                case 5 : // 25bits = 3*8 + 1\n+                    bitWorkArea = bitWorkArea >> 1;\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    break;\n+                case 6 : // 30bits = 3*8 + 6\n+                    bitWorkArea = bitWorkArea >> 6;\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    break;\n+                case 7 : // 35 = 4*8 +3\n+                    bitWorkArea = bitWorkArea >> 3;\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n+     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n+     * remaining bytes (if not multiple of 5).\n+     * </p>\n+     * \n+     * @param in\n+     *            byte[] array of binary data to Base32 encode.\n+     * @param inPos\n+     *            Position to start reading data from.\n+     * @param inAvail\n+     *            Amount of bytes available from input for encoding.\n+     */\n+    @Override\n+    void encode(byte[] in, int inPos, int inAvail) { // package protected for access from I/O streams\n+        if (eof) {\n+            return;\n+        }\n+        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n+        // encoding.\n+        if (inAvail < 0) {\n+            eof = true;\n+            if (0 == modulus && lineLength == 0) {\n+                return; // no leftovers to process and not using chunking\n+            }\n+            ensureBufferSize(encodeSize);\n+            int savedPos = pos;\n+            switch (modulus) { // % 5\n+                case 1 : // Only 1 octet; take top 5 bits then remainder\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; // 5-3=2\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    break;\n+    \n+                case 2 : // 2 octets = 16 bits to use\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    break;\n+                case 3 : // 3 octets = 24 bits to use\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    buffer[pos++] = PAD;\n+                    break;\n+                case 4 : // 4 octets = 32 bits to use\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\n+                    buffer[pos++] = PAD;\n+                    break;\n+            }\n+            currentLinePos += pos - savedPos; // keep track of current line position\n+            // if currentPos == 0 we are at the start of a line, so don't add CRLF\n+            if (lineLength > 0 && currentLinePos > 0){ // add chunk separator if required\n+                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n+                pos += lineSeparator.length;\n+            }            \n+        } else {\n+            for (int i = 0; i < inAvail; i++) {\n+                ensureBufferSize(encodeSize);\n+                modulus = (modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n+                int b = in[inPos++];\n+                if (b < 0) {\n+                    b += 256;\n+                }\n+                bitWorkArea = (bitWorkArea << 8) + b; // BITS_PER_BYTE\n+                if (0 == modulus) { // we have enough bytes to create our output \n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 35) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 30) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 25) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 20) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 15) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 10) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 5) & MASK_5BITS];\n+                    buffer[pos++] = encodeTable[(int)bitWorkArea & MASK_5BITS];\n+                    currentLinePos += BYTES_PER_ENCODED_BLOCK;\n+                    if (lineLength > 0 && lineLength <= currentLinePos) {\n+                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n+                        pos += lineSeparator.length;\n+                        currentLinePos = 0;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns whether or not the <code>octet</code> is in the Base32 alphabet.\n+     * \n+     * @param octet\n+     *            The value to test\n+     * @return <code>true</code> if the value is defined in the the Base32 alphabet <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean isInAlphabet(byte octet) {\n+        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32InputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.InputStream;\n+\n+/**\n+ * Provides Base32 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * constructor.\n+ * <p>\n+ * The default behaviour of the Base32InputStream is to DECODE, whereas the default behaviour of the Base32OutputStream\n+ * is to ENCODE, but this behaviour can be overridden by using a different constructor.\n+ * </p>\n+ * <p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * </p>\n+ * \n+ * @version $Revision$\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n+ * @since 1.5\n+ */\n+public class Base32InputStream extends BaseNCodecInputStream {\n+\n+    /**\n+     * Creates a Base32InputStream such that all data read is Base32-decoded from the original provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     */\n+    public Base32InputStream(InputStream in) {\n+        this(in, false);\n+    }\n+\n+    /**\n+     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n+     * provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data read from us, false if we should decode.\n+     */\n+    public Base32InputStream(InputStream in, boolean doEncode) {\n+        super(in, new Base32(false), doEncode);\n+    }\n+\n+    /**\n+     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n+     * provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data read from us, false if we should decode.\n+     * @param lineLength\n+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            false, lineLength is ignored.\n+     * @param lineSeparator\n+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n+     */\n+    public Base32InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+        super(in, new Base32(lineLength, lineSeparator), doEncode);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32OutputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.OutputStream;\n+\n+/**\n+ * Provides Base32 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * constructor.\n+ * <p>\n+ * The default behaviour of the Base32OutputStream is to ENCODE, whereas the default behaviour of the Base32InputStream\n+ * is to DECODE. But this behaviour can be overridden by using a different constructor.\n+ * </p>\n+ * <p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * </p>\n+ * \n+ * @version $Revision$\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n+ * @since 1.5\n+ */\n+public class Base32OutputStream extends BaseNCodecOutputStream {\n+\n+    /**\n+     * Creates a Base32OutputStream such that all data written is Base32-encoded to the original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     */\n+    public Base32OutputStream(OutputStream out) {\n+        this(out, true);\n+    }\n+\n+    /**\n+     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n+     * original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data written to us, false if we should decode.\n+     */\n+    public Base32OutputStream(OutputStream out, boolean doEncode) {\n+        super(out, new Base32(false), doEncode);\n+    }\n+\n+    /**\n+     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n+     * original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data written to us, false if we should decode.\n+     * @param lineLength\n+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            false, lineLength is ignored.\n+     * @param lineSeparator\n+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n+     */\n+    public Base32OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+        super(out, new Base32(lineLength, lineSeparator), doEncode);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.math.BigInteger;\n+\n+/**\n+ * Provides Base64 encoding and decoding as defined by <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>.\n+ * \n+ * <p>\n+ * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n+ * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n+ * </p>\n+ * <p>\n+ * The class can be parameterized in the following manner with various constructors:\n+ * <ul>\n+ * <li>URL-safe mode: Default off.</li>\n+ * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n+ * 4 in the encoded data.\n+ * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * </p>\n+ * <p>\n+ * This class is not thread-safe. Each thread should use its own instance.\n+ * </p>\n+ * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @author Apache Software Foundation\n+ * @since 1.0\n+ * @version $Revision$\n+ */\n+public class Base64 extends BaseNCodec {\n+\n+    /**\n+     * BASE32 characters are 6 bits in length. \n+     * They are formed by taking a block of 3 octets to form a 24-bit string, \n+     * which is converted into 4 BASE64 characters.\n+     */\n+    private static final int BITS_PER_ENCODED_BYTE = 6;\n+    private static final int BYTES_PER_UNENCODED_BLOCK = 3;\n+    private static final int BYTES_PER_ENCODED_BLOCK = 4;\n+\n+    /**\n+     * Chunk separator per RFC 2045 section 2.1.\n+     *\n+     * <p>\n+     * N.B. The next major release may break compatibility and make this field private.\n+     * </p>\n+     * \n+     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n+     */\n+    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n+\n+    /**\n+     * This array is a lookup table that translates 6-bit positive integer index values into their \"Base64 Alphabet\"\n+     * equivalents as specified in Table 1 of RFC 2045.\n+     * \n+     * Thanks to \"commons\" project in ws.apache.org for this code.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     */\n+    private static final byte[] STANDARD_ENCODE_TABLE = {\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n+    };\n+\n+    /**\n+     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\n+     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\n+     * This table is only used when the Base64's mode is set to URL-SAFE.\n+     */    \n+    private static final byte[] URL_SAFE_ENCODE_TABLE = {\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n+    };\n+\n+    /**\n+     * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n+     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n+     * alphabet but fall within the bounds of the array are translated to -1.\n+     * \n+     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\n+     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\n+     * \n+     * Thanks to \"commons\" project in ws.apache.org for this code.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     */\n+    private static final byte[] DECODE_TABLE = {\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 54,\n+            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n+            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n+            24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n+            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n+    };\n+\n+    /**\n+     * Base64 uses 6-bit fields. \n+     */\n+    /** Mask used to extract 6 bits, used when encoding */\n+    private static final int MASK_6BITS = 0x3f;\n+\n+    // The static final fields above are used for the original static byte[] methods on Base64.\n+    // The private member fields below are used with the new streaming approach, which requires\n+    // some state be preserved between calls of encode() and decode().\n+\n+    /**\n+     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n+     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n+     * between the two modes.\n+     */\n+    private final byte[] encodeTable;\n+\n+    // Only one decode table currently; keep for consistency with Base32 code\n+    private final byte[] decodeTable = DECODE_TABLE;\n+\n+    /**\n+     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n+     */\n+    private final byte[] lineSeparator;\n+\n+    /**\n+     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n+     * <code>decodeSize = 3 + lineSeparator.length;</code>\n+     */\n+    private final int decodeSize;\n+\n+    /**\n+     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n+     * <code>encodeSize = 4 + lineSeparator.length;</code>\n+     */\n+    private final int encodeSize;\n+\n+    /**\n+     * Place holder for the bytes we're dealing with for our based logic. \n+     * Bitwise operations store and extract the encoding or decoding from this variable.\n+     */\n+    private int bitWorkArea;\n+\n+    /**\n+     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n+     * <p>\n+     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * \n+     * <p>\n+     * When decoding all variants are supported.\n+     * </p>\n+     */\n+    public Base64() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n+     * <p>\n+     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * \n+     * <p>\n+     * When decoding all variants are supported.\n+     * </p>\n+     * \n+     * @param urlSafe\n+     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n+     *            <code>false</code>.\n+     * @since 1.4\n+     */\n+    public Base64(boolean urlSafe) {\n+        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n+    }\n+\n+    /**\n+     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n+     * <p>\n+     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n+     * STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * <p>\n+     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n+     * </p>\n+     * <p>\n+     * When decoding all variants are supported.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     * @since 1.4\n+     */\n+    public Base64(int lineLength) {\n+        this(lineLength, CHUNK_SEPARATOR);\n+    }\n+\n+    /**\n+     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n+     * <p>\n+     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n+     * STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * <p>\n+     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n+     * </p>\n+     * <p>\n+     * When decoding all variants are supported.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     * @param lineSeparator\n+     *            Each line of encoded data will end with this sequence of bytes.\n+     * @throws IllegalArgumentException\n+     *             Thrown when the provided lineSeparator included some base64 characters.\n+     * @since 1.4\n+     */\n+    public Base64(int lineLength, byte[] lineSeparator) {\n+        this(lineLength, lineSeparator, false);\n+    }\n+\n+    /**\n+     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n+     * <p>\n+     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n+     * STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * <p>\n+     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n+     * </p>\n+     * <p>\n+     * When decoding all variants are supported.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     * @param lineSeparator\n+     *            Each line of encoded data will end with this sequence of bytes.\n+     * @param urlSafe\n+     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n+     *            operations. Decoding seamlessly handles both modes.\n+     * @throws IllegalArgumentException\n+     *             The provided lineSeparator included some base64 characters. That's not going to work!\n+     * @since 1.4\n+     */\n+    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n+        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, \n+                lineLength,\n+                lineSeparator == null ? 0 : lineSeparator.length);\n+        // TODO could be simplified if there is no requirement to reject invalid line sep when length <=0\n+        // @see test case Base64Test.testConstructors() \n+        if (lineSeparator != null) {\n+            if (containsAlphabetOrPad(lineSeparator)) {\n+                String sep = StringUtils.newStringUtf8(lineSeparator);\n+                throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n+            }            \n+            if (lineLength > 0){ // null line-sep forces no chunking rather than throwing IAE\n+                this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n+                this.lineSeparator = new byte[lineSeparator.length];\n+                System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n+            } else {\n+                this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n+                this.lineSeparator = null;\n+            }\n+        } else {\n+            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n+            this.lineSeparator = null;\n+        }\n+        this.decodeSize = this.encodeSize - 1;\n+        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n+    }\n+\n+    /**\n+     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\n+     * \n+     * @return true if we're in URL-SAFE mode, false otherwise.\n+     * @since 1.4\n+     */\n+    public boolean isUrlSafe() {\n+        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n+    }\n+\n+    /**\n+     * <p>\n+     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n+     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n+     * remaining bytes (if not multiple of 3).\n+     * </p>\n+     * <p>\n+     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     * </p>\n+     * \n+     * @param in\n+     *            byte[] array of binary data to base64 encode.\n+     * @param inPos\n+     *            Position to start reading data from.\n+     * @param inAvail\n+     *            Amount of bytes available from input for encoding.\n+     */\n+    @Override\n+    void encode(byte[] in, int inPos, int inAvail) {\n+        if (eof) {\n+            return;\n+        }\n+        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n+        // encoding.\n+        if (inAvail < 0) {\n+            eof = true;\n+            if (0 == modulus && lineLength == 0) {\n+                return; // no leftovers to process and not using chunking\n+            }\n+            ensureBufferSize(encodeSize);\n+            int savedPos = pos;\n+            switch (modulus) { // 0-2\n+                case 1 : // 8 bits = 6 + 2\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS]; // top 6 bits\n+                    buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS]; // remaining 2 \n+                    // URL-SAFE skips the padding to further reduce size.\n+                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n+                        buffer[pos++] = PAD;\n+                        buffer[pos++] = PAD;\n+                    }\n+                    break;\n+\n+                case 2 : // 16 bits = 6 + 6 + 4\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];\n+                    // URL-SAFE skips the padding to further reduce size.\n+                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n+                        buffer[pos++] = PAD;\n+                    }\n+                    break;\n+            }\n+            currentLinePos += pos - savedPos; // keep track of current line position\n+            // if currentPos == 0 we are at the start of a line, so don't add CRLF\n+            if (lineLength > 0 && currentLinePos > 0) { \n+                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n+                pos += lineSeparator.length;\n+            }\n+        } else {\n+            for (int i = 0; i < inAvail; i++) {\n+                ensureBufferSize(encodeSize);\n+                modulus = (modulus+1) % BYTES_PER_UNENCODED_BLOCK;\n+                int b = in[inPos++];\n+                if (b < 0) {\n+                    b += 256;\n+                }\n+                bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE\n+                if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];\n+                    currentLinePos += BYTES_PER_ENCODED_BLOCK;\n+                    if (lineLength > 0 && lineLength <= currentLinePos) {\n+                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n+                        pos += lineSeparator.length;\n+                        currentLinePos = 0;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n+     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n+     * call is not necessary when decoding, but it doesn't hurt, either.\n+     * </p>\n+     * <p>\n+     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n+     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n+     * garbage-out philosophy: it will not check the provided data for validity.\n+     * </p>\n+     * <p>\n+     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     * </p>\n+     * \n+     * @param in\n+     *            byte[] array of ascii data to base64 decode.\n+     * @param inPos\n+     *            Position to start reading data from.\n+     * @param inAvail\n+     *            Amount of bytes available from input for encoding.\n+     */\n+    @Override\n+    void decode(byte[] in, int inPos, int inAvail) {\n+        if (eof) {\n+            return;\n+        }\n+        if (inAvail < 0) {\n+            eof = true;\n+        }\n+        for (int i = 0; i < inAvail; i++) {\n+            ensureBufferSize(decodeSize);\n+            byte b = in[inPos++];\n+            if (b == PAD) {\n+                // We're done.\n+                eof = true;\n+                break;\n+            } else {\n+                if (b >= 0 && b < DECODE_TABLE.length) {\n+                    int result = DECODE_TABLE[b];\n+                    if (result >= 0) {\n+                        modulus = (modulus+1) % BYTES_PER_ENCODED_BLOCK;\n+                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n+                        if (modulus == 0) {\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                            buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Two forms of EOF as far as base64 decoder is concerned: actual\n+        // EOF (-1) and first time '=' character is encountered in stream.\n+        // This approach makes the '=' padding characters completely optional.\n+        if (eof && modulus != 0) {\n+            ensureBufferSize(decodeSize);\n+            \n+            // We have some spare bits remaining\n+            // Output all whole multiples of 8 bits and ignore the rest\n+            switch (modulus) {\n+           //   case 1: // 6 bits - ignore entirely\n+           //       break;\n+                case 2 : // 12 bits = 8 + 4\n+                    bitWorkArea = bitWorkArea >> 4; // dump the extra 4 bits\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    break;\n+                case 3 : // 18 bits = 8 + 8 + 2\n+                    bitWorkArea = bitWorkArea >> 2; // dump 2 bits\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\n+     * \n+     * @param octet\n+     *            The value to test\n+     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\n+     * @since 1.4\n+     */\n+    public static boolean isBase64(byte octet) {\n+        return octet == PAD_DEFAULT || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n+    }\n+\n+    /**\n+     * Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the\n+     * method treats whitespace as valid.\n+     * \n+     * @param base64\n+     *            String to test\n+     * @return <code>true</code> if all characters in the String are valid characters in the Base64 alphabet or if\n+     *         the String is empty; <code>false</code>, otherwise\n+     *  @since 1.5\n+     */\n+    public static boolean isBase64(String base64) {\n+        return isBase64(StringUtils.getBytesUtf8(base64));\n+    }\n+    \n+    /**\n+     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n+     * method treats whitespace as valid.\n+     * \n+     * @param arrayOctet\n+     *            byte array to test\n+     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n+     *         <code>false</code>, otherwise\n+     * @since 1.5\n+     */    \n+    public static boolean isBase64(byte[] arrayOctet) {\n+        for (int i = 0; i < arrayOctet.length; i++) {\n+            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Encodes binary data using the base64 algorithm but does not chunk the output.\n+     * \n+     * @param binaryData\n+     *            binary data to encode\n+     * @return byte[] containing Base64 characters in their UTF-8 representation.\n+     */\n+    public static byte[] encodeBase64(byte[] binaryData) {\n+        return encodeBase64(binaryData, false);\n+    }\n+\n+    /**\n+     * Encodes binary data using the base64 algorithm but does not chunk the output.\n+     *\n+     * NOTE:  We changed the behaviour of this method from multi-line chunking (commons-codec-1.4) to\n+     * single-line non-chunking (commons-codec-1.5). \n+     * \n+     * @param binaryData\n+     *            binary data to encode\n+     * @return String containing Base64 characters.\n+     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\n+     */    \n+    public static String encodeBase64String(byte[] binaryData) {\n+        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n+    }\n+    \n+    /**\n+     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n+     * url-safe variation emits - and _ instead of + and / characters.\n+     * \n+     * @param binaryData\n+     *            binary data to encode\n+     * @return byte[] containing Base64 characters in their UTF-8 representation.\n+     * @since 1.4\n+     */\n+    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n+        return encodeBase64(binaryData, false, true);\n+    }\n+\n+    /**\n+     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n+     * url-safe variation emits - and _ instead of + and / characters.\n+     *\n+     * @param binaryData\n+     *            binary data to encode\n+     * @return String containing Base64 characters\n+     * @since 1.4\n+     */    \n+    public static String encodeBase64URLSafeString(byte[] binaryData) {\n+        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n+    }    \n+\n+    /**\n+     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n+     * \n+     * @param binaryData\n+     *            binary data to encode\n+     * @return Base64 characters chunked in 76 character blocks\n+     */\n+    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n+        return encodeBase64(binaryData, true);\n+    }\n+\n+    /**\n+     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n+     * \n+     * @param binaryData\n+     *            Array containing binary data to encode.\n+     * @param isChunked\n+     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n+     * @return Base64-encoded data.\n+     * @throws IllegalArgumentException\n+     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n+     */\n+    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n+        return encodeBase64(binaryData, isChunked, false);\n+    }\n+\n+    /**\n+     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n+     * \n+     * @param binaryData\n+     *            Array containing binary data to encode.\n+     * @param isChunked\n+     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n+     * @param urlSafe\n+     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n+     * @return Base64-encoded data.\n+     * @throws IllegalArgumentException\n+     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n+     * @since 1.4\n+     */\n+    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n+        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n+     * \n+     * @param binaryData\n+     *            Array containing binary data to encode.\n+     * @param isChunked\n+     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n+     * @param urlSafe\n+     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n+     * @param maxResultSize\n+     *            The maximum result size to accept.\n+     * @return Base64-encoded data.\n+     * @throws IllegalArgumentException\n+     *             Thrown when the input array needs an output array bigger than maxResultSize\n+     * @since 1.4\n+     */\n+    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n+        if (binaryData == null || binaryData.length == 0) {\n+            return binaryData;\n+        }\n+\n+        // Create this so can use the super-class method\n+        // Also ensures that the same roundings are performed by the ctor and the code\n+        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n+        long len = b64.getEncodedLength(binaryData);\n+        if (len > maxResultSize) {\n+            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n+                len +\n+                \") than the specified maximum size of \" +\n+                maxResultSize);\n+        }\n+                \n+        return b64.encode(binaryData);\n+    }\n+\n+    /**\n+     * Decodes a Base64 String into octets\n+     *\n+     * @param base64String\n+     *            String containing Base64 data\n+     * @return Array containing decoded data.\n+     * @since 1.4\n+     */\n+    public static byte[] decodeBase64(String base64String) {\n+        return new Base64().decode(base64String);\n+    }\n+\n+    /**\n+     * Decodes Base64 data into octets\n+     * \n+     * @param base64Data\n+     *            Byte array containing Base64 data\n+     * @return Array containing decoded data.\n+     */\n+    public static byte[] decodeBase64(byte[] base64Data) {\n+        return new Base64().decode(base64Data);\n+    }\n+\n+    // Implementation of the Encoder Interface\n+\n+    // Implementation of integer encoding used for crypto\n+    /**\n+     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n+     * \n+     * @param pArray\n+     *            a byte array containing base64 character data\n+     * @return A BigInteger\n+     * @since 1.4\n+     */\n+    public static BigInteger decodeInteger(byte[] pArray) {\n+        return new BigInteger(1, decodeBase64(pArray));\n+    }\n+\n+    /**\n+     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n+     * \n+     * @param bigInt\n+     *            a BigInteger\n+     * @return A byte array containing base64 character data\n+     * @throws NullPointerException\n+     *             if null is passed in\n+     * @since 1.4\n+     */\n+    public static byte[] encodeInteger(BigInteger bigInt) {\n+        if (bigInt == null) {\n+            throw new NullPointerException(\"encodeInteger called with null parameter\");\n+        }\n+        return encodeBase64(toIntegerBytes(bigInt), false);\n+    }\n+\n+    /**\n+     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n+     * \n+     * @param bigInt\n+     *            <code>BigInteger</code> to be converted\n+     * @return a byte array representation of the BigInteger parameter\n+     */\n+    static byte[] toIntegerBytes(BigInteger bigInt) {\n+        int bitlen = bigInt.bitLength();\n+        // round bitlen\n+        bitlen = ((bitlen + 7) >> 3) << 3;\n+        byte[] bigBytes = bigInt.toByteArray();\n+\n+        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n+            return bigBytes;\n+        }\n+        // set up params for copying everything but sign bit\n+        int startSrc = 0;\n+        int len = bigBytes.length;\n+\n+        // if bigInt is exactly byte-aligned, just skip signbit in copy\n+        if ((bigInt.bitLength() % 8) == 0) {\n+            startSrc = 1;\n+            len--;\n+        }\n+        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n+        byte[] resizedBytes = new byte[bitlen / 8];\n+        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n+        return resizedBytes;\n+    }\n+\n+    /**\n+     * Returns whether or not the <code>octet</code> is in the Base32 alphabet.\n+     * \n+     * @param octet\n+     *            The value to test\n+     * @return <code>true</code> if the value is defined in the the Base32 alphabet <code>false</code> otherwise.\n+     */\n+    @Override\n+    protected boolean isInAlphabet(byte octet) {\n+        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64InputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.InputStream;\n+\n+/**\n+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * constructor.\n+ * <p>\n+ * The default behaviour of the Base64InputStream is to DECODE, whereas the default behaviour of the Base64OutputStream\n+ * is to ENCODE, but this behaviour can be overridden by using a different constructor.\n+ * </p>\n+ * <p>\n+ * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n+ * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n+ * </p>\n+ * <p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * </p>\n+ * \n+ * @author Apache Software Foundation \n+ * @version $Id$\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @since 1.4\n+ */\n+public class Base64InputStream extends BaseNCodecInputStream {\n+\n+    /**\n+     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     */\n+    public Base64InputStream(InputStream in) {\n+        this(in, false);\n+    }\n+\n+    /**\n+     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n+     * provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data read from us, false if we should decode.\n+     */\n+    public Base64InputStream(InputStream in, boolean doEncode) {\n+        super(in, new Base64(false), doEncode);\n+    }\n+\n+    /**\n+     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n+     * provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data read from us, false if we should decode.\n+     * @param lineLength\n+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            false, lineLength is ignored.\n+     * @param lineSeparator\n+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n+     */\n+    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+        super(in, new Base64(lineLength, lineSeparator), doEncode);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.OutputStream;\n+\n+/**\n+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * constructor.\n+ * <p>\n+ * The default behaviour of the Base64OutputStream is to ENCODE, whereas the default behaviour of the Base64InputStream\n+ * is to DECODE. But this behaviour can be overridden by using a different constructor.\n+ * </p>\n+ * <p>\n+ * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n+ * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n+ * </p>\n+ * <p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @since 1.4\n+ */\n+public class Base64OutputStream extends BaseNCodecOutputStream {\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     */\n+    public Base64OutputStream(OutputStream out) {\n+        this(out, true);\n+    }\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n+     * original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data written to us, false if we should decode.\n+     */\n+    public Base64OutputStream(OutputStream out, boolean doEncode) {\n+        super(out,new Base64(false), doEncode);\n+    }\n+\n+    /**\n+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n+     * original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data written to us, false if we should decode.\n+     * @param lineLength\n+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            false, lineLength is ignored.\n+     * @param lineSeparator\n+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n+     */\n+    public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n+        super(out, new Base64(lineLength, lineSeparator), doEncode);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import org.apache.commons.codec.BinaryDecoder;\n+import org.apache.commons.codec.BinaryEncoder;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+\n+/**\n+ * Abstract superclass for Base-N encoders and decoders.\n+ *\n+ * <p>\n+ * This class is not thread-safe.\n+ * Each thread should use its own instance.\n+ * </p>\n+ */\n+public abstract class BaseNCodec implements BinaryEncoder, BinaryDecoder {\n+\n+    /**\n+     *  MIME chunk size per RFC 2045 section 6.8.\n+     *\n+     * <p>\n+     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n+     * equal signs.\n+     * </p>\n+     *\n+     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n+     */\n+    public static final int MIME_CHUNK_SIZE = 76;\n+\n+    /**\n+     * PEM chunk size per RFC 1421 section 4.3.2.4.\n+     *\n+     * <p>\n+     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n+     * equal signs.\n+     * </p>\n+     *\n+     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n+     */\n+    public static final int PEM_CHUNK_SIZE = 64;\n+\n+    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n+\n+    /**\n+     * Defines the default buffer size - currently {@value}\n+     * - must be large enough for at least one encoded block+separator\n+     */\n+    private static final int DEFAULT_BUFFER_SIZE = 8192;\n+\n+    /** Mask used to extract 8 bits, used in decoding bytes */\n+    protected static final int MASK_8BITS = 0xff;\n+\n+    /**\n+     * Byte used to pad output.\n+     */\n+    protected static final byte PAD_DEFAULT = '='; // Allow static access to default\n+    \n+    protected final byte PAD = PAD_DEFAULT; // instance variable just in case it needs to vary later\n+\n+    /** Number of bytes in each full block of unencoded data, e.g. 4 for Base64 and 5 for Base32 */\n+    private final int unencodedBlockSize;\n+\n+    /** Number of bytes in each full block of encoded data, e.g. 3 for Base64 and 8 for Base32 */\n+    private final int encodedBlockSize;\n+\n+    /**\n+     * Chunksize for encoding. Not used when decoding. \n+     * A value of zero or less implies no chunking of the encoded data.\n+     * Rounded down to nearest multiple of encodedBlockSize.\n+     */\n+    protected final int lineLength;\n+    \n+    /**\n+     * Size of chunk separator. Not used unless {@link #lineLength} > 0. \n+     */\n+    private final int chunkSeparatorLength;\n+\n+    /**\n+     * Buffer for streaming.\n+     */\n+    protected byte[] buffer;\n+\n+    /**\n+     * Position where next character should be written in the buffer.\n+     */\n+    protected int pos;\n+\n+    /**\n+     * Position where next character should be read from the buffer.\n+     */\n+    private int readPos;\n+\n+    /**\n+     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,\n+     * and must be thrown away.\n+     */\n+    protected boolean eof;\n+\n+    /**\n+     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n+     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n+     */\n+    protected int currentLinePos;\n+\n+    /**\n+     * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding.\n+     * This variable helps track that.\n+     */\n+    protected int modulus;\n+\n+    /**\n+     * Note <code>lineLength</code> is rounded down to the nearest multiple of {@link #encodedBlockSize}\n+     * If <code>chunkSeparatorLength</code> is zero, then chunking is disabled.\n+     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\n+     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\n+     * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\n+     * @param chunkSeparatorLength the chunk separator length, if relevant\n+     */\n+    protected BaseNCodec(int unencodedBlockSize, int encodedBlockSize, int lineLength, int chunkSeparatorLength){\n+        this.unencodedBlockSize = unencodedBlockSize;\n+        this.encodedBlockSize = encodedBlockSize;\n+        this.lineLength = (lineLength > 0  && chunkSeparatorLength > 0) ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;\n+        this.chunkSeparatorLength = chunkSeparatorLength;\n+    }\n+\n+    /**\n+     * Returns true if this object has buffered data for reading.\n+     *\n+     * @return true if there is data still available for reading.\n+     */\n+    boolean hasData() {  // package protected for access from I/O streams\n+        return this.buffer != null;\n+    }\n+\n+    /**\n+     * Returns the amount of buffered data available for reading.\n+     *\n+     * @return The amount of buffered data available for reading.\n+     */\n+    int available() {  // package protected for access from I/O streams\n+        return buffer != null ? pos - readPos : 0;\n+    }\n+\n+    /**\n+     * Get the default buffer size. Can be overridden.\n+     *\n+     * @return {@link #DEFAULT_BUFFER_SIZE}\n+     */\n+    protected int getDefaultBufferSize() {\n+        return DEFAULT_BUFFER_SIZE;\n+    }\n+\n+    /** Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}. */\n+    private void resizeBuffer() {\n+        if (buffer == null) {\n+            buffer = new byte[getDefaultBufferSize()];\n+            pos = 0;\n+            readPos = 0;\n+        } else {\n+            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n+            System.arraycopy(buffer, 0, b, 0, buffer.length);\n+            buffer = b;\n+        }\n+    }\n+\n+    /**\n+     * Ensure that the buffer has room for <code>size</code> bytes\n+     *\n+     * @param size minimum spare space required\n+     */\n+    protected void ensureBufferSize(int size){\n+        if ((buffer == null) || (buffer.length < pos + size)){\n+            resizeBuffer();\n+        }\n+    }\n+\n+    /**\n+     * Extracts buffered data into the provided byte[] array, starting at position bPos, \n+     * up to a maximum of bAvail bytes. Returns how many bytes were actually extracted.\n+     *\n+     * @param b\n+     *            byte[] array to extract the buffered data into.\n+     * @param bPos\n+     *            position in byte[] array to start extraction at.\n+     * @param bAvail\n+     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n+     * @return The number of bytes successfully extracted into the provided byte[] array.\n+     */\n+    int readResults(byte[] b, int bPos, int bAvail) {  // package protected for access from I/O streams\n+        if (buffer != null) {\n+            int len = Math.min(available(), bAvail);\n+            System.arraycopy(buffer, readPos, b, bPos, len);\n+            readPos += len;\n+            if (readPos >= pos) {\n+                buffer = null; // so hasData() will return false, and this method can return -1\n+            }\n+            return len;\n+        }\n+        return eof ? -1 : 0;\n+    }\n+\n+    /**\n+     * Checks if a byte value is whitespace or not.\n+     * Whitespace is taken to mean: space, tab, CR, LF\n+     * @param byteToCheck\n+     *            the byte to check\n+     * @return true if byte is whitespace, false otherwise\n+     */\n+    protected static boolean isWhiteSpace(byte byteToCheck) {\n+        switch (byteToCheck) {\n+            case ' ' :\n+            case '\\n' :\n+            case '\\r' :\n+            case '\\t' :\n+                return true;\n+            default :\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Resets this object to its initial newly constructed state.\n+     */\n+    private void reset() {\n+        buffer = null;\n+        pos = 0;\n+        readPos = 0;\n+        currentLinePos = 0;\n+        modulus = 0;\n+        eof = false;\n+    }\n+\n+    /**\n+     * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of the\n+     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n+     *\n+     * @param pObject\n+     *            Object to encode\n+     * @return An object (of type byte[]) containing the Base-N encoded data which corresponds to the byte[] supplied.\n+     * @throws EncoderException\n+     *             if the parameter supplied is not of type byte[]\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (!(pObject instanceof byte[])) {\n+            throw new EncoderException(\"Parameter supplied to Base-N encode is not a byte[]\");\n+        }\n+        return encode((byte[]) pObject);\n+    }\n+\n+    /**\n+     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.\n+     *\n+     * @param pArray\n+     *            a byte array containing binary data\n+     * @return A String containing only Base-N character data\n+     */\n+    public String encodeToString(byte[] pArray) {\n+        return StringUtils.newStringUtf8(encode(pArray));\n+    }\n+\n+    /**\n+     * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of the\n+     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n+     *\n+     * @param pObject\n+     *            Object to decode\n+     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n+     * @throws DecoderException\n+     *             if the parameter supplied is not of type byte[]\n+     */\n+    public Object decode(Object pObject) throws DecoderException {        \n+        if (pObject instanceof byte[]) {\n+            return decode((byte[]) pObject);\n+        } else if (pObject instanceof String) {\n+            return decode((String) pObject);\n+        } else {\n+            throw new DecoderException(\"Parameter supplied to Base-N decode is not a byte[] or a String\");\n+        }\n+    }\n+\n+    /**\n+     * Decodes a String containing characters in the Base-N alphabet.\n+     *\n+     * @param pArray\n+     *            A String containing Base-N character data\n+     * @return a byte array containing binary data\n+     */\n+    public byte[] decode(String pArray) {\n+        return decode(StringUtils.getBytesUtf8(pArray));\n+    }\n+\n+    /**\n+     * Decodes a byte[] containing characters in the Base-N alphabet.\n+     * \n+     * @param pArray\n+     *            A byte array containing Base-N character data\n+     * @return a byte array containing binary data\n+     */\n+    public byte[] decode(byte[] pArray) {\n+        reset();\n+        if (pArray == null || pArray.length == 0) {\n+            return pArray;\n+        }\n+        decode(pArray, 0, pArray.length);\n+        decode(pArray, 0, -1); // Notify decoder of EOF.\n+        byte[] result = new byte[pos];\n+        readResults(result, 0, result.length);\n+        return result;\n+    }\n+\n+    /**\n+     * Encodes a byte[] containing binary data, into a byte[] containing characters in the alphabet.\n+     *\n+     * @param pArray\n+     *            a byte array containing binary data\n+     * @return A byte array containing only the basen alphabetic character data\n+     */\n+    public byte[] encode(byte[] pArray) {\n+        reset();        \n+        if (pArray == null || pArray.length == 0) {\n+            return pArray;\n+        }\n+        encode(pArray, 0, pArray.length);\n+        encode(pArray, 0, -1); // Notify encoder of EOF.\n+        byte[] buf = new byte[pos - readPos];\n+        readResults(buf, 0, buf.length);\n+        return buf;\n+    }\n+    \n+    /**\n+     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.\n+     * Uses UTF8 encoding.\n+     *\n+     * @param pArray a byte array containing binary data\n+     * @return String containing only character data in the appropriate alphabet.\n+    */\n+    public String encodeAsString(byte[] pArray){\n+        return StringUtils.newStringUtf8(encode(pArray));\n+    }\n+\n+    abstract void encode(byte[] pArray, int i, int length);  // package protected for access from I/O streams\n+\n+    abstract void decode(byte[] pArray, int i, int length); // package protected for access from I/O streams\n+    \n+    /**\n+     * Returns whether or not the <code>octet</code> is in the current alphabet.\n+     * Does not allow whitespace or pad.\n+     *\n+     * @param value The value to test\n+     *\n+     * @return <code>true</code> if the value is defined in the current alphabet, <code>false</code> otherwise.\n+     */\n+    protected abstract boolean isInAlphabet(byte value);\n+    \n+    /**\n+     * Tests a given byte array to see if it contains only valid characters within the alphabet.\n+     * The method optionally treats whitespace and pad as valid.\n+     *\n+     * @param arrayOctet byte array to test\n+     * @param allowWSPad if <code>true</code>, then whitespace and PAD are also allowed\n+     *\n+     * @return <code>true</code> if all bytes are valid characters in the alphabet or if the byte array is empty;\n+     *         <code>false</code>, otherwise\n+     */    \n+    public boolean isInAlphabet(byte[] arrayOctet, boolean allowWSPad) {\n+        for (int i = 0; i < arrayOctet.length; i++) {\n+            if (!isInAlphabet(arrayOctet[i]) &&\n+                    (!allowWSPad || (arrayOctet[i] != PAD) && !isWhiteSpace(arrayOctet[i]))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Tests a given String to see if it contains only valid characters within the alphabet. \n+     * The method treats whitespace and PAD as valid.\n+     *\n+     * @param basen String to test\n+     * @return <code>true</code> if all characters in the String are valid characters in the alphabet or if\n+     *         the String is empty; <code>false</code>, otherwise\n+     * @see #isInAlphabet(byte[], boolean)\n+     */\n+    public boolean isInAlphabet(String basen) {\n+        return isInAlphabet(StringUtils.getBytesUtf8(basen), true);\n+    }\n+\n+    /**\n+     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.\n+     *\n+     * Intended for use in checking line-ending arrays\n+     *\n+     * @param arrayOctet\n+     *            byte array to test\n+     * @return <code>true</code> if any byte is a valid character in the alphabet or PAD; <code>false</code> otherwise\n+     */\n+    protected boolean containsAlphabetOrPad(byte[] arrayOctet) {\n+        if (arrayOctet == null) {\n+            return false;\n+        }\n+        for (byte element : arrayOctet) {\n+            if (PAD == element || isInAlphabet(element)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Calculates the amount of space needed to encode the supplied array.\n+     *\n+     * @param pArray byte[] array which will later be encoded\n+     *\n+     * @return amount of space needed to encoded the supplied array.  \n+     * Returns a long since a max-len array will require > Integer.MAX_VALUE\n+     */\n+    public long getEncodedLength(byte[] pArray) {\n+        // Calculate non-chunked size - rounded up to allow for padding\n+        // cast to long is needed to avoid possibility of overflow\n+        long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * (long) encodedBlockSize;\n+        if (lineLength > 0) { // We're using chunking\n+            // Round up to nearest multiple\n+            len += ((len + lineLength-1) / lineLength) * chunkSeparatorLength;\n+        }\n+        return len;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * Abstract superclass for Base-N input streams.\n+ * \n+ * @since 1.5\n+ */\n+public class BaseNCodecInputStream extends FilterInputStream {\n+\n+    private final boolean doEncode;\n+\n+    private final BaseNCodec baseNCodec;\n+\n+    private final byte[] singleByte = new byte[1];\n+\n+    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {\n+        super(in);\n+        this.doEncode = doEncode;\n+        this.baseNCodec = baseNCodec;\n+    }\n+\n+    /**\n+     * Reads one <code>byte</code> from this input stream.\n+     * \n+     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     */\n+    @Override\n+    public int read() throws IOException {\n+        int r = read(singleByte, 0, 1);\n+        while (r == 0) {\n+            r = read(singleByte, 0, 1);\n+        }\n+        if (r > 0) {\n+            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n+     * from this InputStream.\n+     * \n+     * @param b\n+     *            destination byte array\n+     * @param offset\n+     *            where to start writing the bytes\n+     * @param len\n+     *            maximum number of bytes to read\n+     * \n+     * @return number of bytes read\n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     * @throws NullPointerException\n+     *             if the byte array parameter is null\n+     * @throws IndexOutOfBoundsException\n+     *             if offset, len or buffer size are invalid\n+     */\n+    @Override\n+    public int read(byte b[], int offset, int len) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (offset < 0 || len < 0) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (offset > b.length || offset + len > b.length) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (len == 0) {\n+            return 0;\n+        } else {\n+            int readLen = 0;\n+            /*\n+             Rationale for while-loop on (readLen == 0):\n+             -----\n+             Base32.readResults() usually returns > 0 or EOF (-1).  In the\n+             rare case where it returns 0, we just keep trying.\n+\n+             This is essentially an undocumented contract for InputStream\n+             implementors that want their code to work properly with\n+             java.io.InputStreamReader, since the latter hates it when\n+             InputStream.read(byte[]) returns a zero.  Unfortunately our\n+             readResults() call must return 0 if a large amount of the data\n+             being decoded was non-base32, so this while-loop enables proper\n+             interop with InputStreamReader for that scenario.\n+             -----\n+             This is a fix for CODEC-101\n+            */\n+            while (readLen == 0) {\n+                if (!baseNCodec.hasData()) {\n+                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n+                    int c = in.read(buf);\n+                    if (doEncode) {\n+                        baseNCodec.encode(buf, 0, c);\n+                    } else {\n+                        baseNCodec.decode(buf, 0, c);\n+                    }\n+                }\n+                readLen = baseNCodec.readResults(b, offset, len);\n+            }\n+            return readLen;\n+        }\n+    }\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @return false\n+     */\n+    @Override\n+    public boolean markSupported() {\n+        return false; // not an easy job to support marks\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+/**\n+ * Abstract superclass for Base-N output streams.\n+ * \n+ * @since 1.5\n+ */\n+public class BaseNCodecOutputStream extends FilterOutputStream {\n+\n+    private final boolean doEncode;\n+\n+    private final BaseNCodec baseNCodec;\n+\n+    private final byte[] singleByte = new byte[1];\n+\n+    public BaseNCodecOutputStream(OutputStream out, BaseNCodec basedCodec, boolean doEncode) {\n+        super(out);\n+        this.baseNCodec = basedCodec;\n+        this.doEncode = doEncode;\n+    }\n+\n+    /**\n+     * Writes the specified <code>byte</code> to this output stream.\n+     * \n+     * @param i\n+     *            source byte\n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     */\n+    @Override\n+    public void write(int i) throws IOException {\n+        singleByte[0] = (byte) i;\n+        write(singleByte, 0, 1);\n+    }\n+\n+    /**\n+     * Writes <code>len</code> bytes from the specified <code>b</code> array starting at <code>offset</code> to this\n+     * output stream.\n+     * \n+     * @param b\n+     *            source byte array\n+     * @param offset\n+     *            where to start reading the bytes\n+     * @param len\n+     *            maximum number of bytes to write\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     * @throws NullPointerException\n+     *             if the byte array parameter is null\n+     * @throws IndexOutOfBoundsException\n+     *             if offset, len or buffer size are invalid\n+     */\n+    @Override\n+    public void write(byte b[], int offset, int len) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (offset < 0 || len < 0) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (offset > b.length || offset + len > b.length) {\n+            throw new IndexOutOfBoundsException();\n+        } else if (len > 0) {\n+            if (doEncode) {\n+                baseNCodec.encode(b, offset, len);\n+            } else {\n+                baseNCodec.decode(b, offset, len);\n+            }\n+            flush(false);\n+        }\n+    }\n+\n+    /**\n+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propogate is\n+     * true, the wrapped stream will also be flushed.\n+     * \n+     * @param propogate\n+     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     */\n+    private void flush(boolean propogate) throws IOException {\n+        int avail = baseNCodec.available();\n+        if (avail > 0) {\n+            byte[] buf = new byte[avail];\n+            int c = baseNCodec.readResults(buf, 0, avail);\n+            if (c > 0) {\n+                out.write(buf, 0, c);\n+            }\n+        }\n+        if (propogate) {\n+            out.flush();\n+        }\n+    }\n+\n+    /**\n+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     */\n+    @Override\n+    public void flush() throws IOException {\n+        flush(true);\n+    }\n+\n+    /**\n+     * Closes this output stream and releases any system resources associated with the stream.\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        // Notify encoder of EOF (-1).\n+        if (doEncode) {\n+            baseNCodec.encode(singleByte, 0, -1);\n+        } else {\n+            baseNCodec.decode(singleByte, 0, -1);\n+        }\n+        flush();\n+        out.close();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/BinaryCodec.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import org.apache.commons.codec.BinaryDecoder;\n+import org.apache.commons.codec.BinaryEncoder;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+\n+/**\n+ * Converts between byte arrays and strings of \"0\"s and \"1\"s.\n+ * \n+ * TODO: may want to add more bit vector functions like and/or/xor/nand \n+ * TODO: also might be good to generate boolean[] from byte[] et cetera.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.3\n+ * @version $Id$\n+ */\n+public class BinaryCodec implements BinaryDecoder, BinaryEncoder {\n+    /*\n+     * tried to avoid using ArrayUtils to minimize dependencies while using these empty arrays - dep is just not worth\n+     * it.\n+     */\n+    /** Empty char array. */\n+    private static final char[] EMPTY_CHAR_ARRAY = new char[0];\n+\n+    /** Empty byte array. */\n+    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+\n+    /** Mask for bit 0 of a byte. */\n+    private static final int BIT_0 = 1;\n+\n+    /** Mask for bit 1 of a byte. */\n+    private static final int BIT_1 = 0x02;\n+\n+    /** Mask for bit 2 of a byte. */\n+    private static final int BIT_2 = 0x04;\n+\n+    /** Mask for bit 3 of a byte. */\n+    private static final int BIT_3 = 0x08;\n+\n+    /** Mask for bit 4 of a byte. */\n+    private static final int BIT_4 = 0x10;\n+\n+    /** Mask for bit 5 of a byte. */\n+    private static final int BIT_5 = 0x20;\n+\n+    /** Mask for bit 6 of a byte. */\n+    private static final int BIT_6 = 0x40;\n+\n+    /** Mask for bit 7 of a byte. */\n+    private static final int BIT_7 = 0x80;\n+\n+    private static final int[] BITS = {BIT_0, BIT_1, BIT_2, BIT_3, BIT_4, BIT_5, BIT_6, BIT_7};\n+\n+    /**\n+     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n+     * \n+     * @param raw\n+     *                  the raw binary data to convert\n+     * @return 0 and 1 ASCII character bytes one for each bit of the argument\n+     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n+     */\n+    public byte[] encode(byte[] raw) {\n+        return toAsciiBytes(raw);\n+    }\n+\n+    /**\n+     * Converts an array of raw binary data into an array of ASCII 0 and 1 chars.\n+     * \n+     * @param raw\n+     *                  the raw binary data to convert\n+     * @return 0 and 1 ASCII character chars one for each bit of the argument\n+     * @throws EncoderException\n+     *                  if the argument is not a byte[]\n+     * @see org.apache.commons.codec.Encoder#encode(Object)\n+     */\n+    public Object encode(Object raw) throws EncoderException {\n+        if (!(raw instanceof byte[])) {\n+            throw new EncoderException(\"argument not a byte array\");\n+        }\n+        return toAsciiChars((byte[]) raw);\n+    }\n+\n+    /**\n+     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n+     * \n+     * @param ascii\n+     *                  each byte represents an ASCII '0' or '1'\n+     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n+     * @throws DecoderException\n+     *                  if argument is not a byte[], char[] or String\n+     * @see org.apache.commons.codec.Decoder#decode(Object)\n+     */\n+    public Object decode(Object ascii) throws DecoderException {\n+        if (ascii == null) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+        if (ascii instanceof byte[]) {\n+            return fromAscii((byte[]) ascii);\n+        }\n+        if (ascii instanceof char[]) {\n+            return fromAscii((char[]) ascii);\n+        }\n+        if (ascii instanceof String) {\n+            return fromAscii(((String) ascii).toCharArray());\n+        }\n+        throw new DecoderException(\"argument not a byte array\");\n+    }\n+\n+    /**\n+     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n+     * \n+     * @param ascii\n+     *                  each byte represents an ASCII '0' or '1'\n+     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n+     * @see org.apache.commons.codec.Decoder#decode(Object)\n+     */\n+    public byte[] decode(byte[] ascii) {\n+        return fromAscii(ascii);\n+    }\n+\n+    /**\n+     * Decodes a String where each char of the String represents an ASCII '0' or '1'.\n+     * \n+     * @param ascii\n+     *                  String of '0' and '1' characters\n+     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n+     * @see org.apache.commons.codec.Decoder#decode(Object)\n+     */\n+    public byte[] toByteArray(String ascii) {\n+        if (ascii == null) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+        return fromAscii(ascii.toCharArray());\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //\n+    // static codec operations\n+    //\n+    // ------------------------------------------------------------------------\n+    /**\n+     * Decodes a char array where each char represents an ASCII '0' or '1'.\n+     * \n+     * @param ascii\n+     *                  each char represents an ASCII '0' or '1'\n+     * @return the raw encoded binary where each bit corresponds to a char in the char array argument\n+     */\n+    public static byte[] fromAscii(char[] ascii) {\n+        if (ascii == null || ascii.length == 0) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+        // get length/8 times bytes with 3 bit shifts to the right of the length\n+        byte[] l_raw = new byte[ascii.length >> 3];\n+        /*\n+         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n+         * loop.\n+         */\n+        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\n+            for (int bits = 0; bits < BITS.length; ++bits) {\n+                if (ascii[jj - bits] == '1') {\n+                    l_raw[ii] |= BITS[bits];\n+                }\n+            }\n+        }\n+        return l_raw;\n+    }\n+\n+    /**\n+     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n+     * \n+     * @param ascii\n+     *                  each byte represents an ASCII '0' or '1'\n+     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n+     */\n+    public static byte[] fromAscii(byte[] ascii) {\n+        if (isEmpty(ascii)) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+        // get length/8 times bytes with 3 bit shifts to the right of the length\n+        byte[] l_raw = new byte[ascii.length >> 3];\n+        /*\n+         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n+         * loop.\n+         */\n+        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\n+            for (int bits = 0; bits < BITS.length; ++bits) {\n+                if (ascii[jj - bits] == '1') {\n+                    l_raw[ii] |= BITS[bits];\n+                }\n+            }\n+        }\n+        return l_raw;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the given array is <code>null</code> or empty (size 0.)\n+     * \n+     * @param array\n+     *            the source array\n+     * @return <code>true</code> if the given array is <code>null</code> or empty (size 0.)\n+     */\n+    private static boolean isEmpty(byte[] array) {\n+        return array == null || array.length == 0;\n+    }\n+\n+    /**\n+     * Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated\n+     * char.\n+     * \n+     * @param raw\n+     *                  the raw binary data to convert\n+     * @return an array of 0 and 1 character bytes for each bit of the argument\n+     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n+     */\n+    public static byte[] toAsciiBytes(byte[] raw) {\n+        if (isEmpty(raw)) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+        // get 8 times the bytes with 3 bit shifts to the left of the length\n+        byte[] l_ascii = new byte[raw.length << 3];\n+        /*\n+         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n+         * loop.\n+         */\n+        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n+            for (int bits = 0; bits < BITS.length; ++bits) {\n+                if ((raw[ii] & BITS[bits]) == 0) {\n+                    l_ascii[jj - bits] = '0';\n+                } else {\n+                    l_ascii[jj - bits] = '1';\n+                }\n+            }\n+        }\n+        return l_ascii;\n+    }\n+\n+    /**\n+     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n+     * \n+     * @param raw\n+     *                  the raw binary data to convert\n+     * @return an array of 0 and 1 characters for each bit of the argument\n+     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n+     */\n+    public static char[] toAsciiChars(byte[] raw) {\n+        if (isEmpty(raw)) {\n+            return EMPTY_CHAR_ARRAY;\n+        }\n+        // get 8 times the bytes with 3 bit shifts to the left of the length\n+        char[] l_ascii = new char[raw.length << 3];\n+        /*\n+         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\n+         * loop.\n+         */\n+        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\n+            for (int bits = 0; bits < BITS.length; ++bits) {\n+                if ((raw[ii] & BITS[bits]) == 0) {\n+                    l_ascii[jj - bits] = '0';\n+                } else {\n+                    l_ascii[jj - bits] = '1';\n+                }\n+            }\n+        }\n+        return l_ascii;\n+    }\n+\n+    /**\n+     * Converts an array of raw binary data into a String of ASCII 0 and 1 characters.\n+     * \n+     * @param raw\n+     *                  the raw binary data to convert\n+     * @return a String of 0 and 1 characters representing the binary data\n+     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n+     */\n+    public static String toAsciiString(byte[] raw) {\n+        return new String(toAsciiChars(raw));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/Hex.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import org.apache.commons.codec.BinaryDecoder;\n+import org.apache.commons.codec.BinaryEncoder;\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+\n+/**\n+ * Converts hexadecimal Strings. The charset used for certain operation can be set, the default is set in\n+ * {@link #DEFAULT_CHARSET_NAME}\n+ * \n+ * @since 1.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class Hex implements BinaryEncoder, BinaryDecoder {\n+\n+    /**\n+     * Default charset name is {@link CharEncoding#UTF_8}\n+     * \n+     * @since 1.4\n+     */\n+    public static final String DEFAULT_CHARSET_NAME = CharEncoding.UTF_8;\n+\n+    /**\n+     * Used to build output as Hex\n+     */\n+    private static final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n+\n+    /**\n+     * Used to build output as Hex\n+     */\n+    private static final char[] DIGITS_UPPER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n+\n+    /**\n+     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The\n+     * returned array will be half the length of the passed array, as it takes two characters to represent any given\n+     * byte. An exception is thrown if the passed char array has an odd number of elements.\n+     * \n+     * @param data\n+     *            An array of characters containing hexadecimal digits\n+     * @return A byte array containing binary data decoded from the supplied char array.\n+     * @throws DecoderException\n+     *             Thrown if an odd number or illegal of characters is supplied\n+     */\n+    public static byte[] decodeHex(char[] data) throws DecoderException {\n+\n+        int len = data.length;\n+\n+        if ((len & 0x01) != 0) {\n+            throw new DecoderException(\"Odd number of characters.\");\n+        }\n+\n+        byte[] out = new byte[len >> 1];\n+\n+        // two characters form the hex value.\n+        for (int i = 0, j = 0; j < len; i++) {\n+            int f = toDigit(data[j], j) << 4;\n+            j++;\n+            f = f | toDigit(data[j], j);\n+            j++;\n+            out[i] = (byte) (f & 0xFF);\n+        }\n+\n+        return out;\n+    }\n+\n+    /**\n+     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n+     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n+     * given byte.\n+     * \n+     * @param data\n+     *            a byte[] to convert to Hex characters\n+     * @return A char[] containing hexadecimal characters\n+     */\n+    public static char[] encodeHex(byte[] data) {\n+        return encodeHex(data, true);\n+    }\n+\n+    /**\n+     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n+     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n+     * given byte.\n+     * \n+     * @param data\n+     *            a byte[] to convert to Hex characters\n+     * @param toLowerCase\n+     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase\n+     * @return A char[] containing hexadecimal characters\n+     * @since 1.4\n+     */\n+    public static char[] encodeHex(byte[] data, boolean toLowerCase) {\n+        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\n+    }\n+\n+    /**\n+     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n+     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n+     * given byte.\n+     * \n+     * @param data\n+     *            a byte[] to convert to Hex characters\n+     * @param toDigits\n+     *            the output alphabet\n+     * @return A char[] containing hexadecimal characters\n+     * @since 1.4\n+     */\n+    protected static char[] encodeHex(byte[] data, char[] toDigits) {\n+        int l = data.length;\n+        char[] out = new char[l << 1];\n+        // two characters form the hex value.\n+        for (int i = 0, j = 0; i < l; i++) {\n+            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];\n+            out[j++] = toDigits[0x0F & data[i]];\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\n+     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n+     * \n+     * @param data\n+     *            a byte[] to convert to Hex characters\n+     * @return A String containing hexadecimal characters\n+     * @since 1.4\n+     */\n+    public static String encodeHexString(byte[] data) {\n+        return new String(encodeHex(data));\n+    }\n+\n+    /**\n+     * Converts a hexadecimal character to an integer.\n+     * \n+     * @param ch\n+     *            A character to convert to an integer digit\n+     * @param index\n+     *            The index of the character in the source\n+     * @return An integer\n+     * @throws DecoderException\n+     *             Thrown if ch is an illegal hex character\n+     */\n+    protected static int toDigit(char ch, int index) throws DecoderException {\n+        int digit = Character.digit(ch, 16);\n+        if (digit == -1) {\n+            throw new DecoderException(\"Illegal hexadecimal character \" + ch + \" at index \" + index);\n+        }\n+        return digit;\n+    }\n+\n+    private final String charsetName;\n+\n+    /**\n+     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET_NAME}\n+     */\n+    public Hex() {\n+        // use default encoding\n+        this.charsetName = DEFAULT_CHARSET_NAME;\n+    }\n+\n+    /**\n+     * Creates a new codec with the given charset name.\n+     * \n+     * @param csName\n+     *            the charset name.\n+     * @since 1.4\n+     */\n+    public Hex(String csName) {\n+        this.charsetName = csName;\n+    }\n+\n+    /**\n+     * Converts an array of character bytes representing hexadecimal values into an array of bytes of those same values.\n+     * The returned array will be half the length of the passed array, as it takes two characters to represent any given\n+     * byte. An exception is thrown if the passed char array has an odd number of elements.\n+     * \n+     * @param array\n+     *            An array of character bytes containing hexadecimal digits\n+     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n+     * @throws DecoderException\n+     *             Thrown if an odd number of characters is supplied to this function\n+     * @see #decodeHex(char[])\n+     */\n+    public byte[] decode(byte[] array) throws DecoderException {\n+        try {\n+            return decodeHex(new String(array, getCharsetName()).toCharArray());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new DecoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those\n+     * same values. The returned array will be half the length of the passed String or array, as it takes two characters\n+     * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.\n+     * \n+     * @param object\n+     *            A String or, an array of character bytes containing hexadecimal digits\n+     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n+     * @throws DecoderException\n+     *             Thrown if an odd number of characters is supplied to this function or the object is not a String or\n+     *             char[]\n+     * @see #decodeHex(char[])\n+     */\n+    public Object decode(Object object) throws DecoderException {\n+        try {\n+            char[] charArray = object instanceof String ? ((String) object).toCharArray() : (char[]) object;\n+            return decodeHex(charArray);\n+        } catch (ClassCastException e) {\n+            throw new DecoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Converts an array of bytes into an array of bytes for the characters representing the hexadecimal values of each\n+     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to\n+     * represent any given byte.\n+     * <p>\n+     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by\n+     * {@link #getCharsetName()}.\n+     * </p>\n+     * \n+     * @param array\n+     *            a byte[] to convert to Hex characters\n+     * @return A byte[] containing the bytes of the hexadecimal characters\n+     * @throws IllegalStateException\n+     *             if the charsetName is invalid. This API throws {@link IllegalStateException} instead of\n+     *             {@link UnsupportedEncodingException} for backward compatibility.\n+     * @see #encodeHex(byte[])\n+     */\n+    public byte[] encode(byte[] array) {\n+        return StringUtils.getBytesUnchecked(encodeHexString(array), getCharsetName());\n+    }\n+\n+    /**\n+     * Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each\n+     * byte in order. The returned array will be double the length of the passed String or array, as it takes two\n+     * characters to represent any given byte.\n+     * <p>\n+     * The conversion from hexadecimal characters to bytes to be encoded to performed with the charset named by\n+     * {@link #getCharsetName()}.\n+     * </p>\n+     * \n+     * @param object\n+     *            a String, or byte[] to convert to Hex characters\n+     * @return A char[] containing hexadecimal characters\n+     * @throws EncoderException\n+     *             Thrown if the given object is not a String or byte[]\n+     * @see #encodeHex(byte[])\n+     */\n+    public Object encode(Object object) throws EncoderException {\n+        try {\n+            byte[] byteArray = object instanceof String ? ((String) object).getBytes(getCharsetName()) : (byte[]) object;\n+            return encodeHex(byteArray);\n+        } catch (ClassCastException e) {\n+            throw new EncoderException(e.getMessage(), e);\n+        } catch (UnsupportedEncodingException e) {\n+            throw new EncoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Gets the charset name.\n+     * \n+     * @return the charset name.\n+     * @since 1.4\n+     */\n+    public String getCharsetName() {\n+        return this.charsetName;\n+    }\n+\n+    /**\n+     * Returns a string representation of the object, which includes the charset name.\n+     * \n+     * @return a string representation of the object.\n+     */\n+    @Override\n+    public String toString() {\n+        return super.toString() + \"[charsetName=\" + this.charsetName + \"]\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import org.apache.commons.codec.CharEncoding;\n+\n+/**\n+ * Converts String to and from bytes using the encodings required by the Java specification. These encodings are specified in <a\n+ * href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+ * \n+ * @see CharEncoding\n+ * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ * @since 1.4\n+ */\n+public class StringUtils {\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n+     * byte array.\n+     * \n+     * @param string\n+     *            the String to encode, may be <code>null</code>\n+     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getBytesUnchecked(String, String)\n+     */\n+    public static byte[] getBytesIso8859_1(String string) {\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.ISO_8859_1);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode, may be <code>null</code>\n+     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getBytesUnchecked(String, String)\n+     */\n+    public static byte[] getBytesUsAscii(String string) {\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.US_ASCII);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode, may be <code>null</code>\n+     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getBytesUnchecked(String, String)\n+     */\n+    public static byte[] getBytesUtf16(String string) {\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode, may be <code>null</code>\n+     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getBytesUnchecked(String, String)\n+     */\n+    public static byte[] getBytesUtf16Be(String string) {\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16BE);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode, may be <code>null</code>\n+     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getBytesUnchecked(String, String)\n+     */\n+    public static byte[] getBytesUtf16Le(String string) {\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_16LE);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode, may be <code>null</code>\n+     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getBytesUnchecked(String, String)\n+     */\n+    public static byte[] getBytesUtf8(String string) {\n+        return StringUtils.getBytesUnchecked(string, CharEncoding.UTF_8);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n+     * array.\n+     * <p>\n+     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n+     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n+     * </p>\n+     * \n+     * @param string\n+     *            the String to encode, may be <code>null</code>\n+     * @param charsetName\n+     *            The name of a required {@link java.nio.charset.Charset}\n+     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n+     *             required charset name.\n+     * @see CharEncoding\n+     * @see String#getBytes(String)\n+     */\n+    public static byte[] getBytesUnchecked(String string, String charsetName) {\n+        if (string == null) {\n+            return null;\n+        }\n+        try {\n+            return string.getBytes(charsetName);\n+        } catch (UnsupportedEncodingException e) {\n+            throw StringUtils.newIllegalStateException(charsetName, e);\n+        }\n+    }\n+\n+    private static IllegalStateException newIllegalStateException(String charsetName, UnsupportedEncodingException e) {\n+        return new IllegalStateException(charsetName + \": \" + e);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n+     * <p>\n+     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n+     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n+     * </p>\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters, may be <code>null</code>\n+     * @param charsetName\n+     *            The name of a required {@link java.nio.charset.Charset}\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\n+     *         or <code>null</code> if the input byte array was <code>null</code>.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n+     *             required charset name.\n+     * @see CharEncoding\n+     * @see String#String(byte[], String)\n+     */\n+    public static String newString(byte[] bytes, String charsetName) {\n+        if (bytes == null) {\n+            return null;\n+        }\n+        try {\n+            return new String(bytes, charsetName);\n+        } catch (UnsupportedEncodingException e) {\n+            throw StringUtils.newIllegalStateException(charsetName, e);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters, may be <code>null</code>\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset,\n+     *         or <code>null</code> if the input byte array was <code>null</code>.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringIso8859_1(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.ISO_8859_1);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n+     *         or <code>null</code> if the input byte array was <code>null</code>.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUsAscii(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.US_ASCII);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\n+     *         or <code>null</code> if the input byte array was <code>null</code>.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_16);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\n+     *         or <code>null</code> if the input byte array was <code>null</code>.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16Be(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_16BE);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\n+     *         or <code>null</code> if the input byte array was <code>null</code>.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16Le(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_16LE);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\n+     *         or <code>null</code> if the input byte array was <code>null</code>.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf8(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_8);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/digest/DigestUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.digest;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.codec.binary.StringUtils;\n+\n+/**\n+ * Operations to simplify common {@link java.security.MessageDigest} tasks. This class is thread safe.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class DigestUtils {\n+\n+    private static final int STREAM_BUFFER_LENGTH = 1024;\n+\n+    /**\n+     * Read through an InputStream and returns the digest for the data\n+     * \n+     * @param digest\n+     *            The MessageDigest to use (e.g. MD5)\n+     * @param data\n+     *            Data to digest\n+     * @return MD5 digest\n+     * @throws IOException\n+     *             On error reading from the stream\n+     */\n+    private static byte[] digest(MessageDigest digest, InputStream data) throws IOException {\n+        byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n+        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n+\n+        while (read > -1) {\n+            digest.update(buffer, 0, read);\n+            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n+        }\n+\n+        return digest.digest();\n+    }\n+\n+    /**\n+     * Calls {@link StringUtils#getBytesUtf8(String)}\n+     * \n+     * @param data\n+     *            the String to encode\n+     * @return encoded bytes\n+     */\n+    private static byte[] getBytesUtf8(String data) {\n+        return StringUtils.getBytesUtf8(data);\n+    }\n+\n+    /**\n+     * Returns a <code>MessageDigest</code> for the given <code>algorithm</code>.\n+     * \n+     * @param algorithm\n+     *            the name of the algorithm requested. See <a\n+     *            href=\"http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA\">Appendix A in the Java\n+     *            Cryptography Architecture API Specification & Reference</a> for information about standard algorithm\n+     *            names.\n+     * @return An MD5 digest instance.\n+     * @see MessageDigest#getInstance(String)\n+     * @throws RuntimeException\n+     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n+     */\n+    static MessageDigest getDigest(String algorithm) {\n+        try {\n+            return MessageDigest.getInstance(algorithm);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new RuntimeException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Returns an MD5 MessageDigest.\n+     * \n+     * @return An MD5 digest instance.\n+     * @throws RuntimeException\n+     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n+     */\n+    private static MessageDigest getMd5Digest() {\n+        return getDigest(\"MD5\");\n+    }\n+\n+    /**\n+     * Returns an SHA-256 digest.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @return An SHA-256 digest instance.\n+     * @throws RuntimeException\n+     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n+     */\n+    private static MessageDigest getSha256Digest() {\n+        return getDigest(\"SHA-256\");\n+    }\n+\n+    /**\n+     * Returns an SHA-384 digest.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @return An SHA-384 digest instance.\n+     * @throws RuntimeException\n+     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n+     */\n+    private static MessageDigest getSha384Digest() {\n+        return getDigest(\"SHA-384\");\n+    }\n+\n+    /**\n+     * Returns an SHA-512 digest.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @return An SHA-512 digest instance.\n+     * @throws RuntimeException\n+     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n+     */\n+    private static MessageDigest getSha512Digest() {\n+        return getDigest(\"SHA-512\");\n+    }\n+\n+    /**\n+     * Returns an SHA-1 digest.\n+     * \n+     * @return An SHA-1 digest instance.\n+     * @throws RuntimeException\n+     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n+     */\n+    private static MessageDigest getShaDigest() {\n+        return getDigest(\"SHA\");\n+    }\n+\n+    /**\n+     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return MD5 digest\n+     */\n+    public static byte[] md5(byte[] data) {\n+        return getMd5Digest().digest(data);\n+    }\n+\n+    /**\n+     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return MD5 digest\n+     * @throws IOException\n+     *             On error reading from the stream\n+     * @since 1.4\n+     */\n+    public static byte[] md5(InputStream data) throws IOException {\n+        return digest(getMd5Digest(), data);\n+    }\n+\n+    /**\n+     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return MD5 digest\n+     */\n+    public static byte[] md5(String data) {\n+        return md5(getBytesUtf8(data));\n+    }\n+\n+    /**\n+     * Calculates the MD5 digest and returns the value as a 32 character hex string.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return MD5 digest as a hex string\n+     */\n+    public static String md5Hex(byte[] data) {\n+        return Hex.encodeHexString(md5(data));\n+    }\n+\n+    /**\n+     * Calculates the MD5 digest and returns the value as a 32 character hex string.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return MD5 digest as a hex string\n+     * @throws IOException\n+     *             On error reading from the stream\n+     * @since 1.4\n+     */\n+    public static String md5Hex(InputStream data) throws IOException {\n+        return Hex.encodeHexString(md5(data));\n+    }\n+\n+    /**\n+     * Calculates the MD5 digest and returns the value as a 32 character hex string.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return MD5 digest as a hex string\n+     */\n+    public static String md5Hex(String data) {\n+        return Hex.encodeHexString(md5(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-1 digest\n+     */\n+    public static byte[] sha(byte[] data) {\n+        return getShaDigest().digest(data);\n+    }\n+\n+    /**\n+     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-1 digest\n+     * @throws IOException\n+     *             On error reading from the stream\n+     * @since 1.4\n+     */\n+    public static byte[] sha(InputStream data) throws IOException {\n+        return digest(getShaDigest(), data);\n+    }\n+\n+    /**\n+     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-1 digest\n+     */\n+    public static byte[] sha(String data) {\n+        return sha(getBytesUtf8(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-256 digest\n+     * @since 1.4\n+     */\n+    public static byte[] sha256(byte[] data) {\n+        return getSha256Digest().digest(data);\n+    }\n+\n+    /**\n+     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-256 digest\n+     * @throws IOException\n+     *             On error reading from the stream\n+     * @since 1.4\n+     */\n+    public static byte[] sha256(InputStream data) throws IOException {\n+        return digest(getSha256Digest(), data);\n+    }\n+\n+    /**\n+     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-256 digest\n+     * @since 1.4\n+     */\n+    public static byte[] sha256(String data) {\n+        return sha256(getBytesUtf8(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-256 digest and returns the value as a hex string.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-256 digest as a hex string\n+     * @since 1.4\n+     */\n+    public static String sha256Hex(byte[] data) {\n+        return Hex.encodeHexString(sha256(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-256 digest and returns the value as a hex string.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-256 digest as a hex string\n+     * @throws IOException\n+     *             On error reading from the stream\n+     * @since 1.4\n+     */\n+    public static String sha256Hex(InputStream data) throws IOException {\n+        return Hex.encodeHexString(sha256(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-256 digest and returns the value as a hex string.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-256 digest as a hex string\n+     * @since 1.4\n+     */\n+    public static String sha256Hex(String data) {\n+        return Hex.encodeHexString(sha256(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-384 digest\n+     * @since 1.4\n+     */\n+    public static byte[] sha384(byte[] data) {\n+        return getSha384Digest().digest(data);\n+    }\n+\n+    /**\n+     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-384 digest\n+     * @throws IOException\n+     *             On error reading from the stream\n+     * @since 1.4\n+     */\n+    public static byte[] sha384(InputStream data) throws IOException {\n+        return digest(getSha384Digest(), data);\n+    }\n+\n+    /**\n+     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-384 digest\n+     * @since 1.4\n+     */\n+    public static byte[] sha384(String data) {\n+        return sha384(getBytesUtf8(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-384 digest and returns the value as a hex string.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-384 digest as a hex string\n+     * @since 1.4\n+     */\n+    public static String sha384Hex(byte[] data) {\n+        return Hex.encodeHexString(sha384(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-384 digest and returns the value as a hex string.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-384 digest as a hex string\n+     * @throws IOException\n+     *             On error reading from the stream\n+     * @since 1.4\n+     */\n+    public static String sha384Hex(InputStream data) throws IOException {\n+        return Hex.encodeHexString(sha384(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-384 digest and returns the value as a hex string.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-384 digest as a hex string\n+     * @since 1.4\n+     */\n+    public static String sha384Hex(String data) {\n+        return Hex.encodeHexString(sha384(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-512 digest\n+     * @since 1.4\n+     */\n+    public static byte[] sha512(byte[] data) {\n+        return getSha512Digest().digest(data);\n+    }\n+\n+    /**\n+     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-512 digest\n+     * @throws IOException\n+     *             On error reading from the stream\n+     * @since 1.4\n+     */\n+    public static byte[] sha512(InputStream data) throws IOException {\n+        return digest(getSha512Digest(), data);\n+    }\n+\n+    /**\n+     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-512 digest\n+     * @since 1.4\n+     */\n+    public static byte[] sha512(String data) {\n+        return sha512(getBytesUtf8(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-512 digest and returns the value as a hex string.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-512 digest as a hex string\n+     * @since 1.4\n+     */\n+    public static String sha512Hex(byte[] data) {\n+        return Hex.encodeHexString(sha512(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-512 digest and returns the value as a hex string.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-512 digest as a hex string\n+     * @throws IOException\n+     *             On error reading from the stream\n+     * @since 1.4\n+     */\n+    public static String sha512Hex(InputStream data) throws IOException {\n+        return Hex.encodeHexString(sha512(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-512 digest and returns the value as a hex string.\n+     * <p>\n+     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\n+     * </p>\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-512 digest as a hex string\n+     * @since 1.4\n+     */\n+    public static String sha512Hex(String data) {\n+        return Hex.encodeHexString(sha512(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-1 digest and returns the value as a hex string.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-1 digest as a hex string\n+     */\n+    public static String shaHex(byte[] data) {\n+        return Hex.encodeHexString(sha(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-1 digest and returns the value as a hex string.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-1 digest as a hex string\n+     * @throws IOException\n+     *             On error reading from the stream\n+     * @since 1.4\n+     */\n+    public static String shaHex(InputStream data) throws IOException {\n+        return Hex.encodeHexString(sha(data));\n+    }\n+\n+    /**\n+     * Calculates the SHA-1 digest and returns the value as a hex string.\n+     * \n+     * @param data\n+     *            Data to digest\n+     * @return SHA-1 digest as a hex string\n+     */\n+    public static String shaHex(String data) {\n+        return Hex.encodeHexString(sha(data));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/AbstractCaverphone.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * Encodes a string into a Caverphone value.\n+ * \n+ * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\n+ * algorithm:\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id: Caverphone.java 1075947 2011-03-01 17:56:14Z ggregory $\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n+ * @since 1.5\n+ */\n+public abstract class AbstractCaverphone implements StringEncoder {\n+\n+    /**\n+     * Creates an instance of the Caverphone encoder\n+     */\n+    public AbstractCaverphone() {\n+        super();\n+    }\n+\n+    /**\n+     * Encodes an Object using the caverphone algorithm. This method is provided in order to satisfy the requirements of\n+     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\n+     * \n+     * @param source\n+     *            Object to encode\n+     * @return An object (or type java.lang.String) containing the caverphone code which corresponds to the String\n+     *         supplied.\n+     * @throws EncoderException\n+     *             if the parameter supplied is not of type java.lang.String\n+     */\n+    public Object encode(Object source) throws EncoderException {\n+        if (!(source instanceof String)) {\n+            throw new EncoderException(\"Parameter supplied to Caverphone encode is not of type java.lang.String\");\n+        }\n+        return this.encode((String) source);\n+    }\n+\n+    /**\n+     * Tests if the encodings of two strings are equal.\n+     * \n+     * This method might be promoted to a new AbstractStringEncoder superclass.\n+     * \n+     * @param str1\n+     *            First of two strings to compare\n+     * @param str2\n+     *            Second of two strings to compare\n+     * @return <code>true</code> if the encodings of these strings are identical, <code>false</code> otherwise.\n+     * @throws EncoderException\n+     */\n+    public boolean isEncodeEqual(String str1, String str2) throws EncoderException {\n+        return this.encode(str1).equals(this.encode(str2));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/Caverphone1.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+/**\n+ * Encodes a string into a Caverphone 1.0 value.\n+ * \n+ * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 1.0\n+ * algorithm:\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id: Caverphone.java 1075947 2011-03-01 17:56:14Z ggregory $\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n+ * @see <a href=\"http://caversham.otago.ac.nz/files/working/ctp060902.pdf\">Caverphone 1.0 specification</a>\n+ * @since 1.5\n+ */\n+public class Caverphone1 extends AbstractCaverphone {\n+\n+    private static final String SIX_1 = \"111111\";\n+\n+    /**\n+     * Encodes the given String into a Caverphone value.\n+     * \n+     * @param source\n+     *            String the source string\n+     * @return A caverphone code for the given String\n+     */\n+    public String encode(String source) {\n+        String txt = source;\n+        if (txt == null || txt.length() == 0) {\n+            return SIX_1;\n+        }\n+\n+        // 1. Convert to lowercase\n+        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n+\n+        // 2. Remove anything not A-Z\n+        txt = txt.replaceAll(\"[^a-z]\", \"\");\n+\n+        // 3. Handle various start options\n+        // 2 is a temporary placeholder to indicate a consonant which we are no longer interested in.\n+        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n+        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n+        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n+        txt = txt.replaceAll(\"^enough\", \"enou2f\");\n+        txt = txt.replaceAll(\"^gn\", \"2n\");\n+\n+        // End\n+        txt = txt.replaceAll(\"mb$\", \"m2\");\n+\n+        // 4. Handle replacements\n+        txt = txt.replaceAll(\"cq\", \"2q\");\n+        txt = txt.replaceAll(\"ci\", \"si\");\n+        txt = txt.replaceAll(\"ce\", \"se\");\n+        txt = txt.replaceAll(\"cy\", \"sy\");\n+        txt = txt.replaceAll(\"tch\", \"2ch\");\n+        txt = txt.replaceAll(\"c\", \"k\");\n+        txt = txt.replaceAll(\"q\", \"k\");\n+        txt = txt.replaceAll(\"x\", \"k\");\n+        txt = txt.replaceAll(\"v\", \"f\");\n+        txt = txt.replaceAll(\"dg\", \"2g\");\n+        txt = txt.replaceAll(\"tio\", \"sio\");\n+        txt = txt.replaceAll(\"tia\", \"sia\");\n+        txt = txt.replaceAll(\"d\", \"t\");\n+        txt = txt.replaceAll(\"ph\", \"fh\");\n+        txt = txt.replaceAll(\"b\", \"p\");\n+        txt = txt.replaceAll(\"sh\", \"s2\");\n+        txt = txt.replaceAll(\"z\", \"s\");\n+        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n+        // 3 is a temporary placeholder marking a vowel\n+        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n+        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n+        txt = txt.replaceAll(\"gh\", \"22\");\n+        txt = txt.replaceAll(\"g\", \"k\");\n+        txt = txt.replaceAll(\"s+\", \"S\");\n+        txt = txt.replaceAll(\"t+\", \"T\");\n+        txt = txt.replaceAll(\"p+\", \"P\");\n+        txt = txt.replaceAll(\"k+\", \"K\");\n+        txt = txt.replaceAll(\"f+\", \"F\");\n+        txt = txt.replaceAll(\"m+\", \"M\");\n+        txt = txt.replaceAll(\"n+\", \"N\");\n+        txt = txt.replaceAll(\"w3\", \"W3\");\n+        txt = txt.replaceAll(\"wy\", \"Wy\"); // 1.0 only\n+        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n+        txt = txt.replaceAll(\"why\", \"Why\"); // 1.0 only\n+        txt = txt.replaceAll(\"w\", \"2\");\n+        txt = txt.replaceAll(\"^h\", \"A\");\n+        txt = txt.replaceAll(\"h\", \"2\");\n+        txt = txt.replaceAll(\"r3\", \"R3\");\n+        txt = txt.replaceAll(\"ry\", \"Ry\"); // 1.0 only\n+        txt = txt.replaceAll(\"r\", \"2\");\n+        txt = txt.replaceAll(\"l3\", \"L3\");\n+        txt = txt.replaceAll(\"ly\", \"Ly\"); // 1.0 only\n+        txt = txt.replaceAll(\"l\", \"2\");\n+        txt = txt.replaceAll(\"j\", \"y\"); // 1.0 only\n+        txt = txt.replaceAll(\"y3\", \"Y3\"); // 1.0 only\n+        txt = txt.replaceAll(\"y\", \"2\"); // 1.0 only\n+\n+        // 5. Handle removals\n+        txt = txt.replaceAll(\"2\", \"\");\n+        txt = txt.replaceAll(\"3\", \"\");\n+\n+        // 6. put ten 1s on the end\n+        txt = txt + SIX_1;\n+\n+        // 7. take the first six characters as the code\n+        return txt.substring(0, SIX_1.length());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/Caverphone2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+/**\n+ * Encodes a string into a Caverphone 2.0 value.\n+ * \n+ * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\n+ * algorithm:\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id: Caverphone.java 1075947 2011-03-01 17:56:14Z ggregory $\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n+ * @see <a href=\"http://caversham.otago.ac.nz/files/working/ctp150804.pdf\">Caverphone 2.0 specification</a>\n+ * @since 1.5\n+ */\n+public class Caverphone2 extends AbstractCaverphone {\n+\n+    private static final String TEN_1 = \"1111111111\";\n+\n+    /**\n+     * Encodes the given String into a Caverphone 2.0 value.\n+     * \n+     * @param source\n+     *            String the source string\n+     * @return A caverphone code for the given String\n+     */\n+    public String encode(String source) {\n+        String txt = source;\n+        if (txt == null || txt.length() == 0) {\n+            return TEN_1;\n+        }\n+\n+        // 1. Convert to lowercase\n+        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n+\n+        // 2. Remove anything not A-Z\n+        txt = txt.replaceAll(\"[^a-z]\", \"\");\n+\n+        // 2.5. Remove final e\n+        txt = txt.replaceAll(\"e$\", \"\"); // 2.0 only\n+\n+        // 3. Handle various start options\n+        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n+        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n+        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n+        txt = txt.replaceAll(\"^enough\", \"enou2f\"); // 2.0 only\n+        txt = txt.replaceAll(\"^trough\", \"trou2f\"); // 2.0 only - note the spec says ^enough here again, c+p error I assume\n+        txt = txt.replaceAll(\"^gn\", \"2n\");\n+\n+        // End\n+        txt = txt.replaceAll(\"mb$\", \"m2\");\n+\n+        // 4. Handle replacements\n+        txt = txt.replaceAll(\"cq\", \"2q\");\n+        txt = txt.replaceAll(\"ci\", \"si\");\n+        txt = txt.replaceAll(\"ce\", \"se\");\n+        txt = txt.replaceAll(\"cy\", \"sy\");\n+        txt = txt.replaceAll(\"tch\", \"2ch\");\n+        txt = txt.replaceAll(\"c\", \"k\");\n+        txt = txt.replaceAll(\"q\", \"k\");\n+        txt = txt.replaceAll(\"x\", \"k\");\n+        txt = txt.replaceAll(\"v\", \"f\");\n+        txt = txt.replaceAll(\"dg\", \"2g\");\n+        txt = txt.replaceAll(\"tio\", \"sio\");\n+        txt = txt.replaceAll(\"tia\", \"sia\");\n+        txt = txt.replaceAll(\"d\", \"t\");\n+        txt = txt.replaceAll(\"ph\", \"fh\");\n+        txt = txt.replaceAll(\"b\", \"p\");\n+        txt = txt.replaceAll(\"sh\", \"s2\");\n+        txt = txt.replaceAll(\"z\", \"s\");\n+        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n+        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n+        txt = txt.replaceAll(\"j\", \"y\"); // 2.0 only\n+        txt = txt.replaceAll(\"^y3\", \"Y3\"); // 2.0 only\n+        txt = txt.replaceAll(\"^y\", \"A\"); // 2.0 only\n+        txt = txt.replaceAll(\"y\", \"3\"); // 2.0 only\n+        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n+        txt = txt.replaceAll(\"gh\", \"22\");\n+        txt = txt.replaceAll(\"g\", \"k\");\n+        txt = txt.replaceAll(\"s+\", \"S\");\n+        txt = txt.replaceAll(\"t+\", \"T\");\n+        txt = txt.replaceAll(\"p+\", \"P\");\n+        txt = txt.replaceAll(\"k+\", \"K\");\n+        txt = txt.replaceAll(\"f+\", \"F\");\n+        txt = txt.replaceAll(\"m+\", \"M\");\n+        txt = txt.replaceAll(\"n+\", \"N\");\n+        txt = txt.replaceAll(\"w3\", \"W3\");\n+        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n+        txt = txt.replaceAll(\"w$\", \"3\"); // 2.0 only\n+        txt = txt.replaceAll(\"w\", \"2\");\n+        txt = txt.replaceAll(\"^h\", \"A\");\n+        txt = txt.replaceAll(\"h\", \"2\");\n+        txt = txt.replaceAll(\"r3\", \"R3\");\n+        txt = txt.replaceAll(\"r$\", \"3\"); // 2.0 only\n+        txt = txt.replaceAll(\"r\", \"2\");\n+        txt = txt.replaceAll(\"l3\", \"L3\");\n+        txt = txt.replaceAll(\"l$\", \"3\"); // 2.0 only\n+        txt = txt.replaceAll(\"l\", \"2\");\n+\n+        // 5. Handle removals\n+        txt = txt.replaceAll(\"2\", \"\");\n+        txt = txt.replaceAll(\"3$\", \"A\"); // 2.0 only\n+        txt = txt.replaceAll(\"3\", \"\");\n+\n+        // 6. put ten 1s on the end\n+        txt = txt + TEN_1;\n+\n+        // 7. take the first ten characters as the code\n+        return txt.substring(0, TEN_1.length());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/ColognePhonetic.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import java.util.Locale;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * <p>\n+ * Encodes a string into a Cologne Phonetic value.\n+ * </p>\n+ * <p>\n+ * Implements the <a href=\"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\">K&ouml;lner Phonetik</a> (Cologne Phonetic)\n+ * algorithm issued by Hans Joachim Postel in 1969.\n+ * </p>\n+ * \n+ * <p>\n+ * The <i>K&ouml;lner Phonetik</i> is a phonetic algorithm which is optimized for the German language. It is related to the\n+ * well-known soundex algorithm.\n+ * </p>\n+ * \n+ * <h2>Algorithm</h2>\n+ * \n+ * <ul>\n+ * \n+ * <li>\n+ * <h3>Step 1:</h3>\n+ * After preprocessing (conversion to upper case, transcription of <a\n+ * href=\"http://en.wikipedia.org/wiki/Germanic_umlaut\">germanic umlauts</a>, removal of non alphabetical characters) the\n+ * letters of the supplied text are replaced by their phonetic code according to the following table.\n+ * <table border=\"1\">\n+ * <tbody>\n+ * <tr>\n+ * <th>Letter</th>\n+ * <th>Context</th>\n+ * <th align=\"center\">Code</th>\n+ * </tr>\n+ * <tr>\n+ * <td>A, E, I, J, O, U, Y</td>\n+ * <td></td>\n+ * <td align=\"center\">0</td>\n+ * </tr>\n+ * <tr>\n+ * \n+ * <td>H</td>\n+ * <td></td>\n+ * <td align=\"center\">-</td>\n+ * </tr>\n+ * <tr>\n+ * <td>B</td>\n+ * <td></td>\n+ * <td rowspan=\"2\" align=\"center\">1</td>\n+ * </tr>\n+ * <tr>\n+ * <td>P</td>\n+ * <td>not before H</td>\n+ * \n+ * </tr>\n+ * <tr>\n+ * <td>D, T</td>\n+ * <td>not before C, S, Z</td>\n+ * <td align=\"center\">2</td>\n+ * </tr>\n+ * <tr>\n+ * <td>F, V, W</td>\n+ * <td></td>\n+ * <td rowspan=\"2\" align=\"center\">3</td>\n+ * </tr>\n+ * <tr>\n+ * \n+ * <td>P</td>\n+ * <td>before H</td>\n+ * </tr>\n+ * <tr>\n+ * <td>G, K, Q</td>\n+ * <td></td>\n+ * <td rowspan=\"3\" align=\"center\">4</td>\n+ * </tr>\n+ * <tr>\n+ * <td rowspan=\"2\">C</td>\n+ * <td>at onset before A, H, K, L, O, Q, R, U, X</td>\n+ * \n+ * </tr>\n+ * <tr>\n+ * <td>before A, H, K, O, Q, U, X except after S, Z</td>\n+ * </tr>\n+ * <tr>\n+ * <td>X</td>\n+ * <td>not after C, K, Q</td>\n+ * <td align=\"center\">48</td>\n+ * </tr>\n+ * <tr>\n+ * <td>L</td>\n+ * <td></td>\n+ * \n+ * <td align=\"center\">5</td>\n+ * </tr>\n+ * <tr>\n+ * <td>M, N</td>\n+ * <td></td>\n+ * <td align=\"center\">6</td>\n+ * </tr>\n+ * <tr>\n+ * <td>R</td>\n+ * <td></td>\n+ * <td align=\"center\">7</td>\n+ * </tr>\n+ * \n+ * <tr>\n+ * <td>S, Z</td>\n+ * <td></td>\n+ * <td rowspan=\"6\" align=\"center\">8</td>\n+ * </tr>\n+ * <tr>\n+ * <td rowspan=\"3\">C</td>\n+ * <td>after S, Z</td>\n+ * </tr>\n+ * <tr>\n+ * <td>at onset except before A, H, K, L, O, Q, R, U, X</td>\n+ * </tr>\n+ * \n+ * <tr>\n+ * <td>not before A, H, K, O, Q, U, X</td>\n+ * </tr>\n+ * <tr>\n+ * <td>D, T</td>\n+ * <td>before C, S, Z</td>\n+ * </tr>\n+ * <tr>\n+ * <td>X</td>\n+ * <td>after C, K, Q</td>\n+ * </tr>\n+ * </tbody>\n+ * </table>\n+ * <p>\n+ * <small><i>(Source: <a href= \"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik#Buchstabencodes\" >Wikipedia (de):\n+ * K&ouml;lner Phonetik -- Buchstabencodes</a>)</i></small>\n+ * </p>\n+ * \n+ * <h4>Example:</h4>\n+ * \n+ * {@code \"M}&uuml;{@code ller-L}&uuml;{@code denscheidt\" => \"MULLERLUDENSCHEIDT\" => \"6005507500206880022\"}\n+ * \n+ * </li>\n+ * \n+ * <li>\n+ * <h3>Step 2:</h3>\n+ * Collapse of all multiple consecutive code digits.\n+ * <h4>Example:</h4>\n+ * {@code \"6005507500206880022\" => \"6050750206802\"}</li>\n+ * \n+ * <li>\n+ * <h3>Step 3:</h3>\n+ * Removal of all codes \"0\" except at the beginning. This means that two or more identical consecutive digits can occur\n+ * if they occur after removing the \"0\" digits.\n+ * \n+ * <h4>Example:</h4>\n+ * {@code \"6050750206802\" => \"65752682\"}</li>\n+ * \n+ * </ul>\n+ * \n+ * @see <a href=\"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\">Wikipedia (de): K&ouml;lner Phonetik (in German)</a>\n+ * @author Apache Software Foundation\n+ * @since 1.5\n+ */\n+public class ColognePhonetic implements StringEncoder {\n+\n+    private abstract class CologneBuffer {\n+\n+        protected final char[] data;\n+\n+        protected int length = 0;\n+\n+        public CologneBuffer(char[] data) {\n+            this.data = data;\n+            this.length = data.length;\n+        }\n+\n+        public CologneBuffer(int buffSize) {\n+            this.data = new char[buffSize];\n+            this.length = 0;\n+        }\n+\n+        protected abstract char[] copyData(int start, final int length);\n+\n+        public int length() {\n+            return length;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new String(copyData(0, length));\n+        }\n+    }\n+\n+    private class CologneOutputBuffer extends CologneBuffer {\n+\n+        public CologneOutputBuffer(int buffSize) {\n+            super(buffSize);\n+        }\n+\n+        public void addRight(char chr) {\n+            data[length] = chr;\n+            length++;\n+        }\n+\n+        @Override\n+        protected char[] copyData(int start, final int length) {\n+            char[] newData = new char[length];\n+            System.arraycopy(data, start, newData, 0, length);\n+            return newData;\n+        }\n+    }\n+\n+    private class CologneInputBuffer extends CologneBuffer {\n+\n+        public CologneInputBuffer(char[] data) {\n+            super(data);\n+        }\n+\n+        public void addLeft(char ch) {\n+            length++;\n+            data[getNextPos()] = ch;\n+        }\n+\n+        @Override\n+        protected char[] copyData(int start, final int length) {\n+            char[] newData = new char[length];\n+            System.arraycopy(data, data.length - this.length + start, newData, 0, length);\n+            return newData;\n+        }\n+\n+        public char getNextChar() {\n+            return data[getNextPos()];\n+        }\n+\n+        protected int getNextPos() {\n+            return data.length - length;\n+        }\n+\n+        public char removeNext() {\n+            char ch = getNextChar();\n+            length--;\n+            return ch;\n+        }\n+    }\n+\n+    /**\n+     * Maps some Germanic characters to plain for internal processing. The following characters are mapped:\n+     * <ul>\n+     * <li>capital a, umlaut mark</li>\n+     * <li>capital u, umlaut mark</li>\n+     * <li>capital o, umlaut mark</li>\n+     * <li>small sharp s, German</li>\n+     * </ul>\n+     */\n+    private static final char[][] PREPROCESS_MAP = new char[][]{\n+        {'\\u00C4', 'A'}, // capital a, umlaut mark\n+        {'\\u00DC', 'U'}, // capital u, umlaut mark\n+        {'\\u00D6', 'O'}, // capital o, umlaut mark\n+        {'\\u00DF', 'S'} // small sharp s, German\n+    };\n+\n+    /*\n+     * Returns whether the array contains the key, or not.\n+     */\n+    private static boolean arrayContains(char[] arr, char key) {\n+        for (char element : arr) {\n+            if (element == key) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>\n+     * Implements the <i>K&ouml;lner Phonetik</i> algorithm.\n+     * </p>\n+     * <p>\n+     * In contrast to the initial description of the algorithm, this implementation does the encoding in one pass.\n+     * </p>\n+     * \n+     * @param text\n+     * @return the corresponding encoding according to the <i>K&ouml;lner Phonetik</i> algorithm\n+     */\n+    public String colognePhonetic(String text) {\n+        if (text == null) {\n+            return null;\n+        }\n+\n+        text = preprocess(text);\n+\n+        CologneOutputBuffer output = new CologneOutputBuffer(text.length() * 2);\n+        CologneInputBuffer input = new CologneInputBuffer(text.toCharArray());\n+\n+        char nextChar;\n+\n+        char lastChar = '-';\n+        char lastCode = '/';\n+        char code;\n+        char chr;\n+\n+        int rightLength = input.length();\n+\n+        while (rightLength > 0) {\n+            chr = input.removeNext();\n+\n+            if ((rightLength = input.length()) > 0) {\n+                nextChar = input.getNextChar();\n+            } else {\n+                nextChar = '-';\n+            }\n+\n+            if (arrayContains(new char[]{'A', 'E', 'I', 'J', 'O', 'U', 'Y'}, chr)) {\n+                code = '0';\n+            } else if (chr == 'H' || chr < 'A' || chr > 'Z') {\n+                if (lastCode == '/') {\n+                    continue;\n+                }\n+                code = '-';\n+            } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {\n+                code = '1';\n+            } else if ((chr == 'D' || chr == 'T') && !arrayContains(new char[]{'S', 'C', 'Z'}, nextChar)) {\n+                code = '2';\n+            } else if (arrayContains(new char[]{'W', 'F', 'P', 'V'}, chr)) {\n+                code = '3';\n+            } else if (arrayContains(new char[]{'G', 'K', 'Q'}, chr)) {\n+                code = '4';\n+            } else if (chr == 'X' && !arrayContains(new char[]{'C', 'K', 'Q'}, lastChar)) {\n+                code = '4';\n+                input.addLeft('S');\n+                rightLength++;\n+            } else if (chr == 'S' || chr == 'Z') {\n+                code = '8';\n+            } else if (chr == 'C') {\n+                if (lastCode == '/') {\n+                    if (arrayContains(new char[]{'A', 'H', 'K', 'L', 'O', 'Q', 'R', 'U', 'X'}, nextChar)) {\n+                        code = '4';\n+                    } else {\n+                        code = '8';\n+                    }\n+                } else {\n+                    if (arrayContains(new char[]{'S', 'Z'}, lastChar) ||\n+                        !arrayContains(new char[]{'A', 'H', 'O', 'U', 'K', 'Q', 'X'}, nextChar)) {\n+                        code = '8';\n+                    } else {\n+                        code = '4';\n+                    }\n+                }\n+            } else if (arrayContains(new char[]{'T', 'D', 'X'}, chr)) {\n+                code = '8';\n+            } else if (chr == 'R') {\n+                code = '7';\n+            } else if (chr == 'L') {\n+                code = '5';\n+            } else if (chr == 'M' || chr == 'N') {\n+                code = '6';\n+            } else {\n+                code = chr;\n+            }\n+\n+            if (code != '-' && (lastCode != code && (code != '0' || lastCode == '/') || code < '0' || code > '8')) {\n+                output.addRight(code);\n+            }\n+\n+            lastChar = chr;\n+            lastCode = code;\n+        }\n+        return output.toString();\n+    }\n+\n+    public Object encode(Object object) throws EncoderException {\n+        if (!(object instanceof String)) {\n+            throw new EncoderException(\"This method's parameter was expected to be of the type \" +\n+                String.class.getName() +\n+                \". But actually it was of the type \" +\n+                object.getClass().getName() +\n+                \".\");\n+        }\n+        return encode((String) object);\n+    }\n+\n+    public String encode(String text) {\n+        return colognePhonetic(text);\n+    }\n+\n+    public boolean isEncodeEqual(String text1, String text2) {\n+        return colognePhonetic(text1).equals(colognePhonetic(text2));\n+    }\n+\n+    /**\n+     * Converts the string to upper case and replaces germanic characters as defined in {@link #PREPROCESS_MAP}.\n+     */\n+    private String preprocess(String text) {\n+        text = text.toUpperCase(Locale.GERMAN);\n+\n+        char[] chrs = text.toCharArray();\n+\n+        for (int index = 0; index < chrs.length; index++) {\n+            if (chrs[index] > 'Z') {\n+                for (char[] element : PREPROCESS_MAP) {\n+                    if (chrs[index] == element[0]) {\n+                        chrs[index] = element[1];\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        return new String(chrs);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * Encodes a string into a double metaphone value.\n+ * This Implementation is based on the algorithm by <CITE>Lawrence Philips</CITE>.\n+ * <ul>\n+ * <li>Original Article: <a \n+ * href=\"http://www.cuj.com/documents/s=8038/cuj0006philips/\">\n+ * http://www.cuj.com/documents/s=8038/cuj0006philips/</a></li>\n+ * <li>Original Source Code: <a href=\"ftp://ftp.cuj.com/pub/2000/1806/philips.zip\">\n+ * ftp://ftp.cuj.com/pub/2000/1806/philips.zip</a></li>\n+ * </ul>\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class DoubleMetaphone implements StringEncoder {\n+\n+    /**\n+     * \"Vowels\" to test for\n+     */\n+    private static final String VOWELS = \"AEIOUY\";\n+\n+    /**\n+     * Prefixes when present which are not pronounced\n+     */\n+    private static final String[] SILENT_START = \n+    { \"GN\", \"KN\", \"PN\", \"WR\", \"PS\" };\n+    private static final String[] L_R_N_M_B_H_F_V_W_SPACE = \n+    { \"L\", \"R\", \"N\", \"M\", \"B\", \"H\", \"F\", \"V\", \"W\", \" \" };\n+    private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER = \n+    { \"ES\", \"EP\", \"EB\", \"EL\", \"EY\", \"IB\", \"IL\", \"IN\", \"IE\", \"EI\", \"ER\" };\n+    private static final String[] L_T_K_S_N_M_B_Z = \n+    { \"L\", \"T\", \"K\", \"S\", \"N\", \"M\", \"B\", \"Z\" };\n+\n+    /**\n+     * Maximum length of an encoding, default is 4\n+     */\n+    private int maxCodeLen = 4;\n+\n+    /**\n+     * Creates an instance of this DoubleMetaphone encoder\n+     */\n+    public DoubleMetaphone() {\n+        super();\n+    }\n+    \n+    /**\n+     * Encode a value with Double Metaphone\n+     *\n+     * @param value String to encode\n+     * @return an encoded string\n+     */\n+    public String doubleMetaphone(String value) {\n+        return doubleMetaphone(value, false);\n+    }\n+    \n+    /**\n+     * Encode a value with Double Metaphone, optionally using the alternate\n+     * encoding.\n+     *\n+     * @param value String to encode\n+     * @param alternate use alternate encode\n+     * @return an encoded string\n+     */\n+    public String doubleMetaphone(String value, boolean alternate) {\n+        value = cleanInput(value);\n+        if (value == null) {\n+            return null;\n+        }\n+        \n+        boolean slavoGermanic = isSlavoGermanic(value);\n+        int index = isSilentStart(value) ? 1 : 0;\n+        \n+        DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n+        \n+        while (!result.isComplete() && index <= value.length() - 1) {\n+            switch (value.charAt(index)) {\n+            case 'A':\n+            case 'E':\n+            case 'I':\n+            case 'O':\n+            case 'U':\n+            case 'Y':\n+                index = handleAEIOUY(result, index);\n+                break;\n+            case 'B':\n+                result.append('P');\n+                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\n+                break;\n+            case '\\u00C7':\n+                // A C with a Cedilla\n+                result.append('S');\n+                index++;\n+                break; \n+            case 'C':\n+                index = handleC(value, result, index);\n+                break;\n+            case 'D':\n+                index = handleD(value, result, index);\n+                break;\n+            case 'F':\n+                result.append('F');\n+                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\n+                break;\n+            case 'G':\n+                index = handleG(value, result, index, slavoGermanic);\n+                break;\n+            case 'H':\n+                index = handleH(value, result, index);\n+                break;\n+            case 'J':\n+                index = handleJ(value, result, index, slavoGermanic);\n+                break;\n+            case 'K':\n+                result.append('K');\n+                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\n+                break;\n+            case 'L':\n+                index = handleL(value, result, index);\n+                break;\n+            case 'M':\n+                result.append('M');\n+                index = conditionM0(value, index) ? index + 2 : index + 1;\n+                break;\n+            case 'N':\n+                result.append('N');\n+                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\n+                break;\n+            case '\\u00D1':\n+                // N with a tilde (spanish ene)\n+                result.append('N');\n+                index++;\n+                break;\n+            case 'P':\n+                index = handleP(value, result, index);\n+                break;\n+            case 'Q':\n+                result.append('K');\n+                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\n+                break;\n+            case 'R':\n+                index = handleR(value, result, index, slavoGermanic);\n+                break;\n+            case 'S':\n+                index = handleS(value, result, index, slavoGermanic);\n+                break;\n+            case 'T':\n+                index = handleT(value, result, index);\n+                break;\n+            case 'V':\n+                result.append('F');\n+                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\n+                break;\n+            case 'W':\n+                index = handleW(value, result, index);\n+                break;\n+            case 'X':\n+                index = handleX(value, result, index);\n+                break;\n+            case 'Z':\n+                index = handleZ(value, result, index, slavoGermanic);\n+                break;\n+            default:\n+                index++;\n+                break;\n+            }\n+        }\n+\n+        return alternate ? result.getAlternate() : result.getPrimary();\n+    }\n+    \n+    /**\n+     * Encode the value using DoubleMetaphone.  It will only work if \n+     * <code>obj</code> is a <code>String</code> (like <code>Metaphone</code>).\n+     *\n+     * @param obj Object to encode (should be of type String)\n+     * @return An encoded Object (will be of type String)\n+     * @throws EncoderException encode parameter is not of type String\n+     */\n+    public Object encode(Object obj) throws EncoderException {\n+        if (!(obj instanceof String)) {\n+            throw new EncoderException(\"DoubleMetaphone encode parameter is not of type String\"); \n+        } \n+        return doubleMetaphone((String) obj);\n+    }\n+\n+    /**\n+     * Encode the value using DoubleMetaphone.\n+     *\n+     * @param value String to encode\n+     * @return An encoded String\n+     */\n+    public String encode(String value) {\n+        return doubleMetaphone(value);   \n+    }\n+\n+    /**\n+     * Check if the Double Metaphone values of two <code>String</code> values\n+     * are equal.\n+     * \n+     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n+     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n+     * @return <code>true</code> if the encoded <code>String</code>s are equal;\n+     *          <code>false</code> otherwise.\n+     * @see #isDoubleMetaphoneEqual(String,String,boolean)\n+     */\n+    public boolean isDoubleMetaphoneEqual(String value1, String value2) {\n+        return isDoubleMetaphoneEqual(value1, value2, false);\n+    }\n+    \n+    /**\n+     * Check if the Double Metaphone values of two <code>String</code> values\n+     * are equal, optionally using the alternate value.\n+     * \n+     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n+     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n+     * @param alternate use the alternate value if <code>true</code>.\n+     * @return <code>true</code> if the encoded <code>String</code>s are equal;\n+     *          <code>false</code> otherwise.\n+     */\n+    public boolean isDoubleMetaphoneEqual(String value1, \n+                                          String value2, \n+                                          boolean alternate) {\n+        return doubleMetaphone(value1, alternate).equals(doubleMetaphone\n+                                                         (value2, alternate));\n+    }\n+    \n+    /**\n+     * Returns the maxCodeLen.\n+     * @return int\n+     */\n+    public int getMaxCodeLen() {\n+        return this.maxCodeLen;\n+    }\n+\n+    /**\n+     * Sets the maxCodeLen.\n+     * @param maxCodeLen The maxCodeLen to set\n+     */\n+    public void setMaxCodeLen(int maxCodeLen) {\n+        this.maxCodeLen = maxCodeLen;\n+    }\n+\n+    //-- BEGIN HANDLERS --//\n+\n+    /**\n+     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases\n+     */\n+    private int handleAEIOUY(DoubleMetaphoneResult result, int \n+                             index) {\n+        if (index == 0) {\n+            result.append('A');\n+        }\n+        return index + 1;\n+    }\n+    \n+    /**\n+     * Handles 'C' cases\n+     */\n+    private int handleC(String value, \n+                        DoubleMetaphoneResult result, \n+                        int index) {\n+        if (conditionC0(value, index)) {  // very confusing, moved out\n+            result.append('K');\n+            index += 2;\n+        } else if (index == 0 && contains(value, index, 6, \"CAESAR\")) {\n+            result.append('S');\n+            index += 2;\n+        } else if (contains(value, index, 2, \"CH\")) {\n+            index = handleCH(value, result, index);\n+        } else if (contains(value, index, 2, \"CZ\") && \n+                   !contains(value, index - 2, 4, \"WICZ\")) {\n+            //-- \"Czerny\" --//\n+            result.append('S', 'X');\n+            index += 2;\n+        } else if (contains(value, index + 1, 3, \"CIA\")) {\n+            //-- \"focaccia\" --//\n+            result.append('X');\n+            index += 3;\n+        } else if (contains(value, index, 2, \"CC\") && \n+                   !(index == 1 && charAt(value, 0) == 'M')) {\n+            //-- double \"cc\" but not \"McClelland\" --//\n+            return handleCC(value, result, index);\n+        } else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\n+            result.append('K');\n+            index += 2;\n+        } else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\n+            //-- Italian vs. English --//\n+            if (contains(value, index, 3, \"CIO\", \"CIE\", \"CIA\")) {\n+                result.append('S', 'X');\n+            } else {\n+                result.append('S');\n+            }\n+            index += 2;\n+        } else {\n+            result.append('K');\n+            if (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) { \n+                //-- Mac Caffrey, Mac Gregor --//\n+                index += 3;\n+            } else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") && \n+                       !contains(value, index + 1, 2, \"CE\", \"CI\")) {\n+                index += 2;\n+            } else {\n+                index++;\n+            }\n+        }\n+        \n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'CC' cases\n+     */\n+    private int handleCC(String value, \n+                         DoubleMetaphoneResult result, \n+                         int index) {\n+        if (contains(value, index + 2, 1, \"I\", \"E\", \"H\") && \n+            !contains(value, index + 2, 2, \"HU\")) {\n+            //-- \"bellocchio\" but not \"bacchus\" --//\n+            if ((index == 1 && charAt(value, index - 1) == 'A') || \n+                contains(value, index - 1, 5, \"UCCEE\", \"UCCES\")) {\n+                //-- \"accident\", \"accede\", \"succeed\" --//\n+                result.append(\"KS\");\n+            } else {\n+                //-- \"bacci\", \"bertucci\", other Italian --//\n+                result.append('X');\n+            }\n+            index += 3;\n+        } else {    // Pierce's rule\n+            result.append('K');\n+            index += 2;\n+        }\n+        \n+        return index;\n+    }\n+    \n+    /**\n+     * Handles 'CH' cases\n+     */\n+    private int handleCH(String value, \n+                         DoubleMetaphoneResult result, \n+                         int index) {\n+        if (index > 0 && contains(value, index, 4, \"CHAE\")) {   // Michael\n+            result.append('K', 'X');\n+            return index + 2;\n+        } else if (conditionCH0(value, index)) {\n+            //-- Greek roots (\"chemistry\", \"chorus\", etc.) --//\n+            result.append('K');\n+            return index + 2;\n+        } else if (conditionCH1(value, index)) {\n+            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//\n+            result.append('K');\n+            return index + 2;\n+        } else {\n+            if (index > 0) {\n+                if (contains(value, 0, 2, \"MC\")) {\n+                    result.append('K');\n+                } else {\n+                    result.append('X', 'K');\n+                }\n+            } else {\n+                result.append('X');\n+            }\n+            return index + 2;\n+        }\n+    }\n+\n+    /**\n+     * Handles 'D' cases\n+     */\n+    private int handleD(String value, \n+                        DoubleMetaphoneResult result, \n+                        int index) {\n+        if (contains(value, index, 2, \"DG\")) {\n+            //-- \"Edge\" --//\n+            if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n+                result.append('J');\n+                index += 3;\n+                //-- \"Edgar\" --//\n+            } else {\n+                result.append(\"TK\");\n+                index += 2;\n+            }\n+        } else if (contains(value, index, 2, \"DT\", \"DD\")) {\n+            result.append('T');\n+            index += 2;\n+        } else {\n+            result.append('T');\n+            index++;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'G' cases\n+     */\n+    private int handleG(String value, \n+                        DoubleMetaphoneResult result, \n+                        int index, \n+                        boolean slavoGermanic) {\n+        if (charAt(value, index + 1) == 'H') {\n+            index = handleGH(value, result, index);\n+        } else if (charAt(value, index + 1) == 'N') {\n+            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n+                result.append(\"KN\", \"N\");\n+            } else if (!contains(value, index + 2, 2, \"EY\") && \n+                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n+                result.append(\"N\", \"KN\");\n+            } else {\n+                result.append(\"KN\");\n+            }\n+            index = index + 2;\n+        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n+            result.append(\"KL\", \"L\");\n+            index += 2;\n+        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n+            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n+            result.append('K', 'J');\n+            index += 2;\n+        } else if ((contains(value, index + 1, 2, \"ER\") || \n+                    charAt(value, index + 1) == 'Y') &&\n+                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n+                   !contains(value, index - 1, 1, \"E\", \"I\") && \n+                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n+            //-- -ger-, -gy- --//\n+            result.append('K', 'J');\n+            index += 2;\n+        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n+                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n+            //-- Italian \"biaggi\" --//\n+            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n+                //-- obvious germanic --//\n+                result.append('K');\n+            } else if (contains(value, index + 1, 3, \"IER\")) {\n+                result.append('J');\n+            } else {\n+                result.append('J', 'K');\n+            }\n+            index += 2;\n+        } else if (charAt(value, index + 1) == 'G') {\n+            index += 2;\n+            result.append('K');\n+        } else {\n+            index++;\n+            result.append('K');\n+        }\n+        return index;\n+    }\n+    \n+    /**\n+     * Handles 'GH' cases\n+     */\n+    private int handleGH(String value, \n+                         DoubleMetaphoneResult result, \n+                         int index) {\n+        if (index > 0 && !isVowel(charAt(value, index - 1))) {\n+            result.append('K');\n+            index += 2;\n+        } else if (index == 0) {\n+            if (charAt(value, index + 2) == 'I') {\n+                result.append('J');\n+            } else {\n+                result.append('K');\n+            }\n+            index += 2;\n+        } else if ((index > 1 && contains(value, index - 2, 1, \"B\", \"H\", \"D\")) ||\n+                   (index > 2 && contains(value, index - 3, 1, \"B\", \"H\", \"D\")) ||\n+                   (index > 3 && contains(value, index - 4, 1, \"B\", \"H\"))) {\n+            //-- Parker's rule (with some further refinements) - \"hugh\"\n+            index += 2;\n+        } else {\n+            if (index > 2 && charAt(value, index - 1) == 'U' && \n+                contains(value, index - 3, 1, \"C\", \"G\", \"L\", \"R\", \"T\")) {\n+                //-- \"laugh\", \"McLaughlin\", \"cough\", \"gough\", \"rough\", \"tough\"\n+                result.append('F');\n+            } else if (index > 0 && charAt(value, index - 1) != 'I') {\n+                result.append('K');\n+            }\n+            index += 2;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'H' cases\n+     */\n+    private int handleH(String value, \n+                        DoubleMetaphoneResult result, \n+                        int index) {\n+        //-- only keep if first & before vowel or between 2 vowels --//\n+        if ((index == 0 || isVowel(charAt(value, index - 1))) && \n+            isVowel(charAt(value, index + 1))) {\n+            result.append('H');\n+            index += 2;\n+            //-- also takes car of \"HH\" --//\n+        } else {\n+            index++;\n+        }\n+        return index;\n+    }\n+    \n+    /**\n+     * Handles 'J' cases\n+     */\n+    private int handleJ(String value, DoubleMetaphoneResult result, int index, \n+                        boolean slavoGermanic) {\n+        if (contains(value, index, 4, \"JOSE\") || contains(value, 0, 4, \"SAN \")) {\n+                //-- obvious Spanish, \"Jose\", \"San Jacinto\" --//\n+                if ((index == 0 && (charAt(value, index + 4) == ' ') || \n+                     value.length() == 4) || contains(value, 0, 4, \"SAN \")) {\n+                    result.append('H');\n+                } else {\n+                    result.append('J', 'H');\n+                }\n+                index++;\n+            } else {\n+                if (index == 0 && !contains(value, index, 4, \"JOSE\")) {\n+                    result.append('J', 'A');\n+                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && \n+                              (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {\n+                    result.append('J', 'H');\n+                } else if (index == value.length() - 1) {\n+                    result.append('J', ' ');\n+                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, \"S\", \"K\", \"L\")) {\n+                    result.append('J');\n+                }\n+\n+                if (charAt(value, index + 1) == 'J') {\n+                    index += 2;\n+                } else {\n+                    index++;\n+                }\n+            }\n+        return index;\n+    }\n+    \n+    /**\n+     * Handles 'L' cases\n+     */\n+    private int handleL(String value, \n+                        DoubleMetaphoneResult result, \n+                        int index) {\n+        if (charAt(value, index + 1) == 'L') {\n+            if (conditionL0(value, index)) {\n+                result.appendPrimary('L');\n+            } else {\n+                result.append('L');\n+            }\n+            index += 2;\n+        } else {\n+            index++;\n+            result.append('L');\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'P' cases\n+     */\n+    private int handleP(String value, \n+                        DoubleMetaphoneResult result, \n+                        int index) {\n+        if (charAt(value, index + 1) == 'H') {\n+            result.append('F');\n+            index += 2;\n+        } else {\n+            result.append('P');\n+            index = contains(value, index + 1, 1, \"P\", \"B\") ? index + 2 : index + 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'R' cases\n+     */\n+    private int handleR(String value, \n+                        DoubleMetaphoneResult result, \n+                        int index, \n+                        boolean slavoGermanic) {\n+        if (index == value.length() - 1 && !slavoGermanic && \n+            contains(value, index - 2, 2, \"IE\") && \n+            !contains(value, index - 4, 2, \"ME\", \"MA\")) {\n+            result.appendAlternate('R');\n+        } else {\n+            result.append('R');\n+        }\n+        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\n+    }\n+\n+    /**\n+     * Handles 'S' cases\n+     */\n+    private int handleS(String value, \n+                        DoubleMetaphoneResult result, \n+                        int index, \n+                        boolean slavoGermanic) {\n+        if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n+            //-- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\n+            index++;\n+        } else if (index == 0 && contains(value, index, 5, \"SUGAR\")) {\n+            //-- special case \"sugar-\" --//\n+            result.append('X', 'S');\n+            index++;\n+        } else if (contains(value, index, 2, \"SH\")) {\n+            if (contains(value, index + 1, 4, \n+                         \"HEIM\", \"HOEK\", \"HOLM\", \"HOLZ\")) {\n+                //-- germanic --//\n+                result.append('S');\n+            } else {\n+                result.append('X');\n+            }\n+            index += 2;\n+        } else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, index, 4, \"SIAN\")) {\n+            //-- Italian and Armenian --//\n+            if (slavoGermanic) {\n+                result.append('S');\n+            } else {\n+                result.append('S', 'X');\n+            }\n+            index += 3;\n+        } else if ((index == 0 && contains(value, index + 1, 1, \"M\", \"N\", \"L\", \"W\")) || contains(value, index + 1, 1, \"Z\")) {\n+            //-- german & anglicisations, e.g. \"smith\" match \"schmidt\" //\n+            // \"snider\" match \"schneider\" --//\n+            //-- also, -sz- in slavic language altho in hungarian it //\n+            //   is pronounced \"s\" --//\n+            result.append('S', 'X');\n+            index = contains(value, index + 1, 1, \"Z\") ? index + 2 : index + 1;\n+        } else if (contains(value, index, 2, \"SC\")) {\n+            index = handleSC(value, result, index);\n+        } else {\n+            if (index == value.length() - 1 && contains(value, index - 2, \n+                                                        2, \"AI\", \"OI\")){\n+                //-- french e.g. \"resnais\", \"artois\" --//\n+                result.appendAlternate('S');\n+            } else {\n+                result.append('S');\n+            }\n+            index = contains(value, index + 1, 1, \"S\", \"Z\") ? index + 2 : index + 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'SC' cases\n+     */\n+    private int handleSC(String value, \n+                         DoubleMetaphoneResult result, \n+                         int index) {\n+        if (charAt(value, index + 2) == 'H') {\n+            //-- Schlesinger's rule --//\n+            if (contains(value, index + 3, \n+                         2, \"OO\", \"ER\", \"EN\", \"UY\", \"ED\", \"EM\")) {\n+                //-- Dutch origin, e.g. \"school\", \"schooner\" --//\n+                if (contains(value, index + 3, 2, \"ER\", \"EN\")) {\n+                    //-- \"schermerhorn\", \"schenker\" --//\n+                    result.append(\"X\", \"SK\");\n+                } else {\n+                    result.append(\"SK\");\n+                }\n+            } else {\n+                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {\n+                    result.append('X', 'S');\n+                } else {\n+                    result.append('X');\n+                }\n+            }\n+        } else if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n+            result.append('S');\n+        } else {\n+            result.append(\"SK\");\n+        }\n+        return index + 3;\n+    }\n+\n+    /**\n+     * Handles 'T' cases\n+     */\n+    private int handleT(String value, \n+                        DoubleMetaphoneResult result, \n+                        int index) {\n+        if (contains(value, index, 4, \"TION\")) {\n+            result.append('X');\n+            index += 3;\n+        } else if (contains(value, index, 3, \"TIA\", \"TCH\")) {\n+            result.append('X');\n+            index += 3;\n+        } else if (contains(value, index, 2, \"TH\") || contains(value, index, \n+                                                               3, \"TTH\")) {\n+            if (contains(value, index + 2, 2, \"OM\", \"AM\") || \n+                //-- special case \"thomas\", \"thames\" or germanic --//\n+                contains(value, 0, 4, \"VAN \", \"VON \") || \n+                contains(value, 0, 3, \"SCH\")) {\n+                result.append('T');\n+            } else {\n+                result.append('0', 'T');\n+            }\n+            index += 2;\n+        } else {\n+            result.append('T');\n+            index = contains(value, index + 1, 1, \"T\", \"D\") ? index + 2 : index + 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'W' cases\n+     */\n+    private int handleW(String value, \n+                        DoubleMetaphoneResult result, \n+                        int index) {\n+        if (contains(value, index, 2, \"WR\")) {\n+            //-- can also be in middle of word --//\n+            result.append('R');\n+            index += 2;\n+        } else {\n+            if (index == 0 && (isVowel(charAt(value, index + 1)) || \n+                               contains(value, index, 2, \"WH\"))) {\n+                if (isVowel(charAt(value, index + 1))) {\n+                    //-- Wasserman should match Vasserman --//\n+                    result.append('A', 'F');\n+                } else {\n+                    //-- need Uomo to match Womo --//\n+                    result.append('A');\n+                }\n+                index++;\n+            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\n+                       contains(value, index - 1, \n+                                5, \"EWSKI\", \"EWSKY\", \"OWSKI\", \"OWSKY\") ||\n+                       contains(value, 0, 3, \"SCH\")) {\n+                //-- Arnow should match Arnoff --//\n+                result.appendAlternate('F');\n+                index++;\n+            } else if (contains(value, index, 4, \"WICZ\", \"WITZ\")) {\n+                //-- Polish e.g. \"filipowicz\" --//\n+                result.append(\"TS\", \"FX\");\n+                index += 4;\n+            } else {\n+                index++;\n+            }\n+        }\n+        return index;\n+    }\n+    \n+    /**\n+     * Handles 'X' cases\n+     */\n+    private int handleX(String value, \n+                        DoubleMetaphoneResult result, \n+                        int index) {\n+        if (index == 0) {\n+            result.append('S');\n+            index++;\n+        } else {\n+            if (!((index == value.length() - 1) && \n+                  (contains(value, index - 3, 3, \"IAU\", \"EAU\") || \n+                   contains(value, index - 2, 2, \"AU\", \"OU\")))) {\n+                //-- French e.g. breaux --//\n+                result.append(\"KS\");\n+            }\n+            index = contains(value, index + 1, 1, \"C\", \"X\") ? index + 2 : index + 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'Z' cases\n+     */\n+    private int handleZ(String value, DoubleMetaphoneResult result, int index, \n+                        boolean slavoGermanic) {\n+        if (charAt(value, index + 1) == 'H') {\n+            //-- Chinese pinyin e.g. \"zhao\" or Angelina \"Zhang\" --//\n+            result.append('J');\n+            index += 2;\n+        } else {\n+            if (contains(value, index + 1, 2, \"ZO\", \"ZI\", \"ZA\") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {\n+                result.append(\"S\", \"TS\");\n+            } else {\n+                result.append('S');\n+            }\n+            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;\n+        }\n+        return index;\n+    }\n+\n+    //-- BEGIN CONDITIONS --//\n+\n+    /**\n+     * Complex condition 0 for 'C'\n+     */\n+    private boolean conditionC0(String value, int index) {\n+        if (contains(value, index, 4, \"CHIA\")) {\n+            return true;\n+        } else if (index <= 1) {\n+            return false;\n+        } else if (isVowel(charAt(value, index - 2))) {\n+            return false;\n+        } else if (!contains(value, index - 1, 3, \"ACH\")) {\n+            return false;\n+        } else {\n+            char c = charAt(value, index + 2);\n+            return (c != 'I' && c != 'E') ||\n+                    contains(value, index - 2, 6, \"BACHER\", \"MACHER\");\n+        }\n+    }\n+    \n+    /**\n+     * Complex condition 0 for 'CH'\n+     */\n+    private boolean conditionCH0(String value, int index) {\n+        if (index != 0) {\n+            return false;\n+        } else if (!contains(value, index + 1, 5, \"HARAC\", \"HARIS\") && \n+                   !contains(value, index + 1, 3, \"HOR\", \"HYM\", \"HIA\", \"HEM\")) {\n+            return false;\n+        } else if (contains(value, 0, 5, \"CHORE\")) {\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+    \n+    /**\n+     * Complex condition 1 for 'CH'\n+     */\n+    private boolean conditionCH1(String value, int index) {\n+        return ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, \n+                                                                   3, \"SCH\")) ||\n+                contains(value, index - 2, 6, \"ORCHES\", \"ARCHIT\", \"ORCHID\") ||\n+                contains(value, index + 2, 1, \"T\", \"S\") ||\n+                ((contains(value, index - 1, 1, \"A\", \"O\", \"U\", \"E\") || index == 0) &&\n+                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\n+    }\n+    \n+    /**\n+     * Complex condition 0 for 'L'\n+     */\n+    private boolean conditionL0(String value, int index) {\n+        if (index == value.length() - 3 && \n+            contains(value, index - 1, 4, \"ILLO\", \"ILLA\", \"ALLE\")) {\n+            return true;\n+        } else if ((contains(value, value.length() - 2, 2, \"AS\", \"OS\") || \n+                    contains(value, value.length() - 1, 1, \"A\", \"O\")) &&\n+                   contains(value, index - 1, 4, \"ALLE\")) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+    \n+    /**\n+     * Complex condition 0 for 'M'\n+     */\n+    private boolean conditionM0(String value, int index) {\n+        if (charAt(value, index + 1) == 'M') {\n+            return true;\n+        }\n+        return contains(value, index - 1, 3, \"UMB\") &&\n+                ((index + 1) == value.length() - 1 || contains(value,\n+                        index + 2, 2, \"ER\"));\n+    }\n+    \n+    //-- BEGIN HELPER FUNCTIONS --//\n+\n+    /**\n+     * Determines whether or not a value is of slavo-germanic orgin. A value is\n+     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n+     */\n+    private boolean isSlavoGermanic(String value) {\n+        return value.indexOf('W') > -1 || value.indexOf('K') > -1 || \n+            value.indexOf(\"CZ\") > -1 || value.indexOf(\"WITZ\") > -1;\n+    }\n+\n+    /**\n+     * Determines whether or not a character is a vowel or not\n+     */\n+    private boolean isVowel(char ch) {\n+        return VOWELS.indexOf(ch) != -1;\n+    }\n+\n+    /**\n+     * Determines whether or not the value starts with a silent letter.  It will\n+     * return <code>true</code> if the value starts with any of 'GN', 'KN',\n+     * 'PN', 'WR' or 'PS'.\n+     */    \n+    private boolean isSilentStart(String value) {\n+        boolean result = false;\n+        for (String element : SILENT_START) {\n+            if (value.startsWith(element)) {\n+                result = true;\n+                break;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Cleans the input\n+     */    \n+    private String cleanInput(String input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        input = input.trim();\n+        if (input.length() == 0) {\n+            return null;\n+        }\n+        return input.toUpperCase(java.util.Locale.ENGLISH);\n+    }\n+\n+    /**\n+     * Gets the character at index <code>index</code> if available, otherwise\n+     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\n+     * of a default\n+     */    \n+    protected char charAt(String value, int index) {\n+        if (index < 0 || index >= value.length()) {\n+            return Character.MIN_VALUE;\n+        } \n+        return value.charAt(index);\n+    }\n+\n+    /**\n+     * Shortcut method with 1 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria) {\n+        return contains(value, start, length, \n+                        new String[] { criteria });\n+    }\n+\n+    /**\n+     * Shortcut method with 2 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria1, String criteria2) {\n+        return contains(value, start, length, \n+                        new String[] { criteria1, criteria2 });\n+    }\n+\n+    /**\n+     * Shortcut method with 3 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria1, String criteria2, \n+                                    String criteria3) {\n+        return contains(value, start, length, \n+                        new String[] { criteria1, criteria2, criteria3 });\n+    }\n+\n+    /**\n+     * Shortcut method with 4 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria1, String criteria2, \n+                                    String criteria3, String criteria4) {\n+        return contains(value, start, length, \n+                        new String[] { criteria1, criteria2, criteria3, \n+                                       criteria4 });\n+    }\n+\n+    /**\n+     * Shortcut method with 5 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria1, String criteria2, \n+                                    String criteria3, String criteria4, \n+                                    String criteria5) {\n+        return contains(value, start, length, \n+                        new String[] { criteria1, criteria2, criteria3, \n+                                       criteria4, criteria5 });\n+    }\n+\n+    /**\n+     * Shortcut method with 6 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria1, String criteria2, \n+                                    String criteria3, String criteria4, \n+                                    String criteria5, String criteria6) {\n+        return contains(value, start, length, \n+                        new String[] { criteria1, criteria2, criteria3, \n+                                       criteria4, criteria5, criteria6 });\n+    }\n+    \n+    /**\n+     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\n+     * matching up to length <code>length</code>\n+     */\n+    protected static boolean contains(String value, int start, int length, \n+                                      String[] criteria) {\n+        boolean result = false;\n+        if (start >= 0 && start + length <= value.length()) {\n+            String target = value.substring(start, start + length);\n+\n+            for (String element : criteria) {\n+                if (target.equals(element)) {\n+                    result = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+    \n+    //-- BEGIN INNER CLASSES --//\n+    \n+    /**\n+     * Inner class for storing results, since there is the optional alternate\n+     * encoding.\n+     */\n+    public class DoubleMetaphoneResult {\n+\n+        private final StringBuffer primary = new StringBuffer(getMaxCodeLen());\n+        private final StringBuffer alternate = new StringBuffer(getMaxCodeLen());\n+        private final int maxLength;\n+\n+        public DoubleMetaphoneResult(int maxLength) {\n+            this.maxLength = maxLength;\n+        }\n+\n+        public void append(char value) {\n+            appendPrimary(value);\n+            appendAlternate(value);\n+        }\n+\n+        public void append(char primary, char alternate) {\n+            appendPrimary(primary);\n+            appendAlternate(alternate);\n+        }\n+\n+        public void appendPrimary(char value) {\n+            if (this.primary.length() < this.maxLength) {\n+                this.primary.append(value);\n+            }\n+        }\n+\n+        public void appendAlternate(char value) {\n+            if (this.alternate.length() < this.maxLength) {\n+                this.alternate.append(value);\n+            }\n+        }\n+\n+        public void append(String value) {\n+            appendPrimary(value);\n+            appendAlternate(value);\n+        }\n+\n+        public void append(String primary, String alternate) {\n+            appendPrimary(primary);\n+            appendAlternate(alternate);\n+        }\n+\n+        public void appendPrimary(String value) {\n+            int addChars = this.maxLength - this.primary.length();\n+            if (value.length() <= addChars) {\n+                this.primary.append(value);\n+            } else {\n+                this.primary.append(value.substring(0, addChars));\n+            }\n+        }\n+\n+        public void appendAlternate(String value) {\n+            int addChars = this.maxLength - this.alternate.length();\n+            if (value.length() <= addChars) {\n+                this.alternate.append(value);\n+            } else {\n+                this.alternate.append(value.substring(0, addChars));\n+            }\n+        }\n+\n+        public String getPrimary() {\n+            return this.primary.toString();\n+        }\n+\n+        public String getAlternate() {\n+            return this.alternate.toString();\n+        }\n+\n+        public boolean isComplete() {\n+            return this.primary.length() >= this.maxLength && \n+                this.alternate.length() >= this.maxLength;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/Metaphone.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * Encodes a string into a Metaphone value. \n+ * <p>\n+ * Initial Java implementation by <CITE>William B. Brogden. December, 1997</CITE>. \n+ * Permission given by <CITE>wbrogden</CITE> for code to be used anywhere.\n+ * </p>\n+ * <p>\n+ * <CITE>Hanging on the Metaphone</CITE> by <CITE>Lawrence Philips</CITE> in <CITE>Computer Language of Dec. 1990, p\n+ * 39.</CITE>\n+ * </p>\n+ * <p>\n+ * Note, that this does not match the algorithm that ships with PHP, or the algorithm \n+ * found in the Perl <a href=\"http://search.cpan.org/~mschwern/Text-Metaphone-1.96/Metaphone.pm\">Text:Metaphone-1.96</a>.\n+ * They have had undocumented changes from the originally published algorithm. \n+ * For more information, see <a href=\"https://issues.apache.org/jira/browse/CODEC-57\">CODEC-57</a>.\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class Metaphone implements StringEncoder {\n+\n+    /**\n+     * Five values in the English language \n+     */\n+    private static final String VOWELS = \"AEIOU\" ;\n+\n+    /**\n+     * Variable used in Metaphone algorithm\n+     */\n+    private static final String FRONTV = \"EIY\"   ;\n+\n+    /**\n+     * Variable used in Metaphone algorithm\n+     */\n+    private static final String VARSON = \"CSPTG\" ;\n+\n+    /**\n+     * The max code length for metaphone is 4\n+     */\n+    private int maxCodeLen = 4 ;\n+\n+    /**\n+     * Creates an instance of the Metaphone encoder\n+     */\n+    public Metaphone() {\n+        super();\n+    }\n+\n+    /**\n+     * Find the metaphone value of a String. This is similar to the\n+     * soundex algorithm, but better at finding similar sounding words.\n+     * All input is converted to upper case.\n+     * Limitations: Input format is expected to be a single ASCII word\n+     * with only characters in the A - Z range, no punctuation or numbers.\n+     *\n+     * @param txt String to find the metaphone code for\n+     * @return A metaphone code corresponding to the String supplied\n+     */\n+    public String metaphone(String txt) {\n+        boolean hard = false ;\n+        if ((txt == null) || (txt.length() == 0)) {\n+            return \"\" ;\n+        }\n+        // single character is itself\n+        if (txt.length() == 1) {\n+            return txt.toUpperCase(java.util.Locale.ENGLISH) ;\n+        }\n+      \n+        char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;\n+      \n+        StringBuffer local = new StringBuffer(40); // manipulate\n+        StringBuffer code = new StringBuffer(10) ; //   output\n+        // handle initial 2 characters exceptions\n+        switch(inwd[0]) {\n+        case 'K' : \n+        case 'G' : \n+        case 'P' : /* looking for KN, etc*/\n+            if (inwd[1] == 'N') {\n+                local.append(inwd, 1, inwd.length - 1);\n+            } else {\n+                local.append(inwd);\n+            }\n+            break;\n+        case 'A': /* looking for AE */\n+            if (inwd[1] == 'E') {\n+                local.append(inwd, 1, inwd.length - 1);\n+            } else {\n+                local.append(inwd);\n+            }\n+            break;\n+        case 'W' : /* looking for WR or WH */\n+            if (inwd[1] == 'R') {   // WR -> R\n+                local.append(inwd, 1, inwd.length - 1); \n+                break ;\n+            }\n+            if (inwd[1] == 'H') {\n+                local.append(inwd, 1, inwd.length - 1);\n+                local.setCharAt(0, 'W'); // WH -> W\n+            } else {\n+                local.append(inwd);\n+            }\n+            break;\n+        case 'X' : /* initial X becomes S */\n+            inwd[0] = 'S';\n+            local.append(inwd);\n+            break ;\n+        default :\n+            local.append(inwd);\n+        } // now local has working string with initials fixed\n+\n+        int wdsz = local.length();\n+        int n = 0 ;\n+\n+        while ((code.length() < this.getMaxCodeLen()) && \n+               (n < wdsz) ) { // max code size of 4 works well\n+            char symb = local.charAt(n) ;\n+            // remove duplicate letters except C\n+            if ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {\n+                n++ ;\n+            } else { // not dup\n+                switch(symb) {\n+                case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\n+                    if (n == 0) { \n+                        code.append(symb);\n+                    }\n+                    break ; // only use vowel if leading char\n+                case 'B' :\n+                    if ( isPreviousChar(local, n, 'M') && \n+                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB\n+                        break;\n+                    }\n+                    code.append(symb);\n+                    break;\n+                case 'C' : // lots of C special cases\n+                    /* discard if SCI, SCE or SCY */\n+                    if ( isPreviousChar(local, n, 'S') && \n+                         !isLastChar(wdsz, n) && \n+                         (FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) { \n+                        break;\n+                    }\n+                    if (regionMatch(local, n, \"CIA\")) { // \"CIA\" -> X\n+                        code.append('X'); \n+                        break;\n+                    }\n+                    if (!isLastChar(wdsz, n) && \n+                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\n+                        code.append('S');\n+                        break; // CI,CE,CY -> S\n+                    }\n+                    if (isPreviousChar(local, n, 'S') &&\n+                        isNextChar(local, n, 'H') ) { // SCH->sk\n+                        code.append('K') ; \n+                        break ;\n+                    }\n+                    if (isNextChar(local, n, 'H')) { // detect CH\n+                        if ((n == 0) && \n+                            (wdsz >= 3) && \n+                            isVowel(local,2) ) { // CH consonant -> K consonant\n+                            code.append('K');\n+                        } else { \n+                            code.append('X'); // CHvowel -> X\n+                        }\n+                    } else { \n+                        code.append('K');\n+                    }\n+                    break ;\n+                case 'D' :\n+                    if (!isLastChar(wdsz, n + 1) && \n+                        isNextChar(local, n, 'G') && \n+                        (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J \n+                        code.append('J'); n += 2 ;\n+                    } else { \n+                        code.append('T');\n+                    }\n+                    break ;\n+                case 'G' : // GH silent at end or before consonant\n+                    if (isLastChar(wdsz, n + 1) && \n+                        isNextChar(local, n, 'H')) {\n+                        break;\n+                    }\n+                    if (!isLastChar(wdsz, n + 1) &&  \n+                        isNextChar(local,n,'H') && \n+                        !isVowel(local,n+2)) {\n+                        break;\n+                    }\n+                    if ((n > 0) && \n+                        ( regionMatch(local, n, \"GN\") ||\n+                          regionMatch(local, n, \"GNED\") ) ) {\n+                        break; // silent G\n+                    }\n+                    if (isPreviousChar(local, n, 'G')) {\n+                        // NOTE: Given that duplicated chars are removed, I don't see how this can ever be true\n+                        hard = true ;\n+                    } else {\n+                        hard = false ;\n+                    }\n+                    if (!isLastChar(wdsz, n) && \n+                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && \n+                        (!hard)) {\n+                        code.append('J');\n+                    } else {\n+                        code.append('K');\n+                    }\n+                    break ;\n+                case 'H':\n+                    if (isLastChar(wdsz, n)) {\n+                        break ; // terminal H\n+                    }\n+                    if ((n > 0) && \n+                        (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\n+                        break;\n+                    }\n+                    if (isVowel(local,n+1)) {\n+                        code.append('H'); // Hvowel\n+                    }\n+                    break;\n+                case 'F': \n+                case 'J' : \n+                case 'L' :\n+                case 'M': \n+                case 'N' : \n+                case 'R' :\n+                    code.append(symb); \n+                    break;\n+                case 'K' :\n+                    if (n > 0) { // not initial\n+                        if (!isPreviousChar(local, n, 'C')) {\n+                            code.append(symb);\n+                        }\n+                    } else {\n+                        code.append(symb); // initial K\n+                    }\n+                    break ;\n+                case 'P' :\n+                    if (isNextChar(local,n,'H')) {\n+                        // PH -> F\n+                        code.append('F');\n+                    } else {\n+                        code.append(symb);\n+                    }\n+                    break ;\n+                case 'Q' :\n+                    code.append('K');\n+                    break;\n+                case 'S' :\n+                    if (regionMatch(local,n,\"SH\") || \n+                        regionMatch(local,n,\"SIO\") || \n+                        regionMatch(local,n,\"SIA\")) {\n+                        code.append('X');\n+                    } else {\n+                        code.append('S');\n+                    }\n+                    break;\n+                case 'T' :\n+                    if (regionMatch(local,n,\"TIA\") || \n+                        regionMatch(local,n,\"TIO\")) {\n+                        code.append('X'); \n+                        break;\n+                    }\n+                    if (regionMatch(local,n,\"TCH\")) {\n+                        // Silent if in \"TCH\"\n+                        break;\n+                    }\n+                    // substitute numeral 0 for TH (resembles theta after all)\n+                    if (regionMatch(local,n,\"TH\")) {\n+                        code.append('0');\n+                    } else {\n+                        code.append('T');\n+                    }\n+                    break ;\n+                case 'V' :\n+                    code.append('F'); break ;\n+                case 'W' : case 'Y' : // silent if not followed by vowel\n+                    if (!isLastChar(wdsz,n) && \n+                        isVowel(local,n+1)) {\n+                        code.append(symb);\n+                    }\n+                    break ;\n+                case 'X' :\n+                    code.append('K'); code.append('S');\n+                    break ;\n+                case 'Z' :\n+                    code.append('S'); break ;\n+                } // end switch\n+                n++ ;\n+            } // end else from symb != 'C'\n+            if (code.length() > this.getMaxCodeLen()) { \n+                code.setLength(this.getMaxCodeLen()); \n+            }\n+        }\n+        return code.toString();\n+    }\n+\n+    private boolean isVowel(StringBuffer string, int index) {\n+        return VOWELS.indexOf(string.charAt(index)) >= 0;\n+    }\n+\n+    private boolean isPreviousChar(StringBuffer string, int index, char c) {\n+        boolean matches = false;\n+        if( index > 0 &&\n+            index < string.length() ) {\n+            matches = string.charAt(index - 1) == c;\n+        }\n+        return matches;\n+    }\n+\n+    private boolean isNextChar(StringBuffer string, int index, char c) {\n+        boolean matches = false;\n+        if( index >= 0 &&\n+            index < string.length() - 1 ) {\n+            matches = string.charAt(index + 1) == c;\n+        }\n+        return matches;\n+    }\n+\n+    private boolean regionMatch(StringBuffer string, int index, String test) {\n+        boolean matches = false;\n+        if( index >= 0 &&\n+            (index + test.length() - 1) < string.length() ) {\n+            String substring = string.substring( index, index + test.length());\n+            matches = substring.equals( test );\n+        }\n+        return matches;\n+    }\n+\n+    private boolean isLastChar(int wdsz, int n) {\n+        return n + 1 == wdsz;\n+    } \n+    \n+    \n+    /**\n+     * Encodes an Object using the metaphone algorithm.  This method\n+     * is provided in order to satisfy the requirements of the\n+     * Encoder interface, and will throw an EncoderException if the\n+     * supplied object is not of type java.lang.String.\n+     *\n+     * @param pObject Object to encode\n+     * @return An object (or type java.lang.String) containing the \n+     *         metaphone code which corresponds to the String supplied.\n+     * @throws EncoderException if the parameter supplied is not\n+     *                          of type java.lang.String\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (!(pObject instanceof String)) {\n+            throw new EncoderException(\"Parameter supplied to Metaphone encode is not of type java.lang.String\"); \n+        }\n+        return metaphone((String) pObject);\n+    }\n+\n+    /**\n+     * Encodes a String using the Metaphone algorithm. \n+     *\n+     * @param pString String object to encode\n+     * @return The metaphone code corresponding to the String supplied\n+     */\n+    public String encode(String pString) {\n+        return metaphone(pString);   \n+    }\n+\n+    /**\n+     * Tests is the metaphones of two strings are identical.\n+     *\n+     * @param str1 First of two strings to compare\n+     * @param str2 Second of two strings to compare\n+     * @return <code>true</code> if the metaphones of these strings are identical, \n+     *        <code>false</code> otherwise.\n+     */\n+    public boolean isMetaphoneEqual(String str1, String str2) {\n+        return metaphone(str1).equals(metaphone(str2));\n+    }\n+\n+    /**\n+     * Returns the maxCodeLen.\n+     * @return int\n+     */\n+    public int getMaxCodeLen() { return this.maxCodeLen; }\n+\n+    /**\n+     * Sets the maxCodeLen.\n+     * @param maxCodeLen The maxCodeLen to set\n+     */\n+    public void setMaxCodeLen(int maxCodeLen) { this.maxCodeLen = maxCodeLen; }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/RefinedSoundex.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * Encodes a string into a Refined Soundex value. A refined soundex code is\n+ * optimized for spell checking words. Soundex method originally developed by\n+ * <CITE>Margaret Odell</CITE> and <CITE>Robert Russell</CITE>.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class RefinedSoundex implements StringEncoder {\n+\n+    /**\n+     * @since 1.4\n+     */\n+    public static final String US_ENGLISH_MAPPING_STRING = \"01360240043788015936020505\";\n+\n+   /**\n+     * RefinedSoundex is *refined* for a number of reasons one being that the\n+     * mappings have been altered. This implementation contains default\n+     * mappings for US English.\n+     */\n+    private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\n+\n+    /**\n+     * Every letter of the alphabet is \"mapped\" to a numerical value. This char\n+     * array holds the values to which each letter is mapped. This\n+     * implementation contains a default map for US_ENGLISH\n+     */\n+    private final char[] soundexMapping;\n+\n+    /**\n+     * This static variable contains an instance of the RefinedSoundex using\n+     * the US_ENGLISH mapping.\n+     */\n+    public static final RefinedSoundex US_ENGLISH = new RefinedSoundex();\n+\n+     /**\n+     * Creates an instance of the RefinedSoundex object using the default US\n+     * English mapping.\n+     */\n+    public RefinedSoundex() {\n+        this.soundexMapping = US_ENGLISH_MAPPING;\n+    }\n+\n+    /**\n+     * Creates a refined soundex instance using a custom mapping. This\n+     * constructor can be used to customize the mapping, and/or possibly\n+     * provide an internationalized mapping for a non-Western character set.\n+     * \n+     * @param mapping\n+     *                  Mapping array to use when finding the corresponding code for\n+     *                  a given character\n+     */\n+    public RefinedSoundex(char[] mapping) {\n+        this.soundexMapping = new char[mapping.length];\n+        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n+    }\n+\n+    /**\n+     * Creates a refined Soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n+     * and/or possibly provide an internationalized mapping for a non-Western character set.\n+     * \n+     * @param mapping\n+     *            Mapping string to use when finding the corresponding code for a given character\n+     * @since 1.4\n+     */\n+    public RefinedSoundex(String mapping) {\n+        this.soundexMapping = mapping.toCharArray();\n+    }\n+\n+    /**\n+     * Returns the number of characters in the two encoded Strings that are the\n+     * same. This return value ranges from 0 to the length of the shortest\n+     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for\n+     * example) indicates strong similarity or identical values. For refined\n+     * Soundex, the return value can be greater than 4.\n+     * \n+     * @param s1\n+     *                  A String that will be encoded and compared.\n+     * @param s2\n+     *                  A String that will be encoded and compared.\n+     * @return The number of characters in the two encoded Strings that are the\n+     *             same from 0 to to the length of the shortest encoded String.\n+     * \n+     * @see SoundexUtils#difference(StringEncoder,String,String)\n+     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n+     *          MS T-SQL DIFFERENCE</a>\n+     * \n+     * @throws EncoderException\n+     *                  if an error occurs encoding one of the strings\n+     * @since 1.3\n+     */\n+    public int difference(String s1, String s2) throws EncoderException {\n+        return SoundexUtils.difference(this, s1, s2);\n+    }\n+\n+    /**\n+     * Encodes an Object using the refined soundex algorithm. This method is\n+     * provided in order to satisfy the requirements of the Encoder interface,\n+     * and will throw an EncoderException if the supplied object is not of type\n+     * java.lang.String.\n+     * \n+     * @param pObject\n+     *                  Object to encode\n+     * @return An object (or type java.lang.String) containing the refined\n+     *             soundex code which corresponds to the String supplied.\n+     * @throws EncoderException\n+     *                  if the parameter supplied is not of type java.lang.String\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (!(pObject instanceof String)) {\n+            throw new EncoderException(\"Parameter supplied to RefinedSoundex encode is not of type java.lang.String\");\n+        }\n+        return soundex((String) pObject);\n+    }\n+\n+    /**\n+     * Encodes a String using the refined soundex algorithm.\n+     * \n+     * @param pString\n+     *                  A String object to encode\n+     * @return A Soundex code corresponding to the String supplied\n+     */\n+    public String encode(String pString) {\n+        return soundex(pString);\n+    }\n+\n+    /**\n+     * Returns the mapping code for a given character. The mapping codes are\n+     * maintained in an internal char array named soundexMapping, and the\n+     * default values of these mappings are US English.\n+     * \n+     * @param c\n+     *                  char to get mapping for\n+     * @return A character (really a numeral) to return for the given char\n+     */\n+    char getMappingCode(char c) {\n+        if (!Character.isLetter(c)) {\n+            return 0;\n+        }\n+        return this.soundexMapping[Character.toUpperCase(c) - 'A'];\n+    }\n+\n+    /**\n+     * Retrieves the Refined Soundex code for a given String object.\n+     * \n+     * @param str\n+     *                  String to encode using the Refined Soundex algorithm\n+     * @return A soundex code for the String supplied\n+     */\n+    public String soundex(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        str = SoundexUtils.clean(str);\n+        if (str.length() == 0) {\n+            return str;\n+        }\n+\n+        StringBuffer sBuf = new StringBuffer();\n+        sBuf.append(str.charAt(0));\n+\n+        char last, current;\n+        last = '*';\n+\n+        for (int i = 0; i < str.length(); i++) {\n+\n+            current = getMappingCode(str.charAt(i));\n+            if (current == last) {\n+                continue;\n+            } else if (current != 0) {\n+                sBuf.append(current);\n+            }\n+\n+            last = current;\n+\n+        }\n+\n+        return sBuf.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/Soundex.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * Encodes a string into a Soundex value. Soundex is an encoding used to relate similar names, but can also be used as a\n+ * general purpose scheme to find word with similar phonemes.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class Soundex implements StringEncoder {\n+\n+    /**\n+     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\n+     * means do not encode.\n+     * <p>\n+     * (This constant is provided as both an implementation convenience and to allow Javadoc to pick\n+     * up the value for the constant values page.)\n+     * </p>\n+     * \n+     * @see #US_ENGLISH_MAPPING\n+     */\n+    public static final String US_ENGLISH_MAPPING_STRING = \"01230120022455012623010202\";\n+\n+    /**\n+     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\n+     * means do not encode.\n+     * \n+     * @see Soundex#Soundex(char[])\n+     */\n+    private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\n+\n+    /**\n+     * An instance of Soundex using the US_ENGLISH_MAPPING mapping.\n+     * \n+     * @see #US_ENGLISH_MAPPING\n+     */\n+    public static final Soundex US_ENGLISH = new Soundex();\n+\n+\n+    /**\n+     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n+     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n+     * identical values.\n+     * \n+     * @param s1\n+     *                  A String that will be encoded and compared.\n+     * @param s2\n+     *                  A String that will be encoded and compared.\n+     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n+     * \n+     * @see SoundexUtils#difference(StringEncoder,String,String)\n+     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n+     *          T-SQL DIFFERENCE </a>\n+     * \n+     * @throws EncoderException\n+     *                  if an error occurs encoding one of the strings\n+     * @since 1.3\n+     */\n+    public int difference(String s1, String s2) throws EncoderException {\n+        return SoundexUtils.difference(this, s1, s2);\n+    }\n+\n+    /**\n+     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n+     * letter is mapped. This implementation contains a default map for US_ENGLISH\n+     */\n+    private final char[] soundexMapping;\n+\n+    /**\n+     * Creates an instance using US_ENGLISH_MAPPING\n+     * \n+     * @see Soundex#Soundex(char[])\n+     * @see Soundex#US_ENGLISH_MAPPING\n+     */\n+    public Soundex() {\n+        this.soundexMapping = US_ENGLISH_MAPPING;\n+    }\n+\n+    /**\n+     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\n+     * mapping for a non-Western character set.\n+     * \n+     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n+     * letter is mapped. This implementation contains a default map for US_ENGLISH\n+     * \n+     * @param mapping\n+     *                  Mapping array to use when finding the corresponding code for a given character\n+     */\n+    public Soundex(char[] mapping) {\n+        this.soundexMapping = new char[mapping.length];\n+        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\n+    }\n+\n+    /**\n+     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n+     * and/or possibly provide an internationalized mapping for a non-Western character set.\n+     * \n+     * @param mapping\n+     *            Mapping string to use when finding the corresponding code for a given character\n+     * @since 1.4\n+     */\n+    public Soundex(String mapping) {\n+        this.soundexMapping = mapping.toCharArray();\n+    }\n+\n+    /**\n+     * Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of\n+     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\n+     * \n+     * @param pObject\n+     *                  Object to encode\n+     * @return An object (or type java.lang.String) containing the soundex code which corresponds to the String\n+     *             supplied.\n+     * @throws EncoderException\n+     *                  if the parameter supplied is not of type java.lang.String\n+     * @throws IllegalArgumentException\n+     *                  if a character is not mapped\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (!(pObject instanceof String)) {\n+            throw new EncoderException(\"Parameter supplied to Soundex encode is not of type java.lang.String\");\n+        }\n+        return soundex((String) pObject);\n+    }\n+\n+    /**\n+     * Encodes a String using the soundex algorithm.\n+     * \n+     * @param pString\n+     *                  A String object to encode\n+     * @return A Soundex code corresponding to the String supplied\n+     * @throws IllegalArgumentException\n+     *                  if a character is not mapped\n+     */\n+    public String encode(String pString) {\n+        return soundex(pString);\n+    }\n+\n+    /**\n+     * Used internally by the SoundEx algorithm.\n+     * \n+     * Consonants from the same code group separated by W or H are treated as one.\n+     * \n+     * @param str\n+     *                  the cleaned working string to encode (in upper case).\n+     * @param index\n+     *                  the character position to encode\n+     * @return Mapping code for a particular character\n+     * @throws IllegalArgumentException\n+     *                  if the character is not mapped\n+     */\n+    private char getMappingCode(String str, int index) {\n+        // map() throws IllegalArgumentException\n+        char mappedChar = this.map(str.charAt(index));\n+        // HW rule check\n+        if (index > 1 && mappedChar != '0') {\n+            char hwChar = str.charAt(index - 1);\n+            if ('H' == hwChar || 'W' == hwChar) {\n+                char preHWChar = str.charAt(index - 2);\n+                char firstCode = this.map(preHWChar);\n+                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+                    return 0;\n+                }\n+            }\n+        }\n+        return mappedChar;\n+    }\n+\n+    /**\n+     * Returns the soundex mapping.\n+     * \n+     * @return soundexMapping.\n+     */\n+    private char[] getSoundexMapping() {\n+        return this.soundexMapping;\n+    }\n+\n+    /**\n+     * Maps the given upper-case character to its Soundex code.\n+     * \n+     * @param ch\n+     *                  An upper-case character.\n+     * @return A Soundex code.\n+     * @throws IllegalArgumentException\n+     *                  Thrown if <code>ch</code> is not mapped.\n+     */\n+    private char map(char ch) {\n+        int index = ch - 'A';\n+        if (index < 0 || index >= this.getSoundexMapping().length) {\n+            throw new IllegalArgumentException(\"The character is not mapped: \" + ch);\n+        }\n+        return this.getSoundexMapping()[index];\n+    }\n+\n+    /**\n+     * Retrieves the Soundex code for a given String object.\n+     * \n+     * @param str\n+     *                  String to encode using the Soundex algorithm\n+     * @return A soundex code for the String supplied\n+     * @throws IllegalArgumentException\n+     *                  if a character is not mapped\n+     */\n+    public String soundex(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        str = SoundexUtils.clean(str);\n+        if (str.length() == 0) {\n+            return str;\n+        }\n+        char out[] = {'0', '0', '0', '0'};\n+        char last, mapped;\n+        int incount = 1, count = 1;\n+        out[0] = str.charAt(0);\n+        // getMappingCode() throws IllegalArgumentException\n+        last = getMappingCode(str, 0);\n+        while ((incount < str.length()) && (count < out.length)) {\n+            mapped = getMappingCode(str, incount++);\n+            if (mapped != 0) {\n+                if ((mapped != '0') && (mapped != last)) {\n+                    out[count++] = mapped;\n+                }\n+                last = mapped;\n+            }\n+        }\n+        return new String(out);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/SoundexUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * Utility methods for {@link Soundex} and {@link RefinedSoundex} classes.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ * @since 1.3\n+ */\n+final class SoundexUtils {\n+\n+    /**\n+     * Cleans up the input string before Soundex processing by only returning\n+     * upper case letters.\n+     * \n+     * @param str\n+     *                  The String to clean.\n+     * @return A clean String.\n+     */\n+    static String clean(String str) {\n+        if (str == null || str.length() == 0) {\n+            return str;\n+        }\n+        int len = str.length();\n+        char[] chars = new char[len];\n+        int count = 0;\n+        for (int i = 0; i < len; i++) {\n+            if (Character.isLetter(str.charAt(i))) {\n+                chars[count++] = str.charAt(i);\n+            }\n+        }\n+        if (count == len) {\n+            return str.toUpperCase(java.util.Locale.ENGLISH);\n+        }\n+        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n+    }\n+\n+    /**\n+     * Encodes the Strings and returns the number of characters in the two\n+     * encoded Strings that are the same.\n+     * <ul>\n+     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n+     * little or no similarity, and 4 indicates strong similarity or identical\n+     * values.</li>\n+     * <li>For refined Soundex, the return value can be greater than 4.</li>\n+     * </ul>\n+     * \n+     * @param encoder\n+     *                  The encoder to use to encode the Strings.\n+     * @param s1\n+     *                  A String that will be encoded and compared.\n+     * @param s2\n+     *                  A String that will be encoded and compared.\n+     * @return The number of characters in the two Soundex encoded Strings that\n+     *             are the same.\n+     * \n+     * @see #differenceEncoded(String,String)\n+     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n+     *          MS T-SQL DIFFERENCE</a>\n+     * \n+     * @throws EncoderException\n+     *                  if an error occurs encoding one of the strings\n+     */\n+    static int difference(StringEncoder encoder, String s1, String s2) throws EncoderException {\n+        return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\n+    }\n+\n+    /**\n+     * Returns the number of characters in the two Soundex encoded Strings that\n+     * are the same.\n+     * <ul>\n+     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n+     * little or no similarity, and 4 indicates strong similarity or identical\n+     * values.</li>\n+     * <li>For refined Soundex, the return value can be greater than 4.</li>\n+     * </ul>\n+     * \n+     * @param es1\n+     *                  An encoded String.\n+     * @param es2\n+     *                  An encoded String.\n+     * @return The number of characters in the two Soundex encoded Strings that\n+     *             are the same.\n+     * \n+     * @see <a href=\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n+     *          MS T-SQL DIFFERENCE</a>\n+     */\n+    static int differenceEncoded(String es1, String es2) {\n+\n+        if (es1 == null || es2 == null) {\n+            return 0;\n+        }\n+        int lengthToMatch = Math.min(es1.length(), es2.length());\n+        int diff = 0;\n+        for (int i = 0; i < lengthToMatch; i++) {\n+            if (es1.charAt(i) == es2.charAt(i)) {\n+                diff++;\n+            }\n+        }\n+        return diff;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * <p>\n+ * Encodes strings into their Beider-Morse phonetic encoding.\n+ * </p>\n+ * <p>\n+ * Beider-Morse phonetic encodings are optimised for family names. However, they may be useful for a wide range of words.\n+ * </p>\n+ * <p>\n+ * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it is mutable, and may not be\n+ * thread-safe. If you require a guaranteed thread-safe encoding then use {@link PhoneticEngine} directly.\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+public class BeiderMorseEncoder implements StringEncoder {\n+    // a cached object\n+    private PhoneticEngine engine = new PhoneticEngine(NameType.GENERIC, RuleType.APPROX, true);\n+\n+    public Object encode(Object source) throws EncoderException {\n+        if (!(source instanceof String)) {\n+            throw new EncoderException(\"BeiderMorseEncoder encode parameter is not of type String\");\n+        }\n+        return encode((String) source);\n+    }\n+\n+    public String encode(String source) throws EncoderException {\n+        if (source == null) {\n+            return null;\n+        }\n+        return this.engine.encode(source);\n+    }\n+\n+    /**\n+     * Gets the name type currently in operation.\n+     * \n+     * @return the NameType currently being used\n+     */\n+    public NameType getNameType() {\n+        return this.engine.getNameType();\n+    }\n+\n+    /**\n+     * Gets the rule type currently in operation.\n+     * \n+     * @return the RuleType currently being used\n+     */\n+    public RuleType getRuleType() {\n+        return this.engine.getRuleType();\n+    }\n+\n+    /**\n+     * Discovers if multiple possible encodings are concatenated.\n+     * \n+     * @return true if multiple encodings are concatenated, false if just the first one is returned\n+     */\n+    public boolean isConcat() {\n+        return this.engine.isConcat();\n+    }\n+\n+    /**\n+     * Sets how multiple possible phonetic encodings are combined.\n+     * \n+     * @param concat\n+     *            true if multiple encodings are to be combined with a '|', false if just the first one is to be considered\n+     */\n+    public void setConcat(boolean concat) {\n+        this.engine = new PhoneticEngine(this.engine.getNameType(), this.engine.getRuleType(), concat);\n+    }\n+\n+    /**\n+     * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phoentic encodings optimized for Ashkenazi or\n+     * Sephardic Jewish family names.\n+     * \n+     * @param nameType\n+     *            the NameType in use\n+     */\n+    public void setNameType(NameType nameType) {\n+        this.engine = new PhoneticEngine(nameType, this.engine.getRuleType(), this.engine.isConcat());\n+    }\n+\n+    /**\n+     * Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.\n+     * \n+     * @param ruleType\n+     *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches\n+     */\n+    public void setRuleType(RuleType ruleType) {\n+        this.engine = new PhoneticEngine(this.engine.getNameType(), ruleType, this.engine.isConcat());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Lang.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * <p>\n+ * Language guessing utility.\n+ * </p>\n+ * <p>\n+ * This class encapsulates rules used to guess the possible languages that a word originates from. This is done by reference to a whole\n+ * series of rules distributed in resource files.\n+ * </p>\n+ * <p>\n+ * Instances of this class are typically managed through the static factory method instance(). Unless you are developing your own language\n+ * guessing rules, you will not need to interact with this class directly.\n+ * </p>\n+ * <p>\n+ * This class is intended to be immutable and thread-safe.\n+ * </p>\n+ * <h2>Lang resources</h2\n+ * <p>\n+ * Language guessing rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically named\n+ * following the pattern: <blockquote>org/apache/commons/codec/language/bm/lang.txt</blockquote> The format of these resources is the\n+ * following:\n+ * </p>\n+ * <ul>\n+ * <li><b>Rules:</b> whitespace separated strings. There should be 3 columns to each row, and these will be interpreted as:\n+ * <ol>\n+ * <li>pattern: a regular expression.</li>\n+ * <li>languages: a '+'-separated list of languages.</li>\n+ * <li>acceptOnMatch: 'true' or 'false' indicating if a match rules in or rules out the language.</li>\n+ * </ol>\n+ * </li>\n+ * <li><b>End-of-line comments:</b> Any occurance of '//' will cause all text following on that line to be discarded as a comment.</li>\n+ * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip all content until a\n+ * line ending in '*' and '/' is found.</li>\n+ * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n+ * </ul>\n+ * <p/>\n+ * Port of lang.php\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+public class Lang {\n+\n+    private static final class LangRule {\n+        private final boolean acceptOnMatch;\n+        private final Set<String> languages;\n+        private final Pattern pattern;\n+\n+        private LangRule(Pattern pattern, Set<String> languages, boolean acceptOnMatch) {\n+            this.pattern = pattern;\n+            this.languages = languages;\n+            this.acceptOnMatch = acceptOnMatch;\n+        }\n+\n+        public boolean matches(String txt) {\n+            return this.pattern.matcher(txt).find();\n+        }\n+    }\n+\n+    private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class);\n+\n+    private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/lang.txt\";\n+\n+    static {\n+        for (NameType s : NameType.values()) {\n+            Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s)));\n+        }\n+    }\n+\n+    /**\n+     * Gets a Lang instance for one of the supported NameTypes.\n+     * \n+     * @param nameType\n+     *            the NameType to look up\n+     * @return a Lang encapsulating the language guessing rules for that name type\n+     */\n+    public static Lang instance(NameType nameType) {\n+        return Langs.get(nameType);\n+    }\n+\n+    /**\n+     * <p>\n+     * Loads language rules from a resource.\n+     * </p>\n+     * <p>\n+     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method. You will only need to call this\n+     * yourself if you are developing custom language mapping rules.\n+     * </p>\n+     * \n+     * @param languageRulesResourceName\n+     *            the fully-qualified resource name to load\n+     * @param languages\n+     *            the languages that these rules will support\n+     * @return a Lang encapsulating the loaded language-guessing rules.\n+     */\n+    public static Lang loadFromResource(String languageRulesResourceName, Languages languages) {\n+        List<LangRule> rules = new ArrayList<LangRule>();\n+        InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\n+\n+        if (lRulesIS == null) {\n+            throw new IllegalStateException(\"Unable to resolve required resource:\" + LANGUAGE_RULES_RN);\n+        }\n+\n+        Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\n+        boolean inExtendedComment = false;\n+        while (scanner.hasNextLine()) {\n+            String rawLine = scanner.nextLine();\n+            String line = rawLine;\n+\n+            if (inExtendedComment) {\n+                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n+                    inExtendedComment = false;\n+                } else {\n+                    // discard doc comment line\n+                }\n+            } else {\n+                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n+                    inExtendedComment = true;\n+                } else {\n+                    // discard comments\n+                    int cmtI = line.indexOf(ResourceConstants.CMT);\n+                    if (cmtI >= 0) {\n+                        // System.err.println(\"index of comment: \" + cmtI);\n+                        line = line.substring(0, cmtI);\n+                    }\n+\n+                    // trim leading-trailing whitespace\n+                    line = line.trim();\n+\n+                    if (line.length() == 0) {\n+                        continue; // empty lines can be safely skipped\n+                    }\n+\n+                    // split it up\n+                    String[] parts = line.split(\"\\\\s+\");\n+                    // System.err.println(\"part count: \" + parts.length);\n+\n+                    if (parts.length != 3) {\n+                        // fixme: we really need to log this somewhere\n+                        System.err.println(\"Warning: malformed line '\" + rawLine + \"'\");\n+                        continue;\n+                    }\n+\n+                    Pattern pattern = Pattern.compile(parts[0]);\n+                    String[] langs = parts[1].split(\"\\\\+\");\n+                    boolean accept = parts[2].equals(\"true\");\n+\n+                    rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\n+                }\n+            }\n+        }\n+\n+        return new Lang(rules, languages);\n+    }\n+\n+    private final Languages languages;\n+    private final List<LangRule> rules;\n+\n+    private Lang(List<LangRule> rules, Languages languages) {\n+        this.rules = Collections.unmodifiableList(rules);\n+        this.languages = languages;\n+    }\n+\n+    /**\n+     * Guesses the language of a word.\n+     * \n+     * @param text\n+     *            the word\n+     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match\n+     */\n+    public String guessLanguage(String text) {\n+        Languages.LanguageSet ls = guessLanguages(text);\n+        return ls.isSingleton() ? ls.getAny() : Languages.ANY;\n+    }\n+\n+    /**\n+     * Guesses the languages of a word.\n+     * \n+     * @param input\n+     *            the word\n+     * @return a Set of Strings of language names that are potential matches for the input word\n+     */\n+    public Languages.LanguageSet guessLanguages(String input) {\n+        String text = input.toLowerCase(Locale.ENGLISH);\n+        // System.out.println(\"Testing text: '\" + text + \"'\");\n+\n+        Set<String> langs = new HashSet<String>(this.languages.getLanguages());\n+        for (LangRule rule : this.rules) {\n+            if (rule.matches(text)) {\n+                // System.out.println(\"Rule \" + rule.pattern + \" matches \" + text);\n+                if (rule.acceptOnMatch) {\n+                    // System.out.println(\"Retaining \" + rule.languages);\n+                    langs.retainAll(rule.languages);\n+                } else {\n+                    // System.out.println(\"Removing \" + rule.languages);\n+                    langs.removeAll(rule.languages);\n+                }\n+                // System.out.println(\"Current languages: \" + langs);\n+            } else {\n+                // System.out.println(\"Rule \" + rule.pattern + \" does not match \" + text);\n+            }\n+        }\n+\n+        Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\n+        return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Languages.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import java.io.InputStream;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Scanner;\n+import java.util.Set;\n+\n+/**\n+ * <p>\n+ * Language codes.\n+ * </p>\n+ * <p>\n+ * Language codes are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically named following the\n+ * pattern:\n+ * </p>\n+ * <blockquote>org/apache/commons/codec/language/bm/${{@link NameType#getName()} languages.txt</blockquote>\n+ * <p>\n+ * The format of these resources is the following:\n+ * </p>\n+ * <ul>\n+ * <li><b>Language:</b> a single string containing no whitespace</li>\n+ * <li><b>End-of-line comments:</b> Any occurance of '//' will cause all text following on that line to be discarded as a comment.</li>\n+ * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip all content until a\n+ * line ending in '*' and '/' is found.</li>\n+ * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n+ * </ul>\n+ * <p>\n+ * Ported from language.php\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+public class Languages {\n+\n+    /**\n+     * A set of languages.\n+     */\n+    public static abstract class LanguageSet {\n+\n+        public static LanguageSet from(Set<String> langs) {\n+            return langs.isEmpty() ? NO_LANGUAGES : new SomeLanguages(langs);\n+        }\n+\n+        public abstract boolean contains(String language);\n+\n+        public abstract String getAny();\n+\n+        public abstract boolean isEmpty();\n+\n+        public abstract boolean isSingleton();\n+\n+        public abstract LanguageSet restrictTo(LanguageSet other);\n+    }\n+\n+    /**\n+     * Some languages, explicitly enumerated.\n+     */\n+    public static final class SomeLanguages extends LanguageSet {\n+        private final Set<String> languages;\n+\n+        private SomeLanguages(Set<String> languages) {\n+            this.languages = Collections.unmodifiableSet(languages);\n+        }\n+\n+        @Override\n+        public boolean contains(String language) {\n+            return this.languages.contains(language);\n+        }\n+\n+        @Override\n+        public String getAny() {\n+            return this.languages.iterator().next();\n+        }\n+\n+        public Set<String> getLanguages() {\n+            return this.languages;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return this.languages.isEmpty();\n+        }\n+\n+        @Override\n+        public boolean isSingleton() {\n+            return this.languages.size() == 1;\n+        }\n+\n+        @Override\n+        public LanguageSet restrictTo(LanguageSet other) {\n+            if (other == NO_LANGUAGES) {\n+                return other;\n+            } else if (other == ANY_LANGUAGE) {\n+                return this;\n+            } else {\n+                SomeLanguages sl = (SomeLanguages) other;\n+                if (sl.languages.containsAll(languages)) {\n+                    return this;\n+                } else {\n+                    Set<String> ls = new HashSet<String>(this.languages);\n+                    ls.retainAll(sl.languages);\n+                    return from(ls);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Languages(\" + languages.toString() + \")\";\n+        }\n+\n+    }\n+\n+    public static final String ANY = \"any\";\n+\n+    private static final Map<NameType, Languages> LANGUAGES = new EnumMap<NameType, Languages>(NameType.class);\n+\n+    static {\n+        for (NameType s : NameType.values()) {\n+            LANGUAGES.put(s, getInstance(langResourceName(s)));\n+        }\n+    }\n+\n+    public static Languages getInstance(NameType nameType) {\n+        return LANGUAGES.get(nameType);\n+    }\n+\n+    public static Languages getInstance(String languagesResourceName) {\n+        // read languages list\n+        Set<String> ls = new HashSet<String>();\n+        InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName);\n+\n+        if (langIS == null) {\n+            throw new IllegalArgumentException(\"Unable to resolve required resource: \" + languagesResourceName);\n+        }\n+\n+        Scanner lsScanner = new Scanner(langIS, ResourceConstants.ENCODING);\n+        boolean inExtendedComment = false;\n+        while (lsScanner.hasNextLine()) {\n+            String line = lsScanner.nextLine().trim();\n+            if (inExtendedComment) {\n+                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n+                    inExtendedComment = false;\n+                } else {\n+                    // skip\n+                }\n+            } else {\n+                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n+                    inExtendedComment = true;\n+                } else if (line.length() > 0) {\n+                    ls.add(line);\n+                } else {\n+                    // skip blank lines\n+                }\n+            }\n+        }\n+\n+        return new Languages(Collections.unmodifiableSet(ls));\n+    }\n+\n+    private static String langResourceName(NameType nameType) {\n+        return String.format(\"org/apache/commons/codec/language/bm/%s_languages.txt\", nameType.getName());\n+    }\n+\n+    private final Set<String> languages;\n+\n+    /**\n+     * No languages at all.\n+     */\n+    public static final LanguageSet NO_LANGUAGES = new LanguageSet() {\n+        @Override\n+        public boolean contains(String language) {\n+            return false;\n+        }\n+\n+        @Override\n+        public String getAny() {\n+            throw new NoSuchElementException(\"Can't fetch any language from the empty language set.\");\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean isSingleton() {\n+            return false;\n+        }\n+\n+        @Override\n+        public LanguageSet restrictTo(LanguageSet other) {\n+            return this;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"NO_LANGUAGES\";\n+        }\n+    };\n+\n+    /**\n+     * Any/all languages.\n+     */\n+    public static final LanguageSet ANY_LANGUAGE = new LanguageSet() {\n+        @Override\n+        public boolean contains(String language) {\n+            return true;\n+        }\n+\n+        @Override\n+        public String getAny() {\n+            throw new NoSuchElementException(\"Can't fetch any language from the any language set.\");\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isSingleton() {\n+            return false;\n+        }\n+\n+        @Override\n+        public LanguageSet restrictTo(LanguageSet other) {\n+            return other;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ANY_LANGUAGE\";\n+        }\n+    };\n+\n+    private Languages(Set<String> languages) {\n+        this.languages = languages;\n+    }\n+\n+    public Set<String> getLanguages() {\n+        return this.languages;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/bm/NameType.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+/**\n+ * Supported types of names. Unless you are matching particular family names, use {@link #GENERIC}.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+public enum NameType {\n+\n+    /** Ashkenazi family names */\n+    ASHKENAZI(\"ash\"),\n+\n+    /** Generic names and words */\n+    GENERIC(\"gen\"),\n+\n+    /** Sephardic family names */\n+    SEPHARDIC(\"sep\");\n+\n+    private final String name;\n+\n+    NameType(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Gets the short version of the name type.\n+     * \n+     * @return the NameType short string\n+     */\n+    public String getName() {\n+        return this.name;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+/**\n+ * <p>\n+ * Converts words into potential phonetic representations.\n+ * </p>\n+ * <p>\n+ * This is a two-stage process. Firstly, the word is converted into a phonetic representation that takes into account the likely source\n+ * language. Next, this phonetic representation is converted into a pan-european 'average' representation, allowing comparison between\n+ * different versions of essentially the same word from different languages.\n+ * </p>\n+ * <p>\n+ * This class is intentionally immutable. If you wish to alter the settings for a PhoneticEngine, you must make a new one with the updated\n+ * settings. This makes the class thread-safe.\n+ * </p>\n+ * <p>\n+ * Ported from phoneticengine.php\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+public class PhoneticEngine {\n+\n+    static final class PhonemeBuilder {\n+\n+        public static PhonemeBuilder empty(Languages.LanguageSet languages) {\n+            return new PhonemeBuilder(Collections.singleton(new Rule.Phoneme(\"\", languages)));\n+        }\n+\n+        private final Set<Rule.Phoneme> phonemes;\n+\n+        private PhonemeBuilder(Set<Rule.Phoneme> phonemes) {\n+            this.phonemes = phonemes;\n+        }\n+\n+        public PhonemeBuilder append(CharSequence str) {\n+            Set<Rule.Phoneme> newPhonemes = new HashSet<Rule.Phoneme>();\n+\n+            for (Rule.Phoneme ph : this.phonemes) {\n+                newPhonemes.add(ph.append(str));\n+            }\n+\n+            return new PhonemeBuilder(newPhonemes);\n+        }\n+\n+        public PhonemeBuilder apply(Rule.PhonemeExpr phonemeExpr) {\n+            Set<Rule.Phoneme> newPhonemes = new HashSet<Rule.Phoneme>();\n+\n+            for (Rule.Phoneme left : this.phonemes) {\n+                for (Rule.Phoneme right : phonemeExpr.getPhonemes()) {\n+                    Rule.Phoneme join = left.join(right);\n+                    if (!join.getLanguages().isEmpty()) {\n+                        newPhonemes.add(join);\n+                    }\n+                }\n+            }\n+\n+            return new PhonemeBuilder(newPhonemes);\n+        }\n+\n+        public Set<Rule.Phoneme> getPhonemes() {\n+            return this.phonemes;\n+        }\n+\n+        public String makeString() {\n+\n+            StringBuilder sb = new StringBuilder();\n+            // System.err.println(this.phonemes.getClass());\n+\n+            for (Rule.Phoneme ph : this.phonemes) {\n+                if (sb.length() > 0) {\n+                    sb.append(\"|\");\n+                }\n+                sb.append(ph.getPhonemeText());\n+            }\n+\n+            return sb.toString();\n+        }\n+    }\n+\n+    private static final class RulesApplication {\n+        private final List<Rule> finalRules;\n+        private final CharSequence input;\n+\n+        private PhonemeBuilder phonemeBuilder;\n+        private int i;\n+        private boolean found;\n+\n+        public RulesApplication(List<Rule> finalRules, CharSequence input, PhonemeBuilder phonemeBuilder, int i) {\n+            if (finalRules == null) {\n+                throw new NullPointerException(\"The finalRules argument must not be null\");\n+            }\n+            this.finalRules = finalRules;\n+            this.phonemeBuilder = phonemeBuilder;\n+            this.input = input;\n+            this.i = i;\n+        }\n+\n+        public int getI() {\n+            return this.i;\n+        }\n+\n+        public PhonemeBuilder getPhonemeBuilder() {\n+            return this.phonemeBuilder;\n+        }\n+\n+        public RulesApplication invoke() {\n+            this.found = false;\n+            int patternLength = 0;\n+            RULES: for (Rule rule : this.finalRules) {\n+                String pattern = rule.getPattern();\n+                patternLength = pattern.length();\n+                // log(\"trying pattern: \" + pattern);\n+\n+                if (!rule.patternAndContextMatches(this.input, this.i)) {\n+                    // log(\"no match\");\n+                    continue RULES;\n+                }\n+\n+                this.phonemeBuilder = this.phonemeBuilder.apply(rule.getPhoneme());\n+                this.found = true;\n+                break RULES;\n+            }\n+\n+            if (!this.found) {\n+                patternLength = 1;\n+            }\n+\n+            this.i += patternLength;\n+            return this;\n+        }\n+\n+        public boolean isFound() {\n+            return this.found;\n+        }\n+    }\n+\n+    private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class);\n+\n+    static {\n+        NAME_PREFIXES.put(NameType.ASHKENAZI,\n+                Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\"bar\", \"ben\", \"da\", \"de\", \"van\", \"von\"))));\n+        NAME_PREFIXES.put(NameType.SEPHARDIC, Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\"al\", \"el\", \"da\", \"dal\", \"de\",\n+                \"del\", \"dela\", \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n+        NAME_PREFIXES.put(NameType.GENERIC, Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\"da\", \"dal\", \"de\", \"del\", \"dela\",\n+                \"de la\", \"della\", \"des\", \"di\", \"do\", \"dos\", \"du\", \"van\", \"von\"))));\n+    }\n+\n+    private static CharSequence cacheSubSequence(final CharSequence cached) {\n+        // return cached;\n+        final CharSequence[][] cache = new CharSequence[cached.length()][cached.length()];\n+        return new CharSequence() {\n+            public char charAt(int index) {\n+                return cached.charAt(index);\n+            }\n+\n+            public int length() {\n+                return cached.length();\n+            }\n+\n+            public CharSequence subSequence(int start, int end) {\n+                if (start == end) {\n+                    return \"\";\n+                }\n+\n+                CharSequence res = cache[start][end - 1];\n+                if (res == null) {\n+                    res = cached.subSequence(start, end);\n+                    cache[start][end - 1] = res;\n+                }\n+                return res;\n+            }\n+        };\n+    }\n+\n+    private static String join(Iterable<String> strings, String sep) {\n+        StringBuilder sb = new StringBuilder();\n+        Iterator<String> si = strings.iterator();\n+        if (si.hasNext()) {\n+            sb.append(si.next());\n+        }\n+        while (si.hasNext()) {\n+            sb.append(sep).append(si.next());\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    private final Lang lang;\n+\n+    private final NameType nameType;\n+\n+    private final RuleType ruleType;\n+\n+    private final boolean concat;\n+\n+    /**\n+     * Generates a new, fully-configured phonetic engine.\n+     * \n+     * @param nameType\n+     *            the type of names it will use\n+     * @param ruleType\n+     *            the type of rules it will apply\n+     * @param concat\n+     *            if it will concatenate multiple encodings\n+     */\n+    public PhoneticEngine(NameType nameType, RuleType ruleType, boolean concat) {\n+        if (ruleType == RuleType.RULES) {\n+            throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES);\n+        }\n+        this.nameType = nameType;\n+        this.ruleType = ruleType;\n+        this.concat = concat;\n+        this.lang = Lang.instance(nameType);\n+    }\n+\n+    private PhonemeBuilder applyFinalRules(PhonemeBuilder phonemeBuilder, List<Rule> finalRules) {\n+        if (finalRules == null) {\n+            throw new NullPointerException(\"finalRules can not be null\");\n+        }\n+        if (finalRules.isEmpty()) {\n+            return phonemeBuilder;\n+        }\n+\n+        Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n+\n+        for (Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n+            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n+            CharSequence phonemeText = cacheSubSequence(phoneme.getPhonemeText());\n+            // System.err.println(\"Expanding: \" + phonemeText);\n+\n+            for (int i = 0; i < phonemeText.length();) {\n+                RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i).invoke();\n+                boolean found = rulesApplication.isFound();\n+                subBuilder = rulesApplication.getPhonemeBuilder();\n+\n+                if (!found) {\n+                    // System.err.println(\"Not found. Appending as-is\");\n+                    subBuilder = subBuilder.append(phonemeText.subSequence(i, i + 1));\n+                }\n+\n+                i = rulesApplication.getI();\n+\n+                // System.err.println(phonemeText + \" \" + i + \": \" + subBuilder.makeString());\n+            }\n+\n+            // System.err.println(\"Expanded to: \" + subBuilder.makeString());\n+            // System.err.println(\"phenomes in collection of type: \" + subBuilder.getPhonemes().getClass());\n+            phonemes.addAll(subBuilder.getPhonemes());\n+        }\n+\n+        return new PhonemeBuilder(phonemes);\n+    }\n+\n+    /**\n+     * Encodes a string to its phonetic representation.\n+     * \n+     * @param input\n+     *            the String to encode\n+     * @return the encoding of the input\n+     */\n+    public String encode(String input) {\n+        Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\n+        return encode(input, languageSet);\n+    }\n+\n+    /**\n+     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.\n+     * \n+     * @param input\n+     *            String to phoneticise; a String with dashes or spaces separating each word\n+     * @param languageSet\n+     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the input\n+     */\n+    public String encode(String input, final Languages.LanguageSet languageSet) {\n+        final List<Rule> rules = Rule.getInstance(this.nameType, RuleType.RULES, languageSet);\n+        final List<Rule> finalRules1 = Rule.getInstance(this.nameType, this.ruleType, \"common\");\n+        final List<Rule> finalRules2 = Rule.getInstance(this.nameType, this.ruleType, languageSet);\n+        // System.err.println(\"Languages: \" + languageSet);\n+        // System.err.println(\"Rules: \" + rules);\n+\n+        // tidy the input\n+        // lower case is a locale-dependent operation\n+        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n+\n+        if (this.nameType == NameType.GENERIC) {\n+            if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) { // check for d'\n+                String remainder = input.substring(2);\n+                String combined = \"d\" + remainder;\n+                return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n+            }\n+            for (String l : NAME_PREFIXES.get(this.nameType)) {\n+                // handle generic prefixes\n+                if (input.startsWith(l + \" \")) {\n+                    // check for any prefix in the words list\n+                    String remainder = input.substring(l.length() + 1); // input without the prefix\n+                    String combined = l + remainder; // input with prefix without space\n+                    return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n+                }\n+            }\n+        }\n+\n+        final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n+        final List<String> words2 = new ArrayList<String>();\n+\n+        switch (this.nameType) {\n+        case SEPHARDIC:\n+            for (String aWord : words) {\n+                String[] parts = aWord.split(\"'\");\n+                String lastPart = parts[parts.length - 1];\n+                words2.add(lastPart);\n+            }\n+            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n+            break;\n+        case ASHKENAZI:\n+            words2.addAll(words);\n+            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n+            break;\n+        case GENERIC:\n+            words2.addAll(words);\n+            break;\n+        default:\n+            throw new IllegalStateException(\"Unreachable case: \" + this.nameType);\n+        }\n+\n+        if (this.concat) {\n+            // concat mode enabled\n+            input = join(words2, \" \");\n+        } else if (words2.size() == 1) {\n+            // not a multi-word name\n+            input = words.iterator().next();\n+        } else {\n+            // encode each word in a multi-word name separately (normally used for approx matches)\n+            StringBuilder result = new StringBuilder();\n+            for (String word : words2) {\n+                result.append(\"-\").append(encode(word));\n+            }\n+            // return the result without the leading \"-\"\n+            return result.substring(1);\n+        }\n+\n+        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n+\n+        // loop over each char in the input - we will handle the increment manually\n+        CharSequence inputCache = cacheSubSequence(input);\n+        for (int i = 0; i < inputCache.length();) {\n+            RulesApplication rulesApplication = new RulesApplication(rules, inputCache, phonemeBuilder, i).invoke();\n+            i = rulesApplication.getI();\n+            phonemeBuilder = rulesApplication.getPhonemeBuilder();\n+            // System.err.println(input + \" \" + i + \": \" + phonemeBuilder.makeString());\n+        }\n+\n+        // System.err.println(\"Applying general rules\");\n+        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n+        // System.err.println(\"Now got: \" + phonemeBuilder.makeString());\n+        // System.err.println(\"Applying language-specific rules\");\n+        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n+        // System.err.println(\"Now got: \" + phonemeBuilder.makeString());\n+        // System.err.println(\"Done\");\n+\n+        return phonemeBuilder.makeString();\n+    }\n+\n+    /**\n+     * Gets the Lang language guessing rules being used.\n+     * \n+     * @return the Lang in use\n+     */\n+    public Lang getLang() {\n+        return this.lang;\n+    }\n+\n+    /**\n+     * Gets the NameType being used.\n+     * \n+     * @return the NameType in use\n+     */\n+    public NameType getNameType() {\n+        return this.nameType;\n+    }\n+\n+    /**\n+     * Gets the RuleType being used.\n+     * \n+     * @return the RuleType in use\n+     */\n+    public RuleType getRuleType() {\n+        return this.ruleType;\n+    }\n+\n+    /**\n+     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n+     * \n+     * @return true if multiple phonetic encodings are returned, false if just the first is.\n+     */\n+    public boolean isConcat() {\n+        return this.concat;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/bm/ResourceConstants.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+/**\n+ * Constants used to process resource files.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+class ResourceConstants {\n+\n+    static final String CMT = \"//\";\n+    static final String ENCODING = \"UTF-8\";\n+    static final String EXT_CMT_END = \"*/\";\n+    static final String EXT_CMT_START = \"/*\";\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * <p>\n+ * A phoneme rule.\n+ * </p>\n+ * <p>\n+ * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply and a logical flag indicating if\n+ * all lanugages must be in play. A rule matches if:\n+ * <ul>\n+ * <li>the pattern matches at the current position</li>\n+ * <li>the string up until the beginning of the pattern matches the left context</li>\n+ * <li>the string from the end of the pattern matches the right context</li>\n+ * <li>logical is ALL and all languages are in scope; or</li>\n+ * <li>logical is any other value and at least one language is in scope</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user to explicitly construct their\n+ * own.\n+ * </p>\n+ * <p>\n+ * Rules are immutable and thread-safe.\n+ * <h2>Rules resources</h2>\n+ * <p>\n+ * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically named following the pattern:\n+ * <blockquote>org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt</blockquote>\n+ * </p>\n+ * <p>\n+ * The format of these resources is the following:\n+ * <ul>\n+ * <li><b>Rules:</b> whitespace separated, double-quoted strings. There should be 4 columns to each row, and these will be interpreted as:\n+ * <ol>\n+ * <li>pattern</li>\n+ * <li>left context</li>\n+ * <li>right context</li>\n+ * <li>phoneme</li>\n+ * </ol>\n+ * </li>\n+ * <li><b>End-of-line comments:</b> Any occurance of '//' will cause all text following on that line to be discarded as a comment.</li>\n+ * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip all content until a\n+ * line ending in '*' and '/' is found.</li>\n+ * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n+ * </ul>\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+public class Rule {\n+\n+    public static final class Phoneme implements PhonemeExpr {\n+        public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() {\n+            public int compare(Phoneme o1, Phoneme o2) {\n+                for (int i = 0; i < o1.phonemeText.length(); i++) {\n+                    if (i >= o2.phonemeText.length()) {\n+                        return +1;\n+                    }\n+                    int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\n+                    if (c != 0) {\n+                        return c;\n+                    }\n+                }\n+\n+                if (o1.phonemeText.length() < o2.phonemeText.length()) {\n+                    return -1;\n+                }\n+\n+                return 0;\n+            }\n+        };\n+\n+        private final CharSequence phonemeText;\n+        private final Languages.LanguageSet languages;\n+\n+        public Phoneme(CharSequence phonemeText, Languages.LanguageSet languages) {\n+            this.phonemeText = phonemeText;\n+            this.languages = languages;\n+        }\n+\n+        public Phoneme append(CharSequence str) {\n+            return new Phoneme(this.phonemeText.toString() + str.toString(), this.languages);\n+        }\n+\n+        public Languages.LanguageSet getLanguages() {\n+            return this.languages;\n+        }\n+\n+        public Iterable<Phoneme> getPhonemes() {\n+            return Collections.singleton(this);\n+        }\n+\n+        public CharSequence getPhonemeText() {\n+            return this.phonemeText;\n+        }\n+\n+        public Phoneme join(Phoneme right) {\n+            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(), this.languages.restrictTo(right.languages));\n+        }\n+    }\n+\n+    public interface PhonemeExpr {\n+        Iterable<Phoneme> getPhonemes();\n+    }\n+\n+    public static final class PhonemeList implements PhonemeExpr {\n+        private final List<Phoneme> phonemes;\n+\n+        public PhonemeList(List<Phoneme> phonemes) {\n+            this.phonemes = phonemes;\n+        }\n+\n+        public List<Phoneme> getPhonemes() {\n+            return this.phonemes;\n+        }\n+    }\n+\n+    /**\n+     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\n+     */\n+    public static interface RPattern {\n+        boolean isMatch(CharSequence input);\n+    }\n+\n+    public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {\n+        public boolean isMatch(CharSequence input) {\n+            return true;\n+        }\n+    };\n+\n+    public static final String ALL = \"ALL\";\n+\n+    private static final String DOUBLE_QUOTE = \"\\\"\";\n+\n+    private static final String HASH_INCLUDE = \"#include\";\n+\n+    private static final Map<NameType, Map<RuleType, Map<String, List<Rule>>>> RULES = new EnumMap<NameType, Map<RuleType, Map<String, List<Rule>>>>(\n+            NameType.class);\n+\n+    static {\n+        for (NameType s : NameType.values()) {\n+            Map<RuleType, Map<String, List<Rule>>> rts = new EnumMap<RuleType, Map<String, List<Rule>>>(RuleType.class);\n+\n+            for (RuleType rt : RuleType.values()) {\n+                Map<String, List<Rule>> rs = new HashMap<String, List<Rule>>();\n+\n+                Languages ls = Languages.getInstance(s);\n+                for (String l : ls.getLanguages()) {\n+                    try {\n+                        rs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l)));\n+                    } catch (IllegalStateException e) {\n+                        throw new IllegalStateException(\"Problem processing \" + createResourceName(s, rt, l), e);\n+                    }\n+                }\n+                if (!rt.equals(RuleType.RULES)) {\n+                    rs.put(\"common\", parseRules(createScanner(s, rt, \"common\"), createResourceName(s, rt, \"common\")));\n+                }\n+\n+                rts.put(rt, Collections.unmodifiableMap(rs));\n+            }\n+\n+            RULES.put(s, Collections.unmodifiableMap(rts));\n+        }\n+    }\n+\n+    private static boolean contains(CharSequence chars, char input) {\n+        for (int i = 0; i < chars.length(); i++) {\n+            if (chars.charAt(i) == input) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static String createResourceName(NameType nameType, RuleType rt, String lang) {\n+        return String.format(\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\", nameType.getName(), rt.getName(), lang);\n+    }\n+\n+    private static Scanner createScanner(NameType nameType, RuleType rt, String lang) {\n+        String resName = createResourceName(nameType, rt, lang);\n+        InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n+\n+        if (rulesIS == null) {\n+            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n+        }\n+\n+        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n+    }\n+\n+    private static Scanner createScanner(String lang) {\n+        String resName = String.format(\"org/apache/commons/codec/language/bm/%s.txt\", lang);\n+        InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\n+\n+        if (rulesIS == null) {\n+            throw new IllegalArgumentException(\"Unable to load resource: \" + resName);\n+        }\n+\n+        return new Scanner(rulesIS, ResourceConstants.ENCODING);\n+    }\n+\n+    private static boolean endsWith(CharSequence input, CharSequence suffix) {\n+        if (suffix.length() > input.length()) {\n+            return false;\n+        }\n+        for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) {\n+            if (input.charAt(i) != suffix.charAt(j)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets rules for a combination of name type, rule type and languages.\n+     * \n+     * @param nameType\n+     *            the NameType to consider\n+     * @param rt\n+     *            the RuleType to consider\n+     * @param langs\n+     *            the set of languages to consider\n+     * @return a list of Rules that apply\n+     */\n+    public static List<Rule> getInstance(NameType nameType, RuleType rt, Languages.LanguageSet langs) {\n+        return langs.isSingleton() ? getInstance(nameType, rt, langs.getAny()) : getInstance(nameType, rt, Languages.ANY);\n+    }\n+\n+    /**\n+     * Gets rules for a combination of name type, rule type and a single language.\n+     * \n+     * @param nameType\n+     *            the NameType to consider\n+     * @param rt\n+     *            the RuleType to consider\n+     * @param lang\n+     *            the language to consider\n+     * @return a list rules for a combination of name type, rule type and a single language.\n+     */\n+    public static List<Rule> getInstance(NameType nameType, RuleType rt, String lang) {\n+        List<Rule> rules = RULES.get(nameType).get(rt).get(lang);\n+\n+        if (rules == null) {\n+            throw new IllegalArgumentException(String.format(\"No rules found for %s, %s, %s.\", nameType.getName(), rt.getName(), lang));\n+        }\n+\n+        return rules;\n+    }\n+\n+    private static Phoneme parsePhoneme(String ph) {\n+        int open = ph.indexOf(\"[\");\n+        if (open >= 0) {\n+            if (!ph.endsWith(\"]\")) {\n+                throw new IllegalArgumentException(\"Phoneme expression contains a '[' but does not end in ']'\");\n+            }\n+            String before = ph.substring(0, open);\n+            String in = ph.substring(open + 1, ph.length() - 1);\n+            Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\"[+]\")));\n+\n+            return new Phoneme(before, Languages.LanguageSet.from(langs));\n+        } else {\n+            return new Phoneme(ph, Languages.ANY_LANGUAGE);\n+        }\n+    }\n+\n+    private static PhonemeExpr parsePhonemeExpr(String ph) {\n+        if (ph.startsWith(\"(\")) { // we have a bracketed list of options\n+            if (!ph.endsWith(\")\")) {\n+                throw new IllegalArgumentException(\"Phoneme starts with '(' so must end with ')'\");\n+            }\n+\n+            List<Phoneme> phs = new ArrayList<Phoneme>();\n+            String body = ph.substring(1, ph.length() - 1);\n+            for (String part : body.split(\"[|]\")) {\n+                phs.add(parsePhoneme(part));\n+            }\n+            if (body.startsWith(\"|\") || body.endsWith(\"|\")) {\n+                phs.add(new Phoneme(\"\", Languages.ANY_LANGUAGE));\n+            }\n+\n+            return new PhonemeList(phs);\n+        } else {\n+            return parsePhoneme(ph);\n+        }\n+    }\n+\n+    private static List<Rule> parseRules(final Scanner scanner, final String location) {\n+        List<Rule> lines = new ArrayList<Rule>();\n+        int currentLine = 0;\n+\n+        boolean inMultilineComment = false;\n+        while (scanner.hasNextLine()) {\n+            currentLine++;\n+            String rawLine = scanner.nextLine();\n+            String line = rawLine;\n+\n+            if (inMultilineComment) {\n+                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\n+                    inMultilineComment = false;\n+                } else {\n+                    // skip\n+                }\n+            } else {\n+                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\n+                    inMultilineComment = true;\n+                } else {\n+                    // discard comments\n+                    int cmtI = line.indexOf(ResourceConstants.CMT);\n+                    if (cmtI >= 0) {\n+                        line = line.substring(0, cmtI);\n+                    }\n+\n+                    // trim leading-trailing whitespace\n+                    line = line.trim();\n+\n+                    if (line.length() == 0) {\n+                        continue; // empty lines can be safely skipped\n+                    }\n+\n+                    if (line.startsWith(HASH_INCLUDE)) {\n+                        // include statement\n+                        String incl = line.substring(HASH_INCLUDE.length()).trim();\n+                        if (incl.contains(\" \")) {\n+                            System.err.println(\"Warining: malformed import statement: \" + rawLine);\n+                        } else {\n+                            lines.addAll(parseRules(createScanner(incl), location + \"->\" + incl));\n+                        }\n+                    } else {\n+                        // rule\n+                        String[] parts = line.split(\"\\\\s+\");\n+                        if (parts.length != 4) {\n+                            System.err.println(\"Warning: malformed rule statement split into \" + parts.length + \" parts: \" + rawLine);\n+                        } else {\n+                            try {\n+                                String pat = stripQuotes(parts[0]);\n+                                String lCon = stripQuotes(parts[1]);\n+                                String rCon = stripQuotes(parts[2]);\n+                                PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\n+                                final int cLine = currentLine;\n+                                Rule r = new Rule(pat, lCon, rCon, ph) {\n+                                    private final int myLine = cLine;\n+                                    private final String loc = location;\n+\n+                                    @Override\n+                                    public String toString() {\n+                                        final StringBuilder sb = new StringBuilder();\n+                                        sb.append(\"Rule\");\n+                                        sb.append(\"{line=\").append(myLine);\n+                                        sb.append(\", loc='\").append(loc).append('\\'');\n+                                        sb.append('}');\n+                                        return sb.toString();\n+                                    }\n+                                };\n+                                lines.add(r);\n+                            } catch (IllegalArgumentException e) {\n+                                throw new IllegalStateException(\"Problem parsing line \" + currentLine, e);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return lines;\n+    }\n+\n+    /**\n+     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.\n+     * \n+     * @param regex\n+     *            the regular expression to compile\n+     * @return an RPattern that will match this regex\n+     */\n+    private static RPattern pattern(final String regex) {\n+        boolean startsWith = regex.startsWith(\"^\");\n+        boolean endsWith = regex.endsWith(\"$\");\n+        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\n+        boolean boxes = content.contains(\"[\");\n+\n+        if (!boxes) {\n+            if (startsWith && endsWith) {\n+                // exact match\n+                if (content.length() == 0) {\n+                    // empty\n+                    return new RPattern() {\n+                        public boolean isMatch(CharSequence input) {\n+                            return input.length() == 0;\n+                        }\n+                    };\n+                } else {\n+                    return new RPattern() {\n+                        public boolean isMatch(CharSequence input) {\n+                            return input.equals(content);\n+                        }\n+                    };\n+                }\n+            } else if ((startsWith || endsWith) && content.length() == 0) {\n+                // matches every string\n+                return ALL_STRINGS_RMATCHER;\n+            } else if (startsWith) {\n+                // matches from start\n+                return new RPattern() {\n+                    public boolean isMatch(CharSequence input) {\n+                        return startsWith(input, content);\n+                    }\n+                };\n+            } else if (endsWith) {\n+                // matches from start\n+                return new RPattern() {\n+                    public boolean isMatch(CharSequence input) {\n+                        return endsWith(input, content);\n+                    }\n+                };\n+            }\n+        } else {\n+            boolean startsWithBox = content.startsWith(\"[\");\n+            boolean endsWithBox = content.endsWith(\"]\");\n+\n+            if (startsWithBox && endsWithBox) {\n+                String boxContent = content.substring(1, content.length() - 1);\n+                if (!boxContent.contains(\"[\")) {\n+                    // box containing alternatives\n+                    boolean negate = boxContent.startsWith(\"^\");\n+                    if (negate) {\n+                        boxContent = boxContent.substring(1);\n+                    }\n+                    final String bContent = boxContent;\n+                    final boolean shouldMatch = !negate;\n+\n+                    if (startsWith && endsWith) {\n+                        // exact match\n+                        return new RPattern() {\n+                            public boolean isMatch(CharSequence input) {\n+                                return input.length() == 1 && (contains(bContent, input.charAt(0)) == shouldMatch);\n+                            }\n+                        };\n+                    } else if (startsWith) {\n+                        // first char\n+                        return new RPattern() {\n+                            public boolean isMatch(CharSequence input) {\n+                                return input.length() > 0 && (contains(bContent, input.charAt(0)) == shouldMatch);\n+                            }\n+                        };\n+                    } else if (endsWith) {\n+                        // last char\n+                        return new RPattern() {\n+                            public boolean isMatch(CharSequence input) {\n+                                return input.length() > 0 && (contains(bContent, input.charAt(input.length() - 1)) == shouldMatch);\n+                            }\n+                        };\n+                    }\n+                }\n+            }\n+        }\n+\n+        // System.out.println(\"Couldn't optimize regex: \" + regex);\n+        return new RPattern() {\n+            Pattern pattern = Pattern.compile(regex);\n+\n+            public boolean isMatch(CharSequence input) {\n+                Matcher matcher = pattern.matcher(input);\n+                return matcher.find();\n+            }\n+        };\n+    }\n+\n+    private static boolean startsWith(CharSequence input, CharSequence prefix) {\n+        if (prefix.length() > input.length()) {\n+            return false;\n+        }\n+        for (int i = 0; i < prefix.length(); i++) {\n+            if (input.charAt(i) != prefix.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static String stripQuotes(String str) {\n+        if (str.startsWith(DOUBLE_QUOTE)) {\n+            str = str.substring(1);\n+        }\n+\n+        if (str.endsWith(DOUBLE_QUOTE)) {\n+            str = str.substring(0, str.length() - 1);\n+        }\n+\n+        return str;\n+    }\n+\n+    private final RPattern lContext;\n+\n+    private final String pattern;\n+\n+    private final PhonemeExpr phoneme;\n+\n+    private final RPattern rContext;\n+\n+    /**\n+     * Creates a new rule.\n+     * \n+     * @param pattern\n+     *            the pattern\n+     * @param lContext\n+     *            the left context\n+     * @param rContext\n+     *            the right context\n+     * @param phoneme\n+     *            the resulting phoneme\n+     */\n+    public Rule(String pattern, String lContext, String rContext, PhonemeExpr phoneme) {\n+        this.pattern = pattern;\n+        this.lContext = pattern(lContext + \"$\");\n+        this.rContext = pattern(\"^\" + rContext);\n+        this.phoneme = phoneme;\n+    }\n+\n+    /**\n+     * Gets the left context. This is a regular expression that must match to the left of the pattern.\n+     * \n+     * @return the left context Pattern\n+     */\n+    public RPattern getLContext() {\n+        return this.lContext;\n+    }\n+\n+    /**\n+     * Gets the pattern. This is a string-literal that must exactly match.\n+     * \n+     * @return the pattern\n+     */\n+    public String getPattern() {\n+        return this.pattern;\n+    }\n+\n+    /**\n+     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n+     * \n+     * @return the phoneme\n+     */\n+    public PhonemeExpr getPhoneme() {\n+        return this.phoneme;\n+    }\n+\n+    /**\n+     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n+     * \n+     * @return the right context Pattern\n+     */\n+    public RPattern getRContext() {\n+        return this.rContext;\n+    }\n+\n+    /**\n+     * Decides if the pattern and context match the input starting at a position.\n+     * \n+     * @param input\n+     *            the input String\n+     * @param i\n+     *            the int position within the input\n+     * @return true if the pattern and left/right context match, false otherwise\n+     */\n+    public boolean patternAndContextMatches(CharSequence input, int i) {\n+        if (i < 0) {\n+            throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n+        }\n+\n+        int patternLength = this.pattern.length();\n+        int ipl = i + patternLength;\n+\n+        if (ipl > input.length()) {\n+            // not enough room for the pattern to match\n+            return false;\n+        }\n+\n+        boolean patternMatches = input.subSequence(i, ipl).equals(this.pattern);\n+        boolean rContextMatches = this.rContext.isMatch(input.subSequence(ipl, input.length()));\n+        boolean lContextMatches = this.lContext.isMatch(input.subSequence(0, i));\n+\n+        return patternMatches && rContextMatches && lContextMatches;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/bm/RuleType.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+/**\n+ * Types of rule.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+public enum RuleType {\n+\n+    APPROX(\"approx\"), EXACT(\"exact\"), RULES(\"rules\");\n+\n+    private final String name;\n+\n+    RuleType(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/net/BCodec.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.net;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringDecoder;\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.binary.Base64;\n+\n+/**\n+ * <p>\n+ * Identical to the Base64 encoding defined by <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC\n+ * 1521</a> and allows a character set to be specified.\n+ * </p>\n+ * \n+ * <p>\n+ * <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">RFC 1522</a> describes techniques to allow the encoding of non-ASCII\n+ * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message\n+ * handling software.\n+ * </p>\n+ * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">MIME (Multipurpose Internet Mail Extensions) Part Two: Message\n+ *          Header Extensions for Non-ASCII Text</a>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.3\n+ * @version $Id$\n+ */\n+public class BCodec extends RFC1522Codec implements StringEncoder, StringDecoder {\n+    /**\n+     * The default charset used for string decoding and encoding.\n+     */\n+    private final String charset;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public BCodec() {\n+        this(CharEncoding.UTF_8);\n+    }\n+\n+    /**\n+     * Constructor which allows for the selection of a default charset\n+     * \n+     * @param charset\n+     *                  the default string charset to use.\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public BCodec(final String charset) {\n+        super();\n+        this.charset = charset;\n+    }\n+\n+    @Override\n+    protected String getEncoding() {\n+        return \"B\";\n+    }\n+\n+    @Override\n+    protected byte[] doEncoding(byte[] bytes) {\n+        if (bytes == null) {\n+            return null;\n+        }\n+        return Base64.encodeBase64(bytes);\n+    }\n+\n+    @Override\n+    protected byte[] doDecoding(byte[] bytes) {\n+        if (bytes == null) {\n+            return null;\n+        }\n+        return Base64.decodeBase64(bytes);\n+    }\n+\n+    /**\n+     * Encodes a string into its Base64 form using the specified charset. Unsafe characters are escaped.\n+     * \n+     * @param value\n+     *                  string to convert to Base64 form\n+     * @param charset\n+     *                  the charset for <code>value</code>\n+     * @return Base64 string\n+     * \n+     * @throws EncoderException\n+     *                  thrown if a failure condition is encountered during the encoding process.\n+     */\n+    public String encode(final String value, final String charset) throws EncoderException {\n+        if (value == null) {\n+            return null;\n+        }\n+        try {\n+            return encodeText(value, charset);\n+        } catch (UnsupportedEncodingException e) {\n+            throw new EncoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Encodes a string into its Base64 form using the default charset. Unsafe characters are escaped.\n+     * \n+     * @param value\n+     *                  string to convert to Base64 form\n+     * @return Base64 string\n+     * \n+     * @throws EncoderException\n+     *                  thrown if a failure condition is encountered during the encoding process.\n+     */\n+    public String encode(String value) throws EncoderException {\n+        if (value == null) {\n+            return null;\n+        }\n+        return encode(value, getDefaultCharset());\n+    }\n+\n+    /**\n+     * Decodes a Base64 string into its original form. Escaped characters are converted back to their original\n+     * representation.\n+     * \n+     * @param value\n+     *            Base64 string to convert into its original form\n+     * @return original string\n+     * @throws DecoderException\n+     *             A decoder exception is thrown if a failure condition is encountered during the decode process.\n+     */\n+    public String decode(String value) throws DecoderException {\n+        if (value == null) {\n+            return null;\n+        }\n+        try {\n+            return decodeText(value);\n+        } catch (UnsupportedEncodingException e) {\n+            throw new DecoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Encodes an object into its Base64 form using the default charset. Unsafe characters are escaped.\n+     * \n+     * @param value\n+     *                  object to convert to Base64 form\n+     * @return Base64 object\n+     * \n+     * @throws EncoderException\n+     *                  thrown if a failure condition is encountered during the encoding process.\n+     */\n+    public Object encode(Object value) throws EncoderException {\n+        if (value == null) {\n+            return null;\n+        } else if (value instanceof String) {\n+            return encode((String) value);\n+        } else {\n+            throw new EncoderException(\"Objects of type \" +\n+                  value.getClass().getName() +\n+                  \" cannot be encoded using BCodec\");\n+        }\n+    }\n+\n+    /**\n+     * Decodes a Base64 object into its original form. Escaped characters are converted back to their original\n+     * representation.\n+     * \n+     * @param value\n+     *                  Base64 object to convert into its original form\n+     * \n+     * @return original object\n+     * \n+     * @throws DecoderException\n+     *                  Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is\n+     *                  encountered during the decode process.\n+     */\n+    public Object decode(Object value) throws DecoderException {\n+        if (value == null) {\n+            return null;\n+        } else if (value instanceof String) {\n+            return decode((String) value);\n+        } else {\n+            throw new DecoderException(\"Objects of type \" +\n+                  value.getClass().getName() +\n+                  \" cannot be decoded using BCodec\");\n+        }\n+    }\n+\n+    /**\n+     * The default charset used for string decoding and encoding.\n+     * \n+     * @return the default string charset.\n+     */\n+    public String getDefaultCharset() {\n+        return this.charset;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/net/QCodec.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.net;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.BitSet;\n+\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringDecoder;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * <p>\n+ * Similar to the Quoted-Printable content-transfer-encoding defined in <a\n+ * href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521</a> and designed to allow text containing mostly ASCII\n+ * characters to be decipherable on an ASCII terminal without decoding.\n+ * </p>\n+ * \n+ * <p>\n+ * <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">RFC 1522</a> describes techniques to allow the encoding of non-ASCII\n+ * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message\n+ * handling software.\n+ * </p>\n+ * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">MIME (Multipurpose Internet Mail Extensions) Part Two: Message\n+ *          Header Extensions for Non-ASCII Text</a>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.3\n+ * @version $Id$\n+ */\n+public class QCodec extends RFC1522Codec implements StringEncoder, StringDecoder {\n+    /**\n+     * The default charset used for string decoding and encoding.\n+     */\n+    private final String charset;\n+\n+    /**\n+     * BitSet of printable characters as defined in RFC 1522.\n+     */\n+    private static final BitSet PRINTABLE_CHARS = new BitSet(256);\n+    // Static initializer for printable chars collection\n+    static {\n+        // alpha characters\n+        PRINTABLE_CHARS.set(' ');\n+        PRINTABLE_CHARS.set('!');\n+        PRINTABLE_CHARS.set('\"');\n+        PRINTABLE_CHARS.set('#');\n+        PRINTABLE_CHARS.set('$');\n+        PRINTABLE_CHARS.set('%');\n+        PRINTABLE_CHARS.set('&');\n+        PRINTABLE_CHARS.set('\\'');\n+        PRINTABLE_CHARS.set('(');\n+        PRINTABLE_CHARS.set(')');\n+        PRINTABLE_CHARS.set('*');\n+        PRINTABLE_CHARS.set('+');\n+        PRINTABLE_CHARS.set(',');\n+        PRINTABLE_CHARS.set('-');\n+        PRINTABLE_CHARS.set('.');\n+        PRINTABLE_CHARS.set('/');\n+        for (int i = '0'; i <= '9'; i++) {\n+            PRINTABLE_CHARS.set(i);\n+        }\n+        PRINTABLE_CHARS.set(':');\n+        PRINTABLE_CHARS.set(';');\n+        PRINTABLE_CHARS.set('<');\n+        PRINTABLE_CHARS.set('>');\n+        PRINTABLE_CHARS.set('@');\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            PRINTABLE_CHARS.set(i);\n+        }\n+        PRINTABLE_CHARS.set('[');\n+        PRINTABLE_CHARS.set('\\\\');\n+        PRINTABLE_CHARS.set(']');\n+        PRINTABLE_CHARS.set('^');\n+        PRINTABLE_CHARS.set('`');\n+        for (int i = 'a'; i <= 'z'; i++) {\n+            PRINTABLE_CHARS.set(i);\n+        }\n+        PRINTABLE_CHARS.set('{');\n+        PRINTABLE_CHARS.set('|');\n+        PRINTABLE_CHARS.set('}');\n+        PRINTABLE_CHARS.set('~');\n+    }\n+\n+    private static final byte BLANK = 32;\n+\n+    private static final byte UNDERSCORE = 95;\n+\n+    private boolean encodeBlanks = false;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public QCodec() {\n+        this(CharEncoding.UTF_8);\n+    }\n+\n+    /**\n+     * Constructor which allows for the selection of a default charset\n+     * \n+     * @param charset\n+     *                  the default string charset to use.\n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    public QCodec(final String charset) {\n+        super();\n+        this.charset = charset;\n+    }\n+\n+    @Override\n+    protected String getEncoding() {\n+        return \"Q\";\n+    }\n+\n+    @Override\n+    protected byte[] doEncoding(byte[] bytes) {\n+        if (bytes == null) {\n+            return null;\n+        }\n+        byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n+        if (this.encodeBlanks) {\n+            for (int i = 0; i < data.length; i++) {\n+                if (data[i] == BLANK) {\n+                    data[i] = UNDERSCORE;\n+                }\n+            }\n+        }\n+        return data;\n+    }\n+\n+    @Override\n+    protected byte[] doDecoding(byte[] bytes) throws DecoderException {\n+        if (bytes == null) {\n+            return null;\n+        }\n+        boolean hasUnderscores = false;\n+        for (byte b : bytes) {\n+            if (b == UNDERSCORE) {\n+                hasUnderscores = true;\n+                break;\n+            }\n+        }\n+        if (hasUnderscores) {\n+            byte[] tmp = new byte[bytes.length];\n+            for (int i = 0; i < bytes.length; i++) {\n+                byte b = bytes[i];\n+                if (b != UNDERSCORE) {\n+                    tmp[i] = b;\n+                } else {\n+                    tmp[i] = BLANK;\n+                }\n+            }\n+            return QuotedPrintableCodec.decodeQuotedPrintable(tmp);\n+        } \n+        return QuotedPrintableCodec.decodeQuotedPrintable(bytes);       \n+    }\n+\n+    /**\n+     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n+     * \n+     * @param pString\n+     *                  string to convert to quoted-printable form\n+     * @param charset\n+     *                  the charset for pString\n+     * @return quoted-printable string\n+     * \n+     * @throws EncoderException\n+     *                  thrown if a failure condition is encountered during the encoding process.\n+     */\n+    public String encode(final String pString, final String charset) throws EncoderException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        try {\n+            return encodeText(pString, charset);\n+        } catch (UnsupportedEncodingException e) {\n+            throw new EncoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Encodes a string into its quoted-printable form using the default charset. Unsafe characters are escaped.\n+     * \n+     * @param pString\n+     *                  string to convert to quoted-printable form\n+     * @return quoted-printable string\n+     * \n+     * @throws EncoderException\n+     *                  thrown if a failure condition is encountered during the encoding process.\n+     */\n+    public String encode(String pString) throws EncoderException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        return encode(pString, getDefaultCharset());\n+    }\n+\n+    /**\n+     * Decodes a quoted-printable string into its original form. Escaped characters are converted back to their original\n+     * representation.\n+     * \n+     * @param pString\n+     *                  quoted-printable string to convert into its original form\n+     * \n+     * @return original string\n+     * \n+     * @throws DecoderException\n+     *                  A decoder exception is thrown if a failure condition is encountered during the decode process.\n+     */\n+    public String decode(String pString) throws DecoderException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        try {\n+            return decodeText(pString);\n+        } catch (UnsupportedEncodingException e) {\n+            throw new DecoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Encodes an object into its quoted-printable form using the default charset. Unsafe characters are escaped.\n+     * \n+     * @param pObject\n+     *                  object to convert to quoted-printable form\n+     * @return quoted-printable object\n+     * \n+     * @throws EncoderException\n+     *                  thrown if a failure condition is encountered during the encoding process.\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (pObject == null) {\n+            return null;\n+        } else if (pObject instanceof String) {\n+            return encode((String) pObject);\n+        } else {\n+            throw new EncoderException(\"Objects of type \" + \n+                  pObject.getClass().getName() + \n+                  \" cannot be encoded using Q codec\");\n+        }\n+    }\n+\n+    /**\n+     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\n+     * representation.\n+     * \n+     * @param pObject\n+     *                  quoted-printable object to convert into its original form\n+     * \n+     * @return original object\n+     * \n+     * @throws DecoderException\n+     *                  Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is\n+     *                  encountered during the decode process.\n+     */\n+    public Object decode(Object pObject) throws DecoderException {\n+        if (pObject == null) {\n+            return null;\n+        } else if (pObject instanceof String) {\n+            return decode((String) pObject);\n+        } else {\n+            throw new DecoderException(\"Objects of type \" + \n+                  pObject.getClass().getName() + \n+                  \" cannot be decoded using Q codec\");\n+        }\n+    }\n+\n+    /**\n+     * The default charset used for string decoding and encoding.\n+     * \n+     * @return the default string charset.\n+     */\n+    public String getDefaultCharset() {\n+        return this.charset;\n+    }\n+\n+    /**\n+     * Tests if optional transformation of SPACE characters is to be used\n+     * \n+     * @return <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\n+     */\n+    public boolean isEncodeBlanks() {\n+        return this.encodeBlanks;\n+    }\n+\n+    /**\n+     * Defines whether optional transformation of SPACE characters is to be used\n+     * \n+     * @param b\n+     *                  <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\n+     */\n+    public void setEncodeBlanks(boolean b) {\n+        this.encodeBlanks = b;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.net;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.util.BitSet;\n+\n+import org.apache.commons.codec.BinaryDecoder;\n+import org.apache.commons.codec.BinaryEncoder;\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringDecoder;\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.binary.StringUtils;\n+\n+/**\n+ * <p>\n+ * Codec for the Quoted-Printable section of <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521</a>.\n+ * </p>\n+ * <p>\n+ * The Quoted-Printable encoding is intended to represent data that largely consists of octets that correspond to\n+ * printable characters in the ASCII character set. It encodes the data in such a way that the resulting octets are\n+ * unlikely to be modified by mail transport. If the data being encoded are mostly ASCII text, the encoded form of the\n+ * data remains largely recognizable by humans. A body which is entirely ASCII may also be encoded in Quoted-Printable\n+ * to ensure the integrity of the data should the message pass through a character- translating, and/or line-wrapping\n+ * gateway.\n+ * </p>\n+ * \n+ * <p>\n+ * Note:\n+ * </p>\n+ * <p>\n+ * Rules #3, #4, and #5 of the quoted-printable spec are not implemented yet because the complete quoted-printable spec\n+ * does not lend itself well into the byte[] oriented codec framework. Complete the codec once the streamable codec\n+ * framework is ready. The motivation behind providing the codec in a partial form is that it can already come in handy\n+ * for those applications that do not require quoted-printable line formatting (rules #3, #4, #5), for instance Q codec.\n+ * </p>\n+ * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc1521.txt\"> RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One:\n+ *          Mechanisms for Specifying and Describing the Format of Internet Message Bodies </a>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.3\n+ * @version $Id$\n+ */\n+public class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {\n+    /**\n+     * The default charset used for string decoding and encoding.\n+     */\n+    private final String charset;\n+\n+    /**\n+     * BitSet of printable characters as defined in RFC 1521.\n+     */\n+    private static final BitSet PRINTABLE_CHARS = new BitSet(256);\n+\n+    private static final byte ESCAPE_CHAR = '=';\n+\n+    private static final byte TAB = 9;\n+\n+    private static final byte SPACE = 32;\n+    // Static initializer for printable chars collection\n+    static {\n+        // alpha characters\n+        for (int i = 33; i <= 60; i++) {\n+            PRINTABLE_CHARS.set(i);\n+        }\n+        for (int i = 62; i <= 126; i++) {\n+            PRINTABLE_CHARS.set(i);\n+        }\n+        PRINTABLE_CHARS.set(TAB);\n+        PRINTABLE_CHARS.set(SPACE);\n+    }\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public QuotedPrintableCodec() {\n+        this(CharEncoding.UTF_8);\n+    }\n+\n+    /**\n+     * Constructor which allows for the selection of a default charset\n+     * \n+     * @param charset\n+     *                  the default string charset to use.\n+     */\n+    public QuotedPrintableCodec(String charset) {\n+        super();\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * Encodes byte into its quoted-printable representation.\n+     * \n+     * @param b\n+     *                  byte to encode\n+     * @param buffer\n+     *                  the buffer to write to\n+     */\n+    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n+        buffer.write(ESCAPE_CHAR);\n+        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n+        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n+        buffer.write(hex1);\n+        buffer.write(hex2);\n+    }\n+\n+    /**\n+     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n+     * \n+     * <p>\n+     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n+     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n+     * </p>\n+     * \n+     * @param printable\n+     *                  bitset of characters deemed quoted-printable\n+     * @param bytes\n+     *                  array of bytes to be encoded\n+     * @return array of bytes containing quoted-printable data\n+     */\n+    public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n+        if (bytes == null) {\n+            return null;\n+        }\n+        if (printable == null) {\n+            printable = PRINTABLE_CHARS;\n+        }\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        for (byte c : bytes) {\n+            int b = c;\n+            if (b < 0) {\n+                b = 256 + b;\n+            }\n+            if (printable.get(b)) {\n+                buffer.write(b);\n+            } else {\n+                encodeQuotedPrintable(b, buffer);\n+            }\n+        }\n+        return buffer.toByteArray();\n+    }\n+\n+    /**\n+     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted\n+     * back to their original representation.\n+     * \n+     * <p>\n+     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n+     * RFC 1521.\n+     * </p>\n+     * \n+     * @param bytes\n+     *                  array of quoted-printable characters\n+     * @return array of original bytes\n+     * @throws DecoderException\n+     *                  Thrown if quoted-printable decoding is unsuccessful\n+     */\n+    public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n+        if (bytes == null) {\n+            return null;\n+        }\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        for (int i = 0; i < bytes.length; i++) {\n+            int b = bytes[i];\n+            if (b == ESCAPE_CHAR) {\n+                try {\n+                    int u = Utils.digit16(bytes[++i]);\n+                    int l = Utils.digit16(bytes[++i]);\n+                    buffer.write((char) ((u << 4) + l));\n+                } catch (ArrayIndexOutOfBoundsException e) {\n+                    throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n+                }\n+            } else {\n+                buffer.write(b);\n+            }\n+        }\n+        return buffer.toByteArray();\n+    }\n+\n+    /**\n+     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n+     * \n+     * <p>\n+     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n+     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n+     * </p>\n+     * \n+     * @param bytes\n+     *                  array of bytes to be encoded\n+     * @return array of bytes containing quoted-printable data\n+     */\n+    public byte[] encode(byte[] bytes) {\n+        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n+    }\n+\n+    /**\n+     * Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted\n+     * back to their original representation.\n+     * \n+     * <p>\n+     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n+     * RFC 1521.\n+     * </p>\n+     * \n+     * @param bytes\n+     *                  array of quoted-printable characters\n+     * @return array of original bytes\n+     * @throws DecoderException\n+     *                  Thrown if quoted-printable decoding is unsuccessful\n+     */\n+    public byte[] decode(byte[] bytes) throws DecoderException {\n+        return decodeQuotedPrintable(bytes);\n+    }\n+\n+    /**\n+     * Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped.\n+     * \n+     * <p>\n+     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n+     * RFC 1521 and is suitable for encoding binary data.\n+     * </p>\n+     * \n+     * @param pString\n+     *                  string to convert to quoted-printable form\n+     * @return quoted-printable string\n+     * \n+     * @throws EncoderException\n+     *                  Thrown if quoted-printable encoding is unsuccessful\n+     * \n+     * @see #getDefaultCharset()\n+     */\n+    public String encode(String pString) throws EncoderException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        try {\n+            return encode(pString, getDefaultCharset());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new EncoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Decodes a quoted-printable string into its original form using the specified string charset. Escaped characters\n+     * are converted back to their original representation.\n+     * \n+     * @param pString\n+     *                  quoted-printable string to convert into its original form\n+     * @param charset\n+     *                  the original string charset\n+     * @return original string\n+     * @throws DecoderException\n+     *                  Thrown if quoted-printable decoding is unsuccessful\n+     * @throws UnsupportedEncodingException\n+     *                  Thrown if charset is not supported\n+     */\n+    public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n+    }\n+\n+    /**\n+     * Decodes a quoted-printable string into its original form using the default string charset. Escaped characters are\n+     * converted back to their original representation.\n+     * \n+     * @param pString\n+     *                  quoted-printable string to convert into its original form\n+     * @return original string\n+     * @throws DecoderException\n+     *                  Thrown if quoted-printable decoding is unsuccessful.\n+     *                  Thrown if charset is not supported.\n+     * @see #getDefaultCharset()\n+     */\n+    public String decode(String pString) throws DecoderException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        try {\n+            return decode(pString, getDefaultCharset());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new DecoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Encodes an object into its quoted-printable safe form. Unsafe characters are escaped.\n+     * \n+     * @param pObject\n+     *                  string to convert to a quoted-printable form\n+     * @return quoted-printable object\n+     * @throws EncoderException\n+     *                  Thrown if quoted-printable encoding is not applicable to objects of this type or if encoding is\n+     *                  unsuccessful\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (pObject == null) {\n+            return null;\n+        } else if (pObject instanceof byte[]) {\n+            return encode((byte[]) pObject);\n+        } else if (pObject instanceof String) {\n+            return encode((String) pObject);\n+        } else {\n+            throw new EncoderException(\"Objects of type \" + \n+                  pObject.getClass().getName() + \n+                  \" cannot be quoted-printable encoded\");\n+        }\n+    }\n+\n+    /**\n+     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\n+     * representation.\n+     * \n+     * @param pObject\n+     *                  quoted-printable object to convert into its original form\n+     * @return original object\n+     * @throws DecoderException\n+     *                  Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure condition is\n+     *                  encountered during the decode process.\n+     */\n+    public Object decode(Object pObject) throws DecoderException {\n+        if (pObject == null) {\n+            return null;\n+        } else if (pObject instanceof byte[]) {\n+            return decode((byte[]) pObject);\n+        } else if (pObject instanceof String) {\n+            return decode((String) pObject);\n+        } else {\n+            throw new DecoderException(\"Objects of type \" + \n+                  pObject.getClass().getName() + \n+                  \" cannot be quoted-printable decoded\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the default charset used for string decoding and encoding.\n+     * \n+     * @return the default string charset.\n+     */\n+    public String getDefaultCharset() {\n+        return this.charset;\n+    }\n+\n+    /**\n+     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n+     * \n+     * <p>\n+     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n+     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n+     * </p>\n+     * \n+     * @param pString\n+     *                  string to convert to quoted-printable form\n+     * @param charset\n+     *                  the charset for pString\n+     * @return quoted-printable string\n+     * \n+     * @throws UnsupportedEncodingException\n+     *                  Thrown if the charset is not supported\n+     */\n+    public String encode(String pString, String charset) throws UnsupportedEncodingException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/net/RFC1522Codec.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.net;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.binary.StringUtils;\n+\n+/**\n+ * <p>\n+ * Implements methods common to all codecs defined in RFC 1522.\n+ * </p>\n+ * \n+ * <p>\n+ * <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">RFC 1522</a> \n+ * describes techniques to allow the encoding of non-ASCII text in \n+ * various portions of a RFC 822 [2] message header, in a manner which\n+ * is unlikely to confuse existing message handling software.\n+ * </p>\n+\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">\n+ * MIME (Multipurpose Internet Mail Extensions) Part Two:\n+ * Message Header Extensions for Non-ASCII Text</a>\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.3\n+ * @version $Id$\n+ */\n+abstract class RFC1522Codec {\n+    \n+    /**\n+     * Separator.\n+     */\n+    protected static final char SEP = '?';\n+\n+    /**\n+     * Prefix\n+     */\n+    protected static final String POSTFIX = \"?=\";\n+\n+    /**\n+     * Postfix\n+     */\n+    protected static final String PREFIX = \"=?\";\n+\n+    /**\n+     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the \n+     * given charset. This method constructs the \"encoded-word\" header common to all the \n+     * RFC 1522 codecs and then invokes {@link #doEncoding(byte [])} method of a concrete \n+     * class to perform the specific encoding.\n+     * \n+     * @param text a string to encode\n+     * @param charset a charset to be used\n+     * \n+     * @return RFC 1522 compliant \"encoded-word\"\n+     * \n+     * @throws EncoderException thrown if there is an error condition during the Encoding \n+     *  process.\n+     * @throws UnsupportedEncodingException thrown if charset is not supported \n+     * \n+     * @see <a href=\"http://download.oracle.com/javase/1.5.0/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     */\n+    protected String encodeText(final String text, final String charset)\n+     throws EncoderException, UnsupportedEncodingException  \n+    {\n+        if (text == null) {\n+            return null;\n+        }\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(PREFIX); \n+        buffer.append(charset);\n+        buffer.append(SEP);\n+        buffer.append(getEncoding());\n+        buffer.append(SEP);\n+        byte [] rawdata = doEncoding(text.getBytes(charset)); \n+        buffer.append(StringUtils.newStringUsAscii(rawdata));\n+        buffer.append(POSTFIX); \n+        return buffer.toString();\n+    }\n+    \n+    /**\n+     * Applies an RFC 1522 compliant decoding scheme to the given string of text. This method \n+     * processes the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes \n+     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific decoding.\n+     * \n+     * @param text a string to decode\n+     * @return A new decoded String or <code>null</code> if the input is <code>null</code>.\n+     * \n+     * @throws DecoderException thrown if there is an error condition during the decoding \n+     *  process.\n+     * @throws UnsupportedEncodingException thrown if charset specified in the \"encoded-word\" \n+     *  header is not supported \n+     */\n+    protected String decodeText(final String text)\n+     throws DecoderException, UnsupportedEncodingException  \n+    {\n+        if (text == null) {\n+            return null;\n+        }\n+        if ((!text.startsWith(PREFIX)) || (!text.endsWith(POSTFIX))) {\n+            throw new DecoderException(\"RFC 1522 violation: malformed encoded content\");\n+        }\n+        int terminator = text.length() - 2;\n+        int from = 2;\n+        int to = text.indexOf(SEP, from);\n+        if (to == terminator) {\n+            throw new DecoderException(\"RFC 1522 violation: charset token not found\");\n+        }\n+        String charset = text.substring(from, to);\n+        if (charset.equals(\"\")) {\n+            throw new DecoderException(\"RFC 1522 violation: charset not specified\");\n+        }\n+        from = to + 1;\n+        to = text.indexOf(SEP, from);\n+        if (to == terminator) {\n+            throw new DecoderException(\"RFC 1522 violation: encoding token not found\");\n+        }\n+        String encoding = text.substring(from, to);\n+        if (!getEncoding().equalsIgnoreCase(encoding)) {\n+            throw new DecoderException(\"This codec cannot decode \" + \n+                encoding + \" encoded content\");\n+        }\n+        from = to + 1;\n+        to = text.indexOf(SEP, from);\n+        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));\n+        data = doDecoding(data); \n+        return new String(data, charset);\n+    }\n+\n+    /**\n+     * Returns the codec name (referred to as encoding in the RFC 1522)\n+     * \n+     * @return name of the codec\n+     */    \n+    protected abstract String getEncoding();\n+\n+    /**\n+     * Encodes an array of bytes using the defined encoding scheme\n+     * \n+     * @param bytes Data to be encoded\n+     *\n+     * @return A byte array containing the encoded data\n+     * \n+     * @throws EncoderException thrown if the Encoder encounters a failure condition \n+     *  during the encoding process.\n+     */    \n+    protected abstract byte[] doEncoding(byte[] bytes) throws EncoderException;\n+\n+    /**\n+     * Decodes an array of bytes using the defined encoding scheme\n+     * \n+     * @param bytes Data to be decoded\n+     *\n+     * @return a byte array that contains decoded data\n+     * \n+     * @throws DecoderException A decoder exception is thrown if a Decoder encounters a \n+     *  failure condition during the decode process.\n+     */    \n+    protected abstract byte[] doDecoding(byte[] bytes) throws DecoderException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/net/URLCodec.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.net;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.util.BitSet;\n+\n+import org.apache.commons.codec.BinaryDecoder;\n+import org.apache.commons.codec.BinaryEncoder;\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringDecoder;\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.binary.StringUtils;\n+\n+/**\n+ * <p>Implements the 'www-form-urlencoded' encoding scheme, \n+ * also misleadingly known as URL encoding.</p>\n+ *  \n+ * <p>For more detailed information please refer to \n+ * <a href=\"http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1\">\n+ * Chapter 17.13.4 'Form content types'</a> of the \n+ * <a href=\"http://www.w3.org/TR/html4/\">HTML 4.01 Specification<a></p>\n+ * \n+ * <p> \n+ * This codec is meant to be a replacement for standard Java classes\n+ * {@link java.net.URLEncoder} and {@link java.net.URLDecoder} \n+ * on older Java platforms, as these classes in Java versions below \n+ * 1.4 rely on the platform's default charset encoding.\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.2\n+ * @version $Id$\n+ */\n+public class URLCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {\n+    \n+    /**\n+     * Radix used in encoding and decoding.\n+     */\n+    static final int RADIX = 16;\n+    \n+    /**\n+     * The default charset used for string decoding and encoding.\n+     */\n+    protected final String charset;\n+    \n+    /**\n+     * Release 1.5 made this field final.\n+     */\n+    protected static final byte ESCAPE_CHAR = '%';\n+    /**\n+     * BitSet of www-form-url safe characters.\n+     */\n+    protected static final BitSet WWW_FORM_URL = new BitSet(256);\n+    \n+    // Static initializer for www_form_url\n+    static {\n+        // alpha characters\n+        for (int i = 'a'; i <= 'z'; i++) {\n+            WWW_FORM_URL.set(i);\n+        }\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            WWW_FORM_URL.set(i);\n+        }\n+        // numeric characters\n+        for (int i = '0'; i <= '9'; i++) {\n+            WWW_FORM_URL.set(i);\n+        }\n+        // special chars\n+        WWW_FORM_URL.set('-');\n+        WWW_FORM_URL.set('_');\n+        WWW_FORM_URL.set('.');\n+        WWW_FORM_URL.set('*');\n+        // blank to be replaced with +\n+        WWW_FORM_URL.set(' ');\n+    }\n+\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public URLCodec() {\n+        this(CharEncoding.UTF_8);\n+    }\n+\n+    /**\n+     * Constructor which allows for the selection of a default charset\n+     * \n+     * @param charset the default string charset to use.\n+     */\n+    public URLCodec(String charset) {\n+        super();\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\n+     * \n+     * @param urlsafe\n+     *            bitset of characters deemed URL safe\n+     * @param bytes\n+     *            array of bytes to convert to URL safe characters\n+     * @return array of bytes containing URL safe characters\n+     */\n+    public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {\n+        if (bytes == null) {\n+            return null;\n+        }\n+        if (urlsafe == null) {\n+            urlsafe = WWW_FORM_URL;\n+        }\n+\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        for (byte c : bytes) {\n+            int b = c;\n+            if (b < 0) {\n+                b = 256 + b;\n+            }\n+            if (urlsafe.get(b)) {\n+                if (b == ' ') {\n+                    b = '+';\n+                }\n+                buffer.write(b);\n+            } else {\n+                buffer.write(ESCAPE_CHAR);\n+                char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n+                char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n+                buffer.write(hex1);\n+                buffer.write(hex2);\n+            }\n+        }\n+        return buffer.toByteArray();\n+    }\n+\n+    /**\n+     * Decodes an array of URL safe 7-bit characters into an array of \n+     * original bytes. Escaped characters are converted back to their \n+     * original representation.\n+     *\n+     * @param bytes array of URL safe characters\n+     * @return array of original bytes \n+     * @throws DecoderException Thrown if URL decoding is unsuccessful\n+     */\n+    public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {\n+        if (bytes == null) {\n+            return null;\n+        }\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        for (int i = 0; i < bytes.length; i++) {\n+            int b = bytes[i];\n+            if (b == '+') {\n+                buffer.write(' ');\n+            } else if (b == ESCAPE_CHAR) {\n+                try {\n+                    int u = Utils.digit16(bytes[++i]);\n+                    int l = Utils.digit16(bytes[++i]);\n+                    buffer.write((char) ((u << 4) + l));\n+                } catch (ArrayIndexOutOfBoundsException e) {\n+                    throw new DecoderException(\"Invalid URL encoding: \", e);\n+                }\n+            } else {\n+                buffer.write(b);\n+            }\n+        }\n+        return buffer.toByteArray();\n+    }\n+\n+    /**\n+     * Encodes an array of bytes into an array of URL safe 7-bit \n+     * characters. Unsafe characters are escaped.\n+     *\n+     * @param bytes array of bytes to convert to URL safe characters\n+     * @return array of bytes containing URL safe characters\n+     */\n+    public byte[] encode(byte[] bytes) {\n+        return encodeUrl(WWW_FORM_URL, bytes);\n+    }\n+\n+\n+    /**\n+     * Decodes an array of URL safe 7-bit characters into an array of \n+     * original bytes. Escaped characters are converted back to their \n+     * original representation.\n+     *\n+     * @param bytes array of URL safe characters\n+     * @return array of original bytes \n+     * @throws DecoderException Thrown if URL decoding is unsuccessful\n+     */\n+    public byte[] decode(byte[] bytes) throws DecoderException {\n+        return decodeUrl(bytes);\n+    }\n+\n+    /**\n+     * Encodes a string into its URL safe form using the specified string charset. Unsafe characters are escaped.\n+     * \n+     * @param pString\n+     *            string to convert to a URL safe form\n+     * @param charset\n+     *            the charset for pString\n+     * @return URL safe string\n+     * @throws UnsupportedEncodingException\n+     *             Thrown if charset is not supported\n+     */\n+    public String encode(String pString, String charset) throws UnsupportedEncodingException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n+    }\n+\n+    /**\n+     * Encodes a string into its URL safe form using the default string \n+     * charset. Unsafe characters are escaped.\n+     *\n+     * @param pString string to convert to a URL safe form\n+     * @return URL safe string\n+     * @throws EncoderException Thrown if URL encoding is unsuccessful\n+     * \n+     * @see #getDefaultCharset()\n+     */\n+    public String encode(String pString) throws EncoderException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        try {\n+            return encode(pString, getDefaultCharset());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new EncoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+\n+    /**\n+     * Decodes a URL safe string into its original form using the \n+     * specified encoding. Escaped characters are converted back \n+     * to their original representation.\n+     *\n+     * @param pString URL safe string to convert into its original form\n+     * @param charset the original string charset\n+     * @return original string \n+     * @throws DecoderException Thrown if URL decoding is unsuccessful\n+     * @throws UnsupportedEncodingException Thrown if charset is not\n+     *                                      supported \n+     */\n+    public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n+    }\n+\n+    /**\n+     * Decodes a URL safe string into its original form using the default\n+     * string charset. Escaped characters are converted back to their \n+     * original representation.\n+     *\n+     * @param pString URL safe string to convert into its original form\n+     * @return original string \n+     * @throws DecoderException Thrown if URL decoding is unsuccessful\n+     * \n+     * @see #getDefaultCharset()\n+     */\n+    public String decode(String pString) throws DecoderException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        try {\n+            return decode(pString, getDefaultCharset());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new DecoderException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Encodes an object into its URL safe form. Unsafe characters are \n+     * escaped.\n+     *\n+     * @param pObject string to convert to a URL safe form\n+     * @return URL safe object\n+     * @throws EncoderException Thrown if URL encoding is not \n+     *                          applicable to objects of this type or\n+     *                          if encoding is unsuccessful\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (pObject == null) {\n+            return null;\n+        } else if (pObject instanceof byte[]) {\n+            return encode((byte[])pObject);\n+        } else if (pObject instanceof String) {\n+            return encode((String)pObject);\n+        } else {\n+            throw new EncoderException(\"Objects of type \" +\n+                pObject.getClass().getName() + \" cannot be URL encoded\"); \n+              \n+        }\n+    }\n+\n+    /**\n+     * Decodes a URL safe object into its original form. Escaped characters are converted back to their original\n+     * representation.\n+     * \n+     * @param pObject\n+     *                  URL safe object to convert into its original form\n+     * @return original object\n+     * @throws DecoderException\n+     *                  Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure condition is\n+     *                  encountered during the decode process.\n+     */\n+    public Object decode(Object pObject) throws DecoderException {\n+        if (pObject == null) {\n+            return null;\n+        } else if (pObject instanceof byte[]) {\n+            return decode((byte[]) pObject);\n+        } else if (pObject instanceof String) {\n+            return decode((String) pObject);\n+        } else {\n+            throw new DecoderException(\"Objects of type \" + pObject.getClass().getName() + \" cannot be URL decoded\");\n+\n+        }\n+    }\n+\n+    /**\n+     * The default charset used for string decoding and encoding.\n+     *\n+     * @return the default string charset.\n+     */\n+    public String getDefaultCharset() {\n+        return this.charset;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/net/Utils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.net;\n+\n+import org.apache.commons.codec.DecoderException;\n+\n+/**\n+ * Utility methods for this package.\n+ * \n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ * @since 1.4\n+ */\n+class Utils {\n+\n+    /**\n+     * Returns the numeric value of the character <code>b</code> in radix 16.\n+     * \n+     * @param b\n+     *            The byte to be converted.\n+     * @return The numeric value represented by the character in radix 16.\n+     * \n+     * @throws DecoderException\n+     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}\n+     */\n+    static int digit16(byte b) throws DecoderException {\n+        int i = Character.digit((char) b, 16);\n+        if (i == -1) {\n+            throw new DecoderException(\"Invalid URL encoding: not a valid digit (radix \" + URLCodec.RADIX + \"): \" + b);\n+        }\n+        return i;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/BinaryEncoderAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+import org.junit.Test;\n+\n+/**\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public abstract class BinaryEncoderAbstractTest {\n+\n+    protected abstract BinaryEncoder makeEncoder();\n+\n+    @Test\n+    public void testEncodeEmpty() throws Exception {\n+        BinaryEncoder encoder = makeEncoder();\n+        encoder.encode(new byte[0]);\n+    }\n+\n+    @Test\n+    public void testEncodeNull() throws Exception {\n+        BinaryEncoder encoder = makeEncoder();\n+        try {\n+            encoder.encode(null);\n+        } catch (EncoderException ee) {\n+            // An exception should be thrown\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/CharEncodingTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+import junit.framework.Assert;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Sanity checks for {@link CharEncoding}.\n+ * \n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class CharEncodingTest {\n+\n+    /**\n+     * We could make the constructor private in the future, it's a matter a style.\n+     */\n+    @Test\n+    public void testConstructor() {\n+        new CharEncoding();\n+    }\n+\n+    @Test\n+    public void testIso8859_1() {\n+        Assert.assertEquals(\"ISO-8859-1\", CharEncoding.ISO_8859_1);\n+    }\n+\n+    @Test\n+    public void testUsAscii() {\n+        Assert.assertEquals(\"US-ASCII\", CharEncoding.US_ASCII);\n+    }\n+\n+    @Test\n+    public void testUtf16() {\n+        Assert.assertEquals(\"UTF-16\", CharEncoding.UTF_16);\n+    }\n+\n+    @Test\n+    public void testUtf16Be() {\n+        Assert.assertEquals(\"UTF-16BE\", CharEncoding.UTF_16BE);\n+    }\n+\n+    @Test\n+    public void testUtf16Le() {\n+        Assert.assertEquals(\"UTF-16LE\", CharEncoding.UTF_16LE);\n+    }\n+\n+    @Test\n+    public void testUtf8() {\n+        Assert.assertEquals(\"UTF-8\", CharEncoding.UTF_8);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/DecoderExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Tests {@link DecoderException}.\n+ * \n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class DecoderExceptionTest {\n+\n+    private static final String MSG = \"TEST\";\n+\n+    private static final Throwable t = new Exception();\n+\n+    @Test\n+    public void testConstructor0() {\n+        DecoderException e = new DecoderException();\n+        assertNull(e.getMessage());\n+        assertNull(e.getCause());\n+    }\n+\n+    @Test\n+    public void testConstructorString() {\n+        DecoderException e = new DecoderException(MSG);\n+        assertEquals(MSG, e.getMessage());\n+        assertNull(e.getCause());\n+    }\n+\n+    @Test\n+    public void testConstructorStringThrowable() {\n+        DecoderException e = new DecoderException(MSG, t);\n+        assertEquals(MSG, e.getMessage());\n+        assertEquals(t, e.getCause());\n+    }\n+\n+    @Test\n+    public void testConstructorThrowable() {\n+        DecoderException e = new DecoderException(t);\n+        assertEquals(t.getClass().getName(), e.getMessage());\n+        assertEquals(t, e.getCause());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/EncoderExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Tests {@link EncoderException}.\n+ * \n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class EncoderExceptionTest {\n+\n+    private static final String MSG = \"TEST\";\n+\n+    private static final Throwable t = new Exception();\n+\n+    @Test\n+    public void testConstructor0() {\n+        EncoderException e = new EncoderException();\n+        assertNull(e.getMessage());\n+        assertNull(e.getCause());\n+    }\n+\n+    @Test\n+    public void testConstructorString() {\n+        EncoderException e = new EncoderException(MSG);\n+        assertEquals(MSG, e.getMessage());\n+        assertNull(e.getCause());\n+    }\n+\n+    @Test\n+    public void testConstructorStringThrowable() {\n+        EncoderException e = new EncoderException(MSG, t);\n+        assertEquals(MSG, e.getMessage());\n+        assertEquals(t, e.getCause());\n+    }\n+\n+    @Test\n+    public void testConstructorThrowable() {\n+        EncoderException e = new EncoderException(t);\n+        assertEquals(t.getClass().getName(), e.getMessage());\n+        assertEquals(t, e.getCause());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/StringEncoderAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+import java.util.Locale;\n+\n+import junit.framework.Assert;\n+\n+import org.junit.Test;\n+\n+/**\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public abstract class StringEncoderAbstractTest {\n+\n+    protected StringEncoder stringEncoder = this.createStringEncoder();\n+\n+    public void checkEncoding(String expected, String source) throws EncoderException {\n+        Assert.assertEquals(\"Source: \" + source, expected, this.getStringEncoder().encode(source));\n+    }\n+\n+    protected void checkEncodings(String[][] data) throws EncoderException {\n+        for (String[] element : data) {\n+            this.checkEncoding(element[1], element[0]);\n+        }\n+    }\n+\n+    protected void checkEncodingVariations(String expected, String data[]) throws EncoderException {\n+        for (String element : data) {\n+            this.checkEncoding(expected, element);\n+        }\n+    }\n+\n+    protected abstract StringEncoder createStringEncoder();\n+\n+    public StringEncoder getStringEncoder() {\n+        return this.stringEncoder;\n+    }\n+\n+    @Test\n+    public void testEncodeEmpty() throws Exception {\n+        Encoder encoder = this.getStringEncoder();\n+        encoder.encode(\"\");\n+        encoder.encode(\" \");\n+        encoder.encode(\"\\t\");\n+    }\n+\n+    @Test\n+    public void testEncodeNull() throws Exception {\n+        StringEncoder encoder = this.getStringEncoder();\n+        try {\n+            encoder.encode(null);\n+        } catch (EncoderException ee) {\n+            // An exception should be thrown\n+        }\n+    }\n+\n+    @Test\n+    public void testEncodeWithInvalidObject() throws Exception {\n+        boolean exceptionThrown = false;\n+        try {\n+            StringEncoder encoder = this.getStringEncoder();\n+            encoder.encode(new Float(3.4));\n+        } catch (Exception e) {\n+            exceptionThrown = true;\n+        }\n+        Assert.assertTrue(\"An exception was not thrown when we tried to encode \" + \"a Float object\", exceptionThrown);\n+    }\n+\n+    @Test\n+    public void testLocaleIndependence() throws Exception {\n+        StringEncoder encoder = this.getStringEncoder();\n+\n+        String[] data = {\"I\", \"i\",};\n+\n+        Locale orig = Locale.getDefault();\n+        Locale[] locales = {Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault()};\n+\n+        try {\n+            for (String element : data) {\n+                String ref = null;\n+                for (int j = 0; j < locales.length; j++) {\n+                    Locale.setDefault(locales[j]);\n+                    if (j <= 0) {\n+                        ref = encoder.encode(element);\n+                    } else {\n+                        String cur = null;\n+                        try {\n+                            cur = encoder.encode(element);\n+                        } catch (Exception e) {\n+                            Assert.fail(Locale.getDefault().toString() + \": \" + e.getMessage());\n+                        }\n+                        Assert.assertEquals(Locale.getDefault().toString() + \": \", ref, cur);\n+                    }\n+                }\n+            }\n+        } finally {\n+            Locale.setDefault(orig);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/StringEncoderComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.commons.codec.language.DoubleMetaphone;\n+import org.apache.commons.codec.language.Soundex;\n+import org.junit.Test;\n+\n+/**\n+ * Test cases for the StingEncoderComparator.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class StringEncoderComparatorTest {\n+\n+    @Test\n+    public void testComparatorWithSoundex() throws Exception {\n+        StringEncoderComparator sCompare = \n+            new StringEncoderComparator( new Soundex() );\n+\n+        assertTrue( \"O'Brien and O'Brian didn't come out with \" +\n+                    \"the same Soundex, something must be wrong here\",\n+                    0 == sCompare.compare( \"O'Brien\", \"O'Brian\" ) );\n+    }\n+    \n+    @Test\n+    public void testComparatorWithDoubleMetaphone() throws Exception {\n+        StringEncoderComparator sCompare = new StringEncoderComparator(new DoubleMetaphone());\n+\n+        String[] testArray = { \"Jordan\", \"Sosa\", \"Prior\", \"Pryor\" };\n+        List<String> testList = Arrays.asList(testArray);\n+\n+        String[] controlArray = { \"Jordan\", \"Prior\", \"Pryor\", \"Sosa\" };\n+\n+        Collections.sort(testList, sCompare);\n+\n+        String[] resultArray = testList.toArray(new String[0]);\n+\n+        for (int i = 0; i < resultArray.length; i++) {\n+            assertEquals(\"Result Array not Equal to Control Array at index: \" + i, controlArray[i], resultArray[i]);\n+        }\n+    }\n+\n+    @Test\n+    public void testComparatorWithDoubleMetaphoneAndInvalidInput() throws Exception {\n+        StringEncoderComparator sCompare =\n+            new StringEncoderComparator( new DoubleMetaphone() );\n+           \n+        int compare = sCompare.compare(new Double(3.0), Long.valueOf(3));\n+        assertEquals( \"Trying to compare objects that make no sense to the underlying encoder should return a zero compare code\",\n+                                0, compare);        \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+\n+public class Base32InputStreamTest {\n+\n+    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+\n+    private final static byte[] LF = {(byte) '\\n'};\n+\n+    /**\n+     * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.\n+     */\n+    @Test\n+    public void testCodec105() throws IOException {\n+        Base32InputStream in = new Base32InputStream(new Codec105ErrorInputStream(), true, 0, null);\n+        try {\n+            for (int i = 0; i < 5; i++) {\n+                in.read();\n+            }\n+        } finally {\n+            in.close();\n+        }\n+    }\n+\n+//    /**\n+//     * Test for the CODEC-101 bug:  InputStream.read(byte[]) should never return 0\n+//     * because Java's builtin InputStreamReader hates that.\n+//     *\n+//     * @throws Exception for some failure scenarios.\n+//     */\n+//    @Test\n+//    public void testCodec101() throws Exception {\n+//        byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);\n+//        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n+//        Base32InputStream in = new Base32InputStream(bais);\n+//        byte[] result = new byte[8192];\n+//        int c = in.read(result);\n+//        assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n+//\n+//        c = in.read(result);\n+//        assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n+//    }\n+\n+    /**\n+     * Another test for the CODEC-101 bug:\n+     * In commons-codec-1.4 this test shows InputStreamReader explicitly hating an\n+     * InputStream.read(byte[]) return of 0:\n+     *\n+     * java.io.IOException: Underlying input stream returned zero bytes\n+     * at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268)\n+     * at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)\n+     * at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)\n+     * at java.io.InputStreamReader.read(InputStreamReader.java:167)\n+     * at java.io.BufferedReader.fill(BufferedReader.java:136)\n+     * at java.io.BufferedReader.readLine(BufferedReader.java:299)\n+     * at java.io.BufferedReader.readLine(BufferedReader.java:362)\n+     * at org.apache.commons.codec.binary.Base32InputStreamTest.testInputStreamReader(Base32InputStreamTest.java:75)\n+     *\n+     * But in commons-codec-1.5 it's fixed.  :-)\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+//    @Test\n+//    public void testInputStreamReader() throws Exception {\n+//        byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);\n+//        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n+//        Base32InputStream in = new Base32InputStream(bais);\n+//        InputStreamReader isr = new InputStreamReader(in);\n+//        BufferedReader br = new BufferedReader(isr);\n+//        String line = br.readLine();\n+//        assertNotNull(\"Codec101:  InputStreamReader works!\", line);\n+//    }\n+\n+    /**\n+     * Test the Base32InputStream implementation against the special NPE inducing input\n+     * identified in the CODEC-98 bug.\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+//    @Test\n+//    public void testCodec98NPE() throws Exception {\n+//        byte[] codec98 = StringUtils.getBytesUtf8(Base32TestData.CODEC_98_NPE);\n+//        ByteArrayInputStream data = new ByteArrayInputStream(codec98);\n+//        Base32InputStream stream = new Base32InputStream(data);\n+//\n+//        // This line causes an NPE in commons-codec-1.4.jar:\n+//        byte[] decodedBytes = Base32TestData.streamToBytes(stream, new byte[1024]);\n+//\n+//        String decoded = StringUtils.newStringUtf8(decodedBytes);\n+//        assertEquals(\n+//            \"codec-98 NPE Base32InputStream\", Base32TestData.CODEC_98_NPE_DECODED, decoded\n+//        );\n+//    }\n+\n+    /**\n+     * Tests the Base32InputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase32EmptyInputStreamMimeChuckSize() throws Exception {\n+        testBase32EmptyInputStream(BaseNCodec.MIME_CHUNK_SIZE);\n+    }\n+\n+    /**\n+     * Tests the Base32InputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase32EmptyInputStreamPemChuckSize() throws Exception {\n+        testBase32EmptyInputStream(BaseNCodec.PEM_CHUNK_SIZE);\n+    }\n+\n+    private void testBase32EmptyInputStream(int chuckSize) throws Exception {\n+        byte[] emptyEncoded = new byte[0];\n+        byte[] emptyDecoded = new byte[0];\n+        testByteByByte(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n+        testByChunk(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n+    }\n+\n+    /**\n+     * Tests the Base32InputStream implementation.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase32InputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringUtils.getBytesUtf8(\"AA======\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+        testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n+\n+//        // OpenSSL interop test.\n+//        encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE);\n+//        decoded = Base32TestData.DECODED;\n+//        testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF);\n+//\n+//        // Single Line test.\n+//        String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+//        encoded = StringUtils.getBytesUtf8(singleLine);\n+//        decoded = Base32TestData.DECODED;\n+//        testByChunk(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        BaseNCodec codec = new Base32();\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base32TestData.randomData(codec, i);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByChunk(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Tests the Base32InputStream implementation.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase32InputStreamByteByByte() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringUtils.getBytesUtf8(\"AA======\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+        testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n+\n+//        // Single Line test.\n+//        String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+//        encoded = StringUtils.getBytesUtf8(singleLine);\n+//        decoded = Base32TestData.DECODED;\n+//        testByteByByte(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        BaseNCodec codec = new Base32();\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base32TestData.randomData(codec, i);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByteByByte(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     * \n+     * @param encoded\n+     *            base32 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base32 encoded data.\n+     * @param seperator\n+     *            Line separator in the base32 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base32 commons-codec implementation.\n+     */\n+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        InputStream in = new ByteArrayInputStream(decoded);\n+        in = new Base32InputStream(in, true, chunkSize, seperator);\n+        byte[] output = Base32TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        in = new ByteArrayInputStream(encoded);\n+        in = new Base32InputStream(in);\n+        output = Base32TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        in = new ByteArrayInputStream(decoded);\n+        for (int i = 0; i < 10; i++) {\n+            in = new Base32InputStream(in, true, chunkSize, seperator);\n+            in = new Base32InputStream(in, false);\n+        }\n+        output = Base32TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     * \n+     * @param encoded\n+     *            base32 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base32 encoded data.\n+     * @param seperator\n+     *            Line separator in the base32 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base32 commons-codec implementation.\n+     */\n+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        InputStream in = new ByteArrayInputStream(decoded);\n+        in = new Base32InputStream(in, true, chunkSize, seperator);\n+        byte[] output = new byte[encoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        in = new ByteArrayInputStream(encoded);\n+        in = new Base32InputStream(in);\n+        output = new byte[decoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        in = new ByteArrayInputStream(decoded);\n+        for (int i = 0; i < 10; i++) {\n+            in = new Base32InputStream(in, true, chunkSize, seperator);\n+            in = new Base32InputStream(in, false);\n+        }\n+        output = new byte[decoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests markSupported.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMarkSupported() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        // Always returns false for now.\n+        assertFalse(\"Base32InputStream.markSupported() is false\", in.markSupported());\n+    }\n+\n+    /**\n+     * Tests read returning 0\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRead0() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        byte[] buf = new byte[1024];\n+        int bytesRead = 0;\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        bytesRead = in.read(buf, 0, 0);\n+        assertEquals(\"Base32InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n+    }\n+\n+    /**\n+     * Tests read with null.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testReadNull() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        try {\n+            in.read(null, 0, 0);\n+            fail(\"Base32InputStream.read(null, 0, 0) to throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Tests read throwing IndexOutOfBoundsException\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReadOutOfBounds() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        byte[] buf = new byte[1024];\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+\n+        try {\n+            in.read(buf, -1, 0);\n+            fail(\"Expected Base32InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, 0, -1);\n+            fail(\"Expected Base32InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, buf.length + 1, 0);\n+            fail(\"Base32InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, buf.length - 1, 2);\n+            fail(\"Base32InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32OutputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+\n+public class Base32OutputStreamTest {\n+\n+    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+\n+    private final static byte[] LF = {(byte) '\\n'};\n+\n+    \n+\n+//    /**\n+//     * Test the Base32OutputStream implementation against the special NPE inducing input\n+//     * identified in the CODEC-98 bug.\n+//     *\n+//     * @throws Exception for some failure scenarios.\n+//     */\n+//    @Test\n+//    public void testCodec98NPE() throws Exception {\n+//        byte[] codec98 = StringUtils.getBytesUtf8(Base32TestData.CODEC_98_NPE);\n+//        byte[] codec98_1024 = new byte[1024];\n+//        System.arraycopy(codec98, 0, codec98_1024, 0, codec98.length);\n+//        ByteArrayOutputStream data = new ByteArrayOutputStream(1024);\n+//        Base32OutputStream stream = new Base32OutputStream(data, false);\n+//        stream.write(codec98_1024, 0, 1024);\n+//        stream.close();\n+//\n+//        byte[] decodedBytes = data.toByteArray();\n+//        String decoded = StringUtils.newStringUtf8(decodedBytes);\n+//        assertEquals(\n+//            \"codec-98 NPE Base32OutputStream\", Base32TestData.CODEC_98_NPE_DECODED, decoded\n+//        );\n+//    }\n+    \n+\n+    /**\n+     * Test the Base32OutputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase32EmptyOutputStreamMimeChunkSize() throws Exception {\n+        testBase32EmptyOutputStream(BaseNCodec.MIME_CHUNK_SIZE);\n+    }\n+\n+    /**\n+     * Test the Base32OutputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase32EmptyOutputStreamPemChunkSize() throws Exception {\n+        testBase32EmptyOutputStream(BaseNCodec.PEM_CHUNK_SIZE);\n+    }\n+\n+    private void testBase32EmptyOutputStream(int chunkSize) throws Exception {\n+        byte[] emptyEncoded = new byte[0];\n+        byte[] emptyDecoded = new byte[0];\n+        testByteByByte(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n+        testByChunk(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n+    }\n+\n+    /**\n+     * Test the Base32OutputStream implementation\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase32OutputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n+\n+//        // Single Byte test.\n+//        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n+//        decoded = new byte[]{(byte) 0};\n+//        testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF);\n+\n+\n+//        // Single Line test.\n+//        String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+//        encoded = StringUtils.getBytesUtf8(singleLine);\n+//        decoded = Base32TestData.DECODED;\n+//        testByChunk(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        BaseNCodec codec = new Base32();\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base32TestData.randomData(codec, i);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByChunk(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Test the Base32OutputStream implementation\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase32OutputStreamByteByByte() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+//        // Single Byte test.\n+//        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n+//        decoded = new byte[]{(byte) 0};\n+//        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+\n+//        // Single Line test.\n+//        String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+//        encoded = StringUtils.getBytesUtf8(singleLine);\n+//        decoded = Base32TestData.DECODED;\n+//        testByteByByte(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        BaseNCodec codec = new Base32();\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base32TestData.randomData(codec, i);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByteByByte(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32OutputStream wraps itself in encode and decode\n+     * mode over and over again.\n+     * \n+     * @param encoded\n+     *            Base32 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the Base32 encoded data.\n+     * @param seperator\n+     *            Line separator in the Base32 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base32 commons-codec implementation.\n+     */\n+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+        OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator);\n+        out.write(decoded);\n+        out.close();\n+        byte[] output = byteOut.toByteArray();\n+        assertTrue(\"Streaming chunked Base32 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base32OutputStream(byteOut, false);\n+        out.write(encoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming chunked Base32 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        byteOut = new ByteArrayOutputStream();\n+        out = byteOut;\n+        for (int i = 0; i < 10; i++) {\n+            out = new Base32OutputStream(out, false);\n+            out = new Base32OutputStream(out, true, chunkSize, seperator);\n+        }\n+        out.write(decoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+\n+        assertTrue(\"Streaming chunked Base32 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32OutputStream wraps itself in encode and decode\n+     * mode over and over again.\n+     * \n+     * @param encoded\n+     *            Base32 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the Base32 encoded data.\n+     * @param seperator\n+     *            Line separator in the Base32 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base32 commons-codec implementation.\n+     */\n+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+        OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator);\n+        for (byte element : decoded) {\n+            out.write(element);\n+        }\n+        out.close();\n+        byte[] output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte Base32 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base32OutputStream(byteOut, false);\n+        for (byte element : encoded) {\n+            out.write(element);\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte Base32 decode\", Arrays.equals(output, decoded));\n+\n+        // Now let's try decode with tonnes of flushes.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base32OutputStream(byteOut, false);\n+        for (byte element : encoded) {\n+            out.write(element);\n+            out.flush();\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte flush() Base32 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        byteOut = new ByteArrayOutputStream();\n+        out = byteOut;\n+        for (int i = 0; i < 10; i++) {\n+            out = new Base32OutputStream(out, false);\n+            out = new Base32OutputStream(out, true, chunkSize, seperator);\n+        }\n+        for (byte element : decoded) {\n+            out.write(element);\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+\n+        assertTrue(\"Streaming byte-by-byte Base32 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests Base32OutputStream.write for expected IndexOutOfBoundsException conditions.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testWriteOutOfBounds() throws Exception {\n+        byte[] buf = new byte[1024];\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        Base32OutputStream out = new Base32OutputStream(bout);\n+\n+        try {\n+            out.write(buf, -1, 1);\n+            fail(\"Expected Base32OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, 1, -1);\n+            fail(\"Expected Base32OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, buf.length + 1, 0);\n+            fail(\"Expected Base32OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, buf.length - 1, 2);\n+            fail(\"Expected Base32OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Tests Base32OutputStream.write(null).\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testWriteToNullCoverage() throws Exception {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        Base32OutputStream out = new Base32OutputStream(bout);\n+        try {\n+            out.write(null, 0, 0);\n+            fail(\"Expcted Base32OutputStream.write(null) to throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // Expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+\n+public class Base32Test {\n+    \n+    private static final String [][] BASE32_TEST_CASES = { // RFC 4648\n+        {\"\"       ,\"\"},\n+        {\"f\"      ,\"MY======\"},\n+        {\"fo\"     ,\"MZXQ====\"},\n+        {\"foo\"    ,\"MZXW6===\"},\n+        {\"foob\"   ,\"MZXW6YQ=\"},\n+        {\"fooba\"  ,\"MZXW6YTB\"},\n+        {\"foobar\" ,\"MZXW6YTBOI======\"},\n+    };\n+\n+    private static final String [][] BASE32HEX_TEST_CASES = { // RFC 4648\n+        {\"\"       ,\"\"},\n+        {\"f\"      ,\"CO======\"},\n+        {\"fo\"     ,\"CPNG====\"},\n+        {\"foo\"    ,\"CPNMU===\"},\n+        {\"foob\"   ,\"CPNMUOG=\"},\n+        {\"fooba\"  ,\"CPNMUOJ1\"},\n+        {\"foobar\" ,\"CPNMUOJ1E8======\"},\n+    };\n+\n+\n+    private static final String [][] BASE32_TEST_CASES_CHUNKED = { //Chunked\n+        {\"\"       ,\"\"},\n+        {\"f\"      ,\"MY======\\r\\n\"},\n+        {\"fo\"     ,\"MZXQ====\\r\\n\"},\n+        {\"foo\"    ,\"MZXW6===\\r\\n\"},\n+        {\"foob\"   ,\"MZXW6YQ=\\r\\n\"},\n+        {\"fooba\"  ,\"MZXW6YTB\\r\\n\"},\n+        {\"foobar\" ,\"MZXW6YTBOI======\\r\\n\"},\n+    };\n+\n+    @Test\n+    public void testBase32Samples() throws Exception {\n+        Base32 codec = new Base32();\n+        for (String[] element : BASE32_TEST_CASES) {\n+                assertEquals(element[1], codec.encodeAsString(element[0].getBytes(\"UTF-8\")));\n+        }\n+    }\n+\n+    @Test\n+    public void testBase32HexSamples() throws Exception {\n+        Base32 codec = new Base32(true);\n+        for (String[] element : BASE32HEX_TEST_CASES) {\n+                assertEquals(element[1], codec.encodeAsString(element[0].getBytes(\"UTF-8\")));\n+        }\n+    }\n+\n+    @Test\n+    public void testBase32Chunked () throws Exception {\n+        Base32 codec = new Base32(20);\n+        for (String[] element : BASE32_TEST_CASES_CHUNKED) {\n+                assertEquals(element[1], codec.encodeAsString(element[0].getBytes(\"UTF-8\")));\n+        }        \n+    }\n+\n+    @Test\n+    public void testSingleCharEncoding() {\n+        for (int i = 0; i < 20; i++) {\n+            Base32 codec = new Base32();\n+            byte unencoded[] = new byte[i];\n+            byte allInOne[] = codec.encode(unencoded);\n+            codec = new Base32();\n+            for (int j=0; j< unencoded.length; j++) {\n+                codec.encode(unencoded, j, 1);\n+            }\n+            codec.encode(unencoded, 0, -1);\n+            byte singly[] = new byte[allInOne.length];\n+            codec.readResults(singly, 0, 100);\n+            if (!Arrays.equals(allInOne, singly)){\n+                fail();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testRandomBytes() {\n+        for (int i = 0; i < 20; i++) {\n+            Base32 codec = new Base32();\n+            byte[][] b = Base32TestData.randomData(codec, i);\n+            assertEquals(\"\"+i+\" \"+codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));\n+            //assertEquals(b[0],codec.decode(b[1]));\n+        }\n+    }\n+\n+    @Test\n+    public void testRandomBytesChunked() {\n+        for (int i = 0; i < 20; i++) {\n+            Base32 codec = new Base32(10);\n+            byte[][] b = Base32TestData.randomData(codec, i);\n+            assertEquals(\"\"+i+\" \"+codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));\n+            //assertEquals(b[0],codec.decode(b[1]));\n+        }\n+    }\n+    \n+    @Test\n+    public void testRandomBytesHex() {\n+        for (int i = 0; i < 20; i++) {\n+            Base32 codec = new Base32(true);\n+            byte[][] b = Base32TestData.randomData(codec, i);\n+            assertEquals(\"\"+i+\" \"+codec.lineLength,b[1].length,codec.getEncodedLength(b[0]));\n+            //assertEquals(b[0],codec.decode(b[1]));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32TestData.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Random;\n+\n+/**\n+ * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n+ * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n+ * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @since 1.4\n+ */\n+public class Base32TestData {\n+\n+    static final String STRING_FIXTURE = \"Hello World\";\n+\n+    static final String BASE32_FIXTURE = \"JBSWY3DPEBLW64TMMQ======\\r\\n\";\n+//  static final String BASE32HEX_FIXTURE = \"91IMOR3F41BMUSJCCG======\";\n+\n+    // Some utility code to help test chunked reads of the InputStream.\n+\n+    private final static int SIZE_KEY = 0;\n+    private final static int LAST_READ_KEY = 1;\n+\n+    static byte[] streamToBytes(final InputStream in) throws IOException {\n+        // new byte[7] is obviously quite slow, but helps exercise the code.\n+        return streamToBytes(in, new byte[7]);\n+    }\n+\n+    static byte[] streamToBytes(final InputStream in, byte[] buf) throws IOException {\n+        try {\n+            int[] status = fill(buf, 0, in);\n+            int size = status[SIZE_KEY];\n+            int lastRead = status[LAST_READ_KEY];\n+            while (lastRead != -1) {\n+                buf = resizeArray(buf);\n+                status = fill(buf, size, in);\n+                size = status[SIZE_KEY];\n+                lastRead = status[LAST_READ_KEY];\n+            }\n+            if (buf.length != size) {\n+                byte[] smallerBuf = new byte[size];\n+                System.arraycopy(buf, 0, smallerBuf, 0, size);\n+                buf = smallerBuf;\n+            }\n+        }\n+        finally {\n+            in.close();\n+        }\n+        return buf;\n+    }\n+\n+    private static int[] fill(final byte[] buf, final int offset, final InputStream in)\n+            throws IOException {\n+        int read = in.read(buf, offset, buf.length - offset);\n+        int lastRead = read;\n+        if (read == -1) {\n+            read = 0;\n+        }\n+        while (lastRead != -1 && read + offset < buf.length) {\n+            lastRead = in.read(buf, offset + read, buf.length - read - offset);\n+            if (lastRead != -1) {\n+                read += lastRead;\n+            }\n+        }\n+        return new int[]{offset + read, lastRead};\n+    }\n+\n+    private static byte[] resizeArray(final byte[] bytes) {\n+        byte[] biggerBytes = new byte[bytes.length * 2];\n+        System.arraycopy(bytes, 0, biggerBytes, 0, bytes.length);\n+        return biggerBytes;\n+    }\n+\n+\n+    /**\n+     * Returns an encoded and decoded copy of the same random data.\n+     * \n+     * @param codec the codec to use\n+     * @param size amount of random data to generate and encode\n+     * @return two byte[] arrays:  [0] = decoded, [1] = encoded \n+     */\n+    static byte[][] randomData(BaseNCodec codec, int size) {\n+        Random r = new Random();\n+        byte[] decoded = new byte[size];\n+        r.nextBytes(decoded);\n+        byte[] encoded = codec.encode(decoded);\n+        return new byte[][] {decoded, encoded};\n+    }\n+\n+    /**\n+     * Tests the supplied byte[] array to see if it contains the specified byte c.\n+     *\n+     * @param bytes byte[] array to test\n+     * @param c byte to look for\n+     * @return true if bytes contains c, false otherwise\n+     */\n+    static boolean bytesContain(byte[] bytes, byte c) {\n+        for (byte b : bytes) {\n+            if (b == c) { return true; }\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64Codec13Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+\n+import org.apache.commons.codec.BinaryDecoder;\n+import org.apache.commons.codec.BinaryEncoder;\n+import org.apache.commons.codec.Decoder;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.Encoder;\n+import org.apache.commons.codec.EncoderException;\n+import org.junit.Test;\n+\n+/**\n+ * Tests to make sure future versions of commons-codec.jar have identical Base64\n+ * behavior as commons-codec-1.3.jar.\n+ *\n+ * @author Julius Davies\n+ * @since Mar 25, 2010\n+ */\n+public class Base64Codec13Test {\n+\n+    private final static String[] STRINGS = new String[181];\n+    private final static String[] CHUNKED_STRINGS = new String[STRINGS.length];\n+    private final static byte[][] BYTES = new byte[STRINGS.length][];\n+\n+    static {\n+        initSTRINGS();\n+        initCHUNKED_STRINGS();\n+        initBYTES();\n+    }\n+\n+    /* These strings were generated from random byte[] arrays fed into commons-codec-1.3.jar */\n+    private static void initSTRINGS() {\n+        String[] s = STRINGS;\n+        s[0] = \"\";\n+        s[1] = \"uA==\";\n+        s[2] = \"z9w=\";\n+        s[3] = \"TQ+Z\";\n+        s[4] = \"bhjUYA==\";\n+        s[5] = \"1cO9td8=\";\n+        s[6] = \"sMxHoJf5\";\n+        s[7] = \"jQcPlDsZzw==\";\n+        s[8] = \"TAaPnfW/CYU=\";\n+        s[9] = \"cXTZuwzXPONS\";\n+        s[10] = \"Ltn/ZTV4IjT6OA==\";\n+        s[11] = \"6fh+jdU31SOmWrc=\";\n+        s[12] = \"E/5MoD4qCvDuTcFA\";\n+        s[13] = \"2n9YyfCMyMXembtssQ==\";\n+        s[14] = \"qBka3Bq6V31HmcmHjkY=\";\n+        s[15] = \"WvyZe6kQ8py7m25ucawJ\";\n+        s[16] = \"oYpxMy6BSpZXhVpOR6dXmA==\";\n+        s[63] = \"yexFaNKaP+VkVwEUvxQXbC0HSCi/srOY7c036lT25frs4xjIvp214JHCg7OL/XZW3IMe6CDgSMCaaI91eRgM\";\n+        s[64] = \"vkqgnuJ3plxNtoveiMJuYLN6wZQLpb3Fg48/zHkdFuDucuMKWVRO/niFRgKsFqcxq6VgCxwQbePiP9sRnxz7wg==\";\n+        s[65] = \"YHks3GCb2uVF47Y2tCieiDGJ879Rm5dBhQhQizYhfWOo+BrB2/K+E7wZWTid14lMpM60+5C0N9JNKAcBESeqZZI=\";\n+        s[66] = \"z8551jmQp/Qs95tw226+HCHWruKx/JvfBCfQ5p0fF77mkSpp66E552ik2gycrBBsMC/NbznAgTZoMzZxehfJwu49\";\n+        s[67] = \"VsR2whqq/qQm342+TNz1lgOZMoWbpCz+kj2zflq0nx7S/ReEVPUJcqgMtVzrr2FVQPfBAH5VRjR+hkxwv4bssQms8Q==\";\n+        s[68] = \"5xmIp8dUJZzkisIkuEPsnPXvzDeMo48qWFfHIn2av3jr5qoZHCs0LfNEyepC3v2sa0nCU0FlqsmDyTI5/2jt5zsLtV0=\";\n+        s[69] = \"tGEgXjglUB9NbCtiS88AetLtRqhCAnhzOUKVgvbJZHqOA6x8uOorA1t3NcaIA00ZqbPYALu4LzIm4i4lAL9QgiH/Jg7b\";\n+        s[70] = \"gFtxEhYJahDmU5dpudYs6ZTsqAx+s2j+06A0zeyb3U7nhZFsbkCDlds0EYUoqerZqZPm7F6CDOOD3dU7nYmelE0DxyMO9A==\";\n+        s[71] = \"j/h/1JygYA5bjttxzQxr5gBtgh+AYVozhF4WgvcU/g49v0hUy6FdhfZewGK+Phtzj7RabI5p2zXyzvkmLQdFhdI5Um4O5sw=\";\n+        s[72] = \"m+kYVGojIR5pgbz7pGJm2g+3qqk7fhl3cowa2eVrhki7WofyywnRezqTxOkBgVFz6nKs8qxpbbbzALctcPeMsp9dpXUfuUJr\";\n+        s[73] = \"pPaGnMr0UYmldnJVk/F+3WCJJ1r2otvD5KJdt2u1RnS6LwhHhwLCqfW8O/QEg43WdxKomGL/JM33tn/B9pMPoIU0QTGjq2GRow==\";\n+        s[74] = \"mOxzGyym6T/BxCV5nSiIYMlfAUmCN7gt7+ZTMg1kd8Ptirk+JF5dk8USbWBu/9ZvNg5ZuiJCeGwfaVpqpZ3K9ySF7C87Jvu1RUE=\";\n+        s[75] = \"VYLOIE4DnhxJn3FKS/2RHHHYLlZiGVdV/k4uBbtAYHUSTpRzaaYPGNAVjdNwbTHIihmeuk/5YQUy8NFsxIom+Li7bnWiBoHKBPP7\";\n+        s[76] = \"7foMpJ0TknCatjUiSxtnuKSiz4Qvl/idWY9UKiTljoQHZ+C8bcUscnI/bZr13e6AvyUh47MlpdGvzIm05qUdMWWLoZJOaGYvDmvrWQ==\";\n+        s[77] = \"jxQSGiFs+b1TfE4lDUAPUPJ0SWeUgl03rK6auieWJcarDIHM97gGOHMmyHudRMqkZmIkxYRgYgCCUg/JeU91OZD3tL4U+wNhShywe88=\";\n+        s[78] = \"UGmH/gl7t3Dk801vRhRDEbgsfShtHZ1gZQn4KNZ5Qsw3WiGjW0ImInVHa+LSHBzLUjwC0Z3nXO4i4+CiKYqAspOViE6WqVUY8ZSV0Og4\";\n+        s[79] = \"wdEoYmJuRng2z2IkAiSgJ1CW2VE7H7oXpYWEFFO8nG0bZn7PHhT8KyhaO2ridl8eUEysja0VXFDyQqSgZnvdUKrCGepWGZbw0/0bDws3Ag==\";\n+        s[80] = \"5kZqgrUbt+rN5BWAddeUtm9TGT43vYpB6PeyQwTyy9Vbr0+U/4Qzy0Iw37Ra293HmkmpgQzuScVpcIiFGXPAFWwToR+bovwu7aXji/FnMwk=\";\n+        s[81] = \"E467MMmJbmwv8Omc2TdcyMr/30B8izWbf+CAuJtw67b1g9trhC6n4GYnXjeW9DYvmWoIJPx0zvU/Q+gqv0cteg2bx9P2mrgMDARb6egowqjx\";\n+        s[82] = \"Vpt8hYb4jx1F+7REX7K65v6eO5F1GDg/K8SVLWDSp0srupYEQkBVRxnB9dmhSo9XHpz4C8pRl8r82fxXZummEf4U2Oh0Dip5rnNtDL+IJvL8lQ==\";\n+        s[121] = \"hf69xr9mtFf4N3j2uA9MgLL5Zy94Hjv+VQi94+LS8972JJgDHCQOwP5whdQkV+SJpXkiyHGaSsQ4fhepPwzuZcEpYER+beny1j+M0HSZe36MdRIhlTqno+4qsXckL0CjXsYkJJM0NAfOYjHAus5G1bgi9VhmiMfAMA==\";\n+        s[122] = \"yKzTh5hPp9/PBeZtrZXsFHAR9ywOM3hRaBDkgG9E09wFW8MZD0xMGegcp0QrTJcP8QYOaYhTDVimPqsNTVOmjdjkvS+2WhjJW4mVOXQ8KID91yaBtPo+DStL5GMgctcP5MoVf1Vp8w/mYtofqbllfDm5NfYzh2A7ijY=\";\n+        s[123] = \"csFmwvDzoO4IO6ySDA4B2V7emEetAwCgO66zzlfWb3KDrPfFZc3Jgr4+dlaUkEIDHYeLHETdTssWOl2KrPHBEsULpDTR+3OhurXb1Qr2NvHiHFuqT3Geb6EYw2albfTmXxch82ablt4WKl4qPcSey54v6tsCuUuZzrkt\";\n+        s[124] = \"5InxvKwpoCV7EK78OzU/tL9/NmK14Prw9tOCAyK+xpUNLZriuVEVdgpoZ05rliufaUDGHH8dPAem8G9DN/VOPktB6vXKtc2kMUgnMTiZwv/UVd+xyqnT8PLEdNQ8rCWxyiCcLdXFf0+xcE7qCcwzC+D7+cRW+i6dnpZkyw==\";\n+        s[125] = \"cEx7oTsSHWUFPj92cstdy5wGbRcxH+VRWN8kaNTTCPWqSckyU9Xk/jj5/gj9DFwjfsCSp60xutf4/rFanjtwqtRg6dJLP4JAgpOKswDlHi6Vt7zF/w7HidMf2sdtlsqzayZmT2Hn7iOo3CExzr5Z5JfmMFAX8R9peUN4t5U=\";\n+        s[126] = \"AeXetVbj+7mmGiCs3BGUSZDLlq2odMsN8JAHQM64Cly8y5jw75PpISocWRFFQmmXYP7ckKmtuhIvD69HtZxGhNRsl1l1gXzKFhsWykcRtG87F8sS1Uv/i6QvGiRIDVEGGIzWrzRIISkBb9wCxJ2HESfleWwrz/GqryjoN26B\";\n+        s[127] = \"aj1/8/+U8VO3D2iAwvQXZ4H0KwtuzDm4JCC8+22ccqk+UzKvqjGs87XngwfsMfSkeGVAi6VB6tfNJTjYctaj7R8dwh2PIfLSrvaphw4wNB2REjplnPojoOb9bNUNtUvdK3b1bArOWugIRJWLnMl72yEHFb1iBfBmn7uIa7KT2Q==\";\n+        s[128] = \"kiMuF/1CMRlgoS/uLKn1mNZFZNHJNkRQnivOrzj8HQAagwzvTXvsGgI9hXX3qaeZL9/x/Oq+Y5F6Dh+wXo+0kp6JagFjvbTJcQSowFzIwg7/V9sans0NE0Ejow5BfZKvihFI46sHiALl1qzoXqLQq+5fZGIFRyyY8wFW1uiNu9k=\";\n+        s[129] = \"YXmCWhiNz4/IhyxQIYjgNvjX+XwDiPTSBMaFELm5X8Y4knGRnkF4/zix8l9wHBb+7Cgfrr46rF7eiIzaAFLjLjjewy63duBJiVbEWjqFO0fu6T9iIjuEaF2sTppvuZNPHx80vN+HLAnAVmgFESw5APXWn15dizvuUfVHd5isCqbA\";\n+        s[130] = \"GJfUoBivW5uqDpUxTRfjGWNYfN3/dTFtdRqCIH5L2c1nWX0dgY3ba1+fW/YX1Oh5aw4lC6BIiiThjJoV1VrNnlXzbcUcMy+GsDUUB8Qe8lBvfe/t4RmNPB0hVgrS89ntbuU0SsCmWw+9DqM3nidPebANKERig1zZTBBKgpVf7HPFCA==\";\n+        s[131] = \"eTerNs7dOqJAxAxcMQRnUDc2cBj2x0jU1g1D3G+b22kDz7JBzOy/mxhGXAQ3130lavWMhImSBkReU+z0A13EYVMUv9PFzD747KCvns+SCo52YNHB0896b4l47q8hu8jsD17TZ2uWWJhS4cNnSE1jeM6NoXGKvf90yxfzwucNYc4RdaQ=\";\n+        s[132] = \"lbrGsjbzE521q8tzVHV7vcTPchUnzI/UfeR2R+cmOa29YljPWLht9Wx2JrjiKv4Of5nXe7kvhi+LYUuFVqgaqIFhC/PLbqOFiT2VZcXorToaRT9CLiqV5b6nHN/Txz6SI7MiD3hnk7psDbglPOo+ytqc9sFHj7UkR1ZctQjwFYwJjlxf\";\n+        s[133] = \"mQwAPzYzfxz9FXEiZ6M8u1oN3EJbFYmNVfpm+j0DqgU+OPI4URHBIrF4xvdMvAPn0WuarbQy/ZVN0eKL7S4K3Mvan0flAwaZdI+e5HpkfxOoGTp8Dk5EFTXjmZ/s+GonePEQEGNVPL1WYoD6xXqAAvMLKtyrFcpoiGS9eDBlsZDQzPzz/g==\";\n+        s[134] = \"3G6d12UY4l5W7Nnw0BL0HnViVg9SdEuLMqeZwy0RlJR/Ytcgd/mIxIuXXAlGhvhoX6Xc2BGU7RpTi1jYKzA86yul0j96dbcE4OtrP9lUBJlcY9eWz59dvLqKxwt3cEOBwrPf69MHuIa256es3AOCobfC8RQScW0PQ0QUa1VHB/eXSsVTSWg=\";\n+        s[135] = \"AxgrZKTFk5JvLC3DBACHwp266FxKI/yn9F+1tYkzL57RVs5HCJYS47VuG0T0E2wqzHqcLKPQMZWU7vbRoyMGNL3ZtaHoZqTqcq9KWtODC+OnEvSS7+1P4SmQDuyL2MJ/eJABJKNcu1K/Lk0buAaO0FvX6OGBcPzu1+dv/ZkwuORK07qRnxqQ\";\n+        s[136] = \"atkG8l2U/Nnm+zLu7zjenrfcAVQJMUqHimFZ3cQfaUp4qyrFn1UiwZ33j66Vt63eVaT/FXx+LlEnsHn6ATPBMp3iEYoBJYyNpjz/zROhBbcznQAMdWUTcyKInvnG3x6ExgBXpyqfxxp/Pm8by7LlSUT5MKHdcu+TEfUXRokCr2iPnt7NYsNDfA==\";\n+        s[137] = \"dciU1mSHGcBxOAVBgJx75J6DaQdBZfTIzQ04WhkkdRMupOZWSnv19xhz8hiO+ZnbBtDJuO5rHsUGzH/jYacfZyCQ924roRvkh3T1yxsLq3abZJUCD9HYnPTELVhv1+cEF4aoO3vGOu2FpfLUn5QTd0PozsIqcqZVB2V57B7DjfizUe3D8Yf5Vco=\";\n+        s[138] = \"dgR1PPacBvtILBmg33s9KWtuc67ndh3rCHZ/lIN7sENgbFqJQy5DC3XIeHTV7oWd+tJQaXxoC71/SU7Rz6OClAMKXLbMz8U6RPiqn3M7MRCQcDfNjA5cCNknXT9Ehz/IZF/7lcWrwxBKYm4B98lPkpZtR2QHndiQ3venzWrP0P5y27mReaFuaJ++\";\n+        s[139] = \"1Q8rfp1HuGsxurTgGMakxj5SwNF7EixXxVPnfGADWDcygh5C1BMXqiL1AuVXOVFOsaydfLWGC8Kbh/JiL6H+12lYrNGUT9yJRIzRDi4XylMnrYwBtwCJjoHSi4exz5K2ih54utVAuzXZg6mnc9ied/mNRjj9d2HFD5mv0w/qTN/WFxEmtuZM/nMMag==\";\n+        s[140] = \"w01TnPP/F3Vni3fBdV32Bnbb4J1FcbaE+Xn44no5ug77U8FS1gSm3LqJ8yTyXduzl5v2dwBEfziEfTuyqgeLLsCYTBjXmYOIHQosEl6DyAknu4XK52eQW+Fes9eSs2Nq+G4aaR4y4leeFNmCoZ9BQmAAZr0LFkqnvqaKmBVgcgxPs7/8SQHnpqvaU6Y=\";\n+        s[141] = \"OfzIF38Tp5g1W5eVbrkrMe0Mm7e0wBYg5hVvLpn/5MW5OFcmRDuBp15ayRBnJ1sBI93+CNl0LwP8Q0z9IXFjTER5gHZ1KfG8NV+oacKNG7aYrbUftkSL/oPfRNPez6U0FuWgvVrXUB6cwKTWvwb9KoD7s6AGYRdH50ZgJdBniFD7dKoOQnJ/ECuTUXI+\";\n+        s[142] = \"4hoX0sjqlkSJPUq627iJkNYRbtD+V2qErCuTikaeRDEZvVHWvzdvwj4W1xxJjz+yHAN6z2EjCWidcSsVgTejQ1bH8uTzJgh/zq3yGUSsJoJWrecqxsge8bEBjkm+qUO8G3kAnC6FMjJ2NYQeXf6OK6OgsqyJwlHPTyAms2/IoYTB4iEqgIFG/2fNEJEIag==\";\n+        s[143] = \"M/dy14xNbZMRfHiKKFdmD/OrEB+8MexrRO8mMh0i5LrNA5WUtLXdwUfAysYmal94MSoNJfgmwGCoqNwlWZBW1kpQaPdqsrn2cvc6JcZW9FlOx07DERJGbZ6l6ofbzZWgF+yf+hvT6jnJvXBVCTT3lfO3qo4leNuEJwsuU6erXGC3Ch53uPtGIrdDUpcX6/U=\";\n+        s[144] = \"GgLr2hd3nK64IZv0JksKAT/yJNQ38ayuWyBnWLjXbEmT048UDppsrrnP6hikRo5v2TlHGhD2dcwG9NLK3Ph8IoIo9Wf2vZWBB+SMI9FpgZxBWLEjwHbOWsHaEQMVsQfk38EWQP0Fr6VyMKlEQfpsRkuCpp1KxscaxK7g5BgXUlb0a2x0F+C9hEB0OVPsj4JN\";\n+        s[145] = \"W9lKcLDqNGQAG/sKQNaRmeOUmLJ7GcMNqBaGZ659Rnjr6RTrfnmkp5Z9meALnwXoHjPjzSQDJnVYsY+xyMnuPgl6gMVAhAm+XprYVpsne4vt+7ojUqavVPBqLy5dtnhp1qfcnAiV5cZhHXX7NbxkUOzptjEGCQjnhSH4rPbZtgoIWE8Z6boF3l/thLnFX+AiiQ==\";\n+        s[146] = \"iYLn5h9lIhD/x9moaPRnTX6mJEJKThg4WXxS7IrR2zblH26uOkINz0dJNTJVets0ZNYDnsnT7J2iI3Y6hTVWPGoYU49J3B2LhCREs0DZQ3C7080FtiOcfHbfBLNn0DyCK1LeAC7YB/bNdiyhLqH8fKl+0+KhiPDIUBJY2e7IbZR/9t0sxJbIXx6cRvI5AXex12o=\";\n+        s[147] = \"SlRJEc7npTUvQq8SgBYKmVY/3wHYp2gsDxafN/JLUuEqEjmWMtW7fxASi+ePX4gmJJqLhD5t+AZxiCwYK3L3ceuJx4TiqVgJz8d6sc7fgWXluh1K+BcGPbZ7+Cq4Vsga7JEBVekviEZ5Ah4apNr8RkB7oMOUVPGxRcyyaVE4zBW+scA6c1yi/HQXddQ9rWyLUsVo\";\n+        s[148] = \"AAlbGR6ekLOzx4hpqZTUqVUQ0FL2CFpgCMOp6CuuUzkSnWXpUjvOiSDkNPgoTPgpgmg3uYvMsX43mkPGUGC9awDThXyGQh6u3WfWtmhiPRqXnjFek+EPd0LYXps71non6C9m7nUlYNWzBJ1YzrzWjlB5LLPBN8bsZG6RbdZkYMxJ9J5ta/c30m8wDDNuTm0nEE0ZVQ==\";\n+        s[149] = \"nWWbBhzObqwEFh/TiKREcsqLYbRjIcZflJpol16Mi4YDL6EZri22qRnTgrBtIY+HieTYWuLaCSk/B9WcYujoS6Jb5dyg3FQ6XF9bYaNQGx2w8DHgx0k2nqH/0U1sAU0kft32aD2orqCMIprbO1WJIt2auRnvcOTFoOax926nAkxvR3nrFVDevFjDbugpWHkGwic6G7o=\";\n+        s[150] = \"WNk1Rn2qtG+gk0AEewrgo+aRbNrG4CgQpOR8Uo7c2m2XQY8MVDu4uRA6rzYGGdgqTcICKky9MvHeJeNWVAXOxmA4EdXQ2xItFJdQtxBt56cad9FBXXsz21yVsPr5d453abi7T3XfHVTToekiOlxAJs+bpat9cFRbIdHghO9wc/ucoArT53vpYsnyeVnmZG2PX48lXpNS\";\n+        s[151] = \"wVmiO6mdf2aahrJlcmnBD0Qa58y8AvzXtJ54ImxgPLPn0NCQIrmUxzNZNTODE3WO6kZMECaT/REqT3PoOBp9stCHCFNXOM7979J44C1ZRU0yPCha00kQZBF5EmcLitVCz10tP8gG1fiIvMjwpd2ZTOaY4/g4NeJHLjJPll0c5nbH7n4v+1I+xG7/7k7G6N8sp21pbgpTYA==\";\n+        s[152] = \"OoiVZosI+KG0EZTu+WpH7kKISxmO1zRYaSPMBMW0AyRiC2iZVEkOMiKn12XPqIDSW/kVA58cvv/ysTAzKLTu78Uo+sVcJe3AtLdgeA9vORFELTP4v9DQ/mAmehe3N8xk+VTLY6xHWi6f4j9cTDW/BDyJSDRY00oYoHlvnjgHo4CHBo0sMGgX3CwcnK2hpMFVtB/3qPl6v2w=\";\n+        s[153] = \"97ZVsTYwD8VrgN1FOIRZ8jm8OMgrxG3o1aJoYtPVWXp9cjjlgXqTMZVsoWr3pr7pudw+LYo1Ejz3JpiUPHqWcZ2PWrWs7PR1akYGuwdCBHYvCGTcZYFe/yu1AB8w5zYsl1eJR45g0u1DlXfx5BUAUzc4yJDjc48Ls62bn8t0EJ7+30sWwifqKuz2EHpsqp1j/iMlwzKJGjGE\";\n+        s[154] = \"0NSYKTvBKKInwL9PJ/pWUWVX4gjF3igsA2qqQMsRew0lI1LcCB18eGCYk0AnyUCe99w5lWHGFUMMeH6DZciAylWGeDn19JdzVOTevBWk3LIujI1GvsEB3oVqf2Zl9IZeDGCT4+bQKBWvgcXHjysZfnn/5z9Xz06qrPqac5LfS36fDcwnkrUYQWDsL2Ike32ALmOnkcDjNq1BoA==\";\n+        s[155] = \"5ok+rYI4LCgGa2psGUN/fdkT2gQEToB9HRiFXQpe2YcQvEN2z7YlJCETx4jSWw06p5Y8tZcp08moKNYwUJ40DvPpGlDG+wUpFhC4kkfo6vj6TrCj5yoWJi5D+qdgH2T0JeWM80cYN0bsOsetdaqNhDONlYXZ2lVYkyVS/wzw8K5xX87EWktwOwFq/yYhuWCYJ9GZL7QuDipJjEE=\";\n+        s[156] = \"KHzTalU9wPSnIjh5g0eHi1HUaFufxJpXpjDe0N3wEKINqbgzhbj3Kf4qWjb2d1A+0Mlu9tYF/kA9ONjda5jYfRgCHm5mUrjU0TAyT7EQFZ2u6WFK/sFHP++ycJQk8k7KLPUWA5OWScy1EO+dYF4d0r6K5O+7H/rpknxN6M9FlP8sH83DXK1Sd+UXL32D+4flF580FaZ5B3Tkx3dH\";\n+        s[157] = \"RrJVxIKoDXtCviWMv/SXMO42Dn6UWOKDy2hh2ASXssT0e+G6m7F1230iJWlEN0wBR8p+BlTdBhQrn25098P3K16rBmZpzw/5dmesIJxhYPaM4GiaOgztFjuScTgkmV0Jl/vZ9eCXdEVNISeXkIixM4pssTFuUV7PY/Upzdj55rDKGLr1eT7AFVSNP30PhL8zZs8MANqKBeKBBDvtww==\";\n+        s[158] = \"sy4t5rFA75GRBE+Dqa9sQxjPluKt/JnEY54guHnKqccmx3HGiyJ0jUA+et4XO8Xg69wCA9xVxJZQL73z80mVfIf43HIKOxgxT2IjG7EKMOD/qx6NnMTve4BryggLtbLQUeRfhriQeY7h65tD9ierhccXoXDpGnmBn9m2BQP78y+Qhc4eIsa3LcxbQJUIwvURjFp/rgMD7lhOLboa/2Y=\";\n+        s[159] = \"Zs/BfFoWImYau2dZLb7JneeTQp7sQ06yonEq0Ya4BNOJGy/5dGH42ozt0PpP2IZ/S58X7esVgc6jA1y3Bcxj3MPoDjQJSZHFEtR3G31T8eF5OpPVC4dw9s9clllM05tvcemssLdcd85UP/xBaDrmpAl8ZDSc73zflK3nJw8e0HQFYntNnlZPFyyyBLHnLycb6Jlvq7F2OqrZR+FXZnL3\";\n+        s[160] = \"hdeDJuRnmb8q9EYec8+futT/CvqhpqoUdtmG6E31RrYJDs96M5Wfng90IEqrncZe4rVYDocRZK23dvqtJaPhTUBXXh42IyMlUnro69KI+075FvYYwgVaUd10r7ExWM5Z7DCQ2x8Tm1meK2YCTPkF1VXXexl1UjYCnRQuQxppdophMwroJK8VqlJbFFslchTSBFuI7wgcdy+f/LHMbMsusQ==\";\n+        s[161] = \"ClCCOv0mD9//LR0OisHfamxcTvmlwMLgAIQt3hbOjRPkXwEgaDzP0u6LN8BNwdOVw+LhrbzMI8zQzHvo7mGPkQICeeim/x+xmGPQtmWnXxCWiL1uf/8eR5Wuy9Er8skTB8rG4/ubb2ssvCkubObPAkMSOgFnX9UtxnCN4+nMNV2vvn4xMTSvvQyYWewfnlNkflTyva1epE9RVW2RqRtJikY=\";\n+        s[162] = \"Fs+AmFCnUr/imw8D0GpNidIP9qwW8yRAzmtqPS+vT6n5U4YFQcpgbznrYO4TPqkVF2oz1mpgLYIgx/u2XsrtljGX46LfY8OyUPaw4/da38QGngoIlS2cN01cgN3efSjMlnZFo1x8T9p0Nn1IgRgevOd5ezVUL7WdY7eeiE1pXXcGBgDYn7NDQph0dC6HDlBiS95bDFcZ+6FYigE4WybpsOHL\";\n+        s[163] = \"wgO4DdGZy9g13IuOhkJGJcToyLuCBVm9T/c8qY4NOheVU1NW2g8sPIo+RiEsSST8sx6+Jh/A/kaCxYvJ9CsgnBjZMMWRsd383HZAoJtkxwKvyoeXzzD+puFvqKQBEKrlBEwffXhLDoFQAW2ycYtBGztl0GsUtoOob2nv7ienx1xD6KNZNaxYx2ObRAYS/e8LS3pg5dku9MPBp1X12m8ZIXRAaw==\";\n+        s[164] = \"EkXt02SaRUIjFmoLxyO6N+giL4iA4fY0Exao+mjgEfZ+Wv6w95GXHBI1xlYMVLkOcnu9nescvcXQH0OrqL9uforEUTGTSg2ci67m4GrwAryMy+5eUo77Q5GpWKfsg8nDbD8a3gUI/9EE0sCNp7tMaKwoJ56cxhbG3TJYpqWTpq3/S3q76x+3ETL+zxh6EMh8MJPfWcIxlDS7evKqdPgS00KgUtk=\";\n+        s[165] = \"OuBqx5LFJroRbDn41+4azFHlKgw6bMgbsRGaK9UnPvi5xfmV4SLQ2YzIhopGi1F57L6vKukaW0XlFk/Ff5Td5IMC7U+kvXKlf8fGIIQ8FaHI0vbIX89OJlBqlICqftSNiVRxtaE+aCh0rBoDfgPwuC8qBC20I1O3ZLuKfeUVGkMOLEWeZLS6mmcn3cSERj9o/dEl8QYwQvhH+VG6YWF//yki1Vu8\";\n+        s[166] = \"SO/vDsqZDdImOdH19sZI7FUVhlx1EI0XRr8ArTuAG5F8LDK76Bct2C7fXTUowilXnJWhQxvbGiulkUGSuVjVP12zac9bShRpr1L3ucde7n1f9y/NcHJCwdqTLq7RYygItQ4ppQGiP9jXf2Dn/qmVZZTh+SY3AZCIS+OVo2LAiYJHWnzzoX8Zt+dOYiOA/ZQKZieVJlc8ks+2xqYPD55eH0btZn5hzA==\";\n+        s[167] = \"tZL/qACMO9SzmgJhWQMsbKgE5lPAEbxn3NR7504ilgArR8j7uv1KF46uQyjrkEnyBormYB/6nLGlHht62IQftMYf5gHpHFfTvukRKF8728yIYAAYHPQ/WjHzHdVSqUJqF2a8RE6SvvY+KSKWLMU3hjn1f6dqX599hYD7AnbPGTpFKDU5sLFOXbuynU1sPUhP+a4Hev9yNU6atLDo4CkX/Yq3FbpWVuQ=\";\n+        s[168] = \"GRe7uF1wH5/71B3vmGF+pN3H9PKO1tLwsnb0D4/Pm7Pu5KAe4OfelkfFIBgyjuoZrpeEkGZnb+qf+Kn7Kt1hDwYr/Mb9ewuwOXsbIpLQMgfh0I5XsPrWocduVzn+u/cm3cr0Z11zsx0AZjTqvslACkDqiquY41JhtGdc22RCvIYom2l+zzMIMyCPsHeCSB1MBu8EWK3iP7SD3dWttwzMg0xanoPDgk0U\";\n+        s[169] = \"8BDFu+29lptlGSjcZe7ghWaUgIzbuUpM5XDFbtJVQPEd3bAE0cGRlQE9EhKXi5J/IskYNrQ357tBhA+UNDNXCibT2AZGpzWAcwE6dP+14FuRL5Gxqh/teuPYKr5IIn7M3SbgOychZzLI7HGCvVhBUiJBu8orI3WmAIVcUhAsMGHsFveck/ZCXQA+Uq/WVnW1VNs6hSmIhsAFc51qsmsQK07z2Wptx4rRjw==\";\n+        s[170] = \"siPSXD4u36WYtTvvDzRlFPiuZMnRczrL3eA15955JDCc6/V2Cvu6m/HPO6JxogxO0aYTZ5tejYDOIZgBy40DgUZMqPJ2IpYjsmUbjjJU8u/OpwhMon525m3v0EYlvyj2Qp3pwFKDkvncK3aNjN3KaaX6HuIy6kyqsDl0BTEnB5iJyHLRBCkeznTK019u48Yfsrz2oGuZcWzNj5/vKMdxQPiyJ9EHyox8Ark=\";\n+        s[171] = \"+/14PnFQVZ7BTHKUvkTtRrYS7WnPND5gZ5byMhUrDLkJa6UPBV7z0nrDMifEo/dQfUq3EjCiG6xGVhrUvAzgxqOQZTW1Y9p9M0KWW+E0XvCQppHFpuMqF1vYsF0OD6AMiE9JtGnWs3JcaWP/XBF/CvhQlFGbHi3fbrD/haTEBnmpJWBgMdKribdbXHtBSFZ2MzCX2eDtxoDdRdEVGs4v/q8gVBS+WsnZ3TTF\";\n+        s[172] = \"31I1ja+B+aopKkztGzJYvJEWAshyoAAV5yve4LnP0kdImUQaVETSuo5CDIYr7zM8MCD1eYPpLicmGnA+C927o9QGAVL3ctO/DCWhNinW7NmeYIM+o4diKBkDPjHmSWa+nq4nr+gOap4CtwL2wW2B5Yqt26pKgN9uAU5CmTL26hYFgMEOZfrkQ7XdYGy2CN8RJLmjeSFVVNBG/FTaK7tpuy0LQSkko6wczBYGeg==\";\n+        s[173] = \"XbRfDqGe3eeI1tHx8UnPneDB57N8VeSSzXzVCNSgxOEfd6d/un5CDxHG+m4w3tIbtSky4R2+zMF+S5cRvTOwZ/veegYtLKTxA0mVedWLFkfh/v4NgPJ+NEU+cylbSSZLAeBofDvoJwnYKujN2KFa8PGAxr3Y8ry3qdkS8Ob1ZiHYAmLvKS9sGb/vjTvRy+a4Q7kOepsm7PYisinKelBAvDnjli6/lOutGrenjX4=\";\n+        s[174] = \"jGEj/AaBefac9uOcmGuO9nH+N+zMsC4qAe6ZUEMMIXdTGnSWl7Xt0/nKqyOj3ZH249HwkJ8bn5C+0bzOpQ1eA3PxEq6RfKMrjHJPJmTZXrSESTjfj3oNLU/CqqDOqd8znTgN6nvnUdCeStLMh9bmWF1+0G11nDwg6GQWWQ0zjVDTq5j7ocXcFOyUcu0cyl5YDcUP0i2mA2JullInU2uBte7nToeSGB3FJxKueBbv\";\n+        s[175] = \"RAzNCxlP2S/8LfbGtlSDShox8cSgmJMOc2xPFs8egZVJiwlmnS3aBWKPRbbxkZiVVYlu4GNJNwbocc6dgrl28HXAsYikE5wwoQ1MeOJWU3zzFiYENh7SLBQfjVPQHucctr8P6Rl7YL5wHc+aC+m92R3bnzm5rp1PeHm7uzy2iUUN0cgfbwJ4FrpXhVMTsAUpTbg1+037EWcGOuxir4dG2xBfgOwa+ejFHkw7y0LWRw==\";\n+        s[176] = \"08hmZptBGKKqR6Qz9GNc2Wk1etgU/KogbiPQmAh5IXlTBc97DuEToL4Bb889nfObVQ/WelmiCS8wEjSBdmnlkkU7/b5UT3P4k1pB6ZxPH9Qldj5aazkA/yCb0kzDfJlcdFOh1eAcu5LvwTXOizmPwsDvJEnOkaDZrKESZshsHU2A6Mx6awk9/orf6iBlJHQIIH3l4o3b1gx2TNb/hUgdAlwtQDhvKO3skB0PS+rcWAw=\";\n+        s[177] = \"0GhrgbSSHPLWtyS2mnSxrNAj/dyrFQcxIgPjT7+78SZ1ZTGc03vsmlZ4Z/bOO84E9yKblaI5dSHVXrx57L0kikL8tgKCsAkUNO3l/4zv5FfCrRTgGx4sFTFB1NNcLcwagkvFzde764DjYmj4YZhYsXSZCVKi0uu5M8fpgGDZ9UMSFR008cbhaIoFLWSANqiNJYSvTQZhGWfLtIPGLN+gIOMcaKhx1b5vg6OYSz6ScAM/\";\n+        s[178] = \"2VGiMV/f2hNZAjw3fdeHx/wRIVzeP018lZynzwSySG/zQBxyRmi3YmKVZmh3aJunuiqmvdt0kJ6lX7M8BajYHPCBkqJOx8oPJ/K1oADxVgnavZ69dKYrSy9/Pm6sHxjFrdSz9TelUK9sgoFTWS6GxgzWEqXRBDDpGUnsNbSEcWLPKVLNNoYAcltY98JZaNSZBXcpa9FeSN7sVU43q2IEcDx3ZkJzRJpl/lb7n+ivMwX/OQ==\";\n+        s[179] = \"iMSCh1m5vct3C7LEn5wKRYtalzvG6pKahG19rTb6Z9q7+buDsML5yM6NqDvoVxt3Dv7KRwdS3xG/Pyb7bJGvQ2a4FhRnTa4HvPvl3cpJdMgCCvsXeXXoML4pHzFlpP0bNsMoupmhQ0khAW51PAr4B165u1y5ULpruxE+dGx/HJUQyMfGhOSZ5jDKKxD5TNYQkDEY28Xqln6Fj8duzQLzMIgSoD8KGZKD8jm6/f8Vwvf43NE=\";\n+        s[180] = \"hN4+x/sK9FRZn5llaw7/XDGwht3BcIxAFP4JoGqVQCw8c5IOlSqKEOViYss1mnvko6kVrc2iMEA8h8RssJ4dJBpFDZ/bkehCyhQmWpspZtAvRN59mj6nx0SBglYGccPyrn3e0uvvGJ5nYmjTA7gqB0Y+FFGAYwgAO345ipxTrMFsnJ8a913GzpobJdcHiw5hfqYK2iqo8STzVljaGMc5WSzP69vFDTHSS39YSfbE890TPBgm\";\n+    }\n+\n+    /* These are chunked versions of the strings above (chunked by commons-codec-1.3.jar) */    \n+    private static void initCHUNKED_STRINGS() {\n+        String[] c = CHUNKED_STRINGS;\n+        c[0] = \"\";\n+        c[1] = \"uA==\\r\\n\";\n+        c[2] = \"z9w=\\r\\n\";\n+        c[3] = \"TQ+Z\\r\\n\";\n+        c[4] = \"bhjUYA==\\r\\n\";\n+        c[5] = \"1cO9td8=\\r\\n\";\n+        c[6] = \"sMxHoJf5\\r\\n\";\n+        c[7] = \"jQcPlDsZzw==\\r\\n\";\n+        c[8] = \"TAaPnfW/CYU=\\r\\n\";\n+        c[9] = \"cXTZuwzXPONS\\r\\n\";\n+        c[10] = \"Ltn/ZTV4IjT6OA==\\r\\n\";\n+        c[11] = \"6fh+jdU31SOmWrc=\\r\\n\";\n+        c[12] = \"E/5MoD4qCvDuTcFA\\r\\n\";\n+        c[13] = \"2n9YyfCMyMXembtssQ==\\r\\n\";\n+        c[14] = \"qBka3Bq6V31HmcmHjkY=\\r\\n\";\n+        c[15] = \"WvyZe6kQ8py7m25ucawJ\\r\\n\";\n+        c[16] = \"oYpxMy6BSpZXhVpOR6dXmA==\\r\\n\";\n+        c[63] = \"yexFaNKaP+VkVwEUvxQXbC0HSCi/srOY7c036lT25frs4xjIvp214JHCg7OL/XZW3IMe6CDgSMCa\\r\\naI91eRgM\\r\\n\";\n+        c[64] = \"vkqgnuJ3plxNtoveiMJuYLN6wZQLpb3Fg48/zHkdFuDucuMKWVRO/niFRgKsFqcxq6VgCxwQbePi\\r\\nP9sRnxz7wg==\\r\\n\";\n+        c[65] = \"YHks3GCb2uVF47Y2tCieiDGJ879Rm5dBhQhQizYhfWOo+BrB2/K+E7wZWTid14lMpM60+5C0N9JN\\r\\nKAcBESeqZZI=\\r\\n\";\n+        c[66] = \"z8551jmQp/Qs95tw226+HCHWruKx/JvfBCfQ5p0fF77mkSpp66E552ik2gycrBBsMC/NbznAgTZo\\r\\nMzZxehfJwu49\\r\\n\";\n+        c[67] = \"VsR2whqq/qQm342+TNz1lgOZMoWbpCz+kj2zflq0nx7S/ReEVPUJcqgMtVzrr2FVQPfBAH5VRjR+\\r\\nhkxwv4bssQms8Q==\\r\\n\";\n+        c[68] = \"5xmIp8dUJZzkisIkuEPsnPXvzDeMo48qWFfHIn2av3jr5qoZHCs0LfNEyepC3v2sa0nCU0FlqsmD\\r\\nyTI5/2jt5zsLtV0=\\r\\n\";\n+        c[69] = \"tGEgXjglUB9NbCtiS88AetLtRqhCAnhzOUKVgvbJZHqOA6x8uOorA1t3NcaIA00ZqbPYALu4LzIm\\r\\n4i4lAL9QgiH/Jg7b\\r\\n\";\n+        c[70] = \"gFtxEhYJahDmU5dpudYs6ZTsqAx+s2j+06A0zeyb3U7nhZFsbkCDlds0EYUoqerZqZPm7F6CDOOD\\r\\n3dU7nYmelE0DxyMO9A==\\r\\n\";\n+        c[71] = \"j/h/1JygYA5bjttxzQxr5gBtgh+AYVozhF4WgvcU/g49v0hUy6FdhfZewGK+Phtzj7RabI5p2zXy\\r\\nzvkmLQdFhdI5Um4O5sw=\\r\\n\";\n+        c[72] = \"m+kYVGojIR5pgbz7pGJm2g+3qqk7fhl3cowa2eVrhki7WofyywnRezqTxOkBgVFz6nKs8qxpbbbz\\r\\nALctcPeMsp9dpXUfuUJr\\r\\n\";\n+        c[73] = \"pPaGnMr0UYmldnJVk/F+3WCJJ1r2otvD5KJdt2u1RnS6LwhHhwLCqfW8O/QEg43WdxKomGL/JM33\\r\\ntn/B9pMPoIU0QTGjq2GRow==\\r\\n\";\n+        c[74] = \"mOxzGyym6T/BxCV5nSiIYMlfAUmCN7gt7+ZTMg1kd8Ptirk+JF5dk8USbWBu/9ZvNg5ZuiJCeGwf\\r\\naVpqpZ3K9ySF7C87Jvu1RUE=\\r\\n\";\n+        c[75] = \"VYLOIE4DnhxJn3FKS/2RHHHYLlZiGVdV/k4uBbtAYHUSTpRzaaYPGNAVjdNwbTHIihmeuk/5YQUy\\r\\n8NFsxIom+Li7bnWiBoHKBPP7\\r\\n\";\n+        c[76] = \"7foMpJ0TknCatjUiSxtnuKSiz4Qvl/idWY9UKiTljoQHZ+C8bcUscnI/bZr13e6AvyUh47MlpdGv\\r\\nzIm05qUdMWWLoZJOaGYvDmvrWQ==\\r\\n\";\n+        c[77] = \"jxQSGiFs+b1TfE4lDUAPUPJ0SWeUgl03rK6auieWJcarDIHM97gGOHMmyHudRMqkZmIkxYRgYgCC\\r\\nUg/JeU91OZD3tL4U+wNhShywe88=\\r\\n\";\n+        c[78] = \"UGmH/gl7t3Dk801vRhRDEbgsfShtHZ1gZQn4KNZ5Qsw3WiGjW0ImInVHa+LSHBzLUjwC0Z3nXO4i\\r\\n4+CiKYqAspOViE6WqVUY8ZSV0Og4\\r\\n\";\n+        c[79] = \"wdEoYmJuRng2z2IkAiSgJ1CW2VE7H7oXpYWEFFO8nG0bZn7PHhT8KyhaO2ridl8eUEysja0VXFDy\\r\\nQqSgZnvdUKrCGepWGZbw0/0bDws3Ag==\\r\\n\";\n+        c[80] = \"5kZqgrUbt+rN5BWAddeUtm9TGT43vYpB6PeyQwTyy9Vbr0+U/4Qzy0Iw37Ra293HmkmpgQzuScVp\\r\\ncIiFGXPAFWwToR+bovwu7aXji/FnMwk=\\r\\n\";\n+        c[81] = \"E467MMmJbmwv8Omc2TdcyMr/30B8izWbf+CAuJtw67b1g9trhC6n4GYnXjeW9DYvmWoIJPx0zvU/\\r\\nQ+gqv0cteg2bx9P2mrgMDARb6egowqjx\\r\\n\";\n+        c[82] = \"Vpt8hYb4jx1F+7REX7K65v6eO5F1GDg/K8SVLWDSp0srupYEQkBVRxnB9dmhSo9XHpz4C8pRl8r8\\r\\n2fxXZummEf4U2Oh0Dip5rnNtDL+IJvL8lQ==\\r\\n\";\n+        c[121] = \"hf69xr9mtFf4N3j2uA9MgLL5Zy94Hjv+VQi94+LS8972JJgDHCQOwP5whdQkV+SJpXkiyHGaSsQ4\\r\\nfhepPwzuZcEpYER+beny1j+M0HSZe36MdRIhlTqno+4qsXckL0CjXsYkJJM0NAfOYjHAus5G1bgi\\r\\n9VhmiMfAMA==\\r\\n\";\n+        c[122] = \"yKzTh5hPp9/PBeZtrZXsFHAR9ywOM3hRaBDkgG9E09wFW8MZD0xMGegcp0QrTJcP8QYOaYhTDVim\\r\\nPqsNTVOmjdjkvS+2WhjJW4mVOXQ8KID91yaBtPo+DStL5GMgctcP5MoVf1Vp8w/mYtofqbllfDm5\\r\\nNfYzh2A7ijY=\\r\\n\";\n+        c[123] = \"csFmwvDzoO4IO6ySDA4B2V7emEetAwCgO66zzlfWb3KDrPfFZc3Jgr4+dlaUkEIDHYeLHETdTssW\\r\\nOl2KrPHBEsULpDTR+3OhurXb1Qr2NvHiHFuqT3Geb6EYw2albfTmXxch82ablt4WKl4qPcSey54v\\r\\n6tsCuUuZzrkt\\r\\n\";\n+        c[124] = \"5InxvKwpoCV7EK78OzU/tL9/NmK14Prw9tOCAyK+xpUNLZriuVEVdgpoZ05rliufaUDGHH8dPAem\\r\\n8G9DN/VOPktB6vXKtc2kMUgnMTiZwv/UVd+xyqnT8PLEdNQ8rCWxyiCcLdXFf0+xcE7qCcwzC+D7\\r\\n+cRW+i6dnpZkyw==\\r\\n\";\n+        c[125] = \"cEx7oTsSHWUFPj92cstdy5wGbRcxH+VRWN8kaNTTCPWqSckyU9Xk/jj5/gj9DFwjfsCSp60xutf4\\r\\n/rFanjtwqtRg6dJLP4JAgpOKswDlHi6Vt7zF/w7HidMf2sdtlsqzayZmT2Hn7iOo3CExzr5Z5Jfm\\r\\nMFAX8R9peUN4t5U=\\r\\n\";\n+        c[126] = \"AeXetVbj+7mmGiCs3BGUSZDLlq2odMsN8JAHQM64Cly8y5jw75PpISocWRFFQmmXYP7ckKmtuhIv\\r\\nD69HtZxGhNRsl1l1gXzKFhsWykcRtG87F8sS1Uv/i6QvGiRIDVEGGIzWrzRIISkBb9wCxJ2HESfl\\r\\neWwrz/GqryjoN26B\\r\\n\";\n+        c[127] = \"aj1/8/+U8VO3D2iAwvQXZ4H0KwtuzDm4JCC8+22ccqk+UzKvqjGs87XngwfsMfSkeGVAi6VB6tfN\\r\\nJTjYctaj7R8dwh2PIfLSrvaphw4wNB2REjplnPojoOb9bNUNtUvdK3b1bArOWugIRJWLnMl72yEH\\r\\nFb1iBfBmn7uIa7KT2Q==\\r\\n\";\n+        c[128] = \"kiMuF/1CMRlgoS/uLKn1mNZFZNHJNkRQnivOrzj8HQAagwzvTXvsGgI9hXX3qaeZL9/x/Oq+Y5F6\\r\\nDh+wXo+0kp6JagFjvbTJcQSowFzIwg7/V9sans0NE0Ejow5BfZKvihFI46sHiALl1qzoXqLQq+5f\\r\\nZGIFRyyY8wFW1uiNu9k=\\r\\n\";\n+        c[129] = \"YXmCWhiNz4/IhyxQIYjgNvjX+XwDiPTSBMaFELm5X8Y4knGRnkF4/zix8l9wHBb+7Cgfrr46rF7e\\r\\niIzaAFLjLjjewy63duBJiVbEWjqFO0fu6T9iIjuEaF2sTppvuZNPHx80vN+HLAnAVmgFESw5APXW\\r\\nn15dizvuUfVHd5isCqbA\\r\\n\";\n+        c[130] = \"GJfUoBivW5uqDpUxTRfjGWNYfN3/dTFtdRqCIH5L2c1nWX0dgY3ba1+fW/YX1Oh5aw4lC6BIiiTh\\r\\njJoV1VrNnlXzbcUcMy+GsDUUB8Qe8lBvfe/t4RmNPB0hVgrS89ntbuU0SsCmWw+9DqM3nidPebAN\\r\\nKERig1zZTBBKgpVf7HPFCA==\\r\\n\";\n+        c[131] = \"eTerNs7dOqJAxAxcMQRnUDc2cBj2x0jU1g1D3G+b22kDz7JBzOy/mxhGXAQ3130lavWMhImSBkRe\\r\\nU+z0A13EYVMUv9PFzD747KCvns+SCo52YNHB0896b4l47q8hu8jsD17TZ2uWWJhS4cNnSE1jeM6N\\r\\noXGKvf90yxfzwucNYc4RdaQ=\\r\\n\";\n+        c[132] = \"lbrGsjbzE521q8tzVHV7vcTPchUnzI/UfeR2R+cmOa29YljPWLht9Wx2JrjiKv4Of5nXe7kvhi+L\\r\\nYUuFVqgaqIFhC/PLbqOFiT2VZcXorToaRT9CLiqV5b6nHN/Txz6SI7MiD3hnk7psDbglPOo+ytqc\\r\\n9sFHj7UkR1ZctQjwFYwJjlxf\\r\\n\";\n+        c[133] = \"mQwAPzYzfxz9FXEiZ6M8u1oN3EJbFYmNVfpm+j0DqgU+OPI4URHBIrF4xvdMvAPn0WuarbQy/ZVN\\r\\n0eKL7S4K3Mvan0flAwaZdI+e5HpkfxOoGTp8Dk5EFTXjmZ/s+GonePEQEGNVPL1WYoD6xXqAAvML\\r\\nKtyrFcpoiGS9eDBlsZDQzPzz/g==\\r\\n\";\n+        c[134] = \"3G6d12UY4l5W7Nnw0BL0HnViVg9SdEuLMqeZwy0RlJR/Ytcgd/mIxIuXXAlGhvhoX6Xc2BGU7RpT\\r\\ni1jYKzA86yul0j96dbcE4OtrP9lUBJlcY9eWz59dvLqKxwt3cEOBwrPf69MHuIa256es3AOCobfC\\r\\n8RQScW0PQ0QUa1VHB/eXSsVTSWg=\\r\\n\";\n+        c[135] = \"AxgrZKTFk5JvLC3DBACHwp266FxKI/yn9F+1tYkzL57RVs5HCJYS47VuG0T0E2wqzHqcLKPQMZWU\\r\\n7vbRoyMGNL3ZtaHoZqTqcq9KWtODC+OnEvSS7+1P4SmQDuyL2MJ/eJABJKNcu1K/Lk0buAaO0FvX\\r\\n6OGBcPzu1+dv/ZkwuORK07qRnxqQ\\r\\n\";\n+        c[136] = \"atkG8l2U/Nnm+zLu7zjenrfcAVQJMUqHimFZ3cQfaUp4qyrFn1UiwZ33j66Vt63eVaT/FXx+LlEn\\r\\nsHn6ATPBMp3iEYoBJYyNpjz/zROhBbcznQAMdWUTcyKInvnG3x6ExgBXpyqfxxp/Pm8by7LlSUT5\\r\\nMKHdcu+TEfUXRokCr2iPnt7NYsNDfA==\\r\\n\";\n+        c[137] = \"dciU1mSHGcBxOAVBgJx75J6DaQdBZfTIzQ04WhkkdRMupOZWSnv19xhz8hiO+ZnbBtDJuO5rHsUG\\r\\nzH/jYacfZyCQ924roRvkh3T1yxsLq3abZJUCD9HYnPTELVhv1+cEF4aoO3vGOu2FpfLUn5QTd0Po\\r\\nzsIqcqZVB2V57B7DjfizUe3D8Yf5Vco=\\r\\n\";\n+        c[138] = \"dgR1PPacBvtILBmg33s9KWtuc67ndh3rCHZ/lIN7sENgbFqJQy5DC3XIeHTV7oWd+tJQaXxoC71/\\r\\nSU7Rz6OClAMKXLbMz8U6RPiqn3M7MRCQcDfNjA5cCNknXT9Ehz/IZF/7lcWrwxBKYm4B98lPkpZt\\r\\nR2QHndiQ3venzWrP0P5y27mReaFuaJ++\\r\\n\";\n+        c[139] = \"1Q8rfp1HuGsxurTgGMakxj5SwNF7EixXxVPnfGADWDcygh5C1BMXqiL1AuVXOVFOsaydfLWGC8Kb\\r\\nh/JiL6H+12lYrNGUT9yJRIzRDi4XylMnrYwBtwCJjoHSi4exz5K2ih54utVAuzXZg6mnc9ied/mN\\r\\nRjj9d2HFD5mv0w/qTN/WFxEmtuZM/nMMag==\\r\\n\";\n+        c[140] = \"w01TnPP/F3Vni3fBdV32Bnbb4J1FcbaE+Xn44no5ug77U8FS1gSm3LqJ8yTyXduzl5v2dwBEfziE\\r\\nfTuyqgeLLsCYTBjXmYOIHQosEl6DyAknu4XK52eQW+Fes9eSs2Nq+G4aaR4y4leeFNmCoZ9BQmAA\\r\\nZr0LFkqnvqaKmBVgcgxPs7/8SQHnpqvaU6Y=\\r\\n\";\n+        c[141] = \"OfzIF38Tp5g1W5eVbrkrMe0Mm7e0wBYg5hVvLpn/5MW5OFcmRDuBp15ayRBnJ1sBI93+CNl0LwP8\\r\\nQ0z9IXFjTER5gHZ1KfG8NV+oacKNG7aYrbUftkSL/oPfRNPez6U0FuWgvVrXUB6cwKTWvwb9KoD7\\r\\ns6AGYRdH50ZgJdBniFD7dKoOQnJ/ECuTUXI+\\r\\n\";\n+        c[142] = \"4hoX0sjqlkSJPUq627iJkNYRbtD+V2qErCuTikaeRDEZvVHWvzdvwj4W1xxJjz+yHAN6z2EjCWid\\r\\ncSsVgTejQ1bH8uTzJgh/zq3yGUSsJoJWrecqxsge8bEBjkm+qUO8G3kAnC6FMjJ2NYQeXf6OK6Og\\r\\nsqyJwlHPTyAms2/IoYTB4iEqgIFG/2fNEJEIag==\\r\\n\";\n+        c[143] = \"M/dy14xNbZMRfHiKKFdmD/OrEB+8MexrRO8mMh0i5LrNA5WUtLXdwUfAysYmal94MSoNJfgmwGCo\\r\\nqNwlWZBW1kpQaPdqsrn2cvc6JcZW9FlOx07DERJGbZ6l6ofbzZWgF+yf+hvT6jnJvXBVCTT3lfO3\\r\\nqo4leNuEJwsuU6erXGC3Ch53uPtGIrdDUpcX6/U=\\r\\n\";\n+        c[144] = \"GgLr2hd3nK64IZv0JksKAT/yJNQ38ayuWyBnWLjXbEmT048UDppsrrnP6hikRo5v2TlHGhD2dcwG\\r\\n9NLK3Ph8IoIo9Wf2vZWBB+SMI9FpgZxBWLEjwHbOWsHaEQMVsQfk38EWQP0Fr6VyMKlEQfpsRkuC\\r\\npp1KxscaxK7g5BgXUlb0a2x0F+C9hEB0OVPsj4JN\\r\\n\";\n+        c[145] = \"W9lKcLDqNGQAG/sKQNaRmeOUmLJ7GcMNqBaGZ659Rnjr6RTrfnmkp5Z9meALnwXoHjPjzSQDJnVY\\r\\nsY+xyMnuPgl6gMVAhAm+XprYVpsne4vt+7ojUqavVPBqLy5dtnhp1qfcnAiV5cZhHXX7NbxkUOzp\\r\\ntjEGCQjnhSH4rPbZtgoIWE8Z6boF3l/thLnFX+AiiQ==\\r\\n\";\n+        c[146] = \"iYLn5h9lIhD/x9moaPRnTX6mJEJKThg4WXxS7IrR2zblH26uOkINz0dJNTJVets0ZNYDnsnT7J2i\\r\\nI3Y6hTVWPGoYU49J3B2LhCREs0DZQ3C7080FtiOcfHbfBLNn0DyCK1LeAC7YB/bNdiyhLqH8fKl+\\r\\n0+KhiPDIUBJY2e7IbZR/9t0sxJbIXx6cRvI5AXex12o=\\r\\n\";\n+        c[147] = \"SlRJEc7npTUvQq8SgBYKmVY/3wHYp2gsDxafN/JLUuEqEjmWMtW7fxASi+ePX4gmJJqLhD5t+AZx\\r\\niCwYK3L3ceuJx4TiqVgJz8d6sc7fgWXluh1K+BcGPbZ7+Cq4Vsga7JEBVekviEZ5Ah4apNr8RkB7\\r\\noMOUVPGxRcyyaVE4zBW+scA6c1yi/HQXddQ9rWyLUsVo\\r\\n\";\n+        c[148] = \"AAlbGR6ekLOzx4hpqZTUqVUQ0FL2CFpgCMOp6CuuUzkSnWXpUjvOiSDkNPgoTPgpgmg3uYvMsX43\\r\\nmkPGUGC9awDThXyGQh6u3WfWtmhiPRqXnjFek+EPd0LYXps71non6C9m7nUlYNWzBJ1YzrzWjlB5\\r\\nLLPBN8bsZG6RbdZkYMxJ9J5ta/c30m8wDDNuTm0nEE0ZVQ==\\r\\n\";\n+        c[149] = \"nWWbBhzObqwEFh/TiKREcsqLYbRjIcZflJpol16Mi4YDL6EZri22qRnTgrBtIY+HieTYWuLaCSk/\\r\\nB9WcYujoS6Jb5dyg3FQ6XF9bYaNQGx2w8DHgx0k2nqH/0U1sAU0kft32aD2orqCMIprbO1WJIt2a\\r\\nuRnvcOTFoOax926nAkxvR3nrFVDevFjDbugpWHkGwic6G7o=\\r\\n\";\n+        c[150] = \"WNk1Rn2qtG+gk0AEewrgo+aRbNrG4CgQpOR8Uo7c2m2XQY8MVDu4uRA6rzYGGdgqTcICKky9MvHe\\r\\nJeNWVAXOxmA4EdXQ2xItFJdQtxBt56cad9FBXXsz21yVsPr5d453abi7T3XfHVTToekiOlxAJs+b\\r\\npat9cFRbIdHghO9wc/ucoArT53vpYsnyeVnmZG2PX48lXpNS\\r\\n\";\n+        c[151] = \"wVmiO6mdf2aahrJlcmnBD0Qa58y8AvzXtJ54ImxgPLPn0NCQIrmUxzNZNTODE3WO6kZMECaT/REq\\r\\nT3PoOBp9stCHCFNXOM7979J44C1ZRU0yPCha00kQZBF5EmcLitVCz10tP8gG1fiIvMjwpd2ZTOaY\\r\\n4/g4NeJHLjJPll0c5nbH7n4v+1I+xG7/7k7G6N8sp21pbgpTYA==\\r\\n\";\n+        c[152] = \"OoiVZosI+KG0EZTu+WpH7kKISxmO1zRYaSPMBMW0AyRiC2iZVEkOMiKn12XPqIDSW/kVA58cvv/y\\r\\nsTAzKLTu78Uo+sVcJe3AtLdgeA9vORFELTP4v9DQ/mAmehe3N8xk+VTLY6xHWi6f4j9cTDW/BDyJ\\r\\nSDRY00oYoHlvnjgHo4CHBo0sMGgX3CwcnK2hpMFVtB/3qPl6v2w=\\r\\n\";\n+        c[153] = \"97ZVsTYwD8VrgN1FOIRZ8jm8OMgrxG3o1aJoYtPVWXp9cjjlgXqTMZVsoWr3pr7pudw+LYo1Ejz3\\r\\nJpiUPHqWcZ2PWrWs7PR1akYGuwdCBHYvCGTcZYFe/yu1AB8w5zYsl1eJR45g0u1DlXfx5BUAUzc4\\r\\nyJDjc48Ls62bn8t0EJ7+30sWwifqKuz2EHpsqp1j/iMlwzKJGjGE\\r\\n\";\n+        c[154] = \"0NSYKTvBKKInwL9PJ/pWUWVX4gjF3igsA2qqQMsRew0lI1LcCB18eGCYk0AnyUCe99w5lWHGFUMM\\r\\neH6DZciAylWGeDn19JdzVOTevBWk3LIujI1GvsEB3oVqf2Zl9IZeDGCT4+bQKBWvgcXHjysZfnn/\\r\\n5z9Xz06qrPqac5LfS36fDcwnkrUYQWDsL2Ike32ALmOnkcDjNq1BoA==\\r\\n\";\n+        c[155] = \"5ok+rYI4LCgGa2psGUN/fdkT2gQEToB9HRiFXQpe2YcQvEN2z7YlJCETx4jSWw06p5Y8tZcp08mo\\r\\nKNYwUJ40DvPpGlDG+wUpFhC4kkfo6vj6TrCj5yoWJi5D+qdgH2T0JeWM80cYN0bsOsetdaqNhDON\\r\\nlYXZ2lVYkyVS/wzw8K5xX87EWktwOwFq/yYhuWCYJ9GZL7QuDipJjEE=\\r\\n\";\n+        c[156] = \"KHzTalU9wPSnIjh5g0eHi1HUaFufxJpXpjDe0N3wEKINqbgzhbj3Kf4qWjb2d1A+0Mlu9tYF/kA9\\r\\nONjda5jYfRgCHm5mUrjU0TAyT7EQFZ2u6WFK/sFHP++ycJQk8k7KLPUWA5OWScy1EO+dYF4d0r6K\\r\\n5O+7H/rpknxN6M9FlP8sH83DXK1Sd+UXL32D+4flF580FaZ5B3Tkx3dH\\r\\n\";\n+        c[157] = \"RrJVxIKoDXtCviWMv/SXMO42Dn6UWOKDy2hh2ASXssT0e+G6m7F1230iJWlEN0wBR8p+BlTdBhQr\\r\\nn25098P3K16rBmZpzw/5dmesIJxhYPaM4GiaOgztFjuScTgkmV0Jl/vZ9eCXdEVNISeXkIixM4ps\\r\\nsTFuUV7PY/Upzdj55rDKGLr1eT7AFVSNP30PhL8zZs8MANqKBeKBBDvtww==\\r\\n\";\n+        c[158] = \"sy4t5rFA75GRBE+Dqa9sQxjPluKt/JnEY54guHnKqccmx3HGiyJ0jUA+et4XO8Xg69wCA9xVxJZQ\\r\\nL73z80mVfIf43HIKOxgxT2IjG7EKMOD/qx6NnMTve4BryggLtbLQUeRfhriQeY7h65tD9ierhccX\\r\\noXDpGnmBn9m2BQP78y+Qhc4eIsa3LcxbQJUIwvURjFp/rgMD7lhOLboa/2Y=\\r\\n\";\n+        c[159] = \"Zs/BfFoWImYau2dZLb7JneeTQp7sQ06yonEq0Ya4BNOJGy/5dGH42ozt0PpP2IZ/S58X7esVgc6j\\r\\nA1y3Bcxj3MPoDjQJSZHFEtR3G31T8eF5OpPVC4dw9s9clllM05tvcemssLdcd85UP/xBaDrmpAl8\\r\\nZDSc73zflK3nJw8e0HQFYntNnlZPFyyyBLHnLycb6Jlvq7F2OqrZR+FXZnL3\\r\\n\";\n+        c[160] = \"hdeDJuRnmb8q9EYec8+futT/CvqhpqoUdtmG6E31RrYJDs96M5Wfng90IEqrncZe4rVYDocRZK23\\r\\ndvqtJaPhTUBXXh42IyMlUnro69KI+075FvYYwgVaUd10r7ExWM5Z7DCQ2x8Tm1meK2YCTPkF1VXX\\r\\nexl1UjYCnRQuQxppdophMwroJK8VqlJbFFslchTSBFuI7wgcdy+f/LHMbMsusQ==\\r\\n\";\n+        c[161] = \"ClCCOv0mD9//LR0OisHfamxcTvmlwMLgAIQt3hbOjRPkXwEgaDzP0u6LN8BNwdOVw+LhrbzMI8zQ\\r\\nzHvo7mGPkQICeeim/x+xmGPQtmWnXxCWiL1uf/8eR5Wuy9Er8skTB8rG4/ubb2ssvCkubObPAkMS\\r\\nOgFnX9UtxnCN4+nMNV2vvn4xMTSvvQyYWewfnlNkflTyva1epE9RVW2RqRtJikY=\\r\\n\";\n+        c[162] = \"Fs+AmFCnUr/imw8D0GpNidIP9qwW8yRAzmtqPS+vT6n5U4YFQcpgbznrYO4TPqkVF2oz1mpgLYIg\\r\\nx/u2XsrtljGX46LfY8OyUPaw4/da38QGngoIlS2cN01cgN3efSjMlnZFo1x8T9p0Nn1IgRgevOd5\\r\\nezVUL7WdY7eeiE1pXXcGBgDYn7NDQph0dC6HDlBiS95bDFcZ+6FYigE4WybpsOHL\\r\\n\";\n+        c[163] = \"wgO4DdGZy9g13IuOhkJGJcToyLuCBVm9T/c8qY4NOheVU1NW2g8sPIo+RiEsSST8sx6+Jh/A/kaC\\r\\nxYvJ9CsgnBjZMMWRsd383HZAoJtkxwKvyoeXzzD+puFvqKQBEKrlBEwffXhLDoFQAW2ycYtBGztl\\r\\n0GsUtoOob2nv7ienx1xD6KNZNaxYx2ObRAYS/e8LS3pg5dku9MPBp1X12m8ZIXRAaw==\\r\\n\";\n+        c[164] = \"EkXt02SaRUIjFmoLxyO6N+giL4iA4fY0Exao+mjgEfZ+Wv6w95GXHBI1xlYMVLkOcnu9nescvcXQ\\r\\nH0OrqL9uforEUTGTSg2ci67m4GrwAryMy+5eUo77Q5GpWKfsg8nDbD8a3gUI/9EE0sCNp7tMaKwo\\r\\nJ56cxhbG3TJYpqWTpq3/S3q76x+3ETL+zxh6EMh8MJPfWcIxlDS7evKqdPgS00KgUtk=\\r\\n\";\n+        c[165] = \"OuBqx5LFJroRbDn41+4azFHlKgw6bMgbsRGaK9UnPvi5xfmV4SLQ2YzIhopGi1F57L6vKukaW0Xl\\r\\nFk/Ff5Td5IMC7U+kvXKlf8fGIIQ8FaHI0vbIX89OJlBqlICqftSNiVRxtaE+aCh0rBoDfgPwuC8q\\r\\nBC20I1O3ZLuKfeUVGkMOLEWeZLS6mmcn3cSERj9o/dEl8QYwQvhH+VG6YWF//yki1Vu8\\r\\n\";\n+        c[166] = \"SO/vDsqZDdImOdH19sZI7FUVhlx1EI0XRr8ArTuAG5F8LDK76Bct2C7fXTUowilXnJWhQxvbGiul\\r\\nkUGSuVjVP12zac9bShRpr1L3ucde7n1f9y/NcHJCwdqTLq7RYygItQ4ppQGiP9jXf2Dn/qmVZZTh\\r\\n+SY3AZCIS+OVo2LAiYJHWnzzoX8Zt+dOYiOA/ZQKZieVJlc8ks+2xqYPD55eH0btZn5hzA==\\r\\n\";\n+        c[167] = \"tZL/qACMO9SzmgJhWQMsbKgE5lPAEbxn3NR7504ilgArR8j7uv1KF46uQyjrkEnyBormYB/6nLGl\\r\\nHht62IQftMYf5gHpHFfTvukRKF8728yIYAAYHPQ/WjHzHdVSqUJqF2a8RE6SvvY+KSKWLMU3hjn1\\r\\nf6dqX599hYD7AnbPGTpFKDU5sLFOXbuynU1sPUhP+a4Hev9yNU6atLDo4CkX/Yq3FbpWVuQ=\\r\\n\";\n+        c[168] = \"GRe7uF1wH5/71B3vmGF+pN3H9PKO1tLwsnb0D4/Pm7Pu5KAe4OfelkfFIBgyjuoZrpeEkGZnb+qf\\r\\n+Kn7Kt1hDwYr/Mb9ewuwOXsbIpLQMgfh0I5XsPrWocduVzn+u/cm3cr0Z11zsx0AZjTqvslACkDq\\r\\niquY41JhtGdc22RCvIYom2l+zzMIMyCPsHeCSB1MBu8EWK3iP7SD3dWttwzMg0xanoPDgk0U\\r\\n\";\n+        c[169] = \"8BDFu+29lptlGSjcZe7ghWaUgIzbuUpM5XDFbtJVQPEd3bAE0cGRlQE9EhKXi5J/IskYNrQ357tB\\r\\nhA+UNDNXCibT2AZGpzWAcwE6dP+14FuRL5Gxqh/teuPYKr5IIn7M3SbgOychZzLI7HGCvVhBUiJB\\r\\nu8orI3WmAIVcUhAsMGHsFveck/ZCXQA+Uq/WVnW1VNs6hSmIhsAFc51qsmsQK07z2Wptx4rRjw==\\r\\n\";\n+        c[170] = \"siPSXD4u36WYtTvvDzRlFPiuZMnRczrL3eA15955JDCc6/V2Cvu6m/HPO6JxogxO0aYTZ5tejYDO\\r\\nIZgBy40DgUZMqPJ2IpYjsmUbjjJU8u/OpwhMon525m3v0EYlvyj2Qp3pwFKDkvncK3aNjN3KaaX6\\r\\nHuIy6kyqsDl0BTEnB5iJyHLRBCkeznTK019u48Yfsrz2oGuZcWzNj5/vKMdxQPiyJ9EHyox8Ark=\\r\\n\";\n+        c[171] = \"+/14PnFQVZ7BTHKUvkTtRrYS7WnPND5gZ5byMhUrDLkJa6UPBV7z0nrDMifEo/dQfUq3EjCiG6xG\\r\\nVhrUvAzgxqOQZTW1Y9p9M0KWW+E0XvCQppHFpuMqF1vYsF0OD6AMiE9JtGnWs3JcaWP/XBF/CvhQ\\r\\nlFGbHi3fbrD/haTEBnmpJWBgMdKribdbXHtBSFZ2MzCX2eDtxoDdRdEVGs4v/q8gVBS+WsnZ3TTF\\r\\n\";\n+        c[172] = \"31I1ja+B+aopKkztGzJYvJEWAshyoAAV5yve4LnP0kdImUQaVETSuo5CDIYr7zM8MCD1eYPpLicm\\r\\nGnA+C927o9QGAVL3ctO/DCWhNinW7NmeYIM+o4diKBkDPjHmSWa+nq4nr+gOap4CtwL2wW2B5Yqt\\r\\n26pKgN9uAU5CmTL26hYFgMEOZfrkQ7XdYGy2CN8RJLmjeSFVVNBG/FTaK7tpuy0LQSkko6wczBYG\\r\\neg==\\r\\n\";\n+        c[173] = \"XbRfDqGe3eeI1tHx8UnPneDB57N8VeSSzXzVCNSgxOEfd6d/un5CDxHG+m4w3tIbtSky4R2+zMF+\\r\\nS5cRvTOwZ/veegYtLKTxA0mVedWLFkfh/v4NgPJ+NEU+cylbSSZLAeBofDvoJwnYKujN2KFa8PGA\\r\\nxr3Y8ry3qdkS8Ob1ZiHYAmLvKS9sGb/vjTvRy+a4Q7kOepsm7PYisinKelBAvDnjli6/lOutGren\\r\\njX4=\\r\\n\";\n+        c[174] = \"jGEj/AaBefac9uOcmGuO9nH+N+zMsC4qAe6ZUEMMIXdTGnSWl7Xt0/nKqyOj3ZH249HwkJ8bn5C+\\r\\n0bzOpQ1eA3PxEq6RfKMrjHJPJmTZXrSESTjfj3oNLU/CqqDOqd8znTgN6nvnUdCeStLMh9bmWF1+\\r\\n0G11nDwg6GQWWQ0zjVDTq5j7ocXcFOyUcu0cyl5YDcUP0i2mA2JullInU2uBte7nToeSGB3FJxKu\\r\\neBbv\\r\\n\";\n+        c[175] = \"RAzNCxlP2S/8LfbGtlSDShox8cSgmJMOc2xPFs8egZVJiwlmnS3aBWKPRbbxkZiVVYlu4GNJNwbo\\r\\ncc6dgrl28HXAsYikE5wwoQ1MeOJWU3zzFiYENh7SLBQfjVPQHucctr8P6Rl7YL5wHc+aC+m92R3b\\r\\nnzm5rp1PeHm7uzy2iUUN0cgfbwJ4FrpXhVMTsAUpTbg1+037EWcGOuxir4dG2xBfgOwa+ejFHkw7\\r\\ny0LWRw==\\r\\n\";\n+        c[176] = \"08hmZptBGKKqR6Qz9GNc2Wk1etgU/KogbiPQmAh5IXlTBc97DuEToL4Bb889nfObVQ/WelmiCS8w\\r\\nEjSBdmnlkkU7/b5UT3P4k1pB6ZxPH9Qldj5aazkA/yCb0kzDfJlcdFOh1eAcu5LvwTXOizmPwsDv\\r\\nJEnOkaDZrKESZshsHU2A6Mx6awk9/orf6iBlJHQIIH3l4o3b1gx2TNb/hUgdAlwtQDhvKO3skB0P\\r\\nS+rcWAw=\\r\\n\";\n+        c[177] = \"0GhrgbSSHPLWtyS2mnSxrNAj/dyrFQcxIgPjT7+78SZ1ZTGc03vsmlZ4Z/bOO84E9yKblaI5dSHV\\r\\nXrx57L0kikL8tgKCsAkUNO3l/4zv5FfCrRTgGx4sFTFB1NNcLcwagkvFzde764DjYmj4YZhYsXSZ\\r\\nCVKi0uu5M8fpgGDZ9UMSFR008cbhaIoFLWSANqiNJYSvTQZhGWfLtIPGLN+gIOMcaKhx1b5vg6OY\\r\\nSz6ScAM/\\r\\n\";\n+        c[178] = \"2VGiMV/f2hNZAjw3fdeHx/wRIVzeP018lZynzwSySG/zQBxyRmi3YmKVZmh3aJunuiqmvdt0kJ6l\\r\\nX7M8BajYHPCBkqJOx8oPJ/K1oADxVgnavZ69dKYrSy9/Pm6sHxjFrdSz9TelUK9sgoFTWS6GxgzW\\r\\nEqXRBDDpGUnsNbSEcWLPKVLNNoYAcltY98JZaNSZBXcpa9FeSN7sVU43q2IEcDx3ZkJzRJpl/lb7\\r\\nn+ivMwX/OQ==\\r\\n\";\n+        c[179] = \"iMSCh1m5vct3C7LEn5wKRYtalzvG6pKahG19rTb6Z9q7+buDsML5yM6NqDvoVxt3Dv7KRwdS3xG/\\r\\nPyb7bJGvQ2a4FhRnTa4HvPvl3cpJdMgCCvsXeXXoML4pHzFlpP0bNsMoupmhQ0khAW51PAr4B165\\r\\nu1y5ULpruxE+dGx/HJUQyMfGhOSZ5jDKKxD5TNYQkDEY28Xqln6Fj8duzQLzMIgSoD8KGZKD8jm6\\r\\n/f8Vwvf43NE=\\r\\n\";\n+        c[180] = \"hN4+x/sK9FRZn5llaw7/XDGwht3BcIxAFP4JoGqVQCw8c5IOlSqKEOViYss1mnvko6kVrc2iMEA8\\r\\nh8RssJ4dJBpFDZ/bkehCyhQmWpspZtAvRN59mj6nx0SBglYGccPyrn3e0uvvGJ5nYmjTA7gqB0Y+\\r\\nFFGAYwgAO345ipxTrMFsnJ8a913GzpobJdcHiw5hfqYK2iqo8STzVljaGMc5WSzP69vFDTHSS39Y\\r\\nSfbE890TPBgm\\r\\n\";\n+\n+    }\n+\n+    /* Here are the randomly generated byte[] arrays we generated to exercise commons-codec-1.3.jar */\n+    private static void initBYTES() {\n+        byte[][] b = BYTES;\n+        b[0] = new byte[]{};\n+        b[1] = new byte[]{-72};\n+        b[2] = new byte[]{-49, -36};\n+        b[3] = new byte[]{77, 15, -103};\n+        b[4] = new byte[]{110, 24, -44, 96};\n+        b[5] = new byte[]{-43, -61, -67, -75, -33};\n+        b[6] = new byte[]{-80, -52, 71, -96, -105, -7};\n+        b[7] = new byte[]{-115, 7, 15, -108, 59, 25, -49};\n+        b[8] = new byte[]{76, 6, -113, -99, -11, -65, 9, -123};\n+        b[9] = new byte[]{113, 116, -39, -69, 12, -41, 60, -29, 82};\n+        b[10] = new byte[]{46, -39, -1, 101, 53, 120, 34, 52, -6, 56};\n+        b[11] = new byte[]{-23, -8, 126, -115, -43, 55, -43, 35, -90, 90, -73};\n+        b[12] = new byte[]{19, -2, 76, -96, 62, 42, 10, -16, -18, 77, -63, 64};\n+        b[13] = new byte[]{-38, 127, 88, -55, -16, -116, -56, -59, -34, -103, -69, 108, -79};\n+        b[14] = new byte[]{-88, 25, 26, -36, 26, -70, 87, 125, 71, -103, -55, -121, -114, 70};\n+        b[15] = new byte[]{90, -4, -103, 123, -87, 16, -14, -100, -69, -101, 110, 110, 113, -84, 9};\n+        b[16] = new byte[]{-95, -118, 113, 51, 46, -127, 74, -106, 87, -123, 90, 78, 71, -89, 87, -104};\n+        b[63] = new byte[]{-55, -20, 69, 104, -46, -102, 63, -27, 100, 87, 1, 20, -65, 20, 23, 108, 45, 7, 72, 40, -65, -78, -77, -104, -19, -51, 55, -22, 84, -10, -27, -6, -20, -29, 24, -56, -66, -99, -75, -32, -111, -62, -125, -77, -117, -3, 118, 86, -36, -125, 30, -24, 32, -32, 72, -64, -102, 104, -113, 117, 121, 24, 12};\n+        b[64] = new byte[]{-66, 74, -96, -98, -30, 119, -90, 92, 77, -74, -117, -34, -120, -62, 110, 96, -77, 122, -63, -108, 11, -91, -67, -59, -125, -113, 63, -52, 121, 29, 22, -32, -18, 114, -29, 10, 89, 84, 78, -2, 120, -123, 70, 2, -84, 22, -89, 49, -85, -91, 96, 11, 28, 16, 109, -29, -30, 63, -37, 17, -97, 28, -5, -62};\n+        b[65] = new byte[]{96, 121, 44, -36, 96, -101, -38, -27, 69, -29, -74, 54, -76, 40, -98, -120, 49, -119, -13, -65, 81, -101, -105, 65, -123, 8, 80, -117, 54, 33, 125, 99, -88, -8, 26, -63, -37, -14, -66, 19, -68, 25, 89, 56, -99, -41, -119, 76, -92, -50, -76, -5, -112, -76, 55, -46, 77, 40, 7, 1, 17, 39, -86, 101, -110};\n+        b[66] = new byte[]{-49, -50, 121, -42, 57, -112, -89, -12, 44, -9, -101, 112, -37, 110, -66, 28, 33, -42, -82, -30, -79, -4, -101, -33, 4, 39, -48, -26, -99, 31, 23, -66, -26, -111, 42, 105, -21, -95, 57, -25, 104, -92, -38, 12, -100, -84, 16, 108, 48, 47, -51, 111, 57, -64, -127, 54, 104, 51, 54, 113, 122, 23, -55, -62, -18, 61};\n+        b[67] = new byte[]{86, -60, 118, -62, 26, -86, -2, -92, 38, -33, -115, -66, 76, -36, -11, -106, 3, -103, 50, -123, -101, -92, 44, -2, -110, 61, -77, 126, 90, -76, -97, 30, -46, -3, 23, -124, 84, -11, 9, 114, -88, 12, -75, 92, -21, -81, 97, 85, 64, -9, -63, 0, 126, 85, 70, 52, 126, -122, 76, 112, -65, -122, -20, -79, 9, -84, -15};\n+        b[68] = new byte[]{-25, 25, -120, -89, -57, 84, 37, -100, -28, -118, -62, 36, -72, 67, -20, -100, -11, -17, -52, 55, -116, -93, -113, 42, 88, 87, -57, 34, 125, -102, -65, 120, -21, -26, -86, 25, 28, 43, 52, 45, -13, 68, -55, -22, 66, -34, -3, -84, 107, 73, -62, 83, 65, 101, -86, -55, -125, -55, 50, 57, -1, 104, -19, -25, 59, 11, -75, 93};\n+        b[69] = new byte[]{-76, 97, 32, 94, 56, 37, 80, 31, 77, 108, 43, 98, 75, -49, 0, 122, -46, -19, 70, -88, 66, 2, 120, 115, 57, 66, -107, -126, -10, -55, 100, 122, -114, 3, -84, 124, -72, -22, 43, 3, 91, 119, 53, -58, -120, 3, 77, 25, -87, -77, -40, 0, -69, -72, 47, 50, 38, -30, 46, 37, 0, -65, 80, -126, 33, -1, 38, 14, -37};\n+        b[70] = new byte[]{-128, 91, 113, 18, 22, 9, 106, 16, -26, 83, -105, 105, -71, -42, 44, -23, -108, -20, -88, 12, 126, -77, 104, -2, -45, -96, 52, -51, -20, -101, -35, 78, -25, -123, -111, 108, 110, 64, -125, -107, -37, 52, 17, -123, 40, -87, -22, -39, -87, -109, -26, -20, 94, -126, 12, -29, -125, -35, -43, 59, -99, -119, -98, -108, 77, 3, -57, 35, 14, -12};\n+        b[71] = new byte[]{-113, -8, 127, -44, -100, -96, 96, 14, 91, -114, -37, 113, -51, 12, 107, -26, 0, 109, -126, 31, -128, 97, 90, 51, -124, 94, 22, -126, -9, 20, -2, 14, 61, -65, 72, 84, -53, -95, 93, -123, -10, 94, -64, 98, -66, 62, 27, 115, -113, -76, 90, 108, -114, 105, -37, 53, -14, -50, -7, 38, 45, 7, 69, -123, -46, 57, 82, 110, 14, -26, -52};\n+        b[72] = new byte[]{-101, -23, 24, 84, 106, 35, 33, 30, 105, -127, -68, -5, -92, 98, 102, -38, 15, -73, -86, -87, 59, 126, 25, 119, 114, -116, 26, -39, -27, 107, -122, 72, -69, 90, -121, -14, -53, 9, -47, 123, 58, -109, -60, -23, 1, -127, 81, 115, -22, 114, -84, -14, -84, 105, 109, -74, -13, 0, -73, 45, 112, -9, -116, -78, -97, 93, -91, 117, 31, -71, 66, 107};\n+        b[73] = new byte[]{-92, -10, -122, -100, -54, -12, 81, -119, -91, 118, 114, 85, -109, -15, 126, -35, 96, -119, 39, 90, -10, -94, -37, -61, -28, -94, 93, -73, 107, -75, 70, 116, -70, 47, 8, 71, -121, 2, -62, -87, -11, -68, 59, -12, 4, -125, -115, -42, 119, 18, -88, -104, 98, -1, 36, -51, -9, -74, 127, -63, -10, -109, 15, -96, -123, 52, 65, 49, -93, -85, 97, -111, -93};\n+        b[74] = new byte[]{-104, -20, 115, 27, 44, -90, -23, 63, -63, -60, 37, 121, -99, 40, -120, 96, -55, 95, 1, 73, -126, 55, -72, 45, -17, -26, 83, 50, 13, 100, 119, -61, -19, -118, -71, 62, 36, 94, 93, -109, -59, 18, 109, 96, 110, -1, -42, 111, 54, 14, 89, -70, 34, 66, 120, 108, 31, 105, 90, 106, -91, -99, -54, -9, 36, -123, -20, 47, 59, 38, -5, -75, 69, 65};\n+        b[75] = new byte[]{85, -126, -50, 32, 78, 3, -98, 28, 73, -97, 113, 74, 75, -3, -111, 28, 113, -40, 46, 86, 98, 25, 87, 85, -2, 78, 46, 5, -69, 64, 96, 117, 18, 78, -108, 115, 105, -90, 15, 24, -48, 21, -115, -45, 112, 109, 49, -56, -118, 25, -98, -70, 79, -7, 97, 5, 50, -16, -47, 108, -60, -118, 38, -8, -72, -69, 110, 117, -94, 6, -127, -54, 4, -13, -5};\n+        b[76] = new byte[]{-19, -6, 12, -92, -99, 19, -110, 112, -102, -74, 53, 34, 75, 27, 103, -72, -92, -94, -49, -124, 47, -105, -8, -99, 89, -113, 84, 42, 36, -27, -114, -124, 7, 103, -32, -68, 109, -59, 44, 114, 114, 63, 109, -102, -11, -35, -18, -128, -65, 37, 33, -29, -77, 37, -91, -47, -81, -52, -119, -76, -26, -91, 29, 49, 101, -117, -95, -110, 78, 104, 102, 47, 14, 107, -21, 89};\n+        b[77] = new byte[]{-113, 20, 18, 26, 33, 108, -7, -67, 83, 124, 78, 37, 13, 64, 15, 80, -14, 116, 73, 103, -108, -126, 93, 55, -84, -82, -102, -70, 39, -106, 37, -58, -85, 12, -127, -52, -9, -72, 6, 56, 115, 38, -56, 123, -99, 68, -54, -92, 102, 98, 36, -59, -124, 96, 98, 0, -126, 82, 15, -55, 121, 79, 117, 57, -112, -9, -76, -66, 20, -5, 3, 97, 74, 28, -80, 123, -49};\n+        b[78] = new byte[]{80, 105, -121, -2, 9, 123, -73, 112, -28, -13, 77, 111, 70, 20, 67, 17, -72, 44, 125, 40, 109, 29, -99, 96, 101, 9, -8, 40, -42, 121, 66, -52, 55, 90, 33, -93, 91, 66, 38, 34, 117, 71, 107, -30, -46, 28, 28, -53, 82, 60, 2, -47, -99, -25, 92, -18, 34, -29, -32, -94, 41, -118, -128, -78, -109, -107, -120, 78, -106, -87, 85, 24, -15, -108, -107, -48, -24, 56};\n+        b[79] = new byte[]{-63, -47, 40, 98, 98, 110, 70, 120, 54, -49, 98, 36, 2, 36, -96, 39, 80, -106, -39, 81, 59, 31, -70, 23, -91, -123, -124, 20, 83, -68, -100, 109, 27, 102, 126, -49, 30, 20, -4, 43, 40, 90, 59, 106, -30, 118, 95, 30, 80, 76, -84, -115, -83, 21, 92, 80, -14, 66, -92, -96, 102, 123, -35, 80, -86, -62, 25, -22, 86, 25, -106, -16, -45, -3, 27, 15, 11, 55, 2};\n+        b[80] = new byte[]{-26, 70, 106, -126, -75, 27, -73, -22, -51, -28, 21, -128, 117, -41, -108, -74, 111, 83, 25, 62, 55, -67, -118, 65, -24, -9, -78, 67, 4, -14, -53, -43, 91, -81, 79, -108, -1, -124, 51, -53, 66, 48, -33, -76, 90, -37, -35, -57, -102, 73, -87, -127, 12, -18, 73, -59, 105, 112, -120, -123, 25, 115, -64, 21, 108, 19, -95, 31, -101, -94, -4, 46, -19, -91, -29, -117, -15, 103, 51, 9};\n+        b[81] = new byte[]{19, -114, -69, 48, -55, -119, 110, 108, 47, -16, -23, -100, -39, 55, 92, -56, -54, -1, -33, 64, 124, -117, 53, -101, 127, -32, -128, -72, -101, 112, -21, -74, -11, -125, -37, 107, -124, 46, -89, -32, 102, 39, 94, 55, -106, -12, 54, 47, -103, 106, 8, 36, -4, 116, -50, -11, 63, 67, -24, 42, -65, 71, 45, 122, 13, -101, -57, -45, -10, -102, -72, 12, 12, 4, 91, -23, -24, 40, -62, -88, -15};\n+        b[82] = new byte[]{86, -101, 124, -123, -122, -8, -113, 29, 69, -5, -76, 68, 95, -78, -70, -26, -2, -98, 59, -111, 117, 24, 56, 63, 43, -60, -107, 45, 96, -46, -89, 75, 43, -70, -106, 4, 66, 64, 85, 71, 25, -63, -11, -39, -95, 74, -113, 87, 30, -100, -8, 11, -54, 81, -105, -54, -4, -39, -4, 87, 102, -23, -90, 17, -2, 20, -40, -24, 116, 14, 42, 121, -82, 115, 109, 12, -65, -120, 38, -14, -4, -107};\n+        b[121] = new byte[]{-123, -2, -67, -58, -65, 102, -76, 87, -8, 55, 120, -10, -72, 15, 76, -128, -78, -7, 103, 47, 120, 30, 59, -2, 85, 8, -67, -29, -30, -46, -13, -34, -10, 36, -104, 3, 28, 36, 14, -64, -2, 112, -123, -44, 36, 87, -28, -119, -91, 121, 34, -56, 113, -102, 74, -60, 56, 126, 23, -87, 63, 12, -18, 101, -63, 41, 96, 68, 126, 109, -23, -14, -42, 63, -116, -48, 116, -103, 123, 126, -116, 117, 18, 33, -107, 58, -89, -93, -18, 42, -79, 119, 36, 47, 64, -93, 94, -58, 36, 36, -109, 52, 52, 7, -50, 98, 49, -64, -70, -50, 70, -43, -72, 34, -11, 88, 102, -120, -57, -64, 48};\n+        b[122] = new byte[]{-56, -84, -45, -121, -104, 79, -89, -33, -49, 5, -26, 109, -83, -107, -20, 20, 112, 17, -9, 44, 14, 51, 120, 81, 104, 16, -28, -128, 111, 68, -45, -36, 5, 91, -61, 25, 15, 76, 76, 25, -24, 28, -89, 68, 43, 76, -105, 15, -15, 6, 14, 105, -120, 83, 13, 88, -90, 62, -85, 13, 77, 83, -90, -115, -40, -28, -67, 47, -74, 90, 24, -55, 91, -119, -107, 57, 116, 60, 40, -128, -3, -41, 38, -127, -76, -6, 62, 13, 43, 75, -28, 99, 32, 114, -41, 15, -28, -54, 21, 127, 85, 105, -13, 15, -26, 98, -38, 31, -87, -71, 101, 124, 57, -71, 53, -10, 51, -121, 96, 59, -118, 54};\n+        b[123] = new byte[]{114, -63, 102, -62, -16, -13, -96, -18, 8, 59, -84, -110, 12, 14, 1, -39, 94, -34, -104, 71, -83, 3, 0, -96, 59, -82, -77, -50, 87, -42, 111, 114, -125, -84, -9, -59, 101, -51, -55, -126, -66, 62, 118, 86, -108, -112, 66, 3, 29, -121, -117, 28, 68, -35, 78, -53, 22, 58, 93, -118, -84, -15, -63, 18, -59, 11, -92, 52, -47, -5, 115, -95, -70, -75, -37, -43, 10, -10, 54, -15, -30, 28, 91, -86, 79, 113, -98, 111, -95, 24, -61, 102, -91, 109, -12, -26, 95, 23, 33, -13, 102, -101, -106, -34, 22, 42, 94, 42, 61, -60, -98, -53, -98, 47, -22, -37, 2, -71, 75, -103, -50, -71, 45};\n+        b[124] = new byte[]{-28, -119, -15, -68, -84, 41, -96, 37, 123, 16, -82, -4, 59, 53, 63, -76, -65, 127, 54, 98, -75, -32, -6, -16, -10, -45, -126, 3, 34, -66, -58, -107, 13, 45, -102, -30, -71, 81, 21, 118, 10, 104, 103, 78, 107, -106, 43, -97, 105, 64, -58, 28, 127, 29, 60, 7, -90, -16, 111, 67, 55, -11, 78, 62, 75, 65, -22, -11, -54, -75, -51, -92, 49, 72, 39, 49, 56, -103, -62, -1, -44, 85, -33, -79, -54, -87, -45, -16, -14, -60, 116, -44, 60, -84, 37, -79, -54, 32, -100, 45, -43, -59, 127, 79, -79, 112, 78, -22, 9, -52, 51, 11, -32, -5, -7, -60, 86, -6, 46, -99, -98, -106, 100, -53};\n+        b[125] = new byte[]{112, 76, 123, -95, 59, 18, 29, 101, 5, 62, 63, 118, 114, -53, 93, -53, -100, 6, 109, 23, 49, 31, -27, 81, 88, -33, 36, 104, -44, -45, 8, -11, -86, 73, -55, 50, 83, -43, -28, -2, 56, -7, -2, 8, -3, 12, 92, 35, 126, -64, -110, -89, -83, 49, -70, -41, -8, -2, -79, 90, -98, 59, 112, -86, -44, 96, -23, -46, 75, 63, -126, 64, -126, -109, -118, -77, 0, -27, 30, 46, -107, -73, -68, -59, -1, 14, -57, -119, -45, 31, -38, -57, 109, -106, -54, -77, 107, 38, 102, 79, 97, -25, -18, 35, -88, -36, 33, 49, -50, -66, 89, -28, -105, -26, 48, 80, 23, -15, 31, 105, 121, 67, 120, -73, -107};\n+        b[126] = new byte[]{1, -27, -34, -75, 86, -29, -5, -71, -90, 26, 32, -84, -36, 17, -108, 73, -112, -53, -106, -83, -88, 116, -53, 13, -16, -112, 7, 64, -50, -72, 10, 92, -68, -53, -104, -16, -17, -109, -23, 33, 42, 28, 89, 17, 69, 66, 105, -105, 96, -2, -36, -112, -87, -83, -70, 18, 47, 15, -81, 71, -75, -100, 70, -124, -44, 108, -105, 89, 117, -127, 124, -54, 22, 27, 22, -54, 71, 17, -76, 111, 59, 23, -53, 18, -43, 75, -1, -117, -92, 47, 26, 36, 72, 13, 81, 6, 24, -116, -42, -81, 52, 72, 33, 41, 1, 111, -36, 2, -60, -99, -121, 17, 39, -27, 121, 108, 43, -49, -15, -86, -81, 40, -24, 55, 110, -127};\n+        b[127] = new byte[]{106, 61, 127, -13, -1, -108, -15, 83, -73, 15, 104, -128, -62, -12, 23, 103, -127, -12, 43, 11, 110, -52, 57, -72, 36, 32, -68, -5, 109, -100, 114, -87, 62, 83, 50, -81, -86, 49, -84, -13, -75, -25, -125, 7, -20, 49, -12, -92, 120, 101, 64, -117, -91, 65, -22, -41, -51, 37, 56, -40, 114, -42, -93, -19, 31, 29, -62, 29, -113, 33, -14, -46, -82, -10, -87, -121, 14, 48, 52, 29, -111, 18, 58, 101, -100, -6, 35, -96, -26, -3, 108, -43, 13, -75, 75, -35, 43, 118, -11, 108, 10, -50, 90, -24, 8, 68, -107, -117, -100, -55, 123, -37, 33, 7, 21, -67, 98, 5, -16, 102, -97, -69, -120, 107, -78, -109, -39};\n+        b[128] = new byte[]{-110, 35, 46, 23, -3, 66, 49, 25, 96, -95, 47, -18, 44, -87, -11, -104, -42, 69, 100, -47, -55, 54, 68, 80, -98, 43, -50, -81, 56, -4, 29, 0, 26, -125, 12, -17, 77, 123, -20, 26, 2, 61, -123, 117, -9, -87, -89, -103, 47, -33, -15, -4, -22, -66, 99, -111, 122, 14, 31, -80, 94, -113, -76, -110, -98, -119, 106, 1, 99, -67, -76, -55, 113, 4, -88, -64, 92, -56, -62, 14, -1, 87, -37, 26, -98, -51, 13, 19, 65, 35, -93, 14, 65, 125, -110, -81, -118, 17, 72, -29, -85, 7, -120, 2, -27, -42, -84, -24, 94, -94, -48, -85, -18, 95, 100, 98, 5, 71, 44, -104, -13, 1, 86, -42, -24, -115, -69, -39};\n+        b[129] = new byte[]{97, 121, -126, 90, 24, -115, -49, -113, -56, -121, 44, 80, 33, -120, -32, 54, -8, -41, -7, 124, 3, -120, -12, -46, 4, -58, -123, 16, -71, -71, 95, -58, 56, -110, 113, -111, -98, 65, 120, -1, 56, -79, -14, 95, 112, 28, 22, -2, -20, 40, 31, -82, -66, 58, -84, 94, -34, -120, -116, -38, 0, 82, -29, 46, 56, -34, -61, 46, -73, 118, -32, 73, -119, 86, -60, 90, 58, -123, 59, 71, -18, -23, 63, 98, 34, 59, -124, 104, 93, -84, 78, -102, 111, -71, -109, 79, 31, 31, 52, -68, -33, -121, 44, 9, -64, 86, 104, 5, 17, 44, 57, 0, -11, -42, -97, 94, 93, -117, 59, -18, 81, -11, 71, 119, -104, -84, 10, -90, -64};\n+        b[130] = new byte[]{24, -105, -44, -96, 24, -81, 91, -101, -86, 14, -107, 49, 77, 23, -29, 25, 99, 88, 124, -35, -1, 117, 49, 109, 117, 26, -126, 32, 126, 75, -39, -51, 103, 89, 125, 29, -127, -115, -37, 107, 95, -97, 91, -10, 23, -44, -24, 121, 107, 14, 37, 11, -96, 72, -118, 36, -31, -116, -102, 21, -43, 90, -51, -98, 85, -13, 109, -59, 28, 51, 47, -122, -80, 53, 20, 7, -60, 30, -14, 80, 111, 125, -17, -19, -31, 25, -115, 60, 29, 33, 86, 10, -46, -13, -39, -19, 110, -27, 52, 74, -64, -90, 91, 15, -67, 14, -93, 55, -98, 39, 79, 121, -80, 13, 40, 68, 98, -125, 92, -39, 76, 16, 74, -126, -107, 95, -20, 115, -59, 8};\n+        b[131] = new byte[]{121, 55, -85, 54, -50, -35, 58, -94, 64, -60, 12, 92, 49, 4, 103, 80, 55, 54, 112, 24, -10, -57, 72, -44, -42, 13, 67, -36, 111, -101, -37, 105, 3, -49, -78, 65, -52, -20, -65, -101, 24, 70, 92, 4, 55, -41, 125, 37, 106, -11, -116, -124, -119, -110, 6, 68, 94, 83, -20, -12, 3, 93, -60, 97, 83, 20, -65, -45, -59, -52, 62, -8, -20, -96, -81, -98, -49, -110, 10, -114, 118, 96, -47, -63, -45, -49, 122, 111, -119, 120, -18, -81, 33, -69, -56, -20, 15, 94, -45, 103, 107, -106, 88, -104, 82, -31, -61, 103, 72, 77, 99, 120, -50, -115, -95, 113, -118, -67, -1, 116, -53, 23, -13, -62, -25, 13, 97, -50, 17, 117, -92};\n+        b[132] = new byte[]{-107, -70, -58, -78, 54, -13, 19, -99, -75, -85, -53, 115, 84, 117, 123, -67, -60, -49, 114, 21, 39, -52, -113, -44, 125, -28, 118, 71, -25, 38, 57, -83, -67, 98, 88, -49, 88, -72, 109, -11, 108, 118, 38, -72, -30, 42, -2, 14, 127, -103, -41, 123, -71, 47, -122, 47, -117, 97, 75, -123, 86, -88, 26, -88, -127, 97, 11, -13, -53, 110, -93, -123, -119, 61, -107, 101, -59, -24, -83, 58, 26, 69, 63, 66, 46, 42, -107, -27, -66, -89, 28, -33, -45, -57, 62, -110, 35, -77, 34, 15, 120, 103, -109, -70, 108, 13, -72, 37, 60, -22, 62, -54, -38, -100, -10, -63, 71, -113, -75, 36, 71, 86, 92, -75, 8, -16, 21, -116, 9, -114, 92, 95};\n+        b[133] = new byte[]{-103, 12, 0, 63, 54, 51, 127, 28, -3, 21, 113, 34, 103, -93, 60, -69, 90, 13, -36, 66, 91, 21, -119, -115, 85, -6, 102, -6, 61, 3, -86, 5, 62, 56, -14, 56, 81, 17, -63, 34, -79, 120, -58, -9, 76, -68, 3, -25, -47, 107, -102, -83, -76, 50, -3, -107, 77, -47, -30, -117, -19, 46, 10, -36, -53, -38, -97, 71, -27, 3, 6, -103, 116, -113, -98, -28, 122, 100, 127, 19, -88, 25, 58, 124, 14, 78, 68, 21, 53, -29, -103, -97, -20, -8, 106, 39, 120, -15, 16, 16, 99, 85, 60, -67, 86, 98, -128, -6, -59, 122, -128, 2, -13, 11, 42, -36, -85, 21, -54, 104, -120, 100, -67, 120, 48, 101, -79, -112, -48, -52, -4, -13, -2};\n+        b[134] = new byte[]{-36, 110, -99, -41, 101, 24, -30, 94, 86, -20, -39, -16, -48, 18, -12, 30, 117, 98, 86, 15, 82, 116, 75, -117, 50, -89, -103, -61, 45, 17, -108, -108, 127, 98, -41, 32, 119, -7, -120, -60, -117, -105, 92, 9, 70, -122, -8, 104, 95, -91, -36, -40, 17, -108, -19, 26, 83, -117, 88, -40, 43, 48, 60, -21, 43, -91, -46, 63, 122, 117, -73, 4, -32, -21, 107, 63, -39, 84, 4, -103, 92, 99, -41, -106, -49, -97, 93, -68, -70, -118, -57, 11, 119, 112, 67, -127, -62, -77, -33, -21, -45, 7, -72, -122, -74, -25, -89, -84, -36, 3, -126, -95, -73, -62, -15, 20, 18, 113, 109, 15, 67, 68, 20, 107, 85, 71, 7, -9, -105, 74, -59, 83, 73, 104};\n+        b[135] = new byte[]{3, 24, 43, 100, -92, -59, -109, -110, 111, 44, 45, -61, 4, 0, -121, -62, -99, -70, -24, 92, 74, 35, -4, -89, -12, 95, -75, -75, -119, 51, 47, -98, -47, 86, -50, 71, 8, -106, 18, -29, -75, 110, 27, 68, -12, 19, 108, 42, -52, 122, -100, 44, -93, -48, 49, -107, -108, -18, -10, -47, -93, 35, 6, 52, -67, -39, -75, -95, -24, 102, -92, -22, 114, -81, 74, 90, -45, -125, 11, -29, -89, 18, -12, -110, -17, -19, 79, -31, 41, -112, 14, -20, -117, -40, -62, 127, 120, -112, 1, 36, -93, 92, -69, 82, -65, 46, 77, 27, -72, 6, -114, -48, 91, -41, -24, -31, -127, 112, -4, -18, -41, -25, 111, -3, -103, 48, -72, -28, 74, -45, -70, -111, -97, 26, -112};\n+        b[136] = new byte[]{106, -39, 6, -14, 93, -108, -4, -39, -26, -5, 50, -18, -17, 56, -34, -98, -73, -36, 1, 84, 9, 49, 74, -121, -118, 97, 89, -35, -60, 31, 105, 74, 120, -85, 42, -59, -97, 85, 34, -63, -99, -9, -113, -82, -107, -73, -83, -34, 85, -92, -1, 21, 124, 126, 46, 81, 39, -80, 121, -6, 1, 51, -63, 50, -99, -30, 17, -118, 1, 37, -116, -115, -90, 60, -1, -51, 19, -95, 5, -73, 51, -99, 0, 12, 117, 101, 19, 115, 34, -120, -98, -7, -58, -33, 30, -124, -58, 0, 87, -89, 42, -97, -57, 26, 127, 62, 111, 27, -53, -78, -27, 73, 68, -7, 48, -95, -35, 114, -17, -109, 17, -11, 23, 70, -119, 2, -81, 104, -113, -98, -34, -51, 98, -61, 67, 124};\n+        b[137] = new byte[]{117, -56, -108, -42, 100, -121, 25, -64, 113, 56, 5, 65, -128, -100, 123, -28, -98, -125, 105, 7, 65, 101, -12, -56, -51, 13, 56, 90, 25, 36, 117, 19, 46, -92, -26, 86, 74, 123, -11, -9, 24, 115, -14, 24, -114, -7, -103, -37, 6, -48, -55, -72, -18, 107, 30, -59, 6, -52, 127, -29, 97, -89, 31, 103, 32, -112, -9, 110, 43, -95, 27, -28, -121, 116, -11, -53, 27, 11, -85, 118, -101, 100, -107, 2, 15, -47, -40, -100, -12, -60, 45, 88, 111, -41, -25, 4, 23, -122, -88, 59, 123, -58, 58, -19, -123, -91, -14, -44, -97, -108, 19, 119, 67, -24, -50, -62, 42, 114, -90, 85, 7, 101, 121, -20, 30, -61, -115, -8, -77, 81, -19, -61, -15, -121, -7, 85, -54};\n+        b[138] = new byte[]{118, 4, 117, 60, -10, -100, 6, -5, 72, 44, 25, -96, -33, 123, 61, 41, 107, 110, 115, -82, -25, 118, 29, -21, 8, 118, 127, -108, -125, 123, -80, 67, 96, 108, 90, -119, 67, 46, 67, 11, 117, -56, 120, 116, -43, -18, -123, -99, -6, -46, 80, 105, 124, 104, 11, -67, 127, 73, 78, -47, -49, -93, -126, -108, 3, 10, 92, -74, -52, -49, -59, 58, 68, -8, -86, -97, 115, 59, 49, 16, -112, 112, 55, -51, -116, 14, 92, 8, -39, 39, 93, 63, 68, -121, 63, -56, 100, 95, -5, -107, -59, -85, -61, 16, 74, 98, 110, 1, -9, -55, 79, -110, -106, 109, 71, 100, 7, -99, -40, -112, -34, -9, -89, -51, 106, -49, -48, -2, 114, -37, -71, -111, 121, -95, 110, 104, -97, -66};\n+        b[139] = new byte[]{-43, 15, 43, 126, -99, 71, -72, 107, 49, -70, -76, -32, 24, -58, -92, -58, 62, 82, -64, -47, 123, 18, 44, 87, -59, 83, -25, 124, 96, 3, 88, 55, 50, -126, 30, 66, -44, 19, 23, -86, 34, -11, 2, -27, 87, 57, 81, 78, -79, -84, -99, 124, -75, -122, 11, -62, -101, -121, -14, 98, 47, -95, -2, -41, 105, 88, -84, -47, -108, 79, -36, -119, 68, -116, -47, 14, 46, 23, -54, 83, 39, -83, -116, 1, -73, 0, -119, -114, -127, -46, -117, -121, -79, -49, -110, -74, -118, 30, 120, -70, -43, 64, -69, 53, -39, -125, -87, -89, 115, -40, -98, 119, -7, -115, 70, 56, -3, 119, 97, -59, 15, -103, -81, -45, 15, -22, 76, -33, -42, 23, 17, 38, -74, -26, 76, -2, 115, 12, 106};\n+        b[140] = new byte[]{-61, 77, 83, -100, -13, -1, 23, 117, 103, -117, 119, -63, 117, 93, -10, 6, 118, -37, -32, -99, 69, 113, -74, -124, -7, 121, -8, -30, 122, 57, -70, 14, -5, 83, -63, 82, -42, 4, -90, -36, -70, -119, -13, 36, -14, 93, -37, -77, -105, -101, -10, 119, 0, 68, 127, 56, -124, 125, 59, -78, -86, 7, -117, 46, -64, -104, 76, 24, -41, -103, -125, -120, 29, 10, 44, 18, 94, -125, -56, 9, 39, -69, -123, -54, -25, 103, -112, 91, -31, 94, -77, -41, -110, -77, 99, 106, -8, 110, 26, 105, 30, 50, -30, 87, -98, 20, -39, -126, -95, -97, 65, 66, 96, 0, 102, -67, 11, 22, 74, -89, -66, -90, -118, -104, 21, 96, 114, 12, 79, -77, -65, -4, 73, 1, -25, -90, -85, -38, 83, -90};\n+        b[141] = new byte[]{57, -4, -56, 23, 127, 19, -89, -104, 53, 91, -105, -107, 110, -71, 43, 49, -19, 12, -101, -73, -76, -64, 22, 32, -26, 21, 111, 46, -103, -1, -28, -59, -71, 56, 87, 38, 68, 59, -127, -89, 94, 90, -55, 16, 103, 39, 91, 1, 35, -35, -2, 8, -39, 116, 47, 3, -4, 67, 76, -3, 33, 113, 99, 76, 68, 121, -128, 118, 117, 41, -15, -68, 53, 95, -88, 105, -62, -115, 27, -74, -104, -83, -75, 31, -74, 68, -117, -2, -125, -33, 68, -45, -34, -49, -91, 52, 22, -27, -96, -67, 90, -41, 80, 30, -100, -64, -92, -42, -65, 6, -3, 42, -128, -5, -77, -96, 6, 97, 23, 71, -25, 70, 96, 37, -48, 103, -120, 80, -5, 116, -86, 14, 66, 114, 127, 16, 43, -109, 81, 114, 62};\n+        b[142] = new byte[]{-30, 26, 23, -46, -56, -22, -106, 68, -119, 61, 74, -70, -37, -72, -119, -112, -42, 17, 110, -48, -2, 87, 106, -124, -84, 43, -109, -118, 70, -98, 68, 49, 25, -67, 81, -42, -65, 55, 111, -62, 62, 22, -41, 28, 73, -113, 63, -78, 28, 3, 122, -49, 97, 35, 9, 104, -99, 113, 43, 21, -127, 55, -93, 67, 86, -57, -14, -28, -13, 38, 8, 127, -50, -83, -14, 25, 68, -84, 38, -126, 86, -83, -25, 42, -58, -56, 30, -15, -79, 1, -114, 73, -66, -87, 67, -68, 27, 121, 0, -100, 46, -123, 50, 50, 118, 53, -124, 30, 93, -2, -114, 43, -93, -96, -78, -84, -119, -62, 81, -49, 79, 32, 38, -77, 111, -56, -95, -124, -63, -30, 33, 42, -128, -127, 70, -1, 103, -51, 16, -111, 8, 106};\n+        b[143] = new byte[]{51, -9, 114, -41, -116, 77, 109, -109, 17, 124, 120, -118, 40, 87, 102, 15, -13, -85, 16, 31, -68, 49, -20, 107, 68, -17, 38, 50, 29, 34, -28, -70, -51, 3, -107, -108, -76, -75, -35, -63, 71, -64, -54, -58, 38, 106, 95, 120, 49, 42, 13, 37, -8, 38, -64, 96, -88, -88, -36, 37, 89, -112, 86, -42, 74, 80, 104, -9, 106, -78, -71, -10, 114, -9, 58, 37, -58, 86, -12, 89, 78, -57, 78, -61, 17, 18, 70, 109, -98, -91, -22, -121, -37, -51, -107, -96, 23, -20, -97, -6, 27, -45, -22, 57, -55, -67, 112, 85, 9, 52, -9, -107, -13, -73, -86, -114, 37, 120, -37, -124, 39, 11, 46, 83, -89, -85, 92, 96, -73, 10, 30, 119, -72, -5, 70, 34, -73, 67, 82, -105, 23, -21, -11};\n+        b[144] = new byte[]{26, 2, -21, -38, 23, 119, -100, -82, -72, 33, -101, -12, 38, 75, 10, 1, 63, -14, 36, -44, 55, -15, -84, -82, 91, 32, 103, 88, -72, -41, 108, 73, -109, -45, -113, 20, 14, -102, 108, -82, -71, -49, -22, 24, -92, 70, -114, 111, -39, 57, 71, 26, 16, -10, 117, -52, 6, -12, -46, -54, -36, -8, 124, 34, -126, 40, -11, 103, -10, -67, -107, -127, 7, -28, -116, 35, -47, 105, -127, -100, 65, 88, -79, 35, -64, 118, -50, 90, -63, -38, 17, 3, 21, -79, 7, -28, -33, -63, 22, 64, -3, 5, -81, -91, 114, 48, -87, 68, 65, -6, 108, 70, 75, -126, -90, -99, 74, -58, -57, 26, -60, -82, -32, -28, 24, 23, 82, 86, -12, 107, 108, 116, 23, -32, -67, -124, 64, 116, 57, 83, -20, -113, -126, 77};\n+        b[145] = new byte[]{91, -39, 74, 112, -80, -22, 52, 100, 0, 27, -5, 10, 64, -42, -111, -103, -29, -108, -104, -78, 123, 25, -61, 13, -88, 22, -122, 103, -82, 125, 70, 120, -21, -23, 20, -21, 126, 121, -92, -89, -106, 125, -103, -32, 11, -97, 5, -24, 30, 51, -29, -51, 36, 3, 38, 117, 88, -79, -113, -79, -56, -55, -18, 62, 9, 122, -128, -59, 64, -124, 9, -66, 94, -102, -40, 86, -101, 39, 123, -117, -19, -5, -70, 35, 82, -90, -81, 84, -16, 106, 47, 46, 93, -74, 120, 105, -42, -89, -36, -100, 8, -107, -27, -58, 97, 29, 117, -5, 53, -68, 100, 80, -20, -23, -74, 49, 6, 9, 8, -25, -123, 33, -8, -84, -10, -39, -74, 10, 8, 88, 79, 25, -23, -70, 5, -34, 95, -19, -124, -71, -59, 95, -32, 34, -119};\n+        b[146] = new byte[]{-119, -126, -25, -26, 31, 101, 34, 16, -1, -57, -39, -88, 104, -12, 103, 77, 126, -90, 36, 66, 74, 78, 24, 56, 89, 124, 82, -20, -118, -47, -37, 54, -27, 31, 110, -82, 58, 66, 13, -49, 71, 73, 53, 50, 85, 122, -37, 52, 100, -42, 3, -98, -55, -45, -20, -99, -94, 35, 118, 58, -123, 53, 86, 60, 106, 24, 83, -113, 73, -36, 29, -117, -124, 36, 68, -77, 64, -39, 67, 112, -69, -45, -51, 5, -74, 35, -100, 124, 118, -33, 4, -77, 103, -48, 60, -126, 43, 82, -34, 0, 46, -40, 7, -10, -51, 118, 44, -95, 46, -95, -4, 124, -87, 126, -45, -30, -95, -120, -16, -56, 80, 18, 88, -39, -18, -56, 109, -108, 127, -10, -35, 44, -60, -106, -56, 95, 30, -100, 70, -14, 57, 1, 119, -79, -41, 106};\n+        b[147] = new byte[]{74, 84, 73, 17, -50, -25, -91, 53, 47, 66, -81, 18, -128, 22, 10, -103, 86, 63, -33, 1, -40, -89, 104, 44, 15, 22, -97, 55, -14, 75, 82, -31, 42, 18, 57, -106, 50, -43, -69, 127, 16, 18, -117, -25, -113, 95, -120, 38, 36, -102, -117, -124, 62, 109, -8, 6, 113, -120, 44, 24, 43, 114, -9, 113, -21, -119, -57, -124, -30, -87, 88, 9, -49, -57, 122, -79, -50, -33, -127, 101, -27, -70, 29, 74, -8, 23, 6, 61, -74, 123, -8, 42, -72, 86, -56, 26, -20, -111, 1, 85, -23, 47, -120, 70, 121, 2, 30, 26, -92, -38, -4, 70, 64, 123, -96, -61, -108, 84, -15, -79, 69, -52, -78, 105, 81, 56, -52, 21, -66, -79, -64, 58, 115, 92, -94, -4, 116, 23, 117, -44, 61, -83, 108, -117, 82, -59, 104};\n+        b[148] = new byte[]{0, 9, 91, 25, 30, -98, -112, -77, -77, -57, -120, 105, -87, -108, -44, -87, 85, 16, -48, 82, -10, 8, 90, 96, 8, -61, -87, -24, 43, -82, 83, 57, 18, -99, 101, -23, 82, 59, -50, -119, 32, -28, 52, -8, 40, 76, -8, 41, -126, 104, 55, -71, -117, -52, -79, 126, 55, -102, 67, -58, 80, 96, -67, 107, 0, -45, -123, 124, -122, 66, 30, -82, -35, 103, -42, -74, 104, 98, 61, 26, -105, -98, 49, 94, -109, -31, 15, 119, 66, -40, 94, -101, 59, -42, 122, 39, -24, 47, 102, -18, 117, 37, 96, -43, -77, 4, -99, 88, -50, -68, -42, -114, 80, 121, 44, -77, -63, 55, -58, -20, 100, 110, -111, 109, -42, 100, 96, -52, 73, -12, -98, 109, 107, -9, 55, -46, 111, 48, 12, 51, 110, 78, 109, 39, 16, 77, 25, 85};\n+        b[149] = new byte[]{-99, 101, -101, 6, 28, -50, 110, -84, 4, 22, 31, -45, -120, -92, 68, 114, -54, -117, 97, -76, 99, 33, -58, 95, -108, -102, 104, -105, 94, -116, -117, -122, 3, 47, -95, 25, -82, 45, -74, -87, 25, -45, -126, -80, 109, 33, -113, -121, -119, -28, -40, 90, -30, -38, 9, 41, 63, 7, -43, -100, 98, -24, -24, 75, -94, 91, -27, -36, -96, -36, 84, 58, 92, 95, 91, 97, -93, 80, 27, 29, -80, -16, 49, -32, -57, 73, 54, -98, -95, -1, -47, 77, 108, 1, 77, 36, 126, -35, -10, 104, 61, -88, -82, -96, -116, 34, -102, -37, 59, 85, -119, 34, -35, -102, -71, 25, -17, 112, -28, -59, -96, -26, -79, -9, 110, -89, 2, 76, 111, 71, 121, -21, 21, 80, -34, -68, 88, -61, 110, -24, 41, 88, 121, 6, -62, 39, 58, 27, -70};\n+        b[150] = new byte[]{88, -39, 53, 70, 125, -86, -76, 111, -96, -109, 64, 4, 123, 10, -32, -93, -26, -111, 108, -38, -58, -32, 40, 16, -92, -28, 124, 82, -114, -36, -38, 109, -105, 65, -113, 12, 84, 59, -72, -71, 16, 58, -81, 54, 6, 25, -40, 42, 77, -62, 2, 42, 76, -67, 50, -15, -34, 37, -29, 86, 84, 5, -50, -58, 96, 56, 17, -43, -48, -37, 18, 45, 20, -105, 80, -73, 16, 109, -25, -89, 26, 119, -47, 65, 93, 123, 51, -37, 92, -107, -80, -6, -7, 119, -114, 119, 105, -72, -69, 79, 117, -33, 29, 84, -45, -95, -23, 34, 58, 92, 64, 38, -49, -101, -91, -85, 125, 112, 84, 91, 33, -47, -32, -124, -17, 112, 115, -5, -100, -96, 10, -45, -25, 123, -23, 98, -55, -14, 121, 89, -26, 100, 109, -113, 95, -113, 37, 94, -109, 82};\n+        b[151] = new byte[]{-63, 89, -94, 59, -87, -99, 127, 102, -102, -122, -78, 101, 114, 105, -63, 15, 68, 26, -25, -52, -68, 2, -4, -41, -76, -98, 120, 34, 108, 96, 60, -77, -25, -48, -48, -112, 34, -71, -108, -57, 51, 89, 53, 51, -125, 19, 117, -114, -22, 70, 76, 16, 38, -109, -3, 17, 42, 79, 115, -24, 56, 26, 125, -78, -48, -121, 8, 83, 87, 56, -50, -3, -17, -46, 120, -32, 45, 89, 69, 77, 50, 60, 40, 90, -45, 73, 16, 100, 17, 121, 18, 103, 11, -118, -43, 66, -49, 93, 45, 63, -56, 6, -43, -8, -120, -68, -56, -16, -91, -35, -103, 76, -26, -104, -29, -8, 56, 53, -30, 71, 46, 50, 79, -106, 93, 28, -26, 118, -57, -18, 126, 47, -5, 82, 62, -60, 110, -1, -18, 78, -58, -24, -33, 44, -89, 109, 105, 110, 10, 83, 96};\n+        b[152] = new byte[]{58, -120, -107, 102, -117, 8, -8, -95, -76, 17, -108, -18, -7, 106, 71, -18, 66, -120, 75, 25, -114, -41, 52, 88, 105, 35, -52, 4, -59, -76, 3, 36, 98, 11, 104, -103, 84, 73, 14, 50, 34, -89, -41, 101, -49, -88, -128, -46, 91, -7, 21, 3, -97, 28, -66, -1, -14, -79, 48, 51, 40, -76, -18, -17, -59, 40, -6, -59, 92, 37, -19, -64, -76, -73, 96, 120, 15, 111, 57, 17, 68, 45, 51, -8, -65, -48, -48, -2, 96, 38, 122, 23, -73, 55, -52, 100, -7, 84, -53, 99, -84, 71, 90, 46, -97, -30, 63, 92, 76, 53, -65, 4, 60, -119, 72, 52, 88, -45, 74, 24, -96, 121, 111, -98, 56, 7, -93, -128, -121, 6, -115, 44, 48, 104, 23, -36, 44, 28, -100, -83, -95, -92, -63, 85, -76, 31, -9, -88, -7, 122, -65, 108};\n+        b[153] = new byte[]{-9, -74, 85, -79, 54, 48, 15, -59, 107, -128, -35, 69, 56, -124, 89, -14, 57, -68, 56, -56, 43, -60, 109, -24, -43, -94, 104, 98, -45, -43, 89, 122, 125, 114, 56, -27, -127, 122, -109, 49, -107, 108, -95, 106, -9, -90, -66, -23, -71, -36, 62, 45, -118, 53, 18, 60, -9, 38, -104, -108, 60, 122, -106, 113, -99, -113, 90, -75, -84, -20, -12, 117, 106, 70, 6, -69, 7, 66, 4, 118, 47, 8, 100, -36, 101, -127, 94, -1, 43, -75, 0, 31, 48, -25, 54, 44, -105, 87, -119, 71, -114, 96, -46, -19, 67, -107, 119, -15, -28, 21, 0, 83, 55, 56, -56, -112, -29, 115, -113, 11, -77, -83, -101, -97, -53, 116, 16, -98, -2, -33, 75, 22, -62, 39, -22, 42, -20, -10, 16, 122, 108, -86, -99, 99, -2, 35, 37, -61, 50, -119, 26, 49, -124};\n+        b[154] = new byte[]{-48, -44, -104, 41, 59, -63, 40, -94, 39, -64, -65, 79, 39, -6, 86, 81, 101, 87, -30, 8, -59, -34, 40, 44, 3, 106, -86, 64, -53, 17, 123, 13, 37, 35, 82, -36, 8, 29, 124, 120, 96, -104, -109, 64, 39, -55, 64, -98, -9, -36, 57, -107, 97, -58, 21, 67, 12, 120, 126, -125, 101, -56, -128, -54, 85, -122, 120, 57, -11, -12, -105, 115, 84, -28, -34, -68, 21, -92, -36, -78, 46, -116, -115, 70, -66, -63, 1, -34, -123, 106, 127, 102, 101, -12, -122, 94, 12, 96, -109, -29, -26, -48, 40, 21, -81, -127, -59, -57, -113, 43, 25, 126, 121, -1, -25, 63, 87, -49, 78, -86, -84, -6, -102, 115, -110, -33, 75, 126, -97, 13, -52, 39, -110, -75, 24, 65, 96, -20, 47, 98, 36, 123, 125, -128, 46, 99, -89, -111, -64, -29, 54, -83, 65, -96};\n+        b[155] = new byte[]{-26, -119, 62, -83, -126, 56, 44, 40, 6, 107, 106, 108, 25, 67, 127, 125, -39, 19, -38, 4, 4, 78, -128, 125, 29, 24, -123, 93, 10, 94, -39, -121, 16, -68, 67, 118, -49, -74, 37, 36, 33, 19, -57, -120, -46, 91, 13, 58, -89, -106, 60, -75, -105, 41, -45, -55, -88, 40, -42, 48, 80, -98, 52, 14, -13, -23, 26, 80, -58, -5, 5, 41, 22, 16, -72, -110, 71, -24, -22, -8, -6, 78, -80, -93, -25, 42, 22, 38, 46, 67, -6, -89, 96, 31, 100, -12, 37, -27, -116, -13, 71, 24, 55, 70, -20, 58, -57, -83, 117, -86, -115, -124, 51, -115, -107, -123, -39, -38, 85, 88, -109, 37, 82, -1, 12, -16, -16, -82, 113, 95, -50, -60, 90, 75, 112, 59, 1, 106, -1, 38, 33, -71, 96, -104, 39, -47, -103, 47, -76, 46, 14, 42, 73, -116, 65};\n+        b[156] = new byte[]{40, 124, -45, 106, 85, 61, -64, -12, -89, 34, 56, 121, -125, 71, -121, -117, 81, -44, 104, 91, -97, -60, -102, 87, -90, 48, -34, -48, -35, -16, 16, -94, 13, -87, -72, 51, -123, -72, -9, 41, -2, 42, 90, 54, -10, 119, 80, 62, -48, -55, 110, -10, -42, 5, -2, 64, 61, 56, -40, -35, 107, -104, -40, 125, 24, 2, 30, 110, 102, 82, -72, -44, -47, 48, 50, 79, -79, 16, 21, -99, -82, -23, 97, 74, -2, -63, 71, 63, -17, -78, 112, -108, 36, -14, 78, -54, 44, -11, 22, 3, -109, -106, 73, -52, -75, 16, -17, -99, 96, 94, 29, -46, -66, -118, -28, -17, -69, 31, -6, -23, -110, 124, 77, -24, -49, 69, -108, -1, 44, 31, -51, -61, 92, -83, 82, 119, -27, 23, 47, 125, -125, -5, -121, -27, 23, -97, 52, 21, -90, 121, 7, 116, -28, -57, 119, 71};\n+        b[157] = new byte[]{70, -78, 85, -60, -126, -88, 13, 123, 66, -66, 37, -116, -65, -12, -105, 48, -18, 54, 14, 126, -108, 88, -30, -125, -53, 104, 97, -40, 4, -105, -78, -60, -12, 123, -31, -70, -101, -79, 117, -37, 125, 34, 37, 105, 68, 55, 76, 1, 71, -54, 126, 6, 84, -35, 6, 20, 43, -97, 110, 116, -9, -61, -9, 43, 94, -85, 6, 102, 105, -49, 15, -7, 118, 103, -84, 32, -100, 97, 96, -10, -116, -32, 104, -102, 58, 12, -19, 22, 59, -110, 113, 56, 36, -103, 93, 9, -105, -5, -39, -11, -32, -105, 116, 69, 77, 33, 39, -105, -112, -120, -79, 51, -118, 108, -79, 49, 110, 81, 94, -49, 99, -11, 41, -51, -40, -7, -26, -80, -54, 24, -70, -11, 121, 62, -64, 21, 84, -115, 63, 125, 15, -124, -65, 51, 102, -49, 12, 0, -38, -118, 5, -30, -127, 4, 59, -19, -61};\n+        b[158] = new byte[]{-77, 46, 45, -26, -79, 64, -17, -111, -111, 4, 79, -125, -87, -81, 108, 67, 24, -49, -106, -30, -83, -4, -103, -60, 99, -98, 32, -72, 121, -54, -87, -57, 38, -57, 113, -58, -117, 34, 116, -115, 64, 62, 122, -34, 23, 59, -59, -32, -21, -36, 2, 3, -36, 85, -60, -106, 80, 47, -67, -13, -13, 73, -107, 124, -121, -8, -36, 114, 10, 59, 24, 49, 79, 98, 35, 27, -79, 10, 48, -32, -1, -85, 30, -115, -100, -60, -17, 123, -128, 107, -54, 8, 11, -75, -78, -48, 81, -28, 95, -122, -72, -112, 121, -114, -31, -21, -101, 67, -10, 39, -85, -123, -57, 23, -95, 112, -23, 26, 121, -127, -97, -39, -74, 5, 3, -5, -13, 47, -112, -123, -50, 30, 34, -58, -73, 45, -52, 91, 64, -107, 8, -62, -11, 17, -116, 90, 127, -82, 3, 3, -18, 88, 78, 45, -70, 26, -1, 102};\n+        b[159] = new byte[]{102, -49, -63, 124, 90, 22, 34, 102, 26, -69, 103, 89, 45, -66, -55, -99, -25, -109, 66, -98, -20, 67, 78, -78, -94, 113, 42, -47, -122, -72, 4, -45, -119, 27, 47, -7, 116, 97, -8, -38, -116, -19, -48, -6, 79, -40, -122, 127, 75, -97, 23, -19, -21, 21, -127, -50, -93, 3, 92, -73, 5, -52, 99, -36, -61, -24, 14, 52, 9, 73, -111, -59, 18, -44, 119, 27, 125, 83, -15, -31, 121, 58, -109, -43, 11, -121, 112, -10, -49, 92, -106, 89, 76, -45, -101, 111, 113, -23, -84, -80, -73, 92, 119, -50, 84, 63, -4, 65, 104, 58, -26, -92, 9, 124, 100, 52, -100, -17, 124, -33, -108, -83, -25, 39, 15, 30, -48, 116, 5, 98, 123, 77, -98, 86, 79, 23, 44, -78, 4, -79, -25, 47, 39, 27, -24, -103, 111, -85, -79, 118, 58, -86, -39, 71, -31, 87, 102, 114, -9};\n+        b[160] = new byte[]{-123, -41, -125, 38, -28, 103, -103, -65, 42, -12, 70, 30, 115, -49, -97, -70, -44, -1, 10, -6, -95, -90, -86, 20, 118, -39, -122, -24, 77, -11, 70, -74, 9, 14, -49, 122, 51, -107, -97, -98, 15, 116, 32, 74, -85, -99, -58, 94, -30, -75, 88, 14, -121, 17, 100, -83, -73, 118, -6, -83, 37, -93, -31, 77, 64, 87, 94, 30, 54, 35, 35, 37, 82, 122, -24, -21, -46, -120, -5, 78, -7, 22, -10, 24, -62, 5, 90, 81, -35, 116, -81, -79, 49, 88, -50, 89, -20, 48, -112, -37, 31, 19, -101, 89, -98, 43, 102, 2, 76, -7, 5, -43, 85, -41, 123, 25, 117, 82, 54, 2, -99, 20, 46, 67, 26, 105, 118, -118, 97, 51, 10, -24, 36, -81, 21, -86, 82, 91, 20, 91, 37, 114, 20, -46, 4, 91, -120, -17, 8, 28, 119, 47, -97, -4, -79, -52, 108, -53, 46, -79};\n+        b[161] = new byte[]{10, 80, -126, 58, -3, 38, 15, -33, -1, 45, 29, 14, -118, -63, -33, 106, 108, 92, 78, -7, -91, -64, -62, -32, 0, -124, 45, -34, 22, -50, -115, 19, -28, 95, 1, 32, 104, 60, -49, -46, -18, -117, 55, -64, 77, -63, -45, -107, -61, -30, -31, -83, -68, -52, 35, -52, -48, -52, 123, -24, -18, 97, -113, -111, 2, 2, 121, -24, -90, -1, 31, -79, -104, 99, -48, -74, 101, -89, 95, 16, -106, -120, -67, 110, 127, -1, 30, 71, -107, -82, -53, -47, 43, -14, -55, 19, 7, -54, -58, -29, -5, -101, 111, 107, 44, -68, 41, 46, 108, -26, -49, 2, 67, 18, 58, 1, 103, 95, -43, 45, -58, 112, -115, -29, -23, -52, 53, 93, -81, -66, 126, 49, 49, 52, -81, -67, 12, -104, 89, -20, 31, -98, 83, 100, 126, 84, -14, -67, -83, 94, -92, 79, 81, 85, 109, -111, -87, 27, 73, -118, 70};\n+        b[162] = new byte[]{22, -49, -128, -104, 80, -89, 82, -65, -30, -101, 15, 3, -48, 106, 77, -119, -46, 15, -10, -84, 22, -13, 36, 64, -50, 107, 106, 61, 47, -81, 79, -87, -7, 83, -122, 5, 65, -54, 96, 111, 57, -21, 96, -18, 19, 62, -87, 21, 23, 106, 51, -42, 106, 96, 45, -126, 32, -57, -5, -74, 94, -54, -19, -106, 49, -105, -29, -94, -33, 99, -61, -78, 80, -10, -80, -29, -9, 90, -33, -60, 6, -98, 10, 8, -107, 45, -100, 55, 77, 92, -128, -35, -34, 125, 40, -52, -106, 118, 69, -93, 92, 124, 79, -38, 116, 54, 125, 72, -127, 24, 30, -68, -25, 121, 123, 53, 84, 47, -75, -99, 99, -73, -98, -120, 77, 105, 93, 119, 6, 6, 0, -40, -97, -77, 67, 66, -104, 116, 116, 46, -121, 14, 80, 98, 75, -34, 91, 12, 87, 25, -5, -95, 88, -118, 1, 56, 91, 38, -23, -80, -31, -53};\n+        b[163] = new byte[]{-62, 3, -72, 13, -47, -103, -53, -40, 53, -36, -117, -114, -122, 66, 70, 37, -60, -24, -56, -69, -126, 5, 89, -67, 79, -9, 60, -87, -114, 13, 58, 23, -107, 83, 83, 86, -38, 15, 44, 60, -118, 62, 70, 33, 44, 73, 36, -4, -77, 30, -66, 38, 31, -64, -2, 70, -126, -59, -117, -55, -12, 43, 32, -100, 24, -39, 48, -59, -111, -79, -35, -4, -36, 118, 64, -96, -101, 100, -57, 2, -81, -54, -121, -105, -49, 48, -2, -90, -31, 111, -88, -92, 1, 16, -86, -27, 4, 76, 31, 125, 120, 75, 14, -127, 80, 1, 109, -78, 113, -117, 65, 27, 59, 101, -48, 107, 20, -74, -125, -88, 111, 105, -17, -18, 39, -89, -57, 92, 67, -24, -93, 89, 53, -84, 88, -57, 99, -101, 68, 6, 18, -3, -17, 11, 75, 122, 96, -27, -39, 46, -12, -61, -63, -89, 85, -11, -38, 111, 25, 33, 116, 64, 107};\n+        b[164] = new byte[]{18, 69, -19, -45, 100, -102, 69, 66, 35, 22, 106, 11, -57, 35, -70, 55, -24, 34, 47, -120, -128, -31, -10, 52, 19, 22, -88, -6, 104, -32, 17, -10, 126, 90, -2, -80, -9, -111, -105, 28, 18, 53, -58, 86, 12, 84, -71, 14, 114, 123, -67, -99, -21, 28, -67, -59, -48, 31, 67, -85, -88, -65, 110, 126, -118, -60, 81, 49, -109, 74, 13, -100, -117, -82, -26, -32, 106, -16, 2, -68, -116, -53, -18, 94, 82, -114, -5, 67, -111, -87, 88, -89, -20, -125, -55, -61, 108, 63, 26, -34, 5, 8, -1, -47, 4, -46, -64, -115, -89, -69, 76, 104, -84, 40, 39, -98, -100, -58, 22, -58, -35, 50, 88, -90, -91, -109, -90, -83, -1, 75, 122, -69, -21, 31, -73, 17, 50, -2, -49, 24, 122, 16, -56, 124, 48, -109, -33, 89, -62, 49, -108, 52, -69, 122, -14, -86, 116, -8, 18, -45, 66, -96, 82, -39};\n+        b[165] = new byte[]{58, -32, 106, -57, -110, -59, 38, -70, 17, 108, 57, -8, -41, -18, 26, -52, 81, -27, 42, 12, 58, 108, -56, 27, -79, 17, -102, 43, -43, 39, 62, -8, -71, -59, -7, -107, -31, 34, -48, -39, -116, -56, -122, -118, 70, -117, 81, 121, -20, -66, -81, 42, -23, 26, 91, 69, -27, 22, 79, -59, 127, -108, -35, -28, -125, 2, -19, 79, -92, -67, 114, -91, 127, -57, -58, 32, -124, 60, 21, -95, -56, -46, -10, -56, 95, -49, 78, 38, 80, 106, -108, -128, -86, 126, -44, -115, -119, 84, 113, -75, -95, 62, 104, 40, 116, -84, 26, 3, 126, 3, -16, -72, 47, 42, 4, 45, -76, 35, 83, -73, 100, -69, -118, 125, -27, 21, 26, 67, 14, 44, 69, -98, 100, -76, -70, -102, 103, 39, -35, -60, -124, 70, 63, 104, -3, -47, 37, -15, 6, 48, 66, -8, 71, -7, 81, -70, 97, 97, 127, -1, 41, 34, -43, 91, -68};\n+        b[166] = new byte[]{72, -17, -17, 14, -54, -103, 13, -46, 38, 57, -47, -11, -10, -58, 72, -20, 85, 21, -122, 92, 117, 16, -115, 23, 70, -65, 0, -83, 59, -128, 27, -111, 124, 44, 50, -69, -24, 23, 45, -40, 46, -33, 93, 53, 40, -62, 41, 87, -100, -107, -95, 67, 27, -37, 26, 43, -91, -111, 65, -110, -71, 88, -43, 63, 93, -77, 105, -49, 91, 74, 20, 105, -81, 82, -9, -71, -57, 94, -18, 125, 95, -9, 47, -51, 112, 114, 66, -63, -38, -109, 46, -82, -47, 99, 40, 8, -75, 14, 41, -91, 1, -94, 63, -40, -41, 127, 96, -25, -2, -87, -107, 101, -108, -31, -7, 38, 55, 1, -112, -120, 75, -29, -107, -93, 98, -64, -119, -126, 71, 90, 124, -13, -95, 127, 25, -73, -25, 78, 98, 35, -128, -3, -108, 10, 102, 39, -107, 38, 87, 60, -110, -49, -74, -58, -90, 15, 15, -98, 94, 31, 70, -19, 102, 126, 97, -52};\n+        b[167] = new byte[]{-75, -110, -1, -88, 0, -116, 59, -44, -77, -102, 2, 97, 89, 3, 44, 108, -88, 4, -26, 83, -64, 17, -68, 103, -36, -44, 123, -25, 78, 34, -106, 0, 43, 71, -56, -5, -70, -3, 74, 23, -114, -82, 67, 40, -21, -112, 73, -14, 6, -118, -26, 96, 31, -6, -100, -79, -91, 30, 27, 122, -40, -124, 31, -76, -58, 31, -26, 1, -23, 28, 87, -45, -66, -23, 17, 40, 95, 59, -37, -52, -120, 96, 0, 24, 28, -12, 63, 90, 49, -13, 29, -43, 82, -87, 66, 106, 23, 102, -68, 68, 78, -110, -66, -10, 62, 41, 34, -106, 44, -59, 55, -122, 57, -11, 127, -89, 106, 95, -97, 125, -123, -128, -5, 2, 118, -49, 25, 58, 69, 40, 53, 57, -80, -79, 78, 93, -69, -78, -99, 77, 108, 61, 72, 79, -7, -82, 7, 122, -1, 114, 53, 78, -102, -76, -80, -24, -32, 41, 23, -3, -118, -73, 21, -70, 86, 86, -28};\n+        b[168] = new byte[]{25, 23, -69, -72, 93, 112, 31, -97, -5, -44, 29, -17, -104, 97, 126, -92, -35, -57, -12, -14, -114, -42, -46, -16, -78, 118, -12, 15, -113, -49, -101, -77, -18, -28, -96, 30, -32, -25, -34, -106, 71, -59, 32, 24, 50, -114, -22, 25, -82, -105, -124, -112, 102, 103, 111, -22, -97, -8, -87, -5, 42, -35, 97, 15, 6, 43, -4, -58, -3, 123, 11, -80, 57, 123, 27, 34, -110, -48, 50, 7, -31, -48, -114, 87, -80, -6, -42, -95, -57, 110, 87, 57, -2, -69, -9, 38, -35, -54, -12, 103, 93, 115, -77, 29, 0, 102, 52, -22, -66, -55, 64, 10, 64, -22, -118, -85, -104, -29, 82, 97, -76, 103, 92, -37, 100, 66, -68, -122, 40, -101, 105, 126, -49, 51, 8, 51, 32, -113, -80, 119, -126, 72, 29, 76, 6, -17, 4, 88, -83, -30, 63, -76, -125, -35, -43, -83, -73, 12, -52, -125, 76, 90, -98, -125, -61, -126, 77, 20};\n+        b[169] = new byte[]{-16, 16, -59, -69, -19, -67, -106, -101, 101, 25, 40, -36, 101, -18, -32, -123, 102, -108, -128, -116, -37, -71, 74, 76, -27, 112, -59, 110, -46, 85, 64, -15, 29, -35, -80, 4, -47, -63, -111, -107, 1, 61, 18, 18, -105, -117, -110, 127, 34, -55, 24, 54, -76, 55, -25, -69, 65, -124, 15, -108, 52, 51, 87, 10, 38, -45, -40, 6, 70, -89, 53, -128, 115, 1, 58, 116, -1, -75, -32, 91, -111, 47, -111, -79, -86, 31, -19, 122, -29, -40, 42, -66, 72, 34, 126, -52, -35, 38, -32, 59, 39, 33, 103, 50, -56, -20, 113, -126, -67, 88, 65, 82, 34, 65, -69, -54, 43, 35, 117, -90, 0, -123, 92, 82, 16, 44, 48, 97, -20, 22, -9, -100, -109, -10, 66, 93, 0, 62, 82, -81, -42, 86, 117, -75, 84, -37, 58, -123, 41, -120, -122, -64, 5, 115, -99, 106, -78, 107, 16, 43, 78, -13, -39, 106, 109, -57, -118, -47, -113};\n+        b[170] = new byte[]{-78, 35, -46, 92, 62, 46, -33, -91, -104, -75, 59, -17, 15, 52, 101, 20, -8, -82, 100, -55, -47, 115, 58, -53, -35, -32, 53, -25, -34, 121, 36, 48, -100, -21, -11, 118, 10, -5, -70, -101, -15, -49, 59, -94, 113, -94, 12, 78, -47, -90, 19, 103, -101, 94, -115, -128, -50, 33, -104, 1, -53, -115, 3, -127, 70, 76, -88, -14, 118, 34, -106, 35, -78, 101, 27, -114, 50, 84, -14, -17, -50, -89, 8, 76, -94, 126, 118, -26, 109, -17, -48, 70, 37, -65, 40, -10, 66, -99, -23, -64, 82, -125, -110, -7, -36, 43, 118, -115, -116, -35, -54, 105, -91, -6, 30, -30, 50, -22, 76, -86, -80, 57, 116, 5, 49, 39, 7, -104, -119, -56, 114, -47, 4, 41, 30, -50, 116, -54, -45, 95, 110, -29, -58, 31, -78, -68, -10, -96, 107, -103, 113, 108, -51, -113, -97, -17, 40, -57, 113, 64, -8, -78, 39, -47, 7, -54, -116, 124, 2, -71};\n+        b[171] = new byte[]{-5, -3, 120, 62, 113, 80, 85, -98, -63, 76, 114, -108, -66, 68, -19, 70, -74, 18, -19, 105, -49, 52, 62, 96, 103, -106, -14, 50, 21, 43, 12, -71, 9, 107, -91, 15, 5, 94, -13, -46, 122, -61, 50, 39, -60, -93, -9, 80, 125, 74, -73, 18, 48, -94, 27, -84, 70, 86, 26, -44, -68, 12, -32, -58, -93, -112, 101, 53, -75, 99, -38, 125, 51, 66, -106, 91, -31, 52, 94, -16, -112, -90, -111, -59, -90, -29, 42, 23, 91, -40, -80, 93, 14, 15, -96, 12, -120, 79, 73, -76, 105, -42, -77, 114, 92, 105, 99, -1, 92, 17, 127, 10, -8, 80, -108, 81, -101, 30, 45, -33, 110, -80, -1, -123, -92, -60, 6, 121, -87, 37, 96, 96, 49, -46, -85, -119, -73, 91, 92, 123, 65, 72, 86, 118, 51, 48, -105, -39, -32, -19, -58, -128, -35, 69, -47, 21, 26, -50, 47, -2, -81, 32, 84, 20, -66, 90, -55, -39, -35, 52, -59};\n+        b[172] = new byte[]{-33, 82, 53, -115, -81, -127, -7, -86, 41, 42, 76, -19, 27, 50, 88, -68, -111, 22, 2, -56, 114, -96, 0, 21, -25, 43, -34, -32, -71, -49, -46, 71, 72, -103, 68, 26, 84, 68, -46, -70, -114, 66, 12, -122, 43, -17, 51, 60, 48, 32, -11, 121, -125, -23, 46, 39, 38, 26, 112, 62, 11, -35, -69, -93, -44, 6, 1, 82, -9, 114, -45, -65, 12, 37, -95, 54, 41, -42, -20, -39, -98, 96, -125, 62, -93, -121, 98, 40, 25, 3, 62, 49, -26, 73, 102, -66, -98, -82, 39, -81, -24, 14, 106, -98, 2, -73, 2, -10, -63, 109, -127, -27, -118, -83, -37, -86, 74, -128, -33, 110, 1, 78, 66, -103, 50, -10, -22, 22, 5, -128, -63, 14, 101, -6, -28, 67, -75, -35, 96, 108, -74, 8, -33, 17, 36, -71, -93, 121, 33, 85, 84, -48, 70, -4, 84, -38, 43, -69, 105, -69, 45, 11, 65, 41, 36, -93, -84, 28, -52, 22, 6, 122};\n+        b[173] = new byte[]{93, -76, 95, 14, -95, -98, -35, -25, -120, -42, -47, -15, -15, 73, -49, -99, -32, -63, -25, -77, 124, 85, -28, -110, -51, 124, -43, 8, -44, -96, -60, -31, 31, 119, -89, 127, -70, 126, 66, 15, 17, -58, -6, 110, 48, -34, -46, 27, -75, 41, 50, -31, 29, -66, -52, -63, 126, 75, -105, 17, -67, 51, -80, 103, -5, -34, 122, 6, 45, 44, -92, -15, 3, 73, -107, 121, -43, -117, 22, 71, -31, -2, -2, 13, -128, -14, 126, 52, 69, 62, 115, 41, 91, 73, 38, 75, 1, -32, 104, 124, 59, -24, 39, 9, -40, 42, -24, -51, -40, -95, 90, -16, -15, -128, -58, -67, -40, -14, -68, -73, -87, -39, 18, -16, -26, -11, 102, 33, -40, 2, 98, -17, 41, 47, 108, 25, -65, -17, -115, 59, -47, -53, -26, -72, 67, -71, 14, 122, -101, 38, -20, -10, 34, -78, 41, -54, 122, 80, 64, -68, 57, -29, -106, 46, -65, -108, -21, -83, 26, -73, -89, -115, 126};\n+        b[174] = new byte[]{-116, 97, 35, -4, 6, -127, 121, -10, -100, -10, -29, -100, -104, 107, -114, -10, 113, -2, 55, -20, -52, -80, 46, 42, 1, -18, -103, 80, 67, 12, 33, 119, 83, 26, 116, -106, -105, -75, -19, -45, -7, -54, -85, 35, -93, -35, -111, -10, -29, -47, -16, -112, -97, 27, -97, -112, -66, -47, -68, -50, -91, 13, 94, 3, 115, -15, 18, -82, -111, 124, -93, 43, -116, 114, 79, 38, 100, -39, 94, -76, -124, 73, 56, -33, -113, 122, 13, 45, 79, -62, -86, -96, -50, -87, -33, 51, -99, 56, 13, -22, 123, -25, 81, -48, -98, 74, -46, -52, -121, -42, -26, 88, 93, 126, -48, 109, 117, -100, 60, 32, -24, 100, 22, 89, 13, 51, -115, 80, -45, -85, -104, -5, -95, -59, -36, 20, -20, -108, 114, -19, 28, -54, 94, 88, 13, -59, 15, -46, 45, -90, 3, 98, 110, -106, 82, 39, 83, 107, -127, -75, -18, -25, 78, -121, -110, 24, 29, -59, 39, 18, -82, 120, 22, -17};\n+        b[175] = new byte[]{68, 12, -51, 11, 25, 79, -39, 47, -4, 45, -10, -58, -74, 84, -125, 74, 26, 49, -15, -60, -96, -104, -109, 14, 115, 108, 79, 22, -49, 30, -127, -107, 73, -117, 9, 102, -99, 45, -38, 5, 98, -113, 69, -74, -15, -111, -104, -107, 85, -119, 110, -32, 99, 73, 55, 6, -24, 113, -50, -99, -126, -71, 118, -16, 117, -64, -79, -120, -92, 19, -100, 48, -95, 13, 76, 120, -30, 86, 83, 124, -13, 22, 38, 4, 54, 30, -46, 44, 20, 31, -115, 83, -48, 30, -25, 28, -74, -65, 15, -23, 25, 123, 96, -66, 112, 29, -49, -102, 11, -23, -67, -39, 29, -37, -97, 57, -71, -82, -99, 79, 120, 121, -69, -69, 60, -74, -119, 69, 13, -47, -56, 31, 111, 2, 120, 22, -70, 87, -123, 83, 19, -80, 5, 41, 77, -72, 53, -5, 77, -5, 17, 103, 6, 58, -20, 98, -81, -121, 70, -37, 16, 95, -128, -20, 26, -7, -24, -59, 30, 76, 59, -53, 66, -42, 71};\n+        b[176] = new byte[]{-45, -56, 102, 102, -101, 65, 24, -94, -86, 71, -92, 51, -12, 99, 92, -39, 105, 53, 122, -40, 20, -4, -86, 32, 110, 35, -48, -104, 8, 121, 33, 121, 83, 5, -49, 123, 14, -31, 19, -96, -66, 1, 111, -49, 61, -99, -13, -101, 85, 15, -42, 122, 89, -94, 9, 47, 48, 18, 52, -127, 118, 105, -27, -110, 69, 59, -3, -66, 84, 79, 115, -8, -109, 90, 65, -23, -100, 79, 31, -44, 37, 118, 62, 90, 107, 57, 0, -1, 32, -101, -46, 76, -61, 124, -103, 92, 116, 83, -95, -43, -32, 28, -69, -110, -17, -63, 53, -50, -117, 57, -113, -62, -64, -17, 36, 73, -50, -111, -96, -39, -84, -95, 18, 102, -56, 108, 29, 77, -128, -24, -52, 122, 107, 9, 61, -2, -118, -33, -22, 32, 101, 36, 116, 8, 32, 125, -27, -30, -115, -37, -42, 12, 118, 76, -42, -1, -123, 72, 29, 2, 92, 45, 64, 56, 111, 40, -19, -20, -112, 29, 15, 75, -22, -36, 88, 12};\n+        b[177] = new byte[]{-48, 104, 107, -127, -76, -110, 28, -14, -42, -73, 36, -74, -102, 116, -79, -84, -48, 35, -3, -36, -85, 21, 7, 49, 34, 3, -29, 79, -65, -69, -15, 38, 117, 101, 49, -100, -45, 123, -20, -102, 86, 120, 103, -10, -50, 59, -50, 4, -9, 34, -101, -107, -94, 57, 117, 33, -43, 94, -68, 121, -20, -67, 36, -118, 66, -4, -74, 2, -126, -80, 9, 20, 52, -19, -27, -1, -116, -17, -28, 87, -62, -83, 20, -32, 27, 30, 44, 21, 49, 65, -44, -45, 92, 45, -52, 26, -126, 75, -59, -51, -41, -69, -21, -128, -29, 98, 104, -8, 97, -104, 88, -79, 116, -103, 9, 82, -94, -46, -21, -71, 51, -57, -23, -128, 96, -39, -11, 67, 18, 21, 29, 52, -15, -58, -31, 104, -118, 5, 45, 100, -128, 54, -88, -115, 37, -124, -81, 77, 6, 97, 25, 103, -53, -76, -125, -58, 44, -33, -96, 32, -29, 28, 104, -88, 113, -43, -66, 111, -125, -93, -104, 75, 62, -110, 112, 3, 63};\n+        b[178] = new byte[]{-39, 81, -94, 49, 95, -33, -38, 19, 89, 2, 60, 55, 125, -41, -121, -57, -4, 17, 33, 92, -34, 63, 77, 124, -107, -100, -89, -49, 4, -78, 72, 111, -13, 64, 28, 114, 70, 104, -73, 98, 98, -107, 102, 104, 119, 104, -101, -89, -70, 42, -90, -67, -37, 116, -112, -98, -91, 95, -77, 60, 5, -88, -40, 28, -16, -127, -110, -94, 78, -57, -54, 15, 39, -14, -75, -96, 0, -15, 86, 9, -38, -67, -98, -67, 116, -90, 43, 75, 47, 127, 62, 110, -84, 31, 24, -59, -83, -44, -77, -11, 55, -91, 80, -81, 108, -126, -127, 83, 89, 46, -122, -58, 12, -42, 18, -91, -47, 4, 48, -23, 25, 73, -20, 53, -76, -124, 113, 98, -49, 41, 82, -51, 54, -122, 0, 114, 91, 88, -9, -62, 89, 104, -44, -103, 5, 119, 41, 107, -47, 94, 72, -34, -20, 85, 78, 55, -85, 98, 4, 112, 60, 119, 102, 66, 115, 68, -102, 101, -2, 86, -5, -97, -24, -81, 51, 5, -1, 57};\n+        b[179] = new byte[]{-120, -60, -126, -121, 89, -71, -67, -53, 119, 11, -78, -60, -97, -100, 10, 69, -117, 90, -105, 59, -58, -22, -110, -102, -124, 109, 125, -83, 54, -6, 103, -38, -69, -7, -69, -125, -80, -62, -7, -56, -50, -115, -88, 59, -24, 87, 27, 119, 14, -2, -54, 71, 7, 82, -33, 17, -65, 63, 38, -5, 108, -111, -81, 67, 102, -72, 22, 20, 103, 77, -82, 7, -68, -5, -27, -35, -54, 73, 116, -56, 2, 10, -5, 23, 121, 117, -24, 48, -66, 41, 31, 49, 101, -92, -3, 27, 54, -61, 40, -70, -103, -95, 67, 73, 33, 1, 110, 117, 60, 10, -8, 7, 94, -71, -69, 92, -71, 80, -70, 107, -69, 17, 62, 116, 108, 127, 28, -107, 16, -56, -57, -58, -124, -28, -103, -26, 48, -54, 43, 16, -7, 76, -42, 16, -112, 49, 24, -37, -59, -22, -106, 126, -123, -113, -57, 110, -51, 2, -13, 48, -120, 18, -96, 63, 10, 25, -110, -125, -14, 57, -70, -3, -1, 21, -62, -9, -8, -36, -47};\n+        b[180] = new byte[]{-124, -34, 62, -57, -5, 10, -12, 84, 89, -97, -103, 101, 107, 14, -1, 92, 49, -80, -122, -35, -63, 112, -116, 64, 20, -2, 9, -96, 106, -107, 64, 44, 60, 115, -110, 14, -107, 42, -118, 16, -27, 98, 98, -53, 53, -102, 123, -28, -93, -87, 21, -83, -51, -94, 48, 64, 60, -121, -60, 108, -80, -98, 29, 36, 26, 69, 13, -97, -37, -111, -24, 66, -54, 20, 38, 90, -101, 41, 102, -48, 47, 68, -34, 125, -102, 62, -89, -57, 68, -127, -126, 86, 6, 113, -61, -14, -82, 125, -34, -46, -21, -17, 24, -98, 103, 98, 104, -45, 3, -72, 42, 7, 70, 62, 20, 81, -128, 99, 8, 0, 59, 126, 57, -118, -100, 83, -84, -63, 108, -100, -97, 26, -9, 93, -58, -50, -102, 27, 37, -41, 7, -117, 14, 97, 126, -90, 10, -38, 42, -88, -15, 36, -13, 86, 88, -38, 24, -57, 57, 89, 44, -49, -21, -37, -59, 13, 49, -46, 75, 127, 88, 73, -10, -60, -13, -35, 19, 60, 24, 38};\n+    }\n+\n+    /**\n+     * Tests to make sure Base64's implementation of the org.apache.commons.codec.Encoder\n+     * interface is behaving identical to commons-codec-1.3.jar.\n+     * \n+     * @throws EncoderException problem\n+     */\n+    @Test\n+    public void testEncoder() throws EncoderException {\n+        Encoder enc = new Base64();\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                byte[] base64 = utf8(STRINGS[i]);\n+                byte[] binary = BYTES[i];\n+                boolean b = Arrays.equals(base64, (byte[]) enc.encode(binary));\n+                assertTrue(\"Encoder test-\" + i, b);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests to make sure Base64's implementation of the org.apache.commons.codec.Decoder\n+     * interface is behaving identical to commons-codec-1.3.jar.\n+     *\n+     * @throws DecoderException problem\n+     */    \n+    @Test\n+    public void testDecoder() throws DecoderException {\n+        Decoder dec = new Base64();\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                byte[] base64 = utf8(STRINGS[i]);\n+                byte[] binary = BYTES[i];\n+                boolean b = Arrays.equals(binary, (byte[]) dec.decode(base64));\n+                assertTrue(\"Decoder test-\" + i, b);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests to make sure Base64's implementation of the org.apache.commons.codec.BinaryEncoder\n+     * interface is behaving identical to commons-codec-1.3.jar.\n+     *\n+     * @throws EncoderException problem\n+     */        \n+    @Test\n+    public void testBinaryEncoder() throws EncoderException {\n+        BinaryEncoder enc = new Base64();\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                byte[] base64 = utf8(STRINGS[i]);\n+                byte[] binary = BYTES[i];\n+                boolean b = Arrays.equals(base64, enc.encode(binary));\n+                assertTrue(\"BinaryEncoder test-\" + i, b);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests to make sure Base64's implementation of the org.apache.commons.codec.BinaryDecoder\n+     * interface is behaving identical to commons-codec-1.3.jar.\n+     *\n+     * @throws DecoderException problem\n+     */    \n+    @Test\n+    public void testBinaryDecoder() throws DecoderException {\n+        BinaryDecoder dec = new Base64();\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                byte[] base64 = utf8(STRINGS[i]);\n+                byte[] binary = BYTES[i];\n+                boolean b = Arrays.equals(binary, dec.decode(base64));\n+                assertTrue(\"BinaryDecoder test-\" + i, b);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests to make sure Base64's implementation of Base64.encodeBase64()\n+     * static method is behaving identical to commons-codec-1.3.jar.\n+     *\n+     * @throws EncoderException problem\n+     */        \n+    @Test\n+    public void testStaticEncode() throws EncoderException {\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                byte[] base64 = utf8(STRINGS[i]);\n+                byte[] binary = BYTES[i];\n+                boolean b = Arrays.equals(base64, Base64.encodeBase64(binary));\n+                assertTrue(\"static Base64.encodeBase64() test-\" + i, b);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests to make sure Base64's implementation of Base64.decodeBase64()\n+     * static method is behaving identical to commons-codec-1.3.jar.\n+     *\n+     * @throws DecoderException problem\n+     */            \n+    @Test\n+    public void testStaticDecode() throws DecoderException {\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                byte[] base64 = utf8(STRINGS[i]);\n+                byte[] binary = BYTES[i];\n+                boolean b = Arrays.equals(binary, Base64.decodeBase64(base64));\n+                assertTrue(\"static Base64.decodeBase64() test-\" + i, b);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests to make sure Base64's implementation of Base64.encodeBase64Chunked()\n+     * static method is behaving identical to commons-codec-1.3.jar.\n+     *\n+     * @throws EncoderException problem\n+     */                \n+    @Test\n+    public void testStaticEncodeChunked() throws EncoderException {\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                byte[] base64Chunked = utf8(CHUNKED_STRINGS[i]);\n+                byte[] binary = BYTES[i];\n+                boolean b = Arrays.equals(base64Chunked, Base64.encodeBase64Chunked(binary));\n+                assertTrue(\"static Base64.encodeBase64Chunked() test-\" + i, b);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests to make sure Base64's implementation of Base64.decodeBase64()\n+     * static method is behaving identical to commons-codec-1.3.jar when\n+     * supplied with chunked input.\n+     *\n+     * @throws DecoderException problem\n+     */                \n+    @Test\n+    public void testStaticDecodeChunked() throws DecoderException {\n+        for (int i = 0; i < STRINGS.length; i++) {\n+            if (STRINGS[i] != null) {\n+                byte[] base64Chunked = utf8(CHUNKED_STRINGS[i]);\n+                byte[] binary = BYTES[i];\n+                boolean b = Arrays.equals(binary, Base64.decodeBase64(base64Chunked));\n+                assertTrue(\"static Base64.decodeBase64Chunked() test-\" + i, b);\n+            }\n+        }\n+    }\n+\n+    private static byte[] utf8(String s) {\n+\n+        // We would use commons-codec-1.4.jar own utility method for this, but we\n+        // need this class to be able to run against commons-codec-1.3.jar, hence the\n+        // duplication here.\n+        \n+        try {\n+            return s != null ? s.getBytes(\"UTF-8\") : null;\n+        } catch (UnsupportedEncodingException uee) {\n+            throw new IllegalStateException(uee.toString());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+\n+/**\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @since 1.4\n+ */\n+public class Base64InputStreamTest {\n+\n+    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+\n+    private final static byte[] LF = {(byte) '\\n'};\n+\n+    private static final String STRING_FIXTURE = \"Hello World\";\n+\n+    /**\n+     * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.\n+     */\n+    @Test\n+    public void testCodec105() throws IOException {\n+        Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\n+        try {\n+            for (int i = 0; i < 5; i++) {\n+                in.read();\n+            }\n+        } finally {\n+            in.close();\n+        }\n+    }\n+\n+    /**\n+     * Test for the CODEC-101 bug:  InputStream.read(byte[]) should never return 0\n+     * because Java's builtin InputStreamReader hates that.\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+    @Test\n+    public void testCodec101() throws Exception {\n+        byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n+        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n+        Base64InputStream in = new Base64InputStream(bais);\n+        byte[] result = new byte[8192];\n+        int c = in.read(result);\n+        assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n+\n+        c = in.read(result);\n+        assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n+    }\n+\n+    /**\n+     * Another test for the CODEC-101 bug:\n+     * In commons-codec-1.4 this test shows InputStreamReader explicitly hating an\n+     * InputStream.read(byte[]) return of 0:\n+     *\n+     * java.io.IOException: Underlying input stream returned zero bytes\n+     * at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268)\n+     * at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)\n+     * at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)\n+     * at java.io.InputStreamReader.read(InputStreamReader.java:167)\n+     * at java.io.BufferedReader.fill(BufferedReader.java:136)\n+     * at java.io.BufferedReader.readLine(BufferedReader.java:299)\n+     * at java.io.BufferedReader.readLine(BufferedReader.java:362)\n+     * at org.apache.commons.codec.binary.Base64InputStreamTest.testInputStreamReader(Base64InputStreamTest.java:75)\n+     *\n+     * But in commons-codec-1.5 it's fixed.  :-)\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+    @Test\n+    public void testInputStreamReader() throws Exception {\n+        byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n+        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n+        Base64InputStream in = new Base64InputStream(bais);\n+        InputStreamReader isr = new InputStreamReader(in);\n+        BufferedReader br = new BufferedReader(isr);\n+        String line = br.readLine();\n+        assertNotNull(\"Codec101:  InputStreamReader works!\", line);\n+    }\n+\n+    /**\n+     * Test the Base64InputStream implementation against the special NPE inducing input\n+     * identified in the CODEC-98 bug.\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+    @Test\n+    public void testCodec98NPE() throws Exception {\n+        byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n+        ByteArrayInputStream data = new ByteArrayInputStream(codec98);\n+        Base64InputStream stream = new Base64InputStream(data);\n+\n+        // This line causes an NPE in commons-codec-1.4.jar:\n+        byte[] decodedBytes = Base64TestData.streamToBytes(stream, new byte[1024]);\n+\n+        String decoded = StringUtils.newStringUtf8(decodedBytes);\n+        assertEquals(\n+            \"codec-98 NPE Base64InputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n+        );\n+    }\n+\n+    /**\n+     * Tests the Base64InputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase64EmptyInputStreamMimeChuckSize() throws Exception {\n+        testBase64EmptyInputStream(BaseNCodec.MIME_CHUNK_SIZE);\n+    }\n+\n+    /**\n+     * Tests the Base64InputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase64EmptyInputStreamPemChuckSize() throws Exception {\n+        testBase64EmptyInputStream(BaseNCodec.PEM_CHUNK_SIZE);\n+    }\n+\n+    private void testBase64EmptyInputStream(int chuckSize) throws Exception {\n+        byte[] emptyEncoded = new byte[0];\n+        byte[] emptyDecoded = new byte[0];\n+        testByteByByte(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n+        testByChunk(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n+    }\n+\n+    /**\n+     * Tests the Base64InputStream implementation.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase64InputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+        testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+        encoded = StringUtils.getBytesUtf8(singleLine);\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByChunk(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Tests the Base64InputStream implementation.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase64InputStreamByteByByte() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+        testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+        encoded = StringUtils.getBytesUtf8(singleLine);\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByteByByte(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        InputStream in = new ByteArrayInputStream(decoded);\n+        in = new Base64InputStream(in, true, chunkSize, seperator);\n+        byte[] output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        in = new ByteArrayInputStream(encoded);\n+        in = new Base64InputStream(in);\n+        output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        in = new ByteArrayInputStream(decoded);\n+        for (int i = 0; i < 10; i++) {\n+            in = new Base64InputStream(in, true, chunkSize, seperator);\n+            in = new Base64InputStream(in, false);\n+        }\n+        output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        InputStream in = new ByteArrayInputStream(decoded);\n+        in = new Base64InputStream(in, true, chunkSize, seperator);\n+        byte[] output = new byte[encoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        in = new ByteArrayInputStream(encoded);\n+        in = new Base64InputStream(in);\n+        output = new byte[decoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        in = new ByteArrayInputStream(decoded);\n+        for (int i = 0; i < 10; i++) {\n+            in = new Base64InputStream(in, true, chunkSize, seperator);\n+            in = new Base64InputStream(in, false);\n+        }\n+        output = new byte[decoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests markSupported.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMarkSupported() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        // Always returns false for now.\n+        assertFalse(\"Base64InputStream.markSupported() is false\", in.markSupported());\n+    }\n+\n+    /**\n+     * Tests read returning 0\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRead0() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] buf = new byte[1024];\n+        int bytesRead = 0;\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        bytesRead = in.read(buf, 0, 0);\n+        assertEquals(\"Base64InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n+    }\n+\n+    /**\n+     * Tests read with null.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testReadNull() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        try {\n+            in.read(null, 0, 0);\n+            fail(\"Base64InputStream.read(null, 0, 0) to throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Tests read throwing IndexOutOfBoundsException\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReadOutOfBounds() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] buf = new byte[1024];\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+\n+        try {\n+            in.read(buf, -1, 0);\n+            fail(\"Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, 0, -1);\n+            fail(\"Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, buf.length + 1, 0);\n+            fail(\"Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, buf.length - 1, 2);\n+            fail(\"Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+\n+/**\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @since 1.4\n+ */\n+public class Base64OutputStreamTest {\n+\n+    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+\n+    private final static byte[] LF = {(byte) '\\n'};\n+\n+    private static final String STRING_FIXTURE = \"Hello World\";\n+\n+    /**\n+     * Test the Base64OutputStream implementation against the special NPE inducing input\n+     * identified in the CODEC-98 bug.\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+    @Test\n+    public void testCodec98NPE() throws Exception {\n+        byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n+        byte[] codec98_1024 = new byte[1024];\n+        System.arraycopy(codec98, 0, codec98_1024, 0, codec98.length);\n+        ByteArrayOutputStream data = new ByteArrayOutputStream(1024);\n+        Base64OutputStream stream = new Base64OutputStream(data, false);\n+        stream.write(codec98_1024, 0, 1024);\n+        stream.close();\n+\n+        byte[] decodedBytes = data.toByteArray();\n+        String decoded = StringUtils.newStringUtf8(decodedBytes);\n+        assertEquals(\n+            \"codec-98 NPE Base64OutputStream\", Base64TestData.CODEC_98_NPE_DECODED, decoded\n+        );\n+    }\n+    \n+\n+    /**\n+     * Test the Base64OutputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase64EmptyOutputStreamMimeChunkSize() throws Exception {\n+        testBase64EmptyOutputStream(BaseNCodec.MIME_CHUNK_SIZE);\n+    }\n+\n+    /**\n+     * Test the Base64OutputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase64EmptyOutputStreamPemChunkSize() throws Exception {\n+        testBase64EmptyOutputStream(BaseNCodec.PEM_CHUNK_SIZE);\n+    }\n+\n+    private void testBase64EmptyOutputStream(int chunkSize) throws Exception {\n+        byte[] emptyEncoded = new byte[0];\n+        byte[] emptyDecoded = new byte[0];\n+        testByteByByte(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n+        testByChunk(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n+    }\n+\n+    /**\n+     * Test the Base64OutputStream implementation\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase64OutputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+        testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+        encoded = StringUtils.getBytesUtf8(singleLine);\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByChunk(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Test the Base64OutputStream implementation\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testBase64OutputStreamByteByByte() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, 64, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+        encoded = StringUtils.getBytesUtf8(singleLine);\n+        decoded = Base64TestData.DECODED;\n+        testByteByByte(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByteByByte(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n+     * mode over and over again.\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n+        out.write(decoded);\n+        out.close();\n+        byte[] output = byteOut.toByteArray();\n+        assertTrue(\"Streaming chunked base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base64OutputStream(byteOut, false);\n+        out.write(encoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming chunked base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        byteOut = new ByteArrayOutputStream();\n+        out = byteOut;\n+        for (int i = 0; i < 10; i++) {\n+            out = new Base64OutputStream(out, false);\n+            out = new Base64OutputStream(out, true, chunkSize, seperator);\n+        }\n+        out.write(decoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+\n+        assertTrue(\"Streaming chunked base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n+     * mode over and over again.\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n+        for (byte element : decoded) {\n+            out.write(element);\n+        }\n+        out.close();\n+        byte[] output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base64OutputStream(byteOut, false);\n+        for (byte element : encoded) {\n+            out.write(element);\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte base64 decode\", Arrays.equals(output, decoded));\n+\n+        // Now let's try decode with tonnes of flushes.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base64OutputStream(byteOut, false);\n+        for (byte element : encoded) {\n+            out.write(element);\n+            out.flush();\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte flush() base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        byteOut = new ByteArrayOutputStream();\n+        out = byteOut;\n+        for (int i = 0; i < 10; i++) {\n+            out = new Base64OutputStream(out, false);\n+            out = new Base64OutputStream(out, true, chunkSize, seperator);\n+        }\n+        for (byte element : decoded) {\n+            out.write(element);\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+\n+        assertTrue(\"Streaming byte-by-byte base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testWriteOutOfBounds() throws Exception {\n+        byte[] buf = new byte[1024];\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        Base64OutputStream out = new Base64OutputStream(bout);\n+\n+        try {\n+            out.write(buf, -1, 1);\n+            fail(\"Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, 1, -1);\n+            fail(\"Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, buf.length + 1, 0);\n+            fail(\"Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, buf.length - 1, 2);\n+            fail(\"Expected Base64OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Tests Base64OutputStream.write(null).\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    @Test\n+    public void testWriteToNullCoverage() throws Exception {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        Base64OutputStream out = new Base64OutputStream(bout);\n+        try {\n+            out.write(null, 0, 0);\n+            fail(\"Expcted Base64OutputStream.write(null) to throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // Expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.junit.Test;\n+\n+/**\n+ * Test cases for Base64 class.\n+ * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class Base64Test {\n+\n+    private final Random _random = new Random();\n+\n+    /**\n+     * @return Returns the _random.\n+     */\n+    public Random getRandom() {\n+        return this._random;\n+    }\n+\n+    /**\n+     * Test the isStringBase64 method.\n+     */\n+    @Test\n+    public void testIsStringBase64() {\n+        String nullString = null;\n+        String emptyString = \"\";\n+        String validString = \"abc===defg\\n\\r123456\\r789\\r\\rABC\\n\\nDEF==GHI\\r\\nJKL==============\";\n+        String invalidString = validString + ((char)0); // append null character\n+        \n+        try {\n+            Base64.isBase64(nullString);\n+            fail(\"Base64.isStringBase64() should not be null-safe.\");\n+        } catch (NullPointerException npe) {\n+            assertNotNull(\"Base64.isStringBase64() should not be null-safe.\", npe);\n+        }\n+        \n+        assertTrue(\"Base64.isStringBase64(empty-string) is true\", Base64.isBase64(emptyString));\n+        assertTrue(\"Base64.isStringBase64(valid-string) is true\", Base64.isBase64(validString));        \n+        assertFalse(\"Base64.isStringBase64(invalid-string) is false\", Base64.isBase64(invalidString));        \n+    }\n+    \n+    /**\n+     * Test the Base64 implementation\n+     */\n+    @Test\n+    public void testBase64() {\n+        String content = \"Hello World\";\n+        String encodedContent;\n+        byte[] encodedBytes = Base64.encodeBase64(StringUtils.getBytesUtf8(content));\n+        encodedContent = StringUtils.newStringUtf8(encodedBytes);\n+        assertTrue(\"encoding hello world\", encodedContent.equals(\"SGVsbG8gV29ybGQ=\"));\n+\n+        Base64 b64 = new Base64(BaseNCodec.MIME_CHUNK_SIZE, null);  // null lineSeparator same as saying no-chunking\n+        encodedBytes = b64.encode(StringUtils.getBytesUtf8(content));\n+        encodedContent = StringUtils.newStringUtf8(encodedBytes);\n+        assertTrue(\"encoding hello world\", encodedContent.equals(\"SGVsbG8gV29ybGQ=\"));\n+\n+        b64 = new Base64(0, null);  // null lineSeparator same as saying no-chunking\n+        encodedBytes = b64.encode(StringUtils.getBytesUtf8(content));\n+        encodedContent = StringUtils.newStringUtf8(encodedBytes);\n+        assertTrue(\"encoding hello world\", encodedContent.equals(\"SGVsbG8gV29ybGQ=\"));\n+\n+        // bogus characters to decode (to skip actually) {e-acute*6}\n+        byte[] decode = b64.decode(\"SGVsbG{\\u00e9\\u00e9\\u00e9\\u00e9\\u00e9\\u00e9}8gV29ybGQ=\");\n+        String decodeString = StringUtils.newStringUtf8(decode);\n+        assertTrue(\"decode hello world\", decodeString.equals(\"Hello World\"));        \n+    }\n+\n+    /**\n+     * Tests Base64.encodeBase64().\n+     */\n+    @Test\n+    public void testChunkedEncodeMultipleOf76() {\n+        byte[] expectedEncode = Base64.encodeBase64(Base64TestData.DECODED, true);\n+        // convert to \"\\r\\n\" so we're equal to the old openssl encoding test stored\n+        // in Base64TestData.ENCODED_76_CHARS_PER_LINE:\n+        String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll(\"\\n\", \"\\r\\n\");\n+        byte[] actualEncode = StringUtils.getBytesUtf8(actualResult);\n+        assertTrue(\"chunkedEncodeMultipleOf76\", Arrays.equals(expectedEncode, actualEncode));\n+    }\n+\n+    /**\n+     * CODEC-68: isBase64 throws ArrayIndexOutOfBoundsException on some non-BASE64 bytes\n+     */\n+    @Test\n+    public void testCodec68() {\n+        byte[] x = new byte[]{'n', 'A', '=', '=', (byte) 0x9c};\n+        Base64.decodeBase64(x);\n+    }\n+\n+    @Test\n+    public void testCodeInteger1() throws UnsupportedEncodingException {\n+        String encodedInt1 = \"li7dzDacuo67Jg7mtqEm2TRuOMU=\";\n+        BigInteger bigInt1 = new BigInteger(\"85739377120809420210425962799\" + \"0318636601332086981\");\n+\n+        assertEquals(encodedInt1, new String(Base64.encodeInteger(bigInt1)));\n+        assertEquals(bigInt1, Base64.decodeInteger(encodedInt1.getBytes(\"UTF-8\")));\n+    }\n+\n+    @Test\n+    public void testCodeInteger2() throws UnsupportedEncodingException {\n+        String encodedInt2 = \"9B5ypLY9pMOmtxCeTDHgwdNFeGs=\";\n+        BigInteger bigInt2 = new BigInteger(\"13936727572861167254666467268\" + \"91466679477132949611\");\n+\n+        assertEquals(encodedInt2, new String(Base64.encodeInteger(bigInt2)));\n+        assertEquals(bigInt2, Base64.decodeInteger(encodedInt2.getBytes(\"UTF-8\")));\n+    }\n+\n+    @Test\n+    public void testCodeInteger3() throws UnsupportedEncodingException {\n+        String encodedInt3 = \"FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2\" + \"rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg==\";\n+        BigInteger bigInt3 = new BigInteger(\"10806548154093873461951748545\"\n+            + \"1196989136416448805819079363524309897749044958112417136240557\"\n+            + \"4495062430572478766856090958495998158114332651671116876320938126\");\n+\n+        assertEquals(encodedInt3, new String(Base64.encodeInteger(bigInt3)));\n+        assertEquals(bigInt3, Base64.decodeInteger(encodedInt3.getBytes(\"UTF-8\")));\n+    }\n+\n+    @Test\n+    public void testCodeInteger4() throws UnsupportedEncodingException {\n+        String encodedInt4 = \"ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI\"\n+            + \"4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o\"\n+            + \"DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv\"\n+            + \"Q0=\";\n+        BigInteger bigInt4 = new BigInteger(\"80624726256040348115552042320\"\n+            + \"6968135001872753709424419772586693950232350200555646471175944\"\n+            + \"519297087885987040810778908507262272892702303774422853675597\"\n+            + \"748008534040890923814202286633163248086055216976551456088015\"\n+            + \"338880713818192088877057717530169381044092839402438015097654\"\n+            + \"53542091716518238707344493641683483917\");\n+\n+        assertEquals(encodedInt4, new String(Base64.encodeInteger(bigInt4)));\n+        assertEquals(bigInt4, Base64.decodeInteger(encodedInt4.getBytes(\"UTF-8\")));\n+    }\n+\n+    @Test\n+    public void testCodeIntegerEdgeCases() {\n+        // TODO\n+    }\n+\n+    @Test\n+    public void testCodeIntegerNull() {\n+        try {\n+            Base64.encodeInteger(null);\n+            fail(\"Exception not thrown when passing in null to encodeInteger(BigInteger)\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"Incorrect Exception caught when passing in null to encodeInteger(BigInteger)\");\n+        }\n+    }\n+\n+    @Test\n+    public void testConstructors() {\n+        Base64 base64;\n+        base64 = new Base64();\n+        base64 = new Base64(-1);\n+        base64 = new Base64(-1, new byte[]{});\n+        base64 = new Base64(64, new byte[]{});\n+        try {\n+            base64 = new Base64(-1, new byte[]{'A'}); // TODO do we need to check sep if len = -1?\n+            fail(\"Should have rejected attempt to use 'A' as a line separator\");\n+        } catch (IllegalArgumentException ignored) {\n+            // Expected\n+        }\n+        try {\n+            base64 = new Base64(64, new byte[]{'A'});\n+            fail(\"Should have rejected attempt to use 'A' as a line separator\");\n+        } catch (IllegalArgumentException ignored) {\n+            // Expected\n+        }\n+        try {\n+            base64 = new Base64(64, new byte[]{'='});\n+            fail(\"Should have rejected attempt to use '=' as a line separator\");\n+        } catch (IllegalArgumentException ignored) {\n+            // Expected\n+        }\n+        base64 = new Base64(64, new byte[]{'$'}); // OK\n+        try {\n+            base64 = new Base64(64, new byte[]{'A', '$'});\n+            fail(\"Should have rejected attempt to use 'A$' as a line separator\");\n+        } catch (IllegalArgumentException ignored) {\n+            // Expected\n+        }\n+        base64 = new Base64(64, new byte[]{' ', '$', '\\n', '\\r', '\\t'}); // OK\n+        assertNotNull(base64);\n+    }\n+\n+    @Test\n+    public void testConstructor_Int_ByteArray_Boolean() {\n+        Base64 base64 = new Base64(65, new byte[]{'\\t'}, false);\n+        byte[] encoded = base64.encode(Base64TestData.DECODED);\n+        String expectedResult = Base64TestData.ENCODED_64_CHARS_PER_LINE;\n+        expectedResult = expectedResult.replace('\\n', '\\t');\n+        String result = StringUtils.newStringUtf8(encoded);\n+        assertEquals(\"new Base64(65, \\\\t, false)\", expectedResult, result);\n+    }\n+\n+    @Test\n+    public void testConstructor_Int_ByteArray_Boolean_UrlSafe() {\n+        // url-safe variation\n+        Base64 base64 = new Base64(64, new byte[]{'\\t'}, true);\n+        byte[] encoded = base64.encode(Base64TestData.DECODED);\n+        String expectedResult = Base64TestData.ENCODED_64_CHARS_PER_LINE;\n+        expectedResult = expectedResult.replaceAll(\"=\", \"\"); // url-safe has no == padding.\n+        expectedResult = expectedResult.replace('\\n', '\\t');\n+        expectedResult = expectedResult.replace('+', '-');\n+        expectedResult = expectedResult.replace('/', '_');\n+        String result = StringUtils.newStringUtf8(encoded);\n+        assertEquals(\"new Base64(64, \\\\t, true)\", result, expectedResult);\n+    }\n+\n+    /**\n+     * Tests conditional true branch for \"marker0\" test.\n+     */\n+    @Test\n+    public void testDecodePadMarkerIndex2() throws UnsupportedEncodingException {\n+        assertEquals(\"A\", new String(Base64.decodeBase64(\"QQ==\".getBytes(\"UTF-8\"))));\n+    }\n+\n+    /**\n+     * Tests conditional branches for \"marker1\" test.\n+     */\n+    @Test\n+    public void testDecodePadMarkerIndex3() throws UnsupportedEncodingException {\n+        assertEquals(\"AA\", new String(Base64.decodeBase64(\"QUE=\".getBytes(\"UTF-8\"))));\n+        assertEquals(\"AAA\", new String(Base64.decodeBase64(\"QUFB\".getBytes(\"UTF-8\"))));\n+    }\n+\n+    @Test\n+    public void testDecodePadOnly() throws UnsupportedEncodingException {\n+        assertTrue(Base64.decodeBase64(\"====\".getBytes(\"UTF-8\")).length == 0);\n+        assertEquals(\"\", new String(Base64.decodeBase64(\"====\".getBytes(\"UTF-8\"))));\n+        // Test truncated padding\n+        assertTrue(Base64.decodeBase64(\"===\".getBytes(\"UTF-8\")).length == 0);\n+        assertTrue(Base64.decodeBase64(\"==\".getBytes(\"UTF-8\")).length == 0);\n+        assertTrue(Base64.decodeBase64(\"=\".getBytes(\"UTF-8\")).length == 0);\n+        assertTrue(Base64.decodeBase64(\"\".getBytes(\"UTF-8\")).length == 0);\n+    }\n+\n+    @Test\n+    public void testDecodePadOnlyChunked() throws UnsupportedEncodingException {\n+        assertTrue(Base64.decodeBase64(\"====\\n\".getBytes(\"UTF-8\")).length == 0);\n+        assertEquals(\"\", new String(Base64.decodeBase64(\"====\\n\".getBytes(\"UTF-8\"))));\n+        // Test truncated padding\n+        assertTrue(Base64.decodeBase64(\"===\\n\".getBytes(\"UTF-8\")).length == 0);\n+        assertTrue(Base64.decodeBase64(\"==\\n\".getBytes(\"UTF-8\")).length == 0);\n+        assertTrue(Base64.decodeBase64(\"=\\n\".getBytes(\"UTF-8\")).length == 0);\n+        assertTrue(Base64.decodeBase64(\"\\n\".getBytes(\"UTF-8\")).length == 0);\n+    }\n+\n+    @Test\n+    public void testDecodeWithWhitespace() throws Exception {\n+\n+        String orig = \"I am a late night coder.\";\n+\n+        byte[] encodedArray = Base64.encodeBase64(orig.getBytes(\"UTF-8\"));\n+        StringBuffer intermediate = new StringBuffer(new String(encodedArray));\n+\n+        intermediate.insert(2, ' ');\n+        intermediate.insert(5, '\\t');\n+        intermediate.insert(10, '\\r');\n+        intermediate.insert(15, '\\n');\n+\n+        byte[] encodedWithWS = intermediate.toString().getBytes(\"UTF-8\");\n+        byte[] decodedWithWS = Base64.decodeBase64(encodedWithWS);\n+\n+        String dest = new String(decodedWithWS);\n+\n+        assertTrue(\"Dest string doesn't equal the original\", dest.equals(orig));\n+    }\n+\n+    /**\n+     * Test encode and decode of empty byte array.\n+     */\n+    @Test\n+    public void testEmptyBase64() {\n+        byte[] empty = new byte[0];\n+        byte[] result = Base64.encodeBase64(empty);\n+        assertEquals(\"empty base64 encode\", 0, result.length);\n+        assertEquals(\"empty base64 encode\", null, Base64.encodeBase64(null));\n+\n+        empty = new byte[0];\n+        result = Base64.decodeBase64(empty);\n+        assertEquals(\"empty base64 decode\", 0, result.length);\n+        assertEquals(\"empty base64 encode\", null, Base64.decodeBase64((byte[]) null));\n+    }\n+\n+    // encode/decode a large random array\n+    @Test\n+    public void testEncodeDecodeRandom() {\n+        for (int i = 1; i < 5; i++) {\n+            byte[] data = new byte[this.getRandom().nextInt(10000) + 1];\n+            this.getRandom().nextBytes(data);\n+            byte[] enc = Base64.encodeBase64(data);\n+            assertTrue(Base64.isBase64(enc));\n+            byte[] data2 = Base64.decodeBase64(enc);\n+            assertTrue(Arrays.equals(data, data2));\n+        }\n+    }\n+\n+    // encode/decode random arrays from size 0 to size 11\n+    @Test\n+    public void testEncodeDecodeSmall() {\n+        for (int i = 0; i < 12; i++) {\n+            byte[] data = new byte[i];\n+            this.getRandom().nextBytes(data);\n+            byte[] enc = Base64.encodeBase64(data);\n+            assertTrue(\"\\\"\" + (new String(enc)) + \"\\\" is Base64 data.\", Base64.isBase64(enc));\n+            byte[] data2 = Base64.decodeBase64(enc);\n+            assertTrue(toString(data) + \" equals \" + toString(data2), Arrays.equals(data, data2));\n+        }\n+    }\n+\n+    @Test\n+    public void testEncodeOverMaxSize() throws Exception {\n+        testEncodeOverMaxSize(-1);\n+        testEncodeOverMaxSize(0);\n+        testEncodeOverMaxSize(1);\n+        testEncodeOverMaxSize(2);\n+    }\n+    \n+    @Test\n+    public void testCodec112() { // size calculation assumes always chunked\n+        byte[] in = new byte[] {0};\n+        byte[] out=Base64.encodeBase64(in);\n+        Base64.encodeBase64(in, false, false, out.length);\n+    }\n+\n+    private void testEncodeOverMaxSize(int maxSize) throws Exception {\n+        try {\n+            Base64.encodeBase64(Base64TestData.DECODED, true, false, maxSize);\n+            fail(\"Expected \" + IllegalArgumentException.class.getName());\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testIgnoringNonBase64InDecode() throws Exception {\n+        assertEquals(\"The quick brown fox jumped over the lazy dogs.\", new String(Base64\n+                .decodeBase64(\"VGhlIH@$#$@%F1aWN@#@#@@rIGJyb3duIGZve\\n\\r\\t%#%#%#%CBqd##$#$W1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==\".getBytes(\"UTF-8\"))));\n+    }\n+\n+    @Test\n+    public void testIsArrayByteBase64() {\n+        assertFalse(Base64.isBase64(new byte[]{Byte.MIN_VALUE}));\n+        assertFalse(Base64.isBase64(new byte[]{-125}));\n+        assertFalse(Base64.isBase64(new byte[]{-10}));\n+        assertFalse(Base64.isBase64(new byte[]{0}));\n+        assertFalse(Base64.isBase64(new byte[]{64, Byte.MAX_VALUE}));\n+        assertFalse(Base64.isBase64(new byte[]{Byte.MAX_VALUE}));\n+        assertTrue(Base64.isBase64(new byte[]{'A'}));\n+        assertFalse(Base64.isBase64(new byte[]{'A', Byte.MIN_VALUE}));\n+        assertTrue(Base64.isBase64(new byte[]{'A', 'Z', 'a'}));\n+        assertTrue(Base64.isBase64(new byte[]{'/', '=', '+'}));\n+        assertFalse(Base64.isBase64(new byte[]{'$'}));\n+    }\n+\n+    /**\n+     * Tests isUrlSafe.\n+     */\n+    @Test\n+    public void testIsUrlSafe() {\n+        Base64 base64Standard = new Base64(false);\n+        Base64 base64URLSafe = new Base64(true);\n+\n+        assertFalse(\"Base64.isUrlSafe=false\", base64Standard.isUrlSafe());\n+        assertTrue(\"Base64.isUrlSafe=true\", base64URLSafe.isUrlSafe());\n+\n+        byte[] whiteSpace = {' ', '\\n', '\\r', '\\t'};\n+        assertTrue(\"Base64.isBase64(whiteSpace)=true\", Base64.isBase64(whiteSpace));\n+    }\n+\n+    @Test\n+    public void testKnownDecodings() throws UnsupportedEncodingException {\n+        assertEquals(\"The quick brown fox jumped over the lazy dogs.\", new String(Base64\n+                .decodeBase64(\"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==\".getBytes(\"UTF-8\"))));\n+        assertEquals(\"It was the best of times, it was the worst of times.\", new String(Base64\n+                .decodeBase64(\"SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg==\".getBytes(\"UTF-8\"))));\n+        assertEquals(\"http://jakarta.apache.org/commmons\", new String(Base64\n+                .decodeBase64(\"aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw==\".getBytes(\"UTF-8\"))));\n+        assertEquals(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\", new String(Base64\n+                .decodeBase64(\"QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg==\".getBytes(\"UTF-8\"))));\n+        assertEquals(\"{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }\", new String(Base64.decodeBase64(\"eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0=\"\n+                .getBytes(\"UTF-8\"))));\n+        assertEquals(\"xyzzy!\", new String(Base64.decodeBase64(\"eHl6enkh\".getBytes(\"UTF-8\"))));\n+    }\n+\n+    @Test\n+    public void testKnownEncodings() throws UnsupportedEncodingException {\n+        assertEquals(\"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==\", new String(Base64\n+                .encodeBase64(\"The quick brown fox jumped over the lazy dogs.\".getBytes(\"UTF-8\"))));\n+        assertEquals(\n+                \"YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs\\r\\nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo\\r\\nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi\\r\\nbGFoIGJsYWg=\\r\\n\",\n+                new String(\n+                        Base64\n+                                .encodeBase64Chunked(\"blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah\"\n+                                        .getBytes(\"UTF-8\"))));\n+        assertEquals(\"SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg==\", new String(Base64\n+                .encodeBase64(\"It was the best of times, it was the worst of times.\".getBytes(\"UTF-8\"))));\n+        assertEquals(\"aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw==\", new String(Base64\n+                .encodeBase64(\"http://jakarta.apache.org/commmons\".getBytes(\"UTF-8\"))));\n+        assertEquals(\"QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg==\", new String(Base64\n+                .encodeBase64(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\".getBytes(\"UTF-8\"))));\n+        assertEquals(\"eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0=\", new String(Base64.encodeBase64(\"{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }\"\n+                .getBytes(\"UTF-8\"))));\n+        assertEquals(\"eHl6enkh\", new String(Base64.encodeBase64(\"xyzzy!\".getBytes(\"UTF-8\"))));\n+    }\n+\n+    @Test\n+    public void testNonBase64Test() throws Exception {\n+\n+        byte[] bArray = {'%'};\n+\n+        assertFalse(\"Invalid Base64 array was incorrectly validated as \" + \"an array of Base64 encoded data\", Base64\n+                .isBase64(bArray));\n+\n+        try {\n+            Base64 b64 = new Base64();\n+            byte[] result = b64.decode(bArray);\n+\n+            assertTrue(\"The result should be empty as the test encoded content did \" + \"not contain any valid base 64 characters\",\n+                    result.length == 0);\n+        } catch (Exception e) {\n+            fail(\"Exception was thrown when trying to decode \"\n+                + \"invalid base64 encoded data - RFC 2045 requires that all \"\n+                + \"non base64 character be discarded, an exception should not\"\n+                + \" have been thrown\");\n+        }\n+    }\n+\n+    @Test\n+    public void testObjectDecodeWithInvalidParameter() throws Exception {\n+        Base64 b64 = new Base64();\n+\n+        try {\n+            b64.decode(Integer.valueOf(5));\n+            fail(\"decode(Object) didn't throw an exception when passed an Integer object\");\n+        } catch (DecoderException e) {\n+            // ignored\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testObjectDecodeWithValidParameter() throws Exception {\n+\n+        String original = \"Hello World!\";\n+        Object o = Base64.encodeBase64(original.getBytes(\"UTF-8\"));\n+\n+        Base64 b64 = new Base64();\n+        Object oDecoded = b64.decode(o);\n+        byte[] baDecoded = (byte[]) oDecoded;\n+        String dest = new String(baDecoded);\n+\n+        assertTrue(\"dest string does not equal original\", dest.equals(original));\n+    }\n+\n+    @Test\n+    public void testObjectEncodeWithInvalidParameter() throws Exception {\n+        Base64 b64 = new Base64();\n+        try {\n+            b64.encode(\"Yadayadayada\");\n+            fail(\"encode(Object) didn't throw an exception when passed a String object\");\n+        } catch (EncoderException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testObjectEncodeWithValidParameter() throws Exception {\n+\n+        String original = \"Hello World!\";\n+        Object origObj = original.getBytes(\"UTF-8\");\n+\n+        Base64 b64 = new Base64();\n+        Object oEncoded = b64.encode(origObj);\n+        byte[] bArray = Base64.decodeBase64((byte[]) oEncoded);\n+        String dest = new String(bArray);\n+\n+        assertTrue(\"dest string does not equal original\", dest.equals(original));\n+    }\n+\n+    @Test\n+    public void testObjectEncode() throws Exception {\n+        Base64 b64 = new Base64();\n+        assertEquals(\"SGVsbG8gV29ybGQ=\", new String(b64.encode(\"Hello World\".getBytes(\"UTF-8\"))));\n+    }\n+\n+    @Test\n+    public void testPairs() {\n+        assertEquals(\"AAA=\", new String(Base64.encodeBase64(new byte[]{0, 0})));\n+        for (int i = -128; i <= 127; i++) {\n+            byte test[] = {(byte) i, (byte) i};\n+            assertTrue(Arrays.equals(test, Base64.decodeBase64(Base64.encodeBase64(test))));\n+        }\n+    }\n+\n+    /**\n+     * Tests RFC 2045 section 2.1 CRLF definition.\n+     */\n+    @Test\n+    public void testRfc2045Section2Dot1CrLfDefinition() {\n+        assertTrue(Arrays.equals(new byte[]{13, 10}, Base64.CHUNK_SEPARATOR));\n+    }\n+\n+    /**\n+     * Tests RFC 2045 section 6.8 chuck size definition.\n+     */\n+    @Test\n+    public void testRfc2045Section6Dot8ChunkSizeDefinition() {\n+        assertEquals(76, BaseNCodec.MIME_CHUNK_SIZE);\n+    }\n+\n+    /**\n+     * Tests RFC 1421 section 4.3.2.4 chuck size definition.\n+     */\n+    @Test\n+    public void testRfc1421Section6Dot8ChunkSizeDefinition() {\n+        assertEquals(64, BaseNCodec.PEM_CHUNK_SIZE);\n+    }\n+\n+    /**\n+     * Tests RFC 4648 section 10 test vectors.\n+     * <ul>\n+     * <li>BASE64(\"\") = \"\"</li>\n+     * <li>BASE64(\"f\") = \"Zg==\"</li>\n+     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n+     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n+     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n+     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n+     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n+     * </ul>\n+     * \n+     * @see <a href=\"http://tools.ietf.org/html/rfc4648\">http://tools.ietf.org/html/rfc4648</a>\n+     */\n+    @Test\n+    public void testRfc4648Section10Decode() {\n+        assertEquals(\"\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"\")));\n+        assertEquals(\"f\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zg==\")));\n+        assertEquals(\"fo\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zm8=\")));\n+        assertEquals(\"foo\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zm9v\")));\n+        assertEquals(\"foob\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zm9vYg==\")));\n+        assertEquals(\"fooba\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zm9vYmE=\")));\n+        assertEquals(\"foobar\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zm9vYmFy\")));\n+    }\n+    \n+    /**\n+     * Tests RFC 4648 section 10 test vectors.\n+     * <ul>\n+     * <li>BASE64(\"\") = \"\"</li>\n+     * <li>BASE64(\"f\") = \"Zg==\"</li>\n+     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n+     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n+     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n+     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n+     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n+     * </ul>\n+     * \n+     * @see <a href=\"http://tools.ietf.org/html/rfc4648\">http://tools.ietf.org/html/rfc4648</a>\n+     */\n+    @Test\n+    public void testRfc4648Section10DecodeWithCrLf() {\n+        String CRLF = StringUtils.newStringUsAscii(Base64.CHUNK_SEPARATOR);\n+        assertEquals(\"\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"\" + CRLF)));\n+        assertEquals(\"f\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zg==\" + CRLF)));\n+        assertEquals(\"fo\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zm8=\" + CRLF)));\n+        assertEquals(\"foo\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zm9v\" + CRLF)));\n+        assertEquals(\"foob\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zm9vYg==\" + CRLF)));\n+        assertEquals(\"fooba\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zm9vYmE=\" + CRLF)));\n+        assertEquals(\"foobar\", StringUtils.newStringUsAscii(Base64.decodeBase64(\"Zm9vYmFy\" + CRLF)));\n+    }\n+    \n+    /**\n+     * Tests RFC 4648 section 10 test vectors.\n+     * <ul>\n+     * <li>BASE64(\"\") = \"\"</li>\n+     * <li>BASE64(\"f\") = \"Zg==\"</li>\n+     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n+     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n+     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n+     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n+     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n+     * </ul>\n+     * \n+     * @see <a href=\"http://tools.ietf.org/html/rfc4648\">http://tools.ietf.org/html/rfc4648</a>\n+     */\n+    @Test\n+    public void testRfc4648Section10Encode() {\n+        assertEquals(\"\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"\")));\n+        assertEquals(\"Zg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"f\")));\n+        assertEquals(\"Zm8=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fo\")));\n+        assertEquals(\"Zm9v\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foo\")));\n+        assertEquals(\"Zm9vYg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foob\")));\n+        assertEquals(\"Zm9vYmE=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fooba\")));\n+        assertEquals(\"Zm9vYmFy\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foobar\")));\n+    }\n+    \n+    /**\n+     * Tests RFC 4648 section 10 test vectors.\n+     * <ul>\n+     * <li>BASE64(\"\") = \"\"</li>\n+     * <li>BASE64(\"f\") = \"Zg==\"</li>\n+     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n+     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n+     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n+     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n+     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n+     * </ul>\n+     * \n+     * @see <a href=\"http://tools.ietf.org/html/rfc4648\">http://tools.ietf.org/html/rfc4648</a>\n+     */\n+    @Test\n+    public void testRfc4648Section10DecodeEncode() {\n+        testDecodeEncode(\"\");\n+        //testDecodeEncode(\"Zg==\");\n+        //testDecodeEncode(\"Zm8=\");\n+        //testDecodeEncode(\"Zm9v\");\n+        //testDecodeEncode(\"Zm9vYg==\");\n+        //testDecodeEncode(\"Zm9vYmE=\");\n+        //testDecodeEncode(\"Zm9vYmFy\");\n+    }\n+    \n+    private void testDecodeEncode(String encodedText) {\n+        String decodedText = StringUtils.newStringUsAscii(Base64.decodeBase64(encodedText));\n+        String encodedText2 = Base64.encodeBase64String(StringUtils.getBytesUtf8(decodedText));\n+        assertEquals(encodedText, encodedText2);\n+    }\n+\n+    /**\n+     * Tests RFC 4648 section 10 test vectors.\n+     * <ul>\n+     * <li>BASE64(\"\") = \"\"</li>\n+     * <li>BASE64(\"f\") = \"Zg==\"</li>\n+     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n+     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n+     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n+     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n+     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n+     * </ul>\n+     * \n+     * @see <a href=\"http://tools.ietf.org/html/rfc4648\">http://tools.ietf.org/html/rfc4648</a>\n+     */\n+    @Test\n+    public void testRfc4648Section10EncodeDecode() {\n+        testEncodeDecode(\"\");\n+        testEncodeDecode(\"f\");\n+        testEncodeDecode(\"fo\");\n+        testEncodeDecode(\"foo\");\n+        testEncodeDecode(\"foob\");\n+        testEncodeDecode(\"fooba\");\n+        testEncodeDecode(\"foobar\");\n+    }\n+    \n+    private void testEncodeDecode(String plainText) {\n+        String encodedText = Base64.encodeBase64String(StringUtils.getBytesUtf8(plainText));\n+        String decodedText = StringUtils.newStringUsAscii(Base64.decodeBase64(encodedText));\n+        assertEquals(plainText, decodedText);\n+    }\n+    \n+    @Test\n+    public void testSingletons() {\n+        assertEquals(\"AA==\", new String(Base64.encodeBase64(new byte[]{(byte) 0})));\n+        assertEquals(\"AQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 1})));\n+        assertEquals(\"Ag==\", new String(Base64.encodeBase64(new byte[]{(byte) 2})));\n+        assertEquals(\"Aw==\", new String(Base64.encodeBase64(new byte[]{(byte) 3})));\n+        assertEquals(\"BA==\", new String(Base64.encodeBase64(new byte[]{(byte) 4})));\n+        assertEquals(\"BQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 5})));\n+        assertEquals(\"Bg==\", new String(Base64.encodeBase64(new byte[]{(byte) 6})));\n+        assertEquals(\"Bw==\", new String(Base64.encodeBase64(new byte[]{(byte) 7})));\n+        assertEquals(\"CA==\", new String(Base64.encodeBase64(new byte[]{(byte) 8})));\n+        assertEquals(\"CQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 9})));\n+        assertEquals(\"Cg==\", new String(Base64.encodeBase64(new byte[]{(byte) 10})));\n+        assertEquals(\"Cw==\", new String(Base64.encodeBase64(new byte[]{(byte) 11})));\n+        assertEquals(\"DA==\", new String(Base64.encodeBase64(new byte[]{(byte) 12})));\n+        assertEquals(\"DQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 13})));\n+        assertEquals(\"Dg==\", new String(Base64.encodeBase64(new byte[]{(byte) 14})));\n+        assertEquals(\"Dw==\", new String(Base64.encodeBase64(new byte[]{(byte) 15})));\n+        assertEquals(\"EA==\", new String(Base64.encodeBase64(new byte[]{(byte) 16})));\n+        assertEquals(\"EQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 17})));\n+        assertEquals(\"Eg==\", new String(Base64.encodeBase64(new byte[]{(byte) 18})));\n+        assertEquals(\"Ew==\", new String(Base64.encodeBase64(new byte[]{(byte) 19})));\n+        assertEquals(\"FA==\", new String(Base64.encodeBase64(new byte[]{(byte) 20})));\n+        assertEquals(\"FQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 21})));\n+        assertEquals(\"Fg==\", new String(Base64.encodeBase64(new byte[]{(byte) 22})));\n+        assertEquals(\"Fw==\", new String(Base64.encodeBase64(new byte[]{(byte) 23})));\n+        assertEquals(\"GA==\", new String(Base64.encodeBase64(new byte[]{(byte) 24})));\n+        assertEquals(\"GQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 25})));\n+        assertEquals(\"Gg==\", new String(Base64.encodeBase64(new byte[]{(byte) 26})));\n+        assertEquals(\"Gw==\", new String(Base64.encodeBase64(new byte[]{(byte) 27})));\n+        assertEquals(\"HA==\", new String(Base64.encodeBase64(new byte[]{(byte) 28})));\n+        assertEquals(\"HQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 29})));\n+        assertEquals(\"Hg==\", new String(Base64.encodeBase64(new byte[]{(byte) 30})));\n+        assertEquals(\"Hw==\", new String(Base64.encodeBase64(new byte[]{(byte) 31})));\n+        assertEquals(\"IA==\", new String(Base64.encodeBase64(new byte[]{(byte) 32})));\n+        assertEquals(\"IQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 33})));\n+        assertEquals(\"Ig==\", new String(Base64.encodeBase64(new byte[]{(byte) 34})));\n+        assertEquals(\"Iw==\", new String(Base64.encodeBase64(new byte[]{(byte) 35})));\n+        assertEquals(\"JA==\", new String(Base64.encodeBase64(new byte[]{(byte) 36})));\n+        assertEquals(\"JQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 37})));\n+        assertEquals(\"Jg==\", new String(Base64.encodeBase64(new byte[]{(byte) 38})));\n+        assertEquals(\"Jw==\", new String(Base64.encodeBase64(new byte[]{(byte) 39})));\n+        assertEquals(\"KA==\", new String(Base64.encodeBase64(new byte[]{(byte) 40})));\n+        assertEquals(\"KQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 41})));\n+        assertEquals(\"Kg==\", new String(Base64.encodeBase64(new byte[]{(byte) 42})));\n+        assertEquals(\"Kw==\", new String(Base64.encodeBase64(new byte[]{(byte) 43})));\n+        assertEquals(\"LA==\", new String(Base64.encodeBase64(new byte[]{(byte) 44})));\n+        assertEquals(\"LQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 45})));\n+        assertEquals(\"Lg==\", new String(Base64.encodeBase64(new byte[]{(byte) 46})));\n+        assertEquals(\"Lw==\", new String(Base64.encodeBase64(new byte[]{(byte) 47})));\n+        assertEquals(\"MA==\", new String(Base64.encodeBase64(new byte[]{(byte) 48})));\n+        assertEquals(\"MQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 49})));\n+        assertEquals(\"Mg==\", new String(Base64.encodeBase64(new byte[]{(byte) 50})));\n+        assertEquals(\"Mw==\", new String(Base64.encodeBase64(new byte[]{(byte) 51})));\n+        assertEquals(\"NA==\", new String(Base64.encodeBase64(new byte[]{(byte) 52})));\n+        assertEquals(\"NQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 53})));\n+        assertEquals(\"Ng==\", new String(Base64.encodeBase64(new byte[]{(byte) 54})));\n+        assertEquals(\"Nw==\", new String(Base64.encodeBase64(new byte[]{(byte) 55})));\n+        assertEquals(\"OA==\", new String(Base64.encodeBase64(new byte[]{(byte) 56})));\n+        assertEquals(\"OQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 57})));\n+        assertEquals(\"Og==\", new String(Base64.encodeBase64(new byte[]{(byte) 58})));\n+        assertEquals(\"Ow==\", new String(Base64.encodeBase64(new byte[]{(byte) 59})));\n+        assertEquals(\"PA==\", new String(Base64.encodeBase64(new byte[]{(byte) 60})));\n+        assertEquals(\"PQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 61})));\n+        assertEquals(\"Pg==\", new String(Base64.encodeBase64(new byte[]{(byte) 62})));\n+        assertEquals(\"Pw==\", new String(Base64.encodeBase64(new byte[]{(byte) 63})));\n+        assertEquals(\"QA==\", new String(Base64.encodeBase64(new byte[]{(byte) 64})));\n+        assertEquals(\"QQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 65})));\n+        assertEquals(\"Qg==\", new String(Base64.encodeBase64(new byte[]{(byte) 66})));\n+        assertEquals(\"Qw==\", new String(Base64.encodeBase64(new byte[]{(byte) 67})));\n+        assertEquals(\"RA==\", new String(Base64.encodeBase64(new byte[]{(byte) 68})));\n+        assertEquals(\"RQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 69})));\n+        assertEquals(\"Rg==\", new String(Base64.encodeBase64(new byte[]{(byte) 70})));\n+        assertEquals(\"Rw==\", new String(Base64.encodeBase64(new byte[]{(byte) 71})));\n+        assertEquals(\"SA==\", new String(Base64.encodeBase64(new byte[]{(byte) 72})));\n+        assertEquals(\"SQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 73})));\n+        assertEquals(\"Sg==\", new String(Base64.encodeBase64(new byte[]{(byte) 74})));\n+        assertEquals(\"Sw==\", new String(Base64.encodeBase64(new byte[]{(byte) 75})));\n+        assertEquals(\"TA==\", new String(Base64.encodeBase64(new byte[]{(byte) 76})));\n+        assertEquals(\"TQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 77})));\n+        assertEquals(\"Tg==\", new String(Base64.encodeBase64(new byte[]{(byte) 78})));\n+        assertEquals(\"Tw==\", new String(Base64.encodeBase64(new byte[]{(byte) 79})));\n+        assertEquals(\"UA==\", new String(Base64.encodeBase64(new byte[]{(byte) 80})));\n+        assertEquals(\"UQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 81})));\n+        assertEquals(\"Ug==\", new String(Base64.encodeBase64(new byte[]{(byte) 82})));\n+        assertEquals(\"Uw==\", new String(Base64.encodeBase64(new byte[]{(byte) 83})));\n+        assertEquals(\"VA==\", new String(Base64.encodeBase64(new byte[]{(byte) 84})));\n+        assertEquals(\"VQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 85})));\n+        assertEquals(\"Vg==\", new String(Base64.encodeBase64(new byte[]{(byte) 86})));\n+        assertEquals(\"Vw==\", new String(Base64.encodeBase64(new byte[]{(byte) 87})));\n+        assertEquals(\"WA==\", new String(Base64.encodeBase64(new byte[]{(byte) 88})));\n+        assertEquals(\"WQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 89})));\n+        assertEquals(\"Wg==\", new String(Base64.encodeBase64(new byte[]{(byte) 90})));\n+        assertEquals(\"Ww==\", new String(Base64.encodeBase64(new byte[]{(byte) 91})));\n+        assertEquals(\"XA==\", new String(Base64.encodeBase64(new byte[]{(byte) 92})));\n+        assertEquals(\"XQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 93})));\n+        assertEquals(\"Xg==\", new String(Base64.encodeBase64(new byte[]{(byte) 94})));\n+        assertEquals(\"Xw==\", new String(Base64.encodeBase64(new byte[]{(byte) 95})));\n+        assertEquals(\"YA==\", new String(Base64.encodeBase64(new byte[]{(byte) 96})));\n+        assertEquals(\"YQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 97})));\n+        assertEquals(\"Yg==\", new String(Base64.encodeBase64(new byte[]{(byte) 98})));\n+        assertEquals(\"Yw==\", new String(Base64.encodeBase64(new byte[]{(byte) 99})));\n+        assertEquals(\"ZA==\", new String(Base64.encodeBase64(new byte[]{(byte) 100})));\n+        assertEquals(\"ZQ==\", new String(Base64.encodeBase64(new byte[]{(byte) 101})));\n+        assertEquals(\"Zg==\", new String(Base64.encodeBase64(new byte[]{(byte) 102})));\n+        assertEquals(\"Zw==\", new String(Base64.encodeBase64(new byte[]{(byte) 103})));\n+        assertEquals(\"aA==\", new String(Base64.encodeBase64(new byte[]{(byte) 104})));\n+        for (int i = -128; i <= 127; i++) {\n+            byte test[] = {(byte) i};\n+            assertTrue(Arrays.equals(test, Base64.decodeBase64(Base64.encodeBase64(test))));\n+        }\n+    }\n+\n+    @Test\n+    public void testSingletonsChunked() {\n+        assertEquals(\"AA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0})));\n+        assertEquals(\"AQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 1})));\n+        assertEquals(\"Ag==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 2})));\n+        assertEquals(\"Aw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 3})));\n+        assertEquals(\"BA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 4})));\n+        assertEquals(\"BQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 5})));\n+        assertEquals(\"Bg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 6})));\n+        assertEquals(\"Bw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 7})));\n+        assertEquals(\"CA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 8})));\n+        assertEquals(\"CQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 9})));\n+        assertEquals(\"Cg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 10})));\n+        assertEquals(\"Cw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 11})));\n+        assertEquals(\"DA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 12})));\n+        assertEquals(\"DQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 13})));\n+        assertEquals(\"Dg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 14})));\n+        assertEquals(\"Dw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 15})));\n+        assertEquals(\"EA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 16})));\n+        assertEquals(\"EQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 17})));\n+        assertEquals(\"Eg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 18})));\n+        assertEquals(\"Ew==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 19})));\n+        assertEquals(\"FA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 20})));\n+        assertEquals(\"FQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 21})));\n+        assertEquals(\"Fg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 22})));\n+        assertEquals(\"Fw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 23})));\n+        assertEquals(\"GA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 24})));\n+        assertEquals(\"GQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 25})));\n+        assertEquals(\"Gg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 26})));\n+        assertEquals(\"Gw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 27})));\n+        assertEquals(\"HA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 28})));\n+        assertEquals(\"HQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 29})));\n+        assertEquals(\"Hg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 30})));\n+        assertEquals(\"Hw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 31})));\n+        assertEquals(\"IA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 32})));\n+        assertEquals(\"IQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 33})));\n+        assertEquals(\"Ig==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 34})));\n+        assertEquals(\"Iw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 35})));\n+        assertEquals(\"JA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 36})));\n+        assertEquals(\"JQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 37})));\n+        assertEquals(\"Jg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 38})));\n+        assertEquals(\"Jw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 39})));\n+        assertEquals(\"KA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 40})));\n+        assertEquals(\"KQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 41})));\n+        assertEquals(\"Kg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 42})));\n+        assertEquals(\"Kw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 43})));\n+        assertEquals(\"LA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 44})));\n+        assertEquals(\"LQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 45})));\n+        assertEquals(\"Lg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 46})));\n+        assertEquals(\"Lw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 47})));\n+        assertEquals(\"MA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 48})));\n+        assertEquals(\"MQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 49})));\n+        assertEquals(\"Mg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 50})));\n+        assertEquals(\"Mw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 51})));\n+        assertEquals(\"NA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 52})));\n+        assertEquals(\"NQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 53})));\n+        assertEquals(\"Ng==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 54})));\n+        assertEquals(\"Nw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 55})));\n+        assertEquals(\"OA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 56})));\n+        assertEquals(\"OQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 57})));\n+        assertEquals(\"Og==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 58})));\n+        assertEquals(\"Ow==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 59})));\n+        assertEquals(\"PA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 60})));\n+        assertEquals(\"PQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 61})));\n+        assertEquals(\"Pg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 62})));\n+        assertEquals(\"Pw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 63})));\n+        assertEquals(\"QA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 64})));\n+        assertEquals(\"QQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 65})));\n+        assertEquals(\"Qg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 66})));\n+        assertEquals(\"Qw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 67})));\n+        assertEquals(\"RA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 68})));\n+        assertEquals(\"RQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 69})));\n+        assertEquals(\"Rg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 70})));\n+        assertEquals(\"Rw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 71})));\n+        assertEquals(\"SA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 72})));\n+        assertEquals(\"SQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 73})));\n+        assertEquals(\"Sg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 74})));\n+        assertEquals(\"Sw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 75})));\n+        assertEquals(\"TA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 76})));\n+        assertEquals(\"TQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 77})));\n+        assertEquals(\"Tg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 78})));\n+        assertEquals(\"Tw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 79})));\n+        assertEquals(\"UA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 80})));\n+        assertEquals(\"UQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 81})));\n+        assertEquals(\"Ug==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 82})));\n+        assertEquals(\"Uw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 83})));\n+        assertEquals(\"VA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 84})));\n+        assertEquals(\"VQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 85})));\n+        assertEquals(\"Vg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 86})));\n+        assertEquals(\"Vw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 87})));\n+        assertEquals(\"WA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 88})));\n+        assertEquals(\"WQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 89})));\n+        assertEquals(\"Wg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 90})));\n+        assertEquals(\"Ww==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 91})));\n+        assertEquals(\"XA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 92})));\n+        assertEquals(\"XQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 93})));\n+        assertEquals(\"Xg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 94})));\n+        assertEquals(\"Xw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 95})));\n+        assertEquals(\"YA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 96})));\n+        assertEquals(\"YQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 97})));\n+        assertEquals(\"Yg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 98})));\n+        assertEquals(\"Yw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 99})));\n+        assertEquals(\"ZA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 100})));\n+        assertEquals(\"ZQ==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 101})));\n+        assertEquals(\"Zg==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 102})));\n+        assertEquals(\"Zw==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 103})));\n+        assertEquals(\"aA==\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 104})));\n+    }\n+\n+    @Test\n+    public void testTriplets() {\n+        assertEquals(\"AAAA\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 0})));\n+        assertEquals(\"AAAB\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 1})));\n+        assertEquals(\"AAAC\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 2})));\n+        assertEquals(\"AAAD\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 3})));\n+        assertEquals(\"AAAE\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 4})));\n+        assertEquals(\"AAAF\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 5})));\n+        assertEquals(\"AAAG\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 6})));\n+        assertEquals(\"AAAH\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 7})));\n+        assertEquals(\"AAAI\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 8})));\n+        assertEquals(\"AAAJ\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 9})));\n+        assertEquals(\"AAAK\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 10})));\n+        assertEquals(\"AAAL\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 11})));\n+        assertEquals(\"AAAM\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 12})));\n+        assertEquals(\"AAAN\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 13})));\n+        assertEquals(\"AAAO\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 14})));\n+        assertEquals(\"AAAP\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 15})));\n+        assertEquals(\"AAAQ\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 16})));\n+        assertEquals(\"AAAR\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 17})));\n+        assertEquals(\"AAAS\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 18})));\n+        assertEquals(\"AAAT\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 19})));\n+        assertEquals(\"AAAU\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 20})));\n+        assertEquals(\"AAAV\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 21})));\n+        assertEquals(\"AAAW\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 22})));\n+        assertEquals(\"AAAX\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 23})));\n+        assertEquals(\"AAAY\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 24})));\n+        assertEquals(\"AAAZ\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 25})));\n+        assertEquals(\"AAAa\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 26})));\n+        assertEquals(\"AAAb\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 27})));\n+        assertEquals(\"AAAc\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 28})));\n+        assertEquals(\"AAAd\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 29})));\n+        assertEquals(\"AAAe\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 30})));\n+        assertEquals(\"AAAf\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 31})));\n+        assertEquals(\"AAAg\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 32})));\n+        assertEquals(\"AAAh\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 33})));\n+        assertEquals(\"AAAi\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 34})));\n+        assertEquals(\"AAAj\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 35})));\n+        assertEquals(\"AAAk\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 36})));\n+        assertEquals(\"AAAl\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 37})));\n+        assertEquals(\"AAAm\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 38})));\n+        assertEquals(\"AAAn\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 39})));\n+        assertEquals(\"AAAo\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 40})));\n+        assertEquals(\"AAAp\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 41})));\n+        assertEquals(\"AAAq\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 42})));\n+        assertEquals(\"AAAr\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 43})));\n+        assertEquals(\"AAAs\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 44})));\n+        assertEquals(\"AAAt\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 45})));\n+        assertEquals(\"AAAu\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 46})));\n+        assertEquals(\"AAAv\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 47})));\n+        assertEquals(\"AAAw\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 48})));\n+        assertEquals(\"AAAx\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 49})));\n+        assertEquals(\"AAAy\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 50})));\n+        assertEquals(\"AAAz\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 51})));\n+        assertEquals(\"AAA0\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 52})));\n+        assertEquals(\"AAA1\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 53})));\n+        assertEquals(\"AAA2\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 54})));\n+        assertEquals(\"AAA3\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 55})));\n+        assertEquals(\"AAA4\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 56})));\n+        assertEquals(\"AAA5\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 57})));\n+        assertEquals(\"AAA6\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 58})));\n+        assertEquals(\"AAA7\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 59})));\n+        assertEquals(\"AAA8\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 60})));\n+        assertEquals(\"AAA9\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 61})));\n+        assertEquals(\"AAA+\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 62})));\n+        assertEquals(\"AAA/\", new String(Base64.encodeBase64(new byte[]{(byte) 0, (byte) 0, (byte) 63})));\n+    }\n+\n+    @Test\n+    public void testTripletsChunked() {\n+        assertEquals(\"AAAA\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 0})));\n+        assertEquals(\"AAAB\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 1})));\n+        assertEquals(\"AAAC\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 2})));\n+        assertEquals(\"AAAD\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 3})));\n+        assertEquals(\"AAAE\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 4})));\n+        assertEquals(\"AAAF\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 5})));\n+        assertEquals(\"AAAG\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 6})));\n+        assertEquals(\"AAAH\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 7})));\n+        assertEquals(\"AAAI\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 8})));\n+        assertEquals(\"AAAJ\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 9})));\n+        assertEquals(\"AAAK\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 10})));\n+        assertEquals(\"AAAL\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 11})));\n+        assertEquals(\"AAAM\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 12})));\n+        assertEquals(\"AAAN\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 13})));\n+        assertEquals(\"AAAO\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 14})));\n+        assertEquals(\"AAAP\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 15})));\n+        assertEquals(\"AAAQ\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 16})));\n+        assertEquals(\"AAAR\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 17})));\n+        assertEquals(\"AAAS\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 18})));\n+        assertEquals(\"AAAT\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 19})));\n+        assertEquals(\"AAAU\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 20})));\n+        assertEquals(\"AAAV\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 21})));\n+        assertEquals(\"AAAW\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 22})));\n+        assertEquals(\"AAAX\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 23})));\n+        assertEquals(\"AAAY\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 24})));\n+        assertEquals(\"AAAZ\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 25})));\n+        assertEquals(\"AAAa\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 26})));\n+        assertEquals(\"AAAb\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 27})));\n+        assertEquals(\"AAAc\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 28})));\n+        assertEquals(\"AAAd\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 29})));\n+        assertEquals(\"AAAe\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 30})));\n+        assertEquals(\"AAAf\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 31})));\n+        assertEquals(\"AAAg\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 32})));\n+        assertEquals(\"AAAh\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 33})));\n+        assertEquals(\"AAAi\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 34})));\n+        assertEquals(\"AAAj\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 35})));\n+        assertEquals(\"AAAk\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 36})));\n+        assertEquals(\"AAAl\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 37})));\n+        assertEquals(\"AAAm\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 38})));\n+        assertEquals(\"AAAn\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 39})));\n+        assertEquals(\"AAAo\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 40})));\n+        assertEquals(\"AAAp\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 41})));\n+        assertEquals(\"AAAq\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 42})));\n+        assertEquals(\"AAAr\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 43})));\n+        assertEquals(\"AAAs\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 44})));\n+        assertEquals(\"AAAt\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 45})));\n+        assertEquals(\"AAAu\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 46})));\n+        assertEquals(\"AAAv\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 47})));\n+        assertEquals(\"AAAw\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 48})));\n+        assertEquals(\"AAAx\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 49})));\n+        assertEquals(\"AAAy\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 50})));\n+        assertEquals(\"AAAz\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 51})));\n+        assertEquals(\"AAA0\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 52})));\n+        assertEquals(\"AAA1\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 53})));\n+        assertEquals(\"AAA2\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 54})));\n+        assertEquals(\"AAA3\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 55})));\n+        assertEquals(\"AAA4\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 56})));\n+        assertEquals(\"AAA5\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 57})));\n+        assertEquals(\"AAA6\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 58})));\n+        assertEquals(\"AAA7\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 59})));\n+        assertEquals(\"AAA8\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 60})));\n+        assertEquals(\"AAA9\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 61})));\n+        assertEquals(\"AAA+\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 62})));\n+        assertEquals(\"AAA/\\r\\n\", new String(Base64.encodeBase64Chunked(new byte[]{(byte) 0, (byte) 0, (byte) 63})));\n+    }\n+\n+    /**\n+     * Tests url-safe Base64 against random data, sizes 0 to 150.\n+     */\n+    @Test\n+    public void testUrlSafe() {\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, true);\n+            byte[] encoded = randomData[1];\n+            byte[] decoded = randomData[0];\n+            byte[] result = Base64.decodeBase64(encoded);\n+            assertTrue(\"url-safe i=\" + i, Arrays.equals(decoded, result));\n+            assertFalse(\"url-safe i=\" + i + \" no '='\", Base64TestData.bytesContain(encoded, (byte) '='));\n+            assertFalse(\"url-safe i=\" + i + \" no '\\\\'\", Base64TestData.bytesContain(encoded, (byte) '\\\\'));\n+            assertFalse(\"url-safe i=\" + i + \" no '+'\", Base64TestData.bytesContain(encoded, (byte) '+'));\n+        }\n+\n+    }\n+\n+    /**\n+     * Base64 encoding of UUID's is a common use-case, especially in URL-SAFE mode. This test case ends up being the\n+     * \"URL-SAFE\" JUnit's.\n+     * \n+     * @throws DecoderException\n+     *             if Hex.decode() fails - a serious problem since Hex comes from our own commons-codec!\n+     */\n+    @Test\n+    public void testUUID() throws DecoderException {\n+        // The 4 UUID's below contains mixtures of + and / to help us test the\n+        // URL-SAFE encoding mode.\n+        byte[][] ids = new byte[4][];\n+\n+        // ids[0] was chosen so that it encodes with at least one +.\n+        ids[0] = Hex.decodeHex(\"94ed8d0319e4493399560fb67404d370\".toCharArray());\n+\n+        // ids[1] was chosen so that it encodes with both / and +.\n+        ids[1] = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());\n+\n+        // ids[2] was chosen so that it encodes with at least one /.\n+        ids[2] = Hex.decodeHex(\"64be154b6ffa40258d1a01288e7c31ca\".toCharArray());\n+\n+        // ids[3] was chosen so that it encodes with both / and +, with /\n+        // right at the beginning.\n+        ids[3] = Hex.decodeHex(\"ff7f8fc01cdb471a8c8b5a9306183fe8\".toCharArray());\n+\n+        byte[][] standard = new byte[4][];\n+        standard[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg+2dATTcA==\");\n+        standard[1] = StringUtils.getBytesUtf8(\"K/fMJwH+Q5e0nr7tWsxwkA==\");\n+        standard[2] = StringUtils.getBytesUtf8(\"ZL4VS2/6QCWNGgEojnwxyg==\");\n+        standard[3] = StringUtils.getBytesUtf8(\"/3+PwBzbRxqMi1qTBhg/6A==\");\n+\n+        byte[][] urlSafe1 = new byte[4][];\n+        // regular padding (two '==' signs).\n+        urlSafe1[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA==\");\n+        urlSafe1[1] = StringUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA==\");\n+        urlSafe1[2] = StringUtils.getBytesUtf8(\"ZL4VS2_6QCWNGgEojnwxyg==\");\n+        urlSafe1[3] = StringUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A==\");\n+\n+        byte[][] urlSafe2 = new byte[4][];\n+        // single padding (only one '=' sign).\n+        urlSafe2[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA=\");\n+        urlSafe2[1] = StringUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA=\");\n+        urlSafe2[2] = StringUtils.getBytesUtf8(\"ZL4VS2_6QCWNGgEojnwxyg=\");\n+        urlSafe2[3] = StringUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A=\");\n+\n+        byte[][] urlSafe3 = new byte[4][];\n+        // no padding (no '=' signs).\n+        urlSafe3[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA\");\n+        urlSafe3[1] = StringUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA\");\n+        urlSafe3[2] = StringUtils.getBytesUtf8(\"ZL4VS2_6QCWNGgEojnwxyg\");\n+        urlSafe3[3] = StringUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A\");\n+\n+        for (int i = 0; i < 4; i++) {\n+            byte[] encodedStandard = Base64.encodeBase64(ids[i]);\n+            byte[] encodedUrlSafe = Base64.encodeBase64URLSafe(ids[i]);\n+            byte[] decodedStandard = Base64.decodeBase64(standard[i]);\n+            byte[] decodedUrlSafe1 = Base64.decodeBase64(urlSafe1[i]);\n+            byte[] decodedUrlSafe2 = Base64.decodeBase64(urlSafe2[i]);\n+            byte[] decodedUrlSafe3 = Base64.decodeBase64(urlSafe3[i]);\n+\n+            // Very important debugging output should anyone\n+            // ever need to delve closely into this stuff.\n+            if (false) {\n+                System.out.println(\"reference: [\" + Hex.encodeHexString(ids[i]) + \"]\");\n+                System.out.println(\"standard:  [\" +\n+                        Hex.encodeHexString(decodedStandard) +\n+                    \"] From: [\" +\n+                    StringUtils.newStringUtf8(standard[i]) +\n+                    \"]\");\n+                System.out.println(\"safe1:     [\" +\n+                        Hex.encodeHexString(decodedUrlSafe1) +\n+                    \"] From: [\" +\n+                    StringUtils.newStringUtf8(urlSafe1[i]) +\n+                    \"]\");\n+                System.out.println(\"safe2:     [\" +\n+                        Hex.encodeHexString(decodedUrlSafe2) +\n+                    \"] From: [\" +\n+                    StringUtils.newStringUtf8(urlSafe2[i]) +\n+                    \"]\");\n+                System.out.println(\"safe3:     [\" +\n+                        Hex.encodeHexString(decodedUrlSafe3) +\n+                    \"] From: [\" +\n+                    StringUtils.newStringUtf8(urlSafe3[i]) +\n+                    \"]\");\n+            }\n+\n+            assertTrue(\"standard encode uuid\", Arrays.equals(encodedStandard, standard[i]));\n+            assertTrue(\"url-safe encode uuid\", Arrays.equals(encodedUrlSafe, urlSafe3[i]));\n+            assertTrue(\"standard decode uuid\", Arrays.equals(decodedStandard, ids[i]));\n+            assertTrue(\"url-safe1 decode uuid\", Arrays.equals(decodedUrlSafe1, ids[i]));\n+            assertTrue(\"url-safe2 decode uuid\", Arrays.equals(decodedUrlSafe2, ids[i]));\n+            assertTrue(\"url-safe3 decode uuid\", Arrays.equals(decodedUrlSafe3, ids[i]));\n+        }\n+    }\n+\n+    @Test\n+    public void testByteToStringVariations() throws DecoderException {\n+        Base64 base64 = new Base64(0);\n+        byte[] b1 = StringUtils.getBytesUtf8(\"Hello World\");\n+        byte[] b2 = new byte[0];\n+        byte[] b3 = null;\n+        byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n+\n+        assertEquals(\"byteToString Hello World\", \"SGVsbG8gV29ybGQ=\", base64.encodeToString(b1));\n+        assertEquals(\"byteToString static Hello World\", \"SGVsbG8gV29ybGQ=\", Base64.encodeBase64String(b1));\n+        assertEquals(\"byteToString \\\"\\\"\", \"\", base64.encodeToString(b2));\n+        assertEquals(\"byteToString static \\\"\\\"\", \"\", Base64.encodeBase64String(b2));\n+        assertEquals(\"byteToString null\", null, base64.encodeToString(b3));\n+        assertEquals(\"byteToString static null\", null, Base64.encodeBase64String(b3));\n+        assertEquals(\"byteToString UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\", base64.encodeToString(b4));\n+        assertEquals(\"byteToString static UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\", Base64.encodeBase64String(b4));\n+        assertEquals(\"byteToString static-url-safe UUID\", \"K_fMJwH-Q5e0nr7tWsxwkA\", Base64.encodeBase64URLSafeString(b4));\n+    }\n+\n+    @Test\n+    public void testStringToByteVariations() throws DecoderException {\n+        Base64 base64 = new Base64();\n+        String s1 = \"SGVsbG8gV29ybGQ=\\r\\n\";\n+        String s2 = \"\";\n+        String s3 = null;\n+        String s4a = \"K/fMJwH+Q5e0nr7tWsxwkA==\\r\\n\";\n+        String s4b = \"K_fMJwH-Q5e0nr7tWsxwkA\";\n+        byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n+\n+        assertEquals(\"StringToByte Hello World\", \"Hello World\", StringUtils.newStringUtf8(base64.decode(s1)));\n+        assertEquals(\"StringToByte Hello World\", \"Hello World\", StringUtils.newStringUtf8((byte[])base64.decode((Object)s1)));\n+        assertEquals(\"StringToByte static Hello World\", \"Hello World\", StringUtils.newStringUtf8(Base64.decodeBase64(s1)));\n+        assertEquals(\"StringToByte \\\"\\\"\", \"\", StringUtils.newStringUtf8(base64.decode(s2)));\n+        assertEquals(\"StringToByte static \\\"\\\"\", \"\", StringUtils.newStringUtf8(Base64.decodeBase64(s2)));\n+        assertEquals(\"StringToByte null\", null, StringUtils.newStringUtf8(base64.decode(s3)));\n+        assertEquals(\"StringToByte static null\", null, StringUtils.newStringUtf8(Base64.decodeBase64(s3)));\n+        assertTrue(\"StringToByte UUID\", Arrays.equals(b4, base64.decode(s4b)));\n+        assertTrue(\"StringToByte static UUID\", Arrays.equals(b4, Base64.decodeBase64(s4a)));\n+        assertTrue(\"StringToByte static-url-safe UUID\", Arrays.equals(b4, Base64.decodeBase64(s4b)));\n+    }\n+\n+    private String toString(byte[] data) {\n+        StringBuffer buf = new StringBuffer();\n+        for (int i = 0; i < data.length; i++) {\n+            buf.append(data[i]);\n+            if (i != data.length - 1) {\n+                buf.append(\",\");\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64TestData.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Random;\n+\n+/**\n+ * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n+ * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n+ * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @since 1.4\n+ */\n+public class Base64TestData {\n+\n+    public static final String CODEC_101_MULTIPLE_OF_3 = \"123\";\n+\n+    public static final String CODEC_98_NPE\n+        = \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM\";\n+\n+    public static final String CODEC_98_NPE_DECODED\n+        = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123\";\n+\n+\n+    // OpenSSL doesn't include the final \\n, but it would be annoying beyond belief\n+    // to further parameterize commons-codec to support this pointless variation.\n+    final static String ENCODED_64_CHARS_PER_LINE\n+            = \"9IPNKwUvdLiIAp6ctz12SiQmOGstWyYvSPeevufDhrzaws65voykKjbIj33YWTa9\\n\"\n+            + \"xA7c/FHypWclrZhQ7onfc3JE93BJ5fT4R9zAEdjbjy1hv4ZYNnET4WJeXMLJ/5p+\\n\"\n+            + \"qBpTsPpepW8DNVYy1c02/1wyC+kgA6CvRUd9cSr/lt88AEdsTV4GMCn1+EwuAiYd\\n\"\n+            + \"ivxuzn+cLM8q2jewqlI52tP9J7Cs8vqG71s6+WAELKvm/UovvyaOi+OdMUfjQ0JL\\n\"\n+            + \"iLkHu6p9OwUgvQqiDKzEv/Augo0dTPZzYGEyCP5GVrle3QQdgciIHnpdd4VUTPGR\\n\"\n+            + \"UbXeKbh++U3fbJIng/sQXM3IYByMZ7xt9HWS1LUcRdQ7Prwn/IlQWxOMeq+KZJSo\\n\"\n+            + \"AviWtdserXyHbIEa//hmr4p/j80k0g9q35hq1ayGM9984ALTSaZ8WeyFbZx1CxC/\\n\"\n+            + \"Qoqf92UH/ylBRnSJNn4sS0oa3uUbNvOnpkB4D9V7Ut9atinCJrw+wiJcMl+9kp25\\n\"\n+            + \"1IUxBGA4cUxh0eaxk3ODWnwI95EktmWOKwCSP0xjWwIMxDjygwAG5R8fk9H9bVi1\\n\"\n+            + \"thMavm4nDc4vaNoSE1RnZNYwbiUVlVPM9EclvJWTWd6igWeA0MxHAA8iOM5Vnmqp\\n\"\n+            + \"/WGM7UDq59rBIdNQCoeTJaAkEtAuLL5zogOa5e+MzVjvB5MYQlOlaaTtQrRApXa5\\n\"\n+            + \"Z4VfEanu9UK2fi1T8jJPFC2PmXebxp0bnO+VW+bgyEdIIkIQCaZq1MKWC3KuiOS9\\n\"\n+            + \"BJ1t7O0A2JKJKvoE4UNulzV2TGCC+KAnmjRqQBqXlJmgjHQAoHNZKOma/uIQOsvf\\n\"\n+            + \"DnqicYdDmfyCYuV89HjA1H8tiDJ85VfsrFHdcbPAoNCpi65awJSHfdPO1NDONOK+\\n\"\n+            + \"+S7Y0VXUgoYYrBV4Y7YbC8wg/nqcimr3lm3tRyp+QsgKzdREbfNRk0F5PLyLfsUE\\n\"\n+            + \"lepjs1QdV3fEV1LJtiywA3ubVNQJRxhbYxa/C/Xy2qxpm6vvdL92l3q1ccev35Ic\\n\"\n+            + \"aOiSx7Im+/GxV2lVKdaOvYVGDD1zBRe6Y2CwQb9p088l3/93qGR5593NCiuPPWcs\\n\"\n+            + \"DWwUShM1EyW0FNX1F8bnzHnYijoyE/jf4s/l9bBd7yJdRWRCyih2WcypAiOIEkBs\\n\"\n+            + \"H+dCTgalu8sRDoMh4ZIBBdgHfoZUycLqReQFLZZ4Sl4zSmzt5vQxQFhEKb9+ff/4\\n\"\n+            + \"rb1KAo6wifengxVfIsa2b5ljXzAqXs7JkPvmC6fa7X4ZZndRokaxYlu3cg8OV+uG\\n\"\n+            + \"/6YAHZilo8at0OpkkNdNFuhwuGlkBqrZKNUj/gSiYYc06gF/r/z6iWAjpXJRW1qq\\n\"\n+            + \"3CLZXdZFZ/VrqXeVjtOAu2A=\\n\";\n+\n+    final static String ENCODED_76_CHARS_PER_LINE\n+            = \"9IPNKwUvdLiIAp6ctz12SiQmOGstWyYvSPeevufDhrzaws65voykKjbIj33YWTa9xA7c/FHypWcl\\n\"\n+            + \"rZhQ7onfc3JE93BJ5fT4R9zAEdjbjy1hv4ZYNnET4WJeXMLJ/5p+qBpTsPpepW8DNVYy1c02/1wy\\n\"\n+            + \"C+kgA6CvRUd9cSr/lt88AEdsTV4GMCn1+EwuAiYdivxuzn+cLM8q2jewqlI52tP9J7Cs8vqG71s6\\n\"\n+            + \"+WAELKvm/UovvyaOi+OdMUfjQ0JLiLkHu6p9OwUgvQqiDKzEv/Augo0dTPZzYGEyCP5GVrle3QQd\\n\"\n+            + \"gciIHnpdd4VUTPGRUbXeKbh++U3fbJIng/sQXM3IYByMZ7xt9HWS1LUcRdQ7Prwn/IlQWxOMeq+K\\n\"\n+            + \"ZJSoAviWtdserXyHbIEa//hmr4p/j80k0g9q35hq1ayGM9984ALTSaZ8WeyFbZx1CxC/Qoqf92UH\\n\"\n+            + \"/ylBRnSJNn4sS0oa3uUbNvOnpkB4D9V7Ut9atinCJrw+wiJcMl+9kp251IUxBGA4cUxh0eaxk3OD\\n\"\n+            + \"WnwI95EktmWOKwCSP0xjWwIMxDjygwAG5R8fk9H9bVi1thMavm4nDc4vaNoSE1RnZNYwbiUVlVPM\\n\"\n+            + \"9EclvJWTWd6igWeA0MxHAA8iOM5Vnmqp/WGM7UDq59rBIdNQCoeTJaAkEtAuLL5zogOa5e+MzVjv\\n\"\n+            + \"B5MYQlOlaaTtQrRApXa5Z4VfEanu9UK2fi1T8jJPFC2PmXebxp0bnO+VW+bgyEdIIkIQCaZq1MKW\\n\"\n+            + \"C3KuiOS9BJ1t7O0A2JKJKvoE4UNulzV2TGCC+KAnmjRqQBqXlJmgjHQAoHNZKOma/uIQOsvfDnqi\\n\"\n+            + \"cYdDmfyCYuV89HjA1H8tiDJ85VfsrFHdcbPAoNCpi65awJSHfdPO1NDONOK++S7Y0VXUgoYYrBV4\\n\"\n+            + \"Y7YbC8wg/nqcimr3lm3tRyp+QsgKzdREbfNRk0F5PLyLfsUElepjs1QdV3fEV1LJtiywA3ubVNQJ\\n\"\n+            + \"RxhbYxa/C/Xy2qxpm6vvdL92l3q1ccev35IcaOiSx7Im+/GxV2lVKdaOvYVGDD1zBRe6Y2CwQb9p\\n\"\n+            + \"088l3/93qGR5593NCiuPPWcsDWwUShM1EyW0FNX1F8bnzHnYijoyE/jf4s/l9bBd7yJdRWRCyih2\\n\"\n+            + \"WcypAiOIEkBsH+dCTgalu8sRDoMh4ZIBBdgHfoZUycLqReQFLZZ4Sl4zSmzt5vQxQFhEKb9+ff/4\\n\"\n+            + \"rb1KAo6wifengxVfIsa2b5ljXzAqXs7JkPvmC6fa7X4ZZndRokaxYlu3cg8OV+uG/6YAHZilo8at\\n\"\n+            + \"0OpkkNdNFuhwuGlkBqrZKNUj/gSiYYc06gF/r/z6iWAjpXJRW1qq3CLZXdZFZ/VrqXeVjtOAu2A=\\n\";\n+\n+    final static byte[] DECODED\n+            = {-12, -125, -51, 43, 5, 47, 116, -72, -120, 2, -98, -100, -73, 61, 118, 74, 36, 38, 56, 107, 45, 91, 38,\n+            47, 72, -9, -98, -66, -25, -61, -122, -68, -38, -62, -50, -71, -66, -116, -92, 42, 54, -56, -113, 125,\n+            -40, 89, 54, -67, -60, 14, -36, -4, 81, -14, -91, 103, 37, -83, -104, 80, -18, -119, -33, 115, 114, 68,\n+            -9, 112, 73, -27, -12, -8, 71, -36, -64, 17, -40, -37, -113, 45, 97, -65, -122, 88, 54, 113, 19, -31, 98,\n+            94, 92, -62, -55, -1, -102, 126, -88, 26, 83, -80, -6, 94, -91, 111, 3, 53, 86, 50, -43, -51, 54, -1, 92,\n+            50, 11, -23, 32, 3, -96, -81, 69, 71, 125, 113, 42, -1, -106, -33, 60, 0, 71, 108, 77, 94, 6, 48, 41, -11,\n+            -8, 76, 46, 2, 38, 29, -118, -4, 110, -50, 127, -100, 44, -49, 42, -38, 55, -80, -86, 82, 57, -38, -45,\n+            -3, 39, -80, -84, -14, -6, -122, -17, 91, 58, -7, 96, 4, 44, -85, -26, -3, 74, 47, -65, 38, -114, -117,\n+            -29, -99, 49, 71, -29, 67, 66, 75, -120, -71, 7, -69, -86, 125, 59, 5, 32, -67, 10, -94, 12, -84, -60, -65,\n+            -16, 46, -126, -115, 29, 76, -10, 115, 96, 97, 50, 8, -2, 70, 86, -71, 94, -35, 4, 29, -127, -56, -120,\n+            30, 122, 93, 119, -123, 84, 76, -15, -111, 81, -75, -34, 41, -72, 126, -7, 77, -33, 108, -110, 39, -125,\n+            -5, 16, 92, -51, -56, 96, 28, -116, 103, -68, 109, -12, 117, -110, -44, -75, 28, 69, -44, 59, 62, -68,\n+            39, -4, -119, 80, 91, 19, -116, 122, -81, -118, 100, -108, -88, 2, -8, -106, -75, -37, 30, -83, 124, -121,\n+            108, -127, 26, -1, -8, 102, -81, -118, 127, -113, -51, 36, -46, 15, 106, -33, -104, 106, -43, -84, -122,\n+            51, -33, 124, -32, 2, -45, 73, -90, 124, 89, -20, -123, 109, -100, 117, 11, 16, -65, 66, -118, -97, -9,\n+            101, 7, -1, 41, 65, 70, 116, -119, 54, 126, 44, 75, 74, 26, -34, -27, 27, 54, -13, -89, -90, 64, 120, 15,\n+            -43, 123, 82, -33, 90, -74, 41, -62, 38, -68, 62, -62, 34, 92, 50, 95, -67, -110, -99, -71, -44, -123,\n+            49, 4, 96, 56, 113, 76, 97, -47, -26, -79, -109, 115, -125, 90, 124, 8, -9, -111, 36, -74, 101, -114, 43,\n+            0, -110, 63, 76, 99, 91, 2, 12, -60, 56, -14, -125, 0, 6, -27, 31, 31, -109, -47, -3, 109, 88, -75, -74,\n+            19, 26, -66, 110, 39, 13, -50, 47, 104, -38, 18, 19, 84, 103, 100, -42, 48, 110, 37, 21, -107, 83, -52,\n+            -12, 71, 37, -68, -107, -109, 89, -34, -94, -127, 103, -128, -48, -52, 71, 0, 15, 34, 56, -50, 85, -98,\n+            106, -87, -3, 97, -116, -19, 64, -22, -25, -38, -63, 33, -45, 80, 10, -121, -109, 37, -96, 36, 18, -48,\n+            46, 44, -66, 115, -94, 3, -102, -27, -17, -116, -51, 88, -17, 7, -109, 24, 66, 83, -91, 105, -92, -19,\n+            66, -76, 64, -91, 118, -71, 103, -123, 95, 17, -87, -18, -11, 66, -74, 126, 45, 83, -14, 50, 79, 20, 45,\n+            -113, -103, 119, -101, -58, -99, 27, -100, -17, -107, 91, -26, -32, -56, 71, 72, 34, 66, 16, 9, -90, 106,\n+            -44, -62, -106, 11, 114, -82, -120, -28, -67, 4, -99, 109, -20, -19, 0, -40, -110, -119, 42, -6, 4, -31,\n+            67, 110, -105, 53, 118, 76, 96, -126, -8, -96, 39, -102, 52, 106, 64, 26, -105, -108, -103, -96, -116,\n+            116, 0, -96, 115, 89, 40, -23, -102, -2, -30, 16, 58, -53, -33, 14, 122, -94, 113, -121, 67, -103, -4,\n+            -126, 98, -27, 124, -12, 120, -64, -44, 127, 45, -120, 50, 124, -27, 87, -20, -84, 81, -35, 113, -77,\n+            -64, -96, -48, -87, -117, -82, 90, -64, -108, -121, 125, -45, -50, -44, -48, -50, 52, -30, -66, -7, 46,\n+            -40, -47, 85, -44, -126, -122, 24, -84, 21, 120, 99, -74, 27, 11, -52, 32, -2, 122, -100, -118, 106, -9,\n+            -106, 109, -19, 71, 42, 126, 66, -56, 10, -51, -44, 68, 109, -13, 81, -109, 65, 121, 60, -68, -117, 126,\n+            -59, 4, -107, -22, 99, -77, 84, 29, 87, 119, -60, 87, 82, -55, -74, 44, -80, 3, 123, -101, 84, -44, 9, 71,\n+            24, 91, 99, 22, -65, 11, -11, -14, -38, -84, 105, -101, -85, -17, 116, -65, 118, -105, 122, -75, 113,\n+            -57, -81, -33, -110, 28, 104, -24, -110, -57, -78, 38, -5, -15, -79, 87, 105, 85, 41, -42, -114, -67,\n+            -123, 70, 12, 61, 115, 5, 23, -70, 99, 96, -80, 65, -65, 105, -45, -49, 37, -33, -1, 119, -88, 100, 121,\n+            -25, -35, -51, 10, 43, -113, 61, 103, 44, 13, 108, 20, 74, 19, 53, 19, 37, -76, 20, -43, -11, 23, -58, -25,\n+            -52, 121, -40, -118, 58, 50, 19, -8, -33, -30, -49, -27, -11, -80, 93, -17, 34, 93, 69, 100, 66, -54, 40,\n+            118, 89, -52, -87, 2, 35, -120, 18, 64, 108, 31, -25, 66, 78, 6, -91, -69, -53, 17, 14, -125, 33, -31, -110,\n+            1, 5, -40, 7, 126, -122, 84, -55, -62, -22, 69, -28, 5, 45, -106, 120, 74, 94, 51, 74, 108, -19, -26, -12,\n+            49, 64, 88, 68, 41, -65, 126, 125, -1, -8, -83, -67, 74, 2, -114, -80, -119, -9, -89, -125, 21, 95, 34,\n+            -58, -74, 111, -103, 99, 95, 48, 42, 94, -50, -55, -112, -5, -26, 11, -89, -38, -19, 126, 25, 102, 119,\n+            81, -94, 70, -79, 98, 91, -73, 114, 15, 14, 87, -21, -122, -1, -90, 0, 29, -104, -91, -93, -58, -83, -48,\n+            -22, 100, -112, -41, 77, 22, -24, 112, -72, 105, 100, 6, -86, -39, 40, -43, 35, -2, 4, -94, 97, -121, 52,\n+            -22, 1, 127, -81, -4, -6, -119, 96, 35, -91, 114, 81, 91, 90, -86, -36, 34, -39, 93, -42, 69, 103, -11,\n+            107, -87, 119, -107, -114, -45, -128, -69, 96};\n+\n+    // Some utility code to help test chunked reads of the InputStream.\n+\n+    private final static int SIZE_KEY = 0;\n+    private final static int LAST_READ_KEY = 1;\n+\n+    static byte[] streamToBytes(final InputStream in) throws IOException {\n+        // new byte[7] is obviously quite slow, but helps exercise the code.\n+        return streamToBytes(in, new byte[7]);\n+    }\n+\n+    static byte[] streamToBytes(final InputStream in, byte[] buf) throws IOException {\n+        try {\n+            int[] status = fill(buf, 0, in);\n+            int size = status[SIZE_KEY];\n+            int lastRead = status[LAST_READ_KEY];\n+            while (lastRead != -1) {\n+                buf = resizeArray(buf);\n+                status = fill(buf, size, in);\n+                size = status[SIZE_KEY];\n+                lastRead = status[LAST_READ_KEY];\n+            }\n+            if (buf.length != size) {\n+                byte[] smallerBuf = new byte[size];\n+                System.arraycopy(buf, 0, smallerBuf, 0, size);\n+                buf = smallerBuf;\n+            }\n+        }\n+        finally {\n+            in.close();\n+        }\n+        return buf;\n+    }\n+\n+    private static int[] fill(final byte[] buf, final int offset, final InputStream in)\n+            throws IOException {\n+        int read = in.read(buf, offset, buf.length - offset);\n+        int lastRead = read;\n+        if (read == -1) {\n+            read = 0;\n+        }\n+        while (lastRead != -1 && read + offset < buf.length) {\n+            lastRead = in.read(buf, offset + read, buf.length - read - offset);\n+            if (lastRead != -1) {\n+                read += lastRead;\n+            }\n+        }\n+        return new int[]{offset + read, lastRead};\n+    }\n+\n+    private static byte[] resizeArray(final byte[] bytes) {\n+        byte[] biggerBytes = new byte[bytes.length * 2];\n+        System.arraycopy(bytes, 0, biggerBytes, 0, bytes.length);\n+        return biggerBytes;\n+    }\n+\n+\n+    /**\n+     * Returns an encoded and decoded copy of the same random data.\n+     * \n+     * @param size amount of random data to generate and encode\n+     * @param urlSafe true if encoding be urlSafe\n+     * @return two byte[] arrays:  [0] = decoded, [1] = encoded \n+     */\n+    static byte[][] randomData(int size, boolean urlSafe) {\n+        Random r = new Random();\n+        byte[] decoded = new byte[size];\n+        r.nextBytes(decoded);\n+        byte[] encoded = urlSafe ? Base64.encodeBase64URLSafe(decoded) : Base64.encodeBase64(decoded);\n+        return new byte[][] {decoded, encoded};\n+    }\n+\n+    /**\n+     * Tests the supplied byte[] array to see if it contains the specified byte c.\n+     *\n+     * @param bytes byte[] array to test\n+     * @param c byte to look for\n+     * @return true if bytes contains c, false otherwise\n+     */\n+    static boolean bytesContain(byte[] bytes, byte c) {\n+        for (byte b : bytes) {\n+            if (b == c) { return true; }\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/BaseNCodecTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class BaseNCodecTest {\n+\n+    BaseNCodec codec;\n+    \n+    @Before\n+    public void setUp() {\n+        codec = new BaseNCodec(0, 0, 0, 0) {\n+            @Override\n+            protected boolean isInAlphabet(byte b) {\n+                return b=='O' || b == 'K'; // allow OK\n+            }\n+            \n+            @Override\n+            void encode(byte[] pArray, int i, int length) {\n+            }\n+            \n+            @Override\n+            void decode(byte[] pArray, int i, int length) {\n+            }\n+        };        \n+    }\n+\n+    @Test\n+    public void testBaseNCodec() {\n+        assertNotNull(codec);\n+    }\n+\n+//    @Test\n+//    public void testHasData() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    @Test\n+//    public void testAvail() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    @Test\n+//    public void testEnsureBufferSize() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    @Test\n+//    public void testReadResults() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+    @Test\n+    public void testIsWhiteSpace() {\n+        assertTrue(BaseNCodec.isWhiteSpace((byte) ' '));\n+        assertTrue(BaseNCodec.isWhiteSpace((byte) '\\n'));\n+        assertTrue(BaseNCodec.isWhiteSpace((byte) '\\r'));\n+        assertTrue(BaseNCodec.isWhiteSpace((byte) '\\t'));\n+    }\n+//\n+//    @Test\n+//    public void testEncodeObject() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    @Test\n+//    public void testEncodeToString() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    @Test\n+//    public void testDecodeObject() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    @Test\n+//    public void testDecodeString() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    @Test\n+//    public void testDecodeByteArray() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    @Test\n+//    public void testEncodeByteArray() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    @Test\n+//    public void testEncodeAsString() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    @Test\n+//    public void testEncodeByteArrayIntInt() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+//    @Test\n+//    public void testDecodeByteArrayIntInt() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+//\n+    @Test\n+    public void testIsInAlphabetByte() {\n+        assertFalse(codec.isInAlphabet((byte) 0));\n+        assertFalse(codec.isInAlphabet((byte) 'a'));\n+        assertTrue(codec.isInAlphabet((byte) 'O'));\n+        assertTrue(codec.isInAlphabet((byte) 'K'));\n+    }\n+\n+    @Test\n+    public void testIsInAlphabetByteArrayBoolean() {\n+        assertTrue(codec.isInAlphabet(new byte[]{}, false));\n+        assertTrue(codec.isInAlphabet(new byte[]{'O'}, false));\n+        assertFalse(codec.isInAlphabet(new byte[]{'O',' '}, false));\n+        assertFalse(codec.isInAlphabet(new byte[]{' '}, false));\n+        assertTrue(codec.isInAlphabet(new byte[]{}, true));\n+        assertTrue(codec.isInAlphabet(new byte[]{'O'}, true));\n+        assertTrue(codec.isInAlphabet(new byte[]{'O',' '}, true));\n+        assertTrue(codec.isInAlphabet(new byte[]{' '}, true));\n+    }\n+\n+    @Test\n+    public void testIsInAlphabetString() {\n+        assertTrue(codec.isInAlphabet(\"OK\"));\n+        assertTrue(codec.isInAlphabet(\"O=K= \\t\\n\\r\"));\n+    }\n+\n+    @Test\n+    public void testContainsAlphabetOrPad() {\n+        assertFalse(codec.containsAlphabetOrPad(null));\n+        assertFalse(codec.containsAlphabetOrPad(new byte[]{}));\n+        assertTrue(codec.containsAlphabetOrPad(\"OK\".getBytes()));\n+        assertTrue(codec.containsAlphabetOrPad(\"OK \".getBytes()));\n+        assertFalse(codec.containsAlphabetOrPad(\"ok \".getBytes()));\n+        assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD}));\n+    }\n+\n+//    @Test\n+//    public void testGetEncodedLength() {\n+//        fail(\"Not yet implemented\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/BinaryCodecTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * TestCase for BinaryCodec class.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class BinaryCodecTest {\n+    /** mask with bit zero based index 0 raised */\n+    private static final int BIT_0 = 0x01;\n+\n+    /** mask with bit zero based index 0 raised */\n+    private static final int BIT_1 = 0x02;\n+\n+    /** mask with bit zero based index 0 raised */\n+    private static final int BIT_2 = 0x04;\n+\n+    /** mask with bit zero based index 0 raised */\n+    private static final int BIT_3 = 0x08;\n+\n+    /** mask with bit zero based index 0 raised */\n+    private static final int BIT_4 = 0x10;\n+\n+    /** mask with bit zero based index 0 raised */\n+    private static final int BIT_5 = 0x20;\n+\n+    /** mask with bit zero based index 0 raised */\n+    private static final int BIT_6 = 0x40;\n+\n+    /** mask with bit zero based index 0 raised */\n+    private static final int BIT_7 = 0x80;\n+\n+    /** an instance of the binary codec */\n+    BinaryCodec instance = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.instance = new BinaryCodec();\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        this.instance = null;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //\n+    // Test decode(Object)\n+    //\n+    // ------------------------------------------------------------------------\n+    /**\n+     * Tests for Object decode(Object)\n+     */\n+    @Test\n+    public void testDecodeObjectException() {\n+        try {\n+            this.instance.decode(new Object());\n+        } catch (DecoderException e) {\n+            // all is well.\n+            return;\n+        }\n+        fail(\"Expected DecoderException\");\n+    }\n+\n+    /**\n+     * Tests for Object decode(Object)\n+     */\n+    @Test\n+    public void testDecodeObject() throws Exception {\n+        byte[] bits;\n+        // With a single raw binary\n+        bits = new byte[1];\n+        assertDecodeObject(bits, \"00000000\");\n+        bits = new byte[1];\n+        bits[0] = BIT_0;\n+        assertDecodeObject(bits, \"00000001\");\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1;\n+        assertDecodeObject(bits, \"00000011\");\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        assertDecodeObject(bits, \"00000111\");\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        assertDecodeObject(bits, \"00001111\");\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        assertDecodeObject(bits, \"00011111\");\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        assertDecodeObject(bits, \"00111111\");\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        assertDecodeObject(bits, \"01111111\");\n+        bits = new byte[1];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        assertDecodeObject(bits, \"11111111\");\n+        // With a two raw binaries\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        assertDecodeObject(bits, \"0000000011111111\");\n+        bits = new byte[2];\n+        bits[1] = BIT_0;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        assertDecodeObject(bits, \"0000000111111111\");\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        assertDecodeObject(bits, \"0000001111111111\");\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        assertDecodeObject(bits, \"0000011111111111\");\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        assertDecodeObject(bits, \"0000111111111111\");\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        assertDecodeObject(bits, \"0001111111111111\");\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        assertDecodeObject(bits, \"0011111111111111\");\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        assertDecodeObject(bits, \"0111111111111111\");\n+        bits = new byte[2];\n+        bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        assertDecodeObject(bits, \"1111111111111111\");\n+        assertDecodeObject(new byte[0], null);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //\n+    // Test decode(byte[])\n+    //\n+    // ------------------------------------------------------------------------\n+    /**\n+     * Utility used to assert the encoded and decoded values.\n+     * \n+     * @param bits\n+     *            the pre-encoded data\n+     * @param encodeMe\n+     *            data to encode and compare\n+     */\n+    void assertDecodeObject(byte[] bits, String encodeMe) throws DecoderException, UnsupportedEncodingException {\n+        byte[] decoded;\n+        decoded = (byte[]) instance.decode(encodeMe);\n+        assertEquals(new String(bits), new String(decoded));\n+        if (encodeMe == null) {\n+            decoded = instance.decode((byte[]) null);\n+        } else {\n+            decoded = (byte[]) instance.decode((Object) encodeMe.getBytes(\"UTF-8\"));\n+        }\n+        assertEquals(new String(bits), new String(decoded));\n+        if (encodeMe == null) {\n+            decoded = (byte[]) instance.decode((char[]) null);\n+        } else {\n+            decoded = (byte[]) instance.decode(encodeMe.toCharArray());\n+        }\n+        assertEquals(new String(bits), new String(decoded));\n+    }\n+\n+    /*\n+     * Tests for byte[] decode(byte[])\n+     */\n+    @Test\n+    public void testDecodeByteArray() throws UnsupportedEncodingException {\n+        // With a single raw binary\n+        byte[] bits = new byte[1];\n+        byte[] decoded = instance.decode(\"00000000\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0;\n+        decoded = instance.decode(\"00000001\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1;\n+        decoded = instance.decode(\"00000011\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        decoded = instance.decode(\"00000111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        decoded = instance.decode(\"00001111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        decoded = instance.decode(\"00011111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        decoded = instance.decode(\"00111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        decoded = instance.decode(\"01111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.decode(\"11111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        // With a two raw binaries\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.decode(\"0000000011111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.decode(\"0000000111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.decode(\"0000001111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.decode(\"0000011111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.decode(\"0000111111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.decode(\"0001111111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.decode(\"0011111111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.decode(\"0111111111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.decode(\"1111111111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //\n+    // Test toByteArray(String)\n+    //\n+    // ------------------------------------------------------------------------\n+    /*\n+     * Tests for byte[] toByteArray(String)\n+     */\n+    @Test\n+    public void testToByteArrayFromString() {\n+        // With a single raw binary\n+        byte[] bits = new byte[1];\n+        byte[] decoded = instance.toByteArray(\"00000000\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0;\n+        decoded = instance.toByteArray(\"00000001\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1;\n+        decoded = instance.toByteArray(\"00000011\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        decoded = instance.toByteArray(\"00000111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        decoded = instance.toByteArray(\"00001111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        decoded = instance.toByteArray(\"00011111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        decoded = instance.toByteArray(\"00111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        decoded = instance.toByteArray(\"01111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.toByteArray(\"11111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        // With a two raw binaries\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.toByteArray(\"0000000011111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.toByteArray(\"0000000111111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.toByteArray(\"0000001111111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.toByteArray(\"0000011111111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.toByteArray(\"0000111111111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.toByteArray(\"0001111111111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.toByteArray(\"0011111111111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.toByteArray(\"0111111111111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = instance.toByteArray(\"1111111111111111\");\n+        assertEquals(new String(bits), new String(decoded));\n+        assertEquals(0, instance.toByteArray((String) null).length);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //\n+    // Test fromAscii(char[])\n+    //\n+    // ------------------------------------------------------------------------\n+    /*\n+     * Tests for byte[] fromAscii(char[])\n+     */\n+    @Test\n+    public void testFromAsciiCharArray() {\n+        assertEquals(0, BinaryCodec.fromAscii((char[]) null).length);\n+        assertEquals(0, BinaryCodec.fromAscii(new char[0]).length);\n+        // With a single raw binary\n+        byte[] bits = new byte[1];\n+        byte[] decoded = BinaryCodec.fromAscii(\"00000000\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0;\n+        decoded = BinaryCodec.fromAscii(\"00000001\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1;\n+        decoded = BinaryCodec.fromAscii(\"00000011\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        decoded = BinaryCodec.fromAscii(\"00000111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        decoded = BinaryCodec.fromAscii(\"00001111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        decoded = BinaryCodec.fromAscii(\"00011111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        decoded = BinaryCodec.fromAscii(\"00111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        decoded = BinaryCodec.fromAscii(\"01111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"11111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        // With a two raw binaries\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0000000011111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0000000111111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0000001111111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0000011111111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0000111111111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0001111111111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0011111111111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0111111111111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"1111111111111111\".toCharArray());\n+        assertEquals(new String(bits), new String(decoded));\n+        assertEquals(0, BinaryCodec.fromAscii((char[]) null).length);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //\n+    // Test fromAscii(byte[])\n+    //\n+    // ------------------------------------------------------------------------\n+    /*\n+     * Tests for byte[] fromAscii(byte[])\n+     */\n+    @Test\n+    public void testFromAsciiByteArray() throws UnsupportedEncodingException {\n+        assertEquals(0, BinaryCodec.fromAscii((byte[]) null).length);\n+        assertEquals(0, BinaryCodec.fromAscii(new byte[0]).length);\n+        // With a single raw binary\n+        byte[] bits = new byte[1];\n+        byte[] decoded = BinaryCodec.fromAscii(\"00000000\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0;\n+        decoded = BinaryCodec.fromAscii(\"00000001\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1;\n+        decoded = BinaryCodec.fromAscii(\"00000011\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        decoded = BinaryCodec.fromAscii(\"00000111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        decoded = BinaryCodec.fromAscii(\"00001111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        decoded = BinaryCodec.fromAscii(\"00011111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        decoded = BinaryCodec.fromAscii(\"00111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        decoded = BinaryCodec.fromAscii(\"01111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[1];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"11111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        // With a two raw binaries\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0000000011111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0000000111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0000001111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0000011111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0000111111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0001111111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0011111111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"0111111111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        bits = new byte[2];\n+        bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        decoded = BinaryCodec.fromAscii(\"1111111111111111\".getBytes(\"UTF-8\"));\n+        assertEquals(new String(bits), new String(decoded));\n+        assertEquals(0, BinaryCodec.fromAscii((byte[]) null).length);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //\n+    // Test encode(byte[])\n+    //\n+    // ------------------------------------------------------------------------\n+    /*\n+     * Tests for byte[] encode(byte[])\n+     */\n+    @Test\n+    public void testEncodeByteArray() {\n+        // With a single raw binary\n+        byte[] bits = new byte[1];\n+        String l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"00000000\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"00000001\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"00000011\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"00000111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"00001111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"00011111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"00111111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"01111111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"11111111\", l_encoded);\n+        // With a two raw binaries\n+        bits = new byte[2];\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000000000000000\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000000000000001\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000000000000011\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000000000000111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000000000001111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000000000011111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000000000111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000000001111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000000011111111\", l_encoded);\n+        // work on the other byte now\n+        bits = new byte[2];\n+        bits[1] = BIT_0;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000000111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000001111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000011111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0000111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0001111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0011111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"0111111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(instance.encode(bits));\n+        assertEquals(\"1111111111111111\", l_encoded);\n+        assertEquals(0, instance.encode((byte[]) null).length);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //\n+    // Test toAsciiBytes\n+    //\n+    // ------------------------------------------------------------------------\n+    @Test\n+    public void testToAsciiBytes() {\n+        // With a single raw binary\n+        byte[] bits = new byte[1];\n+        String l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"00000000\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"00000001\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"00000011\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"00000111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"00001111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"00011111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"00111111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"01111111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"11111111\", l_encoded);\n+        // With a two raw binaries\n+        bits = new byte[2];\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000000000000000\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000000000000001\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000000000000011\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000000000000111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000000000001111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000000000011111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000000000111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000000001111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000000011111111\", l_encoded);\n+        // work on the other byte now\n+        bits = new byte[2];\n+        bits[1] = BIT_0;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000000111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000001111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000011111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0000111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0001111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0011111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"0111111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiBytes(bits));\n+        assertEquals(\"1111111111111111\", l_encoded);\n+        assertEquals(0, BinaryCodec.toAsciiBytes((byte[]) null).length);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //\n+    // Test toAsciiChars\n+    //\n+    // ------------------------------------------------------------------------\n+    @Test\n+    public void testToAsciiChars() {\n+        // With a single raw binary\n+        byte[] bits = new byte[1];\n+        String l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"00000000\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"00000001\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"00000011\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"00000111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"00001111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"00011111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"00111111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"01111111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"11111111\", l_encoded);\n+        // With a two raw binaries\n+        bits = new byte[2];\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000000000000000\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000000000000001\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000000000000011\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000000000000111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000000000001111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000000000011111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000000000111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000000001111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000000011111111\", l_encoded);\n+        // work on the other byte now\n+        bits = new byte[2];\n+        bits[1] = BIT_0;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000000111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000001111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000011111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0000111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0001111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0011111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"0111111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String(BinaryCodec.toAsciiChars(bits));\n+        assertEquals(\"1111111111111111\", l_encoded);\n+        assertEquals(0, BinaryCodec.toAsciiChars((byte[]) null).length);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //\n+    // Test toAsciiString\n+    //\n+    // ------------------------------------------------------------------------\n+    /**\n+     * Tests the toAsciiString(byte[]) method\n+     */\n+    @Test\n+    public void testToAsciiString() {\n+        // With a single raw binary\n+        byte[] bits = new byte[1];\n+        String l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"00000000\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"00000001\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"00000011\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"00000111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"00001111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"00011111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"00111111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"01111111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"11111111\", l_encoded);\n+        // With a two raw binaries\n+        bits = new byte[2];\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000000000000000\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000000000000001\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000000000000011\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000000000000111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000000000001111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000000000011111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000000000111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000000001111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000000011111111\", l_encoded);\n+        // work on the other byte now\n+        bits = new byte[2];\n+        bits[1] = BIT_0;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000000111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000001111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000011111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0000111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0001111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0011111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"0111111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = BinaryCodec.toAsciiString(bits);\n+        assertEquals(\"1111111111111111\", l_encoded);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //\n+    // Test encode(Object)\n+    //\n+    // ------------------------------------------------------------------------\n+    /*\n+     * Tests for Object encode(Object)\n+     */\n+    @Test\n+    public void testEncodeObjectNull() throws Exception {\n+        Object obj = new byte[0];\n+        assertEquals(0, ((char[]) instance.encode(obj)).length);\n+    }\n+\n+    /*\n+     * Tests for Object encode(Object)\n+     */\n+    @Test\n+    public void testEncodeObjectException() {\n+        try {\n+            instance.encode(\"\");\n+        } catch (EncoderException e) {\n+            // all is well.\n+            return;\n+        }\n+        fail(\"Expected EncoderException\");\n+    }\n+\n+    /*\n+     * Tests for Object encode(Object)\n+     */\n+    @Test\n+    public void testEncodeObject() throws Exception {\n+        // With a single raw binary\n+        byte[] bits = new byte[1];\n+        String l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"00000000\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"00000001\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"00000011\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"00000111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"00001111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"00011111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"00111111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"01111111\", l_encoded);\n+        bits = new byte[1];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"11111111\", l_encoded);\n+        // With a two raw binaries\n+        bits = new byte[2];\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000000000000000\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000000000000001\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000000000000011\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000000000000111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000000000001111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000000000011111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000000000111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000000001111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000000011111111\", l_encoded);\n+        // work on the other byte now\n+        bits = new byte[2];\n+        bits[1] = BIT_0;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000000111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000001111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000011111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0000111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0001111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0011111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6;\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"0111111111111111\", l_encoded);\n+        bits = new byte[2];\n+        bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7);\n+        l_encoded = new String((char[]) instance.encode((Object) bits));\n+        assertEquals(\"1111111111111111\", l_encoded);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/Codec105ErrorInputStream.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * Emits three line-feeds '\\n' in a row, one at a time, and then EOF.\n+ * \n+ * Recreates the bug described in CODEC-105.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @since 1.5\n+ */\n+public class Codec105ErrorInputStream extends InputStream {\n+    private static final int EOF = -1;\n+\n+    int countdown = 3;\n+\n+    @Override\n+    public int read() throws IOException {\n+        if (this.countdown-- > 0) {\n+            return '\\n';\n+        } else {\n+            return EOF;\n+        }\n+    }\n+\n+    @Override\n+    public int read(byte b[], int pos, int len) throws IOException {\n+        if (this.countdown-- > 0) {\n+            b[pos] = '\\n';\n+            return 1;\n+        } else {\n+            return EOF;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/HexTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.junit.Test;\n+\n+/**\n+ * Tests {@link org.apache.commons.codec.binary.Hex}.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class HexTest {\n+\n+    private static final String BAD_ENCODING_NAME = \"UNKNOWN\";\n+    \n+    private final static boolean LOG = false;\n+\n+    private boolean charsetSanityCheck(String name) {\n+        final String source = \"the quick brown dog jumped over the lazy fox\";\n+        try {\n+            byte[] bytes = source.getBytes(name);\n+            String str = new String(bytes, name);\n+            boolean equals = source.equals(str);\n+            if (equals == false) {\n+                // Here with:\n+                //\n+                // Java Sun 1.4.2_19 x86 32-bits on Windows XP\n+                // JIS_X0212-1990\n+                // x-JIS0208\n+                //\n+                // Java Sun 1.5.0_17 x86 32-bits on Windows XP\n+                // JIS_X0212-1990\n+                // x-IBM834\n+                // x-JIS0208\n+                // x-MacDingbat\n+                // x-MacSymbol\n+                //\n+                // Java Sun 1.6.0_14 x86 32-bits\n+                // JIS_X0212-1990\n+                // x-IBM834\n+                // x-JIS0208\n+                // x-MacDingbat\n+                // x-MacSymbol\n+                // \n+                log(\"FAILED charsetSanityCheck=Interesting Java charset oddity: Roundtrip failed for \" + name);\n+            }\n+            return equals;\n+        } catch (UnsupportedEncodingException e) {\n+            // Should NEVER happen since we are getting the name from the Charset class.\n+            if (LOG) {\n+                log(\"FAILED charsetSanityCheck=\" + name + \", e=\" + e);\n+                log(e);\n+            }\n+            return false;\n+        } catch (UnsupportedOperationException e) {\n+            // Caught here with:\n+            // x-JISAutoDetect on Windows XP and Java Sun 1.4.2_19 x86 32-bits\n+            // x-JISAutoDetect on Windows XP and Java Sun 1.5.0_17 x86 32-bits\n+            // x-JISAutoDetect on Windows XP and Java Sun 1.6.0_14 x86 32-bits\n+            if (LOG) {\n+                log(\"FAILED charsetSanityCheck=\" + name + \", e=\" + e);\n+                log(e);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * @param data\n+     */\n+    private void checkDecodeHexOddCharacters(char[] data) {\n+        try {\n+            Hex.decodeHex(data);\n+            fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n+        } catch (DecoderException e) {\n+            // Expected exception\n+        }\n+    }\n+\n+    private void log(String s) {\n+        if (LOG) {\n+            System.out.println(s);\n+            System.out.flush();\n+        }\n+    }\n+\n+    private void log(Throwable t) {\n+        if (LOG) {\n+            t.printStackTrace(System.out);\n+            System.out.flush();\n+        }\n+    }\n+\n+    @Test\n+    public void testCustomCharset() throws UnsupportedEncodingException, DecoderException {\n+        for (String name : Charset.availableCharsets().keySet()) {\n+            testCustomCharset(name, \"testCustomCharset\");            \n+        }\n+    }\n+\n+    /**\n+     * @param name\n+     * @param parent\n+     *            TODO\n+     * @throws UnsupportedEncodingException\n+     * @throws DecoderException\n+     */\n+    private void testCustomCharset(String name, String parent) throws UnsupportedEncodingException, DecoderException {\n+        if (charsetSanityCheck(name) == false) {\n+            return;\n+        }\n+        log(parent + \"=\" + name);\n+        Hex customCodec = new Hex(name);\n+        // source data\n+        String sourceString = \"Hello World\";\n+        byte[] sourceBytes = sourceString.getBytes(name);\n+        // test 1\n+        // encode source to hex string to bytes with charset\n+        byte[] actualEncodedBytes = customCodec.encode(sourceBytes);\n+        // encode source to hex string...\n+        String expectedHexString = Hex.encodeHexString(sourceBytes);\n+        // ... and get the bytes in the expected charset\n+        byte[] expectedHexStringBytes = expectedHexString.getBytes(name);\n+        Assert.assertTrue(Arrays.equals(expectedHexStringBytes, actualEncodedBytes));\n+        // test 2\n+        String actualStringFromBytes = new String(actualEncodedBytes, name);\n+        assertEquals(name + \", expectedHexString=\" + expectedHexString + \", actualStringFromBytes=\" + actualStringFromBytes,\n+                expectedHexString, actualStringFromBytes);\n+        // second test:\n+        Hex utf8Codec = new Hex();\n+        expectedHexString = \"48656c6c6f20576f726c64\";\n+        byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString);\n+        actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharsetName());\n+        // sanity check:\n+        assertEquals(name, sourceString, actualStringFromBytes);\n+        // actual check:\n+        byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes);\n+        actualStringFromBytes = new String(decodedCustomBytes, name);\n+        assertEquals(name, sourceString, actualStringFromBytes);\n+    }\n+\n+    @Test\n+    public void testCustomCharsetBadNameEncodeByteArray() throws UnsupportedEncodingException {\n+        try {\n+            new Hex(BAD_ENCODING_NAME).encode(\"Hello World\".getBytes(\"UTF-8\"));\n+            fail(\"Expected \" + IllegalStateException.class.getName());\n+        } catch (IllegalStateException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testCustomCharsetBadNameEncodeObject() {\n+        try {\n+            new Hex(BAD_ENCODING_NAME).encode(\"Hello World\");\n+            fail(\"Expected \" + EncoderException.class.getName());\n+        } catch (EncoderException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testCustomCharsetBadNameDecodeObject() throws UnsupportedEncodingException {\n+        try {\n+            new Hex(BAD_ENCODING_NAME).decode(\"Hello World\".getBytes(\"UTF-8\"));\n+            fail(\"Expected \" + DecoderException.class.getName());\n+        } catch (DecoderException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testCustomCharsetToString() {\n+        assertTrue(new Hex().toString().indexOf(Hex.DEFAULT_CHARSET_NAME) >= 0);\n+    }\n+\n+    @Test\n+    public void testDecodeArrayOddCharacters() {\n+        try {\n+            new Hex().decode(new byte[]{65});\n+            fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n+        } catch (DecoderException e) {\n+            // Expected exception\n+        }\n+    }\n+\n+    @Test\n+    public void testDecodeBadCharacterPos0() {\n+        try {\n+            new Hex().decode(\"q0\");\n+            fail(\"An exception wasn't thrown when trying to decode an illegal character\");\n+        } catch (DecoderException e) {\n+            // Expected exception\n+        }\n+    }\n+\n+    @Test\n+    public void testDecodeBadCharacterPos1() {\n+        try {\n+            new Hex().decode(\"0q\");\n+            fail(\"An exception wasn't thrown when trying to decode an illegal character\");\n+        } catch (DecoderException e) {\n+            // Expected exception\n+        }\n+    }\n+\n+    @Test\n+    public void testDecodeClassCastException() {\n+        try {\n+            new Hex().decode(new int[]{65});\n+            fail(\"An exception wasn't thrown when trying to decode.\");\n+        } catch (DecoderException e) {\n+            // Expected exception\n+        }\n+    }\n+\n+    @Test\n+    public void testDecodeHexOddCharacters1() {\n+        checkDecodeHexOddCharacters(new char[]{'A'});\n+    }\n+\n+    @Test\n+    public void testDecodeHexOddCharacters3() {\n+        checkDecodeHexOddCharacters(new char[]{'A', 'B', 'C'});\n+    }\n+\n+    @Test\n+    public void testDecodeHexOddCharacters5() {\n+        checkDecodeHexOddCharacters(new char[]{'A', 'B', 'C', 'D', 'E'});\n+    }\n+\n+    @Test\n+    public void testDecodeStringOddCharacters() {\n+        try {\n+            new Hex().decode(\"6\");\n+            fail(\"An exception wasn't thrown when trying to decode an odd number of characters\");\n+        } catch (DecoderException e) {\n+            // Expected exception\n+        }\n+    }\n+\n+    @Test\n+    public void testDencodeEmpty() throws DecoderException {\n+        assertTrue(Arrays.equals(new byte[0], Hex.decodeHex(new char[0])));\n+        assertTrue(Arrays.equals(new byte[0], new Hex().decode(new byte[0])));\n+        assertTrue(Arrays.equals(new byte[0], (byte[]) new Hex().decode(\"\")));\n+    }\n+\n+    @Test\n+    public void testEncodeClassCastException() {\n+        try {\n+            new Hex().encode(new int[]{65});\n+            fail(\"An exception wasn't thrown when trying to encode.\");\n+        } catch (EncoderException e) {\n+            // Expected exception\n+        }\n+    }\n+\n+    @Test\n+    public void testEncodeDecodeRandom() throws DecoderException, EncoderException {\n+        Random random = new Random();\n+\n+        Hex hex = new Hex();\n+        for (int i = 5; i > 0; i--) {\n+            byte[] data = new byte[random.nextInt(10000) + 1];\n+            random.nextBytes(data);\n+\n+            // static API\n+            char[] encodedChars = Hex.encodeHex(data);\n+            byte[] decodedBytes = Hex.decodeHex(encodedChars);\n+            assertTrue(Arrays.equals(data, decodedBytes));\n+\n+            // instance API with array parameter\n+            byte[] encodedStringBytes = hex.encode(data);\n+            decodedBytes = hex.decode(encodedStringBytes);\n+            assertTrue(Arrays.equals(data, decodedBytes));\n+\n+            // instance API with char[] (Object) parameter\n+            String dataString = new String(encodedChars);\n+            char[] encodedStringChars = (char[]) hex.encode(dataString);\n+            decodedBytes = (byte[]) hex.decode(encodedStringChars);\n+            assertTrue(Arrays.equals(StringUtils.getBytesUtf8(dataString), decodedBytes));\n+\n+            // instance API with String (Object) parameter\n+            dataString = new String(encodedChars);\n+            encodedStringChars = (char[]) hex.encode(dataString);\n+            decodedBytes = (byte[]) hex.decode(new String(encodedStringChars));\n+            assertTrue(Arrays.equals(StringUtils.getBytesUtf8(dataString), decodedBytes));\n+        }\n+    }\n+\n+    @Test\n+    public void testEncodeEmpty() throws EncoderException {\n+        assertTrue(Arrays.equals(new char[0], Hex.encodeHex(new byte[0])));\n+        assertTrue(Arrays.equals(new byte[0], new Hex().encode(new byte[0])));\n+        assertTrue(Arrays.equals(new char[0], (char[]) new Hex().encode(\"\")));\n+    }\n+\n+    @Test\n+    public void testEncodeZeroes() {\n+        char[] c = Hex.encodeHex(new byte[36]);\n+        assertEquals(\"000000000000000000000000000000000000000000000000000000000000000000000000\", new String(c));\n+    }\n+\n+    @Test\n+    public void testHelloWorldLowerCaseHex() {\n+        byte[] b = StringUtils.getBytesUtf8(\"Hello World\");\n+        final String expected = \"48656c6c6f20576f726c64\";\n+        char[] actual;\n+        actual = Hex.encodeHex(b);\n+        assertTrue(expected.equals(new String(actual)));\n+        actual = Hex.encodeHex(b, true);\n+        assertTrue(expected.equals(new String(actual)));\n+        actual = Hex.encodeHex(b, false);\n+        assertFalse(expected.equals(new String(actual)));\n+    }\n+\n+    @Test\n+    public void testHelloWorldUpperCaseHex() {\n+        byte[] b = StringUtils.getBytesUtf8(\"Hello World\");\n+        final String expected = \"48656C6C6F20576F726C64\";\n+        char[] actual;\n+        actual = Hex.encodeHex(b);\n+        assertFalse(expected.equals(new String(actual)));\n+        actual = Hex.encodeHex(b, true);\n+        assertFalse(expected.equals(new String(actual)));\n+        actual = Hex.encodeHex(b, false);\n+        assertTrue(expected.equals(new String(actual)));\n+    }\n+\n+    @Test\n+    public void testRequiredCharset() throws UnsupportedEncodingException, DecoderException {\n+        testCustomCharset(\"UTF-8\", \"testRequiredCharset\");\n+        testCustomCharset(\"UTF-16\", \"testRequiredCharset\");\n+        testCustomCharset(\"UTF-16BE\", \"testRequiredCharset\");\n+        testCustomCharset(\"UTF-16LE\", \"testRequiredCharset\");\n+        testCustomCharset(\"US-ASCII\", \"testRequiredCharset\");\n+        testCustomCharset(\"ISO8859_1\", \"testRequiredCharset\");\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/binary/StringUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+\n+import junit.framework.Assert;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Tests {@link StringUtils}\n+ * \n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class StringUtilsTest {\n+\n+    private static final byte[] BYTES_FIXTURE = {'a','b','c'};\n+\n+    private static final String STRING_FIXTURE = \"ABC\";\n+\n+    /**\n+     * We could make the constructor private but there does not seem to be a point to jumping through extra code hoops\n+     * to restrict instantiation right now.\n+     */\n+    @Test\n+    public void testConstructor() {\n+        new StringUtils();\n+    }\n+\n+    @Test\n+    public void testGetBytesIso8859_1() throws UnsupportedEncodingException {\n+        String charsetName = \"ISO-8859-1\";\n+        testGetBytesUnchecked(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesIso8859_1(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    private void testGetBytesUnchecked(String charsetName) throws UnsupportedEncodingException {\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUnchecked(STRING_FIXTURE, charsetName);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    @Test\n+    public void testGetBytesUsAscii() throws UnsupportedEncodingException {\n+        String charsetName = \"US-ASCII\";\n+        testGetBytesUnchecked(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUsAscii(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    @Test\n+    public void testGetBytesUtf16() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16\";\n+        testGetBytesUnchecked(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUtf16(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    @Test\n+    public void testGetBytesUtf16Be() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16BE\";\n+        testGetBytesUnchecked(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUtf16Be(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    @Test\n+    public void testGetBytesUtf16Le() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16LE\";\n+        testGetBytesUnchecked(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUtf16Le(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    @Test\n+    public void testGetBytesUtf8() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-8\";\n+        testGetBytesUnchecked(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    @Test\n+    public void testGetBytesUncheckedBadName() {\n+        try {\n+            StringUtils.getBytesUnchecked(STRING_FIXTURE, \"UNKNOWN\");\n+            Assert.fail(\"Expected \" + IllegalStateException.class.getName());\n+        } catch (IllegalStateException e) {\n+            // Expected\n+        }\n+    }\n+\n+    private void testNewString(String charsetName) throws UnsupportedEncodingException {\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newString(BYTES_FIXTURE, charsetName);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNewStringBadEnc() {\n+        try {\n+            StringUtils.newString(BYTES_FIXTURE, \"UNKNOWN\");\n+            Assert.fail(\"Expected \" + IllegalStateException.class.getName());\n+        } catch (IllegalStateException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test\n+    public void testNewStringIso8859_1() throws UnsupportedEncodingException {\n+        String charsetName = \"ISO-8859-1\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringIso8859_1(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNewStringUsAscii() throws UnsupportedEncodingException {\n+        String charsetName = \"US-ASCII\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringUsAscii(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNewStringUtf16() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringUtf16(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNewStringUtf16Be() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16BE\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringUtf16Be(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNewStringUtf16Le() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16LE\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringUtf16Le(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNewStringUtf8() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-8\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringUtf8(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/digest/DigestUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.digest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.Random;\n+\n+import org.apache.commons.codec.binary.StringUtils;\n+import org.junit.Test;\n+\n+/**\n+ * Tests DigestUtils methods.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class DigestUtilsTest {\n+\n+    private final byte[] testData = new byte[1024*1024];\n+    \n+    private byte[] getBytesUtf8(String hashMe) {\n+        return StringUtils.getBytesUtf8(hashMe);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see junit.framework.TestCase#setUp()\n+     */\n+    protected void setUp() throws Exception {\n+        new Random().nextBytes(testData);\n+    }\n+\n+    @Test\n+    public void testConstructable() {\n+        new DigestUtils();\n+    }\n+    \n+    @Test\n+    public void testInternalNoSuchAlgorithmException() {\n+        try {\n+            DigestUtils.getDigest(\"Bogus Bogus\");\n+            fail(\"A RuntimeException should have been thrown.\");\n+        } catch (RuntimeException e) {\n+            // Expected exception.\n+        }\n+    }\n+\n+    @Test\n+    public void testMd5Hex() throws IOException {\n+        // Examples from RFC 1321\n+        assertEquals(\"d41d8cd98f00b204e9800998ecf8427e\", DigestUtils.md5Hex(\"\"));\n+\n+        assertEquals(\"0cc175b9c0f1b6a831c399e269772661\", DigestUtils.md5Hex(\"a\"));\n+\n+        assertEquals(\"900150983cd24fb0d6963f7d28e17f72\", DigestUtils.md5Hex(\"abc\"));\n+\n+        assertEquals(\"f96b697d7cb7938d525a2f31aaf161d0\", DigestUtils.md5Hex(\"message digest\"));\n+\n+        assertEquals(\"c3fcd3d76192e4007dfb496cca67e13b\", DigestUtils.md5Hex(\"abcdefghijklmnopqrstuvwxyz\"));\n+\n+        assertEquals(\n+            \"d174ab98d277d9f5a5611c2c9f419d9f\",\n+            DigestUtils.md5Hex(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz\" + \"0123456789\"));\n+\n+        assertEquals(\n+            \"57edf4a22be3c955ac49da2e2107b67a\",\n+            DigestUtils.md5Hex(\"1234567890123456789012345678901234567890\" + \"1234567890123456789012345678901234567890\"));\n+\n+        assertEquals(DigestUtils.md5Hex(testData),\n+                DigestUtils.md5Hex(new ByteArrayInputStream(testData)));\n+    }\n+\n+    /**\n+     * An MD5 hash converted to hex should always be 32 characters.\n+     */\n+    @Test\n+    public void testMD5HexLength() {\n+        String hashMe = \"this is some string that is longer than 32 characters\";\n+        String hash = DigestUtils.md5Hex(getBytesUtf8(hashMe));\n+        assertEquals(32, hash.length());\n+\n+        hashMe = \"length < 32\";\n+        hash = DigestUtils.md5Hex(getBytesUtf8(hashMe));\n+        assertEquals(32, hash.length());\n+    }\n+\n+    /**\n+     * An MD5 hash should always be a 16 element byte[].\n+     */\n+    @Test\n+    public void testMD5Length() {\n+        String hashMe = \"this is some string that is longer than 16 characters\";\n+        byte[] hash = DigestUtils.md5(getBytesUtf8(hashMe));\n+        assertEquals(16, hash.length);\n+\n+        hashMe = \"length < 16\";\n+        hash = DigestUtils.md5(getBytesUtf8(hashMe));\n+        assertEquals(16, hash.length);\n+    }\n+\n+    @Test\n+    public void testSha256() throws IOException {\n+    // Examples from FIPS 180-2\n+    assertEquals(\"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\",\n+             DigestUtils.sha256Hex(\"abc\"));\n+    assertEquals(\"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\",\n+             DigestUtils.sha256Hex(getBytesUtf8(\"abc\")));\n+    assertEquals(\"248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1\",\n+             DigestUtils.sha256Hex(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"));\n+    \n+    assertEquals(DigestUtils.sha256Hex(testData),\n+            DigestUtils.sha256Hex(new ByteArrayInputStream(testData)));\n+    }    \n+\n+    @Test\n+    public void testSha384() throws IOException {\n+    // Examples from FIPS 180-2\n+    assertEquals(\"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed\" + \n+             \"8086072ba1e7cc2358baeca134c825a7\",\n+             DigestUtils.sha384Hex(\"abc\"));\n+    assertEquals(\"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed\" + \n+             \"8086072ba1e7cc2358baeca134c825a7\",\n+             DigestUtils.sha384Hex(getBytesUtf8(\"abc\")));\n+    assertEquals(\"09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712\" +\n+            \"fcc7c71a557e2db966c3e9fa91746039\",\n+             DigestUtils.sha384Hex(\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn\" +\n+                       \"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"));\n+    assertEquals(DigestUtils.sha384Hex(testData),\n+            DigestUtils.sha384Hex(new ByteArrayInputStream(testData)));\n+    }\n+\n+    @Test\n+    public void testSha512() throws IOException {\n+    // Examples from FIPS 180-2\n+    assertEquals(\"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a\" +\n+            \"2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\",\n+             DigestUtils.sha512Hex(\"abc\"));\n+    assertEquals(\"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a\" +\n+             \"2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\",\n+             DigestUtils.sha512Hex(getBytesUtf8(\"abc\")));\n+    assertEquals(\"8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018\" + \n+             \"501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909\",\n+             DigestUtils.sha512Hex(\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn\" + \n+                       \"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"));\n+    assertEquals(DigestUtils.sha512Hex(testData),\n+            DigestUtils.sha512Hex(new ByteArrayInputStream(testData)));\n+}    \n+\n+    @Test\n+    public void testShaHex() throws IOException {\n+        // Examples from FIPS 180-1\n+        assertEquals(\"a9993e364706816aba3e25717850c26c9cd0d89d\", DigestUtils.shaHex(\"abc\"));\n+\n+        assertEquals(\"a9993e364706816aba3e25717850c26c9cd0d89d\", DigestUtils.shaHex(getBytesUtf8(\"abc\")));\n+\n+        assertEquals(\n+            \"84983e441c3bd26ebaae4aa1f95129e5e54670f1\",\n+            DigestUtils.shaHex(\"abcdbcdecdefdefgefghfghighij\" + \"hijkijkljklmklmnlmnomnopnopq\"));\n+        assertEquals(DigestUtils.shaHex(testData),\n+                DigestUtils.shaHex(new ByteArrayInputStream(testData)));\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/Caverphone1Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Test;\n+\n+/**\n+ * Tests Caverphone1.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id: CaverphoneTest.java 1075947 2011-03-01 17:56:14Z ggregory $\n+ * @since 1.5\n+ */\n+public class Caverphone1Test extends StringEncoderAbstractTest {\n+\n+    @Override\n+    protected StringEncoder createStringEncoder() {\n+        return new Caverphone1();\n+    }\n+\n+    /**\n+     * Tests example adapted from version 2.0  http://caversham.otago.ac.nz/files/working/ctp150804.pdf\n+     * \n+     * AT1111 words: add, aid, at, art, eat, earth, head, hit, hot, hold, hard, heart, it, out, old\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testCaverphoneRevisitedCommonCodeAT1111() throws EncoderException {\n+        this.checkEncodingVariations(\"AT1111\", new String[]{\n+            \"add\",\n+            \"aid\",\n+            \"at\",\n+            \"art\",\n+            \"eat\",\n+            \"earth\",\n+            \"head\",\n+            \"hit\",\n+            \"hot\",\n+            \"hold\",\n+            \"hard\",\n+            \"heart\",\n+            \"it\",\n+            \"out\",\n+            \"old\"});\n+    }\n+\n+    @Test\n+    public void testEndMb() throws EncoderException {\n+        String[][] data = {{\"mb\", \"M11111\"}, {\"mbmb\", \"MPM111\"}};\n+        this.checkEncodings(data);\n+    }\n+\n+    /**\n+     * Tests some examples from version 2.0 http://caversham.otago.ac.nz/files/working/ctp150804.pdf\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testIsCaverphoneEquals() throws EncoderException {\n+        Caverphone1 caverphone = new Caverphone1();\n+        Assert.assertFalse(\"Caverphone encodings should not be equal\", caverphone.isEncodeEqual(\"Peter\", \"Stevenson\"));\n+        Assert.assertTrue(\"Caverphone encodings should be equal\", caverphone.isEncodeEqual(\"Peter\", \"Peady\"));\n+    }\n+\n+    /**\n+     * Tests example from http://caversham.otago.ac.nz/files/working/ctp060902.pdf\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testSpecificationV1Examples() throws EncoderException {\n+        String[][] data = {{\"David\", \"TFT111\"}, {\"Whittle\", \"WTL111\"}};\n+        this.checkEncodings(data);\n+    }\n+\n+    /**\n+     * Tests examples from http://en.wikipedia.org/wiki/Caverphone\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testWikipediaExamples() throws EncoderException {\n+        String[][] data = {{\"Lee\", \"L11111\"}, {\"Thompson\", \"TMPSN1\"}};\n+        this.checkEncodings(data);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/Caverphone2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Test;\n+\n+/**\n+ * Tests Caverphone2.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ * @since 1.5\n+ */\n+public class Caverphone2Test extends StringEncoderAbstractTest {\n+\n+    @Override\n+    protected StringEncoder createStringEncoder() {\n+        return new Caverphone2();\n+    }\n+\n+    /**\n+     * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf\n+     * \n+     * AT11111111 words: add, aid, at, art, eat, earth, head, hit, hot, hold, hard, heart, it, out, old\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testCaverphoneRevisitedCommonCodeAT11111111() throws EncoderException {\n+        this.checkEncodingVariations(\"AT11111111\", new String[]{\n+            \"add\",\n+            \"aid\",\n+            \"at\",\n+            \"art\",\n+            \"eat\",\n+            \"earth\",\n+            \"head\",\n+            \"hit\",\n+            \"hot\",\n+            \"hold\",\n+            \"hard\",\n+            \"heart\",\n+            \"it\",\n+            \"out\",\n+            \"old\"});\n+    }\n+\n+    /**\n+     * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testCaverphoneRevisitedExamples() throws EncoderException {\n+        String[][] data = {{\"Stevenson\", \"STFNSN1111\"}, {\"Peter\", \"PTA1111111\"}};\n+        this.checkEncodings(data);\n+    }\n+\n+    /**\n+     * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testCaverphoneRevisitedRandomNameKLN1111111() throws EncoderException {\n+        this.checkEncodingVariations(\"KLN1111111\", new String[]{\n+            \"Cailean\",\n+            \"Calan\",\n+            \"Calen\",\n+            \"Callahan\",\n+            \"Callan\",\n+            \"Callean\",\n+            \"Carleen\",\n+            \"Carlen\",\n+            \"Carlene\",\n+            \"Carlin\",\n+            \"Carline\",\n+            \"Carlyn\",\n+            \"Carlynn\",\n+            \"Carlynne\",\n+            \"Charlean\",\n+            \"Charleen\",\n+            \"Charlene\",\n+            \"Charline\",\n+            \"Cherlyn\",\n+            \"Chirlin\",\n+            \"Clein\",\n+            \"Cleon\",\n+            \"Cline\",\n+            \"Cohleen\",\n+            \"Colan\",\n+            \"Coleen\",\n+            \"Colene\",\n+            \"Colin\",\n+            \"Colleen\",\n+            \"Collen\",\n+            \"Collin\",\n+            \"Colline\",\n+            \"Colon\",\n+            \"Cullan\",\n+            \"Cullen\",\n+            \"Cullin\",\n+            \"Gaelan\",\n+            \"Galan\",\n+            \"Galen\",\n+            \"Garlan\",\n+            \"Garlen\",\n+            \"Gaulin\",\n+            \"Gayleen\",\n+            \"Gaylene\",\n+            \"Giliane\",\n+            \"Gillan\",\n+            \"Gillian\",\n+            \"Glen\",\n+            \"Glenn\",\n+            \"Glyn\",\n+            \"Glynn\",\n+            \"Gollin\",\n+            \"Gorlin\",\n+            \"Kalin\",\n+            \"Karlan\",\n+            \"Karleen\",\n+            \"Karlen\",\n+            \"Karlene\",\n+            \"Karlin\",\n+            \"Karlyn\",\n+            \"Kaylyn\",\n+            \"Keelin\",\n+            \"Kellen\",\n+            \"Kellene\",\n+            \"Kellyann\",\n+            \"Kellyn\",\n+            \"Khalin\",\n+            \"Kilan\",\n+            \"Kilian\",\n+            \"Killen\",\n+            \"Killian\",\n+            \"Killion\",\n+            \"Klein\",\n+            \"Kleon\",\n+            \"Kline\",\n+            \"Koerlin\",\n+            \"Kylen\",\n+            \"Kylynn\",\n+            \"Quillan\",\n+            \"Quillon\",\n+            \"Qulllon\",\n+            \"Xylon\"});\n+    }\n+\n+    /**\n+     * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testCaverphoneRevisitedRandomNameTN11111111() throws EncoderException {\n+        this.checkEncodingVariations(\"TN11111111\", new String[]{\n+            \"Dan\",\n+            \"Dane\",\n+            \"Dann\",\n+            \"Darn\",\n+            \"Daune\",\n+            \"Dawn\",\n+            \"Ddene\",\n+            \"Dean\",\n+            \"Deane\",\n+            \"Deanne\",\n+            \"DeeAnn\",\n+            \"Deeann\",\n+            \"Deeanne\",\n+            \"Deeyn\",\n+            \"Den\",\n+            \"Dene\",\n+            \"Denn\",\n+            \"Deonne\",\n+            \"Diahann\",\n+            \"Dian\",\n+            \"Diane\",\n+            \"Diann\",\n+            \"Dianne\",\n+            \"Diannne\",\n+            \"Dine\",\n+            \"Dion\",\n+            \"Dione\",\n+            \"Dionne\",\n+            \"Doane\",\n+            \"Doehne\",\n+            \"Don\",\n+            \"Donn\",\n+            \"Doone\",\n+            \"Dorn\",\n+            \"Down\",\n+            \"Downe\",\n+            \"Duane\",\n+            \"Dun\",\n+            \"Dunn\",\n+            \"Duyne\",\n+            \"Dyan\",\n+            \"Dyane\",\n+            \"Dyann\",\n+            \"Dyanne\",\n+            \"Dyun\",\n+            \"Tan\",\n+            \"Tann\",\n+            \"Teahan\",\n+            \"Ten\",\n+            \"Tenn\",\n+            \"Terhune\",\n+            \"Thain\",\n+            \"Thaine\",\n+            \"Thane\",\n+            \"Thanh\",\n+            \"Thayne\",\n+            \"Theone\",\n+            \"Thin\",\n+            \"Thorn\",\n+            \"Thorne\",\n+            \"Thun\",\n+            \"Thynne\",\n+            \"Tien\",\n+            \"Tine\",\n+            \"Tjon\",\n+            \"Town\",\n+            \"Towne\",\n+            \"Turne\",\n+            \"Tyne\"});\n+    }\n+\n+    /**\n+     * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testCaverphoneRevisitedRandomNameTTA1111111() throws EncoderException {\n+        this.checkEncodingVariations(\"TTA1111111\", new String[]{\n+            \"Darda\",\n+            \"Datha\",\n+            \"Dedie\",\n+            \"Deedee\",\n+            \"Deerdre\",\n+            \"Deidre\",\n+            \"Deirdre\",\n+            \"Detta\",\n+            \"Didi\",\n+            \"Didier\",\n+            \"Dido\",\n+            \"Dierdre\",\n+            \"Dieter\",\n+            \"Dita\",\n+            \"Ditter\",\n+            \"Dodi\",\n+            \"Dodie\",\n+            \"Dody\",\n+            \"Doherty\",\n+            \"Dorthea\",\n+            \"Dorthy\",\n+            \"Doti\",\n+            \"Dotti\",\n+            \"Dottie\",\n+            \"Dotty\",\n+            \"Doty\",\n+            \"Doughty\",\n+            \"Douty\",\n+            \"Dowdell\",\n+            \"Duthie\",\n+            \"Tada\",\n+            \"Taddeo\",\n+            \"Tadeo\",\n+            \"Tadio\",\n+            \"Tati\",\n+            \"Teador\",\n+            \"Tedda\",\n+            \"Tedder\",\n+            \"Teddi\",\n+            \"Teddie\",\n+            \"Teddy\",\n+            \"Tedi\",\n+            \"Tedie\",\n+            \"Teeter\",\n+            \"Teodoor\",\n+            \"Teodor\",\n+            \"Terti\",\n+            \"Theda\",\n+            \"Theodor\",\n+            \"Theodore\",\n+            \"Theta\",\n+            \"Thilda\",\n+            \"Thordia\",\n+            \"Tilda\",\n+            \"Tildi\",\n+            \"Tildie\",\n+            \"Tildy\",\n+            \"Tita\",\n+            \"Tito\",\n+            \"Tjader\",\n+            \"Toddie\",\n+            \"Toddy\",\n+            \"Torto\",\n+            \"Tuddor\",\n+            \"Tudor\",\n+            \"Turtle\",\n+            \"Tuttle\",\n+            \"Tutto\"});\n+    }\n+\n+    /**\n+     * See http://caversham.otago.ac.nz/files/working/ctp150804.pdf\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testCaverphoneRevisitedRandomWords() throws EncoderException {\n+        this.checkEncodingVariations(\"RTA1111111\", new String[]{\"rather\", \"ready\", \"writer\"});\n+        this.checkEncoding(\"SSA1111111\", \"social\");\n+        this.checkEncodingVariations(\"APA1111111\", new String[]{\"able\", \"appear\"});\n+    }\n+\n+    @Test\n+    public void testEndMb() throws EncoderException {\n+        String[][] data = {{\"mb\", \"M111111111\"}, {\"mbmb\", \"MPM1111111\"}};\n+        this.checkEncodings(data);\n+    }\n+\n+    // Caverphone Revisited\n+    @Test\n+    public void testIsCaverphoneEquals() throws EncoderException {\n+        Caverphone2 caverphone = new Caverphone2();\n+        Assert.assertFalse(\"Caverphone encodings should not be equal\", caverphone.isEncodeEqual(\"Peter\", \"Stevenson\"));\n+        Assert.assertTrue(\"Caverphone encodings should be equal\", caverphone.isEncodeEqual(\"Peter\", \"Peady\"));\n+    }\n+\n+    @Test\n+    public void testSpecificationExamples() throws EncoderException {\n+        String[][] data = {\n+            {\"Peter\", \"PTA1111111\"},\n+            {\"ready\", \"RTA1111111\"},\n+            {\"social\", \"SSA1111111\"},\n+            {\"able\", \"APA1111111\"},\n+            {\"Tedder\", \"TTA1111111\"},\n+            {\"Karleen\", \"KLN1111111\"},\n+            {\"Dyun\", \"TN11111111\"}};\n+        this.checkEncodings(data);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/ColognePhoneticTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Test;\n+\n+/**\n+ * Tests the {@code ColognePhonetic} class.\n+ * \n+ * <p>Keep this file in UTF-8 encoding for proper Javadoc processing.</p>\n+ * \n+ * @author ggregory\n+ */\n+public class ColognePhoneticTest extends StringEncoderAbstractTest {\n+\n+    @Override\n+    protected StringEncoder createStringEncoder() {\n+        return new ColognePhonetic();\n+    }\n+\n+    @Test\n+    public void testAabjoe() throws EncoderException {\n+        this.checkEncoding(\"01\", \"Aabjoe\");\n+    }\n+\n+    @Test\n+    public void testAaclan() throws EncoderException {\n+        this.checkEncoding(\"0856\", \"Aaclan\");\n+    }\n+    \n+    /**\n+     * Tests [CODEC-122]\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testAychlmajrForCodec122() throws EncoderException {\n+        this.checkEncoding(\"04567\", \"Aychlmajr\");\n+    }\n+\n+    @Test\n+    public void testEdgeCases() throws EncoderException {\n+        String[][] data = {\n+            {\"a\", \"0\"},\n+            {\"e\", \"0\"},\n+            {\"i\", \"0\"},\n+            {\"o\", \"0\"},\n+            {\"u\", \"0\"},\n+            {\"\\u00E4\", \"0\"}, // a-umlaut\n+            {\"\\u00F6\", \"0\"}, // o-umlaut\n+            {\"\\u00FC\", \"0\"}, // u-umlaut\n+            {\"aa\", \"0\"},\n+            {\"ha\", \"0\"},\n+            {\"h\", \"\"},\n+            {\"aha\", \"0\"},\n+            {\"b\", \"1\"},\n+            {\"p\", \"1\"},\n+            {\"ph\", \"3\"},\n+            {\"f\", \"3\"},\n+            {\"v\", \"3\"},\n+            {\"w\", \"3\"},\n+            {\"g\", \"4\"},\n+            {\"k\", \"4\"},\n+            {\"q\", \"4\"},\n+            {\"x\", \"48\"},\n+            {\"ax\", \"048\"},\n+            {\"cx\", \"48\"},\n+            {\"l\", \"5\"},\n+            {\"cl\", \"45\"},\n+            {\"acl\", \"085\"},\n+            {\"mn\", \"6\"},\n+            {\"r\", \"7\"}};\n+        this.checkEncodings(data);\n+    }\n+\n+    @Test\n+    public void testExamples() throws EncoderException {\n+        String[][] data = {\n+            {\"m\\u00DCller\", \"657\"}, // m\u00dcller - why upper case U-umlaut?\n+            {\"schmidt\", \"862\"},\n+            {\"schneider\", \"8627\"},\n+            {\"fischer\", \"387\"},\n+            {\"weber\", \"317\"},\n+            {\"wagner\", \"3467\"},\n+            {\"becker\", \"147\"},\n+            {\"hoffmann\", \"0366\"},\n+            {\"sch\\u00C4fer\", \"837\"}, // sch\u00c4fer - why upper case A-umlaut ?\n+            {\"Breschnew\", \"17863\"},\n+            {\"Wikipedia\", \"3412\"},\n+            {\"peter\", \"127\"},\n+            {\"pharma\", \"376\"},\n+            {\"m\\u00f6nchengladbach\", \"664645214\"}, // m\u00f6nchengladbach \n+            {\"deutsch\", \"28\"},\n+            {\"deutz\", \"28\"},\n+            {\"hamburg\", \"06174\"},\n+            {\"hannover\", \"0637\"},\n+            {\"christstollen\", \"478256\"},\n+            {\"Xanthippe\", \"48621\"},\n+            {\"Zacharias\", \"8478\"},\n+            {\"Holzbau\", \"0581\"},\n+            {\"matsch\", \"68\"},\n+            {\"matz\", \"68\"},\n+            {\"Arbeitsamt\", \"071862\"},\n+            {\"Eberhard\", \"01772\"},\n+            {\"Eberhardt\", \"01772\"},\n+            {\"heithabu\", \"021\"}};\n+        this.checkEncodings(data);\n+    }\n+\n+    @Test\n+    public void testHyphen() throws EncoderException {\n+        String[][] data = {{\"bergisch-gladbach\", \"174845214\"}, \n+                {\"M\\u00fcller-L\\u00fcdenscheidt\", \"65752682\"}}; // M\u00fcller-L\u00fcdenscheidt\n+        this.checkEncodings(data);\n+    }\n+\n+    @Test\n+    public void testIsEncodeEquals() {\n+        String[][] data = {\n+            {\"Meyer\", \"M\\u00fcller\"}, // M\u00fcller\n+            {\"Meyer\", \"Mayr\"},\n+            {\"house\", \"house\"},\n+            {\"House\", \"house\"},\n+            {\"Haus\", \"house\"},\n+            {\"ganz\", \"Gans\"},\n+            {\"ganz\", \"G\\u00e4nse\"}, // G\u00e4nse\n+            {\"Miyagi\", \"Miyako\"}};\n+        for (String[] element : data) {\n+            ((ColognePhonetic) this.getStringEncoder()).isEncodeEqual(element[1], element[0]);\n+        }\n+    }\n+\n+    @Test\n+    public void testVariationsMella() throws EncoderException {\n+        String data[] = {\"mella\", \"milah\", \"moulla\", \"mellah\", \"muehle\", \"mule\"};\n+        this.checkEncodingVariations(\"65\", data);\n+    }\n+\n+    @Test\n+    public void testVariationsMeyer() throws EncoderException {\n+        String data[] = {\"Meier\", \"Maier\", \"Mair\", \"Meyer\", \"Meyr\", \"Mejer\", \"Major\"};\n+        this.checkEncodingVariations(\"67\", data);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/DoubleMetaphone2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Test;\n+\n+/**\n+ * Tests {@link DoubleMetaphone}.\n+ * <p>\n+ * The test data was extracted from Stephen Woodbridge's <a\n+ * href=\"http://swoodbridge.com/DoubleMetaPhone/surnames.txt\">PHP test program</a>.\n+ * \n+ * @see <a href=\"http://swoodbridge.com/DoubleMetaPhone/surnames.txt\">PHP test program</a>\n+ * @version $Id$\n+ */\n+public class DoubleMetaphone2Test extends StringEncoderAbstractTest {\n+\n+    private static final int ALTERNATE_INDEX = 2;\n+\n+    private static final int PRIMARY_INDEX = 1;\n+\n+    /** Test values and their expected primary & alternate Double Metaphone encodings */\n+    private static final String[][] TEST_DATA = new String[][]{\n+        {\"ALLERTON\", \"ALRT\", \"ALRT\"},\n+        {\"Acton\", \"AKTN\", \"AKTN\"},\n+        {\"Adams\", \"ATMS\", \"ATMS\"},\n+        {\"Aggar\", \"AKR\", \"AKR\"},\n+        {\"Ahl\", \"AL\", \"AL\"},\n+        {\"Aiken\", \"AKN\", \"AKN\"},\n+        {\"Alan\", \"ALN\", \"ALN\"},\n+        {\"Alcock\", \"ALKK\", \"ALKK\"},\n+        {\"Alden\", \"ALTN\", \"ALTN\"},\n+        {\"Aldham\", \"ALTM\", \"ALTM\"},\n+        {\"Allen\", \"ALN\", \"ALN\"},\n+        {\"Allerton\", \"ALRT\", \"ALRT\"},\n+        {\"Alsop\", \"ALSP\", \"ALSP\"},\n+        {\"Alwein\", \"ALN\", \"ALN\"},\n+        {\"Ambler\", \"AMPL\", \"AMPL\"},\n+        {\"Andevill\", \"ANTF\", \"ANTF\"},\n+        {\"Andrews\", \"ANTR\", \"ANTR\"},\n+        {\"Andreyco\", \"ANTR\", \"ANTR\"},\n+        {\"Andriesse\", \"ANTR\", \"ANTR\"},\n+        {\"Angier\", \"ANJ\", \"ANJR\"},\n+        {\"Annabel\", \"ANPL\", \"ANPL\"},\n+        {\"Anne\", \"AN\", \"AN\"},\n+        {\"Anstye\", \"ANST\", \"ANST\"},\n+        {\"Appling\", \"APLN\", \"APLN\"},\n+        {\"Apuke\", \"APK\", \"APK\"},\n+        {\"Arnold\", \"ARNL\", \"ARNL\"},\n+        {\"Ashby\", \"AXP\", \"AXP\"},\n+        {\"Astwood\", \"ASTT\", \"ASTT\"},\n+        {\"Atkinson\", \"ATKN\", \"ATKN\"},\n+        {\"Audley\", \"ATL\", \"ATL\"},\n+        {\"Austin\", \"ASTN\", \"ASTN\"},\n+        {\"Avenal\", \"AFNL\", \"AFNL\"},\n+        {\"Ayer\", \"AR\", \"AR\"},\n+        {\"Ayot\", \"AT\", \"AT\"},\n+        {\"Babbitt\", \"PPT\", \"PPT\"},\n+        {\"Bachelor\", \"PXLR\", \"PKLR\"},\n+        {\"Bachelour\", \"PXLR\", \"PKLR\"},\n+        {\"Bailey\", \"PL\", \"PL\"},\n+        {\"Baivel\", \"PFL\", \"PFL\"},\n+        {\"Baker\", \"PKR\", \"PKR\"},\n+        {\"Baldwin\", \"PLTN\", \"PLTN\"},\n+        {\"Balsley\", \"PLSL\", \"PLSL\"},\n+        {\"Barber\", \"PRPR\", \"PRPR\"},\n+        {\"Barker\", \"PRKR\", \"PRKR\"},\n+        {\"Barlow\", \"PRL\", \"PRLF\"},\n+        {\"Barnard\", \"PRNR\", \"PRNR\"},\n+        {\"Barnes\", \"PRNS\", \"PRNS\"},\n+        {\"Barnsley\", \"PRNS\", \"PRNS\"},\n+        {\"Barouxis\", \"PRKS\", \"PRKS\"},\n+        {\"Bartlet\", \"PRTL\", \"PRTL\"},\n+        {\"Basley\", \"PSL\", \"PSL\"},\n+        {\"Basset\", \"PST\", \"PST\"},\n+        {\"Bassett\", \"PST\", \"PST\"},\n+        {\"Batchlor\", \"PXLR\", \"PXLR\"},\n+        {\"Bates\", \"PTS\", \"PTS\"},\n+        {\"Batson\", \"PTSN\", \"PTSN\"},\n+        {\"Bayes\", \"PS\", \"PS\"},\n+        {\"Bayley\", \"PL\", \"PL\"},\n+        {\"Beale\", \"PL\", \"PL\"},\n+        {\"Beauchamp\", \"PXMP\", \"PKMP\"},\n+        {\"Beauclerc\", \"PKLR\", \"PKLR\"},\n+        {\"Beech\", \"PK\", \"PK\"},\n+        {\"Beers\", \"PRS\", \"PRS\"},\n+        {\"Beke\", \"PK\", \"PK\"},\n+        {\"Belcher\", \"PLXR\", \"PLKR\"},\n+        {\"benign\", \"PNN\", \"PNKN\"},\n+        {\"Benjamin\", \"PNJM\", \"PNJM\"},\n+        {\"Benningham\", \"PNNK\", \"PNNK\"},\n+        {\"Bereford\", \"PRFR\", \"PRFR\"},\n+        {\"Bergen\", \"PRJN\", \"PRKN\"},\n+        {\"Berkeley\", \"PRKL\", \"PRKL\"},\n+        {\"Berry\", \"PR\", \"PR\"},\n+        {\"Besse\", \"PS\", \"PS\"},\n+        {\"Bessey\", \"PS\", \"PS\"},\n+        {\"Bessiles\", \"PSLS\", \"PSLS\"},\n+        {\"Bigelow\", \"PJL\", \"PKLF\"},\n+        {\"Bigg\", \"PK\", \"PK\"},\n+        {\"Bigod\", \"PKT\", \"PKT\"},\n+        {\"Billings\", \"PLNK\", \"PLNK\"},\n+        {\"Bimper\", \"PMPR\", \"PMPR\"},\n+        {\"Binker\", \"PNKR\", \"PNKR\"},\n+        {\"Birdsill\", \"PRTS\", \"PRTS\"},\n+        {\"Bishop\", \"PXP\", \"PXP\"},\n+        {\"Black\", \"PLK\", \"PLK\"},\n+        {\"Blagge\", \"PLK\", \"PLK\"},\n+        {\"Blake\", \"PLK\", \"PLK\"},\n+        {\"Blanck\", \"PLNK\", \"PLNK\"},\n+        {\"Bledsoe\", \"PLTS\", \"PLTS\"},\n+        {\"Blennerhasset\", \"PLNR\", \"PLNR\"},\n+        {\"Blessing\", \"PLSN\", \"PLSN\"},\n+        {\"Blewett\", \"PLT\", \"PLT\"},\n+        {\"Bloctgoed\", \"PLKT\", \"PLKT\"},\n+        {\"Bloetgoet\", \"PLTK\", \"PLTK\"},\n+        {\"Bloodgood\", \"PLTK\", \"PLTK\"},\n+        {\"Blossom\", \"PLSM\", \"PLSM\"},\n+        {\"Blount\", \"PLNT\", \"PLNT\"},\n+        {\"Bodine\", \"PTN\", \"PTN\"},\n+        {\"Bodman\", \"PTMN\", \"PTMN\"},\n+        {\"BonCoeur\", \"PNKR\", \"PNKR\"},\n+        {\"Bond\", \"PNT\", \"PNT\"},\n+        {\"Boscawen\", \"PSKN\", \"PSKN\"},\n+        {\"Bosworth\", \"PSR0\", \"PSRT\"},\n+        {\"Bouchier\", \"PX\", \"PKR\"},\n+        {\"Bowne\", \"PN\", \"PN\"},\n+        {\"Bradbury\", \"PRTP\", \"PRTP\"},\n+        {\"Bradder\", \"PRTR\", \"PRTR\"},\n+        {\"Bradford\", \"PRTF\", \"PRTF\"},\n+        {\"Bradstreet\", \"PRTS\", \"PRTS\"},\n+        {\"Braham\", \"PRHM\", \"PRHM\"},\n+        {\"Brailsford\", \"PRLS\", \"PRLS\"},\n+        {\"Brainard\", \"PRNR\", \"PRNR\"},\n+        {\"Brandish\", \"PRNT\", \"PRNT\"},\n+        {\"Braun\", \"PRN\", \"PRN\"},\n+        {\"Brecc\", \"PRK\", \"PRK\"},\n+        {\"Brent\", \"PRNT\", \"PRNT\"},\n+        {\"Brenton\", \"PRNT\", \"PRNT\"},\n+        {\"Briggs\", \"PRKS\", \"PRKS\"},\n+        {\"Brigham\", \"PRM\", \"PRM\"},\n+        {\"Brobst\", \"PRPS\", \"PRPS\"},\n+        {\"Brome\", \"PRM\", \"PRM\"},\n+        {\"Bronson\", \"PRNS\", \"PRNS\"},\n+        {\"Brooks\", \"PRKS\", \"PRKS\"},\n+        {\"Brouillard\", \"PRLR\", \"PRLR\"},\n+        {\"Brown\", \"PRN\", \"PRN\"},\n+        {\"Browne\", \"PRN\", \"PRN\"},\n+        {\"Brownell\", \"PRNL\", \"PRNL\"},\n+        {\"Bruley\", \"PRL\", \"PRL\"},\n+        {\"Bryant\", \"PRNT\", \"PRNT\"},\n+        {\"Brzozowski\", \"PRSS\", \"PRTS\"},\n+        {\"Buide\", \"PT\", \"PT\"},\n+        {\"Bulmer\", \"PLMR\", \"PLMR\"},\n+        {\"Bunker\", \"PNKR\", \"PNKR\"},\n+        {\"Burden\", \"PRTN\", \"PRTN\"},\n+        {\"Burge\", \"PRJ\", \"PRK\"},\n+        {\"Burgoyne\", \"PRKN\", \"PRKN\"},\n+        {\"Burke\", \"PRK\", \"PRK\"},\n+        {\"Burnett\", \"PRNT\", \"PRNT\"},\n+        {\"Burpee\", \"PRP\", \"PRP\"},\n+        {\"Bursley\", \"PRSL\", \"PRSL\"},\n+        {\"Burton\", \"PRTN\", \"PRTN\"},\n+        {\"Bushnell\", \"PXNL\", \"PXNL\"},\n+        {\"Buss\", \"PS\", \"PS\"},\n+        {\"Buswell\", \"PSL\", \"PSL\"},\n+        {\"Butler\", \"PTLR\", \"PTLR\"},\n+        {\"Calkin\", \"KLKN\", \"KLKN\"},\n+        {\"Canada\", \"KNT\", \"KNT\"},\n+        {\"Canmore\", \"KNMR\", \"KNMR\"},\n+        {\"Canney\", \"KN\", \"KN\"},\n+        {\"Capet\", \"KPT\", \"KPT\"},\n+        {\"Card\", \"KRT\", \"KRT\"},\n+        {\"Carman\", \"KRMN\", \"KRMN\"},\n+        {\"Carpenter\", \"KRPN\", \"KRPN\"},\n+        {\"Cartwright\", \"KRTR\", \"KRTR\"},\n+        {\"Casey\", \"KS\", \"KS\"},\n+        {\"Catterfield\", \"KTRF\", \"KTRF\"},\n+        {\"Ceeley\", \"SL\", \"SL\"},\n+        {\"Chambers\", \"XMPR\", \"XMPR\"},\n+        {\"Champion\", \"XMPN\", \"XMPN\"},\n+        {\"Chapman\", \"XPMN\", \"XPMN\"},\n+        {\"Chase\", \"XS\", \"XS\"},\n+        {\"Cheney\", \"XN\", \"XN\"},\n+        {\"Chetwynd\", \"XTNT\", \"XTNT\"},\n+        {\"Chevalier\", \"XFL\", \"XFLR\"},\n+        {\"Chillingsworth\", \"XLNK\", \"XLNK\"},\n+        {\"Christie\", \"KRST\", \"KRST\"},\n+        {\"Chubbuck\", \"XPK\", \"XPK\"},\n+        {\"Church\", \"XRX\", \"XRK\"},\n+        {\"Clark\", \"KLRK\", \"KLRK\"},\n+        {\"Clarke\", \"KLRK\", \"KLRK\"},\n+        {\"Cleare\", \"KLR\", \"KLR\"},\n+        {\"Clement\", \"KLMN\", \"KLMN\"},\n+        {\"Clerke\", \"KLRK\", \"KLRK\"},\n+        {\"Clibben\", \"KLPN\", \"KLPN\"},\n+        {\"Clifford\", \"KLFR\", \"KLFR\"},\n+        {\"Clivedon\", \"KLFT\", \"KLFT\"},\n+        {\"Close\", \"KLS\", \"KLS\"},\n+        {\"Clothilde\", \"KL0L\", \"KLTL\"},\n+        {\"Cobb\", \"KP\", \"KP\"},\n+        {\"Coburn\", \"KPRN\", \"KPRN\"},\n+        {\"Coburne\", \"KPRN\", \"KPRN\"},\n+        {\"Cocke\", \"KK\", \"KK\"},\n+        {\"Coffin\", \"KFN\", \"KFN\"},\n+        {\"Coffyn\", \"KFN\", \"KFN\"},\n+        {\"Colborne\", \"KLPR\", \"KLPR\"},\n+        {\"Colby\", \"KLP\", \"KLP\"},\n+        {\"Cole\", \"KL\", \"KL\"},\n+        {\"Coleman\", \"KLMN\", \"KLMN\"},\n+        {\"Collier\", \"KL\", \"KLR\"},\n+        {\"Compton\", \"KMPT\", \"KMPT\"},\n+        {\"Cone\", \"KN\", \"KN\"},\n+        {\"Cook\", \"KK\", \"KK\"},\n+        {\"Cooke\", \"KK\", \"KK\"},\n+        {\"Cooper\", \"KPR\", \"KPR\"},\n+        {\"Copperthwaite\", \"KPR0\", \"KPRT\"},\n+        {\"Corbet\", \"KRPT\", \"KRPT\"},\n+        {\"Corell\", \"KRL\", \"KRL\"},\n+        {\"Corey\", \"KR\", \"KR\"},\n+        {\"Corlies\", \"KRLS\", \"KRLS\"},\n+        {\"Corneliszen\", \"KRNL\", \"KRNL\"},\n+        {\"Cornelius\", \"KRNL\", \"KRNL\"},\n+        {\"Cornwallis\", \"KRNL\", \"KRNL\"},\n+        {\"Cosgrove\", \"KSKR\", \"KSKR\"},\n+        {\"Count of Brionne\", \"KNTF\", \"KNTF\"},\n+        {\"Covill\", \"KFL\", \"KFL\"},\n+        {\"Cowperthwaite\", \"KPR0\", \"KPRT\"},\n+        {\"Cowperwaite\", \"KPRT\", \"KPRT\"},\n+        {\"Crane\", \"KRN\", \"KRN\"},\n+        {\"Creagmile\", \"KRKM\", \"KRKM\"},\n+        {\"Crew\", \"KR\", \"KRF\"},\n+        {\"Crispin\", \"KRSP\", \"KRSP\"},\n+        {\"Crocker\", \"KRKR\", \"KRKR\"},\n+        {\"Crockett\", \"KRKT\", \"KRKT\"},\n+        {\"Crosby\", \"KRSP\", \"KRSP\"},\n+        {\"Crump\", \"KRMP\", \"KRMP\"},\n+        {\"Cunningham\", \"KNNK\", \"KNNK\"},\n+        {\"Curtis\", \"KRTS\", \"KRTS\"},\n+        {\"Cutha\", \"K0\", \"KT\"},\n+        {\"Cutter\", \"KTR\", \"KTR\"},\n+        {\"D'Aubigny\", \"TPN\", \"TPKN\"},\n+        {\"DAVIS\", \"TFS\", \"TFS\"},\n+        {\"Dabinott\", \"TPNT\", \"TPNT\"},\n+        {\"Dacre\", \"TKR\", \"TKR\"},\n+        {\"Daggett\", \"TKT\", \"TKT\"},\n+        {\"Danvers\", \"TNFR\", \"TNFR\"},\n+        {\"Darcy\", \"TRS\", \"TRS\"},\n+        {\"Davis\", \"TFS\", \"TFS\"},\n+        {\"Dawn\", \"TN\", \"TN\"},\n+        {\"Dawson\", \"TSN\", \"TSN\"},\n+        {\"Day\", \"T\", \"T\"},\n+        {\"Daye\", \"T\", \"T\"},\n+        {\"DeGrenier\", \"TKRN\", \"TKRN\"},\n+        {\"Dean\", \"TN\", \"TN\"},\n+        {\"Deekindaugh\", \"TKNT\", \"TKNT\"},\n+        {\"Dennis\", \"TNS\", \"TNS\"},\n+        {\"Denny\", \"TN\", \"TN\"},\n+        {\"Denton\", \"TNTN\", \"TNTN\"},\n+        {\"Desborough\", \"TSPR\", \"TSPR\"},\n+        {\"Despenser\", \"TSPN\", \"TSPN\"},\n+        {\"Deverill\", \"TFRL\", \"TFRL\"},\n+        {\"Devine\", \"TFN\", \"TFN\"},\n+        {\"Dexter\", \"TKST\", \"TKST\"},\n+        {\"Dillaway\", \"TL\", \"TL\"},\n+        {\"Dimmick\", \"TMK\", \"TMK\"},\n+        {\"Dinan\", \"TNN\", \"TNN\"},\n+        {\"Dix\", \"TKS\", \"TKS\"},\n+        {\"Doggett\", \"TKT\", \"TKT\"},\n+        {\"Donahue\", \"TNH\", \"TNH\"},\n+        {\"Dorfman\", \"TRFM\", \"TRFM\"},\n+        {\"Dorris\", \"TRS\", \"TRS\"},\n+        {\"Dow\", \"T\", \"TF\"},\n+        {\"Downey\", \"TN\", \"TN\"},\n+        {\"Downing\", \"TNNK\", \"TNNK\"},\n+        {\"Dowsett\", \"TST\", \"TST\"},\n+        {\"Duck?\", \"TK\", \"TK\"},\n+        {\"Dudley\", \"TTL\", \"TTL\"},\n+        {\"Duffy\", \"TF\", \"TF\"},\n+        {\"Dunn\", \"TN\", \"TN\"},\n+        {\"Dunsterville\", \"TNST\", \"TNST\"},\n+        {\"Durrant\", \"TRNT\", \"TRNT\"},\n+        {\"Durrin\", \"TRN\", \"TRN\"},\n+        {\"Dustin\", \"TSTN\", \"TSTN\"},\n+        {\"Duston\", \"TSTN\", \"TSTN\"},\n+        {\"Eames\", \"AMS\", \"AMS\"},\n+        {\"Early\", \"ARL\", \"ARL\"},\n+        {\"Easty\", \"AST\", \"AST\"},\n+        {\"Ebbett\", \"APT\", \"APT\"},\n+        {\"Eberbach\", \"APRP\", \"APRP\"},\n+        {\"Eberhard\", \"APRR\", \"APRR\"},\n+        {\"Eddy\", \"AT\", \"AT\"},\n+        {\"Edenden\", \"ATNT\", \"ATNT\"},\n+        {\"Edwards\", \"ATRT\", \"ATRT\"},\n+        {\"Eglinton\", \"AKLN\", \"ALNT\"},\n+        {\"Eliot\", \"ALT\", \"ALT\"},\n+        {\"Elizabeth\", \"ALSP\", \"ALSP\"},\n+        {\"Ellis\", \"ALS\", \"ALS\"},\n+        {\"Ellison\", \"ALSN\", \"ALSN\"},\n+        {\"Ellot\", \"ALT\", \"ALT\"},\n+        {\"Elny\", \"ALN\", \"ALN\"},\n+        {\"Elsner\", \"ALSN\", \"ALSN\"},\n+        {\"Emerson\", \"AMRS\", \"AMRS\"},\n+        {\"Empson\", \"AMPS\", \"AMPS\"},\n+        {\"Est\", \"AST\", \"AST\"},\n+        {\"Estabrook\", \"ASTP\", \"ASTP\"},\n+        {\"Estes\", \"ASTS\", \"ASTS\"},\n+        {\"Estey\", \"AST\", \"AST\"},\n+        {\"Evans\", \"AFNS\", \"AFNS\"},\n+        {\"Fallowell\", \"FLL\", \"FLL\"},\n+        {\"Farnsworth\", \"FRNS\", \"FRNS\"},\n+        {\"Feake\", \"FK\", \"FK\"},\n+        {\"Feke\", \"FK\", \"FK\"},\n+        {\"Fellows\", \"FLS\", \"FLS\"},\n+        {\"Fettiplace\", \"FTPL\", \"FTPL\"},\n+        {\"Finney\", \"FN\", \"FN\"},\n+        {\"Fischer\", \"FXR\", \"FSKR\"},\n+        {\"Fisher\", \"FXR\", \"FXR\"},\n+        {\"Fisk\", \"FSK\", \"FSK\"},\n+        {\"Fiske\", \"FSK\", \"FSK\"},\n+        {\"Fletcher\", \"FLXR\", \"FLXR\"},\n+        {\"Folger\", \"FLKR\", \"FLJR\"},\n+        {\"Foliot\", \"FLT\", \"FLT\"},\n+        {\"Folyot\", \"FLT\", \"FLT\"},\n+        {\"Fones\", \"FNS\", \"FNS\"},\n+        {\"Fordham\", \"FRTM\", \"FRTM\"},\n+        {\"Forstner\", \"FRST\", \"FRST\"},\n+        {\"Fosten\", \"FSTN\", \"FSTN\"},\n+        {\"Foster\", \"FSTR\", \"FSTR\"},\n+        {\"Foulke\", \"FLK\", \"FLK\"},\n+        {\"Fowler\", \"FLR\", \"FLR\"},\n+        {\"Foxwell\", \"FKSL\", \"FKSL\"},\n+        {\"Fraley\", \"FRL\", \"FRL\"},\n+        {\"Franceys\", \"FRNS\", \"FRNS\"},\n+        {\"Franke\", \"FRNK\", \"FRNK\"},\n+        {\"Frascella\", \"FRSL\", \"FRSL\"},\n+        {\"Frazer\", \"FRSR\", \"FRSR\"},\n+        {\"Fredd\", \"FRT\", \"FRT\"},\n+        {\"Freeman\", \"FRMN\", \"FRMN\"},\n+        {\"French\", \"FRNX\", \"FRNK\"},\n+        {\"Freville\", \"FRFL\", \"FRFL\"},\n+        {\"Frey\", \"FR\", \"FR\"},\n+        {\"Frick\", \"FRK\", \"FRK\"},\n+        {\"Frier\", \"FR\", \"FRR\"},\n+        {\"Froe\", \"FR\", \"FR\"},\n+        {\"Frorer\", \"FRRR\", \"FRRR\"},\n+        {\"Frost\", \"FRST\", \"FRST\"},\n+        {\"Frothingham\", \"FR0N\", \"FRTN\"},\n+        {\"Fry\", \"FR\", \"FR\"},\n+        {\"Gaffney\", \"KFN\", \"KFN\"},\n+        {\"Gage\", \"KJ\", \"KK\"},\n+        {\"Gallion\", \"KLN\", \"KLN\"},\n+        {\"Gallishan\", \"KLXN\", \"KLXN\"},\n+        {\"Gamble\", \"KMPL\", \"KMPL\"},\n+        {\"garage\", \"KRJ\", \"KRK\"},\n+        {\"Garbrand\", \"KRPR\", \"KRPR\"},\n+        {\"Gardner\", \"KRTN\", \"KRTN\"},\n+        {\"Garrett\", \"KRT\", \"KRT\"},\n+        {\"Gassner\", \"KSNR\", \"KSNR\"},\n+        {\"Gater\", \"KTR\", \"KTR\"},\n+        {\"Gaunt\", \"KNT\", \"KNT\"},\n+        {\"Gayer\", \"KR\", \"KR\"},\n+        {\"George\", \"JRJ\", \"KRK\"},\n+        {\"Gerken\", \"KRKN\", \"JRKN\"},\n+        {\"Gerritsen\", \"KRTS\", \"JRTS\"},\n+        {\"Gibbs\", \"KPS\", \"JPS\"},\n+        {\"Giffard\", \"JFRT\", \"KFRT\"},\n+        {\"Gilbert\", \"KLPR\", \"JLPR\"},\n+        {\"Gill\", \"KL\", \"JL\"},\n+        {\"Gilman\", \"KLMN\", \"JLMN\"},\n+        {\"Glass\", \"KLS\", \"KLS\"},\n+        {\"Goddard\\\\Gifford\", \"KTRT\", \"KTRT\"},\n+        {\"Godfrey\", \"KTFR\", \"KTFR\"},\n+        {\"Godwin\", \"KTN\", \"KTN\"},\n+        {\"Goodale\", \"KTL\", \"KTL\"},\n+        {\"Goodnow\", \"KTN\", \"KTNF\"},\n+        {\"Gorham\", \"KRM\", \"KRM\"},\n+        {\"Goseline\", \"KSLN\", \"KSLN\"},\n+        {\"Gott\", \"KT\", \"KT\"},\n+        {\"Gould\", \"KLT\", \"KLT\"},\n+        {\"Grafton\", \"KRFT\", \"KRFT\"},\n+        {\"Grant\", \"KRNT\", \"KRNT\"},\n+        {\"Gray\", \"KR\", \"KR\"},\n+        {\"Green\", \"KRN\", \"KRN\"},\n+        {\"Griffin\", \"KRFN\", \"KRFN\"},\n+        {\"Grill\", \"KRL\", \"KRL\"},\n+        {\"Grim\", \"KRM\", \"KRM\"},\n+        {\"Grisgonelle\", \"KRSK\", \"KRSK\"},\n+        {\"Gross\", \"KRS\", \"KRS\"},\n+        {\"Guba\", \"KP\", \"KP\"},\n+        {\"Gybbes\", \"KPS\", \"JPS\"},\n+        {\"Haburne\", \"HPRN\", \"HPRN\"},\n+        {\"Hackburne\", \"HKPR\", \"HKPR\"},\n+        {\"Haddon?\", \"HTN\", \"HTN\"},\n+        {\"Haines\", \"HNS\", \"HNS\"},\n+        {\"Hale\", \"HL\", \"HL\"},\n+        {\"Hall\", \"HL\", \"HL\"},\n+        {\"Hallet\", \"HLT\", \"HLT\"},\n+        {\"Hallock\", \"HLK\", \"HLK\"},\n+        {\"Halstead\", \"HLST\", \"HLST\"},\n+        {\"Hammond\", \"HMNT\", \"HMNT\"},\n+        {\"Hance\", \"HNS\", \"HNS\"},\n+        {\"Handy\", \"HNT\", \"HNT\"},\n+        {\"Hanson\", \"HNSN\", \"HNSN\"},\n+        {\"Harasek\", \"HRSK\", \"HRSK\"},\n+        {\"Harcourt\", \"HRKR\", \"HRKR\"},\n+        {\"Hardy\", \"HRT\", \"HRT\"},\n+        {\"Harlock\", \"HRLK\", \"HRLK\"},\n+        {\"Harris\", \"HRS\", \"HRS\"},\n+        {\"Hartley\", \"HRTL\", \"HRTL\"},\n+        {\"Harvey\", \"HRF\", \"HRF\"},\n+        {\"Harvie\", \"HRF\", \"HRF\"},\n+        {\"Harwood\", \"HRT\", \"HRT\"},\n+        {\"Hathaway\", \"H0\", \"HT\"},\n+        {\"Haukeness\", \"HKNS\", \"HKNS\"},\n+        {\"Hawkes\", \"HKS\", \"HKS\"},\n+        {\"Hawkhurst\", \"HKRS\", \"HKRS\"},\n+        {\"Hawkins\", \"HKNS\", \"HKNS\"},\n+        {\"Hawley\", \"HL\", \"HL\"},\n+        {\"Heald\", \"HLT\", \"HLT\"},\n+        {\"Helsdon\", \"HLST\", \"HLST\"},\n+        {\"Hemenway\", \"HMN\", \"HMN\"},\n+        {\"Hemmenway\", \"HMN\", \"HMN\"},\n+        {\"Henck\", \"HNK\", \"HNK\"},\n+        {\"Henderson\", \"HNTR\", \"HNTR\"},\n+        {\"Hendricks\", \"HNTR\", \"HNTR\"},\n+        {\"Hersey\", \"HRS\", \"HRS\"},\n+        {\"Hewes\", \"HS\", \"HS\"},\n+        {\"Heyman\", \"HMN\", \"HMN\"},\n+        {\"Hicks\", \"HKS\", \"HKS\"},\n+        {\"Hidden\", \"HTN\", \"HTN\"},\n+        {\"Higgs\", \"HKS\", \"HKS\"},\n+        {\"Hill\", \"HL\", \"HL\"},\n+        {\"Hills\", \"HLS\", \"HLS\"},\n+        {\"Hinckley\", \"HNKL\", \"HNKL\"},\n+        {\"Hipwell\", \"HPL\", \"HPL\"},\n+        {\"Hobart\", \"HPRT\", \"HPRT\"},\n+        {\"Hoben\", \"HPN\", \"HPN\"},\n+        {\"Hoffmann\", \"HFMN\", \"HFMN\"},\n+        {\"Hogan\", \"HKN\", \"HKN\"},\n+        {\"Holmes\", \"HLMS\", \"HLMS\"},\n+        {\"Hoo\", \"H\", \"H\"},\n+        {\"Hooker\", \"HKR\", \"HKR\"},\n+        {\"Hopcott\", \"HPKT\", \"HPKT\"},\n+        {\"Hopkins\", \"HPKN\", \"HPKN\"},\n+        {\"Hopkinson\", \"HPKN\", \"HPKN\"},\n+        {\"Hornsey\", \"HRNS\", \"HRNS\"},\n+        {\"Houckgeest\", \"HKJS\", \"HKKS\"},\n+        {\"Hough\", \"H\", \"H\"},\n+        {\"Houstin\", \"HSTN\", \"HSTN\"},\n+        {\"How\", \"H\", \"HF\"},\n+        {\"Howe\", \"H\", \"H\"},\n+        {\"Howland\", \"HLNT\", \"HLNT\"},\n+        {\"Hubner\", \"HPNR\", \"HPNR\"},\n+        {\"Hudnut\", \"HTNT\", \"HTNT\"},\n+        {\"Hughes\", \"HS\", \"HS\"},\n+        {\"Hull\", \"HL\", \"HL\"},\n+        {\"Hulme\", \"HLM\", \"HLM\"},\n+        {\"Hume\", \"HM\", \"HM\"},\n+        {\"Hundertumark\", \"HNTR\", \"HNTR\"},\n+        {\"Hundley\", \"HNTL\", \"HNTL\"},\n+        {\"Hungerford\", \"HNKR\", \"HNJR\"},\n+        {\"Hunt\", \"HNT\", \"HNT\"},\n+        {\"Hurst\", \"HRST\", \"HRST\"},\n+        {\"Husbands\", \"HSPN\", \"HSPN\"},\n+        {\"Hussey\", \"HS\", \"HS\"},\n+        {\"Husted\", \"HSTT\", \"HSTT\"},\n+        {\"Hutchins\", \"HXNS\", \"HXNS\"},\n+        {\"Hutchinson\", \"HXNS\", \"HXNS\"},\n+        {\"Huttinger\", \"HTNK\", \"HTNJ\"},\n+        {\"Huybertsen\", \"HPRT\", \"HPRT\"},\n+        {\"Iddenden\", \"ATNT\", \"ATNT\"},\n+        {\"Ingraham\", \"ANKR\", \"ANKR\"},\n+        {\"Ives\", \"AFS\", \"AFS\"},\n+        {\"Jackson\", \"JKSN\", \"AKSN\"},\n+        {\"Jacob\", \"JKP\", \"AKP\"},\n+        {\"Jans\", \"JNS\", \"ANS\"},\n+        {\"Jenkins\", \"JNKN\", \"ANKN\"},\n+        {\"Jewett\", \"JT\", \"AT\"},\n+        {\"Jewitt\", \"JT\", \"AT\"},\n+        {\"Johnson\", \"JNSN\", \"ANSN\"},\n+        {\"Jones\", \"JNS\", \"ANS\"},\n+        {\"Josephine\", \"JSFN\", \"HSFN\"},\n+        {\"Judd\", \"JT\", \"AT\"},\n+        {\"June\", \"JN\", \"AN\"},\n+        {\"Kamarowska\", \"KMRS\", \"KMRS\"},\n+        {\"Kay\", \"K\", \"K\"},\n+        {\"Kelley\", \"KL\", \"KL\"},\n+        {\"Kelly\", \"KL\", \"KL\"},\n+        {\"Keymber\", \"KMPR\", \"KMPR\"},\n+        {\"Keynes\", \"KNS\", \"KNS\"},\n+        {\"Kilham\", \"KLM\", \"KLM\"},\n+        {\"Kim\", \"KM\", \"KM\"},\n+        {\"Kimball\", \"KMPL\", \"KMPL\"},\n+        {\"King\", \"KNK\", \"KNK\"},\n+        {\"Kinsey\", \"KNS\", \"KNS\"},\n+        {\"Kirk\", \"KRK\", \"KRK\"},\n+        {\"Kirton\", \"KRTN\", \"KRTN\"},\n+        {\"Kistler\", \"KSTL\", \"KSTL\"},\n+        {\"Kitchen\", \"KXN\", \"KXN\"},\n+        {\"Kitson\", \"KTSN\", \"KTSN\"},\n+        {\"Klett\", \"KLT\", \"KLT\"},\n+        {\"Kline\", \"KLN\", \"KLN\"},\n+        {\"Knapp\", \"NP\", \"NP\"},\n+        {\"Knight\", \"NT\", \"NT\"},\n+        {\"Knote\", \"NT\", \"NT\"},\n+        {\"Knott\", \"NT\", \"NT\"},\n+        {\"Knox\", \"NKS\", \"NKS\"},\n+        {\"Koeller\", \"KLR\", \"KLR\"},\n+        {\"La Pointe\", \"LPNT\", \"LPNT\"},\n+        {\"LaPlante\", \"LPLN\", \"LPLN\"},\n+        {\"Laimbeer\", \"LMPR\", \"LMPR\"},\n+        {\"Lamb\", \"LMP\", \"LMP\"},\n+        {\"Lambertson\", \"LMPR\", \"LMPR\"},\n+        {\"Lancto\", \"LNKT\", \"LNKT\"},\n+        {\"Landry\", \"LNTR\", \"LNTR\"},\n+        {\"Lane\", \"LN\", \"LN\"},\n+        {\"Langendyck\", \"LNJN\", \"LNKN\"},\n+        {\"Langer\", \"LNKR\", \"LNJR\"},\n+        {\"Langford\", \"LNKF\", \"LNKF\"},\n+        {\"Lantersee\", \"LNTR\", \"LNTR\"},\n+        {\"Laquer\", \"LKR\", \"LKR\"},\n+        {\"Larkin\", \"LRKN\", \"LRKN\"},\n+        {\"Latham\", \"LTM\", \"LTM\"},\n+        {\"Lathrop\", \"L0RP\", \"LTRP\"},\n+        {\"Lauter\", \"LTR\", \"LTR\"},\n+        {\"Lawrence\", \"LRNS\", \"LRNS\"},\n+        {\"Leach\", \"LK\", \"LK\"},\n+        {\"Leager\", \"LKR\", \"LJR\"},\n+        {\"Learned\", \"LRNT\", \"LRNT\"},\n+        {\"Leavitt\", \"LFT\", \"LFT\"},\n+        {\"Lee\", \"L\", \"L\"},\n+        {\"Leete\", \"LT\", \"LT\"},\n+        {\"Leggett\", \"LKT\", \"LKT\"},\n+        {\"Leland\", \"LLNT\", \"LLNT\"},\n+        {\"Leonard\", \"LNRT\", \"LNRT\"},\n+        {\"Lester\", \"LSTR\", \"LSTR\"},\n+        {\"Lestrange\", \"LSTR\", \"LSTR\"},\n+        {\"Lethem\", \"L0M\", \"LTM\"},\n+        {\"Levine\", \"LFN\", \"LFN\"},\n+        {\"Lewes\", \"LS\", \"LS\"},\n+        {\"Lewis\", \"LS\", \"LS\"},\n+        {\"Lincoln\", \"LNKL\", \"LNKL\"},\n+        {\"Lindsey\", \"LNTS\", \"LNTS\"},\n+        {\"Linher\", \"LNR\", \"LNR\"},\n+        {\"Lippet\", \"LPT\", \"LPT\"},\n+        {\"Lippincott\", \"LPNK\", \"LPNK\"},\n+        {\"Lockwood\", \"LKT\", \"LKT\"},\n+        {\"Loines\", \"LNS\", \"LNS\"},\n+        {\"Lombard\", \"LMPR\", \"LMPR\"},\n+        {\"Long\", \"LNK\", \"LNK\"},\n+        {\"Longespee\", \"LNJS\", \"LNKS\"},\n+        {\"Look\", \"LK\", \"LK\"},\n+        {\"Lounsberry\", \"LNSP\", \"LNSP\"},\n+        {\"Lounsbury\", \"LNSP\", \"LNSP\"},\n+        {\"Louthe\", \"L0\", \"LT\"},\n+        {\"Loveyne\", \"LFN\", \"LFN\"},\n+        {\"Lowe\", \"L\", \"L\"},\n+        {\"Ludlam\", \"LTLM\", \"LTLM\"},\n+        {\"Lumbard\", \"LMPR\", \"LMPR\"},\n+        {\"Lund\", \"LNT\", \"LNT\"},\n+        {\"Luno\", \"LN\", \"LN\"},\n+        {\"Lutz\", \"LTS\", \"LTS\"},\n+        {\"Lydia\", \"LT\", \"LT\"},\n+        {\"Lynne\", \"LN\", \"LN\"},\n+        {\"Lyon\", \"LN\", \"LN\"},\n+        {\"MacAlpin\", \"MKLP\", \"MKLP\"},\n+        {\"MacBricc\", \"MKPR\", \"MKPR\"},\n+        {\"MacCrinan\", \"MKRN\", \"MKRN\"},\n+        {\"MacKenneth\", \"MKN0\", \"MKNT\"},\n+        {\"MacMael nam Bo\", \"MKML\", \"MKML\"},\n+        {\"MacMurchada\", \"MKMR\", \"MKMR\"},\n+        {\"Macomber\", \"MKMP\", \"MKMP\"},\n+        {\"Macy\", \"MS\", \"MS\"},\n+        {\"Magnus\", \"MNS\", \"MKNS\"},\n+        {\"Mahien\", \"MHN\", \"MHN\"},\n+        {\"Malmains\", \"MLMN\", \"MLMN\"},\n+        {\"Malory\", \"MLR\", \"MLR\"},\n+        {\"Mancinelli\", \"MNSN\", \"MNSN\"},\n+        {\"Mancini\", \"MNSN\", \"MNSN\"},\n+        {\"Mann\", \"MN\", \"MN\"},\n+        {\"Manning\", \"MNNK\", \"MNNK\"},\n+        {\"Manter\", \"MNTR\", \"MNTR\"},\n+        {\"Marion\", \"MRN\", \"MRN\"},\n+        {\"Marley\", \"MRL\", \"MRL\"},\n+        {\"Marmion\", \"MRMN\", \"MRMN\"},\n+        {\"Marquart\", \"MRKR\", \"MRKR\"},\n+        {\"Marsh\", \"MRX\", \"MRX\"},\n+        {\"Marshal\", \"MRXL\", \"MRXL\"},\n+        {\"Marshall\", \"MRXL\", \"MRXL\"},\n+        {\"Martel\", \"MRTL\", \"MRTL\"},\n+        {\"Martha\", \"MR0\", \"MRT\"},\n+        {\"Martin\", \"MRTN\", \"MRTN\"},\n+        {\"Marturano\", \"MRTR\", \"MRTR\"},\n+        {\"Marvin\", \"MRFN\", \"MRFN\"},\n+        {\"Mary\", \"MR\", \"MR\"},\n+        {\"Mason\", \"MSN\", \"MSN\"},\n+        {\"Maxwell\", \"MKSL\", \"MKSL\"},\n+        {\"Mayhew\", \"MH\", \"MHF\"},\n+        {\"McAllaster\", \"MKLS\", \"MKLS\"},\n+        {\"McAllister\", \"MKLS\", \"MKLS\"},\n+        {\"McConnell\", \"MKNL\", \"MKNL\"},\n+        {\"McFarland\", \"MKFR\", \"MKFR\"},\n+        {\"McIlroy\", \"MSLR\", \"MSLR\"},\n+        {\"McNair\", \"MKNR\", \"MKNR\"},\n+        {\"McNair-Landry\", \"MKNR\", \"MKNR\"},\n+        {\"McRaven\", \"MKRF\", \"MKRF\"},\n+        {\"Mead\", \"MT\", \"MT\"},\n+        {\"Meade\", \"MT\", \"MT\"},\n+        {\"Meck\", \"MK\", \"MK\"},\n+        {\"Melton\", \"MLTN\", \"MLTN\"},\n+        {\"Mendenhall\", \"MNTN\", \"MNTN\"},\n+        {\"Mering\", \"MRNK\", \"MRNK\"},\n+        {\"Merrick\", \"MRK\", \"MRK\"},\n+        {\"Merry\", \"MR\", \"MR\"},\n+        {\"Mighill\", \"ML\", \"ML\"},\n+        {\"Miller\", \"MLR\", \"MLR\"},\n+        {\"Milton\", \"MLTN\", \"MLTN\"},\n+        {\"Mohun\", \"MHN\", \"MHN\"},\n+        {\"Montague\", \"MNTK\", \"MNTK\"},\n+        {\"Montboucher\", \"MNTP\", \"MNTP\"},\n+        {\"Moore\", \"MR\", \"MR\"},\n+        {\"Morrel\", \"MRL\", \"MRL\"},\n+        {\"Morrill\", \"MRL\", \"MRL\"},\n+        {\"Morris\", \"MRS\", \"MRS\"},\n+        {\"Morton\", \"MRTN\", \"MRTN\"},\n+        {\"Moton\", \"MTN\", \"MTN\"},\n+        {\"Muir\", \"MR\", \"MR\"},\n+        {\"Mulferd\", \"MLFR\", \"MLFR\"},\n+        {\"Mullins\", \"MLNS\", \"MLNS\"},\n+        {\"Mulso\", \"MLS\", \"MLS\"},\n+        {\"Munger\", \"MNKR\", \"MNJR\"},\n+        {\"Munt\", \"MNT\", \"MNT\"},\n+        {\"Murchad\", \"MRXT\", \"MRKT\"},\n+        {\"Murdock\", \"MRTK\", \"MRTK\"},\n+        {\"Murray\", \"MR\", \"MR\"},\n+        {\"Muskett\", \"MSKT\", \"MSKT\"},\n+        {\"Myers\", \"MRS\", \"MRS\"},\n+        {\"Myrick\", \"MRK\", \"MRK\"},\n+        {\"NORRIS\", \"NRS\", \"NRS\"},\n+        {\"Nayle\", \"NL\", \"NL\"},\n+        {\"Newcomb\", \"NKMP\", \"NKMP\"},\n+        {\"Newcomb(e)\", \"NKMP\", \"NKMP\"},\n+        {\"Newkirk\", \"NKRK\", \"NKRK\"},\n+        {\"Newton\", \"NTN\", \"NTN\"},\n+        {\"Niles\", \"NLS\", \"NLS\"},\n+        {\"Noble\", \"NPL\", \"NPL\"},\n+        {\"Noel\", \"NL\", \"NL\"},\n+        {\"Northend\", \"NR0N\", \"NRTN\"},\n+        {\"Norton\", \"NRTN\", \"NRTN\"},\n+        {\"Nutter\", \"NTR\", \"NTR\"},\n+        {\"Odding\", \"ATNK\", \"ATNK\"},\n+        {\"Odenbaugh\", \"ATNP\", \"ATNP\"},\n+        {\"Ogborn\", \"AKPR\", \"AKPR\"},\n+        {\"Oppenheimer\", \"APNM\", \"APNM\"},\n+        {\"Otis\", \"ATS\", \"ATS\"},\n+        {\"Oviatt\", \"AFT\", \"AFT\"},\n+        {\"PRUST?\", \"PRST\", \"PRST\"},\n+        {\"Paddock\", \"PTK\", \"PTK\"},\n+        {\"Page\", \"PJ\", \"PK\"},\n+        {\"Paine\", \"PN\", \"PN\"},\n+        {\"Paist\", \"PST\", \"PST\"},\n+        {\"Palmer\", \"PLMR\", \"PLMR\"},\n+        {\"Park\", \"PRK\", \"PRK\"},\n+        {\"Parker\", \"PRKR\", \"PRKR\"},\n+        {\"Parkhurst\", \"PRKR\", \"PRKR\"},\n+        {\"Parrat\", \"PRT\", \"PRT\"},\n+        {\"Parsons\", \"PRSN\", \"PRSN\"},\n+        {\"Partridge\", \"PRTR\", \"PRTR\"},\n+        {\"Pashley\", \"PXL\", \"PXL\"},\n+        {\"Pasley\", \"PSL\", \"PSL\"},\n+        {\"Patrick\", \"PTRK\", \"PTRK\"},\n+        {\"Pattee\", \"PT\", \"PT\"},\n+        {\"Patten\", \"PTN\", \"PTN\"},\n+        {\"Pawley\", \"PL\", \"PL\"},\n+        {\"Payne\", \"PN\", \"PN\"},\n+        {\"Peabody\", \"PPT\", \"PPT\"},\n+        {\"Peake\", \"PK\", \"PK\"},\n+        {\"Pearson\", \"PRSN\", \"PRSN\"},\n+        {\"Peat\", \"PT\", \"PT\"},\n+        {\"Pedersen\", \"PTRS\", \"PTRS\"},\n+        {\"Percy\", \"PRS\", \"PRS\"},\n+        {\"Perkins\", \"PRKN\", \"PRKN\"},\n+        {\"Perrine\", \"PRN\", \"PRN\"},\n+        {\"Perry\", \"PR\", \"PR\"},\n+        {\"Peson\", \"PSN\", \"PSN\"},\n+        {\"Peterson\", \"PTRS\", \"PTRS\"},\n+        {\"Peyton\", \"PTN\", \"PTN\"},\n+        {\"Phinney\", \"FN\", \"FN\"},\n+        {\"Pickard\", \"PKRT\", \"PKRT\"},\n+        {\"Pierce\", \"PRS\", \"PRS\"},\n+        {\"Pierrepont\", \"PRPN\", \"PRPN\"},\n+        {\"Pike\", \"PK\", \"PK\"},\n+        {\"Pinkham\", \"PNKM\", \"PNKM\"},\n+        {\"Pitman\", \"PTMN\", \"PTMN\"},\n+        {\"Pitt\", \"PT\", \"PT\"},\n+        {\"Pitts\", \"PTS\", \"PTS\"},\n+        {\"Plantagenet\", \"PLNT\", \"PLNT\"},\n+        {\"Platt\", \"PLT\", \"PLT\"},\n+        {\"Platts\", \"PLTS\", \"PLTS\"},\n+        {\"Pleis\", \"PLS\", \"PLS\"},\n+        {\"Pleiss\", \"PLS\", \"PLS\"},\n+        {\"Plisko\", \"PLSK\", \"PLSK\"},\n+        {\"Pliskovitch\", \"PLSK\", \"PLSK\"},\n+        {\"Plum\", \"PLM\", \"PLM\"},\n+        {\"Plume\", \"PLM\", \"PLM\"},\n+        {\"Poitou\", \"PT\", \"PT\"},\n+        {\"Pomeroy\", \"PMR\", \"PMR\"},\n+        {\"Poretiers\", \"PRTR\", \"PRTR\"},\n+        {\"Pote\", \"PT\", \"PT\"},\n+        {\"Potter\", \"PTR\", \"PTR\"},\n+        {\"Potts\", \"PTS\", \"PTS\"},\n+        {\"Powell\", \"PL\", \"PL\"},\n+        {\"Pratt\", \"PRT\", \"PRT\"},\n+        {\"Presbury\", \"PRSP\", \"PRSP\"},\n+        {\"Priest\", \"PRST\", \"PRST\"},\n+        {\"Prindle\", \"PRNT\", \"PRNT\"},\n+        {\"Prior\", \"PRR\", \"PRR\"},\n+        {\"Profumo\", \"PRFM\", \"PRFM\"},\n+        {\"Purdy\", \"PRT\", \"PRT\"},\n+        {\"Purefoy\", \"PRF\", \"PRF\"},\n+        {\"Pury\", \"PR\", \"PR\"},\n+        {\"Quinter\", \"KNTR\", \"KNTR\"},\n+        {\"Rachel\", \"RXL\", \"RKL\"},\n+        {\"Rand\", \"RNT\", \"RNT\"},\n+        {\"Rankin\", \"RNKN\", \"RNKN\"},\n+        {\"Ravenscroft\", \"RFNS\", \"RFNS\"},\n+        {\"Raynsford\", \"RNSF\", \"RNSF\"},\n+        {\"Reakirt\", \"RKRT\", \"RKRT\"},\n+        {\"Reaves\", \"RFS\", \"RFS\"},\n+        {\"Reeves\", \"RFS\", \"RFS\"},\n+        {\"Reichert\", \"RXRT\", \"RKRT\"},\n+        {\"Remmele\", \"RML\", \"RML\"},\n+        {\"Reynolds\", \"RNLT\", \"RNLT\"},\n+        {\"Rhodes\", \"RTS\", \"RTS\"},\n+        {\"Richards\", \"RXRT\", \"RKRT\"},\n+        {\"Richardson\", \"RXRT\", \"RKRT\"},\n+        {\"Ring\", \"RNK\", \"RNK\"},\n+        {\"Roberts\", \"RPRT\", \"RPRT\"},\n+        {\"Robertson\", \"RPRT\", \"RPRT\"},\n+        {\"Robson\", \"RPSN\", \"RPSN\"},\n+        {\"Rodie\", \"RT\", \"RT\"},\n+        {\"Rody\", \"RT\", \"RT\"},\n+        {\"Rogers\", \"RKRS\", \"RJRS\"},\n+        {\"Ross\", \"RS\", \"RS\"},\n+        {\"Rosslevin\", \"RSLF\", \"RSLF\"},\n+        {\"Rowland\", \"RLNT\", \"RLNT\"},\n+        {\"Ruehl\", \"RL\", \"RL\"},\n+        {\"Russell\", \"RSL\", \"RSL\"},\n+        {\"Ruth\", \"R0\", \"RT\"},\n+        {\"Ryan\", \"RN\", \"RN\"},\n+        {\"Rysse\", \"RS\", \"RS\"},\n+        {\"Sadler\", \"STLR\", \"STLR\"},\n+        {\"Salmon\", \"SLMN\", \"SLMN\"},\n+        {\"Salter\", \"SLTR\", \"SLTR\"},\n+        {\"Salvatore\", \"SLFT\", \"SLFT\"},\n+        {\"Sanders\", \"SNTR\", \"SNTR\"},\n+        {\"Sands\", \"SNTS\", \"SNTS\"},\n+        {\"Sanford\", \"SNFR\", \"SNFR\"},\n+        {\"Sanger\", \"SNKR\", \"SNJR\"},\n+        {\"Sargent\", \"SRJN\", \"SRKN\"},\n+        {\"Saunders\", \"SNTR\", \"SNTR\"},\n+        {\"Schilling\", \"XLNK\", \"XLNK\"},\n+        {\"Schlegel\", \"XLKL\", \"SLKL\"},\n+        {\"Scott\", \"SKT\", \"SKT\"},\n+        {\"Sears\", \"SRS\", \"SRS\"},\n+        {\"Segersall\", \"SJRS\", \"SKRS\"},\n+        {\"Senecal\", \"SNKL\", \"SNKL\"},\n+        {\"Sergeaux\", \"SRJ\", \"SRK\"},\n+        {\"Severance\", \"SFRN\", \"SFRN\"},\n+        {\"Sharp\", \"XRP\", \"XRP\"},\n+        {\"Sharpe\", \"XRP\", \"XRP\"},\n+        {\"Sharply\", \"XRPL\", \"XRPL\"},\n+        {\"Shatswell\", \"XTSL\", \"XTSL\"},\n+        {\"Shattack\", \"XTK\", \"XTK\"},\n+        {\"Shattock\", \"XTK\", \"XTK\"},\n+        {\"Shattuck\", \"XTK\", \"XTK\"},\n+        {\"Shaw\", \"X\", \"XF\"},\n+        {\"Sheldon\", \"XLTN\", \"XLTN\"},\n+        {\"Sherman\", \"XRMN\", \"XRMN\"},\n+        {\"Shinn\", \"XN\", \"XN\"},\n+        {\"Shirford\", \"XRFR\", \"XRFR\"},\n+        {\"Shirley\", \"XRL\", \"XRL\"},\n+        {\"Shively\", \"XFL\", \"XFL\"},\n+        {\"Shoemaker\", \"XMKR\", \"XMKR\"},\n+        {\"Short\", \"XRT\", \"XRT\"},\n+        {\"Shotwell\", \"XTL\", \"XTL\"},\n+        {\"Shute\", \"XT\", \"XT\"},\n+        {\"Sibley\", \"SPL\", \"SPL\"},\n+        {\"Silver\", \"SLFR\", \"SLFR\"},\n+        {\"Simes\", \"SMS\", \"SMS\"},\n+        {\"Sinken\", \"SNKN\", \"SNKN\"},\n+        {\"Sinn\", \"SN\", \"SN\"},\n+        {\"Skelton\", \"SKLT\", \"SKLT\"},\n+        {\"Skiffe\", \"SKF\", \"SKF\"},\n+        {\"Skotkonung\", \"SKTK\", \"SKTK\"},\n+        {\"Slade\", \"SLT\", \"XLT\"},\n+        {\"Slye\", \"SL\", \"XL\"},\n+        {\"Smedley\", \"SMTL\", \"XMTL\"},\n+        {\"Smith\", \"SM0\", \"XMT\"},\n+        {\"Smythe\", \"SM0\", \"XMT\"},\n+        {\"Snow\", \"SN\", \"XNF\"},\n+        {\"Soole\", \"SL\", \"SL\"},\n+        {\"Soule\", \"SL\", \"SL\"},\n+        {\"Southworth\", \"S0R0\", \"STRT\"},\n+        {\"Sowles\", \"SLS\", \"SLS\"},\n+        {\"Spalding\", \"SPLT\", \"SPLT\"},\n+        {\"Spark\", \"SPRK\", \"SPRK\"},\n+        {\"Spencer\", \"SPNS\", \"SPNS\"},\n+        {\"Sperry\", \"SPR\", \"SPR\"},\n+        {\"Spofford\", \"SPFR\", \"SPFR\"},\n+        {\"Spooner\", \"SPNR\", \"SPNR\"},\n+        {\"Sprague\", \"SPRK\", \"SPRK\"},\n+        {\"Springer\", \"SPRN\", \"SPRN\"},\n+        {\"St. Clair\", \"STKL\", \"STKL\"},\n+        {\"St. Claire\", \"STKL\", \"STKL\"},\n+        {\"St. Leger\", \"STLJ\", \"STLK\"},\n+        {\"St. Omer\", \"STMR\", \"STMR\"},\n+        {\"Stafferton\", \"STFR\", \"STFR\"},\n+        {\"Stafford\", \"STFR\", \"STFR\"},\n+        {\"Stalham\", \"STLM\", \"STLM\"},\n+        {\"Stanford\", \"STNF\", \"STNF\"},\n+        {\"Stanton\", \"STNT\", \"STNT\"},\n+        {\"Star\", \"STR\", \"STR\"},\n+        {\"Starbuck\", \"STRP\", \"STRP\"},\n+        {\"Starkey\", \"STRK\", \"STRK\"},\n+        {\"Starkweather\", \"STRK\", \"STRK\"},\n+        {\"Stearns\", \"STRN\", \"STRN\"},\n+        {\"Stebbins\", \"STPN\", \"STPN\"},\n+        {\"Steele\", \"STL\", \"STL\"},\n+        {\"Stephenson\", \"STFN\", \"STFN\"},\n+        {\"Stevens\", \"STFN\", \"STFN\"},\n+        {\"Stoddard\", \"STTR\", \"STTR\"},\n+        {\"Stodder\", \"STTR\", \"STTR\"},\n+        {\"Stone\", \"STN\", \"STN\"},\n+        {\"Storey\", \"STR\", \"STR\"},\n+        {\"Storrada\", \"STRT\", \"STRT\"},\n+        {\"Story\", \"STR\", \"STR\"},\n+        {\"Stoughton\", \"STFT\", \"STFT\"},\n+        {\"Stout\", \"STT\", \"STT\"},\n+        {\"Stow\", \"ST\", \"STF\"},\n+        {\"Strong\", \"STRN\", \"STRN\"},\n+        {\"Strutt\", \"STRT\", \"STRT\"},\n+        {\"Stryker\", \"STRK\", \"STRK\"},\n+        {\"Stuckeley\", \"STKL\", \"STKL\"},\n+        {\"Sturges\", \"STRJ\", \"STRK\"},\n+        {\"Sturgess\", \"STRJ\", \"STRK\"},\n+        {\"Sturgis\", \"STRJ\", \"STRK\"},\n+        {\"Suevain\", \"SFN\", \"SFN\"},\n+        {\"Sulyard\", \"SLRT\", \"SLRT\"},\n+        {\"Sutton\", \"STN\", \"STN\"},\n+        {\"Swain\", \"SN\", \"XN\"},\n+        {\"Swayne\", \"SN\", \"XN\"},\n+        {\"Swayze\", \"SS\", \"XTS\"},\n+        {\"Swift\", \"SFT\", \"XFT\"},\n+        {\"Taber\", \"TPR\", \"TPR\"},\n+        {\"Talcott\", \"TLKT\", \"TLKT\"},\n+        {\"Tarne\", \"TRN\", \"TRN\"},\n+        {\"Tatum\", \"TTM\", \"TTM\"},\n+        {\"Taverner\", \"TFRN\", \"TFRN\"},\n+        {\"Taylor\", \"TLR\", \"TLR\"},\n+        {\"Tenney\", \"TN\", \"TN\"},\n+        {\"Thayer\", \"0R\", \"TR\"},\n+        {\"Thember\", \"0MPR\", \"TMPR\"},\n+        {\"Thomas\", \"TMS\", \"TMS\"},\n+        {\"Thompson\", \"TMPS\", \"TMPS\"},\n+        {\"Thorne\", \"0RN\", \"TRN\"},\n+        {\"Thornycraft\", \"0RNK\", \"TRNK\"},\n+        {\"Threlkeld\", \"0RLK\", \"TRLK\"},\n+        {\"Throckmorton\", \"0RKM\", \"TRKM\"},\n+        {\"Thwaits\", \"0TS\", \"TTS\"},\n+        {\"Tibbetts\", \"TPTS\", \"TPTS\"},\n+        {\"Tidd\", \"TT\", \"TT\"},\n+        {\"Tierney\", \"TRN\", \"TRN\"},\n+        {\"Tilley\", \"TL\", \"TL\"},\n+        {\"Tillieres\", \"TLRS\", \"TLRS\"},\n+        {\"Tilly\", \"TL\", \"TL\"},\n+        {\"Tisdale\", \"TSTL\", \"TSTL\"},\n+        {\"Titus\", \"TTS\", \"TTS\"},\n+        {\"Tobey\", \"TP\", \"TP\"},\n+        {\"Tooker\", \"TKR\", \"TKR\"},\n+        {\"Towle\", \"TL\", \"TL\"},\n+        {\"Towne\", \"TN\", \"TN\"},\n+        {\"Townsend\", \"TNSN\", \"TNSN\"},\n+        {\"Treadway\", \"TRT\", \"TRT\"},\n+        {\"Trelawney\", \"TRLN\", \"TRLN\"},\n+        {\"Trinder\", \"TRNT\", \"TRNT\"},\n+        {\"Tripp\", \"TRP\", \"TRP\"},\n+        {\"Trippe\", \"TRP\", \"TRP\"},\n+        {\"Trott\", \"TRT\", \"TRT\"},\n+        {\"True\", \"TR\", \"TR\"},\n+        {\"Trussebut\", \"TRSP\", \"TRSP\"},\n+        {\"Tucker\", \"TKR\", \"TKR\"},\n+        {\"Turgeon\", \"TRJN\", \"TRKN\"},\n+        {\"Turner\", \"TRNR\", \"TRNR\"},\n+        {\"Tuttle\", \"TTL\", \"TTL\"},\n+        {\"Tyler\", \"TLR\", \"TLR\"},\n+        {\"Tylle\", \"TL\", \"TL\"},\n+        {\"Tyrrel\", \"TRL\", \"TRL\"},\n+        {\"Ua Tuathail\", \"AT0L\", \"ATTL\"},\n+        {\"Ulrich\", \"ALRX\", \"ALRK\"},\n+        {\"Underhill\", \"ANTR\", \"ANTR\"},\n+        {\"Underwood\", \"ANTR\", \"ANTR\"},\n+        {\"Unknown\", \"ANKN\", \"ANKN\"},\n+        {\"Valentine\", \"FLNT\", \"FLNT\"},\n+        {\"Van Egmond\", \"FNKM\", \"FNKM\"},\n+        {\"Van der Beek\", \"FNTR\", \"FNTR\"},\n+        {\"Vaughan\", \"FKN\", \"FKN\"},\n+        {\"Vermenlen\", \"FRMN\", \"FRMN\"},\n+        {\"Vincent\", \"FNSN\", \"FNSN\"},\n+        {\"Volentine\", \"FLNT\", \"FLNT\"},\n+        {\"Wagner\", \"AKNR\", \"FKNR\"},\n+        {\"Waite\", \"AT\", \"FT\"},\n+        {\"Walker\", \"ALKR\", \"FLKR\"},\n+        {\"Walter\", \"ALTR\", \"FLTR\"},\n+        {\"Wandell\", \"ANTL\", \"FNTL\"},\n+        {\"Wandesford\", \"ANTS\", \"FNTS\"},\n+        {\"Warbleton\", \"ARPL\", \"FRPL\"},\n+        {\"Ward\", \"ART\", \"FRT\"},\n+        {\"Warde\", \"ART\", \"FRT\"},\n+        {\"Ware\", \"AR\", \"FR\"},\n+        {\"Wareham\", \"ARHM\", \"FRHM\"},\n+        {\"Warner\", \"ARNR\", \"FRNR\"},\n+        {\"Warren\", \"ARN\", \"FRN\"},\n+        {\"Washburne\", \"AXPR\", \"FXPR\"},\n+        {\"Waterbury\", \"ATRP\", \"FTRP\"},\n+        {\"Watson\", \"ATSN\", \"FTSN\"},\n+        {\"WatsonEllithorpe\", \"ATSN\", \"FTSN\"},\n+        {\"Watts\", \"ATS\", \"FTS\"},\n+        {\"Wayne\", \"AN\", \"FN\"},\n+        {\"Webb\", \"AP\", \"FP\"},\n+        {\"Weber\", \"APR\", \"FPR\"},\n+        {\"Webster\", \"APST\", \"FPST\"},\n+        {\"Weed\", \"AT\", \"FT\"},\n+        {\"Weeks\", \"AKS\", \"FKS\"},\n+        {\"Wells\", \"ALS\", \"FLS\"},\n+        {\"Wenzell\", \"ANSL\", \"FNTS\"},\n+        {\"West\", \"AST\", \"FST\"},\n+        {\"Westbury\", \"ASTP\", \"FSTP\"},\n+        {\"Whatlocke\", \"ATLK\", \"ATLK\"},\n+        {\"Wheeler\", \"ALR\", \"ALR\"},\n+        {\"Whiston\", \"ASTN\", \"ASTN\"},\n+        {\"White\", \"AT\", \"AT\"},\n+        {\"Whitman\", \"ATMN\", \"ATMN\"},\n+        {\"Whiton\", \"ATN\", \"ATN\"},\n+        {\"Whitson\", \"ATSN\", \"ATSN\"},\n+        {\"Wickes\", \"AKS\", \"FKS\"},\n+        {\"Wilbur\", \"ALPR\", \"FLPR\"},\n+        {\"Wilcotes\", \"ALKT\", \"FLKT\"},\n+        {\"Wilkinson\", \"ALKN\", \"FLKN\"},\n+        {\"Willets\", \"ALTS\", \"FLTS\"},\n+        {\"Willett\", \"ALT\", \"FLT\"},\n+        {\"Willey\", \"AL\", \"FL\"},\n+        {\"Williams\", \"ALMS\", \"FLMS\"},\n+        {\"Williston\", \"ALST\", \"FLST\"},\n+        {\"Wilson\", \"ALSN\", \"FLSN\"},\n+        {\"Wimes\", \"AMS\", \"FMS\"},\n+        {\"Winch\", \"ANX\", \"FNK\"},\n+        {\"Winegar\", \"ANKR\", \"FNKR\"},\n+        {\"Wing\", \"ANK\", \"FNK\"},\n+        {\"Winsley\", \"ANSL\", \"FNSL\"},\n+        {\"Winslow\", \"ANSL\", \"FNSL\"},\n+        {\"Winthrop\", \"AN0R\", \"FNTR\"},\n+        {\"Wise\", \"AS\", \"FS\"},\n+        {\"Wood\", \"AT\", \"FT\"},\n+        {\"Woodbridge\", \"ATPR\", \"FTPR\"},\n+        {\"Woodward\", \"ATRT\", \"FTRT\"},\n+        {\"Wooley\", \"AL\", \"FL\"},\n+        {\"Woolley\", \"AL\", \"FL\"},\n+        {\"Worth\", \"AR0\", \"FRT\"},\n+        {\"Worthen\", \"AR0N\", \"FRTN\"},\n+        {\"Worthley\", \"AR0L\", \"FRTL\"},\n+        {\"Wright\", \"RT\", \"RT\"},\n+        {\"Wyer\", \"AR\", \"FR\"},\n+        {\"Wyere\", \"AR\", \"FR\"},\n+        {\"Wynkoop\", \"ANKP\", \"FNKP\"},\n+        {\"Yarnall\", \"ARNL\", \"ARNL\"},\n+        {\"Yeoman\", \"AMN\", \"AMN\"},\n+        {\"Yorke\", \"ARK\", \"ARK\"},\n+        {\"Young\", \"ANK\", \"ANK\"},\n+        {\"ab Wennonwen\", \"APNN\", \"APNN\"},\n+        {\"ap Llewellyn\", \"APLL\", \"APLL\"},\n+        {\"ap Lorwerth\", \"APLR\", \"APLR\"},\n+        {\"d'Angouleme\", \"TNKL\", \"TNKL\"},\n+        {\"de Audeham\", \"TTHM\", \"TTHM\"},\n+        {\"de Bavant\", \"TPFN\", \"TPFN\"},\n+        {\"de Beauchamp\", \"TPXM\", \"TPKM\"},\n+        {\"de Beaumont\", \"TPMN\", \"TPMN\"},\n+        {\"de Bolbec\", \"TPLP\", \"TPLP\"},\n+        {\"de Braiose\", \"TPRS\", \"TPRS\"},\n+        {\"de Braose\", \"TPRS\", \"TPRS\"},\n+        {\"de Briwere\", \"TPRR\", \"TPRR\"},\n+        {\"de Cantelou\", \"TKNT\", \"TKNT\"},\n+        {\"de Cherelton\", \"TXRL\", \"TKRL\"},\n+        {\"de Cherleton\", \"TXRL\", \"TKRL\"},\n+        {\"de Clare\", \"TKLR\", \"TKLR\"},\n+        {\"de Claremont\", \"TKLR\", \"TKLR\"},\n+        {\"de Clifford\", \"TKLF\", \"TKLF\"},\n+        {\"de Colville\", \"TKLF\", \"TKLF\"},\n+        {\"de Courtenay\", \"TKRT\", \"TKRT\"},\n+        {\"de Fauconberg\", \"TFKN\", \"TFKN\"},\n+        {\"de Forest\", \"TFRS\", \"TFRS\"},\n+        {\"de Gai\", \"TK\", \"TK\"},\n+        {\"de Grey\", \"TKR\", \"TKR\"},\n+        {\"de Guernons\", \"TKRN\", \"TKRN\"},\n+        {\"de Haia\", \"T\", \"T\"},\n+        {\"de Harcourt\", \"TRKR\", \"TRKR\"},\n+        {\"de Hastings\", \"TSTN\", \"TSTN\"},\n+        {\"de Hoke\", \"TK\", \"TK\"},\n+        {\"de Hooch\", \"TK\", \"TK\"},\n+        {\"de Hugelville\", \"TJLF\", \"TKLF\"},\n+        {\"de Huntingdon\", \"TNTN\", \"TNTN\"},\n+        {\"de Insula\", \"TNSL\", \"TNSL\"},\n+        {\"de Keynes\", \"TKNS\", \"TKNS\"},\n+        {\"de Lacy\", \"TLS\", \"TLS\"},\n+        {\"de Lexington\", \"TLKS\", \"TLKS\"},\n+        {\"de Lusignan\", \"TLSN\", \"TLSK\"},\n+        {\"de Manvers\", \"TMNF\", \"TMNF\"},\n+        {\"de Montagu\", \"TMNT\", \"TMNT\"},\n+        {\"de Montault\", \"TMNT\", \"TMNT\"},\n+        {\"de Montfort\", \"TMNT\", \"TMNT\"},\n+        {\"de Mortimer\", \"TMRT\", \"TMRT\"},\n+        {\"de Morville\", \"TMRF\", \"TMRF\"},\n+        {\"de Morvois\", \"TMRF\", \"TMRF\"},\n+        {\"de Neufmarche\", \"TNFM\", \"TNFM\"},\n+        {\"de Odingsells\", \"TTNK\", \"TTNK\"},\n+        {\"de Odyngsells\", \"TTNK\", \"TTNK\"},\n+        {\"de Percy\", \"TPRS\", \"TPRS\"},\n+        {\"de Pierrepont\", \"TPRP\", \"TPRP\"},\n+        {\"de Plessetis\", \"TPLS\", \"TPLS\"},\n+        {\"de Porhoet\", \"TPRT\", \"TPRT\"},\n+        {\"de Prouz\", \"TPRS\", \"TPRS\"},\n+        {\"de Quincy\", \"TKNS\", \"TKNS\"},\n+        {\"de Ripellis\", \"TRPL\", \"TRPL\"},\n+        {\"de Ros\", \"TRS\", \"TRS\"},\n+        {\"de Salisbury\", \"TSLS\", \"TSLS\"},\n+        {\"de Sanford\", \"TSNF\", \"TSNF\"},\n+        {\"de Somery\", \"TSMR\", \"TSMR\"},\n+        {\"de St. Hilary\", \"TSTL\", \"TSTL\"},\n+        {\"de St. Liz\", \"TSTL\", \"TSTL\"},\n+        {\"de Sutton\", \"TSTN\", \"TSTN\"},\n+        {\"de Toeni\", \"TTN\", \"TTN\"},\n+        {\"de Tony\", \"TTN\", \"TTN\"},\n+        {\"de Umfreville\", \"TMFR\", \"TMFR\"},\n+        {\"de Valognes\", \"TFLN\", \"TFLK\"},\n+        {\"de Vaux\", \"TF\", \"TF\"},\n+        {\"de Vere\", \"TFR\", \"TFR\"},\n+        {\"de Vermandois\", \"TFRM\", \"TFRM\"},\n+        {\"de Vernon\", \"TFRN\", \"TFRN\"},\n+        {\"de Vexin\", \"TFKS\", \"TFKS\"},\n+        {\"de Vitre\", \"TFTR\", \"TFTR\"},\n+        {\"de Wandesford\", \"TNTS\", \"TNTS\"},\n+        {\"de Warenne\", \"TRN\", \"TRN\"},\n+        {\"de Westbury\", \"TSTP\", \"TSTP\"},\n+        {\"di Saluzzo\", \"TSLS\", \"TSLT\"},\n+        {\"fitz Alan\", \"FTSL\", \"FTSL\"},\n+        {\"fitz Geoffrey\", \"FTSJ\", \"FTSK\"},\n+        {\"fitz Herbert\", \"FTSR\", \"FTSR\"},\n+        {\"fitz John\", \"FTSJ\", \"FTSJ\"},\n+        {\"fitz Patrick\", \"FTSP\", \"FTSP\"},\n+        {\"fitz Payn\", \"FTSP\", \"FTSP\"},\n+        {\"fitz Piers\", \"FTSP\", \"FTSP\"},\n+        {\"fitz Randolph\", \"FTSR\", \"FTSR\"},\n+        {\"fitz Richard\", \"FTSR\", \"FTSR\"},\n+        {\"fitz Robert\", \"FTSR\", \"FTSR\"},\n+        {\"fitz Roy\", \"FTSR\", \"FTSR\"},\n+        {\"fitz Scrob\", \"FTSS\", \"FTSS\"},\n+        {\"fitz Walter\", \"FTSL\", \"FTSL\"},\n+        {\"fitz Warin\", \"FTSR\", \"FTSR\"},\n+        {\"fitz Williams\", \"FTSL\", \"FTSL\"},\n+        {\"la Zouche\", \"LSX\", \"LSK\"},\n+        {\"le Botiller\", \"LPTL\", \"LPTL\"},\n+        {\"le Despenser\", \"LTSP\", \"LTSP\"},\n+        {\"le deSpencer\", \"LTSP\", \"LTSP\"},\n+        {\"of Allendale\", \"AFLN\", \"AFLN\"},\n+        {\"of Angouleme\", \"AFNK\", \"AFNK\"},\n+        {\"of Anjou\", \"AFNJ\", \"AFNJ\"},\n+        {\"of Aquitaine\", \"AFKT\", \"AFKT\"},\n+        {\"of Aumale\", \"AFML\", \"AFML\"},\n+        {\"of Bavaria\", \"AFPF\", \"AFPF\"},\n+        {\"of Boulogne\", \"AFPL\", \"AFPL\"},\n+        {\"of Brittany\", \"AFPR\", \"AFPR\"},\n+        {\"of Brittary\", \"AFPR\", \"AFPR\"},\n+        {\"of Castile\", \"AFKS\", \"AFKS\"},\n+        {\"of Chester\", \"AFXS\", \"AFKS\"},\n+        {\"of Clermont\", \"AFKL\", \"AFKL\"},\n+        {\"of Cologne\", \"AFKL\", \"AFKL\"},\n+        {\"of Dinan\", \"AFTN\", \"AFTN\"},\n+        {\"of Dunbar\", \"AFTN\", \"AFTN\"},\n+        {\"of England\", \"AFNK\", \"AFNK\"},\n+        {\"of Essex\", \"AFSK\", \"AFSK\"},\n+        {\"of Falaise\", \"AFFL\", \"AFFL\"},\n+        {\"of Flanders\", \"AFFL\", \"AFFL\"},\n+        {\"of Galloway\", \"AFKL\", \"AFKL\"},\n+        {\"of Germany\", \"AFKR\", \"AFJR\"},\n+        {\"of Gloucester\", \"AFKL\", \"AFKL\"},\n+        {\"of Heristal\", \"AFRS\", \"AFRS\"},\n+        {\"of Hungary\", \"AFNK\", \"AFNK\"},\n+        {\"of Huntington\", \"AFNT\", \"AFNT\"},\n+        {\"of Kiev\", \"AFKF\", \"AFKF\"},\n+        {\"of Kuno\", \"AFKN\", \"AFKN\"},\n+        {\"of Landen\", \"AFLN\", \"AFLN\"},\n+        {\"of Laon\", \"AFLN\", \"AFLN\"},\n+        {\"of Leinster\", \"AFLN\", \"AFLN\"},\n+        {\"of Lens\", \"AFLN\", \"AFLN\"},\n+        {\"of Lorraine\", \"AFLR\", \"AFLR\"},\n+        {\"of Louvain\", \"AFLF\", \"AFLF\"},\n+        {\"of Mercia\", \"AFMR\", \"AFMR\"},\n+        {\"of Metz\", \"AFMT\", \"AFMT\"},\n+        {\"of Meulan\", \"AFML\", \"AFML\"},\n+        {\"of Nass\", \"AFNS\", \"AFNS\"},\n+        {\"of Normandy\", \"AFNR\", \"AFNR\"},\n+        {\"of Ohningen\", \"AFNN\", \"AFNN\"},\n+        {\"of Orleans\", \"AFRL\", \"AFRL\"},\n+        {\"of Poitou\", \"AFPT\", \"AFPT\"},\n+        {\"of Polotzk\", \"AFPL\", \"AFPL\"},\n+        {\"of Provence\", \"AFPR\", \"AFPR\"},\n+        {\"of Ringelheim\", \"AFRN\", \"AFRN\"},\n+        {\"of Salisbury\", \"AFSL\", \"AFSL\"},\n+        {\"of Saxony\", \"AFSK\", \"AFSK\"},\n+        {\"of Scotland\", \"AFSK\", \"AFSK\"},\n+        {\"of Senlis\", \"AFSN\", \"AFSN\"},\n+        {\"of Stafford\", \"AFST\", \"AFST\"},\n+        {\"of Swabia\", \"AFSP\", \"AFSP\"},\n+        {\"of Tongres\", \"AFTN\", \"AFTN\"},\n+        {\"of the Tributes\", \"AF0T\", \"AFTT\"},\n+        {\"unknown\", \"ANKN\", \"ANKN\"},\n+        {\"van der Gouda\", \"FNTR\", \"FNTR\"},\n+        {\"von Adenbaugh\", \"FNTN\", \"FNTN\"},\n+        {\"ARCHITure\", \"ARKT\", \"ARKT\"},\n+        {\"Arnoff\", \"ARNF\", \"ARNF\"},\n+        {\"Arnow\", \"ARN\", \"ARNF\"},\n+        {\"DANGER\", \"TNJR\", \"TNKR\"},\n+        {\"Jankelowicz\", \"JNKL\", \"ANKL\"},\n+        {\"MANGER\", \"MNJR\", \"MNKR\"},\n+        {\"McClellan\", \"MKLL\", \"MKLL\"},\n+        {\"McHugh\", \"MK\", \"MK\"},\n+        {\"McLaughlin\", \"MKLF\", \"MKLF\"},\n+        {\"ORCHEStra\", \"ARKS\", \"ARKS\"},\n+        {\"ORCHID\", \"ARKT\", \"ARKT\"},\n+        {\"Pierce\", \"PRS\", \"PRS\"},\n+        {\"RANGER\", \"RNJR\", \"RNKR\"},\n+        {\"Schlesinger\", \"XLSN\", \"SLSN\"},\n+        {\"Uomo\", \"AM\", \"AM\"},\n+        {\"Vasserman\", \"FSRM\", \"FSRM\"},\n+        {\"Wasserman\", \"ASRM\", \"FSRM\"},\n+        {\"Womo\", \"AM\", \"FM\"},\n+        {\"Yankelovich\", \"ANKL\", \"ANKL\"},\n+        {\"accede\", \"AKST\", \"AKST\"},\n+        {\"accident\", \"AKST\", \"AKST\"},\n+        {\"adelsheim\", \"ATLS\", \"ATLS\"},\n+        {\"aged\", \"AJT\", \"AKT\"},\n+        {\"ageless\", \"AJLS\", \"AKLS\"},\n+        {\"agency\", \"AJNS\", \"AKNS\"},\n+        {\"aghast\", \"AKST\", \"AKST\"},\n+        {\"agio\", \"AJ\", \"AK\"},\n+        {\"agrimony\", \"AKRM\", \"AKRM\"},\n+        {\"album\", \"ALPM\", \"ALPM\"},\n+        {\"alcmene\", \"ALKM\", \"ALKM\"},\n+        {\"alehouse\", \"ALHS\", \"ALHS\"},\n+        {\"antique\", \"ANTK\", \"ANTK\"},\n+        {\"artois\", \"ART\", \"ARTS\"},\n+        {\"automation\", \"ATMX\", \"ATMX\"},\n+        {\"bacchus\", \"PKS\", \"PKS\"},\n+        {\"bacci\", \"PX\", \"PX\"},\n+        {\"bajador\", \"PJTR\", \"PHTR\"},\n+        {\"bellocchio\", \"PLX\", \"PLX\"},\n+        {\"bertucci\", \"PRTX\", \"PRTX\"},\n+        {\"biaggi\", \"PJ\", \"PK\"},\n+        {\"bough\", \"P\", \"P\"},\n+        {\"breaux\", \"PR\", \"PR\"},\n+        {\"broughton\", \"PRTN\", \"PRTN\"},\n+        {\"cabrillo\", \"KPRL\", \"KPR\"},\n+        {\"caesar\", \"SSR\", \"SSR\"},\n+        {\"cagney\", \"KKN\", \"KKN\"},\n+        {\"campbell\", \"KMPL\", \"KMPL\"},\n+        {\"carlisle\", \"KRLL\", \"KRLL\"},\n+        {\"carlysle\", \"KRLL\", \"KRLL\"},\n+        {\"chemistry\", \"KMST\", \"KMST\"},\n+        {\"chianti\", \"KNT\", \"KNT\"},\n+        {\"chorus\", \"KRS\", \"KRS\"},\n+        {\"cough\", \"KF\", \"KF\"},\n+        {\"czerny\", \"SRN\", \"XRN\"},\n+        {\"deffenbacher\", \"TFNP\", \"TFNP\"},\n+        {\"dumb\", \"TM\", \"TM\"},\n+        {\"edgar\", \"ATKR\", \"ATKR\"},\n+        {\"edge\", \"AJ\", \"AJ\"},\n+        {\"filipowicz\", \"FLPT\", \"FLPF\"},\n+        {\"focaccia\", \"FKX\", \"FKX\"},\n+        {\"gallegos\", \"KLKS\", \"KKS\"},\n+        {\"gambrelli\", \"KMPR\", \"KMPR\"},\n+        {\"geithain\", \"K0N\", \"JTN\"},\n+        {\"ghiradelli\", \"JRTL\", \"JRTL\"},\n+        {\"ghislane\", \"JLN\", \"JLN\"},\n+        {\"gough\", \"KF\", \"KF\"},\n+        {\"hartheim\", \"HR0M\", \"HRTM\"},\n+        {\"heimsheim\", \"HMSM\", \"HMSM\"},\n+        {\"hochmeier\", \"HKMR\", \"HKMR\"},\n+        {\"hugh\", \"H\", \"H\"},\n+        {\"hunger\", \"HNKR\", \"HNJR\"},\n+        {\"hungry\", \"HNKR\", \"HNKR\"},\n+        {\"island\", \"ALNT\", \"ALNT\"},\n+        {\"isle\", \"AL\", \"AL\"},\n+        {\"jose\", \"HS\", \"HS\"},\n+        {\"laugh\", \"LF\", \"LF\"},\n+        {\"mac caffrey\", \"MKFR\", \"MKFR\"},\n+        {\"mac gregor\", \"MKRK\", \"MKRK\"},\n+        {\"pegnitz\", \"PNTS\", \"PKNT\"},\n+        {\"piskowitz\", \"PSKT\", \"PSKF\"},\n+        {\"queen\", \"KN\", \"KN\"},\n+        {\"raspberry\", \"RSPR\", \"RSPR\"},\n+        {\"resnais\", \"RSN\", \"RSNS\"},\n+        {\"rogier\", \"RJ\", \"RJR\"},\n+        {\"rough\", \"RF\", \"RF\"},\n+        {\"san jacinto\", \"SNHS\", \"SNHS\"},\n+        {\"schenker\", \"XNKR\", \"SKNK\"},\n+        {\"schermerhorn\", \"XRMR\", \"SKRM\"},\n+        {\"schmidt\", \"XMT\", \"SMT\"},\n+        {\"schneider\", \"XNTR\", \"SNTR\"},\n+        {\"school\", \"SKL\", \"SKL\"},\n+        {\"schooner\", \"SKNR\", \"SKNR\"},\n+        {\"schrozberg\", \"XRSP\", \"SRSP\"},\n+        {\"schulman\", \"XLMN\", \"XLMN\"},\n+        {\"schwabach\", \"XPK\", \"XFPK\"},\n+        {\"schwarzach\", \"XRSK\", \"XFRT\"},\n+        {\"smith\", \"SM0\", \"XMT\"},\n+        {\"snider\", \"SNTR\", \"XNTR\"},\n+        {\"succeed\", \"SKST\", \"SKST\"},\n+        {\"sugarcane\", \"XKRK\", \"SKRK\"},\n+        {\"svobodka\", \"SFPT\", \"SFPT\"},\n+        {\"tagliaro\", \"TKLR\", \"TLR\"},\n+        {\"thames\", \"TMS\", \"TMS\"},\n+        {\"theilheim\", \"0LM\", \"TLM\"},\n+        {\"thomas\", \"TMS\", \"TMS\"},\n+        {\"thumb\", \"0M\", \"TM\"},\n+        {\"tichner\", \"TXNR\", \"TKNR\"},\n+        {\"tough\", \"TF\", \"TF\"},\n+        {\"umbrella\", \"AMPR\", \"AMPR\"},\n+        {\"vilshofen\", \"FLXF\", \"FLXF\"},\n+        {\"von schuller\", \"FNXL\", \"FNXL\"},\n+        {\"wachtler\", \"AKTL\", \"FKTL\"},\n+        {\"wechsler\", \"AKSL\", \"FKSL\"},\n+        {\"weikersheim\", \"AKRS\", \"FKRS\"},\n+        {\"zhao\", \"J\", \"J\"}};\n+\n+    private void checkDoubleMetaphone(int typeIndex, boolean alternate) {\n+        for (int i = 0; i < TEST_DATA.length; i++) {\n+            String value = TEST_DATA[i][0];\n+            assertEquals(\"Test [\" + i + \"]=\" + value, TEST_DATA[i][typeIndex], this.getDoubleMetaphone().doubleMetaphone(value, alternate));\n+        }\n+    }\n+\n+    @Override\n+    protected StringEncoder createStringEncoder() {\n+        return new DoubleMetaphone();\n+    }\n+\n+    /**\n+     * @return Returns the metaphone.\n+     */\n+    private DoubleMetaphone getDoubleMetaphone() {\n+        return (DoubleMetaphone) this.getStringEncoder();\n+    }\n+\n+    /**\n+     * Test alternative encoding.\n+     */\n+    @Test\n+    public void testDoubleMetaphoneAlternate() {\n+        this.checkDoubleMetaphone(ALTERNATE_INDEX, true);\n+    }\n+\n+    /**\n+     * Test primary encoding.\n+     */\n+    @Test\n+    public void testDoubleMetaphonePrimary() {\n+        this.checkDoubleMetaphone(PRIMARY_INDEX, false);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/DoubleMetaphoneTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Test;\n+\n+/**\n+ * Tests {@link DoubleMetaphone}.\n+ * \n+ * <p>Keep this file in UTF-8 encoding for proper Javadoc processing.</p>\n+ * \n+ * @see \"http://www.cuj.com/documents/s=8038/cuj0006philips/\"\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class DoubleMetaphoneTest extends StringEncoderAbstractTest {\n+\n+    /**\n+     * Test data from http://aspell.sourceforge.net/test/batch0.tab.\n+     * \n+     * \"Copyright (C) 2002 Kevin Atkinson (kevina@gnu.org). Verbatim copying\n+     * and distribution of this entire article is permitted in any medium,\n+     * provided this notice is preserved.\"\n+     * \n+     * Massaged the test data in the array below.\n+     */\n+    private static final String[][] FIXTURE = { { \"Accosinly\", \"Occasionally\" }, {\n+            \"Ciculer\", \"Circler\" }, {\n+            \"Circue\", \"Circle\" }, {\n+            \"Maddness\", \"Madness\" }, {\n+            \"Occusionaly\", \"Occasionally\" }, {\n+            \"Steffen\", \"Stephen\" }, {\n+            \"Thw\", \"The\" }, {\n+            \"Unformanlly\", \"Unfortunately\" }, {\n+            \"Unfortally\", \"Unfortunately\" }, {\n+            \"abilitey\", \"ability\" }, {\n+            \"abouy\", \"about\" }, {\n+            \"absorbtion\", \"absorption\" }, {\n+            \"accidently\", \"accidentally\" }, {\n+            \"accomodate\", \"accommodate\" }, {\n+            \"acommadate\", \"accommodate\" }, {\n+            \"acord\", \"accord\" }, {\n+            \"adultry\", \"adultery\" }, {\n+            \"aggresive\", \"aggressive\" }, {\n+            \"alchohol\", \"alcohol\" }, {\n+            \"alchoholic\", \"alcoholic\" }, {\n+            \"allieve\", \"alive\" }, {\n+            \"alot\", \"a lot\" }, {\n+            \"alright\", \"all right\" }, {\n+            \"amature\", \"amateur\" }, {\n+            \"ambivilant\", \"ambivalent\" }, {\n+            \"amification\", \"amplification\" }, {\n+            \"amourfous\", \"amorphous\" }, {\n+            \"annoint\", \"anoint\" }, {\n+            \"annonsment\", \"announcement\" }, {\n+            \"annoyting\", \"anting\" }, {\n+            \"annuncio\", \"announce\" }, {\n+            \"anonomy\", \"anatomy\" }, {\n+            \"anotomy\", \"anatomy\" }, {\n+            \"antidesestablishmentarianism\", \"antidisestablishmentarianism\" }, {\n+            \"antidisestablishmentarism\", \"antidisestablishmentarianism\" }, {\n+            \"anynomous\", \"anonymous\" }, {\n+            \"appelet\", \"applet\" }, {\n+            \"appreceiated\", \"appreciated\" }, {\n+            \"appresteate\", \"appreciate\" }, {\n+            \"aquantance\", \"acquaintance\" }, {\n+            \"aratictature\", \"architecture\" }, {\n+            \"archeype\", \"archetype\" }, {\n+            \"aricticure\", \"architecture\" }, {\n+            \"artic\", \"arctic\" }, {\n+            \"asentote\", \"asymptote\" }, {\n+            \"ast\", \"at\" }, {\n+            \"asterick\", \"asterisk\" }, {\n+            \"asymetric\", \"asymmetric\" }, {\n+            \"atentively\", \"attentively\" }, {\n+            \"autoamlly\", \"automatically\" }, {\n+            \"bankrot\", \"bankrupt\" }, {\n+            \"basicly\", \"basically\" }, {\n+            \"batallion\", \"battalion\" }, {\n+            \"bbrose\", \"browse\" }, {\n+            \"beauro\", \"bureau\" }, {\n+            \"beaurocracy\", \"bureaucracy\" }, {\n+            \"beggining\", \"beginning\" }, {\n+            \"beging\", \"beginning\" }, {\n+            \"behaviour\", \"behavior\" }, {\n+            \"beleive\", \"believe\" }, {\n+            \"belive\", \"believe\" }, {\n+            \"benidifs\", \"benefits\" }, {\n+            \"bigginging\", \"beginning\" }, {\n+            \"blait\", \"bleat\" }, {\n+            \"bouyant\", \"buoyant\" }, {\n+            \"boygot\", \"boycott\" }, {\n+            \"brocolli\", \"broccoli\" }, {\n+            \"buch\", \"bush\" }, {\n+            \"buder\", \"butter\" }, {\n+            \"budr\", \"butter\" }, {\n+            \"budter\", \"butter\" }, {\n+            \"buracracy\", \"bureaucracy\" }, {\n+            \"burracracy\", \"bureaucracy\" }, {\n+            \"buton\", \"button\" }, {\n+            \"byby\", \"by by\" }, {\n+            \"cauler\", \"caller\" }, {\n+            \"ceasar\", \"caesar\" }, {\n+            \"cemetary\", \"cemetery\" }, {\n+            \"changeing\", \"changing\" }, {\n+            \"cheet\", \"cheat\" }, {\n+            \"cicle\", \"circle\" }, {\n+            \"cimplicity\", \"simplicity\" }, {\n+            \"circumstaces\", \"circumstances\" }, {\n+            \"clob\", \"club\" }, {\n+            \"coaln\", \"colon\" }, {\n+            \"cocamena\", \"cockamamie\" }, {\n+            \"colleaque\", \"colleague\" }, {\n+            \"colloquilism\", \"colloquialism\" }, {\n+            \"columne\", \"column\" }, {\n+            \"comiler\", \"compiler\" }, {\n+            \"comitmment\", \"commitment\" }, {\n+            \"comitte\", \"committee\" }, {\n+            \"comittmen\", \"commitment\" }, {\n+            \"comittmend\", \"commitment\" }, {\n+            \"commerciasl\", \"commercials\" }, {\n+            \"commited\", \"committed\" }, {\n+            \"commitee\", \"committee\" }, {\n+            \"companys\", \"companies\" }, {\n+            \"compicated\", \"complicated\" }, {\n+            \"comupter\", \"computer\" }, {\n+            \"concensus\", \"consensus\" }, {\n+            \"confusionism\", \"confucianism\" }, {\n+            \"congradulations\", \"congratulations\" }, {\n+            \"conibation\", \"contribution\" }, {\n+            \"consident\", \"consistent\" }, {\n+            \"consident\", \"consonant\" }, {\n+            \"contast\", \"constant\" }, {\n+            \"contastant\", \"constant\" }, {\n+            \"contunie\", \"continue\" }, {\n+            \"cooly\", \"coolly\" }, {\n+            \"copping\", \"coping\" }, {\n+            \"cosmoplyton\", \"cosmopolitan\" }, {\n+            \"courst\", \"court\" }, {\n+            \"crasy\", \"crazy\" }, {\n+            \"cravets\", \"caveats\" }, {\n+            \"credetability\", \"credibility\" }, {\n+            \"criqitue\", \"critique\" }, {\n+            \"croke\", \"croak\" }, {\n+            \"crucifiction\", \"crucifixion\" }, {\n+            \"crusifed\", \"crucified\" }, {\n+            \"ctitique\", \"critique\" }, {\n+            \"cumba\", \"combo\" }, {\n+            \"custamisation\", \"customization\" }, {\n+            \"dag\", \"dog\" }, {\n+            \"daly\", \"daily\" }, {\n+            \"danguages\", \"dangerous\" }, {\n+            \"deaft\", \"draft\" }, {\n+            \"defence\", \"defense\" }, {\n+            \"defenly\", \"defiantly\" }, {\n+            \"definate\", \"definite\" }, {\n+            \"definately\", \"definitely\" }, {\n+            \"dependeble\", \"dependable\" }, {\n+            \"descrption\", \"description\" }, {\n+            \"descrptn\", \"description\" }, {\n+            \"desparate\", \"desperate\" }, {\n+            \"dessicate\", \"desiccate\" }, {\n+            \"destint\", \"distant\" }, {\n+            \"develepment\", \"developments\" }, {\n+            \"developement\", \"development\" }, {\n+            \"develpond\", \"development\" }, {\n+            \"devulge\", \"divulge\" }, {\n+            \"diagree\", \"disagree\" }, {\n+            \"dieties\", \"deities\" }, {\n+            \"dinasaur\", \"dinosaur\" }, {\n+            \"dinasour\", \"dinosaur\" }, {\n+            \"direcyly\", \"directly\" }, {\n+            \"discuess\", \"discuss\" }, {\n+            \"disect\", \"dissect\" }, {\n+            \"disippate\", \"dissipate\" }, {\n+            \"disition\", \"decision\" }, {\n+            \"dispair\", \"despair\" }, {\n+            \"disssicion\", \"discussion\" }, {\n+            \"distarct\", \"distract\" }, {\n+            \"distart\", \"distort\" }, {\n+            \"distroy\", \"destroy\" }, {\n+            \"documtations\", \"documentation\" }, {\n+            \"doenload\", \"download\" }, {\n+            \"dongle\", \"dangle\" }, {\n+            \"doog\", \"dog\" }, {\n+            \"dramaticly\", \"dramatically\" }, {\n+            \"drunkeness\", \"drunkenness\" }, {\n+            \"ductioneery\", \"dictionary\" }, {\n+            \"dur\", \"due\" }, {\n+            \"duren\", \"during\" }, {\n+            \"dymatic\", \"dynamic\" }, {\n+            \"dynaic\", \"dynamic\" }, {\n+            \"ecstacy\", \"ecstasy\" }, {\n+            \"efficat\", \"efficient\" }, {\n+            \"efficity\", \"efficacy\" }, {\n+            \"effots\", \"efforts\" }, {\n+            \"egsistence\", \"existence\" }, {\n+            \"eitiology\", \"etiology\" }, {\n+            \"elagent\", \"elegant\" }, {\n+            \"elligit\", \"elegant\" }, {\n+            \"embarass\", \"embarrass\" }, {\n+            \"embarassment\", \"embarrassment\" }, {\n+            \"embaress\", \"embarrass\" }, {\n+            \"encapsualtion\", \"encapsulation\" }, {\n+            \"encyclapidia\", \"encyclopedia\" }, {\n+            \"encyclopia\", \"encyclopedia\" }, {\n+            \"engins\", \"engine\" }, {\n+            \"enhence\", \"enhance\" }, {\n+            \"enligtment\", \"Enlightenment\" }, {\n+            \"ennuui\", \"ennui\" }, {\n+            \"enought\", \"enough\" }, {\n+            \"enventions\", \"inventions\" }, {\n+            \"envireminakl\", \"environmental\" }, {\n+            \"enviroment\", \"environment\" }, {\n+            \"epitomy\", \"epitome\" }, {\n+            \"equire\", \"acquire\" }, {\n+            \"errara\", \"error\" }, {\n+            \"erro\", \"error\" }, {\n+            \"evaualtion\", \"evaluation\" }, {\n+            \"evething\", \"everything\" }, {\n+            \"evtually\", \"eventually\" }, {\n+            \"excede\", \"exceed\" }, {\n+            \"excercise\", \"exercise\" }, {\n+            \"excpt\", \"except\" }, {\n+            \"excution\", \"execution\" }, {\n+            \"exhileration\", \"exhilaration\" }, {\n+            \"existance\", \"existence\" }, {\n+            \"expleyly\", \"explicitly\" }, {\n+            \"explity\", \"explicitly\" }, {\n+            \"expresso\", \"espresso\" }, {\n+            \"exspidient\", \"expedient\" }, {\n+            \"extions\", \"extensions\" }, {\n+            \"factontion\", \"factorization\" }, {\n+            \"failer\", \"failure\" }, {\n+            \"famdasy\", \"fantasy\" }, {\n+            \"faver\", \"favor\" }, {\n+            \"faxe\", \"fax\" }, {\n+            \"febuary\", \"february\" }, {\n+            \"firey\", \"fiery\" }, {\n+            \"fistival\", \"festival\" }, {\n+            \"flatterring\", \"flattering\" }, {\n+            \"fluk\", \"flux\" }, {\n+            \"flukse\", \"flux\" }, {\n+            \"fone\", \"phone\" }, {\n+            \"forsee\", \"foresee\" }, {\n+            \"frustartaion\", \"frustrating\" }, {\n+            \"fuction\", \"function\" }, {\n+            \"funetik\", \"phonetic\" }, {\n+            \"futs\", \"guts\" }, {\n+            \"gamne\", \"came\" }, {\n+            \"gaurd\", \"guard\" }, {\n+            \"generly\", \"generally\" }, {\n+            \"ghandi\", \"gandhi\" }, {\n+            \"goberment\", \"government\" }, {\n+            \"gobernement\", \"government\" }, {\n+            \"gobernment\", \"government\" }, {\n+            \"gotton\", \"gotten\" }, {\n+            \"gracefull\", \"graceful\" }, {\n+            \"gradualy\", \"gradually\" }, {\n+            \"grammer\", \"grammar\" }, {\n+            \"hallo\", \"hello\" }, {\n+            \"hapily\", \"happily\" }, {\n+            \"harrass\", \"harass\" }, {\n+            \"havne\", \"have\" }, {\n+            \"heellp\", \"help\" }, {\n+            \"heighth\", \"height\" }, {\n+            \"hellp\", \"help\" }, {\n+            \"helo\", \"hello\" }, {\n+            \"herlo\", \"hello\" }, {\n+            \"hifin\", \"hyphen\" }, {\n+            \"hifine\", \"hyphen\" }, {\n+            \"higer\", \"higher\" }, {\n+            \"hiphine\", \"hyphen\" }, {\n+            \"hippie\", \"hippy\" }, {\n+            \"hippopotamous\", \"hippopotamus\" }, {\n+            \"hlp\", \"help\" }, {\n+            \"hourse\", \"horse\" }, {\n+            \"houssing\", \"housing\" }, {\n+            \"howaver\", \"however\" }, {\n+            \"howver\", \"however\" }, {\n+            \"humaniti\", \"humanity\" }, {\n+            \"hyfin\", \"hyphen\" }, {\n+            \"hypotathes\", \"hypothesis\" }, {\n+            \"hypotathese\", \"hypothesis\" }, {\n+            \"hystrical\", \"hysterical\" }, {\n+            \"ident\", \"indent\" }, {\n+            \"illegitament\", \"illegitimate\" }, {\n+            \"imbed\", \"embed\" }, {\n+            \"imediaetly\", \"immediately\" }, {\n+            \"imfamy\", \"infamy\" }, {\n+            \"immenant\", \"immanent\" }, {\n+            \"implemtes\", \"implements\" }, {\n+            \"inadvertant\", \"inadvertent\" }, {\n+            \"incase\", \"in case\" }, {\n+            \"incedious\", \"insidious\" }, {\n+            \"incompleet\", \"incomplete\" }, {\n+            \"incomplot\", \"incomplete\" }, {\n+            \"inconvenant\", \"inconvenient\" }, {\n+            \"inconvience\", \"inconvenience\" }, {\n+            \"independant\", \"independent\" }, {\n+            \"independenent\", \"independent\" }, {\n+            \"indepnends\", \"independent\" }, {\n+            \"indepth\", \"in depth\" }, {\n+            \"indispensible\", \"indispensable\" }, {\n+            \"inefficite\", \"inefficient\" }, {\n+            \"inerface\", \"interface\" }, {\n+            \"infact\", \"in fact\" }, {\n+            \"influencial\", \"influential\" }, {\n+            \"inital\", \"initial\" }, {\n+            \"initinized\", \"initialized\" }, {\n+            \"initized\", \"initialized\" }, {\n+            \"innoculate\", \"inoculate\" }, {\n+            \"insistant\", \"insistent\" }, {\n+            \"insistenet\", \"insistent\" }, {\n+            \"instulation\", \"installation\" }, {\n+            \"intealignt\", \"intelligent\" }, {\n+            \"intejilent\", \"intelligent\" }, {\n+            \"intelegent\", \"intelligent\" }, {\n+            \"intelegnent\", \"intelligent\" }, {\n+            \"intelejent\", \"intelligent\" }, {\n+            \"inteligent\", \"intelligent\" }, {\n+            \"intelignt\", \"intelligent\" }, {\n+            \"intellagant\", \"intelligent\" }, {\n+            \"intellegent\", \"intelligent\" }, {\n+            \"intellegint\", \"intelligent\" }, {\n+            \"intellgnt\", \"intelligent\" }, {\n+            \"intensionality\", \"intensionally\" }, {\n+            \"interate\", \"iterate\" }, {\n+            \"internation\", \"international\" }, {\n+            \"interpretate\", \"interpret\" }, {\n+            \"interpretter\", \"interpreter\" }, {\n+            \"intertes\", \"interested\" }, {\n+            \"intertesd\", \"interested\" }, {\n+            \"invermeantial\", \"environmental\" }, {\n+            \"irregardless\", \"regardless\" }, {\n+            \"irresistable\", \"irresistible\" }, {\n+            \"irritible\", \"irritable\" }, {\n+            \"islams\", \"muslims\" }, {\n+            \"isotrop\", \"isotope\" }, {\n+            \"isreal\", \"israel\" }, {\n+            \"johhn\", \"john\" }, {\n+            \"judgement\", \"judgment\" }, {\n+            \"kippur\", \"kipper\" }, {\n+            \"knawing\", \"knowing\" }, {\n+            \"latext\", \"latest\" }, {\n+            \"leasve\", \"leave\" }, {\n+            \"lesure\", \"leisure\" }, {\n+            \"liasion\", \"lesion\" }, {\n+            \"liason\", \"liaison\" }, {\n+            \"libary\", \"library\" }, {\n+            \"likly\", \"likely\" }, {\n+            \"lilometer\", \"kilometer\" }, {\n+            \"liquify\", \"liquefy\" }, {\n+            \"lloyer\", \"layer\" }, {\n+            \"lossing\", \"losing\" }, {\n+            \"luser\", \"laser\" }, {\n+            \"maintanence\", \"maintenance\" }, {\n+            \"majaerly\", \"majority\" }, {\n+            \"majoraly\", \"majority\" }, {\n+            \"maks\", \"masks\" }, {\n+            \"mandelbrot\", \"Mandelbrot\" }, {\n+            \"mant\", \"want\" }, {\n+            \"marshall\", \"marshal\" }, {\n+            \"maxium\", \"maximum\" }, {\n+            \"meory\", \"memory\" }, {\n+            \"metter\", \"better\" }, {\n+            \"mic\", \"mike\" }, {\n+            \"midia\", \"media\" }, {\n+            \"millenium\", \"millennium\" }, {\n+            \"miniscule\", \"minuscule\" }, {\n+            \"minkay\", \"monkey\" }, {\n+            \"minum\", \"minimum\" }, {\n+            \"mischievious\", \"mischievous\" }, {\n+            \"misilous\", \"miscellaneous\" }, {\n+            \"momento\", \"memento\" }, {\n+            \"monkay\", \"monkey\" }, {\n+            \"mosaik\", \"mosaic\" }, {\n+            \"mostlikely\", \"most likely\" }, {\n+            \"mousr\", \"mouser\" }, {\n+            \"mroe\", \"more\" }, {\n+            \"neccessary\", \"necessary\" }, {\n+            \"necesary\", \"necessary\" }, {\n+            \"necesser\", \"necessary\" }, {\n+            \"neice\", \"niece\" }, {\n+            \"neighbour\", \"neighbor\" }, {\n+            \"nemonic\", \"pneumonic\" }, {\n+            \"nevade\", \"Nevada\" }, {\n+            \"nickleodeon\", \"nickelodeon\" }, {\n+            \"nieve\", \"naive\" }, {\n+            \"noone\", \"no one\" }, {\n+            \"noticably\", \"noticeably\" }, {\n+            \"notin\", \"not in\" }, {\n+            \"nozled\", \"nuzzled\" }, {\n+            \"objectsion\", \"objects\" }, {\n+            \"obsfuscate\", \"obfuscate\" }, {\n+            \"ocassion\", \"occasion\" }, {\n+            \"occuppied\", \"occupied\" }, {\n+            \"occurence\", \"occurrence\" }, {\n+            \"octagenarian\", \"octogenarian\" }, {\n+            \"olf\", \"old\" }, {\n+            \"opposim\", \"opossum\" }, {\n+            \"organise\", \"organize\" }, {\n+            \"organiz\", \"organize\" }, {\n+            \"orientate\", \"orient\" }, {\n+            \"oscilascope\", \"oscilloscope\" }, {\n+            \"oving\", \"moving\" }, {\n+            \"paramers\", \"parameters\" }, {\n+            \"parametic\", \"parameter\" }, {\n+            \"paranets\", \"parameters\" }, {\n+            \"partrucal\", \"particular\" }, {\n+            \"pataphysical\", \"metaphysical\" }, {\n+            \"patten\", \"pattern\" }, {\n+            \"permissable\", \"permissible\" }, {\n+            \"permition\", \"permission\" }, {\n+            \"permmasivie\", \"permissive\" }, {\n+            \"perogative\", \"prerogative\" }, {\n+            \"persue\", \"pursue\" }, {\n+            \"phantasia\", \"fantasia\" }, {\n+            \"phenominal\", \"phenomenal\" }, {\n+            \"picaresque\", \"picturesque\" }, {\n+            \"playwrite\", \"playwright\" }, {\n+            \"poeses\", \"poesies\" }, {\n+            \"polation\", \"politician\" }, {\n+            \"poligamy\", \"polygamy\" }, {\n+            \"politict\", \"politic\" }, {\n+            \"pollice\", \"police\" }, {\n+            \"polypropalene\", \"polypropylene\" }, {\n+            \"pompom\", \"pompon\" }, {\n+            \"possable\", \"possible\" }, {\n+            \"practicle\", \"practical\" }, {\n+            \"pragmaticism\", \"pragmatism\" }, {\n+            \"preceeding\", \"preceding\" }, {\n+            \"precion\", \"precision\" }, {\n+            \"precios\", \"precision\" }, {\n+            \"preemptory\", \"peremptory\" }, {\n+            \"prefices\", \"prefixes\" }, {\n+            \"prefixt\", \"prefixed\" }, {\n+            \"presbyterian\", \"Presbyterian\" }, {\n+            \"presue\", \"pursue\" }, {\n+            \"presued\", \"pursued\" }, {\n+            \"privielage\", \"privilege\" }, {\n+            \"priviledge\", \"privilege\" }, {\n+            \"proceedures\", \"procedures\" }, {\n+            \"pronensiation\", \"pronunciation\" }, {\n+            \"pronisation\", \"pronunciation\" }, {\n+            \"pronounciation\", \"pronunciation\" }, {\n+            \"properally\", \"properly\" }, {\n+            \"proplematic\", \"problematic\" }, {\n+            \"protray\", \"portray\" }, {\n+            \"pscolgst\", \"psychologist\" }, {\n+            \"psicolagest\", \"psychologist\" }, {\n+            \"psycolagest\", \"psychologist\" }, {\n+            \"quoz\", \"quiz\" }, {\n+            \"radious\", \"radius\" }, {\n+            \"ramplily\", \"rampantly\" }, {\n+            \"reccomend\", \"recommend\" }, {\n+            \"reccona\", \"raccoon\" }, {\n+            \"recieve\", \"receive\" }, {\n+            \"reconise\", \"recognize\" }, {\n+            \"rectangeles\", \"rectangle\" }, {\n+            \"redign\", \"redesign\" }, {\n+            \"reoccurring\", \"recurring\" }, {\n+            \"repitition\", \"repetition\" }, {\n+            \"replasments\", \"replacement\" }, {\n+            \"reposable\", \"responsible\" }, {\n+            \"reseblence\", \"resemblance\" }, {\n+            \"respct\", \"respect\" }, {\n+            \"respecally\", \"respectfully\" }, {\n+            \"roon\", \"room\" }, {\n+            \"rought\", \"roughly\" }, {\n+            \"rsx\", \"RSX\" }, {\n+            \"rudemtry\", \"rudimentary\" }, {\n+            \"runnung\", \"running\" }, {\n+            \"sacreligious\", \"sacrilegious\" }, {\n+            \"saftly\", \"safely\" }, {\n+            \"salut\", \"salute\" }, {\n+            \"satifly\", \"satisfy\" }, {\n+            \"scrabdle\", \"scrabble\" }, {\n+            \"searcheable\", \"searchable\" }, {\n+            \"secion\", \"section\" }, {\n+            \"seferal\", \"several\" }, {\n+            \"segements\", \"segments\" }, {\n+            \"sence\", \"sense\" }, {\n+            \"seperate\", \"separate\" }, {\n+            \"sherbert\", \"sherbet\" }, {\n+            \"sicolagest\", \"psychologist\" }, {\n+            \"sieze\", \"seize\" }, {\n+            \"simpfilty\", \"simplicity\" }, {\n+            \"simplye\", \"simply\" }, {\n+            \"singal\", \"signal\" }, {\n+            \"sitte\", \"site\" }, {\n+            \"situration\", \"situation\" }, {\n+            \"slyph\", \"sylph\" }, {\n+            \"smil\", \"smile\" }, {\n+            \"snuck\", \"sneaked\" }, {\n+            \"sometmes\", \"sometimes\" }, {\n+            \"soonec\", \"sonic\" }, {\n+            \"specificialy\", \"specifically\" }, {\n+            \"spel\", \"spell\" }, {\n+            \"spoak\", \"spoke\" }, {\n+            \"sponsered\", \"sponsored\" }, {\n+            \"stering\", \"steering\" }, {\n+            \"straightjacket\", \"straitjacket\" }, {\n+            \"stumach\", \"stomach\" }, {\n+            \"stutent\", \"student\" }, {\n+            \"styleguide\", \"style guide\" }, {\n+            \"subisitions\", \"substitutions\" }, {\n+            \"subjecribed\", \"subscribed\" }, {\n+            \"subpena\", \"subpoena\" }, {\n+            \"substations\", \"substitutions\" }, {\n+            \"suger\", \"sugar\" }, {\n+            \"supercede\", \"supersede\" }, {\n+            \"superfulous\", \"superfluous\" }, {\n+            \"susan\", \"Susan\" }, {\n+            \"swimwear\", \"swim wear\" }, {\n+            \"syncorization\", \"synchronization\" }, {\n+            \"taff\", \"tough\" }, {\n+            \"taht\", \"that\" }, {\n+            \"tattos\", \"tattoos\" }, {\n+            \"techniquely\", \"technically\" }, {\n+            \"teh\", \"the\" }, {\n+            \"tem\", \"team\" }, {\n+            \"teo\", \"two\" }, {\n+            \"teridical\", \"theoretical\" }, {\n+            \"tesst\", \"test\" }, {\n+            \"tets\", \"tests\" }, {\n+            \"thanot\", \"than or\" }, {\n+            \"theirselves\", \"themselves\" }, {\n+            \"theridically\", \"theoretical\" }, {\n+            \"thredically\", \"theoretically\" }, {\n+            \"thruout\", \"throughout\" }, {\n+            \"ths\", \"this\" }, {\n+            \"titalate\", \"titillate\" }, {\n+            \"tobagan\", \"tobaggon\" }, {\n+            \"tommorrow\", \"tomorrow\" }, {\n+            \"tomorow\", \"tomorrow\" }, {\n+            \"tradegy\", \"tragedy\" }, {\n+            \"trubbel\", \"trouble\" }, {\n+            \"ttest\", \"test\" }, {\n+            \"tunnellike\", \"tunnel like\" }, {\n+            \"tured\", \"turned\" }, {\n+            \"tyrrany\", \"tyranny\" }, {\n+            \"unatourral\", \"unnatural\" }, {\n+            \"unaturral\", \"unnatural\" }, {\n+            \"unconisitional\", \"unconstitutional\" }, {\n+            \"unconscience\", \"unconscious\" }, {\n+            \"underladder\", \"under ladder\" }, {\n+            \"unentelegible\", \"unintelligible\" }, {\n+            \"unfortunently\", \"unfortunately\" }, {\n+            \"unnaturral\", \"unnatural\" }, {\n+            \"upcast\", \"up cast\" }, {\n+            \"upmost\", \"utmost\" }, {\n+            \"uranisium\", \"uranium\" }, {\n+            \"verison\", \"version\" }, {\n+            \"vinagarette\", \"vinaigrette\" }, {\n+            \"volumptuous\", \"voluptuous\" }, {\n+            \"volunteerism\", \"voluntarism\" }, {\n+            \"volye\", \"volley\" }, {\n+            \"wadting\", \"wasting\" }, {\n+            \"waite\", \"wait\" }, {\n+            \"wan't\", \"won't\" }, {\n+            \"warloord\", \"warlord\" }, {\n+            \"whaaat\", \"what\" }, {\n+            \"whard\", \"ward\" }, {\n+            \"whimp\", \"wimp\" }, {\n+            \"wicken\", \"weaken\" }, {\n+            \"wierd\", \"weird\" }, {\n+            \"wrank\", \"rank\" }, {\n+            \"writeen\", \"righten\" }, {\n+            \"writting\", \"writing\" }, {\n+            \"wundeews\", \"windows\" }, {\n+            \"yeild\", \"yield\" }, {\n+            \"youe\", \"your\" }\n+    };\n+\n+    /**\n+     * A subset of FIXTURE generated by this test.\n+     */\n+    private static final String[][] MATCHES = { { \"Accosinly\", \"Occasionally\" }, {\n+            \"Maddness\", \"Madness\" }, {\n+            \"Occusionaly\", \"Occasionally\" }, {\n+            \"Steffen\", \"Stephen\" }, {\n+            \"Thw\", \"The\" }, {\n+            \"Unformanlly\", \"Unfortunately\" }, {\n+            \"Unfortally\", \"Unfortunately\" }, {\n+            \"abilitey\", \"ability\" }, {\n+            \"absorbtion\", \"absorption\" }, {\n+            \"accidently\", \"accidentally\" }, {\n+            \"accomodate\", \"accommodate\" }, {\n+            \"acommadate\", \"accommodate\" }, {\n+            \"acord\", \"accord\" }, {\n+            \"adultry\", \"adultery\" }, {\n+            \"aggresive\", \"aggressive\" }, {\n+            \"alchohol\", \"alcohol\" }, {\n+            \"alchoholic\", \"alcoholic\" }, {\n+            \"allieve\", \"alive\" }, {\n+            \"alot\", \"a lot\" }, {\n+            \"alright\", \"all right\" }, {\n+            \"amature\", \"amateur\" }, {\n+            \"ambivilant\", \"ambivalent\" }, {\n+            \"amourfous\", \"amorphous\" }, {\n+            \"annoint\", \"anoint\" }, {\n+            \"annonsment\", \"announcement\" }, {\n+            \"annoyting\", \"anting\" }, {\n+            \"annuncio\", \"announce\" }, {\n+            \"anotomy\", \"anatomy\" }, {\n+            \"antidesestablishmentarianism\", \"antidisestablishmentarianism\" }, {\n+            \"antidisestablishmentarism\", \"antidisestablishmentarianism\" }, {\n+            \"anynomous\", \"anonymous\" }, {\n+            \"appelet\", \"applet\" }, {\n+            \"appreceiated\", \"appreciated\" }, {\n+            \"appresteate\", \"appreciate\" }, {\n+            \"aquantance\", \"acquaintance\" }, {\n+            \"aricticure\", \"architecture\" }, {\n+            \"asterick\", \"asterisk\" }, {\n+            \"asymetric\", \"asymmetric\" }, {\n+            \"atentively\", \"attentively\" }, {\n+            \"bankrot\", \"bankrupt\" }, {\n+            \"basicly\", \"basically\" }, {\n+            \"batallion\", \"battalion\" }, {\n+            \"bbrose\", \"browse\" }, {\n+            \"beauro\", \"bureau\" }, {\n+            \"beaurocracy\", \"bureaucracy\" }, {\n+            \"beggining\", \"beginning\" }, {\n+            \"behaviour\", \"behavior\" }, {\n+            \"beleive\", \"believe\" }, {\n+            \"belive\", \"believe\" }, {\n+            \"blait\", \"bleat\" }, {\n+            \"bouyant\", \"buoyant\" }, {\n+            \"boygot\", \"boycott\" }, {\n+            \"brocolli\", \"broccoli\" }, {\n+            \"buder\", \"butter\" }, {\n+            \"budr\", \"butter\" }, {\n+            \"budter\", \"butter\" }, {\n+            \"buracracy\", \"bureaucracy\" }, {\n+            \"burracracy\", \"bureaucracy\" }, {\n+            \"buton\", \"button\" }, {\n+            \"byby\", \"by by\" }, {\n+            \"cauler\", \"caller\" }, {\n+            \"ceasar\", \"caesar\" }, {\n+            \"cemetary\", \"cemetery\" }, {\n+            \"changeing\", \"changing\" }, {\n+            \"cheet\", \"cheat\" }, {\n+            \"cimplicity\", \"simplicity\" }, {\n+            \"circumstaces\", \"circumstances\" }, {\n+            \"clob\", \"club\" }, {\n+            \"coaln\", \"colon\" }, {\n+            \"colleaque\", \"colleague\" }, {\n+            \"colloquilism\", \"colloquialism\" }, {\n+            \"columne\", \"column\" }, {\n+            \"comitmment\", \"commitment\" }, {\n+            \"comitte\", \"committee\" }, {\n+            \"comittmen\", \"commitment\" }, {\n+            \"comittmend\", \"commitment\" }, {\n+            \"commerciasl\", \"commercials\" }, {\n+            \"commited\", \"committed\" }, {\n+            \"commitee\", \"committee\" }, {\n+            \"companys\", \"companies\" }, {\n+            \"comupter\", \"computer\" }, {\n+            \"concensus\", \"consensus\" }, {\n+            \"confusionism\", \"confucianism\" }, {\n+            \"congradulations\", \"congratulations\" }, {\n+            \"contunie\", \"continue\" }, {\n+            \"cooly\", \"coolly\" }, {\n+            \"copping\", \"coping\" }, {\n+            \"cosmoplyton\", \"cosmopolitan\" }, {\n+            \"crasy\", \"crazy\" }, {\n+            \"croke\", \"croak\" }, {\n+            \"crucifiction\", \"crucifixion\" }, {\n+            \"crusifed\", \"crucified\" }, {\n+            \"cumba\", \"combo\" }, {\n+            \"custamisation\", \"customization\" }, {\n+            \"dag\", \"dog\" }, {\n+            \"daly\", \"daily\" }, {\n+            \"defence\", \"defense\" }, {\n+            \"definate\", \"definite\" }, {\n+            \"definately\", \"definitely\" }, {\n+            \"dependeble\", \"dependable\" }, {\n+            \"descrption\", \"description\" }, {\n+            \"descrptn\", \"description\" }, {\n+            \"desparate\", \"desperate\" }, {\n+            \"dessicate\", \"desiccate\" }, {\n+            \"destint\", \"distant\" }, {\n+            \"develepment\", \"developments\" }, {\n+            \"developement\", \"development\" }, {\n+            \"develpond\", \"development\" }, {\n+            \"devulge\", \"divulge\" }, {\n+            \"dieties\", \"deities\" }, {\n+            \"dinasaur\", \"dinosaur\" }, {\n+            \"dinasour\", \"dinosaur\" }, {\n+            \"discuess\", \"discuss\" }, {\n+            \"disect\", \"dissect\" }, {\n+            \"disippate\", \"dissipate\" }, {\n+            \"disition\", \"decision\" }, {\n+            \"dispair\", \"despair\" }, {\n+            \"distarct\", \"distract\" }, {\n+            \"distart\", \"distort\" }, {\n+            \"distroy\", \"destroy\" }, {\n+            \"doenload\", \"download\" }, {\n+            \"dongle\", \"dangle\" }, {\n+            \"doog\", \"dog\" }, {\n+            \"dramaticly\", \"dramatically\" }, {\n+            \"drunkeness\", \"drunkenness\" }, {\n+            \"ductioneery\", \"dictionary\" }, {\n+            \"ecstacy\", \"ecstasy\" }, {\n+            \"egsistence\", \"existence\" }, {\n+            \"eitiology\", \"etiology\" }, {\n+            \"elagent\", \"elegant\" }, {\n+            \"embarass\", \"embarrass\" }, {\n+            \"embarassment\", \"embarrassment\" }, {\n+            \"embaress\", \"embarrass\" }, {\n+            \"encapsualtion\", \"encapsulation\" }, {\n+            \"encyclapidia\", \"encyclopedia\" }, {\n+            \"encyclopia\", \"encyclopedia\" }, {\n+            \"engins\", \"engine\" }, {\n+            \"enhence\", \"enhance\" }, {\n+            \"ennuui\", \"ennui\" }, {\n+            \"enventions\", \"inventions\" }, {\n+            \"envireminakl\", \"environmental\" }, {\n+            \"enviroment\", \"environment\" }, {\n+            \"epitomy\", \"epitome\" }, {\n+            \"equire\", \"acquire\" }, {\n+            \"errara\", \"error\" }, {\n+            \"evaualtion\", \"evaluation\" }, {\n+            \"excede\", \"exceed\" }, {\n+            \"excercise\", \"exercise\" }, {\n+            \"excpt\", \"except\" }, {\n+            \"exhileration\", \"exhilaration\" }, {\n+            \"existance\", \"existence\" }, {\n+            \"expleyly\", \"explicitly\" }, {\n+            \"explity\", \"explicitly\" }, {\n+            \"failer\", \"failure\" }, {\n+            \"faver\", \"favor\" }, {\n+            \"faxe\", \"fax\" }, {\n+            \"firey\", \"fiery\" }, {\n+            \"fistival\", \"festival\" }, {\n+            \"flatterring\", \"flattering\" }, {\n+            \"flukse\", \"flux\" }, {\n+            \"fone\", \"phone\" }, {\n+            \"forsee\", \"foresee\" }, {\n+            \"frustartaion\", \"frustrating\" }, {\n+            \"funetik\", \"phonetic\" }, {\n+            \"gaurd\", \"guard\" }, {\n+            \"generly\", \"generally\" }, {\n+            \"ghandi\", \"gandhi\" }, {\n+            \"gotton\", \"gotten\" }, {\n+            \"gracefull\", \"graceful\" }, {\n+            \"gradualy\", \"gradually\" }, {\n+            \"grammer\", \"grammar\" }, {\n+            \"hallo\", \"hello\" }, {\n+            \"hapily\", \"happily\" }, {\n+            \"harrass\", \"harass\" }, {\n+            \"heellp\", \"help\" }, {\n+            \"heighth\", \"height\" }, {\n+            \"hellp\", \"help\" }, {\n+            \"helo\", \"hello\" }, {\n+            \"hifin\", \"hyphen\" }, {\n+            \"hifine\", \"hyphen\" }, {\n+            \"hiphine\", \"hyphen\" }, {\n+            \"hippie\", \"hippy\" }, {\n+            \"hippopotamous\", \"hippopotamus\" }, {\n+            \"hourse\", \"horse\" }, {\n+            \"houssing\", \"housing\" }, {\n+            \"howaver\", \"however\" }, {\n+            \"howver\", \"however\" }, {\n+            \"humaniti\", \"humanity\" }, {\n+            \"hyfin\", \"hyphen\" }, {\n+            \"hystrical\", \"hysterical\" }, {\n+            \"illegitament\", \"illegitimate\" }, {\n+            \"imbed\", \"embed\" }, {\n+            \"imediaetly\", \"immediately\" }, {\n+            \"immenant\", \"immanent\" }, {\n+            \"implemtes\", \"implements\" }, {\n+            \"inadvertant\", \"inadvertent\" }, {\n+            \"incase\", \"in case\" }, {\n+            \"incedious\", \"insidious\" }, {\n+            \"incompleet\", \"incomplete\" }, {\n+            \"incomplot\", \"incomplete\" }, {\n+            \"inconvenant\", \"inconvenient\" }, {\n+            \"inconvience\", \"inconvenience\" }, {\n+            \"independant\", \"independent\" }, {\n+            \"independenent\", \"independent\" }, {\n+            \"indepnends\", \"independent\" }, {\n+            \"indepth\", \"in depth\" }, {\n+            \"indispensible\", \"indispensable\" }, {\n+            \"inefficite\", \"inefficient\" }, {\n+            \"infact\", \"in fact\" }, {\n+            \"influencial\", \"influential\" }, {\n+            \"innoculate\", \"inoculate\" }, {\n+            \"insistant\", \"insistent\" }, {\n+            \"insistenet\", \"insistent\" }, {\n+            \"instulation\", \"installation\" }, {\n+            \"intealignt\", \"intelligent\" }, {\n+            \"intelegent\", \"intelligent\" }, {\n+            \"intelegnent\", \"intelligent\" }, {\n+            \"intelejent\", \"intelligent\" }, {\n+            \"inteligent\", \"intelligent\" }, {\n+            \"intelignt\", \"intelligent\" }, {\n+            \"intellagant\", \"intelligent\" }, {\n+            \"intellegent\", \"intelligent\" }, {\n+            \"intellegint\", \"intelligent\" }, {\n+            \"intellgnt\", \"intelligent\" }, {\n+            \"intensionality\", \"intensionally\" }, {\n+            \"internation\", \"international\" }, {\n+            \"interpretate\", \"interpret\" }, {\n+            \"interpretter\", \"interpreter\" }, {\n+            \"intertes\", \"interested\" }, {\n+            \"intertesd\", \"interested\" }, {\n+            \"invermeantial\", \"environmental\" }, {\n+            \"irresistable\", \"irresistible\" }, {\n+            \"irritible\", \"irritable\" }, {\n+            \"isreal\", \"israel\" }, {\n+            \"johhn\", \"john\" }, {\n+            \"kippur\", \"kipper\" }, {\n+            \"knawing\", \"knowing\" }, {\n+            \"lesure\", \"leisure\" }, {\n+            \"liasion\", \"lesion\" }, {\n+            \"liason\", \"liaison\" }, {\n+            \"likly\", \"likely\" }, {\n+            \"liquify\", \"liquefy\" }, {\n+            \"lloyer\", \"layer\" }, {\n+            \"lossing\", \"losing\" }, {\n+            \"luser\", \"laser\" }, {\n+            \"maintanence\", \"maintenance\" }, {\n+            \"mandelbrot\", \"Mandelbrot\" }, {\n+            \"marshall\", \"marshal\" }, {\n+            \"maxium\", \"maximum\" }, {\n+            \"mic\", \"mike\" }, {\n+            \"midia\", \"media\" }, {\n+            \"millenium\", \"millennium\" }, {\n+            \"miniscule\", \"minuscule\" }, {\n+            \"minkay\", \"monkey\" }, {\n+            \"mischievious\", \"mischievous\" }, {\n+            \"momento\", \"memento\" }, {\n+            \"monkay\", \"monkey\" }, {\n+            \"mosaik\", \"mosaic\" }, {\n+            \"mostlikely\", \"most likely\" }, {\n+            \"mousr\", \"mouser\" }, {\n+            \"mroe\", \"more\" }, {\n+            \"necesary\", \"necessary\" }, {\n+            \"necesser\", \"necessary\" }, {\n+            \"neice\", \"niece\" }, {\n+            \"neighbour\", \"neighbor\" }, {\n+            \"nemonic\", \"pneumonic\" }, {\n+            \"nevade\", \"Nevada\" }, {\n+            \"nickleodeon\", \"nickelodeon\" }, {\n+            \"nieve\", \"naive\" }, {\n+            \"noone\", \"no one\" }, {\n+            \"notin\", \"not in\" }, {\n+            \"nozled\", \"nuzzled\" }, {\n+            \"objectsion\", \"objects\" }, {\n+            \"ocassion\", \"occasion\" }, {\n+            \"occuppied\", \"occupied\" }, {\n+            \"occurence\", \"occurrence\" }, {\n+            \"octagenarian\", \"octogenarian\" }, {\n+            \"opposim\", \"opossum\" }, {\n+            \"organise\", \"organize\" }, {\n+            \"organiz\", \"organize\" }, {\n+            \"orientate\", \"orient\" }, {\n+            \"oscilascope\", \"oscilloscope\" }, {\n+            \"parametic\", \"parameter\" }, {\n+            \"permissable\", \"permissible\" }, {\n+            \"permmasivie\", \"permissive\" }, {\n+            \"persue\", \"pursue\" }, {\n+            \"phantasia\", \"fantasia\" }, {\n+            \"phenominal\", \"phenomenal\" }, {\n+            \"playwrite\", \"playwright\" }, {\n+            \"poeses\", \"poesies\" }, {\n+            \"poligamy\", \"polygamy\" }, {\n+            \"politict\", \"politic\" }, {\n+            \"pollice\", \"police\" }, {\n+            \"polypropalene\", \"polypropylene\" }, {\n+            \"possable\", \"possible\" }, {\n+            \"practicle\", \"practical\" }, {\n+            \"pragmaticism\", \"pragmatism\" }, {\n+            \"preceeding\", \"preceding\" }, {\n+            \"precios\", \"precision\" }, {\n+            \"preemptory\", \"peremptory\" }, {\n+            \"prefixt\", \"prefixed\" }, {\n+            \"presbyterian\", \"Presbyterian\" }, {\n+            \"presue\", \"pursue\" }, {\n+            \"presued\", \"pursued\" }, {\n+            \"privielage\", \"privilege\" }, {\n+            \"priviledge\", \"privilege\" }, {\n+            \"proceedures\", \"procedures\" }, {\n+            \"pronensiation\", \"pronunciation\" }, {\n+            \"pronounciation\", \"pronunciation\" }, {\n+            \"properally\", \"properly\" }, {\n+            \"proplematic\", \"problematic\" }, {\n+            \"protray\", \"portray\" }, {\n+            \"pscolgst\", \"psychologist\" }, {\n+            \"psicolagest\", \"psychologist\" }, {\n+            \"psycolagest\", \"psychologist\" }, {\n+            \"quoz\", \"quiz\" }, {\n+            \"radious\", \"radius\" }, {\n+            \"reccomend\", \"recommend\" }, {\n+            \"reccona\", \"raccoon\" }, {\n+            \"recieve\", \"receive\" }, {\n+            \"reconise\", \"recognize\" }, {\n+            \"rectangeles\", \"rectangle\" }, {\n+            \"reoccurring\", \"recurring\" }, {\n+            \"repitition\", \"repetition\" }, {\n+            \"replasments\", \"replacement\" }, {\n+            \"respct\", \"respect\" }, {\n+            \"respecally\", \"respectfully\" }, {\n+            \"rsx\", \"RSX\" }, {\n+            \"runnung\", \"running\" }, {\n+            \"sacreligious\", \"sacrilegious\" }, {\n+            \"salut\", \"salute\" }, {\n+            \"searcheable\", \"searchable\" }, {\n+            \"seferal\", \"several\" }, {\n+            \"segements\", \"segments\" }, {\n+            \"sence\", \"sense\" }, {\n+            \"seperate\", \"separate\" }, {\n+            \"sicolagest\", \"psychologist\" }, {\n+            \"sieze\", \"seize\" }, {\n+            \"simplye\", \"simply\" }, {\n+            \"sitte\", \"site\" }, {\n+            \"slyph\", \"sylph\" }, {\n+            \"smil\", \"smile\" }, {\n+            \"sometmes\", \"sometimes\" }, {\n+            \"soonec\", \"sonic\" }, {\n+            \"specificialy\", \"specifically\" }, {\n+            \"spel\", \"spell\" }, {\n+            \"spoak\", \"spoke\" }, {\n+            \"sponsered\", \"sponsored\" }, {\n+            \"stering\", \"steering\" }, {\n+            \"straightjacket\", \"straitjacket\" }, {\n+            \"stumach\", \"stomach\" }, {\n+            \"stutent\", \"student\" }, {\n+            \"styleguide\", \"style guide\" }, {\n+            \"subpena\", \"subpoena\" }, {\n+            \"substations\", \"substitutions\" }, {\n+            \"supercede\", \"supersede\" }, {\n+            \"superfulous\", \"superfluous\" }, {\n+            \"susan\", \"Susan\" }, {\n+            \"swimwear\", \"swim wear\" }, {\n+            \"syncorization\", \"synchronization\" }, {\n+            \"taff\", \"tough\" }, {\n+            \"taht\", \"that\" }, {\n+            \"tattos\", \"tattoos\" }, {\n+            \"techniquely\", \"technically\" }, {\n+            \"teh\", \"the\" }, {\n+            \"tem\", \"team\" }, {\n+            \"teo\", \"two\" }, {\n+            \"teridical\", \"theoretical\" }, {\n+            \"tesst\", \"test\" }, {\n+            \"theridically\", \"theoretical\" }, {\n+            \"thredically\", \"theoretically\" }, {\n+            \"thruout\", \"throughout\" }, {\n+            \"ths\", \"this\" }, {\n+            \"titalate\", \"titillate\" }, {\n+            \"tobagan\", \"tobaggon\" }, {\n+            \"tommorrow\", \"tomorrow\" }, {\n+            \"tomorow\", \"tomorrow\" }, {\n+            \"trubbel\", \"trouble\" }, {\n+            \"ttest\", \"test\" }, {\n+            \"tyrrany\", \"tyranny\" }, {\n+            \"unatourral\", \"unnatural\" }, {\n+            \"unaturral\", \"unnatural\" }, {\n+            \"unconisitional\", \"unconstitutional\" }, {\n+            \"unconscience\", \"unconscious\" }, {\n+            \"underladder\", \"under ladder\" }, {\n+            \"unentelegible\", \"unintelligible\" }, {\n+            \"unfortunently\", \"unfortunately\" }, {\n+            \"unnaturral\", \"unnatural\" }, {\n+            \"upcast\", \"up cast\" }, {\n+            \"verison\", \"version\" }, {\n+            \"vinagarette\", \"vinaigrette\" }, {\n+            \"volunteerism\", \"voluntarism\" }, {\n+            \"volye\", \"volley\" }, {\n+            \"waite\", \"wait\" }, {\n+            \"wan't\", \"won't\" }, {\n+            \"warloord\", \"warlord\" }, {\n+            \"whaaat\", \"what\" }, {\n+            \"whard\", \"ward\" }, {\n+            \"whimp\", \"wimp\" }, {\n+            \"wicken\", \"weaken\" }, {\n+            \"wierd\", \"weird\" }, {\n+            \"wrank\", \"rank\" }, {\n+            \"writeen\", \"righten\" }, {\n+            \"writting\", \"writing\" }, {\n+            \"wundeews\", \"windows\" }, {\n+            \"yeild\", \"yield\" }, };\n+\n+    /**\n+     * Tests encoding APIs in one place.\n+     */\n+    private void assertDoubleMetaphone(String expected, String source) {\n+        assertEquals(expected, this.getDoubleMetaphone().encode(source));\n+        try {\n+            assertEquals(expected, this.getDoubleMetaphone().encode((Object) source));\n+        } catch (EncoderException e) {\n+            fail(\"Unexpected expection: \" + e);\n+        }\n+        assertEquals(expected, this.getDoubleMetaphone().doubleMetaphone(source));\n+        assertEquals(expected, this.getDoubleMetaphone().doubleMetaphone(source, false));\n+    }\n+\n+    /**\n+     * Tests encoding APIs in one place.\n+     */\n+    public void assertDoubleMetaphoneAlt(String expected, String source) {\n+        assertEquals(expected, this.getDoubleMetaphone().doubleMetaphone(source, true));\n+    }\n+\n+    public void doubleMetaphoneEqualTest(String[][] pairs, boolean useAlternate) {\n+        this.validateFixture(pairs);\n+        for (String[] pair : pairs) {\n+            String name0 = pair[0];\n+            String name1 = pair[1];\n+            String failMsg = \"Expected match between \" + name0 + \" and \" + name1 + \" (use alternate: \" + useAlternate + \")\";\n+            assertTrue(failMsg, this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, useAlternate));\n+            assertTrue(failMsg, this.getDoubleMetaphone().isDoubleMetaphoneEqual(name1, name0, useAlternate));\n+            if (!useAlternate) {\n+                assertTrue(failMsg, this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1));\n+                assertTrue(failMsg, this.getDoubleMetaphone().isDoubleMetaphoneEqual(name1, name0));\n+            }\n+        }\n+    }\n+\n+    public void doubleMetaphoneNotEqualTest(boolean alternate) {\n+        assertFalse(this.getDoubleMetaphone().isDoubleMetaphoneEqual(\"Brain\", \"Band\", alternate));\n+        assertFalse(this.getDoubleMetaphone().isDoubleMetaphoneEqual(\"Band\", \"Brain\", alternate));\n+\n+        if (!alternate) {\n+            assertFalse(this.getDoubleMetaphone().isDoubleMetaphoneEqual(\"Brain\", \"Band\"));\n+            assertFalse(this.getDoubleMetaphone().isDoubleMetaphoneEqual(\"Band\", \"Brain\"));\n+        }\n+    }\n+\n+    private DoubleMetaphone getDoubleMetaphone() {\n+        return (DoubleMetaphone) this.getStringEncoder();\n+    }\n+\n+    @Override\n+    protected StringEncoder createStringEncoder() {\n+        return new DoubleMetaphone();\n+    }\n+\n+    @Test\n+    public void testDoubleMetaphone() {\n+        assertDoubleMetaphone(\"TSTN\", \"testing\");\n+        assertDoubleMetaphone(\"0\", \"The\");\n+        assertDoubleMetaphone(\"KK\", \"quick\");\n+        assertDoubleMetaphone(\"PRN\", \"brown\");\n+        assertDoubleMetaphone(\"FKS\", \"fox\");\n+        assertDoubleMetaphone(\"JMPT\", \"jumped\");\n+        assertDoubleMetaphone(\"AFR\", \"over\");\n+        assertDoubleMetaphone(\"0\", \"the\");\n+        assertDoubleMetaphone(\"LS\", \"lazy\");\n+        assertDoubleMetaphone(\"TKS\", \"dogs\");\n+        assertDoubleMetaphone(\"MKFR\", \"MacCafferey\");\n+        assertDoubleMetaphone(\"STFN\", \"Stephan\");\n+        assertDoubleMetaphone(\"KSSK\", \"Kuczewski\");\n+        assertDoubleMetaphone(\"MKLL\", \"McClelland\");\n+        assertDoubleMetaphone(\"SNHS\", \"san jose\");\n+        assertDoubleMetaphone(\"SNFP\", \"xenophobia\");\n+\n+        assertDoubleMetaphoneAlt(\"TSTN\", \"testing\");\n+        assertDoubleMetaphoneAlt(\"T\", \"The\");\n+        assertDoubleMetaphoneAlt(\"KK\", \"quick\");\n+        assertDoubleMetaphoneAlt(\"PRN\", \"brown\");\n+        assertDoubleMetaphoneAlt(\"FKS\", \"fox\");\n+        assertDoubleMetaphoneAlt(\"AMPT\", \"jumped\");\n+        assertDoubleMetaphoneAlt(\"AFR\", \"over\");\n+        assertDoubleMetaphoneAlt(\"T\", \"the\");\n+        assertDoubleMetaphoneAlt(\"LS\", \"lazy\");\n+        assertDoubleMetaphoneAlt(\"TKS\", \"dogs\");\n+        assertDoubleMetaphoneAlt(\"MKFR\", \"MacCafferey\");\n+        assertDoubleMetaphoneAlt(\"STFN\", \"Stephan\");\n+        assertDoubleMetaphoneAlt(\"KXFS\", \"Kutchefski\");\n+        assertDoubleMetaphoneAlt(\"MKLL\", \"McClelland\");\n+        assertDoubleMetaphoneAlt(\"SNHS\", \"san jose\");\n+        assertDoubleMetaphoneAlt(\"SNFP\", \"xenophobia\");\n+        assertDoubleMetaphoneAlt(\"FKR\", \"Fokker\");\n+        assertDoubleMetaphoneAlt(\"AK\", \"Joqqi\");\n+        assertDoubleMetaphoneAlt(\"HF\", \"Hovvi\");\n+        assertDoubleMetaphoneAlt(\"XRN\", \"Czerny\");\n+    }\n+\n+    @Test\n+    public void testEmpty() {\n+        assertEquals(null, this.getDoubleMetaphone().doubleMetaphone(null));\n+        assertEquals(null, this.getDoubleMetaphone().doubleMetaphone(\"\"));\n+        assertEquals(null, this.getDoubleMetaphone().doubleMetaphone(\" \"));\n+        assertEquals(null, this.getDoubleMetaphone().doubleMetaphone(\"\\t\\n\\r \"));\n+    }\n+\n+    /**\n+     * Test setting maximum length\n+     */\n+    @Test\n+    public void testSetMaxCodeLength() {\n+        String value = \"jumped\";\n+        \n+        DoubleMetaphone doubleMetaphone = new DoubleMetaphone();\n+\n+        // Sanity check of default settings\n+        assertEquals(\"Default Max Code Length\", 4, doubleMetaphone.getMaxCodeLen());\n+        assertEquals(\"Default Primary\",   \"JMPT\", doubleMetaphone.doubleMetaphone(value, false));\n+        assertEquals(\"Default Alternate\", \"AMPT\", doubleMetaphone.doubleMetaphone(value, true));\n+\n+        // Check setting Max Code Length\n+        doubleMetaphone.setMaxCodeLen(3);\n+        assertEquals(\"Set Max Code Length\", 3, doubleMetaphone.getMaxCodeLen());\n+        assertEquals(\"Max=3 Primary\",   \"JMP\", doubleMetaphone.doubleMetaphone(value, false));\n+        assertEquals(\"Max=3 Alternate\", \"AMP\", doubleMetaphone.doubleMetaphone(value, true));\n+    }\n+\n+    @Test\n+    public void testIsDoubleMetaphoneEqualBasic() {\n+        String[][] testFixture = new String[][] { { \"Case\", \"case\" }, {\n+                \"CASE\", \"Case\" }, {\n+                \"caSe\", \"cAsE\" }, {\n+                \"cookie\", \"quick\" }, {\n+                \"quick\", \"cookie\" }, {\n+                \"Brian\", \"Bryan\" }, {\n+                \"Auto\", \"Otto\" }, {\n+                \"Steven\", \"Stefan\" }, {\n+                \"Philipowitz\", \"Filipowicz\" }\n+        };\n+        doubleMetaphoneEqualTest(testFixture, false);\n+        doubleMetaphoneEqualTest(testFixture, true);\n+    }\n+\n+    /**\n+     * Example in the original article but failures in this Java impl:\n+     */\n+    @Test\n+    public void testIsDoubleMetaphoneEqualExtended1() {\n+        //        String[][] testFixture = new String[][] { { \"Smith\", \"Schmidt\" }\n+        //        };\n+        //        doubleMetaphoneEqualTest(testFixture, false);\n+        //        doubleMetaphoneEqualTest(testFixture, true);\n+    }\n+\n+    @Test\n+    public void testIsDoubleMetaphoneEqualExtended2() {\n+        String[][] testFixture = new String[][] { { \"Jablonski\", \"Yablonsky\" }\n+        };\n+        //doubleMetaphoneEqualTest(testFixture, false);\n+        doubleMetaphoneEqualTest(testFixture, true);\n+    }\n+\n+    /**\n+     * Used to generate the MATCHES array and test possible matches from the\n+     * FIXTURE array.\n+     */\n+    @Test\n+    public void testIsDoubleMetaphoneEqualExtended3() {\n+        this.validateFixture(FIXTURE);\n+        StringBuffer failures = new StringBuffer();\n+        StringBuffer matches = new StringBuffer();\n+        String cr = System.getProperty(\"line.separator\");\n+        matches.append(\"private static final String[][] MATCHES = {\" + cr);\n+        int failCount = 0;\n+        for (int i = 0; i < FIXTURE.length; i++) {\n+            String name0 = FIXTURE[i][0];\n+            String name1 = FIXTURE[i][1];\n+            boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false);\n+            boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true);\n+            if (match1 == false && match2 == false) {\n+                String failMsg = \"[\" + i + \"] \" + name0 + \" and \" + name1 + cr;\n+                failures.append(failMsg);\n+                failCount++;\n+            } else {\n+                matches.append(\"{\\\"\" + name0 + \"\\\", \\\"\" + name1 + \"\\\"},\" + cr);\n+            }\n+        }\n+        String msg = failures.toString();\n+        matches.append(\"};\");\n+        // Turn on to print a new MATCH array\n+        //System.out.println(matches.toString());\n+        if (msg.length() > 0) {\n+            // Turn on to see which pairs do NOT match.\n+            //fail(failCount + \" failures out of \" + FIXTURE.length + \". The\n+            // following could be made to match: \" + cr + msg);\n+        }\n+    }\n+\n+    @Test\n+    public void testIsDoubleMetaphoneEqualWithMATCHES() {\n+        this.validateFixture(MATCHES);\n+        for (int i = 0; i < MATCHES.length; i++) {\n+            String name0 = MATCHES[i][0];\n+            String name1 = MATCHES[i][1];\n+            boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false);\n+            boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true);\n+            if (match1 == false && match2 == false) {\n+                fail(\"Expected match [\" + i + \"] \" + name0 + \" and \" + name1);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testIsDoubleMetaphoneNotEqual() {\n+        doubleMetaphoneNotEqualTest(false);\n+        doubleMetaphoneNotEqualTest(true);\n+    }\n+\n+    @Test\n+    public void testCCedilla() {\n+        assertTrue(this.getDoubleMetaphone().isDoubleMetaphoneEqual(\"\\u00e7\", \"S\")); // c-cedilla\n+    }\n+    \n+    @Test\n+    public void testNTilde() {\n+        assertTrue(this.getDoubleMetaphone().isDoubleMetaphoneEqual(\"\\u00f1\", \"N\")); // n-tilde\n+    }\n+    \n+    public void validateFixture(String[][] pairs) {\n+        if (pairs.length == 0) {\n+            fail(\"Test fixture is empty\");\n+        }\n+        for (int i = 0; i < pairs.length; i++) {\n+            if (pairs[i].length != 2) {\n+                fail(\"Error in test fixture in the data array at index \" + i);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/MetaphoneTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Test;\n+\n+/**\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MetaphoneTest extends StringEncoderAbstractTest {\n+\n+    public void assertIsMetaphoneEqual(String source, String[] matches) {\n+        // match source to all matches\n+        for (String matche : matches) {\n+            assertTrue(\"Source: \" + source + \", should have same Metaphone as: \" + matche,\n+                       this.getMetaphone().isMetaphoneEqual(source, matche));\n+        }\n+        // match to each other\n+        for (String matche : matches) {\n+            for (String matche2 : matches) {\n+                assertTrue(this.getMetaphone().isMetaphoneEqual(matche, matche2));\n+            }\n+        }\n+    }\n+\n+    public void assertMetaphoneEqual(String[][] pairs) {\n+        this.validateFixture(pairs);\n+        for (String[] pair : pairs) {\n+            String name0 = pair[0];\n+            String name1 = pair[1];\n+            String failMsg = \"Expected match between \" + name0 + \" and \" + name1;\n+            assertTrue(failMsg, this.getMetaphone().isMetaphoneEqual(name0, name1));\n+            assertTrue(failMsg, this.getMetaphone().isMetaphoneEqual(name1, name0));\n+        }\n+    }\n+    \n+    /**\n+     * @return Returns the metaphone.\n+     */\n+    private Metaphone getMetaphone() {\n+        return (Metaphone) this.getStringEncoder();\n+    }\n+\n+    @Override\n+    protected StringEncoder createStringEncoder() {\n+        return new Metaphone();\n+    }\n+\n+    @Test\n+    public void testIsMetaphoneEqual1() {\n+        this.assertMetaphoneEqual(new String[][] { { \"Case\", \"case\" }, {\n+                \"CASE\", \"Case\" }, {\n+                \"caSe\", \"cAsE\" }, {\n+                \"quick\", \"cookie\" }\n+        });\n+    }\n+\n+    /**\n+     * Matches computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqual2() {\n+        this.assertMetaphoneEqual(new String[][] { { \"Lawrence\", \"Lorenza\" }, {\n+                \"Gary\", \"Cahra\" }, });\n+    }\n+\n+    /**\n+     * Initial AE case.\n+     * \n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualAero() {\n+        this.assertIsMetaphoneEqual(\"Aero\", new String[] { \"Eure\" });\n+    }\n+\n+    /**\n+     * Initial WH case.\n+     * \n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualWhite() {\n+        this.assertIsMetaphoneEqual(\n+            \"White\",\n+            new String[] { \"Wade\", \"Wait\", \"Waite\", \"Wat\", \"Whit\", \"Wiatt\", \"Wit\", \"Wittie\", \"Witty\", \"Wood\", \"Woodie\", \"Woody\" });\n+    }\n+\n+    /**\n+     * Initial A, not followed by an E case.\n+     * \n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualAlbert() {\n+        this.assertIsMetaphoneEqual(\"Albert\", new String[] { \"Ailbert\", \"Alberik\", \"Albert\", \"Alberto\", \"Albrecht\" });\n+    }\n+\n+    /**\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualGary() {\n+        this.assertIsMetaphoneEqual(\n+            \"Gary\",\n+            new String[] {\n+                \"Cahra\",\n+                \"Cara\",\n+                \"Carey\",\n+                \"Cari\",\n+                \"Caria\",\n+                \"Carie\",\n+                \"Caro\",\n+                \"Carree\",\n+                \"Carri\",\n+                \"Carrie\",\n+                \"Carry\",\n+                \"Cary\",\n+                \"Cora\",\n+                \"Corey\",\n+                \"Cori\",\n+                \"Corie\",\n+                \"Correy\",\n+                \"Corri\",\n+                \"Corrie\",\n+                \"Corry\",\n+                \"Cory\",\n+                \"Gray\",\n+                \"Kara\",\n+                \"Kare\",\n+                \"Karee\",\n+                \"Kari\",\n+                \"Karia\",\n+                \"Karie\",\n+                \"Karrah\",\n+                \"Karrie\",\n+                \"Karry\",\n+                \"Kary\",\n+                \"Keri\",\n+                \"Kerri\",\n+                \"Kerrie\",\n+                \"Kerry\",\n+                \"Kira\",\n+                \"Kiri\",\n+                \"Kora\",\n+                \"Kore\",\n+                \"Kori\",\n+                \"Korie\",\n+                \"Korrie\",\n+                \"Korry\" });\n+    }\n+\n+    /**\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualJohn() {\n+        this.assertIsMetaphoneEqual(\n+            \"John\",\n+            new String[] {\n+                \"Gena\",\n+                \"Gene\",\n+                \"Genia\",\n+                \"Genna\",\n+                \"Genni\",\n+                \"Gennie\",\n+                \"Genny\",\n+                \"Giana\",\n+                \"Gianna\",\n+                \"Gina\",\n+                \"Ginni\",\n+                \"Ginnie\",\n+                \"Ginny\",\n+                \"Jaine\",\n+                \"Jan\",\n+                \"Jana\",\n+                \"Jane\",\n+                \"Janey\",\n+                \"Jania\",\n+                \"Janie\",\n+                \"Janna\",\n+                \"Jany\",\n+                \"Jayne\",\n+                \"Jean\",\n+                \"Jeana\",\n+                \"Jeane\",\n+                \"Jeanie\",\n+                \"Jeanna\",\n+                \"Jeanne\",\n+                \"Jeannie\",\n+                \"Jen\",\n+                \"Jena\",\n+                \"Jeni\",\n+                \"Jenn\",\n+                \"Jenna\",\n+                \"Jennee\",\n+                \"Jenni\",\n+                \"Jennie\",\n+                \"Jenny\",\n+                \"Jinny\",\n+                \"Jo Ann\",\n+                \"Jo-Ann\",\n+                \"Jo-Anne\",\n+                \"Joan\",\n+                \"Joana\",\n+                \"Joane\",\n+                \"Joanie\",\n+                \"Joann\",\n+                \"Joanna\",\n+                \"Joanne\",\n+                \"Joeann\",\n+                \"Johna\",\n+                \"Johnna\",\n+                \"Joni\",\n+                \"Jonie\",\n+                \"Juana\",\n+                \"June\",\n+                \"Junia\",\n+                \"Junie\" });\n+    }\n+\n+    /**\n+     * Initial KN case.\n+     * \n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualKnight() {\n+        this.assertIsMetaphoneEqual(\n+            \"Knight\",\n+            new String[] {\n+                \"Hynda\",\n+                \"Nada\",\n+                \"Nadia\",\n+                \"Nady\",\n+                \"Nat\",\n+                \"Nata\",\n+                \"Natty\",\n+                \"Neda\",\n+                \"Nedda\",\n+                \"Nedi\",\n+                \"Netta\",\n+                \"Netti\",\n+                \"Nettie\",\n+                \"Netty\",\n+                \"Nita\",\n+                \"Nydia\" });\n+    }\n+    /**\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualMary() {\n+        this.assertIsMetaphoneEqual(\n+            \"Mary\",\n+            new String[] {\n+                \"Mair\",\n+                \"Maire\",\n+                \"Mara\",\n+                \"Mareah\",\n+                \"Mari\",\n+                \"Maria\",\n+                \"Marie\",\n+                \"Mary\",\n+                \"Maura\",\n+                \"Maure\",\n+                \"Meara\",\n+                \"Merrie\",\n+                \"Merry\",\n+                \"Mira\",\n+                \"Moira\",\n+                \"Mora\",\n+                \"Moria\",\n+                \"Moyra\",\n+                \"Muire\",\n+                \"Myra\",\n+                \"Myrah\" });\n+    }\n+\n+    /**\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualParis() {\n+        this.assertIsMetaphoneEqual(\"Paris\", new String[] { \"Pearcy\", \"Perris\", \"Piercy\", \"Pierz\", \"Pryse\" });\n+    }\n+\n+    /**\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualPeter() {\n+        this.assertIsMetaphoneEqual(\n+            \"Peter\",\n+            new String[] { \"Peadar\", \"Peder\", \"Pedro\", \"Peter\", \"Petr\", \"Peyter\", \"Pieter\", \"Pietro\", \"Piotr\" });\n+    }\n+\n+    /**\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualRay() {\n+        this.assertIsMetaphoneEqual(\"Ray\", new String[] { \"Ray\", \"Rey\", \"Roi\", \"Roy\", \"Ruy\" });\n+    }\n+\n+    /**\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualSusan() {\n+        this.assertIsMetaphoneEqual(\n+            \"Susan\",\n+            new String[] {\n+                \"Siusan\",\n+                \"Sosanna\",\n+                \"Susan\",\n+                \"Susana\",\n+                \"Susann\",\n+                \"Susanna\",\n+                \"Susannah\",\n+                \"Susanne\",\n+                \"Suzann\",\n+                \"Suzanna\",\n+                \"Suzanne\",\n+                \"Zuzana\" });\n+    }\n+\n+    /**\n+     * Initial WR case.\n+     * \n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualWright() {\n+        this.assertIsMetaphoneEqual(\"Wright\", new String[] { \"Rota\", \"Rudd\", \"Ryde\" });\n+    }\n+\n+    /**\n+     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n+     */\n+    @Test\n+    public void testIsMetaphoneEqualXalan() {\n+        this.assertIsMetaphoneEqual(\n+            \"Xalan\",\n+            new String[] { \"Celene\", \"Celina\", \"Celine\", \"Selena\", \"Selene\", \"Selina\", \"Seline\", \"Suellen\", \"Xylina\" });\n+    }\n+\n+    @Test\n+    public void testMetaphone() {\n+        assertEquals(\"HL\", this.getMetaphone().metaphone(\"howl\"));\n+        assertEquals(\"TSTN\", this.getMetaphone().metaphone(\"testing\"));\n+        assertEquals(\"0\", this.getMetaphone().metaphone(\"The\"));\n+        assertEquals(\"KK\", this.getMetaphone().metaphone(\"quick\"));\n+        assertEquals(\"BRN\", this.getMetaphone().metaphone(\"brown\"));\n+        assertEquals(\"FKS\", this.getMetaphone().metaphone(\"fox\"));\n+        assertEquals(\"JMPT\", this.getMetaphone().metaphone(\"jumped\"));\n+        assertEquals(\"OFR\", this.getMetaphone().metaphone(\"over\"));\n+        assertEquals(\"0\", this.getMetaphone().metaphone(\"the\"));\n+        assertEquals(\"LS\", this.getMetaphone().metaphone(\"lazy\"));\n+        assertEquals(\"TKS\", this.getMetaphone().metaphone(\"dogs\"));\n+    }\n+    \n+    @Test\n+    public void testWordEndingInMB() {\n+        assertEquals( \"KM\", this.getMetaphone().metaphone(\"COMB\") );\n+        assertEquals( \"TM\", this.getMetaphone().metaphone(\"TOMB\") );\n+        assertEquals( \"WM\", this.getMetaphone().metaphone(\"WOMB\") );\n+    }\n+\n+    @Test\n+    public void testDiscardOfSCEOrSCIOrSCY() {\n+        assertEquals( \"SNS\", this.getMetaphone().metaphone(\"SCIENCE\") );\n+        assertEquals( \"SN\", this.getMetaphone().metaphone(\"SCENE\") );\n+        assertEquals( \"S\", this.getMetaphone().metaphone(\"SCY\") );\n+    }\n+\n+    /**\n+     * Tests (CODEC-57) Metaphone.metaphone(String) returns an empty string when passed the word \"why\"\n+     */\n+    @Test\n+    public void testWhy() {\n+        // PHP returns \"H\". The original metaphone returns an empty string. \n+        assertEquals(\"\", this.getMetaphone().metaphone(\"WHY\"));\n+    }\n+\n+    @Test\n+    public void testWordsWithCIA() {\n+        assertEquals( \"XP\", this.getMetaphone().metaphone(\"CIAPO\") );\n+    }\n+\n+    @Test\n+    public void testTranslateOfSCHAndCH() {\n+        assertEquals( \"SKTL\", this.getMetaphone().metaphone(\"SCHEDULE\") );\n+        assertEquals( \"SKMT\", this.getMetaphone().metaphone(\"SCHEMATIC\") );\n+\n+        assertEquals( \"KRKT\", this.getMetaphone().metaphone(\"CHARACTER\") );\n+        assertEquals( \"TX\", this.getMetaphone().metaphone(\"TEACH\") );\n+    }\n+\n+    @Test\n+    public void testTranslateToJOfDGEOrDGIOrDGY() {\n+        assertEquals( \"TJ\", this.getMetaphone().metaphone(\"DODGY\") );\n+        assertEquals( \"TJ\", this.getMetaphone().metaphone(\"DODGE\") );\n+        assertEquals( \"AJMT\", this.getMetaphone().metaphone(\"ADGIEMTI\") );\n+    }\n+\n+    @Test\n+    public void testDiscardOfSilentHAfterG() {\n+        assertEquals( \"KNT\", this.getMetaphone().metaphone(\"GHENT\") );\n+        assertEquals( \"B\", this.getMetaphone().metaphone(\"BAUGH\") );\n+    }\n+\n+    @Test\n+    public void testDiscardOfSilentGN() {\n+        // NOTE: This does not test for silent GN, but for starting with GN\n+        assertEquals( \"N\", this.getMetaphone().metaphone(\"GNU\") );\n+\n+        // NOTE: Trying to test for GNED, but expected code does not appear to execute\n+        assertEquals( \"SNT\", this.getMetaphone().metaphone(\"SIGNED\") );\n+    }\n+\n+    @Test\n+    public void testPHTOF() {\n+        assertEquals( \"FX\", this.getMetaphone().metaphone(\"PHISH\") );\n+    }\n+\n+    @Test\n+    public void testSHAndSIOAndSIAToX() {\n+        assertEquals( \"XT\", this.getMetaphone().metaphone(\"SHOT\") );\n+        assertEquals( \"OTXN\", this.getMetaphone().metaphone(\"ODSIAN\") );\n+        assertEquals( \"PLXN\", this.getMetaphone().metaphone(\"PULSION\") );\n+    }\n+\n+    @Test\n+    public void testTIOAndTIAToX() {\n+        assertEquals( \"OX\", this.getMetaphone().metaphone(\"OTIA\") );\n+        assertEquals( \"PRXN\", this.getMetaphone().metaphone(\"PORTION\") );\n+    }\n+\n+    @Test\n+    public void testTCH() {\n+        assertEquals( \"RX\", this.getMetaphone().metaphone(\"RETCH\") );\n+        assertEquals( \"WX\", this.getMetaphone().metaphone(\"WATCH\") );\n+    }\n+\n+    @Test\n+    public void testExceedLength() {\n+        // should be AKSKS, but istruncated by Max Code Length\n+        assertEquals( \"AKSK\", this.getMetaphone().metaphone(\"AXEAXE\") );\n+    }\n+\n+    @Test\n+    public void testSetMaxLengthWithTruncation() {\n+        // should be AKSKS, but istruncated by Max Code Length\n+        this.getMetaphone().setMaxCodeLen( 6 );\n+        assertEquals( \"AKSKSK\", this.getMetaphone().metaphone(\"AXEAXEAXE\") );\n+    }\n+\n+    public void validateFixture(String[][] pairs) {\n+        if (pairs.length == 0) {\n+            fail(\"Test fixture is empty\");\n+        }\n+        for (int i = 0; i < pairs.length; i++) {\n+            if (pairs[i].length != 2) {\n+                fail(\"Error in test fixture in the data array at index \" + i);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/RefinedSoundexTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Test;\n+\n+/**\n+ * Tests RefinedSoundex.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class RefinedSoundexTest extends StringEncoderAbstractTest {\n+\n+    @Override\n+    protected StringEncoder createStringEncoder() {\n+        return new RefinedSoundex();\n+    }\n+\n+    /**\n+     * @return Returns the encoder.\n+     */\n+    private RefinedSoundex getRefinedSoundex() {\n+        return (RefinedSoundex)this.getStringEncoder();\n+    }\n+\n+    @Test\n+    public void testDifference() throws EncoderException {\n+        // Edge cases\n+        assertEquals(0, this.getRefinedSoundex().difference(null, null));\n+        assertEquals(0, this.getRefinedSoundex().difference(\"\", \"\"));\n+        assertEquals(0, this.getRefinedSoundex().difference(\" \", \" \"));\n+        // Normal cases\n+        assertEquals(6, this.getRefinedSoundex().difference(\"Smith\", \"Smythe\"));\n+        assertEquals(3, this.getRefinedSoundex().difference(\"Ann\", \"Andrew\"));\n+        assertEquals(1, this.getRefinedSoundex().difference(\"Margaret\", \"Andrew\"));\n+        assertEquals(1, this.getRefinedSoundex().difference(\"Janet\", \"Margaret\"));\n+        // Examples from\n+        // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\n+        assertEquals(5, this.getRefinedSoundex().difference(\"Green\", \"Greene\"));\n+        assertEquals(1, this.getRefinedSoundex().difference(\"Blotchet-Halls\", \"Greene\"));\n+        // Examples from\n+        // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp\n+        assertEquals(6, this.getRefinedSoundex().difference(\"Smith\", \"Smythe\"));\n+        assertEquals(8, this.getRefinedSoundex().difference(\"Smithers\", \"Smythers\"));\n+        assertEquals(5, this.getRefinedSoundex().difference(\"Anothers\", \"Brothers\"));\n+    }\n+\n+    @Test\n+    public void testEncode() {\n+        assertEquals(\"T6036084\", this.getRefinedSoundex().encode(\"testing\"));\n+        assertEquals(\"T6036084\", this.getRefinedSoundex().encode(\"TESTING\"));\n+        assertEquals(\"T60\", this.getRefinedSoundex().encode(\"The\"));\n+        assertEquals(\"Q503\", this.getRefinedSoundex().encode(\"quick\"));\n+        assertEquals(\"B1908\", this.getRefinedSoundex().encode(\"brown\"));\n+        assertEquals(\"F205\", this.getRefinedSoundex().encode(\"fox\"));\n+        assertEquals(\"J408106\", this.getRefinedSoundex().encode(\"jumped\"));\n+        assertEquals(\"O0209\", this.getRefinedSoundex().encode(\"over\"));\n+        assertEquals(\"T60\", this.getRefinedSoundex().encode(\"the\"));\n+        assertEquals(\"L7050\", this.getRefinedSoundex().encode(\"lazy\"));\n+        assertEquals(\"D6043\", this.getRefinedSoundex().encode(\"dogs\"));\n+\n+        // Testing CODEC-56\n+        assertEquals(\"D6043\", RefinedSoundex.US_ENGLISH.encode(\"dogs\"));\n+    }\n+\n+    @Test\n+    public void testGetMappingCodeNonLetter() {\n+        char code = this.getRefinedSoundex().getMappingCode('#');\n+        assertEquals(\"Code does not equals zero\", 0, code);\n+    }\n+    \n+    @Test\n+    public void testNewInstance() {\n+        assertEquals(\"D6043\", new RefinedSoundex().soundex(\"dogs\"));\n+    }\n+    \n+    @Test\n+    public void testNewInstance2() {\n+        assertEquals(\"D6043\", new RefinedSoundex(RefinedSoundex.US_ENGLISH_MAPPING_STRING.toCharArray()).soundex(\"dogs\"));\n+    }\n+    \n+    @Test\n+    public void testNewInstance3() {\n+        assertEquals(\"D6043\", new RefinedSoundex(RefinedSoundex.US_ENGLISH_MAPPING_STRING).soundex(\"dogs\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/SoundexTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// (FYI: Formatted and sorted with Eclipse)\n+\n+package org.apache.commons.codec.language;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Test;\n+\n+/**\n+ * Tests {@link Soundex}.\n+ * \n+ * <p>Keep this file in UTF-8 encoding for proper Javadoc processing.</p>\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class SoundexTest extends StringEncoderAbstractTest {\n+\n+    @Override\n+    protected StringEncoder createStringEncoder() {\n+        return new Soundex();\n+    }\n+\n+    /**\n+     * @return Returns the encoder.\n+     */\n+    public Soundex getSoundexEncoder() {\n+        return (Soundex)this.getStringEncoder();\n+    }\n+\n+    @Test\n+    public void testB650() throws EncoderException {\n+        this.checkEncodingVariations(\"B650\", (new String[]{\n+            \"BARHAM\",\n+            \"BARONE\",\n+            \"BARRON\",\n+            \"BERNA\",\n+            \"BIRNEY\",\n+            \"BIRNIE\",\n+            \"BOOROM\",\n+            \"BOREN\",\n+            \"BORN\",\n+            \"BOURN\",\n+            \"BOURNE\",\n+            \"BOWRON\",\n+            \"BRAIN\",\n+            \"BRAME\",\n+            \"BRANN\",\n+            \"BRAUN\",\n+            \"BREEN\",\n+            \"BRIEN\",\n+            \"BRIM\",\n+            \"BRIMM\",\n+            \"BRINN\",\n+            \"BRION\",\n+            \"BROOM\",\n+            \"BROOME\",\n+            \"BROWN\",\n+            \"BROWNE\",\n+            \"BRUEN\",\n+            \"BRUHN\",\n+            \"BRUIN\",\n+            \"BRUMM\",\n+            \"BRUN\",\n+            \"BRUNO\",\n+            \"BRYAN\",\n+            \"BURIAN\",\n+            \"BURN\",\n+            \"BURNEY\",\n+            \"BYRAM\",\n+            \"BYRNE\",\n+            \"BYRON\",\n+            \"BYRUM\"}));\n+    }\n+\n+    @Test\n+    public void testBadCharacters() {\n+        Assert.assertEquals(\"H452\", this.getSoundexEncoder().encode(\"HOL>MES\"));\n+\n+    }\n+\n+    @Test\n+    public void testDifference() throws EncoderException {\n+        // Edge cases\n+        Assert.assertEquals(0, this.getSoundexEncoder().difference(null, null));\n+        Assert.assertEquals(0, this.getSoundexEncoder().difference(\"\", \"\"));\n+        Assert.assertEquals(0, this.getSoundexEncoder().difference(\" \", \" \"));\n+        // Normal cases\n+        Assert.assertEquals(4, this.getSoundexEncoder().difference(\"Smith\", \"Smythe\"));\n+        Assert.assertEquals(2, this.getSoundexEncoder().difference(\"Ann\", \"Andrew\"));\n+        Assert.assertEquals(1, this.getSoundexEncoder().difference(\"Margaret\", \"Andrew\"));\n+        Assert.assertEquals(0, this.getSoundexEncoder().difference(\"Janet\", \"Margaret\"));\n+        // Examples from http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\n+        Assert.assertEquals(4, this.getSoundexEncoder().difference(\"Green\", \"Greene\"));\n+        Assert.assertEquals(0, this.getSoundexEncoder().difference(\"Blotchet-Halls\", \"Greene\"));\n+        // Examples from http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp\n+        Assert.assertEquals(4, this.getSoundexEncoder().difference(\"Smith\", \"Smythe\"));\n+        Assert.assertEquals(4, this.getSoundexEncoder().difference(\"Smithers\", \"Smythers\"));\n+        Assert.assertEquals(2, this.getSoundexEncoder().difference(\"Anothers\", \"Brothers\"));\n+    }\n+\n+    @Test\n+    public void testEncodeBasic() {\n+        Assert.assertEquals(\"T235\", this.getSoundexEncoder().encode(\"testing\"));\n+        Assert.assertEquals(\"T000\", this.getSoundexEncoder().encode(\"The\"));\n+        Assert.assertEquals(\"Q200\", this.getSoundexEncoder().encode(\"quick\"));\n+        Assert.assertEquals(\"B650\", this.getSoundexEncoder().encode(\"brown\"));\n+        Assert.assertEquals(\"F200\", this.getSoundexEncoder().encode(\"fox\"));\n+        Assert.assertEquals(\"J513\", this.getSoundexEncoder().encode(\"jumped\"));\n+        Assert.assertEquals(\"O160\", this.getSoundexEncoder().encode(\"over\"));\n+        Assert.assertEquals(\"T000\", this.getSoundexEncoder().encode(\"the\"));\n+        Assert.assertEquals(\"L200\", this.getSoundexEncoder().encode(\"lazy\"));\n+        Assert.assertEquals(\"D200\", this.getSoundexEncoder().encode(\"dogs\"));\n+    }\n+\n+    /**\n+     * Examples from http://www.bradandkathy.com/genealogy/overviewofsoundex.html\n+     */\n+    @Test\n+    public void testEncodeBatch2() {\n+        Assert.assertEquals(\"A462\", this.getSoundexEncoder().encode(\"Allricht\"));\n+        Assert.assertEquals(\"E166\", this.getSoundexEncoder().encode(\"Eberhard\"));\n+        Assert.assertEquals(\"E521\", this.getSoundexEncoder().encode(\"Engebrethson\"));\n+        Assert.assertEquals(\"H512\", this.getSoundexEncoder().encode(\"Heimbach\"));\n+        Assert.assertEquals(\"H524\", this.getSoundexEncoder().encode(\"Hanselmann\"));\n+        Assert.assertEquals(\"H431\", this.getSoundexEncoder().encode(\"Hildebrand\"));\n+        Assert.assertEquals(\"K152\", this.getSoundexEncoder().encode(\"Kavanagh\"));\n+        Assert.assertEquals(\"L530\", this.getSoundexEncoder().encode(\"Lind\"));\n+        Assert.assertEquals(\"L222\", this.getSoundexEncoder().encode(\"Lukaschowsky\"));\n+        Assert.assertEquals(\"M235\", this.getSoundexEncoder().encode(\"McDonnell\"));\n+        Assert.assertEquals(\"M200\", this.getSoundexEncoder().encode(\"McGee\"));\n+        Assert.assertEquals(\"O155\", this.getSoundexEncoder().encode(\"Opnian\"));\n+        Assert.assertEquals(\"O155\", this.getSoundexEncoder().encode(\"Oppenheimer\"));\n+        Assert.assertEquals(\"R355\", this.getSoundexEncoder().encode(\"Riedemanas\"));\n+        Assert.assertEquals(\"Z300\", this.getSoundexEncoder().encode(\"Zita\"));\n+        Assert.assertEquals(\"Z325\", this.getSoundexEncoder().encode(\"Zitzmeinn\"));\n+    }\n+\n+    /**\n+     * Examples from http://www.archives.gov/research_room/genealogy/census/soundex.html\n+     */\n+    @Test\n+    public void testEncodeBatch3() {\n+        Assert.assertEquals(\"W252\", this.getSoundexEncoder().encode(\"Washington\"));\n+        Assert.assertEquals(\"L000\", this.getSoundexEncoder().encode(\"Lee\"));\n+        Assert.assertEquals(\"G362\", this.getSoundexEncoder().encode(\"Gutierrez\"));\n+        Assert.assertEquals(\"P236\", this.getSoundexEncoder().encode(\"Pfister\"));\n+        Assert.assertEquals(\"J250\", this.getSoundexEncoder().encode(\"Jackson\"));\n+        Assert.assertEquals(\"T522\", this.getSoundexEncoder().encode(\"Tymczak\"));\n+        // For VanDeusen: D-250 (D, 2 for the S, 5 for the N, 0 added) is also\n+        // possible.\n+        Assert.assertEquals(\"V532\", this.getSoundexEncoder().encode(\"VanDeusen\"));\n+    }\n+\n+    /**\n+     * Examples from: http://www.myatt.demon.co.uk/sxalg.htm\n+     */\n+    @Test\n+    public void testEncodeBatch4() {\n+        Assert.assertEquals(\"H452\", this.getSoundexEncoder().encode(\"HOLMES\"));\n+        Assert.assertEquals(\"A355\", this.getSoundexEncoder().encode(\"ADOMOMI\"));\n+        Assert.assertEquals(\"V536\", this.getSoundexEncoder().encode(\"VONDERLEHR\"));\n+        Assert.assertEquals(\"B400\", this.getSoundexEncoder().encode(\"BALL\"));\n+        Assert.assertEquals(\"S000\", this.getSoundexEncoder().encode(\"SHAW\"));\n+        Assert.assertEquals(\"J250\", this.getSoundexEncoder().encode(\"JACKSON\"));\n+        Assert.assertEquals(\"S545\", this.getSoundexEncoder().encode(\"SCANLON\"));\n+        Assert.assertEquals(\"S532\", this.getSoundexEncoder().encode(\"SAINTJOHN\"));\n+\n+    }\n+\n+    @Test\n+    public void testEncodeIgnoreApostrophes() throws EncoderException {\n+        this.checkEncodingVariations(\"O165\", (new String[]{\n+            \"OBrien\",\n+            \"'OBrien\",\n+            \"O'Brien\",\n+            \"OB'rien\",\n+            \"OBr'ien\",\n+            \"OBri'en\",\n+            \"OBrie'n\",\n+            \"OBrien'\"}));\n+    }\n+\n+    /**\n+     * Test data from http://www.myatt.demon.co.uk/sxalg.htm\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testEncodeIgnoreHyphens() throws EncoderException {\n+        this.checkEncodingVariations(\"K525\", (new String[]{\n+            \"KINGSMITH\",\n+            \"-KINGSMITH\",\n+            \"K-INGSMITH\",\n+            \"KI-NGSMITH\",\n+            \"KIN-GSMITH\",\n+            \"KING-SMITH\",\n+            \"KINGS-MITH\",\n+            \"KINGSM-ITH\",\n+            \"KINGSMI-TH\",\n+            \"KINGSMIT-H\",\n+            \"KINGSMITH-\"}));\n+    }\n+\n+    @Test\n+    public void testEncodeIgnoreTrimmable() {\n+        Assert.assertEquals(\"W252\", this.getSoundexEncoder().encode(\" \\t\\n\\r Washington \\t\\n\\r \"));\n+    }\n+\n+    /**\n+     * Consonants from the same code group separated by W or H are treated as one.\n+     */\n+    @Test\n+    public void testHWRuleEx1() {\n+        // From\n+        // http://www.archives.gov/research_room/genealogy/census/soundex.html:\n+        // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1\n+        // for the F). It is not coded A-226.\n+        Assert.assertEquals(\"A261\", this.getSoundexEncoder().encode(\"Ashcraft\"));\n+    }\n+\n+    /**\n+     * Consonants from the same code group separated by W or H are treated as one.\n+     * \n+     * Test data from http://www.myatt.demon.co.uk/sxalg.htm\n+     */\n+    @Test\n+    public void testHWRuleEx2() {\n+        Assert.assertEquals(\"B312\", this.getSoundexEncoder().encode(\"BOOTHDAVIS\"));\n+        Assert.assertEquals(\"B312\", this.getSoundexEncoder().encode(\"BOOTH-DAVIS\"));\n+    }\n+\n+    /**\n+     * Consonants from the same code group separated by W or H are treated as one.\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testHWRuleEx3() throws EncoderException {\n+        Assert.assertEquals(\"S460\", this.getSoundexEncoder().encode(\"Sgler\"));\n+        Assert.assertEquals(\"S460\", this.getSoundexEncoder().encode(\"Swhgler\"));\n+        // Also S460:\n+        this.checkEncodingVariations(\"S460\", (new String[]{\n+            \"SAILOR\",\n+            \"SALYER\",\n+            \"SAYLOR\",\n+            \"SCHALLER\",\n+            \"SCHELLER\",\n+            \"SCHILLER\",\n+            \"SCHOOLER\",\n+            \"SCHULER\",\n+            \"SCHUYLER\",\n+            \"SEILER\",\n+            \"SEYLER\",\n+            \"SHOLAR\",\n+            \"SHULER\",\n+            \"SILAR\",\n+            \"SILER\",\n+            \"SILLER\"}));\n+    }\n+\n+    /**\n+     * Examples for MS SQLServer from\n+     * http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp\n+     */\n+    @Test\n+    public void testMsSqlServer1() {\n+        Assert.assertEquals(\"S530\", this.getSoundexEncoder().encode(\"Smith\"));\n+        Assert.assertEquals(\"S530\", this.getSoundexEncoder().encode(\"Smythe\"));\n+    }\n+\n+    /**\n+     * Examples for MS SQLServer from\n+     * http://support.microsoft.com/default.aspx?scid=http://support.microsoft.com:80/support\n+     * /kb/articles/Q100/3/65.asp&NoWebContent=1\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testMsSqlServer2() throws EncoderException {\n+        this.checkEncodingVariations(\"E625\", (new String[]{\"Erickson\", \"Erickson\", \"Erikson\", \"Ericson\", \"Ericksen\", \"Ericsen\"}));\n+    }\n+\n+    /**\n+     * Examples for MS SQLServer from http://databases.about.com/library/weekly/aa042901a.htm\n+     */\n+    @Test\n+    public void testMsSqlServer3() {\n+        Assert.assertEquals(\"A500\", this.getSoundexEncoder().encode(\"Ann\"));\n+        Assert.assertEquals(\"A536\", this.getSoundexEncoder().encode(\"Andrew\"));\n+        Assert.assertEquals(\"J530\", this.getSoundexEncoder().encode(\"Janet\"));\n+        Assert.assertEquals(\"M626\", this.getSoundexEncoder().encode(\"Margaret\"));\n+        Assert.assertEquals(\"S315\", this.getSoundexEncoder().encode(\"Steven\"));\n+        Assert.assertEquals(\"M240\", this.getSoundexEncoder().encode(\"Michael\"));\n+        Assert.assertEquals(\"R163\", this.getSoundexEncoder().encode(\"Robert\"));\n+        Assert.assertEquals(\"L600\", this.getSoundexEncoder().encode(\"Laura\"));\n+        Assert.assertEquals(\"A500\", this.getSoundexEncoder().encode(\"Anne\"));\n+    }\n+\n+    /**\n+     * https://issues.apache.org/jira/browse/CODEC-54 https://issues.apache.org/jira/browse/CODEC-56\n+     */\n+    @Test\n+    public void testNewInstance() {\n+        Assert.assertEquals(\"W452\", new Soundex().soundex(\"Williams\"));\n+    }\n+\n+    @Test\n+    public void testNewInstance2() {\n+        Assert.assertEquals(\"W452\", new Soundex(Soundex.US_ENGLISH_MAPPING_STRING.toCharArray()).soundex(\"Williams\"));\n+    }\n+\n+    @Test\n+    public void testNewInstance3() {\n+        Assert.assertEquals(\"W452\", new Soundex(Soundex.US_ENGLISH_MAPPING_STRING).soundex(\"Williams\"));\n+    }\n+\n+    @Test\n+    public void testSoundexUtilsConstructable() {\n+        new SoundexUtils();\n+    }\n+\n+    @Test\n+    public void testSoundexUtilsNullBehaviour() {\n+        Assert.assertEquals(null, SoundexUtils.clean(null));\n+        Assert.assertEquals(\"\", SoundexUtils.clean(\"\"));\n+        Assert.assertEquals(0, SoundexUtils.differenceEncoded(null, \"\"));\n+        Assert.assertEquals(0, SoundexUtils.differenceEncoded(\"\", null));\n+    }\n+\n+    /**\n+     * https://issues.apache.org/jira/browse/CODEC-54 https://issues.apache.org/jira/browse/CODEC-56\n+     */\n+    @Test\n+    public void testUsEnglishStatic() {\n+        Assert.assertEquals(\"W452\", Soundex.US_ENGLISH.soundex(\"Williams\"));\n+    }\n+\n+    /**\n+     * Fancy characters are not mapped by the default US mapping.\n+     * \n+     * http://issues.apache.org/bugzilla/show_bug.cgi?id=29080\n+     */\n+    @Test\n+    public void testUsMappingEWithAcute() {\n+        Assert.assertEquals(\"E000\", this.getSoundexEncoder().encode(\"e\"));\n+        if (Character.isLetter('\\u00e9')) { // e-acute\n+            try {\n+                //         uppercase E-acute\n+                Assert.assertEquals(\"\\u00c9000\", this.getSoundexEncoder().encode(\"\\u00e9\"));\n+                Assert.fail(\"Expected IllegalArgumentException not thrown\");\n+            } catch (IllegalArgumentException e) {\n+                // expected\n+            }\n+        } else {\n+            Assert.assertEquals(\"\", this.getSoundexEncoder().encode(\"\\u00e9\"));\n+        }\n+    }\n+\n+    /**\n+     * Fancy characters are not mapped by the default US mapping.\n+     * \n+     * http://issues.apache.org/bugzilla/show_bug.cgi?id=29080\n+     */\n+    @Test\n+    public void testUsMappingOWithDiaeresis() {\n+        Assert.assertEquals(\"O000\", this.getSoundexEncoder().encode(\"o\"));\n+        if (Character.isLetter('\\u00f6')) { // o-umlaut\n+            try {\n+                //         uppercase O-umlaut\n+                Assert.assertEquals(\"\\u00d6000\", this.getSoundexEncoder().encode(\"\\u00f6\"));\n+                Assert.fail(\"Expected IllegalArgumentException not thrown\");\n+            } catch (IllegalArgumentException e) {\n+                // expected\n+            }\n+        } else {\n+            Assert.assertEquals(\"\", this.getSoundexEncoder().encode(\"\\u00f6\"));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Tests BeiderMorseEncoder.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+public class BeiderMorseEncoderTest extends StringEncoderAbstractTest {\n+    private static final char[] TEST_CHARS = new char[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'o', 'u' };\n+\n+    private void assertNotEmpty(BeiderMorseEncoder bmpm, final String value) throws EncoderException {\n+        Assert.assertFalse(value, bmpm.encode(value).equals(\"\"));\n+    }\n+\n+    private BeiderMorseEncoder createGenericApproxEncoder() {\n+        BeiderMorseEncoder encoder = new BeiderMorseEncoder();\n+        encoder.setNameType(NameType.GENERIC);\n+        encoder.setRuleType(RuleType.APPROX);\n+        return encoder;\n+    }\n+\n+    @Override\n+    protected StringEncoder createStringEncoder() {\n+        return new BeiderMorseEncoder();\n+    }\n+\n+    /**\n+     * Tests we do not blow up.\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testAllChars() throws EncoderException {\n+        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        for (char c = Character.MIN_VALUE; c < Character.MAX_VALUE; c++) {\n+            bmpm.encode(\"\" + c);\n+        }\n+    }\n+\n+    @Test\n+    public void testAsciiEncodeNotEmpty1Letter() throws EncoderException {\n+        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        for (char c = 'a'; c <= 'z'; c++) {\n+            final String value = \"\" + c;\n+            final String valueU = value.toUpperCase();\n+            assertNotEmpty(bmpm, value);\n+            assertNotEmpty(bmpm, valueU);\n+        }\n+    }\n+\n+    @Test\n+    public void testAsciiEncodeNotEmpty2Letters() throws EncoderException {\n+        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        for (char c1 = 'a'; c1 <= 'z'; c1++) {\n+            for (char c2 = 'a'; c2 <= 'z'; c2++) {\n+                final String value = new String(new char[] { c1, c2 });\n+                final String valueU = value.toUpperCase();\n+                assertNotEmpty(bmpm, value);\n+                assertNotEmpty(bmpm, valueU);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEncodeAtzNotEmpty() throws EncoderException {\n+        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        //String[] names = { \"\u00e1cz\", \"\u00e1tz\", \"Ign\u00e1cz\", \"Ign\u00e1tz\", \"Ign\u00e1c\" };\n+        String[] names = { \"\\u00e1cz\", \"\\u00e1tz\", \"Ign\\u00e1cz\", \"Ign\\u00e1tz\", \"Ign\\u00e1c\" };\n+        for (String name : names) {\n+            assertNotEmpty(bmpm, name);\n+        }\n+    }\n+\n+    /**\n+     * Tests https://issues.apache.org/jira/browse/CODEC-125?focusedCommentId=13071566&page=com.atlassian.jira.plugin.system.issuetabpanels:\n+     * comment-tabpanel#comment-13071566\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test\n+    public void testEncodeGna() throws EncoderException {\n+        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        bmpm.encode(\"gna\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testInvalidLangIllegalArgumentException() {\n+        Rule.getInstance(NameType.GENERIC, RuleType.APPROX, \"noSuchLanguage\");\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidLangIllegalStateException() {\n+        Lang.loadFromResource(\"thisIsAMadeUpResourceName\", Languages.getInstance(NameType.GENERIC));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testInvalidLanguageIllegalArgumentException() {\n+        Languages.getInstance(\"thereIsNoSuchLanguage\");\n+    }\n+\n+    @Test(timeout = 10000L)\n+    public void testLongestEnglishSurname() throws EncoderException {\n+        BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n+        bmpm.encode(\"MacGhilleseatheanaich\");\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void testNegativeIndexForRuleMatchIndexOutOfBoundsException() {\n+        Rule r = new Rule(\"a\", \"\", \"\", new Rule.Phoneme(\"\", Languages.ANY_LANGUAGE));\n+        r.patternAndContextMatches(\"bob\", -1);\n+    }\n+\n+    @Test\n+    public void testSetConcat() {\n+        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        bmpm.setConcat(false);\n+        assertFalse(\"Should be able to set concat to false\", bmpm.isConcat());\n+    }\n+\n+    @Test\n+    public void testSetNameTypeAsh() {\n+        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        bmpm.setNameType(NameType.ASHKENAZI);\n+        assertEquals(\"Name type should have been set to ash\", NameType.ASHKENAZI, bmpm.getNameType());\n+    }\n+\n+    @Test\n+    public void testSetRuleTypeExact() {\n+        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        bmpm.setRuleType(RuleType.EXACT);\n+        assertEquals(\"Rule type should have been set to exact\", RuleType.EXACT, bmpm.getRuleType());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testSetRuleTypeToRulesIllegalArgumentException() {\n+        BeiderMorseEncoder bmpm = new BeiderMorseEncoder();\n+        bmpm.setRuleType(RuleType.RULES);\n+    }\n+\n+    /**\n+     * (Un)luckily, the worse performing test because of the data in {@link #TEST_CHARS}\n+     * \n+     * @throws EncoderException\n+     */\n+    @Test(/* timeout = 20000L */)\n+    public void testSpeedCheck() throws EncoderException {\n+        BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n+        StringBuffer stringBuffer = new StringBuffer();\n+        stringBuffer.append(TEST_CHARS[0]);\n+        for (int i = 0, j = 1; i < 40; i++, j++) {\n+            if (j == TEST_CHARS.length) {\n+                j = 0;\n+            }\n+            bmpm.encode(stringBuffer.toString());\n+            stringBuffer.append(TEST_CHARS[j]);\n+        }\n+    }\n+\n+    @Test\n+    public void testSpeedCheck2() throws EncoderException {\n+        BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n+        String phrase = \"ItstheendoftheworldasweknowitandIfeelfine\";\n+\n+        for (int i = 1; i <= phrase.length(); i++) {\n+            bmpm.encode(phrase.subSequence(0, i));\n+        }\n+    }\n+\n+    @Test\n+    public void testSpeedCheck3() throws EncoderException {\n+        BeiderMorseEncoder bmpm = this.createGenericApproxEncoder();\n+        String phrase = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\";\n+\n+        for (int i = 1; i <= phrase.length(); i++) {\n+            bmpm.encode(phrase.subSequence(0, i));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/bm/LanguageGuessingTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests guessLanguages API.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+@RunWith(Parameterized.class)\n+public class LanguageGuessingTest {\n+\n+    private static String EXACT = \"exact\";\n+    private static String ONE_OF = \"one of\";\n+\n+    @Parameterized.Parameters\n+    public static List<Object[]> data() {\n+        return Arrays.asList(new Object[][] {\n+                { \"Renault\", \"french\", EXACT },\n+                { \"Mickiewicz\", \"polish\", EXACT },\n+                { \"Thompson\", \"english\", ONE_OF }, // this also hits german and greeklatin\n+                { \"Nu\\u00f1ez\", \"spanish\", EXACT }, // Nu\u00f1ez\n+                { \"Carvalho\", \"portuguese\", EXACT },\n+                { \"\\u010capek\", \"czech\", EXACT }, // \u010capek\n+                { \"Sjneijder\", \"dutch\", EXACT },\n+                { \"Klausewitz\", \"german\", EXACT },\n+                { \"K\\u00fc\\u00e7\\u00fck\", \"turkish\", EXACT }, // K\u00fc\u00e7\u00fck\n+                { \"Giacometti\", \"italian\", EXACT },\n+                { \"Nagy\", \"hungarian\", EXACT },\n+                { \"Ceau\\u015fescu\", \"romanian\", EXACT }, // Ceau\u015fescu\n+                { \"Angelopoulos\", \"greeklatin\", EXACT },\n+                { \"\\u0391\\u03b3\\u03b3\\u03b5\\u03bb\\u03cc\\u03c0\\u03bf\\u03c5\\u03bb\\u03bf\\u03c2\", \"greek\", EXACT }, // \u0391\u03b3\u03b3\u03b5\u03bb\u03cc\u03c0\u03bf\u03c5\u03bb\u03bf\u03c2\n+                { \"\\u041f\\u0443\\u0448\\u043a\\u0438\\u043d\", \"cyrillic\", EXACT }, // \u041f\u0443\u0448\u043a\u0438\u043d\n+                { \"\\u05db\\u05d4\\u05df\", \"hebrew\", EXACT }, // \u05db\u05d4\u05df\n+                { \"\\u00e1cz\", \"any\", EXACT }, // \u00e1cz\n+                { \"\\u00e1tz\", \"any\", EXACT } }); // \u00e1tz\n+    }\n+\n+    private final String exactness;\n+\n+    private final Lang lang = Lang.instance(NameType.GENERIC);\n+    private final String language;\n+    private final String name;\n+\n+    public LanguageGuessingTest(String name, String language, String exactness) {\n+        this.name = name;\n+        this.language = language;\n+        this.exactness = exactness;\n+    }\n+\n+    @Test\n+    public void testLanguageGuessing() {\n+        Languages.LanguageSet guesses = this.lang.guessLanguages(this.name);\n+\n+        assertTrue(\"language predicted for name '\" + this.name + \"' is wrong: \" + guesses + \" should contain '\" + this.language + \"'\",\n+                guesses.contains(this.language));\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/bm/PhoneticEngineTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests PhoneticEngine.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+@RunWith(Parameterized.class)\n+public class PhoneticEngineTest {\n+\n+    @Parameterized.Parameters\n+    public static List<Object[]> data() {\n+        return Arrays\n+                .asList(new Object[] {\n+                        \"Renault\",\n+                        \"rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult\",\n+                        NameType.GENERIC,\n+                        RuleType.APPROX,\n+                        true },\n+                        new Object[] { \"Renault\", \"rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult\", NameType.ASHKENAZI, RuleType.APPROX, true },\n+                        new Object[] { \"Renault\", \"rinDlt\", NameType.SEPHARDIC, RuleType.APPROX, true },\n+                        new Object[] { \"SntJohn-Smith\", \"sntjonsmit\", NameType.GENERIC, RuleType.EXACT, true },\n+                        new Object[] { \"d'ortley\", \"(ortlaj|ortlej)-(dortlaj|dortlej)\", NameType.GENERIC, RuleType.EXACT, true },\n+                        new Object[] {\n+                                \"van helsing\",\n+                                \"(elSink|elsink|helSink|helsink|helzink|xelsink)-(banhelsink|fanhelsink|fanhelzink|vanhelsink|vanhelzink|vanjelsink)\",\n+                                NameType.GENERIC,\n+                                RuleType.EXACT,\n+                                false });\n+    }\n+\n+    private final boolean concat;\n+    private final String name;\n+    private final NameType nameType;\n+    private final String phoneticExpected;\n+    private final RuleType ruleType;\n+\n+    public PhoneticEngineTest(String name, String phoneticExpected, NameType nameType, RuleType ruleType, boolean concat) {\n+        this.name = name;\n+        this.phoneticExpected = phoneticExpected;\n+        this.nameType = nameType;\n+        this.ruleType = ruleType;\n+        this.concat = concat;\n+    }\n+\n+    @Test(timeout = 10000L)\n+    public void testEncode() {\n+        PhoneticEngine engine = new PhoneticEngine(this.nameType, this.ruleType, this.concat);\n+\n+        String phoneticActual = engine.encode(this.name);\n+\n+        System.err.println(\"expecting: \" + this.phoneticExpected);\n+        System.err.println(\"actual:    \" + phoneticActual);\n+        assertEquals(\"phoneme incorrect\", this.phoneticExpected, phoneticActual);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/bm/RuleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language.bm;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.junit.Test;\n+\n+/**\n+ * Tests Rule.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.6\n+ */\n+public class RuleTest {\n+    private static class NegativeIntegerBaseMatcher extends BaseMatcher<Integer> {\n+        public void describeTo(Description description) {\n+            description.appendText(\"value should be negative\");\n+        }\n+\n+        public boolean matches(Object item) {\n+            return ((Integer) item) < 0;\n+        }\n+    }\n+\n+    private Rule.Phoneme[][] makePhonemes() {\n+        String[][] words = {\n+                { \"rinD\", \"rinDlt\", \"rina\", \"rinalt\", \"rino\", \"rinolt\", \"rinu\", \"rinult\" },\n+                { \"dortlaj\", \"dortlej\", \"ortlaj\", \"ortlej\", \"ortlej-dortlaj\" } };\n+        Rule.Phoneme[][] phonemes = new Rule.Phoneme[words.length][];\n+\n+        for (int i = 0; i < words.length; i++) {\n+            String[] words_i = words[i];\n+            Rule.Phoneme[] phonemes_i = phonemes[i] = new Rule.Phoneme[words_i.length];\n+            for (int j = 0; j < words_i.length; j++) {\n+                phonemes_i[j] = new Rule.Phoneme(words_i[j], Languages.NO_LANGUAGES);\n+            }\n+        }\n+\n+        return phonemes;\n+    }\n+\n+    @Test\n+    public void testPhonemeComparedToLaterIsNegative() {\n+        for (Rule.Phoneme[] phs : makePhonemes()) {\n+            for (int i = 0; i < phs.length; i++) {\n+                for (int j = i + 1; j < phs.length; j++) {\n+                    int c = Rule.Phoneme.COMPARATOR.compare(phs[i], phs[j]);\n+\n+                    assertThat(\"Comparing \" + phs[i].getPhonemeText() + \" to \" + phs[j].getPhonemeText() + \" should be negative\", c,\n+                            new NegativeIntegerBaseMatcher());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testPhonemeComparedToSelfIsZero() {\n+        for (Rule.Phoneme[] phs : makePhonemes()) {\n+            for (Rule.Phoneme ph : phs) {\n+                assertEquals(\"Phoneme compared to itself should be zero: \" + ph.getPhonemeText(), 0,\n+                        Rule.Phoneme.COMPARATOR.compare(ph, ph));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testSubSequenceWorks() {\n+        // AppendableCharSequence is private to Rule. We can only make it through a Phoneme.\n+\n+        Rule.Phoneme a = new Rule.Phoneme(\"a\", null);\n+        Rule.Phoneme b = new Rule.Phoneme(\"b\", null);\n+        Rule.Phoneme cd = new Rule.Phoneme(\"cd\", null);\n+        Rule.Phoneme ef = new Rule.Phoneme(\"ef\", null);\n+        Rule.Phoneme ghi = new Rule.Phoneme(\"ghi\", null);\n+        Rule.Phoneme jkl = new Rule.Phoneme(\"jkl\", null);\n+\n+        assertEquals('a', a.getPhonemeText().charAt(0));\n+        assertEquals('b', b.getPhonemeText().charAt(0));\n+        assertEquals('c', cd.getPhonemeText().charAt(0));\n+        assertEquals('d', cd.getPhonemeText().charAt(1));\n+        assertEquals('e', ef.getPhonemeText().charAt(0));\n+        assertEquals('f', ef.getPhonemeText().charAt(1));\n+        assertEquals('g', ghi.getPhonemeText().charAt(0));\n+        assertEquals('h', ghi.getPhonemeText().charAt(1));\n+        assertEquals('i', ghi.getPhonemeText().charAt(2));\n+        assertEquals('j', jkl.getPhonemeText().charAt(0));\n+        assertEquals('k', jkl.getPhonemeText().charAt(1));\n+        assertEquals('l', jkl.getPhonemeText().charAt(2));\n+\n+        Rule.Phoneme a_b = a.append(b.getPhonemeText());\n+        assertEquals('a', a_b.getPhonemeText().charAt(0));\n+        assertEquals('b', a_b.getPhonemeText().charAt(1));\n+        assertEquals(\"ab\", a_b.getPhonemeText().subSequence(0, 2).toString());\n+        assertEquals(\"a\", a_b.getPhonemeText().subSequence(0, 1).toString());\n+        assertEquals(\"b\", a_b.getPhonemeText().subSequence(1, 2).toString());\n+\n+        Rule.Phoneme cd_ef = cd.append(ef.getPhonemeText());\n+        assertEquals('c', cd_ef.getPhonemeText().charAt(0));\n+        assertEquals('d', cd_ef.getPhonemeText().charAt(1));\n+        assertEquals('e', cd_ef.getPhonemeText().charAt(2));\n+        assertEquals('f', cd_ef.getPhonemeText().charAt(3));\n+        assertEquals(\"c\", cd_ef.getPhonemeText().subSequence(0, 1).toString());\n+        assertEquals(\"d\", cd_ef.getPhonemeText().subSequence(1, 2).toString());\n+        assertEquals(\"e\", cd_ef.getPhonemeText().subSequence(2, 3).toString());\n+        assertEquals(\"f\", cd_ef.getPhonemeText().subSequence(3, 4).toString());\n+        assertEquals(\"cd\", cd_ef.getPhonemeText().subSequence(0, 2).toString());\n+        assertEquals(\"de\", cd_ef.getPhonemeText().subSequence(1, 3).toString());\n+        assertEquals(\"ef\", cd_ef.getPhonemeText().subSequence(2, 4).toString());\n+        assertEquals(\"cde\", cd_ef.getPhonemeText().subSequence(0, 3).toString());\n+        assertEquals(\"def\", cd_ef.getPhonemeText().subSequence(1, 4).toString());\n+        assertEquals(\"cdef\", cd_ef.getPhonemeText().subSequence(0, 4).toString());\n+\n+        Rule.Phoneme a_b_cd = a.append(b.getPhonemeText()).append(cd.getPhonemeText());\n+        assertEquals('a', a_b_cd.getPhonemeText().charAt(0));\n+        assertEquals('b', a_b_cd.getPhonemeText().charAt(1));\n+        assertEquals('c', a_b_cd.getPhonemeText().charAt(2));\n+        assertEquals('d', a_b_cd.getPhonemeText().charAt(3));\n+        assertEquals(\"a\", a_b_cd.getPhonemeText().subSequence(0, 1).toString());\n+        assertEquals(\"b\", a_b_cd.getPhonemeText().subSequence(1, 2).toString());\n+        assertEquals(\"c\", a_b_cd.getPhonemeText().subSequence(2, 3).toString());\n+        assertEquals(\"d\", a_b_cd.getPhonemeText().subSequence(3, 4).toString());\n+        assertEquals(\"ab\", a_b_cd.getPhonemeText().subSequence(0, 2).toString());\n+        assertEquals(\"bc\", a_b_cd.getPhonemeText().subSequence(1, 3).toString());\n+        assertEquals(\"cd\", a_b_cd.getPhonemeText().subSequence(2, 4).toString());\n+        assertEquals(\"abc\", a_b_cd.getPhonemeText().subSequence(0, 3).toString());\n+        assertEquals(\"bcd\", a_b_cd.getPhonemeText().subSequence(1, 4).toString());\n+        assertEquals(\"abcd\", a_b_cd.getPhonemeText().subSequence(0, 4).toString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/net/BCodecTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.net;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.junit.Test;\n+\n+/**\n+ * Quoted-printable codec test cases\n+ * \n+ * @author <a href=\"mailto:oleg@ural.ru\">Oleg Kalnichevski</a>\n+ * @version $Id$\n+ */\n+public class BCodecTest {\n+\n+    static final int SWISS_GERMAN_STUFF_UNICODE[] =\n+        { 0x47, 0x72, 0xFC, 0x65, 0x7A, 0x69, 0x5F, 0x7A, 0xE4, 0x6D, 0xE4 };\n+\n+    static final int RUSSIAN_STUFF_UNICODE[] =\n+        { 0x412, 0x441, 0x435, 0x43C, 0x5F, 0x43F, 0x440, 0x438, 0x432, 0x435, 0x442 };\n+\n+    private String constructString(int[] unicodeChars) {\n+        StringBuffer buffer = new StringBuffer();\n+        if (unicodeChars != null) {\n+            for (int unicodeChar : unicodeChars) {\n+                buffer.append((char) unicodeChar);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    @Test\n+    public void testNullInput() throws Exception {\n+        BCodec bcodec = new BCodec();\n+        assertNull(bcodec.doDecoding(null));\n+        assertNull(bcodec.doEncoding(null));\n+    }\n+\n+    @Test\n+    public void testUTF8RoundTrip() throws Exception {\n+\n+        String ru_msg = constructString(RUSSIAN_STUFF_UNICODE);\n+        String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE);\n+\n+        BCodec bcodec = new BCodec(CharEncoding.UTF_8);\n+\n+        assertEquals(\"=?UTF-8?B?0JLRgdC10Lxf0L/RgNC40LLQtdGC?=\", bcodec.encode(ru_msg));\n+        assertEquals(\"=?UTF-8?B?R3LDvGV6aV96w6Rtw6Q=?=\", bcodec.encode(ch_msg));\n+\n+        assertEquals(ru_msg, bcodec.decode(bcodec.encode(ru_msg)));\n+        assertEquals(ch_msg, bcodec.decode(bcodec.encode(ch_msg)));\n+    }\n+\n+    @Test\n+    public void testBasicEncodeDecode() throws Exception {\n+        BCodec bcodec = new BCodec();\n+        String plain = \"Hello there\";\n+        String encoded = bcodec.encode(plain);\n+        assertEquals(\"Basic B encoding test\", \"=?UTF-8?B?SGVsbG8gdGhlcmU=?=\", encoded);\n+        assertEquals(\"Basic B decoding test\", plain, bcodec.decode(encoded));\n+    }\n+\n+    @Test\n+    public void testEncodeDecodeNull() throws Exception {\n+        BCodec bcodec = new BCodec();\n+        assertNull(\"Null string B encoding test\", bcodec.encode((String) null));\n+        assertNull(\"Null string B decoding test\", bcodec.decode((String) null));\n+    }\n+\n+    @Test\n+    public void testEncodeStringWithNull() throws Exception {\n+        BCodec bcodec = new BCodec();\n+        String test = null;\n+        String result = bcodec.encode(test, \"charset\");\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+\n+    @Test\n+    public void testDecodeStringWithNull() throws Exception {\n+        BCodec bcodec = new BCodec();\n+        String test = null;\n+        String result = bcodec.decode(test);\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+\n+    @Test\n+    public void testEncodeObjects() throws Exception {\n+        BCodec bcodec = new BCodec();\n+        String plain = \"what not\";\n+        String encoded = (String) bcodec.encode((Object) plain);\n+\n+        assertEquals(\"Basic B encoding test\", \"=?UTF-8?B?d2hhdCBub3Q=?=\", encoded);\n+\n+        Object result = bcodec.encode((Object) null);\n+        assertEquals(\"Encoding a null Object should return null\", null, result);\n+\n+        try {\n+            Object dObj = new Double(3.0);\n+            bcodec.encode(dObj);\n+            fail(\"Trying to url encode a Double object should cause an exception.\");\n+        } catch (EncoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidEncoding() {\n+        BCodec bcodec = new BCodec(\"NONSENSE\");\n+        try {\n+            bcodec.encode(\"Hello there!\");\n+            fail(\"We set the encoding to a bogus NONSENSE value, this shouldn't have worked.\");\n+        } catch (EncoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+        try {\n+            bcodec.decode(\"=?NONSENSE?B?Hello there!?=\");\n+            fail(\"We set the encoding to a bogus NONSENSE value, this shouldn't have worked.\");\n+        } catch (DecoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+    }\n+\n+    @Test\n+    public void testDecodeObjects() throws Exception {\n+        BCodec bcodec = new BCodec();\n+        String decoded = \"=?UTF-8?B?d2hhdCBub3Q=?=\";\n+        String plain = (String) bcodec.decode((Object) decoded);\n+        assertEquals(\"Basic B decoding test\", \"what not\", plain);\n+\n+        Object result = bcodec.decode((Object) null);\n+        assertEquals(\"Decoding a null Object should return null\", null, result);\n+\n+        try {\n+            Object dObj = new Double(3.0);\n+            bcodec.decode(dObj);\n+            fail(\"Trying to url encode a Double object should cause an exception.\");\n+        } catch (DecoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/net/QCodecTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package org.apache.commons.codec.net;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.junit.Test;\n+\n+/**\n+ * Quoted-printable codec test cases\n+ * \n+ * @author <a href=\"mailto:oleg@ural.ru\">Oleg Kalnichevski</a>\n+ * @version $Id$\n+ */\n+public class QCodecTest {\n+    \n+    static final int SWISS_GERMAN_STUFF_UNICODE [] = {\n+        0x47, 0x72, 0xFC, 0x65, 0x7A, 0x69, 0x5F, 0x7A, 0xE4, 0x6D, 0xE4\n+    };\n+    \n+    static final int RUSSIAN_STUFF_UNICODE [] = {\n+        0x412, 0x441, 0x435, 0x43C, 0x5F, 0x43F, 0x440, 0x438, \n+        0x432, 0x435, 0x442 \n+    }; \n+\n+    private String constructString(int [] unicodeChars) {\n+        StringBuffer buffer = new StringBuffer();\n+        if (unicodeChars != null) {\n+            for (int unicodeChar : unicodeChars) {\n+                buffer.append((char)unicodeChar); \n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    @Test\n+    public void testNullInput() throws Exception {\n+        QCodec qcodec = new QCodec();\n+        assertNull(qcodec.doDecoding(null));\n+        assertNull(qcodec.doEncoding(null));\n+    }\n+\n+    @Test\n+    public void testUTF8RoundTrip() throws Exception {\n+\n+        String ru_msg = constructString(RUSSIAN_STUFF_UNICODE); \n+        String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE); \n+        \n+        QCodec qcodec = new QCodec(CharEncoding.UTF_8);\n+        \n+        assertEquals(\n+            \"=?UTF-8?Q?=D0=92=D1=81=D0=B5=D0=BC=5F=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82?=\", \n+        qcodec.encode(ru_msg)\n+        );\n+        assertEquals(\"=?UTF-8?Q?Gr=C3=BCezi=5Fz=C3=A4m=C3=A4?=\", qcodec.encode(ch_msg));\n+        \n+        assertEquals(ru_msg, qcodec.decode(qcodec.encode(ru_msg)));\n+        assertEquals(ch_msg, qcodec.decode(qcodec.encode(ch_msg)));\n+    }\n+\n+\n+    @Test\n+    public void testBasicEncodeDecode() throws Exception {\n+        QCodec qcodec = new QCodec();\n+        String plain = \"= Hello there =\\r\\n\";\n+        String encoded = qcodec.encode(plain);\n+        assertEquals(\"Basic Q encoding test\", \n+            \"=?UTF-8?Q?=3D Hello there =3D=0D=0A?=\", encoded);\n+        assertEquals(\"Basic Q decoding test\", \n+            plain, qcodec.decode(encoded));\n+    }\n+\n+    @Test\n+    public void testUnsafeEncodeDecode() throws Exception {\n+        QCodec qcodec = new QCodec();\n+        String plain = \"?_=\\r\\n\";\n+        String encoded = qcodec.encode(plain);\n+        assertEquals(\"Unsafe chars Q encoding test\", \n+            \"=?UTF-8?Q?=3F=5F=3D=0D=0A?=\", encoded);\n+        assertEquals(\"Unsafe chars Q decoding test\", \n+            plain, qcodec.decode(encoded));\n+    }\n+\n+    @Test\n+    public void testEncodeDecodeNull() throws Exception {\n+        QCodec qcodec = new QCodec();\n+        assertNull(\"Null string Q encoding test\", \n+            qcodec.encode((String)null));\n+        assertNull(\"Null string Q decoding test\", \n+            qcodec.decode((String)null));\n+    }\n+\n+    @Test\n+    public void testEncodeStringWithNull() throws Exception {\n+        QCodec qcodec = new QCodec();\n+        String test = null;\n+        String result = qcodec.encode( test, \"charset\" );\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+\n+    @Test\n+    public void testDecodeStringWithNull() throws Exception {\n+        QCodec qcodec = new QCodec();\n+        String test = null;\n+        String result = qcodec.decode( test );\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+    \n+\n+    @Test\n+    public void testEncodeObjects() throws Exception {\n+        QCodec qcodec = new QCodec();\n+        String plain = \"1+1 = 2\";\n+        String encoded = (String) qcodec.encode((Object) plain);\n+        assertEquals(\"Basic Q encoding test\", \n+            \"=?UTF-8?Q?1+1 =3D 2?=\", encoded);\n+\n+        Object result = qcodec.encode((Object) null);\n+        assertEquals( \"Encoding a null Object should return null\", null, result);\n+        \n+        try {\n+            Object dObj = new Double(3.0);\n+            qcodec.encode( dObj );\n+            fail( \"Trying to url encode a Double object should cause an exception.\");\n+        } catch (EncoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+    }\n+    \n+\n+    @Test\n+    public void testInvalidEncoding() {\n+        QCodec qcodec = new QCodec(\"NONSENSE\");\n+            try {\n+               qcodec.encode(\"Hello there!\");\n+                fail( \"We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked.\");\n+            } catch (EncoderException ee) {\n+                // Exception expected, test segment passes.\n+            }\n+            try {\n+               qcodec.decode(\"=?NONSENSE?Q?Hello there!?=\");\n+                fail( \"We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked.\");\n+            } catch (DecoderException ee) {\n+                // Exception expected, test segment passes.\n+            }\n+    }\n+\n+    @Test\n+    public void testDecodeObjects() throws Exception {\n+        QCodec qcodec = new QCodec();\n+        String decoded = \"=?UTF-8?Q?1+1 =3D 2?=\";\n+        String plain = (String) qcodec.decode((Object) decoded);\n+        assertEquals(\"Basic Q decoding test\", \n+            \"1+1 = 2\", plain);\n+\n+        Object result = qcodec.decode((Object) null);\n+        assertEquals( \"Decoding a null Object should return null\", null, result);\n+        \n+        try {\n+            Object dObj = new Double(3.0);\n+            qcodec.decode( dObj );\n+            fail( \"Trying to url encode a Double object should cause an exception.\");\n+        } catch (DecoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testEncodeDecodeBlanks() throws Exception {\n+        String plain = \"Mind those pesky blanks\";\n+        String encoded1 = \"=?UTF-8?Q?Mind those pesky blanks?=\";\n+        String encoded2 = \"=?UTF-8?Q?Mind_those_pesky_blanks?=\";\n+        QCodec qcodec = new QCodec();\n+        qcodec.setEncodeBlanks(false);\n+        String s = qcodec.encode(plain);\n+        assertEquals(\"Blanks encoding with the Q codec test\", encoded1, s);\n+        qcodec.setEncodeBlanks(true);\n+        s = qcodec.encode(plain);\n+        assertEquals(\"Blanks encoding with the Q codec test\", encoded2, s);\n+        s = qcodec.decode(encoded1);\n+        assertEquals(\"Blanks decoding with the Q codec test\", plain, s);\n+        s = qcodec.decode(encoded2);\n+        assertEquals(\"Blanks decoding with the Q codec test\", plain, s);\n+    }\n+\n+\n+    @Test\n+    public void testLetUsMakeCloverHappy() throws Exception {\n+        QCodec qcodec = new QCodec();\n+        qcodec.setEncodeBlanks(true);\n+        assertTrue(qcodec.isEncodeBlanks());\n+        qcodec.setEncodeBlanks(false);\n+        assertFalse(qcodec.isEncodeBlanks());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/net/QuotedPrintableCodecTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.net;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+/**\n+ * Quoted-printable codec test cases\n+ * \n+ * @author <a href=\"mailto:oleg@ural.ru\">Oleg Kalnichevski</a>\n+ * @version $Id$\n+ */\n+public class QuotedPrintableCodecTest {\n+    \n+    static final int SWISS_GERMAN_STUFF_UNICODE [] = {\n+        0x47, 0x72, 0xFC, 0x65, 0x7A, 0x69, 0x5F, 0x7A, 0xE4, 0x6D, 0xE4\n+    };\n+    \n+    static final int RUSSIAN_STUFF_UNICODE [] = {\n+        0x412, 0x441, 0x435, 0x43C, 0x5F, 0x43F, 0x440, 0x438, \n+        0x432, 0x435, 0x442 \n+    }; \n+\n+    private String constructString(int [] unicodeChars) {\n+        StringBuffer buffer = new StringBuffer();\n+        if (unicodeChars != null) {\n+            for (int unicodeChar : unicodeChars) {\n+                buffer.append((char)unicodeChar); \n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    @Test\n+    public void testUTF8RoundTrip() throws Exception {\n+\n+        String ru_msg = constructString(RUSSIAN_STUFF_UNICODE); \n+        String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE); \n+        \n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        \n+        assertEquals(\n+            \"=D0=92=D1=81=D0=B5=D0=BC_=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82\", \n+        qpcodec.encode(ru_msg, CharEncoding.UTF_8)\n+        );\n+        assertEquals(\"Gr=C3=BCezi_z=C3=A4m=C3=A4\", qpcodec.encode(ch_msg, CharEncoding.UTF_8));\n+        \n+        assertEquals(ru_msg, qpcodec.decode(qpcodec.encode(ru_msg, CharEncoding.UTF_8), CharEncoding.UTF_8));\n+        assertEquals(ch_msg, qpcodec.decode(qpcodec.encode(ch_msg, CharEncoding.UTF_8), CharEncoding.UTF_8));\n+    }\n+\n+    @Test\n+    public void testBasicEncodeDecode() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"= Hello there =\\r\\n\";\n+        String encoded = qpcodec.encode(plain);\n+        assertEquals(\"Basic quoted-printable encoding test\", \n+            \"=3D Hello there =3D=0D=0A\", encoded);\n+        assertEquals(\"Basic quoted-printable decoding test\", \n+            plain, qpcodec.decode(encoded));\n+    }\n+\n+    @Test\n+    public void testSafeCharEncodeDecode() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"abc123_-.*~!@#$%^&()+{}\\\"\\\\;:`,/[]\";\n+        String encoded = qpcodec.encode(plain);\n+        assertEquals(\"Safe chars quoted-printable encoding test\", \n+            plain, encoded);\n+        assertEquals(\"Safe chars quoted-printable decoding test\", \n+            plain, qpcodec.decode(encoded));\n+    }\n+\n+\n+    @Test\n+    public void testUnsafeEncodeDecode() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"=\\r\\n\";\n+        String encoded = qpcodec.encode(plain);\n+        assertEquals(\"Unsafe chars quoted-printable encoding test\", \n+            \"=3D=0D=0A\", encoded);\n+        assertEquals(\"Unsafe chars quoted-printable decoding test\", \n+            plain, qpcodec.decode(encoded));\n+    }\n+\n+    @Test\n+    public void testEncodeDecodeNull() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        assertNull(\"Null string quoted-printable encoding test\", \n+            qpcodec.encode((String)null));\n+        assertNull(\"Null string quoted-printable decoding test\", \n+            qpcodec.decode((String)null));\n+    }\n+\n+\n+    @Test\n+    public void testDecodeInvalid() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        try {\n+            qpcodec.decode(\"=\");\n+            fail(\"DecoderException should have been thrown\");\n+        } catch (DecoderException e) {\n+            // Expected. Move on\n+        }\n+        try {\n+            qpcodec.decode(\"=A\");\n+            fail(\"DecoderException should have been thrown\");\n+        } catch (DecoderException e) {\n+            // Expected. Move on\n+        }\n+        try {\n+            qpcodec.decode(\"=WW\");\n+            fail(\"DecoderException should have been thrown\");\n+        } catch (DecoderException e) {\n+            // Expected. Move on\n+        }\n+    }\n+\n+    @Test\n+    public void testEncodeNull() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        byte[] plain = null;\n+        byte[] encoded = qpcodec.encode(plain);\n+        assertEquals(\"Encoding a null string should return null\", \n+            null, encoded);\n+    }\n+    \n+    @Test\n+    public void testEncodeUrlWithNullBitSet() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"1+1 = 2\";\n+        String encoded = new String(QuotedPrintableCodec.\n+            encodeQuotedPrintable(null, plain.getBytes(\"UTF-8\")));\n+        assertEquals(\"Basic quoted-printable encoding test\", \n+            \"1+1 =3D 2\", encoded);\n+        assertEquals(\"Basic quoted-printable decoding test\", \n+            plain, qpcodec.decode(encoded));\n+        \n+    }\n+\n+    @Test\n+    public void testDecodeWithNullArray() throws Exception {\n+        byte[] plain = null;\n+        byte[] result = QuotedPrintableCodec.decodeQuotedPrintable( plain );\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+\n+    @Test\n+    public void testEncodeStringWithNull() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String test = null;\n+        String result = qpcodec.encode( test, \"charset\" );\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+\n+    @Test\n+    public void testDecodeStringWithNull() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String test = null;\n+        String result = qpcodec.decode( test, \"charset\" );\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+    \n+    @Test\n+    public void testEncodeObjects() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"1+1 = 2\";\n+        String encoded = (String) qpcodec.encode((Object) plain);\n+        assertEquals(\"Basic quoted-printable encoding test\", \n+            \"1+1 =3D 2\", encoded);\n+\n+        byte[] plainBA = plain.getBytes(\"UTF-8\");\n+        byte[] encodedBA = (byte[]) qpcodec.encode((Object) plainBA);\n+        encoded = new String(encodedBA);\n+        assertEquals(\"Basic quoted-printable encoding test\", \n+            \"1+1 =3D 2\", encoded);\n+            \n+        Object result = qpcodec.encode((Object) null);\n+        assertEquals( \"Encoding a null Object should return null\", null, result);\n+        \n+        try {\n+            Object dObj = new Double(3.0);\n+            qpcodec.encode( dObj );\n+            fail( \"Trying to url encode a Double object should cause an exception.\");\n+        } catch (EncoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+    }\n+    \n+    @Test\n+    public void testInvalidEncoding() {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(\"NONSENSE\");\n+           String plain = \"Hello there!\";\n+            try {\n+               qpcodec.encode(plain);\n+                fail( \"We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked.\");\n+            } catch (EncoderException ee) {\n+                // Exception expected, test segment passes.\n+            }\n+            try {\n+               qpcodec.decode(plain);\n+                fail( \"We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked.\");\n+            } catch (DecoderException ee) {\n+                // Exception expected, test segment passes.\n+            }\n+    }\n+\n+    @Test\n+    public void testDecodeObjects() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"1+1 =3D 2\";\n+        String decoded = (String) qpcodec.decode((Object) plain);\n+        assertEquals(\"Basic quoted-printable decoding test\", \n+            \"1+1 = 2\", decoded);\n+\n+        byte[] plainBA = plain.getBytes(\"UTF-8\");\n+        byte[] decodedBA = (byte[]) qpcodec.decode((Object) plainBA);\n+        decoded = new String(decodedBA);\n+        assertEquals(\"Basic quoted-printable decoding test\", \n+            \"1+1 = 2\", decoded);\n+            \n+        Object result = qpcodec.decode((Object) null);\n+        assertEquals( \"Decoding a null Object should return null\", null, result);\n+        \n+        try {\n+            Object dObj = new Double(3.0);\n+            qpcodec.decode( dObj );\n+            fail( \"Trying to url encode a Double object should cause an exception.\");\n+        } catch (DecoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+    }\n+\n+    @Test\n+    public void testDefaultEncoding() throws Exception {\n+        String plain = \"Hello there!\";\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(\"UnicodeBig\");\n+        qpcodec.encode(plain); // To work around a weird quirk in Java 1.2.2\n+        String encoded1 = qpcodec.encode(plain, \"UnicodeBig\");\n+        String encoded2 = qpcodec.encode(plain);\n+        assertEquals(encoded1, encoded2);\n+    }\n+\n+    @Test\n+    @Ignore\n+    /**\n+     * The QuotedPrintableCodec documentation states that this is not supported.\n+     *  \n+     * @throws Exception\n+     * @see <a href=\"https://issues.apache.org/jira/browse/CODEC-121\">CODEC-121</a>\n+     */\n+    public void testSoftLineBreakDecode() throws Exception {\n+        String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics is the most beautiful branch of philosophy.\";\n+        String expected = \"If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy.\";\n+        assertEquals(expected, new QuotedPrintableCodec().decode(qpdata));\n+    }\n+\n+    @Test\n+    @Ignore\n+    /**\n+     * The QuotedPrintableCodec documentation states that this is not supported.\n+     *  \n+     * @throws Exception\n+     * @see <a href=\"https://issues.apache.org/jira/browse/CODEC-121\">CODEC-121</a>\n+     */\n+    public void testSoftLineBreakEncode() throws Exception {\n+        String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics is the most beautiful branch of philosophy.\";\n+        String expected = \"If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy.\";\n+        assertEquals(qpdata, new QuotedPrintableCodec().encode(expected));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/net/RFC1522CodecTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.net;\n+\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.codec.DecoderException;\n+import org.junit.Test;\n+\n+/**\n+ * RFC 1522 compliant codec test cases\n+ * \n+ * @author <a href=\"mailto:oleg@ural.ru\">Oleg Kalnichevski</a>\n+ * @version $Id$\n+ */\n+public class RFC1522CodecTest {\n+\n+    static class RFC1522TestCodec extends RFC1522Codec {\n+\n+        @Override\n+        protected byte[] doDecoding(byte[] bytes) {\n+            return bytes;\n+        }\n+\n+        @Override\n+        protected byte[] doEncoding(byte[] bytes) {\n+            return bytes;\n+        }\n+\n+        @Override\n+        protected String getEncoding() {\n+            return \"T\";\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testNullInput() throws Exception {\n+        RFC1522TestCodec testcodec = new RFC1522TestCodec();\n+        assertNull(testcodec.decodeText(null));\n+        assertNull(testcodec.encodeText(null, CharEncoding.UTF_8));\n+    }\n+\n+    private void assertExpectedDecoderException(String s) throws Exception {\n+        RFC1522TestCodec testcodec = new RFC1522TestCodec();\n+        try {\n+            testcodec.decodeText(s);\n+            fail(\"DecoderException should have been thrown\");\n+        } catch (DecoderException e) {\n+            // Expected.\n+        }\n+    }\n+\n+    @Test\n+    public void testDecodeInvalid() throws Exception {\n+        assertExpectedDecoderException(\"whatever\");\n+        assertExpectedDecoderException(\"=?\");\n+        assertExpectedDecoderException(\"?=\");\n+        assertExpectedDecoderException(\"==\");\n+        assertExpectedDecoderException(\"=??=\");\n+        assertExpectedDecoderException(\"=?stuff?=\");\n+        assertExpectedDecoderException(\"=?UTF-8??=\");\n+        assertExpectedDecoderException(\"=?UTF-8?stuff?=\");\n+        assertExpectedDecoderException(\"=?UTF-8?T?stuff\");\n+        assertExpectedDecoderException(\"=??T?stuff?=\");\n+        assertExpectedDecoderException(\"=?UTF-8??stuff?=\");\n+        assertExpectedDecoderException(\"=?UTF-8?W?stuff?=\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/net/URLCodecTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.net;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.junit.Test;\n+\n+/**\n+ * URL codec test cases\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class URLCodecTest {\n+    \n+    static final int SWISS_GERMAN_STUFF_UNICODE [] = {\n+        0x47, 0x72, 0xFC, 0x65, 0x7A, 0x69, 0x5F, 0x7A, 0xE4, 0x6D, 0xE4\n+    };\n+    \n+    static final int RUSSIAN_STUFF_UNICODE [] = {\n+        0x412, 0x441, 0x435, 0x43C, 0x5F, 0x43F, 0x440, 0x438, \n+        0x432, 0x435, 0x442 \n+    }; \n+\n+    private void validateState(URLCodec urlCodec) {\n+        // no tests for now.\n+    }\n+    \n+    private String constructString(int [] unicodeChars) {\n+        StringBuffer buffer = new StringBuffer();\n+        if (unicodeChars != null) {\n+            for (int unicodeChar : unicodeChars) {\n+                buffer.append((char)unicodeChar); \n+            }\n+        }\n+        return buffer.toString();\n+    }\n+    \n+    @Test\n+    public void testUTF8RoundTrip() throws Exception {\n+\n+        String ru_msg = constructString(RUSSIAN_STUFF_UNICODE); \n+        String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE); \n+        \n+        URLCodec urlCodec = new URLCodec();\n+        this.validateState(urlCodec);\n+        \n+        assertEquals(\n+            \"%D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82\", \n+            urlCodec.encode(ru_msg, CharEncoding.UTF_8)\n+        );\n+        assertEquals(\"Gr%C3%BCezi_z%C3%A4m%C3%A4\", urlCodec.encode(ch_msg, CharEncoding.UTF_8));\n+        \n+        assertEquals(ru_msg, urlCodec.decode(urlCodec.encode(ru_msg, CharEncoding.UTF_8), CharEncoding.UTF_8));\n+        assertEquals(ch_msg, urlCodec.decode(urlCodec.encode(ch_msg, CharEncoding.UTF_8), CharEncoding.UTF_8));\n+        this.validateState(urlCodec);\n+    }\n+\n+    @Test\n+    public void testBasicEncodeDecode() throws Exception {\n+        URLCodec urlCodec = new URLCodec();\n+        String plain = \"Hello there!\";\n+        String encoded = urlCodec.encode(plain);\n+        assertEquals(\"Basic URL encoding test\", \n+            \"Hello+there%21\", encoded);\n+        assertEquals(\"Basic URL decoding test\", \n+            plain, urlCodec.decode(encoded));\n+        this.validateState(urlCodec);\n+    }\n+\n+\n+    @Test\n+    public void testSafeCharEncodeDecode() throws Exception {\n+        URLCodec urlCodec = new URLCodec();\n+        String plain = \"abc123_-.*\";\n+        String encoded = urlCodec.encode(plain);\n+        assertEquals(\"Safe chars URL encoding test\", \n+            plain, encoded);\n+        assertEquals(\"Safe chars URL decoding test\", \n+            plain, urlCodec.decode(encoded));\n+        this.validateState(urlCodec);\n+    }\n+\n+\n+    @Test\n+    public void testUnsafeEncodeDecode() throws Exception {\n+        URLCodec urlCodec = new URLCodec();\n+        String plain = \"~!@#$%^&()+{}\\\"\\\\;:`,/[]\";\n+        String encoded = urlCodec.encode(plain);\n+        assertEquals(\"Unsafe chars URL encoding test\", \n+            \"%7E%21%40%23%24%25%5E%26%28%29%2B%7B%7D%22%5C%3B%3A%60%2C%2F%5B%5D\", encoded);\n+        assertEquals(\"Unsafe chars URL decoding test\", \n+            plain, urlCodec.decode(encoded));\n+        this.validateState(urlCodec);\n+    }\n+\n+\n+    @Test\n+    public void testEncodeDecodeNull() throws Exception {\n+        URLCodec urlCodec = new URLCodec();\n+        assertNull(\"Null string URL encoding test\", \n+            urlCodec.encode((String)null));\n+        assertNull(\"Null string URL decoding test\", \n+            urlCodec.decode((String)null));\n+        this.validateState(urlCodec);\n+    }\n+\n+\n+    @Test\n+    public void testDecodeInvalid() throws Exception {\n+        URLCodec urlCodec = new URLCodec();\n+        try {\n+            urlCodec.decode(\"%\");\n+            fail(\"DecoderException should have been thrown\");\n+        } catch (DecoderException e) {\n+            // Expected. Move on\n+        }\n+        try {\n+            urlCodec.decode(\"%A\");\n+            fail(\"DecoderException should have been thrown\");\n+        } catch (DecoderException e) {\n+            // Expected. Move on\n+        }        \n+        try {\n+            // Bad 1st char after %\n+            urlCodec.decode(\"%WW\");\n+            fail(\"DecoderException should have been thrown\");\n+        } catch (DecoderException e) {\n+            // Expected. Move on\n+        }\n+        try {\n+            // Bad 2nd char after %\n+            urlCodec.decode(\"%0W\");\n+            fail(\"DecoderException should have been thrown\");\n+        } catch (DecoderException e) {\n+            // Expected. Move on\n+        }\n+        this.validateState(urlCodec);\n+    }\n+\n+    @Test\n+    public void testDecodeInvalidContent() throws UnsupportedEncodingException, DecoderException {\n+        String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE); \n+        URLCodec urlCodec = new URLCodec();\n+        byte[] input = ch_msg.getBytes(\"ISO-8859-1\");\n+        byte[] output = urlCodec.decode(input);\n+        assertEquals(input.length, output.length);\n+        for (int i = 0; i < input.length; i++) {\n+            assertEquals(input[i], output[i]);\n+        }\n+        this.validateState(urlCodec);\n+    }\n+\n+    @Test\n+    public void testEncodeNull() throws Exception {\n+        URLCodec urlCodec = new URLCodec();\n+        byte[] plain = null;\n+        byte[] encoded = urlCodec.encode(plain);\n+        assertEquals(\"Encoding a null string should return null\", \n+            null, encoded);\n+        this.validateState(urlCodec);\n+    }\n+    \n+    @Test\n+    public void testEncodeUrlWithNullBitSet() throws Exception {\n+        URLCodec urlCodec = new URLCodec();\n+        String plain = \"Hello there!\";\n+        String encoded = new String( URLCodec.encodeUrl(null, plain.getBytes(\"UTF-8\")));\n+        assertEquals(\"Basic URL encoding test\", \n+            \"Hello+there%21\", encoded);\n+        assertEquals(\"Basic URL decoding test\", \n+            plain, urlCodec.decode(encoded));\n+        this.validateState(urlCodec);        \n+    }\n+\n+    @Test\n+    public void testDecodeWithNullArray() throws Exception {\n+        byte[] plain = null;\n+        byte[] result = URLCodec.decodeUrl( plain );\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+\n+    @Test\n+    public void testEncodeStringWithNull() throws Exception {\n+        URLCodec urlCodec = new URLCodec();\n+        String test = null;\n+        String result = urlCodec.encode( test, \"charset\" );\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+\n+    @Test\n+    public void testDecodeStringWithNull() throws Exception {\n+        URLCodec urlCodec = new URLCodec();\n+        String test = null;\n+        String result = urlCodec.decode( test, \"charset\" );\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+    \n+    @Test\n+    public void testEncodeObjects() throws Exception {\n+        URLCodec urlCodec = new URLCodec();\n+        String plain = \"Hello there!\";\n+        String encoded = (String) urlCodec.encode((Object) plain);\n+        assertEquals(\"Basic URL encoding test\", \n+            \"Hello+there%21\", encoded);\n+\n+        byte[] plainBA = plain.getBytes(\"UTF-8\");\n+        byte[] encodedBA = (byte[]) urlCodec.encode((Object) plainBA);\n+        encoded = new String(encodedBA);\n+        assertEquals(\"Basic URL encoding test\", \n+            \"Hello+there%21\", encoded);\n+            \n+        Object result = urlCodec.encode((Object) null);\n+        assertEquals( \"Encoding a null Object should return null\", null, result);\n+        \n+        try {\n+            Object dObj = new Double(3.0);\n+            urlCodec.encode( dObj );\n+            fail( \"Trying to url encode a Double object should cause an exception.\");\n+        } catch (EncoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+        this.validateState(urlCodec);\n+    }\n+    \n+    @Test\n+    public void testInvalidEncoding() {\n+        URLCodec urlCodec = new URLCodec(\"NONSENSE\");\n+        String plain = \"Hello there!\";\n+        try {\n+            urlCodec.encode(plain);\n+            fail(\"We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked.\");\n+        } catch (EncoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+        try {\n+            urlCodec.decode(plain);\n+            fail(\"We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked.\");\n+        } catch (DecoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+        this.validateState(urlCodec);\n+    }\n+\n+    @Test\n+    public void testDecodeObjects() throws Exception {\n+        URLCodec urlCodec = new URLCodec();\n+        String plain = \"Hello+there%21\";\n+        String decoded = (String) urlCodec.decode((Object) plain);\n+        assertEquals(\"Basic URL decoding test\", \n+            \"Hello there!\", decoded);\n+\n+        byte[] plainBA = plain.getBytes(\"UTF-8\");\n+        byte[] decodedBA = (byte[]) urlCodec.decode((Object) plainBA);\n+        decoded = new String(decodedBA);\n+        assertEquals(\"Basic URL decoding test\", \n+            \"Hello there!\", decoded);\n+            \n+        Object result = urlCodec.decode((Object) null);\n+        assertEquals( \"Decoding a null Object should return null\", null, result);\n+        \n+        try {\n+            Object dObj = new Double(3.0);\n+            urlCodec.decode( dObj );\n+            fail( \"Trying to url encode a Double object should cause an exception.\");\n+        } catch (DecoderException ee) {\n+            // Exception expected, test segment passes.\n+        }\n+        this.validateState(urlCodec);\n+    }\n+\n+    @Test\n+    public void testDefaultEncoding() throws Exception {\n+        String plain = \"Hello there!\";\n+        URLCodec urlCodec = new URLCodec(\"UnicodeBig\");\n+        urlCodec.encode(plain); // To work around a weird quirk in Java 1.2.2\n+        String encoded1 = urlCodec.encode(plain, \"UnicodeBig\");\n+        String encoded2 = urlCodec.encode(plain);\n+        assertEquals(encoded1, encoded2);\n+        this.validateState(urlCodec);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/net/UtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.net;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Tests Utils.\n+ * <p>\n+ * Methods currently get 100%/100% line/branch code coverage from other tests classes.\n+ * </p>\n+ * \n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ * @since 1.4\n+ */\n+public class UtilsTest {\n+\n+    /**\n+     * We could make the constructor private but there does not seem to be a point to jumping through extra code hoops\n+     * to restrict instantiation right now.\n+     */\n+    @Test\n+    public void testConstructor() {\n+        new Utils();\n+    }\n+\n+}", "timestamp": 1316542579, "metainfo": ""}