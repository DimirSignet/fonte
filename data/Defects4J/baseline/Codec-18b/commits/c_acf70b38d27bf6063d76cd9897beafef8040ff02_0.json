{"sha": "acf70b38d27bf6063d76cd9897beafef8040ff02", "log": "Convert to Java 5 enhanced loops.   ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/BaseNCodec.java\n+++ b/src/java/org/apache/commons/codec/binary/BaseNCodec.java\n         if (arrayOctet == null) {\n             return false;\n         }\n-        for (int i = 0; i < arrayOctet.length; i++) {\n-            if (PAD == arrayOctet[i] || isInAlphabet(arrayOctet[i])) {\n+        for (byte element : arrayOctet) {\n+            if (PAD == element || isInAlphabet(element)) {\n                 return true;\n             }\n         }\n--- a/src/java/org/apache/commons/codec/language/ColognePhonetic.java\n+++ b/src/java/org/apache/commons/codec/language/ColognePhonetic.java\n      * Returns whether the array contains the key, or not.\n      */\n     private static boolean arrayContains(char[] arr, char key) {\n-        for (int i = 0; i < arr.length; i++) {\n-            if (arr[i] == key) {\n+        for (char element : arr) {\n+            if (element == key) {\n                 return true;\n             }\n         }\n \n         for (int index = 0; index < chrs.length; index++) {\n             if (chrs[index] > 'Z') {\n-                for (int replacement = 0; replacement < PREPROCESS_MAP.length; replacement++) {\n-                    if (chrs[index] == PREPROCESS_MAP[replacement][0]) {\n-                        chrs[index] = PREPROCESS_MAP[replacement][1];\n+                for (char[] element : PREPROCESS_MAP) {\n+                    if (chrs[index] == element[0]) {\n+                        chrs[index] = element[1];\n                         break;\n                     }\n                 }\n--- a/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\n+++ b/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\n      */    \n     private boolean isSilentStart(String value) {\n         boolean result = false;\n-        for (int i = 0; i < SILENT_START.length; i++) {\n-            if (value.startsWith(SILENT_START[i])) {\n+        for (String element : SILENT_START) {\n+            if (value.startsWith(element)) {\n                 result = true;\n                 break;\n             }\n         if (start >= 0 && start + length <= value.length()) {\n             String target = value.substring(start, start + length);\n \n-            for (int i = 0; i < criteria.length; i++) {\n-                if (target.equals(criteria[i])) {\n+            for (String element : criteria) {\n+                if (target.equals(element)) {\n                     result = true;\n                     break;\n                 }\n--- a/src/java/org/apache/commons/codec/net/QCodec.java\n+++ b/src/java/org/apache/commons/codec/net/QCodec.java\n             return null;\n         }\n         boolean hasUnderscores = false;\n-        for (int i = 0; i < bytes.length; i++) {\n-            if (bytes[i] == UNDERSCORE) {\n+        for (byte b : bytes) {\n+            if (b == UNDERSCORE) {\n                 hasUnderscores = true;\n                 break;\n             }\n--- a/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n+++ b/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n             printable = PRINTABLE_CHARS;\n         }\n         ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        for (int i = 0; i < bytes.length; i++) {\n-            int b = bytes[i];\n+        for (byte c : bytes) {\n+            int b = c;\n             if (b < 0) {\n                 b = 256 + b;\n             }\n--- a/src/java/org/apache/commons/codec/net/URLCodec.java\n+++ b/src/java/org/apache/commons/codec/net/URLCodec.java\n         }\n \n         ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        for (int i = 0; i < bytes.length; i++) {\n-            int b = bytes[i];\n+        for (byte c : bytes) {\n+            int b = c;\n             if (b < 0) {\n                 b = 256 + b;\n             }\n--- a/src/test/org/apache/commons/codec/StringEncoderAbstractTest.java\n+++ b/src/test/org/apache/commons/codec/StringEncoderAbstractTest.java\n     }\n \n     protected void checkEncodings(String[][] data) throws EncoderException {\n-        for (int i = 0; i < data.length; i++) {\n-            this.checkEncoding(data[i][1], data[i][0]);\n+        for (String[] element : data) {\n+            this.checkEncoding(element[1], element[0]);\n         }\n     }\n \n     protected void checkEncodingVariations(String expected, String data[]) throws EncoderException {\n-        for (int i = 0; i < data.length; i++) {\n-            this.checkEncoding(expected, data[i]);\n+        for (String element : data) {\n+            this.checkEncoding(expected, element);\n         }\n     }\n \n         Locale[] locales = {Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault()};\n \n         try {\n-            for (int i = 0; i < data.length; i++) {\n+            for (String element : data) {\n                 String ref = null;\n                 for (int j = 0; j < locales.length; j++) {\n                     Locale.setDefault(locales[j]);\n                     if (j <= 0) {\n-                        ref = encoder.encode(data[i]);\n+                        ref = encoder.encode(element);\n                     } else {\n                         String cur = null;\n                         try {\n-                            cur = encoder.encode(data[i]);\n+                            cur = encoder.encode(element);\n                         } catch (Exception e) {\n                             Assert.fail(Locale.getDefault().toString() + \": \" + e.getMessage());\n                         }\n--- a/src/test/org/apache/commons/codec/binary/Base32OutputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base32OutputStreamTest.java\n         // Start with encode.\n         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n         OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator);\n-        for (int i = 0; i < decoded.length; i++) {\n-            out.write(decoded[i]);\n+        for (byte element : decoded) {\n+            out.write(element);\n         }\n         out.close();\n         byte[] output = byteOut.toByteArray();\n         // Now let's try decode.\n         byteOut = new ByteArrayOutputStream();\n         out = new Base32OutputStream(byteOut, false);\n-        for (int i = 0; i < encoded.length; i++) {\n-            out.write(encoded[i]);\n+        for (byte element : encoded) {\n+            out.write(element);\n         }\n         out.close();\n         output = byteOut.toByteArray();\n         // Now let's try decode with tonnes of flushes.\n         byteOut = new ByteArrayOutputStream();\n         out = new Base32OutputStream(byteOut, false);\n-        for (int i = 0; i < encoded.length; i++) {\n-            out.write(encoded[i]);\n+        for (byte element : encoded) {\n+            out.write(element);\n             out.flush();\n         }\n         out.close();\n             out = new Base32OutputStream(out, false);\n             out = new Base32OutputStream(out, true, chunkSize, seperator);\n         }\n-        for (int i = 0; i < decoded.length; i++) {\n-            out.write(decoded[i]);\n+        for (byte element : decoded) {\n+            out.write(element);\n         }\n         out.close();\n         output = byteOut.toByteArray();\n--- a/src/test/org/apache/commons/codec/binary/Base32Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base32Test.java\n     @Test\n     public void testBase32Samples() throws Exception {\n         Base32 codec = new Base32();\n-        for (int i = 0; i < BASE32_TEST_CASES.length; i++) {\n-                assertEquals(BASE32_TEST_CASES[i][1], codec.encodeAsString(BASE32_TEST_CASES[i][0].getBytes(\"UTF-8\")));\n+        for (String[] element : BASE32_TEST_CASES) {\n+                assertEquals(element[1], codec.encodeAsString(element[0].getBytes(\"UTF-8\")));\n         }\n     }\n \n     @Test\n     public void testBase32HexSamples() throws Exception {\n         Base32 codec = new Base32(true);\n-        for (int i = 0; i < BASE32HEX_TEST_CASES.length; i++) {\n-                assertEquals(BASE32HEX_TEST_CASES[i][1], codec.encodeAsString(BASE32HEX_TEST_CASES[i][0].getBytes(\"UTF-8\")));\n+        for (String[] element : BASE32HEX_TEST_CASES) {\n+                assertEquals(element[1], codec.encodeAsString(element[0].getBytes(\"UTF-8\")));\n         }\n     }\n \n     @Test\n     public void testBase32Chunked () throws Exception {\n         Base32 codec = new Base32(20);\n-        for (int i = 0; i < BASE32_TEST_CASES_CHUNKED.length; i++) {\n-                assertEquals(BASE32_TEST_CASES_CHUNKED[i][1], codec.encodeAsString(BASE32_TEST_CASES_CHUNKED[i][0].getBytes(\"UTF-8\")));\n+        for (String[] element : BASE32_TEST_CASES_CHUNKED) {\n+                assertEquals(element[1], codec.encodeAsString(element[0].getBytes(\"UTF-8\")));\n         }        \n     }\n \n--- a/src/test/org/apache/commons/codec/binary/Base32TestData.java\n+++ b/src/test/org/apache/commons/codec/binary/Base32TestData.java\n      * @return true if bytes contains c, false otherwise\n      */\n     static boolean bytesContain(byte[] bytes, byte c) {\n-        for (int i = 0; i < bytes.length; i++) {\n-            if (bytes[i] == c) { return true; }\n+        for (byte b : bytes) {\n+            if (b == c) { return true; }\n         }\n         return false;\n     }\n--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n         // Start with encode.\n         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n-        for (int i = 0; i < decoded.length; i++) {\n-            out.write(decoded[i]);\n+        for (byte element : decoded) {\n+            out.write(element);\n         }\n         out.close();\n         byte[] output = byteOut.toByteArray();\n         // Now let's try decode.\n         byteOut = new ByteArrayOutputStream();\n         out = new Base64OutputStream(byteOut, false);\n-        for (int i = 0; i < encoded.length; i++) {\n-            out.write(encoded[i]);\n+        for (byte element : encoded) {\n+            out.write(element);\n         }\n         out.close();\n         output = byteOut.toByteArray();\n         // Now let's try decode with tonnes of flushes.\n         byteOut = new ByteArrayOutputStream();\n         out = new Base64OutputStream(byteOut, false);\n-        for (int i = 0; i < encoded.length; i++) {\n-            out.write(encoded[i]);\n+        for (byte element : encoded) {\n+            out.write(element);\n             out.flush();\n         }\n         out.close();\n             out = new Base64OutputStream(out, false);\n             out = new Base64OutputStream(out, true, chunkSize, seperator);\n         }\n-        for (int i = 0; i < decoded.length; i++) {\n-            out.write(decoded[i]);\n+        for (byte element : decoded) {\n+            out.write(element);\n         }\n         out.close();\n         output = byteOut.toByteArray();\n--- a/src/test/org/apache/commons/codec/binary/Base64TestData.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64TestData.java\n      * @return true if bytes contains c, false otherwise\n      */\n     static boolean bytesContain(byte[] bytes, byte c) {\n-        for (int i = 0; i < bytes.length; i++) {\n-            if (bytes[i] == c) { return true; }\n+        for (byte b : bytes) {\n+            if (b == c) { return true; }\n         }\n         return false;\n     }\n--- a/src/test/org/apache/commons/codec/language/ColognePhoneticTest.java\n+++ b/src/test/org/apache/commons/codec/language/ColognePhoneticTest.java\n             {\"ganz\", \"Gans\"},\n             {\"ganz\", \"G\u00e4nse\"},\n             {\"Miyagi\", \"Miyako\"}};\n-        for (int i = 0; i < data.length; i++) {\n-            ((ColognePhonetic) this.getStringEncoder()).isEncodeEqual(data[i][1], data[i][0]);\n+        for (String[] element : data) {\n+            ((ColognePhonetic) this.getStringEncoder()).isEncodeEqual(element[1], element[0]);\n         }\n     }\n \n--- a/src/test/org/apache/commons/codec/language/DoubleMetaphoneTest.java\n+++ b/src/test/org/apache/commons/codec/language/DoubleMetaphoneTest.java\n \n     public void doubleMetaphoneEqualTest(String[][] pairs, boolean useAlternate) {\n         this.validateFixture(pairs);\n-        for (int i = 0; i < pairs.length; i++) {\n-            String name0 = pairs[i][0];\n-            String name1 = pairs[i][1];\n+        for (String[] pair : pairs) {\n+            String name0 = pair[0];\n+            String name1 = pair[1];\n             String failMsg = \"Expected match between \" + name0 + \" and \" + name1 + \" (use alternate: \" + useAlternate + \")\";\n             assertTrue(failMsg, this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, useAlternate));\n             assertTrue(failMsg, this.getDoubleMetaphone().isDoubleMetaphoneEqual(name1, name0, useAlternate));\n--- a/src/test/org/apache/commons/codec/language/MetaphoneTest.java\n+++ b/src/test/org/apache/commons/codec/language/MetaphoneTest.java\n \n     public void assertIsMetaphoneEqual(String source, String[] matches) {\n         // match source to all matches\n-        for (int i = 0; i < matches.length; i++) {\n-            assertTrue(\"Source: \" + source + \", should have same Metaphone as: \" + matches[i],\n-                       this.getMetaphone().isMetaphoneEqual(source, matches[i]));\n+        for (String matche : matches) {\n+            assertTrue(\"Source: \" + source + \", should have same Metaphone as: \" + matche,\n+                       this.getMetaphone().isMetaphoneEqual(source, matche));\n         }\n         // match to each other\n-        for (int i = 0; i < matches.length; i++) {\n-            for (int j = 0; j < matches.length; j++) {\n-                assertTrue(this.getMetaphone().isMetaphoneEqual(matches[i], matches[j]));\n+        for (String matche : matches) {\n+            for (String matche2 : matches) {\n+                assertTrue(this.getMetaphone().isMetaphoneEqual(matche, matche2));\n             }\n         }\n     }\n \n     public void assertMetaphoneEqual(String[][] pairs) {\n         this.validateFixture(pairs);\n-        for (int i = 0; i < pairs.length; i++) {\n-            String name0 = pairs[i][0];\n-            String name1 = pairs[i][1];\n+        for (String[] pair : pairs) {\n+            String name0 = pair[0];\n+            String name1 = pair[1];\n             String failMsg = \"Expected match between \" + name0 + \" and \" + name1;\n             assertTrue(failMsg, this.getMetaphone().isMetaphoneEqual(name0, name1));\n             assertTrue(failMsg, this.getMetaphone().isMetaphoneEqual(name1, name0));\n--- a/src/test/org/apache/commons/codec/net/BCodecTest.java\n+++ b/src/test/org/apache/commons/codec/net/BCodecTest.java\n     private String constructString(int[] unicodeChars) {\n         StringBuffer buffer = new StringBuffer();\n         if (unicodeChars != null) {\n-            for (int i = 0; i < unicodeChars.length; i++) {\n-                buffer.append((char) unicodeChars[i]);\n+            for (int unicodeChar : unicodeChars) {\n+                buffer.append((char) unicodeChar);\n             }\n         }\n         return buffer.toString();\n--- a/src/test/org/apache/commons/codec/net/QCodecTest.java\n+++ b/src/test/org/apache/commons/codec/net/QCodecTest.java\n     private String constructString(int [] unicodeChars) {\n         StringBuffer buffer = new StringBuffer();\n         if (unicodeChars != null) {\n-            for (int i = 0; i < unicodeChars.length; i++) {\n-                buffer.append((char)unicodeChars[i]); \n+            for (int unicodeChar : unicodeChars) {\n+                buffer.append((char)unicodeChar); \n             }\n         }\n         return buffer.toString();\n--- a/src/test/org/apache/commons/codec/net/QuotedPrintableCodecTest.java\n+++ b/src/test/org/apache/commons/codec/net/QuotedPrintableCodecTest.java\n     private String constructString(int [] unicodeChars) {\n         StringBuffer buffer = new StringBuffer();\n         if (unicodeChars != null) {\n-            for (int i = 0; i < unicodeChars.length; i++) {\n-                buffer.append((char)unicodeChars[i]); \n+            for (int unicodeChar : unicodeChars) {\n+                buffer.append((char)unicodeChar); \n             }\n         }\n         return buffer.toString();\n--- a/src/test/org/apache/commons/codec/net/URLCodecTest.java\n+++ b/src/test/org/apache/commons/codec/net/URLCodecTest.java\n     private String constructString(int [] unicodeChars) {\n         StringBuffer buffer = new StringBuffer();\n         if (unicodeChars != null) {\n-            for (int i = 0; i < unicodeChars.length; i++) {\n-                buffer.append((char)unicodeChars[i]); \n+            for (int unicodeChar : unicodeChars) {\n+                buffer.append((char)unicodeChar); \n             }\n         }\n         return buffer.toString();", "timestamp": 1310346636, "metainfo": ""}