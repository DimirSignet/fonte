{"sha": "4008ff9e49715f77cd6ac956b358160b7e416e69", "log": "[CODEC-133] Add classes for MD5/SHA1/SHA-512-based Unix crypt(3) hash variants.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/digest/B64.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import java.util.Random;\n+\n+/**\n+ * Base64 like method to convert binary bytes into ASCII chars.\n+ * \n+ * TODO: Can Base64 be reused?\n+ * \n+ * @version $Id $\n+ * @since 1.7\n+ */\n+class B64 {\n+\n+    /**\n+     * Table with characters for Base64 transformation.\n+     */\n+    static final String B64T = \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n+\n+    /**\n+     * Base64 like conversion of bytes to ASCII chars.\n+     * \n+     * @param b2\n+     *            A byte from the result.\n+     * @param b1\n+     *            A byte from the result.\n+     * @param b0\n+     *            A byte from the result.\n+     * @param outLen\n+     *            The number of expected output chars.\n+     * @param buffer\n+     *            Where the output chars is appended to.\n+     */\n+    static void b64from24bit(byte b2, byte b1, byte b0, int outLen, StringBuilder buffer) {\n+        // The bit masking is necessary because the JVM byte type is signed!\n+        int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff);\n+        // It's effectively a \"for\" loop but kept to resemble the original C code.\n+        int n = outLen;\n+        while (n-- > 0) {\n+            buffer.append(B64T.charAt(w & 0x3f));\n+            w >>= 6;\n+        }\n+    }\n+\n+    /**\n+     * Generates a string of random chars from the B64T set.\n+     * \n+     * @param num\n+     *            Number of chars to generate.\n+     */\n+    static String getRandomSalt(int num) {\n+        StringBuilder saltString = new StringBuilder();\n+        for (int i = 1; i <= num; i++) {\n+            saltString.append(B64T.charAt(new Random().nextInt(B64T.length())));\n+        }\n+        return saltString.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/digest/Crypt.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import org.apache.commons.codec.Charsets;\n+\n+/**\n+ * GNU libc crypt(3) compatible hash method.\n+ * \n+ * See {@link #crypt(String, String)} for further details.\n+ * \n+ * @version $Id $\n+ * @since 1.7\n+ */\n+public class Crypt {\n+\n+    /**\n+     * Encrypts a password in a crypt(3) compatible way.\n+     * \n+     * A random salt and the default algorithm (currently SHA-512) are used. See\n+     * {@link #crypt(String, String)} for details.\n+     * \n+     * @param keyBytes\n+     *            The plaintext password.\n+     * @return The hash value.\n+     */\n+    public static String crypt(byte[] keyBytes) throws Exception {\n+        return crypt(keyBytes, null);\n+    }\n+\n+    /**\n+     * Encrypts a password in a crypt(3) compatible way.\n+     * \n+     * A random salt and the default algorithm (currently SHA-512) are used. See\n+     * {@link #crypt(String, String)} for details.\n+     * \n+     * @param keyBytes\n+     *            The plaintext password.\n+     * @param salt\n+     *            The salt value\n+     * @return The hash value.\n+     */\n+    public static String crypt(byte[] keyBytes, String salt) throws Exception {\n+        if (salt == null) {\n+            return Sha2Crypt.sha512Crypt(keyBytes);\n+        } else if (salt.startsWith(Sha2Crypt.SHA512_PREFIX)) {\n+            return Sha2Crypt.sha512Crypt(keyBytes, salt);\n+        } else if (salt.startsWith(Sha2Crypt.SHA256_PREFIX)) {\n+            return Sha2Crypt.sha256Crypt(keyBytes, salt);\n+        } else if (salt.startsWith(Md5Crypt.MD5_PREFIX)) {\n+            return Md5Crypt.md5Crypt(keyBytes, salt);\n+        } else {\n+            return UnixCrypt.crypt(keyBytes, salt);\n+        }\n+    }\n+\n+    /**\n+     * Calculates the digest using the strongest crypt(3) algorithm.\n+     * \n+     * A random salt and the default algorithm (currently SHA-512) are used.\n+     * \n+     * @see #crypt(String, String)\n+     * @param key\n+     *            The plaintext password.\n+     * @return The hash value.\n+     */\n+    public static String crypt(String key) throws Exception {\n+        return crypt(key, null);\n+    }\n+\n+    /**\n+     * Encrypts a password in a crypt(3) compatible way.\n+     * \n+     * <p>\n+     * The exact algorithm depends on the format of the salt string:\n+     * <ul>\n+     * <li>SHA-512 salts start with $6$ and are up to 16 chars long.\n+     * <li>SHA-256 salts start with $5$ and are up to 16 chars long\n+     * <li>MD5 salts start with \"$1$\" and are up to 8 chars long\n+     * <li>DES, the traditional UnixCrypt algorithm is used else with only 2 chars\n+     * <li>Only the first 8 chars of the passwords are used in the DES algorithm!\n+     * </ul>\n+     * The magic strings \"$apr1$\" and \"$2a$\" are not recognised by this method as its output should be identical with\n+     * that of the libc implementation.\n+     * \n+     * <p>\n+     * The rest of the salt string is drawn from the set [a-zA-Z0-9./] and is cut at the maximum length of if a \"$\" sign\n+     * is encountered. It is therefore valid to enter a complete hash value as salt to e.g. verify a password with:\n+     * storedPwd.equals(crypt(enteredPwd, storedPwd))\n+     * \n+     * <p>\n+     * The resulting string starts with the marker string ($6$), continues with the salt value and ends with a \"$\" sign\n+     * followed by the actual hash value. For DES the string only contains the salt and actual hash. It's toal length is\n+     * dependend on the algorithm used:\n+     * <ul>\n+     * <li>SHA-512: 106 chars\n+     * <li>SHA-256: 63 chars\n+     * <li>MD5: 34 chars\n+     * <li>DES: 13 chars\n+     * </ul>\n+     * \n+     * <p>\n+     * Example:\n+     * \n+     * <pre>\n+     *      crypt(\"secret\", \"$1$xxxx\") => \"$1$xxxx$aMkevjfEIpa35Bh3G4bAc.\"\n+     *      crypt(\"secret\", \"xx\") => \"xxWAum7tHdIUw\"\n+     * </pre>\n+     * \n+     * This method comes in a variation that accepts a byte[] array to support input strings that are not encoded in\n+     * UTF-8 but e.g. in ISO-8859-1 where equal characters result in different byte values.\n+     * \n+     * @see \"The man page of the libc crypt (3) function.\"\n+     * @param key\n+     *            The plaintext password as entered by the used.\n+     * @param salt\n+     *            The salt value\n+     * @return The hash value i.e. encrypted password including the salt string\n+     */\n+    public static String crypt(String key, String salt) throws Exception {\n+        return crypt(key.getBytes(Charsets.UTF_8), salt);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/digest/Md5Crypt.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import java.security.MessageDigest;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.codec.Charsets;\n+\n+/**\n+ * The libc crypt() \"$1$\" and Apache \"$apr1$\" MD5-based hash algorithm.\n+ * <p>\n+ * Based on the public domain (\"beer-ware\") C implementation from Poul-Henning Kamp which was found at:\n+ * </p>\n+ * <p>\n+ * http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/libcrypt/crypt-md5.c?rev=1.1;content-type=text%2Fplain</br>\n+ * Source: $FreeBSD: src/lib/libcrypt/crypt-md5.c,v 1.1 1999/01/21 13:50:09 brandon Exp $\n+ * </p>\n+ * <p>\n+ * Conversion to Kotlin and from there to Java in 2012.\n+ * </p>\n+ * <p>\n+ * The C style comments are from the original C code, the ones with \"//\" from me.\n+ * </p>\n+ * \n+ * @version $Id $\n+ * @since 1.7\n+ */\n+public class Md5Crypt {\n+\n+    /**\n+     * The Identifier of the Apache variant.\n+     */\n+    static final String APR1_PREFIX = \"$apr1$\";\n+\n+    /**\n+     * The number of bytes of the final hash.\n+     */\n+    private static final int BLOCKSIZE = 16;\n+\n+    /**\n+     * The MessageDigest MD5_ALGORITHM.\n+     */\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    /**\n+     * The Identifier of this crypt() variant.\n+     */\n+    static final String MD5_PREFIX = \"$1$\";\n+\n+    /**\n+     * The number of rounds of the big loop.\n+     */\n+    private static final int ROUNDS = 1000;\n+\n+    /** See {@link #apr1Crypt(String, String)} for details. */\n+    public static String apr1Crypt(byte[] keyBytes) throws Exception {\n+        return apr1Crypt(keyBytes, APR1_PREFIX + B64.getRandomSalt(8));\n+    }\n+\n+    /** See {@link #apr1Crypt(String, String)} for details. */\n+    public static String apr1Crypt(byte[] keyBytes, String salt) throws Exception {\n+        // to make the md5Crypt regex happy\n+        if (salt != null && !salt.startsWith(APR1_PREFIX)) {\n+            salt = APR1_PREFIX + salt;\n+        }\n+        return Md5Crypt.md5Crypt(keyBytes, salt, APR1_PREFIX);\n+    }\n+\n+    /** See {@link #apr1Crypt(String, String)} for details. */\n+    public static String apr1Crypt(String keyBytes) throws Exception {\n+        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8));\n+    }\n+\n+    /**\n+     * Generates an Apache htpasswd compatible \"$apr1$\" MD5 based hash value. *\n+     * \n+     * The algorithm is identical to the crypt(3) \"$1$\" one but produces different outputs due to the different salt\n+     * prefix.\n+     * \n+     * @param keyBytes\n+     *            The plaintext string that should be hashed.\n+     * @param salt\n+     *            Salt string including the prefix and optionally garbage at the end. Will be generated randomly if\n+     *            null.\n+     */\n+    public static String apr1Crypt(String keyBytes, String salt) throws Exception {\n+        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8), salt);\n+    }\n+\n+    /**\n+     * Generates a libc6 crypt() compatible \"$1$\" hash value.\n+     * \n+     * See {@link Crypt#crypt(String, String)} for details.\n+     */\n+    public static String md5Crypt(final byte[] keyBytes) throws Exception {\n+        return md5Crypt(keyBytes, MD5_PREFIX + B64.getRandomSalt(8));\n+    }\n+\n+    /**\n+     * Generates a libc crypt() compatible \"$1$\" MD5 based hash value.\n+     * \n+     * See {@link Crypt#crypt(String, String)} for details.\n+     * \n+     * @param keyBytes\n+     *            The plaintext string that should be hashed.\n+     * @param salt\n+     *            Salt string including the prefix and optionally garbage at the end. Will be generated randomly if\n+     *            null.\n+     */\n+    public static String md5Crypt(byte[] keyBytes, String salt) throws Exception {\n+        return md5Crypt(keyBytes, salt, MD5_PREFIX);\n+    }\n+\n+    /**\n+     * Generates a libc6 crypt() \"$1$\" or Apache htpasswd \"$apr1$\" hash value.\n+     * \n+     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details.\n+     */\n+    public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) throws Exception {\n+        int keyLen = keyBytes.length;\n+\n+        // Extract the real salt from the given string which can be a complete hash string.\n+        String saltString;\n+        if (salt == null) {\n+            saltString = B64.getRandomSalt(8);\n+        } else {\n+            Pattern p = Pattern.compile(\"^\" + prefix.replace(\"$\", \"\\\\$\") + \"([\\\\.\\\\/a-zA-Z0-9]{1,8}).*\");\n+            Matcher m = p.matcher(salt);\n+            if (m == null || !m.find()) {\n+                throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n+            }\n+            saltString = m.group(1);\n+        }\n+        byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\n+\n+        MessageDigest ctx = MessageDigest.getInstance(MD5_ALGORITHM);\n+\n+        /*\n+         * The password first, since that is what is most unknown\n+         */\n+        ctx.update(keyBytes);\n+\n+        /*\n+         * Then our magic string\n+         */\n+        ctx.update(prefix.getBytes(Charsets.UTF_8));\n+\n+        /*\n+         * Then the raw salt\n+         */\n+        ctx.update(saltBytes);\n+\n+        /*\n+         * Then just as many characters of the MD5(pw,salt,pw)\n+         */\n+        MessageDigest ctx1 = MessageDigest.getInstance(MD5_ALGORITHM);\n+        ctx1.update(keyBytes);\n+        ctx1.update(saltBytes);\n+        ctx1.update(keyBytes);\n+        byte[] finalb = ctx1.digest();\n+        int ii = keyLen;\n+        while (ii > 0) {\n+            ctx.update(finalb, 0, ii > 16 ? 16 : ii);\n+            ii -= 16;\n+        }\n+\n+        /*\n+         * Don't leave anything around in vm they could use.\n+         */\n+        Arrays.fill(finalb, (byte) 0);\n+\n+        /*\n+         * Then something really weird...\n+         */\n+        ii = keyLen;\n+        int j = 0;\n+        while (ii > 0) {\n+            if ((ii & 1) == 1) {\n+                ctx.update(finalb[j]);\n+            } else {\n+                ctx.update(keyBytes[j]);\n+            }\n+            ii >>= 1;\n+        }\n+\n+        /*\n+         * Now make the output string\n+         */\n+        StringBuilder passwd = new StringBuilder(prefix + saltString + \"$\");\n+        finalb = ctx.digest();\n+\n+        /*\n+         * and now, just to make sure things don't run too fast On a 60 Mhz Pentium this takes 34 msec, so you would\n+         * need 30 seconds to build a 1000 entry dictionary...\n+         */\n+        for (int i = 0; i < ROUNDS; i++) {\n+            ctx1 = MessageDigest.getInstance(MD5_ALGORITHM);\n+            if ((i & 1) != 0) {\n+                ctx1.update(keyBytes);\n+            } else {\n+                ctx1.update(finalb, 0, BLOCKSIZE);\n+            }\n+\n+            if (i % 3 != 0) {\n+                ctx1.update(saltBytes);\n+            }\n+\n+            if (i % 7 != 0) {\n+                ctx1.update(keyBytes);\n+            }\n+\n+            if ((i & 1) != 0) {\n+                ctx1.update(finalb, 0, BLOCKSIZE);\n+            } else {\n+                ctx1.update(keyBytes);\n+            }\n+            finalb = ctx1.digest();\n+        }\n+\n+        // The following was nearly identical to the Sha2Crypt code.\n+        // Again, the buflen is not really needed.\n+        // int buflen = MD5_PREFIX.length() - 1 + salt_string.length() + 1 + BLOCKSIZE + 1;\n+        B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);\n+        B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);\n+        B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);\n+        B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);\n+        B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);\n+        B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);\n+\n+        /*\n+         * Don't leave anything around in vm they could use.\n+         */\n+        // Is there a better way to do this with the JVM?\n+        ctx.reset();\n+        ctx1.reset();\n+        Arrays.fill(keyBytes, (byte) 0);\n+        Arrays.fill(saltBytes, (byte) 0);\n+        Arrays.fill(finalb, (byte) 0);\n+\n+        return passwd.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import java.security.MessageDigest;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * SHA2-based Unix crypt implementation.\n+ * \n+ * <p>\n+ * Based on the C implementation released into the Public Domain by Ulrich Drepper &lt;drepper@redhat.com&gt;\n+ * http://www.akkadia.org/drepper/SHA-crypt.txt\n+ * </p>\n+ * \n+ * <p>\n+ * Conversion to Kotlin and from there to Java in 2012 by Christian Hammers &lt;ch@lathspell.de&gt; and likewise put\n+ * into the Public Domain.\n+ * </p>\n+ * \n+ * @version $Id $\n+ * @since 1.7\n+ */\n+public class Sha2Crypt {\n+\n+    /**\n+     * Default number of rounds if not explicitly specified.\n+     */\n+    private static final int ROUNDS_DEFAULT = 5000;\n+    \n+    /**\n+     * Maximum number of rounds.\n+     */\n+    private static final int ROUNDS_MAX = 999999999;\n+    \n+    /**\n+     * Minimum number of rounds.\n+     */\n+    private static final int ROUNDS_MIN = 1000;\n+    \n+    /**\n+     * Prefix for optional rounds specification.\n+     */\n+    private static final String ROUNDS_PREFIX = \"rounds=\";\n+    \n+    /**\n+     * The MessageDigest algorithm.\n+     */\n+    private static final String SHA256_ALGORITHM = \"SHA-256\";\n+    \n+    /**\n+     * The number of bytes the final hash value will have.\n+     */\n+    private static final int SHA256_BLOCKSIZE = 32;\n+    \n+    /**\n+     * The prefixes that can be used to identify this crypt() variant.\n+     */\n+    static final String SHA256_PREFIX = \"$5$\";\n+    \n+    private static final String SHA512_ALGORITHM = \"SHA-512\";\n+    \n+    private static final int SHA512_BLOCKSIZE = 64;\n+    \n+    static final String SHA512_PREFIX = \"$6$\";\n+\n+    /**\n+     * Generates a libc crypt() compatible \"$5$\" hash value with random salt.\n+     * \n+     * See {@link Crypt#crypt(String, String)} for details.\n+     */\n+    public static String sha256Crypt(byte[] keyBytes) throws Exception {\n+        return sha256Crypt(keyBytes, null);\n+    }\n+\n+    /**\n+     * Generates a libc6 crypt() compatible \"$5$\" hash value.\n+     * \n+     * See {@link Crypt#crypt(String, String)} for details.\n+     */\n+    public static String sha256Crypt(byte[] keyBytes, String salt) throws Exception {\n+        if (salt == null) {\n+            salt = SHA256_PREFIX + B64.getRandomSalt(8);\n+        }\n+        return sha2Crypt(keyBytes, salt, SHA256_PREFIX, SHA256_BLOCKSIZE, SHA256_ALGORITHM);\n+    }\n+\n+    /**\n+     * Generates a libc6 crypt() compatible \"$5$\" or \"$6$\" SHA2 based hash value.\n+     * \n+     * This is a nearly line by line conversion of the original C function. The numbered comments are from the algorithm\n+     * description, the short C-style ones from the original C code and the ones with \"Remark\" from me.\n+     * \n+     * See {@link Crypt#crypt(String, String)} for details.\n+     * \n+     * @param keyBytes\n+     *            The plaintext that should be hashed.\n+     * @param salt_string\n+     *            The real salt value without prefix or \"rounds=\".\n+     * @param saltPrefix\n+     *            Either $5$ or $6$.\n+     * @param blocksize\n+     *            A value that differs between $5$ and $6$.\n+     * @param algorithm\n+     *            The MessageDigest algorithm identifier string.\n+     * @return The complete hash value including prefix and salt.\n+     */\n+    private static String sha2Crypt(byte[] keyBytes, String salt, String saltPrefix, int blocksize, String algorithm)\n+            throws Exception {\n+        int keyLen = keyBytes.length;\n+\n+        // Extracts effective salt and the number of rounds from the given salt.\n+        int rounds = ROUNDS_DEFAULT;\n+        boolean roundsCustom = false;\n+        if (salt == null) {\n+            throw new IllegalArgumentException(\"Invalid salt value: null\");\n+        }\n+        Pattern p = Pattern.compile(\"^\\\\$([56])\\\\$(rounds=(\\\\d+)\\\\$)?([\\\\.\\\\/a-zA-Z0-9]{1,16}).*\");\n+        Matcher m = p.matcher(salt);\n+        if (m == null || !m.find()) {\n+            throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n+        }\n+        if (m.group(3) != null) {\n+            rounds = Integer.valueOf(m.group(3));\n+            rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));\n+            roundsCustom = true;\n+        }\n+        String saltString = m.group(4);\n+        byte[] saltBytes = saltString.getBytes(\"UTF-8\");\n+        int saltLen = saltBytes.length;\n+\n+        // 1. start digest A\n+        // Prepare for the real work.\n+        MessageDigest ctx = MessageDigest.getInstance(algorithm);\n+\n+        // 2. the password string is added to digest A\n+        /*\n+         * Add the key string.\n+         */\n+        ctx.update(keyBytes);\n+\n+        // 3. the salt string is added to digest A. This is just the salt string\n+        // itself without the enclosing '$', without the magic salt_prefix $5$ and\n+        // $6$ respectively and without the rounds=<N> specification.\n+        //\n+        // NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed\n+        // necessary since it is a constant string and does not add security\n+        // and /possibly/ allows a plain text attack. Since the rounds=<N>\n+        // specification should never be added this would also create an\n+        // inconsistency.\n+        /*\n+         * The last part is the salt string. This must be at most 16 characters and it ends at the first `$' character\n+         * (for compatibility with existing implementations).\n+         */\n+        ctx.update(saltBytes);\n+\n+        // 4. start digest B\n+        /*\n+         * Compute alternate sha512 sum with input KEY, SALT, and KEY. The final result will be added to the first\n+         * context.\n+         */\n+        MessageDigest altCtx = MessageDigest.getInstance(algorithm);\n+\n+        // 5. add the password to digest B\n+        /*\n+         * Add key.\n+         */\n+        altCtx.update(keyBytes);\n+\n+        // 6. add the salt string to digest B\n+        /*\n+         * Add salt.\n+         */\n+        altCtx.update(saltBytes);\n+\n+        // 7. add the password again to digest B\n+        /*\n+         * Add key again.\n+         */\n+        altCtx.update(keyBytes);\n+\n+        // 8. finish digest B\n+        /*\n+         * Now get result of this (32 bytes) and add it to the other context.\n+         */\n+        byte[] altResult = altCtx.digest();\n+\n+        // 9. For each block of 32 or 64 bytes in the password string (excluding\n+        // the terminating NUL in the C representation), add digest B to digest A\n+        /*\n+         * Add for any character in the key one byte of the alternate sum.\n+         */\n+        /*\n+         * (Remark: the C code comment seems wrong for key length > 32!)\n+         */\n+        int cnt = keyBytes.length;\n+        while (cnt > blocksize) {\n+            ctx.update(altResult, 0, blocksize);\n+            cnt -= blocksize;\n+        }\n+\n+        // 10. For the remaining N bytes of the password string add the first\n+        // N bytes of digest B to digest A\n+        ctx.update(altResult, 0, cnt);\n+\n+        // 11. For each bit of the binary representation of the length of the\n+        // password string up to and including the highest 1-digit, starting\n+        // from to lowest bit position (numeric value 1):\n+        //\n+        // a) for a 1-digit add digest B to digest A\n+        //\n+        // b) for a 0-digit add the password string\n+        //\n+        // NB: this step differs significantly from the MD5 algorithm. It\n+        // adds more randomness.\n+        /*\n+         * Take the binary representation of the length of the key and for every 1 add the alternate sum, for every 0\n+         * the key.\n+         */\n+        cnt = keyBytes.length;\n+        while (cnt > 0) {\n+            if ((cnt & 1) != 0) {\n+                ctx.update(altResult, 0, blocksize);\n+            } else {\n+                ctx.update(keyBytes);\n+            }\n+            cnt >>= 1;\n+        }\n+\n+        // 12. finish digest A\n+        /*\n+         * Create intermediate result.\n+         */\n+        altResult = ctx.digest();\n+\n+        // 13. start digest DP\n+        /*\n+         * Start computation of P byte sequence.\n+         */\n+        altCtx = MessageDigest.getInstance(algorithm);\n+\n+        // 14. for every byte in the password (excluding the terminating NUL byte\n+        // in the C representation of the string)\n+        //\n+        // add the password to digest DP\n+        /*\n+         * For every character in the password add the entire password.\n+         */\n+        for (int i = 1; i <= keyLen; i++) {\n+            altCtx.update(keyBytes);\n+        }\n+\n+        // 15. finish digest DP\n+        /*\n+         * Finish the digest.\n+         */\n+        byte[] tempResult = altCtx.digest();\n+\n+        // 16. produce byte sequence P of the same length as the password where\n+        //\n+        // a) for each block of 32 or 64 bytes of length of the password string\n+        // the entire digest DP is used\n+        //\n+        // b) for the remaining N (up to 31 or 63) bytes use the first N\n+        // bytes of digest DP\n+        /*\n+         * Create byte sequence P.\n+         */\n+        byte[] pBytes = new byte[keyLen];\n+        int cp = 0;\n+        while (cp < keyLen - blocksize) {\n+            System.arraycopy(tempResult, 0, pBytes, cp, blocksize);\n+            cp += blocksize;\n+        }\n+        System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);\n+\n+        // 17. start digest DS\n+        /*\n+         * Start computation of S byte sequence.\n+         */\n+        altCtx = MessageDigest.getInstance(algorithm);\n+\n+        // 18. repeast the following 16+A[0] times, where A[0] represents the first\n+        // byte in digest A interpreted as an 8-bit unsigned value\n+        //\n+        // add the salt to digest DS\n+        /*\n+         * For every character in the password add the entire password.\n+         */\n+        for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {\n+            altCtx.update(saltBytes);\n+        }\n+\n+        // 19. finish digest DS\n+        /*\n+         * Finish the digest.\n+         */\n+        tempResult = altCtx.digest();\n+\n+        // 20. produce byte sequence S of the same length as the salt string where\n+        //\n+        // a) for each block of 32 or 64 bytes of length of the salt string\n+        // the entire digest DS is used\n+        //\n+        // b) for the remaining N (up to 31 or 63) bytes use the first N\n+        // bytes of digest DS\n+        /*\n+         * Create byte sequence S.\n+         */\n+        // Remark: The salt is limited to 16 chars, how does this make sense?\n+        byte[] sBytes = new byte[saltLen];\n+        cp = 0;\n+        while (cp < saltLen - blocksize) {\n+            System.arraycopy(tempResult, 0, sBytes, cp, blocksize);\n+            cp += blocksize;\n+        }\n+        System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);\n+\n+        // 21. repeat a loop according to the number specified in the rounds=<N>\n+        // specification in the salt (or the default value if none is\n+        // present). Each round is numbered, starting with 0 and up to N-1.\n+        //\n+        // The loop uses a digest as input. In the first round it is the\n+        // digest produced in step 12. In the latter steps it is the digest\n+        // produced in step 21.h. The following text uses the notation\n+        // \"digest A/C\" to desribe this behavior.\n+        /*\n+         * Repeatedly run the collected hash value through sha512 to burn CPU cycles.\n+         */\n+        for (int i = 0; i <= rounds - 1; i++) {\n+            // a) start digest C\n+            /*\n+             * New context.\n+             */\n+            ctx = MessageDigest.getInstance(algorithm);\n+\n+            // b) for odd round numbers add the byte sequense P to digest C\n+            // c) for even round numbers add digest A/C\n+            /*\n+             * Add key or last result.\n+             */\n+            if ((i & 1) != 0) {\n+                ctx.update(pBytes, 0, keyLen);\n+            } else {\n+                ctx.update(altResult, 0, blocksize);\n+            }\n+\n+            // d) for all round numbers not divisible by 3 add the byte sequence S\n+            /*\n+             * Add salt for numbers not divisible by 3.\n+             */\n+            if (i % 3 != 0) {\n+                ctx.update(sBytes, 0, saltLen);\n+            }\n+\n+            // e) for all round numbers not divisible by 7 add the byte sequence P\n+            /*\n+             * Add key for numbers not divisible by 7.\n+             */\n+            if (i % 7 != 0) {\n+                ctx.update(pBytes, 0, keyLen);\n+            }\n+\n+            // f) for odd round numbers add digest A/C\n+            // g) for even round numbers add the byte sequence P\n+            /*\n+             * Add key or last result.\n+             */\n+            if ((i & 1) != 0) {\n+                ctx.update(altResult, 0, blocksize);\n+            } else {\n+                ctx.update(pBytes, 0, keyLen);\n+            }\n+\n+            // h) finish digest C.\n+            /*\n+             * Create intermediate result.\n+             */\n+            altResult = ctx.digest();\n+        }\n+\n+        // 22. Produce the output string. This is an ASCII string of the maximum\n+        // size specified above, consisting of multiple pieces:\n+        //\n+        // a) the salt salt_prefix, $5$ or $6$ respectively\n+        //\n+        // b) the rounds=<N> specification, if one was present in the input\n+        // salt string. A trailing '$' is added in this case to separate\n+        // the rounds specification from the following text.\n+        //\n+        // c) the salt string truncated to 16 characters\n+        //\n+        // d) a '$' character\n+        /*\n+         * Now we can construct the result string. It consists of three parts.\n+         */\n+        StringBuilder buffer = new StringBuilder(saltPrefix + (roundsCustom ? ROUNDS_PREFIX + rounds + \"$\" : \"\")\n+                + saltString + \"$\");\n+\n+        // e) the base-64 encoded final C digest. The encoding used is as\n+        // follows:\n+        // [...]\n+        //\n+        // Each group of three bytes from the digest produces four\n+        // characters as output:\n+        //\n+        // 1. character: the six low bits of the first byte\n+        // 2. character: the two high bits of the first byte and the\n+        // four low bytes from the second byte\n+        // 3. character: the four high bytes from the second byte and\n+        // the two low bits from the third byte\n+        // 4. character: the six high bits from the third byte\n+        //\n+        // The groups of three bytes are as follows (in this sequence).\n+        // These are the indices into the byte array containing the\n+        // digest, starting with index 0. For the last group there are\n+        // not enough bytes left in the digest and the value zero is used\n+        // in its place. This group also produces only three or two\n+        // characters as output for SHA-512 and SHA-512 respectively.\n+\n+        // This was just a safeguard in the C implementation:\n+        // int buflen = salt_prefix.length() - 1 + ROUNDS_PREFIX.length() + 9 + 1 + salt_string.length() + 1 + 86 + 1;\n+\n+        if (blocksize == 32) {\n+            B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);\n+            B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);\n+            B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);\n+            B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);\n+            B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);\n+            B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);\n+            B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);\n+            B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);\n+            B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);\n+            B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);\n+            B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);\n+        } else {\n+            B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);\n+            B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);\n+            B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);\n+            B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);\n+            B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);\n+            B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);\n+            B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);\n+            B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);\n+            B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);\n+            B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);\n+            B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);\n+            B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);\n+            B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);\n+            B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);\n+            B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);\n+            B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);\n+            B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);\n+            B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);\n+            B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);\n+            B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);\n+            B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);\n+            B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);\n+        }\n+\n+        /*\n+         * Clear the buffer for the intermediate result so that people attaching to processes or reading core dumps\n+         * cannot get any information.\n+         */\n+        // Is there a better way to do this with the JVM?\n+        Arrays.fill(tempResult, (byte) 0);\n+        Arrays.fill(pBytes, (byte) 0);\n+        Arrays.fill(sBytes, (byte) 0);\n+        ctx.reset();\n+        altCtx.reset();\n+        Arrays.fill(keyBytes, (byte) 0);\n+        Arrays.fill(saltBytes, (byte) 0);\n+\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * Generates a libc crypt() compatible \"$6$\" hash value with random salt.\n+     * \n+     * See {@link Crypt#crypt(String, String)} for details.\n+     */\n+    public static String sha512Crypt(byte[] keyBytes) throws Exception {\n+        return sha512Crypt(keyBytes, null);\n+    }\n+\n+    /**\n+     * Generates a libc6 crypt() compatible \"$6$\" hash value.\n+     * \n+     * See {@link Crypt#crypt(String, String)} for details.\n+     */\n+    public static String sha512Crypt(byte[] keyBytes, String salt) throws Exception {\n+        if (salt == null) {\n+            salt = SHA512_PREFIX + B64.getRandomSalt(8);\n+        }\n+        return sha2Crypt(keyBytes, salt, SHA512_PREFIX, SHA512_BLOCKSIZE, SHA512_ALGORITHM);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/digest/UnixCrypt.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.codec.Charsets;\n+\n+/**\n+ * Unix crypt(3) algorithm implementation.\n+ *\n+ * This class only implements the traditional 56 bit DES based algorithm. Please\n+ * use DigestUtils.crypt() for a method that distinguishes between all the\n+ * algorithms supported in the current glibc's crypt().\n+ *\n+ * The Java implementation was taken from the JetSpeed Portal project (see\n+ * org.apache.jetspeed.services.security.ldap.UnixCrypt).\n+ *\n+ * This class is slightly incompatible if the given salt contains characters\n+ * that are not part of the allowed range [a-zA-Z0-9./].\n+ *\n+ * @version $Id $\n+ * @since 1.7\n+ */\n+public class UnixCrypt {\n+\n+    private static final int CON_SALT[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 1, 2, 3,\n+        4, 5, 6, 7, 8, 9, 10, 11, 5, 6,\n+        7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+        17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\n+        27, 28, 29, 30, 31, 32, 33, 34, 35, 36,\n+        37, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n+        41, 42, 43, 44, 45, 46, 47, 48, 49, 50,\n+        51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\n+        61, 62, 63, 0, 0, 0, 0, 0\n+    };\n+    \n+    private static final int COV2CHAR[] = {\n+        46, 47, 48, 49, 50, 51, 52, 53, 54, 55,\n+        56, 57, 65, 66, 67, 68, 69, 70, 71, 72,\n+        73, 74, 75, 76, 77, 78, 79, 80, 81, 82,\n+        83, 84, 85, 86, 87, 88, 89, 90, 97, 98,\n+        99, 100, 101, 102, 103, 104, 105, 106, 107, 108,\n+        109, 110, 111, 112, 113, 114, 115, 116, 117, 118,\n+        119, 120, 121, 122\n+    };\n+    \n+    private static final char SALT_CHARS[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./\".toCharArray();\n+    \n+    private static final boolean SHIFT2[] = {\n+        false, false, true, true, true, true, true, true, false, true,\n+        true, true, true, true, true, false\n+    };\n+    \n+    private static final int SKB[][] = {\n+        {\n+            0, 16, 0x20000000, 0x20000010, 0x10000, 0x10010, 0x20010000, 0x20010010, 2048, 2064,\n+            0x20000800, 0x20000810, 0x10800, 0x10810, 0x20010800, 0x20010810, 32, 48, 0x20000020, 0x20000030,\n+            0x10020, 0x10030, 0x20010020, 0x20010030, 2080, 2096, 0x20000820, 0x20000830, 0x10820, 0x10830,\n+            0x20010820, 0x20010830, 0x80000, 0x80010, 0x20080000, 0x20080010, 0x90000, 0x90010, 0x20090000, 0x20090010,\n+            0x80800, 0x80810, 0x20080800, 0x20080810, 0x90800, 0x90810, 0x20090800, 0x20090810, 0x80020, 0x80030,\n+            0x20080020, 0x20080030, 0x90020, 0x90030, 0x20090020, 0x20090030, 0x80820, 0x80830, 0x20080820, 0x20080830,\n+            0x90820, 0x90830, 0x20090820, 0x20090830\n+        }, {\n+            0, 0x2000000, 8192, 0x2002000, 0x200000, 0x2200000, 0x202000, 0x2202000, 4, 0x2000004,\n+            8196, 0x2002004, 0x200004, 0x2200004, 0x202004, 0x2202004, 1024, 0x2000400, 9216, 0x2002400,\n+            0x200400, 0x2200400, 0x202400, 0x2202400, 1028, 0x2000404, 9220, 0x2002404, 0x200404, 0x2200404,\n+            0x202404, 0x2202404, 0x10000000, 0x12000000, 0x10002000, 0x12002000, 0x10200000, 0x12200000, 0x10202000, 0x12202000,\n+            0x10000004, 0x12000004, 0x10002004, 0x12002004, 0x10200004, 0x12200004, 0x10202004, 0x12202004, 0x10000400, 0x12000400,\n+            0x10002400, 0x12002400, 0x10200400, 0x12200400, 0x10202400, 0x12202400, 0x10000404, 0x12000404, 0x10002404, 0x12002404,\n+            0x10200404, 0x12200404, 0x10202404, 0x12202404\n+        }, {\n+            0, 1, 0x40000, 0x40001, 0x1000000, 0x1000001, 0x1040000, 0x1040001, 2, 3,\n+            0x40002, 0x40003, 0x1000002, 0x1000003, 0x1040002, 0x1040003, 512, 513, 0x40200, 0x40201,\n+            0x1000200, 0x1000201, 0x1040200, 0x1040201, 514, 515, 0x40202, 0x40203, 0x1000202, 0x1000203,\n+            0x1040202, 0x1040203, 0x8000000, 0x8000001, 0x8040000, 0x8040001, 0x9000000, 0x9000001, 0x9040000, 0x9040001,\n+            0x8000002, 0x8000003, 0x8040002, 0x8040003, 0x9000002, 0x9000003, 0x9040002, 0x9040003, 0x8000200, 0x8000201,\n+            0x8040200, 0x8040201, 0x9000200, 0x9000201, 0x9040200, 0x9040201, 0x8000202, 0x8000203, 0x8040202, 0x8040203,\n+            0x9000202, 0x9000203, 0x9040202, 0x9040203\n+        }, {\n+            0, 0x100000, 256, 0x100100, 8, 0x100008, 264, 0x100108, 4096, 0x101000,\n+            4352, 0x101100, 4104, 0x101008, 4360, 0x101108, 0x4000000, 0x4100000, 0x4000100, 0x4100100,\n+            0x4000008, 0x4100008, 0x4000108, 0x4100108, 0x4001000, 0x4101000, 0x4001100, 0x4101100, 0x4001008, 0x4101008,\n+            0x4001108, 0x4101108, 0x20000, 0x120000, 0x20100, 0x120100, 0x20008, 0x120008, 0x20108, 0x120108,\n+            0x21000, 0x121000, 0x21100, 0x121100, 0x21008, 0x121008, 0x21108, 0x121108, 0x4020000, 0x4120000,\n+            0x4020100, 0x4120100, 0x4020008, 0x4120008, 0x4020108, 0x4120108, 0x4021000, 0x4121000, 0x4021100, 0x4121100,\n+            0x4021008, 0x4121008, 0x4021108, 0x4121108\n+        }, {\n+            0, 0x10000000, 0x10000, 0x10010000, 4, 0x10000004, 0x10004, 0x10010004, 0x20000000, 0x30000000,\n+            0x20010000, 0x30010000, 0x20000004, 0x30000004, 0x20010004, 0x30010004, 0x100000, 0x10100000, 0x110000, 0x10110000,\n+            0x100004, 0x10100004, 0x110004, 0x10110004, 0x20100000, 0x30100000, 0x20110000, 0x30110000, 0x20100004, 0x30100004,\n+            0x20110004, 0x30110004, 4096, 0x10001000, 0x11000, 0x10011000, 4100, 0x10001004, 0x11004, 0x10011004,\n+            0x20001000, 0x30001000, 0x20011000, 0x30011000, 0x20001004, 0x30001004, 0x20011004, 0x30011004, 0x101000, 0x10101000,\n+            0x111000, 0x10111000, 0x101004, 0x10101004, 0x111004, 0x10111004, 0x20101000, 0x30101000, 0x20111000, 0x30111000,\n+            0x20101004, 0x30101004, 0x20111004, 0x30111004\n+        }, {\n+            0, 0x8000000, 8, 0x8000008, 1024, 0x8000400, 1032, 0x8000408, 0x20000, 0x8020000,\n+            0x20008, 0x8020008, 0x20400, 0x8020400, 0x20408, 0x8020408, 1, 0x8000001, 9, 0x8000009,\n+            1025, 0x8000401, 1033, 0x8000409, 0x20001, 0x8020001, 0x20009, 0x8020009, 0x20401, 0x8020401,\n+            0x20409, 0x8020409, 0x2000000, 0xa000000, 0x2000008, 0xa000008, 0x2000400, 0xa000400, 0x2000408, 0xa000408,\n+            0x2020000, 0xa020000, 0x2020008, 0xa020008, 0x2020400, 0xa020400, 0x2020408, 0xa020408, 0x2000001, 0xa000001,\n+            0x2000009, 0xa000009, 0x2000401, 0xa000401, 0x2000409, 0xa000409, 0x2020001, 0xa020001, 0x2020009, 0xa020009,\n+            0x2020401, 0xa020401, 0x2020409, 0xa020409\n+        }, {\n+            0, 256, 0x80000, 0x80100, 0x1000000, 0x1000100, 0x1080000, 0x1080100, 16, 272,\n+            0x80010, 0x80110, 0x1000010, 0x1000110, 0x1080010, 0x1080110, 0x200000, 0x200100, 0x280000, 0x280100,\n+            0x1200000, 0x1200100, 0x1280000, 0x1280100, 0x200010, 0x200110, 0x280010, 0x280110, 0x1200010, 0x1200110,\n+            0x1280010, 0x1280110, 512, 768, 0x80200, 0x80300, 0x1000200, 0x1000300, 0x1080200, 0x1080300,\n+            528, 784, 0x80210, 0x80310, 0x1000210, 0x1000310, 0x1080210, 0x1080310, 0x200200, 0x200300,\n+            0x280200, 0x280300, 0x1200200, 0x1200300, 0x1280200, 0x1280300, 0x200210, 0x200310, 0x280210, 0x280310,\n+            0x1200210, 0x1200310, 0x1280210, 0x1280310\n+        }, {\n+            0, 0x4000000, 0x40000, 0x4040000, 2, 0x4000002, 0x40002, 0x4040002, 8192, 0x4002000,\n+            0x42000, 0x4042000, 8194, 0x4002002, 0x42002, 0x4042002, 32, 0x4000020, 0x40020, 0x4040020,\n+            34, 0x4000022, 0x40022, 0x4040022, 8224, 0x4002020, 0x42020, 0x4042020, 8226, 0x4002022,\n+            0x42022, 0x4042022, 2048, 0x4000800, 0x40800, 0x4040800, 2050, 0x4000802, 0x40802, 0x4040802,\n+            10240, 0x4002800, 0x42800, 0x4042800, 10242, 0x4002802, 0x42802, 0x4042802, 2080, 0x4000820,\n+            0x40820, 0x4040820, 2082, 0x4000822, 0x40822, 0x4040822, 10272, 0x4002820, 0x42820, 0x4042820,\n+            10274, 0x4002822, 0x42822, 0x4042822\n+        }\n+    };\n+    \n+    private static final int SPTRANS[][] = {\n+        {\n+            0x820200, 0x20000, 0x80800000, 0x80820200, 0x800000, 0x80020200, 0x80020000, 0x80800000, 0x80020200, 0x820200,\n+            0x820000, 0x80000200, 0x80800200, 0x800000, 0, 0x80020000, 0x20000, 0x80000000, 0x800200, 0x20200,\n+            0x80820200, 0x820000, 0x80000200, 0x800200, 0x80000000, 512, 0x20200, 0x80820000, 512, 0x80800200,\n+            0x80820000, 0, 0, 0x80820200, 0x800200, 0x80020000, 0x820200, 0x20000, 0x80000200, 0x800200,\n+            0x80820000, 512, 0x20200, 0x80800000, 0x80020200, 0x80000000, 0x80800000, 0x820000, 0x80820200, 0x20200,\n+            0x820000, 0x80800200, 0x800000, 0x80000200, 0x80020000, 0, 0x20000, 0x800000, 0x80800200, 0x820200,\n+            0x80000000, 0x80820000, 512, 0x80020200\n+        }, {\n+            0x10042004, 0, 0x42000, 0x10040000, 0x10000004, 8196, 0x10002000, 0x42000, 8192, 0x10040004,\n+            4, 0x10002000, 0x40004, 0x10042000, 0x10040000, 4, 0x40000, 0x10002004, 0x10040004, 8192,\n+            0x42004, 0x10000000, 0, 0x40004, 0x10002004, 0x42004, 0x10042000, 0x10000004, 0x10000000, 0x40000,\n+            8196, 0x10042004, 0x40004, 0x10042000, 0x10002000, 0x42004, 0x10042004, 0x40004, 0x10000004, 0,\n+            0x10000000, 8196, 0x40000, 0x10040004, 8192, 0x10000000, 0x42004, 0x10002004, 0x10042000, 8192,\n+            0, 0x10000004, 4, 0x10042004, 0x42000, 0x10040000, 0x10040004, 0x40000, 8196, 0x10002000,\n+            0x10002004, 4, 0x10040000, 0x42000\n+        }, {\n+            0x41000000, 0x1010040, 64, 0x41000040, 0x40010000, 0x1000000, 0x41000040, 0x10040, 0x1000040, 0x10000,\n+            0x1010000, 0x40000000, 0x41010040, 0x40000040, 0x40000000, 0x41010000, 0, 0x40010000, 0x1010040, 64,\n+            0x40000040, 0x41010040, 0x10000, 0x41000000, 0x41010000, 0x1000040, 0x40010040, 0x1010000, 0x10040, 0,\n+            0x1000000, 0x40010040, 0x1010040, 64, 0x40000000, 0x10000, 0x40000040, 0x40010000, 0x1010000, 0x41000040,\n+            0, 0x1010040, 0x10040, 0x41010000, 0x40010000, 0x1000000, 0x41010040, 0x40000000, 0x40010040, 0x41000000,\n+            0x1000000, 0x41010040, 0x10000, 0x1000040, 0x41000040, 0x10040, 0x1000040, 0, 0x41010000, 0x40000040,\n+            0x41000000, 0x40010040, 64, 0x1010000\n+        }, {\n+            0x100402, 0x4000400, 2, 0x4100402, 0, 0x4100000, 0x4000402, 0x100002, 0x4100400, 0x4000002,\n+            0x4000000, 1026, 0x4000002, 0x100402, 0x100000, 0x4000000, 0x4100002, 0x100400, 1024, 2,\n+            0x100400, 0x4000402, 0x4100000, 1024, 1026, 0, 0x100002, 0x4100400, 0x4000400, 0x4100002,\n+            0x4100402, 0x100000, 0x4100002, 1026, 0x100000, 0x4000002, 0x100400, 0x4000400, 2, 0x4100000,\n+            0x4000402, 0, 1024, 0x100002, 0, 0x4100002, 0x4100400, 1024, 0x4000000, 0x4100402,\n+            0x100402, 0x100000, 0x4100402, 2, 0x4000400, 0x100402, 0x100002, 0x100400, 0x4100000, 0x4000402,\n+            1026, 0x4000000, 0x4000002, 0x4100400\n+        }, {\n+            0x2000000, 16384, 256, 0x2004108, 0x2004008, 0x2000100, 16648, 0x2004000, 16384, 8,\n+            0x2000008, 16640, 0x2000108, 0x2004008, 0x2004100, 0, 16640, 0x2000000, 16392, 264,\n+            0x2000100, 16648, 0, 0x2000008, 8, 0x2000108, 0x2004108, 16392, 0x2004000, 256,\n+            264, 0x2004100, 0x2004100, 0x2000108, 16392, 0x2004000, 16384, 8, 0x2000008, 0x2000100,\n+            0x2000000, 16640, 0x2004108, 0, 16648, 0x2000000, 256, 16392, 0x2000108, 256,\n+            0, 0x2004108, 0x2004008, 0x2004100, 264, 16384, 16640, 0x2004008, 0x2000100, 264,\n+            8, 16648, 0x2004000, 0x2000008\n+        }, {\n+            0x20000010, 0x80010, 0, 0x20080800, 0x80010, 2048, 0x20000810, 0x80000, 2064, 0x20080810,\n+            0x80800, 0x20000000, 0x20000800, 0x20000010, 0x20080000, 0x80810, 0x80000, 0x20000810, 0x20080010, 0,\n+            2048, 16, 0x20080800, 0x20080010, 0x20080810, 0x20080000, 0x20000000, 2064, 16, 0x80800,\n+            0x80810, 0x20000800, 2064, 0x20000000, 0x20000800, 0x80810, 0x20080800, 0x80010, 0, 0x20000800,\n+            0x20000000, 2048, 0x20080010, 0x80000, 0x80010, 0x20080810, 0x80800, 16, 0x20080810, 0x80800,\n+            0x80000, 0x20000810, 0x20000010, 0x20080000, 0x80810, 0, 2048, 0x20000010, 0x20000810, 0x20080800,\n+            0x20080000, 2064, 16, 0x20080010\n+        }, {\n+            4096, 128, 0x400080, 0x400001, 0x401081, 4097, 4224, 0, 0x400000, 0x400081,\n+            129, 0x401000, 1, 0x401080, 0x401000, 129, 0x400081, 4096, 4097, 0x401081,\n+            0, 0x400080, 0x400001, 4224, 0x401001, 4225, 0x401080, 1, 4225, 0x401001,\n+            128, 0x400000, 4225, 0x401000, 0x401001, 129, 4096, 128, 0x400000, 0x401001,\n+            0x400081, 4225, 4224, 0, 128, 0x400001, 1, 0x400080, 0, 0x400081,\n+            0x400080, 4224, 129, 4096, 0x401081, 0x400000, 0x401080, 1, 4097, 0x401081,\n+            0x400001, 0x401080, 0x401000, 4097\n+        }, {\n+            0x8200020, 0x8208000, 32800, 0, 0x8008000, 0x200020, 0x8200000, 0x8208020, 32, 0x8000000,\n+            0x208000, 32800, 0x208020, 0x8008020, 0x8000020, 0x8200000, 32768, 0x208020, 0x200020, 0x8008000,\n+            0x8208020, 0x8000020, 0, 0x208000, 0x8000000, 0x200000, 0x8008020, 0x8200020, 0x200000, 32768,\n+            0x8208000, 32, 0x200000, 32768, 0x8000020, 0x8208020, 32800, 0x8000000, 0, 0x208000,\n+            0x8200020, 0x8008020, 0x8008000, 0x200020, 0x8208000, 32, 0x200020, 0x8008000, 0x8208020, 0x200000,\n+            0x8200000, 0x8000020, 0x208000, 32800, 0x8008020, 0x8200000, 32, 0x8208000, 0x208020, 0,\n+            0x8000000, 0x8200020, 32768, 0x208020\n+        }\n+    };\n+\n+    private static int[] body(int schedule[], int eSwap0, int eSwap1) {\n+        int left = 0;\n+        int right = 0;\n+        int t = 0;\n+        for (int j = 0; j < 25; j++) {\n+            for (int i = 0; i < 32; i += 4) {\n+                left = dEncrypt(left, right, i, eSwap0, eSwap1, schedule);\n+                right = dEncrypt(right, left, i + 2, eSwap0, eSwap1, schedule);\n+            }\n+            t = left;\n+            left = right;\n+            right = t;\n+        }\n+\n+        t = right;\n+        right = left >>> 1 | left << 31;\n+        left = t >>> 1 | t << 31;\n+        left &= 0xffffffff;\n+        right &= 0xffffffff;\n+        int results[] = new int[2];\n+        permOp(right, left, 1, 0x55555555, results);\n+        right = results[0];\n+        left = results[1];\n+        permOp(left, right, 8, 0xff00ff, results);\n+        left = results[0];\n+        right = results[1];\n+        permOp(right, left, 2, 0x33333333, results);\n+        right = results[0];\n+        left = results[1];\n+        permOp(left, right, 16, 65535, results);\n+        left = results[0];\n+        right = results[1];\n+        permOp(right, left, 4, 0xf0f0f0f, results);\n+        right = results[0];\n+        left = results[1];\n+        int out[] = new int[2];\n+        out[0] = left;\n+        out[1] = right;\n+        return out;\n+    }\n+\n+    private static int byteToUnsigned(byte b) {\n+        int value = b;\n+        return value < 0 ? value + 256 : value;\n+    }\n+\n+    private static int dEncrypt(int el, int r, int s, int e0, int e1, int sArr[]) {\n+        int v = r ^ r >>> 16;\n+        int u = v & e0;\n+        v &= e1;\n+        u = u ^ u << 16 ^ r ^ sArr[s];\n+        int t = v ^ v << 16 ^ r ^ sArr[s + 1];\n+        t = t >>> 4 | t << 28;\n+        el ^= SPTRANS[1][t & 0x3f] | SPTRANS[3][t >>> 8 & 0x3f] | SPTRANS[5][t >>> 16 & 0x3f]\n+                | SPTRANS[7][t >>> 24 & 0x3f] | SPTRANS[0][u & 0x3f] | SPTRANS[2][u >>> 8 & 0x3f]\n+                | SPTRANS[4][u >>> 16 & 0x3f] | SPTRANS[6][u >>> 24 & 0x3f];\n+        return el;\n+    }\n+\n+    private static int[] desSetKey(byte key[]) {\n+        int schedule[] = new int[32];\n+        int c = fourBytesToInt(key, 0);\n+        int d = fourBytesToInt(key, 4);\n+        int results[] = new int[2];\n+        permOp(d, c, 4, 0xf0f0f0f, results);\n+        d = results[0];\n+        c = results[1];\n+        c = hPermOp(c, -2, 0xcccc0000);\n+        d = hPermOp(d, -2, 0xcccc0000);\n+        permOp(d, c, 1, 0x55555555, results);\n+        d = results[0];\n+        c = results[1];\n+        permOp(c, d, 8, 0xff00ff, results);\n+        c = results[0];\n+        d = results[1];\n+        permOp(d, c, 1, 0x55555555, results);\n+        d = results[0];\n+        c = results[1];\n+        d = (d & 0xff) << 16 | d & 0xff00 | (d & 0xff0000) >>> 16 | (c & 0xf0000000) >>> 4;\n+        c &= 0xfffffff;\n+        int j = 0;\n+        for (int i = 0; i < 16; i++) {\n+            if (SHIFT2[i]) {\n+                c = c >>> 2 | c << 26;\n+                d = d >>> 2 | d << 26;\n+            } else {\n+                c = c >>> 1 | c << 27;\n+                d = d >>> 1 | d << 27;\n+            }\n+            c &= 0xfffffff;\n+            d &= 0xfffffff;\n+            int s = SKB[0][c & 0x3f] | SKB[1][c >>> 6 & 0x3 | c >>> 7 & 0x3c] | SKB[2][c >>> 13 & 0xf | c >>> 14 & 0x30] | SKB[3][c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38];\n+            int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] | SKB[7][d >>> 21 & 0xf | d >>> 22 & 0x30];\n+            schedule[j++] = (t << 16 | s & 0xffff) & 0xffffffff;\n+            s = s >>> 16 | t & 0xffff0000;\n+            s = s << 4 | s >>> 28;\n+            schedule[j++] = s & 0xffffffff;\n+        }\n+\n+        return schedule;\n+    }\n+\n+    private static int fourBytesToInt(byte b[], int offset) {\n+        int value = byteToUnsigned(b[offset++]);\n+        value |= byteToUnsigned(b[offset++]) << 8;\n+        value |= byteToUnsigned(b[offset++]) << 16;\n+        value |= byteToUnsigned(b[offset++]) << 24;\n+        return value;\n+    }\n+\n+    private static int hPermOp(int a, int n, int m) {\n+        int t = (a << 16 - n ^ a) & m;\n+        a = a ^ t ^ t >>> 16 - n;\n+        return a;\n+    }\n+\n+    private static void intToFourBytes(int iValue, byte b[], int offset) {\n+        b[offset++] = (byte) (iValue & 0xff);\n+        b[offset++] = (byte) (iValue >>> 8 & 0xff);\n+        b[offset++] = (byte) (iValue >>> 16 & 0xff);\n+        b[offset++] = (byte) (iValue >>> 24 & 0xff);\n+    }\n+\n+    private static void permOp(int a, int b, int n, int m, int results[]) {\n+        int t = (a >>> n ^ b) & m;\n+        a ^= t << n;\n+        b ^= t;\n+        results[0] = a;\n+        results[1] = b;\n+    }\n+\n+    /**\n+     * Generates a crypt(3) compatible hash using the DES algorithm.\n+     *\n+     * As no salt is given, a random one will be used.\n+     *\n+     * @param original Plaintext password\n+     *\n+     * @return A 13 character string starting with the salt string.\n+     */\n+    public static String crypt(byte[] original) {\n+        return crypt(original, null);\n+    }\n+\n+    /**\n+     * Generates a crypt(3) compatible hash using the DES algorithm.\n+     *\n+     * Using unspecified characters as salt results incompatible hash values.\n+     *\n+     * @param original Plaintext password\n+     *\n+     * @param salt A two character string drawn from [a-zA-Z0-9./] or null for a\n+     * random one.\n+     *\n+     * @return A 13 character string starting with the salt string.\n+     */\n+    public static String crypt(byte[] original, String salt) {\n+        if (salt == null) {\n+            Random randomGenerator = new Random();\n+            int numSaltChars = SALT_CHARS.length;\n+            salt = \"\" + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[Math.abs(randomGenerator.nextInt()) % numSaltChars];\n+        } else if (!salt.matches(\"^[\" + B64.B64T + \"]{2,}$\")) {\n+            throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\n+        }\n+\n+        for (; salt.length() < 2; salt = salt + \"A\");\n+        StringBuilder buffer = new StringBuilder(\"             \");\n+        char charZero = salt.charAt(0);\n+        char charOne = salt.charAt(1);\n+        buffer.setCharAt(0, charZero);\n+        buffer.setCharAt(1, charOne);\n+        int eSwap0 = CON_SALT[charZero];\n+        int eSwap1 = CON_SALT[charOne] << 4;\n+        byte key[] = new byte[8];\n+        for (int i = 0; i < key.length; i++) {\n+            key[i] = 0;\n+        }\n+\n+        for (int i = 0; i < key.length && i < original.length; i++) {\n+            int iChar = original[i];\n+            key[i] = (byte) (iChar << 1);\n+        }\n+\n+        int schedule[] = desSetKey(key);\n+        int out[] = body(schedule, eSwap0, eSwap1);\n+        byte b[] = new byte[9];\n+        intToFourBytes(out[0], b, 0);\n+        intToFourBytes(out[1], b, 4);\n+        b[8] = 0;\n+        int i = 2;\n+        int y = 0;\n+        int u = 128;\n+        for (; i < 13; i++) {\n+            int j = 0;\n+            int c = 0;\n+            for (; j < 6; j++) {\n+                c <<= 1;\n+                if ((b[y] & u) != 0) {\n+                    c |= 0x1;\n+                }\n+                u >>>= 1;\n+                if (u == 0) {\n+                    y++;\n+                    u = 128;\n+                }\n+                buffer.setCharAt(i, (char) COV2CHAR[c]);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * Generates a crypt(3) compatible hash using the DES algorithm.\n+     *\n+     * As no salt is given, a random one is used.\n+     *\n+     * @param original Plaintext password\n+     *\n+     * @return A 13 character string starting with the salt string.\n+     */\n+    public static String crypt(String original) throws Exception {\n+        return crypt(original.getBytes(Charsets.UTF_8));\n+    }\n+\n+    /**\n+     * Generates a crypt(3) compatible hash using the DES algorithm.\n+     *\n+     * @param original Plaintext password\n+     * @param salt A two character string drawn from [a-zA-Z0-9./] or null for a\n+     * random one.\n+     * @return A 13 character string starting with the salt string.\n+     */\n+    public static String crypt(String original, String salt) throws Exception {\n+        return crypt(original.getBytes(Charsets.UTF_8), salt);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/digest/Apr1CryptTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+\n+public class Apr1CryptTest {\n+\n+    @Test\n+    public void testApr1CryptStrings() throws Exception {\n+        // A random example using htpasswd\n+        assertEquals(\"$apr1$TqI9WECO$LHZB2DqRlk9nObiB6vJG9.\", Md5Crypt.apr1Crypt(\"secret\", \"$apr1$TqI9WECO\"));\n+        // empty data\n+        assertEquals(\"$apr1$foo$P27KyD1htb4EllIPEYhqi0\", Md5Crypt.apr1Crypt(\"\", \"$apr1$foo\"));\n+        // salt gets cut at dollar sign\n+        assertEquals(\"$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1\", Md5Crypt.apr1Crypt(\"secret\", \"$apr1$1234\"));\n+        assertEquals(\"$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1\", Md5Crypt.apr1Crypt(\"secret\", \"$apr1$1234$567\"));\n+        assertEquals(\"$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1\", Md5Crypt.apr1Crypt(\"secret\", \"$apr1$1234$567$890\"));\n+        // salt gets cut at maximum length\n+        assertEquals(\"$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0\", Md5Crypt.apr1Crypt(\"secret\", \"$apr1$1234567890123456\"));\n+        assertEquals(\"$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0\", Md5Crypt.apr1Crypt(\"secret\", \"$apr1$123456789012345678\"));\n+    }\n+\n+    @Test\n+    public void testApr1CryptBytes() throws Exception {\n+        // An empty Bytearray equals an empty String\n+        assertEquals(\"$apr1$foo$P27KyD1htb4EllIPEYhqi0\", Md5Crypt.apr1Crypt(new byte[0], \"$apr1$foo\"));\n+        // UTF-8 stores \\u00e4 \"a with diaeresis\" as two bytes 0xc3 0xa4.\n+        assertEquals(\"$apr1$./$EeFrYzWWbmTyGdf4xULYc.\", Md5Crypt.apr1Crypt(\"t\\u00e4st\", \"$apr1$./$\"));\n+        // ISO-8859-1 stores \"a with diaeresis\" as single byte 0xe4.\n+        assertEquals(\"$apr1$./$kCwT1pY9qXAJElYG9q1QE1\", Md5Crypt.apr1Crypt(\"t\\u00e4st\".getBytes(\"ISO-8859-1\"), \"$apr1$./$\"));\n+    }\n+\n+    @Test\n+    public void testApr1CryptExplicitCall() throws Exception {\n+        // When explicitly called the prefix is optional\n+        assertEquals(\"$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1\", Md5Crypt.apr1Crypt(\"secret\", \"1234\"));\n+        // When explicitly called without salt, a random one will be used.\n+        assertTrue(Md5Crypt.apr1Crypt(\"secret\".getBytes()).matches(\"^\\\\$apr1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\"));\n+        assertTrue(Md5Crypt.apr1Crypt(\"secret\".getBytes(), null).matches(\"^\\\\$apr1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\"));\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testApr1CryptNullData() throws Exception {\n+        Md5Crypt.apr1Crypt((byte[]) null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testApr1CryptWithEmptySalt() throws Exception {\n+        Md5Crypt.apr1Crypt(\"secret\".getBytes(), \"\");\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/digest/B64Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import static org.junit.Assert.assertEquals;\n+import org.junit.Test;\n+\n+public class B64Test {\n+\n+    @Test\n+    public void testB64from24bit() {\n+        StringBuilder buffer = new StringBuilder(\"\");\n+        B64.b64from24bit((byte) 8, (byte) 16, (byte) 64, 2, buffer);\n+        B64.b64from24bit((byte) 7, (byte) 77, (byte) 120, 4, buffer);\n+        assertEquals(\"./spo/\", buffer.toString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/digest/CryptTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+\n+public class CryptTest {\n+\n+    @Test\n+    public void testDefaultCryptVariant() throws Exception {\n+        // If salt is null or completely omitted, a random \"$6$\" is used.\n+        assertTrue(Crypt.crypt(\"secret\").startsWith(\"$6$\"));\n+        assertTrue(Crypt.crypt(\"secret\", null).startsWith(\"$6$\"));\n+    }\n+\n+    /**\n+     * An empty string as salt is invalid.\n+     *\n+     * The C and Perl implementations return an empty string, PHP threads it\n+     * as NULL. Our implementation should throw an Exception as any resulting\n+     * hash would not be verifyable with other implementations of crypt().\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testCryptWithEmptySalt() throws Exception {\n+        Crypt.crypt(\"secret\", \"\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/digest/Md5CryptTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+\n+public class Md5CryptTest {\n+\n+    @Test\n+    public void testMd5CryptStrings() throws Exception {\n+        // empty data\n+        assertEquals(\"$1$foo$9mS5ExwgIECGE5YKlD5o91\", Crypt.crypt(\"\", \"$1$foo\"));\n+        // salt gets cut at dollar sign\n+        assertEquals(\"$1$1234$ImZYBLmYC.rbBKg9ERxX70\", Crypt.crypt(\"secret\", \"$1$1234\"));\n+        assertEquals(\"$1$1234$ImZYBLmYC.rbBKg9ERxX70\", Crypt.crypt(\"secret\", \"$1$1234$567\"));\n+        assertEquals(\"$1$1234$ImZYBLmYC.rbBKg9ERxX70\", Crypt.crypt(\"secret\", \"$1$1234$567$890\"));\n+        // salt gets cut at maximum length\n+        assertEquals(\"$1$12345678$hj0uLpdidjPhbMMZeno8X/\", Crypt.crypt(\"secret\", \"$1$1234567890123456\"));\n+        assertEquals(\"$1$12345678$hj0uLpdidjPhbMMZeno8X/\", Crypt.crypt(\"secret\", \"$1$123456789012345678\"));\n+    }\n+\n+    @Test\n+    public void testMd5CryptBytes() throws Exception {\n+        // An empty Bytearray equals an empty String\n+        assertEquals(\"$1$foo$9mS5ExwgIECGE5YKlD5o91\", Crypt.crypt(new byte[0], \"$1$foo\"));\n+        // UTF-8 stores \\u00e4 \"a with diaeresis\" as two bytes 0xc3 0xa4.\n+        assertEquals(\"$1$./$52agTEQZs877L9jyJnCNZ1\", Crypt.crypt(\"t\\u00e4st\", \"$1$./$\"));\n+        // ISO-8859-1 stores \"a with diaeresis\" as single byte 0xe4.\n+        assertEquals(\"$1$./$J2UbKzGe0Cpe63WZAt6p//\", Crypt.crypt(\"t\\u00e4st\".getBytes(\"ISO-8859-1\"), \"$1$./$\"));\n+    }\n+\n+    @Test\n+    public void testMd5CryptExplicitCall() throws Exception {\n+        assertTrue(Md5Crypt.md5Crypt(\"secret\".getBytes()).matches(\"^\\\\$1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\"));\n+        assertTrue(Md5Crypt.md5Crypt(\"secret\".getBytes(), null).matches(\"^\\\\$1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\"));\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testMd5CryptNullData() throws Exception {\n+        Md5Crypt.md5Crypt((byte[]) null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testMd5CryptWithEmptySalt() throws Exception {\n+        Md5Crypt.md5Crypt(\"secret\".getBytes(), \"\");\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/digest/Sha256CryptTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+\n+public class Sha256CryptTest {\n+\n+    @Test\n+    public void testSha256CryptStrings() throws Exception {\n+        // empty data\n+        assertEquals(\"$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B\", Crypt.crypt(\"\", \"$5$foo\"));\n+        // salt gets cut at dollar sign\n+        assertEquals(\"$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/\", Crypt.crypt(\"secret\", \"$5$45678\"));\n+        assertEquals(\"$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/\", Crypt.crypt(\"secret\", \"$5$45678$012\"));\n+        assertEquals(\"$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/\", Crypt.crypt(\"secret\", \"$5$45678$012$456\"));\n+        // salt gets cut at maximum length\n+        assertEquals(\"$5$1234567890123456$GUiFKBSTUAGvcK772ulTDPltkTOLtFvPOmp9o.9FNPB\", Crypt.crypt(\"secret\", \"$5$1234567890123456\"));\n+        assertEquals(\"$5$1234567890123456$GUiFKBSTUAGvcK772ulTDPltkTOLtFvPOmp9o.9FNPB\", Crypt.crypt(\"secret\", \"$5$1234567890123456789\"));\n+    }\n+\n+    @Test\n+    public void testSha256CryptBytes() throws Exception {\n+        // An empty Bytearray equals an empty String\n+        assertEquals(\"$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B\", Crypt.crypt(new byte[0], \"$5$foo\"));\n+        // UTF-8 stores \\u00e4 \"a with diaeresis\" as two bytes 0xc3 0xa4.\n+        assertEquals(\"$5$./$iH66LwY5sTDTdHeOxq5nvNDVAxuoCcyH/y6Ptte82P8\", Crypt.crypt(\"t\\u00e4st\", \"$5$./$\"));\n+        // ISO-8859-1 stores \"a with diaeresis\" as single byte 0xe4.\n+        assertEquals(\"$5$./$qx5gFfCzjuWUOvsDDy.5Nor3UULPIqLVBZhgGNS0c14\", Crypt.crypt(\"t\\u00e4st\".getBytes(\"ISO-8859-1\"), \"$5$./$\"));\n+    }\n+\n+    @Test\n+    public void testSha256CryptExplicitCall() throws Exception {\n+        assertTrue(Sha2Crypt.sha256Crypt(\"secret\".getBytes()).matches(\"^\\\\$5\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\"));\n+        assertTrue(Sha2Crypt.sha256Crypt(\"secret\".getBytes(), null).matches(\"^\\\\$5\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\"));\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testSha256CryptNullData() throws Exception {\n+        Sha2Crypt.sha256Crypt((byte[]) null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testSha256CryptWithEmptySalt() throws Exception {\n+        Sha2Crypt.sha256Crypt(\"secret\".getBytes(), \"\");\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/digest/Sha512CryptTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+\n+public class Sha512CryptTest {\n+\n+    @Test\n+    public void testSha512CryptStrings() throws Exception {\n+        // empty data\n+        assertEquals(\"$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/\", Crypt.crypt(\"\", \"$6$foo\"));\n+        // salt gets cut at dollar sign\n+        assertEquals(\"$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.\", Crypt.crypt(\"secret\", \"$6$45678\"));\n+        assertEquals(\"$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.\", Crypt.crypt(\"secret\", \"$6$45678$012\"));\n+        assertEquals(\"$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.\", Crypt.crypt(\"secret\", \"$6$45678$012$456\"));\n+        // salt gets cut at maximum length\n+        assertEquals(\"$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.\", Crypt.crypt(\"secret\", \"$6$1234567890123456\"));\n+        assertEquals(\"$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.\", Crypt.crypt(\"secret\", \"$6$1234567890123456789\"));\n+    }\n+\n+    @Test\n+    public void testSha512CryptBytes() throws Exception {\n+        // An empty Bytearray equals an empty String\n+        assertEquals(\"$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/\", Crypt.crypt(new byte[0], \"$6$foo\"));\n+        // UTF-8 stores \\u00e4 \"a with diaeresis\" as two bytes 0xc3 0xa4.\n+        assertEquals(\"$6$./$fKtWqslQkwI8ZxjdWoeS.jHHrte97bZxiwB5gwCRHX6LG62fUhT6Bb5MRrjWvieh0C/gxh8ItFuTsVy80VrED1\", Crypt.crypt(\"t\\u00e4st\", \"$6$./$\"));\n+        // ISO-8859-1 stores \"a with diaeresis\" as single byte 0xe4.\n+        assertEquals(\"$6$./$L49DSK.d2df/LxGLJQMyS5A/Um.TdHqgc46j5FpScEPlqQHP5dEazltaDNDZ6UEs2mmNI6kPwtH/rsP9g5zBI.\", Crypt.crypt(\"t\\u00e4st\".getBytes(\"ISO-8859-1\"), \"$6$./$\"));\n+    }\n+\n+    @Test\n+    public void testSha512CryptExplicitCall() throws Exception {\n+        assertTrue(Sha2Crypt.sha512Crypt(\"secret\".getBytes()).matches(\"^\\\\$6\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\"));\n+        assertTrue(Sha2Crypt.sha512Crypt(\"secret\".getBytes(), null).matches(\"^\\\\$6\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\"));\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testSha512CryptNullData() throws Exception {\n+        Sha2Crypt.sha512Crypt((byte[]) null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testSha512CryptWithEmptySalt() throws Exception {\n+        Sha2Crypt.sha512Crypt(\"secret\".getBytes(), \"\");\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/digest/UnixCryptTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.digest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+\n+public class UnixCryptTest {\n+\n+    @Test\n+    public void testUnixCryptStrings() throws Exception {\n+        // trivial test\n+        assertEquals(\"xxWAum7tHdIUw\", Crypt.crypt(\"secret\", \"xx\"));\n+        // empty data\n+        assertEquals(\"12UFlHxel6uMM\", Crypt.crypt(\"\", \"12\"));\n+        // salt gets cut at maximum length\n+        assertEquals(\"12FJgqDtVOg7Q\", Crypt.crypt(\"secret\", \"12\"));\n+        assertEquals(\"12FJgqDtVOg7Q\", Crypt.crypt(\"secret\", \"12345678\"));\n+    }\n+\n+    @Test\n+    public void testUnixCryptBytes() throws Exception {\n+        // An empty Bytearray equals an empty String\n+        assertEquals(\"12UFlHxel6uMM\", Crypt.crypt(new byte[0], \"12\"));\n+        // UTF-8 stores \\u00e4 \"a with diaeresis\" as two bytes 0xc3 0xa4.\n+        assertEquals(\"./287bds2PjVw\", Crypt.crypt(\"t\\u00e4st\", \"./\"));\n+        // ISO-8859-1 stores \"a with diaeresis\" as single byte 0xe4.\n+        assertEquals(\"./bLIFNqo9XKQ\", Crypt.crypt(\"t\\u00e4st\".getBytes(\"ISO-8859-1\"), \"./\"));\n+        assertEquals(\"./bLIFNqo9XKQ\", Crypt.crypt(new byte[]{(byte) 0x74, (byte) 0xe4, (byte) 0x73, (byte) 0x74}, \"./\"));\n+    }\n+\n+    /**\n+     * Some salts are invalid for crypt(3) but not for unixCrypt().\n+     */\n+    @Test\n+    public void testUnixCryptExplicitCall() {\n+        // A call to crypt() with an empty salt would result in a \"$6$\" hash.\n+        // Using unixCrypt() explicitly results in a random salt.\n+        assertTrue(UnixCrypt.crypt(\"secret\".getBytes()).matches(\"^[a-zA-Z0-9./]{13}$\"));\n+        assertTrue(UnixCrypt.crypt(\"secret\".getBytes(), null).matches(\"^[a-zA-Z0-9./]{13}$\"));\n+    }\n+\n+    /**\n+     * Unimplemented \"$foo$\" salt prefixes would be threated as UnixCrypt salt.\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testUnicCryptInvalidSalt() throws Exception {\n+        UnixCrypt.crypt(\"secret\", \"$a\");\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testUnixCryptNullData() {\n+        UnixCrypt.crypt((byte[]) null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testUnixCryptWithEmptySalt() throws Exception {\n+        UnixCrypt.crypt(\"secret\", \"\");\n+    }\n+}", "timestamp": 1334936218, "metainfo": ""}