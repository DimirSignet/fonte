{"sha": "a85362e950874ce8fdc1c741a0b775495f2af842", "log": "", "commit": "\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java\n     }\n \n     /**\n-     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propogate is\n+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propagate is\n      * true, the wrapped stream will also be flushed.\n      *\n-     * @param propogate\n+     * @param propagate\n      *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\n      * @throws IOException\n      *             if an I/O error occurs.\n      */\n-    private void flush(final boolean propogate) throws IOException {\n+    private void flush(final boolean propagate) throws IOException {\n         final int avail = baseNCodec.available(context);\n         if (avail > 0) {\n             final byte[] buf = new byte[avail];\n                 out.write(buf, 0, c);\n             }\n         }\n-        if (propogate) {\n+        if (propagate) {\n             out.flush();\n         }\n     }\n--- a/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\n+++ b/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\n                    contains(value, index + 1, 1, \"Z\")) {\n             //-- german & anglicisations, e.g. \"smith\" match \"schmidt\" //\n             // \"snider\" match \"schneider\" --//\n-            //-- also, -sz- in slavic language altho in hungarian it //\n+            //-- also, -sz- in slavic language although in hungarian it //\n             //   is pronounced \"s\" --//\n             result.append('S', 'X');\n             index = contains(value, index + 1, 1, \"Z\") ? index + 2 : index + 1;\n     //-- BEGIN HELPER FUNCTIONS --//\n \n     /**\n-     * Determines whether or not a value is of slavo-germanic orgin. A value is\n+     * Determines whether or not a value is of slavo-germanic origin. A value is\n      * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n      */\n     private boolean isSlavoGermanic(final String value) {\n--- a/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java\n      *            the data from above, but decoded\n      * @param chunkSize\n      *            chunk size (line-length) of the base32 encoded data.\n-     * @param seperator\n+     * @param separator\n      *            Line separator in the base32 encoded data.\n      * @throws Exception\n      *             Usually signifies a bug in the Base32 commons-codec implementation.\n      */\n-    private void testByChunk(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n+    private void testByChunk(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] separator) throws Exception {\n \n         // Start with encode.\n         InputStream in;\n \n-        in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator);\n+        in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator);\n         byte[] output = Base32TestData.streamToBytes(in);\n \n         assertEquals(\"EOF\", -1, in.read());\n         // I always wanted to do this! (wrap encoder with decoder etc etc).\n         in = new ByteArrayInputStream(decoded);\n         for (int i = 0; i < 10; i++) {\n-            in = new Base32InputStream(in, true, chunkSize, seperator);\n+            in = new Base32InputStream(in, true, chunkSize, separator);\n             in = new Base32InputStream(in, false);\n         }\n         output = Base32TestData.streamToBytes(in);\n      *            the data from above, but decoded\n      * @param chunkSize\n      *            chunk size (line-length) of the base32 encoded data.\n-     * @param seperator\n+     * @param separator\n      *            Line separator in the base32 encoded data.\n      * @throws Exception\n      *             Usually signifies a bug in the Base32 commons-codec implementation.\n      */\n-    private void testByteByByte(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n+    private void testByteByByte(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] separator) throws Exception {\n \n         // Start with encode.\n         InputStream in;\n-        in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator);\n+        in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator);\n         byte[] output = new byte[encoded.length];\n         for (int i = 0; i < output.length; i++) {\n             output[i] = (byte) in.read();\n         // I always wanted to do this! (wrap encoder with decoder etc etc).\n         in = new ByteArrayInputStream(decoded);\n         for (int i = 0; i < 10; i++) {\n-            in = new Base32InputStream(in, true, chunkSize, seperator);\n+            in = new Base32InputStream(in, true, chunkSize, separator);\n             in = new Base32InputStream(in, false);\n         }\n         output = new byte[decoded.length];\n--- a/src/test/java/org/apache/commons/codec/binary/Base32OutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base32OutputStreamTest.java\n      *            the data from above, but decoded\n      * @param chunkSize\n      *            chunk size (line-length) of the Base32 encoded data.\n-     * @param seperator\n+     * @param separator\n      *            Line separator in the Base32 encoded data.\n      * @throws Exception\n      *             Usually signifies a bug in the Base32 commons-codec implementation.\n      */\n-    private void testByChunk(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n+    private void testByChunk(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] separator) throws Exception {\n \n         // Start with encode.\n         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n-        OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator);\n+        OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator);\n         out.write(decoded);\n         out.close();\n         byte[] output = byteOut.toByteArray();\n         out = byteOut;\n         for (int i = 0; i < 10; i++) {\n             out = new Base32OutputStream(out, false);\n-            out = new Base32OutputStream(out, true, chunkSize, seperator);\n+            out = new Base32OutputStream(out, true, chunkSize, separator);\n         }\n         out.write(decoded);\n         out.close();\n      *            the data from above, but decoded\n      * @param chunkSize\n      *            chunk size (line-length) of the Base32 encoded data.\n-     * @param seperator\n+     * @param separator\n      *            Line separator in the Base32 encoded data.\n      * @throws Exception\n      *             Usually signifies a bug in the Base32 commons-codec implementation.\n      */\n-    private void testByteByByte(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n+    private void testByteByByte(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] separator) throws Exception {\n \n         // Start with encode.\n         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n-        OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator);\n+        OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator);\n         for (final byte element : decoded) {\n             out.write(element);\n         }\n         out = byteOut;\n         for (int i = 0; i < 10; i++) {\n             out = new Base32OutputStream(out, false);\n-            out = new Base32OutputStream(out, true, chunkSize, seperator);\n+            out = new Base32OutputStream(out, true, chunkSize, separator);\n         }\n         for (final byte element : decoded) {\n             out.write(element);\n--- a/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java\n      *            the data from above, but decoded\n      * @param chunkSize\n      *            chunk size (line-length) of the base64 encoded data.\n-     * @param seperator\n+     * @param separator\n      *            Line separator in the base64 encoded data.\n      * @throws Exception\n      *             Usually signifies a bug in the Base64 commons-codec implementation.\n      */\n-    private void testByChunk(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n+    private void testByChunk(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] separator) throws Exception {\n \n         // Start with encode.\n         InputStream in;\n-        in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator);\n+        in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator);\n         byte[] output = Base64TestData.streamToBytes(in);\n \n         assertEquals(\"EOF\", -1, in.read());\n         // I always wanted to do this! (wrap encoder with decoder etc etc).\n         in = new ByteArrayInputStream(decoded);\n         for (int i = 0; i < 10; i++) {\n-            in = new Base64InputStream(in, true, chunkSize, seperator);\n+            in = new Base64InputStream(in, true, chunkSize, separator);\n             in = new Base64InputStream(in, false);\n         }\n         output = Base64TestData.streamToBytes(in);\n      *            the data from above, but decoded\n      * @param chunkSize\n      *            chunk size (line-length) of the base64 encoded data.\n-     * @param seperator\n+     * @param separator\n      *            Line separator in the base64 encoded data.\n      * @throws Exception\n      *             Usually signifies a bug in the Base64 commons-codec implementation.\n      */\n-    private void testByteByByte(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] seperator) throws Exception {\n+    private void testByteByByte(final byte[] encoded, final byte[] decoded, final int chunkSize, final byte[] separator) throws Exception {\n \n         // Start with encode.\n         InputStream in;\n-        in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator);\n+        in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator);\n         byte[] output = new byte[encoded.length];\n         for (int i = 0; i < output.length; i++) {\n             output[i] = (byte) in.read();\n         // I always wanted to do this! (wrap encoder with decoder etc etc).\n         in = new ByteArrayInputStream(decoded);\n         for (int i = 0; i < 10; i++) {\n-            in = new Base64InputStream(in, true, chunkSize, seperator);\n+            in = new Base64InputStream(in, true, chunkSize, separator);\n             in = new Base64InputStream(in, false);\n         }\n         output = new byte[decoded.length];", "timestamp": 1385073031, "metainfo": ""}