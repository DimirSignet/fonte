{"sha": "e2701a5a1872adc57a2735d39ac9a0dca37f75e3", "log": "<action dev=\"ggregory\" type=\"add\" issue=\"CODEC-161\" due-to=\"crice\">Add Match Rating Approach (MRA) phonetic algorithm encoder.</action>  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.codec.language;\n+\n+import java.util.Locale;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * Match Rating Approach Phonetic Algorithm Developed by <CITE>Western Airlines</CITE> in 1977.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Match_rating_approach\">Wikipedia - Match Rating Approach</a>\n+ * @since 1.8\n+ */\n+public class MatchRatingApproachEncoder implements StringEncoder {\n+\n+    private static final String SPACE = \" \";\n+\n+    private static final String EMPTY = \"\";\n+\n+    /**\n+     * Constants used mainly for the min rating value.\n+     */\n+    private static final int ONE = 1, TWO = 2, THREE = 3, FOUR = 4, FIVE = 5, SIX = 6, SEVEN = 7, EIGHT = 8, ELEVEN = 11, TWELVE = 12;\n+\n+    /**\n+     * The plain letter equivalent of the accented letters.\n+     */\n+    private static final String PLAIN_ASCII = \"AaEeIiOoUu\" // grave\n+            + \"AaEeIiOoUuYy\" // acute\n+            + \"AaEeIiOoUuYy\" // circumflex\n+            + \"AaOoNn\" // tilde\n+            + \"AaEeIiOoUuYy\" // umlaut\n+            + \"Aa\" // ring\n+            + \"Cc\" // cedilla\n+            + \"OoUu\"; // double acute\n+\n+    /**\n+     * Unicode characters corresponding to various accented letters. For example: \\u00DA is U acute etc...\n+     */\n+    private static final String UNICODE = \"\\u00C0\\u00E0\\u00C8\\u00E8\\u00CC\\u00EC\\u00D2\\u00F2\\u00D9\\u00F9\"\n+            + \"\\u00C1\\u00E1\\u00C9\\u00E9\\u00CD\\u00ED\\u00D3\\u00F3\\u00DA\\u00FA\\u00DD\\u00FD\"\n+            + \"\\u00C2\\u00E2\\u00CA\\u00EA\\u00CE\\u00EE\\u00D4\\u00F4\\u00DB\\u00FB\\u0176\\u0177\" + \"\\u00C3\\u00E3\\u00D5\\u00F5\\u00D1\\u00F1\"\n+            + \"\\u00C4\\u00E4\\u00CB\\u00EB\\u00CF\\u00EF\\u00D6\\u00F6\\u00DC\\u00FC\\u0178\\u00FF\" + \"\\u00C5\\u00E5\" + \"\\u00C7\\u00E7\"\n+            + \"\\u0150\\u0151\\u0170\\u0171\";\n+\n+    /**\n+     * Cleans up a name: 1. Upper-cases everything 2. Removes some common punctuation 3. Removes accents 4. Removes any\n+     * spaces.\n+     *\n+     * <h2>API Usage</h2>\n+     * <p>\n+     * Consider this method private, it is package protected for unit testing only.\n+     * </p>\n+     *\n+     * @param name\n+     *            The name to be cleaned\n+     * @return The cleaned name\n+     */\n+    String cleanName(final String name) {\n+        String upperName = name.toUpperCase(Locale.ENGLISH);\n+\n+        String[] charsToTrim = { \"\\\\-\", \"[&]\", \"\\\\'\", \"\\\\.\", \"[\\\\,]\" };\n+        for (String str : charsToTrim) {\n+            upperName = upperName.replaceAll(str, EMPTY);\n+        }\n+\n+        upperName = removeAccents(upperName);\n+        upperName = upperName.replaceAll(\"\\\\s+\", EMPTY);\n+\n+        return upperName;\n+    }\n+\n+    /**\n+     * Encodes an Object using the Match Rating Approach algo. Method is here to satisfy the requirements of the\n+     * Encoder interface Throws an EncoderException if input object is not of type java.lang.String.\n+     *\n+     * @param pObject\n+     *            Object to encode\n+     * @return An object (or type java.lang.String) containing the Match Rating Approach code which corresponds to the\n+     *         String supplied.\n+     * @throws EncoderException\n+     *             if the parameter supplied is not of type java.lang.String\n+     */\n+    @Override\n+    public final Object encode(final Object pObject) throws EncoderException {\n+        if (!(pObject instanceof String)) {\n+            throw new EncoderException(\"Parameter supplied to Match Rating Approach encoder is not of type java.lang.String\");\n+        }\n+        return encode((String) pObject);\n+    }\n+\n+    /**\n+     * Encodes a String using the Match Rating Approach (MRA) algorithm.\n+     *\n+     * @param name\n+     *            String object to encode\n+     * @return The MRA code corresponding to the String supplied\n+     */\n+    @Override\n+    public final String encode(String name) {\n+        // Bulletproof for trivial input - NINO\n+        if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) {\n+            return EMPTY;\n+        }\n+\n+        // Preprocessing\n+        name = cleanName(name);\n+\n+        // BEGIN: Actual encoding part of the algorithm...\n+        // 1. Delete all vowels unless the vowel begins the word\n+        name = removeVowels(name);\n+\n+        // 2. Remove second consonant from any double consonant\n+        name = removeDoubleConsonants(name);\n+\n+        // 3. Reduce codex to 6 letters by joining the first 3 and last 3 letters\n+        name = getFirst3Last3(name);\n+\n+        return name;\n+    }\n+\n+    /**\n+     * Gets the first & last 3 letters of a name (if > 6 characters) Else just returns the name.\n+     *\n+     * <h2>API Usage</h2>\n+     * <p>\n+     * Consider this method private, it is package protected for unit testing only.\n+     * </p>\n+     *\n+     * @param name\n+     *            The string to get the substrings from\n+     * @return Annexed first & last 3 letters of input word.\n+     */\n+    String getFirst3Last3(final String name) {\n+        int nameLength = name.length();\n+\n+        if (nameLength > SIX) {\n+            String firstThree = name.substring(0, THREE);\n+            String lastThree = name.substring(nameLength - THREE, nameLength);\n+            return firstThree + lastThree;\n+        } else {\n+            return name;\n+        }\n+    }\n+\n+    /**\n+     * Obtains the min rating of the length sum of the 2 names. In essence the larger the sum length the smaller the\n+     * min rating. Values strictly from documentation.\n+     *\n+     * <h2>API Usage</h2>\n+     * <p>\n+     * Consider this method private, it is package protected for unit testing only.\n+     * </p>\n+     *\n+     * @param sumLength\n+     *            The length of 2 strings sent down\n+     * @return The min rating value\n+     */\n+    int getMinRating(final int sumLength) {\n+        int minRating = 0;\n+\n+        if (sumLength <= FOUR) {\n+            minRating = FIVE;\n+        } else if ((sumLength >= FIVE) && (sumLength <= SEVEN)) {\n+            minRating = FOUR;\n+        } else if ((sumLength >= EIGHT) && (sumLength <= ELEVEN)) {\n+            minRating = THREE;\n+        } else if (sumLength == TWELVE) {\n+            minRating = TWO;\n+        } else {\n+            minRating = ONE; // docs said little here.\n+        }\n+\n+        return minRating;\n+    }\n+\n+    /**\n+     * Determines if two names are homophonous via Match Rating Approach (MRA) algorithm. It should be noted that the\n+     * strings are cleaned in the same way as {@link #encode(String)}.\n+     *\n+     * @param name1\n+     *            First of the 2 strings (names) to compare\n+     * @param name2\n+     *            Second of the 2 names to compare\n+     * @return <code>true</code> if the encodings are identical <code>false</code> otherwise.\n+     */\n+    public boolean isEncodeEquals(String name1, String name2) {\n+        // Bulletproof for trivial input - NINO\n+        if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) {\n+            return false;\n+        } else if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) {\n+            return false;\n+        } else if (name1.length() == 1 || name2.length() == 1) {\n+            return false;\n+        } else if (name1.equalsIgnoreCase(name2)) {\n+            return true;\n+        }\n+\n+        // Preprocessing\n+        name1 = cleanName(name1);\n+        name2 = cleanName(name2);\n+\n+        // Actual MRA Algorithm\n+\n+        // 1. Remove vowels\n+        name1 = removeVowels(name1);\n+        name2 = removeVowels(name2);\n+\n+        // 2. Remove double consonants\n+        name1 = removeDoubleConsonants(name1);\n+        name2 = removeDoubleConsonants(name2);\n+\n+        // 3. Reduce down to 3 letters\n+        name1 = getFirst3Last3(name1);\n+        name2 = getFirst3Last3(name2);\n+\n+        // 4. Check for length difference - if 3 or greater then no similarity\n+        // comparison is done\n+        if (Math.abs(name1.length() - name2.length()) >= THREE) {\n+            return false;\n+        }\n+\n+        // 5. Obtain the minimum rating value by calculating the length sum of the\n+        // encoded Strings and sending it down.\n+        int sumLength = Math.abs(name1.length() + name2.length());\n+        int minRating = 0;\n+        minRating = getMinRating(sumLength);\n+\n+        // 6. Process the encoded Strings from left to right and remove any\n+        // identical characters found from both Strings respectively.\n+        int count = leftToRightThenRightToLeftProcessing(name1, name2);\n+\n+        // 7. Each PNI item that has a similarity rating equal to or greater than\n+        // the min is considered to be a good candidate match\n+        return count >= minRating;\n+\n+    }\n+\n+    /**\n+     * Determines if a letter is a vowel.\n+     *\n+     * <h2>API Usage</h2>\n+     * <p>\n+     * Consider this method private, it is package protected for unit testing only.\n+     * </p>\n+     *\n+     * @param letter\n+     *            The letter under investiagtion\n+     * @return True if a vowel, else false\n+     */\n+    boolean isVowel(String letter) {\n+        return letter.equalsIgnoreCase(\"E\") || letter.equalsIgnoreCase(\"A\") || letter.equalsIgnoreCase(\"O\") || letter.equalsIgnoreCase(\"I\") ||\n+                letter.equalsIgnoreCase(\"U\");\n+    }\n+\n+    /**\n+     * Processes the names from left to right (first) then right to left removing identical letters in same positions.\n+     * Then subtracts the longer string that remains from 6 and returns this.\n+     *\n+     * <h2>API Usage</h2>\n+     * <p>\n+     * Consider this method private, it is package protected for unit testing only.\n+     * </p>\n+     *\n+     * @param name1\n+     *            name2\n+     * @return\n+     */\n+    int leftToRightThenRightToLeftProcessing(String name1, String name2) {\n+        char[] name1Char = name1.toCharArray();\n+        char[] name2Char = name2.toCharArray();\n+\n+        int name1Size = name1.length() - 1;\n+        int name2Size = name2.length() - 1;\n+\n+        String name1LtRStart = EMPTY;\n+        String name1LtREnd = EMPTY;\n+\n+        String name2RtLStart = EMPTY;\n+        String name2RtLEnd = EMPTY;\n+\n+        for (int i = 0; i < name1Char.length; i++) {\n+            if (i > name2Size) {\n+                break;\n+            }\n+\n+            name1LtRStart = name1.substring(i, i + 1);\n+            name1LtREnd = name1.substring(name1Size - i, (name1Size - i) + 1);\n+\n+            name2RtLStart = name2.substring(i, i + 1);\n+            name2RtLEnd = name2.substring(name2Size - i, (name2Size - i) + 1);\n+\n+            // Left to right...\n+            if (name1LtRStart.equals(name2RtLStart)) {\n+                name1Char[i] = ' ';\n+                name2Char[i] = ' ';\n+            }\n+\n+            // Right to left...\n+            if (name1LtREnd.equals(name2RtLEnd)) {\n+                name1Char[name1Size - i] = ' ';\n+                name2Char[name2Size - i] = ' ';\n+            }\n+        }\n+\n+        // Char arrays -> string & remove extraneous space\n+        String strA = new String(name1Char).replaceAll(\"\\\\s+\", EMPTY);\n+        String strB = new String(name2Char).replaceAll(\"\\\\s+\", EMPTY);\n+\n+        // Final bit - subtract longest string from 6 and return this int value\n+        if (strA.length() > strB.length()) {\n+            return Math.abs(SIX - strA.length());\n+        } else {\n+            return Math.abs(SIX - strB.length());\n+        }\n+    }\n+\n+    /**\n+     * Removes accented letters and replaces with non-accented ascii equivalent Case is preserved.\n+     * http://www.codecodex.com/wiki/Remove_accent_from_letters_%28ex_.%C3%A9_to_e%29\n+     *\n+     * @param accentedWord\n+     *            The word that may have accents in it.\n+     * @return De-accented word\n+     */\n+    String removeAccents(final String accentedWord) {\n+        if (accentedWord == null) {\n+            return null;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        int n = accentedWord.length();\n+\n+        for (int i = 0; i < n; i++) {\n+            char c = accentedWord.charAt(i);\n+            int pos = UNICODE.indexOf(c);\n+            if (pos > -1) {\n+                sb.append(PLAIN_ASCII.charAt(pos));\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Replaces any double consonant pair with the single letter equivalent.\n+     *\n+     * <h2>API Usage</h2>\n+     * <p>\n+     * Consider this method private, it is package protected for unit testing only.\n+     * </p>\n+     *\n+     * @param name\n+     *            String to have double consonants removed\n+     * @return Single consonant word\n+     */\n+    String removeDoubleConsonants(String name) {\n+        String[] dblCnstArray = new String[] { \"BB\", \"CC\", \"DD\", \"FF\", \"GG\", \"HH\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"PP\", \"QQ\", \"RR\", \"SS\", \"TT\", \"VV\",\n+                \"WW\", \"XX\", \"YY\", \"ZZ\" };\n+\n+        String replacedName = name.toUpperCase();\n+        for (String dc : dblCnstArray) {\n+            if (replacedName.contains(dc)) {\n+                String singleLetter = dc.substring(0, 1);\n+                replacedName = replacedName.replace(dc, singleLetter);\n+            }\n+        }\n+\n+        return replacedName;\n+    }\n+\n+    /**\n+     * Deletes all vowels unless the vowel begins the word.\n+     *\n+     * <h2>API Usage</h2>\n+     * <p>\n+     * Consider this method private, it is package protected for unit testing only.\n+     * </p>\n+     *\n+     * @param name\n+     *            The name to have vowels removed\n+     * @return De-voweled word\n+     */\n+    String removeVowels(String name) {\n+        // Extract first letter\n+        String firstLetter = name.substring(0, 1);\n+\n+        name = name.replaceAll(\"A\", EMPTY);\n+        name = name.replaceAll(\"E\", EMPTY);\n+        name = name.replaceAll(\"I\", EMPTY);\n+        name = name.replaceAll(\"O\", EMPTY);\n+        name = name.replaceAll(\"U\", EMPTY);\n+\n+        name = name.replaceAll(\"\\\\s{2,}\\\\b\", SPACE);\n+\n+        // return isVowel(firstLetter) ? (firstLetter + name) : name;\n+        if (isVowel(firstLetter)) {\n+            return (firstLetter + name);\n+        } else {\n+            return name;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/codec/language/MatchRatingApproachEncoderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.language;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.commons.codec.StringEncoder;\n+import org.apache.commons.codec.StringEncoderAbstractTest;\n+import org.junit.Test;\n+\n+/**\n+ * Series of tests for the Match Rating Approach algorithm.\n+ * \n+ * General naming nomeneclature for the test is of the form:\n+ * GeneralMetadataOnTheTestArea_ActualTestValues_ExpectedResult\n+ * \n+ * An unusual value is indicated by the term \"corner case\"\n+ */\n+public class MatchRatingApproachEncoderTest extends StringEncoderAbstractTest {\n+\n+    private MatchRatingApproachEncoder getMatchRatingApproachEncoder() {\n+        return (MatchRatingApproachEncoder) this.getStringEncoder();\n+    }\n+\n+    // ********** BEGIN REGION - TEST SUPPORT METHODS\n+\n+    @Test\n+    public final void testAccentRemoval_AllLower_SuccessfullyRemoved() {\n+        assertEquals(\"aeiou\", getMatchRatingApproachEncoder().removeAccents(\"\u00e1\u00e9\u00ed\u00f3\u00fa\"));\n+    }\n+\n+    @Test\n+    public final void testAccentRemoval_WithSpaces_SuccessfullyRemovedAndSpacesInvariant() {\n+        assertEquals(\"ae io  u\", getMatchRatingApproachEncoder().removeAccents(\"\u00e1\u00e9 \u00ed\u00f3  \u00fa\"));\n+    }\n+\n+    @Test\n+    public final void testAccentRemoval_UpperandLower_SuccessfullyRemovedAndCaseInvariant() {\n+        assertEquals(\"AeiOuu\", getMatchRatingApproachEncoder().removeAccents(\"\u00c1e\u00ed\u00d3uu\"));\n+    }\n+\n+    @Test\n+    public final void testAccentRemoval_MixedWithUnusualChars_SuccessfullyRemovedAndUnusualcharactersInvariant() {\n+        assertEquals(\"A-e'i.,o&u\", getMatchRatingApproachEncoder().removeAccents(\"\u00c1-e'\u00ed.,\u00f3&\u00fa\"));\n+    }\n+\n+    @Test\n+    public final void testAccentRemoval_GerSpanFrenMix_SuccessfullyRemoved() {\n+        assertEquals(\"aeou\u00dfAEOUnNa\", getMatchRatingApproachEncoder().removeAccents(\"\u00e4\u00eb\u00f6\u00fc\u00df\u00c4\u00cb\u00d6\u00dc\u00f1\u00d1\u00e0\"));\n+    }\n+\n+    @Test\n+    public final void testAccentRemoval_ComprehensiveAccentMix_AllSuccessfullyRemoved() {\n+        assertEquals(\"E,E,E,E,U,U,I,I,A,A,O,e,e,e,e,u,u,i,i,a,a,o,c\",\n+                getMatchRatingApproachEncoder().removeAccents(\"\u00c8,\u00c9,\u00ca,\u00cb,\u00db,\u00d9,\u00cf,\u00ce,\u00c0,\u00c2,\u00d4,\u00e8,\u00e9,\u00ea,\u00eb,\u00fb,\u00f9,\u00ef,\u00ee,\u00e0,\u00e2,\u00f4,\u00e7\"));\n+    }\n+\n+    @Test\n+    public final void testAccentRemovalNormalString_NoChange() {\n+        assertEquals(\"Colorless green ideas sleep furiously\", getMatchRatingApproachEncoder().removeAccents(\"Colorless green ideas sleep furiously\"));\n+    }\n+\n+    @Test\n+    public final void testAccentRemoval_NINO_NoChange() {\n+        assertEquals(\"\", getMatchRatingApproachEncoder().removeAccents(\"\"));\n+    }\n+\n+    @Test\n+    public final void testRemoveSingleDoubleConsonants_BUBLE_RemovedSuccessfully() {\n+        assertEquals(\"BUBLE\", getMatchRatingApproachEncoder().removeDoubleConsonants(\"BUBBLE\"));\n+    }\n+\n+    @Test\n+    public final void testRemoveDoubleConsonants_MISSISSIPPI_RemovedSuccessfully() {\n+        assertEquals(\"MISISIPI\", getMatchRatingApproachEncoder().removeDoubleConsonants(\"MISSISSIPPI\"));\n+    }\n+\n+    @Test\n+    public final void testRemoveDoubleDoubleVowel_BEETLE_NotRemoved() {\n+        assertEquals(\"BEETLE\", getMatchRatingApproachEncoder().removeDoubleConsonants(\"BEETLE\"));\n+    }\n+\n+    @Test\n+    public final void testIsVowel_CapitalA_ReturnsTrue() {\n+        assertEquals(true, getMatchRatingApproachEncoder().isVowel(\"A\"));\n+    }\n+\n+    @Test\n+    public final void testIsVowel_SmallD_ReturnsFalse() {\n+        assertFalse(getMatchRatingApproachEncoder().isVowel(\"d\"));\n+    }\n+\n+    @Test\n+    public final void testRemoveVowel_ALESSANDRA_Returns_ALSSNDR() {\n+        assertEquals(\"ALSSNDR\", getMatchRatingApproachEncoder().removeVowels(\"ALESSANDRA\"));\n+    }\n+\n+    @Test\n+    public final void testRemoveVowel__AIDAN_Returns_ADN() {\n+        assertEquals(\"ADN\", getMatchRatingApproachEncoder().removeVowels(\"AIDAN\"));\n+    }\n+\n+    @Test\n+    public final void testRemoveVowel__DECLAN_Returns_DCLN() {\n+        assertEquals(\"DCLN\", getMatchRatingApproachEncoder().removeVowels(\"DECLAN\"));\n+    }\n+\n+    @Test\n+    public final void testGetFirstLast3__ALEXANDER_Returns_Aleder() {\n+        assertEquals(\"Aleder\", getMatchRatingApproachEncoder().getFirst3Last3(\"Alexzander\"));\n+    }\n+\n+    @Test\n+    public final void testGetFirstLast3_PETE_Returns_PETE() {\n+        assertEquals(\"PETE\", getMatchRatingApproachEncoder().getFirst3Last3(\"PETE\"));\n+    }\n+\n+    @Test\n+    public final void testleftTorightThenRightToLeft_ALEXANDER_ALEXANDRA_Returns4() {\n+        assertEquals(4, getMatchRatingApproachEncoder().leftToRightThenRightToLeftProcessing(\"ALEXANDER\", \"ALEXANDRA\"));\n+    }\n+\n+    @Test\n+    public final void testleftTorightThenRightToLeft_EINSTEIN_MICHAELA_Returns0() {\n+        assertEquals(0, getMatchRatingApproachEncoder().leftToRightThenRightToLeftProcessing(\"EINSTEIN\", \"MICHAELA\"));\n+    }\n+\n+    @Test\n+    public final void testGetMinRating_7_Return4_Successfully() {\n+        assertEquals(4, getMatchRatingApproachEncoder().getMinRating(7));\n+    }\n+\n+    @Test\n+    public final void testGetMinRating_2_Returns5_Successfully() {\n+        assertEquals(5, getMatchRatingApproachEncoder().getMinRating(2));\n+    }\n+\n+    @Test\n+    public final void testGetMinRating_2_Return1_Successfully() {\n+        assertEquals(1, getMatchRatingApproachEncoder().getMinRating(13));\n+    }\n+\n+    @Test\n+    public final void testcleanName_SuccessfullyClean() {\n+        assertEquals(\"THISISATEST\", getMatchRatingApproachEncoder().cleanName(\"This-\u00eds   a t.,es &t\"));\n+    }\n+\n+    // ***** END REGION - TEST SUPPORT METHODS\n+\n+    // ***** BEGIN REGION - TEST GET MRA ENCODING\n+\n+    @Test\n+    public final void testGetEncoding_HARPER_HRPR() {\n+        assertEquals(\"HRPR\", getMatchRatingApproachEncoder().encode(\"HARPER\"));\n+    }\n+\n+    @Test\n+    public final void testGetEncoding_SMITH_to_SMTH() {\n+        assertEquals(\"SMTH\", getMatchRatingApproachEncoder().encode(\"Smith\"));\n+    }\n+\n+    @Test\n+    public final void testGetEncoding_SMYTH_to_SMYTH() {\n+        assertEquals(\"SMYTH\", getMatchRatingApproachEncoder().encode(\"Smyth\"));\n+    }\n+\n+    @Test\n+    public final void testGetEncoding_Space_to_Nothing() {\n+        assertEquals(\"\", getMatchRatingApproachEncoder().encode(\" \"));\n+    }\n+\n+    @Test\n+    public final void testGetEncoding_NoSpace_to_Nothing() {\n+        assertEquals(\"\", getMatchRatingApproachEncoder().encode(\"\"));\n+    }\n+\n+    @Test\n+    public final void testGetEncoding_Null_to_Nothing() {\n+        assertEquals(\"\", getMatchRatingApproachEncoder().encode(null));\n+    }\n+\n+    @Test\n+    public final void testGetEncoding_One_Letter_to_Nothing() {\n+        assertEquals(\"\", getMatchRatingApproachEncoder().encode(\"E\"));\n+    }\n+\n+    // ***** END REGION - TEST GET MRA ENCODING\n+\n+    // ***** BEGIN REGION - TEST GET MRA COMPARISONS\n+\n+    @Test\n+    public final void testCompare_SMITH_SMYTH_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"smith\", \"smyth\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_BURNS_BOURNE_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Burns\", \"Bourne\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_ShortNames_AL_ED_WorksButNoMatch() {\n+        assertFalse(getMatchRatingApproachEncoder().isEncodeEquals(\"Al\", \"Ed\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_CATHERINE_KATHRYN_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Catherine\", \"Kathryn\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_BRIAN_BRYAN_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Brian\", \"Bryan\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_SEAN_SHAUN_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"S\u00e9an\", \"Shaun\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_COLM_COLIN_WithAccentsAndSymbolsAndSpaces_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"C\u00f3lm.   \", \"C-ol\u00edn\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_STEPHEN_STEVEN_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Stephen\", \"Steven\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_STEVEN_STEFAN_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Steven\", \"Stefan\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_STEPHEN_STEFAN_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Stephen\", \"Stefan\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_SAM_SAMUEL_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Sam\", \"Samuel\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_MICKY_MICHAEL_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Micky\", \"Michael\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_OONA_OONAGH_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Oona\", \"Oonagh\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_SOPHIE_SOFIA_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Sophie\", \"Sofia\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_FRANCISZEK_FRANCES_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Franciszek\", \"Frances\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_TOMASZ_TOM_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Tomasz\", \"tom\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_SmallInput_CARK_Kl_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Kl\", \"Karl\"));\n+    }\n+\n+    @Test\n+    public final void testCompareNameToSingleLetter_KARL_C_DoesNotMatch() {\n+        assertFalse(getMatchRatingApproachEncoder().isEncodeEquals(\"Karl\", \"C\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_ZACH_ZAKARIA_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Zach\", \"Zacharia\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_KARL_ALESSANDRO_DoesNotMatch() {\n+        assertFalse(getMatchRatingApproachEncoder().isEncodeEquals(\"Karl\", \"Alessandro\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_Forenames_UNA_OONAGH_ShouldSuccessfullyMatchButDoesNot() {\n+        assertFalse(getMatchRatingApproachEncoder().isEncodeEquals(\"\u00dana\", \"Oonagh\")); // Disappointing\n+    }\n+\n+    // ***** Begin Region - Test Get Encoding - Surnames\n+\n+    @Test\n+    public final void testCompare_Surname_OSULLIVAN_OSUILLEABHAIN_SuccessfulMatch() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"O'Sullivan\", \"\u00d3 ' S\u00failleabh\u00e1in\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_LongSurnames_MORIARTY_OMUIRCHEARTAIGH_DoesNotSuccessfulMatch() {\n+        assertFalse(getMatchRatingApproachEncoder().isEncodeEquals(\"Moriarty\", \"OMuircheartaigh\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_LongSurnames_OMUIRCHEARTAIGH_OMIREADHAIGH_SuccessfulMatch() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"o'muireadhaigh\", \"\u00d3 'Muircheartaigh \"));\n+    }\n+\n+    @Test\n+    public final void testCompare_Surname_COOPERFLYNN_SUPERLYN_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Cooper-Flynn\", \"Super-Lyn\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_Surname_HAILEY_HALLEY_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Hailey\", \"Halley\"));\n+    }\n+\n+    // **** BEGIN YIDDISH/SLAVIC SECTION ****\n+\n+    @Test\n+    public final void testCompare_Surname_AUERBACH_UHRBACH_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Auerbach\", \"Uhrbach\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_Surname_MOSKOWITZ_MOSKOVITZ_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Moskowitz\", \"Moskovitz\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_Surname_LIPSHITZ_LIPPSZYC_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"LIPSHITZ\", \"LIPPSZYC\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_Surname_LEWINSKY_LEVINSKI_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"LEWINSKY\", \"LEVINSKI\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_Surname_SZLAMAWICZ_SHLAMOVITZ_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"SZLAMAWICZ\", \"SHLAMOVITZ\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_Surname_ROSOCHOWACIEC_ROSOKHOVATSETS_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"R o s o ch o w a c ie c\", \" R o s o k ho v a ts e ts\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_Surname_PRZEMYSL_PSHEMESHIL_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\" P rz e m y s l\", \" P sh e m e sh i l\"));\n+    }\n+\n+    // **** END YIDDISH/SLAVIC SECTION ****\n+\n+    @Test\n+    public final void testCompare_PETERSON_PETERS_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Peterson\", \"Peters\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_MCGOWAN_MCGEOGHEGAN_SuccessfullyMatched() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"McGowan\", \"Mc Geoghegan\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_SurnamesCornerCase_MURPHY_Space_NoMatch() {\n+        assertFalse(getMatchRatingApproachEncoder().isEncodeEquals(\"Murphy\", \" \"));\n+    }\n+\n+    @Test\n+    public final void testCompare_SurnamesCornerCase_MURPHY_NoSpace_NoMatch() {\n+        assertFalse(getMatchRatingApproachEncoder().isEncodeEquals(\"Murphy\", \"\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_SurnameCornerCase_Nulls_NoMatch() {\n+        assertFalse(getMatchRatingApproachEncoder().isEncodeEquals(null, null));\n+    }\n+\n+    @Test\n+    public final void testCompare_Surnames_MURPHY_LYNCH_NoMatchExpected() {\n+        assertFalse(getMatchRatingApproachEncoder().isEncodeEquals(\"Murphy\", \"Lynch\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_Forenames_SEAN_JOHN_MatchExpected() {\n+        assertTrue(getMatchRatingApproachEncoder().isEncodeEquals(\"Sean\", \"John\"));\n+    }\n+\n+    @Test\n+    public final void testCompare_Forenames_SEAN_PETE_NoMatchExpected() {\n+        assertFalse(getMatchRatingApproachEncoder().isEncodeEquals(\"Sean\", \"Pete\"));\n+    }\n+\n+    @Override\n+    protected StringEncoder createStringEncoder() {\n+        return new MatchRatingApproachEncoder();\n+    }\n+\n+    // ***** END REGION - TEST GET MRA COMPARISONS\n+\n+}", "timestamp": 1354136227, "metainfo": ""}