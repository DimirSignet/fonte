{"sha": "161677911f5ab798708503eb13859e8403281c7f", "log": "[CODEC-125] Implement a Beider-Morse phonetic matching codec. Apply Matthew's patch https://issues.apache.org/jira/secure/attachment/12489548/performanceAndBugs.patch  ", "commit": "\n--- a/src/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n+import java.util.TreeSet;\n \n /**\n  * <p>\n             this.phonemes = phonemes;\n         }\n \n-        public PhonemeBuilder append(String str) {\n+        public PhonemeBuilder append(CharSequence str) {\n             Set<Rule.Phoneme> newPhonemes = new HashSet<Rule.Phoneme>();\n \n             for (Rule.Phoneme ph : this.phonemes) {\n         }\n \n         public String makeString() {\n-            List<String> sorted = new ArrayList<String>();\n+\n+            StringBuilder sb = new StringBuilder();\n+            // System.err.println(this.phonemes.getClass());\n \n             for (Rule.Phoneme ph : this.phonemes) {\n-                sorted.add(ph.getPhonemeText());\n-            }\n-\n-            Collections.sort(sorted);\n-            StringBuilder sb = new StringBuilder();\n-\n-            for (String ph : sorted) {\n                 if (sb.length() > 0)\n                     sb.append(\"|\");\n-                sb.append(ph);\n+                sb.append(ph.getPhonemeText());\n             }\n \n             return sb.toString();\n \n     private static class RulesApplication {\n         private final List<Rule> finalRules;\n-        private final String input;\n+        private final CharSequence input;\n \n         private PhonemeBuilder phonemeBuilder;\n         private int i;\n         private boolean found;\n \n-        public RulesApplication(List<Rule> finalRules, String input, PhonemeBuilder phonemeBuilder, int i) {\n+        public RulesApplication(List<Rule> finalRules, CharSequence input, PhonemeBuilder phonemeBuilder, int i) {\n             if (finalRules == null) {\n                 throw new NullPointerException(\"The finalRules argument must not be null\");\n             }\n             return phonemeBuilder;\n         }\n \n-        Set<Rule.Phoneme> phonemes = new HashSet<Rule.Phoneme>();\n+        Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>();\n \n         for (Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n             PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n-            String phonemeText = phoneme.getPhonemeText();\n+            CharSequence phonemeText = phoneme.getPhonemeText();\n             // System.err.println(\"Expanding: \" + phonemeText);\n \n             for (int i = 0; i < phonemeText.length();) {\n \n                 if (!found) {\n                     // System.err.println(\"Not found. Appending as-is\");\n-                    subBuilder = subBuilder.append(phonemeText.substring(i, i + 1));\n+                    subBuilder = subBuilder.append(phonemeText.subSequence(i, i + 1));\n                 }\n \n                 i = rulesApplication.getI();\n                     // check for any prefix in the words list\n                     String remainder = input.substring(l.length() + 1); // input without the prefix\n                     String combined = l + remainder; // input with prefix without space\n-                    return encode(remainder) + \"-\" + encode(combined);\n+                    return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n                 }\n                 // fixme: this case is invariant on l\n                 else if (input.length() >= 2 && input.substring(0, 2).equals(\"d'\")) // check for d'\n                 {\n                     String remainder = input.substring(2);\n                     String combined = \"d\" + remainder;\n-                    return encode(remainder) + \"-\" + encode(combined);\n+                    return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n                 }\n             }\n         }\n--- a/src/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/java/org/apache/commons/codec/language/bm/Rule.java\n import java.util.Map;\n import java.util.Scanner;\n import java.util.Set;\n+import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n /**\n  * @since 2.0\n  */\n public class Rule {\n-    public static class Phoneme implements PhonemeExpr {\n-        private final String phonemeText;\n+    public static class Phoneme implements PhonemeExpr, Comparable<Phoneme> {\n+        private final CharSequence phonemeText;\n         private final Languages.LanguageSet languages;\n \n-        public Phoneme(String phonemeText, Languages.LanguageSet languages) {\n+        public Phoneme(CharSequence phonemeText, Languages.LanguageSet languages) {\n             this.phonemeText = phonemeText;\n             this.languages = languages;\n         }\n \n-        public Phoneme append(String str) {\n-            return new Phoneme(this.phonemeText + str, this.languages);\n+        public Phoneme append(CharSequence str) {\n+            return new Phoneme(new AppendableCharSeqeuence(this.phonemeText, str), this.languages);\n         }\n \n         public Languages.LanguageSet getLanguages() {\n             return Collections.singleton(this);\n         }\n \n-        public String getPhonemeText() {\n+        public CharSequence getPhonemeText() {\n             return this.phonemeText;\n         }\n \n         public Phoneme join(Phoneme right) {\n-            return new Phoneme(this.phonemeText + right.phonemeText, this.languages.restrictTo(right.languages));\n+            return new Phoneme(new AppendableCharSeqeuence(this.phonemeText, right.phonemeText), this.languages.restrictTo(right.languages));\n+        }\n+\n+        public int compareTo(Phoneme o) {\n+            for (int i = 0; i < phonemeText.length(); i++) {\n+                if (i >= o.phonemeText.length())\n+                    return +1;\n+                int c = phonemeText.charAt(i) - o.phonemeText.charAt(i);\n+                if (c != 0)\n+                    return c;\n+            }\n+\n+            if (phonemeText.length() < o.phonemeText.length())\n+                return -1;\n+\n+            return 0;\n         }\n     }\n \n         return str;\n     }\n \n-    private final Pattern lContext;\n+    private final RPattern lContext;\n \n     private final String pattern;\n \n     private final PhonemeExpr phoneme;\n \n-    private final Pattern rContext;\n+    private final RPattern rContext;\n \n     /**\n      * Creates a new rule.\n      */\n     public Rule(String pattern, String lContext, String rContext, PhonemeExpr phoneme) {\n         this.pattern = pattern;\n-        this.lContext = Pattern.compile(lContext + \"$\");\n-        this.rContext = Pattern.compile(\"^\" + rContext + \".*\");\n+        this.lContext = pattern(lContext + \"$\");\n+        this.rContext = pattern(\"^\" + rContext);\n         this.phoneme = phoneme;\n     }\n \n      * \n      * @return the left context Pattern\n      */\n-    public Pattern getLContext() {\n+    public RPattern getLContext() {\n         return this.lContext;\n     }\n-\n-    // /**\n-    // * Decides if the language restriction for this rule applies.\n-    // *\n-    // * @param languageArg\n-    // * a Set of Strings giving the names of the languages in scope\n-    // * @return true if these satistfy the language and logical restrictions on this rule, false otherwise\n-    // */\n-    // public boolean languageMatches(Set<String> languageArg) {\n-    // if (!languageArg.contains(Languages.ANY) && !this.languages.isEmpty()) {\n-    // if (ALL.equals(this.logical) && !languageArg.containsAll(this.languages)) {\n-    // return false;\n-    // } else {\n-    // Set<String> isect = new HashSet<String>(languageArg);\n-    // isect.retainAll(this.languages);\n-    // return !isect.isEmpty();\n-    // }\n-    // } else {\n-    // return true;\n-    // }\n-    // }\n \n     /**\n      * Gets the pattern. This is a string-literal that must exactly match.\n      * \n      * @return the right context Pattern\n      */\n-    public Pattern getRContext() {\n+    public RPattern getRContext() {\n         return this.rContext;\n     }\n \n      *            the int position within the input\n      * @return true if the pattern and left/right context match, false otherwise\n      */\n-    public boolean patternAndContextMatches(String input, int i) {\n+    public boolean patternAndContextMatches(CharSequence input, int i) {\n         if (i < 0)\n             throw new IndexOutOfBoundsException(\"Can not match pattern at negative indexes\");\n \n             return false;\n         }\n \n-        boolean patternMatches = input.substring(i, ipl).equals(this.pattern);\n-        boolean rContextMatches = this.rContext.matcher(input.substring(ipl)).find();\n-        boolean lContextMatches = this.lContext.matcher(input.substring(0, i)).find();\n+        boolean patternMatches = input.subSequence(i, ipl).equals(this.pattern);\n+        boolean rContextMatches = this.rContext.matcher(input.subSequence(ipl, input.length())).find();\n+        boolean lContextMatches = this.lContext.matcher(input.subSequence(0, i)).find();\n \n         return patternMatches && rContextMatches && lContextMatches;\n     }\n+\n+    /**\n+     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\n+     */\n+    public static interface RPattern {\n+        public RMatcher matcher(CharSequence input);\n+    }\n+\n+    /**\n+     * A minimal wrapper around the functionality of Matcher that we use, to allow for alternate implementations.\n+     */\n+    public static interface RMatcher {\n+        public boolean find();\n+    }\n+\n+    /**\n+     * Attempt to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.\n+     * \n+     * @param regex\n+     *            the regular expression to compile\n+     * @return an RPattern that will match this regex\n+     */\n+    private static RPattern pattern(final String regex) {\n+        boolean startsWith = regex.startsWith(\"^\");\n+        boolean endsWith = regex.endsWith(\"$\");\n+        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\n+        boolean boxes = content.contains(\"[\");\n+\n+        if (!boxes) {\n+            if (startsWith && endsWith) {\n+                // exact match\n+                if (content.length() == 0) {\n+                    // empty\n+                    return new RPattern() {\n+                        public RMatcher matcher(final CharSequence input) {\n+                            return new RMatcher() {\n+                                public boolean find() {\n+                                    return input.length() == 0;\n+                                }\n+                            };\n+                        }\n+                    };\n+                } else {\n+                    return new RPattern() {\n+                        public RMatcher matcher(final CharSequence input) {\n+                            return new RMatcher() {\n+                                public boolean find() {\n+                                    return input.equals(content);\n+                                }\n+                            };\n+                        }\n+                    };\n+                }\n+            } else if ((startsWith || endsWith) && content.length() == 0) {\n+                // matches every string\n+                return new RPattern() {\n+                    public RMatcher matcher(CharSequence input) {\n+                        return new RMatcher() {\n+                            public boolean find() {\n+                                return true;\n+                            }\n+                        };\n+                    }\n+                };\n+            } else if (startsWith) {\n+                // matches from start\n+                return new RPattern() {\n+                    public RMatcher matcher(final CharSequence input) {\n+                        return new RMatcher() {\n+                            public boolean find() {\n+                                return startsWith(input, content);\n+                            }\n+                        };\n+                    }\n+                };\n+            } else if (endsWith) {\n+                // matches from start\n+                return new RPattern() {\n+                    public RMatcher matcher(final CharSequence input) {\n+                        return new RMatcher() {\n+                            public boolean find() {\n+                                return endsWith(input, content);\n+                            }\n+                        };\n+                    }\n+                };\n+            }\n+        } else {\n+            boolean startsWithBox = content.startsWith(\"[\");\n+            boolean endsWithBox = content.endsWith(\"]\");\n+\n+            if (startsWithBox && endsWithBox) {\n+                String boxContent = content.substring(1, content.length() - 1);\n+                if (!boxContent.contains(\"[\")) {\n+                    // box containing alternatives\n+                    boolean negate = boxContent.startsWith(\"^\");\n+                    if (negate) {\n+                        boxContent = boxContent.substring(1);\n+                    }\n+                    final String bContent = boxContent;\n+                    final boolean shouldMatch = !negate;\n+\n+                    if (startsWith && endsWith) {\n+                        // exact match\n+                        return new RPattern() {\n+                            public RMatcher matcher(final CharSequence input) {\n+                                return new RMatcher() {\n+                                    public boolean find() {\n+                                        return input.length() == 1 && (contains(bContent, input.charAt(0)) == shouldMatch);\n+                                    }\n+                                };\n+                            }\n+                        };\n+                    } else if (startsWith) {\n+                        // first char\n+                        return new RPattern() {\n+                            public RMatcher matcher(final CharSequence input) {\n+                                return new RMatcher() {\n+                                    public boolean find() {\n+                                        return input.length() > 0 && (contains(bContent, input.charAt(0)) == shouldMatch);\n+                                    }\n+                                };\n+                            }\n+                        };\n+                    } else if (endsWith) {\n+                        // last char\n+                        return new RPattern() {\n+                            public RMatcher matcher(final CharSequence input) {\n+                                return new RMatcher() {\n+                                    public boolean find() {\n+                                        return input.length() > 0 && (contains(bContent, input.charAt(input.length() - 1)) == shouldMatch);\n+                                    }\n+                                };\n+                            }\n+                        };\n+                    }\n+                }\n+            }\n+        }\n+\n+        // System.out.println(\"Couldn't optimize regex: \" + regex);\n+        return new RPattern() {\n+            Pattern pattern = Pattern.compile(regex);\n+\n+            public RMatcher matcher(CharSequence input) {\n+                final Matcher matcher = pattern.matcher(input);\n+                return new RMatcher() {\n+                    public boolean find() {\n+                        return matcher.find();\n+                    }\n+                };\n+            }\n+        };\n+    }\n+\n+    private static boolean startsWith(CharSequence input, CharSequence prefix) {\n+        if (prefix.length() > input.length())\n+            return false;\n+        for (int i = 0; i < prefix.length(); i++) {\n+            if (input.charAt(i) != prefix.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static boolean endsWith(CharSequence input, CharSequence suffix) {\n+        if (suffix.length() > input.length())\n+            return false;\n+        for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) {\n+            if (input.charAt(i) != suffix.charAt(j)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static boolean contains(CharSequence chars, char input) {\n+        for (int i = 0; i < chars.length(); i++) {\n+            if (chars.charAt(i) == input) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static class AppendableCharSeqeuence implements CharSequence {\n+        private final CharSequence left;\n+        private final CharSequence right;\n+        private final int length;\n+        private String contentCache = null;\n+\n+        private AppendableCharSeqeuence(CharSequence left, CharSequence right) {\n+            this.left = left;\n+            this.right = right;\n+            this.length = left.length() + right.length();\n+        }\n+\n+        public int length() {\n+            return length;\n+        }\n+\n+        public char charAt(int index) {\n+            // int lLength = left.length();\n+            // if(index < lLength) return left.charAt(index);\n+            // else return right.charAt(index - lLength);\n+            return toString().charAt(index);\n+        }\n+\n+        public CharSequence subSequence(int start, int end) {\n+            // int lLength = left.length();\n+            // if(start > lLength) return right.subSequence(start - lLength, end - lLength);\n+            // else if(end <= lLength) return left.subSequence(start, end);\n+            // else {\n+            // CharSequence newLeft = left.subSequence(start, lLength);\n+            // CharSequence newRight = right.subSequence(0, end - lLength);\n+            // return new AppendableCharSeqeuence(newLeft, newRight);\n+            // }\n+            return toString().subSequence(start, end);\n+        }\n+\n+        public CharSequence append(CharSequence right) {\n+            return new AppendableCharSeqeuence(this, right);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (contentCache == null) {\n+                StringBuilder sb = new StringBuilder();\n+                buildString(sb);\n+                contentCache = sb.toString();\n+                // System.err.println(\"Materialized string: \" + contentCache);\n+            }\n+            return contentCache;\n+        }\n+\n+        public void buildString(StringBuilder sb) {\n+            if (left instanceof AppendableCharSeqeuence) {\n+                ((AppendableCharSeqeuence) left).buildString(sb);\n+            } else {\n+                sb.append(left);\n+            }\n+            if (right instanceof AppendableCharSeqeuence) {\n+                ((AppendableCharSeqeuence) right).buildString(sb);\n+            } else {\n+                sb.append(right);\n+            }\n+        }\n+    }\n }\n--- a/src/test/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n+++ b/src/test/org/apache/commons/codec/language/bm/BeiderMorseEncoderTest.java\n         bmpm.setRuleType(RuleType.RULES);\n     }\n \n-    @Test(timeout = 20000L)\n+    @Test(/* timeout = 20000L */)\n     public void testSpeedCheck() throws EncoderException {\n         char[] chars = new char[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'o', 'u' };\n         BeiderMorseEncoder bmpm = createGenericApproxEncoder();\n--- a/src/test/org/apache/commons/codec/language/bm/LanguageGuessingTest.java\n+++ b/src/test/org/apache/commons/codec/language/bm/LanguageGuessingTest.java\n                 { \"Renault\", \"french\", EXACT },\n                 { \"Mickiewicz\", \"polish\", EXACT },\n                 { \"Thompson\", \"english\", ONE_OF }, // this also hits german and greeklatin\n-                { \"Nu\u00f1ez\", \"spanish\", EXACT }, { \"Carvalho\", \"portuguese\", EXACT }, { \"\u010capek\", \"czech\", EXACT },\n-                { \"Sjneijder\", \"dutch\", EXACT }, { \"Klausewitz\", \"german\", EXACT }, { \"K\u00fc\u00e7\u00fck\", \"turkish\", EXACT },\n-                { \"Giacometti\", \"italian\", EXACT }, { \"Nagy\", \"hungarian\", EXACT }, { \"Ceau\u015fescu\", \"romanian\", EXACT },\n-                { \"Angelopoulos\", \"greeklatin\", EXACT }, { \"\u0391\u03b3\u03b3\u03b5\u03bb\u03cc\u03c0\u03bf\u03c5\u03bb\u03bf\u03c2\", \"greek\", EXACT }, { \"\u041f\u0443\u0448\u043a\u0438\u043d\", \"cyrillic\", EXACT },\n-                { \"\u05db\u05d4\u05df\", \"hebrew\", EXACT }, { \"\u00e1cz\", \"any\", EXACT }, { \"\u00e1tz\", \"any\", EXACT } });\n+                { \"Nu\u00f1ez\", \"spanish\", EXACT },\n+                { \"Carvalho\", \"portuguese\", EXACT },\n+                { \"\u010capek\", \"czech\", EXACT },\n+                { \"Sjneijder\", \"dutch\", EXACT },\n+                { \"Klausewitz\", \"german\", EXACT },\n+                { \"K\u00fc\u00e7\u00fck\", \"turkish\", EXACT },\n+                { \"Giacometti\", \"italian\", EXACT },\n+                { \"Nagy\", \"hungarian\", EXACT },\n+                { \"Ceau\u015fescu\", \"romanian\", EXACT },\n+                { \"Angelopoulos\", \"greeklatin\", EXACT },\n+                { \"\u0391\u03b3\u03b3\u03b5\u03bb\u03cc\u03c0\u03bf\u03c5\u03bb\u03bf\u03c2\", \"greek\", EXACT },\n+                { \"\u041f\u0443\u0448\u043a\u0438\u043d\", \"cyrillic\", EXACT },\n+                { \"\u05db\u05d4\u05df\", \"hebrew\", EXACT },\n+                { \"\u00e1cz\", \"any\", EXACT },\n+                { \"\u00e1tz\", \"any\", EXACT } });\n     }\n \n     private final String exactness;\n--- a/src/test/org/apache/commons/codec/language/bm/PhoneticEngineTest.java\n+++ b/src/test/org/apache/commons/codec/language/bm/PhoneticEngineTest.java\n \n     @Parameterized.Parameters\n     public static List<Object[]> data() {\n-        return Arrays.asList(new Object[] { \"Renault\", \"rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult\", NameType.GENERIC,\n-                RuleType.APPROX, true }, new Object[] { \"Renault\", \"rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult\", NameType.ASHKENAZI,\n-                RuleType.APPROX, true }, new Object[] { \"Renault\", \"rinDlt\", NameType.SEPHARDIC, RuleType.APPROX, true }, new Object[] {\n-                \"SntJohn-Smith\", \"sntjonsmit\", NameType.GENERIC, RuleType.EXACT, true }, new Object[] { \"d'ortley\",\n-                \"ortlaj|ortlaj|ortlej|ortlej-dortlaj|dortlaj|dortlej|dortlej\", NameType.GENERIC, RuleType.EXACT, true }, new Object[] {\n-                \"van helsing\",\n-                \"elSink|elsink|helSink|helsink|helzink|xelsink-banhelsink|fanhelsink|fanhelzink|vanhelsink|vanhelzink|vanjelsink\",\n-                NameType.GENERIC, RuleType.EXACT, false });\n+        return Arrays\n+                .asList(new Object[] {\n+                        \"Renault\",\n+                        \"rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult\",\n+                        NameType.GENERIC,\n+                        RuleType.APPROX,\n+                        true },\n+                        new Object[] { \"Renault\", \"rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult\", NameType.ASHKENAZI, RuleType.APPROX, true },\n+                        new Object[] { \"Renault\", \"rinDlt\", NameType.SEPHARDIC, RuleType.APPROX, true },\n+                        new Object[] { \"SntJohn-Smith\", \"sntjonsmit\", NameType.GENERIC, RuleType.EXACT, true },\n+                        new Object[] { \"d'ortley\", \"(ortlaj|ortlej)-(dortlaj|dortlej)\", NameType.GENERIC, RuleType.EXACT, true },\n+                        new Object[] {\n+                                \"van helsing\",\n+                                \"(elSink|elsink|helSink|helsink|helzink|xelsink)-(banhelsink|fanhelsink|fanhelzink|vanhelsink|vanhelzink|vanjelsink)\",\n+                                NameType.GENERIC,\n+                                RuleType.EXACT,\n+                                false });\n     }\n \n     private final boolean concat;\n--- a/src/test/org/apache/commons/codec/language/bm/RuleTest.java\n+++ b/src/test/org/apache/commons/codec/language/bm/RuleTest.java\n \n package org.apache.commons.codec.language.bm;\n \n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n \n-import org.junit.runners.Parameterized;\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.junit.Test;\n \n /**\n  * Tests Rule.\n  * @author Apache Software Foundation\n  * @since 2.0\n  */\n-// @RunWith(Parameterized.class)\n public class RuleTest {\n+    private Rule.Phoneme[][] makePhonemes() {\n+        String[][] words = {\n+                { \"rinD\", \"rinDlt\", \"rina\", \"rinalt\", \"rino\", \"rinolt\", \"rinu\", \"rinult\" },\n+                { \"dortlaj\", \"dortlej\", \"ortlaj\", \"ortlej\", \"ortlej-dortlaj\" } };\n+        Rule.Phoneme[][] phonemes = new Rule.Phoneme[words.length][];\n \n-    @Parameterized.Parameters\n-    public static List<Object[]> data() {\n-        return Arrays.asList(\n-                new Object[] {\n-                        \"matching language sets with ALL\",\n-                        new Rule(\"e\", \"\", \"\", new Rule.Phoneme(\"o\", Languages.LanguageSet.from(new HashSet<String>(Arrays.asList(\"english\",\n-                                \"french\"))))), new HashSet<String>(Arrays.asList(\"english\", \"french\")), true },\n-                new Object[] {\n-                        \"non-matching language sets with ALL\",\n-                        new Rule(\"e\", \"\", \"\", new Rule.Phoneme(\"o\", Languages.LanguageSet.from(new HashSet<String>(Arrays.asList(\"english\",\n-                                \"french\"))))), new HashSet<String>(Arrays.asList(\"english\")), false });\n+        for (int i = 0; i < words.length; i++) {\n+            String[] words_i = words[i];\n+            Rule.Phoneme[] phonemes_i = phonemes[i] = new Rule.Phoneme[words_i.length];\n+            for (int j = 0; j < words_i.length; j++) {\n+                phonemes_i[j] = new Rule.Phoneme(words_i[j], Languages.NO_LANGUAGES);\n+            }\n+        }\n+\n+        return phonemes;\n     }\n \n-    private final String caseName;\n-    private final boolean expected;\n-    private final Set<String> langs;\n-    private final Rule rule;\n-\n-    public RuleTest(String caseName, Rule rule, Set<String> langs, boolean expected) {\n-        this.caseName = caseName;\n-        this.rule = rule;\n-        this.langs = langs;\n-        this.expected = expected;\n+    @Test\n+    public void phonemeComparedToSelfIsZero() {\n+        for (Rule.Phoneme[] phs : makePhonemes()) {\n+            for (Rule.Phoneme ph : phs) {\n+                assertEquals(\"Phoneme compared to itself should be zero: \" + ph.getPhonemeText(), 0, ph.compareTo(ph));\n+            }\n+        }\n     }\n \n-    // @Test\n-    // public void testRuleLanguageMatches() {\n-    // assertEquals(this.caseName, this.expected, this.rule.languageMatches(this.langs));\n-    // }\n+    @Test\n+    public void phonemeComparedToLaterIsNegative() {\n+        for (Rule.Phoneme[] phs : makePhonemes()) {\n+            for (int i = 0; i < phs.length; i++) {\n+                for (int j = i + 1; j < phs.length; j++) {\n+                    int c = phs[i].compareTo(phs[j]);\n \n+                    assertThat(\"Comparing \" + phs[i].getPhonemeText() + \" to \" + phs[j].getPhonemeText() + \" should be negative\", c,\n+                            new NegativeIntegerBaseMatcher());\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class NegativeIntegerBaseMatcher extends BaseMatcher<Integer> {\n+        public boolean matches(Object item) {\n+            return ((Integer) item) < 0;\n+        }\n+\n+        public void describeTo(Description description) {\n+            description.appendText(\"value should be negative\");\n+        }\n+    }\n }", "timestamp": 1312596577, "metainfo": ""}