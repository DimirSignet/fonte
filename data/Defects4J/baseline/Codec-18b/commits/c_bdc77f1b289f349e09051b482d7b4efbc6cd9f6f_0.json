{"sha": "bdc77f1b289f349e09051b482d7b4efbc6cd9f6f", "log": "[CODEC-121] QuotedPrintableCodec does not support soft line break per the 'quoted-printable' example on Wikipedia. Apply patch from TN.  ", "commit": "\n--- a/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n+++ b/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n  * <p>\n  * Note:\n  * <p>\n- * Rules #3, #4, and #5 of the quoted-printable spec are not implemented yet because the complete quoted-printable spec\n- * does not lend itself well into the byte[] oriented codec framework. Complete the codec once the streamable codec\n- * framework is ready. The motivation behind providing the codec in a partial form is that it can already come in handy\n- * for those applications that do not require quoted-printable line formatting (rules #3, #4, #5), for instance Q codec.\n+ * Depending on the selected {@code strict} parameter, this class will implement a different set of rules of the\n+ * quoted-printable spec:\n+ * <ul>\n+ *   <li>{@code strict=false}: only rules #1 and #2 are implemented \n+ *   <li>{@code strict=true}: all rules #1 through #5 are implemented\n+ * </ul>\n+ * Originally, this class only supported the non-strict mode, but the codec in this partial form could already be used\n+ * for certain applications that do not require quoted-printable line formatting (rules #3, #4, #5), for instance Q codec.\n+ * The strict mode has been added in 1.10.\n  * <p>\n  * This class is immutable and thread-safe.\n  *\n- * @see <a href=\"http://www.ietf.org/rfc/rfc1521.txt\"> RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One:\n+ * @see <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One:\n  *          Mechanisms for Specifying and Describing the Format of Internet Message Bodies </a>\n  *\n  * @since 1.3\n     private final Charset charset;\n \n     /**\n+     * Indicates whether soft line breaks shall be used during encoding (rule #3-5).\n+     */\n+    private final boolean strict;\n+\n+    /**\n      * BitSet of printable characters as defined in RFC 1521.\n      */\n     private static final BitSet PRINTABLE_CHARS = new BitSet(256);\n     private static final byte TAB = 9;\n \n     private static final byte SPACE = 32;\n+\n+    private static final byte CR = 13;\n+\n+    private static final byte LF = 10;\n+\n+    /**\n+     * Safe line length for quoted printable encoded text.\n+     */\n+    private static final int SAFE_LENGTH = 73;\n+\n     // Static initializer for printable chars collection\n     static {\n         // alpha characters\n      * Default constructor, assumes default charset of {@link Charsets#UTF_8}\n      */\n     public QuotedPrintableCodec() {\n-        this(Charsets.UTF_8);\n+        this(Charsets.UTF_8, false);\n+    }\n+\n+    /**\n+     * Constructor which allows for the selection of the strict mode.\n+     *\n+     * @param strict\n+     *            if {@code true}, soft line breaks will be used\n+     * @since 1.10\n+     */\n+    public QuotedPrintableCodec(final boolean strict) {\n+        this(Charsets.UTF_8, strict);\n     }\n \n     /**\n      * @since 1.7\n      */\n     public QuotedPrintableCodec(final Charset charset) {\n+        this(charset, false);\n+    }\n+\n+    /**\n+     * Constructor which allows for the selection of a default charset and strict mode.\n+     *\n+     * @param charset\n+     *            the default string charset to use.\n+     * @param strict\n+     *            if {@code true}, soft line breaks will be used\n+     * @since 1.10\n+     */\n+    public QuotedPrintableCodec(final Charset charset, final boolean strict) {\n         this.charset = charset;\n+        this.strict = strict;\n     }\n \n     /**\n      */\n     public QuotedPrintableCodec(final String charsetName)\n             throws IllegalCharsetNameException, IllegalArgumentException, UnsupportedCharsetException {\n-        this(Charset.forName(charsetName));\n+        this(Charset.forName(charsetName), false);\n     }\n \n     /**\n      *            byte to encode\n      * @param buffer\n      *            the buffer to write to\n-     */\n-    private static final void encodeQuotedPrintable(final int b, final ByteArrayOutputStream buffer) {\n+     * @return The number of bytes written to the <code>buffer</code>\n+     */\n+    private static final int encodeQuotedPrintable(final int b, final ByteArrayOutputStream buffer) {\n         buffer.write(ESCAPE_CHAR);\n         final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n         final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n         buffer.write(hex1);\n         buffer.write(hex2);\n+        return 3;\n+    }\n+\n+    /**\n+     * Return the byte at position <code>index</code> of the byte array and\n+     * make sure it is unsigned.\n+     *\n+     * @param index\n+     *            position in the array\n+     * @param bytes\n+     *            the byte array\n+     * @return the unsigned octet at position <code>index</code> from the array\n+     */\n+    private static int getUnsignedOctet(final int index, final byte[] bytes) {\n+        int b = bytes[index];\n+        if (b < 0) {\n+            b = 256 + b;\n+        }\n+        return b;\n+    }\n+\n+    /**\n+     * Write a byte to the buffer.\n+     *\n+     * @param b\n+     *            byte to write\n+     * @param encode\n+     *            indicates whether the octet shall be encoded\n+     * @param buffer\n+     *            the buffer to write to\n+     * @return the number of bytes that have been written to the buffer\n+     */\n+    private static int encodeByte(final int b, final boolean encode,\n+                                  final ByteArrayOutputStream buffer) {\n+        if (encode) {\n+            return encodeQuotedPrintable(b, buffer);\n+        } else {\n+            buffer.write(b);\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the given byte is whitespace.\n+     *\n+     * @param b\n+     *            byte to be checked\n+     * @return <code>true</code> if the byte is either a space or tab character\n+     */\n+    private static boolean isWhitespace(final int b) {\n+        return b == SPACE || b == TAB;\n     }\n \n     /**\n      * @return array of bytes containing quoted-printable data\n      */\n     public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes) {\n+        return encodeQuotedPrintable(printable, bytes, false);\n+    }\n+\n+    /**\n+     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n+     * <p>\n+     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n+     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n+     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n+     *\n+     * @param printable\n+     *            bitset of characters deemed quoted-printable\n+     * @param bytes\n+     *            array of bytes to be encoded\n+     * @param strict\n+     *            if {@code true} the full ruleset is used, otherwise only rule #1 and rule #2\n+     * @return array of bytes containing quoted-printable data\n+     * @since 1.10\n+     */\n+    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, boolean strict) {\n         if (bytes == null) {\n             return null;\n         }\n             printable = PRINTABLE_CHARS;\n         }\n         final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        for (final byte c : bytes) {\n-            int b = c;\n-            if (b < 0) {\n-                b = 256 + b;\n+        \n+        if (strict) {\n+            int pos = 1;\n+            // encode up to buffer.length - 3, the last three octets will be treated\n+            // separately for simplification of note #3\n+            for (int i = 0; i < bytes.length - 3; i++) {\n+                int b = getUnsignedOctet(i, bytes);\n+                if (pos < SAFE_LENGTH) {\n+                    // up to this length it is safe to add any byte, encoded or not\n+                    pos += encodeByte(b, !printable.get(b), buffer);\n+                } else {\n+                    // rule #3: whitespace at the end of a line *must* be encoded\n+                    encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\n+\n+                    // rule #5: soft line break\n+                    buffer.write(ESCAPE_CHAR);\n+                    buffer.write(CR);\n+                    buffer.write(LF);\n+                    pos = 1;\n+                }\n             }\n-            if (printable.get(b)) {\n-                buffer.write(b);\n-            } else {\n-                encodeQuotedPrintable(b, buffer);\n+\n+            // rule #3: whitespace at the end of a line *must* be encoded\n+            // if we would do a soft break line after this octet, encode whitespace\n+            int b = getUnsignedOctet(bytes.length - 3, bytes);\n+            boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);\n+            pos += encodeByte(b, encode, buffer);\n+\n+            // note #3: '=' *must not* be the ultimate or penultimate character\n+            // simplification: if < 6 bytes left, do a soft line break as we may need\n+            //                 exactly 6 bytes space for the last 2 bytes\n+            if (pos > SAFE_LENGTH - 2) {\n+                buffer.write(ESCAPE_CHAR);\n+                buffer.write(CR);\n+                buffer.write(LF);\n+            }\n+            for (int i = bytes.length - 2; i < bytes.length; i++) {\n+                b = getUnsignedOctet(i, bytes);\n+                // rule #3: trailing whitespace shall be encoded\n+                encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));\n+                encodeByte(b, encode, buffer);\n+            }\n+        } else {\n+            for (final byte c : bytes) {\n+                int b = c;\n+                if (b < 0) {\n+                    b = 256 + b;\n+                }\n+                if (printable.get(b)) {\n+                    buffer.write(b);\n+                } else {\n+                    encodeQuotedPrintable(b, buffer);\n+                }\n             }\n         }\n         return buffer.toByteArray();\n      * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted\n      * back to their original representation.\n      * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n-     * RFC 1521.\n+     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n+     * defined in RFC 1521.\n      *\n      * @param bytes\n      *            array of quoted-printable characters\n             final int b = bytes[i];\n             if (b == ESCAPE_CHAR) {\n                 try {\n-                    final int u = Utils.digit16(bytes[++i]);\n+                    // if the next octet is a CR we have found a soft line break\n+                    if (bytes[++i] == CR) {\n+                        continue;\n+                    }\n+                    final int u = Utils.digit16(bytes[i]);\n                     final int l = Utils.digit16(bytes[++i]);\n                     buffer.write((char) ((u << 4) + l));\n                 } catch (final ArrayIndexOutOfBoundsException e) {\n                     throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n                 }\n-            } else {\n+            } else if (b != CR && b != LF) {\n+                // every other octet is appended except for CR & LF\n                 buffer.write(b);\n             }\n         }\n     /**\n      * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n      * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n+     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n+     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n      * RFC 1521 and is suitable for encoding binary data and unformatted text.\n      *\n      * @param bytes\n      */\n     @Override\n     public byte[] encode(final byte[] bytes) {\n-        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n+        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes, strict);\n     }\n \n     /**\n      * Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted\n      * back to their original representation.\n      * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n-     * RFC 1521.\n+     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n+     * defined in RFC 1521.\n      *\n      * @param bytes\n      *            array of quoted-printable characters\n     /**\n      * Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped.\n      * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n-     * RFC 1521 and is suitable for encoding binary data.\n+     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n+     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n+     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n      *\n      * @param str\n      *            string to convert to quoted-printable form\n     /**\n      * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n      * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n+     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n+     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n      * RFC 1521 and is suitable for encoding binary data and unformatted text.\n      *\n      * @param str\n     /**\n      * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\n      * <p>\n-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n+     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n+     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n      * RFC 1521 and is suitable for encoding binary data and unformatted text.\n      *\n      * @param str\n--- a/src/test/java/org/apache/commons/codec/net/QuotedPrintableCodecTest.java\n+++ b/src/test/java/org/apache/commons/codec/net/QuotedPrintableCodecTest.java\n \n package org.apache.commons.codec.net;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n import java.nio.charset.UnsupportedCharsetException;\n \n import org.apache.commons.codec.Charsets;\n import org.apache.commons.codec.DecoderException;\n import org.apache.commons.codec.EncoderException;\n-import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n     }\n \n     @Test\n-    @Ignore\n-    /**\n-     * The QuotedPrintableCodec documentation states that this is not supported.\n-     *\n-     * @throws Exception\n-     * @see <a href=\"https://issues.apache.org/jira/browse/CODEC-121\">CODEC-121</a>\n-     */\n     public void testSoftLineBreakDecode() throws Exception {\n         final String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics is the most beautiful branch of philosophy.\";\n         final String expected = \"If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy.\";\n-        assertEquals(expected, new QuotedPrintableCodec().decode(qpdata));\n-    }\n-\n-    @Test\n-    @Ignore\n-    /**\n-     * The QuotedPrintableCodec documentation states that this is not supported.\n-     *\n-     * @throws Exception\n-     * @see <a href=\"https://issues.apache.org/jira/browse/CODEC-121\">CODEC-121</a>\n-     */\n+\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        assertEquals(expected, qpcodec.decode(qpdata));\n+\n+        String encoded = qpcodec.encode(expected);\n+        assertEquals(expected, qpcodec.decode(encoded));\n+    }\n+\n+    @Test\n     public void testSoftLineBreakEncode() throws Exception {\n-        final String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\nmathematics is the most beautiful branch of philosophy.\";\n+        final String qpdata = \"If you believe that truth=3Dbeauty, then surely mathematics is the most b=\\r\\neautiful branch of philosophy.\";\n         final String expected = \"If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy.\";\n-        assertEquals(qpdata, new QuotedPrintableCodec().encode(expected));\n+\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(true);\n+        assertEquals(qpdata, qpcodec.encode(expected));\n+\n+        String decoded = qpcodec.decode(qpdata);\n+        assertEquals(qpdata, qpcodec.encode(decoded));\n+    }\n+\n+    @Test\n+    public void testSkipNotEncodedCRLF() throws Exception {\n+        String qpdata = \"CRLF in an\\n encoded text should be=20=\\r\\n\\rskipped in the\\r decoding.\";\n+        String expected = \"CRLF in an encoded text should be skipped in the decoding.\";\n+\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(true);\n+        assertEquals(expected, qpcodec.decode(qpdata));\n+\n+        String encoded = qpcodec.encode(expected);\n+        assertEquals(expected, qpcodec.decode(encoded));\n+    }\n+\n+    @Test\n+    public void testTrailingSpecial() throws Exception {\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(true);\n+\n+        String plain =\"This is a example of a quoted-printable text file. This might contain sp=cial chars.\";\n+        String expected = \"This is a example of a quoted-printable text file. This might contain sp=3D=\\r\\ncial chars.\";\n+        assertEquals(expected, qpcodec.encode(plain));\n+                \n+        plain =\"This is a example of a quoted-printable text file. This might contain ta\\tbs as well.\";\n+        expected = \"This is a example of a quoted-printable text file. This might contain ta=09=\\r\\nbs as well.\";\n+        assertEquals(expected, qpcodec.encode(plain));\n+    }\n+\n+    @Test\n+    public void testUltimateSoftBreak() throws Exception {\n+        final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(true);\n+\n+        String plain =\"This is a example of a quoted-printable text file. There is no end to it\\t\";\n+        String expected = \"This is a example of a quoted-printable text file. There is no end to i=\\r\\nt=09\";\n+\n+        assertEquals(expected, qpcodec.encode(plain));\n+\n+        plain =\"This is a example of a quoted-printable text file. There is no end to it \";\n+        expected = \"This is a example of a quoted-printable text file. There is no end to i=\\r\\nt=20\";\n+\n+        assertEquals(expected, qpcodec.encode(plain));\n+\n+        // whitespace before soft break\n+        plain =\"This is a example of a quoted-printable text file. There is no end to   \";\n+        expected = \"This is a example of a quoted-printable text file. There is no end to=20=\\r\\n =20\";\n+\n+        assertEquals(expected, qpcodec.encode(plain));\n+\n+        // non-printable character before soft break\n+        plain =\"This is a example of a quoted-printable text file. There is no end to=  \";\n+        expected = \"This is a example of a quoted-printable text file. There is no end to=3D=\\r\\n =20\";\n+\n+        assertEquals(expected, qpcodec.encode(plain));\n+    }\n+\n+    @Test\n+    public void testFinalBytes() throws Exception {\n+        // whitespace, but does not need to be encoded\n+        final String plain =\"This is a example of a quoted=printable text file. There is no tt\";\n+        final String expected = \"This is a example of a quoted=3Dprintable text file. There is no tt\";\n+\n+        assertEquals(expected, new QuotedPrintableCodec(true).encode(plain));\n     }\n }", "timestamp": 1415230994, "metainfo": ""}