{"sha": "04c4921e077293ebecb50c6ef87d9bffbce72a72", "log": "removed debug flag and console outputs  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n     private static final int BUFFER_SIZE = 8 * 1024;\n     private static final int LARGE_BUFFER_SIZE = 32 * 1024;\n \n-    private boolean debug;\n     private boolean hasHitEOF;\n     private long entrySize;\n     private long entryOffset;\n     public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n         this.buffer = new TarBuffer(is, blockSize, recordSize);\n         this.readBuf = null;\n-        this.debug = false;\n         this.hasHitEOF = false;\n-    }\n-\n-    /**\n-     * Sets the debugging flag.\n-     *\n-     * @param debug True to turn on debugging.\n-     */\n-    public void setDebug(boolean debug) {\n-        this.debug = debug;\n-        buffer.setDebug(debug);\n     }\n \n     /**\n         if (currEntry != null) {\n             long numToSkip = entrySize - entryOffset;\n \n-            if (debug) {\n-                System.err.println(\"TarInputStream: SKIP currENTRY '\"\n-                                   + currEntry.getName() + \"' SZ \"\n-                                   + entrySize + \" OFF \"\n-                                   + entryOffset + \"  skipping \"\n-                                   + numToSkip + \" bytes\");\n-            }\n-\n             while (numToSkip > 0) {\n                 long skipped = skip(numToSkip);\n                 if (skipped <= 0) {\n         byte[] headerBuf = buffer.readRecord();\n \n         if (headerBuf == null) {\n-            if (debug) {\n-                System.err.println(\"READ NULL RECORD\");\n-            }\n             hasHitEOF = true;\n         } else if (buffer.isEOFRecord(headerBuf)) {\n-            if (debug) {\n-                System.err.println(\"READ EOF RECORD\");\n-            }\n             hasHitEOF = true;\n         }\n \n             currEntry = null;\n         } else {\n             currEntry = new TarArchiveEntry(headerBuf);\n-\n-            if (debug) {\n-                System.err.println(\"TarInputStream: SET CURRENTRY '\"\n-                                   + currEntry.getName()\n-                                   + \"' size = \"\n-                                   + currEntry.getSize());\n-            }\n-\n             entryOffset = 0;\n-\n             entrySize = currEntry.getSize();\n         }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n     /** GNU tar extensions are used to store long file names in the archive. */\n     public static final int LONGFILE_GNU = 2;\n \n-    private boolean   debug;// NOT READ\n     private long      currSize;\n     private String    currName;\n     private long      currBytes;\n         out = os;\n \n         this.buffer = new TarBuffer(os, blockSize, recordSize);\n-        this.debug = false;\n         this.assemLen = 0;\n         this.assemBuf = new byte[recordSize];\n         this.recordBuf = new byte[recordSize];\n         this.longFileMode = longFileMode;\n     }\n \n-\n-    /**\n-     * Sets the debugging flag.\n-     *\n-     * @param debugF True to turn on debugging.\n-     */\n-    public void setDebug(boolean debugF) {\n-        this.debug = debugF;\n-    }\n-\n-    /**\n-     * Sets the debugging flag in this stream's TarBuffer.\n-     *\n-     * @param debug True to turn on debugging.\n-     */\n-    public void setBufferDebug(boolean debug) {\n-        buffer.setDebug(debug);\n-    }\n \n     /**\n      * Ends the TAR archive without closing the underlying OutputStream.\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarBuffer.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarBuffer.java\n     private int             blockSize;\n     private int             recordSize;\n     private int             recsPerBlock;\n-    private boolean         debug;\n-\n+    \n     /**\n      * Constructor for a TarBuffer on an input stream.\n      * @param inStream the input stream to use\n      * Initialization common to all constructors.\n      */\n     private void initialize(int blockSize, int recordSize) {\n-        this.debug = false;\n         this.blockSize = blockSize;\n         this.recordSize = recordSize;\n         this.recsPerBlock = (this.blockSize / this.recordSize);\n     }\n \n     /**\n-     * Set the debugging flag for the buffer.\n-     *\n-     * @param debug If true, print debugging output.\n-     */\n-    public void setDebug(boolean debug) {\n-        this.debug = debug;\n-    }\n-\n-    /**\n      * Determine if an archive record indicate End of Archive. End of\n      * archive is indicated by a record that consists entirely of null bytes.\n      *\n      * @throws IOException on error\n      */\n     public void skipRecord() throws IOException {\n-        if (debug) {\n-            System.err.println(\"SkipRecord: recIdx = \" + currRecIdx\n-                               + \" blkIdx = \" + currBlkIdx);\n-        }\n-\n         if (inStream == null) {\n             throw new IOException(\"reading (via skip) from an output buffer\");\n         }\n      * @throws IOException on error\n      */\n     public byte[] readRecord() throws IOException {\n-        if (debug) {\n-            System.err.println(\"ReadRecord: recIdx = \" + currRecIdx\n-                               + \" blkIdx = \" + currBlkIdx);\n-        }\n-\n         if (inStream == null) {\n             if (outStream == null) {\n                 throw new IOException(\"input buffer is closed\");\n      * @return false if End-Of-File, else true\n      */\n     private boolean readBlock() throws IOException {\n-        if (debug) {\n-            System.err.println(\"ReadBlock: blkIdx = \" + currBlkIdx);\n-        }\n-\n         if (inStream == null) {\n             throw new IOException(\"reading from an output buffer\");\n         }\n             bytesNeeded -= numBytes;\n \n             if (numBytes != blockSize) {\n-                if (debug) {\n-                    System.err.println(\"ReadBlock: INCOMPLETE READ \"\n-                                       + numBytes + \" of \" + blockSize\n-                                       + \" bytes read.\");\n-                }\n+                // TODO: Incomplete Read occured - throw exception?\n             }\n         }\n \n      * @throws IOException on error\n      */\n     public void writeRecord(byte[] record) throws IOException {\n-        if (debug) {\n-            System.err.println(\"WriteRecord: recIdx = \" + currRecIdx\n-                               + \" blkIdx = \" + currBlkIdx);\n-        }\n-\n         if (outStream == null) {\n             if (inStream == null){\n                 throw new IOException(\"Output buffer is closed\");\n      * @throws IOException on error\n      */\n     public void writeRecord(byte[] buf, int offset) throws IOException {\n-        if (debug) {\n-            System.err.println(\"WriteRecord: recIdx = \" + currRecIdx\n-                               + \" blkIdx = \" + currBlkIdx);\n-        }\n-\n         if (outStream == null) {\n             if (inStream == null){\n                 throw new IOException(\"Output buffer is closed\");\n      * Write a TarBuffer block to the archive.\n      */\n     private void writeBlock() throws IOException {\n-        if (debug) {\n-            System.err.println(\"WriteBlock: blkIdx = \" + currBlkIdx);\n-        }\n-\n         if (outStream == null) {\n             throw new IOException(\"writing to an input buffer\");\n         }\n      * Flush the current data block if it has any data in it.\n      */\n     private void flushBlock() throws IOException {\n-        if (debug) {\n-            System.err.println(\"TarBuffer.flushBlock() called.\");\n-        }\n-\n         if (outStream == null) {\n             throw new IOException(\"writing to an input buffer\");\n         }\n      * @throws IOException on error\n      */\n     public void close() throws IOException {\n-        if (debug) {\n-            System.err.println(\"TarBuffer.closeBuffer().\");\n-        }\n-\n         if (outStream != null) {\n             flushBlock();\n ", "timestamp": 1239269511, "metainfo": ""}