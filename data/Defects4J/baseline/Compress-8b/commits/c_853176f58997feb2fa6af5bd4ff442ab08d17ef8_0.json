{"sha": "853176f58997feb2fa6af5bd4ff442ab08d17ef8", "log": "Improved encoding support for ZIPs, now with Cp437 for JDK 1.4.  Submitted by Wolfgang Glas.  SANDBOX-176  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n      * encoding of the orginal zip entry.\n      * \n      * @param text The file name or comment.\n-     * @param zipEncoding The encoding of the filenames in the zip\n-     * file, usually <code>\"CP437\"</code>.\n+     * @param bytes The encoded of the filename or comment in the zip\n+     * file.\n+     * @param off The offset of the encoded filename or comment in\n+     * <code>bytes</code>.\n+     * @param len The length of the encoded filename or commentin\n+     * <code>bytes</code>.\n      */\n-    protected AbstractUnicodeExtraField(String text, String zipEncoding) {\n-        this(text, ZipEncodingHelper.encodeName(text, zipEncoding));\n-    }\n-\n-    /**\n-     * Assemble as unicode extension from the name/comment and\n-     * encoding of the orginal zip entry.\n-     * \n-     * @param text The file name or comment.\n-     * @param zipEncoding The encoding of the filenames in the zip\n-     * file, usually <code>\"CP437\"</code>.\n-     */\n-    protected AbstractUnicodeExtraField(String text, byte[] bytes) {\n+    protected AbstractUnicodeExtraField(String text, byte[] bytes, int off,\n+                                        int len) {\n         CRC32 crc32 = new CRC32();\n-        crc32.update(bytes);\n+        crc32.update(bytes, off, len);\n         nameCRC32 = crc32.getValue();\n \n         try {\n             throw new RuntimeException(\"FATAL: UTF-8 encoding not supported.\",\n                                        e);\n         }\n+    }\n+\n+    /**\n+     * Assemble as unicode extension from the name/comment and\n+     * encoding of the orginal zip entry.\n+     * \n+     * @param text The file name or comment.\n+     * @param bytes The encoded of the filename or comment in the zip\n+     * file.\n+     */\n+    protected AbstractUnicodeExtraField(String text, byte[] bytes) {\n+\n+        this(text, bytes, 0, bytes.length);\n     }\n \n     private void assembleData() {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/FallbackZipEncoding.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * A fallback ZipEncoding, which uses a java.io means to encode names.\n+ *\n+ * <p>This implementation is not favorable for encodings other than\n+ * utf-8, because java.io encodes unmappable character as question\n+ * marks leading to unreadable ZIP entries on some operating\n+ * systems.</p>\n+ * \n+ * <p>Furthermore this implementation is unable to tell, whether a\n+ * given name can be safely encoded or not.</p>\n+ * \n+ * <p>This implementation acts as a last resort implementation, when\n+ * neither {@see Simple8BitZipEnoding} nor {@see NioZipEncoding} is\n+ * available.</p>\n+ * \n+ * <p>The methods of this class are reentrant.</p>\n+ */\n+class FallbackZipEncoding implements ZipEncoding {\n+    private final String charset;\n+\n+    /**\n+     * Construct a fallback zip encoding, which uses the platform's\n+     * default charset.\n+     */\n+    public FallbackZipEncoding() {\n+        this.charset = null;\n+    }\n+\n+    /**\n+     * Construct a fallback zip encoding, which uses the given charset.\n+     * \n+     * @param charset The name of the charset or <code>null</code> for\n+     *                the platform's default character set.\n+     */\n+    public FallbackZipEncoding(String charset) {\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n+     */\n+    public boolean canEncode(String name) {\n+        return true;\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n+     */\n+    public ByteBuffer encode(String name) throws IOException {\n+        if (this.charset == null) {\n+            return ByteBuffer.wrap(name.getBytes());\n+        } else {\n+            return ByteBuffer.wrap(name.getBytes(this.charset));\n+        }\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#decode(byte[])\n+     */\n+    public String decode(byte[] data) throws IOException {\n+        if (this.charset == null) {\n+            return new String(data);\n+        } else {\n+            return new String(data,this.charset);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/NioZipEncoding.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+import java.nio.charset.CodingErrorAction;\n+\n+/**\n+ * A ZipEncoding, which uses a java.nio {@link\n+ * java.nio.charset.Charset Charset} to encode names.\n+ *\n+ * <p>This implementation works for all cases under java-1.5 or\n+ * later. However, in java-1.4, some charsets don't have a java-nio\n+ * implementation, most notably the default ZIP encoding Cp437.</p>\n+ * \n+ * <p>The methods of this class are reentrant.</p>\n+ */\n+class NioZipEncoding implements ZipEncoding {\n+    private final Charset charset;\n+\n+    /**\n+     * Construct an NIO based zip encoding, which wraps the given\n+     * charset.\n+     * \n+     * @param charset The NIO charset to wrap.\n+     */\n+    public NioZipEncoding(Charset charset) {\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n+     */\n+    public boolean canEncode(String name) {\n+        CharsetEncoder enc = this.charset.newEncoder();\n+        enc.onMalformedInput(CodingErrorAction.REPORT);\n+        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n+\n+        return enc.canEncode(name);\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n+     */\n+    public ByteBuffer encode(String name) {\n+        CharsetEncoder enc = this.charset.newEncoder();\n+\n+        enc.onMalformedInput(CodingErrorAction.REPORT);\n+        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n+\n+        CharBuffer cb = CharBuffer.wrap(name);\n+        ByteBuffer out = ByteBuffer.allocate(name.length()\n+                                             + (name.length() + 1) / 2);\n+\n+        while (cb.remaining() > 0) {\n+            CoderResult res = enc.encode(cb, out,true);\n+\n+            if (res.isUnmappable() || res.isMalformed()) {\n+\n+                // write the unmappable characters in utf-16\n+                // pseudo-URL encoding style to ByteBuffer.\n+                if (res.length() * 6 > out.remaining()) {\n+                    out = ZipEncodingHelper.growBuffer(out, out.position()\n+                                                       + res.length() * 6);\n+                }\n+\n+                for (int i=0; i<res.length(); ++i) {\n+                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n+                }\n+\n+            } else if (res.isOverflow()) {\n+\n+                out = ZipEncodingHelper.growBuffer(out, 0);\n+\n+            } else if (res.isUnderflow()) {\n+\n+                enc.flush(out);\n+                break;\n+\n+            }\n+        }\n+\n+        out.limit(out.position());\n+        out.rewind();\n+        return out;\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#decode(byte[])\n+     */\n+    public String decode(byte[] data) throws IOException {\n+        return this.charset.newDecoder()\n+            .onMalformedInput(CodingErrorAction.REPORT)\n+            .onUnmappableCharacter(CodingErrorAction.REPORT)\n+            .decode(ByteBuffer.wrap(data)).toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEnoding.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This ZipEncoding implementation implements a simple 8bit character\n+ * set, which mets the following restrictions:\n+ * \n+ * <ul>\n+ * <li>Characters 0x0000 to 0x007f are encoded as the corresponding\n+ *        byte values 0x00 to 0x7f.</li>\n+ * <li>All byte codes from 0x80 to 0xff are mapped to a unique unicode\n+ *       character in the range 0x0080 to 0x7fff. (No support for\n+ *       UTF-16 surrogates)\n+ * </ul>\n+ * \n+ * <p>These restrictions most notably apply to the most prominent\n+ * omissions of java-1.4's {@link java.nio.charset.Charset Charset}\n+ * implementation, Cp437 and Cp850.</p>\n+ * \n+ * <p>The methods of this class are reentrant.</p>\n+ */\n+class Simple8BitZipEnoding implements ZipEncoding {\n+\n+    /**\n+     * A character entity, which is put to the reverse mapping table\n+     * of a simple encoding.\n+     */\n+    private static final class Simple8BitChar implements Comparable {\n+        public final char unicode;\n+        public final byte code;\n+\n+        Simple8BitChar(byte code, char unicode) {\n+            this.code = code;\n+            this.unicode = unicode;\n+        }\n+\n+        public int compareTo(Object o) {\n+            Simple8BitChar a = (Simple8BitChar) o;\n+\n+            return this.unicode - a.unicode;\n+        }\n+\n+        public String toString() {\n+            return \"0x\" + Integer.toHexString(0xffff & (int) unicode)\n+                + \"->0x\" + Integer.toHexString(0xff & (int) code);\n+        }\n+    }\n+\n+    /**\n+     * The characters for byte values of 128 to 255 stored as an array of\n+     * 128 chars.\n+     */\n+    private final char[] highChars;\n+\n+    /**\n+     * A list of {@see Simple8BitChar} objects sorted by the unicode\n+     * field.  This list is used to binary search reverse mapping of\n+     * unicode characters with a character code greater than 127.\n+     */\n+    private final List reverseMapping;\n+\n+    /**\n+     * @param highChars The characters for byte values of 128 to 255\n+     * stored as an array of 128 chars.\n+     */\n+    public Simple8BitZipEnoding(char[] highChars) {\n+        this.highChars = highChars;\n+        this.reverseMapping = new ArrayList(this.highChars.length);\n+\n+        byte code = 127;\n+\n+        for (int i = 0; i < this.highChars.length; ++i) {\n+            this.reverseMapping.add(new Simple8BitChar(++code,\n+                                                       this.highChars[i]));\n+        }\n+\n+        Collections.sort(this.reverseMapping);\n+    }\n+\n+    /**\n+     * Return the character code for a given encoded byte.\n+     * \n+     * @param b The byte to decode.\n+     * @return The associated character value.\n+     */\n+    public char decodeByte(byte b) {\n+        // code 0-127\n+        if (b >= 0) {\n+            return (char) b;\n+        }\n+\n+        // byte is signed, so 128 == -128 and 255 == -1\n+        return this.highChars[128 + (int) b];\n+    }\n+\n+    /**\n+     * @param c The character to encode.\n+     * @return Whether the given unicode character is covered by this encoding.\n+     */\n+    public boolean canEncodeChar(char c) {\n+\n+        if (c >= 0 && c < 128) {\n+            return true;\n+        }\n+\n+        Simple8BitChar r = this.encodeHighChar(c);\n+        return r != null;\n+    }\n+\n+    /**\n+     * Pushes the encoded form of the given character to the given byte buffer.\n+     * \n+     * @param bb The byte buffer to write to.\n+     * @param c The character to encode.\n+     * @return Whether the given unicode character is covered by this encoding.\n+     *         If <code>false</code> is returned, nothing is pushed to the\n+     *         byte buffer. \n+     */\n+    public boolean pushEncodedChar(ByteBuffer bb, char c) {\n+\n+        if (c >= 0 && c < 128) {\n+            bb.put((byte) c);\n+            return true;\n+        }\n+\n+        Simple8BitChar r = this.encodeHighChar(c);\n+        if (r == null) {\n+            return false;\n+        }\n+        bb.put(r.code);\n+        return true;\n+    }\n+\n+    /**\n+     * @param c A unicode character in the range from 0x0080 to 0x7f00\n+     * @return A Simple8BitChar, if this character is covered by this encoding.\n+     *         A <code>null</code> value is returned, if this character is not\n+     *         covered by this encoding.\n+     */\n+    private Simple8BitChar encodeHighChar(char c) {\n+        // for performance an simplicity, yet another reincarnation of\n+        // binary search...\n+        int i0 = 0;\n+        int i1 = this.reverseMapping.size();\n+\n+        while (i1 > i0) {\n+\n+            int i = i0 + (i1 - i0) / 2;\n+\n+            Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i);\n+\n+            if (m.unicode == c) {\n+                return m;\n+            }\n+\n+            if (m.unicode < c) {\n+                i0 = i + 1;\n+            } else {\n+                i1 = i;\n+            }\n+        }\n+\n+        if (i0 >= this.reverseMapping.size()) {\n+            return null;\n+        }\n+\n+        Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0);\n+\n+        if (r.unicode != c) {\n+            return null;\n+        }\n+\n+        return r;\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n+     */\n+    public boolean canEncode(String name) {\n+\n+        for (int i=0;i<name.length();++i) {\n+\n+            char c = name.charAt(i);\n+\n+            if (!this.canEncodeChar(c)) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n+     */\n+    public ByteBuffer encode(String name) {\n+        ByteBuffer out = ByteBuffer.allocate(name.length()\n+                                             + 6 + (name.length() + 1) / 2);\n+\n+        for (int i=0;i<name.length();++i) {\n+\n+            char c = name.charAt(i);\n+\n+            if (out.remaining() < 6) {\n+                out = ZipEncodingHelper.growBuffer(out,out.position() + 6);\n+            }\n+\n+            if (!this.pushEncodedChar(out,c)) {\n+\n+                ZipEncodingHelper.appendSurrogate(out,c);\n+            }\n+        }\n+\n+        out.limit(out.position());\n+        out.rewind();\n+        return out;\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#decode(byte[])\n+     */\n+    public String decode(byte[] data) throws IOException {\n+        char [] ret = new char[data.length];\n+\n+        for (int i=0;i<data.length;++i) {\n+            ret[i] = this.decodeByte(data[i]);\n+        }\n+\n+        return new String(ret);\n+    }\n+\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnicodeCommentExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnicodeCommentExtraField.java\n     }\n \n     /**\n-     * Assemble as unicode comment extension from the comment and\n-     * encoding of the original zip entry.\n+     * Assemble as unicode comment extension from the name given as\n+     * text as well as the encoded bytes actually written to the archive.\n      * \n-     * @param comment The file comment\n-     * @param zipEncoding The encoding of the comment in the zip file,\n-     * usually <code>\"CP437\"</code>.\n+     * @param name The file name\n+     * @param bytes the bytes actually written to the archive\n+     * @param off The offset of the encoded comment in <code>bytes</code>.\n+     * @param len The length of the encoded comment or comment in\n+     * <code>bytes</code>.\n      */\n-    public UnicodeCommentExtraField(String comment, String zipEncoding) {\n-        super(comment, zipEncoding);\n+    public UnicodeCommentExtraField(String text, byte[] bytes, int off,\n+                                    int len) {\n+        super(text, bytes, off, len);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnicodePathExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnicodePathExtraField.java\n     }\n \n     /**\n-     * Assemble as unicode path extension from the name and encoding\n-     * of the original zip entry.\n+     * Assemble as unicode path extension from the name given as\n+     * text as well as the encoded bytes actually written to the archive.\n      * \n      * @param name The file name\n-     * @param zipEncoding The encoding of the filename in the zip\n-     * file, usually <code>\"CP437\"</code>.\n+     * @param bytes the bytes actually written to the archive\n+     * @param off The offset of the encoded filename in <code>bytes</code>.\n+     * @param len The length of the encoded filename or comment in\n+     * <code>bytes</code>.\n      */\n-    public UnicodePathExtraField(String name, String zipEncoding) {\n-        super(name, zipEncoding);\n+    public UnicodePathExtraField(String text, byte[] bytes, int off, int len) {\n+        super(text, bytes, off, len);\n     }\n \n     /**\n      * Assemble as unicode path extension from the name given as\n-     * text as well as the bytes actually written to the archive.\n+     * text as well as the encoded bytes actually written to the archive.\n      * \n      * @param name The file name\n      * @param bytes the bytes actually written to the archive\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n import java.io.IOException;\n import java.io.OutputStream;\n import java.io.RandomAccessFile;\n-import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n import java.util.Date;\n import java.util.HashMap;\n import java.util.Iterator;\n     public static final int STORED = java.util.zip.ZipEntry.STORED;\n \n     /**\n-     * name of the encoding UTF-8\n-     */\n-    static final String UTF8 = \"UTF8\";\n-\n-    /**\n      * default encoding for file names and comment.\n      */\n-    static final String DEFAULT_ENCODING = UTF8;\n+    static final String DEFAULT_ENCODING = ZipEncodingHelper.UTF8;\n \n      /**\n      * General purpose flag, which indicates that filenames are\n      */\n     private String encoding = DEFAULT_ENCODING;\n \n-    // CheckStyle:VisibilityModifier OFF - bc\n+    /**\n+     * The zip encoding to use for filenames and the file comment.\n+     *\n+     * This field is of internal use and will be set in {@link\n+     * #setEncoding(String)}.\n+     */\n+    private ZipEncoding zipEncoding =\n+        ZipEncodingHelper.getZipEncoding(DEFAULT_ENCODING);\n+\n+   // CheckStyle:VisibilityModifier OFF - bc\n \n     /**\n      * This Deflater object is used for output.\n     }\n \n     /**\n-     * This method indicates whether this archive is writing to a seekable stream (i.e., to a random\n-     * access file).\n+     * This method indicates whether this archive is writing to a\n+     * seekable stream (i.e., to a random access file).\n      *\n      * <p>For seekable streams, you don't need to calculate the CRC or\n      * uncompressed size for {@link #STORED} entries before\n      */\n     public void setEncoding(final String encoding) {\n         this.encoding = encoding;\n-        useEFS &= isUTF8(encoding);\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+        useEFS &= ZipEncodingHelper.isUTF8(encoding);\n     }\n \n     /**\n      * <p>Defaults to true.</p>\n      */\n     public void setUseLanguageEncodingFlag(boolean b) {\n-        useEFS = b && isUTF8(encoding);\n+        useEFS = b && ZipEncodingHelper.isUTF8(encoding);\n     }\n \n     /**\n      *\n      * <p>Default is Deflater.DEFAULT_COMPRESSION.</p>\n      * @param level the compression level.\n-     * @throws IllegalArgumentException if an invalid compression level is specified.\n+     * @throws IllegalArgumentException if an invalid compression\n+     * level is specified.\n      */\n     public void setLevel(int level) {\n         if (level < Deflater.DEFAULT_COMPRESSION\n             || level > Deflater.BEST_COMPRESSION) {\n-            throw new IllegalArgumentException(\n-                                               \"Invalid compression level: \" + level);\n+            throw new IllegalArgumentException(\"Invalid compression level: \"\n+                                               + level);\n         }\n         hasCompressionLevelChanged = (this.level != level);\n         this.level = level;\n      */\n     protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n \n-        byte[] name = getBytes(ze.getName());\n+        boolean encodable = this.zipEncoding.canEncode(ze.getName());\n+        ByteBuffer name = this.zipEncoding.encode(ze.getName());\n+\n         if (createUnicodeExtraFields) {\n-            ze.addExtraField(new UnicodePathExtraField(ze.getName(), name));\n+\n+            /*            if (!encodable) { -- FIXME decide what to*/\n+                ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n+                                                           name.array(),\n+                                                           name.arrayOffset(),\n+                                                           name.limit()));\n+            /* } */\n+\n             String comm = ze.getComment();\n             if (comm != null && !\"\".equals(comm)) {\n-                byte[] commentB = getBytes(comm);\n-                ze.addExtraField(new UnicodeCommentExtraField(comm, commentB));\n+\n+                boolean commentEncodable = this.zipEncoding.canEncode(comm);\n+\n+                /*            if (!commentEncodable) { -- FIXME decide what to*/\n+                    ByteBuffer commentB = this.zipEncoding.encode(comm);\n+                    ze.addExtraField(new UnicodeCommentExtraField(comm,\n+                                                                  commentB.array(),\n+                                                                  commentB.arrayOffset(),\n+                                                                  commentB.limit())\n+                                     );\n+                /* } */\n             }\n         }\n \n         // CheckStyle:MagicNumber ON\n \n         // file name length\n-        writeOut(ZipShort.getBytes(name.length));\n+        writeOut(ZipShort.getBytes(name.limit()));\n         written += SHORT;\n \n         // extra field length\n         written += SHORT;\n \n         // file name\n-        writeOut(name);\n-        written += name.length;\n+        writeOut(name.array(), name.arrayOffset(), name.limit());\n+        written += name.limit();\n \n         // extra field\n         writeOut(extra);\n         // CheckStyle:MagicNumber ON\n \n         // file name length\n-        byte[] name = getBytes(ze.getName());\n-        writeOut(ZipShort.getBytes(name.length));\n+        ByteBuffer name = this.zipEncoding.encode(ze.getName());\n+        writeOut(ZipShort.getBytes(name.limit()));\n         written += SHORT;\n \n         // extra field length\n         if (comm == null) {\n             comm = \"\";\n         }\n-        byte[] commentB = getBytes(comm);\n-        writeOut(ZipShort.getBytes(commentB.length));\n+        ByteBuffer commentB = this.zipEncoding.encode(comm);\n+        writeOut(ZipShort.getBytes(commentB.limit()));\n         written += SHORT;\n \n         // disk number start\n         written += WORD;\n \n         // file name\n-        writeOut(name);\n-        written += name.length;\n+        writeOut(name.array(), name.arrayOffset(), name.limit());\n+        written += name.limit();\n \n         // extra field\n         writeOut(extra);\n         written += extra.length;\n \n         // file comment\n-        writeOut(commentB);\n-        written += commentB.length;\n+        writeOut(commentB.array(), commentB.arrayOffset(), commentB.limit());\n+        written += commentB.limit();\n     }\n \n     /**\n         writeOut(ZipLong.getBytes(cdOffset));\n \n         // ZIP file comment\n-        byte[] data = getBytes(comment);\n-        writeOut(ZipShort.getBytes(data.length));\n-        writeOut(data);\n+        ByteBuffer data = this.zipEncoding.encode(comment);\n+        writeOut(ZipShort.getBytes(data.limit()));\n+        writeOut(data.array(), data.arrayOffset(), data.limit());\n     }\n \n     /**\n     }\n \n     /**\n-     * Retrieve the bytes for the given String in the encoding set for\n-     * this Stream.\n-     * @param name the string to get bytes from\n-     * @return the bytes as a byte array\n-     * @throws ZipException on error\n-     */\n-    protected byte[] getBytes(String name) throws ZipException {\n-        if (encoding == null) {\n-            return name.getBytes();\n-        } else {\n-            try {\n-                return ZipEncodingHelper.encodeName(name, encoding);\n-            } catch (java.nio.charset.UnsupportedCharsetException ex) {\n-                // Java 1.4's NIO doesn't recognize a few names that\n-                // String.getBytes does\n-                try {\n-                    return name.getBytes(encoding);\n-                } catch (UnsupportedEncodingException uee) {\n-                    throw new ZipException(uee.getMessage());\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n      * Write bytes to output or random access file.\n      * @param data the byte array to write\n      * @throws IOException on error\n         while (!def.needsInput()) {\n             deflate();\n         }\n-    }\n-\n-    /**\n-     * Whether a given encoding - or the platform's default encoding\n-     * if the parameter is null - is UTF-8.\n-     */\n-    static boolean isUTF8(String encoding) {\n-        if (encoding == null) {\n-            // check platform's default encoding\n-            encoding = System.getProperty(\"file.encoding\");\n-        }\n-        return UTF8.equalsIgnoreCase(encoding)\n-            || \"utf-8\".equalsIgnoreCase(encoding);\n     }\n \n     private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncoding.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * An interface for encoders that do a pretty encoding of ZIP\n+ * filenames.\n+ *\n+ * <p>There are mostly two implementations, one that uses java.nio\n+ * {@link java.nio.charset.Charset Charset} and one implementation,\n+ * which copes with simple 8 bit charsets, because java-1.4 did not\n+ * support Cp437 in java.nio.</p>\n+ * \n+ * <p>The main reason for defining an own encoding layer comes from\n+ * the problems with {@link java.lang.String#getBytes(String)\n+ * String.getBytes}, which encodes unknown characters as ASCII\n+ * quotation marks ('?'), which is per definition an invalid filename\n+ * character under some operating systems (Windows, e.g.) leading to\n+ * ignored ZIP entries.</p>\n+ * \n+ * <p>All implementations should implement this interface in a\n+ * reentrant way.<(p>\n+ */\n+interface ZipEncoding {\n+    /**\n+     * Check, whether the given string may be losslessly encoded using this\n+     * encoding.\n+     * \n+     * @param name A filename or ZIP comment.\n+     * @return Whether the given name may be encoded with out any losses.\n+     */\n+    boolean canEncode(String name);\n+\n+    /**\n+     * Encode a filename or a comment to a byte array suitable for\n+     * storing it to a serialized zip entry.\n+     * \n+     * <p>Examples for CP 437 (in pseudo-notation, right hand side is\n+     * C-style notation):</p>\n+     * <pre>\n+     *  encode(\"\\u20AC_for_Dollar.txt\") = \"%U20AC_for_Dollar.txt\"\n+     *  encode(\"\\u00D6lf\\u00E4sser.txt\") = \"\\231lf\\204sser.txt\"\n+     * </pre>\n+     * \n+     * @param name A filename or ZIP comment. \n+     * @return A byte buffer with a backing array containing the\n+     *         encoded name.  Unmappable characters or malformed\n+     *         character sequences are mapped to a sequence of utf-16\n+     *         words encoded in the format <code>%Uxxxx</code>.  It is\n+     *         assumed, that the byte buffer is positioned at the\n+     *         beinning of the encoded result, the byte buffer has a\n+     *         backing array and the limit of the byte buffer points\n+     *         to the end of the encoded result.\n+     * @throws IOException \n+     */\n+    ByteBuffer encode(String name) throws IOException;\n+\n+    /**\n+     * @param data The byte values to decode.\n+     * @return The decoded string.\n+     * @throws IOException \n+     */\n+    String decode(byte [] data) throws IOException;\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n package org.apache.commons.compress.archivers.zip;\n \n import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n import java.nio.charset.Charset;\n-import java.nio.charset.CharsetEncoder;\n-import java.nio.charset.CoderResult;\n-import java.nio.charset.CodingErrorAction;\n+import java.nio.charset.UnsupportedCharsetException;\n+import java.util.HashMap;\n+import java.util.Map;\n \n /**\n  * Static helper functions for robustly encoding filenames in zip files. \n  */\n abstract class ZipEncodingHelper {\n+\n+    /**\n+     * A class, which holds the high characters of a simple encoding\n+     * and lazily instantiates a Simple8BitZipEnoding instance in a\n+     * thread-safe manner.\n+     */\n+    private static class SimpleEncodingHolder {\n+\n+        private final char [] highChars;\n+        private Simple8BitZipEnoding encoding;\n+\n+        /**\n+         * Instantiate a simple encoding holder.\n+         * \n+         * @param highChars The characters for byte codes 128 to 255.\n+         * \n+         * @see Simple8BitZipEnoding#Simple8BitZipEnoding(char[])\n+         */\n+        SimpleEncodingHolder(char [] highChars) {\n+            this.highChars = highChars;\n+        }\n+\n+        /**\n+         * @return The associated {@see Simple8BitZipEncoding}, which\n+         *         is instantiated if not done so far.\n+         */\n+        public synchronized Simple8BitZipEnoding getEncoding() {\n+            if (this.encoding == null) {\n+                this.encoding = new Simple8BitZipEnoding(this.highChars);\n+            }\n+            return this.encoding;\n+        }\n+    }\n+\n+    private static final Map simpleEncodings;\n+\n+    static {\n+        simpleEncodings = new HashMap();\n+\n+        char[] cp437_high_chars =\n+            new char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n+                         0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n+                         0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n+                         0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n+                         0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n+                         0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n+                         0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n+                         0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n+                         0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n+                         0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n+                         0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n+                         0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n+                         0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n+                         0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n+                         0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n+                         0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n+                         0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n+                         0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n+                         0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n+                         0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n+                         0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n+                         0x25a0, 0x00a0 };\n+\n+        SimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n+\n+        simpleEncodings.put(\"CP437\",cp437);\n+        simpleEncodings.put(\"Cp437\",cp437);\n+        simpleEncodings.put(\"cp437\",cp437);\n+        simpleEncodings.put(\"IBM437\",cp437);\n+        simpleEncodings.put(\"ibm437\",cp437);\n+\n+        char[] cp850_high_chars =\n+            new char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n+                         0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n+                         0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n+                         0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n+                         0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n+                         0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n+                         0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n+                         0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n+                         0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n+                         0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n+                         0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n+                         0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n+                         0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n+                         0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n+                         0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n+                         0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n+                         0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n+                         0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n+                         0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n+                         0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n+                         0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n+                         0x25a0, 0x00a0 };\n+\n+        SimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n+\n+        simpleEncodings.put(\"CP850\",cp850);\n+        simpleEncodings.put(\"Cp850\",cp850);\n+        simpleEncodings.put(\"cp850\",cp850);\n+        simpleEncodings.put(\"IBM850\",cp850);\n+        simpleEncodings.put(\"ibm850\",cp850);\n+    }\n \n     /**\n      * Grow a byte buffer, so it has a minimal capacity or at least\n         return on;\n     }\n \n-\n+ \n     /**\n      * The hexadecimal digits <code>0,...,9,A,...,F</code> encoded as\n      * ASCII bytes.\n     };\n \n     /**\n-     * Encode a filename or a comment to a byte array suitable for\n-     * storing it to a serialized zip entry.\n+     * Append <code>%Uxxxx</code> to the given byte buffer.\n+     * The caller must assure, that <code>bb.remaining()&gt;=6</code>.\n      * \n-     * Examples (in pseudo-notation, right hand side is C-style notation):\n-     * <pre>\n-     *  encodeName(\"\\u20AC_for_Dollar.txt\",\"CP437\") = \"%U20AC_for_Dollar.txt\"\n-     *  encodeName(\"\\u00D6lf\\u00E4sser.txt\",\"CP437\") = \"\\231lf\\204sser.txt\"\n-     * </pre>\n+     * @param bb The byte buffer to write to.\n+     * @param c The character to write.\n+     */\n+    static void appendSurrogate(ByteBuffer bb, char c) {\n+\n+        bb.put((byte) '%');\n+        bb.put((byte) 'U');\n+\n+        bb.put(HEX_DIGITS[(c >> 12)&0x0f]);\n+        bb.put(HEX_DIGITS[(c >> 8)&0x0f]);\n+        bb.put(HEX_DIGITS[(c >> 4)&0x0f]);\n+        bb.put(HEX_DIGITS[c & 0x0f]);\n+    }\n+\n+\n+    /**\n+     * name of the encoding UTF-8\n+     */\n+    static final String UTF8 = \"UTF8\";\n+\n+    /**\n+     * name of the encoding UTF-8\n+     */\n+    static final ZipEncoding UTF8_ZIP_ENCODING = new FallbackZipEncoding(UTF8);\n+\n+    /**\n+     * Instantiates a zip encoding.\n      * \n-     * @param name The filename or comment with possible non-ASCII\n-     * unicode characters.  Must not be null.\n-     * @param encoding A valid encoding name. The standard zip\n-     *                 encoding is <code>\"CP437\"</code>,\n-     *                 <code>\"UTF-8\"</code> is supported in ZIP file\n-     *                 version <code>6.3</code> or later.  If null,\n-     *                 will use the platform's {@link\n-     *                 java.lang.String#getBytes default encoding}.\n-     * @return A byte array containing the mapped file\n-     *         name. Unmappable characters or malformed character\n-     *         sequences are mapped to a sequence of utf-16 words\n-     *         encoded in the format <code>%Uxxxx</code>.\n-     */\n-    static final byte[] encodeName(String name, String encoding) {\n+     * @param name The name of the zip encoding. Specify <code>null</code> for\n+     *             the platform's default encoding.\n+     * @return A zip encoding for the given encoding name.\n+     */\n+    static ZipEncoding getZipEncoding(String name) {\n+ \n+        // fallback encoding is good enough for utf-8.\n+        if (isUTF8(name)) {\n+            return UTF8_ZIP_ENCODING;\n+        }\n+\n+        if (name == null) {\n+            return new FallbackZipEncoding();\n+        }\n+\n+        SimpleEncodingHolder h =\n+            (SimpleEncodingHolder) simpleEncodings.get(name);\n+\n+        if (h!=null) {\n+            return h.getEncoding();\n+        }\n+\n+        try {\n+\n+            Charset cs = Charset.forName(name);\n+            return new NioZipEncoding(cs);\n+\n+        } catch (UnsupportedCharsetException e) {\n+            return new FallbackZipEncoding(name);\n+        }\n+    }\n+\n+    /**\n+     * Whether a given encoding - or the platform's default encoding\n+     * if the parameter is null - is UTF-8.\n+     */\n+    static boolean isUTF8(String encoding) {\n         if (encoding == null) {\n-            return name.getBytes();\n-        }\n-\n-        Charset cs = Charset.forName(encoding);\n-        CharsetEncoder enc = cs.newEncoder();\n-\n-        enc.onMalformedInput(CodingErrorAction.REPORT);\n-        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n-\n-        CharBuffer cb = CharBuffer.wrap(name);\n-        ByteBuffer out = ByteBuffer.allocate(name.length()\n-                                             + (name.length() + 1) / 2);\n-\n-        while (cb.remaining() > 0) {\n-            CoderResult res = enc.encode(cb, out,true);\n-\n-            if (res.isUnmappable() || res.isMalformed()) {\n-\n-                // write the unmappable characters in utf-16\n-                // pseudo-URL encoding style to ByteBuffer.\n-                if (res.length() * 6 > out.remaining()) {\n-                    out = growBuffer(out,out.position() + res.length() * 6);\n-                }\n-\n-                for (int i=0; i<res.length(); ++i) {\n-                    out.put((byte) '%');\n-                    out.put((byte) 'U');\n-\n-                    char c = cb.get();\n-\n-                    out.put(HEX_DIGITS[(c >> 12)&0x0f]);\n-                    out.put(HEX_DIGITS[(c >> 8)&0x0f]);\n-                    out.put(HEX_DIGITS[(c >> 4)&0x0f]);\n-                    out.put(HEX_DIGITS[c & 0x0f]);\n-                }\n-\n-            } else if (res.isOverflow()) {\n-\n-                out = growBuffer(out, 0);\n-\n-            } else if (res.isUnderflow()) {\n-\n-                enc.flush(out);\n-                break;\n-\n-            }\n-        }\n-\n-        byte [] ret = new byte[out.position()];\n-        out.rewind();\n-        out.get(ret);\n-\n-        return ret;\n-    }\n-\n-    /**\n-     * Return, whether a filename or a comment may be encoded to a\n-     * byte array suitable for storing it to a serialized zip entry\n-     * without any losses.\n-     * \n-     * Examples (in pseudo-notation, right hand side is C-style notation):\n-     * <pre>\n-     *  canEncodeName(\"\\u20AC_for_Dollar.txt\",\"CP437\") = false\n-     *  canEncodeName(\"\\u20AC_for_Dollar.txt\",\"UTF-8\") = true\n-     *  canEncodeName(\"\\u00D6lf\\u00E4sser.txt\",\"CP437\") = true\n-     * </pre>\n-     * \n-     * @param name The filename or comment with possible non-ASCII\n-     * unicode characters.\n-     * @param encoding A valid encoding name. The standard zip\n-     *                 encoding is <code>\"CP437\"</code>,\n-     *                 <code>\"UTF-8\"</code> is supported in ZIP file\n-     *                 version <code>6.3</code> or later.\n-     * @return Whether the given encoding may encode the given name.\n-     */\n-    static final boolean canEncodeName(String name, String encoding) {\n-\n-        Charset cs = Charset.forName(encoding);\n-\n-        CharsetEncoder enc = cs.newEncoder();\n-        enc.onMalformedInput(CodingErrorAction.REPORT);\n-        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n-\n-        return enc.canEncode(name);\n-    }\n-\n-    /**\n-     * Decode a filename or a comment from a byte array.\n-     * \n-     * @param name The filename or comment.\n-     * @param encoding A valid encoding name. The standard zip\n-     *                 encoding is <code>\"CP437\"</code>,\n-     *                 <code>\"UTF-8\"</code> is supported in ZIP file\n-     *                 version <code>6.3</code> or later.\n-     */\n-    static final String decodeName(byte[] name, String encoding)\n-        throws java.nio.charset.CharacterCodingException {\n-        Charset cs = Charset.forName(encoding);\n-        return cs.newDecoder()\n-            .onMalformedInput(CodingErrorAction.REPORT)\n-            .onUnmappableCharacter(CodingErrorAction.REPORT)\n-            .decode(ByteBuffer.wrap(name)).toString();\n+            // check platform's default encoding\n+            encoding = System.getProperty(\"file.encoding\");\n+        }\n+        return UTF8.equalsIgnoreCase(encoding)\n+            || \"utf-8\".equalsIgnoreCase(encoding);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.RandomAccessFile;\n-import java.io.UnsupportedEncodingException;\n-import java.nio.charset.CharacterCodingException;\n import java.util.Calendar;\n import java.util.Collections;\n import java.util.Date;\n     private final String encoding;\n \n     /**\n+     * The zip encoding to use for filenames and the file comment.\n+     */\n+    private final ZipEncoding zipEncoding;\n+\n+    /**\n      * The actual data source.\n      */\n     private RandomAccessFile archive;\n      * @throws IOException if an error occurs while reading the file.\n      */\n     public ZipFile(File f) throws IOException {\n-        this(f, ZipArchiveOutputStream.UTF8);\n+        this(f, ZipEncodingHelper.UTF8);\n     }\n \n     /**\n      * @throws IOException if an error occurs while reading the file.\n      */\n     public ZipFile(String name) throws IOException {\n-        this(new File(name), ZipArchiveOutputStream.UTF8);\n+        this(new File(name), ZipEncodingHelper.UTF8);\n     }\n \n     /**\n      * @param f the archive.\n      * @param encoding the encoding to use for file names, use null\n      * for the platform's default encoding\n-     * @param useUnicodeExtraFields whether to use InfoZIP Unicode Extra Fields (if present)\n-     * to set the file names.\n+     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n+     * Extra Fields (if present) to set the file names.\n      *\n      * @throws IOException if an error occurs while reading the file.\n      */\n     public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\n         throws IOException {\n         this.encoding = encoding;\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n         archive = new RandomAccessFile(f, \"r\");\n         boolean success = false;\n      * @param ze the entry to get the stream for.\n      * @return a stream to read the entry from.\n      * @throws IOException if unable to create an input stream from the zipenty\n-     * @throws ZipException if the zipentry has an unsupported compression method\n+     * @throws ZipException if the zipentry has an unsupported\n+     * compression method\n      */\n     public InputStream getInputStream(ZipArchiveEntry ze)\n         throws IOException, ZipException {\n             final int generalPurposeFlag = ZipShort.getValue(cfh, off);\n             final boolean hasEFS = \n                 (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\n-            final String entryEncoding =\n-                hasEFS ? ZipArchiveOutputStream.UTF8 : encoding;\n+            final ZipEncoding entryEncoding =\n+                hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n \n             off += SHORT;\n \n \n             byte[] fileName = new byte[fileNameLen];\n             archive.readFully(fileName);\n-            ze.setName(getString(fileName, entryEncoding));\n+            ze.setName(entryEncoding.decode(fileName));\n \n             // LFH offset,\n             OffsetEntry offset = new OffsetEntry();\n \n             byte[] comment = new byte[commentLen];\n             archive.readFully(comment);\n-            ze.setComment(getString(comment, entryEncoding));\n+            ze.setComment(entryEncoding.decode(comment));\n \n             archive.readFully(signatureBytes);\n             sig = ZipLong.getValue(signatureBytes);\n                                      + SHORT + SHORT + fileNameLen + extraFieldLen));\n             */\n             offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n-                                     + SHORT + SHORT + fileNameLen + extraFieldLen;\n+                + SHORT + SHORT + fileNameLen + extraFieldLen;\n \n             if (entriesWithoutEFS.containsKey(ze)) {\n                 setNameAndCommentFromExtraFields(ze,\n \n \n     /**\n-     * Retrieve a String from the given bytes using the encoding set\n-     * for this ZipFile.\n-     *\n-     * @param bytes the byte array to transform\n-     * @return String obtained by using the given encoding\n-     * @throws ZipException if the encoding cannot be recognized.\n-     */\n-    protected String getString(byte[] bytes, String enc)\n-        throws ZipException {\n-        if (enc == null) {\n-            return new String(bytes);\n-        } else {\n-            try {\n-                try {\n-                    return ZipEncodingHelper.decodeName(bytes, enc);\n-                } catch (CharacterCodingException ex) {\n-                    throw new ZipException(ex.getMessage());\n-                }\n-            } catch (java.nio.charset.UnsupportedCharsetException ex) {\n-                // Java 1.4's NIO doesn't recognize a few names that\n-                // String.getBytes does\n-                try {\n-                    return new String(bytes, enc);\n-                } catch (UnsupportedEncodingException uee) {\n-                    throw new ZipException(uee.getMessage());\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n      * Checks whether the archive starts with a LFH.  If it doesn't,\n      * it may be an empty archive.\n      */\n             if (origCRC32 == f.getNameCRC32()) {\n                 try {\n                     return ZipEncodingHelper\n-                        .decodeName(f.getUnicodeName(),\n-                                    ZipArchiveOutputStream.UTF8);\n-                } catch (CharacterCodingException ex) {\n+                        .UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n+                } catch (IOException ex) {\n                     // UTF-8 unsupported?  should be impossible the\n                     // Unicode*ExtraField must contain some bad bytes\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/TestZipEncodings.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test zip encodings.\n+ */\n+public class TestZipEncodings extends TestCase {\n+    private static final String UNENC_STRING = \"\\u2016\";\n+\n+    // stress test for internal grow method.\n+    private static final String BAD_STRING =\n+        \"\\u2016\\u2015\\u2016\\u2015\\u2016\\u2015\\u2016\\u2015\\u2016\\u2015\\u2016\";\n+\n+    private static final String BAD_STRING_ENC =\n+        \"%U2016%U2015%U2016%U2015%U2016%U2015%U2016%U2015%U2016%U2015%U2016\";\n+\n+    public void testSimpleCp437Encoding() throws IOException {\n+\n+        doSimpleEncodingTest(\"Cp437\", null);\n+    }\n+\n+    public void testSimpleCp850Encoding() throws IOException {\n+\n+        doSimpleEncodingTest(\"Cp850\", null);\n+    }\n+\n+    public void testNioCp1252Encoding() throws IOException {\n+        // CP1252 has some undefined code points, these are\n+        // the defined ones\n+        // retrieved by\n+        //    awk '/^0x/ && NF>2 {print $1;}' CP1252.TXT\n+        byte[] b =\n+            new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+                         0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n+                         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+                         0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,\n+                         0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+                         0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,\n+                         0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+                         0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n+                         0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+                         0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,\n+                         0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+                         0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,\n+                         0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n+                         0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,\n+                         0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n+                         0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,\n+                         (byte) 0x80, (byte) 0x82, (byte) 0x83, (byte) 0x84,\n+                         (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88,\n+                         (byte) 0x89, (byte) 0x8A, (byte) 0x8B, (byte) 0x8C,\n+                         (byte) 0x8E, (byte) 0x91, (byte) 0x92, (byte) 0x93,\n+                         (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97,\n+                         (byte) 0x98, (byte) 0x99, (byte) 0x9A, (byte) 0x9B,\n+                         (byte) 0x9C, (byte) 0x9E, (byte) 0x9F, (byte) 0xA0,\n+                         (byte) 0xA1, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4,\n+                         (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8,\n+                         (byte) 0xA9, (byte) 0xAA, (byte) 0xAB, (byte) 0xAC,\n+                         (byte) 0xAD, (byte) 0xAE, (byte) 0xAF, (byte) 0xB0,\n+                         (byte) 0xB1, (byte) 0xB2, (byte) 0xB3, (byte) 0xB4,\n+                         (byte) 0xB5, (byte) 0xB6, (byte) 0xB7, (byte) 0xB8,\n+                         (byte) 0xB9, (byte) 0xBA, (byte) 0xBB, (byte) 0xBC,\n+                         (byte) 0xBD, (byte) 0xBE, (byte) 0xBF, (byte) 0xC0,\n+                         (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4,\n+                         (byte) 0xC5, (byte) 0xC6, (byte) 0xC7, (byte) 0xC8,\n+                         (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC,\n+                         (byte) 0xCD, (byte) 0xCE, (byte) 0xCF, (byte) 0xD0,\n+                         (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4,\n+                         (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, (byte) 0xD8,\n+                         (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC,\n+                         (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, (byte) 0xE0,\n+                         (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4,\n+                         (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, (byte) 0xE8,\n+                         (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC,\n+                         (byte) 0xED, (byte) 0xEE, (byte) 0xEF, (byte) 0xF0,\n+                         (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4,\n+                         (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, (byte) 0xF8,\n+                         (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC,\n+                         (byte) 0xFD, (byte) 0xFE, (byte) 0xFF };\n+\n+        doSimpleEncodingTest(\"Cp1252\",b);\n+    }\n+\n+    private static final void assertEquals(byte[] expected, ByteBuffer actual) {\n+\n+        assertEquals(expected.length, actual.limit());\n+\n+        for (int i = 0; i < expected.length; ++i) {\n+\n+            byte a = actual.get();\n+            assertEquals(expected[i], a);\n+        }\n+\n+    }\n+\n+    private void doSimpleEncodingTest(String name, byte[] testBytes)\n+        throws IOException {\n+\n+        ZipEncoding enc = ZipEncodingHelper.getZipEncoding(name);\n+\n+        if (testBytes == null) {\n+\n+            testBytes = new byte[256];\n+            for (int i = 0; i < 256; ++i) {\n+                testBytes[i] = (byte) i;\n+            }\n+        }\n+\n+        String decoded = enc.decode(testBytes);\n+\n+        assertEquals(true, enc.canEncode(decoded));\n+\n+        ByteBuffer encoded = enc.encode(decoded);\n+\n+        assertEquals(testBytes, encoded);\n+\n+        assertEquals(false, enc.canEncode(UNENC_STRING));\n+        assertEquals(\"%U2016\".getBytes(\"US-ASCII\"), enc.encode(UNENC_STRING));\n+        assertEquals(false, enc.canEncode(BAD_STRING));\n+        assertEquals(BAD_STRING_ENC.getBytes(\"US-ASCII\"),\n+                     enc.encode(BAD_STRING));\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n import java.io.IOException;\n import java.io.UnsupportedEncodingException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n import java.net.URL;\n-import java.net.URISyntaxException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.UnsupportedCharsetException;\n+import java.nio.ByteBuffer;\n import java.util.Enumeration;\n-import junit.framework.TestCase;\n-\n-public class UTF8ZipFilesTest extends TestCase {\n+import java.util.zip.CRC32;\n+\n+import org.apache.commons.compress.AbstractTestCase;\n+\n+public class UTF8ZipFilesTest extends AbstractTestCase {\n \n     private static final String UTF_8 = \"utf-8\";\n     private static final String CP437 = \"cp437\";\n                                           boolean withExplicitUnicodeExtra)\n         throws IOException {\n \n-        try {\n-            Charset.forName(encoding);\n-        } catch (UnsupportedCharsetException use) {\n-            System.err.println(\"Skipping testFileRoundtrip for unsupported \"\n-                               + \" encoding \" + encoding);\n-            return;\n-        }\n-\n         File file = File.createTempFile(encoding + \"-test\", \".zip\");\n         try {\n             createTestFile(file, encoding, withEFS, withExplicitUnicodeExtra);\n                                        boolean withExplicitUnicodeExtra)\n         throws UnsupportedEncodingException, IOException {\n \n+        ZipEncoding zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+\n         ZipArchiveOutputStream zos = null;\n         try {\n             zos = new ZipArchiveOutputStream(file);\n \n             ZipArchiveEntry ze = new ZipArchiveEntry(OIL_BARREL_TXT);\n             if (withExplicitUnicodeExtra\n-                && !ZipEncodingHelper.canEncodeName(ze.getName(),\n-                                                    zos.getEncoding())) {\n+                && !zipEncoding.canEncode(ze.getName())) {\n+\n+                ByteBuffer en = zipEncoding.encode(ze.getName());\n+\n                 ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n-                                                           zos.getEncoding()));\n+                                                           en.array(),\n+                                                           en.arrayOffset(),\n+                                                           en.limit()));\n             }\n \n             zos.putNextEntry(ze);\n \n             ze = new ZipArchiveEntry(EURO_FOR_DOLLAR_TXT);\n             if (withExplicitUnicodeExtra\n-                && !ZipEncodingHelper.canEncodeName(ze.getName(),\n-                                                    zos.getEncoding())) {\n+                && !zipEncoding.canEncode(ze.getName())) {\n+\n+                ByteBuffer en = zipEncoding.encode(ze.getName());\n+\n                 ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n-                                                           zos.getEncoding()));\n+                                                           en.array(),\n+                                                           en.arrayOffset(),\n+                                                           en.limit()));\n             }\n \n             zos.putNextEntry(ze);\n             ze = new ZipArchiveEntry(ASCII_TXT);\n \n             if (withExplicitUnicodeExtra\n-                && !ZipEncodingHelper.canEncodeName(ze.getName(),\n-                                                    zos.getEncoding())) {\n+                && !zipEncoding.canEncode(ze.getName())) {\n+\n+                ByteBuffer en = zipEncoding.encode(ze.getName());\n+\n                 ze.addExtraField(new UnicodePathExtraField(ze.getName(),\n-                                                           zos.getEncoding()));\n+                                                           en.array(),\n+                                                           en.arrayOffset(),\n+                                                           en.limit()));\n             }\n \n             zos.putNextEntry(ze);\n             UnicodePathExtraField ucpf = findUniCodePath(ze);\n             assertNotNull(ucpf);\n \n-            UnicodePathExtraField ucpe = new UnicodePathExtraField(expectedName,\n-                                                                   encoding);\n-            assertEquals(ucpe.getNameCRC32(), ucpf.getNameCRC32());\n+            ZipEncoding enc = ZipEncodingHelper.getZipEncoding(encoding);\n+            ByteBuffer ne = enc.encode(ze.getName());\n+\n+            CRC32 crc = new CRC32();\n+            crc.update(ne.array(),ne.arrayOffset(),ne.limit());\n+\n+            assertEquals(crc.getValue(), ucpf.getNameCRC32());\n             assertEquals(expectedName, new String(ucpf.getUnicodeName(),\n                                                   UTF_8));\n         }\n     }\n \n-    /*\n     public void testUtf8Interoperability() throws IOException {\n         File file1 = super.getFile(\"utf8-7zip-test.zip\");\n         File file2 = super.getFile(\"utf8-winzip-test.zip\");\n         testFile(file2,CP437);\n \n     }\n-    */\n+\n }\n ", "timestamp": 1236010160, "metainfo": ""}