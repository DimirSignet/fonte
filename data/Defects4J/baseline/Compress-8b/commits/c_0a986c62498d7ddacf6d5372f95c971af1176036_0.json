{"sha": "0a986c62498d7ddacf6d5372f95c971af1176036", "log": "fix linefeeds, thanks to Sebb for spotting this  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n-/*\n- *  Licensed to the Apache Software Foundation (ASF) under one or more\n- *  contributor license agreements.  See the NOTICE file distributed with\n- *  this work for additional information regarding copyright ownership.\n- *  The ASF licenses this file to You under the Apache License, Version 2.0\n- *  (the \"License\"); you may not use this file except in compliance with\n- *  the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- *\n- */\n-\n-/*\n- * This package is based on the work done by Timothy Gerard Endres\n- * (time@ice.com) to whom the Ant project is very grateful for his great code.\n- */\n-\n-package org.apache.commons.compress.archivers.tar;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import org.apache.commons.compress.archivers.ArchiveEntry;\n-import org.apache.commons.compress.archivers.ArchiveInputStream;\n-\n-/**\n- * The TarInputStream reads a UNIX tar archive as an InputStream.\n- * methods are provided to position at each successive entry in\n- * the archive, and the read each entry as a normal input stream\n- * using read().\n- *\n- */\n-public class TarArchiveInputStream extends ArchiveInputStream {\n-    private static final int SMALL_BUFFER_SIZE = 256;\n-    private static final int BUFFER_SIZE = 8 * 1024;\n-    private static final int LARGE_BUFFER_SIZE = 32 * 1024;\n-    private static final int BYTE_MASK = 0xFF;\n-\n-    // CheckStyle:VisibilityModifier OFF - bc\n-    protected boolean debug;\n-    protected boolean hasHitEOF;\n-    protected long entrySize;\n-    protected long entryOffset;\n-    protected byte[] readBuf;\n-    protected TarBuffer buffer;\n-    protected TarArchiveEntry currEntry;\n-\n-    /**\n-     * This contents of this array is not used at all in this class,\n-     * it is only here to avoid repreated object creation during calls\n-     * to the no-arg read method.\n-     */\n-    protected byte[] oneBuf;\n-\n-    // CheckStyle:VisibilityModifier ON\n-\n-    private final InputStream in;\n-\n-    /**\n-     * Constructor for TarInputStream.\n-     * @param is the input stream to use\n-     */\n-    public TarArchiveInputStream(InputStream is) {\n-        this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n-    }\n-\n-    /**\n-     * Constructor for TarInputStream.\n-     * @param is the input stream to use\n-     * @param blockSize the block size to use\n-     */\n-    public TarArchiveInputStream(InputStream is, int blockSize) {\n-        this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n-    }\n-\n-    /**\n-     * Constructor for TarInputStream.\n-     * @param is the input stream to use\n-     * @param blockSize the block size to use\n-     * @param recordSize the record size to use\n-     */\n-    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n-        this.in = is;\n-\n-        this.buffer = new TarBuffer(is, blockSize, recordSize);\n-        this.readBuf = null;\n-        this.oneBuf = new byte[1];\n-        this.debug = false;\n-        this.hasHitEOF = false;\n-    }\n-\n-    /**\n-     * Sets the debugging flag.\n-     *\n-     * @param debug True to turn on debugging.\n-     */\n-    public void setDebug(boolean debug) {\n-        this.debug = debug;\n-        buffer.setDebug(debug);\n-    }\n-\n-    /**\n-     * Closes this stream. Calls the TarBuffer's close() method.\n-     * @throws IOException on error\n-     */\n-    public void close() throws IOException {\n-        buffer.close();\n-    }\n-\n-    /**\n-     * Get the record size being used by this stream's TarBuffer.\n-     *\n-     * @return The TarBuffer record size.\n-     */\n-    public int getRecordSize() {\n-        return buffer.getRecordSize();\n-    }\n-\n-    /**\n-     * Get the available data that can be read from the current\n-     * entry in the archive. This does not indicate how much data\n-     * is left in the entire archive, only in the current entry.\n-     * This value is determined from the entry's size header field\n-     * and the amount of data already read from the current entry.\n-     * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE\n-     * bytes are left in the current entry in the archive.\n-     *\n-     * @return The number of available bytes for the current entry.\n-     * @throws IOException for signature\n-     */\n-    public int available() throws IOException {\n-        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n-            return Integer.MAX_VALUE;\n-        }\n-        return (int) (entrySize - entryOffset);\n-    }\n-\n-    /**\n-     * Skip bytes in the input buffer. This skips bytes in the\n-     * current entry's data, not the entire archive, and will\n-     * stop at the end of the current entry's data if the number\n-     * to skip extends beyond that point.\n-     *\n-     * @param numToSkip The number of bytes to skip.\n-     * @return the number actually skipped\n-     * @throws IOException on error\n-     */\n-    public long skip(long numToSkip) throws IOException {\n-        // REVIEW\n-        // This is horribly inefficient, but it ensures that we\n-        // properly skip over bytes via the TarBuffer...\n-        //\n-        byte[] skipBuf = new byte[BUFFER_SIZE];\n-        long skip = numToSkip;\n-        while (skip > 0) {\n-            int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);\n-            int numRead = read(skipBuf, 0, realSkip);\n-            if (numRead == -1) {\n-                break;\n-            }\n-            skip -= numRead;\n-        }\n-        return (numToSkip - skip);\n-    }\n-\n-    /**\n-     * Since we do not support marking just yet, we do nothing.\n-     */\n-    public void reset() {\n-    }\n-\n-    /**\n-     * Get the next entry in this tar archive. This will skip\n-     * over any remaining data in the current entry, if there\n-     * is one, and place the input stream at the header of the\n-     * next entry, and read the header and instantiate a new\n-     * TarEntry from the header bytes and return that entry.\n-     * If there are no more entries in the archive, null will\n-     * be returned to indicate that the end of the archive has\n-     * been reached.\n-     *\n-     * @return The next TarEntry in the archive, or null.\n-     * @throws IOException on error\n-     */\n-    public TarArchiveEntry getNextTarEntry() throws IOException {\n-        if (hasHitEOF) {\n-            return null;\n-        }\n-\n-        if (currEntry != null) {\n-            long numToSkip = entrySize - entryOffset;\n-\n-            if (debug) {\n-                System.err.println(\"TarInputStream: SKIP currENTRY '\"\n-                                   + currEntry.getName() + \"' SZ \"\n-                                   + entrySize + \" OFF \"\n-                                   + entryOffset + \"  skipping \"\n-                                   + numToSkip + \" bytes\");\n-            }\n-\n-            while (numToSkip > 0) {\n-                long skipped = skip(numToSkip);\n-                if (skipped <= 0) {\n-                    throw new RuntimeException(\"failed to skip current tar\"\n-                                               + \" entry\");\n-                }\n-                numToSkip -= skipped;\n-            }\n-\n-            readBuf = null;\n-        }\n-\n-        byte[] headerBuf = buffer.readRecord();\n-\n-        if (headerBuf == null) {\n-            if (debug) {\n-                System.err.println(\"READ NULL RECORD\");\n-            }\n-            hasHitEOF = true;\n-        } else if (buffer.isEOFRecord(headerBuf)) {\n-            if (debug) {\n-                System.err.println(\"READ EOF RECORD\");\n-            }\n-            hasHitEOF = true;\n-        }\n-\n-        if (hasHitEOF) {\n-            currEntry = null;\n-        } else {\n-            currEntry = new TarArchiveEntry(headerBuf);\n-\n-            if (debug) {\n-                System.err.println(\"TarInputStream: SET CURRENTRY '\"\n-                                   + currEntry.getName()\n-                                   + \"' size = \"\n-                                   + currEntry.getSize());\n-            }\n-\n-            entryOffset = 0;\n-\n-            entrySize = currEntry.getSize();\n-        }\n-\n-        if (currEntry != null && currEntry.isGNULongNameEntry()) {\n-            // read in the name\n-            StringBuffer longName = new StringBuffer();\n-            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n-            int length = 0;\n-            while ((length = read(buf)) >= 0) {\n-                longName.append(new String(buf, 0, length));\n-            }\n-            getNextEntry();\n-            if (currEntry == null) {\n-                // Bugzilla: 40334\n-                // Malformed tar file - long entry name not followed by entry\n-                return null;\n-            }\n-            // remove trailing null terminator\n-            if (longName.length() > 0\n-                && longName.charAt(longName.length() - 1) == 0) {\n-                longName.deleteCharAt(longName.length() - 1);\n-            }\n-            currEntry.setName(longName.toString());\n-        }\n-\n-        return currEntry;\n-    }\n-\n-    public ArchiveEntry getNextEntry() throws IOException {\n-        return getNextTarEntry();\n-    }\n-\n-    /**\n-     * Reads a byte from the current tar archive entry.\n-     *\n-     * This method simply calls read( byte[], int, int ).\n-     *\n-     * @return The byte read, or -1 at EOF.\n-     * @throws IOException on error\n-     */\n-    public int read() throws IOException {\n-        int num = read(oneBuf, 0, 1);\n-        return num == -1 ? -1 : ((int) oneBuf[0]) & BYTE_MASK;\n-    }\n-\n-    /**\n-     * Reads bytes from the current tar archive entry.\n-     *\n-     * This method is aware of the boundaries of the current\n-     * entry in the archive and will deal with them as if they\n-     * were this stream's start and EOF.\n-     *\n-     * @param buf The buffer into which to place bytes read.\n-     * @param offset The offset at which to place bytes read.\n-     * @param numToRead The number of bytes to read.\n-     * @return The number of bytes read, or -1 at EOF.\n-     * @throws IOException on error\n-     */\n-    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n-        int totalRead = 0;\n-\n-        if (entryOffset >= entrySize) {\n-            return -1;\n-        }\n-\n-        if ((numToRead + entryOffset) > entrySize) {\n-            numToRead = (int) (entrySize - entryOffset);\n-        }\n-\n-        if (readBuf != null) {\n-            int sz = (numToRead > readBuf.length) ? readBuf.length\n-                : numToRead;\n-\n-            System.arraycopy(readBuf, 0, buf, offset, sz);\n-\n-            if (sz >= readBuf.length) {\n-                readBuf = null;\n-            } else {\n-                int newLen = readBuf.length - sz;\n-                byte[] newBuf = new byte[newLen];\n-\n-                System.arraycopy(readBuf, sz, newBuf, 0, newLen);\n-\n-                readBuf = newBuf;\n-            }\n-\n-            totalRead += sz;\n-            numToRead -= sz;\n-            offset += sz;\n-        }\n-\n-        while (numToRead > 0) {\n-            byte[] rec = buffer.readRecord();\n-\n-            if (rec == null) {\n-                // Unexpected EOF!\n-                throw new IOException(\"unexpected EOF with \" + numToRead\n-                                      + \" bytes unread\");\n-            }\n-\n-            int sz = numToRead;\n-            int recLen = rec.length;\n-\n-            if (recLen > sz) {\n-                System.arraycopy(rec, 0, buf, offset, sz);\n-\n-                readBuf = new byte[recLen - sz];\n-\n-                System.arraycopy(rec, sz, readBuf, 0, recLen - sz);\n-            } else {\n-                sz = recLen;\n-\n-                System.arraycopy(rec, 0, buf, offset, recLen);\n-            }\n-\n-            totalRead += sz;\n-            numToRead -= sz;\n-            offset += sz;\n-        }\n-\n-        entryOffset += totalRead;\n-\n-        return totalRead;\n-    }\n-\n-    /**\n-     * Copies the contents of the current tar archive entry directly into\n-     * an output stream.\n-     *\n-     * @param out The OutputStream into which to write the entry's data.\n-     * @throws IOException on error\n-     */\n-    public void copyEntryContents(OutputStream out) throws IOException {\n-        byte[] buf = new byte[LARGE_BUFFER_SIZE];\n-\n-        while (true) {\n-            int numRead = read(buf, 0, buf.length);\n-\n-            if (numRead == -1) {\n-                break;\n-            }\n-\n-            out.write(buf, 0, numRead);\n-        }\n-    }\n-\n-    // used to be implemented via FilterInputStream\n-    public int read(byte[] b) throws IOException {\n-        return read(b, 0, b.length);\n-    }\n-\n-    // ArchiveInputStream\n-\n-    public static boolean matches(byte[] signature, int length) {\n-        // 6574 7473 2e31 6d78\n-\n-        if (length < 8) {\n-            return false;\n-        }\n-\n-        if (signature[0] != 0x74) {\n-            return false;\n-        }\n-        if (signature[1] != 0x65) {\n-            return false;\n-        }\n-        if (signature[2] != 0x73) {\n-            return false;\n-        }\n-        if (signature[3] != 0x74) {\n-            return false;\n-        }\n-        if (signature[4] != 0x31) {\n-            return false;\n-        }\n-        if (signature[5] != 0x2e) {\n-            return false;\n-        }\n-        if (signature[6] != 0x78) {\n-            return false;\n-        }\n-        if (signature[7] != 0x6d) {\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-}\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+/*\n+ * This package is based on the work done by Timothy Gerard Endres\n+ * (time@ice.com) to whom the Ant project is very grateful for his great code.\n+ */\n+\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n+\n+/**\n+ * The TarInputStream reads a UNIX tar archive as an InputStream.\n+ * methods are provided to position at each successive entry in\n+ * the archive, and the read each entry as a normal input stream\n+ * using read().\n+ *\n+ */\n+public class TarArchiveInputStream extends ArchiveInputStream {\n+    private static final int SMALL_BUFFER_SIZE = 256;\n+    private static final int BUFFER_SIZE = 8 * 1024;\n+    private static final int LARGE_BUFFER_SIZE = 32 * 1024;\n+    private static final int BYTE_MASK = 0xFF;\n+\n+    // CheckStyle:VisibilityModifier OFF - bc\n+    protected boolean debug;\n+    protected boolean hasHitEOF;\n+    protected long entrySize;\n+    protected long entryOffset;\n+    protected byte[] readBuf;\n+    protected TarBuffer buffer;\n+    protected TarArchiveEntry currEntry;\n+\n+    /**\n+     * This contents of this array is not used at all in this class,\n+     * it is only here to avoid repreated object creation during calls\n+     * to the no-arg read method.\n+     */\n+    protected byte[] oneBuf;\n+\n+    // CheckStyle:VisibilityModifier ON\n+\n+    private final InputStream in;\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param is the input stream to use\n+     */\n+    public TarArchiveInputStream(InputStream is) {\n+        this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param is the input stream to use\n+     * @param blockSize the block size to use\n+     */\n+    public TarArchiveInputStream(InputStream is, int blockSize) {\n+        this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param is the input stream to use\n+     * @param blockSize the block size to use\n+     * @param recordSize the record size to use\n+     */\n+    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n+        this.in = is;\n+\n+        this.buffer = new TarBuffer(is, blockSize, recordSize);\n+        this.readBuf = null;\n+        this.oneBuf = new byte[1];\n+        this.debug = false;\n+        this.hasHitEOF = false;\n+    }\n+\n+    /**\n+     * Sets the debugging flag.\n+     *\n+     * @param debug True to turn on debugging.\n+     */\n+    public void setDebug(boolean debug) {\n+        this.debug = debug;\n+        buffer.setDebug(debug);\n+    }\n+\n+    /**\n+     * Closes this stream. Calls the TarBuffer's close() method.\n+     * @throws IOException on error\n+     */\n+    public void close() throws IOException {\n+        buffer.close();\n+    }\n+\n+    /**\n+     * Get the record size being used by this stream's TarBuffer.\n+     *\n+     * @return The TarBuffer record size.\n+     */\n+    public int getRecordSize() {\n+        return buffer.getRecordSize();\n+    }\n+\n+    /**\n+     * Get the available data that can be read from the current\n+     * entry in the archive. This does not indicate how much data\n+     * is left in the entire archive, only in the current entry.\n+     * This value is determined from the entry's size header field\n+     * and the amount of data already read from the current entry.\n+     * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE\n+     * bytes are left in the current entry in the archive.\n+     *\n+     * @return The number of available bytes for the current entry.\n+     * @throws IOException for signature\n+     */\n+    public int available() throws IOException {\n+        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n+            return Integer.MAX_VALUE;\n+        }\n+        return (int) (entrySize - entryOffset);\n+    }\n+\n+    /**\n+     * Skip bytes in the input buffer. This skips bytes in the\n+     * current entry's data, not the entire archive, and will\n+     * stop at the end of the current entry's data if the number\n+     * to skip extends beyond that point.\n+     *\n+     * @param numToSkip The number of bytes to skip.\n+     * @return the number actually skipped\n+     * @throws IOException on error\n+     */\n+    public long skip(long numToSkip) throws IOException {\n+        // REVIEW\n+        // This is horribly inefficient, but it ensures that we\n+        // properly skip over bytes via the TarBuffer...\n+        //\n+        byte[] skipBuf = new byte[BUFFER_SIZE];\n+        long skip = numToSkip;\n+        while (skip > 0) {\n+            int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);\n+            int numRead = read(skipBuf, 0, realSkip);\n+            if (numRead == -1) {\n+                break;\n+            }\n+            skip -= numRead;\n+        }\n+        return (numToSkip - skip);\n+    }\n+\n+    /**\n+     * Since we do not support marking just yet, we do nothing.\n+     */\n+    public void reset() {\n+    }\n+\n+    /**\n+     * Get the next entry in this tar archive. This will skip\n+     * over any remaining data in the current entry, if there\n+     * is one, and place the input stream at the header of the\n+     * next entry, and read the header and instantiate a new\n+     * TarEntry from the header bytes and return that entry.\n+     * If there are no more entries in the archive, null will\n+     * be returned to indicate that the end of the archive has\n+     * been reached.\n+     *\n+     * @return The next TarEntry in the archive, or null.\n+     * @throws IOException on error\n+     */\n+    public TarArchiveEntry getNextTarEntry() throws IOException {\n+        if (hasHitEOF) {\n+            return null;\n+        }\n+\n+        if (currEntry != null) {\n+            long numToSkip = entrySize - entryOffset;\n+\n+            if (debug) {\n+                System.err.println(\"TarInputStream: SKIP currENTRY '\"\n+                                   + currEntry.getName() + \"' SZ \"\n+                                   + entrySize + \" OFF \"\n+                                   + entryOffset + \"  skipping \"\n+                                   + numToSkip + \" bytes\");\n+            }\n+\n+            while (numToSkip > 0) {\n+                long skipped = skip(numToSkip);\n+                if (skipped <= 0) {\n+                    throw new RuntimeException(\"failed to skip current tar\"\n+                                               + \" entry\");\n+                }\n+                numToSkip -= skipped;\n+            }\n+\n+            readBuf = null;\n+        }\n+\n+        byte[] headerBuf = buffer.readRecord();\n+\n+        if (headerBuf == null) {\n+            if (debug) {\n+                System.err.println(\"READ NULL RECORD\");\n+            }\n+            hasHitEOF = true;\n+        } else if (buffer.isEOFRecord(headerBuf)) {\n+            if (debug) {\n+                System.err.println(\"READ EOF RECORD\");\n+            }\n+            hasHitEOF = true;\n+        }\n+\n+        if (hasHitEOF) {\n+            currEntry = null;\n+        } else {\n+            currEntry = new TarArchiveEntry(headerBuf);\n+\n+            if (debug) {\n+                System.err.println(\"TarInputStream: SET CURRENTRY '\"\n+                                   + currEntry.getName()\n+                                   + \"' size = \"\n+                                   + currEntry.getSize());\n+            }\n+\n+            entryOffset = 0;\n+\n+            entrySize = currEntry.getSize();\n+        }\n+\n+        if (currEntry != null && currEntry.isGNULongNameEntry()) {\n+            // read in the name\n+            StringBuffer longName = new StringBuffer();\n+            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n+            int length = 0;\n+            while ((length = read(buf)) >= 0) {\n+                longName.append(new String(buf, 0, length));\n+            }\n+            getNextEntry();\n+            if (currEntry == null) {\n+                // Bugzilla: 40334\n+                // Malformed tar file - long entry name not followed by entry\n+                return null;\n+            }\n+            // remove trailing null terminator\n+            if (longName.length() > 0\n+                && longName.charAt(longName.length() - 1) == 0) {\n+                longName.deleteCharAt(longName.length() - 1);\n+            }\n+            currEntry.setName(longName.toString());\n+        }\n+\n+        return currEntry;\n+    }\n+\n+    public ArchiveEntry getNextEntry() throws IOException {\n+        return getNextTarEntry();\n+    }\n+\n+    /**\n+     * Reads a byte from the current tar archive entry.\n+     *\n+     * This method simply calls read( byte[], int, int ).\n+     *\n+     * @return The byte read, or -1 at EOF.\n+     * @throws IOException on error\n+     */\n+    public int read() throws IOException {\n+        int num = read(oneBuf, 0, 1);\n+        return num == -1 ? -1 : ((int) oneBuf[0]) & BYTE_MASK;\n+    }\n+\n+    /**\n+     * Reads bytes from the current tar archive entry.\n+     *\n+     * This method is aware of the boundaries of the current\n+     * entry in the archive and will deal with them as if they\n+     * were this stream's start and EOF.\n+     *\n+     * @param buf The buffer into which to place bytes read.\n+     * @param offset The offset at which to place bytes read.\n+     * @param numToRead The number of bytes to read.\n+     * @return The number of bytes read, or -1 at EOF.\n+     * @throws IOException on error\n+     */\n+    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n+        int totalRead = 0;\n+\n+        if (entryOffset >= entrySize) {\n+            return -1;\n+        }\n+\n+        if ((numToRead + entryOffset) > entrySize) {\n+            numToRead = (int) (entrySize - entryOffset);\n+        }\n+\n+        if (readBuf != null) {\n+            int sz = (numToRead > readBuf.length) ? readBuf.length\n+                : numToRead;\n+\n+            System.arraycopy(readBuf, 0, buf, offset, sz);\n+\n+            if (sz >= readBuf.length) {\n+                readBuf = null;\n+            } else {\n+                int newLen = readBuf.length - sz;\n+                byte[] newBuf = new byte[newLen];\n+\n+                System.arraycopy(readBuf, sz, newBuf, 0, newLen);\n+\n+                readBuf = newBuf;\n+            }\n+\n+            totalRead += sz;\n+            numToRead -= sz;\n+            offset += sz;\n+        }\n+\n+        while (numToRead > 0) {\n+            byte[] rec = buffer.readRecord();\n+\n+            if (rec == null) {\n+                // Unexpected EOF!\n+                throw new IOException(\"unexpected EOF with \" + numToRead\n+                                      + \" bytes unread\");\n+            }\n+\n+            int sz = numToRead;\n+            int recLen = rec.length;\n+\n+            if (recLen > sz) {\n+                System.arraycopy(rec, 0, buf, offset, sz);\n+\n+                readBuf = new byte[recLen - sz];\n+\n+                System.arraycopy(rec, sz, readBuf, 0, recLen - sz);\n+            } else {\n+                sz = recLen;\n+\n+                System.arraycopy(rec, 0, buf, offset, recLen);\n+            }\n+\n+            totalRead += sz;\n+            numToRead -= sz;\n+            offset += sz;\n+        }\n+\n+        entryOffset += totalRead;\n+\n+        return totalRead;\n+    }\n+\n+    /**\n+     * Copies the contents of the current tar archive entry directly into\n+     * an output stream.\n+     *\n+     * @param out The OutputStream into which to write the entry's data.\n+     * @throws IOException on error\n+     */\n+    public void copyEntryContents(OutputStream out) throws IOException {\n+        byte[] buf = new byte[LARGE_BUFFER_SIZE];\n+\n+        while (true) {\n+            int numRead = read(buf, 0, buf.length);\n+\n+            if (numRead == -1) {\n+                break;\n+            }\n+\n+            out.write(buf, 0, numRead);\n+        }\n+    }\n+\n+    // used to be implemented via FilterInputStream\n+    public int read(byte[] b) throws IOException {\n+        return read(b, 0, b.length);\n+    }\n+\n+    // ArchiveInputStream\n+\n+    public static boolean matches(byte[] signature, int length) {\n+        // 6574 7473 2e31 6d78\n+\n+        if (length < 8) {\n+            return false;\n+        }\n+\n+        if (signature[0] != 0x74) {\n+            return false;\n+        }\n+        if (signature[1] != 0x65) {\n+            return false;\n+        }\n+        if (signature[2] != 0x73) {\n+            return false;\n+        }\n+        if (signature[3] != 0x74) {\n+            return false;\n+        }\n+        if (signature[4] != 0x31) {\n+            return false;\n+        }\n+        if (signature[5] != 0x2e) {\n+            return false;\n+        }\n+        if (signature[6] != 0x78) {\n+            return false;\n+        }\n+        if (signature[7] != 0x6d) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.compress.archivers.tar;\n-\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import org.apache.commons.compress.archivers.ArchiveEntry;\n-import org.apache.commons.compress.archivers.ArchiveOutputStream;\n-\n-/**\n- * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n- * Methods are provided to put entries, and then write their contents\n- * by writing to this stream using write().\n- *\n- */\n-public class TarArchiveOutputStream extends ArchiveOutputStream {\n-    /** Fail if a long file name is required in the archive. */\n-    public static final int LONGFILE_ERROR = 0;\n-\n-    /** Long paths will be truncated in the archive. */\n-    public static final int LONGFILE_TRUNCATE = 1;\n-\n-    /** GNU tar extensions are used to store long file names in the archive. */\n-    public static final int LONGFILE_GNU = 2;\n-\n-    // CheckStyle:VisibilityModifier OFF - bc\n-    protected boolean   debug;\n-    protected long      currSize;\n-    protected String    currName;\n-    protected long      currBytes;\n-    protected byte[]    oneBuf;\n-    protected byte[]    recordBuf;\n-    protected int       assemLen;\n-    protected byte[]    assemBuf;\n-    protected TarBuffer buffer;\n-    protected int       longFileMode = LONGFILE_ERROR;\n-    // CheckStyle:VisibilityModifier ON\n-\n-    private boolean closed = false;\n-\n-    private final OutputStream out;\n-\n-    /**\n-     * Constructor for TarInputStream.\n-     * @param os the output stream to use\n-     */\n-    public TarArchiveOutputStream(OutputStream os) {\n-        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n-    }\n-\n-    /**\n-     * Constructor for TarInputStream.\n-     * @param os the output stream to use\n-     * @param blockSize the block size to use\n-     */\n-    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n-        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n-    }\n-\n-    /**\n-     * Constructor for TarInputStream.\n-     * @param os the output stream to use\n-     * @param blockSize the block size to use\n-     * @param recordSize the record size to use\n-     */\n-    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n-        out = os;\n-\n-        this.buffer = new TarBuffer(os, blockSize, recordSize);\n-        this.debug = false;\n-        this.assemLen = 0;\n-        this.assemBuf = new byte[recordSize];\n-        this.recordBuf = new byte[recordSize];\n-        this.oneBuf = new byte[1];\n-    }\n-\n-    /**\n-     * Set the long file mode.\n-     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n-     * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).\n-     * Default is LONGFILE_ERROR.\n-     * @param longFileMode the mode to use\n-     */\n-    public void setLongFileMode(int longFileMode) {\n-        this.longFileMode = longFileMode;\n-    }\n-\n-\n-    /**\n-     * Sets the debugging flag.\n-     *\n-     * @param debugF True to turn on debugging.\n-     */\n-    public void setDebug(boolean debugF) {\n-        this.debug = debugF;\n-    }\n-\n-    /**\n-     * Sets the debugging flag in this stream's TarBuffer.\n-     *\n-     * @param debug True to turn on debugging.\n-     */\n-    public void setBufferDebug(boolean debug) {\n-        buffer.setDebug(debug);\n-    }\n-\n-    /**\n-     * Ends the TAR archive without closing the underlying OutputStream.\n-     * The result is that the two EOF records of nulls are written.\n-     * @throws IOException on error\n-     */\n-    public void finish() throws IOException {\n-        // See Bugzilla 28776 for a discussion on this\n-        // http://issues.apache.org/bugzilla/show_bug.cgi?id=28776\n-        writeEOFRecord();\n-        writeEOFRecord();\n-    }\n-\n-    /**\n-     * Ends the TAR archive and closes the underlying OutputStream.\n-     * This means that finish() is called followed by calling the\n-     * TarBuffer's close().\n-     * @throws IOException on error\n-     */\n-    public void close() throws IOException {\n-        if (!closed) {\n-            finish();\n-            buffer.close();\n-            out.close();\n-            closed = true;\n-        }\n-    }\n-\n-    /**\n-     * Get the record size being used by this stream's TarBuffer.\n-     *\n-     * @return The TarBuffer record size.\n-     */\n-    public int getRecordSize() {\n-        return buffer.getRecordSize();\n-    }\n-\n-    /**\n-     * Put an entry on the output stream. This writes the entry's\n-     * header record and positions the output stream for writing\n-     * the contents of the entry. Once this method is called, the\n-     * stream is ready for calls to write() to write the entry's\n-     * contents. Once the contents are written, closeEntry()\n-     * <B>MUST</B> be called to ensure that all buffered data\n-     * is completely written to the output stream.\n-     *\n-     * @param entry The TarEntry to be written to the archive.\n-     * @throws IOException on error\n-     */\n-    public void putNextEntry(TarArchiveEntry entry) throws IOException {\n-        if (entry.getName().length() >= TarConstants.NAMELEN) {\n-\n-            if (longFileMode == LONGFILE_GNU) {\n-                // create a TarEntry for the LongLink, the contents\n-                // of which are the entry's name\n-                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n-                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n-\n-                longLinkEntry.setSize(entry.getName().length() + 1);\n-                putNextEntry(longLinkEntry);\n-                write(entry.getName().getBytes());\n-                write(0);\n-                closeEntry();\n-            } else if (longFileMode != LONGFILE_TRUNCATE) {\n-                throw new RuntimeException(\"file name '\" + entry.getName()\n-                                           + \"' is too long ( > \"\n-                                           + TarConstants.NAMELEN + \" bytes)\");\n-            }\n-        }\n-\n-        entry.writeEntryHeader(recordBuf);\n-        buffer.writeRecord(recordBuf);\n-\n-        currBytes = 0;\n-\n-        if (entry.isDirectory()) {\n-            currSize = 0;\n-        } else {\n-            currSize = entry.getSize();\n-        }\n-        currName = entry.getName();\n-    }\n-\n-    /**\n-     * Close an entry. This method MUST be called for all file\n-     * entries that contain data. The reason is that we must\n-     * buffer data written to the stream in order to satisfy\n-     * the buffer's record based writes. Thus, there may be\n-     * data fragments still being assembled that must be written\n-     * to the output stream before this entry is closed and the\n-     * next entry written.\n-     * @throws IOException on error\n-     */\n-    public void closeEntry() throws IOException {\n-        if (assemLen > 0) {\n-            for (int i = assemLen; i < assemBuf.length; ++i) {\n-                assemBuf[i] = 0;\n-            }\n-\n-            buffer.writeRecord(assemBuf);\n-\n-            currBytes += assemLen;\n-            assemLen = 0;\n-        }\n-\n-        if (currBytes < currSize) {\n-            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n-                                  + currBytes\n-                                  + \"' before the '\" + currSize\n-                                  + \"' bytes specified in the header were written\");\n-        }\n-    }\n-\n-    /**\n-     * Writes a byte to the current tar archive entry.\n-     *\n-     * This method simply calls read( byte[], int, int ).\n-     *\n-     * @param b The byte written.\n-     * @throws IOException on error\n-     */\n-    public void write(int b) throws IOException {\n-        oneBuf[0] = (byte) b;\n-\n-        write(oneBuf, 0, 1);\n-    }\n-\n-    /**\n-     * Writes bytes to the current tar archive entry.\n-     *\n-     * This method simply calls write( byte[], int, int ).\n-     *\n-     * @param wBuf The buffer to write to the archive.\n-     * @throws IOException on error\n-     */\n-    public void write(byte[] wBuf) throws IOException {\n-        write(wBuf, 0, wBuf.length);\n-    }\n-\n-    /**\n-     * Writes bytes to the current tar archive entry. This method\n-     * is aware of the current entry and will throw an exception if\n-     * you attempt to write bytes past the length specified for the\n-     * current entry. The method is also (painfully) aware of the\n-     * record buffering required by TarBuffer, and manages buffers\n-     * that are not a multiple of recordsize in length, including\n-     * assembling records from small buffers.\n-     *\n-     * @param wBuf The buffer to write to the archive.\n-     * @param wOffset The offset in the buffer from which to get bytes.\n-     * @param numToWrite The number of bytes to write.\n-     * @throws IOException on error\n-     */\n-    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n-        if ((currBytes + numToWrite) > currSize) {\n-            throw new IOException(\"request to write '\" + numToWrite\n-                                  + \"' bytes exceeds size in header of '\"\n-                                  + currSize + \"' bytes for entry '\"\n-                                  + currName + \"'\");\n-\n-            //\n-            // We have to deal with assembly!!!\n-            // The programmer can be writing little 32 byte chunks for all\n-            // we know, and we must assemble complete records for writing.\n-            // REVIEW Maybe this should be in TarBuffer? Could that help to\n-            // eliminate some of the buffer copying.\n-            //\n-        }\n-\n-        if (assemLen > 0) {\n-            if ((assemLen + numToWrite) >= recordBuf.length) {\n-                int aLen = recordBuf.length - assemLen;\n-\n-                System.arraycopy(assemBuf, 0, recordBuf, 0,\n-                                 assemLen);\n-                System.arraycopy(wBuf, wOffset, recordBuf,\n-                                 assemLen, aLen);\n-                buffer.writeRecord(recordBuf);\n-\n-                currBytes += recordBuf.length;\n-                wOffset += aLen;\n-                numToWrite -= aLen;\n-                assemLen = 0;\n-            } else {\n-                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n-                                 numToWrite);\n-\n-                wOffset += numToWrite;\n-                assemLen += numToWrite;\n-                numToWrite = 0;\n-            }\n-        }\n-\n-        //\n-        // When we get here we have EITHER:\n-        // o An empty \"assemble\" buffer.\n-        // o No bytes to write (numToWrite == 0)\n-        //\n-        while (numToWrite > 0) {\n-            if (numToWrite < recordBuf.length) {\n-                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n-                                 numToWrite);\n-\n-                assemLen += numToWrite;\n-\n-                break;\n-            }\n-\n-            buffer.writeRecord(wBuf, wOffset);\n-\n-            int num = recordBuf.length;\n-\n-            currBytes += num;\n-            numToWrite -= num;\n-            wOffset += num;\n-        }\n-    }\n-\n-    /**\n-     * Write an EOF (end of archive) record to the tar archive.\n-     * An EOF record consists of a record of all zeros.\n-     */\n-    private void writeEOFRecord() throws IOException {\n-        for (int i = 0; i < recordBuf.length; ++i) {\n-            recordBuf[i] = 0;\n-        }\n-\n-        buffer.writeRecord(recordBuf);\n-    }\n-\n-    // used to be implemented via FilterOutputStream\n-    public void flush() throws IOException {\n-        out.flush();\n-    }\n-\n-    // ArchiveOutputStream\n-\n-    public void closeArchiveEntry() throws IOException {\n-        closeEntry();\n-    }\n-\n-    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n-        putNextEntry((TarArchiveEntry) entry);\n-    }\n-\n-    public String getDefaultFileExtension() {\n-        return \"tar\";\n-    }\n-\n-    public byte[] getHeader() {\n-        // TODO Auto-generated method stub\n-        return null;\n-    }\n-\n-    public String getName() {\n-        return \"tar\";\n-    }\n-\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n+\n+/**\n+ * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n+ * Methods are provided to put entries, and then write their contents\n+ * by writing to this stream using write().\n+ *\n+ */\n+public class TarArchiveOutputStream extends ArchiveOutputStream {\n+    /** Fail if a long file name is required in the archive. */\n+    public static final int LONGFILE_ERROR = 0;\n+\n+    /** Long paths will be truncated in the archive. */\n+    public static final int LONGFILE_TRUNCATE = 1;\n+\n+    /** GNU tar extensions are used to store long file names in the archive. */\n+    public static final int LONGFILE_GNU = 2;\n+\n+    // CheckStyle:VisibilityModifier OFF - bc\n+    protected boolean   debug;\n+    protected long      currSize;\n+    protected String    currName;\n+    protected long      currBytes;\n+    protected byte[]    oneBuf;\n+    protected byte[]    recordBuf;\n+    protected int       assemLen;\n+    protected byte[]    assemBuf;\n+    protected TarBuffer buffer;\n+    protected int       longFileMode = LONGFILE_ERROR;\n+    // CheckStyle:VisibilityModifier ON\n+\n+    private boolean closed = false;\n+\n+    private final OutputStream out;\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param os the output stream to use\n+     */\n+    public TarArchiveOutputStream(OutputStream os) {\n+        this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param os the output stream to use\n+     * @param blockSize the block size to use\n+     */\n+    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n+        this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);\n+    }\n+\n+    /**\n+     * Constructor for TarInputStream.\n+     * @param os the output stream to use\n+     * @param blockSize the block size to use\n+     * @param recordSize the record size to use\n+     */\n+    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n+        out = os;\n+\n+        this.buffer = new TarBuffer(os, blockSize, recordSize);\n+        this.debug = false;\n+        this.assemLen = 0;\n+        this.assemBuf = new byte[recordSize];\n+        this.recordBuf = new byte[recordSize];\n+        this.oneBuf = new byte[1];\n+    }\n+\n+    /**\n+     * Set the long file mode.\n+     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n+     * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).\n+     * Default is LONGFILE_ERROR.\n+     * @param longFileMode the mode to use\n+     */\n+    public void setLongFileMode(int longFileMode) {\n+        this.longFileMode = longFileMode;\n+    }\n+\n+\n+    /**\n+     * Sets the debugging flag.\n+     *\n+     * @param debugF True to turn on debugging.\n+     */\n+    public void setDebug(boolean debugF) {\n+        this.debug = debugF;\n+    }\n+\n+    /**\n+     * Sets the debugging flag in this stream's TarBuffer.\n+     *\n+     * @param debug True to turn on debugging.\n+     */\n+    public void setBufferDebug(boolean debug) {\n+        buffer.setDebug(debug);\n+    }\n+\n+    /**\n+     * Ends the TAR archive without closing the underlying OutputStream.\n+     * The result is that the two EOF records of nulls are written.\n+     * @throws IOException on error\n+     */\n+    public void finish() throws IOException {\n+        // See Bugzilla 28776 for a discussion on this\n+        // http://issues.apache.org/bugzilla/show_bug.cgi?id=28776\n+        writeEOFRecord();\n+        writeEOFRecord();\n+    }\n+\n+    /**\n+     * Ends the TAR archive and closes the underlying OutputStream.\n+     * This means that finish() is called followed by calling the\n+     * TarBuffer's close().\n+     * @throws IOException on error\n+     */\n+    public void close() throws IOException {\n+        if (!closed) {\n+            finish();\n+            buffer.close();\n+            out.close();\n+            closed = true;\n+        }\n+    }\n+\n+    /**\n+     * Get the record size being used by this stream's TarBuffer.\n+     *\n+     * @return The TarBuffer record size.\n+     */\n+    public int getRecordSize() {\n+        return buffer.getRecordSize();\n+    }\n+\n+    /**\n+     * Put an entry on the output stream. This writes the entry's\n+     * header record and positions the output stream for writing\n+     * the contents of the entry. Once this method is called, the\n+     * stream is ready for calls to write() to write the entry's\n+     * contents. Once the contents are written, closeEntry()\n+     * <B>MUST</B> be called to ensure that all buffered data\n+     * is completely written to the output stream.\n+     *\n+     * @param entry The TarEntry to be written to the archive.\n+     * @throws IOException on error\n+     */\n+    public void putNextEntry(TarArchiveEntry entry) throws IOException {\n+        if (entry.getName().length() >= TarConstants.NAMELEN) {\n+\n+            if (longFileMode == LONGFILE_GNU) {\n+                // create a TarEntry for the LongLink, the contents\n+                // of which are the entry's name\n+                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n+                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n+\n+                longLinkEntry.setSize(entry.getName().length() + 1);\n+                putNextEntry(longLinkEntry);\n+                write(entry.getName().getBytes());\n+                write(0);\n+                closeEntry();\n+            } else if (longFileMode != LONGFILE_TRUNCATE) {\n+                throw new RuntimeException(\"file name '\" + entry.getName()\n+                                           + \"' is too long ( > \"\n+                                           + TarConstants.NAMELEN + \" bytes)\");\n+            }\n+        }\n+\n+        entry.writeEntryHeader(recordBuf);\n+        buffer.writeRecord(recordBuf);\n+\n+        currBytes = 0;\n+\n+        if (entry.isDirectory()) {\n+            currSize = 0;\n+        } else {\n+            currSize = entry.getSize();\n+        }\n+        currName = entry.getName();\n+    }\n+\n+    /**\n+     * Close an entry. This method MUST be called for all file\n+     * entries that contain data. The reason is that we must\n+     * buffer data written to the stream in order to satisfy\n+     * the buffer's record based writes. Thus, there may be\n+     * data fragments still being assembled that must be written\n+     * to the output stream before this entry is closed and the\n+     * next entry written.\n+     * @throws IOException on error\n+     */\n+    public void closeEntry() throws IOException {\n+        if (assemLen > 0) {\n+            for (int i = assemLen; i < assemBuf.length; ++i) {\n+                assemBuf[i] = 0;\n+            }\n+\n+            buffer.writeRecord(assemBuf);\n+\n+            currBytes += assemLen;\n+            assemLen = 0;\n+        }\n+\n+        if (currBytes < currSize) {\n+            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n+                                  + currBytes\n+                                  + \"' before the '\" + currSize\n+                                  + \"' bytes specified in the header were written\");\n+        }\n+    }\n+\n+    /**\n+     * Writes a byte to the current tar archive entry.\n+     *\n+     * This method simply calls read( byte[], int, int ).\n+     *\n+     * @param b The byte written.\n+     * @throws IOException on error\n+     */\n+    public void write(int b) throws IOException {\n+        oneBuf[0] = (byte) b;\n+\n+        write(oneBuf, 0, 1);\n+    }\n+\n+    /**\n+     * Writes bytes to the current tar archive entry.\n+     *\n+     * This method simply calls write( byte[], int, int ).\n+     *\n+     * @param wBuf The buffer to write to the archive.\n+     * @throws IOException on error\n+     */\n+    public void write(byte[] wBuf) throws IOException {\n+        write(wBuf, 0, wBuf.length);\n+    }\n+\n+    /**\n+     * Writes bytes to the current tar archive entry. This method\n+     * is aware of the current entry and will throw an exception if\n+     * you attempt to write bytes past the length specified for the\n+     * current entry. The method is also (painfully) aware of the\n+     * record buffering required by TarBuffer, and manages buffers\n+     * that are not a multiple of recordsize in length, including\n+     * assembling records from small buffers.\n+     *\n+     * @param wBuf The buffer to write to the archive.\n+     * @param wOffset The offset in the buffer from which to get bytes.\n+     * @param numToWrite The number of bytes to write.\n+     * @throws IOException on error\n+     */\n+    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n+        if ((currBytes + numToWrite) > currSize) {\n+            throw new IOException(\"request to write '\" + numToWrite\n+                                  + \"' bytes exceeds size in header of '\"\n+                                  + currSize + \"' bytes for entry '\"\n+                                  + currName + \"'\");\n+\n+            //\n+            // We have to deal with assembly!!!\n+            // The programmer can be writing little 32 byte chunks for all\n+            // we know, and we must assemble complete records for writing.\n+            // REVIEW Maybe this should be in TarBuffer? Could that help to\n+            // eliminate some of the buffer copying.\n+            //\n+        }\n+\n+        if (assemLen > 0) {\n+            if ((assemLen + numToWrite) >= recordBuf.length) {\n+                int aLen = recordBuf.length - assemLen;\n+\n+                System.arraycopy(assemBuf, 0, recordBuf, 0,\n+                                 assemLen);\n+                System.arraycopy(wBuf, wOffset, recordBuf,\n+                                 assemLen, aLen);\n+                buffer.writeRecord(recordBuf);\n+\n+                currBytes += recordBuf.length;\n+                wOffset += aLen;\n+                numToWrite -= aLen;\n+                assemLen = 0;\n+            } else {\n+                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n+                                 numToWrite);\n+\n+                wOffset += numToWrite;\n+                assemLen += numToWrite;\n+                numToWrite = 0;\n+            }\n+        }\n+\n+        //\n+        // When we get here we have EITHER:\n+        // o An empty \"assemble\" buffer.\n+        // o No bytes to write (numToWrite == 0)\n+        //\n+        while (numToWrite > 0) {\n+            if (numToWrite < recordBuf.length) {\n+                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n+                                 numToWrite);\n+\n+                assemLen += numToWrite;\n+\n+                break;\n+            }\n+\n+            buffer.writeRecord(wBuf, wOffset);\n+\n+            int num = recordBuf.length;\n+\n+            currBytes += num;\n+            numToWrite -= num;\n+            wOffset += num;\n+        }\n+    }\n+\n+    /**\n+     * Write an EOF (end of archive) record to the tar archive.\n+     * An EOF record consists of a record of all zeros.\n+     */\n+    private void writeEOFRecord() throws IOException {\n+        for (int i = 0; i < recordBuf.length; ++i) {\n+            recordBuf[i] = 0;\n+        }\n+\n+        buffer.writeRecord(recordBuf);\n+    }\n+\n+    // used to be implemented via FilterOutputStream\n+    public void flush() throws IOException {\n+        out.flush();\n+    }\n+\n+    // ArchiveOutputStream\n+\n+    public void closeArchiveEntry() throws IOException {\n+        closeEntry();\n+    }\n+\n+    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n+        putNextEntry((TarArchiveEntry) entry);\n+    }\n+\n+    public String getDefaultFileExtension() {\n+        return \"tar\";\n+    }\n+\n+    public byte[] getHeader() {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    public String getName() {\n+        return \"tar\";\n+    }\n+\n+}", "timestamp": 1234408390, "metainfo": ""}