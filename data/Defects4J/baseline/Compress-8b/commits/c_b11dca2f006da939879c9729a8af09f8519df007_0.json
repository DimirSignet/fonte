{"sha": "b11dca2f006da939879c9729a8af09f8519df007", "log": "make block size configurable, auto-generate unique values for inode and dev, provide a reasonable default for mode.  COMPRESS-85  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n      * @return Returns the mode.\n      */\n     public long getMode() {\n-        return this.mode;\n+        return mode == 0 && !CPIO_TRAILER.equals(name) ? C_ISREG : mode;\n     }\n \n     /**\n      * @return Returns the number of links.\n      */\n     public long getNumberOfLinks() {\n-        return this.nlink;\n+        return nlink == 0 ?\n+            (isDirectory() ? 2 : 1)\n+            : nlink;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n \n     private final OutputStream out;\n \n-    /**\n-     * Construct the cpio output stream with a specified format\n+    private final int blockSize;\n+\n+    private long nextArtificalDeviceAndInode = 1;\n+\n+    /**\n+     * Construct the cpio output stream with a specified format and a\n+     * blocksize of {@link CpioConstants.BLOCK_SIZE BLOCK_SIZE}.\n      * \n      * @param out\n      *            The cpio stream\n      *            The format of the stream\n      */\n     public CpioArchiveOutputStream(final OutputStream out, final short format) {\n+        this(out, format, BLOCK_SIZE);\n+    }\n+\n+    /**\n+     * Construct the cpio output stream with a specified format\n+     * \n+     * @param out\n+     *            The cpio stream\n+     * @param format\n+     *            The format of the stream\n+     * @param blockSize\n+     *            The block size of the archive.\n+     */\n+    public CpioArchiveOutputStream(final OutputStream out, final short format,\n+                                   final int blockSize) {\n         this.out = new CountingStream(out);\n         switch (format) {\n         case FORMAT_NEW:\n             break;\n         default:\n             throw new IllegalArgumentException(\"Unknown format: \"+format);\n-        \n+\n         }\n         this.entryFormat = format;\n+        this.blockSize = blockSize;\n     }\n \n     /**\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        \n+\n         CpioArchiveEntry e = (CpioArchiveEntry) entry;\n         ensureOpen();\n         if (this.entry != null) {\n     }\n \n     private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\n-        writeAsciiLong(entry.getInode(), 8, 16);\n+        long inode = entry.getInode();\n+        long devMin = entry.getDeviceMin();\n+        if (CPIO_TRAILER.equals(entry.getName())) {\n+            inode = devMin = 0;\n+        } else {\n+            if (inode == 0 && devMin == 0) {\n+                inode = nextArtificalDeviceAndInode & 0xFFFFFFFF;\n+                devMin = (nextArtificalDeviceAndInode++ >> 32) & 0xFFFFFFFF;\n+            } else {\n+                nextArtificalDeviceAndInode =\n+                    Math.max(nextArtificalDeviceAndInode,\n+                             inode + 0x100000000L * devMin) + 1;\n+            }\n+        }\n+\n+        writeAsciiLong(inode, 8, 16);\n         writeAsciiLong(entry.getMode(), 8, 16);\n         writeAsciiLong(entry.getUID(), 8, 16);\n         writeAsciiLong(entry.getGID(), 8, 16);\n         writeAsciiLong(entry.getTime(), 8, 16);\n         writeAsciiLong(entry.getSize(), 8, 16);\n         writeAsciiLong(entry.getDeviceMaj(), 8, 16);\n-        writeAsciiLong(entry.getDeviceMin(), 8, 16);\n+        writeAsciiLong(devMin, 8, 16);\n         writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\n         writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\n         writeAsciiLong(entry.getName().length() + 1, 8, 16);\n \n     private void writeOldAsciiEntry(final CpioArchiveEntry entry)\n             throws IOException {\n-        writeAsciiLong(entry.getDevice(), 6, 8);\n-        writeAsciiLong(entry.getInode(), 6, 8);\n+        long inode = entry.getInode();\n+        long device = entry.getDevice();\n+        if (CPIO_TRAILER.equals(entry.getName())) {\n+            inode = device = 0;\n+        } else {\n+            if (inode == 0 && device == 0) {\n+                inode = nextArtificalDeviceAndInode & 0777777;\n+                device = (nextArtificalDeviceAndInode++ >> 18) & 0777777;\n+            } else {\n+                nextArtificalDeviceAndInode =\n+                    Math.max(nextArtificalDeviceAndInode,\n+                             inode + 01000000 * device) + 1;\n+            }\n+        }\n+\n+        writeAsciiLong(device, 6, 8);\n+        writeAsciiLong(inode, 6, 8);\n         writeAsciiLong(entry.getMode(), 6, 8);\n         writeAsciiLong(entry.getUID(), 6, 8);\n         writeAsciiLong(entry.getGID(), 6, 8);\n \n     private void writeOldBinaryEntry(final CpioArchiveEntry entry,\n             final boolean swapHalfWord) throws IOException {\n-        writeBinaryLong(entry.getDevice(), 2, swapHalfWord);\n-        writeBinaryLong(entry.getInode(), 2, swapHalfWord);\n+        long inode = entry.getInode();\n+        long device = entry.getDevice();\n+        if (CPIO_TRAILER.equals(entry.getName())) {\n+            inode = device = 0;\n+        } else {\n+            if (inode == 0 && device == 0) {\n+                inode = nextArtificalDeviceAndInode & 0xFFFF;\n+                device = (nextArtificalDeviceAndInode++ >> 16) & 0xFFFF;\n+            } else {\n+                nextArtificalDeviceAndInode =\n+                    Math.max(nextArtificalDeviceAndInode,\n+                             inode + 0x10000 * device) + 1;\n+            }\n+        }\n+\n+        writeBinaryLong(device, 2, swapHalfWord);\n+        writeBinaryLong(inode, 2, swapHalfWord);\n         writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n         writeBinaryLong(entry.getUID(), 2, swapHalfWord);\n         writeBinaryLong(entry.getGID(), 2, swapHalfWord);\n         if(finished) {\n             throw new IOException(\"Stream has already been finished\");\n         }\n-        \n+\n         ensureOpen();\n \n         if (entry == null) {\n         if (finished) {\n             throw new IOException(\"This archive has already been finished\");\n         }\n-        \n+\n         if (this.entry != null) {\n             throw new IOException(\"This archive contains unclosed entries.\");\n         }\n         closeArchiveEntry();\n \n         int lengthOfLastBlock =\n-            (int) (((CountingStream) out).getTotalWritten() % BLOCK_SIZE);\n+            (int) (((CountingStream) out).getTotalWritten() % blockSize);\n         if (lengthOfLastBlock != 0) {\n-            pad(BLOCK_SIZE - lengthOfLastBlock);\n+            pad(blockSize - lengthOfLastBlock);\n         }\n \n         finished = true;\n         if(!finished) {\n             finish();\n         }\n-        \n+\n         if (!this.closed) {\n             out.close();\n             this.closed = true;\n             write(b, 0, b.length);\n         }\n         public void write(int b) throws IOException {\n+            out.write(b);\n             totalWritten++;\n-            out.write(b);\n         }\n         public void write(byte[] b, int off, int len)\n             throws IOException {\n+            out.write(b, off, len);\n             totalWritten += len;\n-            out.write(b, off, len);\n         }\n         private long getTotalWritten() { return totalWritten; }\n     }", "timestamp": 1266494121, "metainfo": ""}