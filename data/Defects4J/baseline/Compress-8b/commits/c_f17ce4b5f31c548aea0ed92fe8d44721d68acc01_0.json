{"sha": "f17ce4b5f31c548aea0ed92fe8d44721d68acc01", "log": "Make entry \"constants\" final  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java\n  *\n  * <p>The MAGIC numbers and other constants are defined in {@link CpioConstants}\n  * @see \"http://people.freebsd.org/~kientzle/libarchive/man/cpio.5.txt\"\n+ * \n+ * @NotThreadSafe\n  */\n public class CpioArchiveEntry implements CpioConstants, ArchiveEntry {\n \n     /**\n      * See {@link CpioArchiveEntry#setFormat(short)} for possible values.\n      */\n-    private short fileFormat = 0; // Default chosen so checkNewFormat() and checkOldFormat() both fail \n+    private final short fileFormat; \n \n     /** The number of bytes in each header record; depends on the file format */\n-    private int headerSize = -1;\n+    private final int headerSize;\n \n     /** The boundary to which the header and data elements are aligned: 0, 2 or 4 bytes */\n-    private int alignmentBoundary;\n+    private final int alignmentBoundary;\n \n     // Header fields\n     \n      * \n      * @param format\n      *            The cpio format for this entry.\n+     * <br/>\n+     * Possible format values are:\n+     * <p>\n+     * CpioConstants.FORMAT_NEW<br/>\n+     * CpioConstants.FORMAT_NEW_CRC<br/>\n+     * CpioConstants.FORMAT_OLD_BINARY<br/>\n+     * CpioConstants.FORMAT_OLD_ASCII<br/>\n+     * \n      */\n     public CpioArchiveEntry(final short format) {\n-        setFormat(format);\n-    }\n-\n-    /**\n-     * Ceates a CPIOArchiveEntry with a specified name. The format of this entry\n-     * will be the new format.\n-     * \n-     * @param name\n-     *            The name of this entry.\n-     */\n-    public CpioArchiveEntry(final String name) {\n-        this(FORMAT_NEW);\n-        this.name = name;\n-    }\n-\n-    /**\n-     * Creates a CPIOArchiveEntry with a specified name. The format of this entry\n-     * will be the new format.\n-     * \n-     * @param name\n-     *            The name of this entry.\n-     * @param size\n-     *            The size of this entry\n-     */\n-    public CpioArchiveEntry(final String name, final long size) {\n-        this(FORMAT_NEW);\n-        this.name = name;\n-        this.setSize(size);\n-    }\n-\n-    /**\n-     * Check if the method is allowed for the defined format.\n-     */\n-    private void checkNewFormat() {\n-        if ((this.fileFormat & FORMAT_NEW_MASK) == 0) {\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n-\n-    /**\n-     * Check if the method is allowed for the defined format.\n-     */\n-    private void checkOldFormat() {\n-        if ((this.fileFormat & FORMAT_OLD_MASK) == 0) {\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n-\n-    /**\n-     * Get the checksum.\n-     * Only supported for the new formats.\n-     * \n-     * @return Returns the checksum.\n-     * @throws UnsupportedOperationException if the format is not a new format\n-     */\n-    public long getChksum() {\n-        checkNewFormat();\n-        return this.chksum;\n-    }\n-\n-    /**\n-     * Get the device id.\n-     * \n-     * @return Returns the device id.\n-     * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with a new\n-     *             format.\n-     */\n-    public long getDevice() {\n-        checkOldFormat();\n-        return this.min;\n-    }\n-\n-    /**\n-     * Get the major device id.\n-     * \n-     * @return Returns the major device id.\n-     * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with an old\n-     *             format.\n-     */\n-    public long getDeviceMaj() {\n-        checkNewFormat();\n-        return this.maj;\n-    }\n-\n-    /**\n-     * Get the minor device id\n-     * \n-     * @return Returns the minor device id.\n-     * @throws UnsupportedOperationException if format is not a new format\n-     */\n-    public long getDeviceMin() {\n-        checkNewFormat();\n-        return this.min;\n-    }\n-\n-    /**\n-     * Get the filesize.\n-     * \n-     * @return Returns the filesize.\n-     * @see org.apache.commons.compress.archivers.ArchiveEntry#getSize()\n-     */\n-    public long getSize() {\n-        return this.filesize;\n-    }\n-\n-    /**\n-     * Get the format for this entry.\n-     * \n-     * @return Returns the format.\n-     */\n-    public short getFormat() {\n-        return this.fileFormat;\n-    }\n-\n-    /**\n-     * Get the group id.\n-     * \n-     * @return Returns the group id.\n-     */\n-    public long getGID() {\n-        return this.gid;\n-    }\n-\n-    /**\n-     * Get the header size for this CPIO format\n-     * \n-     * @return Returns the header size in bytes.\n-     */\n-    public int getHeaderSize() {\n-        return this.headerSize;\n-    }\n-\n-    /**\n-     * Get the alignment boundary for this CPIO format\n-     * \n-     * @return Returns the aligment boundary (0, 2, 4) in bytes\n-     */\n-    public int getAlignmentBoundary() {\n-        return this.alignmentBoundary;\n-    }\n-\n-    /**\n-     * Get the number of bytes needed to pad the header to the alignment boundary.\n-     * \n-     * @return the number of bytes needed to pad the header (0,1,2,3)\n-     */\n-    public int getHeaderPadCount(){\n-        if (this.alignmentBoundary == 0) return 0;\n-        int size = this.headerSize+this.name.length()+1; // Name has terminating null\n-        int remain = size % this.alignmentBoundary;\n-        if (remain > 0){\n-            return this.alignmentBoundary - remain;\n-        }\n-        return 0;\n-    }\n-\n-    /**\n-     * Get the number of bytes needed to pad the data to the alignment boundary.\n-     * \n-     * @return the number of bytes needed to pad the data (0,1,2,3)\n-     */\n-    public int getDataPadCount(){\n-        if (this.alignmentBoundary == 0) return 0;\n-        long size = this.filesize;\n-        int remain = (int) (size % this.alignmentBoundary);\n-        if (remain > 0){\n-            return this.alignmentBoundary - remain;\n-        }\n-        return 0;\n-    }\n-\n-    /**\n-     * Set the inode.\n-     * \n-     * @return Returns the inode.\n-     */\n-    public long getInode() {\n-        return this.inode;\n-    }\n-\n-    /**\n-     * Get the mode of this entry (e.g. directory, regular file).\n-     * \n-     * @return Returns the mode.\n-     */\n-    public long getMode() {\n-        return this.mode;\n-    }\n-\n-    /**\n-     * Get the name.\n-     * \n-     * @return Returns the name.\n-     */\n-    public String getName() {\n-        return this.name;\n-    }\n-\n-    /**\n-     * Get the number of links.\n-     * \n-     * @return Returns the number of links.\n-     */\n-    public long getNumberOfLinks() {\n-        return this.nlink;\n-    }\n-\n-    /**\n-     * Get the remote device id.\n-     * \n-     * @return Returns the remote device id.\n-     * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with a new\n-     *             format.\n-     */\n-    public long getRemoteDevice() {\n-        checkOldFormat();\n-        return this.rmin;\n-    }\n-\n-    /**\n-     * Get the remote major device id.\n-     * \n-     * @return Returns the remote major device id.\n-     * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with an old\n-     *             format.\n-     */\n-    public long getRemoteDeviceMaj() {\n-        checkNewFormat();\n-        return this.rmaj;\n-    }\n-\n-    /**\n-     * Get the remote minor device id.\n-     * \n-     * @return Returns the remote minor device id.\n-     * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with an old\n-     *             format.\n-     */\n-    public long getRemoteDeviceMin() {\n-        checkNewFormat();\n-        return this.rmin;\n-    }\n-\n-    /**\n-     * Get the time in seconds.\n-     * \n-     * @return Returns the time.\n-     */\n-    public long getTime() {\n-        return this.mtime;\n-    }\n-\n-    /**\n-     * Get the user id.\n-     * \n-     * @return Returns the user id.\n-     */\n-    public long getUID() {\n-        return this.uid;\n-    }\n-\n-    /**\n-     * Check if this entry represents a block device.\n-     * \n-     * @return TRUE if this entry is a block device.\n-     */\n-    public boolean isBlockDevice() {\n-        return (this.mode & S_IFMT) == C_ISBLK;\n-    }\n-\n-    /**\n-     * Check if this entry represents a character device.\n-     * \n-     * @return TRUE if this entry is a character device.\n-     */\n-    public boolean isCharacterDevice() {\n-        return (this.mode & S_IFMT) == C_ISCHR;\n-    }\n-\n-    /**\n-     * Check if this entry represents a directory.\n-     * \n-     * @return TRUE if this entry is a directory.\n-     */\n-    public boolean isDirectory() {\n-        return (this.mode & S_IFMT) == C_ISDIR;\n-    }\n-\n-    /**\n-     * Check if this entry represents a network device.\n-     * \n-     * @return TRUE if this entry is a network device.\n-     */\n-    public boolean isNetwork() {\n-        return (this.mode & S_IFMT) == C_ISNWK;\n-    }\n-\n-    /**\n-     * Check if this entry represents a pipe.\n-     * \n-     * @return TRUE if this entry is a pipe.\n-     */\n-    public boolean isPipe() {\n-        return (this.mode & S_IFMT) == C_ISFIFO;\n-    }\n-\n-    /**\n-     * Check if this entry represents a regular file.\n-     * \n-     * @return TRUE if this entry is a regular file.\n-     */\n-    public boolean isRegularFile() {\n-        return (this.mode & S_IFMT) == C_ISREG;\n-    }\n-\n-    /**\n-     * Check if this entry represents a socket.\n-     * \n-     * @return TRUE if this entry is a socket.\n-     */\n-    public boolean isSocket() {\n-        return (this.mode & S_IFMT) == C_ISSOCK;\n-    }\n-\n-    /**\n-     * Check if this entry represents a symbolic link.\n-     * \n-     * @return TRUE if this entry is a symbolic link.\n-     */\n-    public boolean isSymbolicLink() {\n-        return (this.mode & S_IFMT) == C_ISLNK;\n-    }\n-\n-    /**\n-     * Set the checksum. The checksum is calculated by adding all bytes of a\n-     * file to transfer (crc += buf[pos] & 0xFF).\n-     * \n-     * @param chksum\n-     *            The checksum to set.\n-     */\n-    public void setChksum(final long chksum) {\n-        checkNewFormat();\n-        this.chksum = chksum;\n-    }\n-\n-    /**\n-     * Set the device id.\n-     * \n-     * @param device\n-     *            The device id to set.\n-     * @throws UnsupportedOperationException\n-     *             if this method is called for a CPIOArchiveEntry with a new\n-     *             format.\n-     */\n-    public void setDevice(final long device) {\n-        checkOldFormat();\n-        this.min = device;\n-    }\n-\n-    /**\n-     * Set major device id.\n-     * \n-     * @param maj\n-     *            The major device id to set.\n-     */\n-    public void setDeviceMaj(final long maj) {\n-        checkNewFormat();\n-        this.maj = maj;\n-    }\n-\n-    /**\n-     * Set the minor device id\n-     * \n-     * @param min\n-     *            The minor device id to set.\n-     */\n-    public void setDeviceMin(final long min) {\n-        checkNewFormat();\n-        this.min = min;\n-    }\n-\n-    /**\n-     * Set the filesize.\n-     * \n-     * @param size\n-     *            The filesize to set.\n-     */\n-    public void setSize(final long size) {\n-        if (size < 0 || size > 0xFFFFFFFFL) {\n-            throw new IllegalArgumentException(\"invalid entry size <\" + size\n-                    + \">\");\n-        }\n-        this.filesize = size;\n-    }\n-\n-    /**\n-     * Set the header format for this entry.\n-     * <br/>\n-     * Possible values are:\n-     * <p>\n-     * {@link CpioConstants.FORMAT_NEW}<br/>\n-     * {@link CpioConstants.FORMAT_NEW_CRC}<br/>\n-     * {@link CpioConstants.FORMAT_OLD_BINARY}<br/>\n-     * {@link CpioConstants.FORMAT_OLD_ASCII}<br/>\n-     * \n-     * @param format\n-     *            The format to set.\n-     */\n-    final void setFormat(final short format) {\n         switch (format) {\n         case FORMAT_NEW:\n             this.headerSize = 110;\n     }\n \n     /**\n+     * Ceates a CPIOArchiveEntry with a specified name. The format of this entry\n+     * will be the new format.\n+     * \n+     * @param name\n+     *            The name of this entry.\n+     */\n+    public CpioArchiveEntry(final String name) {\n+        this(FORMAT_NEW);\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Creates a CPIOArchiveEntry with a specified name. The format of this entry\n+     * will be the new format.\n+     * \n+     * @param name\n+     *            The name of this entry.\n+     * @param size\n+     *            The size of this entry\n+     */\n+    public CpioArchiveEntry(final String name, final long size) {\n+        this(FORMAT_NEW);\n+        this.name = name;\n+        this.setSize(size);\n+    }\n+\n+    /**\n+     * Check if the method is allowed for the defined format.\n+     */\n+    private void checkNewFormat() {\n+        if ((this.fileFormat & FORMAT_NEW_MASK) == 0) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    /**\n+     * Check if the method is allowed for the defined format.\n+     */\n+    private void checkOldFormat() {\n+        if ((this.fileFormat & FORMAT_OLD_MASK) == 0) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    /**\n+     * Get the checksum.\n+     * Only supported for the new formats.\n+     * \n+     * @return Returns the checksum.\n+     * @throws UnsupportedOperationException if the format is not a new format\n+     */\n+    public long getChksum() {\n+        checkNewFormat();\n+        return this.chksum;\n+    }\n+\n+    /**\n+     * Get the device id.\n+     * \n+     * @return Returns the device id.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with a new\n+     *             format.\n+     */\n+    public long getDevice() {\n+        checkOldFormat();\n+        return this.min;\n+    }\n+\n+    /**\n+     * Get the major device id.\n+     * \n+     * @return Returns the major device id.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with an old\n+     *             format.\n+     */\n+    public long getDeviceMaj() {\n+        checkNewFormat();\n+        return this.maj;\n+    }\n+\n+    /**\n+     * Get the minor device id\n+     * \n+     * @return Returns the minor device id.\n+     * @throws UnsupportedOperationException if format is not a new format\n+     */\n+    public long getDeviceMin() {\n+        checkNewFormat();\n+        return this.min;\n+    }\n+\n+    /**\n+     * Get the filesize.\n+     * \n+     * @return Returns the filesize.\n+     * @see org.apache.commons.compress.archivers.ArchiveEntry#getSize()\n+     */\n+    public long getSize() {\n+        return this.filesize;\n+    }\n+\n+    /**\n+     * Get the format for this entry.\n+     * \n+     * @return Returns the format.\n+     */\n+    public short getFormat() {\n+        return this.fileFormat;\n+    }\n+\n+    /**\n+     * Get the group id.\n+     * \n+     * @return Returns the group id.\n+     */\n+    public long getGID() {\n+        return this.gid;\n+    }\n+\n+    /**\n+     * Get the header size for this CPIO format\n+     * \n+     * @return Returns the header size in bytes.\n+     */\n+    public int getHeaderSize() {\n+        return this.headerSize;\n+    }\n+\n+    /**\n+     * Get the alignment boundary for this CPIO format\n+     * \n+     * @return Returns the aligment boundary (0, 2, 4) in bytes\n+     */\n+    public int getAlignmentBoundary() {\n+        return this.alignmentBoundary;\n+    }\n+\n+    /**\n+     * Get the number of bytes needed to pad the header to the alignment boundary.\n+     * \n+     * @return the number of bytes needed to pad the header (0,1,2,3)\n+     */\n+    public int getHeaderPadCount(){\n+        if (this.alignmentBoundary == 0) return 0;\n+        int size = this.headerSize+this.name.length()+1; // Name has terminating null\n+        int remain = size % this.alignmentBoundary;\n+        if (remain > 0){\n+            return this.alignmentBoundary - remain;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Get the number of bytes needed to pad the data to the alignment boundary.\n+     * \n+     * @return the number of bytes needed to pad the data (0,1,2,3)\n+     */\n+    public int getDataPadCount(){\n+        if (this.alignmentBoundary == 0) return 0;\n+        long size = this.filesize;\n+        int remain = (int) (size % this.alignmentBoundary);\n+        if (remain > 0){\n+            return this.alignmentBoundary - remain;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Set the inode.\n+     * \n+     * @return Returns the inode.\n+     */\n+    public long getInode() {\n+        return this.inode;\n+    }\n+\n+    /**\n+     * Get the mode of this entry (e.g. directory, regular file).\n+     * \n+     * @return Returns the mode.\n+     */\n+    public long getMode() {\n+        return this.mode;\n+    }\n+\n+    /**\n+     * Get the name.\n+     * \n+     * @return Returns the name.\n+     */\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    /**\n+     * Get the number of links.\n+     * \n+     * @return Returns the number of links.\n+     */\n+    public long getNumberOfLinks() {\n+        return this.nlink;\n+    }\n+\n+    /**\n+     * Get the remote device id.\n+     * \n+     * @return Returns the remote device id.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with a new\n+     *             format.\n+     */\n+    public long getRemoteDevice() {\n+        checkOldFormat();\n+        return this.rmin;\n+    }\n+\n+    /**\n+     * Get the remote major device id.\n+     * \n+     * @return Returns the remote major device id.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with an old\n+     *             format.\n+     */\n+    public long getRemoteDeviceMaj() {\n+        checkNewFormat();\n+        return this.rmaj;\n+    }\n+\n+    /**\n+     * Get the remote minor device id.\n+     * \n+     * @return Returns the remote minor device id.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with an old\n+     *             format.\n+     */\n+    public long getRemoteDeviceMin() {\n+        checkNewFormat();\n+        return this.rmin;\n+    }\n+\n+    /**\n+     * Get the time in seconds.\n+     * \n+     * @return Returns the time.\n+     */\n+    public long getTime() {\n+        return this.mtime;\n+    }\n+\n+    /**\n+     * Get the user id.\n+     * \n+     * @return Returns the user id.\n+     */\n+    public long getUID() {\n+        return this.uid;\n+    }\n+\n+    /**\n+     * Check if this entry represents a block device.\n+     * \n+     * @return TRUE if this entry is a block device.\n+     */\n+    public boolean isBlockDevice() {\n+        return (this.mode & S_IFMT) == C_ISBLK;\n+    }\n+\n+    /**\n+     * Check if this entry represents a character device.\n+     * \n+     * @return TRUE if this entry is a character device.\n+     */\n+    public boolean isCharacterDevice() {\n+        return (this.mode & S_IFMT) == C_ISCHR;\n+    }\n+\n+    /**\n+     * Check if this entry represents a directory.\n+     * \n+     * @return TRUE if this entry is a directory.\n+     */\n+    public boolean isDirectory() {\n+        return (this.mode & S_IFMT) == C_ISDIR;\n+    }\n+\n+    /**\n+     * Check if this entry represents a network device.\n+     * \n+     * @return TRUE if this entry is a network device.\n+     */\n+    public boolean isNetwork() {\n+        return (this.mode & S_IFMT) == C_ISNWK;\n+    }\n+\n+    /**\n+     * Check if this entry represents a pipe.\n+     * \n+     * @return TRUE if this entry is a pipe.\n+     */\n+    public boolean isPipe() {\n+        return (this.mode & S_IFMT) == C_ISFIFO;\n+    }\n+\n+    /**\n+     * Check if this entry represents a regular file.\n+     * \n+     * @return TRUE if this entry is a regular file.\n+     */\n+    public boolean isRegularFile() {\n+        return (this.mode & S_IFMT) == C_ISREG;\n+    }\n+\n+    /**\n+     * Check if this entry represents a socket.\n+     * \n+     * @return TRUE if this entry is a socket.\n+     */\n+    public boolean isSocket() {\n+        return (this.mode & S_IFMT) == C_ISSOCK;\n+    }\n+\n+    /**\n+     * Check if this entry represents a symbolic link.\n+     * \n+     * @return TRUE if this entry is a symbolic link.\n+     */\n+    public boolean isSymbolicLink() {\n+        return (this.mode & S_IFMT) == C_ISLNK;\n+    }\n+\n+    /**\n+     * Set the checksum. The checksum is calculated by adding all bytes of a\n+     * file to transfer (crc += buf[pos] & 0xFF).\n+     * \n+     * @param chksum\n+     *            The checksum to set.\n+     */\n+    public void setChksum(final long chksum) {\n+        checkNewFormat();\n+        this.chksum = chksum;\n+    }\n+\n+    /**\n+     * Set the device id.\n+     * \n+     * @param device\n+     *            The device id to set.\n+     * @throws UnsupportedOperationException\n+     *             if this method is called for a CPIOArchiveEntry with a new\n+     *             format.\n+     */\n+    public void setDevice(final long device) {\n+        checkOldFormat();\n+        this.min = device;\n+    }\n+\n+    /**\n+     * Set major device id.\n+     * \n+     * @param maj\n+     *            The major device id to set.\n+     */\n+    public void setDeviceMaj(final long maj) {\n+        checkNewFormat();\n+        this.maj = maj;\n+    }\n+\n+    /**\n+     * Set the minor device id\n+     * \n+     * @param min\n+     *            The minor device id to set.\n+     */\n+    public void setDeviceMin(final long min) {\n+        checkNewFormat();\n+        this.min = min;\n+    }\n+\n+    /**\n+     * Set the filesize.\n+     * \n+     * @param size\n+     *            The filesize to set.\n+     */\n+    public void setSize(final long size) {\n+        if (size < 0 || size > 0xFFFFFFFFL) {\n+            throw new IllegalArgumentException(\"invalid entry size <\" + size\n+                    + \">\");\n+        }\n+        this.filesize = size;\n+    }\n+\n+    /**\n      * Set the group id.\n      * \n      * @param gid", "timestamp": 1238186876, "metainfo": ""}