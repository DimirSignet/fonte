{"sha": "03e94a450fcd6e8b4d185caee3cb6b693c34d8ae", "log": "optionally read STORED entries with data descriptors.  COMPRESS-103  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n  */\n package org.apache.commons.compress.archivers.zip;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.EOFException;\n import java.io.IOException;\n import java.io.InputStream;\n     private int bytesReadFromStream = 0;\n     private int lengthOfLastRead = 0;\n     private boolean hasDataDescriptor = false;\n+    private ByteArrayInputStream lastStoredEntry = null;\n+\n+    private boolean allowStoredEntriesWithDataDescriptor = false;\n \n     private static final int LFH_LEN = 30;\n     /*\n     public ZipArchiveInputStream(InputStream inputStream,\n                                  String encoding,\n                                  boolean useUnicodeExtraFields) {\n+        this(inputStream, encoding, useUnicodeExtraFields, false);\n+    }\n+\n+    /**\n+     * @param encoding the encoding to use for file names, use null\n+     * for the platform's default encoding\n+     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n+     * Extra Fields (if present) to set the file names.\n+     * @param allowStoredEntriesWithDataDescriptor whether the stream\n+     * will try to read STORED entries that use a data descriptor\n+     * @since Apache Commons Compress 1.1\n+     */\n+    public ZipArchiveInputStream(InputStream inputStream,\n+                                 String encoding,\n+                                 boolean useUnicodeExtraFields,\n+                                 boolean allowStoredEntriesWithDataDescriptor) {\n         zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n         in = new PushbackInputStream(inputStream, buf.length);\n+        this.allowStoredEntriesWithDataDescriptor =\n+            allowStoredEntriesWithDataDescriptor;\n     }\n \n     public ZipArchiveEntry getNextZipEntry() throws IOException {\n             }\n \n             if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n+                if (hasDataDescriptor) {\n+                    if (lastStoredEntry == null) {\n+                        readStoredEntry();\n+                    }\n+                    return lastStoredEntry.read(buffer, start, length);\n+                }\n+\n                 int csize = (int) current.getSize();\n                 if (readBytesOfEntry >= csize) {\n                     return -1;\n             }\n         }\n \n-        if (hasDataDescriptor) {\n+        if (lastStoredEntry == null && hasDataDescriptor) {\n             readDataDescriptor();\n         }\n \n             lengthOfLastRead = 0;\n         crc.reset();\n         current = null;\n+        lastStoredEntry = null;\n     }\n \n     private void fill() throws IOException {\n     /**\n      * Whether this entry requires a data descriptor this library can work with.\n      *\n-     * @return true if the entry doesn't require any data descriptor\n-     * or the method is DEFLATED).\n-     */\n-    private static boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\n-        return !entry.getGeneralPurposeBit().usesDataDescriptor()\n+     * @return true if allowStoredEntriesWithDataDescriptor is true,\n+     * the entry doesn't require any data descriptor or the method is\n+     * DEFLATED.\n+     */\n+    private boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\n+        return allowStoredEntriesWithDataDescriptor ||\n+            !entry.getGeneralPurposeBit().usesDataDescriptor()\n             || entry.getMethod() == ZipArchiveEntry.DEFLATED;\n     }\n \n+    /**\n+     * Caches a stored entry that uses the data descriptor.\n+     *\n+     * <ul>\n+     *   <li>Reads a stored entry until the signature of a local file\n+     *     header, central directory header or data descriptor has been\n+     *     found.</li>\n+     *   <li>Stores all entry data in lastStoredEntry.</p>\n+     *   <li>Rewinds the stream to position at the data\n+     *     descriptor.</li>\n+     *   <li>reads the data descriptor</li>\n+     * </ul>\n+     *\n+     * <p>After calling this method the entry should know its size,\n+     * the entry's data is cached and the stream is positioned at the\n+     * next local file or central directory header.</p>\n+     */\n+    private void readStoredEntry() throws IOException {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        byte[] LFH = ZipLong.LFH_SIG.getBytes();\n+        byte[] CFH = ZipLong.CFH_SIG.getBytes();\n+        byte[] DD = ZipLong.DD_SIG.getBytes();\n+        int off = 0;\n+        boolean done = false;\n+\n+        while (!done) {\n+            int r = in.read(buf, off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n+            if (r <= 0) {\n+                // read the whole archive without ever finding a\n+                // central directory\n+                throw new IOException(\"Truncated ZIP file\");\n+            }\n+            if (r + off < 4) {\n+                // buf is too small to check for a signature, loop\n+                off += r;\n+                continue;\n+            }\n+\n+            int readTooMuch = 0;\n+            for (int i = 0; !done && i < r - 4; i++) {\n+                if (buf[i] == LFH[0] && buf[i + 1] == LFH[1]) {\n+                    if ((buf[i + 2] == LFH[2] && buf[i + 3] == LFH[3])\n+                        || (buf[i] == CFH[2] && buf[i + 3] == CFH[3])) {\n+                        // found a LFH or CFH:\n+                        readTooMuch = off + r - i - 12 /* dd without signature */;\n+                        done = true;\n+                    }\n+                    else if (buf[i + 2] == DD[2] && buf[i + 3] == DD[3]) {\n+                        // found DD:\n+                        readTooMuch = off + r - i;\n+                        done = true;\n+                    }\n+                    if (done) {\n+                        // * push back bytes read in excess as well as the data\n+                        //   descriptor\n+                        // * copy the remaining bytes to cache\n+                        // * read data descriptor\n+                        ((PushbackInputStream) in).unread(buf, off + r - readTooMuch, readTooMuch);\n+                        bos.write(buf, 0, i);\n+                        readDataDescriptor();\n+                    }\n+                }\n+            }\n+            if (!done) {\n+                // worst case we've read a data descriptor without a\n+                // signature (12 bytes) plus the first three bytes of\n+                // a LFH or CFH signature\n+                // save the last 15 bytes in the buffer, cache\n+                // anything in front of that, read on\n+                if (off + r > 15) {\n+                    bos.write(buf, 0, off + r - 15);\n+                    System.arraycopy(buf, off + r - 15, buf, 0, 15);\n+                    off = 15;\n+                } else {\n+                    off += r;\n+                }\n+            }\n+        }\n+\n+        byte[] b = bos.toByteArray();\n+        lastStoredEntry = new ByteArrayInputStream(b);\n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/Lister.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Lister.java\n import java.io.BufferedInputStream;\n import java.io.File;\n import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.util.Enumeration;\n import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.utils.IOUtils;\n \n /**\n  * Simple command line application that lists the contents of a ZIP archive.\n         String archive;\n         boolean useStream = false;\n         String encoding;\n+        boolean allowStoredEntriesWithDataDescriptor = false;\n+        String dir;\n     }\n \n     public static void main(String[] args) throws IOException {\n                 new BufferedInputStream(new FileInputStream(f));\n             try {\n                 ZipArchiveInputStream zs =\n-                    new ZipArchiveInputStream(fs, cl.encoding, true);\n+                    new ZipArchiveInputStream(fs, cl.encoding, true,\n+                                              cl.allowStoredEntriesWithDataDescriptor);\n                 for (ArchiveEntry entry = zs.getNextEntry();\n                      entry != null;\n                      entry = zs.getNextEntry()) {\n-                    list((ZipArchiveEntry) entry);\n+                    ZipArchiveEntry ze = (ZipArchiveEntry) entry;\n+                    list(ze);\n+                    if (cl.dir != null) {\n+                        extract(cl.dir, ze, zs);\n+                    }\n                 }\n             } finally {\n                 fs.close();\n             try {\n                 for (Enumeration entries = zf.getEntries();\n                      entries.hasMoreElements(); ) {\n-                    list((ZipArchiveEntry) entries.nextElement());\n+                    ZipArchiveEntry ze = (ZipArchiveEntry) entries.nextElement();\n+                    list(ze);\n+                    if (cl.dir != null) {\n+                        InputStream is = zf.getInputStream(ze);\n+                        try {\n+                            extract(cl.dir, ze, is);\n+                        } finally {\n+                            is.close();\n+                        }\n+                    }\n                 }\n             } finally {\n                 zf.close();\n \n     private static void list(ZipArchiveEntry entry) {\n         System.out.println(entry.getName());\n+    }\n+\n+    private static void extract(String dir, ZipArchiveEntry entry,\n+                                InputStream is) throws IOException {\n+        File f = new File(dir, entry.getName());\n+        if (!f.getParentFile().exists()) {\n+            f.getParentFile().mkdirs();\n+        }\n+        FileOutputStream fos = null;\n+        try {\n+            fos = new FileOutputStream(f);\n+            IOUtils.copy(is, fos);\n+        } finally {\n+            if (fos != null) {\n+                fos.close();\n+            }\n+        }\n     }\n \n     private static CommandLine parse(String[] args) {\n                     System.err.println(\"missing argument to -enc\");\n                     error = true;\n                 }\n+            } else if (args[i].equals(\"-extract\")) {\n+                if (args.length > i + 1) {\n+                    cl.dir = args[++i];\n+                } else {\n+                    System.err.println(\"missing argument to -extract\");\n+                    error = true;\n+                }\n             } else if (args[i].equals(\"-stream\")) {\n                 cl.useStream = true;\n+            } else if (args[i].equals(\"+storeddd\")) {\n+                cl.allowStoredEntriesWithDataDescriptor = true;\n             } else if (args[i].equals(\"-file\")) {\n                 cl.useStream = false;\n             } else if (cl.archive != null) {\n     }\n \n     private static void usage() {\n-        System.err.println(\"lister [-enc encoding] [-stream] [-file] archive\");\n+        System.err.println(\"lister [-enc encoding] [-stream] [-file]\"\n+                           + \" [+storeddd] [-extract dir] archive\");\n         System.exit(1);\n     }\n }", "timestamp": 1269011303, "metainfo": ""}