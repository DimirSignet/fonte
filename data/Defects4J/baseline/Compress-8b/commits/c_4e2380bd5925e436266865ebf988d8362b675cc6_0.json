{"sha": "4e2380bd5925e436266865ebf988d8362b675cc6", "log": "Add support for extra fields introduced by InfoZIP in order to store UTF-8 filenames in ZIPs.  Submitted by Wolfgang Glas.  SANDBOX-176  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.zip.CRC32;\n+import java.util.zip.ZipException;\n+\n+/**\n+ * A common base class for Unicode extra information extra fields.\n+ */\n+public abstract class AbstractUnicodeExtraField implements ZipExtraField {\n+    private long nameCRC32;\n+    private byte[] unicodeName;\n+    private byte[] data;\n+\n+    protected AbstractUnicodeExtraField() {\n+    }\n+\n+    /**\n+     * Assemble as unicode path extension form the name and encoding\n+     * of the orginal zip entry.\n+     * \n+     * @param name The file name or comment.\n+     * @param zipEncoding The encoding of the filenames in the zip\n+     * file, usually <code>\"CP437\"</code>.\n+     */\n+    protected AbstractUnicodeExtraField(String name, String zipEncoding) {\n+\n+        byte[] filename = ZipEncodingHelper.encodeName(name, zipEncoding);\n+\n+        CRC32 crc32 = new CRC32();\n+        crc32.update(filename);\n+        nameCRC32 = crc32.getValue();\n+\n+        try {\n+            unicodeName = name.getBytes(\"UTF-8\");\n+        } catch (UnsupportedEncodingException e) {\n+            throw new RuntimeException(\"FATAL: UTF-8 encoding not supported.\",\n+                                       e);\n+        }\n+    }\n+\n+    private void assembleData() {\n+        if (unicodeName == null) {\n+            return;\n+        }\n+\n+        data = new byte[5 + unicodeName.length];\n+        // version 1\n+        data[0] = 0x01;\n+        System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4);\n+        System.arraycopy(unicodeName, 0, data, 5, unicodeName.length);\n+    }\n+\n+    /**\n+     * @return The CRC32 checksum of the filename or comment as\n+     *         encoded in the central directory of the zip file.\n+     */\n+    public long getNameCRC32() {\n+        return nameCRC32;\n+    }\n+\n+    /**\n+     * @param nameCRC32 The CRC32 checksum of the filename as encoded\n+     *         in the central directory of the zip file to set.\n+     */\n+    public void setNameCRC32(long nameCRC32) {\n+        nameCRC32 = nameCRC32;\n+        data = null;\n+    }\n+\n+    /**\n+     * @return The utf-8 encoded name.\n+     */\n+    public byte[] getUnicodeName() {\n+        return unicodeName;\n+    }\n+\n+    /**\n+     * @param unicodeName The utf-8 encoded name to set.\n+     */\n+    public void setUnicodeName(byte[] unicodeName) {\n+        unicodeName = unicodeName;\n+        data = null;\n+    }\n+\n+    public byte[] getCentralDirectoryData() {\n+        if (data == null) {\n+            this.assembleData();\n+        }\n+        return data;\n+    }\n+\n+    public ZipShort getCentralDirectoryLength() {\n+        if (data == null) {\n+            assembleData();\n+        }\n+        return new ZipShort(data.length);\n+    }\n+\n+    public byte[] getLocalFileDataData() {\n+        return getCentralDirectoryData();\n+    }\n+\n+    public ZipShort getLocalFileDataLength() {\n+        return getCentralDirectoryLength();\n+    }\n+\n+    public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n+        throws ZipException {\n+\n+        if (length < 5) {\n+            throw new ZipException(\"UniCode path extra data must have at least\"\n+                                   + \" 5 bytes.\");\n+        }\n+\n+        int version = buffer[offset];\n+\n+        if (version != 0x01) {\n+            throw new ZipException(\"Unsupported version [\" + version\n+                                   + \"] for UniCode path extra data.\");\n+        }\n+\n+        nameCRC32 = ZipLong.getValue(buffer, offset + 1);\n+        unicodeName = new byte[length - 5];\n+        System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5);\n+        data = null;\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n         implementations = new HashMap();\n         register(AsiExtraField.class);\n         register(JarMarker.class);\n+        register(UnicodePathExtraField.class);\n+        register(UnicodeCommentExtraField.class);\n     }\n \n     /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnicodeCommentExtraField.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Info-ZIP Unicode Comment Extra Field (0x6375):\n+ *\n+ * <p>Stores the UTF-8 version of the file comment as stored in the\n+ * central directory header.</p>\n+ *\n+ * <pre>\n+ *         Value         Size        Description\n+ *         -----         ----        -----------\n+ *  (UCom) 0x6375        Short       tag for this extra block type (\"uc\")\n+ *         TSize         Short       total data size for this block\n+ *         Version       1 byte      version of this extra field, currently 1\n+ *         ComCRC32      4 bytes     Comment Field CRC32 Checksum\n+ *         UnicodeCom    Variable    UTF-8 version of the entry comment\n+ * </pre>\n+ */\n+public class UnicodeCommentExtraField extends AbstractUnicodeExtraField {\n+\n+    public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n+\n+    public UnicodeCommentExtraField () { \n+    }\n+\n+    /**\n+     * Assemble as unicode comment extension form the comment and\n+     * encoding of the orginal zip entry.\n+     * \n+     * @param name The file name\n+     * @param zipEncoding The encoding of the comment in the zip file,\n+     * usually <code>\"CP437\"</code>.\n+     */\n+    public UnicodeCommentExtraField(String name, String zipEncoding) {\n+        super(name, zipEncoding);\n+    }\n+\n+    public ZipShort getHeaderId() {\n+        return UCOM_ID;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnicodePathExtraField.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Info-ZIP Unicode Path Extra Field (0x7075):\n+ *\n+ * <p>Stores the UTF-8 version of the file name field as stored in the \n+ * local header and central directory header.</p>\n+ *\n+ * <pre>\n+ *         Value         Size        Description\n+ *         -----         ----        -----------\n+ * (UPath) 0x7075        Short       tag for this extra block type (\"up\")\n+ *         TSize         Short       total data size for this block\n+ *         Version       1 byte      version of this extra field, currently 1\n+ *         NameCRC32     4 bytes     File Name Field CRC32 Checksum\n+ *         UnicodeName   Variable    UTF-8 version of the entry File Name\n+ * </pre>\n+ */\n+public class UnicodePathExtraField extends AbstractUnicodeExtraField {\n+\n+    public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n+\n+    public UnicodePathExtraField () { \n+    }\n+\n+    /**\n+     * Assemble as unicode path extension form the name and encoding\n+     * of the orginal zip entry.\n+     * \n+     * @param name The file name\n+     * @param zipEncoding The encoding of the filename in the zip\n+     * file, usually <code>\"CP437\"</code>.\n+     */\n+    public UnicodePathExtraField(String name, String zipEncoding) {\n+        super(name, zipEncoding);\n+    }\n+\n+    public ZipShort getHeaderId() {\n+        return UPATH_ID;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+import java.nio.charset.CodingErrorAction;\n+\n+/**\n+ * Static helper functions for robustly encoding filenames in zip files. \n+ */\n+abstract class ZipEncodingHelper {\n+\n+    /**\n+     * Grow a byte buffer, so it has a minimal capacity or at least\n+     * the double capacity of the original buffer \n+     * \n+     * @param b The original buffer.\n+     * @param newCapacity The minimal requested new capacity.\n+     * @return A byte buffer <code>r</code> with\n+     *         <code>r.capacity() = max(b.capacity()*2,newCapacity)</code> and\n+     *         all the data contained in <code>b</code> copied to the beginning\n+     *         of <code>r</code>.\n+     *\n+     */\n+    static ByteBuffer growBuffer(ByteBuffer b, int newCapacity) {\n+        b.limit(b.position());\n+        b.rewind();\n+\n+        int c2 = b.capacity() * 2;\n+        ByteBuffer on = ByteBuffer.allocate(c2 < newCapacity ? newCapacity : c2);\n+\n+        on.put(b);\n+        return on;\n+    }\n+\n+\n+    /**\n+     * The hexadecimal digits <code>0,...,9,A,...,F</code> encoded as\n+     * ASCII bytes.\n+     */\n+    private static final byte[] HEX_DIGITS =\n+        new byte [] {\n+        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41,\n+        0x42, 0x43, 0x44, 0x45, 0x46\n+    };\n+\n+    /**\n+     * Encode a filename or a comment to a byte array suitable for\n+     * storing it to a serialized zip entry.\n+     * \n+     * Examples (in pseudo-notation, right hand side is C-style notation):\n+     * <pre>\n+     *  encodeName(\"\\u20AC_for_Dollar.txt\",\"CP437\") = \"%U20AC_for_Dollar.txt\"\n+     *  encodeName(\"\\u00D6lf\\u00E4sser.txt\",\"CP437\") = \"\\231lf\\204sser.txt\"\n+     * </pre>\n+     * \n+     * @param name The filename or comment with possible non-ASCII\n+     * unicode characters.\n+     * @param encoding A valid encoding name. The standard zip\n+     *                 encoding is <code>\"CP437\"</code>,\n+     *                 <code>\"UTF-8\"</code> is supported in ZIP file\n+     *                 version <code>6.3</code> or later.\n+     * @return A byte array containing the mapped file\n+     *         name. Unmappable characters or malformed character\n+     *         sequences are mapped to a sequence of utf-16 words\n+     *         encoded in the format <code>%Uxxxx</code>.\n+     */\n+    static final byte[] encodeName(String name, String encoding) {\n+        Charset cs = Charset.forName(encoding);\n+        CharsetEncoder enc = cs.newEncoder();\n+\n+        enc.onMalformedInput(CodingErrorAction.REPORT);\n+        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n+\n+        CharBuffer cb = CharBuffer.wrap(name);\n+        ByteBuffer out = ByteBuffer.allocate(name.length()\n+                                             + (name.length() + 1) / 2);\n+\n+        while (cb.remaining() > 0) {\n+            CoderResult res = enc.encode(cb, out,true);\n+\n+            if (res.isUnmappable() || res.isMalformed()) {\n+\n+                // write the unmappable characters in utf-16\n+                // pseudo-URL encoding style to ByteBuffer.\n+                if (res.length() * 6 > out.remaining()) {\n+                    out = growBuffer(out,out.position() + res.length() * 6);\n+                }\n+\n+                for (int i=0; i<res.length(); ++i) {\n+                    out.put((byte) '%');\n+                    out.put((byte) 'U');\n+\n+                    char c = cb.get();\n+\n+                    out.put(HEX_DIGITS[(c >> 12)&0x0f]);\n+                    out.put(HEX_DIGITS[(c >> 8)&0x0f]);\n+                    out.put(HEX_DIGITS[(c >> 4)&0x0f]);\n+                    out.put(HEX_DIGITS[c & 0x0f]);\n+                }\n+\n+            } else if (res.isOverflow()) {\n+\n+                out = growBuffer(out, 0);\n+\n+            } else if (res.isUnderflow()) {\n+\n+                enc.flush(out);\n+                break;\n+\n+            }\n+        }\n+\n+        byte [] ret = new byte[out.position()];\n+        out.rewind();\n+        out.get(ret);\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Return, whether a filename or a comment may be encoded to a\n+     * byte array suitable for storing it to a serialized zip entry\n+     * without any losses.\n+     * \n+     * Examples (in pseudo-notation, right hand side is C-style notation):\n+     * <pre>\n+     *  canEncodeName(\"\\u20AC_for_Dollar.txt\",\"CP437\") = false\n+     *  canEncodeName(\"\\u20AC_for_Dollar.txt\",\"UTF-8\") = true\n+     *  canEncodeName(\"\\u00D6lf\\u00E4sser.txt\",\"CP437\") = true\n+     * </pre>\n+     * \n+     * @param name The filename or comment with possible non-ASCII\n+     * unicode characters.\n+     * @param encoding A valid encoding name. The standard zip\n+     *                 encoding is <code>\"CP437\"</code>,\n+     *                 <code>\"UTF-8\"</code> is supported in ZIP file\n+     *                 version <code>6.3</code> or later.\n+     * @return Whether the given encoding may encode the given name.\n+     */\n+    static final boolean canEncodeName(String name, String encoding) {\n+\n+        Charset cs = Charset.forName(encoding);\n+\n+        CharsetEncoder enc = cs.newEncoder();\n+        enc.onMalformedInput(CodingErrorAction.REPORT);\n+        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n+\n+        return enc.canEncode(name);\n+    }\n+}", "timestamp": 1234968670, "metainfo": ""}