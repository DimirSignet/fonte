{"sha": "865686ae662ea480b62cf42ddee81feaab741423", "log": "COMPRESS-63 - replace dependency on default charset with ASCII where appropriate; add TODOs where the required charset is not yet clear.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.utils.ArchiveUtils;\n \n /**\n  * Implements the \"ar\" archive format as an input stream.\n         }\n \n         if (offset == 0) {\n-            final byte[] expected = ArArchiveEntry.HEADER.getBytes();\n+            final byte[] expected = ArchiveUtils.toAsciiBytes(ArArchiveEntry.HEADER);\n             final byte[] realized = new byte[expected.length]; \n             final int read = read(realized);\n             if (read != expected.length) {\n             }\n             for (int i = 0; i < expected.length; i++) {\n                 if (expected[i] != realized[i]) {\n-                    throw new IOException(\"invalid header \" + new String(realized));\n+                    throw new IOException(\"invalid header \" + ArchiveUtils.toAsciiString(realized));\n                 }\n             }\n         }\n         read(length);\n \n         {\n-            final byte[] expected = ArArchiveEntry.TRAILER.getBytes();\n+            final byte[] expected = ArchiveUtils.toAsciiBytes(ArArchiveEntry.TRAILER);\n             final byte[] realized = new byte[expected.length]; \n             final int read = read(realized);\n             if (read != expected.length) {\n         if (temp.endsWith(\"/\")){\n             temp=temp.substring(0, temp.length()-1);\n         }\n-        currentEntry = new ArArchiveEntry(temp,\n+        currentEntry = new ArArchiveEntry(temp, // TODO is it correct to use the default charset here?\n                                           Long.parseLong(new String(length)\n                                                          .trim()));\n         return currentEntry;\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n+import org.apache.commons.compress.utils.ArchiveUtils;\n \n /**\n  * Implements the \"ar\" archive format as an output stream.\n     }\n \n     private long writeArchiveHeader() throws IOException {\n-        byte [] header = ArArchiveEntry.HEADER.getBytes();\n+        byte [] header = ArchiveUtils.toAsciiBytes(ArArchiveEntry.HEADER);\n         out.write(header);\n         return header.length;\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n+import org.apache.commons.compress.utils.ArchiveUtils;\n \n /**\n  * CPIOArchiveInputStream is a stream for reading cpio streams. All formats of\n             System.arraycopy(magic, 0, tmp, 0, magic.length);\n             System.arraycopy(more_magic, 0, tmp, magic.length,\n                     more_magic.length);\n-            String magicString = new String(tmp);\n+            String magicString = ArchiveUtils.toAsciiString(tmp);\n             if (magicString.equals(MAGIC_NEW)) {\n                 this.entry = readNewEntry(false);\n             } else if (magicString.equals(MAGIC_NEW_CRC)) {\n             throws IOException {\n         byte tmpBuffer[] = new byte[length];\n         readFully(tmpBuffer, 0, tmpBuffer.length);\n-        return Long.parseLong(new String(tmpBuffer), radix);\n+        return Long.parseLong(ArchiveUtils.toAsciiString(tmpBuffer), radix);\n     }\n \n     private CpioArchiveEntry readNewEntry(final boolean hasCrc)\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n+import org.apache.commons.compress.utils.ArchiveUtils;\n \n /**\n  * CPIOArchiveOutputStream is a stream for writing CPIO streams. All formats of\n     private void writeHeader(final CpioArchiveEntry e) throws IOException {\n         switch (e.getFormat()) {\n         case FORMAT_NEW:\n-            out.write(MAGIC_NEW.getBytes());\n+            out.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW));\n             writeNewEntry(e);\n             break;\n         case FORMAT_NEW_CRC:\n-            out.write(MAGIC_NEW_CRC.getBytes());\n+            out.write(ArchiveUtils.toAsciiBytes(MAGIC_NEW_CRC));\n             writeNewEntry(e);\n             break;\n         case FORMAT_OLD_ASCII:\n-            out.write(MAGIC_OLD_ASCII.getBytes());\n+            out.write(ArchiveUtils.toAsciiBytes(MAGIC_OLD_ASCII));\n             writeOldAsciiEntry(e);\n             break;\n         case FORMAT_OLD_BINARY:\n         } else {\n             tmpStr = tmp.substring(tmp.length() - length);\n         }\n-        out.write(tmpStr.getBytes());\n+        out.write(tmpStr.getBytes()); // TODO is it correct to use the default charset here?\n     }\n \n     private void writeCString(final String str) throws IOException {\n         out.write(str.getBytes());\n-        out.write('\\0');\n+        out.write('\\0'); // TODO is it correct to use the default charset here?\n     }\n \n     public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n                 TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                     TarConstants.LF_GNUTYPE_LONGNAME);\n \n-                final byte[] nameBytes = entry.getName().getBytes();\n+                final byte[] nameBytes = entry.getName().getBytes(); // TODO is it correct to use the default charset here?\n                 longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                 putArchiveEntry(longLinkEntry);\n                 write(nameBytes);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/AsiExtraField.java\n                           + WORD         // SizDev\n                           + 2         // UID\n                           + 2         // GID\n-                          + getLinkedFile().getBytes().length);\n+                          + getLinkedFile().getBytes().length); // TODO is it correct to use the default charset here?\n     }\n \n     /**\n         byte[] data = new byte[getLocalFileDataLength().getValue() - WORD];\n         System.arraycopy(ZipShort.getBytes(getMode()), 0, data, 0, 2);\n \n-        byte[] linkArray = getLinkedFile().getBytes();\n+        byte[] linkArray = getLinkedFile().getBytes(); // TODO is it correct to use the default charset here?\n         // CheckStyle:MagicNumber OFF\n         System.arraycopy(ZipLong.getBytes(linkArray.length),\n                          0, data, 2, WORD);\n             link = \"\";\n         } else {\n             System.arraycopy(tmp, 10, linkArray, 0, linkArray.length);\n-            link = new String(linkArray);\n+            link = new String(linkArray); // TODO is it correct to use the default charset here?\n         }\n         // CheckStyle:MagicNumber ON\n         setDirectory((newMode & DIR_FLAG) != 0);\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/FallbackZipEncoding.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/FallbackZipEncoding.java\n      */\n     public ByteBuffer encode(String name) throws IOException {\n         if (this.charset == null) {\n-            return ByteBuffer.wrap(name.getBytes());\n+            return ByteBuffer.wrap(name.getBytes()); // TODO is it correct to use the default charset here?\n         } else {\n             return ByteBuffer.wrap(name.getBytes(this.charset));\n         }\n      */\n     public String decode(byte[] data) throws IOException {\n         if (this.charset == null) {\n-            return new String(data);\n+            return new String(data); // TODO is it correct to use the default charset here?\n         } else {\n             return new String(data,this.charset);\n         }", "timestamp": 1239751312, "metainfo": ""}