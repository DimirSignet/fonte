{"sha": "91695e47a11e0ca7eb09555ea5c06f711d117036", "log": "Allow extra fields to violate the recommended structure.  COMPRESS-73  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n package org.apache.commons.compress.archivers.zip;\n \n import java.io.File;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Date;\n import java.util.LinkedHashMap;\n+import java.util.List;\n import java.util.zip.ZipException;\n import org.apache.commons.compress.archivers.ArchiveEntry;\n \n /**\n  * Extension that adds better handling of extra fields and provides\n  * access to the internal and external file attributes.\n+ *\n+ * <p>The extra data is expected to follow the recommendation of\n+ * {@link http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n+ * APPNOTE.txt}:</p>\n+ * <ul>\n+ *   <li>the extra byte array consists of a sequence of extra fields</li>\n+ *   <li>each extra fields starts by a two byte header id followed by\n+ *   a two byte sequence holding the length of the remainder of\n+ *   data.</li>\n+ * </ul>\n+ *\n+ * <p>Any extra data that cannot be parsed by the rules above will be\n+ * consumed as \"unparseable\" extra data and treated differently by the\n+ * methods of this class.  Versions prior to Apache Commons Compress\n+ * 1.1 would have thrown an exception if any attempt was made to read\n+ * or write extra data not conforming to the recommendation.</p>\n  *\n  * @NotThreadSafe\n  */\n     private int platform = PLATFORM_FAT;\n     private long externalAttributes = 0;\n     private LinkedHashMap/*<ZipShort, ZipExtraField>*/ extraFields = null;\n+    private UnparseableExtraFieldData unparseableExtra = null;\n     private String name = null;\n \n     /**\n         setName(entry.getName());\n         byte[] extra = entry.getExtra();\n         if (extra != null) {\n-            setExtraFields(ExtraFieldUtils.parse(extra));\n+            setExtraFields(ExtraFieldUtils.parse(extra, true,\n+                                                 ExtraFieldUtils\n+                                                 .UnparseableExtraField.READ));\n         } else {\n             // initializes extra data to an empty byte array\n             setExtra();\n         this((java.util.zip.ZipEntry) entry);\n         setInternalAttributes(entry.getInternalAttributes());\n         setExternalAttributes(entry.getExternalAttributes());\n-        setExtraFields(entry.getExtraFields());\n+        setExtraFields(entry.getExtraFields(true));\n     }\n \n     /**\n     public Object clone() {\n         ZipArchiveEntry e = (ZipArchiveEntry) super.clone();\n \n-        e.extraFields = extraFields != null ? (LinkedHashMap) extraFields.clone() : null;\n         e.setInternalAttributes(getInternalAttributes());\n         e.setExternalAttributes(getExternalAttributes());\n-        e.setExtraFields(getExtraFields());\n+        e.setExtraFields(getExtraFields(true));\n         return e;\n     }\n \n     public void setExtraFields(ZipExtraField[] fields) {\n         extraFields = new LinkedHashMap();\n         for (int i = 0; i < fields.length; i++) {\n+            if (fields[i] instanceof UnparseableExtraFieldData) {\n+                unparseableExtra = (UnparseableExtraFieldData) fields[i];\n+            } else {\n             extraFields.put(fields[i].getHeaderId(), fields[i]);\n+            }\n         }\n         setExtra();\n     }\n \n     /**\n+     * Retrieves all extra fields that have been parsed successfully.\n+     * @return an array of the extra fields\n+     */\n+    public ZipExtraField[] getExtraFields() {\n+        return getExtraFields(false);\n+    }\n+\n+    /**\n      * Retrieves extra fields.\n+     * @param includeUnparseable whether to also return unparseable\n+     * extra fields as {@link UnparseableExtraFieldData} if such data\n+     * exists.\n      * @return an array of the extra fields\n      */\n-    public ZipExtraField[] getExtraFields() {\n+    public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\n         if (extraFields == null) {\n-            return new ZipExtraField[0];\n-        }\n-        ZipExtraField[] result = new ZipExtraField[extraFields.size()];\n-        return (ZipExtraField[]) extraFields.values().toArray(result);\n-    }\n-\n-    /**\n-     * Adds an extra fields - replacing an already present extra field\n+            return !includeUnparseable || unparseableExtra == null\n+                ? new ZipExtraField[0]\n+                : new ZipExtraField[] { unparseableExtra };\n+        }\n+        List result = new ArrayList(extraFields.values());\n+        if (includeUnparseable && unparseableExtra != null) {\n+            result.add(unparseableExtra);\n+        }\n+        return (ZipExtraField[]) result.toArray(new ZipExtraField[0]);\n+    }\n+\n+    /**\n+     * Adds an extra field - replacing an already present extra field\n      * of the same type.\n      *\n      * <p>If no extra field of the same type exists, the field will be\n      * @param ze an extra field\n      */\n     public void addExtraField(ZipExtraField ze) {\n+        if (ze instanceof UnparseableExtraFieldData) {\n+            unparseableExtra = (UnparseableExtraFieldData) ze;\n+        } else {\n         if (extraFields == null) {\n             extraFields = new LinkedHashMap();\n         }\n         extraFields.put(ze.getHeaderId(), ze);\n+        }\n         setExtra();\n     }\n \n     /**\n-     * Adds an extra fields - replacing an already present extra field\n+     * Adds an extra field - replacing an already present extra field\n      * of the same type.\n      *\n      * <p>The new extra field will be the first one.</p>\n      * @param ze an extra field\n      */\n     public void addAsFirstExtraField(ZipExtraField ze) {\n+        if (ze instanceof UnparseableExtraFieldData) {\n+            unparseableExtra = (UnparseableExtraFieldData) ze;\n+        } else {\n         LinkedHashMap copy = extraFields;\n         extraFields = new LinkedHashMap();\n         extraFields.put(ze.getHeaderId(), ze);\n             copy.remove(ze.getHeaderId());\n             extraFields.putAll(copy);\n         }\n+        }\n         setExtra();\n     }\n \n     /**\n-     * Remove an extra fields.\n+     * Remove an extra field.\n      * @param type the type of extra field to remove\n      */\n     public void removeExtraField(ZipShort type) {\n     }\n \n     /**\n+     * Removes unparseable extra field data.\n+     */\n+    public void removeUnparseableExtraFieldData() {\n+        if (unparseableExtra == null) {\n+            throw new java.util.NoSuchElementException();\n+        }\n+        unparseableExtra = null;\n+        setExtra();\n+    }\n+\n+    /**\n      * Looks up an extra field by its header id.\n      *\n      * @return null if no such field exists.\n     }\n \n     /**\n-     * Throws an Exception if extra data cannot be parsed into extra fields.\n+     * Looks up extra field data that couldn't be parsed correctly.\n+     *\n+     * @return null if no such field exists.\n+     */\n+    public UnparseableExtraFieldData getUnparseableExtraFieldData() {\n+        return unparseableExtra;\n+    }\n+\n+    /**\n+     * Parses the given bytes as extra field data and consumes any\n+     * unparseable data as an {@link UnparseableExtraFieldData}\n+     * instance.\n      * @param extra an array of bytes to be parsed into extra fields\n      * @throws RuntimeException if the bytes cannot be parsed\n      * @throws RuntimeException on error\n      */\n     public void setExtra(byte[] extra) throws RuntimeException {\n         try {\n-            ZipExtraField[] local = ExtraFieldUtils.parse(extra, true);\n+            ZipExtraField[] local =\n+                ExtraFieldUtils.parse(extra, true,\n+                                      ExtraFieldUtils.UnparseableExtraField.READ);\n             mergeExtraFields(local, true);\n         } catch (ZipException e) {\n+            // actually this is not be possible as of Commons Compress 1.1\n             throw new RuntimeException(\"Error parsing extra fields for entry: \"\n                                        + getName() + \" - \" + e.getMessage(), e);\n         }\n      * modify super's data directly.\n      */\n     protected void setExtra() {\n-        super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));\n+        super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n     }\n \n     /**\n      */\n     public void setCentralDirectoryExtra(byte[] b) {\n         try {\n-            ZipExtraField[] central = ExtraFieldUtils.parse(b, false);\n+            ZipExtraField[] central =\n+                ExtraFieldUtils.parse(b, false,\n+                                      ExtraFieldUtils.UnparseableExtraField.READ);\n             mergeExtraFields(central, false);\n         } catch (ZipException e) {\n             throw new RuntimeException(e.getMessage(), e);\n      * @return the central directory extra data\n      */\n     public byte[] getCentralDirectoryExtra() {\n-        return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());\n+        return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields(true));\n     }\n \n     /**\n             setExtraFields(f);\n         } else {\n             for (int i = 0; i < f.length; i++) {\n-                ZipExtraField existing = getExtraField(f[i].getHeaderId());\n+                ZipExtraField existing;\n+                if (f[i] instanceof UnparseableExtraFieldData) {\n+                    existing = unparseableExtra;\n+                } else {\n+                    existing = getExtraField(f[i].getHeaderId());\n+                }\n                 if (existing == null) {\n                     addExtraField(f[i]);\n                 } else {", "timestamp": 1266328743, "metainfo": ""}