{"sha": "51e81d0fd794bee6d8765513f853a312f176dcd7", "log": "When it is possible to make the ES5 Strict mode assumptions about a function's \"this\" it is easier to inline a function referencing \"this\". Add \"CompilerOption.assumeStrictThis\" and take advantage of it during function inlining.  R=acleung DELTA=243  (204 added, 4 deleted, 35 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2199   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * Whether the compiler handles `const' keyword or not.\n    */\n   boolean acceptConstKeyword;\n+\n+  /**\n+   * Whether the compiler should assume that a function's \"this\" value\n+   * never needs coercion (for example in non-strict \"null\" or \"undefined\" will\n+   * be coerced to the global \"this\" and primitives to objects).\n+   */\n+  private boolean assumeStrictThis;\n \n   // TODO(johnlenz): Add an language output mode.\n \n     inlineConstantVars = false;\n     inlineFunctions = false;\n     inlineLocalFunctions = false;\n+    assumeStrictThis = false;\n     crossModuleCodeMotion = false;\n     crossModuleMethodMotion = false;\n     inlineGetters = false;\n     return inferTypes;\n   }\n \n+  /**\n+   * @return Whether assumeStrictThis is set.\n+   */\n+  public boolean isAssumeStrictThis() {\n+    return assumeStrictThis;\n+  }\n+\n+  /**\n+   * If true, enables enables additional optimizations.\n+   */\n+  public void setAssumeStrictThis(boolean enable) {\n+    this.assumeStrictThis = enable;\n+  }\n+\n   //////////////////////////////////////////////////////////////////////////////\n   // Enums\n \n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   final HotSwapPassFactory inferJsDocInfo =\n     new HotSwapPassFactory(\"inferJsDocInfo\", false) {\n   @Override\n-  protected HotSwapCompilerPass createInternal(final AbstractCompiler compiler) {\n+  protected HotSwapCompilerPass createInternal(\n+      final AbstractCompiler compiler) {\n     return new HotSwapCompilerPass() {\n       @Override\n       public void process(Node externs, Node root) {\n           compiler.getUniqueNameIdSupplier(),\n           options.inlineFunctions,\n           options.inlineLocalFunctions,\n-          enableBlockInlining);\n+          enableBlockInlining,\n+          options.isAssumeStrictThis());\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n  */\n class FunctionArgumentInjector {\n \n+  // A string to use to represent \"this\".  Anything that is not a valid\n+  // identifier can be used, so we use \"this\".\n+  static final String THIS_MARKER = \"this\";\n+\n   private FunctionArgumentInjector() {\n     // A private constructor to prevent instantiation.\n   }\n    *     to replace the name Nodes.\n    * @returns The root node or its replacement.\n    */\n-  static Node inject(Node node, Node parent,\n+  static Node inject(AbstractCompiler compiler, Node node, Node parent,\n       Map<String, Node> replacements) {\n     if (node.getType() == Token.NAME) {\n       Node replacementTemplate = replacements.get(node.getString());\n         parent.replaceChild(node, replacement);\n         return replacement;\n       }\n+    } else if (node.getType() == Token.THIS) {\n+      Node replacementTemplate = replacements.get(THIS_MARKER);\n+      Preconditions.checkNotNull(replacementTemplate);\n+      if (replacementTemplate.getType() != Token.THIS) {\n+        // The name may need to be replaced more than once,\n+        // so we need to clone the node.\n+        Node replacement = replacementTemplate.cloneTree();\n+        parent.replaceChild(node, replacement);\n+\n+        // Remove the value.  This isn't required but it ensures that we won't\n+        // inject side-effects multiple times as it will trigger the null\n+        // check above if we do.\n+        if (NodeUtil.mayHaveSideEffects(replacementTemplate, compiler)) {\n+          replacements.remove(THIS_MARKER);\n+        }\n+\n+        return replacement;\n+      }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       // We have to reassign c in case it was replaced, because the removed c's\n       // getNext() would no longer be correct.\n-      c = inject(c, node, replacements);\n+      c = inject(compiler, c, node, replacements);\n     }\n \n     return node;\n \n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n-    if (callNode.getFirstChild().getType() != Token.NAME) {\n-      if (NodeUtil.isFunctionObjectCall(callNode)) {\n-        // TODO(johnlenz): Support replace this with a value.\n-        Preconditions.checkNotNull(cArg);\n-        Preconditions.checkState(cArg.getType() == Token.THIS);\n-        cArg = cArg.getNext();\n-      } else {\n-        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n-      }\n+    if (cArg != null && NodeUtil.isFunctionObjectCall(callNode)) {\n+      argMap.put(THIS_MARKER, cArg);\n+      cArg = cArg.getNext();\n+    } else {\n+      // 'apply' isn't supported yet.\n+      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n+      argMap.put(THIS_MARKER, NodeUtil.newUndefinedNode(callNode));\n     }\n \n     for (Node fnArg : NodeUtil.getFunctionParameters(fnNode).children()) {\n           if (parameters.contains(name)) {\n             parametersReferenced.add(name);\n           }\n+        } else if (n.getType() == Token.THIS) {\n+          parametersReferenced.add(THIS_MARKER);\n         }\n       }\n     }\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n   private final Supplier<String> safeNameIdSupplier;\n   private final boolean allowDecomposition;\n   private Set<String> knownConstants = Sets.newHashSet();\n+  private final boolean assumeStrictThis;\n \n   /**\n    * @param allowDecomposition Whether an effort should be made to break down\n   public FunctionInjector(\n       AbstractCompiler compiler,\n       Supplier<String> safeNameIdSupplier,\n-      boolean allowDecomposition) {\n+      boolean allowDecomposition,\n+      boolean assumeStrictThis) {\n     Preconditions.checkNotNull(compiler);\n     Preconditions.checkNotNull(safeNameIdSupplier);\n     this.compiler = compiler;\n     this.safeNameIdSupplier = safeNameIdSupplier;\n     this.allowDecomposition = allowDecomposition;\n+    this.assumeStrictThis = assumeStrictThis;\n   }\n \n   /** The type of inlining to perform. */\n   private boolean isSupportedCallType(Node callNode) {\n     if (callNode.getFirstChild().getType() != Token.NAME) {\n       if (NodeUtil.isFunctionObjectCall(callNode)) {\n-        Node thisValue = callNode.getFirstChild().getNext();\n-        if (thisValue == null || thisValue.getType() != Token.THIS) {\n-          return false;\n+        if (!assumeStrictThis) {\n+          Node thisValue = callNode.getFirstChild().getNext();\n+          if (thisValue == null || thisValue.getType() != Token.THIS) {\n+            return false;\n+          }\n         }\n       } else if (NodeUtil.isFunctionObjectApply(callNode)) {\n         return false;\n       // Clone the return node first.\n       Node safeReturnNode = returnNode.cloneTree();\n       Node inlineResult = FunctionArgumentInjector.inject(\n-          safeReturnNode, null, argMap);\n+          null, safeReturnNode, null, argMap);\n       Preconditions.checkArgument(safeReturnNode == inlineResult);\n       newExpression = safeReturnNode.removeFirstChild();\n     }\n     if (callNode.getFirstChild().getType() != Token.NAME) {\n       if (NodeUtil.isFunctionObjectCall(callNode)) {\n         // TODO(johnlenz): Support replace this with a value.\n-        Preconditions.checkNotNull(cArg);\n-        Preconditions.checkState(cArg.getType() == Token.THIS);\n+        if (cArg == null || cArg.getType() != Token.THIS) {\n+          return CanInlineResult.NO;\n+        }\n         cArg = cArg.getNext();\n       } else {\n         // \".apply\" call should be filtered before this.\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n  */\n package com.google.javascript.jscomp;\n \n+import static com.google.javascript.jscomp.FunctionArgumentInjector.THIS_MARKER;\n+\n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n import com.google.common.collect.Lists;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n-import java.util.Map.Entry;\n \n /**\n  * A class to transform the body of a function into a generic block suitable\n   }\n \n   /**\n+   * Create a unique \"this\" name.\n+   */\n+  private String getUniqueThisName() {\n+    return \"JSCompiler_inline_this_\" + safeNameIdSupplier.get();\n+  }\n+\n+  /**\n    * Inlines the arguments within the node tree using the given argument map,\n    * replaces \"unsafe\" names with local aliases.\n    *\n     if (namesToAlias == null || namesToAlias.isEmpty()) {\n       // There are no names to alias, just inline the arguments directly.\n       Node result = FunctionArgumentInjector.inject(\n-          fnTemplateRoot, null, argMap);\n+          compiler, fnTemplateRoot, null, argMap);\n       Preconditions.checkState(result == fnTemplateRoot);\n       return result;\n     } else {\n       for (Entry<String, Node> entry : argMap.entrySet()) {\n         String name = entry.getKey();\n         if (namesToAlias.contains(name)) {\n-          Node newValue = entry.getValue().cloneTree();\n-          Node newNode = NodeUtil.newVarNode(name, newValue)\n-              .copyInformationFromForTree(newValue);\n-          newVars.add(0, newNode);\n-          // Remove the parameter from the list to replace.\n-          newArgMap.remove(name);\n+          if (name.equals(THIS_MARKER)) {\n+            boolean referencesThis = NodeUtil.referencesThis(fnTemplateRoot);\n+            // Update \"this\", this is only necessary if \"this\" is referenced\n+            // and the value of \"this\" is not Token.THIS, or the value of \"this\"\n+            // has side effects.\n+\n+            Node value = entry.getValue();\n+            if (value.getType() != Token.THIS\n+                && (referencesThis\n+                    || NodeUtil.mayHaveSideEffects(value, compiler))) {\n+              String newName = getUniqueThisName();\n+              Node newValue = entry.getValue().cloneTree();\n+              Node newNode = NodeUtil.newVarNode(newName, newValue)\n+                  .copyInformationFromForTree(newValue);\n+              newVars.add(0, newNode);\n+              // Remove the parameter from the list to replace.\n+              newArgMap.put(THIS_MARKER,\n+                  Node.newString(Token.NAME, newName)\n+                      .copyInformationFromForTree(newValue));\n+            }\n+          } else {\n+            Node newValue = entry.getValue().cloneTree();\n+            Node newNode = NodeUtil.newVarNode(name, newValue)\n+                .copyInformationFromForTree(newValue);\n+            newVars.add(0, newNode);\n+            // Remove the parameter from the list to replace.\n+            newArgMap.remove(name);\n+          }\n         }\n       }\n \n       // Inline the arguments.\n       Node result = FunctionArgumentInjector.inject(\n-          fnTemplateRoot, null, newArgMap);\n+          compiler, fnTemplateRoot, null, newArgMap);\n       Preconditions.checkState(result == fnTemplateRoot);\n \n       // Now that the names have been replaced, add the new aliases for\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n       Supplier<String> safeNameIdSupplier,\n       boolean inlineGlobalFunctions,\n       boolean inlineLocalFunctions,\n-      boolean blockFunctionInliningEnabled) {\n+      boolean blockFunctionInliningEnabled,\n+      boolean assumeStrictThis) {\n     Preconditions.checkArgument(compiler != null);\n     Preconditions.checkArgument(safeNameIdSupplier != null);\n     this.compiler = compiler;\n     this.inlineLocalFunctions = inlineLocalFunctions;\n     this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;\n \n-    this.injector = new FunctionInjector(compiler, safeNameIdSupplier, true);\n+    this.injector = new FunctionInjector(\n+        compiler, safeNameIdSupplier, true, assumeStrictThis);\n   }\n \n   FunctionState getOrCreateFunctionState(String fnName) {\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n public class FunctionInjectorTest extends TestCase {\n   static final InliningMode INLINE_DIRECT = InliningMode.DIRECT;\n   static final InliningMode INLINE_BLOCK = InliningMode.BLOCK;\n+  private boolean assumeStrictThis = true;\n \n \n   private FunctionInjector getInjector() {\n     Compiler compiler = new Compiler();\n     return new FunctionInjector(\n-        compiler, compiler.getUniqueNameIdSupplier(), true);\n+        compiler, compiler.getUniqueNameIdSupplier(), true, assumeStrictThis);\n   }\n \n   public void testIsSimpleFunction1() {\n   }\n \n   public void testCanInlineReferenceToFunction38() {\n+    assumeStrictThis = false;\n+\n     helperCanInlineReferenceToFunction(CanInlineResult.NO,\n         \"function foo(a){return true;}; \" +\n         \"function x() { foo.call(null, goo()); }\",\n         \"foo\", INLINE_BLOCK);\n+\n+    assumeStrictThis = true;\n+\n+    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+        \"function foo(a){return true;}; \" +\n+        \"function x() { foo.call(null, goo()); }\",\n+        \"foo\", INLINE_BLOCK);\n   }\n \n   public void testCanInlineReferenceToFunction39() {\n   }\n \n   public void testCanInlineReferenceToFunction40() {\n+    assumeStrictThis = false;\n     helperCanInlineReferenceToFunction(CanInlineResult.NO,\n         \"function foo(a){return true;}; \" +\n         \"function x() { foo.call(bar, goo()); }\",\n         \"foo\", INLINE_BLOCK);\n+\n+    assumeStrictThis = true;\n+    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+        \"function foo(a){return true;}; \" +\n+        \"function x() { foo.call(bar, goo()); }\",\n+        \"foo\", INLINE_BLOCK);\n   }\n \n   public void testCanInlineReferenceToFunction41() {\n   }\n \n   public void testCanInlineReferenceToFunction42() {\n-    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n+    assumeStrictThis = false;\n+    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n+        \"function foo(a){return true;}; \" +\n+        \"function x() { foo.call(new bar(), goo()); }\",\n+        \"foo\", INLINE_BLOCK);\n+\n+    assumeStrictThis = true;\n+    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n         \"function foo(a){return true;}; \" +\n         \"function x() { foo.call(new bar(), goo()); }\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n   public void testCanInlineReferenceToFunction44() {\n+    assumeStrictThis = false;\n     // Handle the case of a missing 'this' value in a call.\n     helperCanInlineReferenceToFunction(CanInlineResult.NO,\n+        \"function foo(){return true;}; \" +\n+        \"function x() { foo.call(); }\",\n+        \"foo\", INLINE_BLOCK);\n+\n+    assumeStrictThis = true;\n+    // Handle the case of a missing 'this' value in a call.\n+    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n         \"function foo(){return true;}; \" +\n         \"function x() { foo.call(); }\",\n         \"foo\", INLINE_BLOCK);\n       final String code,\n       final String fnName,\n       final InliningMode mode,\n-      boolean allowDecomposition\n-      ) {\n+      boolean allowDecomposition) {\n     final Compiler compiler = new Compiler();\n     final FunctionInjector injector = new FunctionInjector(\n-        compiler, compiler.getUniqueNameIdSupplier(), allowDecomposition);\n+        compiler, compiler.getUniqueNameIdSupplier(), allowDecomposition,\n+        assumeStrictThis);\n     final Node tree = parse(compiler, code);\n \n     Node externsRoot = new Node(Token.EMPTY);\n       final boolean decompose) {\n     final Compiler compiler = new Compiler();\n     final FunctionInjector injector = new FunctionInjector(\n-        compiler, compiler.getUniqueNameIdSupplier(), decompose);\n+        compiler, compiler.getUniqueNameIdSupplier(), decompose,\n+        assumeStrictThis);\n \n     JSSourceFile[] externsInputs = new JSSourceFile[] {\n         JSSourceFile.fromCode(\"externs\", \"\")\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n   final boolean allowExpressionDecomposition = true;\n   final boolean allowFunctionExpressionInlining = true;\n   final boolean allowLocalFunctionInlining = true;\n+  boolean assumeStrictThis = true;\n \n   public InlineFunctionsTest() {\n     this.enableNormalize();\n     super.enableLineNumberCheck(true);\n     allowGlobalFunctionInlining = true;\n     allowBlockInlining = true;\n+    assumeStrictThis = true;\n   }\n \n   @Override\n         compiler.getUniqueNameIdSupplier(),\n         allowGlobalFunctionInlining,\n         allowLocalFunctionInlining,\n-        allowBlockInlining);\n+        allowBlockInlining,\n+        assumeStrictThis);\n   }\n \n   /**\n          \"(function(){ return 1 })();\");\n   }\n \n+  public void testInlineWithThis1() {\n+    assumeStrictThis = false;\n+    // If no \"this\" is provided it might need to be coerced to the global\n+    // \"this\".\n+    testSame(\"function f(){} f.call();\");\n+    testSame(\"function f(){this} f.call();\");\n+\n+    assumeStrictThis = true;\n+    // In strict mode, \"this\" is never coerced so we can use the provided value.\n+    test(\"function f(){} f.call();\", \"{}\");\n+    test(\"function f(){this} f.call();\",\n+         \"{void 0;}\");\n+  }\n+\n+  public void testInlineWithThis2() {\n+    // \"this\" can always be replaced with \"this\"\n+    assumeStrictThis = false;\n+    test(\"function f(){} f.call(this);\", \"void 0\");\n+\n+    assumeStrictThis = true;\n+    test(\"function f(){} f.call(this);\", \"void 0\");\n+  }\n+\n+  public void testInlineWithThis3() {\n+    assumeStrictThis = false;\n+    // If no \"this\" is provided it might need to be coerced to the global\n+    // \"this\".\n+    testSame(\"function f(){} f.call([]);\");\n+\n+    assumeStrictThis = true;\n+    // In strict mode, \"this\" is never coerced so we can use the provided value.\n+    test(\"function f(){} f.call([]);\", \"{}\");\n+  }\n+\n+  public void testInlineWithThis4() {\n+    assumeStrictThis = false;\n+    // If no \"this\" is provided it might need to be coerced to the global\n+    // \"this\".\n+    testSame(\"function f(){} f.call(new g);\");\n+\n+    assumeStrictThis = true;\n+    // In strict mode, \"this\" is never coerced so we can use the provided value.\n+    test(\"function f(){} f.call(new g);\",\n+         \"{var JSCompiler_inline_this_0=new g}\");\n+  }\n+\n+  public void testInlineWithThis5() {\n+    assumeStrictThis = false;\n+    // If no \"this\" is provided it might need to be coerced to the global\n+    // \"this\".\n+    testSame(\"function f(){} f.call(g());\");\n+\n+    assumeStrictThis = true;\n+    // In strict mode, \"this\" is never coerced so we can use the provided value.\n+    test(\"function f(){} f.call(g());\",\n+         \"{var JSCompiler_inline_this_0=g()}\");\n+  }\n+\n+  public void testInlineWithThis6() {\n+    assumeStrictThis = false;\n+    // If no \"this\" is provided it might need to be coerced to the global\n+    // \"this\".\n+    testSame(\"function f(){this} f.call(new g);\");\n+\n+    assumeStrictThis = true;\n+    // In strict mode, \"this\" is never coerced so we can use the provided value.\n+    test(\"function f(){this} f.call(new g);\",\n+         \"{var JSCompiler_inline_this_0=new g;JSCompiler_inline_this_0}\");\n+  }\n+\n+  public void testInlineWithThis7() {\n+    assumeStrictThis = true;\n+    // In strict mode, \"this\" is never coerced so we can use the provided value.\n+    test(\"function f(a){a=1;this} f.call();\",\n+         \"{var a$$inline_1=void 0; a$$inline_1=1; void 0;}\");\n+    test(\"function f(a){a=1;this} f.call(x, x);\",\n+         \"{var a$$inline_1=x; a$$inline_1=1; x;}\");\n+  }\n+\n   // http://en.wikipedia.org/wiki/Fixed_point_combinator#Y_combinator\n   public void testFunctionExpressionYCombinator() {\n     testSame(\n--- a/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n+++ b/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new InlineFunctions(compiler,\n-          compiler.getUniqueNameIdSupplier(), true, false, true);\n+          compiler.getUniqueNameIdSupplier(), true, false, true, true);\n     }\n   };\n ", "timestamp": 1307465381, "metainfo": ""}