{"sha": "31e978ee1763bb13fc4046fe9821763019422de9", "log": "Create a way to do full lookups in the css rewrite map, and sync up ReplaceCssNames with goog.getCssName. Contributed by Ilia Mirkin.  Revision created by MOE tool push_codebase.  R=acleung DELTA=294  (225 added, 19 deleted, 50 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=428   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CssRenamingMap.java\n+++ b/src/com/google/javascript/jscomp/CssRenamingMap.java\n \n   String get(String value);\n \n-  // TODO(nicksantos): Uncomment this once all renaming maps implement\n-  // this method.\n-  //Style getStyle();\n+  Style getStyle();\n \n   public static abstract class ByPart implements CssRenamingMap {\n     abstract public String get(String value);\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n       \"JSC_NULL_ARGUMENT_ERROR\",\n       \"method \\\"{0}\\\" called without an argument\");\n \n+  static final DiagnosticType EXPECTED_OBJECTLIT_ERROR = DiagnosticType.error(\n+      \"JSC_EXPECTED_OBJECTLIT_ERROR\",\n+      \"method \\\"{0}\\\" expected an object literal argument\");\n+\n+  static final DiagnosticType EXPECTED_STRING_ERROR = DiagnosticType.error(\n+      \"JSC_EXPECTED_STRING_ERROR\",\n+      \"method \\\"{0}\\\" expected an object string argument\");\n+\n   static final DiagnosticType INVALID_ARGUMENT_ERROR = DiagnosticType.error(\n       \"JSC_INVALID_ARGUMENT_ERROR\",\n-      \"method \\\"{0}\\\" called with a non-string argument\");\n+      \"method \\\"{0}\\\" called with invalid argument\");\n+\n+  static final DiagnosticType INVALID_STYLE_ERROR = DiagnosticType.error(\n+      \"JSC_INVALID_CSS_NAME_MAP_STYLE_ERROR\",\n+      \"Invalid CSS name map style {0}\");\n \n   static final DiagnosticType TOO_MANY_ARGUMENTS_ERROR = DiagnosticType.error(\n       \"JSC_TOO_MANY_ARGUMENTS_ERROR\",\n       DiagnosticType.error(\n           \"JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR\",\n       \"goog.setCssNameMapping only takes an object literal with string values\");\n+\n+  static final DiagnosticType INVALID_CSS_RENAMING_MAP = DiagnosticType.warning(\n+      \"INVALID_CSS_RENAMING_MAP\",\n+      \"Invalid entries in css renaming map: {0}\");\n \n   static final DiagnosticType BASE_CLASS_ERROR = DiagnosticType.error(\n       \"JSC_BASE_CLASS_ERROR\",\n   private void processSetCssNameMapping(NodeTraversal t, Node n, Node parent) {\n     Node left = n.getFirstChild();\n     Node arg = left.getNext();\n-    if (verifyArgument(t, left, arg, Token.OBJECTLIT)) {\n+    if (verifySetCssNameMapping(t, left, arg)) {\n       // Translate OBJECTLIT into SubstitutionMap. All keys and\n       // values must be strings, or an error will be thrown.\n       final Map<String, String> cssNames = Maps.newHashMap();\n-      JSError error = null;\n+\n       for (Node key = arg.getFirstChild(); key != null;\n           key = key.getNext()) {\n         Node value = key.getFirstChild();\n         if (key.getType() != Token.STRING\n             || value == null\n             || value.getType() != Token.STRING) {\n-          error = t.makeError(n,\n-              NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR);\n-        }\n-        if (error != null) {\n-          compiler.report(error);\n-          break;\n+          compiler.report(\n+              t.makeError(n,\n+                  NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR));\n+          return;\n         }\n         cssNames.put(key.getString(), value.getString());\n       }\n \n-      // If there were no errors, create a CssRenamingMap from cssNames, update\n-      // the compiler to use it and remove the call to goog.setCssNameMapping().\n-      if (error == null) {\n-        CssRenamingMap cssRenamingMap = new CssRenamingMap() {\n-          public String get(String value) {\n-            if (cssNames.containsKey(value)) {\n-              return cssNames.get(value);\n-            } else {\n-              return value;\n+      String styleStr = \"BY_PART\";\n+      if (arg.getNext() != null) {\n+        styleStr = arg.getNext().getString();\n+      }\n+\n+      final CssRenamingMap.Style style;\n+      try {\n+        style = CssRenamingMap.Style.valueOf(styleStr);\n+      } catch (IllegalArgumentException e) {\n+        compiler.report(\n+            t.makeError(n, INVALID_STYLE_ERROR, styleStr));\n+        return;\n+      }\n+\n+      if (style == CssRenamingMap.Style.BY_PART) {\n+        // Make sure that no keys contain -'s\n+        List<String> errors = Lists.newArrayList();\n+        for (String key : cssNames.keySet()) {\n+          if (key.contains(\"-\")) {\n+            errors.add(key);\n+          }\n+        }\n+        if (errors.size() != 0) {\n+          compiler.report(\n+            t.makeError(n, INVALID_CSS_RENAMING_MAP, errors.toString()));\n+        }\n+      } else if (style == CssRenamingMap.Style.BY_WHOLE) {\n+        // Verifying things is a lot trickier here. We just do a quick\n+        // n^2 check over the map which makes sure that if \"a-b\" in\n+        // the map, then map(a-b) = map(a)-map(b).\n+        // To speed things up, only consider cases where len(b) <= 10\n+        List<String> errors = Lists.newArrayList();\n+        for (Map.Entry<String, String> b : cssNames.entrySet()) {\n+          if (b.getKey().length() > 10) continue;\n+          for (Map.Entry<String, String> a : cssNames.entrySet()) {\n+            String combined = cssNames.get(a.getKey() + \"-\" + b.getKey());\n+            if (combined != null &&\n+                !combined.equals(a.getValue() + \"-\" + b.getValue())) {\n+              errors.add(\"map(\" + a.getKey() + \"-\" + b.getKey() +\") != map(\" +\n+                         a.getKey() + \")-map(\" + b.getKey() +\")\");\n             }\n           }\n-        };\n-        compiler.setCssRenamingMap(cssRenamingMap);\n-        parent.getParent().removeChild(parent);\n-        compiler.reportCodeChange();\n-      }\n-    }\n-  }\n+        }\n+        if (errors.size() != 0) {\n+          compiler.report(\n+            t.makeError(n, INVALID_CSS_RENAMING_MAP, errors.toString()));\n+        }\n+      }\n+\n+      CssRenamingMap cssRenamingMap = new CssRenamingMap() {\n+        public String get(String value) {\n+          return cssNames.get(value);\n+        }\n+\n+        public CssRenamingMap.Style getStyle() {\n+          return style;\n+        }\n+      };\n+      compiler.setCssRenamingMap(cssRenamingMap);\n+      parent.getParent().removeChild(parent);\n+      compiler.reportCodeChange();\n+    }\n+  }\n+\n \n   /**\n    * Try to simplify \"new Date(goog.now())\" to \"new Date()\".\n       diagnostic = INVALID_ARGUMENT_ERROR;\n     } else if (arg.getNext() != null) {\n       diagnostic = TOO_MANY_ARGUMENTS_ERROR;\n+    }\n+    if (diagnostic != null) {\n+      compiler.report(\n+          t.makeError(methodName,\n+              diagnostic, methodName.getQualifiedName()));\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Verifies that setCssNameMapping is called with the correct methods.\n+   *\n+   * @return Whether the arguments checked out okay\n+   */\n+  private boolean verifySetCssNameMapping(NodeTraversal t, Node methodName,\n+      Node firstArg) {\n+    DiagnosticType diagnostic = null;\n+    if (firstArg == null) {\n+      diagnostic = NULL_ARGUMENT_ERROR;\n+    } else if (firstArg.getType() != Token.OBJECTLIT) {\n+      diagnostic = EXPECTED_OBJECTLIT_ERROR;\n+    } else if (firstArg.getNext() != null) {\n+      Node secondArg = firstArg.getNext();\n+      if (secondArg.getType() != Token.STRING) {\n+        diagnostic = EXPECTED_STRING_ERROR;\n+      } else if (secondArg.getNext() != null) {\n+        diagnostic = TOO_MANY_ARGUMENTS_ERROR;\n+      }\n     }\n     if (diagnostic != null) {\n       compiler.report(\n--- a/src/com/google/javascript/jscomp/ReplaceCssNames.java\n+++ b/src/com/google/javascript/jscomp/ReplaceCssNames.java\n import javax.annotation.Nullable;\n \n /**\n- * ReplaceCssNames replaces occurrences of goog.getCssName('foo') with a shorter\n- * version from the passed in renaming map.\n+ * ReplaceCssNames replaces occurrences of goog.getCssName('foo') with\n+ * a shorter version from the passed in renaming map. There are two\n+ * styles of operation: for 'BY_WHOLE' we look up the whole string in the\n+ * renaming map. For 'BY_PART', all the class name's components,\n+ * separated by '-', are renamed individually and then recombined.\n  *\n  * Given the renaming map:\n  *   {\n- *     once:  a,\n- *     upon:  b,\n- *     atime: c,\n- *     long:  d,\n- *     time:  e\n- *     ago:   f\n+ *     once:  'a',\n+ *     upon:  'b',\n+ *     atime: 'c',\n+ *     long:  'd',\n+ *     time:  'e',\n+ *     ago:   'f'\n  *   }\n  *\n- * The following outputs are expected:\n+ * The following outputs are expected with the 'BY_PART' renaming style:\n  *\n  * goog.getCssName('once') -> 'a'\n  * goog.getCssName('once-upon-atime') -> 'a-b-c'\n  * ->\n  * var baseClass = 'd-e';\n  * el.className = baseClass + '-f';\n+ *\n+ * However if we have the following renaming map with the 'BY_WHOLE' renaming style:\n+ *   {\n+ *     once: 'a',\n+ *     upon-atime: 'b',\n+ *     long-time: 'c',\n+ *     ago: 'd'\n+ *   }\n+ *\n+ * Then we would expect:\n+ *\n+ * goog.getCssName('once') -> 'a'\n+ *\n+ * var baseClass = goog.getCssName('long-time');\n+ * el.className = goog.getCssName(baseClass, 'ago');\n+ * ->\n+ * var baseClass = 'c';\n+ * el.className = baseClass + '-d';\n  *\n  * In addition, the CSS names before replacement can optionally be gathered.\n  *\n      * @param n The string node to process.\n      */\n     private void processStringNode(NodeTraversal t, Node n) {\n-      if (symbolMap != null || cssNames != null) {\n-        String[] parts = n.getString().split(\"-\");\n+      String name = n.getString();\n+      String[] parts = name.split(\"-\");\n+      if (symbolMap != null) {\n+        String replacement = null;\n+        switch (symbolMap.getStyle()) {\n+          case BY_WHOLE:\n+            replacement = symbolMap.get(name);\n+            if (replacement == null) {\n+              compiler.report(\n+                  t.makeError(n, UNKNOWN_SYMBOL_WARNING, name, name));\n+              return;\n+            }\n+            break;\n+          case BY_PART:\n+            String[] replaced = new String[parts.length];\n+            for (int i = 0; i < parts.length; i++) {\n+              String part = symbolMap.get(parts[i]);\n+              if (part == null) {\n+                // If we can't encode all parts, don't encode any of it.\n+                compiler.report(\n+                    t.makeError(n, UNKNOWN_SYMBOL_WARNING, parts[i], name));\n+                return;\n+              }\n+              replaced[i] = part;\n+            }\n+            replacement = Joiner.on(\"-\").join(replaced);\n+            break;\n+          default:\n+            throw new IllegalStateException(\n+              \"Unknown replacement style: \" + symbolMap.getStyle());\n+        }\n+        n.setString(replacement);\n+      }\n+      if (cssNames != null) {\n+        // We still want to collect statistics even if we've already\n+        // done the full replace. The statistics are collected on a\n+        // per-part basis.\n         for (int i = 0; i < parts.length; i++) {\n-          if (cssNames != null) {\n-            Integer count = cssNames.get(parts[i]);\n-            if (count == null) {\n-              count = Integer.valueOf(0);\n-            }\n-            cssNames.put(parts[i], count.intValue() + 1);\n+          Integer count = cssNames.get(parts[i]);\n+          if (count == null) {\n+            count = Integer.valueOf(0);\n           }\n-          if (symbolMap != null) {\n-            String replacement = symbolMap.get(parts[i]);\n-            if (replacement == null) {\n-              // If we can't encode all parts, don't encode any of it.\n-              compiler.report(t.makeError(\n-                  n, UNKNOWN_SYMBOL_WARNING, parts[i], n.getString()));\n-              return;\n-            }\n-            parts[i] = replacement;\n-          }\n-        }\n-        if (symbolMap != null) {\n-          n.setString(Joiner.on(\"-\").join(parts));\n+          cssNames.put(parts[i], count.intValue() + 1);\n         }\n       }\n     }\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n import com.google.javascript.jscomp.CheckLevel;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.BASE_CLASS_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.DUPLICATE_NAMESPACE_ERROR;\n+import static com.google.javascript.jscomp.ProcessClosurePrimitives.EXPECTED_OBJECTLIT_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.FUNCTION_NAMESPACE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_ARGUMENT_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_PROVIDE_ERROR;\n+import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_STYLE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.LATE_PROVIDE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.MISSING_PROVIDE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.NULL_ARGUMENT_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.TOO_MANY_ARGUMENTS_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.XMODULE_REQUIRE_ERROR;\n+import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_CSS_RENAMING_MAP;\n \n /**\n  * Tests for {@link ProcessClosurePrimitives}.\n     assertEquals(\"baz\", map.get(\"biz\"));\n   }\n \n+  public void testValidSetCssNameMappingWithType() {\n+    test(\"goog.setCssNameMapping({foo:'bar',\\\"biz\\\":'baz'}, 'BY_PART');\", \"\");\n+    CssRenamingMap map = getLastCompiler().getCssRenamingMap();\n+    assertNotNull(map);\n+    assertEquals(\"bar\", map.get(\"foo\"));\n+    assertEquals(\"baz\", map.get(\"biz\"));\n+\n+    test(\"goog.setCssNameMapping({foo:'bar',biz:'baz','biz-foo':'baz-bar'},\" +\n+        \" 'BY_WHOLE');\", \"\");\n+    map = getLastCompiler().getCssRenamingMap();\n+    assertNotNull(map);\n+    assertEquals(\"bar\", map.get(\"foo\"));\n+    assertEquals(\"baz\", map.get(\"biz\"));\n+    assertEquals(\"baz-bar\", map.get(\"biz-foo\"));\n+  }\n+\n   public void testSetCssNameMappingNonStringValueReturnsError() {\n     // Make sure the argument is an object literal.\n     test(\"var BAR = {foo:'bar'}; goog.setCssNameMapping(BAR);\", \"\",\n-        INVALID_ARGUMENT_ERROR);\n+        EXPECTED_OBJECTLIT_ERROR);\n     test(\"goog.setCssNameMapping([]);\", \"\",\n-        INVALID_ARGUMENT_ERROR);\n+        EXPECTED_OBJECTLIT_ERROR);\n     test(\"goog.setCssNameMapping(false);\", \"\",\n-        INVALID_ARGUMENT_ERROR);\n+        EXPECTED_OBJECTLIT_ERROR);\n     test(\"goog.setCssNameMapping(null);\", \"\",\n-        INVALID_ARGUMENT_ERROR);\n+        EXPECTED_OBJECTLIT_ERROR);\n     test(\"goog.setCssNameMapping(undefined);\", \"\",\n-        INVALID_ARGUMENT_ERROR);\n+        EXPECTED_OBJECTLIT_ERROR);\n \n     // Make sure all values of the object literal are string literals.\n     test(\"var BAR = 'bar'; goog.setCssNameMapping({foo:BAR});\", \"\",\n         NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR);\n     test(\"goog.setCssNameMapping({foo:undefined});\", \"\",\n         NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR);\n+  }\n+\n+  public void testSetCssNameMappingValidity() {\n+    // Make sure that the keys don't have -'s\n+    test(\"goog.setCssNameMapping({'a': 'b', 'a-a': 'c'})\", \"\", null,\n+        INVALID_CSS_RENAMING_MAP);\n+\n+    // In full mode, we check that map(a-b)=map(a)-map(b)\n+    test(\"goog.setCssNameMapping({'a': 'b', 'a-a': 'c'}, 'BY_WHOLE')\", \"\", null,\n+        INVALID_CSS_RENAMING_MAP);\n+\n+    // Unknown mapping type\n+    test(\"goog.setCssNameMapping({foo:'bar'}, 'UNKNOWN');\", \"\",\n+        INVALID_STYLE_ERROR);\n   }\n \n   public void testBadCrossModuleRequire() {\n--- a/test/com/google/javascript/jscomp/ReplaceCssNamesTest.java\n+++ b/test/com/google/javascript/jscomp/ReplaceCssNamesTest.java\n       .put(\"elephant\", \"e\")\n       .put(\"footer\", \"f\")\n       .put(\"goog\", \"g\")\n+    .build();\n+\n+  Map<String, String> replacementMapFull =\n+      new ImmutableMap.Builder<String, String>()\n+      .put(\"long-prefix\", \"h\")\n+      .put(\"suffix1\", \"i\")\n+      .put(\"unrelated-word\", \"k\")\n+      .put(\"unrelated\", \"l\")\n+      .put(\"long-suffix\", \"m\")\n+      .put(\"long-prefix-suffix1\", \"h-i\")\n       .build();\n+\n+  CssRenamingMap renamingMap;\n \n   Map<String, Integer> cssNames;\n \n     return new ReplaceCssNames(compiler, cssNames) {\n       @Override\n       protected CssRenamingMap getCssRenamingMap() {\n-        return useReplacementMap ?\n-          new CssRenamingMap() {\n-            @Override public String get(String value) {\n-              return replacementMap.get(value);\n-            }\n-          } : null;\n+        return useReplacementMap ? renamingMap : null;\n+      }\n+    };\n+  }\n+\n+  protected CssRenamingMap getPartialMap() {\n+    CssRenamingMap map = new CssRenamingMap.ByPart() {\n+      @Override public String get(String value) {\n+        return replacementMap.get(value);\n+      }\n+    };\n+    return map;\n+  }\n+\n+  protected CssRenamingMap getFullMap() {\n+    return new CssRenamingMap.ByWhole() {\n+      @Override public String get(String value) {\n+        return replacementMapFull.get(value);\n       }\n     };\n   }\n     super.enableLineNumberCheck(true);\n     cssNames = Maps.newHashMap();\n     useReplacementMap = true;\n+    renamingMap = getPartialMap();\n   }\n \n   @Override\n     assertEquals(expected, cssNames);\n   }\n \n+  public void testOneArgWithCompositeClassNamesFull() {\n+    renamingMap = getFullMap();\n+\n+    test(\"var x = goog.getCssName('long-prefix')\",\n+         \"var x = 'h'\");\n+    test(\"var x = goog.getCssName('long-prefix-suffix1')\",\n+         \"var x = 'h-i'\");\n+    test(\"var x = goog.getCssName('unrelated')\",\n+         \"var x = 'l'\");\n+    test(\"var x = goog.getCssName('unrelated-word')\",\n+         \"var x = 'k'\");\n+  }\n+\n   public void testOneArgWithCompositeClassNamesWithUnknownParts() {\n     test(\"var x = goog.getCssName('goog-header-active')\",\n          \"var x = 'goog-header-active'\", null, UNKNOWN_SYMBOL_WARNING);\n          \"setClass(BASE_CLASS + '-d')\");\n   }\n \n+  public void testTwoArgsWithVariableFirstArgFull() {\n+    renamingMap = getFullMap();\n+\n+    test(\"var x = goog.getCssName(baseClass, 'long-suffix')\",\n+         \"var x = baseClass + '-m'\");\n+  }\n+\n   public void testZeroArguments() {\n     test(\"goog.getCssName()\", null,\n         ReplaceCssNames.INVALID_NUM_ARGUMENTS_ERROR);", "timestamp": 1296780076, "metainfo": ""}