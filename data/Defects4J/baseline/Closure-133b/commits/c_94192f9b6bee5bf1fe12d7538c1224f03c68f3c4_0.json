{"sha": "94192f9b6bee5bf1fe12d7538c1224f03c68f3c4", "log": "Automated g4 rollback.  *** Reason for rollback ***  breaks some optimizations  *** Original change description ***  The infimum() relation on enum types is deeply disturbing, because now you can have subsets of enums. wow.  DELTA=161  (4 added, 149 deleted, 8 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2615   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n     return primitiveType;\n   }\n \n-  /**\n-   * Returns the infimum of a enum element type and another type, or null\n-   * if the infimum is empty.\n-   *\n-   * This can be a little bit weird. For example, suppose you have an enum\n-   * of {(string|number)}, and you want the greatest subtype of the enum\n-   * and a {number}.\n-   *\n-   * The infimum is non-empty. But at the same time, we don't really have\n-   * a name for this infimum. It's equivalent to \"elements of this enum that\n-   * are numbers\".\n-   *\n-   * The best we can do is make up a new type. This is similar to what\n-   * we do in UnionType#meet, which kind-of-sort-of makes sense, because\n-   * an EnumElementType is a union of instances of a type.\n-   */\n-  JSType meet(JSType that) {\n-    JSType meetPrimitive = primitiveType.getGreatestSubtype(that);\n-    if (meetPrimitive.isEmptyType()) {\n-      return null;\n-    } else {\n-      return new EnumElementType(registry, meetPrimitive, name);\n-    }\n-  }\n-\n   @Override\n   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n     primitiveType = primitiveType.resolve(t, scope);\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n       return ((UnionType) thisType).meet(thatType);\n     } else if (thatType.isUnionType()) {\n       return ((UnionType) thatType).meet(thisType);\n-    }\n-\n-    if (thisType instanceof EnumElementType) {\n-      JSType inf = ((EnumElementType) thisType).meet(thatType);\n-      if (inf != null) {\n-        return inf;\n-      }\n-    } else if (thatType instanceof EnumElementType) {\n-      JSType inf = ((EnumElementType) thatType).meet(thisType);\n-      if (inf != null) {\n-        return inf;\n-      }\n-    }\n-\n-    if (thisType.isObject() && thatType.isObject()) {\n+    } else if (thisType.isObject() && thatType.isObject()) {\n       return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     }\n     return thisType.getNativeType(JSTypeNative.NO_TYPE);\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n     }\n \n     // other prototype based objects\n-    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n-      // If unsure, say 'yes', to avoid spurious warnings.\n-      // TODO(user): resolve the prototype chain completely in all cases,\n-      // to avoid guessing.\n-      return true;\n-    }\n-    return this.isImplicitPrototype(thatObj);\n+    if (that != null) {\n+      if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n+        // If unsure, say 'yes', to avoid spurious warnings.\n+        // TODO(user): resolve the prototype chain completely in all cases,\n+        // to avoid guessing.\n+        return true;\n+      }\n+      return this.isImplicitPrototype(thatObj);\n+    }\n+\n+    return false;\n   }\n \n   private boolean implicitPrototypeChainIsUnknown() {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"inconsistent return type\\n\" +\n         \"found   : MyEnum.<number>\\n\" +\n         \"required: string\");\n-  }\n-\n-  public void testEnum42() throws Exception {\n-    testTypes(\n-        \"/** @param {number} x */ function f(x) {}\" +\n-        \"/** @enum {Object} */ var MyEnum = {FOO: {newProperty: 1, b: 2}};\" +\n-        \"f(MyEnum.FOO.newProperty);\");\n   }\n \n   public void testAliasedEnum1() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     verifySubtypeChain(typeChain);\n   }\n \n-  public void testAnonymousObjectChain() throws Exception {\n-    List<JSType> typeChain = Lists.newArrayList(\n-        ALL_TYPE,\n-        createNullableType(OBJECT_TYPE),\n-        OBJECT_TYPE,\n-        registry.createAnonymousObjectType(),\n-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n-        registry.getNativeType(JSTypeNative.NO_TYPE));\n-    verifySubtypeChain(typeChain);\n-  }\n-\n-  public void testAnonymousEnumElementChain() throws Exception {\n-    ObjectType enumElemType = registry.createEnumType(\n-        \"typeB\", registry.createAnonymousObjectType()).getElementsType();\n-    List<JSType> typeChain = Lists.newArrayList(\n-        ALL_TYPE,\n-        createNullableType(OBJECT_TYPE),\n-        OBJECT_TYPE,\n-        enumElemType,\n-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n-        registry.getNativeType(JSTypeNative.NO_TYPE));\n-    verifySubtypeChain(typeChain);\n-  }\n-\n   /**\n    * Tests that the given chain of types has a total ordering defined\n    * by the subtype relationship, with types at the top of the lattice", "timestamp": 1311010876, "metainfo": ""}