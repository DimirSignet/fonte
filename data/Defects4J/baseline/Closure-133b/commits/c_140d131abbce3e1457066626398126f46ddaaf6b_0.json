{"sha": "140d131abbce3e1457066626398126f46ddaaf6b", "log": "Change on 2010/05/14 by alan          Missed opportunities in CrossModuleMethodMotion.          R=nick         DELTA=91  (58 added, 6 deleted, 27 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=4   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n-import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n       new LinkedDirectedGraph<NameInfo, JSModule>();\n \n   // A dummy node for representing global references.\n-  private final NameInfo globalNode = new NameInfo(null);\n+  private final NameInfo globalNode = new NameInfo(\"[global]\");\n \n   // A dummy node for representing extern references.\n-  private final NameInfo externNode = new NameInfo(null);\n+  private final NameInfo externNode = new NameInfo(\"[extern]\");\n+\n+  // A dummy node for representing all anonymous functions with no names.\n+  private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\");\n \n   // All the real NameInfo for prototype properties, hashed by the name\n   // of the property that they represent.\n     }\n   }\n \n-  private class ProcessProperties implements NodeTraversal.Callback {\n-    private Stack<NameInfo> symbolStack = new Stack<NameInfo>();\n+  private class ProcessProperties implements NodeTraversal.ScopedCallback {\n+    private Stack<NameContext> symbolStack = new Stack<NameContext>();\n+\n+    private ProcessProperties() {\n+      symbolStack.push(new NameContext(globalNode));\n+    }\n+\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      symbolStack.peek().scope = t.getScope();\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {\n+\n+    }\n \n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(getNameInfoForName(\n-                n.getFirstChild().getLastChild().getString(), PROPERTY));\n-      } else if (isGlobalFunctionDeclaration(t, n, parent)) {\n+        symbolStack.push(new NameContext(getNameInfoForName(\n+                n.getFirstChild().getLastChild().getString(), PROPERTY)));\n+      } else if (isGlobalFunctionDeclaration(t, n)) {\n         String name = parent.getType() == Token.NAME ?\n             parent.getString() /* VAR */ :\n             n.getFirstChild().getString() /* named function */;\n-        symbolStack.push(getNameInfoForName(name, VAR));\n+        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n+      } else if (NodeUtil.isFunction(n)) {\n+        symbolStack.push(new NameContext(anonymousNode));\n       }\n       return true;\n     }\n           // If it is not a global, it might be accessing a local of the outer\n           // scope. If that's the case the functions between the variable's\n           // declaring scope and the variable reference scope cannot be moved.\n-          } else {\n-            int level = 0;\n-            for (Scope s = t.getScope(); s != var.getScope();\n-                s = s.getParent()) {\n-              level++;\n-            }\n-            for (level = symbolStack.size() < level ?\n-                symbolStack.size() : level; level != 0; level--) {\n-              symbolStack.get(symbolStack.size() - level)\n-                  .readClosureVariables = true;\n+          } else if (var.getScope() != t.getScope()){\n+            for (int i = symbolStack.size() - 1; i >= 0; i--) {\n+              NameContext context = symbolStack.get(i);\n+              context.name.readClosureVariables = true;\n+              if (context.scope == var.getScope()) {\n+                break;\n+              }\n             }\n           }\n         }\n       }\n \n       if (isPrototypePropertyAssign(n) ||\n-          isGlobalFunctionDeclaration(t, n, parent)) {\n+          isGlobalFunctionDeclaration(t, n) ||\n+          NodeUtil.isFunction(n)) {\n         symbolStack.pop();\n       }\n     }\n \n     private void addSymbolUse(String name, JSModule module, SymbolType type) {\n-      if (symbolStack.empty()) {\n-        addGlobalUseOfSymbol(name, module, type);\n-      } else {\n-        NameInfo info = getNameInfoForName(name, type);\n-        if (!symbolStack.peek().equals(info)) {\n-          symbolGraph.connect(symbolStack.peek(), module, info);\n-        }\n+      NameInfo info = getNameInfoForName(name, type);\n+      NameInfo def = null;\n+      // Skip all anonymous nodes. We care only about symbols with names.\n+      for (int i = symbolStack.size() - 1; i >= 0; i--) {\n+        def = symbolStack.get(i).name;\n+        if (def != anonymousNode) {\n+          break;\n+        }\n+      }\n+      if (!def.equals(info)) {\n+        symbolGraph.connect(def, module, info);\n       }\n     }\n \n      * Determines whether {@code n} is the FUNCTION node in a global function\n      * declaration.\n      */\n-    private boolean isGlobalFunctionDeclaration(NodeTraversal t,\n-        Node n, Node parent) {\n+    private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n       return t.inGlobalScope() &&\n           (NodeUtil.isFunctionDeclaration(n) ||\n-           n.getType() == Token.FUNCTION && parent.getType() == Token.NAME);\n+           n.getType() == Token.FUNCTION &&\n+           n.getParent().getType() == Token.NAME);\n     }\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node firstChild = nameNode.getFirstChild();\n \n       if (// Check for a named FUNCTION.\n-          isGlobalFunctionDeclaration(t, parent, gramps) ||\n+          isGlobalFunctionDeclaration(t, parent) ||\n           // Check for a VAR declaration.\n           firstChild != null &&\n-          isGlobalFunctionDeclaration(t, firstChild, nameNode)) {\n+          isGlobalFunctionDeclaration(t, firstChild)) {\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(\n             new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n   }\n \n   /**\n+   * The context of the current name. This includes the NameInfo and the scope\n+   * if it is a scope defining name (function).\n+   */\n+  private class NameContext {\n+    final NameInfo name;\n+    Scope scope;\n+    NameContext(NameInfo name) {\n+      this.name = name;\n+    }\n+  }\n+\n+  /**\n    * Information on all properties or global variables of a given name.\n    */\n   class NameInfo {\n--- a/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n            \"var y = new Foo(); y.baz();\"\n         });\n   }\n+  \n+  // An anonymous inner function reading a closure variable is fine.\n+  public void testInnerFunctionClosureVariableReads() {\n+    test(createModuleChain(\n+            \"function Foo() {}\" +\n+            \"Foo.prototype.baz = function(){var x = 1;\" +\n+            \"  return function(){x}};\",\n+            // Module 2\n+            \"var y = new Foo(); y.baz();\"),\n+         new String[] {\n+           STUB_DECLARATIONS +\n+           \"function Foo() {}\" +\n+           \"Foo.prototype.baz = JSCompiler_stubMethod(0);\",\n+           // Module 2\n+           \"Foo.prototype.baz = JSCompiler_unstubMethod(\" +\n+           \"    0, function(){var x = 1; return function(){x}});\" +\n+           \"var y = new Foo(); y.baz();\"\n+        });\n+  }\n+  \n }", "timestamp": 1273852542, "metainfo": ""}