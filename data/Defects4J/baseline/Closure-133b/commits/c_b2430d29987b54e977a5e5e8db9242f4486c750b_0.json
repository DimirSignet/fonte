{"sha": "b2430d29987b54e977a5e5e8db9242f4486c750b", "log": "Proposal: change how we represent property sets on objects. I went down this rabbit-hole to experiment with a few different things: - Separating property bookkeeping from type relation bookkeeping. - Use the same property-store for \"new Foo()\" and \"Foo.prototype\". I don't think that maintaining separate property maps for these two types actually buys us anything, and it's inconsistent with how they're used in practice. - Use the same property-store for \"Foo.<Bar>\" and \"Foo.<Baz>\" I actually like how this ended up--it's a lot easier to see how properties are inherited. But I'm curious what others think.  R=johnlenz,dimvar DELTA=507  (347 added, 143 deleted, 17 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5910   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       String functionName, HashMap<String, ObjectType> properties,\n       HashMap<String, ObjectType> currentProperties,\n       ObjectType interfaceType) {\n-    Set<String> currentPropertyNames = interfaceType.getPropertyNames();\n+    Set<String> currentPropertyNames =\n+        interfaceType.getImplicitPrototype().getOwnPropertyNames();\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.Property;\n \n import java.util.Iterator;\n import java.util.List;\n         Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n       // Declare var.prototype in the scope chain.\n       FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-      ObjectType.Property prototypeSlot = fnType.getSlot(\"prototype\");\n+      Property prototypeSlot = fnType.getSlot(\"prototype\");\n \n       // When we declare the function prototype implicitly, we\n       // want to make sure that the function and its prototype\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.jstype.StaticReference;\n import com.google.javascript.rhino.jstype.StaticSlot;\n \n-import java.io.Serializable;\n import java.util.Set;\n \n /**\n   @Override\n   public ObjectType getParentScope() {\n     return getImplicitPrototype();\n+  }\n+\n+  /**\n+   * Returns the property map that manages the set of properties for an object.\n+   */\n+  PropertyMap getPropertyMap() {\n+    return null;\n   }\n \n   @Override\n   public Iterable<ObjectType> getCtorExtendedInterfaces() {\n     return ImmutableSet.of();\n   }\n-\n-  public static final class Property\n-      implements Serializable, StaticSlot<JSType>, StaticReference<JSType> {\n-    private static final long serialVersionUID = 1L;\n-\n-    /**\n-     * Property's name.\n-     */\n-    private final String name;\n-\n-    /**\n-     * Property's type.\n-     */\n-    private JSType type;\n-\n-    /**\n-     * Whether the property's type is inferred.\n-     */\n-    private final boolean inferred;\n-\n-    /**\n-     * The node corresponding to this property, e.g., a GETPROP node that\n-     * declares this property.\n-     */\n-    private Node propertyNode;\n-\n-    /**  The JSDocInfo for this property. */\n-    private JSDocInfo docInfo = null;\n-\n-    Property(String name, JSType type, boolean inferred,\n-        Node propertyNode) {\n-      this.name = name;\n-      this.type = type;\n-      this.inferred = inferred;\n-      this.propertyNode = propertyNode;\n-    }\n-\n-    @Override\n-    public String getName() {\n-      return name;\n-    }\n-\n-    @Override\n-    public Node getNode() {\n-      return propertyNode;\n-    }\n-\n-    @Override\n-    public StaticSourceFile getSourceFile() {\n-      return propertyNode == null ? null : propertyNode.getStaticSourceFile();\n-    }\n-\n-    @Override\n-    public Property getSymbol() {\n-      return this;\n-    }\n-\n-    @Override\n-    public Property getDeclaration() {\n-      return propertyNode == null ? null : this;\n-    }\n-\n-    @Override\n-    public JSType getType() {\n-      return type;\n-    }\n-\n-    @Override\n-    public boolean isTypeInferred() {\n-      return inferred;\n-    }\n-\n-    boolean isFromExterns() {\n-      return propertyNode == null ? false : propertyNode.isFromExterns();\n-    }\n-\n-    void setType(JSType type) {\n-      this.type = type;\n-    }\n-\n-    @Override public JSDocInfo getJSDocInfo() {\n-      return this.docInfo;\n-    }\n-\n-    void setJSDocInfo(JSDocInfo info) {\n-      this.docInfo = info;\n-    }\n-\n-    public void setNode(Node n) {\n-      this.propertyNode = n;\n-    }\n-  }\n }\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/Property.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * A property slot of an object.\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public final class Property\n+    implements Serializable, StaticSlot<JSType>, StaticReference<JSType> {\n+  private static final long serialVersionUID = 1L;\n+\n+  /**\n+   * Property's name.\n+   */\n+  private final String name;\n+\n+  /**\n+   * Property's type.\n+   */\n+  private JSType type;\n+\n+  /**\n+   * Whether the property's type is inferred.\n+   */\n+  private final boolean inferred;\n+\n+  /**\n+   * The node corresponding to this property, e.g., a GETPROP node that\n+   * declares this property.\n+   */\n+  private Node propertyNode;\n+\n+  /**  The JSDocInfo for this property. */\n+  private JSDocInfo docInfo = null;\n+\n+  Property(String name, JSType type, boolean inferred,\n+      Node propertyNode) {\n+    this.name = name;\n+    this.type = type;\n+    this.inferred = inferred;\n+    this.propertyNode = propertyNode;\n+  }\n+\n+  @Override\n+      public String getName() {\n+    return name;\n+  }\n+\n+  @Override\n+      public Node getNode() {\n+    return propertyNode;\n+  }\n+\n+  @Override\n+      public StaticSourceFile getSourceFile() {\n+    return propertyNode == null ? null : propertyNode.getStaticSourceFile();\n+  }\n+\n+  @Override\n+      public Property getSymbol() {\n+    return this;\n+  }\n+\n+  @Override\n+      public Property getDeclaration() {\n+    return propertyNode == null ? null : this;\n+  }\n+\n+  @Override\n+      public JSType getType() {\n+    return type;\n+  }\n+\n+  @Override\n+      public boolean isTypeInferred() {\n+    return inferred;\n+  }\n+\n+  boolean isFromExterns() {\n+    return propertyNode == null ? false : propertyNode.isFromExterns();\n+  }\n+\n+  void setType(JSType type) {\n+    this.type = type;\n+  }\n+\n+  @Override public JSDocInfo getJSDocInfo() {\n+    return this.docInfo;\n+  }\n+\n+  void setJSDocInfo(JSDocInfo info) {\n+    this.docInfo = info;\n+  }\n+\n+  public void setNode(Node n) {\n+    this.propertyNode = n;\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/PropertyMap.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.common.base.Function;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Representation for a collection of properties on an object.\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+class PropertyMap implements Serializable {\n+  private static final Function<ObjectType, PropertyMap> PROP_MAP_FROM_TYPE =\n+      new Function<ObjectType, PropertyMap>() {\n+    @Override public PropertyMap apply(ObjectType t) {\n+      return t.getPropertyMap();\n+    }\n+  };\n+\n+  // A place to get the inheritance structure.\n+  // Because the extended interfaces are resolved dynamically, this gets\n+  // messy :(. If type-resolution was more well-defined, we could\n+  // just reference primary parents and secondary parents directly.\n+  private ObjectType parentSource = null;\n+\n+  // The map of our own properties.\n+  private final Map<String, Property> properties;\n+\n+  PropertyMap() {\n+    this.properties = Maps.newTreeMap();\n+  }\n+\n+  void setParentSource(ObjectType ownerType) {\n+    this.parentSource = ownerType;\n+  }\n+\n+  /** Returns the direct parent of this property map. */\n+  PropertyMap getPrimaryParent() {\n+    ObjectType iProto = parentSource.getImplicitPrototype();\n+    return iProto == null ? null : iProto.getPropertyMap();\n+  }\n+\n+  /**\n+   * Returns the secondary parents of this property map, for interfaces that\n+   * need multiple inheritance.\n+   */\n+  Iterable<PropertyMap> getSecondaryParents() {\n+    Iterable<ObjectType> extendedInterfaces =\n+        parentSource.getCtorExtendedInterfaces();\n+\n+    // Most of the time, this will be empty.\n+    if (Iterables.isEmpty(extendedInterfaces)) {\n+      return ImmutableList.of();\n+    }\n+\n+    return Iterables.transform(extendedInterfaces, PROP_MAP_FROM_TYPE);\n+  }\n+\n+  Property getSlot(String name) {\n+    if (properties.containsKey(name)) {\n+      return properties.get(name);\n+    }\n+    PropertyMap primaryParent = getPrimaryParent();\n+    if (primaryParent != null) {\n+      Property prop = primaryParent.getSlot(name);\n+      if (prop != null) {\n+        return prop;\n+      }\n+    }\n+    for (PropertyMap p : getSecondaryParents()) {\n+      if (p != null) {\n+        Property prop = p.getSlot(name);\n+        if (prop != null) {\n+          return prop;\n+        }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  Property getOwnProperty(String propertyName) {\n+    return properties.get(propertyName);\n+  }\n+\n+  int getPropertiesCount() {\n+    PropertyMap primaryParent = getPrimaryParent();\n+    if (primaryParent == null) {\n+      return this.properties.size();\n+    }\n+    Set<String> props = Sets.newHashSet();\n+    collectPropertyNames(props);\n+    return props.size();\n+  }\n+\n+  boolean hasOwnProperty(String propertyName) {\n+    return properties.get(propertyName) != null;\n+  }\n+\n+  boolean hasProperty(String propertyName) {\n+    return getSlot(propertyName) != null;\n+  }\n+\n+  Set<String> getOwnPropertyNames() {\n+    return properties.keySet();\n+  }\n+\n+  void collectPropertyNames(Set<String> props) {\n+    for (String prop : properties.keySet()) {\n+      props.add(prop);\n+    }\n+    PropertyMap primaryParent = getPrimaryParent();\n+    if (primaryParent != null) {\n+      primaryParent.collectPropertyNames(props);\n+    }\n+    for (PropertyMap p : getSecondaryParents()) {\n+      if (p != null) {\n+        p.collectPropertyNames(props);\n+      }\n+    }\n+  }\n+\n+  boolean removeProperty(String name) {\n+    return properties.remove(name) != null;\n+  }\n+\n+  void putProperty(String name, Property newProp) {\n+    Property oldProp = properties.get(name);\n+    if (oldProp != null) {\n+      // This is to keep previously inferred JsDoc info, e.g., in a\n+      // replaceScript scenario.\n+      newProp.setJSDocInfo(oldProp.getJSDocInfo());\n+    }\n+    properties.put(name, newProp);\n+  }\n+\n+  Iterable<Property> values() {\n+    return properties.values();\n+  }\n+}\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n package com.google.javascript.rhino.jstype;\n \n import static com.google.common.base.Preconditions.checkState;\n+\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n \n-import java.util.Map;\n import java.util.Set;\n \n /**\n   private static final long serialVersionUID = 1L;\n \n   private final String className;\n-  private final Map<String, Property> properties;\n+  private final PropertyMap properties;\n   private final boolean nativeType;\n \n   // NOTE(nicksantos): The implicit prototype can change over time.\n       ImmutableList<String> templateKeys,\n       ImmutableList<JSType> templatizedTypes) {\n     super(registry, templateKeys, templatizedTypes);\n-    this.properties = Maps.newTreeMap();\n+    this.properties = new PropertyMap();\n+    this.properties.setParentSource(this);\n+\n     this.className = className;\n     this.nativeType = nativeType;\n     if (nativeType || implicitPrototype != null) {\n   }\n \n   @Override\n+  PropertyMap getPropertyMap() {\n+    return properties;\n+  }\n+\n+  @Override\n   public Property getSlot(String name) {\n-    if (properties.containsKey(name)) {\n-      return properties.get(name);\n-    }\n-    ObjectType implicitPrototype = getImplicitPrototype();\n-    if (implicitPrototype != null) {\n-      Property prop = implicitPrototype.getSlot(name);\n-      if (prop != null) {\n-        return prop;\n-      }\n-    }\n-    for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n-      Property prop = interfaceType.getSlot(name);\n-      if (prop != null) {\n-        return prop;\n-      }\n-    }\n-    return null;\n+    return properties.getSlot(name);\n   }\n \n   /**\n    */\n   @Override\n   public int getPropertiesCount() {\n-    ObjectType implicitPrototype = getImplicitPrototype();\n-    if (implicitPrototype == null) {\n-      return this.properties.size();\n-    }\n-    int localCount = 0;\n-    for (String property : properties.keySet()) {\n-      if (!implicitPrototype.hasProperty(property)) {\n-        localCount++;\n-      }\n-    }\n-    return implicitPrototype.getPropertiesCount() + localCount;\n+    return properties.getPropertiesCount();\n   }\n \n   @Override\n \n   @Override\n   public boolean hasOwnProperty(String propertyName) {\n-    return properties.get(propertyName) != null;\n+    return properties.hasOwnProperty(propertyName);\n   }\n \n   @Override\n   public Set<String> getOwnPropertyNames() {\n-    return properties.keySet();\n+    return properties.getOwnPropertyNames();\n   }\n \n   @Override\n \n   @Override\n   void collectPropertyNames(Set<String> props) {\n-    for (String prop : properties.keySet()) {\n-      props.add(prop);\n-    }\n-    ObjectType implicitPrototype = getImplicitPrototype();\n-    if (implicitPrototype != null) {\n-      implicitPrototype.collectPropertyNames(props);\n-    }\n+    properties.collectPropertyNames(props);\n   }\n \n   @Override\n \n   @Override\n   public boolean isPropertyInExterns(String propertyName) {\n-    Property p = properties.get(propertyName);\n+    Property p = getSlot(propertyName);\n     if (p != null) {\n       return p.isFromExterns();\n-    }\n-    ObjectType implicitPrototype = getImplicitPrototype();\n-    if (implicitPrototype != null) {\n-      return implicitPrototype.isPropertyInExterns(propertyName);\n     }\n     return false;\n   }\n     }\n     Property newProp = new Property(\n         name, type, inferred, propertyNode);\n-    Property oldProp = properties.get(name);\n-    if (oldProp != null) {\n-      // This is to keep previously inferred JsDoc info, e.g., in a\n-      // replaceScript scenario.\n-      newProp.setJSDocInfo(oldProp.getJSDocInfo());\n-    }\n-    properties.put(name, newProp);\n+    properties.putProperty(name, newProp);\n     return true;\n   }\n \n   @Override\n   public boolean removeProperty(String name) {\n-    return properties.remove(name) != null;\n+    return properties.removeProperty(name);\n   }\n \n   @Override\n   public Node getPropertyNode(String propertyName) {\n-    Property p = properties.get(propertyName);\n+    Property p = getSlot(propertyName);\n     if (p != null) {\n       return p.getNode();\n     }\n-    ObjectType implicitPrototype = getImplicitPrototype();\n-    if (implicitPrototype != null) {\n-      return implicitPrototype.getPropertyNode(propertyName);\n-    }\n     return null;\n   }\n \n   @Override\n   public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n-    Property p = properties.get(propertyName);\n+    Property p = properties.getOwnProperty(propertyName);\n     if (p != null) {\n       return p.getJSDocInfo();\n     }\n   @Override\n   public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n     if (info != null) {\n-      if (!properties.containsKey(propertyName)) {\n+      if (properties.getOwnProperty(propertyName) == null) {\n         // If docInfo was attached, but the type of the property\n         // was not defined anywhere, then we consider this an explicit\n         // declaration of the property.\n \n       // The prototype property is not represented as a normal Property.\n       // We probably don't want to attach any JSDoc to it anyway.\n-      Property property = properties.get(propertyName);\n+      Property property = properties.getOwnProperty(propertyName);\n       if (property != null) {\n         property.setJSDocInfo(info);\n       }\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n+  PropertyMap getPropertyMap() {\n+    return referencedObjType == null\n+        ? null : referencedObjType.getPropertyMap();\n+  }\n+\n+  @Override\n   public Property getSlot(String name) {\n     if (referencedObjType != null) {\n       return referencedObjType.getSlot(name);\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n     assertTrue(ctor.isPropertyTypeInferred(\"prototype\"));\n     assertTrue(ctor.getPropertyType(\"prototype\").isUnknownType());\n \n-    // The node is not recorded.\n-    assertNull(ctor.getPropertyNode(\"prototype\"));\n+    assertEquals(node, ctor.getPropertyNode(\"prototype\"));\n   }\n \n   public void testEmptyFunctionTypes() {", "timestamp": 1354555814, "metainfo": ""}