{"sha": "aafd3788df73bd0d21c9411014a7cbda0a5bbd17", "log": "A bit of clean-up: rename GoogleCodeRemoval -> ClosureCodeRemoval fix warnings.  R=johnlenz DELTA=475  (236 added, 234 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=90005   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ClosureCodeRemoval.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.List;\n+\n+/**\n+ * <p>Compiler pass that removes Closure-specific code patterns.</p>\n+ *\n+ * <p>Currently does the following:</p>\n+ *\n+ * <ul>\n+ *   <li> Instead  of setting abstract methods to a function that throws an\n+ *        informative error, this pass allows some binary size reduction by\n+ *        removing these methods altogether for production builds.</li>\n+ * </ul>\n+ *\n+ * @author robbyw@google.com (Robby Walker)\n+ */\n+final class ClosureCodeRemoval implements CompilerPass {\n+\n+  /** Reference to the JS compiler */\n+  private final AbstractCompiler compiler;\n+\n+  /** Name used to denote an abstract function */\n+  static final String ABSTRACT_METHOD_NAME = \"goog.abstractMethod\";\n+\n+  /**\n+   * List of names referenced in successive generations of finding referenced\n+   * nodes\n+   */\n+  private final List<RemovableAssignment> abstractMethodAssignmentNodes =\n+      Lists.newArrayList();\n+\n+\n+  /**\n+   * Utility class to track a node and its parent.\n+   */\n+  private class RemovableAssignment {\n+    /**\n+     * The node\n+     */\n+    final Node node;\n+\n+    /**\n+     * Its parent\n+     */\n+    final Node parent;\n+\n+    /**\n+     * Full chain of ASSIGN ancestors\n+     */\n+    final List<Node> assignAncestors = Lists.newArrayList();\n+\n+    /**\n+     * The last ancestor\n+     */\n+    final Node lastAncestor;\n+\n+    /**\n+     * Data structure for information about a removable assignment.\n+     *\n+     * @param nameNode The LHS\n+     * @param assignNode The parent ASSIGN node\n+     * @param traversal Access to further levels, assumed to start at 1\n+     */\n+    public RemovableAssignment(Node nameNode, Node assignNode,\n+        NodeTraversal traversal) {\n+      this.node = nameNode;\n+      this.parent = assignNode;\n+\n+      Node ancestor = assignNode;\n+      do {\n+        ancestor = ancestor.getParent();\n+        assignAncestors.add(ancestor);\n+      } while (ancestor.getType() == Token.ASSIGN &&\n+               ancestor.getFirstChild().isQualifiedName());\n+      lastAncestor = ancestor.getParent();\n+    }\n+\n+    /**\n+     * Remove this node.\n+     */\n+    public void remove() {\n+      Node rhs = node.getNext();\n+      Node last = parent;\n+      for (Node ancestor : assignAncestors) {\n+        if (NodeUtil.isExpressionNode(ancestor)) {\n+          lastAncestor.removeChild(ancestor);\n+        } else {\n+          rhs.detachFromParent();\n+          ancestor.replaceChild(last, rhs);\n+        }\n+        last = ancestor;\n+      }\n+      compiler.reportCodeChange();\n+    }\n+  }\n+\n+\n+\n+  /**\n+   * Identifies all assignments of the abstract method to a variable.\n+   */\n+  private class FindAbstractMethods extends AbstractPostOrderCallback {\n+\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() == Token.ASSIGN) {\n+        Node nameNode = n.getFirstChild();\n+        Node valueNode = n.getLastChild();\n+\n+        if (nameNode.isQualifiedName() &&\n+            valueNode.isQualifiedName() &&\n+            ABSTRACT_METHOD_NAME.equals(valueNode.getQualifiedName())) {\n+          abstractMethodAssignmentNodes.add(new RemovableAssignment(\n+              n.getFirstChild(), n, t));\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /**\n+   * Creates a Closure code remover.\n+   *\n+   * @param compiler The AbstractCompiler\n+   */\n+  ClosureCodeRemoval(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new FindAbstractMethods());\n+\n+    for (RemovableAssignment assignment : abstractMethodAssignmentNodes) {\n+      assignment.remove();\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     // Abstract method removal works best on minimally modified code, and also\n     // only needs to run once.\n     if (options.closurePass && options.removeAbstractMethods) {\n-      passes.add(removeAbstractMethods);\n+      passes.add(closureCodeRemoval);\n     }\n \n     // Collapsing properties can undo constant inlining, so we do this before\n   };\n \n   /** Remove variables set to goog.abstractMethod. */\n-  private final PassFactory removeAbstractMethods =\n-      new PassFactory(\"removeAbstractMethods\", true) {\n+  private final PassFactory closureCodeRemoval =\n+      new PassFactory(\"closureCodeRemoval\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n-      return new GoogleCodeRemoval(compiler);\n+      return new ClosureCodeRemoval(compiler);\n     }\n   };\n \n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ClosureCodeRemovalTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Tests for {@link ClosureCodeRemoval}\n+ *\n+ * @author robbyw@google.com (Robby Walker)\n+ */\n+public class ClosureCodeRemovalTest extends CompilerTestCase {\n+\n+  private static String EXTERNS = \"var window;\";\n+\n+  public ClosureCodeRemovalTest() {\n+    super(EXTERNS);\n+  }\n+\n+  public void testRemoveAbstract() {\n+    test(\"function Foo() {}; Foo.prototype.doSomething = goog.abstractMethod;\",\n+        \"function Foo() {};\");\n+  }\n+\n+  public void testRemoveMultiplySetAbstract() {\n+    test(\"function Foo() {}; Foo.prototype.doSomething = \" +\n+        \"Foo.prototype.doSomethingElse = Foo.prototype.oneMore = \" +\n+        \"goog.abstractMethod;\",\n+        \"function Foo() {};\");\n+  }\n+\n+  public void testDoNotRemoveNormal() {\n+    testSame(\"function Foo() {}; Foo.prototype.doSomething = function() {};\");\n+  }\n+\n+  public void testDoNotRemoveOverride() {\n+    test(\"function Foo() {}; Foo.prototype.doSomething = goog.abstractMethod;\" +\n+         \"function Bar() {}; goog.inherits(Bar, Foo);\" +\n+         \"Bar.prototype.doSomething = function() {}\",\n+         \"function Foo() {}; function Bar() {}; goog.inherits(Bar, Foo);\" +\n+         \"Bar.prototype.doSomething = function() {}\");\n+  }\n+\n+  public void testDoNotRemoveNonQualifiedName() {\n+    testSame(\"document.getElementById('x').y = goog.abstractMethod;\");\n+  }\n+\n+  public void testStopRemovalAtNonQualifiedName() {\n+    test(\"function Foo() {}; function Bar() {};\" +\n+         \"Foo.prototype.x = document.getElementById('x').y = Bar.prototype.x\" +\n+         \" = goog.abstractMethod;\",\n+         \"function Foo() {}; function Bar() {};\" +\n+         \"Foo.prototype.x = document.getElementById('x').y = \" +\n+         \"goog.abstractMethod;\");\n+  }\n+\n+  @Override\n+  protected ClosureCodeRemoval getProcessor(Compiler compiler) {\n+    return new ClosureCodeRemoval(compiler);\n+  }\n+}", "timestamp": 1280951381, "metainfo": ""}