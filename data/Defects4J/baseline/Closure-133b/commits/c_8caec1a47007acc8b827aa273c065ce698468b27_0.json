{"sha": "8caec1a47007acc8b827aa273c065ce698468b27", "log": "Emit more reasonable warnings about bad overrides  Tested: yes  R=johnlenz DELTA=230  (127 added, 86 deleted, 17 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4955   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n         }\n       }\n \n-      // Inheritance checks for prototype properties.\n-      //\n-      // TODO(nicksantos): This isn't the right place to do this check. We\n-      // really want to do this when we're looking at the constructor.\n-      // We'd find all its properties and make sure they followed inheritance\n-      // rules, like we currently do for @implements to make sure\n-      // all the methods are implemented.\n-      //\n-      // As-is, this misses many other ways to override a property.\n-      //\n-      // object.prototype.property = ...;\n-      if (object.isGetProp()) {\n-        Node object2 = object.getFirstChild();\n-        String property2 = NodeUtil.getStringValue(object.getLastChild());\n-\n-        if (\"prototype\".equals(property2)) {\n-          JSType jsType = getJSType(object2);\n-          if (jsType.isFunctionType()) {\n-            FunctionType functionType = jsType.toMaybeFunctionType();\n-            if (functionType.isConstructor() || functionType.isInterface()) {\n-              checkDeclaredPropertyInheritance(\n-                  t, assign, functionType, property, info, getJSType(rvalue));\n-            }\n-          }\n-        }\n-      }\n-\n       // The generic checks for 'object.property' when 'object' is known,\n       // and 'property' is declared on it.\n       // object.property = ...;\n             validator.expectCanAssignToPropertyOf(\n                 t, assign, getJSType(rvalue),\n                 expectedType, object, property);\n+            checkPropertyInheritanceOnGetpropAssign(\n+                t, assign, object, property, info, expectedType);\n             return;\n           }\n         }\n       }\n+\n+      // If we couldn't get the property type with normal object property\n+      // lookups, then check inheritance anyway with the unknown type.\n+      checkPropertyInheritanceOnGetpropAssign(\n+          t, assign, object, property, info, getNativeType(UNKNOWN_TYPE));\n     }\n \n     // Check qualified name sets to 'object' and 'object.property'.\n       ensureTyped(t, assign, rightType);\n     } else {\n       ensureTyped(t, assign);\n+    }\n+  }\n+\n+  private void checkPropertyInheritanceOnGetpropAssign(\n+      NodeTraversal t, Node assign, Node object, String property,\n+      JSDocInfo info, JSType propertyType) {\n+    // Inheritance checks for prototype properties.\n+    //\n+    // TODO(nicksantos): This isn't the right place to do this check. We\n+    // really want to do this when we're looking at the constructor.\n+    // We'd find all its properties and make sure they followed inheritance\n+    // rules, like we currently do for @implements to make sure\n+    // all the methods are implemented.\n+    //\n+    // As-is, this misses many other ways to override a property.\n+    //\n+    // object.prototype.property = ...;\n+    if (object.isGetProp()) {\n+      Node object2 = object.getFirstChild();\n+      String property2 = NodeUtil.getStringValue(object.getLastChild());\n+\n+      if (\"prototype\".equals(property2)) {\n+        JSType jsType = getJSType(object2);\n+        if (jsType.isFunctionType()) {\n+          FunctionType functionType = jsType.toMaybeFunctionType();\n+          if (functionType.isConstructor() || functionType.isInterface()) {\n+            checkDeclaredPropertyInheritance(\n+                t, assign, functionType, property, info, propertyType);\n+          }\n+        }\n+      }\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"SubFoo.prototype.bar = [];\");\n   }\n \n-  // overridden property 3 is in another cl.\n+  public void testOverriddenProperty3() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {\" +\n+        \"}\" +\n+        \"/** @type {string} */ Foo.prototype.data;\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function SubFoo() {}\" +\n+        \"/** @type {string|Object} \\n @override */ \" +\n+        \"SubFoo.prototype.data = null;\",\n+        \"mismatch of the data property type and the type \" +\n+        \"of the property it overrides from superclass Foo\\n\" +\n+        \"original: string\\n\" +\n+        \"override: (Object|null|string)\");\n+  }\n \n   public void testOverriddenProperty4() throws Exception {\n     // These properties aren't declared, so there should be no warning.", "timestamp": 1338997357, "metainfo": ""}