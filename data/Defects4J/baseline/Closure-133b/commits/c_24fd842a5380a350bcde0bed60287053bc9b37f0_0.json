{"sha": "24fd842a5380a350bcde0bed60287053bc9b37f0", "log": "Automated g4 rollback   *** Reason for rollback ***  breaks various projects without whitelists  *** Original change description ***  Introduced a CAST ast node   Revision created by MOE tool push_codebase. MOE_MIGRATION=5848   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AstValidator.java\n+++ b/src/com/google/javascript/jscomp/AstValidator.java\n       case Token.TYPEOF:\n       case Token.VOID:\n       case Token.BITNOT:\n-      case Token.CAST:\n         validateUnaryOp(n);\n         return;\n \n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n             last, getContextForNonEmptyExpression(context), true);\n         break;\n \n-      case Token.CAST:\n-        add(\"(\");\n-        add(first);\n-        add(\")\");\n-        break;\n-\n       default:\n         throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n       case Token.TRUE:\n       case Token.FALSE:\n         return true;\n-      case Token.CAST:\n       case Token.NOT:\n         return isImmutableValue(n.getFirstChild());\n       case Token.VOID:\n    */\n   static boolean isLiteralValue(Node n, boolean includeFunctions) {\n     switch (n.getType()) {\n-      case Token.CAST:\n-        return isLiteralValue(n.getFirstChild(), includeFunctions);\n-\n       case Token.ARRAYLIT:\n         for (Node child = n.getFirstChild(); child != null;\n              child = child.getNext()) {\n     // that we know to be safe\n     switch (n.getType()) {\n       // other side-effect free statements and expressions\n-      case Token.CAST:\n       case Token.AND:\n       case Token.BLOCK:\n       case Token.EXPR_RESULT:\n       case Token.THIS:\n       case Token.TRUE:\n         return 15;\n-      case Token.CAST:\n-        return 16;\n \n       default: throw new Error(\"Unknown precedence for \" +\n                                Token.name(type) +\n    */\n   static boolean allResultsMatch(Node n, Predicate<Node> p) {\n     switch (n.getType()) {\n-      case Token.CAST:\n-        return allResultsMatch(n.getFirstChild(), p);\n       case Token.ASSIGN:\n       case Token.COMMA:\n         return allResultsMatch(n.getLastChild(), p);\n    */\n   static boolean anyResultsMatch(Node n, Predicate<Node> p) {\n     switch (n.getType()) {\n-      case Token.CAST:\n-        return anyResultsMatch(n.getFirstChild(), p);\n       case Token.ASSIGN:\n       case Token.COMMA:\n         return anyResultsMatch(n.getLastChild(), p);\n    */\n   static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n     switch (value.getType()) {\n-      case Token.CAST:\n-        return evaluatesToLocalValue(value.getFirstChild(), locals);\n       case Token.ASSIGN:\n         // A result that is aliased by a non-local name, is the effectively the\n         // same as returning a non-local name, but this doesn't matter if the\n                  parent.isAnd() ||\n                  (parent.isComma() && parent.getFirstChild() != n)) {\n         return getBestJSDocInfo(parent);\n-      } else if (parent.isCast()) {\n-        return parent.getJSDocInfo();\n       }\n     }\n     return info;\n         parent.isAnd() ||\n         (parent.isComma() && parent.getFirstChild() != n)) {\n       return getBestLValue(parent);\n-    } else if (parent.isCast()) {\n-      return getBestLValue(parent);\n     }\n     return null;\n   }\n       case Token.BLOCK:\n       case Token.EXPR_RESULT:\n         return false;\n-      case Token.CAST:\n-        return isExpressionResultUsed(parent);\n       case Token.HOOK:\n       case Token.AND:\n       case Token.OR:\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n             annotateConstantsByConvention(n, parent);\n           }\n           break;\n-\n-        case Token.CAST:\n-          parent.replaceChild(n, n.removeFirstChild());\n-          break;\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     boolean typeable = true;\n \n     switch (n.getType()) {\n-      case Token.CAST:\n-        Node expr = n.getFirstChild();\n-        ensureTyped(t, n, getJSType(expr));\n-\n-        JSType castType = getJSType(n);\n-        JSType exprType = getJSType(expr);\n-        // If the cast, tightens the type apply it, so it is available post\n-        // normalization.\n-        if (castType.isSubtype(exprType)) {\n-          expr.setJSType(castType);\n-        }\n-        break;\n-\n       case Token.NAME:\n         typeable = visitName(t, n, parent);\n         break;\n     JSDocInfo info = n.getJSDocInfo();\n     if (info != null) {\n       if (info.hasType()) {\n-        // TODO(johnlenz): Change this so that we only look for casts on CAST\n-        // nodes one the misplaced type annotation warning is on by default and\n-        // people have been given a chance to fix them.  As is, this is here\n-        // simply for legacy casts.\n         JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n+        // remove cast check here.\n         validator.expectCanCast(t, n, infoType, type);\n         type = infoType;\n       }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       case Token.CATCH:\n         scope = traverseCatch(n, scope);\n         break;\n-\n-      case Token.CAST:\n-        scope = traverseChildren(n, scope);\n-        break;\n-    }\n-\n-    // TODO(johnlenz): remove this after the CAST node change has shaken out.\n+    }\n     if (!n.isFunction()) {\n       JSDocInfo info = n.getJSDocInfo();\n       if (info != null && info.hasType()) {\n         JSType castType = info.getType().evaluate(syntacticScope, registry);\n \n-        // A stubbed type declaration on a qualified name should take\n+        // validate cast here\n+\n+        // A stubbed type cast on a qualified name should take\n         // effect for all subsequent accesses of that name,\n         // so treat it the same as an assign to that name.\n         if (n.isQualifiedName() &&\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n \n   /**\n    * Expect that the first type can be cast to the second type. The first type\n-   * must have some relationship with the second.\n+   * should be either a subtype or supertype of the second.\n    *\n    * @param t The node traversal.\n    * @param n The node where warnings should point.\n    * @param castType The type being cast to.\n    */\n   void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) {\n-\n-    // TODO(johnlenz): consider tightening this to:\n-    //   \"a.canAssignTo(b) || b.canAssignTo(a)\"\n-    if (!type.isEmptyType() &&\n-        !castType.isEmptyType() &&\n-        type.getGreatestSubtype(castType).isEmptyType()) {\n+    castType = castType.restrictByNotNullOrUndefined();\n+    type = type.restrictByNotNullOrUndefined();\n+\n+    if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {\n       registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST,\n           castType.toString(), type.toString())));\n     }\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n \n   private void validateTypeAnnotations(\n       JSDocInfo info, AstNode node, Node irNode) {\n-    if (info.hasType()) {\n+    if (info.getType() != null) {\n       boolean valid = false;\n       switch (node.getType()) {\n         // Casts are valid\n     Node irNode = justTransform(node);\n     JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n     if (jsDocInfo != null) {\n-      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n       irNode.setJSDocInfo(jsDocInfo);\n     }\n     setSourceInfo(irNode, node);\n-    return irNode;\n-  }\n-\n-  private Node maybeInjectCastNode(AstNode node, JSDocInfo info, Node irNode) {\n-    if (node.getType() == com.google.javascript.rhino.head.Token.LP\n-        && node instanceof ParenthesizedExpression\n-        && info.hasType()\n-        // TODO(johnlenz): for now, attach object literal type directly.\n-        && !irNode.isObjectLit()) {\n-      irNode = newNode(Token.CAST, irNode);\n-    }\n     return irNode;\n   }\n \n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     return this.getType() == Token.CASE;\n   }\n \n-  public boolean isCast() {\n-    return this.getType() == Token.CAST;\n-  }\n-\n   public boolean isCatch() {\n     return this.getType() == Token.CATCH;\n   }\n--- a/src/com/google/javascript/rhino/Token.java\n+++ b/src/com/google/javascript/rhino/Token.java\n         // JSCompiler introduced tokens\n         LABEL_NAME     = 153,\n         STRING_KEY     = 154, // object literal key\n-        CAST           = 155,\n \n         // JSDoc-only tokens\n         ANNOTATION     = 300,\n           case SETTER_DEF:      return \"SETTER_DEF\";\n           case CONST:           return \"CONST\";\n           case DEBUGGER:        return \"DEBUGGER\";\n-          case CAST:            return \"CAST\";\n           case ANNOTATION:      return \"ANNOTATION\";\n           case PIPE:            return \"PIPE\";\n           case STAR:            return \"STAR\";\n--- a/test/com/google/javascript/jscomp/TightenTypesTest.java\n+++ b/test/com/google/javascript/jscomp/TightenTypesTest.java\n   public TightenTypesTest() {\n     parseTypeInfo = true;\n     enableTypeCheck(CheckLevel.WARNING);\n-    enableNormalize(true);\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"}\", null);\n   }\n \n-  public void testTypeOfReduction16() throws Exception {\n-    testClosureTypes(\n-        CLOSURE_DEFS +\n-        \"/** @interface */ function I() {}\\n\" +\n-        \"/**\\n\" +\n-        \" * @param {*} x\\n\" +\n-        \" * @return {I}\\n\" +\n-        \" */\\n\" +\n-        \"function f(x) { \" +\n-        \"  if(goog.isObject(x)) {\" +\n-        \"    return /** @type {I} */(x);\" +\n-        \"  }\" +\n-        \"  return null;\" +\n-        \"}\", null);\n-  }\n-\n   public void testQualifiedNameReduction1() throws Exception {\n     testTypes(\"var x = {}; /** @type {string?} */ x.a = 'a';\\n\" +\n         \"/** @return {string} */ var f = function() {\\n\" +\n         \"/** @param {number=} x \\n * @param {number=} y */ \" +\n         \"SubFoo.prototype.bar = \" +\n         \"    function(x, y) { f(y); };\",\n-        \"actual parameter 1 of f does not match formal parameter\\n\" +\n-        \"found   : (number|undefined)\\n\" +\n-        \"required: string\");\n-  }\n-\n-  public void testInferredParam7() throws Exception {\n-    testTypes(\n-        \"/** @param {string} x */ function f(x) {}\" +\n-        \"var bar = /** @type {function(number=,number=)} */ (\" +\n-        \"    function(x, y) { f(y); });\",\n         \"actual parameter 1 of f does not match formal parameter\\n\" +\n         \"found   : (number|undefined)\\n\" +\n         \"required: string\");\n         \"required: derived\");\n   }\n \n-  public void testCast3a() throws Exception {\n-    // cannot downcast\n-    testTypes(\"/** @constructor */function Base() {}\\n\" +\n-        \"/** @constructor @extends {Base} */function Derived() {}\\n\" +\n-        \"var baseInstance = new Base();\" +\n-        \"/** @type {!Derived} */ var baz = baseInstance;\\n\",\n-        \"initializing variable\\n\" +\n-        \"found   : Base\\n\" +\n-        \"required: Derived\");\n-  }\n-\n   public void testCast4() throws Exception {\n     // downcast must be explicit\n     testTypes(\"/** @constructor */function base() {}\\n\" +\n     testTypes(\"/** @constructor */function foo() {}\\n\" +\n         \"/** @constructor */function bar() {}\\n\" +\n         \"var baz = /** @type {!foo} */(new bar);\\n\",\n-        \"invalid cast - must be a subtype or supertype\\n\" +\n-        \"from: bar\\n\" +\n-        \"to  : foo\");\n-  }\n-\n-  public void testCast5a() throws Exception {\n-    // cannot explicitly cast to an unrelated type\n-    testTypes(\"/** @constructor */function foo() {}\\n\" +\n-        \"/** @constructor */function bar() {}\\n\" +\n-        \"var barInstance = new bar;\\n\" +\n-        \"var baz = /** @type {!foo} */(barInstance);\\n\",\n         \"invalid cast - must be a subtype or supertype\\n\" +\n         \"from: bar\\n\" +\n         \"to  : foo\");\n         \"required: string\");\n   }\n \n-  public void testCast17a() throws Exception {\n+  public void testCast17() throws Exception {\n     // Mostly verifying that rhino actually understands these JsDocs.\n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ (y)\");\n \n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n         \"/** @type {Foo} */ var x = (/** @type {Foo} */ y)\");\n-  }\n-\n-  public void testCast17b() throws Exception {\n+\n     // Mostly verifying that rhino actually understands these JsDocs.\n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ ({})\");\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ {}\",\n         \"Type annotations are not allowed here. \" +\n         \"Are you missing parentheses?\");\n-  }\n-\n-  public void testCast19() throws Exception {\n-    testTypes(\n-        \"var x = 'string';\\n\" +\n-        \"/** @type {number} */\\n\" +\n-        \"var y = /** @type {number} */(x);\",\n-        \"invalid cast - must be a subtype or supertype\\n\" +\n-        \"from: string\\n\" +\n-        \"to  : number\");\n-  }\n-\n-  public void testCast20() throws Exception {\n-    testTypes(\n-        \"/** @enum {boolean|null} */\\n\" +\n-        \"var X = {\" +\n-        \"  AA: true,\" +\n-        \"  BB: false,\" +\n-        \"  CC: null\" +\n-        \"};\\n\" +\n-        \"var y = /** @type {X} */(true);\");\n-  }\n-\n-  public void testCast21() throws Exception {\n-    testTypes(\n-        \"/** @enum {boolean|null} */\\n\" +\n-        \"var X = {\" +\n-        \"  AA: true,\" +\n-        \"  BB: false,\" +\n-        \"  CC: null\" +\n-        \"};\\n\" +\n-        \"var value = true;\\n\" +\n-        \"var y = /** @type {X} */(value);\");\n-  }\n-\n-  public void testCast22() throws Exception {\n-    testTypes(\n-        \"var x = null;\\n\" +\n-        \"var y = /** @type {number} */(x);\",\n-        \"invalid cast - must be a subtype or supertype\\n\" +\n-        \"from: null\\n\" +\n-        \"to  : number\");\n-  }\n-\n-  public void testCast23() throws Exception {\n-    testTypes(\n-        \"var x = null;\\n\" +\n-        \"var y = /** @type {Number} */(x);\");\n-  }\n-\n-  public void testCast24() throws Exception {\n-    testTypes(\n-        \"var x = undefined;\\n\" +\n-        \"var y = /** @type {number} */(x);\",\n-        \"invalid cast - must be a subtype or supertype\\n\" +\n-        \"from: undefined\\n\" +\n-        \"to  : number\");\n-  }\n-\n-  public void testCast25() throws Exception {\n-    testTypes(\n-        \"var x = undefined;\\n\" +\n-        \"var y = /** @type {number|undefined} */(x);\");\n-  }\n-\n-  public void testCast26() throws Exception {\n-    testTypes(\n-        \"function fn(dir) {\\n\" +\n-        \"  var node = dir ? 1 : 2;\\n\" +\n-        \"  fn(/** @type {number} */ (node));\\n\" +\n-        \"}\");\n   }\n \n   public void testNestedCasts() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n     verify(\"x\", NUMBER_TYPE);\n   }\n \n-  public void testExprWithinCast() {\n-    assuming(\"x\", OBJECT_TYPE);\n-    inFunction(\"/** @type {string} */ (x = 1);\");\n-    verify(\"x\", NUMBER_TYPE);\n-  }\n-\n   public void testGetProp() {\n     assuming(\"x\", createNullableType(OBJECT_TYPE));\n     inFunction(\"x.y();\");", "timestamp": 1353367158, "metainfo": ""}