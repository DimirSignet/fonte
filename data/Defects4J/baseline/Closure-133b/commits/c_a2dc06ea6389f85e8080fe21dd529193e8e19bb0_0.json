{"sha": "a2dc06ea6389f85e8080fe21dd529193e8e19bb0", "log": "\"Stable naming\" for ReplaceIdGenerators.  * Update the report created by the pass to actually contain enough information to enable stable renaming: \"consistent\" id generators no record the original name \"unique\" id generators now also record the complete source location of the string being replaced. * Add a compiler option to provide the previous recorded mappings * Enable using the previous mappings as a hint for current namings.  R=mwr DELTA=256  (197 added, 3 deleted, 56 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5710   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Id generators to replace. */\n   Set<String> idGenerators;\n+\n+  /**\n+   * A previous map of ids (serialized to a string by a previous compile).\n+   * This will be used as a hint during the ReplaceIdGenerators pass, which\n+   * will attempt to reuse the same ids.\n+   */\n+  String idGeneratorsMapSerialized;\n \n   /** Configuration strings */\n   List<String> replaceStringsFunctionDescriptions;\n   }\n \n   /**\n+   * A previous map of ids (serialized to a string by a previous compile).\n+   * This will be used as a hint during the ReplaceIdGenerators pass, which\n+   * will attempt to reuse the same ids.\n+   */\n+  public void setIdGeneratorsMap(String previousMappings) {\n+    this.idGeneratorsMapSerialized = previousMappings;\n+  }\n+\n+  /**\n    * Set the function inlining policy for the compiler.\n    */\n   public void setInlineFunctions(Reach reach) {\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   final PassFactory garbageCollectChecks =\n       new HotSwapPassFactory(\"garbageCollectChecks\", true) {\n     @Override\n-    protected HotSwapCompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected HotSwapCompilerPass createInternal(\n+        final AbstractCompiler compiler) {\n       return new HotSwapCompilerPass() {\n         @Override\n         public void process(Node externs, Node jsRoot) {\n         @Override public void process(Node externs, Node root) {\n           ReplaceIdGenerators pass =\n               new ReplaceIdGenerators(\n-                  compiler, options.idGenerators, options.generatePseudoNames);\n+                  compiler, options.idGenerators, options.generatePseudoNames,\n+                  options.idGeneratorsMapSerialized);\n           pass.process(externs, root);\n-          idGeneratorMap = pass.getIdGeneratorMap();\n+          idGeneratorMap = pass.getSerializedIdMappings();\n         }\n       };\n     }\n--- a/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n+++ b/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.collect.Lists;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableBiMap;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n import java.util.Collections;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n           \"JSC_CONFLICTING_ID_GENERATOR_TYPE\",\n           \"Id generator can only be consistent or inconsistent\");\n \n+  static final DiagnosticType INVALID_GENERATOR_ID_MAPPING =\n+      DiagnosticType.error(\n+          \"JSC_INVALID_GENERATOR_ID_MAPPING\",\n+          \"Invalid generator id mapping. {0}\");\n+\n   private final AbstractCompiler compiler;\n   private final Map<String, NameSupplier> nameGenerators;\n   private final Map<String, NameSupplier> consistNameGenerators;\n   private final Map<String, Map<String, String>> consistNameMap;\n \n-  private final Map<String, List<Replacement>> idGeneratorMaps;\n+  private final Map<String, Map<String, String>> idGeneratorMaps;\n+  private final Map<String, BiMap<String, String>> previousMap;\n \n   private final boolean generatePseudoNames;\n \n   public ReplaceIdGenerators(\n       AbstractCompiler compiler, Set<String> idGens,\n-      boolean generatePseudoNames) {\n+      boolean generatePseudoNames,\n+      String previousMapSerialized) {\n     this.compiler = compiler;\n     this.generatePseudoNames = generatePseudoNames;\n     nameGenerators = Maps.newLinkedHashMap();\n     idGeneratorMaps = Maps.newLinkedHashMap();\n     consistNameMap = Maps.newLinkedHashMap();\n \n+    Map<String, BiMap<String, String>> previousMap;\n+    previousMap = parsePreviousResults(previousMapSerialized);\n+    this.previousMap = previousMap;\n+\n     if (idGens != null) {\n-      for(String gen : idGens) {\n-        nameGenerators.put(gen, createNameSupplier());\n-        idGeneratorMaps.put(gen, Lists.<Replacement>newLinkedList());\n+      for (String gen : idGens) {\n+        nameGenerators.put(gen, createNameSupplier(previousMap.get(gen)));\n+        idGeneratorMaps.put(gen, Maps.<String, String>newLinkedHashMap());\n       }\n     }\n   }\n \n   private static interface NameSupplier {\n-    String getName(String name);\n+    String getName(String id, String name);\n   }\n \n   private static class ObfuscatedNameSuppier implements NameSupplier {\n-    private final NameGenerator generator =\n-        new NameGenerator(Collections.<String>emptySet(), \"\", null);\n+    private final NameGenerator generator;\n+    private final Map<String, String> previousMappings;\n+    public ObfuscatedNameSuppier(BiMap<String, String> previousMappings) {\n+      this.previousMappings = previousMappings.inverse();\n+      this.generator =\n+          new NameGenerator(previousMappings.keySet(), \"\", null);\n+    }\n+\n     @Override\n-    public String getName(String name) {\n-      return generator.generateNextName();\n+    public String getName(String id, String name) {\n+      String newName = previousMappings.get(id);\n+      if (newName == null) {\n+        newName = generator.generateNextName();\n+      }\n+      return newName;\n     }\n   }\n \n   private static class PseudoNameSuppier implements NameSupplier {\n     private int counter = 0;\n     @Override\n-    public String getName(String name) {\n+    public String getName(String id, String name) {\n       return name + \"$\" + counter++;\n     }\n   }\n \n-  private NameSupplier createNameSupplier() {\n+  private NameSupplier createNameSupplier(\n+      BiMap<String, String> previousMappings) {\n+    previousMappings = previousMappings != null ?\n+        previousMappings :\n+        ImmutableBiMap.<String, String>of();\n     if (generatePseudoNames) {\n       return new PseudoNameSuppier();\n     } else {\n-      return new ObfuscatedNameSuppier();\n+      return new ObfuscatedNameSuppier(previousMappings);\n     }\n   }\n \n \n       // TODO(user): Error on function that has both. Or redeclartion\n       // on the same function.\n+\n       if (doc.isConsistentIdGenerator()) {\n-        consistNameGenerators.put(name, createNameSupplier());\n+        consistNameGenerators.put(\n+            name, createNameSupplier(previousMap.get(name)));\n         consistNameMap.put(name, Maps.<String, String>newLinkedHashMap());\n       } else {\n-        nameGenerators.put(name, createNameSupplier());\n-      }\n-      idGeneratorMaps.put(name, Lists.<Replacement>newArrayList());\n+        nameGenerators.put(name, createNameSupplier(previousMap.get(name)));\n+      }\n+      idGeneratorMaps.put(name, Maps.<String, String>newLinkedHashMap());\n     }\n   }\n \n         return;\n       }\n \n-      List<Replacement> idGeneratorMap = idGeneratorMaps.get(callName);\n+      Map<String, String> idGeneratorMap = idGeneratorMaps.get(callName);\n       String rename = null;\n \n+      String name = id.getString();\n+      String instanceId = getIdForGeneratorNode(consistent, id);\n       if (consistent) {\n         Map<String, String> entry = consistNameMap.get(callName);\n-        rename = entry.get(id.getString());\n+        rename = entry.get(instanceId);\n         if (rename == null) {\n-          rename = nameGenerator.getName(id.getString());\n-          entry.put(id.getString(), rename);\n+          rename = nameGenerator.getName(instanceId, name);\n+          entry.put(instanceId, rename);\n         }\n       } else {\n-        rename = nameGenerator.getName(id.getString());\n+        rename = nameGenerator.getName(instanceId, name);\n       }\n \n       parent.replaceChild(n, IR.string(rename));\n-      idGeneratorMap.add(\n-          new Replacement(rename, t.getSourceName(), t.getLineNumber()));\n+      idGeneratorMap.put(rename, instanceId);\n \n       compiler.reportCodeChange();\n     }\n   }\n \n   /**\n-   * @return the id generator map.\n+   * @return The serialize map of generators and their ids and their\n+   *     replacements.\n    */\n-  public String getIdGeneratorMap() {\n+  public String getSerializedIdMappings() {\n     StringBuilder sb = new StringBuilder();\n-    for (Map.Entry<String, List<Replacement>> entry :\n+    for (Map.Entry<String, Map<String, String>> replacements :\n         idGeneratorMaps.entrySet()) {\n-      sb.append(\"[\");\n-      sb.append(entry.getKey());\n-      sb.append(\"]\\n\\n\");\n-      for (Replacement replacement : entry.getValue()) {\n-        sb.append(replacement.toString());\n+      if (!replacements.getValue().isEmpty()) {\n+        sb.append(\"[\");\n+        sb.append(replacements.getKey());\n+        sb.append(\"]\\n\\n\");\n+        for (Map.Entry<String, String> replacement :\n+            replacements.getValue().entrySet()) {\n+          sb.append(replacement.getKey());\n+          sb.append(':');\n+          sb.append(replacement.getValue());\n+          sb.append(\"\\n\");\n+        }\n         sb.append(\"\\n\");\n       }\n-      sb.append(\"\\n\");\n     }\n     return sb.toString();\n   }\n \n-  private static class Replacement {\n-    private final String name;\n-    private final String sourceName;\n-    private final int lineNumber;\n-\n-    private Replacement(String name, String sourceName, int lineNumber) {\n-      this.name = name;\n-      this.sourceName = sourceName;\n-      this.lineNumber = lineNumber;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return name + \":\" + sourceName + \":\" + lineNumber;\n+  private Map<String, BiMap<String, String>> parsePreviousResults(\n+      String serializedMap) {\n+\n+    //\n+    // The expected format looks like this:\n+    //\n+    // [generatorName]\n+    // someId:someFile:theLine:theColumn\n+    //\n+    //\n+\n+    if (serializedMap == null || serializedMap.isEmpty()) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String, BiMap<String, String>> resultMap = Maps.newHashMap();\n+    BufferedReader reader = new BufferedReader(new StringReader(serializedMap));\n+    BiMap<String, String> currentSectionMap = null;\n+\n+    String line;\n+    int lineIndex = 0;\n+    try {\n+      while ((line = reader.readLine()) != null) {\n+        lineIndex++;\n+        if (line.isEmpty()) {\n+          continue;\n+        }\n+        if (line.charAt(0) == '[') {\n+          String currentSection = line.substring(1, line.length() - 1);\n+          currentSectionMap = resultMap.get(currentSection);\n+          if (currentSectionMap == null) {\n+            currentSectionMap = HashBiMap.create();\n+            resultMap.put(currentSection, currentSectionMap);\n+          } else {\n+            reportInvalidLine(line, lineIndex);\n+            return Collections.emptyMap();\n+          }\n+        } else {\n+          int split = line.indexOf(':');\n+          if (split != -1) {\n+            String name = line.substring(0, split);\n+            String location = line.substring(split + 1, line.length());\n+            currentSectionMap.put(name, location);\n+          } else {\n+            reportInvalidLine(line, lineIndex);\n+            return Collections.emptyMap();\n+          }\n+        }\n+      }\n+    } catch (IOException e) {\n+      JSError.make(INVALID_GENERATOR_ID_MAPPING, e.getMessage());\n+    }\n+    return resultMap;\n+  }\n+\n+  private void reportInvalidLine(String line, int lineIndex) {\n+    JSError.make(INVALID_GENERATOR_ID_MAPPING,\n+        \"line(\" + line + \"): \" + lineIndex);\n+  }\n+\n+  String getIdForGeneratorNode(boolean consistent, Node n) {\n+    Preconditions.checkState(n.isString());\n+    if (consistent) {\n+      return n.getString();\n+    } else {\n+      return n.getSourceFileName() + ':' + n.getLineno() + \":\" + n.getCharno();\n     }\n   }\n }\n--- a/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java\n+++ b/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java\n \n   private boolean generatePseudoNames = false;\n   private ReplaceIdGenerators lastPass = null;\n+  private String previousMappings = null;\n \n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n             .add(\"goog.events.getUniqueId\")\n             .add(\"goog.place.getUniqueId\")\n             .build(),\n-        generatePseudoNames);\n+        generatePseudoNames,\n+        previousMappings);\n     return lastPass;\n   }\n \n   protected void setUp() throws Exception {\n     super.setUp();\n     generatePseudoNames = false;\n+    previousMappings = null;\n   }\n \n   @Override\n          \"foo.bar = 'foo_bar$0'\");\n   }\n \n-  public void testSerialization() {\n+  public void testSerialization1() {\n     testMap(\"var x = goog.events.getUniqueId('xxx');\\n\" +\n             \"var y = goog.events.getUniqueId('yyy');\\n\",\n \n \n             \"[goog.events.getUniqueId]\\n\" +\n             \"\\n\" +\n-            \"a:testcode:1\\n\" +\n-            \"b:testcode:2\\n\" +\n+            \"a:testcode:1:32\\n\" +\n+            \"b:testcode:2:32\\n\" +\n+            \"\\n\");\n+  }\n+\n+  public void testSerialization2() {\n+    testMap(\"/** @consistentIdGenerator */ id = function() {};\" +\n+         \"f1 = id('f1');\" +\n+         \"f1 = id('f1')\",\n+\n+         \"id = function() {};\" +\n+         \"f1 = 'a';\" +\n+         \"f1 = 'a'\",\n+\n+         \"[id]\\n\" +\n+         \"\\n\" +\n+         \"a:f1\\n\" +\n+         \"\\n\");\n+  }\n+\n+  public void testReusePreviousSerialization1() {\n+    previousMappings =\n+        \"[goog.events.getUniqueId]\\n\" +\n+        \"\\n\" +\n+        \"previous1:testcode:1:32\\n\" +\n+        \"previous2:testcode:2:32\\n\" +\n+        \"\\n\" +\n+        \"[goog.place.getUniqueId]\\n\" +\n+        \"\\n\" +\n+        \"\\n\";\n+    testMap(\"var x = goog.events.getUniqueId('xxx');\\n\" +\n+            \"var y = goog.events.getUniqueId('yyy');\\n\",\n+\n+            \"var x = 'previous1';\\n\" +\n+            \"var y = 'previous2';\\n\",\n+\n+            \"[goog.events.getUniqueId]\\n\" +\n             \"\\n\" +\n-            \"[goog.place.getUniqueId]\\n\" +\n-            \"\\n\" +\n+            \"previous1:testcode:1:32\\n\" +\n+            \"previous2:testcode:2:32\\n\" +\n             \"\\n\");\n+  }\n+\n+  public void testReusePreviousSerialization2() {\n+    previousMappings =\n+        \"[goog.events.getUniqueId]\\n\" +\n+        \"\\n\" +\n+        \"a:testcode:1:32\\n\" +\n+        \"b:testcode:2:32\\n\" +\n+        \"\\n\" +\n+        \"[goog.place.getUniqueId]\\n\" +\n+        \"\\n\" +\n+        \"\\n\";\n+    testMap(\n+        \"var x = goog.events.getUniqueId('xxx');\\n\" +\n+        \"\\n\" + // new line to change location\n+        \"var y = goog.events.getUniqueId('yyy');\\n\",\n+\n+        \"var x = 'a';\\n\" +\n+        \"var y = 'c';\\n\",\n+\n+        \"[goog.events.getUniqueId]\\n\" +\n+        \"\\n\" +\n+        \"a:testcode:1:32\\n\" +\n+        \"c:testcode:3:32\\n\" +\n+        \"\\n\");\n+  }\n+\n+  public void testReusePreviousSerializationConsistent1() {\n+    previousMappings =\n+        \"[id]\\n\" +\n+        \"\\n\" +\n+        \"a:f1\\n\" +\n+        \"\\n\";\n+    testMap(\n+        \"/** @consistentIdGenerator */ id = function() {};\" +\n+        \"f1 = id('f1');\" +\n+        \"f1 = id('f1')\",\n+\n+        \"id = function() {};\" +\n+        \"f1 = 'a';\" +\n+        \"f1 = 'a'\",\n+\n+        \"[id]\\n\" +\n+        \"\\n\" +\n+        \"a:f1\\n\" +\n+        \"\\n\");\n   }\n \n   public void testSimple() {\n \n   private void testMap(String code, String expected, String expectedMap) {\n     test(code, expected);\n-    assertEquals(expectedMap, lastPass.getIdGeneratorMap());\n+    assertEquals(expectedMap, lastPass.getSerializedIdMappings());\n   }\n \n   private void test(String code, String expected, String expectedPseudo) {", "timestamp": 1351211319, "metainfo": ""}