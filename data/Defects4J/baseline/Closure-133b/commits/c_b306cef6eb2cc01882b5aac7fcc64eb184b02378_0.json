{"sha": "b306cef6eb2cc01882b5aac7fcc64eb184b02378", "log": "Automated g4 rollback.  *** Reason for rollback ***  Seems to have broken a several things.  *** Original change description ***  Modify rhino so that infix expressions use a starte position and line number that point to the start of the expression rather than the position of the operator. Modify IRFactory to maintain this new position logic when it does its translation pass. Adjusted the test file expectations accordingly.  R=nicksantos DELTA=207  (21 added, 8 deleted, 178 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3505   ", "commit": "\n--- a/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Parser.java\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Parser.java\n             if (peekToken() == Token.YIELD)\n                 reportError(\"msg.yield.parenthesized\");\n             pn = new InfixExpression(Token.COMMA, pn, assignExpr(), opPos);\n+            pn.setLineno(lineno);\n         }\n         return pn;\n     }\n \n             pn = new Assignment(tt, pn, assignExpr(), opPos);\n \n+            pn.setLineno(opLineno);\n             if (jsdocNode != null) {\n                 pn.setJsDocNode(jsdocNode);\n             }\n             int opPos = ts.tokenBeg;\n             int lineno = ts.lineno;\n             pn = new InfixExpression(Token.OR, pn, orExpr(), opPos);\n+            pn.setLineno(lineno);\n         }\n         return pn;\n     }\n             int opPos = ts.tokenBeg;\n             int lineno = ts.lineno;\n             pn = new InfixExpression(Token.AND, pn, andExpr(), opPos);\n+            pn.setLineno(lineno);\n         }\n         return pn;\n     }\n             int opPos = ts.tokenBeg;\n             int lineno = ts.lineno;\n             pn = new InfixExpression(Token.BITOR, pn, bitXorExpr(), opPos);\n+            pn.setLineno(lineno);\n         }\n         return pn;\n     }\n             int opPos = ts.tokenBeg;\n             int lineno = ts.lineno;\n             pn = new InfixExpression(Token.BITXOR, pn, bitAndExpr(), opPos);\n+            pn.setLineno(lineno);\n         }\n         return pn;\n     }\n             int opPos = ts.tokenBeg;\n             int lineno = ts.lineno;\n             pn = new InfixExpression(Token.BITAND, pn, eqExpr(), opPos);\n+            pn.setLineno(lineno);\n         }\n         return pn;\n     }\n                         parseToken = Token.SHNE;\n                 }\n                 pn = new InfixExpression(parseToken, pn, relExpr(), opPos);\n+                pn.setLineno(lineno);\n                 continue;\n             }\n             break;\n               case Token.GT:\n                 consumeToken();\n                 pn = new InfixExpression(tt, pn, shiftExpr(), opPos);\n+                pn.setLineno(line);\n                 continue;\n             }\n             break;\n               case Token.RSH:\n                 consumeToken();\n                 pn = new InfixExpression(tt, pn, addExpr(), opPos);\n+                pn.setLineno(lineno);\n                 continue;\n             }\n             break;\n                 consumeToken();\n                 int lineno = ts.lineno;\n                 pn = new InfixExpression(tt, pn, mulExpr(), opPos);\n+                pn.setLineno(lineno);\n                 continue;\n             }\n             break;\n                 consumeToken();\n                 int line = ts.lineno;\n                 pn = new InfixExpression(tt, pn, unaryExpr(), opPos);\n+                pn.setLineno(line);\n                 continue;\n             }\n             break;\n           case Token.TYPEOF:\n               consumeToken();\n               node = new UnaryExpression(tt, ts.tokenBeg, unaryExpr());\n+              node.setLineno(line);\n               return node;\n \n           case Token.ADD:\n         result.setPosition(pos);\n         result.setLength(getNodeEnd(ref) - pos);\n         result.setOperatorPosition(dotPos - pos);\n-        result.setLineno(pn.getLineno());\n+        result.setLineno(lineno);\n         result.setLeft(pn);  // do this after setting position\n         result.setRight(ref);\n         return result;\n--- a/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/InfixExpression.java\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/InfixExpression.java\n         int beg = left.getPosition();\n         int end = right.getPosition() + right.getLength();\n         setBounds(beg, end);\n-        // line number should agree with source position\n-        setLineno(left.getLineno());\n-\n         // this updates their positions to be parent-relative\n         setLeft(left);\n         setRight(right);\n--- a/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/ParserTest.java\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/ParserTest.java\n \n         assertEquals(1, var1.getLineno());\n         assertEquals(1, firstVarName.getLineno());\n-        assertEquals(1, var1Add.getLineno());\n+        assertEquals(2, var1Add.getLineno());\n         assertEquals(1, var1Add.getLeft().getLineno());\n         assertEquals(3, var1Add.getRight().getLineno());\n \n \n         assertEquals(8, var3.getLineno());\n         assertEquals(8, thirdVarName.getLineno());\n-        assertEquals(8, thirdVarDiv.getLineno());\n+        assertEquals(9, thirdVarDiv.getLineno());\n         assertEquals(8, thirdVarDiv.getLeft().getLineno());\n         assertEquals(9, thirdVarDiv.getRight().getLineno());\n     }\n         AstNode rhs = compare.getRight();\n \n         assertEquals(1, lhs.getLineno());\n-        assertEquals(1, compare.getLineno());\n+        assertEquals(2, compare.getLineno());\n         assertEquals(3, rhs.getLineno());\n     }\n \n         AstNode rhs = compare.getRight();\n \n         assertEquals(1, lhs.getLineno());\n-        assertEquals(1, compare.getLineno());\n+        assertEquals(2, compare.getLineno());\n         assertEquals(3, rhs.getLineno());\n     }\n \n         AstNode rhs = assign.getRight();\n \n         assertEquals(1, lhs.getLineno());\n-        assertEquals(1, assign.getLineno());\n+        assertEquals(2, assign.getLineno());\n         assertEquals(3, rhs.getLineno());\n     }\n \n         AstNode aRef = comma2.getLeft();\n         AstNode bRef = comma2.getRight();\n \n-        assertEquals(1, comma1.getLineno());\n+        assertEquals(2, comma1.getLineno());\n         assertEquals(1, comma2.getLineno());\n         assertEquals(1, aRef.getLineno());\n         assertEquals(2, bRef.getLineno());\n       AstNode cName = orClause.getRight();\n \n       assertEquals(1, ifStmt.getLineno());\n-      assertEquals(1, orClause.getLineno());\n+      assertEquals(2, orClause.getLineno());\n       assertEquals(1, andClause.getLineno());\n       assertEquals(4, cName.getLineno());\n \n       AstNode thirdValue = thirdObjectLit.getRight();\n \n       assertEquals(1, firstVarName.getLineno());\n-      assertEquals(2, objectLiteral.getLineno());\n-      assertEquals(3, firstObjectLit.getLineno());\n+      assertEquals(2, firstObjectLit.getLineno());\n       assertEquals(3, firstKey.getLineno());\n       assertEquals(3, firstValue.getLineno());\n \n       AstNode bTest = andTest.getRight();\n \n       assertEquals(1, ifStmt.getLineno());\n-      assertEquals(2, orTest.getLineno());\n-      assertEquals(2, andTest.getLineno());\n+      assertEquals(4, orTest.getLineno());\n+      assertEquals(3, andTest.getLineno());\n       assertEquals(2, aTest.getLineno());\n       assertEquals(4, bTest.getLineno());\n       assertEquals(5, cTest.getLineno());\n \n       assertEquals(2, bigLHSExpr.getLineno());\n       assertEquals(7, bigRHSExpr.getLineno());\n-      assertEquals(2, eqTest.getLineno());\n-      assertEquals(7, notEqTest.getLineno());\n+      assertEquals(4, eqTest.getLineno());\n+      assertEquals(9, notEqTest.getLineno());\n \n       assertEquals(2, test1Expr.getLineno());\n       assertEquals(5, test2Expr.getLineno());\n       assertEquals(7, test3Expr.getLineno());\n       assertEquals(10, test4Expr.getLineno());\n \n-      assertEquals(2, bitOrTest.getLineno());\n-      assertEquals(5, bitAndTest.getLineno());\n-      assertEquals(7, bitXorTest.getLineno());\n-      assertEquals(10, bitShiftTest.getLineno());\n+      assertEquals(3, bitOrTest.getLineno());\n+      assertEquals(6, bitAndTest.getLineno());\n+      assertEquals(8, bitXorTest.getLineno());\n+      assertEquals(11, bitShiftTest.getLineno());\n     }\n \n     public void testLinenoFunctionCall() {\n       AstNode bName = aDotbName.getRight();\n       FunctionNode fnNode = (FunctionNode) fnAssignment.getRight();\n \n-      assertEquals(1, fnAssignment.getLineno());\n+      assertEquals(2, fnAssignment.getLineno());\n       assertEquals(1, aDotbName.getLineno());\n       assertEquals(1, aName.getLineno());\n       assertEquals(2, bName.getLineno());\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n           transformTokenType(exprNode.getType()),\n           transform(exprNode.getLeft()),\n           transform(exprNode.getRight()));\n+      // Set the line number here so we can fine-tune it in ways transform\n+      // doesn't do.\n       n.setLineno(exprNode.getLineno());\n-      n.setCharno(position2charno(exprNode.getAbsolutePosition()));\n+      // Position in new ASTNode is to start of expression, but old-fashioned\n+      // line numbers from Node reference the operator token.  Add the offset\n+      // to the operator to get the correct character number.\n+      n.setCharno(position2charno(exprNode.getAbsolutePosition() +\n+          exprNode.getOperatorPosition()));\n       maybeSetLengthFrom(n, exprNode);\n       return n;\n     }\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n         \"var goog = {};\" +\n         \"/** @enum */goog.a=8;\",\n         Lists.newArrayList(\n+            \"enum initializer must be an object literal or an enum\",\n             \"assignment to property a of goog\\n\" +\n             \"found   : number\\n\" +\n-            \"required: enum{goog.a}\",\n-            \"enum initializer must be an object literal or an enum\"));\n+            \"required: enum{goog.a}\"));\n   }\n \n   public void testEnum10() throws Exception {\n                \"used in externs.\",\n                \"assignment to property innerHTML of Element\\n\" +\n                \"found   : Array\\n\" +\n-               \"required: string\"\n-               });\n+               \"required: string\"});\n   }\n \n   public void testNumberNode() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"var goog = {};\" +\n         \"/** @enum */goog.a=8;\",\n         Lists.newArrayList(\n+            \"enum initializer must be an object literal or an enum\",\n             \"assignment to property a of goog\\n\" +\n             \"found   : number\\n\" +\n-            \"required: enum{goog.a}\",\n-            \"enum initializer must be an object literal or an enum\"));\n+            \"required: enum{goog.a}\"));\n   }\n \n   public void testEnum10() throws Exception {\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n package com.google.javascript.jscomp.parsing;\n \n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.SourceFile;\n import com.google.javascript.jscomp.mozilla.rhino.CompilerEnvirons;\n import com.google.javascript.jscomp.mozilla.rhino.Parser;\n import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot;\n \n   public void testArrayLiteral2() throws Exception {\n     testNewParser(\"[a, , b]\",\n-      \"SCRIPT 1 [source_file: FileName.js] [length: 8]\\n\" +\n-      \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 8]\\n\" +\n-      \"        ARRAYLIT 1 [source_file: FileName.js] [length: 8]\\n\" +\n-      \"            NAME a 1 [source_file: FileName.js] [length: 1]\\n\" +\n-      \"            EMPTY 1 [source_file: FileName.js] [length: 1]\\n\" +\n-      \"            NAME b 1 [source_file: FileName.js] [length: 1]\\n\");\n+      \"SCRIPT 0 [length: 8]\\n\" +\n+      \"    EXPR_RESULT 0 [length: 8]\\n\" +\n+      \"        ARRAYLIT 0 [length: 8]\\n\" +\n+      \"            NAME a 0 [length: 1]\\n\" +\n+      \"            EMPTY 0 [length: 1]\\n\" +\n+      \"            NAME b 0 [length: 1]\\n\");\n   }\n \n   public void testArrayLiteral3() throws Exception {\n \n   public void testArrayLiteral4() throws Exception {\n     testNewParser(\"[,,,a,,b]\",\n-      \"SCRIPT 1 [source_file: FileName.js] [length: 9]\\n\" +\n-      \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 9]\\n\" +\n-      \"        ARRAYLIT 1 [source_file: FileName.js] [length: 9]\\n\" +\n-      \"            EMPTY 1 [source_file: FileName.js] [length: 1]\\n\" +\n-      \"            EMPTY 1 [source_file: FileName.js] [length: 1]\\n\" +\n-      \"            EMPTY 1 [source_file: FileName.js] [length: 1]\\n\" +\n-      \"            NAME a 1 [source_file: FileName.js] [length: 1]\\n\" +\n-      \"            EMPTY 1 [source_file: FileName.js] [length: 1]\\n\" +\n-      \"            NAME b 1 [source_file: FileName.js] [length: 1]\\n\");\n+      \"SCRIPT 0 [length: 9]\\n\" +\n+      \"    EXPR_RESULT 0 [length: 9]\\n\" +\n+      \"        ARRAYLIT 0 [length: 9]\\n\" +\n+      \"            EMPTY 0 [length: 1]\\n\" +\n+      \"            EMPTY 0 [length: 1]\\n\" +\n+      \"            EMPTY 0 [length: 1]\\n\" +\n+      \"            NAME a 0 [length: 1]\\n\" +\n+      \"            EMPTY 0 [length: 1]\\n\" +\n+      \"            NAME b 0 [length: 1]\\n\");\n   }\n \n   public void testAssignment() throws Exception {\n \n   public void testObjectLiteral6() {\n     testNewParser(\"({1: true})\",\n-      \"SCRIPT 1 [source_file: FileName.js] [length: 11]\\n\" +\n-      \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 10]\\n\" +\n-      \"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 9]\\n\" +\n-      \"            STRING 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n-      \"                TRUE 1 [source_file: FileName.js] [length: 4]\\n\");\n+      \"SCRIPT 0 [length: 11]\\n\" +\n+      \"    EXPR_RESULT 0 [length: 10]\\n\" +\n+      \"        OBJECTLIT 0 [parenthesized: true] [length: 9]\\n\" +\n+      \"            STRING 1 0 [quoted: 1] [length: 1]\\n\" +\n+      \"                TRUE 0 [length: 4]\\n\");\n   }\n \n   public void testObjectLiteral7() {\n     mode = LanguageMode.ECMASCRIPT5;\n \n     testNewParser(\"({get 1() {}})\",\n-        \"SCRIPT 1 [source_file: FileName.js] [length: 14]\\n\" +\n-        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 13]\\n\" +\n-        \"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 12]\\n\" +\n-        \"            GET 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n-        \"                FUNCTION  1 [source_file: FileName.js] [length: 6]\\n\" +\n-        \"                    NAME  1 [source_file: FileName.js]\\n\" +\n-        \"                    LP 1 [source_file: FileName.js]\\n\" +\n-        \"                    BLOCK 1 [source_file: FileName.js] [length: 2]\\n\");\n+        \"SCRIPT 0 [length: 14]\\n\" +\n+        \"    EXPR_RESULT 0 [length: 13]\\n\" +\n+        \"        OBJECTLIT 0 [parenthesized: true] [length: 12]\\n\" +\n+        \"            GET 1 0 [quoted: 1] [length: 1]\\n\" +\n+        \"                FUNCTION  0 [length: 6]\\n\" +\n+        \"                    NAME  0\\n\" +\n+        \"                    LP 0\\n\" +\n+        \"                    BLOCK 0 [length: 2]\\n\");\n   }\n \n   public void testObjectLiteral8() {\n     mode = LanguageMode.ECMASCRIPT5;\n \n     testNewParser(\"({set 1(a) {}})\",\n-        \"SCRIPT 1 [source_file: FileName.js] [length: 15]\\n\" +\n-        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\\n\" +\n-        \"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 13]\\n\" +\n-        \"            SET 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n-        \"                FUNCTION  1 [source_file: FileName.js] [length: 7]\\n\" +\n-        \"                    NAME  1 [source_file: FileName.js]\\n\" +\n-        \"                    LP 1 [source_file: FileName.js]\\n\" +\n-        \"                        NAME a 1 [source_file: FileName.js] [length: 1]\\n\" +\n-        \"                    BLOCK 1 [source_file: FileName.js] [length: 2]\\n\");\n+        \"SCRIPT 0 [length: 15]\\n\" +\n+        \"    EXPR_RESULT 0 [length: 14]\\n\" +\n+        \"        OBJECTLIT 0 [parenthesized: true] [length: 13]\\n\" +\n+        \"            SET 1 0 [quoted: 1] [length: 1]\\n\" +\n+        \"                FUNCTION  0 [length: 7]\\n\" +\n+        \"                    NAME  0\\n\" +\n+        \"                    LP 0\\n\" +\n+        \"                        NAME a 0 [length: 1]\\n\" +\n+        \"                    BLOCK 0 [length: 2]\\n\");\n   }\n \n \n   // named breaks and continues, so disable these tests.\n   public void testLabel() {\n     testNewParser(\"foo: bar\",\n-        \"SCRIPT 1 [source_file: FileName.js] [length: 8]\\n\" +\n-        \"    LABEL 1 [source_file: FileName.js] [length: 4]\\n\" +\n-        \"        LABEL_NAME foo 1 [source_file: FileName.js] [length: 4]\\n\" +\n-        \"        EXPR_RESULT 1 [source_file: FileName.js] [length: 3]\\n\" +\n-        \"            NAME bar 1 [source_file: FileName.js] [length: 3]\\n\");\n+        \"SCRIPT 0 [length: 8]\\n\" +\n+        \"    LABEL 0 [length: 4]\\n\" +\n+        \"        LABEL_NAME foo 0 [length: 4]\\n\" +\n+        \"        EXPR_RESULT 0 [length: 3]\\n\" +\n+        \"            NAME bar 0 [length: 3]\\n\");\n   }\n \n   public void testLabel2() {\n     testNewParser(\"l: while (f()) { if (g()) { continue l; } }\",\n-        \"SCRIPT 1 [source_file: FileName.js] [length: 43]\\n\" +\n-        \"    LABEL 1 [source_file: FileName.js] [length: 2]\\n\" +\n-        \"        LABEL_NAME l 1 [source_file: FileName.js] [length: 2]\\n\" +\n-        \"        WHILE 1 [source_file: FileName.js] [length: 40]\\n\" +\n-        \"            CALL 1 [source_file: FileName.js] [length: 3]\\n\" +\n-        \"                NAME f 1 [source_file: FileName.js] [length: 1]\\n\" +\n-        \"            BLOCK 1 [source_file: FileName.js] [length: 28]\\n\" +\n-        \"                IF 1 [source_file: FileName.js] [length: 24]\\n\" +\n-        \"                    CALL 1 [source_file: FileName.js] [length: 3]\\n\" +\n-        \"                        NAME g 1 [source_file: FileName.js] [length: 1]\\n\" +\n-        \"                    BLOCK 1 [source_file: FileName.js] [length: 15]\\n\" +\n-        \"                        CONTINUE 1 [source_file: FileName.js] [length: 11]\\n\" +\n-        \"                            LABEL_NAME l 1 [source_file: FileName.js] [length: 1]\\n\");\n+        \"SCRIPT 0 [length: 43]\\n\" +\n+        \"    LABEL 0 [length: 2]\\n\" +\n+        \"        LABEL_NAME l 0 [length: 2]\\n\" +\n+        \"        WHILE 0 [length: 40]\\n\" +\n+        \"            CALL 0 [length: 3]\\n\" +\n+        \"                NAME f 0 [length: 1]\\n\" +\n+        \"            BLOCK 0 [length: 28]\\n\" +\n+        \"                IF 0 [length: 24]\\n\" +\n+        \"                    CALL 0 [length: 3]\\n\" +\n+        \"                        NAME g 0 [length: 1]\\n\" +\n+        \"                    BLOCK 0 [length: 15]\\n\" +\n+        \"                        CONTINUE 0 [length: 11]\\n\" +\n+        \"                            LABEL_NAME l 0 [length: 1]\\n\");\n   }\n \n   public void testLabel3() {\n     testNewParser(\"Foo:Bar:X:{ break Bar; }\",\n-        \"SCRIPT 1 [source_file: FileName.js] [length: 24]\\n\" +\n-        \"    LABEL 1 [source_file: FileName.js] [length: 4]\\n\" +\n-        \"        LABEL_NAME Foo 1 [source_file: FileName.js] [length: 4]\\n\" +\n-        \"        LABEL 1 [source_file: FileName.js] [length: 4]\\n\" +\n-        \"            LABEL_NAME Bar 1 [source_file: FileName.js] [length: 4]\\n\" +\n-        \"            LABEL 1 [source_file: FileName.js] [length: 2]\\n\" +\n-        \"                LABEL_NAME X 1 [source_file: FileName.js] [length: 2]\\n\" +\n-        \"                BLOCK 1 [source_file: FileName.js] [length: 14]\\n\" +\n-        \"                    BREAK 1 [source_file: FileName.js] [length: 10]\\n\" +\n-        \"                        LABEL_NAME Bar 1 [source_file: FileName.js] [length: 3]\\n\");\n+        \"SCRIPT 0 [length: 24]\\n\" +\n+        \"    LABEL 0 [length: 4]\\n\" +\n+        \"        LABEL_NAME Foo 0 [length: 4]\\n\" +\n+        \"        LABEL 0 [length: 4]\\n\" +\n+        \"            LABEL_NAME Bar 0 [length: 4]\\n\" +\n+        \"            LABEL 0 [length: 2]\\n\" +\n+        \"                LABEL_NAME X 0 [length: 2]\\n\" +\n+        \"                BLOCK 0 [length: 14]\\n\" +\n+        \"                    BREAK 0 [length: 10]\\n\" +\n+        \"                        LABEL_NAME Bar 0 [length: 3]\\n\");\n   }\n \n   public void testNegation1() {\n     testNewParser(\"-a\",\n-        \"SCRIPT 1 [source_file: FileName.js] [length: 2]\\n\" +\n-        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 2]\\n\" +\n-        \"        NEG 1 [source_file: FileName.js] [length: 2]\\n\" +\n-        \"            NAME a 1 [source_file: FileName.js] [length: 1]\\n\");\n+        \"SCRIPT 0 [length: 2]\\n\" +\n+        \"    EXPR_RESULT 0 [length: 2]\\n\" +\n+        \"        NEG 0 [length: 2]\\n\" +\n+        \"            NAME a 0 [length: 1]\\n\");\n   }\n \n   public void testNegation2() {\n     testNewParser(\"-2\",\n-        \"SCRIPT 1 [source_file: FileName.js] [length: 2]\\n\" +\n-        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 2]\\n\" +\n-        \"        NUMBER -2.0 1 [source_file: FileName.js] [length: 1]\\n\");\n+        \"SCRIPT 0 [length: 2]\\n\" +\n+        \"    EXPR_RESULT 0 [length: 2]\\n\" +\n+        \"        NUMBER -2.0 0 [length: 1]\\n\");\n   }\n \n   public void testNegation3() {\n     testNewParser(\"1 - -2\",\n-        \"SCRIPT 1 [source_file: FileName.js] [length: 6]\\n\" +\n-        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 6]\\n\" +\n-        \"        SUB 1 [source_file: FileName.js] [length: 6]\\n\" +\n-        \"            NUMBER 1.0 1 [source_file: FileName.js] [length: 1]\\n\" +\n-        \"            NUMBER -2.0 1 [source_file: FileName.js] [length: 1]\\n\");\n+        \"SCRIPT 0 [length: 6]\\n\" +\n+        \"    EXPR_RESULT 0 [length: 6]\\n\" +\n+        \"        SUB 0 [length: 6]\\n\" +\n+        \"            NUMBER 1.0 0 [length: 1]\\n\" +\n+        \"            NUMBER -2.0 0 [length: 1]\\n\");\n   }\n \n   public void testGetter() {\n     mode = LanguageMode.ECMASCRIPT5;\n     testNewParser(\"({get a() {}})\",\n-        \"SCRIPT 1 [source_file: FileName.js] [length: 14]\\n\" +\n-        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 13]\\n\" +\n-        \"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 12]\\n\" +\n-        \"            GET a 1 [source_file: FileName.js] [length: 1]\\n\" +\n-        \"                FUNCTION  1 [source_file: FileName.js] [length: 6]\\n\" +\n-        \"                    NAME  1 [source_file: FileName.js]\\n\" +\n-        \"                    LP 1 [source_file: FileName.js]\\n\" +\n-        \"                    BLOCK 1 [source_file: FileName.js] [length: 2]\\n\");\n+        \"SCRIPT 0 [length: 14]\\n\" +\n+        \"    EXPR_RESULT 0 [length: 13]\\n\" +\n+        \"        OBJECTLIT 0 [parenthesized: true] [length: 12]\\n\" +\n+        \"            GET a 0 [length: 1]\\n\" +\n+        \"                FUNCTION  0 [length: 6]\\n\" +\n+        \"                    NAME  0\\n\" +\n+        \"                    LP 0\\n\" +\n+        \"                    BLOCK 0 [length: 2]\\n\");\n   }\n \n   public void testSetter() {\n     mode = LanguageMode.ECMASCRIPT5;\n     testNewParser(\"({set a(x) {}})\",\n-        \"SCRIPT 1 [source_file: FileName.js] [length: 15]\\n\" +\n-        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\\n\" +\n-        \"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 13]\\n\" +\n-        \"            SET a 1 [source_file: FileName.js] [length: 1]\\n\" +\n-        \"                FUNCTION  1 [source_file: FileName.js] [length: 7]\\n\" +\n-        \"                    NAME  1 [source_file: FileName.js]\\n\" +\n-        \"                    LP 1 [source_file: FileName.js]\\n\" +\n-        \"                        NAME x 1 [source_file: FileName.js] [length: 1]\\n\" +\n-        \"                    BLOCK 1 [source_file: FileName.js] [length: 2]\\n\");\n+        \"SCRIPT 0 [length: 15]\\n\" +\n+        \"    EXPR_RESULT 0 [length: 14]\\n\" +\n+        \"        OBJECTLIT 0 [parenthesized: true] [length: 13]\\n\" +\n+        \"            SET a 0 [length: 1]\\n\" +\n+        \"                FUNCTION  0 [length: 7]\\n\" +\n+        \"                    NAME  0\\n\" +\n+        \"                    LP 0\\n\" +\n+        \"                        NAME x 0 [length: 1]\\n\" +\n+        \"                    BLOCK 0 [length: 2]\\n\");\n   }\n \n   public void testSwitch() {\n         \"/** @param {string} x */function b(x) {}\");\n     Node a = root.getFirstChild();\n     Node b = root.getLastChild();\n-    assertMarkerPosition(a, 1, 4);\n-    assertMarkerPosition(b, 1, 45);\n+    assertMarkerPosition(a, 0, 4);\n+    assertMarkerPosition(b, 0, 45);\n   }\n \n   public void testCommentPositions2() {\n         \"\\n\" +\n         \"/**   @param {string} x */\\n\" +\n         \"function b(x) {};\");\n-    assertMarkerPosition(root.getFirstChild(), 4, 4);\n-    assertMarkerPosition(root.getFirstChild().getNext().getNext(), 11, 6);\n+    assertMarkerPosition(root.getFirstChild(), 3, 4);\n+    assertMarkerPosition(root.getFirstChild().getNext().getNext(), 10, 6);\n   }\n \n    public void testLiteralLocation() {\n     Node root = newParse(\n-        \"var d =\\n\" +\n+        \"\\nvar d =\\n\" +\n         \"    \\\"foo\\\";\\n\" +\n         \"var e =\\n\" +\n         \"    1;\\n\" +\n \n   public void testSwitchLocation() {\n     Node root = newParse(\n-        \"switch (a) {\\n\" +\n+        \"\\nswitch (a) {\\n\" +\n         \"  //{\\n\" +\n         \"   case 1:\\n\" +\n         \"     b++;\\n\" +\n \n   public void testFunctionParamLocation() {\n     Node root = newParse(\n-        \"function\\n\" +\n+        \"\\nfunction\\n\" +\n         \"     foo(a,\\n\" +\n         \"     b,\\n\" +\n         \"     c)\\n\" +\n \n   public void testVarDeclLocation() {\n     Node root = newParse(\n-        \"var\\n\" +\n+        \"\\nvar\\n\" +\n         \"    a =\\n\" +\n         \"    3\\n\");\n     Node varDecl = root.getFirstChild();\n \n   public void testReturnLocation() {\n     Node root = newParse(\n-        \"function\\n\" +\n+        \"\\nfunction\\n\" +\n         \"    foo(\\n\" +\n         \"    a,\\n\" +\n         \"    b,\\n\" +\n \n   public void testLinenoFor() {\n     Node root = newParse(\n-        \"for(\\n\" +\n+        \"\\nfor(\\n\" +\n         \";\\n\" +\n         \";\\n\" +\n         \") {\\n\" +\n \n   public void testBinaryExprLocation() {\n     Node root = newParse(\n-        \"var d = a\\n\" +\n+        \"\\nvar d = a\\n\" +\n         \"    + \\n\" +\n         \"    b;\\n\" +\n         \"var\\n\" +\n \n     assertNodePosition(1, 0, firstVarDecl);\n     assertNodePosition(1, 4, firstVar);\n-    assertNodePosition(1, 8, firstVarAdd);\n+    assertNodePosition(2, 4, firstVarAdd);\n     assertNodePosition(1, 8, firstVarAdd.getFirstChild());\n     assertNodePosition(3, 4, firstVarAdd.getLastChild());\n \n     assertNodePosition(4, 0, secondVarDecl);\n     assertNodePosition(5, 4, secondVar);\n-    assertNodePosition(6, 4, secondVarAdd);\n+    assertNodePosition(6, 6, secondVarAdd);\n     assertNodePosition(6, 4, secondVarAdd.getFirstChild());\n     assertNodePosition(7, 4, secondVarAdd.getLastChild());\n \n     assertNodePosition(8, 0, thirdVarDecl);\n     assertNodePosition(8, 4, thirdVar);\n-    assertNodePosition(8, 8, thirdVarAdd);\n+    assertNodePosition(9, 4, thirdVarAdd);\n     assertNodePosition(8, 8, thirdVarAdd.getFirstChild());\n     assertNodePosition(9, 6, thirdVarAdd.getLastChild());\n   }\n \n   public void testPrefixLocation() {\n     Node root = newParse(\n-         \"a++;\\n\" +\n+         \"\\na++;\\n\" +\n          \"--\\n\" +\n          \"b;\\n\");\n \n \n   public void testIfLocation() {\n     Node root = newParse(\n-        \"if\\n\" +\n+        \"\\nif\\n\" +\n         \"  (a == 3)\\n\" +\n         \"{\\n\" +\n         \"  b = 0;\\n\" +\n     Node elseClause = thenClause.getNext();\n \n     assertNodePosition(1, 0, ifStmt);\n-    assertNodePosition(2, 3, eqClause);\n+    assertNodePosition(2, 5, eqClause);\n     assertNodePosition(3, 0, thenClause);\n     assertNodePosition(7, 0, elseClause);\n   }\n \n   public void testTryLocation() {\n      Node root = newParse(\n-         \"try {\\n\" +\n+         \"\\ntry {\\n\" +\n          \"  var x = 1;\\n\" +\n          \"} catch\\n\" +\n          \"   (err)\\n\" +\n \n   public void testHookLocation() {\n     Node root = newParse(\n-        \"a\\n\" +\n+        \"\\na\\n\" +\n         \"?\\n\" +\n         \"b\\n\" +\n         \":\\n\" +\n \n   public void testLabelLocation() {\n     Node root = newParse(\n-        \"foo:\\n\" +\n+        \"\\nfoo:\\n\" +\n         \"a = 1;\\n\" +\n         \"bar:\\n\" +\n         \"b = 2;\\n\");\n \n   public void testCompareLocation() {\n     Node root = newParse(\n-        \"a\\n\" +\n+        \"\\na\\n\" +\n         \"<\\n\" +\n         \"b\\n\");\n \n     Node lhs = condClause.getFirstChild();\n     Node rhs = lhs.getNext();\n \n-    assertNodePosition(1, 0, condClause);\n+    assertNodePosition(2, 0, condClause);\n     assertNodePosition(1, 0, lhs);\n     assertNodePosition(3, 0, rhs);\n    }\n \n   public void testEqualityLocation() {\n     Node root = newParse(\n-        \"a\\n\" +\n+        \"\\na\\n\" +\n         \"==\\n\" +\n         \"b\\n\");\n \n     Node lhs = condClause.getFirstChild();\n     Node rhs = lhs.getNext();\n \n-    assertNodePosition(1, 0, condClause);\n+    assertNodePosition(2, 0, condClause);\n     assertNodePosition(1, 0, lhs);\n     assertNodePosition(3, 0, rhs);\n   }\n \n   public void testPlusEqLocation() {\n     Node root = newParse(\n-        \"a\\n\" +\n+        \"\\na\\n\" +\n         \"+=\\n\" +\n         \"b\\n\");\n \n     Node lhs = condClause.getFirstChild();\n     Node rhs = lhs.getNext();\n \n-    assertNodePosition(1, 0, condClause);\n+    assertNodePosition(2, 0, condClause);\n     assertNodePosition(1, 0, lhs);\n     assertNodePosition(3, 0, rhs);\n   }\n \n   public void testCommaLocation() {\n     Node root = newParse(\n-        \"a,\\n\" +\n+        \"\\na,\\n\" +\n         \"b,\\n\" +\n         \"c;\\n\");\n \n     Node aRef = comma2.getFirstChild();\n     Node bRef = aRef.getNext();\n \n-    assertNodePosition(1, 0, comma2);\n+    assertNodePosition(1, 1, comma2);\n     assertNodePosition(1, 0, aRef);\n     assertNodePosition(2, 0, bRef);\n     assertNodePosition(3, 0, cRef);\n \n   public void testRegexpLocation() {\n     Node root = newParse(\n-        \"var path =\\n\" +\n+        \"\\nvar path =\\n\" +\n         \"replace(\\n\" +\n         \"/a/g,\" +\n         \"'/');\\n\");\n \n   public void testNestedOr() {\n     Node root = newParse(\n-        \"if (a && \\n\" +\n+        \"\\nif (a && \\n\" +\n         \"    b() || \\n\" +\n         \"    /* comment */\\n\" +\n         \"    c) {\\n\" +\n     Node cName = andClause.getNext();\n \n     assertNodePosition(1, 0, ifStmt);\n-    assertNodePosition(1, 4, orClause);\n-    assertNodePosition(1, 4, andClause);\n+    assertNodePosition(2, 8, orClause);\n+    assertNodePosition(1, 6, andClause);\n     assertNodePosition(4, 4, cName);\n \n   }\n \n   public void testBitwiseOps() {\n       Node root = newParse(\n-        \"if (a & \\n\" +\n+        \"\\nif (a & \\n\" +\n         \"    b() | \\n\" +\n         \"    /* comment */\\n\" +\n         \"    c) {\\n\" +\n     Node cName = bitAnd.getNext();\n \n     assertNodePosition(1, 0, ifStmt);\n-    assertNodePosition(1, 4, bitOr);\n-    assertNodePosition(1, 4, bitAnd);\n+    assertNodePosition(2, 8, bitOr);\n+    assertNodePosition(1, 6, bitAnd);\n     assertNodePosition(4, 4, cName);\n \n   }\n \n   public void testObjectLitLocation() {\n     Node root = newParse(\n-        \"var foo =\\n\" +\n+        \"\\nvar foo =\\n\" +\n         \"{ \\n\" +\n         \"'A' : 'A', \\n\" +\n         \"'B' : 'B', \\n\" +\n \n   public void testTryWithoutCatchLocation() {\n      Node root = newParse(\n-         \"try {\\n\" +\n+         \"\\ntry {\\n\" +\n          \"  var x = 1;\\n\" +\n          \"} finally {\\n\" +\n          \"  var y = 2;\\n\" +\n \n   public void testTryWithoutFinallyLocation() {\n      Node root = newParse(\n-         \"try {\\n\" +\n+         \"\\ntry {\\n\" +\n          \"  var x = 1;\\n\" +\n          \"} catch (ex) {\\n\" +\n          \"  var y = 2;\\n\" +\n \n   public void testMultilineEqLocation() {\n     Node  root = newParse(\n-        \"if\\n\" +\n+        \"\\nif\\n\" +\n         \"    (((a == \\n\" +\n         \"  3) && \\n\" +\n         \"  (b == 2)) || \\n\" +\n     Node bTest = aTest.getNext();\n \n     assertNodePosition(1, 0, ifStmt);\n-    assertNodePosition(2, 7, orTest);\n-    assertNodePosition(2, 7, andTest);\n-    assertNodePosition(2, 7, aTest);\n-    assertNodePosition(4, 3, bTest);\n-    assertNodePosition(5, 2, cTest);\n+    assertNodePosition(4, 12, orTest);\n+    assertNodePosition(3, 5, andTest);\n+    assertNodePosition(2, 9, aTest);\n+    assertNodePosition(4, 5, bTest);\n+    assertNodePosition(5, 4, cTest);\n   }\n \n   public void testMultilineBitTestLocation() {\n     Node root = newParse(\n-        \"if (\\n\" +\n+        \"\\nif (\\n\" +\n         \"      ((a \\n\" +\n         \"        | 3 \\n\" +\n         \"       ) == \\n\" +\n \n     assertNodePosition(1, 0, ifStmt);\n \n-    assertNodePosition(2, 8, eqTest);\n-    assertNodePosition(7, 8, notEqTest);\n-\n-    assertNodePosition(2, 8, bitOrTest);\n-    assertNodePosition(5, 8, bitAndTest);\n-    assertNodePosition(7, 8, bitXorTest);\n-    assertNodePosition(10, 8, bitShiftTest);\n+    assertNodePosition(4, 9, eqTest);\n+    assertNodePosition(9, 7, notEqTest);\n+\n+    assertNodePosition(3, 8, bitOrTest);\n+    assertNodePosition(6, 8, bitAndTest);\n+    assertNodePosition(8, 9, bitXorTest);\n+    assertNodePosition(11, 8, bitShiftTest);\n   }\n \n   public void testCallLocation() {\n     Node root = newParse(\n-        \"a.\\n\" +\n+        \"\\na.\\n\" +\n         \"b.\\n\" +\n         \"cccc(1);\\n\");\n \n \n   public void testLinenoDeclaration() {\n     Node root = newParse(\n-        \"a.\\n\" +\n+        \"\\na.\\n\" +\n         \"b=\\n\" +\n         \"function() {};\\n\");\n \n     Node fnNode = aDotbName.getNext();\n     Node fnName = fnNode.getFirstChild();\n \n-    assertNodePosition(1, 0, fnAssignment);\n+    assertNodePosition(2, 1, fnAssignment);\n     // TODO(bowdidge) New Rhino doesn't keep track of the position of the dot.\n     //assertNodePosition(1, 1, aDotbName);\n     assertNodePosition(1, 0, aName);\n     environment.setRecordingLocalJsDocComments(true);\n \n     Parser p = new Parser(environment);\n-    AstRoot script = p.parse(string, null, 1);\n+    AstRoot script = p.parse(string, null, 0);\n \n     Config config = ParserRunner.createConfig(true, mode, false);\n     Node root = IRFactory.transformTree(\n-        script, SourceFile.fromCode(\"FileName.js\", string), string, config, errorReporter);\n+        script, null, string, config, errorReporter);\n \n     return root;\n   }\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n \n     assertEquals(Token.ASSIGN, assign.getType());\n     assertEquals(1, assign.getLineno());\n-    assertEquals(0, assign.getCharno());\n+    assertEquals(2, assign.getCharno());\n   }\n \n   public void testLinenoCharnoAssign2() throws Exception {\n \n     assertEquals(Token.ASSIGN, assign.getType());\n     assertEquals(2, assign.getLineno());\n-    assertEquals(1, assign.getCharno());\n+    assertEquals(12, assign.getCharno());\n   }\n \n   public void testLinenoCharnoCall() throws Exception {\n \n     assertEquals(Token.LT, lt.getType());\n     assertEquals(1, lt.getLineno());\n-    assertEquals(7, lt.getCharno());\n+    assertEquals(9, lt.getCharno());\n   }\n \n   public void testLinenoCharnoHook() throws Exception {\n         getFirstChild().getFirstChild();\n \n     assertEquals(1, op.getLineno());\n-    assertEquals(8, op.getCharno());\n+    assertEquals(11, op.getCharno());\n   }\n \n   public void testJSDocAttachment1() {", "timestamp": 1319117367, "metainfo": ""}