{"sha": "208aa65bee67c464bbe5b9bf5e6385b8a06a920f", "log": "Automated g4 rollback.  *** Reason for rollback ***  This doesn't work for Rhino classes where toString returns {java.lang.String|null}  Seems like we should make this change more conservatively, by doing this only in cases where the \"toString\" is called to append to a string literal or similiar.  *** Original change description ***  Transform toString() calls to string literal concatonation. (Helps string simplification in some cases)  R=nicksantos DELTA=25  (0 added, 17 deleted, 8 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4604   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n   private Node tryFoldSimpleFunctionCall(Node n) {\n     Preconditions.checkState(n.isCall());\n     Node callTarget = n.getFirstChild();\n-    Preconditions.checkNotNull(callTarget);\n-    if (callTarget.isName() && callTarget.getString().equals(\"String\")) {\n-      // Replace String(a) with ''+a - which allows further optimizations\n+    if (callTarget != null && callTarget.isName() &&\n+          callTarget.getString().equals(\"String\")) {\n+      // Fold String(a) to ''+(a) - which allows further optimizations\n       Node value = callTarget.getNext();\n-      if (value != null && value.getNext() == null) {\n-        Node replacement = IR.add(\n+      if (value != null) {\n+        Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n-        n.getParent().replaceChild(n, replacement);\n+        n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n-        return replacement;\n-      }\n-    } else if (n.hasOneChild() && NodeUtil.isObjectCallMethod(n, \"toString\")) {\n-      // Replace a.toString() with ''+a - which allows further optimizations\n-      Node value = callTarget.getFirstChild();\n-      Node replacement = IR.add(\n-          IR.string(\"\").srcref(callTarget),\n-          value.detachFromParent());\n-      n.getParent().replaceChild(n, replacement);\n-      reportCodeChange();\n-      return replacement;\n+        return addition;\n+      }\n     }\n     return n;\n   }\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n   public void testSimpleFunctionCall() {\n     test(\"var a = String(23)\", \"var a = '' + 23\");\n     test(\"var a = String('hello')\", \"var a = '' + 'hello'\");\n-    testSame(\"var a = String(23,45)\");\n-  }\n-\n-  public void testSimpleMethodCall() {\n-    test(\"var a = (23).toString()\", \"var a = '' + 23\");\n-    test(\"var a = ('hello').toString()\", \"var a = '' + 'hello'\");\n-    test(\"var a = (b).toString()\", \"var a = '' + b\");\n-    testSame(\"var a = (23).toString(45)\");\n   }\n \n   private static class StringCompareTestCase extends CompilerTestCase {", "timestamp": 1335212220, "metainfo": ""}