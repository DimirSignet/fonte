{"sha": "8b7e4f656bd5c067543681a721d9f69324ea7a10", "log": "Refactor CodingConvention to use a decorate-based api rather than a subclass-based api. Discourage people from subclassing DefaultCodingConvention by deleting it, and writing documentation that they should be subclassing CodingConventions.Proxy.  R=johnlenz DELTA=745  (478 added, 243 deleted, 24 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3399   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n       return this;\n     }\n \n-    private CodingConvention codingConvention = new DefaultCodingConvention();\n+    private CodingConvention codingConvention = CodingConventions.getDefault();\n \n     /**\n      * Sets rules and conventions to enforce.\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n+import com.google.javascript.jscomp.CodingConvention.Bind;\n+import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;\n+import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n+import com.google.javascript.jscomp.CodingConvention.SubclassType;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n  * This describes the Closure-specific JavaScript coding conventions.\n  *\n  */\n-public class ClosureCodingConvention extends DefaultCodingConvention {\n+public class ClosureCodingConvention extends CodingConventions.Proxy {\n \n   private static final long serialVersionUID = 1L;\n \n   static final DiagnosticType OBJECTLIT_EXPECTED = DiagnosticType.warning(\n       \"JSC_REFLECT_OBJECTLIT_EXPECTED\",\n       \"Object literal expected as second argument\");\n+\n+  public ClosureCodingConvention() {\n+    this(CodingConventions.getDefault());\n+  }\n+\n+  public ClosureCodingConvention(CodingConvention wrapped) {\n+    super(wrapped);\n+  }\n \n   /**\n    * Closure's goog.inherits adds a {@code superClass_} property to the\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n  * CodingConvention defines a set of hooks to customize the behavior of the\n  * Compiler for a specific team/company.\n  *\n- * // TODO(bolinfest): Tighten up this interface -- it is far too big.\n- *\n  */\n public interface CodingConvention extends Serializable {\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CodingConventions.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n+import com.google.javascript.jscomp.CodingConvention.Bind;\n+import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;\n+import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n+import com.google.javascript.jscomp.CodingConvention.SubclassType;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Helper classes for dealing with coding conventions.\n+ */\n+public class CodingConventions {\n+\n+  private CodingConventions() {}\n+\n+  /** Gets the default coding convention. */\n+  public static CodingConvention getDefault() {\n+    return new DefaultCodingConvention();\n+  }\n+\n+  /**\n+   * A convention that wraps another.\n+   *\n+   * When you want to support a new library, you should subclass this\n+   * delegate, and override the methods that you want to customize.\n+   *\n+   * This way, a person using jQuery and Closure Library can create a new\n+   * coding convention by creating a jQueryCodingConvention that delegates\n+   * to a ClosureCodingConvention that delegates to a DefaultCodingConvention.\n+   */\n+  public static class Proxy implements CodingConvention {\n+\n+    protected final CodingConvention nextConvention;\n+\n+    protected Proxy(CodingConvention convention) {\n+      this.nextConvention = convention;\n+    }\n+\n+    @Override\n+    public boolean isConstant(String variableName) {\n+      return nextConvention.isConstant(variableName);\n+    }\n+\n+    @Override public boolean isConstantKey(String keyName) {\n+      return nextConvention.isConstantKey(keyName);\n+    }\n+\n+    @Override\n+    public boolean isValidEnumKey(String key) {\n+      return nextConvention.isValidEnumKey(key);\n+    }\n+\n+    @Override\n+    public boolean isOptionalParameter(Node parameter) {\n+      return nextConvention.isOptionalParameter(parameter);\n+    }\n+\n+    @Override\n+    public boolean isVarArgsParameter(Node parameter) {\n+      return nextConvention.isVarArgsParameter(parameter);\n+    }\n+\n+    @Override\n+    public boolean isExported(String name, boolean local) {\n+      return nextConvention.isExported(name, local);\n+    }\n+\n+\n+    @Override\n+    public final boolean isExported(String name) {\n+      return isExported(name, false) || isExported(name, true);\n+    }\n+\n+    @Override\n+    public boolean isPrivate(String name) {\n+      return nextConvention.isPrivate(name);\n+    }\n+\n+    @Override\n+    public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n+      return nextConvention.getClassesDefinedByCall(callNode);\n+    }\n+\n+    @Override\n+    public boolean isSuperClassReference(String propertyName) {\n+      return nextConvention.isSuperClassReference(propertyName);\n+    }\n+\n+    @Override\n+    public String extractClassNameIfProvide(Node node, Node parent) {\n+      return nextConvention.extractClassNameIfProvide(node, parent);\n+    }\n+\n+    @Override\n+    public String extractClassNameIfRequire(Node node, Node parent) {\n+      return nextConvention.extractClassNameIfRequire(node, parent);\n+    }\n+\n+    @Override\n+    public String getExportPropertyFunction() {\n+      return nextConvention.getExportPropertyFunction();\n+    }\n+\n+    @Override\n+    public String getExportSymbolFunction() {\n+      return nextConvention.getExportSymbolFunction();\n+    }\n+\n+    @Override\n+    public List<String> identifyTypeDeclarationCall(Node n) {\n+      return nextConvention.identifyTypeDeclarationCall(n);\n+    }\n+\n+    @Override\n+    public void applySubclassRelationship(FunctionType parentCtor,\n+        FunctionType childCtor, SubclassType type) {\n+      nextConvention.applySubclassRelationship(\n+          parentCtor, childCtor, type);\n+    }\n+\n+    @Override\n+    public String getAbstractMethodName() {\n+      return nextConvention.getAbstractMethodName();\n+    }\n+\n+    @Override\n+    public String getSingletonGetterClassName(Node callNode) {\n+      return nextConvention.getSingletonGetterClassName(callNode);\n+    }\n+\n+    @Override\n+    public void applySingletonGetter(FunctionType functionType,\n+        FunctionType getterType, ObjectType objectType) {\n+      nextConvention.applySingletonGetter(\n+          functionType, getterType, objectType);\n+    }\n+\n+    @Override\n+    public DelegateRelationship getDelegateRelationship(Node callNode) {\n+      return nextConvention.getDelegateRelationship(callNode);\n+    }\n+\n+\n+    @Override\n+    public void applyDelegateRelationship(\n+        ObjectType delegateSuperclass, ObjectType delegateBase,\n+        ObjectType delegator, FunctionType delegateProxy,\n+        FunctionType findDelegate) {\n+      nextConvention.applyDelegateRelationship(\n+          delegateSuperclass, delegateBase, delegator,\n+          delegateProxy, findDelegate);\n+    }\n+\n+    @Override\n+    public String getDelegateSuperclassName() {\n+      return nextConvention.getDelegateSuperclassName();\n+    }\n+\n+    @Override\n+    public void checkForCallingConventionDefiningCalls(\n+        Node n, Map<String, String> delegateCallingConventions) {\n+      nextConvention.checkForCallingConventionDefiningCalls(\n+          n, delegateCallingConventions);\n+    }\n+\n+    @Override\n+    public void defineDelegateProxyPrototypeProperties(\n+        JSTypeRegistry registry, Scope scope,\n+        List<ObjectType> delegateProxyPrototypes,\n+        Map<String, String> delegateCallingConventions) {\n+      nextConvention.defineDelegateProxyPrototypeProperties(\n+          registry, scope, delegateProxyPrototypes, delegateCallingConventions);\n+    }\n+\n+    @Override\n+    public String getGlobalObject() {\n+      return nextConvention.getGlobalObject();\n+    }\n+\n+    @Override\n+    public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n+      return nextConvention.getAssertionFunctions();\n+    }\n+\n+    @Override\n+    public Bind describeFunctionBind(Node n) {\n+      return nextConvention.describeFunctionBind(n);\n+    }\n+\n+    @Override\n+    public boolean isPropertyTestFunction(Node call) {\n+      return nextConvention.isPropertyTestFunction(call);\n+    }\n+\n+    @Override\n+    public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n+        Node callNode) {\n+      return nextConvention.getObjectLiteralCast(t, callNode);\n+    }\n+  }\n+\n+\n+  /**\n+   * The default coding convention.\n+   * Should be at the bottom of all proxy chains.\n+   */\n+  private static class DefaultCodingConvention implements CodingConvention {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    @Override\n+    public boolean isConstant(String variableName) {\n+      return false;\n+    }\n+\n+    @Override\n+    public boolean isConstantKey(String variableName) {\n+      return false;\n+    }\n+\n+    @Override\n+    public boolean isValidEnumKey(String key) {\n+      return key != null && key.length() > 0;\n+    }\n+\n+    @Override\n+    public boolean isOptionalParameter(Node parameter) {\n+      // be as lax as possible, but this must be mutually exclusive from\n+      // var_args parameters.\n+      return !isVarArgsParameter(parameter);\n+    }\n+\n+    @Override\n+    public boolean isVarArgsParameter(Node parameter) {\n+      // be as lax as possible\n+      return parameter.getParent().getLastChild() == parameter;\n+    }\n+\n+    @Override\n+    public boolean isExported(String name, boolean local) {\n+      return local && name.startsWith(\"$super\");\n+    }\n+\n+    @Override\n+    public boolean isExported(String name) {\n+      return isExported(name, false) || isExported(name, true);\n+    }\n+\n+    @Override\n+    public boolean isPrivate(String name) {\n+      return false;\n+    }\n+\n+    @Override\n+    public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n+      return null;\n+    }\n+\n+    @Override\n+    public boolean isSuperClassReference(String propertyName) {\n+      return false;\n+    }\n+\n+    @Override\n+    public String extractClassNameIfProvide(Node node, Node parent) {\n+      String message = \"only implemented in GoogleCodingConvention\";\n+      throw new UnsupportedOperationException(message);\n+    }\n+\n+    @Override\n+    public String extractClassNameIfRequire(Node node, Node parent) {\n+      String message = \"only implemented in GoogleCodingConvention\";\n+      throw new UnsupportedOperationException(message);\n+    }\n+\n+    @Override\n+    public String getExportPropertyFunction() {\n+      return null;\n+    }\n+\n+    @Override\n+    public String getExportSymbolFunction() {\n+      return null;\n+    }\n+\n+    @Override\n+    public List<String> identifyTypeDeclarationCall(Node n) {\n+      return null;\n+    }\n+\n+    @Override\n+    public void applySubclassRelationship(FunctionType parentCtor,\n+        FunctionType childCtor, SubclassType type) {\n+      // do nothing\n+    }\n+\n+    @Override\n+    public String getAbstractMethodName() {\n+      return null;\n+    }\n+\n+    @Override\n+    public String getSingletonGetterClassName(Node callNode) {\n+      return null;\n+    }\n+\n+    @Override\n+    public void applySingletonGetter(FunctionType functionType,\n+        FunctionType getterType, ObjectType objectType) {\n+      // do nothing.\n+    }\n+\n+    @Override\n+    public DelegateRelationship getDelegateRelationship(Node callNode) {\n+      return null;\n+    }\n+\n+    @Override\n+    public void applyDelegateRelationship(\n+        ObjectType delegateSuperclass, ObjectType delegateBase,\n+        ObjectType delegator, FunctionType delegateProxy,\n+        FunctionType findDelegate) {\n+      // do nothing.\n+    }\n+\n+    @Override\n+    public String getDelegateSuperclassName() {\n+      return null;\n+    }\n+\n+    @Override\n+    public void checkForCallingConventionDefiningCalls(Node n,\n+        Map<String, String> delegateCallingConventions) {\n+      // do nothing.\n+    }\n+\n+    @Override\n+    public void defineDelegateProxyPrototypeProperties(\n+        JSTypeRegistry registry, Scope scope,\n+        List<ObjectType> delegateProxyPrototypes,\n+        Map<String, String> delegateCallingConventions) {\n+      // do nothing.\n+    }\n+\n+    @Override\n+    public String getGlobalObject() {\n+      return \"window\";\n+    }\n+\n+    @Override\n+    public boolean isPropertyTestFunction(Node call) {\n+      return false;\n+    }\n+\n+    @Override\n+    public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n+        Node callNode) {\n+      return null;\n+    }\n+\n+    @Override\n+    public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n+      return Collections.emptySet();\n+    }\n+\n+    @Override\n+    public Bind describeFunctionBind(Node n) {\n+      // It would be nice to be able to identify a fn.bind call\n+      // but that requires knowing the type of \"fn\".\n+\n+      if (n.getType() != Token.CALL) {\n+        return null;\n+      }\n+\n+      Node callTarget = n.getFirstChild();\n+      String name = callTarget.getQualifiedName();\n+      if (name != null) {\n+        if (name.equals(\"Function.prototype.bind.call\")) {\n+          // goog.bind(fn, self, args...);\n+          Node fn = callTarget.getNext();\n+          if (fn == null) {\n+            return null;\n+          }\n+          Node thisValue = safeNext(fn);\n+          Node parameters = safeNext(thisValue);\n+          return new Bind(fn, thisValue, parameters);\n+        }\n+      }\n+\n+      if (callTarget.getType() == Token.GETPROP\n+          && callTarget.getLastChild().getString().equals(\"bind\")\n+          && callTarget.getFirstChild().getType() == Token.FUNCTION) {\n+        // (function(){}).bind(self, args...);\n+        Node fn = callTarget.getFirstChild();\n+        Node thisValue = callTarget.getNext();\n+        Node parameters = safeNext(thisValue);\n+        return new Bind(fn, thisValue, parameters);\n+      }\n+\n+      return null;\n+    }\n+\n+    private Node safeNext(Node n) {\n+      if (n != null) {\n+        return n.getNext();\n+      }\n+      return null;\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n           .setCreateNameMapFiles(flags.create_name_map_files)\n           .setPropertyMapOutputFile(flags.property_map_output_file)\n           .setCodingConvention(flags.third_party ?\n-               new DefaultCodingConvention() :\n+               CodingConventions.getDefault() :\n                new ClosureCodingConvention())\n           .setSummaryDetailLevel(flags.summary_detail_level)\n           .setOutputWrapper(flags.output_wrapper)\n--- a/src/com/google/javascript/jscomp/GoogleCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/GoogleCodingConvention.java\n  * Within Google, variable names are semantically significant.\n  *\n  */\n-public class GoogleCodingConvention extends ClosureCodingConvention {\n+public class GoogleCodingConvention extends CodingConventions.Proxy {\n \n   private static final long serialVersionUID = 1L;\n \n \n   private static final Pattern ENUM_KEY_PATTERN =\n     Pattern.compile(\"[A-Z0-9][A-Z0-9_]*\");\n+\n+  /** By default, decorate the ClosureCodingConvention. */\n+  public GoogleCodingConvention() {\n+    this(new ClosureCodingConvention());\n+  }\n+\n+  /** Decorates a wrapped CodingConvention. */\n+  public GoogleCodingConvention(CodingConvention convention) {\n+    super(convention);\n+  }\n \n   /**\n    * {@inheritDoc}\n--- a/test/com/google/javascript/jscomp/DefaultCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/DefaultCodingConventionTest.java\n  * Test class for {@link DefaultCodingConvention}.\n  */\n public class DefaultCodingConventionTest extends TestCase {\n-  private DefaultCodingConvention conv = new DefaultCodingConvention();\n+  private CodingConvention conv = CodingConventions.getDefault();\n \n   public void testVarAndOptionalParams() {\n     Node args = new Node(Token.LP,\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n \n   public void testInitialTypingScope() {\n     Scope s = new TypedScopeCreator(compiler,\n-        new DefaultCodingConvention()).createInitialScope(\n+        CodingConventions.getDefault()).createInitialScope(\n             new Node(Token.BLOCK));\n \n     assertEquals(ARRAY_FUNCTION_TYPE, s.getVar(\"Array\").getType());\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n     if (useGoogleCodingConvention) {\n       return new GoogleCodingConvention();\n     } else {\n-      return new DefaultCodingConvention();\n+      return CodingConventions.getDefault();\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n   }\n \n   public void testFunctionWithDefaultCodingConvention() {\n-    convention = new DefaultCodingConvention();\n+    convention = CodingConventions.getDefault();\n     testSame(\"var foo = function(x) {}; foo(1, 2);\");\n     testSame(\"var foo = function(opt_x) {}; foo(1, 2);\");\n     testSame(\"var foo = function(var_args) {}; foo(1, 2);\");\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n \n   public void testInitialTypingScope() {\n     Scope s = new TypedScopeCreator(compiler,\n-        new DefaultCodingConvention()).createInitialScope(\n+        CodingConventions.getDefault()).createInitialScope(\n             new Node(Token.BLOCK));\n \n     assertEquals(ARRAY_FUNCTION_TYPE, s.getVar(\"Array\").getType());", "timestamp": 1317733681, "metainfo": ""}