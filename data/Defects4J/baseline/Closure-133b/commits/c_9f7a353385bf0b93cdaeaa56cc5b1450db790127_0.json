{"sha": "9f7a353385bf0b93cdaeaa56cc5b1450db790127", "log": "Fix parts of issue 635, mostly by deleting hacks that are now obsolete  R=dimvar DELTA=6185  (2271 added, 2886 deleted, 1028 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5763   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n       JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n-      if (bothIntrinsics(rightType, leftType)) {\n-        // We have a superior warning for this mistake, which gives you\n-        // the line numbers of both types.\n-        registerMismatch(rightType, leftType, null);\n-      } else {\n-        // Do not type-check interface methods, because we expect that\n-        // they will have dummy implementations that do not match the type\n-        // annotations.\n-        JSType ownerType = getJSType(owner);\n-        if (ownerType.isFunctionPrototypeType()) {\n-          FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n-          if (ownerFn.isInterface() &&\n-              rightType.isFunctionType() && leftType.isFunctionType()) {\n-            return true;\n-          }\n+      // Do not type-check interface methods, because we expect that\n+      // they will have dummy implementations that do not match the type\n+      // annotations.\n+      JSType ownerType = getJSType(owner);\n+      if (ownerType.isFunctionPrototypeType()) {\n+        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n+        if (ownerFn.isInterface() &&\n+            rightType.isFunctionType() && leftType.isFunctionType()) {\n+          return true;\n         }\n-\n-        mismatch(t, n,\n-            \"assignment to property \" + propName + \" of \" +\n-            getReadableJSTypeName(owner, true),\n-            rightType, leftType);\n-      }\n+      }\n+\n+      mismatch(t, n,\n+          \"assignment to property \" + propName + \" of \" +\n+          getReadableJSTypeName(owner, true),\n+          rightType, leftType);\n       return false;\n     }\n     return true;\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n-      if (bothIntrinsics(rightType, leftType)) {\n-        // We have a superior warning for this mistake, which gives you\n-        // the line numbers of both types.\n-        registerMismatch(rightType, leftType, null);\n-      } else {\n-        mismatch(t, n, msg, rightType, leftType);\n-      }\n+      mismatch(t, n, msg, rightType, leftType);\n       return false;\n     }\n     return true;\n-  }\n-\n-  private boolean bothIntrinsics(JSType rightType, JSType leftType) {\n-    return (leftType.isConstructor() || leftType.isEnumType()) &&\n-        (rightType.isConstructor() || rightType.isEnumType());\n   }\n \n   /**\n       }\n \n       registerIfMismatch(\n-        fnTypeA.getReturnType(), fnTypeB.getReturnType(), error);\n+          fnTypeA.getReturnType(), fnTypeB.getReturnType(), error);\n     }\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n         // An interface function cannot be assigned to anything.\n         return false;\n       }\n+\n       // If functionA is a subtype of functionB, then their \"this\" types\n       // should be contravariant. However, this causes problems because\n       // of the way we enforce overrides. Because function(this:SubFoo)\n       // is not a subtype of function(this:Foo), our override check treats\n-      // this as an error. It also screws up out standard method\n-      // for aliasing constructors. Let's punt on all this for now.\n+      // this as an error. Let's punt on all this for now.\n       // TODO(nicksantos): fix this.\n       boolean treatThisTypesAsCovariant =\n-        // If either one of these is a ctor, skip 'this' checking.\n-        isConstructor() || other.isConstructor() ||\n-\n         // An interface 'this'-type is non-restrictive.\n         // In practical terms, if C implements I, and I has a method m,\n         // then any m doesn't necessarily have to C#m's 'this'\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n \n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\n \n import java.util.Arrays;\n import java.util.List;\n+import java.util.Set;\n \n /**\n  * Tests {@link TypeCheck}.\n   }\n \n   public void testTypeRedefinition() throws Exception {\n-    testTypes(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n+    testClosureTypesMultipleWarnings(\n+        \"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n         + \"/** @constructor */ a.A = function() {}\",\n-        \"variable a.A redefined with type function (new:a.A): undefined, \" +\n-        \"original definition at [testcode]:1 with type enum{a.A}\");\n+        Lists.newArrayList(\n+            \"variable a.A redefined with type function (new:a.A): undefined, \" +\n+            \"original definition at [testcode]:1 with type enum{a.A}\",\n+            \"assignment to property A of a\\n\" +\n+            \"found   : function (new:a.A): undefined\\n\" +\n+            \"required: enum{a.A}\"));\n   }\n \n   public void testIn1() throws Exception {\n           0, compiler.getWarningCount());\n     } else {\n       assertEquals(descriptions.size(), compiler.getWarningCount());\n+      Set<String> actualWarningDescriptions = Sets.newHashSet();\n       for (int i = 0; i < descriptions.size(); i++) {\n-        assertEquals(descriptions.get(i),\n-            compiler.getWarnings()[i].description);\n+        actualWarningDescriptions.add(compiler.getWarnings()[i].description);\n       }\n+      assertEquals(\n+          Sets.newHashSet(descriptions), actualWarningDescriptions);\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n \n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\n import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n \n import java.util.Arrays;\n import java.util.List;\n+import java.util.Set;\n \n /**\n  * Tests {@link TypeCheck}.\n   }\n \n   public void testTypeRedefinition() throws Exception {\n-    testTypes(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n+    testClosureTypesMultipleWarnings(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n         + \"/** @constructor */ a.A = function() {}\",\n-        \"variable a.A redefined with type function (new:a.A): undefined, \" +\n-        \"original definition at [testcode]:1 with type enum{a.A}\");\n+        Lists.newArrayList(\n+            \"variable a.A redefined with type function (new:a.A): undefined, \" +\n+            \"original definition at [testcode]:1 with type enum{a.A}\",\n+            \"assignment to property A of a\\n\" +\n+            \"found   : function (new:a.A): undefined\\n\" +\n+            \"required: enum{a.A}\"));\n   }\n \n   public void testIn1() throws Exception {\n         \"/** @constructor */\" +\n         \"function G() {}\" +\n         \"G.prototype.bar = F.prototype.bar;\");\n+  }\n+\n+  public void testIssue635b() throws Exception {\n+    testTypes(\n+        \"/** @constructor */\" +\n+        \"function F() {}\" +\n+        \"/** @constructor */\" +\n+        \"function G() {}\" +\n+        \"/** @type {function(new:G)} */ var x = F;\",\n+        \"initializing variable\\n\" +\n+        \"found   : function (new:F): undefined\\n\" +\n+        \"required: function (new:G): ?\");\n   }\n \n   public void testIssue669() throws Exception {\n           \"unexpected warning(s) : \" +\n           Joiner.on(\", \").join(compiler.getWarnings()),\n           descriptions.size(), compiler.getWarningCount());\n+      Set<String> actualWarningDescriptions = Sets.newHashSet();\n       for (int i = 0; i < descriptions.size(); i++) {\n-        assertEquals(descriptions.get(i),\n-            compiler.getWarnings()[i].description);\n+        actualWarningDescriptions.add(compiler.getWarnings()[i].description);\n       }\n+      assertEquals(\n+          Sets.newHashSet(descriptions), actualWarningDescriptions);\n     }\n   }\n ", "timestamp": 1352316617, "metainfo": ""}