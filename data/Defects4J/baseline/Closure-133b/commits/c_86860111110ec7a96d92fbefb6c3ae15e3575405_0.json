{"sha": "86860111110ec7a96d92fbefb6c3ae15e3575405", "log": "Fix up the inheritance hierarchy so that \"Foo implements Bar\" implies that Bar.prototype is the implicit prototype of Foo.prototoype.    ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.jstype.ObjectType;\n+\n+import java.util.List;\n+import java.util.Set;\n \n /**\n  * Represents the prototype of a {@link FunctionType}.\n   public FunctionType getOwnerFunction() {\n     return ownerFunction;\n   }\n+\n+  @Override\n+  Iterable<ObjectType> getCtorImplementedInterfaces() {\n+    return getOwnerFunction().getImplementedInterfaces();\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n package com.google.javascript.rhino.jstype;\n \n import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n+\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n-\n \n /**\n  * This derived type provides extended information about a function, including\n \n   /** Returns interfaces implemented directly by a class or its superclass. */\n   public Iterable<ObjectType> getImplementedInterfaces() {\n-    return implementedInterfaces;\n+    FunctionType superCtor = isConstructor() ?\n+        getSuperClassConstructor() : null;\n+    if (superCtor == null) {\n+      return implementedInterfaces;\n+    } else {\n+      return Iterables.concat(\n+          implementedInterfaces, superCtor.getImplementedInterfaces());\n+    }\n   }\n \n   public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) {\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n import com.google.common.base.Preconditions;\n \n import java.util.List;\n-\n+import java.util.Set;\n \n /**\n  * An object type that is an instance of some function constructor.\n   }\n \n   @Override\n-  public boolean isSubtype(JSType that) {\n-    if (super.isSubtype(that)) {\n-      return true;\n-    }\n-    Iterable<ObjectType> thisInterfaces =\n-        getConstructor().getImplementedInterfaces();\n-    if (thisInterfaces != null) {\n-      List<ObjectType> thatInterfaces = that.keepAssignableInterfaces();\n-      for (ObjectType thatInterface : thatInterfaces) {\n-        for (ObjectType thisInterface : thisInterfaces) {\n-          if (thisInterface.isSubtype(thatInterface)) {\n-            return true;\n-          }\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-\n-  @Override\n   public boolean equals(Object that) {\n     if (this == that) {\n       return true;\n       return super.hashCode();\n     }\n   }\n+\n+  @Override\n+  Iterable<ObjectType> getCtorImplementedInterfaces() {\n+    return getConstructor().getImplementedInterfaces();\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n   }\n \n   /**\n-   * Computes the list of interfaces that can be assigned to this type.\n-   * @return A list of interface types (may contain duplicates).\n-   */\n-  List<ObjectType> keepAssignableInterfaces() {\n-    return visit(keepAssignableInterfacesVisitor);\n-  }\n-\n-  /**\n-   * @see #keepAssignableInterfaces()\n-   */\n-  private static final Visitor<List<ObjectType>>\n-      keepAssignableInterfacesVisitor =\n-      new Visitor<List<ObjectType>>() {\n-        public List<ObjectType> caseEnumElementType(EnumElementType type) {\n-          return ImmutableList.of();\n-        }\n-\n-        public List<ObjectType> caseAllType() {\n-          return ImmutableList.of();\n-        }\n-\n-        public List<ObjectType> caseNoObjectType() {\n-          return ImmutableList.of();\n-        }\n-\n-        public List<ObjectType> caseNoType() {\n-          return ImmutableList.of();\n-        }\n-\n-        public List<ObjectType> caseBooleanType() {\n-          return ImmutableList.of();\n-        }\n-\n-        public List<ObjectType> caseFunctionType(FunctionType type) {\n-          return ImmutableList.of();\n-        }\n-\n-        public List<ObjectType> caseNullType() {\n-          return ImmutableList.of();\n-        }\n-\n-        public List<ObjectType> caseNumberType() {\n-          return ImmutableList.of();\n-        }\n-\n-        public List<ObjectType> caseObjectType(ObjectType type) {\n-          if (type.getConstructor() != null &&\n-              type.getConstructor().isInterface()) {\n-            return ImmutableList.of(type);\n-          } else {\n-            return ImmutableList.of();\n-          }\n-        }\n-\n-        public List<ObjectType> caseStringType() {\n-          return ImmutableList.of();\n-        }\n-\n-        public List<ObjectType> caseUnionType(UnionType type) {\n-          List<ObjectType> lst = Lists.newArrayList();\n-          for (JSType alternate : type.getAlternates()) {\n-            lst.addAll(alternate.keepAssignableInterfaces());\n-          }\n-          return lst;\n-        }\n-\n-        public List<ObjectType> caseUnknownType() {\n-          return ImmutableList.of();\n-        }\n-\n-        public List<ObjectType> caseVoidType() {\n-          return ImmutableList.of();\n-        }\n-      };\n-\n-  /**\n    * Visit this type with the given visitor.\n    * @see com.google.javascript.rhino.jstype.Visitor\n    * @return the value returned by the visitor\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Sets;\n-\n import com.google.javascript.rhino.JSDocInfo;\n \n import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n \n /**\n   public static ObjectType cast(JSType type) {\n     return type == null ? null : type.toObjectType();\n   }\n+\n+  /**\n+   * Gets the interfaces implemented by the ctor associated with this type.\n+   * Intended to be overridden by subclasses.\n+   */\n+  Iterable<ObjectType> getCtorImplementedInterfaces() {\n+    return ImmutableSet.of();\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n import com.google.javascript.rhino.JSDocInfo;\n \n import java.io.Serializable;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n \n /**\n  * The object type represents instances of JavaScript objects such as\n     if (JSType.isSubtype(this, that)) {\n       return true;\n     }\n+\n+    // Union types\n+    if (that instanceof UnionType) {\n+      // The static {@code JSType.isSubtype} check already decomposed\n+      // union types, so we don't need to check those again.\n+      return false;\n+    }\n+\n     // record types\n     if (that instanceof RecordType) {\n       return RecordType.isSubtype(this, (RecordType) that);\n     }\n-    // prototype based objects\n-    ObjectType thatObj = ObjectType.cast(that);\n+\n+    // Interfaces\n+    // Find all the interfaces implemented by this class and compare each one\n+    // to the interface instance.\n+    ObjectType thatObj = that.toObjectType();\n+    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n+    if (thatCtor != null && thatCtor.isInterface()) {\n+      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n+      for (ObjectType thisInterface : thisInterfaces) {\n+        if (thisInterface.isSubtype(that)) {\n+          return true;\n+        }\n+      }\n+    }\n+\n+    // other prototype based objects\n     if (that != null) {\n       if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n         // If unsure, say 'yes', to avoid spurious warnings.\n       }\n       return this.isImplicitPrototype(thatObj);\n     }\n+\n     return false;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n \n import com.google.javascript.rhino.JSDocInfo;\n \n+import java.util.List;\n import java.util.Set;\n \n /**\n   @Override\n   public boolean isSubtype(JSType that) {\n     return referencedType.isSubtype(that);\n+  }\n+\n+  @Override\n+  Iterable<ObjectType> getCtorImplementedInterfaces() {\n+    return referencedType.getCtorImplementedInterfaces();\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"assignment to property y of x\\n\" +\n         \"found   : number\\n\" +\n         \"required: string\");\n+  }\n+\n+  public void testBug2341812() throws Exception {\n+    testTypes(\n+        \"/** @interface */\" +\n+        \"function EventTarget() {}\" +\n+        \"/** @constructor \\n * @implements {EventTarget} */\" +\n+        \"function Node() {}\" +\n+        \"/** @type {number} */ Node.prototype.index;\" +\n+        \"/** @param {EventTarget} x \\n * @return {string} */\" +\n+        \"function foo(x) { return x.index; }\");\n   }\n \n   public void testScopedConstructors() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n   private ObjectType subclassOfUnresolvedNamedType;\n   private FunctionType subclassCtor;\n   private FunctionType interfaceType;\n+  private ObjectType interfaceInstType;\n   private JSType recordType;\n   private EnumType enumType;\n   private EnumElementType elementsType;\n     subclassOfUnresolvedNamedType = subclassCtor.getInstanceType();\n \n     interfaceType = new FunctionType(registry, \"Interface\", null);\n+    interfaceInstType = interfaceType.getInstanceType();\n \n     googBar = registry.createConstructorType(\"goog.Bar\", null, null, null);\n     googBar.getPrototype().defineDeclaredProperty(\"date\", DATE_TYPE, true);\n     googBar.setImplementedInterfaces(\n-        Lists.<ObjectType>newArrayList(interfaceType.getInstanceType()));\n+        Lists.<ObjectType>newArrayList(interfaceInstType));\n     googBarInst = googBar.getInstanceType();\n \n     googSubBar = registry.createConstructorType(\n     verifySubtypeChain(typeChain, false);\n   }\n \n+  public void testInterfaceInstanceSubtypeChain() throws Exception {\n+    List<JSType> typeChain = Lists.newArrayList(\n+        ALL_TYPE,\n+        OBJECT_TYPE,\n+        interfaceInstType,\n+        googBar.getPrototype(),\n+        googBarInst,\n+        googSubBar.getPrototype(),\n+        googSubBarInst,\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n   /**\n    * Tests that the given chain of types has a total ordering defined\n    * by the subtype relationship, with types at the top of the lattice", "timestamp": 1262876890, "metainfo": ""}