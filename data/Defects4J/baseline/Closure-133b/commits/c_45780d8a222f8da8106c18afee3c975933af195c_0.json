{"sha": "45780d8a222f8da8106c18afee3c975933af195c", "log": "create a generic mechanism for injecting compile-time libraries  R=johnlenz DELTA=194  (136 added, 36 deleted, 22 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4338   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n \n   /** Sets the progress to a certain value in [0,1] range. */\n   abstract void setProgress(double progress);\n+\n+  /**\n+   * The subdir js/ contains libraries of code that we inject\n+   * at compile-time only if requested by this function.\n+   *\n+   * Notice that these libraries will almost always create global symbols.\n+   *\n+   * @param resourceName The name of the library. For example, if \"base\" is\n+   *     is specified, then we load js/base.js\n+   * @return If new code was injected, returns the last expression node of the\n+   *     library. If the caller needs to add additional code, they should add\n+   *     it as the next sibling of this node. If new code was not injected,\n+   *     returns null.\n+   */\n+  abstract Node ensureLibraryInjected(String resourceName);\n }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n package com.google.javascript.jscomp;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Charsets;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n import com.google.common.base.Throwables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.io.CharStreams;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n import java.io.IOException;\n+import java.io.InputStreamReader;\n import java.io.PrintStream;\n import java.io.Serializable;\n import java.nio.charset.Charset;\n \n   // Warnings guard for filtering warnings.\n   private WarningsGuard warningsGuard;\n+\n+  // Compile-time injected libraries. The node points to the last node of\n+  // the library, so code can be inserted after.\n+  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n \n   // Parse tree root nodes\n   Node externsRoot;\n     private PassConfig.State passConfigState;\n     private JSTypeRegistry typeRegistry;\n     private AbstractCompiler.LifeCycleStage lifeCycleStage;\n+    private Map<String, Node> injectedLibraries;\n \n     private IntermediateState() {}\n   }\n     state.passConfigState = getPassConfig().getIntermediateState();\n     state.typeRegistry = typeRegistry;\n     state.lifeCycleStage = getLifeCycleStage();\n+    state.injectedLibraries = Maps.newLinkedHashMap(injectedLibraries);\n \n     return state;\n   }\n     getPassConfig().setIntermediateState(state.passConfigState);\n     typeRegistry = state.typeRegistry;\n     setLifeCycleStage(state.lifeCycleStage);\n+\n+    injectedLibraries.clear();\n+    injectedLibraries.putAll(state.injectedLibraries);\n   }\n \n   @VisibleForTesting\n     removeExternInput(new InputId(sourceName));\n   }\n \n+  @Override\n+  Node ensureLibraryInjected(String resourceName) {\n+    if (injectedLibraries.containsKey(resourceName)) {\n+      return null;\n+    }\n+\n+    // All libraries depend on js/base.js\n+    boolean isBase = \"base\".equals(resourceName);\n+    if (!isBase) {\n+      ensureLibraryInjected(\"base\");\n+    }\n+\n+    Node firstChild = loadLibraryCode(resourceName).removeChildren();\n+    Node lastChild = firstChild.getLastSibling();\n+\n+    Node parent = getNodeForCodeInsertion(null);\n+    if (isBase) {\n+      parent.addChildrenToFront(firstChild);\n+    } else {\n+      parent.addChildrenAfter(\n+          firstChild, injectedLibraries.get(\"base\"));\n+    }\n+    reportCodeChange();\n+\n+    injectedLibraries.put(resourceName, lastChild);\n+    return lastChild;\n+  }\n+\n+  /** Load a library as a resource */\n+  @VisibleForTesting\n+  Node loadLibraryCode(String resourceName) {\n+    String originalCode;\n+    try {\n+      originalCode = CharStreams.toString(new InputStreamReader(\n+          Compiler.class.getResourceAsStream(\n+              String.format(\"js/%s.js\", resourceName)),\n+          Charsets.UTF_8));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    return Normalize.parseAndNormalizeSyntheticCode(\n+        this, originalCode,\n+        String.format(\"jscomp_%s_\", resourceName));\n+  }\n }\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Charsets;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Sets;\n-import com.google.common.io.CharStreams;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n-import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.util.Collection;\n import java.util.Comparator;\n import java.util.TreeSet;\n   }\n \n   private void addBoilerplateCode() {\n-    Node js = getBoilerplateCode(compiler, logFunction);\n-    compiler.getNodeForCodeInsertion(null).addChildrenToFront(\n-        js.removeChildren());\n-    compiler.reportCodeChange();\n+    Node newNode = compiler.ensureLibraryInjected(\"runtime_type_check\");\n+    if (newNode != null && logFunction != null) {\n+      // Inject the custom log function.\n+      Node logOverride = IR.exprResult(\n+          IR.assign(\n+              NodeUtil.newQualifiedNameNode(\n+                  compiler.getCodingConvention(),\n+                  \"jscomp.typecheck.log\"),\n+              NodeUtil.newQualifiedNameNode(\n+                  compiler.getCodingConvention(),\n+                  logFunction)));\n+      newNode.getParent().addChildAfter(logOverride, newNode);\n+      compiler.reportCodeChange();\n+    }\n   }\n \n   private Node jsCode(String prop) {\n     return NodeUtil.newQualifiedNameNode(\n         compiler.getCodingConvention(), \"jscomp.typecheck.\" + prop);\n   }\n-\n-  @VisibleForTesting\n-  static Node getBoilerplateCode(\n-      AbstractCompiler compiler, @Nullable String logFunction) {\n-    String boilerplateCode;\n-    try {\n-      boilerplateCode = CharStreams.toString(new InputStreamReader(\n-          RuntimeTypeCheck.class.getResourceAsStream(\n-          \"js/runtime_type_check.js\"), Charsets.UTF_8));\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-\n-    boilerplateCode = boilerplateCode.replace(\"%%LOG%%\",\n-        logFunction == null ? \"function(warning, expr) {}\" : logFunction);\n-\n-    return Normalize.parseAndNormalizeSyntheticCode(\n-        compiler, boilerplateCode, \"jscomp_runtimeTypeCheck_\");\n-  }\n }\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n   }\n \n   public void addChildrenToBack(Node children) {\n-    for (Node child = children; child != null; child = child.next) {\n-      Preconditions.checkArgument(child.parent == null);\n-      child.parent = this;\n-    }\n-    if (last != null) {\n-      last.next = children;\n-    }\n-    last = children.getLastSibling();\n-    if (first == null) {\n-      first = children;\n-    }\n+    addChildrenAfter(children, getLastChild());\n   }\n \n   /**\n    * Add 'child' before 'node'.\n    */\n   public void addChildBefore(Node newChild, Node node) {\n-    Preconditions.checkArgument(node != null,\n+    Preconditions.checkArgument(node != null && node.parent == this,\n         \"The existing child node of the parent should not be null.\");\n     Preconditions.checkArgument(newChild.next == null,\n         \"The new child node has siblings.\");\n   public void addChildAfter(Node newChild, Node node) {\n     Preconditions.checkArgument(newChild.next == null,\n         \"The new child node has siblings.\");\n-    Preconditions.checkArgument(newChild.parent == null,\n-        \"The new child node already has a parent.\");\n-    newChild.parent = this;\n-    newChild.next = node.next;\n-    node.next = newChild;\n-    if (last == node) {\n-        last = newChild;\n+    addChildrenAfter(newChild, node);\n+  }\n+\n+  /**\n+   * Add all children after 'node'.\n+   */\n+  public void addChildrenAfter(Node children, Node node) {\n+    Preconditions.checkArgument(node == null || node.parent == this);\n+    for (Node child = children; child != null; child = child.next) {\n+      Preconditions.checkArgument(child.parent == null);\n+      child.parent = this;\n+    }\n+\n+    Node lastSibling = children.getLastSibling();\n+    if (node != null) {\n+      Node oldNext = node.next;\n+      node.next = children;\n+      lastSibling.next = oldNext;\n+      if (node == last) {\n+        last = lastSibling;\n+      }\n+    } else {\n+      // Append to the beginning.\n+      if (first != null) {\n+        lastSibling.next = first;\n+      } else {\n+        last = lastSibling;\n+      }\n+      first = children;\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n     compiler.init(Lists.<SourceFile>newArrayList(),\n                   Lists.<SourceFile>newArrayList(),\n                   new CompilerOptions());\n-    Node boilerplateCode =\n-        RuntimeTypeCheck.getBoilerplateCode(compiler, null);\n-    test(js, compiler.toSource(boilerplateCode) + \";\" + expected);\n+    Node base = compiler.loadLibraryCode(\"base\");\n+    Node typeCheck = compiler.loadLibraryCode(\"runtime_type_check\");\n+    test(js,\n+         compiler.toSource(base) + \";\"\n+         + compiler.toSource(typeCheck) + \";\"\n+         + expected);\n   }\n \n   @Override", "timestamp": 1331266614, "metainfo": ""}