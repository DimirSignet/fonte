{"sha": "4d76dedc8b1d33060a9164c6ec38193d1e69502c", "log": "Clean up a bunch of code warnings that are visible in eclipse.  R=acleung DELTA=99 (38 added, 29 deleted, 32 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6055   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import java.util.Map.Entry;\n import java.util.Set;\n import java.util.logging.Level;\n \n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n   abstract Node ensureLibraryInjected(String resourceName);\n \n    /**\n-    * Stores the old parse tree for a given source file.\n-    * @param sourceName\n-    * @param astRoot\n+    * Stores the \"new\" Rhino parse tree for a given source file.\n+    * @param sourceName The source file name.\n+    * @param astRoot The \"new\" Rhino parse tree.\n     */\n    abstract void setOldParseTree(String sourceName, AstRoot astRoot);\n \n    /**\n     * Gets an old format parse tree for a given source file.\n     * @param sourceName The source file name to get the tree for.\n-    * @return The old format parse tree for the given source file.\n+    * @return The \"new\" Rhino parse tree for the given source file.\n     */\n    abstract AstRoot getOldParseTreeByName(String sourceName);\n }\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n         options.disambiguateProperties = true;\n         options.ambiguateProperties = true;\n         options.inlineProperties = true;\n-        // TODO(johnlenz) :removeUnusedClassProperties isn't strictly a \n-        // type based pass, but add it here for now because I may have to \n+        // TODO(johnlenz) :removeUnusedClassProperties isn't strictly a\n+        // type based pass, but add it here for now because I may have to\n         // make it into one.\n         options.removeUnusedClassProperties = true;\n         break;\n       case SIMPLE_OPTIMIZATIONS:\n         // TODO(johnlenz): enable peephole type based optimization.\n         break;\n+      case WHITESPACE_ONLY:\n+        break;\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   /**\n    * Rebuilds the internal list of inputs by iterating over all modules.\n    * This is necessary if inputs have been added to or removed from a module\n-   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n+   * after the {@link #init(List, List, CompilerOptions)} call.\n    */\n   public void rebuildInputsFromModules() {\n     inputs = getAllInputsFromModules(modules);\n       case ECMASCRIPT5:\n       case ECMASCRIPT5_STRICT:\n         return true;\n-    }\n-    return false;\n+      case ECMASCRIPT3:\n+        return false;\n+    }\n+    throw new IllegalStateException(\"unexpected language mode\");\n   }\n \n   public LanguageMode languageMode() {\n   }\n \n   /**\n-   * Stores the old parse tree for a given source file.\n-   * @param sourceName\n-   * @param oldAst\n-   */\n+   * {@inheritDoc}\n+   */\n+  @Override\n   public void setOldParseTree(String sourceName, AstRoot oldAst) {\n   }\n \n   /**\n-   * Gets an old format parse tree for a given source file.\n-   * @param sourceName\n-   * @return\n-   */\n+   * {@inheritDoc}\n+   */\n+  @Override\n   public AstRoot getOldParseTreeByName(String sourceName) {\n     return null;\n   }\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n    * could be inlined using {@link GatherCandiates}.\n    *\n    * The second step involves verifying that each candidate is actually safe\n-   * to inline with {@link Candidate#canInline()} and finally perform inlining\n-   * using {@link Candidate#inlineVariable()}.\n+   * to inline with {@link Candidate#canInline(Scope)} and finally perform\n+   * inlining using {@link Candidate#inlineVariable()}.\n    *\n    * The reason for the delayed evaluation of the candidates is because we\n    * need two separate dataflow result.\n    * Gathers a list of possible candidates for inlining based only on\n    * information from {@link MustBeReachingVariableDef}. The list will be stored\n    * in {@code candidates} and the validity of each inlining Candidate should\n-   * be later verified with {@link Candidate#canInline()} when\n+   * be later verified with {@link Candidate#canInline(Scope)} when\n    * {@link MaybeReachingVariableUse} has been performed.\n    */\n   private class GatherCandiates extends AbstractShallowCallback {\n--- a/src/com/google/javascript/jscomp/LoggerErrorManager.java\n+++ b/src/com/google/javascript/jscomp/LoggerErrorManager.java\n       case WARNING:\n         logger.warning(error.format(level, formatter));\n         break;\n+      case OFF:\n+        break;\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n           return Token.TRUE;\n         case FALSE:\n           return Token.FALSE;\n+        case UNKNOWN:\n+          return type;\n       }\n     }\n     return type;\n--- a/src/com/google/javascript/jscomp/PerformanceTracker.java\n+++ b/src/com/google/javascript/jscomp/PerformanceTracker.java\n   }\n \n   class CmpEntries implements Comparator<Entry<String, Stats>> {\n+    @Override\n     public int compare(Entry<String, Stats> e1, Entry<String, Stats> e2) {\n       return (int) (e1.getValue().runtime - e2.getValue().runtime);\n     }\n--- a/src/com/google/javascript/jscomp/ProcessTweaks.java\n+++ b/src/com/google/javascript/jscomp/ProcessTweaks.java\n           return IR.number(0);\n         case REGISTER_STRING:\n           return IR.string(\"\");\n-      }\n-      throw new IllegalStateException();\n+        default:\n+          throw new IllegalStateException();\n+      }\n     }\n   }\n \n     final Map<String, TweakInfo> allTweaks = Maps.newHashMap();\n     final List<TweakFunctionCall> getOverridesCalls = Lists.newArrayList();\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (!n.isCall()) {\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n   }\n \n   @Override\n-  @SuppressWarnings(\"fallthrough\")\n+  @SuppressWarnings({\"fallthrough\", \"incomplete-switch\"})\n   List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {\n     // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND\n     // edges. If we wanted to be perfect, we'd actually JOIN all the out\n--- a/src/com/google/javascript/jscomp/ant/AntErrorManager.java\n+++ b/src/com/google/javascript/jscomp/ant/AntErrorManager.java\n       case WARNING:\n         this.task.log(error.format(level, this.formatter), Project.MSG_WARN);\n         break;\n+      case OFF:\n+        break;\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/ant/CompileTask.java\n+++ b/src/com/google/javascript/jscomp/ant/CompileTask.java\n    * @param options\n    */\n   private void convertPropertiesMap(CompilerOptions options) {\n+    @SuppressWarnings(\"unchecked\")\n     Map<String, Object> props = getProject().getProperties();\n     for (Map.Entry<String, Object> entry : props.entrySet()) {\n       String key = entry.getKey();\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n    * @return {@code true} if JSDoc information was correctly parsed,\n    *     {@code false} otherwise\n    */\n+  @SuppressWarnings(\"incomplete-switch\")\n   boolean parse() {\n     int lineno;\n     int charno;\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n \n   private void fold(String js, String expected) {\n     test(js, expected);\n-  }\n-\n-  private void fold(String js, String expected, DiagnosticType warning) {\n-    test(js, expected, warning);\n   }\n \n   void assertResultString(String js, String expected) {\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n         registry.getNativeType(type), registry.getNativeType(VOID_TYPE));\n   }\n \n-  private JSType getNoResolvedType() {\n-    return registry.getNativeType(NO_RESOLVED_TYPE);\n-  }\n-\n   private JSType createNullableType(JSTypeNative type) {\n     return createNullableType(registry.getNativeType(type));\n   }\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n         \"Some.Long.Type.Name\", 0, 7, 1, 8, true);\n   }\n \n+  @SuppressWarnings(\"deprecation\")\n   public void testParseWithoutMarkerName() throws Exception {\n     JSDocInfo jsdoc = parse(\"@author helloworld*/\", true);\n     assertNull(assertAnnotationMarker(jsdoc, \"author\", 0, 0).getName());\n    * @param startCharno The starting character of the text.\n    * @return The marker, for chaining purposes.\n    */\n+  @SuppressWarnings(\"deprecation\")\n   private JSDocInfo.Marker assertNameInMarker(JSDocInfo.Marker marker,\n       String name, int startLine, int startCharno) {\n     assertTrue(marker.getName() != null);\n--- a/test/com/google/javascript/rhino/jstype/ParameterizedTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/ParameterizedTypeTest.java\n     super.setUp();\n   }\n \n+  @Override\n   protected ParameterizedType createParameterizedType(\n       ObjectType objectType, JSType parameterType) {\n     return registry.createParameterizedType(objectType, parameterType);", "timestamp": 1357174753, "metainfo": ""}