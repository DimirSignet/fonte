{"sha": "46da17d59abb4f9c48b6ffd31601c212490b970b", "log": "Fix issue 586. Distinguishing declared functions from inferred functions is really hard!  R=johnlenz DELTA=62  (52 added, 1 deleted, 9 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3696   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n  *\n  * When building scope information, also declares relevant information\n  * about types in the type registry.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n  */\n final class TypedScopeCreator implements ScopeCreator {\n   /**\n      * Check if the given node is a property of a name in the global scope.\n      */\n     private boolean isQnameRootedInGlobalScope(Node n) {\n+      Scope scope = getQnameRootScope(n);\n+      return scope != null && scope.isGlobal();\n+    }\n+\n+    /**\n+     * Return the scope for the name of the given node.\n+     */\n+    private Scope getQnameRootScope(Node n) {\n       Node root = NodeUtil.getRootOfQualifiedName(n);\n       if (root.isName()) {\n         Var var = scope.getVar(root.getString());\n         if (var != null) {\n-          return var.isGlobal();\n-        }\n-      }\n-      return false;\n+          return var.getScope();\n+        }\n+      }\n+      return null;\n     }\n \n     /**\n         return;\n       }\n \n+      // NOTE(nicksantos): Determining whether a property is declared or not\n+      // is really really obnoxious.\n+      //\n+      // The problem is that there are two (equally valid) coding styles:\n+      //\n+      // (function() {\n+      //   /* The authoritative definition of goog.bar. */\n+      //   goog.bar = function() {};\n+      // })();\n+      //\n+      // function f() {\n+      //   goog.bar();\n+      //   /* Reset goog.bar to a no-op. */\n+      //   goog.bar = function() {};\n+      // }\n+      //\n+      // In a dynamic language with first-class functions, it's very difficult\n+      // to know which one the user intended without looking at lots of\n+      // contextual information (the second example demonstrates a small case\n+      // of this, but there are some really pathological cases as well).\n+      //\n+      // The current algorithm checks if either the declaration has\n+      // jsdoc type information, or @const with a known type,\n+      // or a function literal with a name we haven't seen before.\n       boolean inferred = true;\n       if (info != null) {\n         // Determining declaration for #1 + #3 + #4\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n+      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n         // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+        if (info != null) {\n+          inferred = false;\n+        } else if (!scope.isDeclared(qName, false) &&\n+                   n.isUnscopedQualifiedName()) {\n+          inferred = false;\n+        }\n       }\n \n       if (!inferred) {\n         // If the property is already declared, the error will be\n         // caught when we try to declare it in the current scope.\n         defineSlot(n, parent, valueType, inferred);\n-      } else if (rhsValue != null &&\n-          rhsValue.isTrue()) {\n+      } else if (rhsValue != null && rhsValue.isTrue()) {\n         // We declare these for delegate proxy method properties.\n         FunctionType ownerType =\n             JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"  /** @return {Foo} */ y: function() { new Bar(); }\" +\n         \"};\" +\n         \"Bar.prototype.__proto__ = Foo.prototype;\");\n+  }\n+\n+  public void testIssue586() throws Exception {\n+    testTypes(\n+        \"/** @constructor */\" +\n+        \"var MyClass = function() {};\" +\n+        \"/** @param {boolean} success */\" +\n+        \"MyClass.prototype.fn = function(success) {};\" +\n+        \"MyClass.prototype.test = function() {\" +\n+        \"  this.fn();\" +\n+        \"  this.fn = function() {};\" +\n+        \"};\",\n+        \"Function MyClass.prototype.fn: called with 0 argument(s). \" +\n+        \"Function requires at least 1 argument(s) \" +\n+        \"and no more than 1 argument(s).\");\n   }\n \n   /**", "timestamp": 1321290766, "metainfo": ""}