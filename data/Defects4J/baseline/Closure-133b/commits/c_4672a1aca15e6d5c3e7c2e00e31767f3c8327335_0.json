{"sha": "4672a1aca15e6d5c3e7c2e00e31767f3c8327335", "log": "Change on 2010/06/01 by nicksantos          Rename a test file, since the class its testing has been renamed.          R=johnlenz         DELTA=112  (56 added, 56 deleted, 0 changed)  Change on 2010/06/01 by johnlenz          RemoveUnusedVars: Prevent retraversal of exported function bodies.         Fixes issue 168.          R=bowdidge         DELTA=40  (32 added, 1 deleted, 7 changed)  Change on 2010/06/01 by johnlenz          Our scope object can't model it properly, so report an error if a var         with the same name as a catch expression is used within a catch block.         Fixes issue 166.          R=acleung         DELTA=78  (75 added, 0 deleted, 3 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=13012   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n   private final boolean assertOnChange;\n   private static final boolean CONVERT_WHILE_TO_FOR = true;\n   static final boolean MAKE_LOCAL_NAMES_UNIQUE = true;\n+\n+  public static final DiagnosticType CATCH_BLOCK_VAR_ERROR =\n+    DiagnosticType.error(\n+        \"JSC_CATCH_BLOCK_VAR_ERROR\",\n+        \"The use of scope variable {0} is not allowed within a catch block \" +\n+        \"with a catch exception of the same name.\");\n+\n \n   Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n     this.compiler = compiler;\n       Preconditions.checkState(n.getType() == Token.NAME);\n       Var v = s.getVar(name);\n       // If name is \"arguments\", Var maybe null.\n-      Preconditions.checkState(\n-          v == null || v.getParentNode().getType() != Token.CATCH);\n-      if (v != null && parent.getType() == Token.FUNCTION) {\n+      if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n+            name);\n+        compiler.report(\n+            JSError.make(\n+                NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,\n+                CATCH_BLOCK_VAR_ERROR, name));\n+      } else if (v != null && parent.getType() == Token.FUNCTION) {\n         if (v.getParentNode().getType() == Token.VAR) {\n           s.undeclare(v);\n           s.declare(name, n, n.getJSType(), v.input);\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n       case Token.FUNCTION:\n         // If it's an exported function, or an function expression, assume\n         // that it'll be called.\n-        if (NodeUtil.isFunctionExpression(n) || isExportedFunction(n, scope)) {\n+        if (traverseFunctionWhenFirstSeen(n, scope)) {\n           traverseFunction(n, scope);\n         }\n         return;\n \n   /**\n    * @param n The function node.\n+   * @return Whether to traverse the function immediately.\n+   */\n+  private boolean traverseFunctionWhenFirstSeen(Node n, Scope scope) {\n+    return NodeUtil.isFunctionExpression(n) || isExportedFunction(n, scope);\n+  }\n+\n+  /**\n+   * @param n The function node.\n    * @return Whether the function is exported.\n    */\n   private boolean isExportedFunction(Node n, Scope scope) {\n     Preconditions.checkState(NodeUtil.isFunctionDeclaration(n));\n     // If we aren't removing global names, assume that all global functions\n     // are exported.\n-    return (!removeGlobals && scope.isGlobal()) || \n+    return (!removeGlobals && scope.isGlobal()) ||\n         compiler_.getCodingConvention().isExported(\n            n.getFirstChild().getString());\n   }\n     referenced.add(var);\n \n     Node parent = var.getParentNode();\n-    if (parent.getType() == Token.FUNCTION &&\n-        var.getInitialValue() != var.scope.getRootNode()) {\n-      // Now that the function has been referenced, traverse it.\n-      // Unless it's a bleeding function, in which case we're already\n-      // traversing it.\n-\n-      traverseFunction(parent, var.scope);\n+    if (parent.getType() == Token.FUNCTION) {\n+      // Now that the function has been referenced traverse it if it won't be\n+      // traversed otherwise.\n+      if (!traverseFunctionWhenFirstSeen(parent, var.getScope())) {\n+        traverseFunction(parent, var.scope);\n+      }\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n          \"var b = EXTERN; var c = ext.FOO\", null, null);\n   }\n \n+  public void testIssue166a() {\n+    test(\"try { throw 1 } catch(e) { /** @suppress {duplicate} */ var e=2 }\",\n+         \"try { throw 1 } catch(e) { var e=2 }\",\n+         Normalize.CATCH_BLOCK_VAR_ERROR);\n+  }\n+\n+  public void testIssue166b() {\n+    test(\"function a() {\" +\n+         \"try { throw 1 } catch(e) { /** @suppress {duplicate} */ var e=2 }\" +\n+         \"};\",\n+         \"function a() {\" +\n+         \"try { throw 1 } catch(e) { var e=2 }\" +\n+         \"}\",\n+         Normalize.CATCH_BLOCK_VAR_ERROR);\n+  }\n+\n+  public void testIssue166c() {\n+    test(\"var e = 0; try { throw 1 } catch(e) {\" +\n+             \"/** @suppress {duplicate} */ var e=2 }\",\n+         \"var e = 0; try { throw 1 } catch(e) { var e=2 }\",\n+         Normalize.CATCH_BLOCK_VAR_ERROR);\n+  }\n+\n+  public void testIssue166d() {\n+    test(\"function a() {\" +\n+         \"var e = 0; try { throw 1 } catch(e) {\" +\n+             \"/** @suppress {duplicate} */ var e=2 }\" +\n+         \"};\",\n+         \"function a() {\" +\n+         \"var e = 0; try { throw 1 } catch(e) { var e=2 }\" +\n+         \"}\",\n+         Normalize.CATCH_BLOCK_VAR_ERROR);\n+  }\n+\n+  public void testIssue166e() {\n+    test(\"var e = 2; try { throw 1 } catch(e) {}\",\n+         \"var e = 2; try { throw 1 } catch(e$$1) {}\");\n+  }\n+\n+  public void testIssue166f() {\n+    test(\"function a() {\" +\n+         \"var e = 2; try { throw 1 } catch(e) {}\" +\n+         \"}\",\n+         \"function a() {\" +\n+         \"var e = 2; try { throw 1 } catch(e$$1) {}\" +\n+         \"}\");\n+  }\n+\n   public void testRenamingConstantProperties() {\n     // In order to detecte that foo.BAR is a constant, we need collapse\n     // properties to run first so that we can tell if the initial value is\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n     testSame(\"var x=1\");\n     test(\"function y(x){var z;}\", \"function y(){}\");\n   }\n-  \n+\n   public void testRemoveGlobal3() {\n     removeGlobal = false;\n     testSame(\"var x=1\");\n-    test(\"function x(){function y(x){var z;}y()}\", \n+    test(\"function x(){function y(x){var z;}y()}\",\n          \"function x(){function y(){}y()}\");\n   }\n-  \n+\n   public void testRemoveGlobal4() {\n     removeGlobal = false;\n     testSame(\"var x=1\");\n-    test(\"function x(){function y(x){var z;}}\", \n+    test(\"function x(){function y(x){var z;}}\",\n          \"function x(){}\");\n-  }   \n+  }\n+\n+  public void testIssue168a() {\n+    test(\"function _a(){\" +\n+         \"  (function(x){ _b(); })(1);\" +\n+         \"}\" +\n+         \"function _b(){\" +\n+         \"  _a();\" +\n+         \"}\",\n+         \"function _a(){(function(){_b()})(1)}\" +\n+         \"function _b(){_a()}\");\n+  }\n+\n+  public void testIssue168b() {\n+    removeGlobal = false;\n+    test(\"function a(){\" +\n+         \"  (function(x){ b(); })(1);\" +\n+         \"}\" +\n+         \"function b(){\" +\n+         \"  a();\" +\n+         \"}\",\n+         \"function a(){(function(){b()})(1)}\" +\n+         \"function b(){a()}\");\n+  }\n+\n }", "timestamp": 1275487833, "metainfo": ""}