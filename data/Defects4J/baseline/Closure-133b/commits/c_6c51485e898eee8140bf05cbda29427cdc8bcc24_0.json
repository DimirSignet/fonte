{"sha": "6c51485e898eee8140bf05cbda29427cdc8bcc24", "log": "Add an explicit \"trusted strings\" mode.  R=johnlenz DELTA=188  (143 added, 19 deleted, 26 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5931   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n     options.devMode = config.jscompDevMode;\n     options.setCodingConvention(config.codingConvention);\n     options.setSummaryDetailLevel(config.summaryDetailLevel);\n+    options.setTrustedStrings(true);\n \n     legacyOutputCharset = options.outputCharset = getLegacyOutputCharset();\n     outputCharset2 = getOutputCharset2();\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n  *\n  */\n class CodeGenerator {\n+  private static final String LT_ESCAPED = \"\\\\x3c\";\n+  private static final String GT_ESCAPED = \"\\\\x3e\";\n+\n   // A memoizer for formatting strings as JS strings.\n   private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();\n \n   private final CharsetEncoder outputCharsetEncoder;\n \n   private final boolean preferSingleQuotes;\n+  private final boolean trustedStrings;\n+\n+  private CodeGenerator(CodeConsumer consumer) {\n+    cc = consumer;\n+    outputCharsetEncoder = null;\n+    preferSingleQuotes = false;\n+    trustedStrings = true;\n+  }\n+\n+  static CodeGenerator forCostEstimation(CodeConsumer consumer) {\n+    return new CodeGenerator(consumer);\n+  }\n \n   CodeGenerator(\n-      CodeConsumer consumer, Charset outputCharset,\n-      boolean preferSingleQuotes) {\n+      CodeConsumer consumer,\n+      CompilerOptions options) {\n     cc = consumer;\n+\n+    Charset outputCharset = options.getOutputCharset();\n     if (outputCharset == null || outputCharset == Charsets.US_ASCII) {\n       // If we want our default (pretending to be UTF-8, but escaping anything\n       // outside of straight ASCII), then don't use the encoder, but\n     } else {\n       this.outputCharsetEncoder = outputCharset.newEncoder();\n     }\n-    this.preferSingleQuotes = preferSingleQuotes;\n+    this.preferSingleQuotes = options.preferSingleQuotes;\n+    this.trustedStrings = options.trustedStrings;\n   }\n \n   /**\n     }\n \n     return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\",\n-        outputCharsetEncoder, useSlashV);\n+        outputCharsetEncoder, useSlashV, false);\n   }\n \n   /** Escapes regular expression */\n-  static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {\n-    return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder, false);\n+  String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {\n+    return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder, false, true);\n   }\n \n   /**\n    * Escapes the given string to a double quoted (\") JavaScript/JSON string\n    */\n-  static String escapeToDoubleQuotedJsString(String s) {\n-    return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null, false);\n+  String escapeToDoubleQuotedJsString(String s) {\n+    return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null, false, false);\n   }\n \n   /* If the user doesn't want to specify an output charset encoder, assume\n      they want Latin/ASCII characters only.\n    */\n-  static String regexpEscape(String s) {\n+  String regexpEscape(String s) {\n     return regexpEscape(s, null);\n   }\n \n   /** Helper to escape JavaScript string as well as regular expression */\n-  private static String strEscape(\n-      String s, char quote,\n+  private String strEscape(\n+      String s,\n+      char quote,\n       String doublequoteEscape,\n       String singlequoteEscape,\n       String backslashEscape,\n       CharsetEncoder outputCharsetEncoder,\n-      boolean useSlashV) {\n+      boolean useSlashV,\n+      boolean isRegexp) {\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n         case '\\u2028': sb.append(\"\\\\u2028\"); break;\n         case '\\u2029': sb.append(\"\\\\u2029\"); break;\n \n-        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n+        case '=':\n+          // '=' is a syntactically signficant regexp character.\n+          if (trustedStrings || isRegexp) {\n+            sb.append(c);\n+          } else {\n+            sb.append(\"\\\\x3d\");\n+          }\n+          break;\n+\n+        case '&':\n+          if (trustedStrings || isRegexp) {\n+            sb.append(c);\n+          } else {\n+            sb.append(\"\\\\x26\");\n+          }\n+          break;\n+\n+        case '>':\n+          if (!trustedStrings && !isRegexp) {\n+            sb.append(GT_ESCAPED);\n+            break;\n+          }\n+\n+          // Break --> into --\\> or ]]> into ]]\\>\n+          //\n+          // This is just to prevent developers from shooting themselves in the\n+          // foot, and does not provide the level of security that you get\n+          // with trustedString == false.\n           if (i >= 2 &&\n               ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n                (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n-            sb.append(\"\\\\>\");\n+            sb.append(GT_ESCAPED);\n           } else {\n             sb.append(c);\n           }\n           break;\n         case '<':\n+          if (!trustedStrings && !isRegexp) {\n+            sb.append(LT_ESCAPED);\n+            break;\n+          }\n+\n           // Break </script into <\\/script\n+          // As above, this is just to prevent developers from doing this\n+          // accidentally.\n           final String END_SCRIPT = \"/script\";\n \n           // Break <!-- into <\\!--\n \n           if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                               END_SCRIPT.length())) {\n-            sb.append(\"<\\\\\");\n+            sb.append(LT_ESCAPED);\n           } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                      START_COMMENT.length())) {\n-            sb.append(\"<\\\\\");\n+            sb.append(LT_ESCAPED);\n           } else {\n             sb.append(c);\n           }\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n-import java.nio.charset.Charset;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Deque;\n     Preconditions.checkState(options.sourceMapDetailLevel != null);\n \n     boolean createSourceMap = (sourceMap != null);\n-    Charset outputCharset = options.outputCharset == null ? null :\n-        Charset.forName(options.outputCharset);\n     MappedCodePrinter mcp =\n         outputFormat == Format.COMPACT\n         ? new CompactCodePrinter(\n             options.sourceMapDetailLevel);\n     CodeGenerator cg =\n         outputFormat == Format.TYPED\n-        ? new TypedCodeGenerator(mcp, outputCharset)\n-        : new CodeGenerator(mcp, outputCharset, options.preferSingleQuotes);\n+        ? new TypedCodeGenerator(mcp, options)\n+        : new CodeGenerator(mcp, options);\n \n     if (tagAsStrict) {\n       cg.tagAsStrict();\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.SourcePosition;\n+\n import java.io.Serializable;\n+import java.nio.charset.Charset;\n import java.text.ParseException;\n import java.util.Collections;\n import java.util.List;\n    */\n   public void setPreferSingleQuotes(boolean enabled) {\n     this.preferSingleQuotes = enabled;\n+  }\n+\n+  boolean trustedStrings;\n+\n+  /**\n+   * Some people want to put arbitrary user input into strings, which are then\n+   * run through the compiler. These scripts are then put into HTML.\n+   * By default, we assume strings are untrusted. If the compiler is run\n+   * from the command-line, we assume that strings are trusted.\n+   */\n+  public void setTrustedStrings(boolean yes) {\n+    trustedStrings = yes;\n   }\n \n   String reportPath;\n   }\n \n   /**\n+   * Gets the output charset as a rich object.\n+   */\n+  Charset getOutputCharset() {\n+    return outputCharset == null ? null : Charset.forName(outputCharset);\n+  }\n+\n+  /**\n    * Sets how goog.tweak calls are processed.\n    */\n   public void setTweakProcessing(TweakProcessing tweakProcessing) {\n--- a/src/com/google/javascript/jscomp/InlineCostEstimator.java\n+++ b/src/com/google/javascript/jscomp/InlineCostEstimator.java\n     }\n \n     void add(Node root) {\n-      CodeGenerator cg = new CodeGenerator(this, null, false);\n+      CodeGenerator cg = CodeGenerator.forCostEstimation(this);\n       cg.add(root);\n     }\n \n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n   private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n   private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n   private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n+  private static final CodeGenerator REGEXP_ESCAPER =\n+      CodeGenerator.forCostEstimation(\n+          null /* blow up if we try to produce code */);\n \n   private final boolean late;\n \n    * out as the body of a regular expression literal.\n    */\n   static boolean containsUnicodeEscape(String s) {\n-    String esc = CodeGenerator.regexpEscape(s);\n+    String esc = REGEXP_ESCAPER.regexpEscape(s);\n     for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) {\n       int nSlashes = 0;\n       while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) {\n--- a/src/com/google/javascript/jscomp/PerformanceTracker.java\n+++ b/src/com/google/javascript/jscomp/PerformanceTracker.java\n \n   private final CodeSizeEstimatePrinter estimateCodeSize(Node root) {\n     CodeSizeEstimatePrinter cp = new CodeSizeEstimatePrinter(trackGzippedSize);\n-    CodeGenerator cg = new CodeGenerator(cp, null, false);\n+    CodeGenerator cg = CodeGenerator.forCostEstimation(cp);\n     cg.add(root);\n     return cp;\n   }\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n-import java.nio.charset.Charset;\n import java.util.Set;\n \n /**\n  * constructors.\n  */\n class TypedCodeGenerator extends CodeGenerator {\n-  TypedCodeGenerator(CodeConsumer consumer, Charset outputCharset) {\n-    super(consumer, outputCharset, false);\n+  TypedCodeGenerator(CodeConsumer consumer, CompilerOptions options) {\n+    super(consumer, options);\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n import java.util.List;\n \n public class CodePrinterTest extends TestCase {\n-  static Node parse(String js) {\n+  boolean trustedStrings = true;\n+\n+  @Override public void setUp() {\n+    trustedStrings = true;\n+  }\n+\n+  Node parse(String js) {\n     return parse(js, false);\n   }\n \n-  static Node parse(String js, boolean checkTypes) {\n+  Node parse(String js, boolean checkTypes) {\n     Compiler compiler = new Compiler();\n     CompilerOptions options = new CompilerOptions();\n+    options.setTrustedStrings(trustedStrings);\n+\n     // Allow getters and setters.\n     options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n     compiler.initOptions(options);\n \n   String parsePrint(String js, boolean prettyprint, int lineThreshold) {\n     CompilerOptions options = new CompilerOptions();\n+    options.setTrustedStrings(trustedStrings);\n     options.setPrettyPrint(prettyprint);\n     options.setLineLengthThreshold(lineThreshold);\n     return new CodePrinter.Builder(parse(js)).setCompilerOptions(options)\n   String parsePrint(String js, boolean prettyprint, boolean lineBreak,\n       int lineThreshold) {\n     CompilerOptions options = new CompilerOptions();\n+    options.setTrustedStrings(trustedStrings);\n     options.setPrettyPrint(prettyprint);\n     options.setLineLengthThreshold(lineThreshold);\n     options.setLineBreak(lineBreak);\n   String parsePrint(String js, boolean prettyprint, boolean lineBreak,\n       boolean preferLineBreakAtEof, int lineThreshold) {\n     CompilerOptions options = new CompilerOptions();\n+    options.setTrustedStrings(trustedStrings);\n     options.setPrettyPrint(prettyprint);\n     options.setLineLengthThreshold(lineThreshold);\n     options.setPreferLineBreakAtEndOfFile(preferLineBreakAtEof);\n   String parsePrint(String js, boolean prettyprint, boolean lineBreak,\n       int lineThreshold, boolean outputTypes) {\n     CompilerOptions options = new CompilerOptions();\n+    options.setTrustedStrings(trustedStrings);\n     options.setPrettyPrint(prettyprint);\n     options.setLineLengthThreshold(lineThreshold);\n     options.setLineBreak(lineBreak);\n                     int lineThreshold, boolean outputTypes,\n                     boolean tagAsStrict) {\n     CompilerOptions options = new CompilerOptions();\n+    options.setTrustedStrings(trustedStrings);\n     options.setPrettyPrint(prettyprint);\n     options.setLineLengthThreshold(lineThreshold);\n     options.setLineBreak(lineBreak);\n         \"var a,b,c;a+=b=c+=3\");\n     assertPrint(\"var a,b,c; a *= (b -= c);\",\n         \"var a,b,c;a*=b-=c\");\n-\n-    // Break scripts\n-    assertPrint(\"'<script>'\", \"\\\"<script>\\\"\");\n-    assertPrint(\"'</script>'\", \"\\\"<\\\\/script>\\\"\");\n-    assertPrint(\"\\\"</script> </SCRIPT>\\\"\", \"\\\"<\\\\/script> <\\\\/SCRIPT>\\\"\");\n-\n-    assertPrint(\"'-->'\", \"\\\"--\\\\>\\\"\");\n-    assertPrint(\"']]>'\", \"\\\"]]\\\\>\\\"\");\n-    assertPrint(\"' --></script>'\", \"\\\" --\\\\><\\\\/script>\\\"\");\n-\n-    assertPrint(\"/--> <\\\\/script>/g\", \"/--\\\\> <\\\\/script>/g\");\n-\n-    // Break HTML start comments. Certain versions of WebKit\n-    // begin an HTML comment when they see this.\n-    assertPrint(\"'<!-- I am a string -->'\", \"\\\"<\\\\!-- I am a string --\\\\>\\\"\");\n \n     // Precedence\n     assertPrint(\"a ? delete b[0] : 3\", \"a?delete b[0]:3\");\n     assertPrint(\"if(x){if(y);}\", \"if(x)if(y);\");\n     assertPrint(\"if(x){if(y){};;;}\", \"if(x)if(y);\");\n     assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");\n+  }\n+\n+  public void testBreakTrustedStrings() {\n+    // Break scripts\n+    assertPrint(\"'<script>'\", \"\\\"<script>\\\"\");\n+    assertPrint(\"'</script>'\", \"\\\"\\\\x3c/script>\\\"\");\n+    assertPrint(\"\\\"</script> </SCRIPT>\\\"\", \"\\\"\\\\x3c/script> \\\\x3c/SCRIPT>\\\"\");\n+\n+    assertPrint(\"'-->'\", \"\\\"--\\\\x3e\\\"\");\n+    assertPrint(\"']]>'\", \"\\\"]]\\\\x3e\\\"\");\n+    assertPrint(\"' --></script>'\", \"\\\" --\\\\x3e\\\\x3c/script>\\\"\");\n+\n+    assertPrint(\"/--> <\\\\/script>/g\", \"/--\\\\x3e <\\\\/script>/g\");\n+\n+    // Break HTML start comments. Certain versions of WebKit\n+    // begin an HTML comment when they see this.\n+    assertPrint(\"'<!-- I am a string -->'\",\n+        \"\\\"\\\\x3c!-- I am a string --\\\\x3e\\\"\");\n+\n+    assertPrint(\"'<=&>'\", \"\\\"<=&>\\\"\");\n+  }\n+\n+  public void testBreakUntrustedStrings() {\n+    trustedStrings = false;\n+\n+    // Break scripts\n+    assertPrint(\"'<script>'\", \"\\\"\\\\x3cscript\\\\x3e\\\"\");\n+    assertPrint(\"'</script>'\", \"\\\"\\\\x3c/script\\\\x3e\\\"\");\n+    assertPrint(\"\\\"</script> </SCRIPT>\\\"\", \"\\\"\\\\x3c/script\\\\x3e \\\\x3c/SCRIPT\\\\x3e\\\"\");\n+\n+    assertPrint(\"'-->'\", \"\\\"--\\\\x3e\\\"\");\n+    assertPrint(\"']]>'\", \"\\\"]]\\\\x3e\\\"\");\n+    assertPrint(\"' --></script>'\", \"\\\" --\\\\x3e\\\\x3c/script\\\\x3e\\\"\");\n+\n+    assertPrint(\"/--> <\\\\/script>/g\", \"/--\\\\x3e <\\\\/script>/g\");\n+\n+    // Break HTML start comments. Certain versions of WebKit\n+    // begin an HTML comment when they see this.\n+    assertPrint(\"'<!-- I am a string -->'\",\n+        \"\\\"\\\\x3c!-- I am a string --\\\\x3e\\\"\");\n+\n+    assertPrint(\"'<=&>'\", \"\\\"\\\\x3c\\\\x3d\\\\x26\\\\x3e\\\"\");\n+    assertPrint(\"/(?=x)/\", \"/(?=x)/\");\n   }\n \n   public void testPrintArray() {", "timestamp": 1354909180, "metainfo": ""}