{"sha": "27d9224ea579a3cf5780de2994bac258b3cfcd42", "log": "start indexing jsdoc asts  R=jschorr DELTA=223  (193 added, 21 deleted, 9 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3296   ", "commit": "\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n           \", aliasingGets=\" + aliasingGets + \", callGets=\" + callGets;\n     }\n \n+    @Override\n+    public JSDocInfo getJSDocInfo() {\n+      return docInfo;\n+    }\n+\n     /**\n      * Tries to get the doc info for a given declaration ref.\n      */\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n    */\n   private final Map<Node, SymbolScope> scopes = Maps.newHashMap();\n \n+  /**\n+   * All JSDocInfo in the program.\n+   */\n+  private final List<JSDocInfo> docInfos = Lists.newArrayList();\n+\n   private SymbolScope globalScope = null;\n \n   private final JSTypeRegistry registry;\n   @Override\n   public SymbolScope getScope(Symbol slot) {\n     return slot.scope;\n+  }\n+\n+  public Collection<JSDocInfo> getAllJSDocInfo() {\n+    return Collections.unmodifiableList(docInfos);\n   }\n \n   /**\n     return declareSymbol(\n         sym.getName(), sym.getType(), sym.isTypeInferred(), scope,\n         // All symbols must have declaration nodes.\n-        Preconditions.checkNotNull(sym.getDeclaration().getNode()));\n+        Preconditions.checkNotNull(sym.getDeclaration().getNode()),\n+        sym.getJSDocInfo());\n   }\n \n   private Symbol declareSymbol(\n       String name, JSType type, boolean inferred,\n-      SymbolScope scope, Node declNode) {\n+      SymbolScope scope, Node declNode, JSDocInfo info) {\n     Symbol symbol = new Symbol(name, type, inferred, scope);\n+    symbol.setJSDocInfo(info);\n     symbols.put(declNode, name, symbol);\n \n     Symbol replacedSymbol = scope.ownSymbols.put(name, symbol);\n \n       Symbol newSym = copySymbolTo(newProp, s.propertyScope);\n       if (oldProp != null) {\n+        if (newSym.getJSDocInfo() == null) {\n+          newSym.setJSDocInfo(oldProp.getJSDocInfo());\n+        }\n         newSym.propertyScope = oldProp.propertyScope;\n         for (Reference ref : oldProp.references.values()) {\n           newSym.defineReferenceAt(ref.getNode());\n \n     private Reference declaration = null;\n \n+    private JSDocInfo docInfo = null;\n+\n     Symbol(String name, JSType type, boolean inferred, SymbolScope scope) {\n       super(name, type, inferred);\n       this.scope = scope;\n       return JSType.toMaybeFunctionType(getType());\n     }\n \n-    void defineReferenceAt(Node n) {\n+    public void defineReferenceAt(Node n) {\n       if (!references.containsKey(n)) {\n         references.put(n, new Reference(this, n));\n       }\n \n     public SymbolScope getPropertyScope() {\n       return propertyScope;\n+    }\n+\n+    @Override\n+    public JSDocInfo getJSDocInfo() {\n+      return docInfo;\n+    }\n+\n+    void setJSDocInfo(JSDocInfo info) {\n+      this.docInfo = info;\n     }\n \n     @Override\n               registry.getNativeType(JSTypeNative.GLOBAL_THIS),\n               false /* declared */,\n               globalScope,\n-              n);\n+              n,\n+              null);\n         } else {\n           symbol = globalScope.getSlot(GLOBAL_THIS);\n         }\n                 type,\n                 type != null && !type.isUnknownType(),\n                 propScope,\n-                n);\n+                n,\n+                null);\n           }\n         }\n       }\n \n     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getJSDocInfo() != null) {\n+\n         // Find references in the JSDocInfo.\n         JSDocInfo info = n.getJSDocInfo();\n+        docInfos.add(info);\n         for (Node typeAst : info.getTypeNodes()) {\n           SymbolScope scope = scopes.get(t.getScopeRoot());\n           visitTypeNode(scope == null ? globalScope : scope, typeAst);\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n import com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType;\n import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n       return null;\n     }\n \n+    @Override public JSDocInfo getJSDocInfo() {\n+      return null;\n+    }\n+\n     /**\n      * Adds the given type to the possible concrete types for this slot.\n      * Returns whether the added type was not already known.\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n \n   /** Gets the list of all markers for the documentation in this JSDoc. */\n   public Collection<Marker> getMarkers() {\n-    return documentation == null\n+    return (documentation == null || documentation.markers == null)\n         ? ImmutableList.<Marker>of() : documentation.markers;\n   }\n \n--- a/src/com/google/javascript/rhino/JSTypeExpression.java\n+++ b/src/com/google/javascript/rhino/JSTypeExpression.java\n    * Evaluates the type expression into a {@code JSType} object.\n    */\n   public JSType evaluate(StaticScope<JSType> scope, JSTypeRegistry registry) {\n-    return registry.createFromTypeNodes(root, sourceName, scope);\n+    JSType type = registry.createFromTypeNodes(root, sourceName, scope);\n+    root.setJSType(type);\n+    return type;\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n       this.type = type;\n     }\n \n-    JSDocInfo getJSDocInfo() {\n+    @Override public JSDocInfo getJSDocInfo() {\n       return this.docInfo;\n     }\n \n--- a/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n+++ b/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.javascript.rhino.JSDocInfo;\n+\n import java.io.Serializable;\n \n /**\n   public StaticReference<JSType> getDeclaration() {\n     return null;\n   }\n+\n+  @Override\n+  public JSDocInfo getJSDocInfo() {\n+    return null;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/StaticSlot.java\n+++ b/src/com/google/javascript/rhino/jstype/StaticSlot.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.javascript.rhino.JSDocInfo;\n+\n /**\n  * The {@code StaticSlot} interface must be implemented by variables that can\n  * appear as members of a {@code StaticScope}.\n \n   /** Gets the declaration of this symbol. May not exist. */\n   StaticReference<T> getDeclaration();\n+\n+  /** Gets the JSDoc for this slot. */\n+  JSDocInfo getJSDocInfo();\n }\n--- a/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n+++ b/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType;\n import com.google.javascript.jscomp.ConcreteType.ConcreteUnionType;\n import com.google.javascript.jscomp.ConcreteType.Factory;\n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n \n     @Override\n     public StaticReference<ConcreteType> getDeclaration() { return null; }\n+\n+    @Override\n+    public JSDocInfo getJSDocInfo() { return null; }\n   }\n }", "timestamp": 1316467197, "metainfo": ""}