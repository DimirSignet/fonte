{"sha": "63c9ab97253d7bfb1d5e2a27c39c9c3a8a6d3d7e", "log": "Fixes an issue  R=nicksantos DELTA=37  (31 added, 1 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1179   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n       }\n \n       // Add the property to the record.\n-      builder.addProperty(fieldName, fieldType, fieldNameNode);\n+      if (builder.addProperty(fieldName, fieldType, fieldNameNode) == null) {\n+        // Duplicate field name, warning and skip\n+        reporter.warning(\n+            \"Duplicate record field \" + fieldName,\n+            sourceName,\n+            n.getLineno(), \"\", n.getCharno());\n+      }\n     }\n \n     return builder.build();\n--- a/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n \n package com.google.javascript.rhino.jstype;\n \n-import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n import com.google.javascript.rhino.Node;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n \n /**\n  * A builder for record types.\n public class RecordTypeBuilder {\n   private boolean isEmpty = true;\n   private final JSTypeRegistry registry;\n-  private final ImmutableMap.Builder<String, RecordProperty> properties =\n-      ImmutableMap.builder();\n+  private final HashMap<String, RecordProperty> properties = Maps.newHashMap();\n \n   public RecordTypeBuilder(JSTypeRegistry registry) {\n     this.registry = registry;\n    * @param name the name of the new property\n    * @param type the JSType of the new property\n    * @param propertyNode the node that holds this property definition\n-   * @return The builder itself for chaining purposes.\n+   * @return The builder itself for chaining purposes, or null if there's\n+   *          a duplicate.\n    */\n   public RecordTypeBuilder addProperty(String name, JSType type, Node\n       propertyNode) {\n     isEmpty = false;\n+    if (properties.containsKey(name)) {\n+      return null;\n+    }\n     properties.put(name, new RecordProperty(type, propertyNode));\n     return this;\n   }\n        return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n     }\n \n-    return registry.createRecordType(properties.build());\n+    return registry.createRecordType(Collections.unmodifiableMap(properties));\n   }\n \n   static class RecordProperty {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"/** @type { {impossibleProperty} } */ var y = new ActiveXObject();\");\n   }\n \n+  public void testDuplicateRecordFields1() throws Exception {\n+    testTypes(\"/**\"\n+         + \"* @param {{x:string, x:number}} a\"\n+         + \"*/\"\n+         + \"function f(a) {};\",\n+         \"Parse error. Duplicate record field x\");\n+  }\n+\n+  public void testDuplicateRecordFields2() throws Exception {\n+    testTypes(\"/**\"\n+         + \"* @param {{name:string,number:x,number:y}} a\"\n+         + \" */\"\n+         + \"function f(a) {};\",\n+         new String[] { \"Parse error. Duplicate record field number\",\n+           \"Bad type annotation. Unknown type x\",\n+           \"Bad type annotation. Unknown type y\"});\n+  }\n+\n   private void checkObjectType(ObjectType objectType, String propertyName,\n         JSType expectedType) {\n     assertTrue(\"Expected \" + objectType.getReferenceName() +", "timestamp": 1301522554, "metainfo": ""}