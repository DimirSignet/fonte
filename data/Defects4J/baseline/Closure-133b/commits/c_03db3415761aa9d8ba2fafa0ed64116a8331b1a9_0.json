{"sha": "03db3415761aa9d8ba2fafa0ed64116a8331b1a9", "log": "Prevent inlining of extern vars that are redeclared.  R=nicksantos DELTA=92  (58 added, 16 deleted, 18 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2401   ", "commit": "\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n       //    of the mechanism that creates variable references, so we don't\n       //    have a good way to update the reference. Just punt on it.\n       // 3) Don't inline the special RENAME_PROPERTY_FUNCTION_NAME\n-      return compiler.getCodingConvention().isExported(var.name)\n+      return var.isExtern()\n+          || compiler.getCodingConvention().isExported(var.name)\n           || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)\n           || staleVars.contains(var);\n     }\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n    */\n   @Override\n   public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, this);\n+    NodeTraversal.traverseRoots(\n+        compiler, Lists.newArrayList(externs, root), this);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n           return;\n         }\n \n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-          info = parent.getJSDocInfo();\n-        }\n-        allowDupe =\n-            info != null && info.getSuppressions().contains(\"duplicate\");\n-\n-        info = origVar.nameNode.getJSDocInfo();\n-        if (info == null) {\n-          info = origParent.getJSDocInfo();\n-        }\n-\n-        allowDupe |=\n-            info != null && info.getSuppressions().contains(\"duplicate\");\n+        boolean allowDupe = hasDuplicateDeclarationSuppression(n, origVar);\n \n         if (!allowDupe) {\n           compiler.report(\n \n \n   /**\n+   * @param n The name node to check.\n+   * @param origVar The associated Var.\n+   * @return Whether duplicated declarations warnings should be suppressed\n+   *     for the given node.\n+   */\n+  static boolean hasDuplicateDeclarationSuppression(Node n, Scope.Var origVar) {\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Node parent = n.getParent();\n+    Node origParent = origVar.getParentNode();\n+\n+    JSDocInfo info = n.getJSDocInfo();\n+    if (info == null) {\n+      info = parent.getJSDocInfo();\n+    }\n+    if (info != null && info.getSuppressions().contains(\"duplicate\")) {\n+      return true;\n+    }\n+\n+    info = origVar.nameNode.getJSDocInfo();\n+    if (info == null) {\n+      info = origParent.getJSDocInfo();\n+    }\n+    return (info != null && info.getSuppressions().contains(\"duplicate\"));\n+  }\n+\n+  /**\n    * Generates an untyped global scope from the root of AST of compiler (which\n    * includes externs).\n    *\n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.BasicBlock;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\n         BasicBlock basicBlock = reference.getBasicBlock();\n         boolean isDeclaration = reference.isDeclaration();\n \n-        if (isDeclaration) {\n+        boolean allowDupe =\n+            SyntacticScopeCreator.hasDuplicateDeclarationSuppression(\n+                reference.getNode(), v);\n+        if (isDeclaration && !allowDupe) {\n           // Look through all the declarations we've found so far, and\n           // check if any of them are before this block.\n           for (BasicBlock declaredBlock : blocksWithDeclarations) {\n         }\n \n         if (!isDeclaration && !isDeclaredInScope) {\n-          // Special case to deal with var goog = goog || {}\n-          Node grandparent = reference.getGrandparent();\n-          if (grandparent.getType() == Token.NAME\n-              && grandparent.getString() == v.name) {\n-            continue;\n-          }\n+          // Don't check the order of refer in externs files.\n+          if (!reference.getSourceFile().isExtern()) {\n+            // Special case to deal with var goog = goog || {}\n+            Node grandparent = reference.getGrandparent();\n+            if (grandparent.getType() == Token.NAME\n+                && grandparent.getString() == v.name) {\n+              continue;\n+            }\n \n-          // Only generate warnings if the scopes do not match in order\n-          // to deal with possible forward declarations and recursion\n-          if (reference.getScope() == v.scope) {\n-            compiler.report(\n-                JSError.make(reference.getSourceFile().getName(),\n-                             reference.getNode(),\n-                             checkLevel,\n-                             UNDECLARED_REFERENCE, v.name));\n+            // Only generate warnings if the scopes do not match in order\n+            // to deal with possible forward declarations and recursion\n+            if (reference.getScope() == v.scope) {\n+              compiler.report(\n+                  JSError.make(reference.getSourceFile().getName(),\n+                               reference.getNode(),\n+                               checkLevel,\n+                               UNDECLARED_REFERENCE, v.name));\n+            }\n           }\n         }\n \n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n       \"}\");\n   }\n \n+  public void testNoInlineRedeclaredExterns() {\n+    String externs = \"var test = 1;\";\n+    String code = \"/** @suppress {duplicate} */ var test = 2;alert(test);\";\n+    test(externs, code, code, null, null);\n+  }\n+\n }\n--- a/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.jscomp.CheckLevel;\n \n \n /**\n     assertNoWarning(\"function g() { if (false) { function f() { f(); g(); }}}\");\n   }\n \n+  public void testNoWarnInExterns1() {\n+    // Verify duplicate suppressions are properly recognized.\n+    String externs =\n+       \"var google;\" +\n+       \"/** @suppress {duplicate} */ var google\";\n+    String code = \"\";\n+    test(externs, code, code, null, null);\n+  }\n+\n+  public void testNoWarnInExterns2() {\n+    // Verify we don't complain about early references in externs\n+    String externs =\n+       \"window;\" +\n+       \"var window;\";\n+    String code = \"\";\n+    test(externs, code, code, null, null);\n+  }\n+\n   /**\n    * Expects the JS to generate one bad-read error.\n    */", "timestamp": 1308861909, "metainfo": ""}