{"sha": "93252fd6ea544d95224e3758576bc1d1ab580b5c", "log": "Don't keep a stack of CFGs during UnreachableCodeElimination.  R=blickly DELTA=259  (85 added, 77 deleted, 97 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5950   ", "commit": "\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.graph.GraphReachability;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n-import java.util.Deque;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n   private final AbstractCompiler compiler;\n   private final boolean removeNoOpStatements;\n \n-  Deque<ControlFlowGraph<Node>> cfgStack =\n-      new LinkedList<ControlFlowGraph<Node>>();\n-\n-  ControlFlowGraph<Node> curCfg = null;\n-\n   UnreachableCodeElimination(AbstractCompiler compiler,\n       boolean removeNoOpStatements) {\n     this.compiler = compiler;\n   }\n \n   @Override\n-  public void enterScope(NodeTraversal t) {\n+  public void exitScope(NodeTraversal t) {\n     Scope scope = t.getScope();\n \n     // Computes the control flow graph.\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n     cfa.process(null, scope.getRootNode());\n-    cfgStack.push(curCfg);\n-    curCfg = cfa.getCfg();\n-\n-    new GraphReachability<Node, ControlFlowGraph.Branch>(curCfg)\n-        .compute(curCfg.getEntry().getValue());\n-  }\n-\n-  @Override\n-  public void exitScope(NodeTraversal t) {\n-    curCfg = cfgStack.pop();\n+    ControlFlowGraph<Node> cfg = cfa.getCfg();\n+\n+    new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n+        .compute(cfg.getEntry().getValue());\n+\n+    Node root = scope.getRootNode();\n+    if (scope.isLocal()) {\n+      root = root.getLastChild();\n+    }\n+    NodeTraversal.traverse(\n+        compiler, root, new EliminationPass(cfg));\n   }\n \n   @Override\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n-  @Override\n-  public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (parent == null) {\n-      return;\n-    }\n-    if (n.isFunction() || n.isScript()) {\n-      return;\n-    }\n-\n-    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n-    if (gNode == null) { // Not in CFG.\n-      return;\n-    }\n-    if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n-        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n, compiler))) {\n-      removeDeadExprStatementSafely(n);\n-      return;\n-    }\n-\n-    tryRemoveUnconditionalBranching(n);\n-  }\n-\n-  /**\n-   * Tries to remove n if it is an unconditional branch node (break, continue,\n-   * or return) and the target of n is the same as the the follow of n.\n-   * That is, if removing n preserves the control flow. Also if n targets\n-   * another unconditional branch, this function will recursively try to remove\n-   * the target branch as well. The reason why we want to cascade this removal\n-   * is because we only run this pass once. If we have code such as\n-   *\n-   * break -> break -> break\n-   *\n-   * where all 3 breaks are useless, then the order of removal matters. When we\n-   * first look at the first break, we see that it branches to the 2nd break.\n-   * However, if we remove the last break, the 2nd break becomes useless and\n-   * finally the first break becomes useless as well.\n-   *\n-   * @return The target of this jump. If the target is also useless jump,\n-   *     the target of that useless jump recursively.\n-   */\n-  @SuppressWarnings(\"fallthrough\")\n-  private Node tryRemoveUnconditionalBranching(Node n) {\n-    /*\n-     * For each unconditional branching control flow node, check to see\n-     * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n-     * the branching target. If it is, the branch node is safe to be removed.\n+  private class EliminationPass extends AbstractShallowCallback {\n+    private final ControlFlowGraph<Node> cfg;\n+    private EliminationPass(ControlFlowGraph<Node> cfg) {\n+      this.cfg = cfg;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (parent == null) {\n+        return;\n+      }\n+      if (n.isFunction() || n.isScript()) {\n+        return;\n+      }\n+\n+      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n+      if (gNode == null) { // Not in CFG.\n+        return;\n+      }\n+      if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n+          (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n, compiler))) {\n+        removeDeadExprStatementSafely(n);\n+        return;\n+      }\n+\n+      tryRemoveUnconditionalBranching(n);\n+    }\n+\n+    /**\n+     * Tries to remove n if it is an unconditional branch node (break, continue,\n+     * or return) and the target of n is the same as the the follow of n.\n+     * That is, if removing n preserves the control flow. Also if n targets\n+     * another unconditional branch, this function will recursively try to remove\n+     * the target branch as well. The reason why we want to cascade this removal\n+     * is because we only run this pass once. If we have code such as\n      *\n-     * This is not as clever as MinimizeExitPoints because it doesn't do any\n-     * if-else conversion but it handles more complicated switch statements\n-     * much more nicely.\n+     * break -> break -> break\n+     *\n+     * where all 3 breaks are useless, then the order of removal matters. When we\n+     * first look at the first break, we see that it branches to the 2nd break.\n+     * However, if we remove the last break, the 2nd break becomes useless and\n+     * finally the first break becomes useless as well.\n+     *\n+     * @return The target of this jump. If the target is also useless jump,\n+     *     the target of that useless jump recursively.\n      */\n-\n-    // If n is null the target is the end of the function, nothing to do.\n-    if (n == null) {\n-       return n;\n-    }\n-\n-    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n-\n-    if (gNode == null) {\n+    @SuppressWarnings(\"fallthrough\")\n+    private Node tryRemoveUnconditionalBranching(Node n) {\n+      /*\n+       * For each unconditional branching control flow node, check to see\n+       * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n+       * the branching target. If it is, the branch node is safe to be removed.\n+       *\n+       * This is not as clever as MinimizeExitPoints because it doesn't do any\n+       * if-else conversion but it handles more complicated switch statements\n+       * much more nicely.\n+       */\n+\n+      // If n is null the target is the end of the function, nothing to do.\n+      if (n == null) {\n+         return n;\n+      }\n+\n+      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n+\n+      if (gNode == null) {\n+        return n;\n+      }\n+\n+      switch (n.getType()) {\n+        case Token.RETURN:\n+          if (n.hasChildren()) {\n+            break;\n+          }\n+        case Token.BREAK:\n+        case Token.CONTINUE:\n+\n+          // We are looking for a control flow changing statement that always\n+          // branches to the same node. If after removing it control still\n+          // branches to the same node, it is safe to remove.\n+          List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n+          if (outEdges.size() == 1 &&\n+              // If there is a next node, there is no chance this jump is useless.\n+              (n.getNext() == null || n.getNext().isFunction())) {\n+\n+            Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n+            Node fallThrough = computeFollowing(n);\n+            Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n+            if (nextCfgNode == fallThrough) {\n+              removeDeadExprStatementSafely(n);\n+              return fallThrough;\n+            }\n+          }\n+      }\n       return n;\n     }\n \n-    switch (n.getType()) {\n-      case Token.RETURN:\n-        if (n.hasChildren()) {\n+    private Node computeFollowing(Node n) {\n+      Node next = ControlFlowAnalysis.computeFollowNode(n);\n+      while (next != null && next.isBlock()) {\n+        if (next.hasChildren()) {\n+          next = next.getFirstChild();\n+        } else {\n+          next = computeFollowing(next);\n+        }\n+      }\n+      return next;\n+    }\n+\n+    private void removeDeadExprStatementSafely(Node n) {\n+      Node parent = n.getParent();\n+      if (n.isEmpty() ||\n+          (n.isBlock() && !n.hasChildren())) {\n+        // Not always trivial to remove, let FoldConstants work its magic later.\n+        return;\n+      }\n+\n+      // TODO(user): This is a problem with removeNoOpStatements.\n+      // Every expression in a FOR-IN header looks side effect free on its own.\n+      if (NodeUtil.isForIn(parent)) {\n+        return;\n+      }\n+\n+      switch (n.getType()) {\n+        // Removing an unreachable DO node is messy because it means we still have\n+        // to execute one iteration. If the DO's body has breaks in the middle, it\n+        // can get even more tricky and code size might actually increase.\n+        case Token.DO:\n+          return;\n+\n+        case Token.BLOCK:\n+          // BLOCKs are used in several ways including wrapping CATCH\n+          // blocks in TRYs\n+          if (parent.isTry()) {\n+            if (NodeUtil.isTryCatchNodeContainer(n)) {\n+              return;\n+            }\n+          }\n           break;\n-        }\n-      case Token.BREAK:\n-      case Token.CONTINUE:\n-\n-        // We are looking for a control flow changing statement that always\n-        // branches to the same node. If after removing it control still\n-        // branches to the same node, it is safe to remove.\n-        List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n-        if (outEdges.size() == 1 &&\n-            // If there is a next node, there is no chance this jump is useless.\n-            (n.getNext() == null || n.getNext().isFunction())) {\n-\n-          Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n-          Node fallThrough = computeFollowing(n);\n-          Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-          if (nextCfgNode == fallThrough) {\n-            removeDeadExprStatementSafely(n);\n-            return fallThrough;\n-          }\n-        }\n-    }\n-    return n;\n-  }\n-\n-  private Node computeFollowing(Node n) {\n-    Node next = ControlFlowAnalysis.computeFollowNode(n);\n-    while (next != null && next.isBlock()) {\n-      if (next.hasChildren()) {\n-        next = next.getFirstChild();\n-      } else {\n-        next = computeFollowing(next);\n-      }\n-    }\n-    return next;\n-  }\n-\n-  private void removeDeadExprStatementSafely(Node n) {\n-    Node parent = n.getParent();\n-    if (n.isEmpty() ||\n-        (n.isBlock() && !n.hasChildren())) {\n-      // Not always trivial to remove, let FoldConstants work its magic later.\n-      return;\n-    }\n-\n-    // TODO(user): This is a problem with removeNoOpStatements.\n-    // Every expression in a FOR-IN header looks side effect free on its own.\n-    if (NodeUtil.isForIn(parent)) {\n-      return;\n-    }\n-\n-    switch (n.getType()) {\n-      // Removing an unreachable DO node is messy because it means we still have\n-      // to execute one iteration. If the DO's body has breaks in the middle, it\n-      // can get even more tricky and code size might actually increase.\n-      case Token.DO:\n-        return;\n-\n-      case Token.BLOCK:\n-        // BLOCKs are used in several ways including wrapping CATCH\n-        // blocks in TRYs\n-        if (parent.isTry()) {\n-          if (NodeUtil.isTryCatchNodeContainer(n)) {\n-            return;\n-          }\n-        }\n-        break;\n-\n-      case Token.CATCH:\n-        Node tryNode = parent.getParent();\n-        NodeUtil.maybeAddFinally(tryNode);\n-        break;\n-    }\n-\n-\n-    if (n.isVar() && !n.getFirstChild().hasChildren()) {\n-      // Very Edge case, Consider this:\n-      // File 1: {throw 1}\n-      // File 2: {var x}\n-      // The node var x is unreachable in the global scope.\n-      // Before we remove the node, redeclareVarsInsideBranch\n-      // would basically move var x to the beginning of File 2,\n-      // which resulted in zero changes to the AST but triggered\n-      // reportCodeChange().\n-      // Instead, we should just ignore dead variable declarations.\n-      return;\n-    }\n-\n-    NodeUtil.redeclareVarsInsideBranch(n);\n-    compiler.reportCodeChange();\n-    if (logger.isLoggable(Level.FINE)) {\n-      logger.fine(\"Removing \" + n.toString());\n-    }\n-\n-    NodeUtil.removeChild(n.getParent(), n);\n-  }\n+\n+        case Token.CATCH:\n+          Node tryNode = parent.getParent();\n+          NodeUtil.maybeAddFinally(tryNode);\n+          break;\n+      }\n+\n+\n+      if (n.isVar() && !n.getFirstChild().hasChildren()) {\n+        // Very Edge case, Consider this:\n+        // File 1: {throw 1}\n+        // File 2: {var x}\n+        // The node var x is unreachable in the global scope.\n+        // Before we remove the node, redeclareVarsInsideBranch\n+        // would basically move var x to the beginning of File 2,\n+        // which resulted in zero changes to the AST but triggered\n+        // reportCodeChange().\n+        // Instead, we should just ignore dead variable declarations.\n+        return;\n+      }\n+\n+      NodeUtil.redeclareVarsInsideBranch(n);\n+      compiler.reportCodeChange();\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.fine(\"Removing \" + n.toString());\n+      }\n+\n+      NodeUtil.removeChild(n.getParent(), n);\n+    }\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {}\n+\n+  @Override\n+  public void enterScope(NodeTraversal t) {}\n }", "timestamp": 1355171011, "metainfo": ""}