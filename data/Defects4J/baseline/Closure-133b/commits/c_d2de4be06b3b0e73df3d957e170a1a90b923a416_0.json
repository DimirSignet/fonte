{"sha": "d2de4be06b3b0e73df3d957e170a1a90b923a416", "log": "Enable stable renaming for \"name anonymous functions\" when used in \"MAPPED\" mode.  R=mwr DELTA=76  (62 added, 4 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5694   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   /** Give anonymous functions names for easier debugging */\n   public AnonymousFunctionNamingPolicy anonymousFunctionNaming;\n \n-  /** Serialized input variable renaming map. */\n+  /** Input anonymous function renaming map. */\n+  VariableMap inputAnonymousFunctionNamingMap;\n+\n+  /** Input variable renaming map. */\n   VariableMap inputVariableMap;\n \n-  /** Serialized input property renaming map. */\n+  /** Input property renaming map. */\n   VariableMap inputPropertyMap;\n \n   /** Whether to export test functions. */\n     this.anonymousFunctionNaming = anonymousFunctionNaming;\n   }\n \n+  public void setInputAnonymousFunctionNamingMap(VariableMap inputMap) {\n+    this.inputAnonymousFunctionNamingMap = inputMap;\n+  }\n+\n   @Deprecated\n   public void setInputVariableMapSerialized(byte[] inputVariableMapSerialized)\n       throws ParseException {\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       return new CompilerPass() {\n         @Override public void process(Node externs, Node root) {\n           NameAnonymousFunctionsMapped naf =\n-              new NameAnonymousFunctionsMapped(compiler);\n+              new NameAnonymousFunctionsMapped(\n+                  compiler, options.inputAnonymousFunctionNamingMap);\n           naf.process(externs, root);\n           anonymousFunctionNameMap = naf.getFunctionMap();\n         }\n--- a/src/com/google/javascript/jscomp/NameAnonymousFunctionsMapped.java\n+++ b/src/com/google/javascript/jscomp/NameAnonymousFunctionsMapped.java\n \n   private final AbstractCompiler compiler;\n   private final NameGenerator nameGenerator;\n+  private final VariableMap previousMap;\n   private final Map<String, String> renameMap;\n \n   private int namedCount = 0;\n   private int bytesUsed = 0;\n \n-  NameAnonymousFunctionsMapped(AbstractCompiler compiler) {\n+  NameAnonymousFunctionsMapped(\n+      AbstractCompiler compiler, VariableMap previousMap) {\n     this.compiler = compiler;\n-    nameGenerator = new NameGenerator(\n-        Collections.<String>emptySet(), PREFIX_STRING, null);\n-    renameMap = Maps.newHashMap();\n+    Set<String> reserved =\n+        previousMap != null ?\n+            previousMap.getNewNameToOriginalNameMap().keySet() :\n+            Collections.<String>emptySet();\n+    this.nameGenerator = new NameGenerator(reserved, PREFIX_STRING, null);\n+    this.previousMap = previousMap;\n+    this.renameMap = Maps.newHashMap();\n   }\n \n   @Override\n     @Override\n     public final void setFunctionName(String name, Node fnNode) {\n       Node fnNameNode = fnNode.getFirstChild();\n-      String newName = renameMap.get(name);\n-      if (newName == null) {\n-        newName = nameGenerator.generateNextName();\n-        renameMap.put(name, newName);\n-      }\n+      String newName = getAlternateName(name);\n       fnNameNode.setString(newName);\n       namedCount++;\n       bytesUsed += newName.length();\n+    }\n+\n+    String getAlternateName(String name) {\n+      String newName = renameMap.get(name);\n+      if (newName == null) {\n+        // Use the previously used name, if possible.\n+        if (previousMap != null) {\n+          newName = previousMap.lookupNewName(name);\n+        }\n+        if (newName == null) {\n+          // otherwise generate a new name.\n+          newName = nameGenerator.generateNextName();\n+        }\n+        renameMap.put(name, newName);\n+      }\n+      return newName;\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     if (info != null) {\n       if (info.hasType()) {\n         JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n+        // remove cast check here.\n         validator.expectCanCast(t, n, infoType, type);\n         type = infoType;\n       }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       if (info != null && info.hasType()) {\n         JSType castType = info.getType().evaluate(syntacticScope, registry);\n \n+        // validate cast here\n+\n         // A stubbed type cast on a qualified name should take\n         // effect for all subsequent accesses of that name,\n         // so treat it the same as an assign to that name.\n--- a/test/com/google/javascript/jscomp/NameAnonymousFunctionsMappedTest.java\n+++ b/test/com/google/javascript/jscomp/NameAnonymousFunctionsMappedTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableMap;\n+\n /**\n  * Test cases for {@link NameAnonymousFunctionsMapped}.\n  *\n   private static final String EXTERNS = \"var document;\";\n \n   private NameAnonymousFunctionsMapped pass;\n+  private VariableMap previous;\n \n   public NameAnonymousFunctionsMappedTest() {\n     super(EXTERNS);\n   }\n \n   @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    previous = null;\n+  }\n+\n+  @Override\n   public CompilerPass getProcessor(Compiler compiler) {\n-    return pass = new NameAnonymousFunctionsMapped(compiler);\n+    return pass = new NameAnonymousFunctionsMapped(compiler, previous);\n   }\n \n   private void assertMapping(String... pairs) {\n         functionMap.getNewNameToOriginalNameMap().size());\n   }\n \n-  public void testSimpleVarAssignment() {\n+  public void testSimpleVarAssignment1() {\n     test(\"var a = function() { return 1; }\",\n          \"var a = function $() { return 1; }\");\n     assertMapping(\"$\", \"a\");\n+  }\n+\n+  public void testSimpleVarAssignment2() {\n+    previous = VariableMap.fromMap(ImmutableMap.<String,String>of(\n+        \"a\", \"previous\"));\n+\n+    test(\"var a = function() { return 1; }\",\n+         \"var a = function previous() { return 1; }\");\n+\n+    assertMapping(\"previous\", \"a\");\n+  }\n+\n+  public void testSimpleVarAssignment3() {\n+    previous = VariableMap.fromMap(ImmutableMap.<String,String>of(\n+        \"unused\", \"$\"));\n+\n+    test(\"var fn = function() { return 1; }\",\n+         \"var fn = function $a() { return 1; }\");\n+\n+    assertMapping(\"$a\", \"fn\");\n   }\n \n   public void testAssignmentToProperty() {", "timestamp": 1350944838, "metainfo": ""}