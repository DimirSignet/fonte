{"sha": "2353d807058bc2a20af279a480d6652cdf892f4d", "log": "Improve the scheduling of loopable passes  R=nicksantos DELTA=64 (36 added, 10 deleted, 18 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6077   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n import com.google.javascript.rhino.Node;\n \n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n import java.util.logging.Logger;\n      \"minimizeExitPoints\",\n      \"inlineVariables\",\n      \"collapseObjectLiterals\",\n-     \"peepholeOptimizations\"\n-     );\n+     \"peepholeOptimizations\");\n \n   static final int MAX_LOOPS = 100;\n   static final String OPTIMIZE_LOOP_ERROR =\n       \"Fixed point loop exceeded the maximum number of iterations.\";\n+\n+  // Only used by Loop/process, but enum types can't be local\n+  enum State {\n+    RUN_PASSES_NOT_RUN_IN_PREV_ITER,\n+    RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER\n+  }\n \n   private static final Logger logger =\n       Logger.getLogger(PhaseOptimizer.class.getName());\n    * Add the passes generated by the given factories to the compile sequence.\n    *\n    * Automatically pulls multi-run passes into fixed point loops. If there\n-   * are 2 or more multi-run passes in a row, they will run together in\n-   * the same fixed point loop. If A and B are in the same fixed point loop,\n-   * the loop will continue to run both A and B until both are finished\n+   * are 1 or more multi-run passes in a row, they will run together in\n+   * the same fixed point loop. The passes will run until they are finished\n    * making changes.\n    *\n-   * Other than that, the PhaseOptimizer is free to tweak the order and\n-   * frequency of multi-run passes in a fixed-point loop.\n+   * The PhaseOptimizer is free to tweak the order and frequency of multi-run\n+   * passes in a fixed-point loop.\n    */\n   void consume(List<PassFactory> factories) {\n     Loop currentLoop = new Loop();\n    * A single compiler pass.\n    */\n   class NamedPass implements CompilerPass {\n-    private final String name;\n+    final String name;\n     private final PassFactory factory;\n \n     NamedPass(PassFactory factory) {\n         optimizePasses();\n       }\n \n+      // Contains a pass iff it made changes the last time it was run.\n+      Set<NamedPass> madeChanges = new HashSet<NamedPass>();\n+      // Contains a pass iff it was run during the last inner loop.\n+      Set<NamedPass> runInPrevIter = new HashSet<NamedPass>();\n+      State s = State.RUN_PASSES_NOT_RUN_IN_PREV_ITER;\n+      boolean lastIterMadeChanges;\n+      int count = 0;\n+\n       try {\n-        // TODO(nicksantos): Use a smarter algorithm that dynamically adjusts\n-        // the order that passes are run in.\n-        int count = 0;\n-        out: do {\n+        while (true) {\n           if (count++ > MAX_LOOPS) {\n             compiler.throwInternalError(OPTIMIZE_LOOP_ERROR, null);\n           }\n-\n-          recentChange.reset();  // reset before this round of optimizations\n-\n-          for (CompilerPass pass : myPasses) {\n-            pass.process(externs, root);\n-            if (hasHaltingErrors()) {\n-              break out;\n+          lastIterMadeChanges = false;\n+          for (NamedPass pass : myPasses) {\n+            recentChange.reset();\n+            if ((s == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER &&\n+                !runInPrevIter.contains(pass)) ||\n+                (s == State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER &&\n+                    madeChanges.contains(pass))) {\n+              pass.process(externs, root);\n+              runInPrevIter.add(pass);\n+              if (hasHaltingErrors()) {\n+                return;\n+              } else if (recentChange.hasCodeChanged()) {\n+                madeChanges.add(pass);\n+                lastIterMadeChanges = true;\n+              } else {\n+                madeChanges.remove(pass);\n+              }\n+            } else {\n+              runInPrevIter.remove(pass);\n             }\n           }\n-\n-        } while (recentChange.hasCodeChanged() && !hasHaltingErrors());\n-\n-        if (randomizeLoops) {\n-          loopsRun.add(getPassOrder());\n+          if (s == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER) {\n+            if (lastIterMadeChanges) {\n+              s = State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER;\n+            } else {\n+              return;\n+            }\n+          } else if (!lastIterMadeChanges) {\n+            s = State.RUN_PASSES_NOT_RUN_IN_PREV_ITER;\n+          }\n         }\n       } finally {\n         loopMutex = false;\n--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n     Loop loop = optimizer.addFixedPointLoop();\n     addLoopedPass(loop, \"x\", 3);\n     addLoopedPass(loop, \"y\", 1);\n-    assertPasses(\"x\", \"y\", \"x\", \"y\", \"x\", \"y\", \"x\", \"y\");\n+    assertPasses(\"x\", \"y\", \"x\", \"y\", \"x\", \"x\", \"y\");\n   }\n \n   public void testNotInfiniteLoop() {\n     Loop loop = optimizer.addFixedPointLoop();\n-    addLoopedPass(loop, \"x\", PhaseOptimizer.MAX_LOOPS);\n+    addLoopedPass(loop, \"x\", PhaseOptimizer.MAX_LOOPS - 1);\n     optimizer.process(null, null);\n     assertEquals(\"There should be no errors.\", 0, compiler.getErrorCount());\n   }\n     addLoopedPass(loop, \"x\", 3);\n     addLoopedPass(loop, \"y\", 1);\n     addOneTimePass(\"z\");\n-    assertPasses(\"a\", \"x\", \"y\", \"x\", \"y\", \"x\", \"y\", \"x\", \"y\", \"z\");\n+    assertPasses(\"a\", \"x\", \"y\", \"x\", \"y\", \"x\", \"x\", \"y\", \"z\");\n   }\n \n   public void testSanityCheck() {\n             createPassFactory(\"d\", 1, false),\n             createPassFactory(\"e\", 1, true),\n             createPassFactory(\"f\", 0, true)));\n-    assertPasses(\"a\", \"b\", \"c\", \"d\", \"b\", \"c\", \"d\", \"b\", \"c\", \"d\", \"e\", \"f\");\n+    assertPasses(\"a\", \"b\", \"c\", \"d\", \"b\", \"c\", \"d\", \"c\", \"b\", \"d\", \"e\", \"f\");\n   }\n \n   public void testConsumption2() {", "timestamp": 1357335383, "metainfo": ""}