{"sha": "475548341c38755063c8475379745ba31caffe41", "log": "Change on 2010/05/06 by nick          Automatic source sorting--now with modules!          R=alan         DELTA=194  (176 added, 7 deleted, 11 changed)  Change on 2010/05/06 by nick          Identify unknown @suppress parameters.          R=alan         DELTA=109  (83 added, 12 deleted, 14 changed)  Change on 2010/05/06 by alan          Enable flow sensitive inlining in open source world.          R=nick         DELTA=2  (2 added, 0 deleted, 0 changed)  Change on 2010/05/06 by alan          Factor out JoinOp          R=nick         DELTA=137  (77 added, 54 deleted, 6 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=ewwtfu   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n     options.optimizeArgumentsArray = true;\n     options.removeUnusedVars = true;\n     options.removeUnusedVarsInGlobalScope = false;\n+    options.flowSensitiveInlineVariables = true;\n \n     // Allows annotations that are not standard.\n     options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,\n     options.labelRenaming = true;\n     options.removeDeadCode = true;\n     options.optimizeArgumentsArray = true;\n+    options.flowSensitiveInlineVariables = true;\n \n     // All the advance optimizations.\n     options.reserveRawExports = true;\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n-import com.google.javascript.jscomp.deps.SortedDependencies;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.parsing.Config;\n import com.google.javascript.jscomp.parsing.ParserRunner;\n import java.io.IOException;\n import java.io.PrintStream;\n import java.io.Serializable;\n-import java.util.ArrayList;\n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n   // The JS source modules\n   private List<JSModule> modules;\n \n-  // The graph of the JS source modules\n+  // The graph of the JS source modules. Must be null if there are less than\n+  // 2 modules, because we use this as a signal for which passes to run.\n   private JSModuleGraph moduleGraph;\n \n   // The JS source inputs\n           input.setCompiler(this);\n         }\n \n-        SortedDependencies<CompilerInput> sorter =\n-            new SortedDependencies<CompilerInput>(inputs);\n-        inputs = Lists.newArrayList(\n-            sorter.getSortedDependenciesOf(\n-                sorter.getInputsWithoutProvides()));\n+        inputs =\n+            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n+            .manageDependencies(inputs);\n       }\n \n       // Check if externs files need to be lifted.\n   @Override\n   Config getParserConfig() {\n     if (parserConfig == null) {\n-      parserConfig = ParserRunner.createConfig(\n-          getTypeRegistry(), isIdeMode());\n+      parserConfig = ParserRunner.createConfig(isIdeMode());\n     }\n     return parserConfig;\n   }\n--- a/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Function;\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n  */\n abstract class DataFlowAnalysis<N, L extends LatticeElement> {\n \n-  static interface JoinOp<L extends LatticeElement>\n-      extends Function<List<L>, L> {\n-  }\n-\n-  /**\n-   * An implementation of {@code JoinOp} that makes it easy to join to\n-   * lattice elements at a time.\n-   */\n-  static abstract class BinaryJoinOp<L extends LatticeElement>\n-      implements JoinOp<L> {\n-    @Override\n-    public final L apply(List<L> values) {\n-      Preconditions.checkArgument(!values.isEmpty());\n-      int size = values.size();\n-      if (size == 1) {\n-        return values.get(0);\n-      } else if (size == 2) {\n-        return apply(values.get(0), values.get(1));\n-      } else {\n-        int mid = computeMidPoint(size);\n-        return apply(\n-            apply(values.subList(0, mid)),\n-            apply(values.subList(mid, size)));\n-      }\n-    }\n-\n-    /**\n-     * Creates a new lattice that will be the join of two input lattices.\n-     *\n-     * @return The join of {@code latticeA} and {@code latticeB}.\n-     */\n-    abstract L apply(L latticeA, L latticeB);\n-\n-    /**\n-     * Finds the midpoint of a list. The function will favor two lists of\n-     * even length instead of two lists of the same odd length. The list\n-     * must be at least length two.\n-     *\n-     * @param size Size of the list.\n-     */\n-    static int computeMidPoint(int size) {\n-      int midpoint = size >>> 1;\n-      if (size > 4) {\n-        /* Any list longer than 4 should prefer an even split point\n-         * over the true midpoint, so that [0,6] splits at 2, not 3. */\n-        midpoint &= -2; // (0xfffffffe) clears low bit so midpoint is even\n-      }\n-      return midpoint;\n-    }\n-  }\n-\n   private final ControlFlowGraph<N> cfg;\n   final JoinOp<L> joinOp;\n   protected final Set<DiGraphNode<N, Branch>> orderedWorkSet;\n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.LinkedHashMultimap;\n+import com.google.common.collect.LinkedListMultimap;\n+import com.google.common.collect.ListMultimap;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n+import com.google.javascript.jscomp.deps.SortedDependencies;\n \n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.Comparator;\n-import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n    */\n   Iterable<JSModule> getAllModules() {\n     return moduleDepths.keySet();\n+  }\n+\n+  /**\n+   * Gets all the modules in dependency order.\n+   */\n+  private Iterable<JSModule> getAllModulesInDependencyOrder() {\n+    List<JSModule> modules = Lists.newArrayList(getAllModules());\n+    Collections.sort(modules, new DepthComparator());\n+    return modules;\n   }\n \n   /**\n   }\n \n   /**\n+   * Sort the sources of modules in dependency-order.\n+   *\n+   * If a source file provides a symbol that is not required, then that\n+   * file will be removed from the compilation. If a source file provides\n+   * a symbol that is not required until a later module, then that\n+   * file will be moved to the later module.\n+   *\n+   * @param The original list of sources. Used to ensure that the sort\n+   *     is stable.\n+   * @return The sorted list of sources.\n+   */\n+  List<CompilerInput> manageDependencies(List<CompilerInput> inputs) {\n+    SortedDependencies<CompilerInput> sorter =\n+        new SortedDependencies<CompilerInput>(inputs);\n+    List<CompilerInput> inputsWithoutProvides =\n+        sorter.getInputsWithoutProvides();\n+\n+    // The order of inputs, sorted independently of modules.\n+    List<CompilerInput> absoluteOrder = sorter.getSortedDependenciesOf(inputs);\n+\n+    // Figure out which sources *must* be in each module.\n+    ListMultimap<JSModule, CompilerInput> inputsWithoutProvidesPerModule =\n+        LinkedListMultimap.create();\n+    for (CompilerInput input : inputsWithoutProvides) {\n+      JSModule module = input.getModule();\n+      Preconditions.checkNotNull(module);\n+      inputsWithoutProvidesPerModule.put(module, input);\n+    }\n+\n+    // Clear the modules of their inputs. This also nulls out\n+    // the input's reference to its module.\n+    for (JSModule module : getAllModules()) {\n+      module.removeAll();\n+    }\n+\n+    // Figure out which sources *must* be in each module, or in one\n+    // of that module's dependencies.\n+    for (JSModule module : inputsWithoutProvidesPerModule.keySet()) {\n+      List<CompilerInput> transitiveClosure =\n+          sorter.getSortedDependenciesOf(\n+              inputsWithoutProvidesPerModule.get(module));\n+      for (CompilerInput input : transitiveClosure) {\n+        JSModule oldModule = input.getModule();\n+        input.setModule(\n+            oldModule == null ?\n+                module :\n+                getDeepestCommonDependencyInclusive(oldModule, module));\n+      }\n+    }\n+\n+    // All the inputs are pointing to the modules that own them. Yeah!\n+    // Update the modules to reflect this.\n+    for (CompilerInput input : absoluteOrder) {\n+      JSModule module = input.getModule();\n+      if (module != null) {\n+        module.add(input);\n+      }\n+    }\n+\n+    // Now, generate the sorted result.\n+    List<CompilerInput> result = Lists.newArrayList();\n+    for (JSModule module : getAllModulesInDependencyOrder()) {\n+      result.addAll(module.getInputs());\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * A module depth comparator that considers a deeper module to be\n+   * \"greater than\" a shallower module. Uses module names to\n+   * consistently break ties.\n+   */\n+  private class DepthComparator implements Comparator<JSModule> {\n+    public int compare(JSModule m1, JSModule m2) {\n+      return depthCompare(m1, m2);\n+    }\n+  }\n+\n+  /**\n    * A module depth comparator that considers a deeper module to be \"less than\"\n    * a shallower module. Uses module names to consistently break ties.\n    */\n   private class InverseDepthComparator implements Comparator<JSModule> {\n     public int compare(JSModule m1, JSModule m2) {\n-      if (m1 == m2) {\n-        return 0;\n-      }\n-      int d1 = getDepth(m1);\n-      int d2 = getDepth(m2);\n-      return d2 < d1 ? -1 : d2 == d1 ? m2.getName().compareTo(m1.getName()) : 1;\n-    }\n+      return depthCompare(m2, m1);\n+    }\n+  }\n+\n+  private int depthCompare(JSModule m1, JSModule m2) {\n+    if (m1 == m2) {\n+      return 0;\n+    }\n+    int d1 = getDepth(m1);\n+    int d2 = getDepth(m2);\n+    return d1 < d2 ? -1 : d2 == d1 ? m1.getName().compareTo(m2.getName()) : 1;\n   }\n \n   /*\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/JoinOp.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Function;\n+import com.google.common.base.Preconditions;\n+\n+import java.util.List;\n+\n+/**\n+ * Defines a way join a list of LatticeElements.\n+ */\n+interface JoinOp<L extends LatticeElement> extends Function<List<L>, L> {\n+\n+  /**\n+   * An implementation of {@code JoinOp} that makes it easy to join to\n+   * lattice elements at a time.\n+   */\n+  static abstract class BinaryJoinOp<L extends LatticeElement>\n+      implements JoinOp<L> {\n+    @Override\n+    public final L apply(List<L> values) {\n+      Preconditions.checkArgument(!values.isEmpty());\n+      int size = values.size();\n+      if (size == 1) {\n+        return values.get(0);\n+      } else if (size == 2) {\n+        return apply(values.get(0), values.get(1));\n+      } else {\n+        int mid = computeMidPoint(size);\n+        return apply(\n+            apply(values.subList(0, mid)),\n+            apply(values.subList(mid, size)));\n+      }\n+    }\n+    \n+    /**\n+     * Creates a new lattice that will be the join of two input lattices.\n+     *\n+     * @return The join of {@code latticeA} and {@code latticeB}.\n+     */\n+    abstract L apply(L latticeA, L latticeB);\n+\n+    /**\n+     * Finds the midpoint of a list. The function will favor two lists of\n+     * even length instead of two lists of the same odd length. The list\n+     * must be at least length two.\n+     *\n+     * @param size Size of the list.\n+     */\n+    static int computeMidPoint(int size) {\n+      int midpoint = size >>> 1;\n+      if (size > 4) {\n+        /* Any list longer than 4 should prefer an even split point\n+         * over the true midpoint, so that [0,6] splits at 2, not 3. */\n+        midpoint &= -2; // (0xfffffffe) clears low bit so midpoint is even\n+      }\n+      return midpoint;\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/LinkedFlowScope.java\n+++ b/src/com/google/javascript/jscomp/LinkedFlowScope.java\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.DataFlowAnalysis.BinaryJoinOp;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.SimpleSlot;\n   }\n \n   /** Join the two FlowScopes. */\n-  static class FlowScopeJoinOp extends BinaryJoinOp<FlowScope> {\n+  static class FlowScopeJoinOp extends JoinOp.BinaryJoinOp<FlowScope> {\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public FlowScope apply(FlowScope a, FlowScope b) {\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n \n   MustBeReachingVariableDef(\n       ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) {\n-    super(cfg, new JoinOp());\n+    super(cfg, new MustDefJoin());\n     this.jsScope = jsScope;\n     this.compiler = compiler;\n     this.escaped = Sets.newHashSet();\n     }\n   }\n \n-  private static class JoinOp extends DataFlowAnalysis.BinaryJoinOp<MustDef> {\n+  private static class MustDefJoin extends JoinOp.BinaryJoinOp<MustDef> {\n     @Override\n     public MustDef apply(MustDef a, MustDef b) {\n       MustDef result = new MustDef();\n--- a/src/com/google/javascript/jscomp/parsing/Config.java\n+++ b/src/com/google/javascript/jscomp/parsing/Config.java\n   final Map<String, Annotation> annotationNames;\n \n   /**\n+   * Recognized names in a {@code @suppress} tag.\n+   */\n+  final Set<String> suppressionNames;\n+\n+  /**\n    * Annotation names.\n    */\n \n-  Config(Set<String> annotationWhitelist, boolean isIdeMode) {\n+  Config(Set<String> annotationWhitelist, Set<String> suppressionNames,\n+      boolean isIdeMode) {\n     this.annotationNames = buildAnnotationNames(annotationWhitelist);\n     this.parseJsDocDocumentation = isIdeMode;\n+    this.suppressionNames = suppressionNames;\n     this.isIdeMode = isIdeMode;\n   }\n \n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n   private State state;\n \n   private final Map<String, Annotation> annotationNames;\n+  private final Set<String> suppressionNames;\n \n   private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;\n \n     this.sourceName = sourceName;\n     this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n     this.annotationNames = config.annotationNames;\n+    this.suppressionNames = config.suppressionNames;\n \n     this.errorReporter = errorReporter;\n   }\n    */\n   public static Node parseTypeString(String typeString) {\n     Config config = new Config(\n+        Sets.<String>newHashSet(),\n         Sets.<String>newHashSet(),\n         false);\n     JsDocInfoParser parser = new JsDocInfoParser(\n       Set<String> suppressions = new HashSet<String>();\n       while (true) {\n         if (match(JsDocToken.STRING)) {\n+          String name = stream.getString();\n+          if (!suppressionNames.contains(name)) {\n+            parser.addWarning(\"msg.jsdoc.suppress.unknown\", name,\n+                stream.getLineno(), stream.getCharno());\n+          }\n+\n           suppressions.add(stream.getString());\n           token = next();\n         } else {\n--- a/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n+++ b/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n \n   private static Set<String> annotationNames = null;\n \n+  private static Set<String> suppressionNames = null;\n+\n   // Should never need to instantiate class of static methods.\n   private ParserRunner() {}\n \n-  public static Config createConfig(\n-      JSTypeRegistry typeRegistry, boolean isIdeMode) {\n-    return new Config(getAnnotationNames(), isIdeMode);\n+  public static Config createConfig(boolean isIdeMode) {\n+    initResourceConfig();\n+    return new Config(annotationNames, suppressionNames, isIdeMode);\n   }\n \n-  /**\n-   * Gets a list of extra annotations that are OK, even if the parser\n-   * doesn't have handlers for them built-in.\n-   */\n-  static Set<String> getAnnotationNames() {\n-    initAnnotationNames();\n-    return annotationNames;\n-  }\n-\n-  private static synchronized void initAnnotationNames() {\n+  private static synchronized void initResourceConfig() {\n     if (annotationNames != null) {\n       return;\n     }\n \n+    ResourceBundle config = ResourceBundle.getBundle(configResource);\n+    annotationNames = extractList(config.getString(\"jsdoc.annotations\"));\n+    suppressionNames = extractList(config.getString(\"jsdoc.suppressions\"));\n+  }\n+\n+  private static Set<String> extractList(String configProp) {\n+    String[] names = configProp.split(\",\");\n     Set<String> trimmedNames = Sets.newHashSet();\n-    ResourceBundle config = ResourceBundle.getBundle(configResource);\n-    String[] names = config.getString(\"jsdoc.annotations\").split(\",\");\n     for (String name : names) {\n       trimmedNames.add(name.trim());\n     }\n-    annotationNames = ImmutableSet.copyOf(trimmedNames);\n+    return ImmutableSet.copyOf(trimmedNames);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       DIRECTIVES         = 48,    // The ES5 directives on this node.\n       DIRECT_EVAL        = 49,    // ES5 distinguishes between direct and\n                                   // indirect calls to eval.\n-      LAST_PROP          = 49;\n+      SUPPRESSIONS       = 50,    // Used by the compiler to associate\n+                                  // @suppress directly with functions\n+                                  // and scripts.\n+      LAST_PROP          = 50;\n \n   // values of ISNUMBER_PROP to specify\n   // which of the children are Number types\n   }\n \n   /**\n+   * Sets the warning suppressions on this node.\n+   */\n+  public void setSuppressions(Set<String> val) {\n+    Preconditions.checkState(type == Token.FUNCTION || type == Token.SCRIPT);\n+    putProp(SUPPRESSIONS, val);\n+  }\n+\n+  /**\n+   * Returns the set of supressions for this node.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public Set<String> getSuppressions() {\n+    return (Set<String>) getProp(SUPPRESSIONS);\n+  }\n+\n+  /**\n    * Sets whether this is a synthetic block that should not be considered\n    * a real source block.\n    */\n--- a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n-import com.google.javascript.jscomp.DataFlowAnalysis.BinaryJoinOp;\n import com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState;\n import com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis;\n import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n import com.google.javascript.jscomp.DataFlowAnalysis.MaxIterationsExceededException;\n+import com.google.javascript.jscomp.JoinOp.BinaryJoinOp;\n import com.google.javascript.jscomp.graph.GraphNode;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n \n   }\n \n   public void testLatticeArrayMinimizationWhenMidpointIsEven() {\n-    assertEquals(6, DataFlowAnalysis.BinaryJoinOp.computeMidPoint(12));\n+    assertEquals(6, JoinOp.BinaryJoinOp.computeMidPoint(12));\n   }\n \n   public void testLatticeArrayMinimizationWhenMidpointRoundsDown() {\n-    assertEquals(8, DataFlowAnalysis.BinaryJoinOp.computeMidPoint(18));\n+    assertEquals(8, JoinOp.BinaryJoinOp.computeMidPoint(18));\n   }\n \n   public void testLatticeArrayMinimizationWithTwoElements() {\n-    assertEquals(1, DataFlowAnalysis.BinaryJoinOp.computeMidPoint(2));\n+    assertEquals(1, JoinOp.BinaryJoinOp.computeMidPoint(2));\n   }\n \n \n--- a/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n+++ b/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n \n import junit.framework.*;\n \n   private final JSModule E = new JSModule(\"E\");\n   private final JSModule F = new JSModule(\"F\");\n   private JSModuleGraph graph = null;\n+\n+  // For resolving dependencies only.\n+  private Compiler compiler;\n \n   @Override\n   public void setUp() throws Exception {\n     F.addDependency(C);  //       F\n     F.addDependency(E);\n     graph = new JSModuleGraph(new JSModule[] {A, B, C, D, E, F});\n+    compiler = new Compiler();\n   }\n \n   public void testModuleDepth() {\n     assertEquals(\"d.js\", E.getInputs().get(0).getName());\n   }\n \n+  public void testManageDependencies() {\n+    List<CompilerInput> inputs = Lists.newArrayList();\n+\n+    A.add(code(\"a1\", provides(\"a1\"), requires()));\n+    A.add(code(\"a2\", provides(\"a2\"), requires(\"a1\")));\n+    A.add(code(\"a3\", provides(), requires(\"a1\")));\n+\n+    B.add(code(\"b1\", provides(\"b1\"), requires(\"a2\")));\n+    B.add(code(\"b2\", provides(), requires(\"a1\", \"a2\")));\n+\n+    C.add(code(\"c1\", provides(\"c1\"), requires(\"a1\")));\n+    C.add(code(\"c2\", provides(\"c2\"), requires(\"c1\")));\n+\n+    E.add(code(\"e1\", provides(), requires(\"c1\")));\n+    E.add(code(\"e2\", provides(), requires(\"c1\")));\n+\n+    inputs.addAll(A.getInputs());\n+    inputs.addAll(B.getInputs());\n+    inputs.addAll(C.getInputs());\n+    inputs.addAll(E.getInputs());\n+\n+    for (CompilerInput input : inputs) {\n+      input.setCompiler(compiler);\n+    }\n+\n+    List<CompilerInput> results = graph.manageDependencies(inputs);\n+\n+    assertInputs(A, \"a1\", \"a3\");\n+    assertInputs(B, \"a2\", \"b2\");\n+    assertInputs(C); // no inputs\n+    assertInputs(E, \"c1\", \"e1\", \"e2\");\n+\n+    assertEquals(\n+        Lists.newArrayList(\"a1\", \"a3\", \"a2\", \"b2\", \"c1\", \"e1\", \"e2\"),\n+        sourceNames(results));\n+  }\n+\n+  private void assertInputs(JSModule module, String ... sourceNames) {\n+    List<CompilerInput> actualInputs = module.getInputs();\n+\n+    assertEquals(\n+        Lists.newArrayList(sourceNames),\n+        sourceNames(module.getInputs()));\n+  }\n+\n+  private List<String> sourceNames(List<CompilerInput> inputs) {\n+    List<String> inputNames = Lists.newArrayList();\n+    for (CompilerInput input : inputs) {\n+      inputNames.add(input.getName());\n+    }\n+    return inputNames;\n+  }\n+\n+  private JSSourceFile code(\n+      String sourceName, List<String> provides, List<String> requires) {\n+    String text = \"\";\n+    for (String p : provides) {\n+      text += \"goog.provide('\" + p + \"');\\n\";\n+    }\n+    for (String r : requires) {\n+      text += \"goog.require('\" + r + \"');\\n\";\n+    }\n+    return JSSourceFile.fromCode(sourceName, text);\n+  }\n+\n+  private List<String> provides(String ... strings) {\n+    return Lists.newArrayList(strings);\n+  }\n+\n+  private List<String> requires(String ... strings) {\n+    return Lists.newArrayList(strings);\n+  }\n \n   private void assertDeepestCommonDepInclusive(\n       JSModule expected, JSModule m1, JSModule m2) {\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n     Parser p = new Parser(environment);\n     AstRoot script = p.parse(string, null, 0);\n \n-    Config config = new Config(ParserRunner.getAnnotationNames(), true);\n+    Config config = ParserRunner.createConfig(true);\n     Node root = IRFactory.transformTree(script, string, config,\n         new TestErrorReporter(null, null));\n \n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n public class JsDocInfoParserTest extends BaseJSTypeTestCase {\n \n   private Set<String> extraAnnotations;\n+  private Set<String> extraSuppressions;\n   private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = null;\n \n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n-    extraAnnotations = Sets.newHashSet(ParserRunner.getAnnotationNames());\n+    extraAnnotations =\n+        Sets.newHashSet(\n+            ParserRunner.createConfig(true).annotationNames.keySet());\n+    extraSuppressions =\n+        Sets.newHashSet(\n+            ParserRunner.createConfig(true).suppressionNames);\n+\n+    extraSuppressions.add(\"x\");\n+    extraSuppressions.add(\"y\");\n+    extraSuppressions.add(\"z\");\n   }\n \n   public void testParseTypeViaStatic1() throws Exception {\n \n   public void testBadSuppress6() throws Exception {\n     parse(\"@suppress {x} \\n * @suppress {y} */\", \"duplicate @suppress tag\");\n+  }\n+\n+  public void testBadSuppress7() throws Exception {\n+    parse(\"@suppress {impossible} */\",\n+          \"unknown @suppress parameter: impossible\");\n   }\n \n   //public void testNoParseFileOverview() throws Exception {\n     Parser p = new Parser(environment, testErrorReporter);\n     AstRoot script = p.parse(code, null, 0);\n \n-    Config config = new Config(extraAnnotations, true);\n+    Config config =\n+        new Config(extraAnnotations, extraSuppressions, true);\n     for (Comment comment : script.getComments()) {\n       JsDocInfoParser jsdocParser =\n         new JsDocInfoParser(\n       boolean parseFileOverview, String... warnings) {\n     TestErrorReporter errorReporter = new TestErrorReporter(null, warnings);\n \n-    Config config = new Config(extraAnnotations, parseDocumentation);\n+    Config config = new Config(extraAnnotations, extraSuppressions,\n+        parseDocumentation);\n     JsDocInfoParser jsdocParser = new JsDocInfoParser(stream(comment),\n         \"testcode\", config, errorReporter);\n \n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n     Node script = null;\n     try {\n       script = ParserRunner.parse(\n-          \"input\", string, ParserRunner.createConfig(registry, true),\n+          \"input\", string, ParserRunner.createConfig(true),\n           testErrorReporter, Logger.getAnonymousLogger());\n     } catch (IOException e) {\n       throw new RuntimeException(e);\n     Node script = null;\n     try {\n       script = ParserRunner.parse(\n-          \"input\", string, ParserRunner.createConfig(registry, true),\n+          \"input\", string, ParserRunner.createConfig(true),\n           testErrorReporter, Logger.getAnonymousLogger());\n     } catch (IOException e) {\n       throw new RuntimeException(e);", "timestamp": 1273269581, "metainfo": ""}