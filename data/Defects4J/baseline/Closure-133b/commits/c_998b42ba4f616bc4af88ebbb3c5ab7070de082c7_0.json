{"sha": "998b42ba4f616bc4af88ebbb3c5ab7070de082c7", "log": "open-source some integration tests  R=acleung DELTA=179  (21 added, 7 deleted, 151 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4124   ", "commit": "\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for {@link PassFactory}.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class IntegrationTest extends TestCase {\n+\n+  /** Externs for the test */\n+  private final JSSourceFile[] DEFAULT_EXTERNS = new JSSourceFile[] {\n+    JSSourceFile.fromCode(\"externs\",\n+        \"var arguments;\\n\"\n+        + \"/** @constructor */ function Window() {}\\n\"\n+        + \"/** @type {string} */ Window.prototype.name;\\n\"\n+        + \"/** @type {string} */ Window.prototype.offsetWidth;\\n\"\n+        + \"/** @type {Window} */ var window;\\n\"\n+        + \"/** @nosideeffects */ function noSideEffects() {}\\n\"\n+        + \"/** @constructor\\n * @nosideeffects */ function Widget() {}\\n\"\n+        + \"/** @modifies {this} */ Widget.prototype.go = function() {};\\n\"\n+        + \"/** @return {string} */ var widgetToken = function() {};\\n\")\n+  };\n+\n+  private JSSourceFile[] externs = DEFAULT_EXTERNS;\n+\n+  private static final String CLOSURE_BOILERPLATE =\n+      \"/** @define {boolean} */ var COMPILED = false; var goog = {};\" +\n+      \"goog.exportSymbol = function() {};\";\n+\n+  private static final String CLOSURE_COMPILED =\n+      \"var COMPILED = true; var goog$exportSymbol = function() {};\";\n+\n+  // The most recently used compiler.\n+  private Compiler lastCompiler;\n+\n+  @Override\n+  public void setUp() {\n+    externs = DEFAULT_EXTERNS;\n+    lastCompiler = null;\n+  }\n+\n+  public void testBug1949424() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.collapseProperties = true;\n+    options.closurePass = true;\n+    test(options, CLOSURE_BOILERPLATE + \"goog.provide('FOO'); FOO.bar = 3;\",\n+         CLOSURE_COMPILED + \"var FOO$bar = 3;\");\n+  }\n+\n+  public void testBug1949424_v2() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.collapseProperties = true;\n+    options.closurePass = true;\n+    test(options, CLOSURE_BOILERPLATE + \"goog.provide('FOO.BAR'); FOO.BAR = 3;\",\n+         CLOSURE_COMPILED + \"var FOO$BAR = 3;\");\n+  }\n+\n+  public void testBug1956277() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.collapseProperties = true;\n+    options.inlineVariables = true;\n+    test(options, \"var CONST = {}; CONST.bar = null;\" +\n+         \"function f(url) { CONST.bar = url; }\",\n+         \"var CONST$bar = null; function f(url) { CONST$bar = url; }\");\n+  }\n+\n+  public void testBug1962380() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.collapseProperties = true;\n+    options.inlineVariables = true;\n+    options.generateExports = true;\n+    test(options,\n+         CLOSURE_BOILERPLATE + \"/** @export */ goog.CONSTANT = 1;\" +\n+         \"var x = goog.CONSTANT;\",\n+         \"(function() {})('goog.CONSTANT', 1);\" +\n+         \"var x = 1;\");\n+  }\n+\n+  public void testBug2410122() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.generateExports = true;\n+    options.closurePass = true;\n+    test(options,\n+         \"var goog = {};\" +\n+         \"function F() {}\" +\n+         \"/** @export */ function G() { goog.base(this); } \" +\n+         \"goog.inherits(G, F);\",\n+         \"var goog = {};\" +\n+         \"function F() {}\" +\n+         \"function G() { F.call(this); } \" +\n+         \"goog.inherits(G, F); goog.exportSymbol('G', G);\");\n+  }\n+\n+  public void testIssue90() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.foldConstants = true;\n+    options.inlineVariables = true;\n+    options.removeDeadCode = true;\n+    test(options,\n+         \"var x; x && alert(1);\",\n+         \"\");\n+  }\n+\n+  public void testClosurePassOff() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = false;\n+    testSame(\n+        options,\n+        \"var goog = {}; goog.require = function(x) {}; goog.require('foo');\");\n+    testSame(\n+        options,\n+        \"var goog = {}; goog.getCssName = function(x) {};\" +\n+        \"goog.getCssName('foo');\");\n+  }\n+\n+  public void testClosurePassOn() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    test(\n+        options,\n+        \"var goog = {}; goog.require = function(x) {}; goog.require('foo');\",\n+        ProcessClosurePrimitives.MISSING_PROVIDE_ERROR);\n+    test(\n+        options,\n+        \"/** @define {boolean} */ var COMPILED = false;\" +\n+        \"var goog = {}; goog.getCssName = function(x) {};\" +\n+        \"goog.getCssName('foo');\",\n+        \"var COMPILED = true;\" +\n+        \"var goog = {}; goog.getCssName = function(x) {};\" +\n+        \"'foo';\");\n+  }\n+\n+  public void testCssNameCheck() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    options.checkMissingGetCssNameLevel = CheckLevel.ERROR;\n+    options.checkMissingGetCssNameBlacklist = \"foo\";\n+    test(options, \"var x = 'foo';\",\n+         CheckMissingGetCssName.MISSING_GETCSSNAME);\n+  }\n+\n+  public void testBug2592659() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    options.checkTypes = true;\n+    options.checkMissingGetCssNameLevel = CheckLevel.WARNING;\n+    options.checkMissingGetCssNameBlacklist = \"foo\";\n+    test(options,\n+        \"var goog = {};\\n\" +\n+        \"/**\\n\" +\n+        \" * @param {string} className\\n\" +\n+        \" * @param {string=} opt_modifier\\n\" +\n+        \" * @return {string}\\n\" +\n+        \"*/\\n\" +\n+        \"goog.getCssName = function(className, opt_modifier) {}\\n\" +\n+        \"var x = goog.getCssName(123, 'a');\",\n+        TypeValidator.TYPE_MISMATCH_WARNING);\n+  }\n+\n+  public void testTypedefBeforeOwner1() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    test(options,\n+         \"goog.provide('foo.Bar.Type');\\n\" +\n+         \"goog.provide('foo.Bar');\\n\" +\n+         \"/** @typedef {number} */ foo.Bar.Type;\\n\" +\n+         \"foo.Bar = function() {};\",\n+         \"var foo = {}; foo.Bar.Type; foo.Bar = function() {};\");\n+  }\n+\n+  public void testTypedefBeforeOwner2() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    options.collapseProperties = true;\n+    test(options,\n+         \"goog.provide('foo.Bar.Type');\\n\" +\n+         \"goog.provide('foo.Bar');\\n\" +\n+         \"/** @typedef {number} */ foo.Bar.Type;\\n\" +\n+         \"foo.Bar = function() {};\",\n+         \"var foo$Bar$Type; var foo$Bar = function() {};\");\n+  }\n+\n+  public void testExportedNames() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    options.variableRenaming = VariableRenamingPolicy.ALL;\n+    test(options,\n+         \"/** @define {boolean} */ var COMPILED = false;\" +\n+         \"var goog = {}; goog.exportSymbol('b', goog);\",\n+         \"var a = true; var c = {}; c.exportSymbol('b', c);\");\n+    test(options,\n+         \"/** @define {boolean} */ var COMPILED = false;\" +\n+         \"var goog = {}; goog.exportSymbol('a', goog);\",\n+         \"var b = true; var c = {}; c.exportSymbol('a', c);\");\n+  }\n+\n+  public void testCheckGlobalThisOn() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkSuspiciousCode = true;\n+    options.checkGlobalThisLevel = CheckLevel.ERROR;\n+    test(options, \"function f() { this.y = 3; }\", CheckGlobalThis.GLOBAL_THIS);\n+  }\n+\n+  public void testSusiciousCodeOff() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkSuspiciousCode = false;\n+    options.checkGlobalThisLevel = CheckLevel.ERROR;\n+    test(options, \"function f() { this.y = 3; }\", CheckGlobalThis.GLOBAL_THIS);\n+  }\n+\n+  public void testCheckGlobalThisOff() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkSuspiciousCode = true;\n+    options.checkGlobalThisLevel = CheckLevel.OFF;\n+    testSame(options, \"function f() { this.y = 3; }\");\n+  }\n+\n+  public void testCheckRequiresAndCheckProvidesOff() {\n+    testSame(createCompilerOptions(), new String[] {\n+      \"/** @constructor */ function Foo() {}\",\n+      \"new Foo();\"\n+    });\n+  }\n+\n+  public void testCheckRequiresOn() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkRequires = CheckLevel.ERROR;\n+    test(options, new String[] {\n+      \"/** @constructor */ function Foo() {}\",\n+      \"new Foo();\"\n+    }, CheckRequiresForConstructors.MISSING_REQUIRE_WARNING);\n+  }\n+\n+  public void testCheckProvidesOn() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkProvides = CheckLevel.ERROR;\n+    test(options, new String[] {\n+      \"/** @constructor */ function Foo() {}\",\n+      \"new Foo();\"\n+    }, CheckProvides.MISSING_PROVIDE_WARNING);\n+  }\n+\n+  public void testGenerateExportsOff() {\n+    testSame(createCompilerOptions(), \"/** @export */ function f() {}\");\n+  }\n+\n+  public void testGenerateExportsOn() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.generateExports = true;\n+    test(options, \"/** @export */ function f() {}\",\n+         \"/** @export */ function f() {} goog.exportSymbol('f', f);\");\n+  }\n+\n+  public void testExportTestFunctionsOff() {\n+    testSame(createCompilerOptions(), \"function testFoo() {}\");\n+  }\n+\n+  public void testExportTestFunctionsOn() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.exportTestFunctions = true;\n+    test(options, \"function testFoo() {}\",\n+         \"/** @export */ function testFoo() {}\" +\n+         \"goog.exportSymbol('testFoo', testFoo);\");\n+  }\n+\n+  public void testCheckSymbolsOff() {\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, \"x = 3;\");\n+  }\n+\n+  public void testCheckSymbolsOn() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkSymbols = true;\n+    test(options, \"x = 3;\", VarCheck.UNDEFINED_VAR_ERROR);\n+  }\n+\n+  public void testCheckReferencesOff() {\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, \"x = 3; var x = 5;\");\n+  }\n+\n+  public void testCheckReferencesOn() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.aggressiveVarCheck = CheckLevel.ERROR;\n+    test(options, \"x = 3; var x = 5;\",\n+         VariableReferenceCheck.UNDECLARED_REFERENCE);\n+  }\n+\n+  public void testInferTypes() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.inferTypes = true;\n+    options.checkTypes = false;\n+    options.closurePass = true;\n+\n+    test(options,\n+        CLOSURE_BOILERPLATE +\n+        \"goog.provide('Foo'); /** @enum */ Foo = {a: 3};\",\n+        TypeCheck.ENUM_NOT_CONSTANT);\n+    assertTrue(lastCompiler.getErrorManager().getTypedPercent() == 0);\n+\n+    // This does not generate a warning.\n+    test(options, \"/** @type {number} */ var n = window.name;\",\n+        \"var n = window.name;\");\n+    assertTrue(lastCompiler.getErrorManager().getTypedPercent() == 0);\n+  }\n+\n+  public void testTypeCheckAndInference() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkTypes = true;\n+    test(options, \"/** @type {number} */ var n = window.name;\",\n+         TypeValidator.TYPE_MISMATCH_WARNING);\n+    assertTrue(lastCompiler.getErrorManager().getTypedPercent() > 0);\n+  }\n+\n+  public void testTypeNameParser() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkTypes = true;\n+    test(options, \"/** @type {n} */ var n = window.name;\",\n+         RhinoErrorReporter.TYPE_PARSE_ERROR);\n+  }\n+\n+  // This tests that the TypedScopeCreator is memoized so that it only creates a\n+  // Scope object once for each scope. If, when type inference requests a scope,\n+  // it creates a new one, then multiple JSType objects end up getting created\n+  // for the same local type, and ambiguate will rename the last statement to\n+  // o.a(o.a, o.a), which is bad.\n+  public void testMemoizedTypedScopeCreator() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkTypes = true;\n+    options.ambiguateProperties = true;\n+    options.propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED;\n+    test(options, \"function someTest() {\\n\"\n+        + \"  /** @constructor */\\n\"\n+        + \"  function Foo() { this.instProp = 3; }\\n\"\n+        + \"  Foo.prototype.protoProp = function(a, b) {};\\n\"\n+        + \"  /** @constructor\\n @extends Foo */\\n\"\n+        + \"  function Bar() {}\\n\"\n+        + \"  goog.inherits(Bar, Foo);\\n\"\n+        + \"  var o = new Bar();\\n\"\n+        + \"  o.protoProp(o.protoProp, o.instProp);\\n\"\n+        + \"}\",\n+        \"function someTest() {\\n\"\n+        + \"  function Foo() { this.b = 3; }\\n\"\n+        + \"  Foo.prototype.a = function(a, b) {};\\n\"\n+        + \"  function Bar() {}\\n\"\n+        + \"  goog.c(Bar, Foo);\\n\"\n+        + \"  var o = new Bar();\\n\"\n+        + \"  o.a(o.a, o.b);\\n\"\n+        + \"}\");\n+  }\n+\n+  public void testCheckTypes() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkTypes = true;\n+    test(options, \"var x = x || {}; x.f = function() {}; x.f(3);\",\n+         TypeCheck.WRONG_ARGUMENT_COUNT);\n+  }\n+\n+  public void testReplaceCssNames() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    options.gatherCssNames = true;\n+    test(options, \"/** @define {boolean} */\\n\"\n+         + \"var COMPILED = false;\\n\"\n+         + \"goog.setCssNameMapping({'foo':'bar'});\\n\"\n+         + \"function getCss() {\\n\"\n+         + \"  return goog.getCssName('foo');\\n\"\n+         + \"}\",\n+         \"var COMPILED = true;\\n\"\n+         + \"function getCss() {\\n\"\n+         + \"  return \\\"bar\\\";\"\n+         + \"}\");\n+    assertEquals(\n+        ImmutableMap.of(\"foo\", new Integer(1)),\n+        lastCompiler.getPassConfig().getIntermediateState().cssNames);\n+  }\n+\n+  public void testRemoveClosureAsserts() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    testSame(options,\n+        \"var goog = {};\"\n+        + \"goog.asserts.assert(goog);\");\n+    options.removeClosureAsserts = true;\n+    test(options,\n+        \"var goog = {};\"\n+        + \"goog.asserts.assert(goog);\",\n+        \"var goog = {};\");\n+  }\n+\n+  public void testDeprecation() {\n+    String code = \"/** @deprecated */ function f() { } function g() { f(); }\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.setWarningLevel(DiagnosticGroups.DEPRECATED, CheckLevel.ERROR);\n+    testSame(options, code);\n+\n+    options.checkTypes = true;\n+    test(options, code, CheckAccessControls.DEPRECATED_NAME);\n+  }\n+\n+  public void testVisibility() {\n+    String[] code = {\n+        \"/** @private */ function f() { }\",\n+        \"function g() { f(); }\"\n+    };\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.setWarningLevel(DiagnosticGroups.VISIBILITY, CheckLevel.ERROR);\n+    testSame(options, code);\n+\n+    options.checkTypes = true;\n+    test(options, code, CheckAccessControls.BAD_PRIVATE_GLOBAL_ACCESS);\n+  }\n+\n+  public void testUnreachableCode() {\n+    String code = \"function f() { return \\n 3; }\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.checkUnreachableCode = CheckLevel.ERROR;\n+    test(options, code, CheckUnreachableCode.UNREACHABLE_CODE);\n+  }\n+\n+  public void testMissingReturn() {\n+    String code =\n+        \"/** @return {number} */ function f() { if (f) { return 3; } }\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.checkMissingReturn = CheckLevel.ERROR;\n+    testSame(options, code);\n+\n+    options.checkTypes = true;\n+    test(options, code, CheckMissingReturn.MISSING_RETURN_STATEMENT);\n+  }\n+\n+  public void testIdGenerators() {\n+    String code =  \"function f() {} f('id');\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.idGenerators = Sets.newHashSet(\"f\");\n+    test(options, code, \"function f() {} 'a';\");\n+  }\n+\n+  public void testOptimizeArgumentsArray() {\n+    String code =  \"function f() { return arguments[0]; }\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.optimizeArgumentsArray = true;\n+    String argName = \"JSCompiler_OptimizeArgumentsArray_p0\";\n+    test(options, code,\n+         \"function f(\" + argName + \") { return \" + argName + \"; }\");\n+  }\n+\n+  public void testOptimizeParameters() {\n+    String code = \"function f(a) { return a; } f(true);\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.optimizeParameters = true;\n+    test(options, code, \"function f() { var a = true; return a;} f();\");\n+  }\n+\n+  public void testOptimizeReturns() {\n+    String code = \"function f(a) { return a; } f(true);\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.optimizeReturns = true;\n+    test(options, code, \"function f(a) {return;} f(true);\");\n+  }\n+\n+  public void testRemoveAbstractMethods() {\n+    String code = CLOSURE_BOILERPLATE +\n+        \"var x = {}; x.foo = goog.abstractMethod; x.bar = 3;\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.closurePass = true;\n+    options.collapseProperties = true;\n+    test(options, code, CLOSURE_COMPILED + \" var x$bar = 3;\");\n+  }\n+\n+  public void testCollapseProperties1() {\n+    String code =\n+        \"var x = {}; x.FOO = 5; x.bar = 3;\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.collapseProperties = true;\n+    test(options, code, \"var x$FOO = 5; var x$bar = 3;\");\n+  }\n+\n+  public void testCollapseProperties2() {\n+    String code =\n+        \"var x = {}; x.FOO = 5; x.bar = 3;\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.collapseProperties = true;\n+    options.collapseObjectLiterals = true;\n+    test(options, code, \"var x$FOO = 5; var x$bar = 3;\");\n+  }\n+\n+  public void testCollapseObjectLiteral1() {\n+    // Verify collapseObjectLiterals does nothing in global scope\n+    String code = \"var x = {}; x.FOO = 5; x.bar = 3;\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.collapseObjectLiterals = true;\n+    testSame(options, code);\n+  }\n+\n+  public void testCollapseObjectLiteral2() {\n+    String code =\n+        \"function f() {var x = {}; x.FOO = 5; x.bar = 3;}\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.collapseObjectLiterals = true;\n+    test(options, code,\n+        \"function f(){\" +\n+        \"var JSCompiler_object_inline_FOO_0;\" +\n+        \"var JSCompiler_object_inline_bar_1;\" +\n+        \"JSCompiler_object_inline_FOO_0=5;\" +\n+        \"JSCompiler_object_inline_bar_1=3}\");\n+  }\n+\n+  public void testTightenTypesWithoutTypeCheck() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.tightenTypes = true;\n+    test(options, \"\", DefaultPassConfig.TIGHTEN_TYPES_WITHOUT_TYPE_CHECK);\n+  }\n+\n+  public void testDisambiguateProperties() {\n+    String code =\n+        \"/** @constructor */ function Foo(){} Foo.prototype.bar = 3;\" +\n+        \"/** @constructor */ function Baz(){} Baz.prototype.bar = 3;\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.disambiguateProperties = true;\n+    options.checkTypes = true;\n+    test(options, code,\n+         \"function Foo(){} Foo.prototype.Foo_prototype$bar = 3;\" +\n+         \"function Baz(){} Baz.prototype.Baz_prototype$bar = 3;\");\n+  }\n+\n+  public void testMarkPureCalls() {\n+    String testCode = \"function foo() {} foo();\";\n+    CompilerOptions options = createCompilerOptions();\n+    options.removeDeadCode = true;\n+\n+    testSame(options, testCode);\n+\n+    options.computeFunctionSideEffects = true;\n+    test(options, testCode, \"function foo() {}\");\n+  }\n+\n+  public void testMarkNoSideEffects() {\n+    String testCode = \"noSideEffects();\";\n+    CompilerOptions options = createCompilerOptions();\n+    options.removeDeadCode = true;\n+\n+    testSame(options, testCode);\n+\n+    options.markNoSideEffectCalls = true;\n+    test(options, testCode, \"\");\n+  }\n+\n+  public void testChainedCalls() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.chainCalls = true;\n+    test(\n+        options,\n+        \"/** @constructor */ function Foo() {} \" +\n+        \"Foo.prototype.bar = function() { return this; }; \" +\n+        \"var f = new Foo();\" +\n+        \"f.bar(); \" +\n+        \"f.bar(); \",\n+        \"function Foo() {} \" +\n+        \"Foo.prototype.bar = function() { return this; }; \" +\n+        \"var f = new Foo();\" +\n+        \"f.bar().bar();\");\n+  }\n+\n+  public void testExtraAnnotationNames() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.setExtraAnnotationNames(Sets.newHashSet(\"TagA\", \"TagB\"));\n+    test(\n+        options,\n+        \"/** @TagA */ var f = new Foo(); /** @TagB */ f.bar();\",\n+        \"var f = new Foo(); f.bar();\");\n+  }\n+\n+  public void testDevirtualizePrototypeMethods() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.devirtualizePrototypeMethods = true;\n+    test(\n+        options,\n+        \"/** @constructor */ var Foo = function() {}; \" +\n+        \"Foo.prototype.bar = function() {};\" +\n+        \"(new Foo()).bar();\",\n+        \"var Foo = function() {};\" +\n+        \"var JSCompiler_StaticMethods_bar = \" +\n+        \"    function(JSCompiler_StaticMethods_bar$self) {};\" +\n+        \"JSCompiler_StaticMethods_bar(new Foo());\");\n+  }\n+\n+  public void testCheckConsts() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.inlineConstantVars = true;\n+    test(options, \"var FOO = true; FOO = false\",\n+        ConstCheck.CONST_REASSIGNED_VALUE_ERROR);\n+  }\n+\n+  public void testAllChecksOn() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkSuspiciousCode = true;\n+    options.checkControlStructures = true;\n+    options.checkRequires = CheckLevel.ERROR;\n+    options.checkProvides = CheckLevel.ERROR;\n+    options.generateExports = true;\n+    options.exportTestFunctions = true;\n+    options.closurePass = true;\n+    options.checkMissingGetCssNameLevel = CheckLevel.ERROR;\n+    options.checkMissingGetCssNameBlacklist = \"goog\";\n+    options.syntheticBlockStartMarker = \"synStart\";\n+    options.syntheticBlockEndMarker = \"synEnd\";\n+    options.checkSymbols = true;\n+    options.aggressiveVarCheck = CheckLevel.ERROR;\n+    options.processObjectPropertyString = true;\n+    options.collapseProperties = true;\n+    test(options, CLOSURE_BOILERPLATE, CLOSURE_COMPILED);\n+  }\n+\n+  public void testTypeCheckingWithSyntheticBlocks() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.syntheticBlockStartMarker = \"synStart\";\n+    options.syntheticBlockEndMarker = \"synEnd\";\n+    options.checkTypes = true;\n+\n+    // We used to have a bug where the CFG drew an\n+    // edge straight from synStart to f(progress).\n+    // If that happens, then progress will get type {number|undefined}.\n+    testSame(\n+        options,\n+        \"/** @param {number} x */ function f(x) {}\" +\n+        \"function g() {\" +\n+        \" synStart('foo');\" +\n+        \" var progress = 1;\" +\n+        \" f(progress);\" +\n+        \" synEnd('foo');\" +\n+        \"}\");\n+  }\n+\n+  public void testCompilerDoesNotBlowUpIfUndefinedSymbols() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkSymbols = true;\n+\n+    // Disable the undefined variable check.\n+    options.setWarningLevel(\n+        DiagnosticGroup.forType(VarCheck.UNDEFINED_VAR_ERROR),\n+        CheckLevel.OFF);\n+\n+    // The compiler used to throw an IllegalStateException on this.\n+    testSame(options, \"var x = {foo: y};\");\n+  }\n+\n+  // Make sure that if we change variables which are constant to have\n+  // $$constant appended to their names, we remove that tag before\n+  // we finish.\n+  public void testConstantTagsMustAlwaysBeRemoved() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.variableRenaming = VariableRenamingPolicy.LOCAL;\n+    String originalText = \"var G_GEO_UNKNOWN_ADDRESS=1;\\n\" +\n+        \"function foo() {\" +\n+        \"  var localVar = 2;\\n\" +\n+        \"  if (G_GEO_UNKNOWN_ADDRESS == localVar) {\\n\" +\n+        \"    alert(\\\"A\\\"); }}\";\n+    String expectedText = \"var G_GEO_UNKNOWN_ADDRESS=1;\" +\n+        \"function foo(){var a=2;if(G_GEO_UNKNOWN_ADDRESS==a){alert(\\\"A\\\")}}\";\n+\n+    test(options, originalText, expectedText);\n+  }\n+\n+  public void testClosurePassPreservesJsDoc() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkTypes = true;\n+    options.closurePass = true;\n+\n+    test(options,\n+         CLOSURE_BOILERPLATE +\n+         \"goog.provide('Foo'); /** @constructor */ Foo = function() {};\" +\n+         \"var x = new Foo();\",\n+         \"var COMPILED=true;var goog={};goog.exportSymbol=function(){};\" +\n+         \"var Foo=function(){};var x=new Foo\");\n+    test(options,\n+         CLOSURE_BOILERPLATE +\n+         \"goog.provide('Foo'); /** @enum */ Foo = {a: 3};\",\n+         TypeCheck.ENUM_NOT_CONSTANT);\n+  }\n+\n+  public void testProvidedNamespaceIsConst() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    options.inlineConstantVars = true;\n+    options.collapseProperties = true;\n+    test(options,\n+         \"var goog = {}; goog.provide('foo'); \" +\n+         \"function f() { foo = {};}\",\n+         \"var foo = {}; function f() { foo = {}; }\",\n+         ConstCheck.CONST_REASSIGNED_VALUE_ERROR);\n+  }\n+\n+  public void testProvidedNamespaceIsConst2() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    options.inlineConstantVars = true;\n+    options.collapseProperties = true;\n+    test(options,\n+         \"var goog = {}; goog.provide('foo.bar'); \" +\n+         \"function f() { foo.bar = {};}\",\n+         \"var foo$bar = {};\" +\n+         \"function f() { foo$bar = {}; }\",\n+         ConstCheck.CONST_REASSIGNED_VALUE_ERROR);\n+  }\n+\n+  public void testProvidedNamespaceIsConst3() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    options.inlineConstantVars = true;\n+    options.collapseProperties = true;\n+    test(options,\n+         \"var goog = {}; \" +\n+         \"goog.provide('foo.bar'); goog.provide('foo.bar.baz'); \" +\n+         \"/** @constructor */ foo.bar = function() {};\" +\n+         \"/** @constructor */ foo.bar.baz = function() {};\",\n+         \"var foo$bar = function(){};\" +\n+         \"var foo$bar$baz = function(){};\");\n+  }\n+\n+  public void testProvidedNamespaceIsConst4() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    options.inlineConstantVars = true;\n+    options.collapseProperties = true;\n+    test(options,\n+         \"var goog = {}; goog.provide('foo.Bar'); \" +\n+         \"var foo = {}; foo.Bar = {};\",\n+         \"var foo = {}; var foo = {}; foo.Bar = {};\");\n+  }\n+\n+  public void testProvidedNamespaceIsConst5() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    options.inlineConstantVars = true;\n+    options.collapseProperties = true;\n+    test(options,\n+         \"var goog = {}; goog.provide('foo.Bar'); \" +\n+         \"foo = {}; foo.Bar = {};\",\n+         \"var foo = {}; foo = {}; foo.Bar = {};\");\n+  }\n+\n+  public void testProcessDefinesAlwaysOn() {\n+    test(createCompilerOptions(),\n+         \"/** @define {boolean} */ var HI = true; HI = false;\",\n+         \"var HI = false;false;\");\n+  }\n+\n+  public void testProcessDefinesAdditionalReplacements() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.setDefineToBooleanLiteral(\"HI\", false);\n+    test(options,\n+         \"/** @define {boolean} */ var HI = true;\",\n+         \"var HI = false;\");\n+  }\n+\n+  public void testReplaceMessages() {\n+    CompilerOptions options = createCompilerOptions();\n+    String prefix = \"var goog = {}; goog.getMsg = function() {};\";\n+    testSame(options, prefix + \"var MSG_HI = goog.getMsg('hi');\");\n+\n+    options.messageBundle = new EmptyMessageBundle();\n+    test(options,\n+        prefix + \"/** @desc xyz */ var MSG_HI = goog.getMsg('hi');\",\n+        prefix + \"var MSG_HI = 'hi';\");\n+  }\n+\n+  public void testCheckGlobalNames() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkGlobalNamesLevel = CheckLevel.ERROR;\n+    test(options, \"var x = {}; var y = x.z;\",\n+         CheckGlobalNames.UNDEFINED_NAME_WARNING);\n+  }\n+\n+  public void testInlineGetters() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code =\n+        \"function Foo() {} Foo.prototype.bar = function() { return 3; };\" +\n+        \"var x = new Foo(); x.bar();\";\n+\n+    testSame(options, code);\n+    options.inlineGetters = true;\n+\n+    test(options, code,\n+         \"function Foo() {} Foo.prototype.bar = function() { return 3 };\" +\n+         \"var x = new Foo(); 3;\");\n+  }\n+\n+  public void testInlineGettersWithAmbiguate() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    String code =\n+        \"/** @constructor */\" +\n+        \"function Foo() {}\" +\n+        \"/** @type {number} */ Foo.prototype.field;\" +\n+        \"Foo.prototype.getField = function() { return this.field; };\" +\n+        \"/** @constructor */\" +\n+        \"function Bar() {}\" +\n+        \"/** @type {string} */ Bar.prototype.field;\" +\n+        \"Bar.prototype.getField = function() { return this.field; };\" +\n+        \"new Foo().getField();\" +\n+        \"new Bar().getField();\";\n+\n+    testSame(options, code);\n+\n+    options.inlineGetters = true;\n+\n+    test(options, code,\n+        \"function Foo() {}\" +\n+        \"Foo.prototype.field;\" +\n+        \"Foo.prototype.getField = function() { return this.field; };\" +\n+        \"function Bar() {}\" +\n+        \"Bar.prototype.field;\" +\n+        \"Bar.prototype.getField = function() { return this.field; };\" +\n+        \"new Foo().field;\" +\n+        \"new Bar().field;\");\n+\n+    options.checkTypes = true;\n+    options.ambiguateProperties = true;\n+\n+    // Propagating the wrong type information may cause ambiguate properties\n+    // to generate bad code.\n+    testSame(options, code);\n+  }\n+\n+  public void testInlineVariables() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function foo() {} var x = 3; foo(x);\";\n+    testSame(options, code);\n+\n+    options.inlineVariables = true;\n+    test(options, code, \"(function foo() {})(3);\");\n+\n+    options.propertyRenaming = PropertyRenamingPolicy.HEURISTIC;\n+    test(options, code, DefaultPassConfig.CANNOT_USE_PROTOTYPE_AND_VAR);\n+  }\n+\n+  public void testInlineConstants() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function foo() {} var x = 3; foo(x); var YYY = 4; foo(YYY);\";\n+    testSame(options, code);\n+\n+    options.inlineConstantVars = true;\n+    test(options, code, \"function foo() {} var x = 3; foo(x); foo(4);\");\n+  }\n+\n+  public void testMinimizeExits() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code =\n+        \"function f() {\" +\n+        \"  if (window.foo) return; window.h(); \" +\n+        \"}\";\n+    testSame(options, code);\n+\n+    options.foldConstants = true;\n+    test(\n+        options, code,\n+        \"function f() {\" +\n+        \"  window.foo || window.h(); \" +\n+        \"}\");\n+  }\n+\n+  public void testFoldConstants() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"if (true) { window.foo(); }\";\n+    testSame(options, code);\n+\n+    options.foldConstants = true;\n+    test(options, code, \"window.foo();\");\n+  }\n+\n+  public void testRemoveUnreachableCode() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function f() { return; f(); }\";\n+    testSame(options, code);\n+\n+    options.removeDeadCode = true;\n+    test(options, code, \"function f() {}\");\n+  }\n+\n+  public void testRemoveUnusedPrototypeProperties1() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function Foo() {} \" +\n+        \"Foo.prototype.bar = function() { return new Foo(); };\";\n+    testSame(options, code);\n+\n+    options.removeUnusedPrototypeProperties = true;\n+    test(options, code, \"function Foo() {}\");\n+  }\n+\n+  public void testRemoveUnusedPrototypeProperties2() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function Foo() {} \" +\n+        \"Foo.prototype.bar = function() { return new Foo(); };\" +\n+        \"function f(x) { x.bar(); }\";\n+    testSame(options, code);\n+\n+    options.removeUnusedPrototypeProperties = true;\n+    testSame(options, code);\n+\n+    options.removeUnusedVars = true;\n+    test(options, code, \"\");\n+  }\n+\n+  public void testSmartNamePass() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function Foo() { this.bar(); } \" +\n+        \"Foo.prototype.bar = function() { return Foo(); };\";\n+    testSame(options, code);\n+\n+    options.smartNameRemoval = true;\n+    test(options, code, \"\");\n+  }\n+\n+  public void testDeadAssignmentsElimination() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function f() { var x = 3; 4; x = 5; return x; } f(); \";\n+    testSame(options, code);\n+\n+    options.deadAssignmentElimination = true;\n+    testSame(options, code);\n+\n+    options.removeUnusedVars = true;\n+    test(options, code, \"function f() { var x = 3; 4; x = 5; return x; } f();\");\n+  }\n+\n+  public void testInlineFunctions() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function f() { return 3; } f(); \";\n+    testSame(options, code);\n+\n+    options.inlineFunctions = true;\n+    test(options, code, \"3;\");\n+  }\n+\n+  public void testRemoveUnusedVars1() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function f(x) {} f();\";\n+    testSame(options, code);\n+\n+    options.removeUnusedVars = true;\n+    test(options, code, \"function f() {} f();\");\n+  }\n+\n+  public void testRemoveUnusedVars2() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"(function f(x) {})();var g = function() {}; g();\";\n+    testSame(options, code);\n+\n+    options.removeUnusedVars = true;\n+    test(options, code, \"(function() {})();var g = function() {}; g();\");\n+\n+    options.anonymousFunctionNaming = AnonymousFunctionNamingPolicy.UNMAPPED;\n+    test(options, code, \"(function f() {})();var g = function $g$() {}; g();\");\n+  }\n+\n+  public void testCrossModuleCodeMotion() {\n+    CompilerOptions options = createCompilerOptions();\n+    String[] code = new String[] {\n+      \"var x = 1;\",\n+      \"x;\",\n+    };\n+    testSame(options, code);\n+\n+    options.crossModuleCodeMotion = true;\n+    test(options, code, new String[] {\n+      \"\",\n+      \"var x = 1; x;\",\n+    });\n+  }\n+\n+  public void testCrossModuleMethodMotion() {\n+    CompilerOptions options = createCompilerOptions();\n+    String[] code = new String[] {\n+      \"var Foo = function() {}; Foo.prototype.bar = function() {};\" +\n+      \"var x = new Foo();\",\n+      \"x.bar();\",\n+    };\n+    testSame(options, code);\n+\n+    options.crossModuleMethodMotion = true;\n+    test(options, code, new String[] {\n+      CrossModuleMethodMotion.STUB_DECLARATIONS +\n+      \"var Foo = function() {};\" +\n+      \"Foo.prototype.bar=JSCompiler_stubMethod(0); var x=new Foo;\",\n+      \"Foo.prototype.bar=JSCompiler_unstubMethod(0,function(){}); x.bar()\",\n+    });\n+  }\n+\n+  public void testFlowSensitiveInlineVariables1() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function f() { var x = 3; x = 5; return x; }\";\n+    testSame(options, code);\n+\n+    options.flowSensitiveInlineVariables = true;\n+    test(options, code, \"function f() { var x = 3; return 5; }\");\n+\n+    String unusedVar = \"function f() { var x; x = 5; return x; } f()\";\n+    test(options, unusedVar, \"function f() { var x; return 5; } f()\");\n+\n+    options.removeUnusedVars = true;\n+    test(options, unusedVar, \"function f() { return 5; } f()\");\n+  }\n+\n+  public void testFlowSensitiveInlineVariables2() {\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel.SIMPLE_OPTIMIZATIONS\n+        .setOptionsForCompilationLevel(options);\n+    test(options,\n+        \"function f () {\\n\" +\n+        \"    var ab = 0;\\n\" +\n+        \"    ab += '-';\\n\" +\n+        \"    alert(ab);\\n\" +\n+        \"}\",\n+        \"function f () {\\n\" +\n+        \"    alert('0-');\\n\" +\n+        \"}\");\n+  }\n+\n+  public void testCollapseAnonymousFunctions() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"var f = function() {};\";\n+    testSame(options, code);\n+\n+    options.collapseAnonymousFunctions = true;\n+    test(options, code, \"function f() {}\");\n+  }\n+\n+  public void testMoveFunctionDeclarations() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"var x = f(); function f() { return 3; }\";\n+    testSame(options, code);\n+\n+    options.moveFunctionDeclarations = true;\n+    test(options, code, \"function f() { return 3; } var x = f();\");\n+  }\n+\n+  public void testNameAnonymousFunctions() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"var f = function() {};\";\n+    testSame(options, code);\n+\n+    options.anonymousFunctionNaming = AnonymousFunctionNamingPolicy.MAPPED;\n+    test(options, code, \"var f = function $() {}\");\n+    assertNotNull(lastCompiler.getResult().namedAnonFunctionMap);\n+\n+    options.anonymousFunctionNaming = AnonymousFunctionNamingPolicy.UNMAPPED;\n+    test(options, code, \"var f = function $f$() {}\");\n+    assertNull(lastCompiler.getResult().namedAnonFunctionMap);\n+  }\n+\n+  public void testExtractPrototypeMemberDeclarations() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"var f = function() {};\";\n+    String expected = \"var a; var b = function() {}; a = b.prototype;\";\n+    for (int i = 0; i < 10; i++) {\n+      code += \"f.prototype.a = \" + i + \";\";\n+      expected += \"a.a = \" + i + \";\";\n+    }\n+    testSame(options, code);\n+\n+    options.extractPrototypeMemberDeclarations = true;\n+    options.variableRenaming = VariableRenamingPolicy.ALL;\n+    test(options, code, expected);\n+\n+    options.propertyRenaming = PropertyRenamingPolicy.HEURISTIC;\n+    options.variableRenaming = VariableRenamingPolicy.OFF;\n+    testSame(options, code);\n+  }\n+\n+  public void testDevirtualizationAndExtractPrototypeMemberDeclarations() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.devirtualizePrototypeMethods = true;\n+    options.collapseAnonymousFunctions = true;\n+    options.extractPrototypeMemberDeclarations = true;\n+    options.variableRenaming = VariableRenamingPolicy.ALL;\n+    String code = \"var f = function() {};\";\n+    String expected = \"var a; function b() {} a = b.prototype;\";\n+    for (int i = 0; i < 10; i++) {\n+      code += \"f.prototype.argz = function() {arguments};\";\n+      code += \"f.prototype.devir\" + i + \" = function() {};\";\n+\n+      char letter = (char) ('d' + i);\n+      expected += \"a.argz = function() {arguments};\";\n+      expected += \"function \" + letter + \"(c){}\";\n+    }\n+\n+    code += \"var F = new f(); F.argz();\";\n+    expected += \"var n = new b(); n.argz();\";\n+\n+    for (int i = 0; i < 10; i++) {\n+      code += \"F.devir\" + i + \"();\";\n+\n+      char letter = (char) ('d' + i);\n+      expected += letter + \"(n);\";\n+    }\n+    test(options, code, expected);\n+  }\n+\n+  public void testCoalesceVariableNames() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function f() {var x = 3; var y = x; var z = y; return z;}\";\n+    testSame(options, code);\n+\n+    options.coalesceVariableNames = true;\n+    test(options, code,\n+         \"function f() {var x = 3; x = x; x = x; return x;}\");\n+  }\n+\n+  public void testPropertyRenaming() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.propertyAffinity = true;\n+    String code =\n+        \"function f() { return this.foo + this['bar'] + this.Baz; }\" +\n+        \"f.prototype.bar = 3; f.prototype.Baz = 3;\";\n+    String heuristic =\n+        \"function f() { return this.foo + this['bar'] + this.a; }\" +\n+        \"f.prototype.bar = 3; f.prototype.a = 3;\";\n+    String aggHeuristic =\n+        \"function f() { return this.foo + this['b'] + this.a; } \" +\n+        \"f.prototype.b = 3; f.prototype.a = 3;\";\n+    String all =\n+        \"function f() { return this.b + this['bar'] + this.a; }\" +\n+        \"f.prototype.c = 3; f.prototype.a = 3;\";\n+    testSame(options, code);\n+\n+    options.propertyRenaming = PropertyRenamingPolicy.HEURISTIC;\n+    test(options, code, heuristic);\n+\n+    options.propertyRenaming = PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n+    test(options, code, aggHeuristic);\n+\n+    options.propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED;\n+    test(options, code, all);\n+  }\n+\n+  public void testConvertToDottedProperties() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code =\n+        \"function f() { return this['bar']; } f.prototype.bar = 3;\";\n+    String expected =\n+        \"function f() { return this.bar; } f.prototype.a = 3;\";\n+    testSame(options, code);\n+\n+    options.convertToDottedProperties = true;\n+    options.propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED;\n+    test(options, code, expected);\n+  }\n+\n+  public void testRewriteFunctionExpressions() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"var a = function() {};\";\n+    String expected = \"function JSCompiler_emptyFn(){return function(){}} \" +\n+        \"var a = JSCompiler_emptyFn();\";\n+    for (int i = 0; i < 10; i++) {\n+      code += \"a = function() {};\";\n+      expected += \"a = JSCompiler_emptyFn();\";\n+    }\n+    testSame(options, code);\n+\n+    options.rewriteFunctionExpressions = true;\n+    test(options, code, expected);\n+  }\n+\n+  public void testAliasAllStrings() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function f() { return 'a'; }\";\n+    String expected = \"var $$S_a = 'a'; function f() { return $$S_a; }\";\n+    testSame(options, code);\n+\n+    options.aliasAllStrings = true;\n+    test(options, code, expected);\n+  }\n+\n+  public void testAliasExterns() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"function f() { return window + window + window + window; }\";\n+    String expected = \"var GLOBAL_window = window;\" +\n+        \"function f() { return GLOBAL_window + GLOBAL_window + \" +\n+        \"               GLOBAL_window + GLOBAL_window; }\";\n+    testSame(options, code);\n+\n+    options.aliasExternals = true;\n+    test(options, code, expected);\n+  }\n+\n+  public void testAliasKeywords() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code =\n+        \"function f() { return true + true + true + true + true + true; }\";\n+    String expected = \"var JSCompiler_alias_TRUE = true;\" +\n+        \"function f() { return JSCompiler_alias_TRUE + \" +\n+        \"    JSCompiler_alias_TRUE + JSCompiler_alias_TRUE + \" +\n+        \"    JSCompiler_alias_TRUE + JSCompiler_alias_TRUE + \" +\n+        \"    JSCompiler_alias_TRUE; }\";\n+    testSame(options, code);\n+\n+    options.aliasKeywords = true;\n+    test(options, code, expected);\n+  }\n+\n+  public void testRenameVars1() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code =\n+        \"var abc = 3; function f() { var xyz = 5; return abc + xyz; }\";\n+    String local = \"var abc = 3; function f() { var a = 5; return abc + a; }\";\n+    String all = \"var a = 3; function c() { var b = 5; return a + b; }\";\n+    testSame(options, code);\n+\n+    options.variableRenaming = VariableRenamingPolicy.LOCAL;\n+    test(options, code, local);\n+\n+    options.variableRenaming = VariableRenamingPolicy.ALL;\n+    test(options, code, all);\n+\n+    options.reserveRawExports = true;\n+  }\n+\n+  public void testRenameVars2() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.variableRenaming = VariableRenamingPolicy.ALL;\n+\n+    String code =     \"var abc = 3; function f() { window['a'] = 5; }\";\n+    String noexport = \"var a = 3;   function b() { window['a'] = 5; }\";\n+    String export =   \"var b = 3;   function c() { window['a'] = 5; }\";\n+\n+    options.reserveRawExports = false;\n+    test(options, code, noexport);\n+\n+    options.reserveRawExports = true;\n+    test(options, code, export);\n+  }\n+\n+  public void testShadowVaribles() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.variableRenaming = VariableRenamingPolicy.LOCAL;\n+    options.shadowVariables = true;\n+    String code =     \"var f = function(x) { return function(y) {}}\";\n+    String expected = \"var f = function(a) { return function(a) {}}\";\n+    test(options, code, expected);\n+  }\n+\n+  public void testRenameLabels() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"longLabel: while (true) { break longLabel; }\";\n+    String expected = \"a: while (true) { break a; }\";\n+    testSame(options, code);\n+\n+    options.labelRenaming = true;\n+    test(options, code, expected);\n+  }\n+\n+  public void testIssue63SourceMap() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"var a;\";\n+\n+    options.skipAllPasses = true;\n+    options.sourceMapOutputPath = \"./src.map\";\n+\n+    Compiler compiler = compile(options, code);\n+    compiler.toSource();\n+  }\n+\n+  public void testRegExp1() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.foldConstants = true;\n+\n+    String code = \"/(a)/.test(\\\"a\\\");\";\n+\n+    testSame(options, code);\n+\n+    options.computeFunctionSideEffects = true;\n+\n+    String expected = \"\";\n+\n+    test(options, code, expected);\n+  }\n+\n+  public void testRegExp2() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.foldConstants = true;\n+\n+    String code = \"/(a)/.test(\\\"a\\\");var a = RegExp.$1\";\n+\n+    testSame(options, code);\n+\n+    options.computeFunctionSideEffects = true;\n+\n+    test(options, code, CheckRegExp.REGEXP_REFERENCE);\n+\n+    options.setWarningLevel(DiagnosticGroups.CHECK_REGEXP, CheckLevel.OFF);\n+\n+    testSame(options, code);\n+  }\n+\n+  public void testFoldLocals1() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.foldConstants = true;\n+\n+    // An external object, whose constructor has no side-effects,\n+    // and whose method \"go\" only modifies the object.\n+    String code = \"new Widget().go();\";\n+\n+    testSame(options, code);\n+\n+    options.computeFunctionSideEffects = true;\n+\n+    test(options, code, \"\");\n+  }\n+\n+  public void testFoldLocals2() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.foldConstants = true;\n+    options.checkTypes = true;\n+\n+    // An external function that returns a local object that the\n+    // method \"go\" that only modifies the object.\n+    String code = \"widgetToken().go();\";\n+\n+    testSame(options, code);\n+\n+    options.computeFunctionSideEffects = true;\n+\n+    test(options, code, \"widgetToken()\");\n+  }\n+\n+\n+  public void testFoldLocals3() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.foldConstants = true;\n+\n+    // A function \"f\" who returns a known local object, and a method that\n+    // modifies only modifies that.\n+    String definition = \"function f(){return new Widget()}\";\n+    String call = \"f().go();\";\n+    String code = definition + call;\n+\n+    testSame(options, code);\n+\n+    options.computeFunctionSideEffects = true;\n+\n+    // BROKEN\n+    //test(options, code, definition);\n+    testSame(options, code);\n+  }\n+\n+  public void testFoldLocals4() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.foldConstants = true;\n+\n+    String code = \"/** @constructor */\\n\"\n+        + \"function InternalWidget(){this.x = 1;}\"\n+        + \"InternalWidget.prototype.internalGo = function (){this.x = 2};\"\n+        + \"new InternalWidget().internalGo();\";\n+\n+    testSame(options, code);\n+\n+    options.computeFunctionSideEffects = true;\n+\n+    String optimized = \"\"\n+      + \"function InternalWidget(){this.x = 1;}\"\n+      + \"InternalWidget.prototype.internalGo = function (){this.x = 2};\";\n+\n+    test(options, code, optimized);\n+  }\n+\n+  public void testFoldLocals5() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.foldConstants = true;\n+\n+    String code = \"\"\n+        + \"function fn(){var a={};a.x={};return a}\"\n+        + \"fn().x.y = 1;\";\n+\n+    // \"fn\" returns a unescaped local object, we should be able to fold it,\n+    // but we don't currently.\n+    String result = \"\"\n+        + \"function fn(){var a={x:{}};return a}\"\n+        + \"fn().x.y = 1;\";\n+\n+    test(options, code, result);\n+\n+    options.computeFunctionSideEffects = true;\n+\n+    test(options, code, result);\n+  }\n+\n+  public void testFoldLocals6() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.foldConstants = true;\n+\n+    String code = \"\"\n+        + \"function fn(){return {}}\"\n+        + \"fn().x.y = 1;\";\n+\n+    testSame(options, code);\n+\n+    options.computeFunctionSideEffects = true;\n+\n+    testSame(options, code);\n+  }\n+\n+  public void testFoldLocals7() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.foldConstants = true;\n+\n+    String code = \"\"\n+        + \"function InternalWidget(){return [];}\"\n+        + \"Array.prototype.internalGo = function (){this.x = 2};\"\n+        + \"InternalWidget().internalGo();\";\n+\n+    testSame(options, code);\n+\n+    options.computeFunctionSideEffects = true;\n+\n+    String optimized = \"\"\n+      + \"function InternalWidget(){return [];}\"\n+      + \"Array.prototype.internalGo = function (){this.x = 2};\";\n+\n+    test(options, code, optimized);\n+  }\n+\n+  public void testVarDeclarationsIntoFor() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.collapseVariableDeclarations = false;\n+\n+    String code = \"var a = 1; for (var b = 2; ;) {}\";\n+\n+    testSame(options, code);\n+\n+    options.collapseVariableDeclarations = false;\n+\n+    test(options, code, \"for (var a = 1, b = 2; ;) {}\");\n+  }\n+\n+  public void testExploitAssigns() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.collapseVariableDeclarations = false;\n+\n+    String code = \"a = 1; b = a; c = b\";\n+\n+    testSame(options, code);\n+\n+    options.collapseVariableDeclarations = true;\n+\n+    test(options, code, \"c=b=a=1\");\n+  }\n+\n+  public void testRecoverOnBadExterns() throws Exception {\n+    // This test is for a bug in a very narrow set of circumstances:\n+    // 1) externs validation has to be off.\n+    // 2) aliasExternals has to be on.\n+    // 3) The user has to reference a \"normal\" variable in externs.\n+    // This case is handled at checking time by injecting a\n+    // synthetic extern variable, and adding a \"@suppress {duplicate}\" to\n+    // the normal code at compile time. But optimizations may remove that\n+    // annotation, so we need to make sure that the variable declarations\n+    // are de-duped before that happens.\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.aliasExternals = true;\n+    externs = new JSSourceFile[] {\n+      JSSourceFile.fromCode(\"externs\", \"extern.foo\")\n+    };\n+\n+    test(options,\n+         \"var extern; \" +\n+         \"function f() { return extern + extern + extern + extern; }\",\n+         \"var extern; \" +\n+         \"function f() { return extern + extern + extern + extern; }\",\n+         VarCheck.UNDEFINED_EXTERN_VAR_ERROR);\n+  }\n+\n+  public void testDuplicateVariablesInExterns() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkSymbols = true;\n+    externs = new JSSourceFile[] {\n+      JSSourceFile.fromCode(\"externs\",\n+          \"var externs = {}; /** @suppress {duplicate} */ var externs = {};\")\n+    };\n+    testSame(options, \"\");\n+  }\n+\n+  public void testLanguageMode() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.setLanguageIn(LanguageMode.ECMASCRIPT3);\n+\n+    String code = \"var a = {get f(){}}\";\n+\n+    Compiler compiler = compile(options, code);\n+    checkUnexpectedErrorsOrWarnings(compiler, 1);\n+    assertEquals(\n+        \"JSC_PARSE_ERROR. Parse error. \" +\n+        \"getters are not supported in Internet Explorer \" +\n+        \"at i0 line 1 : 0\",\n+        compiler.getErrors()[0].toString());\n+\n+    options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n+\n+    testSame(options, code);\n+\n+    options.setLanguageIn(LanguageMode.ECMASCRIPT5_STRICT);\n+\n+    testSame(options, code);\n+  }\n+\n+  public void testLanguageMode2() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.setLanguageIn(LanguageMode.ECMASCRIPT3);\n+    options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.OFF);\n+\n+    String code = \"var a  = 2; delete a;\";\n+\n+    testSame(options, code);\n+\n+    options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n+\n+    testSame(options, code);\n+\n+    options.setLanguageIn(LanguageMode.ECMASCRIPT5_STRICT);\n+\n+    test(options,\n+        code,\n+        code,\n+        StrictModeCheck.DELETE_VARIABLE);\n+  }\n+\n+  public void testIssue598() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.setLanguageIn(LanguageMode.ECMASCRIPT5_STRICT);\n+    WarningLevel.VERBOSE.setOptionsForWarningLevel(options);\n+\n+    options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n+\n+    String code =\n+        \"'use strict';\\n\" +\n+        \"function App() {}\\n\" +\n+        \"App.prototype = {\\n\" +\n+        \"  get appData() { return this.appData_; },\\n\" +\n+        \"  set appData(data) { this.appData_ = data; }\\n\" +\n+        \"};\";\n+\n+    Compiler compiler = compile(options, code);\n+    testSame(options, code);\n+  }\n+\n+  public void testCoaleseVariables() {\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.foldConstants = false;\n+    options.coalesceVariableNames = true;\n+\n+    String code =\n+        \"function f(a) {\" +\n+        \"  if (a) {\" +\n+        \"    return a;\" +\n+        \"  } else {\" +\n+        \"    var b = a;\" +\n+        \"    return b;\" +\n+        \"  }\" +\n+        \"  return a;\" +\n+        \"}\";\n+    String expected =\n+        \"function f(a) {\" +\n+        \"  if (a) {\" +\n+        \"    return a;\" +\n+        \"  } else {\" +\n+        \"    a = a;\" +\n+        \"    return a;\" +\n+        \"  }\" +\n+        \"  return a;\" +\n+        \"}\";\n+\n+    test(options, code, expected);\n+\n+    options.foldConstants = true;\n+    options.coalesceVariableNames = false;\n+\n+    code =\n+        \"function f(a) {\" +\n+        \"  if (a) {\" +\n+        \"    return a;\" +\n+        \"  } else {\" +\n+        \"    var b = a;\" +\n+        \"    return b;\" +\n+        \"  }\" +\n+        \"  return a;\" +\n+        \"}\";\n+    expected =\n+        \"function f(a) {\" +\n+        \"  if (!a) {\" +\n+        \"    var b = a;\" +\n+        \"    return b;\" +\n+        \"  }\" +\n+        \"  return a;\" +\n+        \"}\";\n+\n+    test(options, code, expected);\n+\n+    options.foldConstants = true;\n+    options.coalesceVariableNames = true;\n+\n+    expected =\n+      \"function f(a) {\" +\n+      \"  return a;\" +\n+      \"}\";\n+\n+    test(options, code, expected);\n+  }\n+\n+  public void testLateStatementFusion() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.foldConstants = true;\n+    test(options,\n+        \"while(a){a();if(b){b();b()}}\",\n+        \"for(;a;)a(),b&&(b(),b())\");\n+  }\n+\n+  public void testLateConstantReordering() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.foldConstants = true;\n+    test(options,\n+        \"if (x < 1 || x > 1 || 1 < x || 1 > x) { alert(x) }\",\n+        \"   (1 > x || 1 < x || 1 < x || 1 > x) && alert(x) \");\n+  }\n+\n+  public void testsyntheticBlockOnDeadAssignments() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.deadAssignmentElimination = true;\n+    options.removeUnusedVars = true;\n+    options.syntheticBlockStartMarker = \"START\";\n+    options.syntheticBlockEndMarker = \"END\";\n+    test(options, \"var x; x = 1; START(); x = 1;END();x()\",\n+                  \"var x; x = 1;{START();{x = 1}END()}x()\");\n+  }\n+\n+  public void testBug4152835() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.foldConstants = true;\n+    options.syntheticBlockStartMarker = \"START\";\n+    options.syntheticBlockEndMarker = \"END\";\n+    test(options, \"START();END()\", \"{START();{}END()}\");\n+  }\n+\n+  public void testBug5786871() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.ideMode = true;\n+    test(options, \"function () {}\", RhinoErrorReporter.PARSE_ERROR);\n+  }\n+\n+  public void testIssue378() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.inlineVariables = true;\n+    options.flowSensitiveInlineVariables = true;\n+    testSame(options, \"function f(c) {var f = c; arguments[0] = this;\" +\n+                      \"    f.apply(this, arguments); return this;}\");\n+  }\n+\n+  public void testIssue550() {\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel.SIMPLE_OPTIMIZATIONS\n+        .setOptionsForCompilationLevel(options);\n+    options.foldConstants = true;\n+    options.inlineVariables = true;\n+    options.flowSensitiveInlineVariables = true;\n+    test(options,\n+        \"function f(h) {\\n\" +\n+        \"  var a = h;\\n\" +\n+        \"  a = a + 'x';\\n\" +\n+        \"  a = a + 'y';\\n\" +\n+        \"  return a;\\n\" +\n+        \"}\",\n+        \"function f(a) {return a + 'xy'}\");\n+  }\n+\n+  public void testCodingConvention() {\n+    Compiler compiler = new Compiler();\n+    compiler.initOptions(new CompilerOptions());\n+    assertEquals(\n+      compiler.getCodingConvention().getClass().toString(),\n+      ClosureCodingConvention.class.toString());\n+  }\n+\n+  public void testJQueryStringSplitLoops() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.foldConstants = true;\n+    test(options,\n+      \"var x=['1','2','3','4','5','6','7']\",\n+      \"var x='1,2,3,4,5,6,7'.split(',')\");\n+\n+    options = createCompilerOptions();\n+    options.foldConstants = true;\n+    options.computeFunctionSideEffects = false;\n+    options.removeUnusedVars = true;\n+\n+    // If we do splits too early, it would add a sideeffect to x.\n+    test(options,\n+      \"var x=['1','2','3','4','5','6','7']\",\n+      \"\");\n+\n+  }\n+\n+  public void testAlwaysRunSafetyCheck() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.checkSymbols = false;\n+    options.customPasses = ArrayListMultimap.create();\n+    options.customPasses.put(\n+        CustomPassExecutionTime.BEFORE_OPTIMIZATIONS,\n+        new CompilerPass() {\n+          @Override public void process(Node externs, Node root) {\n+            Node var = root.getLastChild().getFirstChild();\n+            assertEquals(Token.VAR, var.getType());\n+            var.detachFromParent();\n+          }\n+        });\n+    try {\n+      test(options,\n+           \"var x = 3; function f() { return x + z; }\",\n+           \"function f() { return x + z; }\");\n+      fail(\"Expected runtime exception\");\n+    } catch (RuntimeException e) {\n+      assertTrue(e.getMessage().indexOf(\"Unexpected variable x\") != -1);\n+    }\n+  }\n+\n+  public void testSuppressEs5StrictWarning() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.WARNING);\n+    testSame(options,\n+        \"/** @suppress{es5Strict} */\\n\" +\n+        \"function f() { var arguments; }\");\n+  }\n+\n+  public void testCheckProvidesWarning() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.setWarningLevel(DiagnosticGroups.CHECK_PROVIDES, CheckLevel.WARNING);\n+    options.setCheckProvides(CheckLevel.WARNING);\n+    test(options,\n+        \"/** @constructor */\\n\" +\n+        \"function f() { var arguments; }\",\n+        DiagnosticType.warning(\"JSC_MISSING_PROVIDE\", \"missing goog.provide(''{0}'')\"));\n+  }\n+\n+  public void testSuppressCheckProvidesWarning() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.setWarningLevel(DiagnosticGroups.CHECK_PROVIDES, CheckLevel.WARNING);\n+    options.setCheckProvides(CheckLevel.WARNING);\n+    testSame(options,\n+        \"/** @constructor\\n\" +\n+        \" *  @suppress{checkProvides} */\\n\" +\n+        \"function f() { var arguments; }\");\n+  }\n+\n+  public void testRenamePrefixNamespace() {\n+    String code =\n+        \"var x = {}; x.FOO = 5; x.bar = 3;\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    testSame(options, code);\n+\n+    options.collapseProperties = true;\n+    options.renamePrefixNamespace = \"_\";\n+    test(options, code, \"_.x$FOO = 5; _.x$bar = 3;\");\n+  }\n+\n+  public void testRenamePrefixNamespaceActivatesMoveFunctionDeclarations() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"var x = f; function f() { return 3; }\";\n+    testSame(options, code);\n+    assertFalse(options.moveFunctionDeclarations);\n+    options.renamePrefixNamespace = \"_\";\n+    test(options, code, \"_.f = function() { return 3; }; _.x = _.f;\");\n+  }\n+\n+  public void testBrokenNameSpace() {\n+    CompilerOptions options = createCompilerOptions();\n+    String code = \"var goog; goog.provide('i.am.on.a.Horse');\" +\n+                  \"i.am.on.a.Horse = function() {};\" +\n+                  \"i.am.on.a.Horse.prototype.x = function() {};\" +\n+                  \"i.am.on.a.Boat.prototype.y = function() {}\";\n+    options.closurePass = true;\n+    options.collapseProperties = true;\n+    options.smartNameRemoval = true;\n+    test(options, code, \"\");\n+  }\n+\n+  public void testNamelessParameter() {\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel.ADVANCED_OPTIMIZATIONS\n+        .setOptionsForCompilationLevel(options);\n+    String code =\n+        \"var impl_0;\" +\n+        \"$load($init());\" +\n+        \"function $load(){\" +\n+        \"  window['f'] = impl_0;\" +\n+        \"}\" +\n+        \"function $init() {\" +\n+        \"  impl_0 = {};\" +\n+        \"}\";\n+    String result =\n+        \"window.f = {};\";\n+    test(options, code, result);\n+  }\n+\n+  public void testHiddenSideEffect() {\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel.ADVANCED_OPTIMIZATIONS\n+        .setOptionsForCompilationLevel(options);\n+    options.setAliasExternals(true);\n+    String code =\n+        \"window.offsetWidth;\";\n+    String result =\n+        \"window.offsetWidth;\";\n+    test(options, code, result);\n+  }\n+\n+  private void testSame(CompilerOptions options, String original) {\n+    testSame(options, new String[] { original });\n+  }\n+\n+  private void testSame(CompilerOptions options, String[] original) {\n+    test(options, original, original);\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * {@code original} is transformed into {@code compiled}.\n+   */\n+  private void test(CompilerOptions options,\n+      String original, String compiled) {\n+    test(options, new String[] { original }, new String[] { compiled });\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * {@code original} is transformed into {@code compiled}.\n+   */\n+  private void test(CompilerOptions options,\n+      String[] original, String[] compiled) {\n+    Compiler compiler = compile(options, original);\n+    assertEquals(\"Expected no warnings or errors\\n\" +\n+        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n+        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n+        0, compiler.getErrors().length + compiler.getWarnings().length);\n+\n+    Node root = compiler.getRoot().getLastChild();\n+    Node expectedRoot = parse(compiled, options);\n+    String explanation = expectedRoot.checkTreeEquals(root);\n+    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+        \"\\nResult: \" + compiler.toSource(root) +\n+        \"\\n\" + explanation, explanation);\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * there is an error or warning.\n+   */\n+  private void test(CompilerOptions options,\n+      String original, DiagnosticType warning) {\n+    test(options, new String[] { original }, warning);\n+  }\n+\n+  private void test(CompilerOptions options,\n+      String original, String compiled, DiagnosticType warning) {\n+    test(options, new String[] { original }, new String[] { compiled },\n+         warning);\n+  }\n+\n+  private void test(CompilerOptions options,\n+      String[] original, DiagnosticType warning) {\n+    test(options, original, null, warning);\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * there is an error or warning.\n+   */\n+  private void test(CompilerOptions options,\n+      String[] original, String[] compiled, DiagnosticType warning) {\n+    Compiler compiler = compile(options, original);\n+    checkUnexpectedErrorsOrWarnings(compiler, 1);\n+    assertEquals(\"Expected exactly one warning or error\",\n+        1, compiler.getErrors().length + compiler.getWarnings().length);\n+    if (compiler.getErrors().length > 0) {\n+      assertEquals(warning, compiler.getErrors()[0].getType());\n+    } else {\n+      assertEquals(warning, compiler.getWarnings()[0].getType());\n+    }\n+\n+    if (compiled != null) {\n+      Node root = compiler.getRoot().getLastChild();\n+      Node expectedRoot = parse(compiled, options);\n+      String explanation = expectedRoot.checkTreeEquals(root);\n+      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+          \"\\nResult: \" + compiler.toSource(root) +\n+          \"\\n\" + explanation, explanation);\n+    }\n+  }\n+\n+  private void checkUnexpectedErrorsOrWarnings(\n+      Compiler compiler, int expected) {\n+    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n+    if (actual != expected) {\n+      String msg = \"\";\n+      for (JSError err : compiler.getErrors()) {\n+        msg += \"Error:\" + err.toString() + \"\\n\";\n+      }\n+      for (JSError err : compiler.getWarnings()) {\n+        msg += \"Warning:\" + err.toString() + \"\\n\";\n+      }\n+      assertEquals(\"Unexpected warnings or errors.\\n \"+ msg,\n+        expected, actual);\n+    }\n+  }\n+\n+  private Compiler compile(CompilerOptions options, String original) {\n+    return compile(options, new String[] { original });\n+  }\n+\n+  private Compiler compile(CompilerOptions options, String[] original) {\n+    Compiler compiler = lastCompiler = new Compiler();\n+    JSSourceFile[] inputs = new JSSourceFile[original.length];\n+    for (int i = 0; i < original.length; i++) {\n+      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n+    }\n+    compiler.compile(\n+        externs, CompilerTestCase.createModuleChain(original), options);\n+    return compiler;\n+  }\n+\n+  private Node parse(String[] original, CompilerOptions options) {\n+    Compiler compiler = new Compiler();\n+    JSSourceFile[] inputs = new JSSourceFile[original.length];\n+    for (int i = 0; i < inputs.length; i++) {\n+      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n+    }\n+    compiler.init(externs, inputs, options);\n+    checkUnexpectedErrorsOrWarnings(compiler, 0);\n+    Node all = compiler.parseInputs();\n+    checkUnexpectedErrorsOrWarnings(compiler, 0);\n+    Node n = all.getLastChild();\n+    Node externs = all.getFirstChild();\n+\n+    (new CreateSyntheticBlocks(\n+        compiler, \"synStart\", \"synEnd\")).process(externs, n);\n+    (new Normalize(compiler, false)).process(externs, n);\n+    (MakeDeclaredNamesUnique.getContextualRenameInverter(compiler)).process(\n+        externs, n);\n+    (new Denormalize(compiler)).process(externs, n);\n+    return n;\n+  }\n+\n+  /** Creates a CompilerOptions object with google coding conventions. */\n+  private CompilerOptions createCompilerOptions() {\n+    CompilerOptions options = new CompilerOptions();\n+    options.setCodingConvention(new GoogleCodingConvention());\n+    return options;\n+  }\n+}", "timestamp": 1327336942, "metainfo": ""}