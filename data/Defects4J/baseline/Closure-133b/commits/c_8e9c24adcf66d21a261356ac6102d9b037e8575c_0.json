{"sha": "8e9c24adcf66d21a261356ac6102d9b037e8575c", "log": "property refs should have precedence over lexical refs  R=johnlenz DELTA=58  (33 added, 4 deleted, 21 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4068   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n           this);\n     }\n \n-    private void maybeDefineReference(\n+    private boolean maybeDefineReference(\n         Node n, String propName, Symbol ownerSymbol) {\n       // getPropertyScope() will be null in some rare cases where there\n       // are no extern declarations for built-in types (like Function).\n         Symbol prop = ownerSymbol.getPropertyScope().getSlot(propName);\n         if (prop != null) {\n           prop.defineReferenceAt(n);\n-        }\n-      }\n+          return true;\n+        }\n+      }\n+      return false;\n     }\n \n     // Try to find the symbol by its fully qualified name.\n       return false;\n     }\n \n-    private void maybeDefineTypedReference(\n+    private boolean maybeDefineTypedReference(\n         Node n, String propName, JSType owner) {\n       if (owner.isGlobalThisType()) {\n         Symbol sym = globalScope.getSlot(propName);\n         if (sym != null) {\n           sym.defineReferenceAt(n);\n+          return true;\n         }\n       } else if (owner.isNominalConstructor()) {\n-        maybeDefineReference(\n+        return maybeDefineReference(\n             n, propName, getSymbolDeclaredBy(owner.toMaybeFunctionType()));\n       } else if (owner.isEnumType()) {\n-        maybeDefineReference(\n+        return maybeDefineReference(\n             n, propName, getSymbolDeclaredBy(owner.toMaybeEnumType()));\n       } else {\n+        boolean defined = false;\n         for (Symbol ctor : getAllSymbolsForType(owner)) {\n-          maybeDefineReference(n, propName, getSymbolForInstancesOf(ctor));\n-        }\n-      }\n+          if (maybeDefineReference(\n+                  n, propName, getSymbolForInstancesOf(ctor))) {\n+            defined = true;\n+          }\n+        }\n+        return defined;\n+      }\n+      return false;\n     }\n \n     @Override\n       // There are two ways to define a property reference:\n       // 1) As a fully qualified lexical symbol (e.g., x.y)\n       // 2) As a property of another object (e.g., x's y)\n+      // Property definitions should take precedence over lexical\n+      // definitions. e.g., for \"a.b\", it's more useful to record\n+      // this as \"property b of the type of a\", than as \"symbol a.b\".\n \n       if (n.isGetProp()) {\n         JSType owner = n.getFirstChild().getJSType();\n-        if (owner == null || owner.isUnknownType()) {\n-          boolean defined = tryDefineLexicalQualifiedNameRef(\n-              n.getQualifiedName(), n);\n-\n-          // If the owner is unknown, and we haven't been able to define\n-          // this lexically, try to define it as a property (in case\n-          // the owner is just a type with an unresolved superclass).\n-          if (defined || owner == null) {\n+        if (owner != null) {\n+          boolean defined = maybeDefineTypedReference(\n+              n, n.getLastChild().getString(), owner);\n+\n+          if (defined) {\n             return;\n           }\n         }\n \n-        maybeDefineTypedReference(n, n.getLastChild().getString(), owner);\n+        tryDefineLexicalQualifiedNameRef(n.getQualifiedName(), n);\n       } else if (NodeUtil.isObjectLitKey(n, parent) && n.isString()) {\n         JSType owner = parent.getJSType();\n-        if (owner == null || owner.isUnknownType()) {\n-          boolean defined = tryDefineLexicalQualifiedNameRef(\n-              NodeUtil.getBestLValueName(n), n);\n-\n-          // See comments above.\n-          if (defined || owner == null) {\n+        if (owner != null) {\n+          boolean defined =\n+              maybeDefineTypedReference(n, n.getString(), owner);\n+\n+          if (defined) {\n             return;\n           }\n         }\n \n-        maybeDefineTypedReference(n, n.getString(), owner);\n+        tryDefineLexicalQualifiedNameRef(\n+            NodeUtil.getBestLValueName(n), n);\n       }\n     }\n   }\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n         3, Iterables.size(table.getReferences(method)));\n   }\n \n+  public void testFieldReferencesMissingTypeInfo() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Missing}\\n\" +\n+        \" */ var DomHelper = function(){ this.prop = 1; };\\n\" +\n+        \"/** @type {number} */ DomHelper.prototype.prop = 2;\\n\" +\n+        \"function f() {\\n\" +\n+        \"  return (new DomHelper()).prop;\\n\" +\n+        \"};\");\n+\n+    Symbol prop =\n+        getGlobalVar(table, \"DomHelper.prototype.prop\");\n+    assertEquals(3, table.getReferenceList(prop).size());\n+\n+    Symbol thisDotProp =\n+        getLocalVar(table, \"this.prop\");\n+    assertEquals(\n+        1, table.getReferenceList(thisDotProp).size());\n+  }\n \n   public void testFieldReferences() throws Exception {\n     SymbolTable table = createSymbolTable(", "timestamp": 1326327104, "metainfo": ""}