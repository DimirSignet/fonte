{"sha": "d1f25380b5d74c5303533491e36ae4b33a50e2da", "log": "Type-checking fix when the prototype is assigned directly. Fixes issue 59.  Also, make sure that DevirtualizePrototypeMethods maintains type info.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n \n     for (Node child : node.children()) {\n       if (NodeUtil.isThis(child)) {\n-        node.replaceChild(child, Node.newString(Token.NAME, name));\n+        Node newName = Node.newString(Token.NAME, name);\n+        newName.setJSType(child.getJSType());\n+        node.replaceChild(child, newName);\n       } else {\n         replaceReferencesToThis(child, name);\n       }\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n         }\n       }\n \n+      // Ignore the prototype itself at all times.\n+      if (\"prototype\".equals(field)) {\n+        return null;\n+      }\n+\n       // We look up the prototype chain to find the highest place (if any) that\n       // this appears.  This will make references to overriden properties look\n       // like references to the initial property, so they are renamed alike.\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     String qName = getprop.getQualifiedName();\n     if (qName != null) {\n       Var var = syntacticScope.getVar(qName);\n-      if (var != null &&\n-          !var.isTypeInferred() &&\n-          !objectType.hasOwnProperty(propName) &&\n-          (!objectType.isInstanceType() ||\n-           (var.isExtern() && !objectType.isNativeObjectType()))) {\n-        objectType.defineDeclaredProperty(\n-            propName, var.getType(), var.isExtern());\n-        return true;\n+      if (var != null && !var.isTypeInferred()) {\n+        // Handle normal declarations that could not be addressed earlier.\n+        if (propName.equals(\"prototype\") ||\n+        // Handle prototype declarations that could not be addressed earlier.\n+            (!objectType.hasOwnProperty(propName) &&\n+             (!objectType.isInstanceType() ||\n+                 (var.isExtern() && !objectType.isNativeObjectType())))) {\n+          return objectType.defineDeclaredProperty(\n+              propName, var.getType(), var.isExtern());\n+        }\n       }\n     }\n     return false;\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   }\n \n   @Override\n+  public boolean hasOwnProperty(String name) {\n+    return super.hasOwnProperty(name) || \"prototype\".equals(name);\n+  }\n+\n+  @Override\n   public JSType getPropertyType(String name) {\n     if (\"prototype\".equals(name)) {\n       return getPrototype();\n     if (\"prototype\".equals(name)) {\n       ObjectType objType = type.toObjectType();\n       if (objType != null) {\n+        if (objType.equals(prototype)) {\n+          return true;\n+        }\n         return setPrototype(\n             new FunctionPrototypeType(\n                 registry, this, objType, isNativeObjectType()));\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n    *        file. TightenTypes assumes that any function passed to an externs\n    *        property could be called, so setting this incorrectly could result\n    *        in live code being removed.\n+   * @return True if the property was registered successfully, false if this\n+   *        conflicts with a previous property type declaration.\n    */\n   abstract boolean defineProperty(String propertyName, JSType type,\n       boolean inferred, boolean inExterns);\n--- a/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n \n     static final List<String> EXPECTED_TYPE_CHECKING_OFF = ImmutableList.of(\n         \"FUNCTION a = null\",\n+        \"NAME JSCompiler_StaticMethods_foo$self = null\",\n         \"FUNCTION JSCompiler_StaticMethods_foo = null\",\n+        \"NAME JSCompiler_StaticMethods_bar$self = null\",\n         \"FUNCTION JSCompiler_StaticMethods_bar = null\",\n         \"FUNCTION JSCompiler_StaticMethods_baz = null\",\n         \"NEW a = null\",\n \n     static final List<String> EXPECTED_TYPE_CHECKING_ON = ImmutableList.of(\n         \"FUNCTION a = function (this:a): ?\",\n+        \"NAME JSCompiler_StaticMethods_foo$self = a\",\n         \"FUNCTION JSCompiler_StaticMethods_foo = function (a): number\",\n+        \"NAME JSCompiler_StaticMethods_bar$self = a\",\n         \"FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number\",\n         \"FUNCTION JSCompiler_StaticMethods_baz = function (a): ?\",\n         \"NEW a = a\",\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n-    return new FunctionTypeInformationGatherer(\n+    return new TypeInformationGatherer(\n         compiler, new DevirtualizePrototypeMethods(compiler), typeInformation);\n   }\n \n   /**\n-   * Wrapper that gathers function and call type strings after the\n-   * pass under test runs.  For use to test passes that modify JSType\n+   * Wrapper that gathers function, call, and self variable type strings after\n+   * the pass under test runs.  For use to test passes that modify JSType\n    * annotations.\n    */\n-  private static class FunctionTypeInformationGatherer\n+  private static class TypeInformationGatherer\n       implements CompilerPass {\n     private final Compiler compiler;\n     private final CompilerPass passUnderTest;\n     private final List<String> typeInformation;\n \n-    FunctionTypeInformationGatherer(Compiler compiler,\n+    TypeInformationGatherer(Compiler compiler,\n                                     CompilerPass passUnderTest,\n                                     List<String> typeInformation) {\n       this.compiler = compiler;\n                         \" = \",\n                         (type != null) ? type.toString() : \"null\"));\n         }\n+\n+        if (NodeUtil.isGetProp(node)) {\n+          Node child = node.getFirstChild();\n+          if (NodeUtil.isName(child) && child.getString().endsWith(\"$self\")) {\n+            JSType type = child.getJSType();\n+            typeInformation.add(\n+                Joiner.on(\"\").join(\n+                    Token.name(child.getType()),\n+                    \" \",\n+                    child.getString(),\n+                    \" = \",\n+                    (type != null) ? type.toString() : \"null\"));\n+          }\n+        }\n       }\n     }\n   }\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n       String fieldTypes) {\n     this.runTightenTypes = runTightenTypes;\n     test(js, expected);\n-    assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));\n+    assertEquals(\n+        fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));\n   }\n \n   @SuppressWarnings(\"unchecked\")\n        String description) {\n     this.runTightenTypes = runTightenTypes;\n     test(externs, js, expected, null, warning, description);\n-    assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));\n+    assertEquals(\n+        fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"inconsistent return type\\n\" +\n         \"found   : boolean\\n\" +\n         \"required: number\");\n+  }\n+\n+  public void testGoodExtends9() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Super() {}\" +\n+        \"Super.prototype.foo = function() {};\" +\n+        \"/** @constructor \\n * @extends {Super} */ function Sub() {}\" +\n+        \"Sub.prototype = new Super();\" +\n+        \"/** @override */ Sub.prototype.foo = function() {};\");\n+  }\n+\n+  public void testGoodExtends10() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Super() {}\" +\n+        \"/** @constructor \\n * @extends {Super} */ function Sub() {}\" +\n+        \"Sub.prototype = new Super();\" +\n+        \"/** @return {Super} */ function foo() { return new Sub(); }\");\n+  }\n+\n+  public void testGoodExtends11() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Super() {}\" +\n+        \"/** @param {boolean} x */ Super.prototype.foo = function(x) {};\" +\n+        \"/** @constructor \\n * @extends {Super} */ function Sub() {}\" +\n+        \"Sub.prototype = new Super();\" +\n+        \"(new Sub()).foo(0);\",\n+        \"actual parameter 1 of Super.prototype.foo \" +\n+        \"does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: boolean\");\n   }\n \n   public void testBadExtends1() throws Exception {", "timestamp": 1265394688, "metainfo": ""}