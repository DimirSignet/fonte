{"sha": "0b7eccf2fd3a9293d7b513fbb766d7bc06abd7e0", "log": "A bunch of bug fixes Added the --warning_level={QUIET|DEFAULT|VERBOSE} flag, to match the webservice API    ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n     return !scope.isGlobal();\n   }\n \n-  @Override\n-  public boolean allowsUndeclaredVariables() {\n-    return true;\n-  }\n-\n   private final Set<String> propertyTestFunctions = ImmutableSet.of(\n       \"goog.isDef\", \"goog.isNull\", \"goog.isDefAndNotNull\",\n       \"goog.isString\", \"goog.isNumber\", \"goog.isBoolean\",\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n     private static boolean isReadFrom(Var var, Node name) {\n       return name != null && NodeUtil.isName(name) &&\n           var.getName().equals(name.getString()) &&\n-          NodeUtil.isRValue(name);\n+          !NodeUtil.isLhs(name, name.getParent());\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n \n   public boolean allowsVariableRedeclaration(Scope scope, String name,\n       Node parent);\n-\n-  public boolean allowsUndeclaredVariables();\n \n   /**\n    * Whether this CALL function is testing for the existence of a property.\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n   private static void applySafeCompilationOptions(CompilerOptions options) {\n     // Does not call applyBasicCompilationOptions(options) because the call to\n     // skipAllCompilerPasses() cannot be easily undone.\n+    options.closurePass = true;\n     options.variableRenaming = VariableRenamingPolicy.LOCAL;\n     options.checkGlobalThisLevel = CheckLevel.OFF;\n     options.foldConstants = true;\n     options.removeUnusedVars = true;\n     options.removeUnusedVarsInGlobalScope = false;\n \n-    // Pretty much all external JS libraries use things like setTimeout()\n-    // directly rather than specifying window.setTimeout().\n-    options.setWarningLevel(DiagnosticGroups.UNDEFINED_VARIABLES,\n-        CheckLevel.OFF);\n-\n     // Allows annotations that are not standard.\n     options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,\n         CheckLevel.OFF);\n     // create possible conflicts between multiple diagnostic groups.\n \n     // All the safe optimizations.\n+    options.closurePass = true;\n     options.checkGlobalThisLevel = CheckLevel.OFF;\n     options.foldConstants = true;\n     options.removeConstantExpressions = true;\n     options.labelRenaming = true;\n     options.removeDeadCode = true;\n     options.optimizeArgumentsArray = true;\n-\n-    // Pretty much all external JS libraries use things like setTimeout()\n-    // directly rather than specifying window.setTimeout().\n-    options.setWarningLevel(DiagnosticGroups.UNDEFINED_VARIABLES,\n-        CheckLevel.OFF);\n \n     // All the advance optimizations.\n     options.variableRenaming = VariableRenamingPolicy.ALL;\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   void sanityCheckVars() {\n     logger_.info(\"Checking for undefined vars\");\n     startPass(\"sanityCheckVars\");\n-    VarCheck v = new VarCheck(this, false);\n+    VarCheck v = new VarCheck(this, true);\n     process(v);\n     endPass();\n   }\n       VariableMap prevVariableMap) {\n     logger_.info(\"Renaming vars\");\n     startPass(\"renameVars\");\n+    boolean preserveAnonymousFunctionNames =\n+      anonFunctionNamePolicy != AnonymousFunctionNamingPolicy.OFF;\n     RenameVars rn = new RenameVars(\n-        this, renamePrefix, renameLocalVarsOnly, prevVariableMap,\n+        this, renamePrefix,\n+        renameLocalVarsOnly, preserveAnonymousFunctionNames,\n+        prevVariableMap,\n         anonFunctionNamePolicy.getReservedCharacters(),\n         getPassConfig().getExportedNames());\n     process(rn);\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    */\n   public CheckLevel checkGlobalNamesLevel;\n \n-  /** Allow bad Closure require calls. Use brokenClosureRequiresLevel instead */\n-  @Deprecated\n-  public boolean allowBrokenClosureRequires;\n-\n   /** Sets the check level for bad Closure require calls. */\n   public CheckLevel brokenClosureRequiresLevel;\n \n \n   /** Removes unused variables in global scope. */\n   public boolean removeUnusedVarsInGlobalScope;\n-  \n+\n   /** Adds variable aliases for externals to reduce code size */\n   public boolean aliasExternals;\n \n   boolean collapsePropertiesOnExternTypes;\n \n   /**\n-   * Devirtualize prototype method by rewriting them to be static calls that \n+   * Devirtualize prototype method by rewriting them to be static calls that\n    * take the this pointer as their first argument\n    */\n   public boolean devirtualizePrototypeMethods;\n     checkRequires = CheckLevel.OFF;\n     checkProvides = CheckLevel.OFF;\n     checkGlobalNamesLevel = CheckLevel.OFF;\n-    allowBrokenClosureRequires = false;\n+    brokenClosureRequiresLevel = CheckLevel.ERROR;\n     checkGlobalThisLevel = CheckLevel.WARNING;\n     checkUnreachableCode = CheckLevel.OFF;\n     checkMissingReturn = CheckLevel.OFF;\n--- a/src/com/google/javascript/jscomp/CompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/CompilerRunner.java\n public class CompilerRunner extends\n     AbstractCompilerRunner<Compiler, CompilerOptions> {\n \n-  @FlagSpec(help = \"Specifies the compilation level to use\")\n+  @FlagSpec(help = \"Specifies the compilation level to use. Options: \" +\n+            \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\")\n   private static final Flag<CompilationLevel> FLAG_compilation_level\n       = Flag.value(CompilationLevel.SIMPLE_OPTIMIZATIONS);\n+\n+  @FlagSpec(help = \"Specifies the warning level to use. Options: \" +\n+            \"QUIET, DEFAULT, VERBOSE\")\n+  static final Flag<WarningLevel> FLAG_warning_level\n+      = Flag.value(WarningLevel.DEFAULT);\n \n   @FlagSpec(help = \"Specifies whether the default externs should be excluded.\")\n   private static final Flag<Boolean> FLAG_use_only_custom_externs\n     CompilerOptions options = new CompilerOptions();\n     CompilationLevel level = FLAG_compilation_level.get();\n     level.setOptionsForCompilationLevel(options);\n+    WarningLevel wLevel = FLAG_warning_level.get();\n+    wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : FLAG_formatting.get()) {\n       formattingOption.applyToOptions(options);\n     }\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n   }\n \n   @Override\n-  public boolean allowsUndeclaredVariables() {\n-    return true;\n-  }\n-\n-  @Override\n   public boolean isPropertyTestFunction(Node call) {\n     return false;\n   }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       checks.add(createSyntheticBlocks);\n     }\n \n-    if (options.checkSymbols) {\n-      checks.add(checkVars);\n-    }\n+    // All passes must run the variable check. This synthesizes\n+    // variables later so that the compiler doesn't crash. It also\n+    // checks the externs file for validity. If you don't want to warn\n+    // about missing variable declarations, we shut that specific\n+    // error off.\n+    if (!options.checkSymbols) {\n+      options.setWarningLevel(DiagnosticGroups.UNDEFINED_VARIABLES,\n+          CheckLevel.OFF);\n+    }\n+\n+    checks.add(checkVars);\n \n     if (options.checkShadowVars.isOn()) {\n       checks.add(checkShadowVars);\n       new PassFactory(\"processProvidesAndRequires\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      final ProcessClosurePrimitives pass =\n-          options.brokenClosureRequiresLevel != null ?\n-          new ProcessClosurePrimitives(\n-              compiler,\n-              options.brokenClosureRequiresLevel,\n-              options.rewriteNewDateGoogNow) :\n-          new ProcessClosurePrimitives(\n-              compiler,\n-              options.allowBrokenClosureRequires,\n-              options.rewriteNewDateGoogNow);\n+      final ProcessClosurePrimitives pass = new ProcessClosurePrimitives(\n+          compiler,\n+          options.brokenClosureRequiresLevel,\n+          options.rewriteNewDateGoogNow);\n \n       return new CompilerPass() {\n         @Override\n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n       Node var = getBlockVar(elseBranch);\n       Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n \n-      Node name1 = thenAssign.getFirstChild();\n+      Node maybeName1 = thenAssign.getFirstChild();\n       Node name2 = var.getFirstChild();\n \n-      if (name2.hasChildren() && name1.getString().equals(name2.getString())) {\n+      if (name2.hasChildren()\n+          && maybeName1.getType() == Token.NAME\n+          && maybeName1.getString().equals(name2.getString())) {\n         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n         Node elseExpr = name2.removeChildren();\n         cond.detachFromParent();\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n       // This is a simple call?  Example: \"foo();\".\n       return CallSiteType.SIMPLE_CALL;\n     } else if (NodeUtil.isExprAssign(grandParent)\n-        && NodeUtil.isRValue(callNode)\n+        && !NodeUtil.isLhs(callNode, parent)\n         && parent.getFirstChild().getType() == Token.NAME\n         && !NodeUtil.isConstantName(parent.getFirstChild())) {\n       // This is a simple assignment.  Example: \"x = foo();\"\n--- a/src/com/google/javascript/jscomp/GoogleCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/GoogleCodingConvention.java\n   public boolean isPrivate(String name) {\n     return name.endsWith(\"_\") && !isExported(name);\n   }\n-\n-  @Override\n-  public boolean allowsUndeclaredVariables() {\n-    return false;\n-  }\n }\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n      * If the value is a literal, we can cross more boundaries to inline it.\n      */\n     private boolean canMoveAggressively(Reference declaration) {\n-      return NodeUtil.isLiteralValue(\n-          declaration.getNameNode().getFirstChild());\n+      // Anonymous functions and other mutable objects can move within \n+      // the same basic block.\n+      Node value = declaration.getNameNode().getFirstChild();\n+      return NodeUtil.isLiteralValue(value)\n+          || value.getType() == Token.FUNCTION;\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n \n     final Node fnName = n.getFirstChild();\n \n-    // Function name\n-    traverseBranch(fnName, n);\n+    boolean anonymous = parent != null && NodeUtil.isFunctionAnonymous(n); \n+\n+    if (!anonymous) {\n+      // Named functions are parent of the containing scope.\n+      traverseBranch(fnName, n);\n+    }\n \n     curNode = n;\n     pushScope(n);\n \n+    if (anonymous) {\n+      // Anonymous function names are parent of the contained scope.\n+      traverseBranch(fnName, n);\n+    }\n+    \n     final Node args = fnName.getNext();\n     final Node body = args.getNext();\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   /**\n-   * Determines if the given node is ever used as an L-value of an expression.\n-   * In other words, returns true if the value of the node is being written\n-   * (as opposed to only being read).\n-   *\n-   * @param n The node in question, which must be the current node in the\n-   *          traversal, or one of its parents.\n-   * @throws IllegalArgumentException if {@code n} is not the current\n-   *   node (or a parent of) in the traversal.\n-   */\n-  static boolean isLValue(Node n) {\n-    return getRValue(n) != null;\n-  }\n-\n-  /**\n-   * Determines the R-Value of a node that is used as a L-Value.\n-   *\n-   * @return The node that is the R-Value or {@code null} if {@code n} is not an\n-   *     L-Value node.\n-   */\n-  static Node getRValue(Node n) {\n-    Node current = n;\n-    Node ancestor;\n-    while ((ancestor = current.getParent()) != null) {\n-      switch (ancestor.getType()) {\n-        case Token.EXPR_RESULT:\n-        case Token.GETPROP:\n-          // Expression statements and get prop's don't indicate how the\n-          // value is being used. We have to look at the parent.\n-          break;\n-        case Token.ASSIGN:\n-          if (ancestor.getFirstChild() == current) {\n-            // The L-value because it's on the left hand side of the assign\n-            return ancestor.getLastChild();\n-          }\n-          // Otherwise, it's an R-value, but we have to continue examining\n-          // ancestors because this assignment may also be used as a L-value.\n-          break;\n-\n-        case Token.SCRIPT:\n-        case Token.FUNCTION:\n-        case Token.LP:\n-        case Token.BLOCK:\n-          // These parents indicate that the value was read, but not written.\n-          return null;\n-\n-        case Token.VAR:\n-          // The value was written.\n-          if (n.hasChildren()) {\n-            return n.getFirstChild();\n-          } else {\n-            return null;\n-          }\n-\n-        default:\n-          // Other parent nodes indicate that the value is being read.\n-          return null;\n-      }\n-      current = ancestor;\n-    }\n-\n-    // Reached the top of the script. Definitely not an l-value.\n-    return null;\n-  }\n-\n-  /**\n-   * Determines if the given node is ever used as an R-value of an expression.\n-   * In other words, returns true if the value of the node is being read\n-   * (as opposed to only being written to).\n-   *\n-   * @param n The node in question, which must be the current node in the\n-   *          traversal, or one of its parents.\n-   */\n-  static boolean isRValue(Node n) {\n-    Node current = n;\n-    Node parent;\n-    while ((parent = current.getParent()) != null) {\n-      switch (parent.getType()) {\n-        case Token.EXPR_RESULT:\n-        case Token.GETPROP:\n-          // Expression statements and get prop's don't indicate how the\n-          // value is being used. We have to look at the parent.\n-          break;\n-        case Token.ASSIGN:\n-          if (parent.getFirstChild() != current) {\n-            // Not the L-value, so it's on the right hand side of the assign\n-            return true;\n-          }\n-          // Otherwise, it's an L-value, but we have to continue examining\n-          // ancestors because this assignment may also be used as a R-value.\n-          break;\n-\n-        case Token.SCRIPT:\n-        case Token.FUNCTION:\n-        case Token.LP:\n-        case Token.BLOCK:\n-        case Token.VAR:\n-          return false;\n-\n-        default:\n-          // Other parent nodes indicate that the value is being read.\n-          return true;\n-      }\n-      current = parent;\n-    }\n-\n-    // Reached the top of the script. Definitely not an r-value.\n-    return false;\n-  }\n-\n-  /**\n    * Is this a GETPROP or GETELEM node?\n    */\n   static boolean isGet(Node n) {\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n     Token.NAME,\n     Token.NEW,\n     Token.FUNCTION);\n-\n-  ProcessClosurePrimitives(AbstractCompiler compiler,\n-                           boolean allowBrokenRequires,\n-                           boolean rewriteNewDateGoogNow) {\n-    this(compiler,\n-         allowBrokenRequires ? CheckLevel.WARNING : CheckLevel.ERROR,\n-         rewriteNewDateGoogNow);\n-  }\n \n   ProcessClosurePrimitives(AbstractCompiler compiler,\n                            CheckLevel requiresLevel,\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n   }\n \n   /**\n-   * Updates block statck and invokes any additional behavior.\n+   * Updates block stack and invokes any additional behavior.\n    */\n   public void enterScope(NodeTraversal t) {\n     Node n = t.getScope().getRootNode();\n     BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek();\n     blockStack.push(new BasicBlock(parent, n));\n-\n-    // Handle bleeding functions (named functions that create a variable\n-    // declaration inside their scope, for recursion. such as:\n-    // var x = function y() { return y(); }\n-    // This is a special case because the declaration of \"y\" does not\n-    // actually appear in the inner scope, even though it is a part of the\n-    // inner scope.\n-    if (n.getType() == Token.FUNCTION) {\n-      String fnName = n.getFirstChild().getString();\n-      Scope s = t.getScope();\n-      if (!fnName.isEmpty() && s.getVar(fnName).scope == s) {\n-        addReference(t, s.getVar(fnName),\n-            Reference.newBleedingFunction(t, parent, n));\n-      }\n-    }\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n   /** Whether renaming should apply to local variables only. */\n   private final boolean localRenamingOnly;\n \n+  /**\n+   * Whether anonymous function names should be preserved. Typically, for\n+   * debugging purposes.\n+   * @see NameAnonymousFunctions\n+   */\n+  private boolean preserveAnonymousFunctionNames;\n+\n   /** Characters that shouldn't be used in variable names. */\n   private final char[] reservedCharacters;\n \n   /** A prefix to distinguish temporary local names from global names */\n   private static final String LOCAL_VAR_PREFIX = \"L \";\n \n-  RenameVars(AbstractCompiler compiler, String prefix,\n-      boolean localRenamingOnly, VariableMap prevUsedRenameMap,\n+  RenameVars(AbstractCompiler compiler,\n+      String prefix,\n+      boolean localRenamingOnly,\n+      boolean preserveAnonymousFunctionNames,\n+      VariableMap prevUsedRenameMap,\n       @Nullable char[] reservedCharacters,\n       @Nullable Set<String> reservedNames) {\n     this.compiler = compiler;\n     this.prefix = prefix == null ? \"\" : prefix;\n     this.localRenamingOnly = localRenamingOnly;\n+    this.preserveAnonymousFunctionNames = preserveAnonymousFunctionNames;\n     this.prevUsedRenameMap = prevUsedRenameMap;\n     this.reservedCharacters = reservedCharacters;\n     if (reservedNames == null) {\n         return;\n       }\n \n+      // Are we renaming anonymous function names?\n+      if (preserveAnonymousFunctionNames\n+          && var != null\n+          && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+        reservedNames.add(name);\n+        return;\n+      }\n+\n       // Check if we can rename this.\n       if (!okToRenameVar(name, local)) {\n         return;\n--- a/src/com/google/javascript/jscomp/ShowByPathWarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/ShowByPathWarningsGuard.java\n import com.google.common.base.Preconditions;\n \n /**\n- * Show warnings only for specific path. The rest of warnings should be\n- * suppressed.\n+ * Control whether warnings should be restricted or suppressed for specified\n+ * paths.\n  *\n *\n  */\n public class ShowByPathWarningsGuard extends WarningsGuard {\n-  private final String[] checkWarningsOnlyForPath;\n+  /**\n+   * Controls whether warnings should be restricted to a specified path or\n+   * suppressed within the specified path.\n+   */\n+  public enum ShowType {\n+    INCLUDE,  // Suppress warnings outside the path.\n+    EXCLUDE;  // Suppress warnings within the path.\n+  }\n+\n+  private final String[] paths;\n+  private final ShowType showType;\n \n   public ShowByPathWarningsGuard(String checkWarningsOnlyForPath) {\n-    Preconditions.checkArgument(checkWarningsOnlyForPath != null);\n-    this.checkWarningsOnlyForPath = new String[] { checkWarningsOnlyForPath };\n+    this(checkWarningsOnlyForPath, ShowType.INCLUDE);\n   }\n \n   public ShowByPathWarningsGuard(String[] checkWarningsOnlyForPath) {\n-    Preconditions.checkArgument(checkWarningsOnlyForPath != null);\n-    this.checkWarningsOnlyForPath = checkWarningsOnlyForPath;\n+    this(checkWarningsOnlyForPath, ShowType.INCLUDE);\n+  }\n+\n+  public ShowByPathWarningsGuard(String path, ShowType showType) {\n+    this(new String[] { path }, showType);\n+  }\n+\n+  public ShowByPathWarningsGuard(String[] paths, ShowType showType) {\n+    Preconditions.checkArgument(paths != null);\n+    Preconditions.checkArgument(showType != null);\n+    this.paths = paths;\n+    this.showType = showType;\n   }\n \n   @Override\n   public CheckLevel level(JSError error) {\n-    // Check if we dont want to see these warnings\n-    final String filePath = error.sourceName;\n-\n-    if (error.level != CheckLevel.ERROR && filePath != null) {\n-      boolean checkMe = false;\n-      for (String checkedPath : checkWarningsOnlyForPath) {\n-        checkMe |= filePath.contains(checkedPath);\n+    final String errorPath = error.sourceName;\n+    if (error.level != CheckLevel.ERROR && errorPath != null) {\n+      boolean inPath = false;\n+      for (String path : paths) {\n+        inPath |= errorPath.contains(path);\n       }\n-\n-      if (!checkMe) {\n+      if (inPath ^ (showType == ShowType.INCLUDE)) {\n         return CheckLevel.OFF;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/SourceFile.java\n+++ b/src/com/google/javascript/jscomp/SourceFile.java\n   //////////////////////////////////////////////////////////////////////////////\n   // Implementation\n \n-  /** Gets all the code in this source file. */\n+  /** \n+   * Gets all the code in this source file. \n+   * @throws IOException \n+   */\n   public String getCode() throws IOException {\n     return code;\n   }\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n     super(consumer);\n   }\n \n+  @Override\n   void add(Node n, Context context) {\n     if (n.getParent().getType() == Token.BLOCK\n         || n.getParent().getType() == Token.SCRIPT) {\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n           ObjectType ownerType = getObjectSlot(ownerName);\n           if (ownerType instanceof FunctionType) {\n             JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();\n-            JSType delegateType = typeRegistry.getType(\n-                codingConvention.getDelegateSuperclassName());\n+            String delegateName = codingConvention.getDelegateSuperclassName();\n+            JSType delegateType = delegateName == null ?\n+                null : typeRegistry.getType(delegateName);\n             if (delegateType != null &&\n                 ownerTypeOfThis.isSubtype(delegateType)) {\n               defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE),\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n \n   private final AbstractCompiler compiler;\n \n-  private final boolean nonStrictModuleChecks;\n+  // Whether this is the post-processing sanity check.\n+  private final boolean sanityCheck;\n \n   VarCheck(AbstractCompiler compiler) {\n-    this(compiler, true);\n-  }\n-  \n-  VarCheck(AbstractCompiler compiler, boolean nonStrictModuleChecks) {\n+    this(compiler, false);\n+  }\n+\n+  VarCheck(AbstractCompiler compiler, boolean sanityCheck) {\n     this.compiler = compiler;\n-    this.nonStrictModuleChecks = nonStrictModuleChecks;\n+    this.sanityCheck = sanityCheck;\n   }\n \n   /** {@inheritDoc} */\n       } else {\n         t.report(n, UNDEFINED_VAR_ERROR, varName);\n \n-        // Create a new variable in a synthetic script. This will prevent\n-        \n-        Node nameNode = Node.newString(Token.NAME, varName);\n-        getSynthesizedExternsRoot().addChildToBack(\n-            new Node(Token.VAR, nameNode));\n-        scope.declare(varName, nameNode,\n-            null, getSynthesizedExternsInput());\n+        if (sanityCheck) {\n+          throw new IllegalStateException(\"Unexpected variable \" + varName);\n+        } else {\n+          // Create a new variable in a synthetic script. This will prevent\n+          // subsequent compiler passes from crashing.\n+          Node nameNode = Node.newString(Token.NAME, varName);\n+          getSynthesizedExternsRoot().addChildToBack(\n+              new Node(Token.VAR, nameNode));\n+          scope.declare(varName, nameNode,\n+              null, getSynthesizedExternsInput());\n+        }\n       }\n       return;\n     }\n       if (moduleGraph.dependsOn(currModule, varModule)) {\n         // The module dependency was properly declared.\n       } else {\n-        if (nonStrictModuleChecks && scope.isGlobal()) {\n+        if (!sanityCheck && scope.isGlobal()) {\n           if (moduleGraph.dependsOn(varModule, currModule)) {\n             // The variable reference violates a declared module dependency.\n             t.report(n, VIOLATED_MODULE_DEP_ERROR,\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/WarningLevel.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.CheckLevel;\n+import com.google.javascript.jscomp.CompilerOptions;\n+\n+/**\n+ * Convert the warnings level to an Options object.\n+ *\n+*\n+ */\n+public enum WarningLevel {\n+  QUIET,\n+\n+  DEFAULT,\n+\n+  VERBOSE;\n+\n+  public void setOptionsForWarningLevel(CompilerOptions options) {\n+    switch (this) {\n+      case QUIET:\n+        // Nothing to do\n+        break;\n+      case DEFAULT:\n+        addDefaultWarnings(options);\n+        break;\n+      case VERBOSE:\n+        addVerboseWarnings(options);\n+        break;\n+      default:\n+        throw new RuntimeException(\"Unknown warning level.\");\n+    }\n+  }\n+\n+  /**\n+   * Add the default checking pass to the compilation options.\n+   * @param options The CompilerOptions object to set the options on.\n+   */\n+  private static void addDefaultWarnings(CompilerOptions options) {\n+    options.checkSymbols = true;\n+    options.checkSuspiciousCode = true;\n+    // TODO(user): This is deprecated. We should turn on the\n+    // new one once it is default in command line JSCompiler.\n+    options.checkUndefinedProperties = CheckLevel.OFF;\n+    options.checkUnusedPropertiesEarly = false;\n+  }\n+\n+  /**\n+   * Add all the check pass that are possibly relevant to a non googler.\n+   * @param options The CompilerOptions object to set the options on.\n+   */\n+  private static void addVerboseWarnings(CompilerOptions options) {\n+    addDefaultWarnings(options);\n+\n+    // checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run.\n+    options.checkSuspiciousCode = true;\n+    options.checkGlobalThisLevel = CheckLevel.WARNING;\n+\n+    // checkTypes and checkFunctions have the side-effect of asserting that the\n+    // correct number of arguments are passed to a function.\n+    // Because the CodingConvention used with the web service does not provide a\n+    // way for optional arguments to be specified, these warnings may result in\n+    // false positives.\n+    options.checkTypes = true;\n+    options.checkFunctions = CheckLevel.WARNING;\n+\n+    options.checkMethods = CheckLevel.WARNING;\n+    options.checkGlobalNamesLevel = CheckLevel.WARNING;\n+    options.aggressiveVarCheck = CheckLevel.WARNING;\n+  }\n+}\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n    * @return {@code true} if the description was recorded.\n    */\n   public boolean recordBlockDescription(String description) {\n+    if (parseDocumentation) {\n+      populated = true;\n+    }\n     return currentInfo.documentBlock(description);\n   }\n \n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Join;\n+import com.google.common.flags.Flags;\n+import com.google.javascript.rhino.Node;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for {@link CompilerRunner}.\n+ *\n+*\n+ */\n+public class CompilerRunnerTest extends TestCase {\n+\n+  /** Externs for the test */\n+  private final JSSourceFile[] externs = new JSSourceFile[] {\n+    JSSourceFile.fromCode(\"externs\",\n+        \"/** @constructor */ function Window() {}\\n\"\n+        + \"/** @type {string} */ Window.prototype.name;\\n\"\n+        + \"/** @type {Window} */ var window;\"\n+        + \"/** @nosideeffects */ function noSideEffects() {}\")\n+  };\n+\n+  @Override\n+  public void setUp() {\n+    Flags.disableStateCheckingForTest();\n+  }\n+\n+  @Override\n+  public void tearDown() {\n+    Flags.resetAllFlagsForTest();\n+    Flags.enableStateCheckingForTest();\n+  }\n+\n+  public void testTypeCheckingOffByDefault() {\n+    test(\"function f(x) { return x; } f();\",\n+         \"function f(a) { return a; } f();\");\n+  }\n+\n+  public void testTypeCheckingOnWithVerbose() {\n+    CompilerRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n+    test(\"function f(x) { return x; } f();\", TypeCheck.WRONG_ARGUMENT_COUNT);\n+  }\n+\n+  private void testSame(String original) {\n+    testSame(new String[] { original });\n+  }\n+\n+  private void testSame(String[] original) {\n+    test(original, original);\n+  }\n+\n+  private void test(String original, String compiled) {\n+    test(new String[] { original }, new String[] { compiled });\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * {@code original} is transformed into {@code compiled}.\n+   */\n+  private void test(String[] original, String[] compiled) {\n+    Compiler compiler = compile(original);\n+    assertEquals(\"Expected no warnings or errors\\n\" +\n+        \"Errors: \\n\" + Join.join(\"\\n\", compiler.getErrors()) +\n+        \"Warnings: \\n\" + Join.join(\"\\n\", compiler.getWarnings()),\n+        0, compiler.getErrors().length + compiler.getWarnings().length);\n+\n+    Node root = compiler.getRoot().getLastChild();\n+    Node expectedRoot = parse(compiled);\n+    String explanation = expectedRoot.checkTreeEquals(root);\n+    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+        \"\\nResult: \" + compiler.toSource(root) +\n+        \"\\n\" + explanation, explanation);\n+  }\n+\n+  /**\n+   * Asserts that when compiling, there is an error or warning.\n+   */\n+  private void test(String original, DiagnosticType warning) {\n+    test(new String[] { original }, warning);\n+  }\n+\n+  /**\n+   * Asserts that when compiling, there is an error or warning.\n+   */\n+  private void test(String[] original, DiagnosticType warning) {\n+    Compiler compiler = compile(original);\n+    assertEquals(\"Expected exactly one warning or error\",\n+        1, compiler.getErrors().length + compiler.getWarnings().length);\n+    if (compiler.getErrors().length > 0) {\n+      assertEquals(warning, compiler.getErrors()[0].getType());\n+    } else {\n+      assertEquals(warning, compiler.getWarnings()[0].getType());\n+    }\n+  }\n+\n+  private Compiler compile(String original) {\n+    return compile( new String[] { original });\n+  }\n+\n+  private Compiler compile(String[] original) {\n+    CompilerRunner runner = new CompilerRunner(new String[] {});\n+    Compiler compiler = runner.createCompiler();\n+    JSSourceFile[] inputs = new JSSourceFile[original.length];\n+    for (int i = 0; i < original.length; i++) {\n+      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n+    }\n+    compiler.compile(\n+        externs, CompilerTestCase.createModuleChain(original),\n+        runner.createOptions());\n+    return compiler;\n+  }\n+\n+  private Node parse(String[] original) {\n+    CompilerRunner runner = new CompilerRunner(new String[] {});\n+    Compiler compiler = runner.createCompiler();\n+    JSSourceFile[] inputs = new JSSourceFile[original.length];\n+    for (int i = 0; i < inputs.length; i++) {\n+      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n+    }\n+    compiler.init(externs, inputs, new CompilerOptions());\n+    Node all = compiler.parseInputs();\n+    Node n = all.getLastChild();\n+    Node externs = all.getFirstChild();\n+    (new Normalize(compiler, false)).process(externs, n);\n+    (new MakeDeclaredNamesUnique.UndoConstantRenaming(compiler)).process(\n+        externs, n);\n+    (MakeDeclaredNamesUnique.getContextualRenameInverter(compiler)).process(\n+        externs, n);\n+    return n;\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n import java.util.List;\n \n /**\n- * Tests for {@link StaticMethodOptimizer}\n+ * Tests for {@link DevirtualizePrototypeMethods}\n  *\n *\n  */\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n     fold(\"function(){if(a()){return undefined;}}\",\n          \"function(){if(a()){return}}\");\n   }\n+  \n+  public void testBugIssue3() {\n+    foldSame(\"function foo() {\" +\n+             \"  if(sections.length != 1) children[i] = 0;\" +\n+             \"  else var selectedid = children[i]\" +\n+             \"}\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n     testSame(\"var a = b.c; a();\");\n   }\n \n+  public void testInlineFunctionDeclaration() {\n+    test(\"var f = function () {}; var a = f;\", \n+         \"var a = function () {};\");\n+    test(\"var f = function () {}; foo(); var a = f;\", \n+         \"foo(); var a = function () {};\");\n+    test(\"var f = function () {}; foo(f);\", \n+         \"foo(function () {});\");\n+    \n+    testSame(\"var f = function () {}; function g() {var a = f;}\"); \n+    testSame(\"var f = function () {}; function g() {h(f);}\"); \n+  }\n+  \n   public void testRecursiveFunction1() {\n     testSame(\"var x = 0; (function x() { return x ? x() : 3; })();\");\n   }\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n \n   @Override public CompilerPass getProcessor(final Compiler compiler) {\n     if ((additionalCode == null) && (additionalEndCode == null)) {\n-      return new ProcessClosurePrimitives(compiler, false, true);\n+      return new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true);\n     } else {\n       return new CompilerPass() {\n         public void process(Node externs, Node root) {\n--- a/test/com/google/javascript/jscomp/RenameLocalVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameLocalVarsTest.java\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n-    return new RenameVars(compiler, prefix, true, null, null, null);\n+    return new RenameVars(compiler, prefix, true, false, null, null, null);\n   }\n \n   public void testRenameSimple() {\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n   private RenameVars renameVars;\n   private boolean withClosurePass = false;\n   private boolean localRenamingOnly = false;\n+  private boolean preserveAnonymousFunctionNames = false;\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n       return new ClosurePassAndRenameVars(compiler);\n     } else {\n       return renameVars = new RenameVars(compiler, prefix,\n-          localRenamingOnly, previouslyUsedMap, null, null);\n+          localRenamingOnly, preserveAnonymousFunctionNames,\n+          previouslyUsedMap, null, null);\n     }\n   }\n \n     prefix = DEFAULT_PREFIX;\n     withClosurePass = false;\n     localRenamingOnly = false;\n+    preserveAnonymousFunctionNames = false;\n   }\n \n   public void testRenameSimple() {\n         \"function f1(v3, v4) {f1()};\",\n         \"function f1(a, b) {f1()};\" +\n         \"function f1(a, b) {f1()};\");\n+  }\n+\n+  public void testRecursiveFunctions1() {\n+    test(\"var walk = function walk(node, aFunction) {\" +\n+         \"  walk(node, aFunction);\" +\n+         \"};\",\n+         \"var d = function a(b, c) {\" +\n+         \"  a(b, c);\" +\n+         \"};\");\n+\n+    localRenamingOnly = true;\n+\n+    test(\"var walk = function walk(node, aFunction) {\" +\n+         \"  walk(node, aFunction);\" +\n+         \"};\",\n+         \"var walk = function a(b, c) {\" +\n+         \"  a(b, c);\" +\n+         \"};\");\n+  }\n+\n+  public void testRecursiveFunctions2() {\n+    preserveAnonymousFunctionNames = true;\n+\n+    test(\"var walk = function walk(node, aFunction) {\" +\n+         \"  walk(node, aFunction);\" +\n+         \"};\",\n+         \"var c = function walk(a, b) {\" +\n+         \"  walk(a, b);\" +\n+         \"};\");\n+\n+    localRenamingOnly = true;\n+\n+    test(\"var walk = function walk(node, aFunction) {\" +\n+        \"  walk(node, aFunction);\" +\n+        \"};\",\n+        \"var walk = function walk(a, b) {\" +\n+        \"  walk(a, b);\" +\n+        \"};\");\n   }\n \n   public void testRenameLocalsClashingWithGlobals() {\n \n     public void process(Node externs, Node root) {\n       ProcessClosurePrimitives closurePass =\n-          new ProcessClosurePrimitives(compiler, true, true);\n+          new ProcessClosurePrimitives(compiler, CheckLevel.WARNING, true);\n       closurePass.process(externs, root);\n       renameVars = new RenameVars(compiler, prefix,\n-          false, previouslyUsedMap, null,\n+          false, false, previouslyUsedMap, null,\n           closurePass.getExportedVariableNames());\n       renameVars.process(externs, root);\n     }\n--- a/test/com/google/javascript/jscomp/SourceMapTest.java\n+++ b/test/com/google/javascript/jscomp/SourceMapTest.java\n   }\n \n   public void testGoldenOutput1() throws Exception {\n-    checkSourceMap(\"function(foo, bar) { foo = foo + bar + 2; return foo; }\",\n+    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n \n                    \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testMap\\\", \" +\n                    \"\\\"count\\\": 1 }\\n\" +\n \n-                   \"[0,0,0,0,0,0,0,0,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9,9,\" +\n+                   \"[0,0,0,0,0,0,0,0,2,2,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9,9,\" +\n                    \"10,10,10,10,11,11,12,12,12,12,12,12,13,13,13,13,13,6]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n                    \"[\\\"testcode\\\"]\\n\" +\n                    \"/** Begin mapping definitions. **/\\n\" +\n                    \"[\\\"testcode\\\",1,0]\\n\" +\n-                   \"[\\\"testcode\\\",1,8]\\n\" +\n-                   \"[\\\"testcode\\\",1,8,\\\"\\\"]\\n\" +\n-                   \"[\\\"testcode\\\",1,8]\\n\" +\n-                   \"[\\\"testcode\\\",1,9,\\\"foo\\\"]\\n\" +\n-                   \"[\\\"testcode\\\",1,14,\\\"bar\\\"]\\n\" +\n-                   \"[\\\"testcode\\\",1,19]\\n\" +\n+                   \"[\\\"testcode\\\",1,9]\\n\" +\n+                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,10]\\n\" +\n+                   \"[\\\"testcode\\\",1,11,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,16,\\\"bar\\\"]\\n\" +\n                    \"[\\\"testcode\\\",1,21]\\n\" +\n-                   \"[\\\"testcode\\\",1,21,\\\"foo\\\"]\\n\" +\n-                   \"[\\\"testcode\\\",1,27,\\\"foo\\\"]\\n\" +\n-                   \"[\\\"testcode\\\",1,33,\\\"bar\\\"]\\n\" +\n-                   \"[\\\"testcode\\\",1,39]\\n\" +\n-                   \"[\\\"testcode\\\",1,42]\\n\" +\n-                   \"[\\\"testcode\\\",1,49,\\\"foo\\\"]\\n\");\n+                   \"[\\\"testcode\\\",1,23]\\n\" +\n+                   \"[\\\"testcode\\\",1,23,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,29,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,35,\\\"bar\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,41]\\n\" +\n+                   \"[\\\"testcode\\\",1,44]\\n\" +\n+                   \"[\\\"testcode\\\",1,51,\\\"foo\\\"]\\n\");\n   }\n \n   public void testGoldenOutput2() throws Exception {\n-    checkSourceMap(\"function(foo, bar) {\\r\\n\\n\\n\\nfoo = foo + bar + foo;\" +\n+    checkSourceMap(\"function f(foo, bar) {\\r\\n\\n\\n\\nfoo = foo + bar + foo;\" +\n                    \"\\nreturn foo;\\n}\",\n \n                    \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testMap\\\", \" +\n                    \"\\\"count\\\": 1 }\\n\" +\n \n-                   \"[0,0,0,0,0,0,0,0,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9,\" +\n+                   \"[0,0,0,0,0,0,0,0,2,2,2,4,4,4,4,5,5,5,5,3,8,8,8,8,9,9,9,\" +\n                    \"9,10,10,10,10,11,11,11,11,12,12,12,12,12,12,13,13,13,\" +\n                    \"13,13,6]\\n\" +\n \n                    \"[\\\"testcode\\\"]\\n\" +\n                    \"/** Begin mapping definitions. **/\\n\" +\n                    \"[\\\"testcode\\\",1,0]\\n\" +\n-                   \"[\\\"testcode\\\",1,8]\\n\" +\n-                   \"[\\\"testcode\\\",1,8,\\\"\\\"]\\n\" +\n-                   \"[\\\"testcode\\\",1,8]\\n\" +\n-                   \"[\\\"testcode\\\",1,9,\\\"foo\\\"]\\n\" +\n-                   \"[\\\"testcode\\\",1,14,\\\"bar\\\"]\\n\" +\n-                   \"[\\\"testcode\\\",1,19]\\n\" +\n+                   \"[\\\"testcode\\\",1,9]\\n\" +\n+                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,10]\\n\" +\n+                   \"[\\\"testcode\\\",1,11,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,16,\\\"bar\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,21]\\n\" +\n                    \"[\\\"testcode\\\",5,0]\\n\" +\n                    \"[\\\"testcode\\\",5,0,\\\"foo\\\"]\\n\" +\n                    \"[\\\"testcode\\\",5,6,\\\"foo\\\"]\\n\" +\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n   private static final String EXTERNS = \"var window; function alert() {}\";\n \n   private CheckLevel strictModuleDepErrorLevel;\n-  private boolean nonStrictModuleChecks = true;\n+  private boolean sanityCheck = false;\n \n   public VarCheckTest() {\n     super(EXTERNS);\n   protected void setUp() throws Exception {\n     super.setUp();\n     strictModuleDepErrorLevel = CheckLevel.OFF;\n-    nonStrictModuleChecks = true;\n+    sanityCheck = false;\n   }\n \n   @Override\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n-    return new VarCheck(compiler, nonStrictModuleChecks);\n+    return new VarCheck(compiler, sanityCheck);\n   }\n \n   @Override\n   }\n \n   public void testMissingModuleDependencySkipNonStrict() {\n-    nonStrictModuleChecks = false;\n+    sanityCheck = true;\n     testIndependentModules(\"var x = 10;\", \"var y = x++;\",\n                            null, null);\n   }\n \n   public void testViolatedModuleDependencySkipNonStrict() {\n-    nonStrictModuleChecks = false;\n+    sanityCheck = true;\n     testDependentModules(\"var y = x++;\", \"var x = 10;\",\n                          null);\n   }\n \n   public void testMissingModuleDependencySkipNonStrictPromoted() {\n-    nonStrictModuleChecks = false;\n+    sanityCheck = true;\n     strictModuleDepErrorLevel = CheckLevel.ERROR;\n     testIndependentModules(\"var x = 10;\", \"var y = x++;\",\n         VarCheck.STRICT_MODULE_DEP_ERROR, null);\n   }\n \n   public void testViolatedModuleDependencyNonStrictPromoted() {\n-    nonStrictModuleChecks = false;\n+    sanityCheck = true;\n     strictModuleDepErrorLevel = CheckLevel.ERROR;\n     testDependentModules(\"var y = x++;\", \"var x = 10;\",\n         VarCheck.STRICT_MODULE_DEP_ERROR);\n   public void testSimple() {\n     checkSynthesizedExtern(\"x\", \"var x\");\n     checkSynthesizedExtern(\"var x\", \"\");\n+  }\n+\n+  public void testSimpleSanityCheck() {\n+    sanityCheck = true;\n+    try {\n+      checkSynthesizedExtern(\"x\", \"\");\n+    } catch (RuntimeException e) {\n+      assertTrue(e.getMessage().indexOf(\"Unexpected variable x\") != -1);\n+    }\n   }\n \n   public void testParameter() {\n     Node expected = compiler.parseTestCode(expectedExtern);\n     assertFalse(compiler.hasErrors());\n \n-    (new VarCheck(compiler)).process(externs, root);\n-    (new VariableTestCheck(compiler)).process(externs, root);\n+    (new VarCheck(compiler, sanityCheck)).process(externs, root);\n+    if (!sanityCheck) {\n+      (new VariableTestCheck(compiler)).process(externs, root);\n+    }\n \n     String externsCode = compiler.toSource(externs);\n     String expectedCode = compiler.toSource(expected);", "timestamp": 1257557060, "metainfo": ""}