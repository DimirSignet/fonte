{"sha": "9bf6d8db973a4691ad1551bdcbc559a86ba60532", "log": "More unused locals and parameter removal and unused parameter warning suppression.  R=dimvar   Revision created by MOE tool push_codebase. MOE_MIGRATION=6122   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n \n   /**\n    * Informs the optimization that a traversal has completed.\n+   * @param compiler The current compiler.\n    */\n   void endTraversal(AbstractCompiler compiler) {\n     this.compiler = null;\n--- a/src/com/google/javascript/jscomp/CheckProvides.java\n+++ b/src/com/google/javascript/jscomp/CheckProvides.java\n           visitFunctionNode(n, parent);\n           break;\n         case Token.SCRIPT:\n-          visitScriptNode(t, n);\n+          visitScriptNode();\n       }\n     }\n \n       }\n     }\n \n-    private void visitScriptNode(NodeTraversal t, Node n) {\n+    private void visitScriptNode() {\n       for (Map.Entry<String, Node> ctorEntry : ctors.entrySet()) {\n         String ctor = ctorEntry.getKey();\n         int index = -1;\n         } while (index != -1);\n \n         if (!found) {\n+          Node n = ctorEntry.getValue();\n           compiler.report(\n-              t.makeError(ctorEntry.getValue(), checkLevel,\n-                  MISSING_PROVIDE_WARNING, ctorEntry.getKey()));\n+              JSError.make(n.getSourceFileName(), n,\n+                  checkLevel, MISSING_PROVIDE_WARNING, ctorEntry.getKey()));\n         }\n       }\n       provides.clear();\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n     /**\n      * Returns the type for a type assertion, or null if the function asserts\n      * that the node must not be null or undefined.\n+     * @param call The asserting call\n      */\n     public JSType getAssertedType(Node call, JSTypeRegistry registry) {\n       return assertedType != null ? registry.getNativeType(assertedType) : null;\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n    * Inline a function into the call site.\n    */\n   Node inline(\n-      NodeTraversal t, Node callNode, String fnName, Node fnNode,\n-      InliningMode mode) {\n+      Node callNode, String fnName, Node fnNode, InliningMode mode) {\n     Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n \n     if (mode == InliningMode.DIRECT) {\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       super.visit(t, n, parent);\n       if (n.isName()) {\n-        checkNameUsage(t, n, parent);\n+        checkNameUsage(n, parent);\n       }\n     }\n \n     /**\n      * Find functions that can be inlined.\n      */\n-    private void checkNameUsage(NodeTraversal t, Node n, Node parent) {\n+    private void checkNameUsage(Node n, Node parent) {\n       Preconditions.checkState(n.isName());\n \n       if (isCandidateUsage(n)) {\n       String fnName = fn.getName();\n       Node fnNode = fs.getSafeFnNode();\n \n-      injector.inline(t, callNode, fnName, fnNode, mode);\n+      injector.inline(callNode, fnName, fnNode, mode);\n       t.getCompiler().reportCodeChange();\n       t.getCompiler().addToDebugLog(\"Inlined function: \" + fn.getName());\n     }\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n      * variable name.\n      */\n     private Map<String, String> computeVarList(\n-        Var v, ReferenceCollection referenceInfo) {\n+        ReferenceCollection referenceInfo) {\n       Map<String, String> varmap = Maps.newLinkedHashMap();\n \n       for (Reference ref : referenceInfo.references) {\n                              ReferenceCollection referenceInfo) {\n       // First figure out the FULL set of possible keys, so that they\n       // can all be properly set as necessary.\n-      Map<String, String> varmap = computeVarList(v, referenceInfo);\n+      Map<String, String> varmap = computeVarList(referenceInfo);\n \n       Map<String, Node> initvals = Maps.newHashMap();\n       // Figure out the top-level of the var assign node. If it's a plain\n--- a/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n+++ b/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n               !NodeUtil.mayHaveSideEffects(\n                   callNode.getFirstChild(), compiler)) {\n             logger.fine(\"Inlining empty method: \" + callName);\n-            inlineEmptyMethod(t, parent, callNode);\n+            inlineEmptyMethod(parent, callNode);\n           }\n         }\n       } else {\n   /**\n    * Remove the provided object and its method call.\n    */\n-  private void inlineEmptyMethod(NodeTraversal t, Node parent, Node call) {\n+  private void inlineEmptyMethod(Node parent, Node call) {\n     // If the return value of the method call is read,\n     // replace it with \"void 0\". Otherwise, remove the call entirely.\n     if (NodeUtil.isExprCall(parent)) {\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n         if (parent.isAssign() &&\n             NodeUtil.isPrototypeProperty(parent.getFirstChild())) {\n           pushContainingFunction(\n-              recordPrototypePropDefinition(t, parent.getFirstChild(), type,\n-                  parent));\n+              recordPrototypePropDefinition(parent.getFirstChild(), type, parent));\n         } else {\n           pushContainingFunction(\n               recordStaticNameDefinition(\n-                t, name, type, root, root.getLastChild()));\n+                name, type, root, root.getLastChild()));\n         }\n       }\n     }\n           }\n \n           if (isPrototypeNameReference(n)) {\n-            recordPrototypePropUse(t, n, parent);\n+            recordPrototypePropUse(n, parent);\n           } else if (isStaticNameReference(n, t.getScope())) {\n-            recordStaticNameUse(t, n, parent);\n+            recordStaticNameUse(n, parent);\n           } else {\n-            recordUnknownUse(t, n, parent);\n+            recordUnknownUse(n, parent);\n           }\n           break;\n \n               rhs.isGetProp()) {\n             if (NodeUtil.isPrototypeProperty(lhs)) {\n               Name name = recordPrototypePropDefinition(\n-                  t, lhs, getType(rhs), n);\n+                  lhs, getType(rhs), n);\n               name.setAliased(true);\n             }\n           }\n       return (type.isInstanceType() || type.autoboxesTo() != null);\n     }\n \n-    private Name recordStaticNameDefinition(NodeTraversal t, String name,\n-        JSType type, Node n, Node rValue) {\n+    private Name recordStaticNameDefinition(String name, JSType type,\n+        Node n, Node rValue) {\n       if (getNamedContainingFunction() != graph.MAIN) {\n         // TODO(user): if A.B() defines A.C(), there is a dependence from\n         // A.C() -> A.B(). However, this is not important in module code motion\n      *     declaration for recording the rValue's type.\n      */\n     private Name recordPrototypePropDefinition(\n-        NodeTraversal t, Node qName, JSType type,\n-        @Nullable Node assign) {\n+        Node qName, JSType type, @Nullable Node assign) {\n       JSType constructor = getType(NodeUtil.getPrototypeClassName(qName));\n       FunctionType classType = null;\n       String className = null;\n     }\n \n     private Reference recordStaticNameUse(\n-        NodeTraversal t, Node n, Node parent) {\n+        Node n, Node parent) {\n       if (isExtern) {\n         // Don't count reference in extern as a use.\n         return null;\n       }\n     }\n \n-    private void recordPrototypePropUse(\n-        NodeTraversal t, Node n, Node parent) {\n+    private void recordPrototypePropUse(Node n, Node parent) {\n       Preconditions.checkArgument(n.isGetProp());\n       Node instance = n.getFirstChild();\n       JSType instanceType = getType(instance);\n           // TODO(user): TightenType can help a whole lot here.\n           recordSubclassPrototypePropUse(constructor, propName, ref);\n         } else {\n-          recordUnknownUse(t, n, parent);\n+          recordUnknownUse(n, parent);\n         }\n       }\n     }\n       }\n     }\n \n-    private void recordUnknownUse(NodeTraversal t, Node n, Node parent) {\n+    private void recordUnknownUse(Node n, Node parent) {\n       if (isExtern) {\n         // Don't count reference in extern as a use.\n         return;\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n   }\n \n   static Node parseAndNormalizeTestCode(\n-      AbstractCompiler compiler, String code, String prefix) {\n+      AbstractCompiler compiler, String code) {\n     Node js = compiler.parseTestCode(code);\n     NodeTraversal.traverse(compiler, js,\n         new Normalize.NormalizeStatements(compiler, false));\n \n     @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-      doStatementNormalizations(t, n);\n+      doStatementNormalizations(n);\n \n       return true;\n     }\n     /**\n      * Do normalizations that introduce new siblings or parents.\n      */\n-    private void doStatementNormalizations(\n-        NodeTraversal t, Node n) {\n+    private void doStatementNormalizations(Node n) {\n       if (n.isLabel()) {\n         normalizeLabels(n);\n       }\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n         v = t.getScope().getVar(n.getString());\n       }\n       if (v != null && varFilter.apply(v)) {\n-        addReference(t, v, new Reference(n, t, blockStack.peek()));\n+        addReference(v, new Reference(n, t, blockStack.peek()));\n       }\n     }\n \n     return n.isCase();\n   }\n \n-  private void addReference(NodeTraversal t, Var v, Reference reference) {\n+  private void addReference(Var v, Reference reference) {\n     // Create collection if none already\n     ReferenceCollection referenceInfo = referenceMap.get(v);\n     if (referenceInfo == null) {\n     }\n \n     // Add this particular reference\n-    referenceInfo.add(reference, t, v);\n+    referenceInfo.add(reference);\n   }\n \n   interface ReferenceMap {\n       return references.iterator();\n     }\n \n-    void add(Reference reference, NodeTraversal t, Var v) {\n+    void add(Reference reference) {\n       references.add(reference);\n     }\n \n--- a/src/com/google/javascript/jscomp/ReplaceStrings.java\n+++ b/src/com/google/javascript/jscomp/ReplaceStrings.java\n \n     Preconditions.checkNotNull(key);\n     Preconditions.checkNotNull(replacementString);\n-    recordReplacement(expr, key, replacementString);\n+    recordReplacement(expr, key);\n \n     parent.replaceChild(expr, replacement);\n     compiler.reportCodeChange();\n   /**\n    * Record the location the replacement was made.\n    */\n-  private void recordReplacement(Node n, String key, String replacement) {\n+  private void recordReplacement(Node n, String key) {\n     Result result = results.get(key);\n     Preconditions.checkState(result != null);\n \n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.isFunction()) {\n-        visitFunction(t, n);\n-      }\n-    }\n-\n-    private void visitFunction(NodeTraversal t, Node n) {\n+        visitFunction(n);\n+      }\n+    }\n+\n+    private void visitFunction(Node n) {\n       FunctionType funType = n.getJSType().toMaybeFunctionType();\n       if (funType != null && !funType.isConstructor()) {\n         return;\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.isFunction()) {\n-        visitFunction(t, n);\n+        visitFunction(n);\n       } else if (n.isReturn()) {\n         visitReturn(t, n);\n       }\n     /**\n      * Insert checks for the parameters of the function.\n      */\n-    private void visitFunction(NodeTraversal t, Node n) {\n+    private void visitFunction(Node n) {\n       FunctionType funType = JSType.toMaybeFunctionType(n.getJSType());\n       Node block = n.getLastChild();\n       Node paramName = NodeUtil.getFunctionParameters(n).getFirstChild();\n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n   /**\n    * Returns true if the node is pure, that is it side effect free and does it\n    * not depend on its environment?\n+   * @param node node to check.\n    */\n   private boolean isPure(Node node) {\n     // For now, we conservatively assume all code is not pure.\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n           for (Node child = node.getFirstChild();\n                child != null; child = child.getNext()) {\n             identifyNameNode(\n-                child, child.getFirstChild(),\n-                NodeUtil.getBestJSDocInfo(child));\n+                child, NodeUtil.getBestJSDocInfo(child));\n           }\n           break;\n         case Token.EXPR_RESULT:\n           Node firstChild = node.getFirstChild();\n           if (firstChild.isAssign()) {\n             identifyNameNode(\n-                firstChild.getFirstChild(), firstChild.getLastChild(),\n-                firstChild.getJSDocInfo());\n+                firstChild.getFirstChild(), firstChild.getJSDocInfo());\n           } else {\n             identifyNameNode(\n-                firstChild, null, firstChild.getJSDocInfo());\n+                firstChild, firstChild.getJSDocInfo());\n           }\n           break;\n       }\n     }\n \n     private void identifyNameNode(\n-        Node nameNode, Node valueNode, JSDocInfo info) {\n+        Node nameNode, JSDocInfo info) {\n       if (nameNode.isQualifiedName()) {\n         if (info != null) {\n           if (info.hasEnumParameterType()) {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       inputId = t.getInputId();\n-      attachLiteralTypes(t, n);\n+      attachLiteralTypes(n);\n \n       switch (n.getType()) {\n         case Token.CALL:\n       }\n     }\n \n-    private void attachLiteralTypes(NodeTraversal t, Node n) {\n+    private void attachLiteralTypes(Node n) {\n       switch (n.getType()) {\n         case Token.NULL:\n           n.setJSType(getNativeType(NULL_TYPE));\n         Node value = keyNode.getFirstChild();\n         String memberName = NodeUtil.getObjectLitKeyName(keyNode);\n         JSDocInfo info = keyNode.getJSDocInfo();\n-        JSType valueType =\n-            getDeclaredType(keyNode.getSourceFileName(), info, keyNode, value);\n+        JSType valueType = getDeclaredType(info, keyNode, value);\n         JSType keyType =  objLitType.isEnumType() ?\n             objLitType.toMaybeEnumType().getElementsType() :\n             NodeUtil.getObjectLitKeyTypeFromValueType(keyNode, valueType);\n       Node catchName = n.getFirstChild();\n       defineSlot(catchName, n,\n           getDeclaredType(\n-              sourceName, catchName.getJSDocInfo(), catchName, null));\n+              catchName.getJSDocInfo(), catchName, null));\n     }\n \n     /**\n       Node value = name.getFirstChild();\n \n       // variable's type\n-      JSType type = getDeclaredType(sourceName, info, name, value);\n+      JSType type = getDeclaredType(info, name, value);\n       if (type == null) {\n         // The variable's type will be inferred.\n         type = name.isFromExterns() ? unknownType : null;\n     /**\n      * Look for a type declaration on a property assignment\n      * (in an ASSIGN or an object literal key).\n-     *\n      * @param info The doc info for this property.\n      * @param lValue The l-value node.\n      * @param rValue The node that {@code n} is being initialized to,\n      *     or {@code null} if this is a stub declaration.\n      */\n-    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n-        Node lValue, @Nullable Node rValue) {\n+    private JSType getDeclaredType(JSDocInfo info, Node lValue,\n+        @Nullable Node rValue) {\n       if (info != null && info.hasType()) {\n         return getDeclaredTypeInAnnotation(lValue, info);\n       } else if (rValue != null && rValue.isFunction() &&\n       // about getting as much type information as possible for them.\n \n       // Determining type for #1 + #2 + #3 + #4\n-      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n+      JSType valueType = getDeclaredType(info, n, rhsValue);\n       if (valueType == null && rhsValue != null) {\n         // Determining type for #5\n         valueType = rhsValue.getJSType();\n           Node child = n.getFirstChild();\n           switch (child.getType()) {\n             case Token.ASSIGN:\n-              maybeCollectMember(t, child.getFirstChild(), child,\n+              maybeCollectMember(child.getFirstChild(), child,\n                   child.getLastChild());\n               break;\n             case Token.GETPROP:\n-              maybeCollectMember(t, child, child, null);\n+              maybeCollectMember(child, child, null);\n               break;\n           }\n         }\n       }\n \n-      private void maybeCollectMember(NodeTraversal t,\n-          Node member, Node nodeWithJsDocInfo, @Nullable Node value) {\n+      private void maybeCollectMember(Node member,\n+          Node nodeWithJsDocInfo, @Nullable Node value) {\n         JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo();\n \n         // Do nothing if there is no JSDoc type info, or\n         }\n \n         member.getFirstChild().setJSType(thisType);\n-        JSType jsType = getDeclaredType(t.getSourceName(), info, member, value);\n+        JSType jsType = getDeclaredType(info, member, value);\n         Node name = member.getLastChild();\n         if (jsType != null &&\n             (name.isName() || name.isString()) &&\n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n       // Check all vars after finishing a scope\n       for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n         Var v = it.next();\n-        checkVar(t, v, referenceMap.getReferences(v).references);\n+        checkVar(v, referenceMap.getReferences(v).references);\n       }\n     }\n \n      * declared, which suggest a likely error. Relies on the fact that\n      * references is in parse-tree order.\n      */\n-    private void checkVar(NodeTraversal t, Var v, List<Reference> references) {\n+    private void checkVar(Var v, List<Reference> references) {\n       blocksWithDeclarations.clear();\n       boolean isDeclaredInScope = false;\n       boolean isUnhoistedNamedFunction = false;\n--- a/src/com/google/javascript/jscomp/XtbMessageBundle.java\n+++ b/src/com/google/javascript/jscomp/XtbMessageBundle.java\n   private final JsMessage.IdGenerator idGenerator;\n \n   public XtbMessageBundle(\n-      InputStream xtb, @Nullable String projectId, boolean unused) {\n+      InputStream xtb, @Nullable String projectId,\n+      @SuppressWarnings(\"unused\") boolean unused) {\n     this(xtb, projectId);\n   }\n \n--- a/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n \n   @Override\n   public List<GraphNode<N, E>> getNeighborNodes(N value) {\n-    UndiGraphNode<N, E> uNode = getUndirectedGraphNode(value);\n     List<GraphNode<N, E>> nodeList = Lists.newArrayList();\n     for (Iterator<GraphNode<N, E>> i = getNeighborNodesIterator(value);\n         i.hasNext();) {\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n       if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n         JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n         if (info != null) {\n-          validateTypeAnnotations(info, node, irNode);\n+          validateTypeAnnotations(info, node);\n         }\n         return info;\n       }\n     return null;\n   }\n \n-  private void validateTypeAnnotations(\n-      JSDocInfo info, AstNode node, Node irNode) {\n+  private void validateTypeAnnotations(JSDocInfo info, AstNode node) {\n     if (info.hasType()) {\n       boolean valid = false;\n       switch (node.getType()) {\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     }\n   }\n \n-  /** Can only be called when <tt>getType() == TokenStream.NUMBER</tt> */\n-  public void setDouble(double s) throws UnsupportedOperationException {\n+  /**\n+   * Can only be called when <tt>getType() == Token.NUMBER</tt>\n+   * @param value value to set.\n+   */\n+  public void setDouble(double value) throws UnsupportedOperationException {\n     if (this.getType() == Token.NUMBER) {\n       throw new IllegalStateException(\n           \"Number node not created with Node.newNumber\");\n     }\n   }\n \n-  /** Can only be called when node has String context. */\n-  public void setString(String s) throws UnsupportedOperationException {\n-    if (this.getType() == Token.STRING) {\n+  /**\n+   * Can only be called for a Token.STRING or Token.NAME.\n+   * @param value the value to set.\n+   */\n+  public void setString(String value) throws UnsupportedOperationException {\n+    if (this.getType() == Token.STRING || this.getType() == Token.NAME) {\n       throw new IllegalStateException(\n           \"String node not created with Node.newString\");\n     } else {\n--- a/src/com/google/javascript/rhino/SimpleErrorReporter.java\n+++ b/src/com/google/javascript/rhino/SimpleErrorReporter.java\n         if (warnings == null) {\n             warnings = new ArrayList<String>();\n         }\n-        warnings.add(formatDetailedMessage(\n-            message, sourceName, line, lineOffset));\n+        warnings.add(formatDetailedMessage(message, sourceName, line));\n     }\n \n     @Override\n         if (errors == null) {\n             errors = new ArrayList<String>();\n         }\n-        errors.add(formatDetailedMessage(\n-            message, sourceName, line, lineOffset));\n+        errors.add(formatDetailedMessage(message, sourceName, line));\n     }\n \n     /**\n     }\n \n     private String formatDetailedMessage(\n-        String message, String sourceName, int lineNumber, int lineOffset) {\n+        String message, String sourceName, int lineNumber) {\n       String details = message;\n       if (sourceName == null || lineNumber <= 0) {\n         return details;\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n     return displayName != null && !displayName.isEmpty();\n   }\n \n-  /** Checks whether the property pname is present on the object. */\n+  /**\n+   * Checks whether the property is present on the object.\n+   * @param pname The property name.\n+   */\n   public boolean hasProperty(String pname) {\n     return false;\n   }\n    * This is useful for reverse type-inference, where we want to\n    * infer that an object literal matches its constraint (much like\n    * how the java compiler does reverse-inference to figure out generics).\n+   * @param constraint\n    */\n   public void matchConstraint(JSType constraint) {}\n }\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n     // different mechanisms for resolving named types, and if so, which order\n     // makes more sense. Now, resolution via registry is first in order to\n     // avoid triggering the warnings built into the resolution via properties.\n-    boolean resolved = resolveViaRegistry(t, enclosing);\n+    boolean resolved = resolveViaRegistry(t);\n     if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }\n    * Resolves a named type by looking it up in the registry.\n    * @return True if we resolved successfully.\n    */\n-  private boolean resolveViaRegistry(\n-      ErrorReporter t, StaticScope<JSType> enclosing) {\n+  private boolean resolveViaRegistry(ErrorReporter reporter) {\n     JSType type = registry.getType(reference);\n     if (type != null) {\n-      setReferencedAndResolvedType(type, t, enclosing);\n+      setReferencedAndResolvedType(type, reporter);\n       return true;\n     }\n     return false;\n    * subsequent components as properties. The scope must have been fully\n    * parsed and a symbol table constructed.\n    */\n-  private void resolveViaProperties(ErrorReporter t,\n+  private void resolveViaProperties(ErrorReporter reporter,\n                                     StaticScope<JSType> enclosing) {\n-    JSType value = lookupViaProperties(t, enclosing);\n+    JSType value = lookupViaProperties(reporter, enclosing);\n     // last component of the chain\n     if (value != null && value.isFunctionType() &&\n         (value.isConstructor() || value.isInterface())) {\n       FunctionType functionType = value.toMaybeFunctionType();\n-      setReferencedAndResolvedType(\n-          functionType.getInstanceType(), t, enclosing);\n+      setReferencedAndResolvedType(functionType.getInstanceType(), reporter);\n     } else if (value != null && value.isNoObjectType()) {\n       setReferencedAndResolvedType(\n           registry.getNativeFunctionType(\n-              JSTypeNative.NO_OBJECT_TYPE).getInstanceType(), t, enclosing);\n+              JSTypeNative.NO_OBJECT_TYPE).getInstanceType(), reporter);\n     } else if (value instanceof EnumType) {\n       setReferencedAndResolvedType(\n-          ((EnumType) value).getElementsType(), t, enclosing);\n+          ((EnumType) value).getElementsType(), reporter);\n     } else {\n       // We've been running into issues where people forward-declare\n       // non-named types. (This is legitimate...our dependency management\n       //\n       // So if the type does resolve to an actual value, but it's not named,\n       // then don't respect the forward declaration.\n-      handleUnresolvedType(t, value == null || value.isUnknownType());\n+      handleUnresolvedType(reporter, value == null || value.isUnknownType());\n     }\n   }\n \n    * parsed and a symbol table constructed.\n    * @return The type of the symbol, or null if the type could not be found.\n    */\n-  private JSType lookupViaProperties( ErrorReporter t,\n+  private JSType lookupViaProperties(ErrorReporter reporter,\n       StaticScope<JSType> enclosing) {\n     String[] componentNames = reference.split(\"\\\\.\", -1);\n     if (componentNames[0].length() == 0) {\n     if (slotType == null || slotType.isAllType() || slotType.isNoType()) {\n       return null;\n     }\n-    JSType value = getTypedefType(t, slot, componentNames[0]);\n+    JSType value = getTypedefType(reporter, slot);\n     if (value == null) {\n       return null;\n     }\n     return value;\n   }\n \n-  private void setReferencedAndResolvedType(JSType type, ErrorReporter t,\n-      StaticScope<JSType> enclosing) {\n+  private void setReferencedAndResolvedType(\n+      JSType type, ErrorReporter reporter) {\n     if (validator != null) {\n       validator.apply(type);\n     }\n     setReferencedType(type);\n-    checkEnumElementCycle(t);\n-    checkProtoCycle(t);\n+    checkEnumElementCycle(reporter);\n+    checkProtoCycle(reporter);\n     setResolvedTypeInternal(getReferencedType());\n   }\n \n     }\n   }\n \n-  JSType getTypedefType(ErrorReporter t, StaticSlot<JSType> slot, String name) {\n+  private JSType getTypedefType(ErrorReporter t, StaticSlot<JSType> slot) {\n     JSType type = slot.getType();\n     if (type != null) {\n       return type;\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n                 ParameterizedType parameterizedCurrent = current.toMaybeParameterizedType();\n \n                 if (parameterizedCurrent.wrapsSameRawType(parameterizedAlternate)) {\n-                  JSType alternateTypeParameter = parameterizedAlternate.getParameterType();\n                   JSType currentTypeParameter = parameterizedCurrent.getParameterType();\n                   if (currentTypeParameter.isEquivalentTo(parameterizedCurrent)) {\n                     // case 8\n--- a/test/com/google/javascript/jscomp/CallGraphTest.java\n+++ b/test/com/google/javascript/jscomp/CallGraphTest.java\n     CallGraph callgraph = compileAndRunBackward(source);\n \n     Function mainFunction = callgraph.getMainFunction();\n-    Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n \n     Callsite callInMain = mainFunction.getCallsitesInFunction().iterator()\n         .next();\n-\n-    UnsupportedOperationException caughtException = null;\n \n     try {\n       callInMain.getPossibleTargets();\n--- a/test/com/google/javascript/jscomp/CheckPathsBetweenNodesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckPathsBetweenNodesTest.java\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.jscomp.graph.DiGraph;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n-import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n-\n import junit.framework.TestCase;\n \n /**\n     g.connect(\"b\", \"-\", \"c\");\n     g.connect(\"c\", \"-\", \"d\");\n     g.connect(\"a\", \"x\", \"d\");\n-\n-    CheckPathsBetweenNodes<String, String> test = null;\n \n     // Simple case: the sole path from a to d has a matching node.\n     assertGood(createTest(g, \"a\", \"d\", Predicates.equalTo(\"b\"), edgeIs(\"-\")));\n     g.createDirectedGraphNode(\"c1\");\n     g.createDirectedGraphNode(\"c2\");\n     g.createDirectedGraphNode(\"c3\");\n-    DiGraphNode<String, String> d = g.createDirectedGraphNode(\"d\");\n+    g.createDirectedGraphNode(\"d\");\n \n     g.connect(\"a\",  \"-\", \"b\");\n     g.connect(\"b\",  \"-\", \"c1\");\n--- a/test/com/google/javascript/jscomp/CompilerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerTest.java\n  * @author johnlenz@google.com (John Lenz)\n  */\n public class CompilerTest extends TestCase {\n-\n-  public void testCodeBuilderColumnAfterResetDummy() {\n-    Compiler compiler = new Compiler();\n-    Node n = compiler.parseTestCode(\"\");\n-    Compiler.CodeBuilder cb = new Compiler.CodeBuilder();\n-  }\n \n   // Verify the line and column information is maintained after a reset\n   public void testCodeBuilderColumnAfterReset() {\n--- a/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n \n     Node script1 = compiler.parseSyntheticCode(\"cfgtest\", \"var foo;\");\n     Node script2 = compiler.parseSyntheticCode(\"cfgtest2\", \"var bar;\");\n-    Node root = new Node(Token.BLOCK, script1, script2);\n+    // Create a parent node for the scripts\n+    new Node(Token.BLOCK, script1, script2);\n \n     cfa.process(null, script1);\n     ControlFlowGraph<Node> cfg = cfa.getCfg();\n--- a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n         assertTrue(outEdges.size() < 2);\n         ConstPropLatticeElement aResult = flowThroughArithmeticInstruction(\n             (ArithmeticInstruction) node, input);\n-        for (DiGraphEdge<Instruction, Branch> _ : outEdges) {\n+        for (int i = 0; i < outEdges.size(); i++) {\n           result.add(aResult);\n         }\n       } else {\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n         + \"/** @constructor */ function Baz() {}\\n\"\n         + \"Baz.prototype.a = 0;\\n\"\n         + \"Baz.prototype.b = 0;\\n\";\n-    String output = \"\"\n-        + \"function Foo(){}\"\n-        + \"Foo.prototype.Bar_prototype$a=0;\"\n-        + \"Foo.prototype.Bar_prototype$b=0;\"\n-        + \"function Bar(){}\"\n-        + \"Bar.prototype.Bar_prototype$a=0;\"\n-        + \"Bar.prototype.Bar_prototype$b=0;\"\n-        + \"var B=new Bar;\"\n-        + \"B.Bar_prototype$a=0;\"\n-        + \"B.Bar_prototype$b=0;\"\n-        + \"function Baz(){}\"\n-        + \"Baz.prototype.a$Baz_prototype=0;\"\n-        + \"Baz.prototype.b$Baz_prototype=0;\";\n     testSets(false, js, \"{a=[[Bar.prototype, Foo.prototype], [Baz.prototype]],\"\n                  + \" b=[[Bar.prototype, Foo.prototype], [Baz.prototype]]}\");\n     testSets(true, js, \"{a=[[Bar.prototype, Foo.prototype], [Baz.prototype]],\"\n--- a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import junit.framework.TestCase;\n \n import java.util.Set;\n         \"function goo() {}\" +\n         \"function foo() {}\");\n     assertNotNull(externsRoot);\n-    Node mainRoot = tree;\n \n     Node callSite = findCall(tree, null, 2);\n     assertNotNull(\"Call \" + call + \" was not found.\", callSite);\n         \"function goo() {}\" +\n         \"function foo() {}\");\n     assertNotNull(externsRoot);\n-    Node mainRoot = tree;\n \n     Node callSite = findCall(tree, fnName);\n     assertNotNull(\"Call to \" + fnName + \" was not found.\", callSite);\n     Node tree = parse(compiler, code);\n     assertNotNull(tree);\n \n-    Node externsRoot = new Node(Token.EMPTY);\n-    Node mainRoot = tree;\n-\n     Node callSite = findCall(tree, fnName);\n     assertNotNull(\"Call to \" + fnName + \" was not found.\", callSite);\n \n     Node expectedRoot = parse(compiler, expectedResult);\n     Node tree = parse(compiler, code);\n     assertNotNull(tree);\n-\n-    Node externsRoot = new Node(Token.EMPTY);\n-    Node mainRoot = tree;\n \n     Node callSite = findCall(tree, fnName);\n     assertNotNull(\"Call to \" + fnName + \" was not found.\", callSite);\n   }\n \n   private static Node parse(Compiler compiler, String js) {\n-    Node n = Normalize.parseAndNormalizeTestCode(compiler, js, \"\");\n+    Node n = Normalize.parseAndNormalizeTestCode(compiler, js);\n     assertEquals(0, compiler.getErrorCount());\n     return n;\n   }\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n import com.google.javascript.jscomp.FunctionInjector.InliningMode;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import junit.framework.TestCase;\n \n import java.util.List;\n         assumeMinimumCapture);\n     final Node tree = parse(compiler, code);\n \n-    Node externsRoot = new Node(Token.EMPTY);\n-    Node mainRoot = tree;\n-\n     final Node fnNode = findFunction(tree, fnName);\n     final Set<String> unsafe =\n         FunctionArgumentInjector.findModifiedParameters(fnNode);\n               CanInlineResult.AFTER_PREPARATION == canInline);\n \n           Set<String> knownConstants = Sets.newHashSet();\n-          ExpressionDecomposer decomposer = new ExpressionDecomposer(\n-              compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n           injector.setKnownConstants(knownConstants);\n           injector.maybePrepareCall(n);\n \n               CanInlineResult.YES != canInline);\n         }\n \n-        Node result = injector.inline(\n-            t, n, fnName, fnNode, mode);\n+        Node result = injector.inline(n, fnName, fnNode, mode);\n         validateSourceInfo(compiler, result);\n         String explanation = expectedRoot.checkTreeEquals(tree.getFirstChild());\n         assertNull(\"\\nExpected: \" + toSource(expectedRoot) +\n--- a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n \n import junit.framework.TestCase;\n \n-import java.util.Set;\n-\n /**\n  * @author johnlenz@google.com (John Lenz)\n  */\n     mark.process(externsRoot, mainRoot);\n \n     final Node fnNode = findFunction(tree, fnName);\n-    final Set<String> unsafe =\n-        FunctionArgumentInjector.findModifiedParameters(fnNode);\n \n     // Fake precondition.\n     compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n   }\n \n   public void testComplexSampleNoInline() {\n-    // This is the result we would expect if we could handle \"foo = function\"\n-    String result =\n-    \"foo=function(stylesString,opt_element){\" +\n-        \"var styleSheet=null;\" +\n-        \"if(goog$userAgent$IE){\" +\n-          \"styleSheet=0\" +\n-        \"}else{\" +\n-          \"var head=0\" +\n-         \"}\" +\n-         \"{var JSCompiler_inline_element_0=styleSheet;\" +\n-         \"var JSCompiler_inline_stylesString_1=stylesString;\" +\n-         \"if(goog$userAgent$IE){\" +\n-           \"JSCompiler_inline_element_0.cssText=\" +\n-           \"JSCompiler_inline_stylesString_1\" +\n-         \"}else{\" +\n-           \"var propToSet=goog$userAgent$WEBKIT?\\\"innerText\\\":\\\"innerHTML\\\";\" +\n-           \"JSCompiler_inline_element_0[propToSet]=\" +\n-           \"JSCompiler_inline_stylesString_1\" +\n-         \"}}\" +\n-        \"return styleSheet\" +\n-     \"}\";\n-\n     testSame(\n       \"foo=function(stylesString,opt_element){\" +\n         \"var styleSheet=null;\" +\n             }\n          );\n   }\n-  \n+\n   public void test6671158() {\n     test(\n         \"function f() {return g()}\" +\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n         \"  set appData(data) { this.appData_ = data; }\\n\" +\n         \"};\";\n \n-    Compiler compiler = compile(options, code);\n     testSame(options, code);\n   }\n \n--- a/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n+++ b/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n   }\n \n   private void assertInputs(JSModule module, String ... sourceNames) {\n-    List<CompilerInput> actualInputs = module.getInputs();\n-\n     assertEquals(\n         Lists.newArrayList(sourceNames),\n         sourceNames(module.getInputs()));\n--- a/test/com/google/javascript/jscomp/JSModuleTest.java\n+++ b/test/com/google/javascript/jscomp/JSModuleTest.java\n     assertSortedInputs(\n         ImmutableList.of(d, b, c, a),\n         ImmutableList.of(d, a, b, c));\n+\n+    assertSortedInputs(\n+        ImmutableList.of(d, b, c, a, e, f),\n+        ImmutableList.of(a, b, c, d, e, f));\n+    assertSortedInputs(\n+        ImmutableList.of(e, f, d, b, c, a),\n+        ImmutableList.of(e, f, a, b, c, d));\n+    assertSortedInputs(\n+        ImmutableList.of(e, d, b, c, a, f),\n+        ImmutableList.of(a, b, c, e, d, f));\n+    assertSortedInputs(\n+        ImmutableList.of(e, f, d, b, c, a),\n+        ImmutableList.of(e, a, f, b, c, d));\n   }\n \n   private void assertSortedInputs(\n--- a/test/com/google/javascript/jscomp/JsMessageVisitorTest.java\n+++ b/test/com/google/javascript/jscomp/JsMessageVisitorTest.java\n \n   private void extractMessagesSafely(String input) {\n     extractMessages(input);\n-    JSError[] errors = compiler.getErrors();\n     assertEquals(\n         \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),\n         0, compiler.getErrorCount());\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n     TypeCheckResult ns =\n         parseAndTypeCheckWithScope(\"/** @type {!Object} */var t; t.x; t;\");\n     Node n = ns.root;\n-    Scope s = ns.scope;\n     JSType type = n.getLastChild().getLastChild().getJSType();\n     assertFalse(type.isUnknownType());\n     assertTypeEquals(type, OBJECT_TYPE);\n \n   void testTypes(String externs, String js, String description, boolean isError)\n       throws Exception {\n-    Node n = parseAndTypeCheck(externs, js);\n+    parseAndTypeCheck(externs, js);\n \n     JSError[] errors = compiler.getErrors();\n     if (description != null && isError) {\n     Node n = compiler.parseTestCode(js);\n     assertEquals(0, compiler.getErrorCount());\n     Node externsNode = new Node(Token.BLOCK);\n-    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n+    // create a common parent for the externs and source roots\n+    new Node(Token.BLOCK, externsNode, n);\n \n     makeTypeCheck().processForTesting(null, n);\n     assertEquals(0, compiler.getErrorCount());\n--- a/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n+++ b/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n   private void computeDefUse(String src) {\n     Compiler compiler = new Compiler();\n     src = \"function _FUNCTION(param1, param2){\" + src + \"}\";\n-    Node externs = compiler.parseTestCode(EXTERNS);\n     Node root = compiler.parseTestCode(src).getFirstChild();\n     assertEquals(0, compiler.getErrorCount());\n     Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null);\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n   }\n \n   public void testGetVarsDeclaredInBranch() {\n-    Compiler compiler = new Compiler();\n-\n     assertNodeNames(Sets.newHashSet(\"foo\"),\n         NodeUtil.getVarsDeclaredInBranch(\n             parse(\"var foo;\")));\n     Node actual = parse(\"try {foo()} catch(e) {} finally {}\");\n \n     Node tryNode = actual.getFirstChild();\n-    Node tryBlock = tryNode.getFirstChild();\n-    Node catchBlocks = tryNode.getFirstChild().getNext();\n     Node finallyBlock = tryNode.getLastChild();\n \n     NodeUtil.removeChild(tryNode, finallyBlock);\n \n     Node tryNode = actual.getFirstChild();\n     Node tryBlock = tryNode.getFirstChild();\n-    Node catchBlocks = tryNode.getFirstChild().getNext();\n \n     NodeUtil.removeChild(tryNode, tryBlock);\n     String expected = \"try {} catch(e) {} finally {}\";\n     Node actual = parse(\"try {foo()} catch(e) {} finally {}\");\n \n     Node tryNode = actual.getFirstChild();\n-    Node tryBlock = tryNode.getFirstChild();\n     Node catchBlocks = tryNode.getFirstChild().getNext();\n     Node catchBlock = catchBlocks.getFirstChild();\n-    Node finallyBlock = tryNode.getLastChild();\n \n     NodeUtil.removeChild(catchBlocks, catchBlock);\n     String expected = \"try {foo()} finally {}\";\n     Node actual = parse(\"try {foo()} catch(e) {} finally {}\");\n \n     Node tryNode = actual.getFirstChild();\n-    Node tryBlock = tryNode.getFirstChild();\n     Node catchBlocks = tryNode.getFirstChild().getNext();\n-    Node catchBlock = catchBlocks.getFirstChild();\n-    Node finallyBlock = tryNode.getLastChild();\n \n     NodeUtil.removeChild(tryNode, catchBlocks);\n     String expected = \"try {foo()} finally {}\";\n     Node actual = parse(\"try {foo()} catch(e) {} finally {}\");\n \n     Node tryNode = actual.getFirstChild();\n-    Node tryBlock = tryNode.getFirstChild();\n     Node catchBlocks = tryNode.getFirstChild().getNext();\n     Node catchBlock = catchBlocks.getFirstChild();\n-    Node finallyBlock = tryNode.getLastChild();\n \n     NodeUtil.removeChild(catchBlocks, catchBlock);\n     String expected = \"try {foo()} finally {}\";\n   }\n \n   public void testRemoveVarChild() {\n-    Compiler compiler = new Compiler();\n-\n     // Test removing the first child.\n     Node actual = parse(\"var foo, goo, hoo\");\n \n   }\n \n   public void testRemoveLabelChild1() {\n-    Compiler compiler = new Compiler();\n-\n     // Test removing the first child.\n     Node actual = parse(\"foo: goo()\");\n \n   }\n \n   public void testRemoveForChild() {\n-    Compiler compiler = new Compiler();\n-\n     // Test removing the initializer.\n     Node actual = parse(\"for(var a=0;a<0;a++)foo()\");\n \n   }\n \n   public void testMergeBlock1() {\n-    Compiler compiler = new Compiler();\n-\n     // Test removing the initializer.\n     Node actual = parse(\"{{a();b();}}\");\n \n   }\n \n   public void testMergeBlock2() {\n-    Compiler compiler = new Compiler();\n-\n     // Test removing the initializer.\n     Node actual = parse(\"foo:{a();}\");\n \n   }\n \n   public void testMergeBlock3() {\n-    Compiler compiler = new Compiler();\n-\n     // Test removing the initializer.\n     String code = \"foo:{a();boo()}\";\n     Node actual = parse(\"foo:{a();boo()}\");\n--- a/test/com/google/javascript/jscomp/OptimizeParametersTest.java\n+++ b/test/com/google/javascript/jscomp/OptimizeParametersTest.java\n   }\n \n   public void testRemoveOneOptionalMultiplePossibleDefinition() {\n+    // TODO(johnlenz): Support multiple valid definitions.\n     String src = \"var goog = {};\" +\n         \"goog.foo = function (p1, p2) { };\" +\n         \"goog.foo = function (q1, q2) { };\" +\n         \"goog.foo = function (r1, r2) { };\" +\n         \"goog.foo(1); goog.foo(2); goog.foo()\";\n-\n-    String expected = \"var goog = {};\" +\n-        \"goog.foo = function (p1) { var p2 };\" +\n-        \"goog.foo = function (q1) { var q2 };\" +\n-        \"goog.foo = function (r1) { var r2 };\" +\n-        \"goog.foo(1); goog.foo(2); goog.foo()\";\n+    testSame(src);\n+  }\n+\n+  public void testRemoveTwoOptionalMultiplePossibleDefinition() {\n     // TODO(johnlenz): Support multiple valid definitions.\n-    testSame(src);\n-  }\n-\n-  public void testRemoveTwoOptionalMultiplePossibleDefinition() {\n     String src = \"var goog = {};\" +\n         \"goog.foo = function (p1, p2, p3, p4) { };\" +\n         \"goog.foo = function (q1, q2, q3, q4) { };\" +\n         \"goog.foo = function (r1, r2, r3, r4) { };\" +\n         \"goog.foo(1,0); goog.foo(2,1); goog.foo()\";\n-\n-    String expected = \"var goog = {};\" +\n-        \"goog.foo = function(p1, p2) { var p4; var p3};\" +\n-        \"goog.foo = function(q1, q2) { var q4; var q3};\" +\n-        \"goog.foo = function(r1, r2) { var r4; var r3};\" +\n-        \"goog.foo(1,0); goog.foo(2,1); goog.foo()\";\n-    // TODO(johnlenz): Support multiple valid definitions.\n     testSame(src);\n   }\n \n   }\n \n   public void testMultipleUnknown() {\n+    // TODO(johnlenz): Support multiple definitions.\n     String src = \"var goog1 = {};\" +\n         \"goog1.foo = function () { };\" +\n         \"var goog2 = {};\" +\n         \"goog2.foo = function (p1) { };\" +\n         \"var x = getGoog();\" +\n         \"x.foo()\";\n-\n-    String expected = \"var goog1 = {};\" +\n-        \"goog1.foo = function () { };\" +\n-        \"var goog2 = {};\" +\n-        \"goog2.foo = function () { var p1 };\" +\n-        \"var x = getGoog();\" +\n-        \"x.foo()\";\n-    // TODO(johnlenz): Support multiple definitions.\n     testSame(src);\n   }\n \n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n \n   private void assertSameResultsOrUncollapsed(String exprA, String exprB) {\n     String resultA = process(exprA);\n-    String resultB = process(exprB);  // TODO: why is nothing done with this?\n     if (resultA.equals(print(exprA))) {\n       foldSame(exprA);\n       foldSame(exprB);\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n     super.tearDown();\n     noSideEffectCalls.clear();\n     localResultCalls.clear();\n-    boolean regExpHaveSideEffects = true;\n+    regExpHaveSideEffects = true;\n   }\n \n   public void testIssue303() throws Exception {\n           new PureFunctionIdentifier(compiler, defFinder);\n       passUnderTest.process(externs, root);\n \n-      // Ensure that debug report computation works.\n-      String debugReport = passUnderTest.getDebugReport();\n+      // Ensure that debug report computation doesn't crash.\n+      passUnderTest.getDebugReport();\n \n       NodeTraversal.traverse(compiler, externs, this);\n       NodeTraversal.traverse(compiler, root, this);\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     Symbol bar = getGlobalVar(table, \"Bar\");\n     Symbol fooPrototype = getGlobalVar(table, \"Foo.prototype\");\n     Symbol fn = getGlobalVar(table, \"Function\");\n-    Symbol obj = getGlobalVar(table, \"Object\");\n     assertEquals(\n         Lists.newArrayList(foo, bar), table.getAllSymbolsForTypeOf(x));\n     assertEquals(\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n     TypeCheckResult ns =\n         parseAndTypeCheckWithScope(\"/** @type {!Object} */var t; t.x; t;\");\n     Node n = ns.root;\n-    Scope s = ns.scope;\n     JSType type = n.getLastChild().getLastChild().getJSType();\n     assertFalse(type.isUnknownType());\n     assertTypeEquals(type, OBJECT_TYPE);\n \n   void testTypes(String externs, String js, String description, boolean isError)\n       throws Exception {\n-    Node n = parseAndTypeCheck(externs, js);\n+    parseAndTypeCheck(externs, js);\n \n     JSError[] errors = compiler.getErrors();\n     if (description != null && isError) {\n     Node n = compiler.parseTestCode(js);\n     assertEquals(0, compiler.getErrorCount());\n     Node externsNode = new Node(Token.BLOCK);\n-    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n+    // create a parent node for the extern and source blocks\n+    new Node(Token.BLOCK, externsNode, n);\n \n     makeTypeCheck().processForTesting(null, n);\n     assertEquals(0, compiler.getErrorCount());\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n     Node externsAndJs = compiler.getRoot();\n     Node root = externsAndJs.getLastChild();\n \n-    Node rootOriginal = root.cloneTree();\n     Node externs = externsAndJs.getFirstChild();\n \n     Node expected = compiler.parseTestCode(expectedExtern);\n--- a/test/com/google/javascript/jscomp/deps/SortedDependenciesTest.java\n+++ b/test/com/google/javascript/jscomp/deps/SortedDependenciesTest.java\n         \"d\", \"d\", provides(\"d\"), requires());\n     SimpleDependencyInfo e = new SimpleDependencyInfo(\n         \"e\", \"e\", provides(\"e\"), requires());\n-    SimpleDependencyInfo f = new SimpleDependencyInfo(\n-        \"f\", \"f\", provides(\"f\"), requires());\n \n     assertSortedInputs(\n         ImmutableList.of(d, b, c, a),\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n     // line number gets reported correctly (on the next line) but the\n     // character position is -1, so the overall line/char pair in our tree\n     // is -1.\n-    //assertNodePosition(4, 0, incrClause);\n+    assertNodePosition(-1, -1, incrClause); // should be 4\n   }\n \n   public void testBinaryExprLocation() {\n   }\n \n   private void testParseError(String string, String[] errors) {\n-    Node root = newParse(string, new TestErrorReporter(errors, null));\n+    newParse(string, new TestErrorReporter(errors, null));\n     assertTrue(\"unexpected warnings reported\",\n         errorReporter.hasEncounteredAllWarnings());\n     assertTrue(\"expected error were not reported\",\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n   }\n \n   public void testFileOverviewDuplicate() throws Exception {\n-    JSDocInfo jsdoc = parseFileOverview(\n+    parseFileOverview(\n         \"@fileoverview Pie \\n * @fileoverview Cake */\",\n         \"extra @fileoverview tag\");\n   }\n     Config config =\n         new Config(extraAnnotations, extraSuppressions,\n             true, LanguageMode.ECMASCRIPT3, false);\n-    StaticSourceFile file = new SimpleSourceFile(script.getSourceName(), false);\n     for (Comment comment : script.getComments()) {\n       JsDocInfoParser jsdocParser =\n         new JsDocInfoParser(\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n   }\n \n   public void testReservedKeywords() {\n-    boolean isIdeMode = false;\n-\n     mode = LanguageMode.ECMASCRIPT3;\n \n     parseError(\"var boolean;\", \"missing variable name\");\n   }\n \n   public void testKeywordsAsProperties() {\n-    boolean isIdeMode = false;\n-\n     mode = LanguageMode.ECMASCRIPT3;\n \n     parseError(\"var x = {function: 1};\", \"invalid property id\");\n--- a/test/com/google/javascript/rhino/NodeTest.java\n+++ b/test/com/google/javascript/rhino/NodeTest.java\n   }\n \n   public void testCheckTreeTypeAwareEqualsSameNull() {\n-    TestErrorReporter testErrorReporter = new TestErrorReporter(null, null);\n-    JSTypeRegistry registry = new JSTypeRegistry(testErrorReporter);\n     Node node1 = Node.newString(Token.NAME, \"f\");\n     Node node2 = Node.newString(Token.NAME, \"f\");\n     assertTrue(node1.isEquivalentToTyped(node2));\n     assertEquals(\"foobar\", n.getJSDocInfo().getLicense());\n   }\n \n-  // TODO(johnlenz): reenable this test.\n-  public void disable_testIsQualifiedName() {\n-    assertTrue(getNode(\"a\").isQualifiedName());\n-    assertTrue(getNode(\"$\").isQualifiedName());\n-    assertTrue(getNode(\"_\").isQualifiedName());\n-    assertTrue(getNode(\"a.b\").isQualifiedName());\n-    assertTrue(getNode(\"a_b.cccccc$d4.x.y.zA$\").isQualifiedName());\n-    assertTrue(getNode(\"this.foo\").isQualifiedName());\n-    assertFalse(getNode(\"0\").isQualifiedName());\n-    assertFalse(getNode(\"[]\").isQualifiedName());\n-    assertFalse(getNode(\"{}\").isQualifiedName());\n-    assertFalse(getNode(\"''\").isQualifiedName());\n-    assertFalse(getNode(\"a[b]\").isQualifiedName());\n-    assertFalse(getNode(\"a[b].c\").isQualifiedName());\n-    assertFalse(getNode(\"c.a[b]\").isQualifiedName());\n-    assertFalse(getNode(\"a()\").isQualifiedName());\n-    assertFalse(getNode(\"a().b\").isQualifiedName());\n-    assertFalse(getNode(\"b.a()\").isQualifiedName());\n-    assertFalse(getNode(\"'a'\").isQualifiedName());\n-    assertFalse(getNode(\"/x/\").isQualifiedName());\n-    assertFalse(getNode(\"++x\").isQualifiedName());\n+  public void testIsQualifiedName() {\n+    assertTrue(IR.name(\"a\").isQualifiedName());\n+    assertTrue(IR.name(\"$\").isQualifiedName());\n+    assertTrue(IR.name(\"_\").isQualifiedName());\n+    assertTrue(IR.getprop(IR.name(\"a\"),IR.string(\"b\")).isQualifiedName());\n+    assertTrue(IR.getprop(IR.thisNode(),IR.string(\"b\")).isQualifiedName());\n+    assertFalse(IR.number(0).isQualifiedName());\n+    assertFalse(IR.arraylit().isQualifiedName());\n+    assertFalse(IR.objectlit().isQualifiedName());\n+    assertFalse(IR.string(\"\").isQualifiedName());\n+    assertFalse(IR.getelem(IR.name(\"a\"),IR.string(\"b\")).isQualifiedName());\n+    assertFalse( // a[b].c\n+        IR.getprop(\n+            IR.getelem(IR.name(\"a\"),IR.string(\"b\")),\n+            IR.string(\"c\"))\n+            .isQualifiedName());\n+    assertFalse( // a.b[c]\n+        IR.getelem(\n+            IR.getprop(IR.name(\"a\"),IR.string(\"b\")),\n+            IR.string(\"c\"))\n+            .isQualifiedName());\n+    assertFalse(IR.call(IR.name(\"a\")).isQualifiedName());\n+    assertFalse( // a().b\n+        IR.getprop(\n+            IR.call(IR.name(\"a\")),\n+            IR.string(\"b\"))\n+        .isQualifiedName());\n+    assertFalse( // (a.b)()\n+        IR.call(\n+            IR.getprop(IR.name(\"a\"),IR.string(\"b\")))\n+        .isQualifiedName());\n+    assertFalse(IR.string(\"a\").isQualifiedName());\n+    assertFalse(IR.regexp(IR.string(\"x\")).isQualifiedName());\n+    assertFalse(new Node(Token.INC, IR.name(\"x\")).isQualifiedName());\n   }\n \n   public void testCloneAnnontations() {\n   private static Node getAssignExpr(String name1, String name2) {\n     return new Node(Token.ASSIGN, getVarRef(name1), getVarRef(name2));\n   }\n-\n-  private static Node getNode(String js) {\n-    /*\n-    Node root = parse(\"var a=(\" + js + \");\");\n-    Node expr = root.getFirstChild();\n-    Node var = expr.getFirstChild();\n-    return var.getFirstChild();\n-    */\n-    return null;\n-  }\n-\n-  private static Node parse(String string) {\n-    /*\n-    CompilerEnvirons environment = new CompilerEnvirons();\n-    TestErrorReporter testErrorReporter = new TestErrorReporter(null, null);\n-    environment.setErrorReporter(testErrorReporter);\n-    environment.setParseJSDoc(true);\n-    Parser p = new Parser(environment, testErrorReporter);\n-    return p.parse(string, null, 0);\n-    */\n-    return null;\n-  }\n }\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n         ARRAY_TYPE, STRING_TYPE);\n     JSType arrayOfNumber = createParameterizedType(\n         ARRAY_TYPE, NUMBER_TYPE);\n-    JSType arrayOfUnknown = createParameterizedType(\n-        ARRAY_TYPE, UNKNOWN_TYPE);\n \n     // Union and least super type cases:\n     //\n \n     boolean exceptionThrown = false;\n     try {\n-      JSType templatizedInstance = registry.createTemplatizedType(\n+      registry.createTemplatizedType(\n           templatizedCtor.getInstanceType(),\n           ImmutableList.of(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE));\n     } catch (IllegalArgumentException e) {", "timestamp": 1357864288, "metainfo": ""}