{"sha": "4d98fc9034031ee146c7e5534a150e2700d89f8e", "log": "Add basic Node type helpers to Node  R=nicksantos DELTA=241  (135 added, 9 deleted, 97 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3672   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * @return The string representation.\n    */\n   static String getArrayElementStringValue(Node n) {\n-    return (NodeUtil.isNullOrUndefined(n) || n.getType() == Token.EMPTY)\n+    return (NodeUtil.isNullOrUndefined(n) || n.isEmpty())\n         ? \"\" : getStringValue(n);\n   }\n \n         return null;\n \n       case Token.NEG:\n-        if (n.getChildCount() == 1 && n.getFirstChild().getType() == Token.NAME\n+        if (n.getChildCount() == 1 && n.getFirstChild().isName()\n             && n.getFirstChild().getString().equals(\"Infinity\")) {\n           return Double.NEGATIVE_INFINITY;\n         }\n       case Token.ARRAYLIT:\n         for (Node child = n.getFirstChild(); child != null;\n              child = child.getNext()) {\n-          if (child.getType() != Token.EMPTY\n-              && !isLiteralValue(child, includeFunctions)) {\n+          if ((!child.isEmpty()) && !isLiteralValue(child, includeFunctions)) {\n             return false;\n           }\n         }\n    * @param block The node.\n    */\n   static boolean isEmptyBlock(Node block) {\n-    if (block.getType() != Token.BLOCK) {\n+    if (!block.isBlock()) {\n       return false;\n     }\n \n     for (Node n = block.getFirstChild(); n != null; n = n.getNext()) {\n-      if (n.getType() != Token.EMPTY) {\n+      if (!n.isEmpty()) {\n         return false;\n       }\n     }\n \n   static boolean constructorCallHasSideEffects(\n       Node callNode, AbstractCompiler compiler) {\n-    if (callNode.getType() != Token.NEW) {\n+    if (!callNode.isNew()) {\n       throw new IllegalStateException(\n           \"Expected NEW node, got \" + Token.name(callNode.getType()));\n     }\n     }\n \n     Node nameNode = callNode.getFirstChild();\n-    if (nameNode.getType() == Token.NAME &&\n+    if (nameNode.isName() &&\n         CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) {\n       return false;\n     }\n    */\n   static boolean functionCallHasSideEffects(\n       Node callNode, @Nullable AbstractCompiler compiler) {\n-    if (callNode.getType() != Token.CALL) {\n+    if (!callNode.isCall()) {\n       throw new IllegalStateException(\n           \"Expected CALL node, got \" + Token.name(callNode.getType()));\n     }\n     Node nameNode = callNode.getFirstChild();\n \n     // Built-in functions with no side effects.\n-    if (nameNode.getType() == Token.NAME) {\n+    if (nameNode.isName()) {\n       String name = nameNode.getString();\n       if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n         return false;\n       }\n-    } else if (nameNode.getType() == Token.GETPROP) {\n+    } else if (nameNode.isGetProp()) {\n       if (callNode.hasOneChild()\n           && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                 nameNode.getLastChild().getString())) {\n       // Math.floor has no sideeffects.\n       // TODO(nicksantos): This is a terrible terrible hack, until\n       // I create a definitionprovider that understands namespacing.\n-      if (nameNode.getFirstChild().getType() == Token.NAME) {\n+      if (nameNode.getFirstChild().isName()) {\n         if (\"Math.floor\".equals(nameNode.getQualifiedName())) {\n           return false;\n         }\n       }\n \n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n-        if (nameNode.getFirstChild().getType() == Token.REGEXP\n+        if (nameNode.getFirstChild().isRegExp()\n             && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n           return false;\n-        } else if (nameNode.getFirstChild().getType() == Token.STRING\n+        } else if (nameNode.getFirstChild().isString()\n             && STRING_REGEXP_METHODS.contains(\n                 nameNode.getLastChild().getString())) {\n           Node param = nameNode.getNext();\n           if (param != null &&\n-              (param.getType() == Token.STRING\n-                  || param.getType() == Token.REGEXP))\n+              (param.isString() || param.isRegExp()))\n           return false;\n         }\n       }\n    * @return Whether the call has a local result.\n    */\n   static boolean callHasLocalResult(Node n) {\n-    Preconditions.checkState(n.getType() == Token.CALL);\n+    Preconditions.checkState(n.isCall());\n     return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0;\n   }\n \n    * @return Whether the new has a local result.\n    */\n   static boolean newHasLocalResult(Node n) {\n-    Preconditions.checkState(n.getType() == Token.NEW);\n+    Preconditions.checkState(n.isNew());\n     return n.isOnlyModifiesThisCall();\n   }\n \n   }\n \n   static boolean isNull(Node n) {\n-    return n.getType() == Token.NULL;\n+    return n.isNull();\n   }\n \n   static boolean isNullOrUndefined(Node n) {\n   }\n \n   static boolean isExpressionNode(Node n) {\n-    return n.getType() == Token.EXPR_RESULT;\n+    return n.isExprResult();\n   }\n \n   /**\n    * Is this a GETPROP or GETELEM node?\n    */\n   static boolean isGet(Node n) {\n-    return n.getType() == Token.GETPROP\n-        || n.getType() == Token.GETELEM;\n+    return n.isGetProp() || n.isGetElem();\n   }\n \n   /**\n    * Is this a GETPROP node?\n    */\n   static boolean isGetProp(Node n) {\n-    return n.getType() == Token.GETPROP;\n+    return n.isGetProp();\n   }\n \n   /**\n    * Is this a NAME node?\n    */\n   static boolean isName(Node n) {\n-    return n.getType() == Token.NAME;\n+    return n.isName();\n   }\n \n   /**\n    * Is this a NEW node?\n    */\n   static boolean isNew(Node n) {\n-    return n.getType() == Token.NEW;\n+    return n.isNew();\n   }\n \n   /**\n    * Is this a VAR node?\n    */\n   static boolean isVar(Node n) {\n-    return n.getType() == Token.VAR;\n+    return n.isVar();\n   }\n \n   /**\n   static boolean isVarDeclaration(Node n) {\n     // There is no need to verify that parent != null because a NAME node\n     // always has a parent in a valid parse tree.\n-    return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR;\n+    return n.isName() && n.getParent().isVar();\n   }\n \n   /**\n    * Is this a STRING node?\n    */\n   static boolean isString(Node n) {\n-    return n.getType() == Token.STRING;\n+    return n.isString();\n   }\n \n   /**\n    *     first child is ASSIGN\n    */\n   static boolean isExprAssign(Node n) {\n-    return n.getType() == Token.EXPR_RESULT\n-        && n.getFirstChild().getType() == Token.ASSIGN;\n+    return n.isExprResult()\n+        && n.getFirstChild().isAssign();\n   }\n \n   /**\n    * Is this an ASSIGN node?\n    */\n   static boolean isAssign(Node n) {\n-    return n.getType() == Token.ASSIGN;\n+    return n.isAssign();\n   }\n \n   /**\n    *     first child is CALL\n    */\n   static boolean isExprCall(Node n) {\n-    return n.getType() == Token.EXPR_RESULT\n-        && n.getFirstChild().getType() == Token.CALL;\n+    return n.isExprResult()\n+        && n.getFirstChild().isCall();\n   }\n \n   /**\n    * @return Whether the node represents a FOR-IN loop.\n    */\n   static boolean isForIn(Node n) {\n-    return n.getType() == Token.FOR\n+    return n.isFor()\n         && n.getChildCount() == 3;\n   }\n \n    * @return Whether the node is of a type that contain other statements.\n    */\n   static boolean isStatementBlock(Node n) {\n-    return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK;\n+    return n.isScript() || n.isBlock();\n   }\n \n   /**\n \n   /** Whether the node is part of a switch statement. */\n   static boolean isSwitchCase(Node n) {\n-    return n.getType() == Token.CASE || n.getType() == Token.DEFAULT;\n+    return n.isCase() || n.isDefault();\n   }\n \n   /**\n \n   /** @return Whether the node is a label name. */\n   static boolean isLabelName(Node n) {\n-    return (n != null && n.getType() == Token.LABEL_NAME);\n+    return (n != null && n.isLabelName());\n   }\n \n   /** Whether the child node is the FINALLY block of a try. */\n   static boolean isTryFinallyNode(Node parent, Node child) {\n-    return parent.getType() == Token.TRY && parent.getChildCount() == 3\n+    return parent.isTry() && parent.getChildCount() == 3\n         && child == parent.getLastChild();\n   }\n \n   /** Whether the node is a CATCH container BLOCK. */\n   static boolean isTryCatchNodeContainer(Node n) {\n     Node parent = n.getParent();\n-    return parent.getType() == Token.TRY\n+    return parent.isTry()\n         && parent.getFirstChild().getNext() == n;\n   }\n \n         // Otherwise only its children can be removed.\n         node.detachChildren();\n       }\n-    } else if (node.getType() == Token.CATCH) {\n+    } else if (node.isCatch()) {\n       // The CATCH can can only be removed if there is a finally clause.\n       Node tryNode = node.getParent().getParent();\n       Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n       Node tryNode = node.getParent();\n       Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n       node.detachChildren();\n-    } else if (node.getType() == Token.BLOCK) {\n+    } else if (node.isBlock()) {\n       // Simply empty the block.  This maintains source location and\n       // \"synthetic\"-ness.\n       node.detachChildren();\n         || isSwitchCase(node)) {\n       // A statement in a block can simply be removed.\n       parent.removeChild(node);\n-    } else if (parent.getType() == Token.VAR) {\n+    } else if (parent.isVar()) {\n       if (parent.hasMoreThanOneChild()) {\n         parent.removeChild(node);\n       } else {\n         // This would leave an empty VAR, remove the VAR itself.\n         removeChild(parent.getParent(), parent);\n       }\n-    } else if (parent.getType() == Token.LABEL\n+    } else if (parent.isLabel()\n         && node == parent.getLastChild()) {\n       // Remove the node from the parent, so it can be reused.\n       parent.removeChild(node);\n       // A LABEL without children can not be referred to, remove it.\n       removeChild(parent.getParent(), parent);\n-    } else if (parent.getType() == Token.FOR\n+    } else if (parent.isFor()\n         && parent.getChildCount() == 4) {\n       // Only Token.FOR can have an Token.EMPTY other control structure\n       // need something for the condition. Others need to be replaced\n    * Add a finally block if one does not exist.\n    */\n   static void maybeAddFinally(Node tryNode) {\n-    Preconditions.checkState(tryNode.getType() == Token.TRY);\n+    Preconditions.checkState(tryNode.isTry());\n     if (!NodeUtil.hasFinally(tryNode)) {\n       tryNode.addChildrenToBack(new Node(Token.BLOCK)\n           .copyInformationFrom(tryNode));\n    * @return Whether the block was removed.\n    */\n   static boolean tryMergeBlock(Node block) {\n-    Preconditions.checkState(block.getType() == Token.BLOCK);\n+    Preconditions.checkState(block.isBlock());\n     Node parent = block.getParent();\n     // Try to remove the block if its parent is a block/script or if its\n     // parent is label and it has exactly one child.\n    * Is this a CALL node?\n    */\n   static boolean isCall(Node n) {\n-    return n.getType() == Token.CALL;\n+    return n.isCall();\n   }\n \n   /**\n    * Is this a FUNCTION node?\n    */\n   static boolean isFunction(Node n) {\n-    return n.getType() == Token.FUNCTION;\n+    return n.isFunction();\n   }\n \n   /**\n    * Is this a THIS node?\n    */\n   static boolean isThis(Node node) {\n-    return node.getType() == Token.THIS;\n+    return node.isThis();\n   }\n \n \n    * Is this an ARRAYLIT node\n    */\n   static boolean isArrayLiteral(Node node) {\n-    return node.getType() == Token.ARRAYLIT;\n+    return node.isArrayLit();\n   }\n \n   /**\n    * is not part of a expression; see {@link #isFunctionExpression}).\n    */\n   static boolean isFunctionDeclaration(Node n) {\n-    return n.getType() == Token.FUNCTION && isStatement(n);\n+    return n.isFunction() && isStatement(n);\n   }\n \n   /**\n    */\n   static boolean isHoistedFunctionDeclaration(Node n) {\n     return isFunctionDeclaration(n)\n-        && (n.getParent().getType() == Token.SCRIPT\n-            || n.getParent().getParent().getType() == Token.FUNCTION);\n+        && (n.getParent().isScript()\n+            || n.getParent().getParent().isFunction());\n   }\n \n   /**\n    * @return Whether n is an function used within an expression.\n    */\n   static boolean isFunctionExpression(Node n) {\n-    return n.getType() == Token.FUNCTION && !isStatement(n);\n+    return n.isFunction() && !isStatement(n);\n   }\n \n   /**\n    *    a['f'](...)\n    */\n   static boolean isObjectCallMethod(Node callNode, String methodName) {\n-    if (callNode.getType() == Token.CALL) {\n+    if (callNode.isCall()) {\n       Node functionIndentifyingExpression = callNode.getFirstChild();\n       if (isGet(functionIndentifyingExpression)) {\n         Node last = functionIndentifyingExpression.getLastChild();\n-        if (last != null && last.getType() == Token.STRING) {\n+        if (last != null && last.isString()) {\n           String propName = last.getString();\n           return (propName.equals(methodName));\n         }\n    */\n   static boolean isSimpleFunctionObjectCall(Node callNode) {\n     if (isFunctionObjectCall(callNode)) {\n-      if (callNode.getFirstChild().getFirstChild().getType() == Token.NAME) {\n+      if (callNode.getFirstChild().getFirstChild().isName()) {\n         return true;\n       }\n     }\n    * @return True if n is the left hand of an assign\n    */\n   static boolean isVarOrSimpleAssignLhs(Node n, Node parent) {\n-    return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) ||\n-           parent.getType() == Token.VAR;\n+    return (parent.isAssign() && parent.getFirstChild() == n) ||\n+           parent.isVar();\n   }\n \n   /**\n    * because it makes sense to treat this as synactically similar to\n    * \"var x = 0;\".\n    *\n-   * @param node The node\n+   * @param n The node\n    * @return True if n is an L-value.\n    */\n-  static boolean isLValue(Node node) {\n-    int nType = node.getType();\n-    Preconditions.checkArgument(nType == Token.NAME || nType == Token.GETPROP ||\n-        nType == Token.GETELEM);\n-    Node parent = node.getParent();\n-    return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == node)\n-        || (NodeUtil.isForIn(parent) && parent.getFirstChild() == node)\n-        || NodeUtil.isVar(parent)\n-        || (parent.getType() == Token.FUNCTION &&\n-            parent.getFirstChild() == node)\n-        || parent.getType() == Token.DEC\n-        || parent.getType() == Token.INC\n-        || parent.getType() == Token.LP\n-        || parent.getType() == Token.CATCH;\n+  static boolean isLValue(Node n) {\n+    Preconditions.checkArgument(n.isName() || n.isGetProp() ||\n+        n.isGetElem());\n+    Node parent = n.getParent();\n+    return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n+        || (NodeUtil.isForIn(parent) && parent.getFirstChild() == n)\n+        || parent.isVar()\n+        || (parent.isFunction() && parent.getFirstChild() == n)\n+        || parent.isDec()\n+        || parent.isInc()\n+        || parent.isLP()\n+        || parent.isCatch();\n   }\n \n   /**\n   static boolean isObjectLitKey(Node node, Node parent) {\n     switch (node.getType()) {\n       case Token.STRING:\n-        return parent.getType() == Token.OBJECTLIT;\n+        return parent.isObjectLit();\n       case Token.GET:\n       case Token.SET:\n         return true;\n     }\n \n     // make sure that the adding root looks ok\n-    Preconditions.checkState(addingRoot.getType() == Token.BLOCK ||\n-        addingRoot.getType() == Token.SCRIPT);\n+    Preconditions.checkState(addingRoot.isBlock() ||\n+        addingRoot.isScript());\n     Preconditions.checkState(addingRoot.getFirstChild() == null ||\n-        addingRoot.getFirstChild().getType() != Token.SCRIPT);\n+        !addingRoot.getFirstChild().isScript());\n     return addingRoot;\n   }\n \n   public static Node getRootOfQualifiedName(Node qName) {\n     for (Node current = qName; true;\n          current = current.getFirstChild()) {\n-      int type = current.getType();\n-      if (type == Token.NAME || type == Token.THIS) {\n+      if (current.isName() || current.isThis()) {\n         return current;\n       }\n-      Preconditions.checkState(type == Token.GETPROP);\n+      Preconditions.checkState(current.isGetProp());\n     }\n   }\n \n \n     @Override\n     public void visit(Node n) {\n-      if (n.getType() == Token.NAME) {\n+      if (n.isName()) {\n         Node parent = n.getParent();\n-        if (parent != null && parent.getType() == Token.VAR) {\n+        if (parent != null && parent.isVar()) {\n           String name = n.getString();\n           if (!vars.containsKey(name)) {\n             vars.put(name, n);\n \n     @Override\n     public boolean apply(Node n) {\n-      return n.getType() == Token.NAME\n-          && n.getString().equals(name);\n+      return n.isName() && n.getString().equals(name);\n     }\n   }\n \n   static class MatchDeclaration implements Predicate<Node> {\n     @Override\n     public boolean apply(Node n) {\n-      return isFunctionDeclaration(n) || n.getType() == Token.VAR;\n+      return isFunctionDeclaration(n) || n.isVar();\n     }\n   }\n \n     @Override\n     public boolean apply(Node n) {\n       Node parent = n.getParent();\n-      return n.getType() == Token.BLOCK\n+      return n.isBlock()\n           || (!isFunction(n) && (parent == null\n               || isControlStructure(parent)\n               || isStatementBlock(parent)));\n    * @return Whether a TRY node has a finally block.\n    */\n   static boolean hasFinally(Node n) {\n-    Preconditions.checkArgument(n.getType() == Token.TRY);\n+    Preconditions.checkArgument(n.isTry());\n     return n.getChildCount() == 3;\n   }\n \n    * of a TRY.\n    */\n   static Node getCatchBlock(Node n) {\n-    Preconditions.checkArgument(n.getType() == Token.TRY);\n+    Preconditions.checkArgument(n.isTry());\n     return n.getFirstChild().getNext();\n   }\n \n    * @see NodeUtil#getCatchBlock\n    */\n   static boolean hasCatchHandler(Node n) {\n-    Preconditions.checkArgument(n.getType() == Token.BLOCK);\n-    return n.hasChildren() && n.getFirstChild().getType() == Token.CATCH;\n+    Preconditions.checkArgument(n.isBlock());\n+    return n.hasChildren() && n.getFirstChild().isCatch();\n   }\n \n   /**\n     */\n   public static Node getFunctionParameters(Node fnNode) {\n     // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]\n-    Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);\n+    Preconditions.checkArgument(fnNode.isFunction());\n     return fnNode.getFirstChild().getNext();\n   }\n \n   static boolean isConstantByConvention(\n       CodingConvention convention, Node node, Node parent) {\n     String name = node.getString();\n-    if (parent.getType() == Token.GETPROP &&\n+    if (parent.isGetProp() &&\n         node == parent.getLastChild()) {\n       return convention.isConstantKey(name);\n     } else if (isObjectLitKey(node, parent)) {\n    * Get the JSDocInfo for a function.\n    */\n   public static JSDocInfo getFunctionJSDocInfo(Node n) {\n-    Preconditions.checkState(n.getType() == Token.FUNCTION);\n+    Preconditions.checkState(n.isFunction());\n     JSDocInfo fnInfo = n.getJSDocInfo();\n     if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {\n       // Look for the info on other nodes.\n       Node parent = n.getParent();\n-      if (parent.getType() == Token.ASSIGN) {\n+      if (parent.isAssign()) {\n         // on ASSIGNs\n         fnInfo = parent.getJSDocInfo();\n-      } else if (parent.getType() == Token.NAME) {\n+      } else if (parent.isName()) {\n         // on var NAME = function() { ... };\n         fnInfo = parent.getParent().getJSDocInfo();\n       }\n    * @return The InputId property on the node or its ancestors.\n    */\n   public static InputId getInputId(Node n) {\n-    while (n != null && n.getType() != Token.SCRIPT) {\n+    while (n != null && !n.isScript()) {\n       n = n.getParent();\n     }\n \n-    return (n != null && n.getType() == Token.SCRIPT) ? n.getInputId() : null;\n+    return (n != null && n.isScript()) ? n.getInputId() : null;\n   }\n \n   /**\n         return null;\n       }\n \n-      int parentType = parent.getType();\n-      if (parentType == Token.NAME) {\n+      if (parent.isName()) {\n         return getBestJSDocInfo(parent);\n-      } else if (parentType == Token.ASSIGN) {\n+      } else if (parent.isAssign()) {\n         info = parent.getJSDocInfo();\n       } else if (isObjectLitKey(parent, parent.getParent())) {\n         info = parent.getJSDocInfo();\n-      } else if (parentType == Token.FUNCTION) {\n+      } else if (parent.isFunction()) {\n         info = parent.getJSDocInfo();\n-      } else if (parentType == Token.VAR && parent.hasOneChild()) {\n+      } else if (parent.isVar() && parent.hasOneChild()) {\n         info = parent.getJSDocInfo();\n       }\n     }\n   /** Find the l-value that the given r-value is being assigned to. */\n   static Node getBestLValue(Node n) {\n     Node parent = n.getParent();\n-    int parentType = parent.getType();\n     boolean isFunctionDeclaration = isFunctionDeclaration(n);\n     if (isFunctionDeclaration) {\n       return n.getFirstChild();\n-    } else if (parentType == Token.NAME) {\n+    } else if (parent.isName()) {\n       return parent;\n-    } else if (parentType == Token.ASSIGN) {\n+    } else if (parent.isAssign()) {\n       return parent.getFirstChild();\n     } else if (isObjectLitKey(parent, parent.getParent())) {\n       return parent;\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     }\n   }\n \n+\n+  /*** AST type check methods ***/\n+\n+  public boolean isArrayLit() {\n+    return this.getType() == Token.ARRAYLIT;\n+  }\n+\n+  public boolean isAssign() {\n+    return this.getType() == Token.ASSIGN;\n+  }\n+\n+  public boolean isBlock() {\n+    return this.getType() == Token.BLOCK;\n+  }\n+\n+  public boolean isCall() {\n+    return this.getType() == Token.CALL;\n+  }\n+\n+  public boolean isCase() {\n+    return this.getType() == Token.CASE;\n+  }\n+\n+  public boolean isCatch() {\n+    return this.getType() == Token.CATCH;\n+  }\n+\n+  public boolean isDec() {\n+    return this.getType() == Token.DEC;\n+  }\n+\n+  public boolean isDefault() {\n+    return this.getType() == Token.DEFAULT;\n+  }\n+\n+  public boolean isDo() {\n+    return this.getType() == Token.DO;\n+  }\n+\n+  public boolean isEmpty() {\n+    return this.getType() == Token.EMPTY;\n+  }\n+\n+  public boolean isExprResult() {\n+    return this.getType() == Token.EXPR_RESULT;\n+  }\n+\n+  public boolean isFor() {\n+    return this.getType() == Token.FOR;\n+  }\n+\n+  public boolean isFunction() {\n+    return this.getType() == Token.FUNCTION;\n+  }\n+\n+  public boolean isGet() {\n+    return this.getType() == Token.GET;\n+  }\n+\n+  public boolean isGetElem() {\n+    return this.getType() == Token.GETELEM;\n+  }\n+\n+  public boolean isGetProp() {\n+    return this.getType() == Token.GETPROP;\n+  }\n+\n+  public boolean isIf() {\n+    return this.getType() == Token.IF;\n+  }\n+\n+  public boolean isInc() {\n+    return this.getType() == Token.INC;\n+  }\n+\n+  public boolean isLabel() {\n+    return this.getType() == Token.LABEL;\n+  }\n+\n+  public boolean isLabelName() {\n+    return this.getType() == Token.LABEL_NAME;\n+  }\n+\n+  public boolean isLP() {\n+    return this.getType() == Token.LP;\n+  }\n+\n+  public boolean isName() {\n+    return this.getType() == Token.NAME;\n+  }\n+\n+  public boolean isNew() {\n+    return this.getType() == Token.NEW;\n+  }\n+\n+  public boolean isNull() {\n+    return this.getType() == Token.NULL;\n+  }\n+\n+  public boolean isObjectLit() {\n+    return this.getType() == Token.OBJECTLIT;\n+  }\n+\n+  public boolean isRegExp() {\n+    return this.getType() == Token.REGEXP;\n+  }\n+\n+  public boolean isScript() {\n+    return this.getType() == Token.SCRIPT;\n+  }\n+\n+  public boolean isSet() {\n+    return this.getType() == Token.SET;\n+  }\n+\n+  public boolean isString() {\n+    return this.getType() == Token.STRING;\n+  }\n+\n+  public boolean isThis() {\n+    return this.getType() == Token.THIS;\n+  }\n+\n+  public boolean isTry() {\n+    return this.getType() == Token.TRY;\n+  }\n+\n+  public boolean isVar() {\n+    return this.getType() == Token.VAR;\n+  }\n+\n+  public boolean isVoid() {\n+    return this.getType() == Token.VOID;\n+  }\n+\n }", "timestamp": 1320870778, "metainfo": ""}