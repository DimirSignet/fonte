{"sha": "b1e133d228bb79683bd29f620e3af1cec1308d02", "log": "Do not warn about property hiding when the properties are inferred.  R=johnlenz DELTA=95  (64 added, 12 deleted, 19 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4949   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     FunctionType superClass = ctorType.getSuperClassConstructor();\n     boolean superClassHasProperty = superClass != null &&\n         superClass.getInstanceType().hasProperty(propertyName);\n+    boolean superClassHasDeclaredProperty = superClass != null &&\n+        superClass.getInstanceType().isPropertyTypeDeclared(propertyName);\n+\n     // For interface\n-    boolean superInterfacesHasProperty = false;\n+    boolean superInterfaceHasProperty = false;\n+    boolean superInterfaceHasDeclaredProperty = false;\n     if (ctorType.isInterface()) {\n       for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n-        superInterfacesHasProperty =\n-          superInterfacesHasProperty || interfaceType.hasProperty(propertyName);\n+        superInterfaceHasProperty =\n+            superInterfaceHasProperty ||\n+            interfaceType.hasProperty(propertyName);\n+        superInterfaceHasDeclaredProperty =\n+            superInterfaceHasDeclaredProperty ||\n+            interfaceType.isPropertyTypeDeclared(propertyName);\n       }\n     }\n     boolean declaredOverride = info != null && info.isOverride();\n         FunctionType interfaceType =\n             implementedInterface.toObjectType().getConstructor();\n         Preconditions.checkNotNull(interfaceType);\n+\n         boolean interfaceHasProperty =\n             interfaceType.getPrototype().hasProperty(propertyName);\n-        foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n-        if (reportMissingOverride.isOn() && !declaredOverride &&\n-            interfaceHasProperty) {\n+        foundInterfaceProperty = foundInterfaceProperty ||\n+            interfaceHasProperty;\n+        if (reportMissingOverride.isOn()\n+            && !declaredOverride\n+            && interfaceHasProperty) {\n           // @override not present, but the property does override an interface\n           // property\n           compiler.report(t.makeError(n, reportMissingOverride,\n \n     if (!declaredOverride\n         && !superClassHasProperty\n-        && !superInterfacesHasProperty) {\n+        && !superInterfaceHasProperty) {\n       // nothing to do here, it's just a plain new property\n       return;\n     }\n \n-    JSType topInstanceType = superClassHasProperty ?\n+    ObjectType topInstanceType = superClassHasDeclaredProperty ?\n         superClass.getTopMostDefiningType(propertyName) : null;\n-    if (reportMissingOverride.isOn() && ctorType.isConstructor() &&\n-        !declaredOverride && superClassHasProperty) {\n+    boolean declaredLocally =\n+        ctorType.isConstructor() &&\n+        (ctorType.getPrototype().hasOwnProperty(propertyName) ||\n+         ctorType.getInstanceType().hasOwnProperty(propertyName));\n+    if (reportMissingOverride.isOn()\n+        && !declaredOverride\n+        && superClassHasDeclaredProperty\n+        && declaredLocally) {\n       // @override not present, but the property does override a superclass\n       // property\n       compiler.report(t.makeError(n, reportMissingOverride,\n     }\n \n     // @override is present and we have to check that it is ok\n-    if (superClassHasProperty) {\n+    if (superClassHasDeclaredProperty) {\n       // there is a superclass implementation\n       JSType superClassPropType =\n           superClass.getInstanceType().getPropertyType(propertyName);\n                 propertyName, topInstanceType.toString(),\n                 superClassPropType.toString(), propertyType.toString()));\n       }\n-    } else if (superInterfacesHasProperty) {\n+    } else if (superInterfaceHasDeclaredProperty) {\n       // there is an super interface property\n       for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n         if (interfaceType.hasProperty(propertyName)) {\n           JSType superPropertyType =\n-            interfaceType.getPropertyType(propertyName);\n+              interfaceType.getPropertyType(propertyName);\n           if (!propertyType.canAssignTo(superPropertyType)) {\n             topInstanceType = interfaceType.getConstructor().\n                 getTopMostDefiningType(propertyName);\n           }\n         }\n       }\n-    } else if (!foundInterfaceProperty) {\n+    } else if (!foundInterfaceProperty\n+        && !superClassHasProperty\n+        && !superInterfaceHasProperty) {\n       // there is no superclass nor interface implementation\n       compiler.report(\n           t.makeError(n, UNKNOWN_OVERRIDE,\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n    */\n   public final boolean defineInferredProperty(String propertyName,\n       JSType type, Node propertyNode) {\n+    StaticSlot<JSType> originalSlot = getSlot(propertyName);\n     if (hasProperty(propertyName)) {\n+      if (isPropertyTypeDeclared(propertyName)) {\n+        // We never want to hide a declared property with an inferred property.\n+        return true;\n+      }\n       JSType originalType = getPropertyType(propertyName);\n       type = originalType == null ? type :\n           originalType.getLeastSupertype(type);\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n         \"/** @constructor */goog.Super = function() {};\" +\n         \"goog.Super.prototype.foo = 3;\" +\n         \"/** @constructor\\n @extends {goog.Super} */goog.Sub = function() {};\" +\n-        \"goog.Sub.prototype.foo = 5;\",\n-        \"property foo already defined on superclass goog.Super; \" +\n-        \"use @override to override it\");\n+        \"goog.Sub.prototype.foo = 5;\");\n   }\n \n   public void testInheritanceCheck8() throws Exception {\n         \"/** @constructor */goog.Super = function() {};\" +\n         \"goog.Super.prototype.foo = 3;\" +\n         \"/** @constructor\\n @extends {goog.Super} */goog.Sub = function() {};\" +\n-        \"/** @override */goog.Sub.prototype.foo = \\\"some string\\\";\",\n-        \"mismatch of the foo property type and the type of the property it \" +\n-        \"overrides from superclass goog.Super\\n\" +\n-        \"original: number\\n\" +\n-        \"override: string\");\n+        \"/** @override */goog.Sub.prototype.foo = \\\"some string\\\";\");\n   }\n \n   public void testInheritanceCheck13() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \" * @override\\n\" +\n         \" */\" +\n         \"SubFoo.prototype.bar = [];\");\n+  }\n+\n+  // overridden property 3 is in another cl.\n+\n+  public void testOverriddenProperty4() throws Exception {\n+    // These properties aren't declared, so there should be no warning.\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = null;\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function SubFoo() {}\" +\n+        \"SubFoo.prototype.bar = 3;\");\n+  }\n+\n+  public void testOverriddenProperty5() throws Exception {\n+    // An override should be OK if the superclass property wasn't declared.\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = null;\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function SubFoo() {}\" +\n+        \"/** @override */ SubFoo.prototype.bar = 3;\");\n+  }\n+\n+  public void testOverriddenProperty6() throws Exception {\n+    // The override keyword shouldn't be neccessary if the subclass property\n+    // is inferred.\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @type {?number} */ Foo.prototype.bar = null;\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function SubFoo() {}\" +\n+        \"SubFoo.prototype.bar = 3;\");\n   }\n \n   public void testThis2() throws Exception {\n         \"/** @constructor */goog.Super = function() {};\" +\n         \"goog.Super.prototype.foo = 3;\" +\n         \"/** @constructor\\n @extends {goog.Super} */goog.Sub = function() {};\" +\n-        \"goog.Sub.prototype.foo = 5;\",\n-        \"property foo already defined on superclass goog.Super; \" +\n-        \"use @override to override it\");\n+        \"goog.Sub.prototype.foo = 5;\");\n   }\n \n   public void testInheritanceCheck8() throws Exception {\n         \"/** @constructor */goog.Super = function() {};\" +\n         \"goog.Super.prototype.foo = 3;\" +\n         \"/** @constructor\\n @extends {goog.Super} */goog.Sub = function() {};\" +\n-        \"/** @override */goog.Sub.prototype.foo = \\\"some string\\\";\",\n-        \"mismatch of the foo property type and the type of the property it \" +\n-        \"overrides from superclass goog.Super\\n\" +\n-        \"original: number\\n\" +\n-        \"override: string\");\n+        \"/** @override */goog.Sub.prototype.foo = \\\"some string\\\";\");\n   }\n \n   public void testInheritanceCheck13() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     JSDocInfo privateInfo = new JSDocInfo();\n     privateInfo.setVisibility(Visibility.PRIVATE);\n \n-    sup.defineProperty(\"X\", NUMBER_TYPE, false, null);\n+    sup.defineProperty(\"X\", NUMBER_TYPE, true, null);\n     sup.setPropertyJSDocInfo(\"X\", privateInfo);\n \n+    sub.defineProperty(\"X\", NUMBER_TYPE, true, null);\n     sub.setPropertyJSDocInfo(\"X\", deprecated);\n \n     assertFalse(sup.getOwnPropertyJSDocInfo(\"X\").isDeprecated());", "timestamp": 1338942998, "metainfo": ""}