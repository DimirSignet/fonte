{"sha": "b8f616c939c652b8540c95fa2b377b8c628ef3ff", "log": "Migrate DefaultDateTypeAdapter to streaming adapter (#1070)", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n \n package com.google.gson;\n \n-import java.lang.reflect.Type;\n+import java.io.IOException;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import java.text.ParseException;\n import java.util.Locale;\n \n import com.google.gson.internal.bind.util.ISO8601Utils;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n \n /**\n  * This type adapter supports three subclasses of date: Date, Timestamp, and\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n-final class DefaultDateTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {\n+final class DefaultDateTypeAdapter extends TypeAdapter<Date> {\n \n-  // TODO: migrate to streaming adapter\n-  \n   private static final String SIMPLE_NAME = \"DefaultDateTypeAdapter\";\n-  \n+\n+  private final Class<? extends Date> dateType;\n   private final DateFormat enUsFormat;\n   private final DateFormat localFormat;\n   \n-  DefaultDateTypeAdapter() {\n-    this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n+  DefaultDateTypeAdapter(Class<? extends Date> dateType) {\n+    this(dateType,\n+        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n         DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n   }\n \n-  DefaultDateTypeAdapter(String datePattern) {\n-    this(new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));\n+  DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {\n+    this(dateType, new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));\n   }\n \n-  DefaultDateTypeAdapter(int style) {\n-    this(DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));\n+  DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {\n+    this(dateType, DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));\n   }\n \n   public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n-    this(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n+    this(Date.class,\n+        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n         DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n   }\n \n-  DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {\n+  public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {\n+    this(dateType,\n+        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n+        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n+  }\n+\n+  DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) {\n+    if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {\n+      throw new IllegalArgumentException(\"Date type must be one of \" + Date.class + \", \" + Timestamp.class + \", or \" + java.sql.Date.class + \" but was \" + dateType);\n+    }\n+    this.dateType = dateType;\n     this.enUsFormat = enUsFormat;\n     this.localFormat = localFormat;\n   }\n   // These methods need to be synchronized since JDK DateFormat classes are not thread-safe\n   // See issue 162\n   @Override\n-  public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {\n+  public void write(JsonWriter out, Date value) throws IOException {\n     synchronized (localFormat) {\n-      String dateFormatAsString = enUsFormat.format(src);\n-      return new JsonPrimitive(dateFormatAsString);\n+      String dateFormatAsString = enUsFormat.format(value);\n+      out.value(dateFormatAsString);\n     }\n   }\n \n   @Override\n-  public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n-      throws JsonParseException {\n-    if (!(json instanceof JsonPrimitive)) {\n+  public Date read(JsonReader in) throws IOException {\n+    if (in.peek() != JsonToken.STRING) {\n       throw new JsonParseException(\"The date should be a string value\");\n     }\n-    Date date = deserializeToDate(json);\n-    if (typeOfT == Date.class) {\n+    Date date = deserializeToDate(in.nextString());\n+    if (dateType == Date.class) {\n       return date;\n-    } else if (typeOfT == Timestamp.class) {\n+    } else if (dateType == Timestamp.class) {\n       return new Timestamp(date.getTime());\n-    } else if (typeOfT == java.sql.Date.class) {\n+    } else if (dateType == java.sql.Date.class) {\n       return new java.sql.Date(date.getTime());\n     } else {\n-      throw new IllegalArgumentException(getClass() + \" cannot deserialize to \" + typeOfT);\n+      // This must never happen: dateType is guarded in the primary constructor\n+      throw new AssertionError();\n     }\n   }\n \n-  private Date deserializeToDate(JsonElement json) {\n+  private Date deserializeToDate(String s) {\n     synchronized (localFormat) {\n       try {\n-      \treturn localFormat.parse(json.getAsString());\n+        return localFormat.parse(s);\n       } catch (ParseException ignored) {}\n       try {\n-        return enUsFormat.parse(json.getAsString());\n+        return enUsFormat.parse(s);\n       } catch (ParseException ignored) {}\n       try {\n-        return ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));\n+        return ISO8601Utils.parse(s, new ParsePosition(0));\n       } catch (ParseException e) {\n-        throw new JsonSyntaxException(json.getAsString(), e);\n+        throw new JsonSyntaxException(s, e);\n       }\n     }\n   }\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n         serializeSpecialFloatingPointValues, longSerializationPolicy, factories);\n   }\n \n+  @SuppressWarnings(\"unchecked\")\n   private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,\n       List<TypeAdapterFactory> factories) {\n     DefaultDateTypeAdapter dateTypeAdapter;\n+    TypeAdapter<Timestamp> timestampTypeAdapter;\n+    TypeAdapter<java.sql.Date> javaSqlDateTypeAdapter;\n     if (datePattern != null && !\"\".equals(datePattern.trim())) {\n-      dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);\n+      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, datePattern);\n+      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, datePattern);\n+      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, datePattern);\n     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {\n-      dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);\n+      dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, dateStyle, timeStyle);\n+      timestampTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(Timestamp.class, dateStyle, timeStyle);\n+      javaSqlDateTypeAdapter = (TypeAdapter) new DefaultDateTypeAdapter(java.sql.Date.class, dateStyle, timeStyle);\n     } else {\n       return;\n     }\n \n-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Date.class), dateTypeAdapter));\n-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Timestamp.class), dateTypeAdapter));\n-    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(java.sql.Date.class), dateTypeAdapter));\n+    factories.add(TypeAdapters.newFactory(Date.class, dateTypeAdapter));\n+    factories.add(TypeAdapters.newFactory(Timestamp.class, timestampTypeAdapter));\n+    factories.add(TypeAdapters.newFactory(java.sql.Date.class, javaSqlDateTypeAdapter));\n   }\n }\n--- a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java\n \n package com.google.gson;\n \n+import java.io.IOException;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n import java.util.Date;\n     Locale defaultLocale = Locale.getDefault();\n     Locale.setDefault(locale);\n     try {\n-      assertFormatted(\"Jan 1, 1970 12:00:00 AM\", new DefaultDateTypeAdapter());\n-      assertFormatted(\"1/1/70\", new DefaultDateTypeAdapter(DateFormat.SHORT));\n-      assertFormatted(\"Jan 1, 1970\", new DefaultDateTypeAdapter(DateFormat.MEDIUM));\n-      assertFormatted(\"January 1, 1970\", new DefaultDateTypeAdapter(DateFormat.LONG));\n+      assertFormatted(\"Jan 1, 1970 12:00:00 AM\", new DefaultDateTypeAdapter(Date.class));\n+      assertFormatted(\"1/1/70\", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));\n+      assertFormatted(\"Jan 1, 1970\", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));\n+      assertFormatted(\"January 1, 1970\", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));\n       assertFormatted(\"1/1/70 12:00 AM\",\n           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));\n       assertFormatted(\"Jan 1, 1970 12:00:00 AM\",\n     }\n   }\n \n-  public void testParsingDatesFormattedWithSystemLocale() {\n+  public void testParsingDatesFormattedWithSystemLocale() throws Exception {\n     TimeZone defaultTimeZone = TimeZone.getDefault();\n     TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\n     Locale defaultLocale = Locale.getDefault();\n     Locale.setDefault(Locale.FRANCE);\n     try {\n-      assertParsed(\"1 janv. 1970 00:00:00\", new DefaultDateTypeAdapter());\n-      assertParsed(\"01/01/70\", new DefaultDateTypeAdapter(DateFormat.SHORT));\n-      assertParsed(\"1 janv. 1970\", new DefaultDateTypeAdapter(DateFormat.MEDIUM));\n-      assertParsed(\"1 janvier 1970\", new DefaultDateTypeAdapter(DateFormat.LONG));\n+      assertParsed(\"1 janv. 1970 00:00:00\", new DefaultDateTypeAdapter(Date.class));\n+      assertParsed(\"01/01/70\", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));\n+      assertParsed(\"1 janv. 1970\", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));\n+      assertParsed(\"1 janvier 1970\", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));\n       assertParsed(\"01/01/70 00:00\",\n           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));\n       assertParsed(\"1 janv. 1970 00:00:00\",\n     }\n   }\n \n-  public void testParsingDatesFormattedWithUsLocale() {\n+  public void testParsingDatesFormattedWithUsLocale() throws Exception {\n     TimeZone defaultTimeZone = TimeZone.getDefault();\n     TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\n     Locale defaultLocale = Locale.getDefault();\n     Locale.setDefault(Locale.US);\n     try {\n-      assertParsed(\"Jan 1, 1970 0:00:00 AM\", new DefaultDateTypeAdapter());\n-      assertParsed(\"1/1/70\", new DefaultDateTypeAdapter(DateFormat.SHORT));\n-      assertParsed(\"Jan 1, 1970\", new DefaultDateTypeAdapter(DateFormat.MEDIUM));\n-      assertParsed(\"January 1, 1970\", new DefaultDateTypeAdapter(DateFormat.LONG));\n+      assertParsed(\"Jan 1, 1970 0:00:00 AM\", new DefaultDateTypeAdapter(Date.class));\n+      assertParsed(\"1/1/70\", new DefaultDateTypeAdapter(Date.class, DateFormat.SHORT));\n+      assertParsed(\"Jan 1, 1970\", new DefaultDateTypeAdapter(Date.class, DateFormat.MEDIUM));\n+      assertParsed(\"January 1, 1970\", new DefaultDateTypeAdapter(Date.class, DateFormat.LONG));\n       assertParsed(\"1/1/70 0:00 AM\",\n           new DefaultDateTypeAdapter(DateFormat.SHORT, DateFormat.SHORT));\n       assertParsed(\"Jan 1, 1970 0:00:00 AM\",\n     }\n   }\n \n-  public void testFormatUsesDefaultTimezone() {\n+  public void testFormatUsesDefaultTimezone() throws Exception {\n     TimeZone defaultTimeZone = TimeZone.getDefault();\n     TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"));\n     Locale defaultLocale = Locale.getDefault();\n     Locale.setDefault(Locale.US);\n     try {\n-      assertFormatted(\"Dec 31, 1969 4:00:00 PM\", new DefaultDateTypeAdapter());\n-      assertParsed(\"Dec 31, 1969 4:00:00 PM\", new DefaultDateTypeAdapter());\n+      assertFormatted(\"Dec 31, 1969 4:00:00 PM\", new DefaultDateTypeAdapter(Date.class));\n+      assertParsed(\"Dec 31, 1969 4:00:00 PM\", new DefaultDateTypeAdapter(Date.class));\n     } finally {\n       TimeZone.setDefault(defaultTimeZone);\n       Locale.setDefault(defaultLocale);\n   }\n \n   public void testDateDeserializationISO8601() throws Exception {\n-  \tDefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();\n+    DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);\n     assertParsed(\"1970-01-01T00:00:00.000Z\", adapter);\n     assertParsed(\"1970-01-01T00:00Z\", adapter);\n     assertParsed(\"1970-01-01T00:00:00+00:00\", adapter);\n   \n   public void testDateSerialization() throws Exception {\n     int dateStyle = DateFormat.LONG;\n-    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);\n+    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, dateStyle);\n     DateFormat formatter = DateFormat.getDateInstance(dateStyle, Locale.US);\n     Date currentDate = new Date();\n \n-    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();\n-    assertEquals(formatter.format(currentDate), dateString);\n+    String dateString = dateTypeAdapter.toJson(currentDate);\n+    assertEquals(toLiteral(formatter.format(currentDate)), dateString);\n   }\n \n   public void testDatePattern() throws Exception {\n     String pattern = \"yyyy-MM-dd\";\n-    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(pattern);\n+    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(Date.class, pattern);\n     DateFormat formatter = new SimpleDateFormat(pattern);\n     Date currentDate = new Date();\n \n-    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();\n-    assertEquals(formatter.format(currentDate), dateString);\n+    String dateString = dateTypeAdapter.toJson(currentDate);\n+    assertEquals(toLiteral(formatter.format(currentDate)), dateString);\n   }\n \n   public void testInvalidDatePattern() throws Exception {\n     try {\n-      new DefaultDateTypeAdapter(\"I am a bad Date pattern....\");\n+      new DefaultDateTypeAdapter(Date.class, \"I am a bad Date pattern....\");\n       fail(\"Invalid date pattern should fail.\");\n     } catch (IllegalArgumentException expected) { }\n   }\n \n   private void assertFormatted(String formatted, DefaultDateTypeAdapter adapter) {\n-    assertEquals(formatted, adapter.serialize(new Date(0), Date.class, null).getAsString());\n+    assertEquals(toLiteral(formatted), adapter.toJson(new Date(0)));\n   }\n \n-  private void assertParsed(String date, DefaultDateTypeAdapter  adapter) {\n-    assertEquals(date, new Date(0), adapter.deserialize(new JsonPrimitive(date), Date.class, null));\n-    assertEquals(\"ISO 8601\", new Date(0), adapter.deserialize(\n-        new JsonPrimitive(\"1970-01-01T00:00:00Z\"), Date.class, null));\n+  private void assertParsed(String date, DefaultDateTypeAdapter adapter) throws IOException {\n+    assertEquals(date, new Date(0), adapter.fromJson(toLiteral(date)));\n+    assertEquals(\"ISO 8601\", new Date(0), adapter.fromJson(toLiteral(\"1970-01-01T00:00:00Z\")));\n+  }\n+\n+  private static String toLiteral(String s) {\n+    return '\"' + s + '\"';\n   }\n }", "timestamp": 1496193170, "metainfo": ""}