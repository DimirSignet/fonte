{"sha": "3ff16c30dbcd2a66209935a3e71a5f21f696d896", "log": "Don't use a runtime wrapper if a JsonAdapter annotation is present on a field.  This ensures that JsonAdapter annotation works correctly on a primitive field. This is a potentially backward incompatible change.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n import java.text.SimpleDateFormat;\n import java.util.Date;\n import java.util.Locale;\n-import java.util.TimeZone;\n \n import com.google.gson.internal.bind.util.ISO8601Utils;\n \n--- a/gson/src/main/java/com/google/gson/internal/Streams.java\n+++ b/gson/src/main/java/com/google/gson/internal/Streams.java\n     TypeAdapters.JSON_ELEMENT.write(writer, element);\n   }\n \n-  @SuppressWarnings(\"resource\")\n   public static Writer writerForAppendable(Appendable appendable) {\n     return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\n   }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+\n import java.io.IOException;\n import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n     // special casing primitives here saves ~5% on Android...\n+    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n+    TypeAdapter<?> mapped = null;\n+    if (annotation != null) {\n+      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n+    }\n+    final boolean jsonAdapterPresent = mapped != null;\n+    if (mapped == null) mapped = context.getAdapter(fieldType);\n+\n+    final TypeAdapter<?> typeAdapter = mapped;\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n-      final TypeAdapter<?> typeAdapter = getFieldAdapter(context, field, fieldType);\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n+        TypeAdapter t = jsonAdapterPresent ? typeAdapter\n+            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n         return fieldValue != value; // avoid recursion for example for Throwable.cause\n       }\n     };\n-  }\n-\n-  TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {\n-    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n-    if (annotation != null) {\n-      TypeAdapter<?> adapter = getTypeAdapter(constructorConstructor, gson, fieldType, annotation);\n-      if (adapter != null) return adapter;\n-    }\n-    return gson.getAdapter(fieldType);\n   }\n \n   private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n  */\n package com.google.gson.internal.bind;\n \n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+\n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n-import java.io.IOException;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n \n final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {\n   private final Gson context;\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n         @Override public void write(JsonWriter out, Part part) throws IOException {\n           throw new AssertionError();\n         }\n-\n         @Override public Part read(JsonReader in) throws IOException {\n           throw new AssertionError();\n         }\n       this.part = part;\n     }\n   }\n+\n+  /** Regression test contributed through https://github.com/google/gson/issues/831 */\n+  public void testNonPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new GadgetWithOptionalPart(new Part(\"foo\")));\n+    assertEquals(\"{\\\"part\\\":\\\"PartJsonFieldAnnotationAdapter\\\"}\", json);\n+    GadgetWithOptionalPart gadget = gson.fromJson(\"{'part':'foo'}\", GadgetWithOptionalPart.class);\n+    assertEquals(\"PartJsonFieldAnnotationAdapter\", gadget.part.name);\n+  }\n+\n+  /** Regression test contributed through https://github.com/google/gson/issues/831 */\n+  public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new GadgetWithPrimitivePart(42));\n+    assertEquals(\"{\\\"part\\\":\\\"42\\\"}\", json);\n+    GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class);\n+    assertEquals(42, gadget.part);\n+  }\n+\n+  private static final class GadgetWithPrimitivePart {\n+    @JsonAdapter(LongToStringTypeAdapterFactory.class)\n+    final long part;\n+\n+    private GadgetWithPrimitivePart(long part) {\n+      this.part = part;\n+    }\n+  }\n+\n+  private static final class LongToStringTypeAdapterFactory implements TypeAdapterFactory {\n+    static final TypeAdapter<Long> ADAPTER = new TypeAdapter<Long>() {\n+      @Override public void write(JsonWriter out, Long value) throws IOException {\n+        out.value(value.toString());\n+      }\n+      @Override public Long read(JsonReader in) throws IOException {\n+        return in.nextLong();\n+      }\n+    };\n+    @SuppressWarnings(\"unchecked\")\n+    @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n+      Class<?> cls = type.getRawType();\n+      if (Long.class.isAssignableFrom(cls)) {\n+        return (TypeAdapter<T>) ADAPTER;\n+      } else if (long.class.isAssignableFrom(cls)) {\n+        return (TypeAdapter<T>) ADAPTER;\n+      }\n+      throw new IllegalStateException(\"Non-long field of type \" + type\n+          + \" annotated with @JsonAdapter(LongToStringTypeAdapterFactory.class)\");\n+    }\n+  }\n }", "timestamp": 1463517059, "metainfo": ""}