{"sha": "c24af304077e4a6d1925db7cd35d0cd1ed488d6a", "log": "Merge pull request #871 from google/jw/tree-json-path  Implement JSON Path for JsonTreeReader.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n import com.google.gson.stream.JsonToken;\n import java.io.IOException;\n import java.io.Reader;\n-import java.util.ArrayList;\n import java.util.Iterator;\n-import java.util.List;\n import java.util.Map;\n \n /**\n   };\n   private static final Object SENTINEL_CLOSED = new Object();\n \n-  private final List<Object> stack = new ArrayList<Object>();\n+  /*\n+   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n+   */\n+  private Object[] stack = new Object[32];\n+  private int stackSize = 0;\n+\n+  /*\n+   * The path members. It corresponds directly to stack: At indices where the\n+   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n+   * pathNames contains the name at this scope. Where it contains an array\n+   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n+   * that array. Otherwise the value is undefined, and we take advantage of that\n+   * by incrementing pathIndices when doing so isn't useful.\n+   */\n+  private String[] pathNames = new String[32];\n+  private int[] pathIndices = new int[32];\n \n   public JsonTreeReader(JsonElement element) {\n     super(UNREADABLE_READER);\n-    stack.add(element);\n+    push(element);\n   }\n \n   @Override public void beginArray() throws IOException {\n     expect(JsonToken.BEGIN_ARRAY);\n     JsonArray array = (JsonArray) peekStack();\n-    stack.add(array.iterator());\n+    push(array.iterator());\n+    pathIndices[stackSize - 1] = 0;\n   }\n \n   @Override public void endArray() throws IOException {\n     expect(JsonToken.END_ARRAY);\n     popStack(); // empty iterator\n     popStack(); // array\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n   }\n \n   @Override public void beginObject() throws IOException {\n     expect(JsonToken.BEGIN_OBJECT);\n     JsonObject object = (JsonObject) peekStack();\n-    stack.add(object.entrySet().iterator());\n+    push(object.entrySet().iterator());\n   }\n \n   @Override public void endObject() throws IOException {\n     expect(JsonToken.END_OBJECT);\n     popStack(); // empty iterator\n     popStack(); // object\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n   }\n \n   @Override public boolean hasNext() throws IOException {\n   }\n \n   @Override public JsonToken peek() throws IOException {\n-    if (stack.isEmpty()) {\n+    if (stackSize == 0) {\n       return JsonToken.END_DOCUMENT;\n     }\n \n     Object o = peekStack();\n     if (o instanceof Iterator) {\n-      boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;\n+      boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n       Iterator<?> iterator = (Iterator<?>) o;\n       if (iterator.hasNext()) {\n         if (isObject) {\n           return JsonToken.NAME;\n         } else {\n-          stack.add(iterator.next());\n+          push(iterator.next());\n           return peek();\n         }\n       } else {\n   }\n \n   private Object peekStack() {\n-    return stack.get(stack.size() - 1);\n+    return stack[stackSize - 1];\n   }\n \n   private Object popStack() {\n-    return stack.remove(stack.size() - 1);\n+    Object result = stack[--stackSize];\n+    stack[stackSize] = null;\n+    return result;\n   }\n \n   private void expect(JsonToken expected) throws IOException {\n     if (peek() != expected) {\n-      throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek());\n+      throw new IllegalStateException(\n+          \"Expected \" + expected + \" but was \" + peek() + locationString());\n     }\n   }\n \n     expect(JsonToken.NAME);\n     Iterator<?> i = (Iterator<?>) peekStack();\n     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n-    stack.add(entry.getValue());\n-    return (String) entry.getKey();\n+    String result = (String) entry.getKey();\n+    pathNames[stackSize - 1] = result;\n+    push(entry.getValue());\n+    return result;\n   }\n \n   @Override public String nextString() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token);\n-    }\n-    return ((JsonPrimitive) popStack()).getAsString();\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n+    }\n+    String result = ((JsonPrimitive) popStack()).getAsString();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n+    return result;\n   }\n \n   @Override public boolean nextBoolean() throws IOException {\n     expect(JsonToken.BOOLEAN);\n-    return ((JsonPrimitive) popStack()).getAsBoolean();\n+    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n+    return result;\n   }\n \n   @Override public void nextNull() throws IOException {\n     expect(JsonToken.NULL);\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n   }\n \n   @Override public double nextDouble() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     double result = ((JsonPrimitive) peekStack()).getAsDouble();\n     if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n       throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n     }\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n     return result;\n   }\n \n   @Override public long nextLong() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     long result = ((JsonPrimitive) peekStack()).getAsLong();\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n     return result;\n   }\n \n   @Override public int nextInt() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     int result = ((JsonPrimitive) peekStack()).getAsInt();\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n     return result;\n   }\n \n   @Override public void close() throws IOException {\n-    stack.clear();\n-    stack.add(SENTINEL_CLOSED);\n+    stack = new Object[] { SENTINEL_CLOSED };\n+    stackSize = 1;\n   }\n \n   @Override public void skipValue() throws IOException {\n     if (peek() == JsonToken.NAME) {\n       nextName();\n+      pathNames[stackSize - 2] = \"null\";\n     } else {\n       popStack();\n-    }\n+      pathNames[stackSize - 1] = \"null\";\n+    }\n+    pathIndices[stackSize - 1]++;\n   }\n \n   @Override public String toString() {\n     expect(JsonToken.NAME);\n     Iterator<?> i = (Iterator<?>) peekStack();\n     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n-    stack.add(entry.getValue());\n-    stack.add(new JsonPrimitive((String)entry.getKey()));\n+    push(entry.getValue());\n+    push(new JsonPrimitive((String) entry.getKey()));\n+  }\n+\n+  private void push(Object newTop) {\n+    if (stackSize == stack.length) {\n+      Object[] newStack = new Object[stackSize * 2];\n+      int[] newPathIndices = new int[stackSize * 2];\n+      String[] newPathNames = new String[stackSize * 2];\n+      System.arraycopy(stack, 0, newStack, 0, stackSize);\n+      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n+      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n+      stack = newStack;\n+      pathIndices = newPathIndices;\n+      pathNames = newPathNames;\n+    }\n+    stack[stackSize++] = newTop;\n+  }\n+\n+  @Override public String getPath() {\n+    StringBuilder result = new StringBuilder().append('$');\n+    for (int i = 0; i < stackSize; i++) {\n+      if (stack[i] instanceof JsonArray) {\n+        if (stack[++i] instanceof Iterator) {\n+          result.append('[').append(pathIndices[i]).append(']');\n+        }\n+      } else if (stack[i] instanceof JsonObject) {\n+        if (stack[++i] instanceof Iterator) {\n+          result.append('.');\n+          if (pathNames[i] != null) {\n+            result.append(pathNames[i]);\n+          }\n+        }\n+      }\n+    }\n+    return result.toString();\n+  }\n+\n+  private String locationString() {\n+    return \" at path \" + getPath();\n   }\n }\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java\n \n package com.google.gson.stream;\n \n+import com.google.gson.JsonElement;\n+import com.google.gson.internal.Streams;\n+import com.google.gson.internal.bind.JsonTreeReader;\n import java.io.IOException;\n import java.io.StringReader;\n-import junit.framework.TestCase;\n-\n-@SuppressWarnings(\"resource\")\n-public class JsonReaderPathTest extends TestCase {\n-  public void testPath() throws IOException {\n-    JsonReader reader = new JsonReader(\n-        new StringReader(\"{\\\"a\\\":[2,true,false,null,\\\"b\\\",{\\\"c\\\":\\\"d\\\"},[3]]}\"));\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static org.junit.Assume.assumeTrue;\n+\n+@RunWith(Parameterized.class)\n+public class JsonReaderPathTest {\n+  @Parameterized.Parameters(name = \"{0}\")\n+  public static List<Object[]> parameters() {\n+    return Arrays.asList(\n+        new Object[] { Factory.STRING_READER },\n+        new Object[] { Factory.OBJECT_READER }\n+    );\n+  }\n+\n+  @Parameterized.Parameter\n+  public Factory factory;\n+\n+  @Test public void path() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":[2,true,false,null,\\\"b\\\",{\\\"c\\\":\\\"d\\\"},[3]]}\");\n     assertEquals(\"$\", reader.getPath());\n     reader.beginObject();\n     assertEquals(\"$.\", reader.getPath());\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testObjectPath() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1,\\\"b\\\":2}\"));\n+  @Test public void objectPath() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":1,\\\"b\\\":2}\");\n     assertEquals(\"$\", reader.getPath());\n \n     reader.peek();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testArrayPath() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[1,2]\"));\n+  @Test public void arrayPath() throws IOException {\n+    JsonReader reader = factory.create(\"[1,2]\");\n     assertEquals(\"$\", reader.getPath());\n \n     reader.peek();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testMultipleTopLevelValuesInOneDocument() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[][]\"));\n+  @Test public void multipleTopLevelValuesInOneDocument() throws IOException {\n+    assumeTrue(factory == Factory.STRING_READER);\n+\n+    JsonReader reader = factory.create(\"[][]\");\n     reader.setLenient(true);\n     reader.beginArray();\n     reader.endArray();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testSkipArrayElements() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[1,2,3]\"));\n-    reader.beginArray();\n-    reader.skipValue();\n-    reader.skipValue();\n-    assertEquals(\"$[2]\", reader.getPath());\n-  }\n-\n-  public void testSkipObjectNames() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1}\"));\n+  @Test public void skipArrayElements() throws IOException {\n+    JsonReader reader = factory.create(\"[1,2,3]\");\n+    reader.beginArray();\n+    reader.skipValue();\n+    reader.skipValue();\n+    assertEquals(\"$[2]\", reader.getPath());\n+  }\n+\n+  @Test public void skipObjectNames() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":1}\");\n     reader.beginObject();\n     reader.skipValue();\n     assertEquals(\"$.null\", reader.getPath());\n   }\n \n-  public void testSkipObjectValues() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1,\\\"b\\\":2}\"));\n-    reader.beginObject();\n+  @Test public void skipObjectValues() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":1,\\\"b\\\":2}\");\n+    reader.beginObject();\n+    assertEquals(\"$.\", reader.getPath());\n     reader.nextName();\n     reader.skipValue();\n     assertEquals(\"$.null\", reader.getPath());\n     assertEquals(\"$.b\", reader.getPath());\n   }\n \n-  public void testSkipNestedStructures() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[[1,2,3],4]\"));\n-    reader.beginArray();\n-    reader.skipValue();\n-    assertEquals(\"$[1]\", reader.getPath());\n-  }\n-\n-  public void testArrayOfObjects() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[{},{},{}]\"));\n+  @Test public void skipNestedStructures() throws IOException {\n+    JsonReader reader = factory.create(\"[[1,2,3],4]\");\n+    reader.beginArray();\n+    reader.skipValue();\n+    assertEquals(\"$[1]\", reader.getPath());\n+  }\n+\n+  @Test public void arrayOfObjects() throws IOException {\n+    JsonReader reader = factory.create(\"[{},{},{}]\");\n     reader.beginArray();\n     assertEquals(\"$[0]\", reader.getPath());\n     reader.beginObject();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testArrayOfArrays() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[[],[],[]]\"));\n+  @Test public void arrayOfArrays() throws IOException {\n+    JsonReader reader = factory.create(\"[[],[],[]]\");\n     reader.beginArray();\n     assertEquals(\"$[0]\", reader.getPath());\n     reader.beginArray();\n     reader.endArray();\n     assertEquals(\"$\", reader.getPath());\n   }\n+\n+  enum Factory {\n+    STRING_READER {\n+      @Override public JsonReader create(String data) {\n+        return new JsonReader(new StringReader(data));\n+      }\n+    },\n+    OBJECT_READER {\n+      @Override public JsonReader create(String data) {\n+        JsonElement element = Streams.parse(new JsonReader(new StringReader(data)));\n+        return new JsonTreeReader(element);\n+      }\n+    };\n+\n+    abstract JsonReader create(String data);\n+  }\n }\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n  * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field\n  * name to the {@link #of} factory method. If you don't supply an explicit type\n  * field name, {@code \"type\"} will be used. <pre>   {@code\n- *   RuntimeTypeAdapterFactory<Shape> shapeAdapter\n+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory\n  *       = RuntimeTypeAdapterFactory.of(Shape.class, \"type\");\n  * }</pre>\n  * Next register all of your subtypes. Every subtype must be explicitly\n  *   shapeAdapter.registerSubtype(Circle.class, \"Circle\");\n  *   shapeAdapter.registerSubtype(Diamond.class, \"Diamond\");\n  * }</pre>\n- * Finally, register the type adapter in your application's GSON builder:\n+ * Finally, register the type adapter factory in your application's GSON builder:\n  * <pre>   {@code\n  *   Gson gson = new GsonBuilder()\n- *       .registerTypeAdapter(Shape.class, shapeAdapter)\n+ *       .registerTypeAdapterFactory(shapeAdapterFactory)\n  *       .create();\n  * }</pre>\n  * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code\n- *   RuntimeTypeAdapterFactory<Shape> shapeAdapter = RuntimeTypeAdapterFactory.of(Shape.class)\n+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)\n  *       .registerSubtype(Rectangle.class)\n  *       .registerSubtype(Circle.class)\n  *       .registerSubtype(Diamond.class);\n--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n import java.text.SimpleDateFormat;\n import java.util.Date;\n import java.util.Locale;\n-import java.util.TimeZone;\n \n import com.google.gson.internal.bind.util.ISO8601Utils;\n \n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   }\n \n   /**\n-   * Returns a new JSON writer configured for the settings on this Gson instance.\n+   * Returns a new JSON reader configured for the settings on this Gson instance.\n    */\n   public JsonReader newJsonReader(Reader reader) {\n     JsonReader jsonReader = new JsonReader(reader);\n--- a/gson/src/main/java/com/google/gson/JsonObject.java\n+++ b/gson/src/main/java/com/google/gson/JsonObject.java\n   }\n \n   /**\n+   * Returns the number of key/value pairs in the object.\n+   *\n+   * @return the number of key/value pairs in the object.\n+   */\n+  public int size() {\n+    return members.size();\n+  }\n+\n+  /**\n    * Convenience method to check if a member with the specified name is present in this object.\n    *\n    * @param memberName name of the member that is being checked for presence.\n--- a/gson/src/main/java/com/google/gson/internal/Streams.java\n+++ b/gson/src/main/java/com/google/gson/internal/Streams.java\n     TypeAdapters.JSON_ELEMENT.write(writer, element);\n   }\n \n-  @SuppressWarnings(\"resource\")\n   public static Writer writerForAppendable(Appendable appendable) {\n     return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\n   }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+\n import java.io.IOException;\n import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n     // special casing primitives here saves ~5% on Android...\n+    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n+    TypeAdapter<?> mapped = null;\n+    if (annotation != null) {\n+      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n+    }\n+    final boolean jsonAdapterPresent = mapped != null;\n+    if (mapped == null) mapped = context.getAdapter(fieldType);\n+\n+    final TypeAdapter<?> typeAdapter = mapped;\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n-      final TypeAdapter<?> typeAdapter = getFieldAdapter(context, field, fieldType);\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n+        TypeAdapter t = jsonAdapterPresent ? typeAdapter\n+            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n         return fieldValue != value; // avoid recursion for example for Throwable.cause\n       }\n     };\n-  }\n-\n-  TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {\n-    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n-    if (annotation != null) {\n-      TypeAdapter<?> adapter = getTypeAdapter(constructorConstructor, gson, fieldType, annotation);\n-      if (adapter != null) return adapter;\n-    }\n-    return gson.getAdapter(fieldType);\n   }\n \n   private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n  */\n package com.google.gson.internal.bind;\n \n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+\n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n-import java.io.IOException;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n \n final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {\n   private final Gson context;\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n           constantToName.put(constant, name);\n         }\n       } catch (NoSuchFieldException e) {\n-        throw new AssertionError(\"Missing field in \" + classOfT.getName(), e);\n+        throw new AssertionError(e);\n       }\n     }\n     @Override public T read(JsonReader in) throws IOException {\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n     case '\\'':\n     case '\"':\n     case '\\\\':\n+    case '/':\t\n+    \treturn escaped;\n     default:\n-      return escaped;\n+    \t// throw error when none of the above cases are matched\n+    \tthrow syntaxError(\"Invalid escape sequence\");\n     }\n   }\n \n--- a/gson/src/test/java/com/google/gson/JsonObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonObjectTest.java\n     assertFalse(b.equals(a));\n   }\n \n+  public void testSize() {\n+    JsonObject o = new JsonObject();\n+    assertEquals(0, o.size());\n+\n+    o.add(\"Hello\", new JsonPrimitive(1));\n+    assertEquals(1, o.size());\n+\n+    o.add(\"Hi\", new JsonPrimitive(1));\n+    assertEquals(2, o.size());\n+\n+    o.remove(\"Hello\");\n+    assertEquals(1, o.size());\n+  }\n+\n   public void testDeepCopy() {\n     JsonObject original = new JsonObject();\n     JsonArray firstEntry = new JsonArray();\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n         @Override public void write(JsonWriter out, Part part) throws IOException {\n           throw new AssertionError();\n         }\n-\n         @Override public Part read(JsonReader in) throws IOException {\n           throw new AssertionError();\n         }\n       this.part = part;\n     }\n   }\n+\n+  /** Regression test contributed through https://github.com/google/gson/issues/831 */\n+  public void testNonPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new GadgetWithOptionalPart(new Part(\"foo\")));\n+    assertEquals(\"{\\\"part\\\":\\\"PartJsonFieldAnnotationAdapter\\\"}\", json);\n+    GadgetWithOptionalPart gadget = gson.fromJson(\"{'part':'foo'}\", GadgetWithOptionalPart.class);\n+    assertEquals(\"PartJsonFieldAnnotationAdapter\", gadget.part.name);\n+  }\n+\n+  /** Regression test contributed through https://github.com/google/gson/issues/831 */\n+  public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new GadgetWithPrimitivePart(42));\n+    assertEquals(\"{\\\"part\\\":\\\"42\\\"}\", json);\n+    GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class);\n+    assertEquals(42, gadget.part);\n+  }\n+\n+  private static final class GadgetWithPrimitivePart {\n+    @JsonAdapter(LongToStringTypeAdapterFactory.class)\n+    final long part;\n+\n+    private GadgetWithPrimitivePart(long part) {\n+      this.part = part;\n+    }\n+  }\n+\n+  private static final class LongToStringTypeAdapterFactory implements TypeAdapterFactory {\n+    static final TypeAdapter<Long> ADAPTER = new TypeAdapter<Long>() {\n+      @Override public void write(JsonWriter out, Long value) throws IOException {\n+        out.value(value.toString());\n+      }\n+      @Override public Long read(JsonReader in) throws IOException {\n+        return in.nextLong();\n+      }\n+    };\n+    @SuppressWarnings(\"unchecked\")\n+    @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n+      Class<?> cls = type.getRawType();\n+      if (Long.class.isAssignableFrom(cls)) {\n+        return (TypeAdapter<T>) ADAPTER;\n+      } else if (long.class.isAssignableFrom(cls)) {\n+        return (TypeAdapter<T>) ADAPTER;\n+      }\n+      throw new IllegalStateException(\"Non-long field of type \" + type\n+          + \" annotated with @JsonAdapter(LongToStringTypeAdapterFactory.class)\");\n+    }\n+  }\n }\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n     assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n   }\n \n+  public void testInvalidJsonInput() throws IOException {\n+    String json = \"{\\n\"\n+        + \"   \\\"h\\\\ello\\\": true,\\n\"\n+        + \"   \\\"foo\\\": [\\\"world\\\"]\\n\"\n+        + \"}\";\n+\n+    JsonReader reader = new JsonReader(reader(json));\n+    reader.beginObject();\n+    try {\n+      reader.nextName();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+  \n   public void testNulls() {\n     try {\n       new JsonReader(null);\n--- a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java\n+++ b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java\n           String jsonFieldName =\n               getCustSerializedName(fieldDescriptor.getOptions(), fieldDescriptor.getName());\n \n-          if (jsonObject.has(jsonFieldName)) {\n-            JsonElement jsonElement = jsonObject.get(jsonFieldName);\n+          JsonElement jsonElement = jsonObject.get(jsonFieldName);\n+          if (jsonElement != null && !jsonElement.isJsonNull()) {\n             // Do not reuse jsonFieldName here, it might have a custom value\n             Object fieldValue;\n             if (fieldDescriptor.getType() == ENUM_TYPE) {\n--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java\n+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java\n     assertEquals(\"foo\", proto.getMsg());\n     assertEquals(3, proto.getCount());\n   }\n+\n+  public void testDeserializeWithExplicitNullValue() {\n+    SimpleProto proto = gson.fromJson(\"{msg:'foo',count:null}\", SimpleProto.class);\n+    assertEquals(\"foo\", proto.getMsg());\n+    assertEquals(0, proto.getCount());\n+  }\n+\n }", "timestamp": 1465540344, "metainfo": ""}