{"sha": "45511fdd1534aa4fcc3c560ac4c0b439d94fc2ad", "log": "Added support for JsonSerializer/JsonDeserializer for JsonAdapter annotation. JsonAdapter is cached per the type of the JsonAdapter class. Added a test to ensure JsonAdapter works on fields of parameterized types Keep track of registered JsonAdapters and JsonAdapterFactorys in ThreadLocal.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   private final boolean generateNonExecutableJson;\n   private final boolean prettyPrinting;\n   private final boolean lenient;\n+  private JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\n \n   /**\n    * Constructs a Gson object with default configuration. The default configuration has the\n     // type adapters for composite and user-defined types\n     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n-    factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\n+    this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\n+    factories.add(jsonAdapterFactory);\n     factories.add(TypeAdapters.ENUM_FACTORY);\n     factories.add(new ReflectiveTypeAdapterFactory(\n-        constructorConstructor, fieldNamingStrategy, excluder));\n+        constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n \n     this.factories = Collections.unmodifiableList(factories);\n   }\n    * @since 2.2\n    */\n   public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\n-    boolean skipPastFound = false;\n-    // Skip past if and only if the specified factory is present in the factories.\n-    // This is useful because the factories created through JsonAdapter annotations are not\n-    // registered in this list.\n-    if (!factories.contains(skipPast)) skipPastFound = true;\n+    // If the specified skipPast factory is not registered, ignore it.\n+    boolean skipPastFound = skipPast == null\n+        || (!factories.contains(skipPast) && jsonAdapterFactory.getDelegateAdapterFactory(type) == null);\n \n     for (TypeAdapterFactory factory : factories) {\n       if (!skipPastFound) {\n-        if (factory == skipPast) {\n-          skipPastFound = true;\n+        skipPastFound = factory == skipPast;\n+        if (!skipPastFound && factory instanceof JsonAdapterAnnotationTypeAdapterFactory) {\n+          // Also check if there is a registered JsonAdapter for it\n+          factory = ((JsonAdapterAnnotationTypeAdapterFactory)factory).getDelegateAdapterFactory(type);\n+          skipPastFound = factory == skipPast;\n         }\n         continue;\n       }\n-\n       TypeAdapter<T> candidate = factory.create(this, type);\n       if (candidate != null) {\n         return candidate;\n       }\n     }\n-    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n+    throw new IllegalArgumentException(\"GSON cannot serialize or deserialize \" + type);\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n \n package com.google.gson.internal.bind;\n \n+import java.util.HashMap;\n+import java.util.Map;\n+\n import com.google.gson.Gson;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonSerializer;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n import com.google.gson.annotations.JsonAdapter;\n  */\n public final class JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory {\n \n+  @SuppressWarnings(\"rawtypes\")\n+  private final ThreadLocal<Map<Class, TypeAdapter>> activeJsonAdapterClasses = new ThreadLocal<Map<Class, TypeAdapter>>() {\n+    @Override protected Map<Class, TypeAdapter> initialValue() {\n+      // No need for a thread-safe map since we are using it in a single thread\n+      return new HashMap<Class, TypeAdapter>();\n+    }\n+  };\n+  @SuppressWarnings(\"rawtypes\")\n+  private final ThreadLocal<Map<Class, TypeAdapterFactory>> activeJsonAdapterFactories = new ThreadLocal<Map<Class, TypeAdapterFactory>>() {\n+    @Override protected Map<Class, TypeAdapterFactory> initialValue() {\n+      // No need for a thread-safe map since we are using it in a single thread\n+      return new HashMap<Class, TypeAdapterFactory>();\n+    }\n+  };\n+\n   private final ConstructorConstructor constructorConstructor;\n \n   public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n   @SuppressWarnings(\"unchecked\")\n   @Override\n   public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n-    JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\n+    Class<? super T> rawType = targetType.getRawType();\n+    JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\n     if (annotation == null) {\n       return null;\n     }\n     return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n   }\n \n-  @SuppressWarnings(\"unchecked\") // Casts guarded by conditionals.\n-  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n-      TypeToken<?> fieldType, JsonAdapter annotation) {\n+  public <T> TypeAdapter<T> getDelegateAdapter(Gson gson, TypeAdapterFactory skipPast, TypeToken<T> targetType) {\n+    TypeAdapterFactory factory = getDelegateAdapterFactory(targetType);\n+    if (factory == skipPast) factory = null;\n+    return factory == null ? null: factory.create(gson, targetType);\n+  }\n+\n+  public <T> TypeAdapterFactory getDelegateAdapterFactory(TypeToken<T> targetType) {\n+    Class<?> annotatedClass = targetType.getRawType();\n+    JsonAdapter annotation = annotatedClass.getAnnotation(JsonAdapter.class);\n+    if (annotation == null) {\n+      return null;\n+    }\n+    return getTypeAdapterFactory(annotation, constructorConstructor);\n+  }\n+\n+  @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // Casts guarded by conditionals.\n+  TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n+      TypeToken<?> type, JsonAdapter annotation) {\n     Class<?> value = annotation.value();\n+    boolean isTypeAdapter = TypeAdapter.class.isAssignableFrom(value);\n+    boolean isJsonSerializer = JsonSerializer.class.isAssignableFrom(value);\n+    boolean isJsonDeserializer = JsonDeserializer.class.isAssignableFrom(value);\n+\n     TypeAdapter<?> typeAdapter;\n-    if (TypeAdapter.class.isAssignableFrom(value)) {\n-      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n-      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n+    if (isTypeAdapter || isJsonSerializer || isJsonDeserializer) {\n+      Map<Class, TypeAdapter> adapters = activeJsonAdapterClasses.get();\n+      typeAdapter = adapters.get(value);\n+      if (typeAdapter == null) {\n+        if (isTypeAdapter) {\n+          Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n+          typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n+        } else if (isJsonSerializer || isJsonDeserializer) {\n+          JsonSerializer serializer = null;\n+          if (isJsonSerializer) {\n+            Class<JsonSerializer<?>> serializerClass = (Class<JsonSerializer<?>>) value;\n+            serializer = constructorConstructor.get(TypeToken.get(serializerClass)).construct();\n+          }\n+          JsonDeserializer deserializer = null;\n+          if (isJsonDeserializer) {\n+            Class<JsonDeserializer<?>> deserializerClass = (Class<JsonDeserializer<?>>) value;\n+            deserializer = constructorConstructor.get(TypeToken.get(deserializerClass)).construct();\n+          }\n+          typeAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null);\n+        }\n+        adapters.put(value, typeAdapter);\n+      }\n     } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n-      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n-      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n-          .construct()\n-          .create(gson, fieldType);\n+      TypeAdapterFactory factory = getTypeAdapterFactory(annotation, constructorConstructor);\n+      typeAdapter = factory == null ? null : factory.create(gson, type);\n     } else {\n       throw new IllegalArgumentException(\n-          \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n+          \"@JsonAdapter value must be TypeAdapter, TypeAdapterFactory, JsonSerializer or JsonDeserializer reference.\");\n     }\n     if (typeAdapter != null) {\n       typeAdapter = typeAdapter.nullSafe();\n     }\n     return typeAdapter;\n   }\n+\n+\n+  @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // Casts guarded by conditionals.\n+  TypeAdapterFactory getTypeAdapterFactory(JsonAdapter annotation, ConstructorConstructor constructorConstructor) {\n+    Class<?> value = annotation.value();\n+    if (!TypeAdapterFactory.class.isAssignableFrom(value)) return null;\n+    Map<Class, TypeAdapterFactory> adapterFactories = activeJsonAdapterFactories.get();\n+    TypeAdapterFactory factory = adapterFactories.get(value);\n+    if (factory == null) {\n+      Class<TypeAdapterFactory> typeAdapterFactoryClass = (Class<TypeAdapterFactory>) value;\n+      factory = constructorConstructor.get(TypeToken.get(typeAdapterFactoryClass))\n+          .construct();\n+      adapterFactories.put(value, factory);\n+    }\n+    return factory;\n+  }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n import java.util.List;\n import java.util.Map;\n \n-import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;\n-\n /**\n  * Type adapter that reflects over the fields and methods of a class.\n  */\n   private final ConstructorConstructor constructorConstructor;\n   private final FieldNamingStrategy fieldNamingPolicy;\n   private final Excluder excluder;\n+  private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\n \n   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n-      FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\n+      FieldNamingStrategy fieldNamingPolicy, Excluder excluder,\n+      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\n     this.constructorConstructor = constructorConstructor;\n     this.fieldNamingPolicy = fieldNamingPolicy;\n     this.excluder = excluder;\n+    this.jsonAdapterFactory = jsonAdapterFactory;\n   }\n \n   public boolean excludeField(Field f, boolean serialize) {\n     JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n     TypeAdapter<?> mapped = null;\n     if (annotation != null) {\n-      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n+      mapped = jsonAdapterFactory.getTypeAdapter(\n+                constructorConstructor, context, fieldType, annotation);\n     }\n     final boolean jsonAdapterPresent = mapped != null;\n     if (mapped == null) mapped = context.getAdapter(fieldType);\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n \n package com.google.gson.functional;\n \n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n-import java.io.IOException;\n+\n import junit.framework.TestCase;\n \n /**\n           + \" annotated with @JsonAdapter(LongToStringTypeAdapterFactory.class)\");\n     }\n   }\n+\n+  public void testFieldAnnotationWorksForParameterizedType() {\n+      Gson gson = new Gson();\n+      String json = gson.toJson(new Gizmo2(Arrays.asList(new Part(\"Part\"))));\n+      assertEquals(\"{\\\"part\\\":\\\"GizmoPartTypeAdapterFactory\\\"}\", json);\n+      Gizmo2 computer = gson.fromJson(\"{'part':'Part'}\", Gizmo2.class);\n+      assertEquals(\"GizmoPartTypeAdapterFactory\", computer.part.get(0).name);\n+    }\n+\n+  private static final class Gizmo2 {\n+      @JsonAdapter(Gizmo2PartTypeAdapterFactory.class)\n+      List<Part> part;\n+      Gizmo2(List<Part> part) {\n+        this.part = part;\n+      }\n+    }\n+\n+  private static class Gizmo2PartTypeAdapterFactory implements TypeAdapterFactory {\n+    @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n+      return new TypeAdapter<T>() {\n+        @Override public void write(JsonWriter out, T value) throws IOException {\n+          out.value(\"GizmoPartTypeAdapterFactory\");\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        @Override public T read(JsonReader in) throws IOException {\n+          in.nextString();\n+          return (T) Arrays.asList(new Part(\"GizmoPartTypeAdapterFactory\"));\n+        }\n+      };\n+    }\n+  }\n }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import java.lang.reflect.Type;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+import com.google.gson.annotations.JsonAdapter;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Functional tests for the {@link JsonAdapter} annotation on fields where the value is of\n+ * type {@link JsonSerializer} or {@link JsonDeserializer}.\n+ */\n+public final class JsonAdapterSerializerDeserializerTest extends TestCase {\n+\n+  public void testJsonSerializerDeserializerBasedJsonAdapterOnFields() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new Computer(new User(\"Inderjeet Singh\"), null, new User(\"Jesse Wilson\")));\n+    assertEquals(\"{\\\"user1\\\":\\\"UserSerializer\\\",\\\"user3\\\":\\\"UserSerializerDeserializer\\\"}\", json);\n+    Computer computer = gson.fromJson(\"{'user2':'Jesse Wilson','user3':'Jake Wharton'}\", Computer.class);\n+    assertEquals(\"UserSerializer\", computer.user2.name);\n+    assertEquals(\"UserSerializerDeserializer\", computer.user3.name);\n+  }\n+\n+  private static final class Computer {\n+    @JsonAdapter(UserSerializer.class) final User user1;\n+    @JsonAdapter(UserDeserializer.class) final User user2;\n+    @JsonAdapter(UserSerializerDeserializer.class) final User user3;\n+    Computer(User user1, User user2, User user3) {\n+      this.user1 = user1;\n+      this.user2 = user2;\n+      this.user3 = user3;\n+    }\n+  }\n+\n+  private static final class User {\n+    public final String name;\n+    private User(String name) {\n+      this.name = name;\n+    }\n+  }\n+\n+  private static final class UserSerializer implements JsonSerializer<User> {\n+    @Override\n+    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(\"UserSerializer\");\n+    }\n+  }\n+\n+  private static final class UserDeserializer implements JsonDeserializer<User> {\n+    @Override\n+    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return new User(\"UserSerializer\");\n+    }\n+  }\n+\n+  private static final class UserSerializerDeserializer implements JsonSerializer<User>, JsonDeserializer<User> {\n+    @Override\n+    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(\"UserSerializerDeserializer\");\n+    }\n+    @Override\n+    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return new User(\"UserSerializerDeserializer\");\n+    }\n+  }\n+\n+  public void testJsonSerializerDeserializerBasedJsonAdapterOnClass() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new Computer2(new User2(\"Inderjeet Singh\")));\n+    assertEquals(\"{\\\"user\\\":\\\"UserSerializerDeserializer2\\\"}\", json);\n+    Computer2 computer = gson.fromJson(\"{'user':'Inderjeet Singh'}\", Computer2.class);\n+    assertEquals(\"UserSerializerDeserializer2\", computer.user.name);\n+  }\n+\n+  private static final class Computer2 {\n+    final User2 user;\n+    Computer2(User2 user) {\n+      this.user = user;\n+    }\n+  }\n+\n+  @JsonAdapter(UserSerializerDeserializer2.class)\n+  private static final class User2 {\n+    public final String name;\n+    private User2(String name) {\n+      this.name = name;\n+    }\n+  }\n+\n+  private static final class UserSerializerDeserializer2 implements JsonSerializer<User2>, JsonDeserializer<User2> {\n+    @Override\n+    public JsonElement serialize(User2 src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(\"UserSerializerDeserializer2\");\n+    }\n+    @Override\n+    public User2 deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return new User2(\"UserSerializerDeserializer2\");\n+    }\n+  }\n+\n+  public void testDifferentJsonAdaptersForGenericFieldsOfSameRawType() {\n+    Container c = new Container(\"Foo\", 10);\n+    Gson gson = new Gson();\n+    String json = gson.toJson(c);\n+    assertTrue(json.contains(\"\\\"a\\\":\\\"BaseStringAdapter\\\"\"));\n+    assertTrue(json.contains(\"\\\"b\\\":\\\"BaseIntegerAdapter\\\"\"));\n+  }\n+\n+  private static final class Container {\n+    @JsonAdapter(BaseStringAdapter.class) Base<String> a;\n+    @JsonAdapter(BaseIntegerAdapter.class) Base<Integer> b;\n+    Container(String a, int b) {\n+      this.a = new Base<String>(a);\n+      this.b = new Base<Integer>(b);\n+    }\n+  }\n+\n+  private static final class Base<T> {\n+    @SuppressWarnings(\"unused\")\n+    T value;\n+    Base(T value) {\n+      this.value = value;\n+    }\n+  }\n+\n+  private static final class BaseStringAdapter implements JsonSerializer<Base<String>> {\n+    @Override public JsonElement serialize(Base<String> src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(\"BaseStringAdapter\");\n+    }\n+  }\n+\n+  private static final class BaseIntegerAdapter implements JsonSerializer<Base<Integer>> {\n+    @Override public JsonElement serialize(Base<Integer> src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(\"BaseIntegerAdapter\");\n+    }\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java\n    * This test also ensures that {@link TypeAdapterFactory} registered through {@link JsonAdapter}\n    * work correctly for {@link Gson#getDelegateAdapter(TypeAdapterFactory, TypeToken)}.\n    */\n-  public void testSubclassesAutomaticallySerialzed() throws Exception {\n+  public void testSubclassesAutomaticallySerialized() throws Exception {\n     Shape shape = new Circle(25);\n     String json = gson.toJson(shape);\n     shape = gson.fromJson(json, Shape.class);", "timestamp": 1464840505, "metainfo": ""}