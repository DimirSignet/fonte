{"sha": "ebad966efd8dfaf950b8e93fd39041e7fc5c4a27", "log": "Merge pull request #870 from google/jw/reader-location  Consolidate location and path rendering for exceptions.", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n       pathIndices[stackSize - 1] = 0;\n       peeked = PEEKED_NONE;\n     } else {\n-      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n     }\n   }\n \n       pathIndices[stackSize - 1]++;\n       peeked = PEEKED_NONE;\n     } else {\n-      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + locationString());\n     }\n   }\n \n       push(JsonScope.EMPTY_OBJECT);\n       peeked = PEEKED_NONE;\n     } else {\n-      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\n     }\n   }\n \n       pathIndices[stackSize - 1]++;\n       peeked = PEEKED_NONE;\n     } else {\n-      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\n     }\n   }\n \n     } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n       result = nextQuotedValue('\"');\n     } else {\n-      throw new IllegalStateException(\"Expected a name but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n     }\n     peeked = PEEKED_NONE;\n     pathNames[stackSize - 1] = result;\n       result = new String(buffer, pos, peekedNumberLength);\n       pos += peekedNumberLength;\n     } else {\n-      throw new IllegalStateException(\"Expected a string but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n     }\n     peeked = PEEKED_NONE;\n     pathIndices[stackSize - 1]++;\n       pathIndices[stackSize - 1]++;\n       return false;\n     }\n-    throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n-        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n   }\n \n   /**\n       peeked = PEEKED_NONE;\n       pathIndices[stackSize - 1]++;\n     } else {\n-      throw new IllegalStateException(\"Expected null but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected null but was \" + peek() + locationString());\n     }\n   }\n \n     } else if (p == PEEKED_UNQUOTED) {\n       peekedString = nextUnquotedValue();\n     } else if (p != PEEKED_BUFFERED) {\n-      throw new IllegalStateException(\"Expected a double but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n     }\n \n     peeked = PEEKED_BUFFERED;\n     double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n-      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new MalformedJsonException(\n+          \"JSON forbids NaN and infinities: \" + result + locationString());\n     }\n     peekedString = null;\n     peeked = PEEKED_NONE;\n         // Fall back to parse as a double below.\n       }\n     } else {\n-      throw new IllegalStateException(\"Expected a long but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected a long but was \" + peek() + locationString());\n     }\n \n     peeked = PEEKED_BUFFERED;\n     double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n     long result = (long) asDouble;\n     if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n-      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\n     }\n     peekedString = null;\n     peeked = PEEKED_NONE;\n     if (p == PEEKED_LONG) {\n       result = (int) peekedLong;\n       if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n-        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n-            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+        throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\n       }\n       peeked = PEEKED_NONE;\n       pathIndices[stackSize - 1]++;\n         // Fall back to parse as a double below.\n       }\n     } else {\n-      throw new IllegalStateException(\"Expected an int but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected an int but was \" + peek() + locationString());\n     }\n \n     peeked = PEEKED_BUFFERED;\n     double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n     result = (int) asDouble;\n     if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n-      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\n     }\n     peekedString = null;\n     peeked = PEEKED_NONE;\n     return false;\n   }\n \n-  int getLineNumber() {\n-    return lineNumber + 1;\n-  }\n-\n-  int getColumnNumber() {\n-    return pos - lineStart + 1;\n-  }\n-\n   /**\n    * Returns the next character in the stream that is neither whitespace nor a\n    * part of a comment. When this returns, the returned character is always at\n       }\n     }\n     if (throwOnEof) {\n-      throw new EOFException(\"End of input\"\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+      throw new EOFException(\"End of input\" + locationString());\n     } else {\n       return -1;\n     }\n   }\n \n   @Override public String toString() {\n-    return getClass().getSimpleName()\n-        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber();\n+    return getClass().getSimpleName() + locationString();\n+  }\n+\n+  private String locationString() {\n+    int line = lineNumber + 1;\n+    int column = pos - lineStart + 1;\n+    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\n   }\n \n   /**\n    * with this reader's content.\n    */\n   private IOException syntaxError(String message) throws IOException {\n-    throw new MalformedJsonException(message\n-        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+    throw new MalformedJsonException(message + locationString());\n   }\n \n   /**\n         } else if (p == PEEKED_UNQUOTED_NAME) {\n           reader.peeked = PEEKED_UNQUOTED;\n         } else {\n-          throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n-              + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n-              + \" path \" + reader.getPath());\n+          throw new IllegalStateException(\n+              \"Expected a name but was \" + reader.peek() + reader.locationString());\n         }\n       }\n     };\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n  * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field\n  * name to the {@link #of} factory method. If you don't supply an explicit type\n  * field name, {@code \"type\"} will be used. <pre>   {@code\n- *   RuntimeTypeAdapterFactory<Shape> shapeAdapter\n+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory\n  *       = RuntimeTypeAdapterFactory.of(Shape.class, \"type\");\n  * }</pre>\n  * Next register all of your subtypes. Every subtype must be explicitly\n  *   shapeAdapter.registerSubtype(Circle.class, \"Circle\");\n  *   shapeAdapter.registerSubtype(Diamond.class, \"Diamond\");\n  * }</pre>\n- * Finally, register the type adapter in your application's GSON builder:\n+ * Finally, register the type adapter factory in your application's GSON builder:\n  * <pre>   {@code\n  *   Gson gson = new GsonBuilder()\n- *       .registerTypeAdapter(Shape.class, shapeAdapter)\n+ *       .registerTypeAdapterFactory(shapeAdapterFactory)\n  *       .create();\n  * }</pre>\n  * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code\n- *   RuntimeTypeAdapterFactory<Shape> shapeAdapter = RuntimeTypeAdapterFactory.of(Shape.class)\n+ *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)\n  *       .registerSubtype(Rectangle.class)\n  *       .registerSubtype(Circle.class)\n  *       .registerSubtype(Diamond.class);\n--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n import java.text.SimpleDateFormat;\n import java.util.Date;\n import java.util.Locale;\n-import java.util.TimeZone;\n \n import com.google.gson.internal.bind.util.ISO8601Utils;\n \n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   }\n \n   /**\n-   * Returns a new JSON writer configured for the settings on this Gson instance.\n+   * Returns a new JSON reader configured for the settings on this Gson instance.\n    */\n   public JsonReader newJsonReader(Reader reader) {\n     JsonReader jsonReader = new JsonReader(reader);\n--- a/gson/src/main/java/com/google/gson/internal/Streams.java\n+++ b/gson/src/main/java/com/google/gson/internal/Streams.java\n     TypeAdapters.JSON_ELEMENT.write(writer, element);\n   }\n \n-  @SuppressWarnings(\"resource\")\n   public static Writer writerForAppendable(Appendable appendable) {\n     return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\n   }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+\n import java.io.IOException;\n import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n     // special casing primitives here saves ~5% on Android...\n+    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n+    TypeAdapter<?> mapped = null;\n+    if (annotation != null) {\n+      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n+    }\n+    final boolean jsonAdapterPresent = mapped != null;\n+    if (mapped == null) mapped = context.getAdapter(fieldType);\n+\n+    final TypeAdapter<?> typeAdapter = mapped;\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n-      final TypeAdapter<?> typeAdapter = getFieldAdapter(context, field, fieldType);\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n+        TypeAdapter t = jsonAdapterPresent ? typeAdapter\n+            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n         return fieldValue != value; // avoid recursion for example for Throwable.cause\n       }\n     };\n-  }\n-\n-  TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {\n-    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n-    if (annotation != null) {\n-      TypeAdapter<?> adapter = getTypeAdapter(constructorConstructor, gson, fieldType, annotation);\n-      if (adapter != null) return adapter;\n-    }\n-    return gson.getAdapter(fieldType);\n   }\n \n   private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n  */\n package com.google.gson.internal.bind;\n \n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+\n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n-import java.io.IOException;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n \n final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {\n   private final Gson context;\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n           constantToName.put(constant, name);\n         }\n       } catch (NoSuchFieldException e) {\n-        throw new AssertionError(\"Missing field in \" + classOfT.getName(), e);\n+        throw new AssertionError(e);\n       }\n     }\n     @Override public T read(JsonReader in) throws IOException {\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n     case '\\'':\n     case '\"':\n     case '\\\\':\n+    case '/':\t\n+    \treturn escaped;\n     default:\n-      return escaped;\n+    \t// throw error when none of the above cases are matched\n+    \tthrow syntaxError(\"Invalid escape sequence\");\n     }\n   }\n \n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n         @Override public void write(JsonWriter out, Part part) throws IOException {\n           throw new AssertionError();\n         }\n-\n         @Override public Part read(JsonReader in) throws IOException {\n           throw new AssertionError();\n         }\n       this.part = part;\n     }\n   }\n+\n+  /** Regression test contributed through https://github.com/google/gson/issues/831 */\n+  public void testNonPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new GadgetWithOptionalPart(new Part(\"foo\")));\n+    assertEquals(\"{\\\"part\\\":\\\"PartJsonFieldAnnotationAdapter\\\"}\", json);\n+    GadgetWithOptionalPart gadget = gson.fromJson(\"{'part':'foo'}\", GadgetWithOptionalPart.class);\n+    assertEquals(\"PartJsonFieldAnnotationAdapter\", gadget.part.name);\n+  }\n+\n+  /** Regression test contributed through https://github.com/google/gson/issues/831 */\n+  public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new GadgetWithPrimitivePart(42));\n+    assertEquals(\"{\\\"part\\\":\\\"42\\\"}\", json);\n+    GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class);\n+    assertEquals(42, gadget.part);\n+  }\n+\n+  private static final class GadgetWithPrimitivePart {\n+    @JsonAdapter(LongToStringTypeAdapterFactory.class)\n+    final long part;\n+\n+    private GadgetWithPrimitivePart(long part) {\n+      this.part = part;\n+    }\n+  }\n+\n+  private static final class LongToStringTypeAdapterFactory implements TypeAdapterFactory {\n+    static final TypeAdapter<Long> ADAPTER = new TypeAdapter<Long>() {\n+      @Override public void write(JsonWriter out, Long value) throws IOException {\n+        out.value(value.toString());\n+      }\n+      @Override public Long read(JsonReader in) throws IOException {\n+        return in.nextLong();\n+      }\n+    };\n+    @SuppressWarnings(\"unchecked\")\n+    @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n+      Class<?> cls = type.getRawType();\n+      if (Long.class.isAssignableFrom(cls)) {\n+        return (TypeAdapter<T>) ADAPTER;\n+      } else if (long.class.isAssignableFrom(cls)) {\n+        return (TypeAdapter<T>) ADAPTER;\n+      }\n+      throw new IllegalStateException(\"Non-long field of type \" + type\n+          + \" annotated with @JsonAdapter(LongToStringTypeAdapterFactory.class)\");\n+    }\n+  }\n }\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n     assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n   }\n \n+  public void testInvalidJsonInput() throws IOException {\n+    String json = \"{\\n\"\n+        + \"   \\\"h\\\\ello\\\": true,\\n\"\n+        + \"   \\\"foo\\\": [\\\"world\\\"]\\n\"\n+        + \"}\";\n+\n+    JsonReader reader = new JsonReader(reader(json));\n+    reader.beginObject();\n+    try {\n+      reader.nextName();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+  \n   public void testNulls() {\n     try {\n       new JsonReader(null);\n--- a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java\n+++ b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java\n           String jsonFieldName =\n               getCustSerializedName(fieldDescriptor.getOptions(), fieldDescriptor.getName());\n \n-          if (jsonObject.has(jsonFieldName)) {\n-            JsonElement jsonElement = jsonObject.get(jsonFieldName);\n+          JsonElement jsonElement = jsonObject.get(jsonFieldName);\n+          if (jsonElement != null && !jsonElement.isJsonNull()) {\n             // Do not reuse jsonFieldName here, it might have a custom value\n             Object fieldValue;\n             if (fieldDescriptor.getType() == ENUM_TYPE) {\n--- a/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java\n+++ b/proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java\n     assertEquals(\"foo\", proto.getMsg());\n     assertEquals(3, proto.getCount());\n   }\n+\n+  public void testDeserializeWithExplicitNullValue() {\n+    SimpleProto proto = gson.fromJson(\"{msg:'foo',count:null}\", SimpleProto.class);\n+    assertEquals(\"foo\", proto.getMsg());\n+    assertEquals(0, proto.getCount());\n+  }\n+\n }", "timestamp": 1465511170, "metainfo": ""}