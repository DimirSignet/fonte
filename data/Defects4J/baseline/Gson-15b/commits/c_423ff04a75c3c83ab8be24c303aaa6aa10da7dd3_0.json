{"sha": "423ff04a75c3c83ab8be24c303aaa6aa10da7dd3", "log": "Merge pull request #1037 from guptasourabh/master  elimiating code overhead", "commit": "\n--- a/gson/src/main/java/com/google/gson/FieldNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java\n       firstCharacter = name.charAt(++index);\n     }\n \n-    if (index == length) {\n-      return fieldNameBuilder.toString();\n-    }\n-\n     if (!Character.isUpperCase(firstCharacter)) {\n       String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), name, ++index);\n       return fieldNameBuilder.append(modifiedTarget).toString();\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n \n       if (hasComplexKeys) {\n         out.beginArray();\n-        for (int i = 0; i < keys.size(); i++) {\n+        for (int i = 0, size = keys.size(); i < size; i++) {\n           out.beginArray(); // entry array\n           Streams.write(keys.get(i), out);\n           valueTypeAdapter.write(out, values.get(i));\n         out.endArray();\n       } else {\n         out.beginObject();\n-        for (int i = 0; i < keys.size(); i++) {\n+        for (int i = 0, size = keys.size(); i < size; i++) {\n           JsonElement keyElement = keys.get(i);\n           out.name(keyToString(keyElement));\n           valueTypeAdapter.write(out, values.get(i));\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n package com.google.gson;\n \n-import com.google.gson.stream.JsonReader;\n import java.lang.reflect.Type;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import com.google.gson.internal.bind.TreeTypeAdapter;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n \n import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;\n import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;\n         || typeAdapter instanceof JsonDeserializer<?>\n         || typeAdapter instanceof TypeAdapter<?>);\n     if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {\n-      hierarchyFactories.add(0,\n-          TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\n+      hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\n     }\n     if (typeAdapter instanceof TypeAdapter<?>) {\n       factories.add(TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter)typeAdapter));\n    * @return an instance of Gson configured with the options currently set in this builder\n    */\n   public Gson create() {\n-    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n+    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>(this.factories.size() + this.hierarchyFactories.size() + 3);\n     factories.addAll(this.factories);\n     Collections.reverse(factories);\n+    Collections.reverse(this.hierarchyFactories);\n     factories.addAll(this.hierarchyFactories);\n     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);\n \n--- a/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java\n+++ b/proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java\n               if (jsonElement.isJsonArray()) {\n                 // Handling array\n                 Collection<EnumValueDescriptor> enumCollection =\n-                    new ArrayList<EnumValueDescriptor>();\n+                    new ArrayList<EnumValueDescriptor>(jsonElement.getAsJsonArray().size());\n                 for (JsonElement element : jsonElement.getAsJsonArray()) {\n                   enumCollection.add(\n                       findValueByNameAndExtension(fieldDescriptor.getEnumType(), element));", "timestamp": 1489865649, "metainfo": ""}