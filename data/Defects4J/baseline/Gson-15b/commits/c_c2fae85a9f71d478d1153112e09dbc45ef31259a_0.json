{"sha": "c2fae85a9f71d478d1153112e09dbc45ef31259a", "log": "Implement JSON Path for JsonTreeReader.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n import com.google.gson.stream.JsonToken;\n import java.io.IOException;\n import java.io.Reader;\n-import java.util.ArrayList;\n import java.util.Iterator;\n-import java.util.List;\n import java.util.Map;\n \n /**\n   };\n   private static final Object SENTINEL_CLOSED = new Object();\n \n-  private final List<Object> stack = new ArrayList<Object>();\n+  /*\n+   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n+   */\n+  private Object[] stack = new Object[32];\n+  private int stackSize = 0;\n+\n+  /*\n+   * The path members. It corresponds directly to stack: At indices where the\n+   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n+   * pathNames contains the name at this scope. Where it contains an array\n+   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n+   * that array. Otherwise the value is undefined, and we take advantage of that\n+   * by incrementing pathIndices when doing so isn't useful.\n+   */\n+  private String[] pathNames = new String[32];\n+  private int[] pathIndices = new int[32];\n \n   public JsonTreeReader(JsonElement element) {\n     super(UNREADABLE_READER);\n-    stack.add(element);\n+    push(element);\n   }\n \n   @Override public void beginArray() throws IOException {\n     expect(JsonToken.BEGIN_ARRAY);\n     JsonArray array = (JsonArray) peekStack();\n-    stack.add(array.iterator());\n+    push(array.iterator());\n+    pathIndices[stackSize - 1] = 0;\n   }\n \n   @Override public void endArray() throws IOException {\n     expect(JsonToken.END_ARRAY);\n     popStack(); // empty iterator\n     popStack(); // array\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n   }\n \n   @Override public void beginObject() throws IOException {\n     expect(JsonToken.BEGIN_OBJECT);\n     JsonObject object = (JsonObject) peekStack();\n-    stack.add(object.entrySet().iterator());\n+    push(object.entrySet().iterator());\n   }\n \n   @Override public void endObject() throws IOException {\n     expect(JsonToken.END_OBJECT);\n     popStack(); // empty iterator\n     popStack(); // object\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n   }\n \n   @Override public boolean hasNext() throws IOException {\n   }\n \n   @Override public JsonToken peek() throws IOException {\n-    if (stack.isEmpty()) {\n+    if (stackSize == 0) {\n       return JsonToken.END_DOCUMENT;\n     }\n \n     Object o = peekStack();\n     if (o instanceof Iterator) {\n-      boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;\n+      boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n       Iterator<?> iterator = (Iterator<?>) o;\n       if (iterator.hasNext()) {\n         if (isObject) {\n           return JsonToken.NAME;\n         } else {\n-          stack.add(iterator.next());\n+          push(iterator.next());\n           return peek();\n         }\n       } else {\n   }\n \n   private Object peekStack() {\n-    return stack.get(stack.size() - 1);\n+    return stack[stackSize - 1];\n   }\n \n   private Object popStack() {\n-    return stack.remove(stack.size() - 1);\n+    Object result = stack[--stackSize];\n+    stack[stackSize] = null;\n+    return result;\n   }\n \n   private void expect(JsonToken expected) throws IOException {\n     if (peek() != expected) {\n-      throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek());\n+      throw new IllegalStateException(\n+          \"Expected \" + expected + \" but was \" + peek() + locationString());\n     }\n   }\n \n     expect(JsonToken.NAME);\n     Iterator<?> i = (Iterator<?>) peekStack();\n     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n-    stack.add(entry.getValue());\n-    return (String) entry.getKey();\n+    String result = (String) entry.getKey();\n+    pathNames[stackSize - 1] = result;\n+    push(entry.getValue());\n+    return result;\n   }\n \n   @Override public String nextString() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token);\n-    }\n-    return ((JsonPrimitive) popStack()).getAsString();\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n+    }\n+    String result = ((JsonPrimitive) popStack()).getAsString();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n+    return result;\n   }\n \n   @Override public boolean nextBoolean() throws IOException {\n     expect(JsonToken.BOOLEAN);\n-    return ((JsonPrimitive) popStack()).getAsBoolean();\n+    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n+    return result;\n   }\n \n   @Override public void nextNull() throws IOException {\n     expect(JsonToken.NULL);\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n   }\n \n   @Override public double nextDouble() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     double result = ((JsonPrimitive) peekStack()).getAsDouble();\n     if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n       throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n     }\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n     return result;\n   }\n \n   @Override public long nextLong() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     long result = ((JsonPrimitive) peekStack()).getAsLong();\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n     return result;\n   }\n \n   @Override public int nextInt() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     int result = ((JsonPrimitive) peekStack()).getAsInt();\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n     return result;\n   }\n \n   @Override public void close() throws IOException {\n-    stack.clear();\n-    stack.add(SENTINEL_CLOSED);\n+    stack = new Object[] { SENTINEL_CLOSED };\n+    stackSize = 1;\n   }\n \n   @Override public void skipValue() throws IOException {\n     if (peek() == JsonToken.NAME) {\n       nextName();\n+      pathNames[stackSize - 2] = \"null\";\n     } else {\n       popStack();\n-    }\n+      pathNames[stackSize - 1] = \"null\";\n+    }\n+    pathIndices[stackSize - 1]++;\n   }\n \n   @Override public String toString() {\n     expect(JsonToken.NAME);\n     Iterator<?> i = (Iterator<?>) peekStack();\n     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n-    stack.add(entry.getValue());\n-    stack.add(new JsonPrimitive((String)entry.getKey()));\n+    push(entry.getValue());\n+    push(new JsonPrimitive((String) entry.getKey()));\n+  }\n+\n+  private void push(Object newTop) {\n+    if (stackSize == stack.length) {\n+      Object[] newStack = new Object[stackSize * 2];\n+      int[] newPathIndices = new int[stackSize * 2];\n+      String[] newPathNames = new String[stackSize * 2];\n+      System.arraycopy(stack, 0, newStack, 0, stackSize);\n+      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n+      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n+      stack = newStack;\n+      pathIndices = newPathIndices;\n+      pathNames = newPathNames;\n+    }\n+    stack[stackSize++] = newTop;\n+  }\n+\n+  @Override public String getPath() {\n+    StringBuilder result = new StringBuilder().append('$');\n+    for (int i = 0; i < stackSize; i++) {\n+      if (stack[i] instanceof JsonArray) {\n+        if (stack[++i] instanceof Iterator) {\n+          result.append('[').append(pathIndices[i]).append(']');\n+        }\n+      } else if (stack[i] instanceof JsonObject) {\n+        if (stack[++i] instanceof Iterator) {\n+          result.append('.');\n+          if (pathNames[i] != null) {\n+            result.append(pathNames[i]);\n+          }\n+        }\n+      }\n+    }\n+    return result.toString();\n+  }\n+\n+  private String locationString() {\n+    return \" at path \" + getPath();\n   }\n }\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java\n \n package com.google.gson.stream;\n \n+import com.google.gson.JsonElement;\n+import com.google.gson.internal.Streams;\n+import com.google.gson.internal.bind.JsonTreeReader;\n import java.io.IOException;\n import java.io.StringReader;\n-import junit.framework.TestCase;\n-\n-@SuppressWarnings(\"resource\")\n-public class JsonReaderPathTest extends TestCase {\n-  public void testPath() throws IOException {\n-    JsonReader reader = new JsonReader(\n-        new StringReader(\"{\\\"a\\\":[2,true,false,null,\\\"b\\\",{\\\"c\\\":\\\"d\\\"},[3]]}\"));\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static org.junit.Assume.assumeTrue;\n+\n+@RunWith(Parameterized.class)\n+public class JsonReaderPathTest {\n+  @Parameterized.Parameters(name = \"{0}\")\n+  public static List<Object[]> parameters() {\n+    return Arrays.asList(\n+        new Object[] { Factory.STRING_READER },\n+        new Object[] { Factory.OBJECT_READER }\n+    );\n+  }\n+\n+  @Parameterized.Parameter\n+  public Factory factory;\n+\n+  @Test public void path() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":[2,true,false,null,\\\"b\\\",{\\\"c\\\":\\\"d\\\"},[3]]}\");\n     assertEquals(\"$\", reader.getPath());\n     reader.beginObject();\n     assertEquals(\"$.\", reader.getPath());\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testObjectPath() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1,\\\"b\\\":2}\"));\n+  @Test public void objectPath() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":1,\\\"b\\\":2}\");\n     assertEquals(\"$\", reader.getPath());\n \n     reader.peek();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testArrayPath() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[1,2]\"));\n+  @Test public void arrayPath() throws IOException {\n+    JsonReader reader = factory.create(\"[1,2]\");\n     assertEquals(\"$\", reader.getPath());\n \n     reader.peek();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testMultipleTopLevelValuesInOneDocument() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[][]\"));\n+  @Test public void multipleTopLevelValuesInOneDocument() throws IOException {\n+    assumeTrue(factory == Factory.STRING_READER);\n+\n+    JsonReader reader = factory.create(\"[][]\");\n     reader.setLenient(true);\n     reader.beginArray();\n     reader.endArray();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testSkipArrayElements() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[1,2,3]\"));\n-    reader.beginArray();\n-    reader.skipValue();\n-    reader.skipValue();\n-    assertEquals(\"$[2]\", reader.getPath());\n-  }\n-\n-  public void testSkipObjectNames() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1}\"));\n+  @Test public void skipArrayElements() throws IOException {\n+    JsonReader reader = factory.create(\"[1,2,3]\");\n+    reader.beginArray();\n+    reader.skipValue();\n+    reader.skipValue();\n+    assertEquals(\"$[2]\", reader.getPath());\n+  }\n+\n+  @Test public void skipObjectNames() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":1}\");\n     reader.beginObject();\n     reader.skipValue();\n     assertEquals(\"$.null\", reader.getPath());\n   }\n \n-  public void testSkipObjectValues() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1,\\\"b\\\":2}\"));\n-    reader.beginObject();\n+  @Test public void skipObjectValues() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":1,\\\"b\\\":2}\");\n+    reader.beginObject();\n+    assertEquals(\"$.\", reader.getPath());\n     reader.nextName();\n     reader.skipValue();\n     assertEquals(\"$.null\", reader.getPath());\n     assertEquals(\"$.b\", reader.getPath());\n   }\n \n-  public void testSkipNestedStructures() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[[1,2,3],4]\"));\n-    reader.beginArray();\n-    reader.skipValue();\n-    assertEquals(\"$[1]\", reader.getPath());\n-  }\n-\n-  public void testArrayOfObjects() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[{},{},{}]\"));\n+  @Test public void skipNestedStructures() throws IOException {\n+    JsonReader reader = factory.create(\"[[1,2,3],4]\");\n+    reader.beginArray();\n+    reader.skipValue();\n+    assertEquals(\"$[1]\", reader.getPath());\n+  }\n+\n+  @Test public void arrayOfObjects() throws IOException {\n+    JsonReader reader = factory.create(\"[{},{},{}]\");\n     reader.beginArray();\n     assertEquals(\"$[0]\", reader.getPath());\n     reader.beginObject();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testArrayOfArrays() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[[],[],[]]\"));\n+  @Test public void arrayOfArrays() throws IOException {\n+    JsonReader reader = factory.create(\"[[],[],[]]\");\n     reader.beginArray();\n     assertEquals(\"$[0]\", reader.getPath());\n     reader.beginArray();\n     reader.endArray();\n     assertEquals(\"$\", reader.getPath());\n   }\n+\n+  enum Factory {\n+    STRING_READER {\n+      @Override public JsonReader create(String data) {\n+        return new JsonReader(new StringReader(data));\n+      }\n+    },\n+    OBJECT_READER {\n+      @Override public JsonReader create(String data) {\n+        JsonElement element = Streams.parse(new JsonReader(new StringReader(data)));\n+        return new JsonTreeReader(element);\n+      }\n+    };\n+\n+    abstract JsonReader create(String data);\n+  }\n }", "timestamp": 1465532068, "metainfo": ""}