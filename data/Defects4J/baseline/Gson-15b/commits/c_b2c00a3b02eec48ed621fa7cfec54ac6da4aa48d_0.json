{"sha": "b2c00a3b02eec48ed621fa7cfec54ac6da4aa48d", "log": "Merge pull request #873 from google/jwilson.0601.get_delegate_adapter  Add support for JsonSerializer/JsonDeserializer in the JsonAdapter annotation", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   private final boolean generateNonExecutableJson;\n   private final boolean prettyPrinting;\n   private final boolean lenient;\n+  private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\n \n   /**\n    * Constructs a Gson object with default configuration. The default configuration has the\n     // type adapters for composite and user-defined types\n     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n-    factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\n+    this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\n+    factories.add(jsonAdapterFactory);\n     factories.add(TypeAdapters.ENUM_FACTORY);\n     factories.add(new ReflectiveTypeAdapterFactory(\n-        constructorConstructor, fieldNamingStrategy, excluder));\n+        constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n \n     this.factories = Collections.unmodifiableList(factories);\n   }\n    * @since 2.2\n    */\n   public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\n+    // Hack. If the skipPast factory isn't registered, assume the factory is being requested via\n+    // our @JsonAdapter annotation.\n+    if (!factories.contains(skipPast)) {\n+      skipPast = jsonAdapterFactory;\n+    }\n+\n     boolean skipPastFound = false;\n-    // Skip past if and only if the specified factory is present in the factories.\n-    // This is useful because the factories created through JsonAdapter annotations are not\n-    // registered in this list.\n-    if (!factories.contains(skipPast)) skipPastFound = true;\n-\n     for (TypeAdapterFactory factory : factories) {\n       if (!skipPastFound) {\n         if (factory == skipPast) {\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n package com.google.gson.internal.bind;\n \n import com.google.gson.Gson;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonSerializer;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n import com.google.gson.annotations.JsonAdapter;\n  * @since 2.3\n  */\n public final class JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory {\n-\n   private final ConstructorConstructor constructorConstructor;\n \n   public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n   @SuppressWarnings(\"unchecked\")\n   @Override\n   public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n-    JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\n+    Class<? super T> rawType = targetType.getRawType();\n+    JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\n     if (annotation == null) {\n       return null;\n     }\n     return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n   }\n \n-  @SuppressWarnings(\"unchecked\") // Casts guarded by conditionals.\n-  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n-      TypeToken<?> fieldType, JsonAdapter annotation) {\n-    Class<?> value = annotation.value();\n+  @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // Casts guarded by conditionals.\n+  TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n+      TypeToken<?> type, JsonAdapter annotation) {\n+    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();\n+\n     TypeAdapter<?> typeAdapter;\n-    if (TypeAdapter.class.isAssignableFrom(value)) {\n-      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n-      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n-    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n-      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n-      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n-          .construct()\n-          .create(gson, fieldType);\n+    if (instance instanceof TypeAdapter) {\n+      typeAdapter = (TypeAdapter<?>) instance;\n+    } else if (instance instanceof TypeAdapterFactory) {\n+      typeAdapter = ((TypeAdapterFactory) instance).create(gson, type);\n+    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\n+      JsonSerializer<?> serializer = instance instanceof JsonSerializer\n+          ? (JsonSerializer) instance\n+          : null;\n+      JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer\n+          ? (JsonDeserializer) instance\n+          : null;\n+      typeAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null);\n     } else {\n       throw new IllegalArgumentException(\n-          \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n+          \"@JsonAdapter value must be TypeAdapter, TypeAdapterFactory, \"\n+              + \"JsonSerializer or JsonDeserializer reference.\");\n     }\n+\n     if (typeAdapter != null) {\n       typeAdapter = typeAdapter.nullSafe();\n     }\n+\n     return typeAdapter;\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n-\n import java.io.IOException;\n import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n import java.util.List;\n import java.util.Map;\n \n-import static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;\n-\n /**\n  * Type adapter that reflects over the fields and methods of a class.\n  */\n   private final ConstructorConstructor constructorConstructor;\n   private final FieldNamingStrategy fieldNamingPolicy;\n   private final Excluder excluder;\n+  private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\n \n   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n-      FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\n+      FieldNamingStrategy fieldNamingPolicy, Excluder excluder,\n+      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\n     this.constructorConstructor = constructorConstructor;\n     this.fieldNamingPolicy = fieldNamingPolicy;\n     this.excluder = excluder;\n+    this.jsonAdapterFactory = jsonAdapterFactory;\n   }\n \n   public boolean excludeField(Field f, boolean serialize) {\n     JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n     TypeAdapter<?> mapped = null;\n     if (annotation != null) {\n-      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n+      mapped = jsonAdapterFactory.getTypeAdapter(\n+          constructorConstructor, context, fieldType, annotation);\n     }\n     final boolean jsonAdapterPresent = mapped != null;\n     if (mapped == null) mapped = context.getAdapter(fieldType);\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n \n package com.google.gson.functional;\n \n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n-import java.io.IOException;\n+\n import junit.framework.TestCase;\n \n /**\n           + \" annotated with @JsonAdapter(LongToStringTypeAdapterFactory.class)\");\n     }\n   }\n+\n+  public void testFieldAnnotationWorksForParameterizedType() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new Gizmo2(Arrays.asList(new Part(\"Part\"))));\n+    assertEquals(\"{\\\"part\\\":\\\"GizmoPartTypeAdapterFactory\\\"}\", json);\n+    Gizmo2 computer = gson.fromJson(\"{'part':'Part'}\", Gizmo2.class);\n+    assertEquals(\"GizmoPartTypeAdapterFactory\", computer.part.get(0).name);\n+  }\n+\n+  private static final class Gizmo2 {\n+    @JsonAdapter(Gizmo2PartTypeAdapterFactory.class)\n+    List<Part> part;\n+    Gizmo2(List<Part> part) {\n+      this.part = part;\n+    }\n+  }\n+\n+  private static class Gizmo2PartTypeAdapterFactory implements TypeAdapterFactory {\n+    @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n+      return new TypeAdapter<T>() {\n+        @Override public void write(JsonWriter out, T value) throws IOException {\n+          out.value(\"GizmoPartTypeAdapterFactory\");\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        @Override public T read(JsonReader in) throws IOException {\n+          in.nextString();\n+          return (T) Arrays.asList(new Part(\"GizmoPartTypeAdapterFactory\"));\n+        }\n+      };\n+    }\n+  }\n }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java\n+/*\n+ * Copyright (C) 2016 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import java.lang.reflect.Type;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+import com.google.gson.annotations.JsonAdapter;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Functional tests for the {@link JsonAdapter} annotation on fields where the value is of\n+ * type {@link JsonSerializer} or {@link JsonDeserializer}.\n+ */\n+public final class JsonAdapterSerializerDeserializerTest extends TestCase {\n+\n+  public void testJsonSerializerDeserializerBasedJsonAdapterOnFields() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new Computer(new User(\"Inderjeet Singh\"), null, new User(\"Jesse Wilson\")));\n+    assertEquals(\"{\\\"user1\\\":\\\"UserSerializer\\\",\\\"user3\\\":\\\"UserSerializerDeserializer\\\"}\", json);\n+    Computer computer = gson.fromJson(\"{'user2':'Jesse Wilson','user3':'Jake Wharton'}\", Computer.class);\n+    assertEquals(\"UserSerializer\", computer.user2.name);\n+    assertEquals(\"UserSerializerDeserializer\", computer.user3.name);\n+  }\n+\n+  private static final class Computer {\n+    @JsonAdapter(UserSerializer.class) final User user1;\n+    @JsonAdapter(UserDeserializer.class) final User user2;\n+    @JsonAdapter(UserSerializerDeserializer.class) final User user3;\n+    Computer(User user1, User user2, User user3) {\n+      this.user1 = user1;\n+      this.user2 = user2;\n+      this.user3 = user3;\n+    }\n+  }\n+\n+  private static final class User {\n+    public final String name;\n+    private User(String name) {\n+      this.name = name;\n+    }\n+  }\n+\n+  private static final class UserSerializer implements JsonSerializer<User> {\n+    @Override\n+    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(\"UserSerializer\");\n+    }\n+  }\n+\n+  private static final class UserDeserializer implements JsonDeserializer<User> {\n+    @Override\n+    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return new User(\"UserSerializer\");\n+    }\n+  }\n+\n+  private static final class UserSerializerDeserializer implements JsonSerializer<User>, JsonDeserializer<User> {\n+    @Override\n+    public JsonElement serialize(User src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(\"UserSerializerDeserializer\");\n+    }\n+    @Override\n+    public User deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return new User(\"UserSerializerDeserializer\");\n+    }\n+  }\n+\n+  public void testJsonSerializerDeserializerBasedJsonAdapterOnClass() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new Computer2(new User2(\"Inderjeet Singh\")));\n+    assertEquals(\"{\\\"user\\\":\\\"UserSerializerDeserializer2\\\"}\", json);\n+    Computer2 computer = gson.fromJson(\"{'user':'Inderjeet Singh'}\", Computer2.class);\n+    assertEquals(\"UserSerializerDeserializer2\", computer.user.name);\n+  }\n+\n+  private static final class Computer2 {\n+    final User2 user;\n+    Computer2(User2 user) {\n+      this.user = user;\n+    }\n+  }\n+\n+  @JsonAdapter(UserSerializerDeserializer2.class)\n+  private static final class User2 {\n+    public final String name;\n+    private User2(String name) {\n+      this.name = name;\n+    }\n+  }\n+\n+  private static final class UserSerializerDeserializer2 implements JsonSerializer<User2>, JsonDeserializer<User2> {\n+    @Override\n+    public JsonElement serialize(User2 src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(\"UserSerializerDeserializer2\");\n+    }\n+    @Override\n+    public User2 deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return new User2(\"UserSerializerDeserializer2\");\n+    }\n+  }\n+\n+  public void testDifferentJsonAdaptersForGenericFieldsOfSameRawType() {\n+    Container c = new Container(\"Foo\", 10);\n+    Gson gson = new Gson();\n+    String json = gson.toJson(c);\n+    assertTrue(json.contains(\"\\\"a\\\":\\\"BaseStringAdapter\\\"\"));\n+    assertTrue(json.contains(\"\\\"b\\\":\\\"BaseIntegerAdapter\\\"\"));\n+  }\n+\n+  private static final class Container {\n+    @JsonAdapter(BaseStringAdapter.class) Base<String> a;\n+    @JsonAdapter(BaseIntegerAdapter.class) Base<Integer> b;\n+    Container(String a, int b) {\n+      this.a = new Base<String>(a);\n+      this.b = new Base<Integer>(b);\n+    }\n+  }\n+\n+  private static final class Base<T> {\n+    @SuppressWarnings(\"unused\")\n+    T value;\n+    Base(T value) {\n+      this.value = value;\n+    }\n+  }\n+\n+  private static final class BaseStringAdapter implements JsonSerializer<Base<String>> {\n+    @Override public JsonElement serialize(Base<String> src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(\"BaseStringAdapter\");\n+    }\n+  }\n+\n+  private static final class BaseIntegerAdapter implements JsonSerializer<Base<Integer>> {\n+    @Override public JsonElement serialize(Base<Integer> src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(\"BaseIntegerAdapter\");\n+    }\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java\n    * This test also ensures that {@link TypeAdapterFactory} registered through {@link JsonAdapter}\n    * work correctly for {@link Gson#getDelegateAdapter(TypeAdapterFactory, TypeToken)}.\n    */\n-  public void testSubclassesAutomaticallySerialzed() throws Exception {\n+  public void testSubclassesAutomaticallySerialized() throws Exception {\n     Shape shape = new Circle(25);\n     String json = gson.toJson(shape);\n     shape = gson.fromJson(json, Shape.class);\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n  * Finally, register the type adapter factory in your application's GSON builder:\n  * <pre>   {@code\n  *   Gson gson = new GsonBuilder()\n- *       .registerTypeAdapterFactory(Shape.class, shapeAdapterFactory)\n+ *       .registerTypeAdapterFactory(shapeAdapterFactory)\n  *       .create();\n  * }</pre>\n  * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code\n--- a/gson/src/main/java/com/google/gson/JsonObject.java\n+++ b/gson/src/main/java/com/google/gson/JsonObject.java\n   }\n \n   /**\n+   * Returns the number of key/value pairs in the object.\n+   *\n+   * @return the number of key/value pairs in the object.\n+   */\n+  public int size() {\n+    return members.size();\n+  }\n+\n+  /**\n    * Convenience method to check if a member with the specified name is present in this object.\n    *\n    * @param memberName name of the member that is being checked for presence.\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n import com.google.gson.stream.JsonToken;\n import java.io.IOException;\n import java.io.Reader;\n-import java.util.ArrayList;\n import java.util.Iterator;\n-import java.util.List;\n import java.util.Map;\n \n /**\n   };\n   private static final Object SENTINEL_CLOSED = new Object();\n \n-  private final List<Object> stack = new ArrayList<Object>();\n+  /*\n+   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n+   */\n+  private Object[] stack = new Object[32];\n+  private int stackSize = 0;\n+\n+  /*\n+   * The path members. It corresponds directly to stack: At indices where the\n+   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n+   * pathNames contains the name at this scope. Where it contains an array\n+   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n+   * that array. Otherwise the value is undefined, and we take advantage of that\n+   * by incrementing pathIndices when doing so isn't useful.\n+   */\n+  private String[] pathNames = new String[32];\n+  private int[] pathIndices = new int[32];\n \n   public JsonTreeReader(JsonElement element) {\n     super(UNREADABLE_READER);\n-    stack.add(element);\n+    push(element);\n   }\n \n   @Override public void beginArray() throws IOException {\n     expect(JsonToken.BEGIN_ARRAY);\n     JsonArray array = (JsonArray) peekStack();\n-    stack.add(array.iterator());\n+    push(array.iterator());\n+    pathIndices[stackSize - 1] = 0;\n   }\n \n   @Override public void endArray() throws IOException {\n     expect(JsonToken.END_ARRAY);\n     popStack(); // empty iterator\n     popStack(); // array\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n   }\n \n   @Override public void beginObject() throws IOException {\n     expect(JsonToken.BEGIN_OBJECT);\n     JsonObject object = (JsonObject) peekStack();\n-    stack.add(object.entrySet().iterator());\n+    push(object.entrySet().iterator());\n   }\n \n   @Override public void endObject() throws IOException {\n     expect(JsonToken.END_OBJECT);\n     popStack(); // empty iterator\n     popStack(); // object\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n   }\n \n   @Override public boolean hasNext() throws IOException {\n   }\n \n   @Override public JsonToken peek() throws IOException {\n-    if (stack.isEmpty()) {\n+    if (stackSize == 0) {\n       return JsonToken.END_DOCUMENT;\n     }\n \n     Object o = peekStack();\n     if (o instanceof Iterator) {\n-      boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;\n+      boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n       Iterator<?> iterator = (Iterator<?>) o;\n       if (iterator.hasNext()) {\n         if (isObject) {\n           return JsonToken.NAME;\n         } else {\n-          stack.add(iterator.next());\n+          push(iterator.next());\n           return peek();\n         }\n       } else {\n   }\n \n   private Object peekStack() {\n-    return stack.get(stack.size() - 1);\n+    return stack[stackSize - 1];\n   }\n \n   private Object popStack() {\n-    return stack.remove(stack.size() - 1);\n+    Object result = stack[--stackSize];\n+    stack[stackSize] = null;\n+    return result;\n   }\n \n   private void expect(JsonToken expected) throws IOException {\n     if (peek() != expected) {\n-      throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek());\n+      throw new IllegalStateException(\n+          \"Expected \" + expected + \" but was \" + peek() + locationString());\n     }\n   }\n \n     expect(JsonToken.NAME);\n     Iterator<?> i = (Iterator<?>) peekStack();\n     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n-    stack.add(entry.getValue());\n-    return (String) entry.getKey();\n+    String result = (String) entry.getKey();\n+    pathNames[stackSize - 1] = result;\n+    push(entry.getValue());\n+    return result;\n   }\n \n   @Override public String nextString() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token);\n-    }\n-    return ((JsonPrimitive) popStack()).getAsString();\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n+    }\n+    String result = ((JsonPrimitive) popStack()).getAsString();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n+    return result;\n   }\n \n   @Override public boolean nextBoolean() throws IOException {\n     expect(JsonToken.BOOLEAN);\n-    return ((JsonPrimitive) popStack()).getAsBoolean();\n+    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n+    return result;\n   }\n \n   @Override public void nextNull() throws IOException {\n     expect(JsonToken.NULL);\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n   }\n \n   @Override public double nextDouble() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     double result = ((JsonPrimitive) peekStack()).getAsDouble();\n     if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n       throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n     }\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n     return result;\n   }\n \n   @Override public long nextLong() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     long result = ((JsonPrimitive) peekStack()).getAsLong();\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n     return result;\n   }\n \n   @Override public int nextInt() throws IOException {\n     JsonToken token = peek();\n     if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n-      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+      throw new IllegalStateException(\n+          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n     }\n     int result = ((JsonPrimitive) peekStack()).getAsInt();\n     popStack();\n+    if (stackSize > 0) {\n+      pathIndices[stackSize - 1]++;\n+    }\n     return result;\n   }\n \n   @Override public void close() throws IOException {\n-    stack.clear();\n-    stack.add(SENTINEL_CLOSED);\n+    stack = new Object[] { SENTINEL_CLOSED };\n+    stackSize = 1;\n   }\n \n   @Override public void skipValue() throws IOException {\n     if (peek() == JsonToken.NAME) {\n       nextName();\n+      pathNames[stackSize - 2] = \"null\";\n     } else {\n       popStack();\n-    }\n+      pathNames[stackSize - 1] = \"null\";\n+    }\n+    pathIndices[stackSize - 1]++;\n   }\n \n   @Override public String toString() {\n     expect(JsonToken.NAME);\n     Iterator<?> i = (Iterator<?>) peekStack();\n     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n-    stack.add(entry.getValue());\n-    stack.add(new JsonPrimitive((String)entry.getKey()));\n+    push(entry.getValue());\n+    push(new JsonPrimitive((String) entry.getKey()));\n+  }\n+\n+  private void push(Object newTop) {\n+    if (stackSize == stack.length) {\n+      Object[] newStack = new Object[stackSize * 2];\n+      int[] newPathIndices = new int[stackSize * 2];\n+      String[] newPathNames = new String[stackSize * 2];\n+      System.arraycopy(stack, 0, newStack, 0, stackSize);\n+      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n+      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n+      stack = newStack;\n+      pathIndices = newPathIndices;\n+      pathNames = newPathNames;\n+    }\n+    stack[stackSize++] = newTop;\n+  }\n+\n+  @Override public String getPath() {\n+    StringBuilder result = new StringBuilder().append('$');\n+    for (int i = 0; i < stackSize; i++) {\n+      if (stack[i] instanceof JsonArray) {\n+        if (stack[++i] instanceof Iterator) {\n+          result.append('[').append(pathIndices[i]).append(']');\n+        }\n+      } else if (stack[i] instanceof JsonObject) {\n+        if (stack[++i] instanceof Iterator) {\n+          result.append('.');\n+          if (pathNames[i] != null) {\n+            result.append(pathNames[i]);\n+          }\n+        }\n+      }\n+    }\n+    return result.toString();\n+  }\n+\n+  private String locationString() {\n+    return \" at path \" + getPath();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n       pathIndices[stackSize - 1] = 0;\n       peeked = PEEKED_NONE;\n     } else {\n-      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n     }\n   }\n \n       pathIndices[stackSize - 1]++;\n       peeked = PEEKED_NONE;\n     } else {\n-      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + locationString());\n     }\n   }\n \n       push(JsonScope.EMPTY_OBJECT);\n       peeked = PEEKED_NONE;\n     } else {\n-      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\n     }\n   }\n \n       pathIndices[stackSize - 1]++;\n       peeked = PEEKED_NONE;\n     } else {\n-      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\n     }\n   }\n \n     } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n       result = nextQuotedValue('\"');\n     } else {\n-      throw new IllegalStateException(\"Expected a name but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n     }\n     peeked = PEEKED_NONE;\n     pathNames[stackSize - 1] = result;\n       result = new String(buffer, pos, peekedNumberLength);\n       pos += peekedNumberLength;\n     } else {\n-      throw new IllegalStateException(\"Expected a string but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n     }\n     peeked = PEEKED_NONE;\n     pathIndices[stackSize - 1]++;\n       pathIndices[stackSize - 1]++;\n       return false;\n     }\n-    throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n-        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n   }\n \n   /**\n       peeked = PEEKED_NONE;\n       pathIndices[stackSize - 1]++;\n     } else {\n-      throw new IllegalStateException(\"Expected null but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected null but was \" + peek() + locationString());\n     }\n   }\n \n     } else if (p == PEEKED_UNQUOTED) {\n       peekedString = nextUnquotedValue();\n     } else if (p != PEEKED_BUFFERED) {\n-      throw new IllegalStateException(\"Expected a double but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n     }\n \n     peeked = PEEKED_BUFFERED;\n     double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n-      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new MalformedJsonException(\n+          \"JSON forbids NaN and infinities: \" + result + locationString());\n     }\n     peekedString = null;\n     peeked = PEEKED_NONE;\n         // Fall back to parse as a double below.\n       }\n     } else {\n-      throw new IllegalStateException(\"Expected a long but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected a long but was \" + peek() + locationString());\n     }\n \n     peeked = PEEKED_BUFFERED;\n     double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n     long result = (long) asDouble;\n     if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n-      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\n     }\n     peekedString = null;\n     peeked = PEEKED_NONE;\n     if (p == PEEKED_LONG) {\n       result = (int) peekedLong;\n       if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n-        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n-            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+        throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\n       }\n       peeked = PEEKED_NONE;\n       pathIndices[stackSize - 1]++;\n         // Fall back to parse as a double below.\n       }\n     } else {\n-      throw new IllegalStateException(\"Expected an int but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new IllegalStateException(\"Expected an int but was \" + peek() + locationString());\n     }\n \n     peeked = PEEKED_BUFFERED;\n     double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n     result = (int) asDouble;\n     if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n-      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+      throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\n     }\n     peekedString = null;\n     peeked = PEEKED_NONE;\n     return false;\n   }\n \n-  int getLineNumber() {\n-    return lineNumber + 1;\n-  }\n-\n-  int getColumnNumber() {\n-    return pos - lineStart + 1;\n-  }\n-\n   /**\n    * Returns the next character in the stream that is neither whitespace nor a\n    * part of a comment. When this returns, the returned character is always at\n       }\n     }\n     if (throwOnEof) {\n-      throw new EOFException(\"End of input\"\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+      throw new EOFException(\"End of input\" + locationString());\n     } else {\n       return -1;\n     }\n   }\n \n   @Override public String toString() {\n-    return getClass().getSimpleName()\n-        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber();\n+    return getClass().getSimpleName() + locationString();\n+  }\n+\n+  private String locationString() {\n+    int line = lineNumber + 1;\n+    int column = pos - lineStart + 1;\n+    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\n   }\n \n   /**\n     case '\\'':\n     case '\"':\n     case '\\\\':\n+    case '/':\t\n+    \treturn escaped;\n     default:\n-      return escaped;\n+    \t// throw error when none of the above cases are matched\n+    \tthrow syntaxError(\"Invalid escape sequence\");\n     }\n   }\n \n    * with this reader's content.\n    */\n   private IOException syntaxError(String message) throws IOException {\n-    throw new MalformedJsonException(message\n-        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n+    throw new MalformedJsonException(message + locationString());\n   }\n \n   /**\n         } else if (p == PEEKED_UNQUOTED_NAME) {\n           reader.peeked = PEEKED_UNQUOTED;\n         } else {\n-          throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n-              + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n-              + \" path \" + reader.getPath());\n+          throw new IllegalStateException(\n+              \"Expected a name but was \" + reader.peek() + reader.locationString());\n         }\n       }\n     };\n--- a/gson/src/test/java/com/google/gson/JsonObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonObjectTest.java\n     assertFalse(b.equals(a));\n   }\n \n+  public void testSize() {\n+    JsonObject o = new JsonObject();\n+    assertEquals(0, o.size());\n+\n+    o.add(\"Hello\", new JsonPrimitive(1));\n+    assertEquals(1, o.size());\n+\n+    o.add(\"Hi\", new JsonPrimitive(1));\n+    assertEquals(2, o.size());\n+\n+    o.remove(\"Hello\");\n+    assertEquals(1, o.size());\n+  }\n+\n   public void testDeepCopy() {\n     JsonObject original = new JsonObject();\n     JsonArray firstEntry = new JsonArray();\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java\n \n package com.google.gson.stream;\n \n+import com.google.gson.JsonElement;\n+import com.google.gson.internal.Streams;\n+import com.google.gson.internal.bind.JsonTreeReader;\n import java.io.IOException;\n import java.io.StringReader;\n-import junit.framework.TestCase;\n-\n-@SuppressWarnings(\"resource\")\n-public class JsonReaderPathTest extends TestCase {\n-  public void testPath() throws IOException {\n-    JsonReader reader = new JsonReader(\n-        new StringReader(\"{\\\"a\\\":[2,true,false,null,\\\"b\\\",{\\\"c\\\":\\\"d\\\"},[3]]}\"));\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static org.junit.Assume.assumeTrue;\n+\n+@RunWith(Parameterized.class)\n+public class JsonReaderPathTest {\n+  @Parameterized.Parameters(name = \"{0}\")\n+  public static List<Object[]> parameters() {\n+    return Arrays.asList(\n+        new Object[] { Factory.STRING_READER },\n+        new Object[] { Factory.OBJECT_READER }\n+    );\n+  }\n+\n+  @Parameterized.Parameter\n+  public Factory factory;\n+\n+  @Test public void path() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":[2,true,false,null,\\\"b\\\",{\\\"c\\\":\\\"d\\\"},[3]]}\");\n     assertEquals(\"$\", reader.getPath());\n     reader.beginObject();\n     assertEquals(\"$.\", reader.getPath());\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testObjectPath() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1,\\\"b\\\":2}\"));\n+  @Test public void objectPath() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":1,\\\"b\\\":2}\");\n     assertEquals(\"$\", reader.getPath());\n \n     reader.peek();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testArrayPath() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[1,2]\"));\n+  @Test public void arrayPath() throws IOException {\n+    JsonReader reader = factory.create(\"[1,2]\");\n     assertEquals(\"$\", reader.getPath());\n \n     reader.peek();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testMultipleTopLevelValuesInOneDocument() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[][]\"));\n+  @Test public void multipleTopLevelValuesInOneDocument() throws IOException {\n+    assumeTrue(factory == Factory.STRING_READER);\n+\n+    JsonReader reader = factory.create(\"[][]\");\n     reader.setLenient(true);\n     reader.beginArray();\n     reader.endArray();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testSkipArrayElements() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[1,2,3]\"));\n-    reader.beginArray();\n-    reader.skipValue();\n-    reader.skipValue();\n-    assertEquals(\"$[2]\", reader.getPath());\n-  }\n-\n-  public void testSkipObjectNames() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1}\"));\n+  @Test public void skipArrayElements() throws IOException {\n+    JsonReader reader = factory.create(\"[1,2,3]\");\n+    reader.beginArray();\n+    reader.skipValue();\n+    reader.skipValue();\n+    assertEquals(\"$[2]\", reader.getPath());\n+  }\n+\n+  @Test public void skipObjectNames() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":1}\");\n     reader.beginObject();\n     reader.skipValue();\n     assertEquals(\"$.null\", reader.getPath());\n   }\n \n-  public void testSkipObjectValues() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1,\\\"b\\\":2}\"));\n-    reader.beginObject();\n+  @Test public void skipObjectValues() throws IOException {\n+    JsonReader reader = factory.create(\"{\\\"a\\\":1,\\\"b\\\":2}\");\n+    reader.beginObject();\n+    assertEquals(\"$.\", reader.getPath());\n     reader.nextName();\n     reader.skipValue();\n     assertEquals(\"$.null\", reader.getPath());\n     assertEquals(\"$.b\", reader.getPath());\n   }\n \n-  public void testSkipNestedStructures() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[[1,2,3],4]\"));\n-    reader.beginArray();\n-    reader.skipValue();\n-    assertEquals(\"$[1]\", reader.getPath());\n-  }\n-\n-  public void testArrayOfObjects() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[{},{},{}]\"));\n+  @Test public void skipNestedStructures() throws IOException {\n+    JsonReader reader = factory.create(\"[[1,2,3],4]\");\n+    reader.beginArray();\n+    reader.skipValue();\n+    assertEquals(\"$[1]\", reader.getPath());\n+  }\n+\n+  @Test public void arrayOfObjects() throws IOException {\n+    JsonReader reader = factory.create(\"[{},{},{}]\");\n     reader.beginArray();\n     assertEquals(\"$[0]\", reader.getPath());\n     reader.beginObject();\n     assertEquals(\"$\", reader.getPath());\n   }\n \n-  public void testArrayOfArrays() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[[],[],[]]\"));\n+  @Test public void arrayOfArrays() throws IOException {\n+    JsonReader reader = factory.create(\"[[],[],[]]\");\n     reader.beginArray();\n     assertEquals(\"$[0]\", reader.getPath());\n     reader.beginArray();\n     reader.endArray();\n     assertEquals(\"$\", reader.getPath());\n   }\n+\n+  enum Factory {\n+    STRING_READER {\n+      @Override public JsonReader create(String data) {\n+        return new JsonReader(new StringReader(data));\n+      }\n+    },\n+    OBJECT_READER {\n+      @Override public JsonReader create(String data) {\n+        JsonElement element = Streams.parse(new JsonReader(new StringReader(data)));\n+        return new JsonTreeReader(element);\n+      }\n+    };\n+\n+    abstract JsonReader create(String data);\n+  }\n }\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n     assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n   }\n \n+  public void testInvalidJsonInput() throws IOException {\n+    String json = \"{\\n\"\n+        + \"   \\\"h\\\\ello\\\": true,\\n\"\n+        + \"   \\\"foo\\\": [\\\"world\\\"]\\n\"\n+        + \"}\";\n+\n+    JsonReader reader = new JsonReader(reader(json));\n+    reader.beginObject();\n+    try {\n+      reader.nextName();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+  \n   public void testNulls() {\n     try {\n       new JsonReader(null);", "timestamp": 1465947434, "metainfo": ""}