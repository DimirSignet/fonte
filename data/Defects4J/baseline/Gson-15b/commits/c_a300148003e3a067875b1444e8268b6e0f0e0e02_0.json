{"sha": "a300148003e3a067875b1444e8268b6e0f0e0e02", "log": "Fix StackOverflowError on resolving recursive types by collapsing chains of type bounds (#1075)  * Fixes StackOverflowError on resolving recursive types.\r \r See Issue #440, Issue #603, tests.\r \r * fix 'codacy' coding style warnings\r \r * added copyright header", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n    * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n    */\n   public static WildcardType subtypeOf(Type bound) {\n-    return new WildcardTypeImpl(new Type[] { bound }, EMPTY_TYPE_ARRAY);\n+    Type[] upperBounds;\n+    if (bound instanceof WildcardType) {\n+      upperBounds = ((WildcardType) bound).getUpperBounds();\n+    } else {\n+      upperBounds = new Type[] { bound };\n+    }\n+    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n   }\n \n   /**\n    * super String}.\n    */\n   public static WildcardType supertypeOf(Type bound) {\n-    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });\n+    Type[] lowerBounds;\n+    if (bound instanceof WildcardType) {\n+      lowerBounds = ((WildcardType) bound).getLowerBounds();\n+    } else {\n+      lowerBounds = new Type[] { bound };\n+    }\n+    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n   }\n \n   /**\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java\n+/*\n+ * Copyright (C) 2017 Gson Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.internal.$Gson$Types;\n+import junit.framework.TestCase;\n+\n+import java.io.PrintStream;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * Test fixes for infinite recursion on {@link $Gson$Types#resolve(java.lang.reflect.Type, Class,\n+ * java.lang.reflect.Type)}, described at <a href=\"https://github.com/google/gson/issues/440\">Issue #440</a>\n+ * and similar issues.\n+ * <p>\n+ * These tests originally caused {@link StackOverflowError} because of infinite recursion on attempts to\n+ * resolve generics on types, with an intermediate types like 'Foo2&lt;? extends ? super ? extends ... ? extends A&gt;'\n+ */\n+public class RecursiveTypesResolveTest extends TestCase {\n+\n+  private static class Foo1<A> {\n+    public Foo2<? extends A> foo2;\n+  }\n+\n+  private static class Foo2<B> {\n+    public Foo1<? super B> foo1;\n+  }\n+\n+  /**\n+   * Test simplest case of recursion.\n+   */\n+  public void testRecursiveResolveSimple() {\n+    TypeAdapter<Foo1> adapter = new Gson().getAdapter(Foo1.class);\n+    assertNotNull(adapter);\n+  }\n+\n+  //\n+  // Real-world samples, found in Issues #603 and #440.\n+  //\n+  public void testIssue603PrintStream() {\n+    TypeAdapter<PrintStream> adapter = new Gson().getAdapter(PrintStream.class);\n+    assertNotNull(adapter);\n+  }\n+\n+  public void testIssue440WeakReference() throws Exception {\n+    TypeAdapter<WeakReference> adapter = new Gson().getAdapter(WeakReference.class);\n+    assertNotNull(adapter);\n+  }\n+\n+  //\n+  // Tests belows check the behaviour of the methods changed for the fix\n+  //\n+\n+  public void testDoubleSupertype() {\n+    assertEquals($Gson$Types.supertypeOf(Number.class),\n+            $Gson$Types.supertypeOf($Gson$Types.supertypeOf(Number.class)));\n+  }\n+\n+  public void testDoubleSubtype() {\n+    assertEquals($Gson$Types.subtypeOf(Number.class),\n+            $Gson$Types.subtypeOf($Gson$Types.subtypeOf(Number.class)));\n+  }\n+\n+  public void testSuperSubtype() {\n+    assertEquals($Gson$Types.subtypeOf(Object.class),\n+            $Gson$Types.supertypeOf($Gson$Types.subtypeOf(Number.class)));\n+  }\n+\n+  public void testSubSupertype() {\n+    assertEquals($Gson$Types.subtypeOf(Object.class),\n+            $Gson$Types.subtypeOf($Gson$Types.supertypeOf(Number.class)));\n+  }\n+}", "timestamp": 1496191624, "metainfo": ""}