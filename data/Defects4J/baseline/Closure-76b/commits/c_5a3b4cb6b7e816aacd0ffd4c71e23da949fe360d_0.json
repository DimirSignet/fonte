{"sha": "5a3b4cb6b7e816aacd0ffd4c71e23da949fe360d", "log": "improve validation for types that are resolved later.  R=johnlenz DELTA=192  (166 added, 1 deleted, 25 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=337976   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n       \"JSC_EXTENDS_NON_OBJECT\",\n       \"{0} @extends non-object type {1}\");\n \n+  static final DiagnosticType RESOLVED_TAG_EMPTY = DiagnosticType.warning(\n+      \"JSC_RESOLVED_TAG_EMPTY\",\n+      \"Could not resolve type in {0} tag of {1}\");\n+\n   static final DiagnosticType IMPLEMENTS_WITHOUT_CONSTRUCTOR =\n       DiagnosticType.warning(\n           \"JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR\",\n   static final DiagnosticType TEMPLATE_TYPE_EXPECTED = DiagnosticType.error(\n       \"JSC_TEMPLATE_TYPE_EXPECTED\",\n       \"The template type must be a parameter type\");\n+\n+  private class ExtendedTypeValidator implements Predicate<JSType> {\n+    @Override\n+    public boolean apply(JSType type) {\n+      ObjectType objectType = ObjectType.cast(type);\n+      if (objectType == null) {\n+        reportWarning(EXTENDS_NON_OBJECT, fnName, type.toString());\n+      } else if (objectType.isUnknownType() &&\n+          // If this has a supertype that hasn't been resolved yet,\n+          // then we can assume this type will be ok once the super\n+          // type resolves.\n+          (objectType.getImplicitPrototype() == null ||\n+           objectType.getImplicitPrototype().isResolved())) {\n+        reportWarning(RESOLVED_TAG_EMPTY, \"@extends\", fnName);\n+      } else {\n+        return true;\n+      }\n+      return false;\n+    }\n+  };\n+\n+  private class ImplementedTypeValidator implements Predicate<JSType> {\n+    @Override\n+    public boolean apply(JSType type) {\n+      ObjectType objectType = ObjectType.cast(type);\n+      if (objectType == null) {\n+        reportError(BAD_IMPLEMENTED_TYPE, fnName);\n+      } else if (objectType.isUnknownType() &&\n+          // If this has a supertype that hasn't been resolved yet,\n+          // then we can assume this type will be ok once the super\n+          // type resolves.\n+          (objectType.getImplicitPrototype() == null ||\n+           objectType.getImplicitPrototype().isResolved())) {\n+        reportWarning(RESOLVED_TAG_EMPTY, \"@implements\", fnName);\n+      } else {\n+        return true;\n+      }\n+      return false;\n+    }\n+  };\n \n   /**\n    * @param fnName The function name.\n       // base type\n       if (info.hasBaseType()) {\n         if (isConstructor || isInterface) {\n-          baseType = ObjectType.cast(info.getBaseType().evaluate(scope, typeRegistry));\n-          if (baseType == null) {\n-            reportWarning(EXTENDS_NON_OBJECT, fnName, baseType.toString());\n+          JSType maybeBaseType =\n+              info.getBaseType().evaluate(scope, typeRegistry);\n+          if (maybeBaseType != null &&\n+              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n+            baseType = (ObjectType) maybeBaseType;\n           }\n         } else {\n           reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n       if (isConstructor || isInterface) {\n         implementedInterfaces = Lists.newArrayList();\n         for (JSTypeExpression t : info.getImplementedInterfaces()) {\n-          ObjectType interType = ObjectType.cast(t.evaluate(scope, typeRegistry));\n-          if (interType != null) {\n-            implementedInterfaces.add(interType);\n-          } else {\n-            reportError(BAD_IMPLEMENTED_TYPE, fnName);\n+          JSType maybeInterType = t.evaluate(scope, typeRegistry);\n+          if (maybeInterType != null &&\n+              maybeInterType.setValidator(new ImplementedTypeValidator())) {\n+            implementedInterfaces.add((ObjectType) maybeInterType);\n           }\n         }\n         if (baseType != null) {\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.lastIndexOf('.');\n+          int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n--- a/src/com/google/javascript/jscomp/SourceFile.java\n+++ b/src/com/google/javascript/jscomp/SourceFile.java\n     }\n   }\n \n-  @Override\n-  public String toString() {\n-    return fileName;\n-  }\n-\n   public static SourceFile fromFile(String fileName, Charset c) {\n     return fromFile(new File(fileName), c);\n   }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n \n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n+import com.google.common.base.Predicate;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;\n     return type == null ? null : type.resolve(t, scope);\n   }\n \n+  /**\n+   * Certain types have constraints on them at resolution-time.\n+   * For example, a type in an {@code @extends} annotation must be an\n+   * object. Clients should inject a validator that emits a warning\n+   * if the type does not validate, and return false.\n+   */\n+  public boolean setValidator(Predicate<JSType> validator) {\n+    return validator.apply(this);\n+  }\n+\n   public static class TypePair {\n     public final JSType typeA;\n     public final JSType typeB;\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n package com.google.javascript.rhino.jstype;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n import com.google.javascript.rhino.ErrorReporter;\n \n /**\n   private final String sourceName;\n   private final int lineno;\n   private final int charno;\n+\n+  /**\n+   * Validates the type resolution.\n+   */\n+  private Predicate<JSType> validator;\n \n   /**\n    * If true, don't warn about unresolveable type names.\n \n   private void setReferencedAndResolvedType(JSType type, ErrorReporter t,\n       StaticScope<JSType> enclosing) {\n+    if (validator != null) {\n+      validator.apply(type);\n+    }\n     setReferencedType(type);\n     checkEnumElementCycle(t);\n     setResolvedTypeInternal(getReferencedType());\n   private void handleUnresolvedType(\n       ErrorReporter t, boolean ignoreForwardReferencedTypes) {\n     if (registry.isLastGeneration()) {\n-      boolean beForgiving = forgiving ||\n-          (ignoreForwardReferencedTypes &&\n-           registry.isForwardDeclaredType(reference));\n+      boolean isForwardDeclared =\n+          ignoreForwardReferencedTypes &&\n+          registry.isForwardDeclaredType(reference);\n+      boolean beForgiving = forgiving || isForwardDeclared;\n       if (!beForgiving && registry.isLastGeneration()) {\n         t.warning(\"Unknown type \" + reference, sourceName, lineno, null,\n             charno);\n         setReferencedType(\n             registry.getNativeObjectType(\n                 JSTypeNative.CHECKED_UNKNOWN_TYPE));\n+\n+        if (registry.isLastGeneration() && validator != null) {\n+          validator.apply(getReferencedType());\n+        }\n       }\n \n       setResolvedTypeInternal(getReferencedType());\n     handleUnresolvedType(t, true);\n     return null;\n   }\n+\n+  @Override\n+  public boolean setValidator(Predicate<JSType> validator) {\n+    // If the type is already resolved, we can validate it now. If\n+    // the type has not been resolved yet, we need to wait till its\n+    // resolved before we can validate it.\n+    if (this.isResolved()) {\n+      return super.setValidator(validator);\n+    } else {\n+      this.validator = validator;\n+      return true;\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n         + \"Foo.prototype.Foo_prototype$a=0;\"\n         + \"var Bar=function(){};\"\n         + \"Bar.prototype.Bar_prototype$a=0;\";\n-    testSets(false, js, js, \"{}\");\n+    testSets(false, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES,\n+        js, js, \"{}\", FunctionTypeBuilder.RESOLVED_TAG_EMPTY,\n+        \"Could not resolve type in @extends tag of Foo\");\n     testSets(true, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES,\n-        js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n+        js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\",\n+        FunctionTypeBuilder.RESOLVED_TAG_EMPTY,\n+        \"Could not resolve type in @extends tag of Foo\");\n   }\n \n   public void testNamedType() {\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n import com.google.javascript.rhino.jstype.ObjectType;\n \n import java.util.Arrays;\n+import java.util.List;\n \n /**\n  * Tests {@link TypeCheck}.\n   }\n \n   public void testPrototypeLoop() throws Exception {\n-    testTypes(\n+    testClosureTypesMultipleWarnings(\n         suppressMissingProperty(\"foo\") +\n         \"/** @constructor \\n * @extends {T} */var T = function() {};\" +\n         \"alert((new T).foo);\",\n-        \"Parse error. Cycle detected in inheritance chain of type T\");\n+        Lists.newArrayList(\n+            \"Parse error. Cycle detected in inheritance chain of type T\",\n+            \"Could not resolve type in @extends tag of T\"));\n   }\n \n   public void testDirectPrototypeAssign() throws Exception {\n \n         \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n         \"/** @param {MyType} x \\n * @return {number} */\" +\n-        \"function f(x) { return x; }\", null);\n+        \"function f(x) { return 3; }\", null);\n   }\n \n   public void testForwardTypeDeclaration2() throws Exception {\n \n   private void testClosureTypes(String js, String description)\n       throws Exception {\n+    testClosureTypesMultipleWarnings(js,\n+        description == null ? null : Lists.newArrayList(description));\n+  }\n+\n+  private void testClosureTypesMultipleWarnings(\n+      String js, List<String> descriptions) throws Exception {\n     Node n = compiler.parseTestCode(js);\n     Node externs = new Node(Token.BLOCK);\n     Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n \n     assertEquals(0, compiler.getErrorCount());\n \n-    if (description == null) {\n+    if (descriptions == null) {\n       assertEquals(\n           \"unexpected warning(s) : \" +\n           Joiner.on(\", \").join(compiler.getWarnings()),\n           0, compiler.getWarningCount());\n     } else {\n-      assertEquals(1, compiler.getWarningCount());\n-      assertEquals(description, compiler.getWarnings()[0].description);\n+      assertEquals(descriptions.size(), compiler.getWarningCount());\n+      for (int i = 0; i < descriptions.size(); i++) {\n+        assertEquals(descriptions.get(i),\n+            compiler.getWarnings()[i].description);\n+      }\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n         });\n   }\n \n-  public void testProvideInIndependentModules4() {\n-    // Regression test for bug 261:\n-    // http://code.google.com/p/closure-compiler/issues/detail?id=261\n-    test(\n-        createModuleStar(\n-            \"goog.provide('apps');\",\n-            \"goog.provide('apps.foo.bar.B');\",\n-            \"goog.provide('apps.foo.bar.C');\"),\n-        new String[] {\n-            \"var apps = {};apps.foo = {};apps.foo.bar = {}\",\n-            \"apps.foo.bar.B = {};\",\n-            \"apps.foo.bar.C = {};\",\n-        });\n-  }\n-\n   public void testRequireOfBaseGoog() {\n     test(\"goog.require('goog');\",\n          \"\", MISSING_PROVIDE_ERROR);\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n import com.google.javascript.rhino.jstype.ObjectType;\n \n import java.util.Arrays;\n+import java.util.List;\n \n /**\n  * Tests {@link TypeCheck}.\n         \"required: boolean\");\n   }\n \n+  public void testGoodExtends12() throws Exception {\n+    testTypes(\n+        \"/** @constructor \\n * @extends {Super} */ function Sub() {}\" +\n+        \"/** @constructor \\n * @extends {Sub} */ function Sub2() {}\" +\n+        \"/** @constructor */ function Super() {}\" +\n+        \"/** @param {Super} x */ function foo(x) {}\" +\n+        \"foo(new Sub2());\");\n+  }\n+\n   public void testBadExtends1() throws Exception {\n     testTypes(\"/** @constructor */function base() {}\\n\" +\n         \"/** @constructor\\n * @extends {not_base} */function derived() {}\\n\",\n   public void testBadExtends3() throws Exception {\n     testTypes(\"/** @extends {Object} */function base() {}\",\n         \"@extends used without @constructor or @interface for base\");\n+  }\n+\n+  public void testBadExtends4() throws Exception {\n+    // If there's a subclass of a class with a bad extends,\n+    // we only want to warn about the first one.\n+    testTypes(\n+        \"/** @constructor \\n * @extends {bad} */ function Sub() {}\" +\n+        \"/** @constructor \\n * @extends {Sub} */ function Sub2() {}\" +\n+        \"/** @param {Sub} x */ function foo(x) {}\" +\n+        \"foo(new Sub2());\",\n+        \"Parse error. Unknown type bad\");\n   }\n \n   public void testLateExtends() throws Exception {\n   }\n \n   public void testInheritanceCheck14() throws Exception {\n-    testTypes(\n+    testClosureTypes(\n         \"var goog = {};\\n\" +\n         \"/** @constructor\\n @extends {goog.Missing} */\\n\" +\n         \"goog.Super = function() {};\\n\" +\n   }\n \n   public void testPrototypeLoop() throws Exception {\n-    testTypes(\n+    testClosureTypesMultipleWarnings(\n         suppressMissingProperty(\"foo\") +\n         \"/** @constructor \\n * @extends {T} */var T = function() {};\" +\n         \"alert((new T).foo);\",\n-        \"Parse error. Cycle detected in inheritance chain of type T\");\n+        Lists.newArrayList(\n+            \"Parse error. Cycle detected in inheritance chain of type T\",\n+            \"Could not resolve type in @extends tag of T\"));\n   }\n \n   public void testDirectPrototypeAssign() throws Exception {\n \n         \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n         \"/** @param {MyType} x \\n * @return {number} */\" +\n-        \"function f(x) { return x; }\", null);\n+        \"function f(x) { return 3; }\", null);\n   }\n \n   public void testForwardTypeDeclaration2() throws Exception {\n         \"actual parameter 1 of f does not match formal parameter\\n\" +\n         \"found   : number\\n\" +\n         \"required: (MyType|null)\");\n+  }\n+\n+  public void testForwardTypeDeclaration4() throws Exception {\n+    testClosureTypes(\n+        \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/** @param {MyType} x */ function f(x) { return x; }\" +\n+        \"/** @constructor */ var MyType = function() {};\" +\n+        \"f(new MyType());\",\n+        null);\n+  }\n+\n+  public void testForwardTypeDeclaration5() throws Exception {\n+    testClosureTypes(\n+        \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {MyType}\\n\" +\n+        \" */ var YourType = function() {};\" +\n+        \"/** @override */ YourType.prototype.method = function() {};\",\n+        \"Could not resolve type in @extends tag of YourType\");\n+  }\n+\n+  public void testForwardTypeDeclaration6() throws Exception {\n+    testClosureTypesMultipleWarnings(\n+        \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @implements {MyType}\\n\" +\n+        \" */ var YourType = function() {};\" +\n+        \"/** @override */ YourType.prototype.method = function() {};\",\n+        Lists.newArrayList(\n+            \"Could not resolve type in @implements tag of YourType\",\n+            \"property method not defined on any superclass of YourType\"));\n   }\n \n   public void testMalformedOldTypeDef() throws Exception {\n \n   private void testClosureTypes(String js, String description)\n       throws Exception {\n+    testClosureTypesMultipleWarnings(js,\n+        description == null ? null : Lists.newArrayList(description));\n+  }\n+\n+  private void testClosureTypesMultipleWarnings(\n+      String js, List<String> descriptions) throws Exception {\n     Node n = compiler.parseTestCode(js);\n     Node externs = new Node(Token.BLOCK);\n     Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n \n     assertEquals(0, compiler.getErrorCount());\n \n-    if (description == null) {\n+    if (descriptions == null) {\n       assertEquals(\n           \"unexpected warning(s) : \" +\n           Joiner.on(\", \").join(compiler.getWarnings()),\n           0, compiler.getWarningCount());\n     } else {\n-      assertEquals(1, compiler.getWarningCount());\n-      assertEquals(description, compiler.getWarnings()[0].description);\n+      assertEquals(descriptions.size(), compiler.getWarningCount());\n+      for (int i = 0; i < descriptions.size(); i++) {\n+        assertEquals(descriptions.get(i),\n+            compiler.getWarnings()[i].description);\n+      }\n     }\n   }\n ", "timestamp": 1287004993, "metainfo": ""}