{"sha": "41abf3b75893403d9e21c33d06e8dc233b5cf657", "log": "Unify global scope building and local scope building. This goes a long way towards fixing issue 61  R=johnlenz DELTA=492  (242 added, 203 deleted, 47 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=215715   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n     // inner scopes, because only global scopes can contain named classes that\n     // show up in the type registry.\n     Scope newScope = null;\n+    AbstractScopeBuilder scopeBuilder = null;\n     if (parent == null) {\n       // Find all the classes in the global scope.\n       newScope = createInitialScope(root);\n \n-      GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(newScope);\n+      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n+      scopeBuilder = globalScopeBuilder;\n       NodeTraversal.traverse(compiler, root, scopeBuilder);\n-      scopeBuilder.resolveStubDeclarations();\n-      scopeBuilder.resolveTypes();\n-\n-      // Gather the properties in each function that we found in the\n-      // global scope, if that function has a @this type that we can\n-      // build properties on.\n-      for (Node functionNode : scopeBuilder.nonExternFunctions) {\n-        JSType type = functionNode.getJSType();\n-        if (type != null && type instanceof FunctionType) {\n-          FunctionType fnType = (FunctionType) type;\n-          ObjectType fnThisType = fnType.getTypeOfThis();\n-          if (!fnThisType.isUnknownType()) {\n-            NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n-                scopeBuilder.new CollectProperties(fnThisType));\n-          }\n-        }\n-      }\n-\n+    } else {\n+      newScope = new Scope(parent, root);\n+      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n+      scopeBuilder = localScopeBuilder;\n+      localScopeBuilder.build();\n+    }\n+\n+    scopeBuilder.resolveStubDeclarations();\n+    scopeBuilder.resolveTypes();\n+\n+    // Gather the properties in each function that we found in the\n+    // global scope, if that function has a @this type that we can\n+    // build properties on.\n+    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n+      JSType type = functionNode.getJSType();\n+      if (type != null && type instanceof FunctionType) {\n+        FunctionType fnType = (FunctionType) type;\n+        ObjectType fnThisType = fnType.getTypeOfThis();\n+        if (!fnThisType.isUnknownType()) {\n+          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n+              scopeBuilder.new CollectProperties(fnThisType));\n+        }\n+      }\n+    }\n+\n+    if (parent == null) {\n       codingConvention.defineDelegateProxyPrototypeProperties(\n           typeRegistry, newScope, delegateProxyPrototypes);\n-    } else {\n-      newScope = new Scope(parent, root);\n-      LocalScopeBuilder scopeBuilder = new LocalScopeBuilder(newScope);\n-      scopeBuilder.build();\n-      scopeBuilder.resolveTypes();\n     }\n     return newScope;\n   }\n         Lists.newArrayList();\n \n     /**\n+     * Functions that we found in the global scope and not in externs.\n+     */\n+    private final List<Node> nonExternFunctions = Lists.newArrayList();\n+\n+    /**\n+     * Type-less stubs.\n+     *\n+     * If at the end of traversal, we still don't have types for these\n+     * stubs, then we should declare UNKNOWN types.\n+     */\n+    private final List<StubDeclaration> stubDeclarations =\n+        Lists.newArrayList();\n+\n+    /**\n      * The current source file that we're in.\n      */\n     private String sourceName = null;\n     }\n \n     @Override\n-    public abstract void visit(NodeTraversal t, Node n, Node parent);\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      attachLiteralTypes(n);\n+\n+      switch (n.getType()) {\n+        case Token.CALL:\n+          checkForClassDefiningCalls(t, n, parent);\n+          break;\n+\n+        case Token.FUNCTION:\n+          if (t.getInput() == null || !t.getInput().isExtern()) {\n+            nonExternFunctions.add(n);\n+          }\n+\n+          // VARs and ASSIGNs are handled in different branches of this\n+          // switch statement.\n+          if (parent.getType() != Token.ASSIGN &&\n+              parent.getType() != Token.NAME) {\n+            defineDeclaredFunction(n, parent);\n+          }\n+\n+          break;\n+\n+        case Token.ASSIGN:\n+          // Handle constructor and enum definitions.\n+          defineNamedTypeAssign(n, parent);\n+\n+          // Handle initialization of properties.\n+          Node firstChild = n.getFirstChild();\n+          if (firstChild.getType() == Token.GETPROP &&\n+              firstChild.isQualifiedName()) {\n+            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n+                firstChild, n, firstChild.getNext());\n+          }\n+          break;\n+\n+        case Token.CATCH:\n+          defineCatch(n, parent);\n+          break;\n+\n+        case Token.VAR:\n+          defineVar(n, parent);\n+          break;\n+\n+        case Token.GETPROP:\n+          // Handle stubbed properties.\n+          if (parent.getType() == Token.EXPR_RESULT &&\n+              n.isQualifiedName()) {\n+            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n+          }\n+          break;\n+      }\n+    }\n \n     /**\n      * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n         Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n       FunctionType functionType = null;\n \n-      // Handle function aliases.\n-      if (rValue != null && rValue.isQualifiedName()) {\n+      // Global function aliases should be registered with the type registry.\n+      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n         Var var = scope.getVar(rValue.getQualifiedName());\n         if (var != null && var.getType() instanceof FunctionType) {\n           functionType = (FunctionType) var.getType();\n         }\n       }\n     }\n-  }\n-\n-  /**\n-   * A shallow traversal of the global scope to build up all classes,\n-   * functions, and methods.\n-   */\n-  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n-\n-    /**\n-     * Functions that we found in the global scope and not in externs.\n-     */\n-    private final List<Node> nonExternFunctions = Lists.newArrayList();\n-\n-    /**\n-     * Type-less stubs in the global scope.\n+\n+    /**\n+     * Look for a type declaration on a GETPROP node.\n      *\n-     * If at the end of traversal, we still don't have types for these\n-     * stubs, then we should declare UNKNOWN types.\n-     */\n-    private final List<StubDeclaration> stubDeclarations =\n-        Lists.newArrayList();\n-\n-    private GlobalScopeBuilder(Scope scope) {\n-      super(scope);\n-    }\n-\n-    /**\n-     * Visit a node in the global scope, and add anything it declares to the\n-     * global symbol table.\n-     *\n-     * @param t The current traversal.\n-     * @param n The node being visited.\n-     * @param parent The parent of n\n-     */\n-    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      attachLiteralTypes(n);\n-\n-      switch (n.getType()) {\n-        case Token.CALL:\n-          checkForClassDefiningCalls(t, n, parent);\n-          break;\n-\n-        case Token.FUNCTION:\n-          if (!t.getInput().isExtern()) {\n-            nonExternFunctions.add(n);\n-          }\n-\n-          // VARs and ASSIGNs are handled separately.\n-          if (parent.getType() == Token.ASSIGN ||\n-              parent.getType() == Token.NAME) {\n-            return;\n-          }\n-\n-          defineDeclaredFunction(n, parent);\n-          break;\n-\n-        case Token.ASSIGN:\n-          // Handle constructor and enum definitions.\n-          defineNamedTypeAssign(n, parent);\n-\n-          // Handle typedefs.\n-          checkForOldStyleTypedef(t, n);\n-\n-          // Handle initialization of properties.\n-          Node firstChild = n.getFirstChild();\n-          if (firstChild.getType() == Token.GETPROP &&\n-              firstChild.isQualifiedName()) {\n-            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n-                firstChild, n, firstChild.getNext());\n-          }\n-          break;\n-\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-\n-        case Token.VAR:\n-          defineVar(n, parent);\n-\n-          // Handle typedefs.\n-          if (n.hasOneChild()) {\n-            checkForOldStyleTypedef(t, n);\n-            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n-          }\n-          break;\n-\n-        case Token.GETPROP:\n-          // Handle stubbed properties.\n-          if (parent.getType() == Token.EXPR_RESULT &&\n-              n.isQualifiedName()) {\n-            checkForTypedef(t, n, n.getJSDocInfo());\n-            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n-          }\n-          break;\n+     * @param info The doc info for this property.\n+     * @param n A top-level GETPROP node (it should not be contained inside\n+     *     another GETPROP).\n+     * @param rhsValue The node that {@code n} is being initialized to,\n+     *     or {@code null} if this is a stub declaration.\n+     */\n+    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n+        Node n, Node rhsValue) {\n+      if (info != null && info.hasType()) {\n+        return getDeclaredTypeInAnnotation(t, n, info);\n+      } else if (info != null && info.hasEnumParameterType()) {\n+        return n.getJSType();\n+      } else if (rhsValue != null &&\n+          rhsValue.getType() == Token.FUNCTION) {\n+        return rhsValue.getJSType();\n+      } else {\n+        return getDeclaredTypeInAnnotation(t, n, info);\n       }\n     }\n \n     }\n \n     /**\n-     * Handle typedefs.\n-     * @param t The current traversal.\n-     * @param candidate A qualified name node.\n-     * @param info JSDoc comments.\n-     */\n-    private void checkForTypedef(\n-        NodeTraversal t, Node candidate, JSDocInfo info) {\n-      if (info == null || !info.hasTypedefType()) {\n-        return;\n-      }\n-\n-      String typedef = candidate.getQualifiedName();\n-      if (typedef == null) {\n-        return;\n-      }\n-\n-      // TODO(nicksantos|user): This is a terrible, terrible hack\n-      // to bail out on recusive typedefs. We'll eventually need\n-      // to handle these properly.\n-      typeRegistry.forwardDeclareType(typedef);\n-\n-      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n-      if (realType == null) {\n-        compiler.report(\n-            JSError.make(\n-                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n-      }\n-\n-      typeRegistry.declareType(typedef, realType);\n-      if (candidate.getType() == Token.GETPROP) {\n-        defineSlot(candidate, candidate.getParent(),\n-            getNativeType(NO_TYPE), false);\n-      }\n-    }\n-\n-    /**\n-     * Handle typedefs.\n-     * @param t The current traversal.\n-     * @param candidate An ASSIGN or VAR node.\n-     */\n-    // TODO(nicksantos): Kill this.\n-    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {\n-      // old-style typedefs\n-      String typedef = codingConvention.identifyTypeDefAssign(candidate);\n-      if (typedef != null) {\n-        // TODO(nicksantos|user): This is a terrible, terrible hack\n-        // to bail out on recusive typedefs. We'll eventually need\n-        // to handle these properly.\n-        typeRegistry.forwardDeclareType(typedef);\n-\n-        JSDocInfo info = candidate.getJSDocInfo();\n-        JSType realType = null;\n-        if (info != null && info.getType() != null) {\n-          realType = info.getType().evaluate(scope, typeRegistry);\n-        }\n-\n-        if (realType == null) {\n-          compiler.report(\n-              JSError.make(\n-                  t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n-        }\n-\n-        typeRegistry.declareType(typedef, realType);\n-\n-        // Duplicate typedefs get handled when we try to register\n-        // this typedef in the scope.\n-      }\n-    }\n-\n-    /**\n      * Declare the symbol for a qualified name in the global scope.\n      *\n      * @param info The doc info for this property.\n      * @param rhsValue The node that {@code n} is being initialized to,\n      *     or {@code null} if this is a stub declaration.\n      */\n-    private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n+    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n         Node n, Node parent, Node rhsValue) {\n       Node ownerNode = n.getFirstChild();\n       String ownerName = ownerNode.getQualifiedName();\n       if (valueType == null) {\n         if (parent.getType() == Token.EXPR_RESULT) {\n           stubDeclarations.add(new StubDeclaration(\n-              n, t.getInput().isExtern(), ownerName));\n+              n,\n+              t.getInput() != null && t.getInput().isExtern(),\n+              ownerName));\n         }\n \n         return;\n         if (ownerType != null) {\n           // Only declare this as an official property if it has not been\n           // declared yet.\n-          boolean isExtern = t.getInput().isExtern();\n+          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n           if ((!ownerType.hasOwnProperty(propName) ||\n                ownerType.isPropertyTypeInferred(propName)) &&\n               ((isExtern && !ownerType.isNativeObjectType()) ||\n     }\n \n     /**\n-     * Look for a type declaration on a GETPROP node.\n-     *\n-     * @param info The doc info for this property.\n-     * @param n A top-level GETPROP node (it should not be contained inside\n-     *     another GETPROP).\n-     * @param rhsValue The node that {@code n} is being initialized to,\n-     *     or {@code null} if this is a stub declaration.\n-     */\n-    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n-        Node n, Node rhsValue) {\n-      if (info != null && info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-      } else if (info != null && info.hasEnumParameterType()) {\n-        return n.getJSType();\n-      } else if (rhsValue != null &&\n-          rhsValue.getType() == Token.FUNCTION) {\n-        return rhsValue.getJSType();\n-      } else {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-      }\n-    }\n-\n-    /**\n      * Resolve any stub delcarations to unknown types if we could not\n      * find types for them during traversal.\n      */\n-    private void resolveStubDeclarations() {\n+    void resolveStubDeclarations() {\n       for (StubDeclaration stub : stubDeclarations) {\n         Node n = stub.node;\n         Node parent = n.getParent();\n     }\n \n     /**\n-     * A stub declaration without any type information.\n-     */\n-    private final class StubDeclaration {\n-      private final Node node;\n-      private final boolean isExtern;\n-      private final String ownerName;\n-\n-      private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n-        this.node = node;\n-        this.isExtern = isExtern;\n-        this.ownerName = ownerName;\n-      }\n-    }\n-\n-    /**\n      * Collects all declared properties in a function, and\n      * resolves them relative to the global scope.\n      */\n         }\n       }\n     } // end CollectProperties\n+  }\n+\n+  /**\n+   * A stub declaration without any type information.\n+   */\n+  private static final class StubDeclaration {\n+    private final Node node;\n+    private final boolean isExtern;\n+    private final String ownerName;\n+\n+    private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n+      this.node = node;\n+      this.isExtern = isExtern;\n+      this.ownerName = ownerName;\n+    }\n+  }\n+\n+  /**\n+   * A shallow traversal of the global scope to build up all classes,\n+   * functions, and methods.\n+   */\n+  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n+\n+    private GlobalScopeBuilder(Scope scope) {\n+      super(scope);\n+    }\n+\n+    /**\n+     * Visit a node in the global scope, and add anything it declares to the\n+     * global symbol table.\n+     *\n+     * @param t The current traversal.\n+     * @param n The node being visited.\n+     * @param parent The parent of n\n+     */\n+    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+      super.visit(t, n, parent);\n+\n+      switch (n.getType()) {\n+\n+        case Token.ASSIGN:\n+          // Handle typedefs.\n+          checkForOldStyleTypedef(t, n);\n+          break;\n+\n+        case Token.VAR:\n+          // Handle typedefs.\n+          if (n.hasOneChild()) {\n+            checkForOldStyleTypedef(t, n);\n+            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n+          }\n+          break;\n+      }\n+    }\n+\n+    @Override\n+    void maybeDeclareQualifiedName(\n+        NodeTraversal t, JSDocInfo info,\n+        Node n, Node parent, Node rhsValue) {\n+      checkForTypedef(t, n, info);\n+      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n+    }\n+\n+    /**\n+     * Handle typedefs.\n+     * @param t The current traversal.\n+     * @param candidate A qualified name node.\n+     * @param info JSDoc comments.\n+     */\n+    private void checkForTypedef(\n+        NodeTraversal t, Node candidate, JSDocInfo info) {\n+      if (info == null || !info.hasTypedefType()) {\n+        return;\n+      }\n+\n+      String typedef = candidate.getQualifiedName();\n+      if (typedef == null) {\n+        return;\n+      }\n+\n+      // TODO(nicksantos|user): This is a terrible, terrible hack\n+      // to bail out on recusive typedefs. We'll eventually need\n+      // to handle these properly.\n+      typeRegistry.forwardDeclareType(typedef);\n+\n+      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n+      if (realType == null) {\n+        compiler.report(\n+            JSError.make(\n+                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n+      }\n+\n+      typeRegistry.declareType(typedef, realType);\n+      if (candidate.getType() == Token.GETPROP) {\n+        defineSlot(candidate, candidate.getParent(),\n+            getNativeType(NO_TYPE), false);\n+      }\n+    }\n+\n+    /**\n+     * Handle typedefs.\n+     * @param t The current traversal.\n+     * @param candidate An ASSIGN or VAR node.\n+     */\n+    // TODO(nicksantos): Kill this.\n+    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {\n+      // old-style typedefs\n+      String typedef = codingConvention.identifyTypeDefAssign(candidate);\n+      if (typedef != null) {\n+        // TODO(nicksantos|user): This is a terrible, terrible hack\n+        // to bail out on recusive typedefs. We'll eventually need\n+        // to handle these properly.\n+        typeRegistry.forwardDeclareType(typedef);\n+\n+        JSDocInfo info = candidate.getJSDocInfo();\n+        JSType realType = null;\n+        if (info != null && info.getType() != null) {\n+          realType = info.getType().evaluate(scope, typeRegistry);\n+        }\n+\n+        if (realType == null) {\n+          compiler.report(\n+              JSError.make(\n+                  t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n+        }\n+\n+        typeRegistry.declareType(typedef, realType);\n+\n+        // Duplicate typedefs get handled when we try to register\n+        // this typedef in the scope.\n+      }\n+    }\n   } // end GlobalScopeBuilder\n \n   /**\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          // VARs and ASSIGNs are handled separately.\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+      super.visit(t, n, parent);\n     }\n \n     /** Handle bleeding functions and function parameters. */\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     assertFalse(x.isPropertyTypeInferred(\"foo\"));\n   }\n \n+  public void testCollectedFunctionStubLocal() {\n+    testSame(\n+        \"(function() {\" +\n+        \"/** @constructor */ function f() { \" +\n+        \"  /** @return {number} */ this.foo;\" +\n+        \"}\" +\n+        \"var x = new f();\" +\n+        \"});\");\n+    ObjectType x = (ObjectType) findNameType(\"x\", lastLocalScope);\n+    assertEquals(\"f\", x.toString());\n+    assertTrue(x.hasProperty(\"foo\"));\n+    assertEquals(\"function (this:f): number\",\n+        x.getPropertyType(\"foo\").toString());\n+    assertFalse(x.isPropertyTypeInferred(\"foo\"));\n+  }\n+\n   public void testNamespacedFunctionStub() {\n     testSame(\n         \"var goog = {};\" +\n     assertTrue(goog.isPropertyTypeDeclared(\"foo\"));\n \n     assertEquals(globalScope.getVar(\"goog.foo\").getType(),\n+        goog.getPropertyType(\"foo\"));\n+  }\n+\n+  public void testNamespacedFunctionStubLocal() {\n+    testSame(\n+        \"(function() {\" +\n+        \"var goog = {};\" +\n+        \"/** @param {number} x */ goog.foo;\" +\n+        \"});\");\n+\n+    ObjectType goog = (ObjectType) findNameType(\"goog\", lastLocalScope);\n+    assertTrue(goog.hasProperty(\"foo\"));\n+    assertEquals(\"function (number): ?\",\n+        goog.getPropertyType(\"foo\").toString());\n+    assertTrue(goog.isPropertyTypeDeclared(\"foo\"));\n+\n+    assertEquals(lastLocalScope.getVar(\"goog.foo\").getType(),\n         goog.getPropertyType(\"foo\"));\n   }\n ", "timestamp": 1284405623, "metainfo": ""}