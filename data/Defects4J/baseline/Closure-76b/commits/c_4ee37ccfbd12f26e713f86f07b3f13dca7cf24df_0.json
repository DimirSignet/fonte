{"sha": "4ee37ccfbd12f26e713f86f07b3f13dca7cf24df", "log": "Don't inline parameters when arguments object is escaped.  R=johnlenz DELTA=35  (23 added, 8 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=949   ", "commit": "\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n               n.getLastChild(), output);\n             return;\n           } else if (NodeUtil.isGet(n.getFirstChild())) {\n-\n             // Treat all assignments to arguments as redefining the\n             // parameters itself.\n             Node obj = n.getFirstChild().getFirstChild();\n-            // TODO(user): More accuracy can be introduced\n-            // ie: We know exactly what arguments[x] is if x is a constant\n-            // number.\n             if (NodeUtil.isName(obj) && \"arguments\".equals(obj.getString())) {\n-              for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {\n-                Var v = i.next();\n-                if (v.getParentNode().getType() == Token.LP) {\n-                  // Assume we no longer know where the parameter comes from\n-                  // anymore.\n-                  output.reachingDef.put(v, null);\n-                }\n-              }\n+              // TODO(user): More accuracy can be introduced\n+              // ie: We know exactly what arguments[x] is if x is a constant\n+              // number.\n+              escapeParameters(output);\n             }\n           }\n+        }\n+\n+        if (NodeUtil.isName(n) && \"arguments\".equals(n.getString())) {\n+          escapeParameters(output);\n         }\n \n         // DEC and INC actually defines the variable.\n           computeDependence(definition, rValue);\n         }\n         def.reachingDef.put(var, definition);\n+      }\n+    }\n+  }\n+\n+  private void escapeParameters(MustDef output) {\n+    for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {\n+      Var v = i.next();\n+      if (v.getParentNode().getType() == Token.LP) {\n+        // Assume we no longer know where the parameter comes from\n+        // anymore.\n+        output.reachingDef.put(v, null);\n       }\n     }\n   }\n--- a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n \n   public void testInvalidInlineArguments() {\n     testSame(\"function f(x, y) { x = 1; arguments[0] = 2; print(x) }\");\n+    testSame(\"function f(x, y) { x = 1; var z = arguments;\" +\n+        \"z[0] = 2; z[1] = 3; print(x)}\");\n+    testSame(\"function g(a){a[0]=2} function f(x){x=1;g(arguments);print(x)}\");\n   }\n \n   private void noInline(String input) {\n--- a/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n+++ b/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n \n   public void testArgumentsObjectModifications() {\n     computeDefUse(\"D: param1 = 1; arguments[0] = 2; U: param1\");\n+    assertNotSame(def, defUse.getDef(\"param1\", use));\n+  }\n+\n+  public void testArgumentsObjectEscaped() {\n+    computeDefUse(\"D: param1 = 1; var x = arguments; x[0] = 2; U: param1\");\n     assertNotSame(def, defUse.getDef(\"param1\", use));\n   }\n ", "timestamp": 1300481927, "metainfo": ""}