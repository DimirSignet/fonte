{"sha": "52ee613aac16221a15fa8ba3b9bbc14b56ce8fb7", "log": "-Make OptimizeReturns much faster (don't have exact measurements, but from the logs, OptimizeCalls goes from from 3 seconds to < 1 second).  R=johnlenz DELTA=49  (19 added, 18 deleted, 12 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=811   ", "commit": "\n--- a/src/com/google/javascript/jscomp/OptimizeReturns.java\n+++ b/src/com/google/javascript/jscomp/OptimizeReturns.java\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n \n import java.util.Collection;\n+import java.util.List;\n \n /**\n  * A compiler pass for optimize function return results.  Currently this\n   @Override\n   public void process(\n       Node externs, Node root, SimpleDefinitionFinder definitions) {\n-    // Create a snapshot of the definition sites to iterate over\n-    // as they can be removed during processing.\n-    for (DefinitionSite defSite :\n-        definitions.getDefinitionSites().toArray(new DefinitionSite[0])) {\n-      if (definitions.getDefinitionSites().contains(defSite)) {\n-        optimizeResultsIfEligible(defSite, definitions);\n+    // Find all function nodes whose callers ignore the return values.\n+    List<Node> toOptimize = Lists.newArrayList();\n+    for (DefinitionSite defSite : definitions.getDefinitionSites()) {\n+      if (!defSite.inExterns && !callResultsMaybeUsed(definitions, defSite)) {\n+        toOptimize.add(defSite.definition.getRValue());\n       }\n     }\n-  }\n-\n-  /**\n-   * Rewrites method results sites if the method results are never used.\n-   *\n-   * Definition and use site information is provided by the\n-   * {@link SimpleDefinitionFinder} passed in as an argument.\n-   *\n-   * @param defSite definition site to process.\n-   * @param defFinder structure that hold Node -> Definition and\n-   * Definition -> [UseSite] maps.\n-   */\n-  private void optimizeResultsIfEligible(\n-      DefinitionSite defSite, SimpleDefinitionFinder defFinder) {\n-\n-    if (defSite.inExterns || callResultsMaybeUsed(defFinder, defSite)) {\n-      return;\n-    }\n-\n-    rewriteReturns(defFinder, defSite.definition.getRValue());\n+    // Optimize the return statements.\n+    for (Node node : toOptimize) {\n+      rewriteReturns(definitions, node);\n+    }\n   }\n \n   /**\n     }\n \n     Collection<UseSite> useSites = defFinder.getUseSites(definition);\n-    \n+\n     // Don't modify unused definitions for two reasons:\n     // 1) It causes unnecessary churn\n     // 2) Other definitions might be used to reflect on this one using\n     //    goog.reflect.object (the check for definitions with uses is below).\n     if (useSites.isEmpty()) {\n       return true;\n-    }    \n-    \n+    }\n+\n     for (UseSite site : useSites) {\n       // This catches the case where an object literal in goog.reflect.object\n       // and a prototype method have the same property name.\n--- a/test/com/google/javascript/jscomp/OptimizeReturnsTest.java\n+++ b/test/com/google/javascript/jscomp/OptimizeReturnsTest.java\n         \"function c() { return b() }\",\n         \"c();\");\n \n-    // TODO(johnlenz): It would be better if we do some kind of fixed point.\n     String expected = newlineJoin(\n         \"function a() { return 1 }\",\n         \"function b() { return a() }\",\n         \"function b() { return a() }\",\n         \"function a() { return 1 }\");\n \n-\n-    // TODO(johnlenz): It would be better if we do some kind of fixed point.\n-    String expected = newlineJoin(\n+    // Iteration 1.\n+    String expected = newlineJoin(\n+        \"c();\",\n+        \"function c() { b(); return }\",\n+        \"function b() { return a() }\",\n+        \"function a() { return 1 }\");\n+    test(source, expected);\n+\n+    // Iteration 2.\n+    source = expected;\n+    expected = newlineJoin(\n+        \"c();\",\n+        \"function c() { b(); return }\",\n+        \"function b() { a(); return }\",\n+        \"function a() { return 1 }\");\n+    test(source, expected);\n+\n+    // Iteration 3.\n+    source = expected;\n+    expected = newlineJoin(\n         \"c();\",\n         \"function c() { b(); return }\",\n         \"function b() { a(); return }\",\n         \"x.a()\");\n     test(source, result);\n   }\n-  \n+\n   public void testPrototypeMethod2() throws Exception {\n     String source = newlineJoin(\n         \"function c(){}\",\n         \"c.prototype.a = function(){return 1}\",\n         \"goog.reflect.object({a: 'v'})\",\n         \"var x = new c;\",\n-        \"x.a()\");    \n-    testSame(source);\n-  }  \n-  \n+        \"x.a()\");\n+    testSame(source);\n+  }\n+\n   public void testPrototypeMethod3() throws Exception {\n     String source = newlineJoin(\n         \"function c(){}\",\n         \"c.prototype.a = function(){return 1}\",\n         \"var x = new c;\",\n         \"for(var key in goog.reflect.object({a: 'v'})){ x[key](); }\",\n-        \"x.a()\");    \n-    testSame(source);\n-  } \n-  \n+        \"x.a()\");\n+    testSame(source);\n+  }\n+\n   public void testPrototypeMethod4() throws Exception {\n     String source = newlineJoin(\n         \"function c(){}\",\n         \"c.prototype.a = function(){return 1}\",\n         \"var x = new c;\",\n-        \"for(var key in goog.reflect.object({a: 'v'})){ x[key](); }\");    \n-    testSame(source);\n-  }  \n+        \"for(var key in goog.reflect.object({a: 'v'})){ x[key](); }\");\n+    testSame(source);\n+  }\n \n   public void testCallOrApply() throws Exception {\n     // TODO(johnlenz): Add support for .call and .apply", "timestamp": 1299769780, "metainfo": ""}