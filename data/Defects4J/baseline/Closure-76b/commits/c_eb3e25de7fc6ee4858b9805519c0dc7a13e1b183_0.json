{"sha": "eb3e25de7fc6ee4858b9805519c0dc7a13e1b183", "log": "Add support for \"@modifies{this}\" and \"@modifies{arguments}\".  R=nicksantos DELTA=220  (218 added, 0 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=244022   ", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/Annotation.java\n+++ b/src/com/google/javascript/jscomp/parsing/Annotation.java\n   JAVA_DISPATCH,\n   LICENSE, // same as preserve\n   MEANING,\n+  MODIFIES,\n   NO_ALIAS,\n   NO_COMPILE,\n   NO_SHADOW,\n       put(\"javadispatch\", Annotation.JAVA_DISPATCH).\n       put(\"license\", Annotation.LICENSE).\n       put(\"meaning\", Annotation.MEANING).\n+      put(\"modifies\", Annotation.MODIFIES).\n       put(\"noalias\", Annotation.NO_ALIAS).\n       put(\"nocompile\", Annotation.NO_COMPILE).\n       put(\"noshadow\", Annotation.NO_SHADOW).\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n package com.google.javascript.jscomp.parsing;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n \n   private final Map<String, Annotation> annotationNames;\n   private final Set<String> suppressionNames;\n+  static private final Set<String> modifiesAnnotationKeywords =\n+      ImmutableSet.<String>of(\"this\", \"arguments\");\n \n   private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;\n \n                   token = eatTokensUntilEOL();\n                   continue retry;\n \n+                case MODIFIES:\n+                  token = parseModifiesTag(next());\n+                  continue retry;\n+\n                 case IMPLICIT_CAST:\n                   if (!jsdocBuilder.recordImplicitCast()) {\n                     parser.addWarning(\"msg.jsdoc.implicitcast\",\n         token = next();\n         if (!jsdocBuilder.recordSuppressions(suppressions)) {\n           parser.addWarning(\"msg.jsdoc.suppress.duplicate\",\n+              stream.getLineno(), stream.getCharno());\n+        }\n+      }\n+    }\n+    return token;\n+  }\n+\n+  /**\n+   * Parse a {@code @modifies} tag of the form\n+   * {@code @modifies&#123;this|arguments|param&#125;}.\n+   *\n+   * @param token The current token.\n+   */\n+  private JsDocToken parseModifiesTag(JsDocToken token) {\n+    if (token == JsDocToken.LC) {\n+      Set<String> modifies = new HashSet<String>();\n+      while (true) {\n+        if (match(JsDocToken.STRING)) {\n+          String name = stream.getString();\n+          if (!modifiesAnnotationKeywords.contains(name)\n+              && !jsdocBuilder.hasParameter(name)) {\n+              parser.addWarning(\"msg.jsdoc.modifies.unknown\", name,\n+                  stream.getLineno(), stream.getCharno());\n+          }\n+\n+          modifies.add(stream.getString());\n+          token = next();\n+        } else {\n+          parser.addWarning(\"msg.jsdoc.modifies\",\n+              stream.getLineno(), stream.getCharno());\n+          return token;\n+        }\n+\n+        if (match(JsDocToken.PIPE)) {\n+          token = next();\n+        } else {\n+          break;\n+        }\n+      }\n+\n+      if (!match(JsDocToken.RC)) {\n+        parser.addWarning(\"msg.jsdoc.modifies\",\n+            stream.getLineno(), stream.getCharno());\n+      } else {\n+        token = next();\n+        if (!jsdocBuilder.recordModifies(modifies)) {\n+          parser.addWarning(\"msg.jsdoc.modifies.duplicate\",\n               stream.getLineno(), stream.getCharno());\n         }\n       }\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n     String deprecated = null;\n     String license = null;\n     Set<String> suppressions = null;\n+    Set<String> modifies = null;\n   }\n \n   private static final class LazilyInitializedDocumentation {\n   }\n \n   /**\n+   * Add modifies values.\n+   */\n+  void addModifies(String modifies) {\n+    lazyInitInfo();\n+\n+    if (info.modifies == null) {\n+      info.modifies = Sets.newHashSet();\n+    }\n+    info.modifies.add(modifies);\n+  }\n+\n+  /**\n+   * Sets modifies values.\n+   * @param modifies A list of modifies types.\n+   */\n+  boolean setModifies(Set<String> modifies) {\n+    lazyInitInfo();\n+\n+    if (info.modifies != null) {\n+      return false;\n+    }\n+\n+    info.modifies = modifies;\n+    return true;\n+  }\n+\n+  /**\n    * Documents the version.\n    */\n   boolean documentVersion(String version) {\n   public Set<String> getSuppressions() {\n     Set<String> suppressions = info == null ? null : info.suppressions;\n     return suppressions == null ? Collections.<String>emptySet() : suppressions;\n+  }\n+\n+  /**\n+   * Returns the set of sideeffect notations.\n+   */\n+  public Set<String> getModifies() {\n+    Set<String> modifies = info == null ? null : info.modifies;\n+    return modifies == null ? Collections.<String>emptySet() : modifies;\n   }\n \n   /**\n \n     return nodes;\n   }\n+\n+  public boolean hasModifies() {\n+    return info != null && info.modifies != null;\n+  }\n }\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n   }\n \n   /**\n+   * Records the list of modifies warnings.\n+   */\n+  public boolean recordModifies(Set<String> modifies) {\n+    if (!hasAnySingletonSideEffectTags()\n+        && currentInfo.setModifies(modifies)) {\n+      populated = true;\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  /**\n    * Records a type.\n    *\n    * @return {@code true} if the type was recorded and {@code false} if\n    * {@link JSDocInfo#isNoSideEffects()} flag set to {@code true}.\n    */\n   public boolean recordNoSideEffects() {\n-    if (!currentInfo.isNoSideEffects()) {\n+    if (!hasAnySingletonSideEffectTags()\n+        && !currentInfo.isNoSideEffects()) {\n       currentInfo.setNoSideEffects(true);\n       populated = true;\n       return true;\n         currentInfo.hasTypedefType() ||\n         currentInfo.hasEnumParameterType();\n   }\n+\n+  /**\n+   * Whether the current doc info has any of the singleton type\n+   * tags that may not appear with other type tags, like\n+   * {@code @type} or {@code @typedef}.\n+   */\n+  private boolean hasAnySingletonSideEffectTags() {\n+    return currentInfo.isNoSideEffects() ||\n+        currentInfo.hasModifies();\n+  }\n+\n }\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n   public void testBadSuppress7() throws Exception {\n     parse(\"@suppress {impossible} */\",\n           \"unknown @suppress parameter: impossible\");\n+  }\n+\n+  public void testModifies1() throws Exception {\n+    JSDocInfo info = parse(\"@modifies {this} */\");\n+    assertEquals(Sets.newHashSet(\"this\"), info.getModifies());\n+  }\n+\n+  public void testModifies2() throws Exception {\n+    JSDocInfo info = parse(\"@modifies {arguments} */\");\n+    assertEquals(Sets.newHashSet(\"arguments\"), info.getModifies());\n+  }\n+\n+  public void testModifies3() throws Exception {\n+    JSDocInfo info = parse(\"@modifies {this|arguments} */\");\n+    assertEquals(Sets.newHashSet(\"this\", \"arguments\"), info.getModifies());\n+  }\n+\n+  public void testModifies4() throws Exception {\n+    JSDocInfo info = parse(\"@param {*} x\\n * @modifies {x} */\");\n+    assertEquals(Sets.newHashSet(\"x\"), info.getModifies());\n+  }\n+\n+  public void testModifies5() throws Exception {\n+    JSDocInfo info = parse(\n+        \"@param {*} x\\n\"\n+        + \" * @param {*} y\\n\"\n+        + \" * @modifies {x} */\");\n+    assertEquals(Sets.newHashSet(\"x\"), info.getModifies());\n+  }\n+\n+  public void testModifies6() throws Exception {\n+    JSDocInfo info = parse(\n+        \"@param {*} x\\n\"\n+        + \" * @param {*} y\\n\"\n+        + \" * @modifies {x|y} */\");\n+    assertEquals(Sets.newHashSet(\"x\", \"y\"), info.getModifies());\n+  }\n+\n+\n+  public void testBadModifies1() throws Exception {\n+    parse(\"@modifies {} */\", \"malformed @modifies tag\");\n+  }\n+\n+  public void testBadModifies2() throws Exception {\n+    parse(\"@modifies {this|} */\", \"malformed @modifies tag\");\n+  }\n+\n+  public void testBadModifies3() throws Exception {\n+    parse(\"@modifies {|this} */\", \"malformed @modifies tag\");\n+  }\n+\n+  public void testBadModifies4() throws Exception {\n+    parse(\"@modifies {this|arguments */\", \"malformed @modifies tag\");\n+  }\n+\n+  public void testBadModifies5() throws Exception {\n+    parse(\"@modifies {this,arguments} */\", \"malformed @modifies tag\");\n+  }\n+\n+  public void testBadModifies6() throws Exception {\n+    parse(\"@modifies {this} \\n * @modifies {this} */\", \n+        \"conflicting @modifies tag\");\n+  }\n+\n+  public void testBadModifies7() throws Exception {\n+    parse(\"@modifies {impossible} */\",\n+          \"unknown @modifies parameter: impossible\");\n+  }\n+\n+  public void testBadModifies8() throws Exception {\n+    parse(\"@modifies {this}\\n\"\n+        + \"@nosideeffects */\", \"conflicting @nosideeffects tag\");\n+  }\n+\n+  public void testBadModifies9() throws Exception {\n+    parse(\"@nosideeffects\\n\"\n+        + \"@modifies {this} */\", \"conflicting @modifies tag\");\n   }\n \n   //public void testNoParseFileOverview() throws Exception {\n--- a/test/com/google/javascript/rhino/JSDocInfoTest.java\n+++ b/test/com/google/javascript/rhino/JSDocInfoTest.java\n     assertEquals(Sets.newHashSet(\"bob\", \"sam\"), info.getSuppressions());\n   }\n \n+  public void testSetModifies() {\n+    JSDocInfo info = new JSDocInfo(true);\n+    info.setModifies(Sets.newHashSet(\"this\"));\n+    assertEquals(Sets.newHashSet(\"this\"), info.getModifies());\n+\n+    info = new JSDocInfo(true);\n+    info.setModifies(Sets.newHashSet(\"arguments\"));\n+    assertEquals(Sets.newHashSet(\"arguments\"), info.getModifies());\n+  }  \n+\n   /** Gets the type expression for a simple type name. */\n   private JSTypeExpression fromString(String s) {\n     return new JSTypeExpression(Node.newString(s), \"\");", "timestamp": 1285197546, "metainfo": ""}