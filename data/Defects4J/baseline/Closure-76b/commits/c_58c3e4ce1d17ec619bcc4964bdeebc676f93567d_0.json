{"sha": "58c3e4ce1d17ec619bcc4964bdeebc676f93567d", "log": "Change on 2010/05/03 by robby          Preliminary: goog.scope support for closure-compiler          R=nick,john         DELTA=318  (318 added, 0 deleted, 0 changed)  Change on 2010/05/03 by nick          Add a bit more smarts to type resolution. Also, give it a         \"forceResolve\" method so that it will try to resolve type names,         even if the registry is in a lazy mode.          R=robert         DELTA=205  (133 added, 54 deleted, 18 changed)  Change on 2010/05/03 by alan          Enable Flow Sensitive Inlining by default. Passes GMail automation test.          R=nick         DELTA=1  (0 added, 0 deleted, 1 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=cmvhwl   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Process aliases in goog.scope blocks.\n+ *\n+ * goog.scope(function() {\n+ *   var dom = goog.dom;\n+ *   var DIV = dom.TagName.DIV;\n+ *\n+ *   dom.createElement(DIV);\n+ * });\n+ *\n+ * should become\n+ *\n+ * goog.dom.createElement(goog.dom.TagName.DIV);\n+ *\n+ * @author robbyw@google.com (Robby Walker)\n+ */\n+class ScopedAliases implements CompilerPass {\n+  /** Name used to denote an scoped function block used for aliasing. */\n+  static final String SCOPING_METHOD_NAME = \"goog.scope\";\n+\n+  final AbstractCompiler compiler;\n+\n+  ScopedAliases(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    Traversal traversal = new Traversal();\n+    NodeTraversal.traverse(compiler, root, traversal);\n+\n+    // Apply the aliases.\n+    for (AliasedNode entry : traversal.getAliasUsages()) {\n+      entry.getAliasReference().getParent().replaceChild(\n+          entry.getAliasReference(),\n+          entry.getAliasDefinition().cloneTree());\n+    }\n+\n+    // Remove the alias definitions.\n+    for (Node aliasDefinition : traversal.getAliasDefinitions()) {\n+      if (aliasDefinition.getParent().getType() == Token.VAR &&\n+          aliasDefinition.getParent().getChildCount() == 1) {\n+        aliasDefinition.getParent().detachFromParent();\n+      } else {\n+        aliasDefinition.detachFromParent();\n+      }\n+    }\n+\n+    // Collapse the scopes.\n+    for (Node scopeCall : traversal.getScopeCalls()) {\n+      Node expressionWithScopeCall = scopeCall.getParent();\n+      Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n+      scopeClosureBlock.detachFromParent();\n+      expressionWithScopeCall.getParent().replaceChild(\n+          expressionWithScopeCall,\n+          scopeClosureBlock);\n+      NodeUtil.tryMergeBlock(scopeClosureBlock);\n+    }\n+\n+    if (traversal.getAliasUsages().size() > 0 ||\n+        traversal.getAliasDefinitions().size() > 0 ||\n+        traversal.getScopeCalls().size() > 0) {\n+      compiler.reportCodeChange();\n+    }\n+  }\n+\n+  private class AliasedNode {\n+    private final Node aliasReference;\n+\n+    private final Node aliasDefinition;\n+\n+    AliasedNode(Node aliasReference, Node aliasDefinition) {\n+      this.aliasReference = aliasReference;\n+      this.aliasDefinition = aliasDefinition;\n+    }\n+\n+    public Node getAliasReference() {\n+      return aliasReference;\n+    }\n+\n+    public Node getAliasDefinition() {\n+      return aliasDefinition;\n+    }\n+  }\n+\n+  private class Traversal implements NodeTraversal.ScopedCallback {\n+    // The job of this class is to collect these three data sets.\n+    private List<Node> aliasDefinitions = Lists.newArrayList();\n+\n+    private List<Node> scopeCalls = Lists.newArrayList();\n+\n+    private List<AliasedNode> aliasUsages = Lists.newArrayList();\n+\n+    // This map is temporary and cleared for each scope.\n+    private Map<String, Node> aliases = Maps.newHashMap();\n+\n+\n+    List<Node> getAliasDefinitions() {\n+      return aliasDefinitions;\n+    }\n+\n+    private List<AliasedNode> getAliasUsages() {\n+      return aliasUsages;\n+    }\n+\n+    List<Node> getScopeCalls() {\n+      return scopeCalls;\n+    }\n+\n+    private boolean isCallToScopeMethod(Node n) {\n+      return n.getType() == Token.CALL &&\n+          SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName());\n+    }\n+\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {\n+      if (t.getScopeDepth() == 2) {\n+        aliases.clear();\n+      }\n+    }\n+\n+    @Override\n+    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() == Token.FUNCTION && t.inGlobalScope()) {\n+        // Do not traverse in to functions except for goog.scope functions.\n+        if (parent == null || !isCallToScopeMethod(parent)) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (isCallToScopeMethod(n)) {\n+        // TODO(robbyw): Report an error if the call is not at the root of an\n+        // expression: NodeUtil.isExpressionNode(parent)\n+        // TODO(robbyw): Report an error if the parameter is not anonymous\n+        // or has extra parameters.\n+        // Node firstParam = n.getFirstChild().getNext();\n+        // NodeUtil.isFunction(firstParam);\n+        // NodeUtil.getFunctionName(firstParam).isEmpty();\n+        // NodeUtil.getFnParameters(firstParam).hasChildren();\n+        scopeCalls.add(n);\n+      }\n+\n+      if (t.getScopeDepth() == 2) {\n+        if (n.getType() == Token.NAME && parent.getType() == Token.VAR) {\n+          if (n.hasChildren() && n.isQualifiedName()) {\n+            // TODO(robbyw): What other checks go here?\n+\n+            aliases.put(n.getString(), n.getFirstChild());\n+            aliasDefinitions.add(n);\n+\n+            // Undeclare the variable.\n+            t.getScope().undeclare(t.getScope().getVar(n.getString()));\n+\n+            // If we found an alias, we are done.\n+            return;\n+          }\n+        }\n+      }\n+\n+      if (t.getScopeDepth() >= 2) {\n+        if (n.getType() == Token.NAME) {\n+          // TODO(robbyw): Check if the name is overridden locally.\n+          // TODO(robbyw): Check if this is a place where the name is being set.\n+          Node aliasedNode = aliases.get(n.getString());\n+          // The variable should not exist since we undeclared it when we found\n+          // it.  If it does exist, it's because it's been overridden.\n+          if (t.getScope().getVar(n.getString()) == null &&\n+              aliasedNode != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(n, aliasedNode));\n+          }\n+        }\n+\n+        // TODO(robbyw): Disallow RETURN nodes and THIS nodes.\n+      }\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n \n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;\n \n import java.io.Serializable;\n import java.util.Comparator;\n   public abstract <T> T visit(Visitor<T> visitor);\n \n   /**\n+   * Force this type to resolve, even if the registry is in a lazy\n+   * resolving mode.\n+   * @see #resolve\n+   */\n+  public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) {\n+    ResolveMode oldResolveMode = registry.getResolveMode();\n+    registry.setResolveMode(ResolveMode.IMMEDIATE);\n+    JSType result = resolve(t, scope);\n+    registry.setResolveMode(oldResolveMode);\n+    return result;\n+  }\n+\n+\n+  /**\n    * Resolve this type in the given scope.\n    *\n    * The returned value must be equal to {@code this}, as defined by\n     }\n     resolved = true;\n     resolveResult = resolveInternal(t, scope);\n+    resolveResult.setResolvedTypeInternal(resolveResult);\n     return resolveResult;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n     this.resolveMode = mode;\n   }\n \n+  ResolveMode getResolveMode() {\n+    return resolveMode;\n+  }\n+\n   public ErrorReporter getErrorReporter() {\n     return reporter;\n   }\n     enumTypeNames.add(name);\n   }\n \n-\n-  /**\n-   * Creates a RecordType from the nodes representing said record type.\n-   * @param n The node with type info.\n-   * @param sourceName The source file name.\n-   * @param scope A scope for doing type name lookups.\n-   */\n-  public JSType createRecordTypeFromNodes(Node n, String sourceName,\n-      StaticScope<JSType> scope) {\n-\n-    RecordTypeBuilder builder = new RecordTypeBuilder(this);\n-\n-    // For each of the fields in the record type.\n-    for (Node fieldTypeNode = n.getFirstChild();\n-         fieldTypeNode != null;\n-         fieldTypeNode = fieldTypeNode.getNext()) {\n-\n-      // Get the property's name.\n-      Node fieldNameNode = fieldTypeNode;\n-      boolean hasType = false;\n-\n-      if (fieldTypeNode.getType() == Token.COLON) {\n-        fieldNameNode = fieldTypeNode.getFirstChild();\n-        hasType = true;\n-      }\n-\n-      String fieldName = fieldNameNode.getString();\n-\n-      // TODO(user): Move this into the lexer/parser.\n-      // Remove the string literal characters around a field name,\n-      // if any.\n-      if (fieldName.startsWith(\"'\") || fieldName.startsWith(\"\\\"\")) {\n-        fieldName = fieldName.substring(1, fieldName.length() - 1);\n-      }\n-\n-      // Get the property's type.\n-      JSType fieldType = null;\n-\n-      if (hasType) {\n-        // We have a declared type.\n-        fieldType = createFromTypeNodes(\n-            fieldTypeNode.getLastChild(), sourceName, scope);\n-      } else {\n-        // Otherwise, the type is UNKNOWN.\n-        fieldType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n-      }\n-\n-      // Add the property to the record.\n-      builder.addProperty(fieldName, fieldType);\n-    }\n-\n-    return builder.build();\n-  }\n-\n   /**\n    * Creates a JSType from the nodes representing a type.\n    * @param n The node with type info.\n   public JSType createFromTypeNodes(Node n, String sourceName,\n       StaticScope<JSType> scope, boolean forgiving) {\n     if (resolveMode == ResolveMode.LAZY_EXPRESSIONS) {\n-      return new UnresolvedTypeExpression(this, n, sourceName, forgiving);\n-    }\n-\n+      // If the type expression doesn't contain any names, just\n+      // resolve it anyway.\n+      boolean hasNames = hasTypeName(n);\n+      if (hasNames) {\n+        return new UnresolvedTypeExpression(this, n, sourceName, forgiving);\n+      }\n+    }\n+    return createFromTypeNodesInternal(n, sourceName, scope, forgiving);\n+  }\n+\n+  private boolean hasTypeName(Node n) {\n+    if (n.getType() == Token.STRING) {\n+      return true;\n+    }\n+\n+    for (Node child = n.getFirstChild();\n+         child != null; child = child.getNext()) {\n+      if (hasTypeName(child)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /** @see #createFromTypeNodes(Node, String, StaticScope, boolean) */\n+  private JSType createFromTypeNodesInternal(Node n, String sourceName,\n+      StaticScope<JSType> scope, boolean forgiving) {\n     switch (n.getType()) {\n       case Token.LC: // Record type.\n-        return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n+        return createRecordTypeFromNodes(\n+            n.getFirstChild(), sourceName, scope);\n \n       case Token.BANG: // Not nullable\n-        return createFromTypeNodes(\n+        return createFromTypeNodesInternal(\n             n.getFirstChild(), sourceName, scope, forgiving)\n             .restrictByNotNullOrUndefined();\n \n           return getNativeType(UNKNOWN_TYPE);\n         }\n         return createDefaultObjectUnion(\n-            createFromTypeNodes(firstChild, sourceName, scope, forgiving));\n+            createFromTypeNodesInternal(\n+                firstChild, sourceName, scope, forgiving));\n \n       case Token.EQUALS: // Optional\n         return createOptionalType(\n-            createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n+            createFromTypeNodesInternal(\n+                n.getFirstChild(), sourceName, scope, false));\n \n       case Token.ELLIPSIS: // Var args\n         return createOptionalType(\n-            createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n+            createFromTypeNodesInternal(\n+                n.getFirstChild(), sourceName, scope, false));\n \n       case Token.STAR: // The AllType\n         return getNativeType(ALL_TYPE);\n         UnionTypeBuilder builder = new UnionTypeBuilder(this);\n         for (Node child = n.getFirstChild(); child != null;\n              child = child.getNext()) {\n-          builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n+          builder.addAlternate(\n+              createFromTypeNodesInternal(child, sourceName, scope, false));\n         }\n         return builder.build();\n \n               (\"Array\".equals(n.getString()) ||\n                \"Object\".equals(n.getString()))) {\n             JSType parameterType =\n-                createFromTypeNodes(\n-                    typeList.getLastChild(), sourceName, scope);\n+                createFromTypeNodesInternal(\n+                    typeList.getLastChild(), sourceName, scope, false);\n             namedType = new ParameterizedType(\n                 this, (ObjectType) namedType, parameterType);\n             if (typeList.hasMoreThanOneChild()) {\n               JSType indexType =\n-                  createFromTypeNodes(\n-                      typeList.getFirstChild(), sourceName, scope);\n+                  createFromTypeNodesInternal(\n+                      typeList.getFirstChild(), sourceName, scope, false);\n               namedType = new IndexedType(\n                   this, (ObjectType) namedType, indexType);\n             }\n           Node thisNode = current.getFirstChild();\n           thisType =\n               ObjectType.cast(\n-                  createFromTypeNodes(thisNode, sourceName, scope)\n+                  createFromTypeNodesInternal(\n+                      thisNode, sourceName, scope, false)\n                   .restrictByNotNullOrUndefined());\n           if (thisType == null) {\n             reporter.warning(\n                 paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n               } else {\n                 paramBuilder.addVarArgs(\n-                    createFromTypeNodes(\n-                        arg.getFirstChild(), sourceName, scope));\n+                    createFromTypeNodesInternal(\n+                        arg.getFirstChild(), sourceName, scope, false));\n               }\n             } else {\n-              JSType type = createFromTypeNodes(arg, sourceName, scope);\n+              JSType type = createFromTypeNodesInternal(\n+                  arg, sourceName, scope, false);\n               if (arg.getType() == Token.EQUALS) {\n                 boolean addSuccess = paramBuilder.addOptionalParams(type);\n                 if (!addSuccess) {\n           current = current.getNext();\n         }\n \n-        JSType returnType = createFromTypeNodes(current, sourceName, scope);\n+        JSType returnType =\n+            createFromTypeNodesInternal(current, sourceName, scope, false);\n \n         return new FunctionBuilder(this)\n             .withParams(paramBuilder)\n   }\n \n   /**\n+   * Creates a RecordType from the nodes representing said record type.\n+   * @param n The node with type info.\n+   * @param sourceName The source file name.\n+   * @param scope A scope for doing type name lookups.\n+   */\n+  private JSType createRecordTypeFromNodes(Node n, String sourceName,\n+      StaticScope<JSType> scope) {\n+\n+    RecordTypeBuilder builder = new RecordTypeBuilder(this);\n+\n+    // For each of the fields in the record type.\n+    for (Node fieldTypeNode = n.getFirstChild();\n+         fieldTypeNode != null;\n+         fieldTypeNode = fieldTypeNode.getNext()) {\n+\n+      // Get the property's name.\n+      Node fieldNameNode = fieldTypeNode;\n+      boolean hasType = false;\n+\n+      if (fieldTypeNode.getType() == Token.COLON) {\n+        fieldNameNode = fieldTypeNode.getFirstChild();\n+        hasType = true;\n+      }\n+\n+      String fieldName = fieldNameNode.getString();\n+\n+      // TODO(user): Move this into the lexer/parser.\n+      // Remove the string literal characters around a field name,\n+      // if any.\n+      if (fieldName.startsWith(\"'\") || fieldName.startsWith(\"\\\"\")) {\n+        fieldName = fieldName.substring(1, fieldName.length() - 1);\n+      }\n+\n+      // Get the property's type.\n+      JSType fieldType = null;\n+\n+      if (hasType) {\n+        // We have a declared type.\n+        fieldType = createFromTypeNodesInternal(\n+            fieldTypeNode.getLastChild(), sourceName, scope, false);\n+      } else {\n+        // Otherwise, the type is UNKNOWN.\n+        fieldType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+      }\n+\n+      // Add the property to the record.\n+      builder.addProperty(fieldName, fieldType);\n+    }\n+\n+    return builder.build();\n+  }\n+\n+  /**\n    * Sets the template type name.\n    */\n   public void setTemplateTypeName(String name) {\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Tests for {@link ScopedAliases}\n+ *\n+ * @author robbyw@google.com (Robby Walker)\n+ */\n+public class ScopedAliasesTest extends CompilerTestCase {\n+\n+  private static String EXTERNS = \"var window;\";\n+\n+  public ScopedAliasesTest() {\n+    super(EXTERNS);\n+  }\n+\n+  private void testScoped(String code, String expected) {\n+    test(\"goog.scope(function() {\" + code + \"});\", expected);\n+  }\n+\n+  private void testScopedNoChanges(String aliases, String code) {\n+    testScoped(aliases + code, code);\n+  }\n+\n+  public void testOneLevel() {\n+    testScoped(\"var g = goog;g.dom.createElement(g.dom.TagName.DIV);\",\n+        \"goog.dom.createElement(goog.dom.TagName.DIV);\");\n+  }\n+\n+  public void testTwoLevel() {\n+    testScoped(\"var d = goog.dom;d.createElement(d.TagName.DIV);\",\n+               \"goog.dom.createElement(goog.dom.TagName.DIV);\");\n+  }\n+\n+  public void testTransitive() {\n+    testScoped(\"var d = goog.dom;var DIV = d.TagName.DIV;d.createElement(DIV);\",\n+        \"goog.dom.createElement(goog.dom.TagName.DIV);\");\n+  }\n+\n+  public void testMultipleTransitive() {\n+    testScoped(\n+        \"var g=goog;var d=g.dom;var t=d.TagName;var DIV=t.DIV;\" +\n+            \"d.createElement(DIV);\",\n+        \"goog.dom.createElement(goog.dom.TagName.DIV);\");\n+  }\n+\n+\n+  public void testFourLevel() {\n+    testScoped(\"var DIV = goog.dom.TagName.DIV;goog.dom.createElement(DIV);\",\n+        \"goog.dom.createElement(goog.dom.TagName.DIV);\");\n+  }\n+\n+  public void testWorksInClosures() {\n+    testScoped(\n+        \"var DIV = goog.dom.TagName.DIV;\" +\n+            \"goog.x = function() {goog.dom.createElement(DIV);};\",\n+        \"goog.x = function() {goog.dom.createElement(goog.dom.TagName.DIV);};\");\n+  }\n+\n+  public void testOverridden() {\n+    // Test that the alias doesn't get unaliased when it's overriden by a\n+    // parameter.\n+    testScopedNoChanges(\n+        \"var g = goog;\", \"goog.x = function(g) {g.z()};\");\n+    // Same for a local.\n+    testScopedNoChanges(\n+        \"var g = goog;\", \"goog.x = function() {var g = {}; g.z()};\");\n+  }\n+\n+  public void testTwoScopes() {\n+    test(\n+        \"goog.scope(function() {var g = goog;g.method()});\" +\n+        \"goog.scope(function() {g.method();});\",\n+\n+        \"goog.method();g.method();\");\n+  }\n+\n+  // TODO(robbyw): Test JsDoc aliasing.\n+  // TODO(robbyw): What if it's recursive?  var goog = goog.dom;\n+\n+  @Override\n+  protected ScopedAliases getProcessor(Compiler compiler) {\n+    return new ScopedAliases(compiler);\n+  }\n+}\n--- a/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n     assertEquals(\"Expected warnings\", 1, reporter.warnings().size());\n   }\n \n+  public void testForceResolve() {\n+    SimpleErrorReporter reporter = new SimpleErrorReporter();\n+\n+    JSTypeRegistry lazyExprRegistry = new JSTypeRegistry(reporter);\n+    lazyExprRegistry.setResolveMode(ResolveMode.LAZY_EXPRESSIONS);\n+\n+    Node expr = new Node(Token.QMARK, Node.newString(\"foo\"));\n+    StaticScope<JSType> empty = new EmptyScope();\n+\n+    JSType type = lazyExprRegistry.createFromTypeNodes(\n+        expr, \"source.js\", empty);\n+    assertFalse(type.isResolved());\n+    assertTrue(type.forceResolve(reporter, empty).isResolved());\n+    assertEquals(\"Expected warnings\", 1, reporter.warnings().size());\n+  }\n+\n+  public void testAllTypeResolvesImmediately() {\n+    JSTypeRegistry lazyExprRegistry = new JSTypeRegistry(\n+        new SimpleErrorReporter());\n+    lazyExprRegistry.setResolveMode(ResolveMode.LAZY_EXPRESSIONS);\n+\n+    Node expr = new Node(Token.STAR);\n+    JSType type = lazyExprRegistry.createFromTypeNodes(\n+        expr, \"source.js\", new EmptyScope());\n+    assertTrue(type instanceof AllType);\n+  }\n+\n   private static class EmptyScope implements StaticScope<JSType> {\n     public StaticSlot<JSType> getSlot(final String name) { return null; }\n     public StaticSlot<JSType> getOwnSlot(String name) { return null; }", "timestamp": 1272983994, "metainfo": ""}