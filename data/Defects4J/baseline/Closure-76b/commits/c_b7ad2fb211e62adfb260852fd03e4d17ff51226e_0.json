{"sha": "b7ad2fb211e62adfb260852fd03e4d17ff51226e", "log": "Generalze folding of the operands of AND, OR, HOOK in conditions. Fixes issue 244.  R=acleung DELTA=195  (118 added, 56 deleted, 21 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=236991   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n         // (TRUE && x) => x\n         result = right;\n       }\n-    } else {\n-      TernaryValue rightVal = NodeUtil.getBooleanValue(right);\n-      if (rightVal != TernaryValue.UNKNOWN) {\n-\n-      // Note: We cannot always fold when the constant is on the\n-      // right, because the typed value of the expression will depend\n-      // on the type of the constant on the right, even if the boolean\n-      // equivalent of the value does not. Specifically, in \"a = x ||\n-      // 0\", a will be numeric 0 if x is undefined (and hence is\n-      // e.g. a valid array index). However, it is safe to fold\n-      // e.g. \"if (x || true)\" because 'if' doesn't care if the\n-      // expression is 'true' or '3'.\n-      int pt = parent.getType();\n-      if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO ||\n-          (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) ||\n-          (pt == Token.HOOK && parent.getFirstChild() == n)) {\n-        boolean rval = rightVal.toBoolean(true);\n-\n-        // (x || FALSE) => x\n-        // (x && TRUE) => x\n-        if (type == Token.OR && !rval ||\n-            type == Token.AND && rval) {\n-          result = left;\n-        } else {\n-          // If x has no side-effects:\n-          //   (x || TRUE) => TRUE\n-          //   (x && FALSE) => FALSE\n-          if (!mayHaveSideEffects(left)) {\n-            result = right;\n-          }\n-        }\n-        }\n-      }\n-    }\n-\n-    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so\n-    // there is not much need to worry about const values on left's\n-    // right child.\n+    }\n+\n+    // Note: Right hand side folding is handled by\n+    // PeepholeSubstituteAlternateSyntax#tryMinimizeCondition\n \n     if (result != null) {\n       // Fold it!\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n         return tryReduceReturn(node);\n \n       case Token.NOT:\n+        tryMinimizeCondition(node.getFirstChild());\n         return tryMinimizeNot(node);\n \n       case Token.IF:\n           case Token.NOT: {\n               Node newRoot = first.removeFirstChild();\n               parent.replaceChild(n, newRoot);\n-              n = newRoot; // continue from here.\n               reportCodeChange();\n-\n-              // The child has moved up, to minimize it recurse.\n-\n-              return tryMinimizeCondition(n);\n+              // No need to traverse, tryMinimizeCondition is called on the\n+              // NOT children are handled below.\n+              return newRoot;\n             }\n           case Token.AND:\n           case Token.OR: {\n               Node leftParent = first.getFirstChild();\n               Node rightParent = first.getLastChild();\n-              if (leftParent.getType() != Token.NOT\n-                  || rightParent.getType() != Token.NOT) {\n-                // No NOTs to elminate.\n-                break;\n+              if (leftParent.getType() == Token.NOT\n+                  && rightParent.getType() == Token.NOT) {\n+                Node left = leftParent.removeFirstChild();\n+                Node right = rightParent.removeFirstChild();\n+\n+                int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;\n+                Node newRoot = new Node(newOp, left, right);\n+                parent.replaceChild(n, newRoot);\n+                reportCodeChange();\n+                // No need to traverse, tryMinimizeCondition is called on the\n+                // AND and OR children below.\n+                return newRoot;\n               }\n-              Node left = leftParent.removeFirstChild();\n-              Node right = rightParent.removeFirstChild();\n-\n-              int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;\n-              Node newRoot = new Node(newOp, left, right);\n-              parent.replaceChild(n, newRoot);\n-              n = newRoot; // continue from here.\n-              reportCodeChange();\n-\n-              // Unlike the NOT case above, we know that AND and OR are\n-              // valid root to check minimize so just break out and check\n-              // the children.\n             }\n             break;\n         }\n-        break;\n+        // No need to traverse, tryMinimizeCondition is called on the NOT\n+        // children in the general case in the main post-order traversal.\n+        return n;\n \n       case Token.OR:\n-      case Token.AND:\n-        // check the children.\n-        break;\n+      case Token.AND: {\n+        Node left = n.getFirstChild();\n+        Node right = n.getLastChild();\n+\n+        // Because the expression is in a boolean context minimize\n+        // the children, this can't be done in the general case.\n+        left = tryMinimizeCondition(left);\n+        right = tryMinimizeCondition(right);\n+\n+        // Remove useless conditionals\n+        // Handle four cases:\n+        //   x || false --> x\n+        //   x || true  --> true\n+        //   x && true --> x\n+        //   x && false  --> false\n+        TernaryValue rightVal = NodeUtil.getBooleanValue(right);\n+        if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) {\n+          int type = n.getType();\n+          Node replacement = null;\n+          boolean rval = rightVal.toBoolean(true);\n+\n+          // (x || FALSE) => x\n+          // (x && TRUE) => x\n+          if (type == Token.OR && !rval ||\n+              type == Token.AND && rval) {\n+            replacement = left;\n+          } else if (!mayHaveSideEffects(left)) {\n+            replacement = right;\n+          }\n+\n+          if (replacement != null) {\n+            n.detachChildren();\n+            parent.replaceChild(n, replacement);\n+            reportCodeChange();\n+            return replacement;\n+          }\n+        }\n+        return n;\n+      }\n+\n+      case Token.HOOK: {\n+        Node condition = n.getFirstChild();\n+        Node trueNode = n.getFirstChild().getNext();\n+        Node falseNode = n.getLastChild();\n+\n+        // Because the expression is in a boolean context minimize\n+        // the result children, this can't be done in the general case.\n+        // The condition is handled in the general case in #optimizeSubtree\n+        trueNode = tryMinimizeCondition(trueNode);\n+        falseNode = tryMinimizeCondition(falseNode);\n+\n+        // Handle four cases:\n+        //   x ? true : false --> x\n+        //   x ? false : true --> !x\n+        //   x ? true : y     --> x || y\n+        //   x ? y : false    --> x && y\n+        Node replacement = null;\n+        if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE\n+            && NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {\n+          // Remove useless conditionals, keep the condition\n+          condition.detachFromParent();\n+          replacement = condition;\n+        } else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.FALSE\n+            && NodeUtil.getBooleanValue(falseNode) == TernaryValue.TRUE) {\n+          // Remove useless conditionals, keep the condition\n+          condition.detachFromParent();\n+          replacement = new Node(Token.NOT, condition);\n+        } else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE) {\n+          // Remove useless true case.\n+          n.detachChildren();\n+          replacement = new Node(Token.OR, condition, falseNode);\n+        } else if (NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {\n+          // Remove useless false case\n+          n.detachChildren();\n+          replacement = new Node(Token.AND, condition, trueNode);\n+        }\n+\n+        if (replacement != null) {\n+          parent.replaceChild(n, replacement);\n+          n = replacement;\n+          reportCodeChange();\n+        }\n+\n+        return n;\n+      }\n \n       default:\n         // while(true) --> while(1)\n         // We can't do anything else currently.\n         return n;\n     }\n-\n-    for (Node c = n.getFirstChild(); c != null; ) {\n-      Node next = c.getNext();  // c may be removed.\n-      tryMinimizeCondition(c);\n-      c = next;\n-    }\n-\n-    return n;\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"a = b ? c : x && true\", \"a=b?c:x&&true\");\n     fold(\"a = b ? x && true : c\", \"a=b?x&&true:c\");\n \n-    // foldable, analogous to if().\n-    fold(\"a = x || false ? b : c\", \"a=x?b:c\");\n-    fold(\"a = x && true ? b : c\", \"a=x?b:c\");\n+    // folded, but not here.\n+    foldSame(\"a = x || false ? b : c\");\n+    foldSame(\"a = x && true ? b : c\");\n \n     fold(\"x = foo() || true || bar()\", \"x = foo()||true\");\n     fold(\"x = foo() || false || bar()\", \"x = foo()||bar()\");\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n   public void testShortCircuit4() {\n     test(\"a() && (1 && b())\", \"a() && b()\");\n     test(\"a() && 1 && b()\", \"a() && b()\");\n-    testSame(\"(a() && 1) && b()\");\n+    test(\"(a() && 1) && b()\", \"a() && b()\");\n+  }\n+\n+  public void testMinimizeExprCondition() {\n+    fold(\"(x || true) && y()\", \"y()\");\n+    fold(\"(x || false) && y()\", \"x&&y()\");\n+    fold(\"(x && true) && y()\", \"x && y()\");\n+    fold(\"(x && false) && y()\", \"\");\n+    fold(\"a = x || false ? b : c\", \"a=x?b:c\");\n+    fold(\"do {x()} while((x && false) && y())\", \"{x()}\");\n   }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     foldSame(\"while(!(x<y)){a=b;}\");\n     foldSame(\"while(!(x<=y)){a=b;}\");\n     foldSame(\"while(!(x<=NaN)){a=b;}\");\n+\n+    // NOT forces a boolean context\n+    fold(\"x = !(y() && true)\", \"x = !y()\");\n+    // This will be further optimized by PeepholeFoldConstants.\n+    fold(\"x = !true\", \"x = !1\");\n   }\n \n   public void testFoldRegExpConstructor() {\n     foldSame(\"x = new Array(Object(), Array(\\\"abc\\\", Object(), Array(Array())))\");\n   }\n \n+  public void testMinimizeExprCondition() {\n+    fold(\"(x ? true : false) && y()\", \"x&&y()\");\n+    fold(\"(x ? false : true) && y()\", \"(!x)&&y()\");\n+    fold(\"(x ? true : y) && y()\", \"(x || y)&&y()\");\n+    fold(\"(x ? y : false) && y()\", \"(x && y)&&y()\");\n+    fold(\"(x && true) && y()\", \"x && y()\");\n+    fold(\"(x && false) && y()\", \"0&&y()\");\n+    fold(\"(x || true) && y()\", \"1&&y()\");\n+    fold(\"(x || false) && y()\", \"x&&y()\");\n+  }\n+\n   public void testMinimizeWhileCondition() {\n     // This test uses constant folding logic, so is only here for completeness.\n     fold(\"while(!!true) foo()\", \"while(1) foo()\");\n     // These could be simplified to \"for(;;) ...\"\n     fold(\"for(;!!true;) foo()\", \"for(;1;) foo()\");\n     // Don't bother with FOR inits as there are normalized out.\n-    foldSame(\"for(!!true;;) foo()\");\n+    fold(\"for(!!true;;) foo()\", \"for(!!1;;) foo()\");\n \n     // These test tryMinimizeCondition\n     fold(\"for(;!!x;) foo()\", \"for(;x;) foo()\");\n     foldSame(\"for(a in b) foo()\");\n     foldSame(\"for(a in {}) foo()\");\n     foldSame(\"for(a in []) foo()\");\n-    foldSame(\"for(a in !!true) foo()\");\n+    fold(\"for(a in !!true) foo()\", \"for(a in !!1) foo()\");\n   }\n \n   public void testMinimizeCondition_example1() {", "timestamp": 1285086073, "metainfo": ""}