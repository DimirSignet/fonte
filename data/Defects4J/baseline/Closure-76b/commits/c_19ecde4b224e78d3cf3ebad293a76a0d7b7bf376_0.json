{"sha": "19ecde4b224e78d3cf3ebad293a76a0d7b7bf376", "log": "RenameProperties with affinity informations.  R=nicksantos DELTA=159  (139 added, 6 deleted, 14 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=766   ", "commit": "\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.graph.Graph.GraphEdge;\n+import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n+import com.google.javascript.jscomp.graph.UndiGraph;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.TokenStream;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n \n import javax.annotation.Nullable;\n \n   private final Map<String, Property> propertyMap =\n       new HashMap<String, Property>();\n \n+  /**\n+   * A graph of property affinity information.\n+   *\n+   * Suppose property X and Y are access in the same function N times.\n+   *\n+   * The graph would have X -> Y with the edge of N.\n+   */\n+  private final UndiGraph<Property, PropertyAffinity> affinityGraph =\n+      LinkedUndirectedGraph.createWithoutAnnotations();\n+\n   // Property names that don't get renamed\n   private final Set<String> externedNames = new HashSet<String>(\n       Arrays.asList(\"prototype\"));\n   // Names to which properties shouldn't be renamed, to avoid name conflicts\n   private final Set<String> quotedNames = new HashSet<String>();\n \n-  /**\n-   * Sorts Property objects by their count, breaking ties alphabetically to\n-   * ensure a deterministic total ordering.\n-   */\n   private static final Comparator<Property> FREQUENCY_COMPARATOR =\n-      new Comparator<Property>() {\n-        public int compare(Property p1, Property p2) {\n-          if (p1.numOccurrences != p2.numOccurrences) {\n-            return p2.numOccurrences - p1.numOccurrences;\n-          }\n-          return p1.oldName.compareTo(p2.oldName);\n-        }\n-      };\n+    new Comparator<Property>() {\n+      public int compare(Property p1, Property p2) {\n+\n+        /**\n+         * First a frequently used names would always be picked first.\n+         */\n+        if (p1.numOccurrences != p2.numOccurrences) {\n+          return p2.numOccurrences - p1.numOccurrences;\n+\n+        /**\n+         * If both properties are used equally frequent. We'll let the property\n+         * with a high affinity score get a name first.\n+         *\n+         * see #computeAffinityScores() for how the score is computed.\n+         */\n+        } else if (p1.affinityScore != p2.affinityScore) {\n+          return p2.affinityScore - p1.affinityScore;\n+        }\n+\n+        /**\n+         * Finally, for determinism, we compare them based on the old name.\n+         */\n+        return p1.oldName.compareTo(p2.oldName);\n+       }\n+    };\n \n   /**\n    * The name of a special function that this pass replaces. It takes one\n     }\n \n     compiler.addToDebugLog(\"JS property assignments:\");\n+    computeAffinityScores();\n \n     // Assign names, sorted by descending frequency to minimize code size.\n     Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);\n   }\n \n   /**\n+   * A X property gets an affinity score:\n+   *\n+   * score = sum (# of times X appears Y * frequency(Y)) for all Y where\n+   *   frequency(Y) > frequency (X).\n+   *\n+   * This way a property would have a name closer to all high frequency names.\n+   * Also two property of the same frequency would have very close names if\n+   * they always appear together.\n+   */\n+  private void computeAffinityScores() {\n+    for (Property p : propertyMap.values()) {\n+      for (Property other : propertyMap.values()) {\n+        if (p != other && p.numOccurrences < other.numOccurrences) {\n+          List<GraphEdge<Property,PropertyAffinity>> edges =\n+              affinityGraph.getEdges(p, other);\n+          if (!edges.isEmpty()) {\n+            p.affinityScore += edges.get(0)\n+                .getValue().affinity + other.numOccurrences;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n    * Generates new names for properties.\n    *\n    * @param props Properties to generate new names for\n           p.newName = nameGen.generateNextName();\n         }\n       }\n-\n       reservedNames.add(p.newName);\n-\n       compiler.addToDebugLog(p.oldName + \" => \" + p.newName);\n     }\n   }\n     }\n   }\n \n+\n   // -------------------------------------------------------------------------\n \n   /**\n    * A traversal callback that collects property names and counts how\n    * frequently each property name occurs.\n    */\n-  private class ProcessProperties extends AbstractPostOrderCallback {\n+  private class ProcessProperties extends AbstractPostOrderCallback implements\n+      ScopedCallback {\n+\n+    private Set<Property> currentHighAffinityProperties = null;\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (prop == null) {\n         prop = new Property(name);\n         propertyMap.put(name, prop);\n+        affinityGraph.createNode(prop);\n       }\n       prop.numOccurrences++;\n+      if (currentHighAffinityProperties != null) {\n+        currentHighAffinityProperties.add(prop);\n+      }\n+    }\n+\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      if (!t.inGlobalScope() && t.getScope().getParent().isGlobal()) {\n+        currentHighAffinityProperties = Sets.newHashSet();\n+      }\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {\n+      if (!t.inGlobalScope() && t.getScope().getParent().isGlobal()) {\n+        for (Property p1 : currentHighAffinityProperties) {\n+          for (Property p2 : currentHighAffinityProperties) {\n+            if (p1.oldName.compareTo(p2.oldName) < 0) {\n+              List<GraphEdge<Property,PropertyAffinity>> edges =\n+                  affinityGraph.getEdges(p1, p2);\n+              if (edges.isEmpty()) {\n+                affinityGraph.connect(p1, new PropertyAffinity(1), p2);\n+              } else {\n+                edges.get(0).getValue().increase();\n+              }\n+            }\n+          }\n+        }\n+        currentHighAffinityProperties = null;\n+      }\n     }\n   }\n \n     final String oldName;\n     String newName;\n     int numOccurrences;\n+    int affinityScore = 0;\n \n     Property(String name) {\n       this.oldName = name;\n     }\n   }\n+\n+  private class PropertyAffinity {\n+    private int affinity = 0;\n+\n+    private PropertyAffinity(int affinity) {\n+      this.affinity = affinity;\n+    }\n+\n+    private void increase() {\n+      affinity++;\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n                  compiler.toSource(module3));\n   }\n \n+  public void testPropertyAffinity() {\n+    // 'y' gets to be 'b' because it appears with z often.\n+    // Other wise, 'x' gets to be 'b' because of alphabetical ordering.\n+\n+    test(\"var foo={};foo.x=1;foo.y=2;foo.z=3;\" +\n+         \"function f1() { foo.z; foo.z; foo.z; foo.y}\" +\n+         \"function f2() {                      foo.x}\",\n+\n+\n+         \"var foo={};foo.c=1;foo.b=2;foo.a=3;\" +\n+         \"function f1() { foo.a; foo.a; foo.a; foo.b}\" +\n+         \"function f2() {                      foo.c}\");\n+\n+    test(\"var foo={};foo.x=1;foo.y=2;foo.z=3;\" +\n+        \"function f1() { foo.z; foo.z; foo.z; foo.y}\" +\n+        \"function f2() { foo.z; foo.z; foo.z; foo.x}\",\n+\n+\n+        \"var foo={};foo.b=1;foo.c=2;foo.a=3;\" +\n+        \"function f1() { foo.a; foo.a; foo.a; foo.c}\" +\n+        \"function f2() { foo.a; foo.a; foo.a; foo.b}\");\n+  }\n+\n   public void testPrototypePropertiesStable() {\n     testStableRenaming(\n         \"Bar.prototype.getA = function(){}; bar.getA();\" +", "timestamp": 1299292086, "metainfo": ""}