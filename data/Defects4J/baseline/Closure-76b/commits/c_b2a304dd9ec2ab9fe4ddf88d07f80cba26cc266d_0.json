{"sha": "b2a304dd9ec2ab9fe4ddf88d07f80cba26cc266d", "log": "Do some clean up on how we resolve type names.  R=johnlenz DELTA=103  (73 added, 19 deleted, 11 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=60002   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n    */\n   private void resolveViaProperties(ErrorReporter t,\n                                     StaticScope<JSType> enclosing) {\n+    JSType value = lookupViaProperties(t, enclosing);\n+    // last component of the chain\n+    if ((value instanceof FunctionType) &&\n+        (value.isConstructor() || value.isInterface())) {\n+      FunctionType functionType = (FunctionType) value;\n+      setReferencedType(functionType.getInstanceType(), t, enclosing);\n+    } else if (value instanceof EnumType) {\n+      setReferencedType(((EnumType) value).getElementsType(), t, enclosing);\n+    } else {\n+      // We've been running into issues where people forward-declare\n+      // non-named types. (This is legitimate...our dependency management\n+      // code doubles as our forward-declaration code.)\n+      //\n+      // So if the type does resolve to an actual value, but it's not named,\n+      // then don't respect the forward declaration.\n+      handleUnresolvedType(t, value == null || value.isUnknownType());\n+    }\n+  }\n+\n+  /**\n+   * Resolves a type by looking up its first component in the scope, and\n+   * subsequent components as properties. The scope must have been fully\n+   * parsed and a symbol table constructed.\n+   * @return The type of the symbol, or null if the type could not be found.\n+   */\n+  private JSType lookupViaProperties( ErrorReporter t,\n+      StaticScope<JSType> enclosing) {\n     String[] componentNames = reference.split(\"\\\\.\", -1);\n     if (componentNames[0].length() == 0) {\n-      handleUnresolvedType(t);\n-      return;\n+      return null;\n     }\n     StaticSlot<JSType> slot = enclosing.getSlot(componentNames[0]);\n     if (slot == null) {\n-      handleUnresolvedType(t);\n-      return;\n+      return null;\n     }\n     // If the first component has a type of 'Unknown', then any type\n     // names using it should be regarded as silently 'Unknown' rather than be\n     // noisy about it.\n     JSType slotType = slot.getType();\n     if (slotType == null || slotType.isAllType() || slotType.isNoType()) {\n-      handleUnresolvedType(t);\n-      return;\n+      return null;\n     }\n     JSType value = getTypedefType(t, slot, componentNames[0]);\n     if (value == null) {\n-      handleUnresolvedType(t);\n-      return;\n+      return null;\n     }\n \n     // resolving component by component\n     for (int i = 1; i < componentNames.length; i++) {\n       ObjectType parentClass = ObjectType.cast(value);\n       if (parentClass == null) {\n-        handleUnresolvedType(t);\n-        return;\n+        return null;\n       }\n       if (componentNames[i].length() == 0) {\n-        handleUnresolvedType(t);\n-        return;\n+        return null;\n       }\n       value = parentClass.getPropertyType(componentNames[i]);\n     }\n-\n-    // last component of the chain\n-    if (value instanceof FunctionType) {\n-      FunctionType functionType = (FunctionType)value;\n-      if (functionType.isConstructor() || functionType.isInterface()) {\n-        setReferencedType(functionType.getInstanceType(), t, enclosing);\n-      } else {\n-        handleUnresolvedType(t);\n-      }\n-    } else if (value instanceof EnumType) {\n-      setReferencedType(((EnumType) value).getElementsType(), t, enclosing);\n-    } else {\n-      handleUnresolvedType(t);\n-    }\n+    return value;\n   }\n \n   private void setReferencedType(ObjectType type, ErrorReporter t,\n \n   // Warns about this type being unresolved iff it's not a forward-declared\n   // type name.\n-  private void handleUnresolvedType(ErrorReporter t) {\n-    if (!registry.isForwardDeclaredType(reference) && !forgiving &&\n-        registry.isLastGeneration()) {\n+  private void handleUnresolvedType(\n+      ErrorReporter t, boolean ignoreForwardReferencedTypes) {\n+    boolean beForgiving = forgiving ||\n+        (ignoreForwardReferencedTypes &&\n+         registry.isForwardDeclaredType(reference));\n+    if (!beForgiving && registry.isLastGeneration()) {\n       t.warning(\"Unknown type \" + reference, sourceName, lineno, null,\n           charno);\n     } else {\n     if (type != null) {\n       return type;\n     }\n-    handleUnresolvedType(t);\n+    handleUnresolvedType(t, true);\n     return null;\n   }\n }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   public void testCast8() throws Exception {\n     testTypes(\"function f() { return /** @type {foo} */ (new Object()); }\",\n         \"Parse error. Unknown type foo\");\n+  }\n+\n+  public void testCast9() throws Exception {\n+    testTypes(\"var foo = {};\" +\n+        \"function f() { return /** @type {foo} */ (new Object()); }\",\n+        \"Parse error. Unknown type foo\");\n+  }\n+\n+  public void testCast10() throws Exception {\n+    testTypes(\"var foo = function() {};\" +\n+        \"function f() { return /** @type {foo} */ (new Object()); }\",\n+        \"Parse error. Unknown type foo\");\n+  }\n+\n+  public void testCast11() throws Exception {\n+    testTypes(\"var goog = {}; goog.foo = {};\" +\n+        \"function f() { return /** @type {goog.foo} */ (new Object()); }\",\n+        \"Parse error. Unknown type goog.foo\");\n+  }\n+\n+  public void testCast12() throws Exception {\n+    testTypes(\"var goog = {}; goog.foo = function() {};\" +\n+        \"function f() { return /** @type {goog.foo} */ (new Object()); }\",\n+        \"Parse error. Unknown type goog.foo\");\n+  }\n+\n+  public void testCast13() throws Exception {\n+    // Test to make sure that the forward-declaration still allows for\n+    // a warning.\n+    testClosureTypes(\"var goog = {}; \" +\n+        \"goog.addDependency('zzz.js', ['goog.foo'], []);\" +\n+        \"goog.foo = function() {};\" +\n+        \"function f() { return /** @type {goog.foo} */ (new Object()); }\",\n+        \"Parse error. Unknown type goog.foo\");\n+  }\n+\n+  public void testCast14() throws Exception {\n+    // Test to make sure that the forward-declaration still prevents\n+    // some warnings.\n+    testClosureTypes(\"var goog = {}; \" +\n+        \"goog.addDependency('zzz.js', ['goog.bar'], []);\" +\n+        \"function f() { return /** @type {goog.bar} */ (new Object()); }\",\n+        null);\n   }\n \n   public void testNestedCasts() throws Exception {", "timestamp": 1279825600, "metainfo": ""}