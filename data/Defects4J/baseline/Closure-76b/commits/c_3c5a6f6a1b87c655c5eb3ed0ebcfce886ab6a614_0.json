{"sha": "3c5a6f6a1b87c655c5eb3ed0ebcfce886ab6a614", "log": "Allow graphs without annotations.  R=acleung DELTA=405  (249 added, 83 deleted, 73 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=58   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n   // then there would be a node for \"scotch\", a node for \"age\", and an edge\n   // from scotch to age.\n   private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph =\n-      new LinkedDirectedGraph<NameInfo, JSModule>();\n+      LinkedDirectedGraph.createWithoutAnnotations();\n \n   // A dummy node for representing global references.\n   private final NameInfo globalNode = new NameInfo(\"[global]\");\n--- a/src/com/google/javascript/jscomp/CallGraph.java\n+++ b/src/com/google/javascript/jscomp/CallGraph.java\n /**\n  * A pass the uses a {@link DefinitionProvider} to compute a call graph for an\n  * AST.\n- * \n- * <p>A {@link CallGraph} connects {@link Function}s to {@link Callsite}s and \n+ *\n+ * <p>A {@link CallGraph} connects {@link Function}s to {@link Callsite}s and\n  * vice versa: each function in the graph links to the callsites it contains and\n  * each callsite links to the functions it could call. Similarly, each callsite\n  * links to the function that contains it and each function links to the\n  * callsites that could call it.\n- * \n+ *\n  * <p>The callgraph is not precise. That is, a callsite may indicate it can\n- * call a function when in fact it does not do so in the running program. \n- * \n- * <p>The callgraph is also not complete: in some cases it may be unable to \n- * determine some targets of a callsite. In this case, \n+ * call a function when in fact it does not do so in the running program.\n+ *\n+ * <p>The callgraph is also not complete: in some cases it may be unable to\n+ * determine some targets of a callsite. In this case,\n  * Callsite.hasUnknownTarget() will return true.\n  *\n  * <p>The CallGraph doesn't (currently) have functions for externally defined\n  * functions; however, callsites that target externs will have hasExternTarget()\n  * return true.\n- * \n+ *\n  * <p>TODO(dcc): Have CallGraph (optionally?) include functions for externs.\n  *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n-public class CallGraph implements CompilerPass { \n+public class CallGraph implements CompilerPass {\n   private AbstractCompiler compiler;\n-  \n-  /** \n+\n+  /**\n    * Maps an AST node (with type Token.CALL or Token.NEW) to a Callsite object.\n    */\n   private Map<Node, Callsite> callsitesByNode;\n-  \n+\n   /** Maps an AST node (with type Token.FUNCTION) to a Function object. */\n   private Map<Node, Function> functionsByNode;\n-  \n+\n   /**\n    * Will the call graph support looking up the callsites that could call a\n    * given function?\n    */\n   private boolean computeBackwardGraph;\n-  \n+\n   /**\n    * Will the call graph support looking up the functions that a given callsite\n    * can call?\n    */\n   private boolean computeForwardGraph;\n- \n-  /**\n-   * If true, then the callgraph will use NameReferenceGraph as a \n+\n+  /**\n+   * If true, then the callgraph will use NameReferenceGraph as a\n    * definition provider; otherwise, use the faster SimpleDefinitionProvider.\n    */\n   private boolean useNameReferenceGraph = false;\n-  \n+\n   /** Has the CallGraph already been constructed? */\n   private boolean alreadyRun = false;\n-  \n+\n   /** The name we give the main function. */\n   @VisibleForTesting\n   public static final String MAIN_FUNCTION_NAME = \"{main}\";\n-  \n+\n   /**\n    *  Represents the global function. Calling getBody() on this\n    *  function will yield the global script/block.\n-   *  \n+   *\n    *  TODO(dcc): having a single main function is somewhat misleading. Perhaps\n    *  it might be better to make CallGraph module aware and have one per\n    *  module?\n    */\n   private Function mainFunction;\n-  \n+\n   /**\n    * Creates a call graph object supporting the specified lookups.\n-   * \n+   *\n    * At leats one (and possibly both) of computeForwardGraph and\n    * computeBackwardGraph must be true.\n-   * \n+   *\n    * @param compiler The compiler\n    * @param computeForwardGraph Should the call graph allow lookup of the target\n    *        functions a given callsite could call?\n   public CallGraph(AbstractCompiler compiler, boolean computeForwardGraph,\n       boolean computeBackwardGraph) {\n     Preconditions.checkArgument(computeForwardGraph || computeBackwardGraph);\n-    \n-    this.compiler = compiler; \n-    \n+\n+    this.compiler = compiler;\n+\n     this.computeForwardGraph = computeForwardGraph;\n     this.computeBackwardGraph = computeBackwardGraph;\n-    \n+\n     callsitesByNode = Maps.newLinkedHashMap();\n     functionsByNode = Maps.newLinkedHashMap();\n   }\n-  \n+\n   /**\n    * Creates a call graph object support both forward and backward lookups.\n    */\n   public CallGraph(AbstractCompiler compiler) {\n     this(compiler, true, true);\n   }\n-  \n+\n   /**\n    * Builds a call graph for the given externsRoot and jsRoot.\n    * This method must not be called more than once per CallGraph instance.\n   @Override\n   public void process(Node externsRoot, Node jsRoot) {\n     Preconditions.checkState(alreadyRun == false);\n-    \n+\n     DefinitionProvider definitionProvider =\n         constructDefinitionProvider(externsRoot, jsRoot);\n-    \n+\n     createFunctionsAndCallsites(jsRoot, definitionProvider);\n-    \n+\n     fillInFunctionInformation(definitionProvider);\n-    \n+\n     alreadyRun = true;\n   }\n \n    */\n   public Function getFunctionForAstNode(Node functionNode) {\n     Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n-    \n+\n     return functionsByNode.get(functionNode);\n   }\n-  \n+\n   /**\n    * Returns a Function object representing the \"main\" global function.\n    */\n   public Function getMainFunction() {\n     return mainFunction;\n   }\n-  \n+\n   /**\n    * Returns a collection of all functions (including the main function)\n    * in the call graph.\n   public Collection<Function> getAllFunctions() {\n     return functionsByNode.values();\n   }\n-  \n+\n   /**\n    * Finds a function with the given name. Throws an exception if\n    * there are no functions or multiple functions with the name. This is\n    * for testing purposes only.\n    */\n   @VisibleForTesting\n-  public Function getUniqueFunctionWithName(final String desiredName) {  \n+  public Function getUniqueFunctionWithName(final String desiredName) {\n     Collection<Function> functions =\n         Collections2.<Function>filter(getAllFunctions(),\n             new Predicate<Function>() {\n     if (functions.size() == 1) {\n       return functions.iterator().next();\n     } else {\n-      throw new IllegalStateException(\"Found \" + functions.size() \n+      throw new IllegalStateException(\"Found \" + functions.size()\n           + \" functions with name \" + desiredName);\n     }\n   }\n    * AST Token.CALL or Token.NEW node, or null if no such object exists.\n    */\n   public Callsite getCallsiteForAstNode(Node callsiteNode) {\n-    Preconditions.checkArgument(callsiteNode.getType() == Token.CALL || \n+    Preconditions.checkArgument(callsiteNode.getType() == Token.CALL ||\n         callsiteNode.getType() == Token.NEW);\n-    \n+\n     return callsitesByNode.get(callsiteNode);\n   }\n-  \n+\n   /**\n    * Returns a collection of all callsites in the call graph.\n    */\n   public Collection<Callsite> getAllCallsites() {\n    return callsitesByNode.values();\n   }\n-  \n+\n   /**\n    * Creates {@link Function}s and {@link Callsite}s in a single\n    * AST traversal.\n       final DefinitionProvider provider) {\n     // Create fake function representing global execution\n     mainFunction = createFunction(jsRoot);\n-    \n-    NodeTraversal.traverse(compiler, jsRoot, new AbstractPostOrderCallback() {    \n+\n+    NodeTraversal.traverse(compiler, jsRoot, new AbstractPostOrderCallback() {\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n         int nodeType = n.getType();\n-        \n+\n         if (nodeType == Token.CALL || nodeType == Token.NEW) {\n           Callsite callsite = createCallsite(n);\n-          \n+\n           Node containingFunctionNode = t.getScopeRoot();\n-          \n+\n           Function containingFunction =\n               functionsByNode.get(containingFunctionNode);\n-          \n+\n           if (containingFunction == null) {\n             containingFunction = createFunction(containingFunctionNode);\n           }\n           callsite.containingFunction = containingFunction;\n           containingFunction.addCallsiteInFunction(callsite);\n-          \n+\n           connectCallsiteToTargets(callsite, provider);\n-          \n+\n         } else if (NodeUtil.isFunction(n)) {\n           if (!functionsByNode.containsKey(n)) {\n             createFunction(n);\n           }\n-        }       \n+        }\n       }\n     });\n   }\n-  \n+\n   /**\n    * Create a Function object for given an Token.FUNCTION AST node.\n-   * \n+   *\n    * This is the bottleneck for Function creation: all Functions should\n    * be created with this method.\n    */\n   private Function createFunction(Node functionNode) {\n     Function function = new Function(functionNode);\n-    functionsByNode.put(functionNode, function); \n-    \n+    functionsByNode.put(functionNode, function);\n+\n     return function;\n   }\n-  \n+\n   private Callsite createCallsite(Node callsiteNode) {\n-    Callsite callsite = new Callsite(callsiteNode);   \n+    Callsite callsite = new Callsite(callsiteNode);\n     callsitesByNode.put(callsiteNode, callsite);\n-    \n+\n     return callsite;\n   }\n-  \n-  /**\n-   * Maps a Callsite to the Function(s) it could call \n+\n+  /**\n+   * Maps a Callsite to the Function(s) it could call\n    * and each Function to the Callsite(s) that could call it.\n-   * \n+   *\n    * If the definitionProvider cannot determine the target of the Callsite,\n    * the Callsite's hasUnknownTarget field is set to true.\n-   * \n+   *\n    * If the definitionProvider determines that the target of the Callsite\n    * could be an extern-defined function, then the Callsite's hasExternTarget\n    * field is set to true.\n-   * \n+   *\n    * @param callsite The callsite for which target functions should be found\n    * @param definitionProvider The DefinitionProvider used to determine\n    *    targets of callsites.\n    */\n   private void connectCallsiteToTargets(Callsite callsite,\n-      DefinitionProvider definitionProvider) { \n+      DefinitionProvider definitionProvider) {\n     Collection<Definition> definitions =\n       lookupDefinitionsForTargetsOfCall(callsite.getAstNode(),\n           definitionProvider);\n \n     if (definitions == null) {\n-      callsite.hasUnknownTarget = true; \n+      callsite.hasUnknownTarget = true;\n     } else {\n       for (Definition definition : definitions) {\n         if (definition.isExtern()) {\n \n           if (target != null && NodeUtil.isFunction(target)) {\n             Function targetFunction = functionsByNode.get(target);\n-            \n+\n             if (targetFunction == null) {\n               targetFunction = createFunction(target);\n             }\n-            \n+\n             if (computeForwardGraph) {\n               callsite.addPossibleTarget(targetFunction);\n             }\n               targetFunction.addCallsitePossiblyTargetingFunction(callsite);\n             }\n           } else {\n-            callsite.hasUnknownTarget = true;                 \n+            callsite.hasUnknownTarget = true;\n           }\n         }\n       }\n     }\n   }\n-  \n+\n   /**\n    * Fills in function information (such as whether the function is ever\n    * aliased or whether it is exposed to .call or .apply) using the\n    * definition provider.\n-   * \n+   *\n    * We do this here, rather than when connecting the callgraph, to make sure\n    * that we have correct information for all functions, rather than just\n    * functions that are actually called.\n   private void fillInFunctionInformation(DefinitionProvider provider) {\n     if (useNameReferenceGraph) {\n       NameReferenceGraph referenceGraph = (NameReferenceGraph) provider;\n-      \n+\n       for (Function function : getAllFunctions()) {\n         if (!function.isMain()) {\n           String functionName = function.getName();\n-          \n+\n           if (functionName != null) {\n             Name symbol = referenceGraph.getSymbol(functionName);\n             updateFunctionForName(function, symbol);\n           }\n-        }  \n+        }\n       }\n     } else {\n       SimpleDefinitionFinder finder = (SimpleDefinitionFinder) provider;\n-      \n+\n       for (DefinitionSite definitionSite : finder.getDefinitionSites()) {\n         Definition definition = definitionSite.definition;\n-        \n+\n         Function function = lookupFunctionForDefinition(definition);\n-        \n-        if (function != null) {              \n+\n+        if (function != null) {\n           for (UseSite useSite : finder.getUseSites(definition)) {\n             updateFunctionForUse(function, useSite.node);\n           }\n-        }                      \n-      }\n-    }\n-  }\n-  \n+        }\n+      }\n+    }\n+  }\n+\n   /**\n    * Updates {@link Function} information (such as whether is is aliased\n    * or exposed to .apply or .call from a {@link NameReferenceGraph.Name}.\n-   * \n+   *\n    * Note: this method may be called multiple times per Function, each time\n    * with a different name.\n    */\n   private void updateFunctionForName(Function function, Name name) {\n     if (name.isAliased()) {\n-      function.isAliased = true; \n-    }   \n-     \n+      function.isAliased = true;\n+    }\n+\n     if (name.exposedToCallOrApply()) {\n       function.isExposedToCallOrApply = true;\n     }\n   }\n-  \n+\n   /**\n    * Updates {@link Function} information (such as whether is is aliased\n    * or exposed to .apply or .call based a site where the function is used.\n-   * \n+   *\n    * Note: this method may be called multiple times per Function, each time\n    * with a different useNode.\n    */\n   private void updateFunctionForUse(Function function, Node useNode) {\n     Node useParent = useNode.getParent();\n     int parentType = useParent.getType();\n-    \n+\n     if ((parentType == Token.CALL || parentType == Token.NEW)\n         && useParent.getFirstChild() == useNode) {\n       // Regular call sites don't count as aliases\n     } else if (NodeUtil.isGet(useParent)) {\n       // GET{PROP,ELEM} don't count as aliases\n       // but we have to check for using them in .call and .apply.\n-      \n+\n       if (NodeUtil.isGetProp(useParent)) {\n         Node gramps = useParent.getParent();\n         if (NodeUtil.isFunctionObjectApply(gramps) ||\n       function.isAliased = true;\n     }\n   }\n-  \n+\n   /**\n    * Returns a {@link CallGraph.Function} for the passed in {@link Definition}\n    * or null if the definition isn't for a function.\n   private Function lookupFunctionForDefinition(Definition definition) {\n     if (definition != null && !definition.isExtern()) {\n       Node rValue = definition.getRValue();\n-      \n+\n       if (rValue != null && NodeUtil.isFunction(rValue)) {\n         Function function = functionsByNode.get(rValue);\n         Preconditions.checkNotNull(function);\n-        \n+\n         return function;\n       }\n     }\n-    \n+\n     return null;\n   }\n-  \n+\n   /**\n    * Constructs and returns a directed graph where the nodes are functions and\n    * the edges are callsites connecting callers to callees.\n-   * \n+   *\n    * It is safe to call this method on both forward and backwardly constructed\n    * CallGraphs.\n    */\n   public DiGraph<Function, Callsite> getForwardDirectedGraph() {\n     return constructDirectedGraph(true);\n   }\n-  \n+\n   /**\n    * Constructs and returns a directed graph where the nodes are functions and\n    * the edges are callsites connecting callees to callers.\n-   * \n+   *\n    * It is safe to call this method on both forward and backwardly constructed\n    * CallGraphs.\n    */\n   public DiGraph<Function, Callsite> getBackwardDirectedGraph() {\n     return constructDirectedGraph(false);\n   }\n-  \n+\n   private static void digraphConnect(DiGraph<Function, Callsite> digraph,\n       Function caller,\n       Callsite callsite,\n       Function callee,\n       boolean forward) {\n-    \n+\n     Function source;\n     Function destination;\n \n       source = callee;\n       destination = caller;\n     }\n-    \n+\n     digraph.connect(source, callsite, destination);\n   }\n-  \n+\n   /**\n    * Constructs a digraph of the call graph. If {@code forward} is true, then\n    * the edges in the digraph will go from callers to callees, if false then\n    * the edges will go from callees to callers.\n-   * \n+   *\n    * It is safe to run this method on both a forwardly constructed callgraph\n    * and a backwardly constructed callgraph, regardless of the value of\n    * {@code forward}.\n-   * \n+   *\n    * @param forward If true then the digraph will be a forward digraph.\n    */\n   private DiGraph<Function, Callsite> constructDirectedGraph(boolean forward) {\n     DiGraph<Function, Callsite>digraph =\n-        new LinkedDirectedGraph<Function, Callsite>();\n-    \n+        LinkedDirectedGraph.createWithoutAnnotations();\n+\n     // Create nodes in call graph\n     for (Function function : getAllFunctions()) {\n       digraph.createNode(function);\n     }\n-    \n+\n     if (computeForwardGraph) {\n       // The CallGraph is a forward graph, so go from callers to callees\n       for (Function caller : getAllFunctions()) {\n         for (Callsite callsite : caller.getCallsitesInFunction()) {\n           for (Function callee : callsite.getPossibleTargets()) {\n             digraphConnect(digraph, caller, callsite, callee,\n-                forward);       \n+                forward);\n           }\n         }\n       }\n       for (Function callee : getAllFunctions()) {\n         for (Callsite callsite :\n             callee.getCallsitesPossiblyTargetingFunction()) {\n-          \n+\n           Function caller = callsite.getContainingFunction();\n           digraphConnect(digraph, caller, callsite, callee,\n               forward);\n         }\n       }\n-    }    \n-    \n+    }\n+\n     return digraph;\n   }\n-  \n+\n   /**\n    * Constructs a DefinitionProvider that can be used to determine the\n    * targets of callsites.\n-   * \n+   *\n    * This construction is the main cost of building the callgraph, so we offer\n    * the client a choice of NameReferenceGraph, which is slow and hopefully more\n    * precise, and SimpleDefinitionFinder, which is fast and perhaps not as\n    * precise.\n-   * \n+   *\n    * We use SimpleNameFinder as the default because in practice it does\n    * not appear to be less precise than NameReferenceGraph and is at least an\n    * order of magnitude faster on large compiles.\n         Node jsRoot) {\n     if (useNameReferenceGraph) {\n       // Name reference graph is very, very slow\n-      NameReferenceGraphConstruction graphConstruction \n+      NameReferenceGraphConstruction graphConstruction\n           = new NameReferenceGraphConstruction(compiler);\n \n       graphConstruction.process(externsRoot, jsRoot);\n       SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n       defFinder.process(externsRoot, jsRoot);\n       return defFinder;\n-    }   \n-  }\n-  \n+    }\n+  }\n+\n   /**\n    * Queries the definition provider for the definitions that could be the\n    * targets of the given callsite node.\n-   * \n+   *\n    * This is complicated by the fact that NameReferenceGraph and\n    * SimpleDefinitionProvider (the two definition providers we currently\n    * use) differ on the types of target nodes they will analyze.\n       Node callsite, DefinitionProvider definitionProvider) {\n     Preconditions.checkArgument(callsite.getType() == Token.CALL\n         || callsite.getType() == Token.NEW);\n-    \n+\n     Node targetExpression = callsite.getFirstChild();\n-    \n+\n     // NameReferenceGraph throws an exception unless the node is\n     // a GETPROP or a NAME\n-    if (!useNameReferenceGraph \n+    if (!useNameReferenceGraph\n         || (NodeUtil.isGetProp(targetExpression)\n         ||  NodeUtil.isName(targetExpression))) {\n-      \n-      Collection<Definition> definitions = \n+\n+      Collection<Definition> definitions =\n         definitionProvider.getDefinitionsReferencedAt(targetExpression);\n-      \n+\n       if (definitions != null && !definitions.isEmpty()) {\n         return definitions;\n       }\n     }\n-    \n+\n     return null;\n   }\n-  \n+\n   /**\n    * An inner class that represents functions in the call graph.\n    * A Function knows how to get its AST node and what Callsites\n    * it contains.\n    */\n   public class Function {\n-    \n+\n     private Node astNode;\n-    \n+\n     private boolean isAliased = false;\n-    \n+\n     private boolean isExposedToCallOrApply = false;\n-    \n+\n     private Collection<Callsite> callsitesInFunction;\n-    \n+\n     private Collection<Callsite> callsitesPossiblyTargetingFunction;\n-    \n+\n     private Function(Node functionAstNode) {\n       astNode = functionAstNode;\n     }\n-    \n+\n     /**\n      * Does this function represent the global \"main\" function?\n      */\n     public boolean isMain() {\n       return (this == CallGraph.this.mainFunction);\n     }\n-    \n+\n     /**\n      * Returns the underlying AST node for the function. This usually\n      * has type Token.FUNCTION but in the case of the \"main\" function\n     public Node getAstNode() {\n       return astNode;\n     }\n-    \n+\n     /**\n      * Returns the AST node for the body of the function. If this function\n      * is the main function, it will return the global block.\n         return NodeUtil.getFunctionBody(astNode);\n       }\n     }\n-    \n+\n     /**\n      * Gets the name of this function. Returns null if the function is\n      * anonymous.\n         return NodeUtil.getFunctionName(astNode);\n       }\n     }\n-    \n+\n     /**\n      * Returns the callsites in this function.\n      */\n         return ImmutableList.of();\n       }\n     }\n-    \n+\n     private void addCallsiteInFunction(Callsite callsite) {\n       if (callsitesInFunction == null) {\n         callsitesInFunction = new LinkedList<Callsite>();\n-      } \n+      }\n       callsitesInFunction.add(callsite);\n     }\n-    \n+\n     /**\n      * Returns a collection of callsites that might call this function.\n-     * \n+     *\n      * getCallsitesPossiblyTargetingFunction() is a best effort only: the\n      * collection may include callsites that do not actually call this function\n      * and if this function is exported or aliased may be missing actual\n-     * targets. \n-     * \n+     * targets.\n+     *\n      * This method should not be called on a Function from a CallGraph\n      * that was constructed with {@code computeBackwardGraph} {@code false}.\n      */\n             + \"from a non-backward CallGraph\");\n       }\n     }\n-    \n+\n     private void addCallsitePossiblyTargetingFunction(Callsite callsite) {\n       Preconditions.checkState(computeBackwardGraph);\n       if (callsitesPossiblyTargetingFunction == null) {\n         callsitesPossiblyTargetingFunction =\n             new LinkedList<Callsite>();\n-      } \n+      }\n       callsitesPossiblyTargetingFunction.add(callsite);\n     }\n-  \n+\n     /**\n      * Returns true if the function is aliased.\n      */\n     public boolean isAliased() {\n       return isAliased;\n     }\n-    \n+\n     /**\n      * Returns true if the function is ever exposed to \".call\" or \".apply\".\n      */\n       return isExposedToCallOrApply;\n     }\n   }\n-  \n+\n   /**\n    * An inner class that represents call sites in the call graph.\n    * A Callsite knows how to get its AST node, what its containing\n    */\n   public class Callsite {\n     private Node astNode;\n-    \n+\n     private boolean hasUnknownTarget = false;\n     private boolean hasExternTarget = false;\n-     \n+\n     private Function containingFunction = null;\n-    \n+\n     private Collection<Function> possibleTargets;\n-    \n+\n     private Callsite(Node callsiteAstNode) {\n       astNode = callsiteAstNode;\n     }\n-    \n+\n     public Node getAstNode() {\n       return astNode;\n     }\n-    \n+\n     public Function getContainingFunction() {\n       return containingFunction;\n     }\n-    \n+\n     /**\n      * Returns the possible target functions that this callsite could call.\n-     * \n+     *\n      * These targets do not include functions defined in externs. If this\n      * callsite could call an extern function, then hasExternTarget() will\n      * return true.\n-     * \n+     *\n      * getKnownTargets() is a best effort only: the collection may include\n      * other functions that are not actual targets and (if hasUnknownTargets()\n      * is true) may be missing actual targets.\n-     * \n+     *\n      * This method should not be called on a Callsite from a CallGraph\n      * that was constructed with {@code computeForwardGraph} {@code false}.\n      */\n             \"CallGraph\");\n       }\n     }\n-    \n+\n     private void addPossibleTarget(Function target) {\n       Preconditions.checkState(computeForwardGraph);\n-      \n+\n       if (possibleTargets == null) {\n         possibleTargets = new LinkedList<Function>();\n-      } \n+      }\n       possibleTargets.add(target);\n     }\n-    \n+\n     /**\n      * If true, then DefinitionProvider used in callgraph construction\n      * was unable find all target functions of this callsite.\n-     * \n+     *\n      * If false, then getKnownTargets() contains all the possible targets of\n      * this callsite (and, perhaps, additional targets as well).\n      */\n     public boolean hasUnknownTarget() {\n       return hasUnknownTarget;\n     }\n-    \n+\n     /**\n      * If true, then this callsite could target a function defined in the\n      * externs. If false, then not.\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n   private UndiGraph<Var, Void> computeVariableNamesInterferenceGraph(\n       NodeTraversal t, ControlFlowGraph<Node> cfg, Set<Var> escaped) {\n     UndiGraph<Var, Void> interferenceGraph =\n-        new LinkedUndirectedGraph<Var, Void>();\n+        LinkedUndirectedGraph.create();\n     Scope scope = t.getScope();\n \n     // First create a node for each non-escaped variable.\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   ControlFlowGraph<Node> computeCFG() {\n     logger.info(\"Computing Control Flow Graph\");\n     Tracer tracer = newTracer(\"computeCFG\");\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true);\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n     process(cfa);\n     stopTracer(tracer, \"computeCFG\");\n     return cfa.getCfg();\n   /** Gets the DOT graph of the AST generated at the end of compilation. */\n   public String getAstDotGraph() throws IOException {\n     if (jsRoot != null) {\n-      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true);\n+      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n       cfa.process(null, jsRoot);\n       return DotFormatter.toDot(jsRoot, cfa.getCfg());\n     } else {\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n   private int priorityCounter;\n \n   private final boolean shouldTraverseFunctions;\n+  private final boolean edgeAnnotations;\n \n   // We need to store where we started, in case we aren't doing a flow analysis\n   // for the whole scope. This happens, for example, when running type inference\n    * @param compiler Compiler instance.\n    * @param shouldTraverseFunctions Whether functions should be traversed (true\n    *    by default).\n+   * @param edgeAnnotations Whether to allow edge annotations. By default,\n+   *    only node annotations are allowed.\n    */\n   ControlFlowAnalysis(AbstractCompiler compiler,\n-      boolean shouldTraverseFunctions) {\n+      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n     this.compiler = compiler;\n     this.shouldTraverseFunctions = shouldTraverseFunctions;\n+    this.edgeAnnotations = edgeAnnotations;\n   }\n \n   ControlFlowGraph<Node> getCfg() {\n     astPositionCounter = 0;\n     astPosition = Maps.newHashMap();\n     nodePriorities = Maps.newHashMap();\n-    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);\n+    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n+                                  edgeAnnotations);\n     NodeTraversal.traverse(compiler, root, this);\n     astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n \n      *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n      */\n     private AstControlFlowGraph(Node entry,\n-        Map<DiGraphNode<Node, Branch>, Integer> priorities) {\n-      super(entry);\n+        Map<DiGraphNode<Node, Branch>, Integer> priorities,\n+        boolean edgeAnnotations) {\n+      super(entry,\n+          true /* node annotations */, edgeAnnotations);\n       this.priorities = priorities;\n     }\n \n--- a/src/com/google/javascript/jscomp/ControlFlowGraph.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowGraph.java\n   /**\n    * Constructor.\n    */\n-  public ControlFlowGraph(N entry) {\n+  ControlFlowGraph(\n+      N entry, boolean nodeAnnotations, boolean edgeAnnotations) {\n+    super(nodeAnnotations, edgeAnnotations);\n     implicitReturn = createDirectedGraphNode(null);\n     this.entry = createDirectedGraphNode(entry);\n   }\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n     }\n \n     // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(NodeUtil.isFunction(t.getScopeRoot()));\n     cfa.process(null, t.getScopeRoot().getLastChild());\n--- a/src/com/google/javascript/jscomp/InstrumentFunctions.java\n+++ b/src/com/google/javascript/jscomp/InstrumentFunctions.java\n      */\n     private boolean allPathsReturn(Node block) {\n       // Computes the control flow graph.\n-      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n+      ControlFlowAnalysis cfa = new ControlFlowAnalysis(\n+          compiler, false, false);\n       cfa.process(null, block);\n       ControlFlowGraph<Node> cfg = cfa.getCfg();\n \n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n \n   /** Reference dependency graph */\n   private DiGraph<JsName, RefType> referenceGraph =\n-      new LinkedDirectedGraph<JsName, RefType>();\n+      LinkedDirectedGraph.createWithoutAnnotations();\n \n   /**\n    * Map of name scopes - all children of the Node key have a dependency on the\n--- a/src/com/google/javascript/jscomp/NameReferenceGraph.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraph.java\n   final AbstractCompiler compiler;\n \n   public NameReferenceGraph(AbstractCompiler compiler) {\n+    super(true, true);\n     this.compiler = compiler;\n \n     // Initialize builtins.\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n   /** Gets the control flow graph for the current JS scope. */\n   public ControlFlowGraph<Node> getControlFlowGraph() {\n     if (cfgs.peek() == null) {\n-      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n+      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n       cfa.process(null, getScopeRoot());\n       cfgs.pop();\n       cfgs.push(cfa.getCfg());\n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n    * Gets a graph of the passes run. For debugging.\n    */\n   GraphvizGraph getPassGraph() {\n-    LinkedDirectedGraph<String, String> graph = LinkedDirectedGraph.create();\n+    LinkedDirectedGraph<String, String> graph =\n+        LinkedDirectedGraph.createWithoutAnnotations();\n     Iterable<PassFactory> allPasses =\n         Iterables.concat(getChecks(), getOptimizations());\n     String lastPass = null;\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n   private void propagateSideEffects() {\n     // Nodes are function declarations; Edges are function call sites.\n     DiGraph<FunctionInformation, Node> sideEffectGraph =\n-        new LinkedDirectedGraph<FunctionInformation, Node>();\n+        LinkedDirectedGraph.createWithoutAnnotations();\n \n     // create graph nodes\n     for (FunctionInformation functionInfo : functionSideEffectMap.values()) {\n--- a/src/com/google/javascript/jscomp/TypeInferencePass.java\n+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java\n   }\n \n   private ControlFlowGraph<Node> computeCfg(Node n) {\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n     cfa.process(null, n);\n     return cfa.getCfg();\n   }\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n     Scope scope = t.getScope();\n \n     // Computes the control flow graph.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n     cfa.process(null, scope.getRootNode());\n     cfgStack.push(curCfg);\n     curCfg = cfa.getCfg();\n--- a/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n     return new SimpleSubGraph<N, E>(this);\n   }\n \n+  public static <N, E> LinkedDirectedGraph<N, E> createWithoutAnnotations() {\n+    return new LinkedDirectedGraph<N, E>(false, false);\n+  }\n+\n+  public static <N, E> LinkedDirectedGraph<N, E> createWithNodeAnnotations() {\n+    return new LinkedDirectedGraph<N, E>(true, false);\n+  }\n+\n+  public static <N, E> LinkedDirectedGraph<N, E> createWithEdgeAnnotations() {\n+    return new LinkedDirectedGraph<N, E>(false, true);\n+  }\n+\n   public static <N, E> LinkedDirectedGraph<N, E> create() {\n-    return new LinkedDirectedGraph<N, E>();\n+    return new LinkedDirectedGraph<N, E>(true, true);\n+  }\n+\n+  private final boolean useNodeAnnotations;\n+  private final boolean useEdgeAnnotations;\n+\n+  protected LinkedDirectedGraph(\n+      boolean useNodeAnnotations, boolean useEdgeAnnotations) {\n+    this.useNodeAnnotations = useNodeAnnotations;\n+    this.useEdgeAnnotations = useEdgeAnnotations;\n   }\n \n   @Override\n     LinkedDirectedGraphNode<N, E> src = getNodeOrFail(srcValue);\n     LinkedDirectedGraphNode<N, E> dest = getNodeOrFail(destValue);\n     LinkedDirectedGraphEdge<N, E> edge =\n+        useEdgeAnnotations ?\n+        new AnnotatedLinkedDirectedGraphEdge<N, E>(src, edgeValue, dest) :\n         new LinkedDirectedGraphEdge<N, E>(src, edgeValue, dest);\n     src.getOutEdges().add(edge);\n     dest.getInEdges().add(edge);\n   public DiGraphNode<N, E> createDirectedGraphNode(N nodeValue) {\n     LinkedDirectedGraphNode<N, E> node = nodes.get(nodeValue);\n     if (node == null) {\n-      node = new LinkedDirectedGraphNode<N, E>(nodeValue);\n+      node = useNodeAnnotations ?\n+          new AnnotatedLinkedDirectedGraphNode<N, E>(nodeValue) :\n+          new LinkedDirectedGraphNode<N, E>(nodeValue);\n       nodes.put(nodeValue, node);\n     }\n     return node;\n \n     protected final N value;\n \n-    protected Annotation annotation;\n-\n-    protected int id;\n-\n-    private static int totalNodes = 0;\n-\n     /**\n      * Constructor\n      *\n      */\n     LinkedDirectedGraphNode(N nodeValue) {\n       this.value = nodeValue;\n-      this.id = totalNodes++;\n     }\n \n     @Override\n       return value;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     @Override\n     public <A extends Annotation> A getAnnotation() {\n-      return (A) annotation;\n+      throw new UnsupportedOperationException(\n+          \"Graph initialized with node annotations turned off\");\n     }\n \n     @Override\n     public void setAnnotation(Annotation data) {\n-      annotation = data;\n+      throw new UnsupportedOperationException(\n+          \"Graph initialized with node annotations turned off\");\n     }\n \n     @Override\n \n     @Override\n     public String getId() {\n-      return \"LDN\" + id;\n+      return \"LDN\" + hashCode();\n     }\n \n     @Override\n   }\n \n   /**\n+   * A directed graph node with annotations.\n+   */\n+  static class AnnotatedLinkedDirectedGraphNode<N, E>\n+      extends LinkedDirectedGraphNode<N, E> {\n+\n+    protected Annotation annotation;\n+\n+    /**\n+     * @param nodeValue Node's value.\n+     */\n+    AnnotatedLinkedDirectedGraphNode(N nodeValue) {\n+      super(nodeValue);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <A extends Annotation> A getAnnotation() {\n+      return (A) annotation;\n+    }\n+\n+    @Override\n+    public void setAnnotation(Annotation data) {\n+      annotation = data;\n+    }\n+  }\n+\n+  /**\n    * A directed graph edge that stores the source and destination nodes at each\n    * edge.\n    */\n     private DiGraphNode<N, E> destNode;\n \n     protected final E value;\n-\n-    protected Annotation annotation;\n \n     /**\n      * Constructor.\n       return value;\n     }\n \n+    @Override\n+    public <A extends Annotation> A getAnnotation() {\n+      throw new UnsupportedOperationException(\n+          \"Graph initialized with edge annotations turned off\");\n+    }\n+\n+    @Override\n+    public void setAnnotation(Annotation data) {\n+      throw new UnsupportedOperationException(\n+          \"Graph initialized with edge annotations turned off\");\n+    }\n+\n+    @Override\n+    public String getColor() {\n+      return \"black\";\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+      return value != null ? value.toString() : \"null\";\n+    }\n+\n+    @Override\n+    public String getNode1Id() {\n+      return ((LinkedDirectedGraphNode<N, E>) sourceNode).getId();\n+    }\n+\n+    @Override\n+    public String getNode2Id() {\n+      return ((LinkedDirectedGraphNode<N, E>) destNode).getId();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return sourceNode.toString() + \" -> \" + destNode.toString();\n+    }\n+\n+    @Override\n+    public GraphNode<N, E> getNodeA() {\n+      return sourceNode;\n+    }\n+\n+    @Override\n+    public GraphNode<N, E> getNodeB() {\n+      return destNode;\n+    }\n+  }\n+\n+  /**\n+   * A directed graph edge that stores the source and destination nodes at each\n+   * edge.\n+   */\n+  static class AnnotatedLinkedDirectedGraphEdge<N, E>\n+      extends LinkedDirectedGraphEdge<N, E> {\n+\n+    protected Annotation annotation;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param edgeValue Edge Value.\n+     */\n+    AnnotatedLinkedDirectedGraphEdge(DiGraphNode<N, E> sourceNode,\n+        E edgeValue, DiGraphNode<N, E> destNode) {\n+      super(sourceNode, edgeValue, destNode);\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <A extends Annotation> A getAnnotation() {\n     public void setAnnotation(Annotation data) {\n       annotation = data;\n     }\n-\n-    @Override\n-    public String getColor() {\n-      return \"black\";\n-    }\n-\n-    @Override\n-    public String getLabel() {\n-      return value != null ? value.toString() : \"null\";\n-    }\n-\n-    @Override\n-    public String getNode1Id() {\n-      return ((LinkedDirectedGraphNode<N, E>) sourceNode).getId();\n-    }\n-\n-    @Override\n-    public String getNode2Id() {\n-      return ((LinkedDirectedGraphNode<N, E>) destNode).getId();\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return sourceNode.toString() + \" -> \" + destNode.toString();\n-    }\n-\n-    @Override\n-    public GraphNode<N, E> getNodeA() {\n-      return sourceNode;\n-    }\n-\n-    @Override\n-    public GraphNode<N, E> getNodeB() {\n-      return destNode;\n-    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n     return new SimpleSubGraph<N, E>(this);\n   }\n \n+  public static <N, E> LinkedUndirectedGraph<N, E> createWithoutAnnotations() {\n+    return new LinkedUndirectedGraph<N, E>(false, false);\n+  }\n+\n+  public static <N, E> LinkedUndirectedGraph<N, E> createWithNodeAnnotations() {\n+    return new LinkedUndirectedGraph<N, E>(true, false);\n+  }\n+\n+  public static <N, E> LinkedUndirectedGraph<N, E> createWithEdgeAnnotations() {\n+    return new LinkedUndirectedGraph<N, E>(false, true);\n+  }\n+\n+  public static <N, E> LinkedUndirectedGraph<N, E> create() {\n+    return new LinkedUndirectedGraph<N, E>(true, true);\n+  }\n+\n+  private final boolean useNodeAnnotations;\n+  private final boolean useEdgeAnnotations;\n+\n+  protected LinkedUndirectedGraph(\n+      boolean useNodeAnnotations, boolean useEdgeAnnotations) {\n+    this.useNodeAnnotations = useNodeAnnotations;\n+    this.useEdgeAnnotations = useEdgeAnnotations;\n+  }\n+\n   @Override\n   public void connect(N srcValue, E edgeValue, N destValue) {\n     LinkedUndirectedGraphNode<N, E> src = getNodeOrFail(srcValue);\n     LinkedUndirectedGraphNode<N, E> dest = getNodeOrFail(destValue);\n     LinkedUndirectedGraphEdge<N, E> edge =\n+        useEdgeAnnotations ?\n+        new AnnotatedLinkedUndirectedGraphEdge<N, E>(src, edgeValue, dest) :\n         new LinkedUndirectedGraphEdge<N, E>(src, edgeValue, dest);\n     src.getNeighborEdges().add(edge);\n     dest.getNeighborEdges().add(edge);\n       N nodeValue) {\n     LinkedUndirectedGraphNode<N, E> node = nodes.get(nodeValue);\n     if (node == null) {\n-      node = new LinkedUndirectedGraphNode<N, E>(nodeValue);\n+      node = useNodeAnnotations ?\n+          new AnnotatedLinkedUndirectedGraphNode<N, E>(nodeValue) :\n+          new LinkedUndirectedGraphNode<N, E>(nodeValue);\n       nodes.put(nodeValue, node);\n     }\n     return node;\n     private List<UndiGraphEdge<N, E>> neighborList =\n       Lists.newArrayList();\n     private final N value;\n-    private Annotation annotation;\n-    private int id;\n-    private static int totalNodes = 0;\n-\n-    public LinkedUndirectedGraphNode(N nodeValue) {\n+\n+    LinkedUndirectedGraphNode(N nodeValue) {\n       this.value = nodeValue;\n-      this.id = totalNodes++;\n     }\n \n     @Override\n       return neighborList;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     @Override\n     public <A extends Annotation> A getAnnotation() {\n-      return (A) annotation;\n+      throw new UnsupportedOperationException(\n+          \"Graph initialized with node annotations turned off\");\n+    }\n+\n+    @Override\n+    public void setAnnotation(Annotation data) {\n+      throw new UnsupportedOperationException(\n+          \"Graph initialized with node annotations turned off\");\n     }\n \n     @Override\n     }\n \n     @Override\n-    public void setAnnotation(Annotation data) {\n-      annotation = data;\n-    }\n-\n-    @Override\n     public String getColor() {\n       return \"white\";\n     }\n \n     @Override\n     public String getId() {\n-      return \"LDN\" + id;\n+      return \"LDN\" + hashCode();\n     }\n \n     @Override\n   }\n \n   /**\n+   * An undirected graph node with annotations.\n+   */\n+  static class AnnotatedLinkedUndirectedGraphNode<N, E>\n+      extends LinkedUndirectedGraphNode<N, E> {\n+\n+    protected Annotation annotation;\n+\n+    AnnotatedLinkedUndirectedGraphNode(N nodeValue) {\n+      super(nodeValue);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <A extends Annotation> A getAnnotation() {\n+      return (A) annotation;\n+    }\n+\n+    @Override\n+    public void setAnnotation(Annotation data) {\n+      annotation = data;\n+    }\n+  }\n+\n+  /**\n    * An undirected graph edge that stores two nodes at each edge.\n    */\n   static class LinkedUndirectedGraphEdge<N, E> implements UndiGraphEdge<N, E>,\n     private UndiGraphNode<N, E> nodeA;\n     private UndiGraphNode<N, E> nodeB;\n     protected final E value;\n-    protected Annotation annotation;\n-\n-    public LinkedUndirectedGraphEdge(UndiGraphNode<N, E> nodeA, E edgeValue,\n+\n+    LinkedUndirectedGraphEdge(UndiGraphNode<N, E> nodeA, E edgeValue,\n         UndiGraphNode<N, E> nodeB) {\n       this.value = edgeValue;\n       this.nodeA = nodeA;\n       return nodeB;\n     }\n \n+    @Override\n+    public <A extends Annotation> A getAnnotation() {\n+      throw new UnsupportedOperationException(\n+          \"Graph initialized with edge annotations turned off\");\n+    }\n+\n+    @Override\n+    public void setAnnotation(Annotation data) {\n+      throw new UnsupportedOperationException(\n+          \"Graph initialized with edge annotations turned off\");\n+    }\n+\n+    @Override\n+    public String getColor() {\n+      return \"black\";\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+      return value != null ? value.toString() : \"null\";\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public String getNode1Id() {\n+      return ((LinkedUndirectedGraphNode<N, E>) nodeA).getId();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public String getNode2Id() {\n+      return ((LinkedUndirectedGraphNode<N, E>) nodeB).getId();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return nodeA.toString() + \" -- \" + nodeB.toString();\n+    }\n+  }\n+\n+  /**\n+   * An annotated undirected graph edge..\n+   */\n+  static class AnnotatedLinkedUndirectedGraphEdge<N, E>\n+      extends LinkedUndirectedGraphEdge<N, E> {\n+\n+    protected Annotation annotation;\n+\n+    AnnotatedLinkedUndirectedGraphEdge(\n+        UndiGraphNode<N, E> nodeA, E edgeValue,\n+        UndiGraphNode<N, E> nodeB) {\n+      super(nodeA, edgeValue, nodeB);\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <A extends Annotation> A getAnnotation() {\n     public void setAnnotation(Annotation data) {\n       annotation = data;\n     }\n-\n-    @Override\n-    public String getColor() {\n-      return \"black\";\n-    }\n-\n-    @Override\n-    public String getLabel() {\n-      return value != null ? value.toString() : \"null\";\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public String getNode1Id() {\n-      return ((LinkedUndirectedGraphNode<N, E>) nodeA).getId();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public String getNode2Id() {\n-      return ((LinkedUndirectedGraphNode<N, E>) nodeB).getId();\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return nodeA.toString() + \" -- \" + nodeB.toString();\n-    }\n   }\n }\n--- a/test/com/google/javascript/jscomp/CheckPathsBetweenNodesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckPathsBetweenNodesTest.java\n \n   /** Tests straight-line graphs. */\n   public void testSimple() {\n-    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    DiGraph<String, String> g = LinkedDirectedGraph.create();\n     g.createDirectedGraphNode(\"a\");\n     g.createDirectedGraphNode(\"b\");\n     g.createDirectedGraphNode(\"c\");\n    * are invalid.\n    */\n   public void testSomeValidPaths() {\n-    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    DiGraph<String, String> g = LinkedDirectedGraph.create();\n     g.createDirectedGraphNode(\"a\");\n     g.createDirectedGraphNode(\"b\");\n     g.createDirectedGraphNode(\"c\");\n \n   /** Tests a graph with many valid paths. */\n   public void testManyValidPaths() {\n-    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    DiGraph<String, String> g = LinkedDirectedGraph.create();\n     g.createDirectedGraphNode(\"a\");\n     g.createDirectedGraphNode(\"b\");\n     g.createDirectedGraphNode(\"c1\");\n \n   /** Tests a graph with some cycles. */\n   public void testCycles1() {\n-    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    DiGraph<String, String> g = LinkedDirectedGraph.create();\n     g.createDirectedGraphNode(\"a\");\n     g.createDirectedGraphNode(\"b\");\n     g.createDirectedGraphNode(\"c\");\n    * version of CheckPathsBetweenNodes.\n    */\n   public void testCycles2() {\n-    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    DiGraph<String, String> g = LinkedDirectedGraph.create();\n     g.createDirectedGraphNode(\"a\");\n     g.createDirectedGraphNode(\"b\");\n     g.createDirectedGraphNode(\"c\");\n    * version of CheckPathsBetweenNodes.\n    */\n   public void testCycles3() {\n-    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    DiGraph<String, String> g = LinkedDirectedGraph.create();\n     g.createDirectedGraphNode(\"a\");\n     g.createDirectedGraphNode(\"b\");\n     g.createDirectedGraphNode(\"c\");\n    * that some paths are indeed correct for the some path case.\n    */\n   public void testSomePath1() {\n-    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    DiGraph<String, String> g = LinkedDirectedGraph.create();\n     g.createDirectedGraphNode(\"a\");\n     g.createDirectedGraphNode(\"b\");\n     g.createDirectedGraphNode(\"c\");\n \n   public void testSomePath2() {\n     // No Paths between nodes, by definition, always false.\n-    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    DiGraph<String, String> g = LinkedDirectedGraph.create();\n     g.createDirectedGraphNode(\"a\");\n     g.createDirectedGraphNode(\"b\");\n \n \n   public void testNonInclusive() {\n     // No Paths between nodes, by definition, always false.\n-    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    DiGraph<String, String> g = LinkedDirectedGraph.create();\n     g.createDirectedGraphNode(\"a\");\n     g.createDirectedGraphNode(\"b\");\n     g.createDirectedGraphNode(\"c\");\n--- a/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n   private ControlFlowGraph<Node> createCfg(String input,\n       boolean runSynBlockPass) {\n     Compiler compiler = new Compiler();\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true);\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true, true);\n \n     Node root = compiler.parseSyntheticCode(\"cfgtest\", input);\n     if (runSynBlockPass) {\n       boolean shouldTraverseFunctions) {\n     Compiler compiler = new Compiler();\n     ControlFlowAnalysis cfa =\n-        new ControlFlowAnalysis(compiler, shouldTraverseFunctions);\n+        new ControlFlowAnalysis(compiler, shouldTraverseFunctions, true);\n \n     Node root = compiler.parseSyntheticCode(\"cfgtest\", input);\n     cfa.process(null, root);\n \n   public void testPartialTraversalOfScope() {\n     Compiler compiler = new Compiler();\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true);\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true, true);\n \n     Node script1 = compiler.parseSyntheticCode(\"cfgtest\", \"var foo;\");\n     Node script2 = compiler.parseSyntheticCode(\"cfgtest2\", \"var bar;\");\n--- a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n     Instruction inst3 = newAssignNumberToVariableInstruction(b, 1);\n     Instruction inst4 = newAssignVariableToVariableInstruction(c, b);\n     ControlFlowGraph<Instruction> cfg =\n-      new ControlFlowGraph<Instruction>(inst1);\n+      new ControlFlowGraph<Instruction>(inst1, true, true);\n     GraphNode<Instruction, Branch> n1 = cfg.createNode(inst1);\n     GraphNode<Instruction, Branch> n2 = cfg.createNode(inst2);\n     GraphNode<Instruction, Branch> n3 = cfg.createNode(inst3);\n     Instruction inst3 = new BranchInstruction(b);\n     Instruction inst4 = newAssignVariableToVariableInstruction(c, a);\n     ControlFlowGraph<Instruction> cfg =\n-      new ControlFlowGraph<Instruction>(inst1);\n+      new ControlFlowGraph<Instruction>(inst1, true, true);\n     GraphNode<Instruction, Branch> n1 = cfg.createNode(inst1);\n     GraphNode<Instruction, Branch> n2 = cfg.createNode(inst2);\n     GraphNode<Instruction, Branch> n3 = cfg.createNode(inst3);\n     Instruction inst3 = newAssignNumberToVariableInstruction(b, 0);\n     Instruction inst4 = newAssignVariableToVariableInstruction(c, b);\n     ControlFlowGraph<Instruction> cfg =\n-      new ControlFlowGraph<Instruction>(inst1);\n+      new ControlFlowGraph<Instruction>(inst1, true, true);\n     GraphNode<Instruction, Branch> n1 = cfg.createNode(inst1);\n     GraphNode<Instruction, Branch> n2 = cfg.createNode(inst2);\n     GraphNode<Instruction, Branch> n3 = cfg.createNode(inst3);\n     Variable a = new Variable(\"a\");\n     Instruction inst1 = new ArithmeticInstruction(a, a, Operation.ADD, a);\n     ControlFlowGraph<Instruction> cfg =\n-      new ControlFlowGraph<Instruction>(inst1) {\n+      new ControlFlowGraph<Instruction>(inst1, true, true) {\n       @Override\n       public Comparator<DiGraphNode<Instruction, Branch>>\n           getOptionalNodeComparator(boolean isForward) {\n--- a/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java\n+++ b/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java\n     D = new Counter();\n     E = new Counter();\n \n-    graph = new LinkedDirectedGraph<Counter, String>();\n+    graph = LinkedDirectedGraph.create();\n     graph.createDirectedGraphNode(A);\n     graph.createDirectedGraphNode(B);\n     graph.createDirectedGraphNode(C);\n     A = new Counter();\n     B = new Counter();\n \n-    graph = new LinkedDirectedGraph<Counter, String>();\n+    graph = LinkedDirectedGraph.create();\n     graph.createDirectedGraphNode(A);\n     graph.createDirectedGraphNode(B);\n \n--- a/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n     assertEquals(0, compiler.getErrorCount());\n     Scope scope = new SyntacticScopeCreator(compiler).createScope(\n         n, new Scope(script, compiler));\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     cfa.process(null, n);\n     ControlFlowGraph<Node> cfg = cfa.getCfg();\n     LiveVariablesAnalysis analysis =\n--- a/test/com/google/javascript/jscomp/MaybeReachingVariableUseTest.java\n+++ b/test/com/google/javascript/jscomp/MaybeReachingVariableUseTest.java\n     Node n = compiler.parseTestCode(src).getFirstChild();\n     assertEquals(0, compiler.getErrorCount());\n     Scope scope = new SyntacticScopeCreator(compiler).createScope(n, null);\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     cfa.process(null, n);\n     ControlFlowGraph<Node> cfg = cfa.getCfg();\n     useDef = new MaybeReachingVariableUse(cfg, scope, compiler);\n--- a/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n+++ b/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n     Node root = compiler.parseTestCode(src).getFirstChild();\n     assertEquals(0, compiler.getErrorCount());\n     Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null);\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     cfa.process(null, root);\n     ControlFlowGraph<Node> cfg = cfa.getCfg();\n     defUse = new MustBeReachingVariableDef(cfg, scope, compiler);\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n       assumedScope.declare(entry.getKey(), null, entry.getValue(), null);\n     }\n     // Create the control graph.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n     cfa.process(null, n);\n     ControlFlowGraph<Node> cfg = cfa.getCfg();\n     // Create a simple reverse abstract interpreter.\n--- a/test/com/google/javascript/jscomp/graph/GraphColoringTest.java\n+++ b/test/com/google/javascript/jscomp/graph/GraphColoringTest.java\n public class GraphColoringTest extends TestCase {\n \n   public void testNoEdge() {\n-    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    Graph<String, String> graph = LinkedUndirectedGraph.create();\n     for (int i = 0; i < 5; i++) {\n       graph.createNode(\"Node \" + i);\n       // All node with same color.\n   }\n \n   public void testTwoNodesConnected() {\n-    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    Graph<String, String> graph = LinkedUndirectedGraph.create();\n     graph.createNode(\"A\");\n     graph.createNode(\"B\");\n     graph.connect(\"A\", \"--\", \"B\");\n   }\n \n   public void testGreedy() {\n-    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    Graph<String, String> graph = LinkedUndirectedGraph.create();\n     graph.createNode(\"A\");\n     graph.createNode(\"B\");\n     graph.createNode(\"C\");\n \n   public void testFullyConnected() {\n     final int count = 100;\n-    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    Graph<String, String> graph = LinkedUndirectedGraph.create();\n     for (int i = 0; i < count; i++) {\n       graph.createNode(\"Node \" + i);\n       for (int j = 0; j < count; j++) {\n \n   public void testAllConnectedToOneNode() {\n     final int count = 10;\n-    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    Graph<String, String> graph = LinkedUndirectedGraph.create();\n     graph.createNode(\"Center\");\n     for (int i = 0; i < count; i++) {\n       graph.createNode(\"Node \" + i);\n   public void testTwoFullyConnected() {\n     final int count = 100;\n     // A graph with two disconnected disjunct cliques.\n-    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    Graph<String, String> graph = LinkedUndirectedGraph.create();\n     for (int i = 0; i < count; i++) {\n       graph.createNode(\"Node Left \" + i);\n       graph.createNode(\"Node Right \" + i);\n \n   public void testDeterministic() {\n     // A pentagon.\n-    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    Graph<String, String> graph = LinkedUndirectedGraph.create();\n     graph.createNode(\"A\");\n     graph.createNode(\"B\");\n     graph.createNode(\"C\");\n--- a/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java\n+++ b/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java\n   DiGraph<String, String> graph = null;\n \n   public void testSimple() {\n-    graph = new LinkedDirectedGraph<String, String>();\n+    graph = LinkedDirectedGraph.create();\n     graph.createNode(\"A\");\n     reachability = new GraphReachability<String, String>(graph);\n     reachability.compute(\"A\");\n--- a/test/com/google/javascript/jscomp/graph/GraphTest.java\n+++ b/test/com/google/javascript/jscomp/graph/GraphTest.java\n \n   public void testDirectedSimple() {\n     DiGraph<String, String> graph =\n-        new LinkedDirectedGraph<String, String>();\n+        LinkedDirectedGraph.create();\n     graph.createNode(\"a\");\n     graph.createNode(\"b\");\n     graph.createNode(\"c\");\n \n   public void testUndirectedSimple() {\n     UndiGraph<String, String> graph =\n-        new LinkedUndirectedGraph<String, String>();\n+        LinkedUndirectedGraph.create();\n     graph.createNode(\"a\");\n     graph.createNode(\"b\");\n     graph.createNode(\"c\");\n \n   public void testDirectedSelfLoop() {\n     DiGraph<String, String> graph =\n-        new LinkedDirectedGraph<String, String>();\n+        LinkedDirectedGraph.create();\n     graph.createNode(\"a\");\n     graph.createNode(\"b\");\n     graph.connect(\"a\", \"->\", \"a\");\n \n   public void testUndirectedSelfLoop() {\n     UndiGraph<String, String> graph =\n-        new LinkedUndirectedGraph<String, String>();\n+        LinkedUndirectedGraph.create();\n     graph.createNode(\"a\");\n     graph.createNode(\"b\");\n     graph.connect(\"a\", \"--\", \"a\");\n \n   public void testDirectedInAndOutEdges() {\n     DiGraph<String, String> graph =\n-        new LinkedDirectedGraph<String, String>();\n+        LinkedDirectedGraph.create();\n     graph.createNode(\"a\");\n     graph.createNode(\"b\");\n     graph.createNode(\"c\");\n \n   public void testUndirectedNeighbors() {\n     UndiGraph<String, String> graph =\n-        new LinkedUndirectedGraph<String, String>();\n+        LinkedUndirectedGraph.create();\n     graph.createNode(\"a\");\n     graph.createNode(\"b\");\n     graph.createNode(\"c\");\n   }\n \n   public void testNodeAnnotations() {\n-    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    Graph<String, String> graph = LinkedUndirectedGraph.create();\n     GraphNode<String, String> a = graph.createNode(\"a\");\n     GraphNode<String, String> b = graph.createNode(\"b\");\n     checkAnnotations(graph, a, b);\n   }\n \n   public void testEdgeAnnotations() {\n-    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    Graph<String, String> graph = LinkedUndirectedGraph.create();\n     graph.createNode(\"1\");\n     graph.createNode(\"2\");\n     graph.createNode(\"3\");\n   }\n \n   public void testDegree() {\n-    testDirectedDegree(new LinkedDirectedGraph<String, String>());\n-    testDirectedDegree(new LinkedUndirectedGraph<String, String>());\n+    testDirectedDegree(LinkedDirectedGraph.<String, String>create());\n+    testDirectedDegree(LinkedUndirectedGraph.<String, String>create());\n   }\n \n   public void testDirectedDegree(Graph<String, String> graph) {\n   }\n \n   public void testDirectedConnectIfNotFound() {\n-    testDirectedConnectIfNotFound(new LinkedDirectedGraph<String, String>());\n-    testDirectedConnectIfNotFound(new LinkedUndirectedGraph<String, String>());\n+    testDirectedConnectIfNotFound(\n+        LinkedDirectedGraph.<String, String>create());\n+    testDirectedConnectIfNotFound(\n+        LinkedUndirectedGraph.<String, String>create());\n   }\n \n   public void testDirectedConnectIfNotFound(Graph<String, String> graph) {\n \n   public void testSimpleSubGraph() {\n     UndiGraph<String, String> graph =\n-        new LinkedUndirectedGraph<String, String>();\n+        LinkedUndirectedGraph.create();\n     graph.createNode(\"a\");\n     graph.createNode(\"b\");\n     graph.createNode(\"c\");", "timestamp": 1291414225, "metainfo": ""}