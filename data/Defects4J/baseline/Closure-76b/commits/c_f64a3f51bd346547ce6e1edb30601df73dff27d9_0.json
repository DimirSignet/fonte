{"sha": "f64a3f51bd346547ce6e1edb30601df73dff27d9", "log": "a really terrible fix for issue 291 fixes issue 291  R=johnlenz DELTA=69  (63 added, 0 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=134   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n     Node elseBranch = thenBranch.getNext();\n \n     if (elseBranch == null) {\n-      if (isExpressBlock(thenBranch)) {\n+      if (isFoldableExpressBlock(thenBranch)) {\n         Node expr = getBlockExpression(thenBranch);\n         if (isPropertyAssignmentInExpression(expr)) {\n           // Keep opportunities for CollapseProperties such as\n       return returnNode;\n     }\n \n-    boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch);\n-    boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch);\n+    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n+    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n \n     if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n       Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    * @return Whether the node is a block with a single statement that is\n    *     an expression.\n    */\n-  private boolean isExpressBlock(Node n) {\n+  private boolean isFoldableExpressBlock(Node n) {\n     if (n.getType() == Token.BLOCK) {\n       if (n.hasOneChild()) {\n-        return NodeUtil.isExpressionNode(n.getFirstChild());\n+        Node maybeExpr = n.getFirstChild();\n+        if (maybeExpr.getType() == Token.EXPR_RESULT) {\n+          // IE has a bug where event handlers behave differently when\n+          // their return value is used vs. when their return value is in\n+          // an EXPR_RESULT. It's pretty freaking weird. See:\n+          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n+          // We try to detect this case, and not fold EXPR_RESULTs\n+          // into other expressions.\n+          if (maybeExpr.getFirstChild().getType() == Token.CALL) {\n+            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n+\n+            // We only have to worry about methods with an implicit 'this'\n+            // param, or this doesn't happen.\n+            if (calledFn.getType() == Token.GETELEM) {\n+              return false;\n+            } else if (calledFn.getType() == Token.GETPROP &&\n+                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n+              return false;\n+            }\n+          }\n+\n+          return true;\n+        }\n+        return false;\n       }\n     }\n \n    * @return The expression node.\n    */\n   private Node getBlockExpression(Node n) {\n-    Preconditions.checkState(isExpressBlock(n));\n+    Preconditions.checkState(isFoldableExpressBlock(n));\n     return n.getFirstChild();\n   }\n \n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n \n     foldSame(\"function f() { try{ return a } finally { a = 2 } return a; }\");\n   }\n+\n+  public void testIssue291() {\n+    fold(\"if (true) { f.onchange(); }\", \"if (1) f.onchange();\");\n+    foldSame(\"if (f) { f.onchange(); }\");\n+    foldSame(\"if (f) { f.bar(); } else { f.onchange(); }\");\n+    fold(\"if (f) { f.bonchange(); }\", \"f && f.bonchange();\");\n+    foldSame(\"if (f) { f['x'](); }\");\n+  }\n }", "timestamp": 1292368674, "metainfo": ""}