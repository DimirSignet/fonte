{"sha": "bf1185e5d96eeb9e6621a6ee20a09d4d96a82749", "log": "changed chomp() to match Perl deprecated chomp* methods in favor of new slice methods improved unit tests and documentation   ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n  * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n  * @author Arun Mammen Thomas\n  * @since 1.0\n- * @version $Id: StringUtils.java,v 1.39 2003/03/25 00:15:58 scolebourne Exp $\n+ * @version $Id: StringUtils.java,v 1.40 2003/03/29 16:17:21 alex Exp $\n  */\n public class StringUtils {\n \n \n     // Chomping\n     //--------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Remove one newline from end of a String if it's there,\n+     * otherwise leave it alone.  A newline is \"\\n\", \"\\r\", or \"\\r\\n\".\n+     * <p>\n+     * Note that this behavior has changed from 1.0.  It\n+     * now more closely matches Perl chomp.  For the previous behavior,\n+     * use slice(String).\n+     *\n+     * @param str String to chomp a newline from\n+     * @return String without newline\n+     * @throws NullPointerException if str is <code>null</code>\n+     */\n+    public static String chomp(String str) {\n+        if (str.length() == 0) {\n+            return str;\n+        }\n+\n+        if (str.length() == 1) {\n+            if (\"\\r\".equals(str) || \"\\n\".equals(str)) {\n+                return \"\";\n+            }\n+            else {\n+                return str;\n+            }\n+        }\n+\n+        int lastIdx = str.length() - 1;\n+        char last = str.charAt(lastIdx);\n+\n+        if (last == '\\n') {\n+            if (str.charAt(lastIdx - 1) == '\\r') {\n+                lastIdx--;\n+            }\n+        } else if (last == '\\r') {\n+\n+        } else {\n+            lastIdx++;\n+        }\n+        return str.substring(0, lastIdx);\n+    }\n+\n+    /**\n+     * <p>Remove one string (the separator) from the end of another\n+     * string if it's there, otherwise leave it alone.\n+     * <p>\n+     *\n+     * Note that this behavior has changed from 1.0.  It\n+     * now more closely matches Perl chomp.  For the previous behavior,\n+     * use slice(String,String).\n+     *\n+     * @param str string to chomp from\n+     * @param separator separator string\n+     * @return String without trailing separator\n+     * @throws NullPointerException if str is <code>null</code>\n+     */\n+    public static String chomp(String str, String separator) {\n+        if (str.length() == 0) {\n+            return str;\n+        }\n+        if (str.endsWith(separator)) {\n+            return str.substring(0, str.length() - separator.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Remove a newline if and only if it is at the end\n+     * of the supplied String.</p>\n+     * \n+     * @param str String to chomp from\n+     * @return String without chomped ending\n+     * @throws NullPointerException if str is <code>null</code>\n+     * @deprecated use chomp(String) instead\n+     */\n+    public static String chompLast(String str) {\n+        return chompLast(str, \"\\n\");\n+    }\n     \n-    /** \n-     * <p>Remove the last newline, and everything after it from a String.</p>\n-     *\n-     * @param str String to chomp the newline from\n-     * @return String without chomped newline\n-     * @throws NullPointerException if str is <code>null</code>\n-     */\n-    public static String chomp(String str) {\n-        return chomp(str, \"\\n\");\n-    }\n-    \n-    /** \n-     * <p>Remove the last value of a supplied String, and everything after\n-     * it from a String.</p>\n-     *\n+    /**\n+     * <p>Remove a value if and only if the String ends with that value.</p>\n+     * \n      * @param str String to chomp from\n      * @param sep String to chomp\n      * @return String without chomped ending\n      * @throws NullPointerException if str or sep is <code>null</code>\n-     */\n-    public static String chomp(String str, String sep) {\n-        int idx = str.lastIndexOf(sep);\n-        if (idx != -1) {\n-            return str.substring(0, idx);\n-        } else {\n-            return str;\n-        }\n-    }\n-    \n-    /**\n-     * <p>Remove a newline if and only if it is at the end\n-     * of the supplied String.</p>\n-     * \n-     * @param str String to chomp from\n-     * @return String without chomped ending\n-     * @throws NullPointerException if str is <code>null</code>\n-     */\n-    public static String chompLast(String str) {\n-        return chompLast(str, \"\\n\");\n-    }\n-    \n-    /**\n-     * <p>Remove a value if and only if the String ends with that value.</p>\n-     * \n-     * @param str String to chomp from\n-     * @param sep String to chomp\n-     * @return String without chomped ending\n-     * @throws NullPointerException if str or sep is <code>null</code>\n+     * @deprecated use chomp(String,String) instead\n      */\n     public static String chompLast(String str, String sep) {\n         if (str.length() == 0) {\n \n     /** \n      * <p>Remove everything and return the last value of a supplied String, and\n-     * everything after it from a String.</p>\n+     * everything after it from a String.\n+     * [That makes no sense. Just use sliceRemainder() :-)]</p>\n      *\n      * @param str String to chomp from\n      * @param sep String to chomp\n      * @return String chomped\n      * @throws NullPointerException if str or sep is <code>null</code>\n+     * @deprecated use sliceRemainder(String,String) instead\n      */\n     public static String getChomp(String str, String sep) {\n         int idx = str.lastIndexOf(sep);\n      * @param sep String to chomp\n      * @return String without chomped beginning\n      * @throws NullPointerException if str or sep is <code>null</code>\n+     * @deprecated use sliceFirstRemainder(String,String) instead\n      */\n     public static String prechomp(String str, String sep) {\n         int idx = str.indexOf(sep);\n      * @param sep String to chomp\n      * @return String prechomped\n      * @throws NullPointerException if str or sep is <code>null</code>\n+     * @deprecated use sliceFirst(String) instead\n      */\n     public static String getPrechomp(String str, String sep) {\n         int idx = str.indexOf(sep);\n      * @param str String to chop a newline from\n      * @return String without newline\n      * @throws NullPointerException if str is <code>null</code>\n+     * @deprecated use chomp(String) instead\n      */\n     public static String chopNewline(String str) {\n         int lastIdx = str.length() - 1;\n         return str.substring(0, lastIdx);\n     }\n \n+\n+    // Slicing\n+    //--------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Remove the last newline, and everything after it from a String.</p>\n+     * (This method was formerly named chomp or chopNewline.)\n+     *\n+     * @param str String to slice the newline from\n+     * @return String without sliced newline\n+     * @throws NullPointerException if str is <code>null</code>\n+     */\n+    public static String slice(String str) {\n+        return slice(str, \"\\n\");\n+    }\n+\n+    /**\n+     * <p>Find the last occurence of a separator String;\n+     * remove it and everything after it.</p>\n+     * (This method was formerly named chomp.)\n+     *\n+     * @param str String to slice from\n+     * @param sep String to slice\n+     * @return String without sliced ending\n+     * @throws NullPointerException if str or sep is <code>null</code>\n+     */\n+    public static String slice(String str, String sep) {\n+        int idx = str.lastIndexOf(sep);\n+        if (idx != -1) {\n+            return str.substring(0, idx);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * <p>Find the last occurence of a separator String, and return\n+     * everything after it.</p>\n+     * (This method was formerly named getchomp. Also, now it does not\n+     * include the separator in the return value.)\n+     *\n+     * @param str String to slice from\n+     * @param sep String to slice\n+     * @return String sliced\n+     * @throws NullPointerException if str or sep is <code>null</code>\n+     */\n+    public static String sliceRemainder(String str, String sep) {\n+        int idx = str.lastIndexOf(sep);\n+        if (idx == str.length() - sep.length()) {\n+            return \"\";\n+        } else if (idx != -1) {\n+            return str.substring(idx + sep.length());\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    /**\n+     * <p>Find the first occurence of a separator String, and return\n+     * everything after it.</p>\n+     * (This method was formerly named prechomp.  Also, previously\n+     * it included the separator in the return value; now it does not.)\n+     *\n+     * @param str String to slice from\n+     * @param sep String to slice\n+     * @return String without sliced beginning\n+     * @throws NullPointerException if str or sep is <code>null</code>\n+     */\n+    public static String sliceFirstRemainder(String str, String sep) {\n+        int idx = str.indexOf(sep);\n+        if (idx != -1) {\n+            return str.substring(idx + sep.length());\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * <p>Find the first occurence of a separator string;\n+     * return everything before it (but not including the separator).</p>\n+     * (This method was formerly named getPrechomp.  Also, it used to\n+     * include the separator, but now it does not.)\n+     *\n+     * @param str String to slice from\n+     * @param sep String to slice\n+     * @return String presliced\n+     * @throws NullPointerException if str or sep is <code>null</code>\n+     */\n+    public static String sliceFirst(String str, String sep) {\n+        int idx = str.indexOf(sep);\n+        if (idx != -1) {\n+            return str.substring(0, idx);\n+        } else {\n+            return \"\";\n+        }\n+    }\n \n     // Conversion\n     //--------------------------------------------------------------------------\n--- a/src/test/org/apache/commons/lang/StringUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/StringUtilsTest.java\n  * @author <a href=\"mailto:fredrik@westermarck.com>Fredrik Westermarck</a>\n  * @author Holger Krauth\n  * @author <a href=\"hps@intermeta.de\">Henning P. Schmiedehausen</a>\n- * @version $Id: StringUtilsTest.java,v 1.16 2003/03/23 21:51:19 scolebourne Exp $\n+ * @version $Id: StringUtilsTest.java,v 1.17 2003/03/29 16:17:21 alex Exp $\n  */\n public class StringUtilsTest extends TestCase {\n \n     }\n \n     public void testJoin() {\n-        assertEquals(\"concatenate(Object[]) failed\", \n+        assertEquals(\"concatenate(Object[]) failed\",\n                      TEXT_LIST_NOSEP, StringUtils.concatenate(ARRAY_LIST));\n         assertEquals(\"join(Object[], String) failed\", TEXT_LIST,\n                      StringUtils.join(ARRAY_LIST, SEPARATOR));\n                      StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(),\n                                       null));\n \n-        assertEquals(\"concatenate(Object[]) failed\", \n+        assertEquals(\"concatenate(Object[]) failed\",\n                      \"\", StringUtils.concatenate(EMPTY_ARRAY_LIST));\n         assertEquals(\"join(Object[], String) failed\", \"\",\n                      StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR));\n                      \"   \"+FOO+\"   \", StringUtils.center(FOO, 9) );\n     }\n \n-    public void testChompFunctions() {\n-        assertEquals(\"chomp(String) failed\",\n-                     FOO, StringUtils.chomp(FOO + \"\\n\" + FOO) );\n-\n+    public void testDeprecatedChompFunctions() {\n         assertEquals(\"chompLast(String) failed\",\n                      FOO, StringUtils.chompLast(FOO + \"\\n\") );\n \n         assertEquals(\"getPrechomp(String, String) failed\",\n                      FOO + \"\\n\", StringUtils.getPrechomp(FOO + \"\\n\" + FOO, \"\\n\") );\n \n-        assertEquals(\"chop(String, String) failed\",\n-                     FOO, StringUtils.chop(FOO + \"\\r\\n\") );\n-\n         assertEquals(\"chopNewline(String, String) failed\",\n                      FOO, StringUtils.chopNewline(FOO + \"\\r\\n\") );\n+    }\n+\n+    public void testChop() {\n+\n+        String[][] chopCases = {\n+            { FOO + \"\\r\\n\", FOO } ,\n+            { FOO + \"\\n\" , FOO } ,\n+            { FOO + \"\\r\", FOO },\n+            { \"foo\", \"fo\"},\n+            { \"foo\\nfoo\", \"foo\\nfo\" },\n+            { \"\\n\", \"\" },\n+            { \"\\r\", \"\" },\n+            { \"\\r\\n\", \"\" },\n+        };\n+        for (int i = 0; i < chopCases.length; i++) {\n+            String original = chopCases[i][0];\n+            String expectedResult = chopCases[i][1];\n+            assertEquals(\"chop(String) failed\",\n+                    expectedResult, StringUtils.chop(original));\n+        }\n+    }\n+\n+    public void testChomp() {\n+\n+        String[][] chompCases = {\n+            { FOO + \"\\r\\n\", FOO } ,\n+            { FOO + \"\\n\" , FOO } ,\n+            { FOO + \"\\r\", FOO },\n+            { FOO, FOO },\n+            { FOO + \"\\n\\n\", FOO + \"\\n\"},\n+            { \"foo\\nfoo\", \"foo\\nfoo\" },\n+            { \"\\n\", \"\" },\n+            { \"\\r\", \"\" },\n+            { \"\\r\\n\", \"\" },\n+        };\n+        for (int i = 0; i < chompCases.length; i++) {\n+            String original = chompCases[i][0];\n+            String expectedResult = chompCases[i][1];\n+            assertEquals(\"chomp(String) failed\",\n+                    expectedResult, StringUtils.chomp(original));\n+        }\n+\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foo\", StringUtils.chomp(\"foobar\", \"bar\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foobar\", StringUtils.chomp(\"foobar\", \"baz\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foo\", StringUtils.chomp(\"foo\", \"foooo\"));\n+    }\n+\n+    public void testSliceFunctions() {\n+\n+        String[][] sliceCases = {\n+            {\"foo\\n\", \"foo\"},\n+            {\"foo\\nbar\", \"foo\"},\n+            {\"foo\\nbar\\n\", \"foo\\nbar\"},\n+            {\"foo\\nbar\\nbaz\", \"foo\\nbar\"},\n+        };\n+        for (int i = 0; i < sliceCases.length; i++) {\n+            String original = sliceCases[i][0];\n+            String expectedResult = sliceCases[i][1];\n+            assertEquals(\"slice(String) failed\",\n+                    expectedResult, StringUtils.slice(original));\n+        }\n+\n+        String original = \"fooXXbarXXbaz\";\n+        String sep = \"XX\";\n+\n+        assertEquals(\"slice(String,String) failed\",\n+                     \"fooXXbar\", StringUtils.slice(original, sep) );\n+\n+        assertEquals(\"sliceRemainder(String, String) failed\",\n+                     \"baz\", StringUtils.sliceRemainder(original, sep) );\n+\n+        assertEquals(\"sliceFirst(String, String) failed\",\n+                     \"foo\", StringUtils.sliceFirst(original, sep) );\n+\n+        assertEquals(\"sliceFirstRemainder(String, String) failed\",\n+                     \"barXXbaz\", StringUtils.sliceFirstRemainder(original, sep) );\n+\n     }\n \n     public void testPadFunctions() {\n         assertEquals(\"reverse(empty-string) failed\",\n                      \"\", StringUtils.reverse(\"\") );\n         assertEquals(\"reverseDelimitedString(String,'.') failed\",\n-                     \"org.apache.test\", \n+                     \"org.apache.test\",\n                        StringUtils.reverseDelimitedString(\"test.apache.org\", \".\") );\n         assertEquals(\"reverseDelimitedString(empty-string,'.') failed\",\n-                     \"\", \n+                     \"\",\n                        StringUtils.reverseDelimitedString(\"\", \".\") );\n         assertEquals(\"reverseDelimitedString(String,' ') failed\",\n-                     \"once upon a time\", \n+                     \"once upon a time\",\n                        StringUtils.reverseDelimitedString(\"time a upon once\",\" \") );\n     }\n \n                      \"\\\\u0234\", StringUtils.escape(\"\\u0234\") );\n         assertEquals(\"escape(String) failed\",\n                      \"\\\\u00fd\", StringUtils.escape(\"\\u00fd\") );\n-        assertEquals(\"unescape(String) failed\", \n+        assertEquals(\"unescape(String) failed\",\n                      \"\", StringUtils.unescape(\"\") );\n-        assertEquals(\"unescape(String) failed\", \n+        assertEquals(\"unescape(String) failed\",\n                      \"test\", StringUtils.unescape(\"test\") );\n-        assertEquals(\"unescape(String) failed\", \n+        assertEquals(\"unescape(String) failed\",\n                      \"\\ntest\\b\", StringUtils.unescape(\"\\\\ntest\\\\b\") );\n-        assertEquals(\"unescape(String) failed\", \n+        assertEquals(\"unescape(String) failed\",\n                      \"\\u123425foo\\ntest\\b\", StringUtils.unescape(\"\\\\u123425foo\\\\ntest\\\\b\") );\n     }\n ", "timestamp": 1048954641, "metainfo": ""}