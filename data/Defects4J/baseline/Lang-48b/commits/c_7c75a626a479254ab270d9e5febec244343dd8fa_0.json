{"sha": "7c75a626a479254ab270d9e5febec244343dd8fa", "log": "Added printRootCauseStackTrace   ", "commit": "\n--- a/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n+++ b/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n  * <http://www.apache.org/>.\n  */\n \n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n import java.sql.SQLException;\n import java.util.ArrayList;\n import java.util.LinkedList;\n         }\n         return -1;\n     }\n-\n+    \n+    /**\n+     * Prints a compact stack trace for the root cause of a throwable.\n+     * The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.\n+     * <p>\n+     * The method is equivalent to t.printStackTrace() for throwables\n+     * that don't have nested causes.\n+     */\n+    public static void printRootCauseStackTrace(Throwable t, PrintStream stream)\n+    {\n+        String trace[] = getRootCauseStackTrace(t);\n+        for (int i = 0; i < trace.length; i++){\n+            stream.println(trace[i]);\n+        }\n+        stream.flush();\n+    }\n+    \n+    /**\n+     * Equivalent to printRootCauseStackTrace(t, System.err)\n+     */\n+    public static void printRootCauseStackTrace(Throwable t)\n+    {\n+        printRootCauseStackTrace(t, System.err);\n+    }\n+\n+    /**\n+     * Same as printRootCauseStackTrace(t, stream), except it takes\n+     * a PrintWriter as an argument.\n+     */\n+    public static void printRootCauseStackTrace(Throwable t, PrintWriter writer)\n+    {\n+        String trace[] = getRootCauseStackTrace(t);\n+        for (int i = 0; i < trace.length; i++){\n+            writer.println(trace[i]);\n+        }\n+        writer.flush();\n+    }\n+\n+\n+    /**\n+     * Creates a compact stack trace for the root cause of the supplied \n+     * throwable.\n+     *   \n+     * See <code>printRootCauseStackTrace(Throwable t, PrintStream s)</code> \n+     */\n+    public static String[] getRootCauseStackTrace(Throwable t)\n+    {\n+        Throwable throwables[] = getThrowables(t);\n+        int count = throwables.length;        \n+        ArrayList frames = new ArrayList();\n+        List nextTrace = getStackFrameList(throwables[count-1]);        \n+        for (int i = count; --i >= 0;){\n+            List trace = nextTrace;\n+            if (i != 0){\n+                nextTrace = getStackFrameList(throwables[i-1]);\n+                removeCommonFrames(trace, nextTrace);\n+            }\n+            if (i == count - 1){\n+                frames.add(throwables[i].toString());\n+            }\n+            else {\n+                frames.add(\" [wrapped] \" + throwables[i].toString());\n+            }\n+            for (int j = 0; j < trace.size(); j++){\n+                frames.add(trace.get(j));\n+            }\n+        }\n+        return (String[]) frames.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Given two stack traces, removes common frames from the cause trace.\n+     * \n+     * @param causeFrames   stack trace of a cause throwable\n+     * @param wrapperFrames stack trace of a wrapper throwable \n+     */\n+    private static void removeCommonFrames(List causeFrames, List wrapperFrames)\n+    {\n+        int causeFrameIndex = causeFrames.size() - 1; \n+        int wrapperFrameIndex = wrapperFrames.size() - 1;\n+        while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0)\n+        {\n+            // Remove the frame from the cause trace if it is the same\n+            // as in the wrapper trace\n+            String causeFrame = (String)causeFrames.get(causeFrameIndex);\n+            String wrapperFrame = (String)wrapperFrames.get(wrapperFrameIndex);\n+            if (causeFrame.equals(wrapperFrame)){\n+                causeFrames.remove(causeFrameIndex);\n+            }\n+            causeFrameIndex--;\n+            wrapperFrameIndex--;\n+        }\n+    }\n+    \n     /**\n      * A convenient way of extracting the stack trace from an\n      * exception.\n         }\n         return (String []) list.toArray(new String[] {});\n     }\n+    \n+    /**\n+     * Produces a List of stack frames - the message is not included.\n+     * This works in most cases - it will only fail if the exception message\n+     * contains a line that starts with:  \"   at\".\n+     * \n+     * @param t is any throwable\n+     * @return List of stack frames\n+     */\n+    static List getStackFrameList(Throwable t){\n+        String stackTrace = getStackTrace(t);\n+        String linebreak = SystemUtils.LINE_SEPARATOR;\n+        StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n+        List list = new LinkedList();\n+        boolean traceStarted = false;\n+        while (frames.hasMoreTokens())\n+        {\n+            String token = frames.nextToken(); \n+            // Determine if the line starts with <whitespace>at\n+            int at = token.indexOf(\"at\");\n+            if (at != -1 && token.substring(0, at).trim().length() == 0){\n+                traceStarted = true;\n+                list.add(token);\n+            }\n+            else if (traceStarted){\n+                break;\n+            }\n+        }\n+        return list;\n+    }\n }\n--- a/src/test/org/apache/commons/lang/exception/ExceptionUtilsTestCase.java\n+++ b/src/test/org/apache/commons/lang/exception/ExceptionUtilsTestCase.java\n  * <http://www.apache.org/>.\n  */\n \n+import java.io.PrintWriter;\n+\n import junit.framework.Test;\n-import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n /**\n \n     public void setUp()\n     {\n-        withoutCause = new ExceptionWithoutCause();\n+        withoutCause = createExceptionWithoutCause();\n         nested = new NestableException(withoutCause);\n         withCause = new ExceptionWithCause(nested);\n     }\n+    \n+    private Throwable createExceptionWithoutCause(){\n+        try {\n+            throw new ExceptionWithoutCause();\n+        }\n+        catch (Throwable t){\n+            return t;\n+        }\n+    }\n \n+    private Throwable createExceptionWithCause(){\n+        try {\n+            try {\n+                throw new ExceptionWithCause(createExceptionWithoutCause());\n+            }\n+            catch (Throwable t){\n+                throw new ExceptionWithCause(t);\n+            }\n+        }\n+        catch (Throwable t){\n+            return t;\n+        }\n+    } \n+    \n     public void testGetCause()\n     {\n         assertNull(ExceptionUtils.getCause(withoutCause));\n         assertEquals(ExceptionUtils.getThrowableCount(null), 0);\n     }\n \n+    public void testPrintThrowables()\n+    {\n+        Throwable withCause = createExceptionWithCause();\n+        ExceptionUtils.printRootCauseStackTrace(withCause, \n+            new PrintWriter(System.out));\n+        ExceptionUtils.printRootCauseStackTrace(withoutCause, \n+            System.out);\n+    }\n+    \n     /**\n      * Provides a method with a well known chained/nested exception\n      * name which matches the full signature (e.g. has a return value", "timestamp": 1040079929, "metainfo": ""}