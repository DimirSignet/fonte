{"sha": "7faee9ea028bed6733ad8d44f8bde9b4d86e4393", "log": "Add superclass behaviour to builder classes from Gary Gregory   ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n  *\n  * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n  * @author Stephen Colebourne\n+ * @author Gary Gregory\n  * @since 1.0\n- * @version $Id: CompareToBuilder.java,v 1.9 2002/12/25 22:00:31 scolebourne Exp $\n+ * @version $Id: CompareToBuilder.java,v 1.10 2003/01/19 17:35:21 scolebourne Exp $\n  */\n public class CompareToBuilder {\n     \n      * <p>Transient members will be not be tested, as they are likely derived\n      * fields, and not part of the value of the object.</p>\n      *\n-     * <p>Static fields will not be tested.</p>\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n      *\n      * @param lhs  <code>this</code> object\n      * @param rhs  the other object\n      *  from being compared to this Object.\n      */\n     public static int reflectionCompare(Object lhs, Object rhs) {\n-        return reflectionCompare(lhs, rhs, false);\n+        return reflectionCompare(lhs, rhs, false, null);\n     }\n \n     /**\n      * transient members will be tested, otherwise they are ignored, as they\n      * are likely derived fields, and not part of the value of the object.</p>\n      *\n-     * <p>Static fields will not be tested.</p>\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n      * \n      * @param lhs  <code>this</code> object\n      * @param rhs  the other object\n      *  from being compared to this Object.\n      */\n     public static int reflectionCompare(Object lhs, Object rhs, boolean testTransients) {\n+        return reflectionCompare(lhs, rhs, testTransients, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two Objects are\n+     * equal.</p>\n+     *\n+     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manger, if  the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the <code>testTransients</code> is set to <code>true</code>,\n+     * transient members will be tested, otherwise they are ignored, as they\n+     * are likely derived fields, and not part of the value of the object.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     * \n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be null\n+     * @return a negative integer, zero, or a positive integer as this \n+     *  Object is less than, equal to, or greater than the specified Object.\n+     * @throws NullPointerException  if either (but not both) parameter is\n+     *  <code>null</code>\n+     * @throws ClassCastException  if the specified Object's type prevents it\n+     *  from being compared to this Object.\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass) {\n         if (lhs == rhs) {\n             return 0;\n         }\n         if (!c1.isInstance(rhs)) {\n             throw new ClassCastException();\n         }\n-        Field[] fields = c1.getDeclaredFields();\n+        CompareToBuilder compareToBuilder = new CompareToBuilder();\n+        reflectionAppend(lhs, rhs, c1, compareToBuilder, testTransients);\n+        while (c1.getSuperclass() != null && c1 != reflectUpToClass) {\n+            c1 = c1.getSuperclass();\n+            reflectionAppend(lhs, rhs, c1, compareToBuilder, testTransients);\n+        }\n+        return compareToBuilder.toComparison();\n+    }\n+\n+    /**\n+     * Appends the fields and values defined by the given object of the\n+     * given Class.\n+     * \n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @param clazz  the class to append details of\n+     * @param builder  the builder to append to\n+     * @param useTransients  whether to test transient fields\n+     */\n+    private static void reflectionAppend(Object lhs, Object rhs, Class clazz, CompareToBuilder builder, boolean useTransients) {\n+        Field[] fields = clazz.getDeclaredFields();\n         Field.setAccessible(fields, true);\n-        CompareToBuilder compareToBuilder = new CompareToBuilder();\n-        for (int i = 0; i < fields.length && compareToBuilder.comparison == 0; ++i) {\n+        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n             Field f = fields[i];\n-            if (testTransients || !Modifier.isTransient(f.getModifiers())) {\n+            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n                 if (!Modifier.isStatic(f.getModifiers())) {\n                     try {\n-                        compareToBuilder.append(f.get(lhs), f.get(rhs));\n-                    } catch (IllegalAccessException ex) {\n+                        builder.append(f.get(lhs), f.get(rhs));\n+                    } catch (IllegalAccessException e) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         }\n-        return compareToBuilder.toComparison();\n     }\n \n     //-------------------------------------------------------------------------\n--- a/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n  *\n  * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n  * @author Stephen Colebourne\n+ * @author Gary Gregory\n  * @since 1.0\n- * @version $Id: EqualsBuilder.java,v 1.9 2003/01/15 20:54:00 bayard Exp $\n+ * @version $Id: EqualsBuilder.java,v 1.10 2003/01/19 17:35:21 scolebourne Exp $\n  */\n public class EqualsBuilder {\n     /**\n      * <p>Transient members will be not be tested, as they are likely derived\n      * fields, and not part of the value of the Object.</p>\n      *\n-     * <p>Static fields will not be tested.</p>\n-     *\n-     * @param lhs  Left Hand Side\n-     * @param rhs  Right Hand Side\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n     public static boolean reflectionEquals(Object lhs, Object rhs) {\n-        return reflectionEquals(lhs, rhs, false);\n+        return reflectionEquals(lhs, rhs, false, null);\n     }\n \n     /**\n      * members will be tested, otherwise they are ignored, as they are likely\n      * derived fields, and not part of the value of the Object.</p>\n      *\n-     * <p>Static fields will not be tested.</p>\n-     *\n-     * @param lhs  Left Hand Side\n-     * @param rhs  Right Hand Side\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n      * @param testTransients  whether to include transient fields\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n-    public static boolean reflectionEquals(Object lhs, Object rhs,\n-            boolean testTransients) {\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n+        return reflectionEquals(lhs, rhs, testTransients, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two Object are equal.</p>\n+     *\n+     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manger, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be null\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass) {\n         if (lhs == rhs) {\n             return true;\n         }\n         if (lhs == null || rhs == null) {\n             return false;\n         }\n-        Class c1 = lhs.getClass();\n-        if (!c1.isInstance(rhs)) {\n+        // Find the leaf class since there may be transients in the leaf \n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars, \n+        // then a subclass can test equals to a superclass.\n+        Class lhsClass = lhs.getClass();\n+        Class rhsClass = rhs.getClass();\n+        Class testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass = lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass = rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass = rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass = lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n             return false;\n         }\n-        Field[] fields = c1.getDeclaredFields();\n+        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        try {\n+            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients);\n+            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                testClass = testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and \n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            return false;\n+        }\n+        return equalsBuilder.isEquals();\n+    }\n+\n+    /**\n+     * Appends the fields and values defined by the given object of the\n+     * given Class.\n+     * \n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @param clazz  the class to append details of\n+     * @param builder  the builder to append to\n+     * @param useTransients  whether to test transient fields\n+     */\n+    private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n+        Field[] fields = clazz.getDeclaredFields();\n         Field.setAccessible(fields, true);\n-        EqualsBuilder equalsBuilder = new EqualsBuilder();\n-        for (int i = 0; i < fields.length && equalsBuilder.isEquals; ++i) {\n+        for (int i = 0; i < fields.length && builder.isEquals; i++) {\n             Field f = fields[i];\n-            if (testTransients || !Modifier.isTransient(f.getModifiers())) {\n+            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n                 if (!Modifier.isStatic(f.getModifiers())) {\n                     try {\n-                        equalsBuilder.append(f.get(lhs), f.get(rhs));\n+                        builder.append(f.get(lhs), f.get(rhs));\n                     } catch (IllegalAccessException e) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         }\n-        return equalsBuilder.isEquals();\n     }\n \n     //-------------------------------------------------------------------------\n--- a/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n  * </pre>\n  *\n  * @author Stephen Colebourne\n+ * @author Gary Gregory\n  * @since 1.0\n- * @version $Id: HashCodeBuilder.java,v 1.8 2003/01/15 20:51:57 bayard Exp $\n+ * @version $Id: HashCodeBuilder.java,v 1.9 2003/01/19 17:35:21 scolebourne Exp $\n  */\n public class HashCodeBuilder {\n \n      * <p>Transient members will be not be used, as they are likely derived\n      * fields, and not part of the value of the Object.</p>\n      *\n-     * <p>Static fields will not be tested.</p>\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n      *\n      * @param object  the Object to create a <code>hashCode</code> for\n      * @return int hash code\n      * @throws IllegalArgumentException if the object is <code>null</code>\n      */\n     public static int reflectionHashCode(Object object) {\n-        return reflectionHashCode(object, false);\n+        return reflectionHashCode(17, 37, object, false, null);\n     }\n \n     /**\n      * members will be tested, otherwise they are ignored, as they are likely\n      * derived fields, and not part of the value of the Object.</p>\n      *\n-     * <p>Static fields will not be tested.</p>\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n      *\n      * @param object  the Object to create a <code>hashCode</code> for\n      * @param testTransients  whether to include transient fields\n      * @throws IllegalArgumentException if the object is <code>null</code>\n      */\n     public static int reflectionHashCode(Object object, boolean testTransients) {\n-        return reflectionHashCode(17, 37, object, testTransients);\n+        return reflectionHashCode(17, 37, object, testTransients, null);\n     }\n \n     /**\n      * <p>Transient members will be not be used, as they are likely derived\n      * fields, and not part of the value of the Object.</p>\n      *\n-     * <p>Static fields will not be tested.</p>\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n      *\n      * <p>Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n      * these should be different for each class, however this is not vital.\n      * @throws IllegalArgumentException if the number is zero or even\n      */\n     public static int reflectionHashCode(\n-            int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n-            Object object) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false);\n+            int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\n     }\n \n     /**\n      * members will be tested, otherwise they are ignored, as they are likely\n      * derived fields, and not part of the value of the Object.</p>\n      *\n-     * <p>Static fields will not be tested.</p>\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n      *\n      * <p>Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n      * these should be different for each class, however this is not vital.\n     public static int reflectionHashCode(\n             int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n             Object object, boolean testTransients) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\n+    }\n+            \n+    /**\n+     * <p>This method uses reflection to build a valid hash code.</p>\n+     *\n+     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manger, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be included\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * <p>Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n+     * these should be different for each class, however this is not vital.\n+     * Prime numbers are preferred, especially for the multiplier.</p>\n+     *\n+     * @param initialNonZeroOddNumber\n+     * @param multiplierNonZeroOddNumber\n+     * @param object  the Object to create a <code>hashCode</code> for\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be null\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     * @throws IllegalArgumentException if the number is zero or even\n+     */\n+    public static int reflectionHashCode(\n+            int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n+            Object object, boolean testTransients, Class reflectUpToClass) {\n \n         if (object == null) {\n             throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n         }\n-        HashCodeBuilder hashCodeBuilder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n-        Field[] fields = object.getClass().getDeclaredFields();\n+        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n+        Class clazz = object.getClass();\n+        reflectionAppend(object, clazz, builder, testTransients);\n+        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n+            clazz = clazz.getSuperclass();\n+            reflectionAppend(object, clazz, builder, testTransients);\n+        }\n+        return builder.toHashCode();\n+    }\n+\n+    /**\n+     * Appends the fields and values defined by the given object of the\n+     * given Class.\n+     * \n+     * @param object  the object to append details of\n+     * @param clazz  the class to append details of\n+     * @param builder  the builder to append to\n+     * @param useTransients  whether to use transient fields\n+     */\n+    private static void reflectionAppend(Object object, Class clazz, HashCodeBuilder builder, boolean useTransients) {\n+        Field[] fields = clazz.getDeclaredFields();\n         Field.setAccessible(fields, true);\n-        for (int i = 0; i < fields.length; ++i) {\n+        for (int i = 0; i < fields.length; i++) {\n             Field f = fields[i];\n-            if (testTransients || !Modifier.isTransient(f.getModifiers())) {\n+            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n                 if (!Modifier.isStatic(f.getModifiers())) {\n                     try {\n-                        hashCodeBuilder.append(f.get(object));\n+                        builder.append(f.get(object));\n                     } catch (IllegalAccessException e) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         }\n-        return hashCodeBuilder.toHashCode();\n-    }\n+     }\n \n     //-------------------------------------------------------------------------\n \n--- a/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n  * @author Stephen Colebourne\n  * @author Gary Gregory\n  * @since 1.0\n- * @version $Id: ToStringBuilder.java,v 1.12 2002/12/31 20:21:34 scolebourne Exp $\n+ * @version $Id: ToStringBuilder.java,v 1.13 2003/01/19 17:35:21 scolebourne Exp $\n  */\n public class ToStringBuilder {\n     \n      * up to and including the specified superclass. A null superclass is treated\n      * as java.lang.Object.</p>\n      *\n-     * <p>\n-     * If the style is <code>null</code>, the default\n+     * <p>If the style is <code>null</code>, the default\n      * <code>ToStringStyle</code> is used.</p>\n      * \n      * @param object  the Object to be output\n      * @param object  the object to append details of\n      * @param clazz  the class to append details of\n      * @param builder  the builder to append to\n-     * @param outputTransients  whether to output transient fields\n-     */\n-    private static void reflectionAppend(Object object, Class clazz, ToStringBuilder builder, boolean outputTransients) {\n+     * @param useTransients  whether to output transient fields\n+     */\n+    private static void reflectionAppend(Object object, Class clazz, ToStringBuilder builder, boolean useTransients) {\n         Field[] fields = clazz.getDeclaredFields();\n         Field.setAccessible(fields, true);\n-        for (int i = 0; i < fields.length; ++i) {\n+        for (int i = 0; i < fields.length; i++) {\n             Field f = fields[i];\n-            if (outputTransients || !Modifier.isTransient(f.getModifiers())) {\n+            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n                 if (!Modifier.isStatic(f.getModifiers())) {\n                     try {\n                         builder.append(f.getName(), f.get(object));\n--- a/src/test/org/apache/commons/lang/builder/CompareToBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/CompareToBuilderTest.java\n  */\n package org.apache.commons.lang.builder;\n \n-import org.apache.commons.lang.builder.CompareToBuilder;\n+import java.math.BigInteger;\n \n import junit.framework.Test;\n import junit.framework.TestCase;\n  *\n  * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: CompareToBuilderTest.java,v 1.3 2002/12/08 21:43:34 scolebourne Exp $\n+ * @version $Id: CompareToBuilderTest.java,v 1.4 2003/01/19 17:35:20 scolebourne Exp $\n  */\n public class CompareToBuilderTest extends TestCase {\n \n \n     //-----------------------------------------------------------------------\n \n-    static class TestObject implements Comparable{\n+    static class TestObject implements Comparable {\n         private int a;\n         public TestObject(int a) {\n             this.a = a;\n \t\t\tTestObject rhs = (TestObject) o;\n \t\t\treturn (a < rhs.a) ? -1 : (a > rhs.a) ? +1 : 0;\n \t\t}\n+    }\n+\n+    static class TestSubObject extends TestObject {\n+        private int b;\n+        public TestSubObject() {\n+            super(0);\n+        }\n+        public TestSubObject(int a, int b) {\n+            super(a);\n+            this.b = b;\n+        }\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestSubObject)) {\n+                return false;\n+            }\n+            TestSubObject rhs = (TestSubObject) o;\n+            return super.equals(o) && (b == rhs.b);\n+        }\n+    }\n+\n+    static class TestTransientSubObject extends TestObject {\n+        private transient int t;\n+        public TestTransientSubObject(int a, int t) {\n+            super(a);\n+            this.t = t;\n+        }\n     }\n \n     public void testReflectionCompare() {\n         } catch (ClassCastException ex) {}\n     }\n \n+    public void testReflectionHierarchyCompare() {\n+        testReflectionHierarchyCompare(false);\n+    }\n+    \n+    public void testReflectionHierarchyCompareTransients() {\n+        testReflectionHierarchyCompare(true);\n+\n+        TestTransientSubObject x;\n+        TestTransientSubObject y;\n+        TestTransientSubObject z;\n+\n+        x = new TestTransientSubObject(1, 1);\n+        y = new TestTransientSubObject(2, 2);\n+        z = new TestTransientSubObject(3, 3);\n+        assertXYZCompareOrder(x, y, z, true);\n+        \n+        x = new TestTransientSubObject(1, 1);\n+        y = new TestTransientSubObject(1, 2);\n+        z = new TestTransientSubObject(1, 3);\n+        assertXYZCompareOrder(x, y, z, true);  \n+    }\n+    \n+    private void assertXYZCompareOrder(Object x, Object y, Object z, boolean testTransients) {\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(x, x, testTransients));\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(y, y, testTransients));\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(z, z, testTransients));\n+        \n+        assertTrue(0 > CompareToBuilder.reflectionCompare(x, y, testTransients));\n+        assertTrue(0 > CompareToBuilder.reflectionCompare(x, z, testTransients));\n+        assertTrue(0 > CompareToBuilder.reflectionCompare(y, z, testTransients));\n+        \n+        assertTrue(0 < CompareToBuilder.reflectionCompare(y, x, testTransients));\n+        assertTrue(0 < CompareToBuilder.reflectionCompare(z, x, testTransients));\n+        assertTrue(0 < CompareToBuilder.reflectionCompare(z, y, testTransients));\n+    }\n+    \n+    public void testReflectionHierarchyCompare(boolean testTransients) {\n+        TestObject to1 = new TestObject(1);\n+        TestObject to2 = new TestObject(2);\n+        TestObject to3 = new TestObject(3);\n+        TestSubObject tso1 = new TestSubObject(1, 1);\n+        TestSubObject tso2 = new TestSubObject(2, 2);\n+        TestSubObject tso3 = new TestSubObject(3, 3);\n+        \n+        assertReflectionCompareContract(to1, to1, to1, false);\n+        assertReflectionCompareContract(to1, to2, to3, false);\n+        assertReflectionCompareContract(tso1, tso1, tso1, false);\n+        assertReflectionCompareContract(tso1, tso2, tso3, false);\n+        assertReflectionCompareContract(\"1\", \"2\", \"3\", false);\n+        \n+        assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(1, 0), testTransients));\n+        assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(0, 1), testTransients));\n+\n+        // root class\n+        assertXYZCompareOrder(to1, to2, to3, true);\n+        // subclass  \n+        assertXYZCompareOrder(tso1, tso2, tso3, true);  \n+    }\n+\n+    /**\n+     * See \"Effective Java\" under \"Consider Implementing Comparable\".\n+     *  \n+     * @param x an object to compare \n+     * @param y an object to compare\n+     * @param z an object to compare\n+     * @param testTransients Whether to include transients in the comparison\n+     */\n+    public void assertReflectionCompareContract(Object x, Object y, Object z, boolean testTransients) {\n+\n+        // signum\n+        assertTrue(reflectionCompareSignum(x, y, testTransients) == -reflectionCompareSignum(y, x, testTransients));\n+        \n+        // transitive\n+        if (CompareToBuilder.reflectionCompare(x, y, testTransients) > 0 && CompareToBuilder.reflectionCompare(y, z, testTransients) > 0){\n+            assertTrue(CompareToBuilder.reflectionCompare(x, z, testTransients) > 0);\n+        }\n+        \n+        // un-named\n+        if (CompareToBuilder.reflectionCompare(x, y, testTransients) == 0) {\n+            assertTrue(reflectionCompareSignum(x, z, testTransients) == -reflectionCompareSignum(y, z, testTransients));\n+        }\n+        \n+        // strongly recommended but not strictly required\n+        assertTrue((CompareToBuilder.reflectionCompare(x, y, testTransients) ==0 ) == EqualsBuilder.reflectionEquals(x, y, testTransients));\n+    }\n+    \n+    /**\n+     * Returns the signum of the result of comparing x and y with\n+     * <code>CompareToBuilder.reflectionCompare</code>\n+     * \n+     * @param lhs The \"left-hand-side\" of the comparison.\n+     * @param rhs The \"right-hand-side\" of the comparison.\n+     * @param testTransients Whether to include transients in the comparison\n+     * @return int The signum\n+     */\n+    private int reflectionCompareSignum(Object lhs, Object rhs, boolean testTransients) {\n+        return BigInteger.valueOf(CompareToBuilder.reflectionCompare(lhs, rhs, testTransients)).signum();\n+    }\n+    \n     public void testAppendSuper() {\n         TestObject o1 = new TestObject(4);\n         TestObject o2 = new TestObject(5);\n--- a/src/test/org/apache/commons/lang/builder/EqualsBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/EqualsBuilderTest.java\n  *\n  * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: EqualsBuilderTest.java,v 1.2 2002/12/08 21:10:11 scolebourne Exp $\n+ * @version $Id: EqualsBuilderTest.java,v 1.3 2003/01/19 17:35:20 scolebourne Exp $\n  */\n public class EqualsBuilderTest extends TestCase {\n \n \n     static class TestObject {\n         private int a;\n+        public TestObject() {\n+        }\n         public TestObject(int a) {\n             this.a = a;\n         }\n \n         public int getA() {\n             return a;\n+        }\n+    }\n+\n+    static class TestSubObject extends TestObject {\n+        private int b;\n+        public TestSubObject() {\n+            super(0);\n+        }\n+        public TestSubObject(int a, int b) {\n+            super(a);\n+            this.b = b;\n+        }\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestSubObject)) {\n+                return false;\n+            }\n+            TestSubObject rhs = (TestSubObject) o;\n+            return super.equals(o) && (b == rhs.b);\n+        }\n+\n+        public void setB(int b) {\n+            this.b = b;\n+        }\n+\n+        public int getB() {\n+            return b;\n+        }\n+    }\n+\n+    static class TestEmptySubObject extends TestObject {\n+        public TestEmptySubObject(int a) {\n+            super(a);\n+        }\n+    }\n+\n+    static class TestTSubObject extends TestObject {\n+        private transient int t;\n+        public TestTSubObject(int a, int t) {\n+            super(a);\n+            this.t = t;\n+        }\n+    }\n+\n+    static class TestTTSubObject extends TestTSubObject {\n+        private transient int tt;\n+        public TestTTSubObject(int a, int t, int tt) {\n+            super(a, t);\n+            this.tt = tt;\n+        }\n+    }\n+\n+    static class TestTTLeafObject extends TestTTSubObject {\n+        private int leafValue;\n+        public TestTTLeafObject(int a, int t, int tt, int leafValue) {\n+            super(a, t, tt);\n+            this.leafValue = leafValue;\n+        }\n+    }\n+\n+    static class TestTSubObject2 extends TestObject {\n+        private transient int t;\n+        public TestTSubObject2(int a, int t) {\n+            super(a);\n+        }\n+        public int getT() {\n+            return t;\n+        }\n+        public void setT(int t) {\n+            this.t = t;\n         }\n     }\n \n         assertTrue(EqualsBuilder.reflectionEquals(o1, o2));\n \n         assertTrue(!EqualsBuilder.reflectionEquals(o1, this));\n-        \n+\n         assertTrue(!EqualsBuilder.reflectionEquals(o1, null));\n         assertTrue(!EqualsBuilder.reflectionEquals(null, o2));\n         assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null));\n+    }\n+    \n+    public void testReflectionHierarchyEquals() {\n+        testReflectionHierarchyEquals(false);\n+        testReflectionHierarchyEquals(true);\n+        // Transients\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), false));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 0, 0, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 0), true));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(0, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+    }\n+\n+    public void testReflectionHierarchyEquals(boolean testTransients) {\n+        TestObject to1 = new TestObject(4);\n+        TestObject to1Bis = new TestObject(4);\n+        TestObject to1Ter = new TestObject(4);\n+        TestObject to2 = new TestObject(5);\n+        TestEmptySubObject teso = new TestEmptySubObject(4);\n+        TestTSubObject ttso = new TestTSubObject(4, 1);\n+        TestTTSubObject tttso = new TestTTSubObject(4, 1, 2);\n+        TestTTLeafObject ttlo = new TestTTLeafObject(4, 1, 2, 3);\n+        TestSubObject tso1 = new TestSubObject(1, 4);\n+        TestSubObject tso1bis = new TestSubObject(1, 4);\n+        TestSubObject tso1ter = new TestSubObject(1, 4);\n+        TestSubObject tso2 = new TestSubObject(2, 5);\n+\n+        testReflectionEqualsEquivalenceRelationship(to1, to1Bis, to1Ter, to2, new TestObject(), testTransients);\n+        testReflectionEqualsEquivalenceRelationship(tso1, tso1bis, tso1ter, tso2, new TestSubObject(), testTransients);\n+\n+        // More sanity checks:\n+\n+        // same values\n+        assertTrue(EqualsBuilder.reflectionEquals(ttlo, ttlo, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 10), testTransients));\n+        // same super values, diff sub values\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 11), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 11), new TestSubObject(1, 10), testTransients));\n+        // diff super values, same sub values\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestSubObject(1, 10), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(0, 10), testTransients));\n+\n+        // mix super and sub types: equals\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, teso, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(teso, to1, testTransients));\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, ttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(ttso, to1, false)); // Force testTransients = false for this assert\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, tttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(tttso, to1, false)); // Force testTransients = false for this assert\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(ttso, tttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(tttso, ttso, false)); // Force testTransients = false for this assert\n+\n+        // mix super and sub types: NOT equals\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestEmptySubObject(1), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestEmptySubObject(1), new TestObject(0), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestTSubObject(1, 1), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTSubObject(1, 1), new TestObject(0), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(1), new TestSubObject(0, 10), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestObject(1), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(to1, ttlo));\n+        assertTrue(!EqualsBuilder.reflectionEquals(tso1, this));\n+    }\n+\n+    /**\n+     * Equivalence relationship tests inspired by \"Effective Java\":\n+     * <ul>\n+     * <li>reflection</li>\n+     * <li>symetry</li>\n+     * <li>transitive</li>\n+     * <li>consistency</li>\n+     * <li>non-null reference</li>\n+     * </ul>\n+     * @param to a TestObject\n+     * @param toBis a TestObject, equal to to and toTer\n+     * @param toTer Left hand side, equal to to and toBis\n+     * @param to2 a different TestObject\n+     * @param oToChange a TestObject that will be changed\n+     */\n+    public void testReflectionEqualsEquivalenceRelationship(\n+        TestObject to,\n+        TestObject toBis,\n+        TestObject toTer,\n+        TestObject to2,\n+        TestObject oToChange,\n+        boolean testTransients) {\n+\n+        // reflection test\n+        assertTrue(EqualsBuilder.reflectionEquals(to, to, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(to2, to2, testTransients));\n+\n+        // symetry test\n+        assertTrue(EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, to, testTransients));\n+\n+        // transitive test\n+        assertTrue(\n+            EqualsBuilder.reflectionEquals(to, toBis, testTransients)\n+                && EqualsBuilder.reflectionEquals(toBis, toTer, testTransients)\n+                && EqualsBuilder.reflectionEquals(to, toTer, testTransients));\n+\n+        // consistency test\n+        oToChange.setA(to.getA());\n+        if (oToChange instanceof TestSubObject) {\n+            ((TestSubObject) oToChange).setB(((TestSubObject) to).getB());\n+        }\n+        assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        oToChange.setA(to.getA() + 1);\n+        if (oToChange instanceof TestSubObject) {\n+            ((TestSubObject) oToChange).setB(((TestSubObject) to).getB() + 1);\n+        }\n+        assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+\n+        // non-null reference test\n+        assertTrue(!EqualsBuilder.reflectionEquals(to, null, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(to2, null, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(null, to, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(null, to2, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null, testTransients));\n     }\n \n     public void testSuper() {\n--- a/src/test/org/apache/commons/lang/builder/HashCodeBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/HashCodeBuilderTest.java\n  * Unit tests {@link org.apache.commons.lang.HashCodeBuilder}.\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: HashCodeBuilderTest.java,v 1.2 2002/12/08 21:22:42 scolebourne Exp $\n+ * @version $Id: HashCodeBuilderTest.java,v 1.3 2003/01/19 17:35:20 scolebourne Exp $\n  */\n public class HashCodeBuilderTest extends TestCase {\n \n         }\n     }\n \n+    static class TestSubObject extends TestObject {\n+        private int b;\n+        transient private int t;\n+        public TestSubObject() {\n+            super(0);\n+        }\n+        public TestSubObject(int a, int b, int t) {\n+            super(a);\n+            this.b = b;\n+            this.t = t;\n+        }\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestSubObject)) {\n+                return false;\n+            }\n+            TestSubObject rhs = (TestSubObject) o;\n+            return super.equals(o) && (b == rhs.b);\n+        }\n+    }\n+\n     public void testReflectionHashCode() {\n         assertEquals(17 * 37, HashCodeBuilder.reflectionHashCode(new TestObject(0)));\n         assertEquals(17 * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestObject(123456)));\n+    }\n+\n+    public void testReflectionHierarchyHashCode() {\n+        assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0)));\n+        assertEquals(17 * 37 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0), true));\n+        assertEquals((17 * 37 + 7890) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890, 0)));\n+        assertEquals(((17 * 37 + 7890) * 37 + 0) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890, 0), true));\n+    }\n+\n+    public void testReflectionHierarchyHashCodeEx1() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(0, 0, new TestSubObject(0, 0, 0), true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testReflectionHierarchyHashCodeEx2() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(2, 2, new TestSubObject(0, 0, 0), true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n     }\n \n     public void testReflectionHashCodeEx1() {", "timestamp": 1042997721, "metainfo": ""}