{"sha": "dd62731413715544de51f2021616369145eb8d54", "log": "Javadoc improvements. Finish renaming of Command to Executor.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/functor/ExecutorUtils.java\n+++ b/src/java/org/apache/commons/lang/functor/ExecutorUtils.java\n import org.apache.commons.lang.functor.TransformerUtils;\n /**\n  * <code>ExecutorUtils</code> provides reference implementations and utilities\n- * for the Executor pattern interface. The supplied commands are:\n+ * for the Executor functor interface. The supplied executors are:\n  * <ul>\n  * <li>Invoker - invokes a method on the input object\n- * <li>For - repeatedly calls a command for a fixed number of times\n- * <li>While - repeatedly calls a command while a predicate is true\n- * <li>DoWhile - repeatedly calls a command while a predicate is true\n- * <li>Chained - chains two or more commands together\n- * <li>Switch - calls one command based on one or more predicates\n- * <li>SwitchMap - calls one command looked up from a Map\n- * <li>Transformer - wraps a Transformer as a Predicate\n+ * <li>For - repeatedly calls an executor for a fixed number of times\n+ * <li>While - repeatedly calls an executor while a predicate is true\n+ * <li>DoWhile - repeatedly calls an executor while a predicate is true\n+ * <li>Chained - chains two or more executors together\n+ * <li>Switch - calls one executor based on one or more predicates\n+ * <li>SwitchMap - calls one executor looked up from a Map\n+ * <li>Transformer - wraps a Transformer as an Executor\n  * <li>NOP - does nothing\n  * <li>Exception - always throws an exception\n  * </ul>\n- * All the supplied commands are Serializable.\n+ * All the supplied executors are Serializable.\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: ExecutorUtils.java,v 1.1 2002/11/06 19:15:40 bayard Exp $\n+ * @version $Id: ExecutorUtils.java,v 1.2 2002/11/14 21:54:49 scolebourne Exp $\n  */\n public class ExecutorUtils {\n \n     /**\n      * A Executor that always throws an exception\n      */\n-    private static final Executor EXCEPTION_COMMAND = new ExceptionExecutor();\n+    private static final Executor EXCEPTION_EXECUTOR = new ExceptionExecutor();\n     /**\n      * A Executor that does nothing\n      */\n-    private static final Executor NOP_COMMAND = new NOPExecutor();\n+    private static final Executor NOP_EXECUTOR = new NOPExecutor();\n \n     /**\n      * Restrictive constructor\n      * Gets a Executor that always throws an exception.\n      * This could be useful during testing as a placeholder.\n      *\n-     * @return the command\n+     * @return the executor\n      */\n     public static Executor exceptionExecutor() {\n-        return EXCEPTION_COMMAND;\n+        return EXCEPTION_EXECUTOR;\n     }\n \n     /**\n      * Gets a Executor that will do nothing.\n      * This could be useful during testing as a placeholder.\n      *\n-     * @return the command\n+     * @return the executor\n      */\n     public static Executor nopExecutor() {\n-        return NOP_COMMAND;\n-    }\n-\n-    /**\n-     * Creates a Executor that calls a Factory each time the transformer is used.\n-     * The transformer will return the value returned by the factory.\n+        return NOP_EXECUTOR;\n+    }\n+\n+    /**\n+     * Creates a Executor that calls a Transformer each time it is called.\n+     * The transformer will be called using the executor's input object.\n+     * The transformer's result will be ignored.\n      *\n-     * @param transformer  the transformer to run each time in the command\n-     * @return the command.\n+     * @param transformer  the transformer to run each time in the executor\n+     * @return the executor.\n      */\n     public static Executor asExecutor(Transformer transformer) {\n         if (transformer == null) {\n-            throw new IllegalArgumentException(\"TransformerExecutor: The transformer must not be null\");\n+            throw new IllegalArgumentException(\"The transformer must not be null\");\n         }\n         return new TransformerExecutor(transformer);\n     }\n \n     /**\n-     * Creates a Executor that will call the command <code>count</code> times.\n+     * Creates a Executor that will call the executor <code>count</code> times.\n      *\n      * @param count  the number of times to loop\n-     * @param command  the command to call repeatedly\n-     * @return the command\n+     * @param executor  the executor to call repeatedly\n+     * @return the <code>for</code> executor\n      * @throws IllegalArgumentException if either argument is null\n      */\n-    public static Executor forExecutor(int count, Executor command) {\n+    public static Executor forExecutor(int count, Executor executor) {\n         if (count < 0) {\n-            throw new IllegalArgumentException(\"ForExecutor: The loop count must not be less than zero, it was \" + count);\n-        }\n-        if (command == null) {\n-            throw new IllegalArgumentException(\"ForExecutor: The command must not be null\");\n-        }\n-        return new ForExecutor(count, command);\n-    }\n-\n-    /**\n-     * Creates a Executor that will call the command repeatedly until the \n+            throw new IllegalArgumentException(\"The loop count must not be less than zero, it was \" + count);\n+        }\n+        if (executor == null) {\n+            throw new IllegalArgumentException(\"The executor must not be null\");\n+        }\n+        return new ForExecutor(count, executor);\n+    }\n+\n+    /**\n+     * Creates a Executor that will call the executor repeatedly until the \n      * predicate returns false.\n      *\n      * @param predicate  the predicate to use as an end of loop test\n-     * @param command  the command to call repeatedly\n-     * @return the command\n+     * @param executor  the executor to call repeatedly\n+     * @return the <code>while</code> executor\n      * @throws IllegalArgumentException if either argument is null\n      */\n-    public static Executor whileExecutor(Predicate predicate, Executor command) {\n+    public static Executor whileExecutor(Predicate predicate, Executor executor) {\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"WhileExecutor: The predicate must not be null\");\n-        }\n-        if (command == null) {\n-            throw new IllegalArgumentException(\"WhileExecutor: The command must not be null\");\n-        }\n-        return new WhileExecutor(predicate, command, false);\n-    }\n-\n-    /**\n-     * Creates a Executor that will call the command once and then repeatedly\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        if (executor == null) {\n+            throw new IllegalArgumentException(\"The executor must not be null\");\n+        }\n+        return new WhileExecutor(predicate, executor, false);\n+    }\n+\n+    /**\n+     * Creates a Executor that will call the executor once and then repeatedly\n      * until the predicate returns false.\n      *\n-     * @param command  the command to call repeatedly\n+     * @param executor  the executor to call repeatedly\n      * @param predicate  the predicate to use as an end of loop test\n-     * @return the command\n+     * @return the <code>do-while</code> executor\n      * @throws IllegalArgumentException if either argument is null\n      */\n-    public static Executor doWhileExecutor(Executor command, Predicate predicate) {\n-        if (command == null) {\n-            throw new IllegalArgumentException(\"DoWhileExecutor: The command must not be null\");\n+    public static Executor doWhileExecutor(Executor executor, Predicate predicate) {\n+        if (executor == null) {\n+            throw new IllegalArgumentException(\"The executor must not be null\");\n         }\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"DoWhileExecutor: The predicate must not be null\");\n-        }\n-        return new WhileExecutor(predicate, command, true);\n-    }\n-\n-    /**\n-     * Creates a Executor that will invoke a specific method on the command's\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        return new WhileExecutor(predicate, executor, true);\n+    }\n+\n+    /**\n+     * Creates a Executor that will invoke a specific method on the executor's\n      * input object by reflection.\n      *\n      * @param methodName  the name of the method\n-     * @return the command\n+     * @return the <code>invoker</code> executor\n      * @throws IllegalArgumentException if the method name is null\n      */\n     public static Executor invokerExecutor(String methodName) {\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n         return asExecutor(TransformerUtils.invokerTransformer(methodName, null, null));\n     }\n \n     /**\n-     * Creates a Executor that will invoke a specific method on the command's\n+     * Creates a Executor that will invoke a specific method on the executor's\n      * input object by reflection.\n      *\n      * @param methodName  the name of the method\n      * @param paramTypes  the parameter types\n      * @param args  the arguments\n-     * @return the command\n+     * @return the <code>invoker</code> executor\n      * @throws IllegalArgumentException if the method name is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n     public static Executor invokerExecutor(String methodName, Class[] paramTypes, Object[] args) {\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n         return asExecutor(TransformerUtils.invokerTransformer(methodName, paramTypes, args));\n     }\n \n      * Create a new Executor that calls two Executors, passing the result of\n      * the first into the second.\n      * \n-     * @param command1  the first command\n-     * @param command2  the second command\n-     * @return the command\n-     * @throws IllegalArgumentException if either command is null\n-     */\n-    public static Executor chainedExecutor(Executor command1, Executor command2) {\n-        Executor[] commands = new Executor[] { command1, command2 };\n-        validate(commands);\n-        return new ChainedExecutor(commands);\n-    }\n-\n-    /**\n-     * Create a new Executor that calls each command in turn, passing the \n-     * result into the next command.\n-     * \n-     * @param commands  an array of commands to chain\n-     * @return the command\n-     * @throws IllegalArgumentException if the commands array is null\n-     * @throws IllegalArgumentException if the commands array has 0 elements\n-     * @throws IllegalArgumentException if any command in the array is null\n-     */\n-    public static Executor chainedExecutor(Executor[] commands) {\n-        commands = copy(commands);\n-        validate(commands);\n-        return new ChainedExecutor(commands);\n-    }\n-\n-    /**\n-     * Create a new Executor that calls each command in turn, passing the \n-     * result into the next command. The ordering is that of the iterator()\n+     * @param executor1  the first executor\n+     * @param executor2  the second executor\n+     * @return the <code>chained</code> executor\n+     * @throws IllegalArgumentException if either executor is null\n+     */\n+    public static Executor chainedExecutor(Executor executor1, Executor executor2) {\n+        Executor[] executors = new Executor[] { executor1, executor2 };\n+        validate(executors);\n+        return new ChainedExecutor(executors);\n+    }\n+\n+    /**\n+     * Create a new Executor that calls each executor in turn, passing the \n+     * result into the next executor.\n+     * \n+     * @param executors  an array of executors to chain\n+     * @return the <code>chained</code> executor\n+     * @throws IllegalArgumentException if the executors array is null\n+     * @throws IllegalArgumentException if the executors array has 0 elements\n+     * @throws IllegalArgumentException if any executor in the array is null\n+     */\n+    public static Executor chainedExecutor(Executor[] executors) {\n+        executors = copy(executors);\n+        validate(executors);\n+        return new ChainedExecutor(executors);\n+    }\n+\n+    /**\n+     * Create a new Executor that calls each executor in turn, passing the \n+     * result into the next executor. The ordering is that of the iterator()\n      * method on the collection.\n      * \n-     * @param commands  a collection of commands to chain\n-     * @return the command\n-     * @throws IllegalArgumentException if the commands collection is null\n-     * @throws IllegalArgumentException if the commands collection is empty\n-     * @throws IllegalArgumentException if any command in the collection is null\n-     */\n-    public static Executor chainedExecutor(Collection commands) {\n-        if (commands == null) {\n-            throw new IllegalArgumentException(\"ChainedExecutor: The command collection must not be null\");\n+     * @param executors  a collection of executors to chain\n+     * @return the <code>chained</code> executor\n+     * @throws IllegalArgumentException if the executors collection is null\n+     * @throws IllegalArgumentException if the executors collection is empty\n+     * @throws IllegalArgumentException if any executor in the collection is null\n+     */\n+    public static Executor chainedExecutor(Collection executors) {\n+        if (executors == null) {\n+            throw new IllegalArgumentException(\"The executor collection must not be null\");\n         }\n         // convert to array like this to guarantee iterator() ordering\n-        Executor[] cmds = new Executor[commands.size()];\n+        Executor[] cmds = new Executor[executors.size()];\n         int i = 0;\n-        for (Iterator it = commands.iterator(); it.hasNext();) {\n+        for (Iterator it = executors.iterator(); it.hasNext();) {\n             cmds[i++] = (Executor) it.next();\n         }\n         validate(cmds);\n     }\n \n     /**\n-     * Create a new Executor that calls one of two commands depending \n+     * Create a new Executor that calls one of two executors depending \n      * on the specified predicate.\n      * \n      * @param predicate  the predicate to switch on\n-     * @param trueExecutor  the command called if the predicate is true\n-     * @param falseExecutor  the command called if the predicate is false\n-     * @return the command\n+     * @param trueExecutor  the executor called if the predicate is true\n+     * @param falseExecutor  the executor called if the predicate is false\n+     * @return the <code>switch</code> executor\n      * @throws IllegalArgumentException if the predicate is null\n-     * @throws IllegalArgumentException if either command is null\n+     * @throws IllegalArgumentException if either executor is null\n      */\n     public static Executor switchExecutor(Predicate predicate, Executor trueExecutor, Executor falseExecutor) {\n         return switchExecutorInternal(new Predicate[] { predicate }, new Executor[] { trueExecutor }, falseExecutor);\n     }\n \n     /**\n-     * Create a new Executor that calls one of the commands depending \n-     * on the predicates. The command at array location 0 is called if the\n-     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * Create a new Executor that calls one of the executors depending \n+     * on the predicates.\n+     * <p>\n+     * The executor at array location 0 is called if the predicate at array \n+     * location 0 returned true. Each predicate is evaluated\n      * until one returns true.\n      * \n      * @param predicates  an array of predicates to check\n-     * @param commands  an array of commands to call\n-     * @return the command\n+     * @param executors  an array of executors to call\n+     * @return the <code>switch</code> executor\n      * @throws IllegalArgumentException if the either array is null\n      * @throws IllegalArgumentException if the either array has 0 elements\n      * @throws IllegalArgumentException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n-    public static Executor switchExecutor(Predicate[] predicates, Executor[] commands) {\n-        return switchExecutorInternal(copy(predicates), copy(commands), null);\n-    }\n-\n-    /**\n-     * Create a new Executor that calls one of the commands depending \n-     * on the predicates. The command at array location 0 is called if the\n-     * predicate at array location 0 returned true. Each predicate is evaluated\n+    public static Executor switchExecutor(Predicate[] predicates, Executor[] executors) {\n+        return switchExecutorInternal(copy(predicates), copy(executors), null);\n+    }\n+\n+    /**\n+     * Create a new Executor that calls one of the executors depending \n+     * on the predicates.\n+     * <p>\n+     * The executor at array location 0 is called if the predicate at array\n+     * location 0 returned true. Each predicate is evaluated\n      * until one returns true. If no predicates evaluate to true, the default\n-     * command is called.\n+     * executor is called.\n      * \n      * @param predicates  an array of predicates to check\n-     * @param commands  an array of commands to call\n+     * @param executors  an array of executors to call\n      * @param defaultExecutor  the default to call if no predicate matches\n-     * @return the command\n+     * @return the <code>switch</code> executor\n      * @throws IllegalArgumentException if the either array is null\n      * @throws IllegalArgumentException if the either array has 0 elements\n      * @throws IllegalArgumentException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n-    public static Executor switchExecutor(Predicate[] predicates, Executor[] commands, Executor defaultExecutor) {\n-        return switchExecutorInternal(copy(predicates), copy(commands), defaultExecutor);\n+    public static Executor switchExecutor(Predicate[] predicates, Executor[] executors, Executor defaultExecutor) {\n+        return switchExecutorInternal(copy(predicates), copy(executors), defaultExecutor);\n     }\n     \n     /**\n-     * Create a new Executor that calls one of the commands depending \n+     * Create a new Executor that calls one of the executors depending \n      * on the predicates. \n      * <p>\n-     * The Map consists of Predicate keys and Executor values. A command \n+     * The Map consists of Predicate keys and Executor values. A executor \n      * is called if its matching predicate returns true. Each predicate is evaluated\n      * until one returns true. If no predicates evaluate to true, the default\n-     * command is called. The default command is set in the map with a \n+     * executor is called. The default executor is set in the map with a \n      * null key. The ordering is that of the iterator() method on the entryset \n      * collection of the map.\n      * \n-     * @param predicatesAndExecutors  a map of predicates to commands\n-     * @return the command\n+     * @param predicatesAndExecutors  a map of predicates to executors\n+     * @return the <code>switch</code> executor\n      * @throws IllegalArgumentException if the map is null\n      * @throws IllegalArgumentException if the map is empty\n-     * @throws IllegalArgumentException if any command in the map is null\n+     * @throws IllegalArgumentException if any executor in the map is null\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n     public static Executor switchExecutor(Map predicatesAndExecutors) {\n         Executor[] trs = null;\n         Predicate[] preds = null;\n         if (predicatesAndExecutors == null) {\n-            throw new IllegalArgumentException(\"SwitchExecutor: The predicate and command map must not be null\");\n+            throw new IllegalArgumentException(\"The predicate and executor map must not be null\");\n         }\n         // convert to array like this to guarantee iterator() ordering\n         Executor def = (Executor) predicatesAndExecutors.remove(null);\n     }\n \n     /**\n-     * Validate input and create command\n-     */\n-    private static Executor switchExecutorInternal(Predicate[] predicates, Executor[] commands, Executor defaultExecutor) {\n+     * Validate input and create executor.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param executors  an array of executors to call\n+     * @param defaultExecutor  the default to call if no predicate matches\n+     * @return the <code>switch</code> executor\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    private static Executor switchExecutorInternal(Predicate[] predicates, Executor[] executors, Executor defaultExecutor) {\n         validate(predicates);\n-        validate(commands);\n-        if (predicates.length != commands.length) {\n-            throw new IllegalArgumentException(\"SwitchExecutor: The predicate and command arrays must be the same size\");\n+        validate(executors);\n+        if (predicates.length != executors.length) {\n+            throw new IllegalArgumentException(\"The predicate and executor arrays must be the same size\");\n         }\n         if (defaultExecutor == null) {\n             defaultExecutor = nopExecutor();\n         }\n-        return new SwitchExecutor(predicates, commands, defaultExecutor);\n+        return new SwitchExecutor(predicates, executors, defaultExecutor);\n     }\n \n     /**\n      * Create a new Executor that uses the input object as a key to find the\n-     * command to call. \n+     * executor to call. \n      * <p>\n-     * The Map consists of object keys and Executor values. A command \n+     * The Map consists of object keys and Executor values. A executor \n      * is called if the input object equals the key. If there is no match, the\n-     * default command is called. The default command is set in the map\n+     * default executor is called. The default executor is set in the map\n      * using a null key.\n      * \n-     * @param objectsAndExecutors  a map of objects to commands\n-     * @return the command\n+     * @param objectsAndExecutors  a map of objects to executors\n+     * @return the executor\n      * @throws IllegalArgumentException if the map is null\n      * @throws IllegalArgumentException if the map is empty\n-     * @throws IllegalArgumentException if any command in the map is null\n+     * @throws IllegalArgumentException if any executor in the map is null\n      */\n     public static Executor switchMapExecutor(Map objectsAndExecutors) {\n         Executor[] trs = null;\n         Predicate[] preds = null;\n         if (objectsAndExecutors == null) {\n-            throw new IllegalArgumentException(\"SwitchEqualsExecutor: The obejct and command map must not be null\");\n+            throw new IllegalArgumentException(\"The obejct and executor map must not be null\");\n         }\n         Executor def = (Executor) objectsAndExecutors.remove(null);\n         int size = objectsAndExecutors.size();\n     }\n \n     /**\n-     * Copy method\n+     * Clone the predicates to ensure that the internal reference can't be messed with.\n      * \n      * @param predicates  the predicates to copy\n+     * @return the cloned predicates\n      */\n     private static Predicate[] copy(Predicate[] predicates) {\n         if (predicates == null) {\n     }\n     \n     /**\n-     * Validate method\n+     * Validate the predicates to ensure that all is well.\n      * \n      * @param predicates  the predicates to validate\n+     * @return the validated predicates\n      */\n     private static void validate(Predicate[] predicates) {\n         if (predicates == null) {\n-            throw new IllegalArgumentException(\"ExecutorUtils: The predicate array must not be null\");\n+            throw new IllegalArgumentException(\"The predicate array must not be null\");\n         }\n         if (predicates.length < 1) {\n             throw new IllegalArgumentException(\n-                \"ExecutorUtils: At least 1 predicate must be specified in the predicate array, size was \" + predicates.length);\n+                \"At least 1 predicate must be specified in the predicate array, size was \" + predicates.length);\n         }\n         for (int i = 0; i < predicates.length; i++) {\n             if (predicates[i] == null) {\n-                throw new IllegalArgumentException(\"ExecutorUtils: The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+                throw new IllegalArgumentException(\"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n             }\n         }\n     }\n \n     /**\n-     * Copy method\n-     * \n-     * @param commands  the commands to copy\n-     */\n-    private static Executor[] copy(Executor[] commands) {\n-        if (commands == null) {\n+     * Clone the executors to ensure that the internal reference can't be messed with.\n+     * \n+     * @param executors  the executors to copy\n+     * @return the cloned executors\n+     */\n+    private static Executor[] copy(Executor[] executors) {\n+        if (executors == null) {\n             return null;\n         }\n-        return (Executor[]) commands.clone();\n+        return (Executor[]) executors.clone();\n     }\n     \n     /**\n-     * Validate method\n-     * \n-     * @param commands  the commands to validate\n-     */\n-    private static void validate(Executor[] commands) {\n-        if (commands == null) {\n-            throw new IllegalArgumentException(\"ExecutorUtils: The command array must not be null\");\n-        }\n-        if (commands.length < 1) {\n+     * Validate the executors to ensure that all is well.\n+     * \n+     * @param executors  the executors to validate\n+     * @return the validated executors\n+     */\n+    private static void validate(Executor[] executors) {\n+        if (executors == null) {\n+            throw new IllegalArgumentException(\"The executor array must not be null\");\n+        }\n+        if (executors.length < 1) {\n             throw new IllegalArgumentException(\n-                \"ExecutorUtils: At least 1 command must be specified in the command array, size was \" + commands.length);\n-        }\n-        for (int i = 0; i < commands.length; i++) {\n-            if (commands[i] == null) {\n-                throw new IllegalArgumentException(\"ExecutorUtils: The command array must not contain a null command, index \" + i + \" was null\");\n+                \"At least 1 executor must be specified in the executor array, size was \" + executors.length);\n+        }\n+        for (int i = 0; i < executors.length; i++) {\n+            if (executors[i] == null) {\n+                throw new IllegalArgumentException(\"The executor array must not contain a null executor, index \" + i + \" was null\");\n             }\n         }\n     }\n     //----------------------------------------------------------------------------------\n \n     /**\n-     * TransformerExecutor returns the result of calling a Transformer.\n+     * TransformerExecutor calls a Transformer using the input object and ignore the result.\n      */\n     private static class TransformerExecutor implements Executor, Serializable {\n-\n+        /** The transformer to wrap */\n         private final Transformer iTransformer;\n \n         /**\n-         * Constructor to store factory\n+         * Constructor to store transformer\n          */\n         private TransformerExecutor(Transformer transformer) {\n             super();\n         }\n \n         /**\n-         * Return the result of calling the factory\n+         * Call the transformer\n          */\n         public void execute(Object input) {\n             try {\n     //----------------------------------------------------------------------------------\n \n     /**\n-     * ChainedExecutor calls a list of commands.\n+     * ChainedExecutor calls a list of executors.\n      */\n     private static class ChainedExecutor implements Executor, Serializable {\n-\n+        /** The executors to call in turn */\n         private final Executor[] iExecutors;\n \n         /**\n          * Constructor to store params\n          */\n-        private ChainedExecutor(Executor[] commands) {\n+        private ChainedExecutor(Executor[] executors) {\n             super();\n-            iExecutors = commands;\n-        }\n-\n-        /**\n-         * Execute a list of commands\n+            iExecutors = executors;\n+        }\n+\n+        /**\n+         * Execute a list of executors\n          */\n         public void execute(Object input) {\n             for (int i = 0; i < iExecutors.length; i++) {\n     //----------------------------------------------------------------------------------\n \n     /**\n-     * SwitchExecutor calls the command whose predicate returns true.\n+     * SwitchExecutor calls the executor whose predicate returns true.\n      */\n     private static class SwitchExecutor implements Executor, Serializable {\n-\n+        /** The tests to consider */\n         private final Predicate[] iPredicates;\n+        /** The matching executors to call */\n         private final Executor[] iExecutors;\n+        /** The default executor to call if no tests match */\n         private final Executor iDefault;\n \n         /**\n          * Constructor to store params\n          */\n-        private SwitchExecutor(Predicate[] predicates, Executor[] commands, Executor defaultExecutor) {\n+        private SwitchExecutor(Predicate[] predicates, Executor[] executors, Executor defaultExecutor) {\n             super();\n             iPredicates = predicates;\n-            iExecutors = commands;\n+            iExecutors = executors;\n             iDefault = defaultExecutor;\n         }\n \n         /**\n-         * Execute the command whose predicate returns true\n+         * Execute the executor whose predicate returns true\n          */\n         public void execute(Object input) {\n             for (int i = 0; i < iPredicates.length; i++) {\n     //----------------------------------------------------------------------------------\n \n     /**\n-     * ForExecutor calls the command a fixed nunmber of times.\n+     * ForExecutor calls the executor a fixed nunmber of times.\n      */\n     private static class ForExecutor implements Executor, Serializable {\n-\n+        /** The number of times to loop */\n         private final int iCount;\n+        /** The executor to call */\n         private final Executor iExecutor;\n \n         /**\n          * Constructor to store params\n          */\n-        private ForExecutor(int count, Executor command) {\n+        private ForExecutor(int count, Executor executor) {\n             super();\n             iCount = count;\n-            iExecutor = command;\n-        }\n-\n-        /**\n-         * Execute the command count times\n+            iExecutor = executor;\n+        }\n+\n+        /**\n+         * Execute the executor count times\n          */\n         public void execute(Object input) {\n             for (int i = 0; i < iCount; i++) {\n     //----------------------------------------------------------------------------------\n \n     /**\n-     * WhileExecutor calls the command until the predicate is false.\n+     * WhileExecutor calls the executor until the predicate is false.\n      */\n     private static class WhileExecutor implements Executor, Serializable {\n-\n+        /** The test condition */\n         private final Predicate iPredicate;\n+        /** The executor to call */\n         private final Executor iExecutor;\n+        /** The flag, true is a do loop, false is a while */\n         private final boolean iDoLoop;\n \n         /**\n          * Constructor to store params\n          */\n-        private WhileExecutor(Predicate predicate, Executor command, boolean doLoop) {\n+        private WhileExecutor(Predicate predicate, Executor executor, boolean doLoop) {\n             super();\n             iPredicate = predicate;\n-            iExecutor = command;\n+            iExecutor = executor;\n             iDoLoop = doLoop;\n         }\n \n         /**\n-         * Execute the command until the predicate is false\n+         * Execute the executor until the predicate is false\n          */\n         public void execute(Object input) {\n             if (iDoLoop) {\n--- a/src/java/org/apache/commons/lang/functor/FactoryUtils.java\n+++ b/src/java/org/apache/commons/lang/functor/FactoryUtils.java\n import org.apache.commons.lang.SerializationUtils;\n /**\n  * <code>FactoryUtils</code> provides reference implementations and utilities\n- * for the Factory pattern interface. The supplied factories are:\n+ * for the Factory functor interface. The supplied factories are:\n  * <ul>\n  * <li>Prototype - clones a specified object\n  * <li>Reflection - creates objects using reflection\n  * All the supplied factories are Serializable.\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: FactoryUtils.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ * @version $Id: FactoryUtils.java,v 1.2 2002/11/14 21:54:49 scolebourne Exp $\n  */\n public class FactoryUtils {\n \n \n     /**\n      * Gets a Factory that will return null each time the factory is used.\n+     * This could be useful during testing as a placeholder.\n      *\n      * @return the factory\n      */\n      * use the prototype factory.\n      *\n      * @param constantToReturn  the constant object to return each time in the factory\n-     * @return the factory.\n+     * @return the <code>constant</code> factory.\n      */\n     public static Factory constantFactory(Object constantToReturn) {\n         return new ConstantFactory(constantToReturn);\n      * <ul>\n      *\n      * @param prototype  the object to clone each time in the factory\n-     * @return the factory\n+     * @return the <code>prototype</code> factory\n      * @throws IllegalArgumentException if the prototype is null\n      * @throws IllegalArgumentException if the prototype cannot be cloned\n      */\n     public static Factory prototypeFactory(Object prototype) {\n         if (prototype == null) {\n-            throw new IllegalArgumentException(\"PrototypeFactory: The prototype must not be null\");\n-        }\n-        // TODO: move to cloneable pattern\n+            throw new IllegalArgumentException(\"The prototype must not be null\");\n+        }\n         try {\n             prototype.getClass().getMethod(\"clone\", null);\n             return new PrototypeCloneFactory(prototype);\n                 }\n             }\n         }\n-        throw new IllegalArgumentException(\"PrototypeFactory: The prototype must be cloneable\");\n+        throw new IllegalArgumentException(\"The prototype must be cloneable via a public clone method\");\n     }\n \n     /**\n      * a no-args constructor.\n      *\n      * @param classToInstantiate  the Class to instantiate each time in the factory\n-     * @return the factory\n+     * @return the <code>reflection</code> factory\n      * @throws IllegalArgumentException if the classToInstantiate is null\n      */\n     public static Factory reflectionFactory(Class classToInstantiate) {\n      * @param classToInstantiate  the Class to instantiate each time in the factory\n      * @param paramTypes  parameter types for the constructor, can be null\n      * @param args  the arguments to pass to the constructor, can be null\n-     * @return the factory\n+     * @return the <code>reflection</code> factory\n      * @throws IllegalArgumentException if the classToInstantiate is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      * @throws IllegalArgumentException if the constructor doesn't exist\n      * ConstantFactory returns the same instance each time.\n      */\n     private static class ConstantFactory implements Factory, Serializable {\n-\n+        /** The constant to return each time */\n         private final Object iConstant;\n \n         /**\n      * PrototypeCloneFactory creates objects by copying a prototype using the clone method.\n      */\n     private static class PrototypeCloneFactory implements Factory, Serializable {\n+        /** The object to clone each time */\n         private final Object iPrototype;\n+        /** The method used to clone */\n         private transient Method iCloneMethod;\n \n         /**\n      * PrototypeSerializationFactory creates objects by cloning a prototype using serialization.\n      */\n     private static class PrototypeSerializationFactory implements Factory, Serializable {\n-\n+        /** The object to clone via serialization each time */\n         private final Serializable iPrototype;\n \n         /**\n      * ReflectionFactory creates objects using reflection.\n      */\n     private static class ReflectionFactory implements Factory, Serializable {\n-\n+        /** The class to create */\n         private final Class iClassToInstantiate;\n+        /** The constructor parameter types */\n         private final Class[] iParamTypes;\n+        /** The constructor arguments */\n         private final Object[] iArgs;\n+        /** The constructor */\n         private transient Constructor iConstructor = null;\n \n         /**\n--- a/src/java/org/apache/commons/lang/functor/PredicateUtils.java\n+++ b/src/java/org/apache/commons/lang/functor/PredicateUtils.java\n import org.apache.commons.lang.functor.TransformerUtils;\n /**\n  * <code>PredicateUtils</code> provides reference implementations and utilities\n- * for the Predicate pattern interface. The supplied predicates are:\n+ * for the Predicate functor interface. The supplied predicates are:\n  * <ul>\n  * <li>Invoker - returns the result of a method call on the input object\n  * <li>InstanceOf - true if the object is an instanceof a class\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n  * @author Ola Berg\n- * @version $Id: PredicateUtils.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ * @version $Id: PredicateUtils.java,v 1.2 2002/11/14 21:54:49 scolebourne Exp $\n  */\n public class PredicateUtils {\n \n      * Gets a Predicate that always throws an exception.\n      * This could be useful during testing as a placeholder.\n      *\n-     * @return the factory\n+     * @return the predicate\n      */\n     public static Predicate exceptionPredicate() {\n         return EXCEPTION_PREDICATE;\n     \n     /**\n      * Creates a Predicate that checks if the object passed in is of\n-     * a particular type, using instanceof.\n+     * a particular type, using instanceof. A <code>null</code> input\n+     * object will return <code>false</code>.\n      * \n      * @param type  the type to check for, may not be null\n      * @return the predicate\n      */\n     public static Predicate instanceofPredicate(Class type) {\n         if (type == null) {\n-            throw new IllegalArgumentException(\"InstanceofPredicate: The type to check instanceof must not be null\");\n+            throw new IllegalArgumentException(\"The type to check instanceof must not be null\");\n         }\n         return new InstanceofPredicate(type);\n     }\n     /**\n      * Creates a Predicate that returns true the first time an object is\n      * encoutered, and false if the same object is received \n-     * again. The comparison is by equals().\n+     * again. The comparison is by equals(). A <code>null</code> input object\n+     * is accepted and will return true the first time, and false subsequently\n+     * as well.\n      * \n      * @return the predicate\n      */\n      * @throws IllegalArgumentException if the methodName is null.\n      */\n     public static Predicate invokerPredicate(String methodName){\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n         return asPredicate(TransformerUtils.invokerTransformer(methodName));\n     }\n \n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n     public static Predicate invokerPredicate(String methodName, Class[] paramTypes, Object[] args){\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n         return asPredicate(TransformerUtils.invokerTransformer(methodName, paramTypes, args));\n     }\n \n      * \n      * @param predicate1  the first predicate, may not be null\n      * @param predicate2  the second predicate, may not be null\n-     * @return the predicate\n+     * @return the <code>and</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n     public static Predicate andPredicate(Predicate predicate1, Predicate predicate2) {\n      * predicates are true.\n      * \n      * @param predicates  an array of predicates to check, may not be null\n-     * @return the predicate\n+     * @return the <code>all</code> predicate\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if the predicates array has less than 2 elements\n      * @throws IllegalArgumentException if any predicate in the array is null\n      * predicates are true. The predicates are checked in iterator order.\n      * \n      * @param predicates  a collection of predicates to check, may not be null\n-     * @return the predicate\n+     * @return the <code>all</code> predicate\n      * @throws IllegalArgumentException if the predicates collection is null\n      * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n      * @throws IllegalArgumentException if any predicate in the collection is null\n      * \n      * @param predicate1  the first predicate, may not be null\n      * @param predicate2  the second predicate, may not be null\n-     * @return the predicate\n+     * @return the <code>or</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n     public static Predicate orPredicate(Predicate predicate1, Predicate predicate2) {\n      * predicates are true.\n      * \n      * @param predicates  an array of predicates to check, may not be null\n-     * @return the predicate\n+     * @return the <code>any</code> predicate\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if the predicates array has less than 2 elements\n      * @throws IllegalArgumentException if any predicate in the array is null\n      * predicates are true. The predicates are checked in iterator order.\n      * \n      * @param predicates  a collection of predicates to check, may not be null\n-     * @return the predicate\n+     * @return the <code>any</code> predicate\n      * @throws IllegalArgumentException if the predicates collection is null\n      * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n      * @throws IllegalArgumentException if any predicate in the collection is null\n      * \n      * @param predicate1  the first predicate, may not be null\n      * @param predicate2  the second predicate, may not be null\n-     * @return the predicate\n+     * @return the <code>either</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n     public static Predicate eitherPredicate(Predicate predicate1, Predicate predicate2) {\n      * predicates are true.\n      * \n      * @param predicates  an array of predicates to check, may not be null\n-     * @return the predicate\n+     * @return the <code>one</code> predicate\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if the predicates array has less than 2 elements\n      * @throws IllegalArgumentException if any predicate in the array is null\n      * predicates are true. The predicates are checked in iterator order.\n      * \n      * @param predicates  a collection of predicates to check, may not be null\n-     * @return the predicate\n+     * @return the <code>one</code> predicate\n      * @throws IllegalArgumentException if the predicates collection is null\n      * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n      * @throws IllegalArgumentException if any predicate in the collection is null\n      * \n      * @param predicate1  the first predicate, may not be null\n      * @param predicate2  the second predicate, may not be null\n-     * @return the predicate\n+     * @return the <code>neither</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n     public static Predicate neitherPredicate(Predicate predicate1, Predicate predicate2) {\n      * predicates are true.\n      * \n      * @param predicates  an array of predicates to check, may not be null\n-     * @return the predicate\n+     * @return the <code>none</code> predicate\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if the predicates array has less than 2 elements\n      * @throws IllegalArgumentException if any predicate in the array is null\n      * predicates are true. The predicates are checked in iterator order.\n      * \n      * @param predicates  a collection of predicates to check, may not be null\n-     * @return the predicate\n+     * @return the <code>none</code> predicate\n      * @throws IllegalArgumentException if the predicates collection is null\n      * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n      * @throws IllegalArgumentException if any predicate in the collection is null\n      * returns false and vice versa.\n      * \n      * @param predicate  the predicate to not\n-     * @return the predicate\n+     * @return the <code>not</code> predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n     public static Predicate notPredicate(Predicate predicate) {\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"NotPredicate: The predicate must not be null\");\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n         }\n         return new NotPredicate(predicate);\n     }\n      * will be thrown.\n      * \n      * @param transformer  the transformer to wrap, may not be null\n-     * @return the predicate\n+     * @return the transformer wrapping predicate\n      * @throws IllegalArgumentException if the transformer is null\n      */\n     public static Predicate asPredicate(Transformer transformer) {\n         if (transformer == null) {\n-            throw new IllegalArgumentException(\"TransformerPredicate: The transformer to call must not be null\");\n+            throw new IllegalArgumentException(\"The transformer to call must not be null\");\n         }\n         return new TransformerPredicate(transformer);\n     }\n      */\n     private static Predicate[] validate(Collection predicates) {\n         if (predicates == null) {\n-            throw new IllegalArgumentException(\"PredicateUtils: The predicate collection must not be null\");\n+            throw new IllegalArgumentException(\"The predicate collection must not be null\");\n         }\n         if (predicates.size() < 2) {\n             throw new IllegalArgumentException(\n-                \"PredicateUtils: At least 2 predicates must be specified in the predicate collection, size was \" + predicates.size());\n+                \"At least 2 predicates must be specified in the predicate collection, size was \" + predicates.size());\n         }\n         // convert to array like this to guarantee iterator() ordering\n         Predicate[] preds = new Predicate[predicates.size()];\n         for (Iterator it = predicates.iterator(); it.hasNext();) {\n             preds[i] = (Predicate) it.next();\n             if (preds[i] == null) {\n-                throw new IllegalArgumentException(\"PredicateUtils: The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n+                throw new IllegalArgumentException(\"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n             }\n             i++;\n         }\n      */\n     private static Predicate[] validate(Predicate[] predicates) {\n         if (predicates == null) {\n-            throw new IllegalArgumentException(\"PredicateUtils: The predicate array must not be null\");\n+            throw new IllegalArgumentException(\"The predicate array must not be null\");\n         }\n         if (predicates.length < 2) {\n             throw new IllegalArgumentException(\n-                \"PredicateUtils: At least 2 predicates must be specified in the predicate array, size was \" + predicates.length);\n+                \"At least 2 predicates must be specified in the predicate array, size was \" + predicates.length);\n         }\n         Predicate[] preds = new Predicate[predicates.length];\n         for (int i = 0; i < predicates.length; i++) {\n             if (predicates[i] == null) {\n-                throw new IllegalArgumentException(\"PredicateUtils: The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+                throw new IllegalArgumentException(\"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n             }\n             preds[i] = predicates[i];\n         }\n      * ConstantPredicate returns the same instance each time.\n      */\n     private static class ConstantPredicate implements Predicate, Serializable {\n-\n+        /** The constant value to return each time */\n         private final boolean iConstant;\n \n         /**\n      * AllPredicate returns true if all predicates return true\n      */\n     private static class AllPredicate implements Predicate, Serializable {\n+        /** The array of predicates to call */\n         private final Predicate[] iPredicates;\n \n         /**\n      * AnyPredicate returns true if one of the predicates return true\n      */\n     private static class AnyPredicate implements Predicate, Serializable {\n+        /** The array of predicates to call */\n         private final Predicate[] iPredicates;\n \n         /**\n      * OnePredicate returns true if only one of the predicates return true\n      */\n     private static class OnePredicate implements Predicate, Serializable {\n+        /** The array of predicates to call */\n         private final Predicate[] iPredicates;\n \n         /**\n      * NotPredicate returns the opposite of the wrapped predicate\n      */\n     private static class NotPredicate implements Predicate, Serializable {\n+        /** The predicate to call */\n         private final Predicate iPredicate;\n \n         /**\n      * InstanceofPredicate checks the type of an object\n      */\n     private static class InstanceofPredicate implements Predicate, Serializable {\n+        /** The type to check for */\n         private final Class iType;\n \n         /**\n      * EqualPredicate that checks if the object is a particular value by equals().\n      */\n     private static class EqualPredicate implements Predicate, Serializable {\n+        /** The object to compare to */\n         private final Object iValue;\n \n         /**\n      * IdentityPredicate that checks if the object is a particular value by identity.\n      */\n     private static class IdentityPredicate implements Predicate, Serializable {\n+        /** The object to compare identity to */\n         private final Object iValue;\n \n         /**\n      * again using equals().\n      */\n     private static class UniquePredicate implements Predicate, Serializable {\n+        /** The set of previously seen objects */\n         private final Set iSet = new HashSet();\n \n         /**\n      * TransformerPredicate returns the result of the Transformer as a boolean.\n      */\n     private static class TransformerPredicate implements Predicate, Serializable {\n-\n+        /** The transformer to call */\n         private final Transformer iTransformer;\n \n         /**\n      * NullIsExceptionPredicate returns an exception if null is passed in.\n      */\n     private static class NullIsExceptionPredicate implements Predicate, Serializable {\n+        /** The predicate to call */\n         private final Predicate iPredicate;\n         \n         /**\n      * NullIsFalsePredicate returns false if null is passed in.\n      */\n     private static class NullIsFalsePredicate implements Predicate, Serializable {\n+        /** The predicate to call */\n         private final Predicate iPredicate;\n         \n         /**\n      * NullIsTruePredicate returns true if null is passed in.\n      */\n     private static class NullIsTruePredicate implements Predicate, Serializable {\n+        /** The predicate to call */\n         private final Predicate iPredicate;\n         \n         /**\n--- a/src/java/org/apache/commons/lang/functor/TransformerUtils.java\n+++ b/src/java/org/apache/commons/lang/functor/TransformerUtils.java\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.Map;\n-\n /**\n  * <code>TransformerUtils</code> provides reference implementations and \n- * utilities for the Transformer pattern interface. The supplied transformers are:\n+ * utilities for the Transformer functor interface. The supplied transformers are:\n  * <ul>\n  * <li>Invoker - returns the result of a method call on the input object\n  * <li>Clone - returns a clone of the input object\n  * All the supplied transformers are Serializable.\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: TransformerUtils.java,v 1.2 2002/11/06 19:16:33 bayard Exp $\n+ * @version $Id: TransformerUtils.java,v 1.3 2002/11/14 21:54:49 scolebourne Exp $\n  */\n public class TransformerUtils {\n \n      * @param command  the command to run each time in the transformer\n      * @return the transformer.\n      */\n-    public static Transformer asTransformer(Executor command) {\n-        if (command == null) {\n-            throw new IllegalArgumentException(\"ExecutorTransformer: The command must not be null\");\n-        }\n-        return new ExecutorTransformer(command);\n+    public static Transformer asTransformer(Executor executor) {\n+        if (executor == null) {\n+            throw new IllegalArgumentException(\"The executor must not be null\");\n+        }\n+        return new ExecutorTransformer(executor);\n     }\n \n     /**\n      */\n     public static Transformer asTransformer(Predicate predicate) {\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"PredicateTransformer: The predicate must not be null\");\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n         }\n         return new PredicateTransformer(predicate);\n     }\n      */\n     public static Transformer asTransformer(Factory factory) {\n         if (factory == null) {\n-            throw new IllegalArgumentException(\"FactoryTransformer: The factory must not be null\");\n+            throw new IllegalArgumentException(\"The factory must not be null\");\n         }\n         return new FactoryTransformer(factory);\n     }\n     public static Transformer chainedTransformer(Collection transformers) {\n         Transformer[] trs = null;\n         if (transformers == null) {\n-            throw new IllegalArgumentException(\"ChainedTransformer: The transformer collection must not be null\");\n+            throw new IllegalArgumentException(\"The transformer collection must not be null\");\n         }\n         // convert to array like this to guarantee iterator() ordering\n         trs = new Transformer[transformers.size()];\n         Transformer[] trs = null;\n         Predicate[] preds = null;\n         if (predicatesAndTransformers == null) {\n-            throw new IllegalArgumentException(\"SwitchTransformer: The predicate and transformer map must not be null\");\n+            throw new IllegalArgumentException(\"The predicate and transformer map must not be null\");\n         }\n         // convert to array like this to guarantee iterator() ordering\n         Transformer def = (Transformer) predicatesAndTransformers.remove(null);\n         validate(predicates);\n         validate(transformers);\n         if (predicates.length != transformers.length) {\n-            throw new IllegalArgumentException(\"SwitchTransformer: The predicate and transformer arrays must be the same size\");\n+            throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n         }\n         if (defaultTransformer == null) {\n             defaultTransformer = nullTransformer();\n         Transformer[] trs = null;\n         Predicate[] preds = null;\n         if (objectsAndTransformers == null) {\n-            throw new IllegalArgumentException(\"SwitchEqualsTransformer: The obejct and transformer map must not be null\");\n+            throw new IllegalArgumentException(\"The obejct and transformer map must not be null\");\n         }\n         Transformer def = (Transformer) objectsAndTransformers.remove(null);\n         int size = objectsAndTransformers.size();\n      */\n     public static Transformer mapTransformer(Map map) {\n         if (map == null) {\n-            throw new IllegalArgumentException(\"MapTransformer: The map must not be null\");\n+            throw new IllegalArgumentException(\"The map must not be null\");\n         }\n         return new MapTransformer(map);\n     }\n      */\n     private static void validate(Predicate[] predicates) {\n         if (predicates == null) {\n-            throw new IllegalArgumentException(\"TransformerUtils: The predicate array must not be null\");\n+            throw new IllegalArgumentException(\"The predicate array must not be null\");\n         }\n         if (predicates.length < 1) {\n             throw new IllegalArgumentException(\n-                \"TransformerUtils: At least 1 predicate must be specified in the predicate array, size was \" + predicates.length);\n+                \"At least 1 predicate must be specified in the predicate array, size was \" + predicates.length);\n         }\n         for (int i = 0; i < predicates.length; i++) {\n             if (predicates[i] == null) {\n                 throw new IllegalArgumentException(\n-                    \"TransformerUtils: The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+                    \"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n             }\n         }\n     }\n      */\n     private static void validate(Transformer[] transformers) {\n         if (transformers == null) {\n-            throw new IllegalArgumentException(\"TransformerUtils: The transformer array must not be null\");\n+            throw new IllegalArgumentException(\"The transformer array must not be null\");\n         }\n         if (transformers.length < 1) {\n             throw new IllegalArgumentException(\n-                \"TransformerUtils: At least 1 transformer must be specified in the transformer array, size was \" + transformers.length);\n+                \"At least 1 transformer must be specified in the transformer array, size was \" + transformers.length);\n         }\n         for (int i = 0; i < transformers.length; i++) {\n             if (transformers[i] == null) {\n                 throw new IllegalArgumentException(\n-                    \"TransformerUtils: The transformer array must not contain a null transformer, index \" + i + \" was null\");\n+                    \"The transformer array must not contain a null transformer, index \" + i + \" was null\");\n             }\n         }\n     }\n      * ConstantTransformer returns the same instance each time.\n      */\n     private static class ConstantTransformer implements Transformer, Serializable {\n-\n+        /** The constant to return each time */\n         private final Object iConstant;\n \n         /**\n-         * Constructor to store constant\n+         * Constructor to store constant.\n          */\n         private ConstantTransformer(Object constant) {\n             super();\n         }\n \n         /**\n-         * Always return constant\n+         * Always return constant.\n          */\n         public Object transform(Object input) {\n             return iConstant;\n      * ExecutorTransformer executes a Executor object.\n      */\n     private static class ExecutorTransformer implements Transformer, Serializable {\n-\n+        /** The executor to call each time */\n         private final Executor iExecutor;\n \n         /**\n-         * Constructor to store command\n-         */\n-        private ExecutorTransformer(Executor command) {\n-            super();\n-            iExecutor = command;\n-        }\n-\n-        /**\n-         * Exceute the command and return the input\n+         * Constructor to store executor.\n+         */\n+        private ExecutorTransformer(Executor executor) {\n+            super();\n+            iExecutor = executor;\n+        }\n+\n+        /**\n+         * Exceute the executor and return the input.\n          */\n         public Object transform(Object input) {\n             try {\n      * PredicateTransformer evaluates a Predicate object.\n      */\n     private static class PredicateTransformer implements Transformer, Serializable {\n-\n+        /** The predicate to call each time */\n         private final Predicate iPredicate;\n \n         /**\n-         * Constructor to store predicate\n+         * Constructor to store predicate.\n          */\n         private PredicateTransformer(Predicate predicate) {\n             super();\n         }\n \n         /**\n-         * Evaluate the predicate and return the result as a Boolean\n+         * Evaluate the predicate and return the result as a Boolean.\n          */\n         public Object transform(Object input) {\n             try {\n      * FactoryTransformer returns the result of calling a Factory.\n      */\n     private static class FactoryTransformer implements Transformer, Serializable {\n-\n+        /** The factory to call each time */\n         private final Factory iFactory;\n \n         /**\n-         * Constructor to store factory\n+         * Constructor to store factory.\n          */\n         private FactoryTransformer(Factory factory) {\n             super();\n         }\n \n         /**\n-         * Return the result of calling the factory\n+         * Return the result of calling the factory.\n          */\n         public Object transform(Object input) {\n             try {\n      * ChainedTransformer returns the result of calling a list of transformers.\n      */\n     private static class ChainedTransformer implements Transformer, Serializable {\n-\n+        /** The array of transformers to call */\n         private final Transformer[] iTransformers;\n \n         /**\n-         * Constructor to store params\n+         * Constructor to store params.\n          */\n         private ChainedTransformer(Transformer[] transformers) {\n             super();\n         }\n \n         /**\n-         * Returns the result of calling a list of transformers\n+         * Returns the result of calling a list of transformers.\n          */\n         public Object transform(Object object) {\n             for (int i = 0; i < iTransformers.length; i++) {\n      * SwitchTransformer returns the result of the transformer whose predicate returns true.\n      */\n     private static class SwitchTransformer implements Transformer, Serializable {\n-\n+        /** The array of predicates to switch on */\n         private final Predicate[] iPredicates;\n+        /** The array of transformers to call */\n         private final Transformer[] iTransformers;\n+        /** The default transformer called if no predicate matches */\n         private final Transformer iDefault;\n \n         /**\n-         * Constructor to store params\n+         * Constructor to store params.\n          */\n         private SwitchTransformer(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n             super();\n         }\n \n         /**\n-         * Returns the result of the transformer whose predicate returns true\n+         * Returns the result of the transformer whose predicate returns true.\n          */\n         public Object transform(Object input) {\n             for (int i = 0; i < iPredicates.length; i++) {\n     //----------------------------------------------------------------------------------\n \n     /**\n-     * InstantiateTransformer returns the result of calling a Factory.\n+     * InstantiateTransformer returns the result of instantiating the input Class object.\n      */\n     private static class InstantiateTransformer implements Transformer, Serializable {\n-\n+        /** The array of reflection parameter types */\n         private final Class[] iParamTypes;\n+        /** The array of reflection arguments */\n         private final Object[] iArgs;\n \n         /**\n-         * Constructor to store params\n+         * Constructor to store params.\n          */\n         private InstantiateTransformer(Class[] paramTypes, Object[] args) {\n             super();\n         }\n \n         /**\n-         * Return the result of calling the factory\n+         * Return the result of instantiating the input Class object.\n          */\n         public Object transform(Object input) {\n             try {\n      * MapTransformer returns the result by looking up in the map.\n      */\n     private static class MapTransformer implements Transformer, Serializable {\n-\n+        /** The map of data to lookup in */\n         private final Map iMap;\n \n         /**\n-         * Constructor to store map\n+         * Constructor to store map.\n          */\n         private MapTransformer(Map map) {\n             super();\n         }\n \n         /**\n-         * Returns the result by looking up in the map\n+         * Returns the result by looking up in the map.\n          */\n         public Object transform(Object input) {\n             return iMap.get(input);\n      * the input object.\n      */\n     private static class InvokerTransformer implements Transformer, Serializable {\n+        /** The method name to call */\n         private final String iMethodName;\n+        /** The array of reflection parameter types */\n         private final Class[] iParamTypes;\n+        /** The array of reflection arguments */\n         private final Object[] iArgs;\n \n         /**\n-         * Constructor\n+         * Constructor.\n          */\n         public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {\n             super();\n         }\n \n         /**\n-         * Execute the command based on the input object.\n+         * Invoke the specified method on the input object.\n          */\n         public Object transform(Object input) {\n             if (input == null) {", "timestamp": 1037310889, "metainfo": ""}