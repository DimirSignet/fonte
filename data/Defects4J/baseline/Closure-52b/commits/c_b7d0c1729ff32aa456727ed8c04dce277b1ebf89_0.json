{"sha": "b7d0c1729ff32aa456727ed8c04dce277b1ebf89", "log": "Move ExploitAssigns on its own.  R=johnlenz DELTA=785  (437 added, 348 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=878   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n     collapses.clear();\n     nodesToCollapse.clear();\n \n-    // TODO(user): I would like to void exploit assign output this and make\n-    // both peephole optimization.\n-    NodeTraversal.traverse(compiler, root, new ExploitAssigns());\n     NodeTraversal.traverse(compiler, root, new GatherCollapses());\n \n     if (!collapses.isEmpty()) {\n       applyCollapses();\n       compiler.reportCodeChange();\n     }\n-  }\n-\n-  private class ExploitAssigns extends AbstractPostOrderCallback {\n-\n-    public void visit(NodeTraversal t, Node expr, Node exprParent) {\n-      if (!NodeUtil.isExprAssign(expr)) {\n-        return;\n-      }\n-\n-      collapseAssign(t, expr.getFirstChild(), expr, exprParent);\n-    }\n-\n-    /**\n-     * Try to collapse the given assign into subsequent expressions.\n-     */\n-    private void collapseAssign(NodeTraversal t, Node assign, Node expr,\n-        Node exprParent) {\n-      Node leftValue = assign.getFirstChild();\n-      Node rightValue = leftValue.getNext();\n-      if (isCollapsibleValue(leftValue, true) &&\n-          collapseAssignEqualTo(expr, exprParent, leftValue)) {\n-        t.getCompiler().reportCodeChange();\n-      } else if (isCollapsibleValue(rightValue, false) &&\n-          collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-        t.getCompiler().reportCodeChange();\n-      } else if (rightValue.getType() == Token.ASSIGN) {\n-        // Recursively deal with nested assigns.\n-        collapseAssign(t, rightValue, expr, exprParent);\n-      }\n-    }\n-\n-    /**\n-     * Determines whether we know enough about the given value to be able\n-     * to collapse it into subsequent expressions.\n-     *\n-     * For example, we can collapse booleans and variable names:\n-     * <code>\n-     * x = 3; y = x; // y = x = 3;\n-     * a = true; b = true; // b = a = true;\n-     * <code>\n-     * But we won't try to collapse complex expressions.\n-     *\n-     * @param value The value node.\n-     * @param isLValue Whether it's on the left-hand side of an expr.\n-     */\n-    private boolean isCollapsibleValue(Node value, boolean isLValue) {\n-      switch (value.getType()) {\n-        case Token.GETPROP:\n-          // Do not collapse GETPROPs on arbitrary objects, because\n-          // they may be implemented  setter functions, and oftentimes\n-          // setter functions fail on native objects. This is ok for \"THIS\"\n-          // objects, because we assume that they are non-native.\n-          return !isLValue || value.getFirstChild().getType() == Token.THIS;\n-\n-        case Token.NAME:\n-          return true;\n-\n-        default:\n-          return NodeUtil.isImmutableValue(value);\n-      }\n-    }\n-\n-    /**\n-     * Collapse the given assign expression into the expression directly\n-     * following it, if possible.\n-     *\n-     * @param expr The expression that may be moved.\n-     * @param exprParent The parent of {@code expr}.\n-     * @param value The value of this expression, expressed as a node. Each\n-     *     expression may have multiple values, so this function may be called\n-     *     multiple times for the same expression. For example,\n-     *     <code>\n-     *     a = true;\n-     *     </code>\n-     *     is equal to the name \"a\" and the boolean \"true\".\n-     * @return Whether the expression was collapsed succesfully.\n-     */\n-    private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n-        Node value) {\n-      Node assign = expr.getFirstChild();\n-      Node parent = exprParent;\n-      Node next = expr.getNext();\n-      while (next != null) {\n-        switch (next.getType()) {\n-          case Token.AND:\n-          case Token.OR:\n-          case Token.HOOK:\n-          case Token.IF:\n-          case Token.RETURN:\n-          case Token.EXPR_RESULT:\n-            // Dive down the left side\n-            parent = next;\n-            next = next.getFirstChild();\n-            break;\n-\n-          case Token.VAR:\n-            if (next.getFirstChild().hasChildren()) {\n-              parent = next.getFirstChild();\n-              next = parent.getFirstChild();\n-              break;\n-            }\n-            return false;\n-\n-          case Token.GETPROP:\n-          case Token.NAME:\n-            if (next.isQualifiedName()) {\n-              String nextName = next.getQualifiedName();\n-              if (value.isQualifiedName() &&\n-                  nextName.equals(value.getQualifiedName())) {\n-                // If the previous expression evaluates to value of a\n-                // qualified name, and that qualified name is used again\n-                // shortly, then we can exploit the assign here.\n-\n-                // Verify the assignment doesn't change its own value.\n-                if (!isSafeReplacement(next, assign)) {\n-                  return false;\n-                }\n-\n-                exprParent.removeChild(expr);\n-                expr.removeChild(assign);\n-                parent.replaceChild(next, assign);\n-                return true;\n-              }\n-            }\n-            return false;\n-\n-          case Token.ASSIGN:\n-            // Assigns are really tricky. In lots of cases, we want to inline\n-            // into the right side of the assign. But the left side of the\n-            // assign is evaluated first, and it may have convoluted logic:\n-            //   a = null;\n-            //   (a = b).c = null;\n-            // We don't want to exploit the first assign. Similarly:\n-            //   a.b = null;\n-            //   a.b.c = null;\n-            // We don't want to exploit the first assign either.\n-            //\n-            // To protect against this, we simply only inline when the left side\n-            // is guaranteed to evaluate to the same L-value no matter what.\n-            Node leftSide = next.getFirstChild();\n-            if (leftSide.getType() == Token.NAME ||\n-                leftSide.getType() == Token.GETPROP &&\n-                leftSide.getFirstChild().getType() == Token.THIS) {\n-              // Dive down the right side of the assign.\n-              parent = next;\n-              next = leftSide.getNext();\n-              break;\n-            } else {\n-              return false;\n-            }\n-\n-          default:\n-            if (NodeUtil.isImmutableValue(next)\n-                && next.isEquivalentTo(value)) {\n-              // If the r-value of the expr assign is an immutable value,\n-              // and the value is used again shortly, then we can exploit\n-              // the assign here.\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-            // Return without inlining a thing\n-            return false;\n-        }\n-      }\n-\n-      return false;\n-    }\n-  }\n-\n-  /**\n-   * Checks name referenced in node to determine if it might have\n-   * changed.\n-   * @return Whether the replacement can be made.\n-   */\n-  private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.getType() == Token.NAME) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.getType() == Token.GETPROP);\n-\n-    Node name = node.getFirstChild();\n-    if (name.getType() == Token.NAME\n-        && isNameAssignedTo(name.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n-  }\n-\n-  /**\n-   * @return Whether name is assigned in the expression rooted at node.\n-   */\n-  private boolean isNameAssignedTo(String name, Node node) {\n-    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n-      if (isNameAssignedTo(name, c)) {\n-        return true;\n-      }\n-    }\n-\n-    if (node.getType() == Token.NAME) {\n-      Node parent = node.getParent();\n-      if (parent.getType() == Token.ASSIGN && parent.getFirstChild() == node) {\n-        if (name.equals(node.getString())) {\n-          return true;\n-        }\n-      }\n-    }\n-\n-    return false;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     }\n \n     if (options.collapseVariableDeclarations) {\n+      passes.add(exploitAssign);\n       passes.add(collapseVariableDeclarations);\n     }\n \n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new CoalesceVariableNames(compiler, options.generatePseudoNames);\n+    }\n+  };\n+\n+  /**\n+   * Some simple, local collapses (e.g., {@code var x; var y;} becomes\n+   * {@code var x,y;}.\n+   */\n+  private final PassFactory exploitAssign =\n+      new PassFactory(\"expointAssign\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new PeepholeOptimizationsPass(compiler,\n+          new ExploitAssigns());\n     }\n   };\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ExploitAssigns.java\n+/*\n+ * Copyright 2006 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Tries to chain assignments together.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ * @author acleung@google.com (Alan Leung)\n+ *\n+ */\n+class ExploitAssigns extends AbstractPeepholeOptimization {\n+\n+  @Override\n+  Node optimizeSubtree(Node subtree) {\n+    for (Node child = subtree.getFirstChild(); child != null;) {\n+      Node next = child.getNext();\n+      if (NodeUtil.isExprAssign(child)) {\n+        collapseAssign(child.getFirstChild(), child, subtree);\n+      }\n+      child = next;\n+    }\n+    return subtree;\n+  }\n+\n+  /**\n+   * Try to collapse the given assign into subsequent expressions.\n+   */\n+  private void collapseAssign(Node assign, Node expr,\n+      Node exprParent) {\n+    Node leftValue = assign.getFirstChild();\n+    Node rightValue = leftValue.getNext();\n+    if (isCollapsibleValue(leftValue, true) &&\n+        collapseAssignEqualTo(expr, exprParent, leftValue)) {\n+      reportCodeChange();\n+    } else if (isCollapsibleValue(rightValue, false) &&\n+        collapseAssignEqualTo(expr, exprParent, rightValue)) {\n+      reportCodeChange();\n+    } else if (rightValue.getType() == Token.ASSIGN) {\n+      // Recursively deal with nested assigns.\n+      collapseAssign(rightValue, expr, exprParent);\n+    }\n+  }\n+\n+  /**\n+   * Determines whether we know enough about the given value to be able\n+   * to collapse it into subsequent expressions.\n+   *\n+   * For example, we can collapse booleans and variable names:\n+   * <code>\n+   * x = 3; y = x; // y = x = 3;\n+   * a = true; b = true; // b = a = true;\n+   * <code>\n+   * But we won't try to collapse complex expressions.\n+   *\n+   * @param value The value node.\n+   * @param isLValue Whether it's on the left-hand side of an expr.\n+   */\n+  private boolean isCollapsibleValue(Node value, boolean isLValue) {\n+    switch (value.getType()) {\n+      case Token.GETPROP:\n+        // Do not collapse GETPROPs on arbitrary objects, because\n+        // they may be implemented  setter functions, and oftentimes\n+        // setter functions fail on native objects. This is ok for \"THIS\"\n+        // objects, because we assume that they are non-native.\n+        return !isLValue || value.getFirstChild().getType() == Token.THIS;\n+\n+      case Token.NAME:\n+        return true;\n+\n+      default:\n+        return NodeUtil.isImmutableValue(value);\n+    }\n+  }\n+\n+  /**\n+   * Collapse the given assign expression into the expression directly\n+   * following it, if possible.\n+   *\n+   * @param expr The expression that may be moved.\n+   * @param exprParent The parent of {@code expr}.\n+   * @param value The value of this expression, expressed as a node. Each\n+   *     expression may have multiple values, so this function may be called\n+   *     multiple times for the same expression. For example,\n+   *     <code>\n+   *     a = true;\n+   *     </code>\n+   *     is equal to the name \"a\" and the boolean \"true\".\n+   * @return Whether the expression was collapsed succesfully.\n+   */\n+  private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n+      Node value) {\n+    Node assign = expr.getFirstChild();\n+    Node parent = exprParent;\n+    Node next = expr.getNext();\n+    while (next != null) {\n+      switch (next.getType()) {\n+        case Token.AND:\n+        case Token.OR:\n+        case Token.HOOK:\n+        case Token.IF:\n+        case Token.RETURN:\n+        case Token.EXPR_RESULT:\n+          // Dive down the left side\n+          parent = next;\n+          next = next.getFirstChild();\n+          break;\n+\n+        case Token.VAR:\n+          if (next.getFirstChild().hasChildren()) {\n+            parent = next.getFirstChild();\n+            next = parent.getFirstChild();\n+            break;\n+          }\n+          return false;\n+\n+        case Token.GETPROP:\n+        case Token.NAME:\n+          if (next.isQualifiedName()) {\n+            String nextName = next.getQualifiedName();\n+            if (value.isQualifiedName() &&\n+                nextName.equals(value.getQualifiedName())) {\n+              // If the previous expression evaluates to value of a\n+              // qualified name, and that qualified name is used again\n+              // shortly, then we can exploit the assign here.\n+\n+              // Verify the assignment doesn't change its own value.\n+              if (!isSafeReplacement(next, assign)) {\n+                return false;\n+              }\n+\n+              exprParent.removeChild(expr);\n+              expr.removeChild(assign);\n+              parent.replaceChild(next, assign);\n+              return true;\n+            }\n+          }\n+          return false;\n+\n+        case Token.ASSIGN:\n+          // Assigns are really tricky. In lots of cases, we want to inline\n+          // into the right side of the assign. But the left side of the\n+          // assign is evaluated first, and it may have convoluted logic:\n+          //   a = null;\n+          //   (a = b).c = null;\n+          // We don't want to exploit the first assign. Similarly:\n+          //   a.b = null;\n+          //   a.b.c = null;\n+          // We don't want to exploit the first assign either.\n+          //\n+          // To protect against this, we simply only inline when the left side\n+          // is guaranteed to evaluate to the same L-value no matter what.\n+          Node leftSide = next.getFirstChild();\n+          if (leftSide.getType() == Token.NAME ||\n+              leftSide.getType() == Token.GETPROP &&\n+              leftSide.getFirstChild().getType() == Token.THIS) {\n+            // Dive down the right side of the assign.\n+            parent = next;\n+            next = leftSide.getNext();\n+            break;\n+          } else {\n+            return false;\n+          }\n+\n+        default:\n+          if (NodeUtil.isImmutableValue(next)\n+              && next.isEquivalentTo(value)) {\n+            // If the r-value of the expr assign is an immutable value,\n+            // and the value is used again shortly, then we can exploit\n+            // the assign here.\n+            exprParent.removeChild(expr);\n+            expr.removeChild(assign);\n+            parent.replaceChild(next, assign);\n+            return true;\n+          }\n+          // Return without inlining a thing\n+          return false;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Checks name referenced in node to determine if it might have\n+   * changed.\n+   * @return Whether the replacement can be made.\n+   */\n+  private boolean isSafeReplacement(Node node, Node replacement) {\n+    // No checks are needed for simple names.\n+    if (node.getType() == Token.NAME) {\n+      return true;\n+    }\n+    Preconditions.checkArgument(node.getType() == Token.GETPROP);\n+\n+    Node name = node.getFirstChild();\n+    if (name.getType() == Token.NAME\n+        && isNameAssignedTo(name.getString(), replacement)) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * @return Whether name is assigned in the expression rooted at node.\n+   */\n+\n+  private boolean isNameAssignedTo(String name, Node node) {\n+    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n+      if (isNameAssignedTo(name, c)) {\n+        return true;\n+      }\n+    }\n+\n+    if (node.getType() == Token.NAME) {\n+      Node parent = node.getParent();\n+      if (parent.getType() == Token.ASSIGN && parent.getFirstChild() == node) {\n+        if (name.equals(node.getString())) {\n+          return true;\n+        }\n+      }\n+    }\n+\n+    return false;\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/CollapseVariableDeclarationsTest.java\n+++ b/test/com/google/javascript/jscomp/CollapseVariableDeclarationsTest.java\n     testSame(\"if (x) var a = 1; else var a = 2;\");\n   }\n \n-  public void testExprExploitationTypes() {\n-    test(\"a = true; b = true\",\n-         \"b = a = true\");\n-    test(\"a = !0; b = !0\",\n-         \"b = a = !0\");\n-    test(\"a = !1; b = !1\",\n-         \"b = a = !1\");\n-    test(\"a = void 0; b = void 0\",\n-         \"b = a = void 0\");\n-    test(\"a = -Infinity; b = -Infinity\",\n-         \"b = a = -Infinity\");\n-  }\n-\n-  public void testExprExploitationTypes2() {\n-    test(\"a = !0; b = !0\",\n-         \"b = a = !0\");\n-  }\n-\n-  public void testExprExploitation() {\n-    test(\"a = null; b = null; var c = b\",\n-         \"var c = b = a = null\");\n-    test(\"a = null; b = null\",\n-         \"b = a = null\");\n-    test(\"a = undefined; b = undefined\",\n-         \"b = a = undefined\");\n-    test(\"a = 0; b = 0\", \"b=a=0\");\n-    test(\"a = 'foo'; b = 'foo'\",\n-         \"b = a = \\\"foo\\\"\");\n-    test(\"a = c; b = c\", \"b=a=c\");\n-\n-    testSame(\"a = 0; b = 1\");\n-    testSame(\"a = \\\"foo\\\"; b = \\\"foox\\\"\");\n-\n-    test(\"a = null; a && b;\", \"(a = null)&&b\");\n-    test(\"a = null; a || b;\", \"(a = null)||b\");\n-\n-    test(\"a = null; a ? b : c;\", \"(a = null) ? b : c\");\n-\n-    test(\"a = null; this.foo = null;\",\n-         \"this.foo = a = null\");\n-    test(\"function f(){ a = null; return null; }\",\n-         \"function f(){return a = null}\");\n-\n-    test(\"a = true; if (a) { foo(); }\",\n-         \"if (a = true) { foo() }\");\n-    test(\"a = true; if (a && a) { foo(); }\",\n-         \"if ((a = true) && a) { foo() }\");\n-    test(\"a = false; if (a) { foo(); }\",\n-         \"if (a = false) { foo() }\");\n-\n-    test(\"a = !0; if (a) { foo(); }\",\n-        \"if (a = !0) { foo() }\");\n-    test(\"a = !0; if (a && a) { foo(); }\",\n-        \"if ((a = !0) && a) { foo() }\");\n-    test(\"a = !1; if (a) { foo(); }\",\n-        \"if (a = !1) { foo() }\");\n-\n-    testSame(\"a = this.foo; a();\");\n-    test(\"a = b; b = a;\",\n-         \"b = a = b\");\n-    testSame(\"a = b; a.c = a\");\n-    test(\"this.foo = null; this.bar = null;\",\n-         \"this.bar = this.foo = null\");\n-    test(\"this.foo = null; this.bar = null; this.baz = this.bar\",\n-         \"this.baz = this.bar = this.foo = null\");\n-    test(\"this.foo = null; a = null;\",\n-         \"a = this.foo = null\");\n-    test(\"this.foo = null; a = this.foo;\",\n-         \"a = this.foo = null\");\n-    test(\"a.b.c=null; a=null;\",\n-         \"a = a.b.c = null\");\n-    testSame(\"a = null; a.b.c = null\");\n-    test(\"(a=b).c = null; this.b = null;\",\n-         \"this.b = (a=b).c = null\");\n-    testSame(\"if(x) a = null; else b = a\");\n-  }\n-\n-  public void testNestedExprExploitation() {\n-    test(\"this.foo = null; this.bar = null; this.baz = null;\",\n-         \"this.baz = this.bar = this.foo = null\");\n-\n-    test(\"a = 3; this.foo = a; this.bar = a; this.baz = 3;\",\n-         \"this.baz = this.bar = this.foo = a = 3\");\n-    test(\"a = 3; this.foo = a; this.bar = this.foo; this.baz = a;\",\n-         \"this.baz = this.bar = this.foo = a = 3\");\n-    test(\"a = 3; this.foo = a; this.bar = 3; this.baz = this.foo;\",\n-         \"this.baz = this.bar = this.foo = a = 3\");\n-    test(\"a = 3; this.foo = a; a = 3; this.bar = 3; \" +\n-         \"a = 3; this.baz = this.foo;\",\n-         \"this.baz = a = this.bar = a = this.foo = a = 3\");\n-\n-    test(\"a = 4; this.foo = a; a = 3; this.bar = 3; \" +\n-         \"a = 3; this.baz = this.foo;\",\n-         \"this.foo = a = 4; a = this.bar = a = 3; this.baz = this.foo\");\n-    test(\"a = 3; this.foo = a; a = 4; this.bar = 3; \" +\n-         \"a = 3; this.baz = this.foo;\",\n-         \"this.foo = a = 3; a = 4; a = this.bar = 3; this.baz = this.foo\");\n-    test(\"a = 3; this.foo = a; a = 3; this.bar = 3; \" +\n-         \"a = 4; this.baz = this.foo;\",\n-         \"this.bar = a = this.foo = a = 3; a = 4; this.baz = this.foo\");\n-  }\n-\n-  public void testBug1840071() {\n-    // Some external properties are implemented as setters. Let's\n-    // make sure that we don't collapse them inappropriately.\n-    test(\"a.b = a.x; if (a.x) {}\", \"if (a.b = a.x) {}\");\n-    testSame(\"a.b = a.x; if (a.b) {}\");\n-    test(\"a.b = a.c = a.x; if (a.x) {}\", \"if (a.b = a.c = a.x) {}\");\n-    testSame(\"a.b = a.c = a.x; if (a.c) {}\");\n-    testSame(\"a.b = a.c = a.x; if (a.b) {}\");\n-  }\n-\n-  public void testBug2072343() {\n-    testSame(\"a = a.x;a = a.x\");\n-    testSame(\"a = a.x;b = a.x\");\n-    test(\"b = a.x;a = a.x\", \"a = b = a.x\");\n-    testSame(\"a.x = a;a = a.x\");\n-    testSame(\"a.b = a.b.x;a.b = a.b.x\");\n-    testSame(\"a.y = a.y.x;b = a.y;c = a.y.x\");\n-    test(\"a = a.x;b = a;c = a.x\", \"b = a = a.x;c = a.x\");\n-    test(\"b = a.x;a = b;c = a.x\", \"a = b = a.x;c = a.x\");\n- }\n-\n-  public void testBadCollapseIntoCall() {\n-    // Can't collapse this, because if we did, 'foo' would be called\n-    // in the wrong 'this' context.\n-    testSame(\"this.foo = function() {}; this.foo();\");\n-  }\n-\n-  public void testBadCollapse() {\n-    testSame(\"this.$e$ = []; this.$b$ = null;\");\n-  }\n-\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     return new CollapseVariableDeclarations(compiler);\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ExploitAssignsTest.java\n+/*\n+ * Copyright 2006 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit tests for {@link ExploitAssigns}\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ * @author acleung@google.com (Alan Leung)\n+ */\n+public class ExploitAssignsTest extends CompilerTestCase {\n+\n+  public void testExprExploitationTypes() {\n+    test(\"a = true; b = true\",\n+         \"b = a = true\");\n+    test(\"a = !0; b = !0\",\n+         \"b = a = !0\");\n+    test(\"a = !1; b = !1\",\n+         \"b = a = !1\");\n+    test(\"a = void 0; b = void 0\",\n+         \"b = a = void 0\");\n+    test(\"a = -Infinity; b = -Infinity\",\n+         \"b = a = -Infinity\");\n+  }\n+\n+  public void testExprExploitationTypes2() {\n+    test(\"a = !0; b = !0\",\n+         \"b = a = !0\");\n+  }\n+\n+  public void testExprExploitation() {\n+    test(\"a = null; b = null; var c = b\",\n+         \"var c = b = a = null\");\n+    test(\"a = null; b = null\",\n+         \"b = a = null\");\n+    test(\"a = undefined; b = undefined\",\n+         \"b = a = undefined\");\n+    test(\"a = 0; b = 0\", \"b=a=0\");\n+    test(\"a = 'foo'; b = 'foo'\",\n+         \"b = a = \\\"foo\\\"\");\n+    test(\"a = c; b = c\", \"b=a=c\");\n+\n+    testSame(\"a = 0; b = 1\");\n+    testSame(\"a = \\\"foo\\\"; b = \\\"foox\\\"\");\n+\n+    test(\"a = null; a && b;\", \"(a = null)&&b\");\n+    test(\"a = null; a || b;\", \"(a = null)||b\");\n+\n+    test(\"a = null; a ? b : c;\", \"(a = null) ? b : c\");\n+\n+    test(\"a = null; this.foo = null;\",\n+         \"this.foo = a = null\");\n+    test(\"function f(){ a = null; return null; }\",\n+         \"function f(){return a = null}\");\n+\n+    test(\"a = true; if (a) { foo(); }\",\n+         \"if (a = true) { foo() }\");\n+    test(\"a = true; if (a && a) { foo(); }\",\n+         \"if ((a = true) && a) { foo() }\");\n+    test(\"a = false; if (a) { foo(); }\",\n+         \"if (a = false) { foo() }\");\n+\n+    test(\"a = !0; if (a) { foo(); }\",\n+        \"if (a = !0) { foo() }\");\n+    test(\"a = !0; if (a && a) { foo(); }\",\n+        \"if ((a = !0) && a) { foo() }\");\n+    test(\"a = !1; if (a) { foo(); }\",\n+        \"if (a = !1) { foo() }\");\n+\n+    testSame(\"a = this.foo; a();\");\n+    test(\"a = b; b = a;\",\n+         \"b = a = b\");\n+    testSame(\"a = b; a.c = a\");\n+    test(\"this.foo = null; this.bar = null;\",\n+         \"this.bar = this.foo = null\");\n+    test(\"this.foo = null; this.bar = null; this.baz = this.bar\",\n+         \"this.baz = this.bar = this.foo = null\");\n+    test(\"this.foo = null; a = null;\",\n+         \"a = this.foo = null\");\n+    test(\"this.foo = null; a = this.foo;\",\n+         \"a = this.foo = null\");\n+    test(\"a.b.c=null; a=null;\",\n+         \"a = a.b.c = null\");\n+    testSame(\"a = null; a.b.c = null\");\n+    test(\"(a=b).c = null; this.b = null;\",\n+         \"this.b = (a=b).c = null\");\n+    testSame(\"if(x) a = null; else b = a\");\n+  }\n+\n+  public void testNestedExprExploitation() {\n+    test(\"this.foo = null; this.bar = null; this.baz = null;\",\n+         \"this.baz = this.bar = this.foo = null\");\n+\n+    test(\"a = 3; this.foo = a; this.bar = a; this.baz = 3;\",\n+         \"this.baz = this.bar = this.foo = a = 3\");\n+    test(\"a = 3; this.foo = a; this.bar = this.foo; this.baz = a;\",\n+         \"this.baz = this.bar = this.foo = a = 3\");\n+    test(\"a = 3; this.foo = a; this.bar = 3; this.baz = this.foo;\",\n+         \"this.baz = this.bar = this.foo = a = 3\");\n+    test(\"a = 3; this.foo = a; a = 3; this.bar = 3; \" +\n+         \"a = 3; this.baz = this.foo;\",\n+         \"this.baz = a = this.bar = a = this.foo = a = 3\");\n+\n+    test(\"a = 4; this.foo = a; a = 3; this.bar = 3; \" +\n+         \"a = 3; this.baz = this.foo;\",\n+         \"this.foo = a = 4; a = this.bar = a = 3; this.baz = this.foo\");\n+    test(\"a = 3; this.foo = a; a = 4; this.bar = 3; \" +\n+         \"a = 3; this.baz = this.foo;\",\n+         \"this.foo = a = 3; a = 4; a = this.bar = 3; this.baz = this.foo\");\n+    test(\"a = 3; this.foo = a; a = 3; this.bar = 3; \" +\n+         \"a = 4; this.baz = this.foo;\",\n+         \"this.bar = a = this.foo = a = 3; a = 4; this.baz = this.foo\");\n+  }\n+\n+  public void testBug1840071() {\n+    // Some external properties are implemented as setters. Let's\n+    // make sure that we don't collapse them inappropriately.\n+    test(\"a.b = a.x; if (a.x) {}\", \"if (a.b = a.x) {}\");\n+    testSame(\"a.b = a.x; if (a.b) {}\");\n+    test(\"a.b = a.c = a.x; if (a.x) {}\", \"if (a.b = a.c = a.x) {}\");\n+    testSame(\"a.b = a.c = a.x; if (a.c) {}\");\n+    testSame(\"a.b = a.c = a.x; if (a.b) {}\");\n+  }\n+\n+  public void testBug2072343() {\n+    testSame(\"a = a.x;a = a.x\");\n+    testSame(\"a = a.x;b = a.x\");\n+    test(\"b = a.x;a = a.x\", \"a = b = a.x\");\n+    testSame(\"a.x = a;a = a.x\");\n+    testSame(\"a.b = a.b.x;a.b = a.b.x\");\n+    testSame(\"a.y = a.y.x;b = a.y;c = a.y.x\");\n+    test(\"a = a.x;b = a;c = a.x\", \"b = a = a.x;c = a.x\");\n+    test(\"b = a.x;a = b;c = a.x\", \"a = b = a.x;c = a.x\");\n+ }\n+\n+  public void testBadCollapseIntoCall() {\n+    // Can't collapse this, because if we did, 'foo' would be called\n+    // in the wrong 'this' context.\n+    testSame(\"this.foo = function() {}; this.foo();\");\n+  }\n+\n+  public void testBadCollapse() {\n+    testSame(\"this.$e$ = []; this.$b$ = null;\");\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new PeepholeOptimizationsPass(compiler,new ExploitAssigns());\n+  }\n+}", "timestamp": 1300213108, "metainfo": ""}