{"sha": "5c4ba569a07e89689e482be5a3d3b521f3754f0d", "log": "Update CallGraph to support isAliased() and isExposedToCallOrApply() so it could potentially be used in OptimizeParameters.  R=acleung DELTA=250  (245 added, 0 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=85005   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CallGraph.java\n+++ b/src/com/google/javascript/jscomp/CallGraph.java\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n+import com.google.javascript.jscomp.NameReferenceGraph.Name;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.jscomp.graph.DiGraph;\n     // Depends on createCallsites already being called\n     connectCallsitesToTargets(definitionProvider);\n     \n+    fillInFunctionInformation(definitionProvider);\n+    \n     alreadyRun = true;\n   }\n \n    * If the definitionProvider cannot determine the target of a Callsite,\n    * the Callsite's hasUnknownTarget field is set to true.\n    * \n-   * If the definitionProvider determins that the target of a Callsite\n+   * If the definitionProvider determines that the target of a Callsite\n    * could be an extern-defined function, then the Callsite's hasExternTarget\n    * field is set to true.\n    * \n                 \n                 if (computeBackwardGraph) {\n                   callsitesByTargetingFunction.put(targetFunction, callsite);\n-                }             \n+                }\n               } else {\n                   callsite.hasUnknownTarget = true;                 \n               }\n         }\n       }\n     }\n+  }\n+  \n+  /**\n+   * Fills in function information (such as whether the function is ever\n+   * aliased or whether it is exposed to .call or .apply) using the\n+   * definition provider.\n+   * \n+   * We do this here, rather than when connecting the callgraph, to make sure\n+   * that we have correct information for all functions, rather than just\n+   * functions that are actually called.\n+   */\n+  private void fillInFunctionInformation(DefinitionProvider provider) {\n+    if (useNameReferenceGraph) {\n+      NameReferenceGraph referenceGraph = (NameReferenceGraph) provider;\n+      \n+      for (Function function : getAllFunctions()) {\n+        if (!function.isMain()) {\n+          String functionName = function.getName();\n+          \n+          if (functionName != null) {\n+            Name symbol = referenceGraph.getSymbol(functionName);\n+            updateFunctionForName(function, symbol);\n+          }\n+        }  \n+      }\n+    } else {\n+      SimpleDefinitionFinder finder = (SimpleDefinitionFinder) provider;\n+      \n+      for (DefinitionSite definitionSite : finder.getDefinitionSites()) {\n+        Definition definition = definitionSite.definition;\n+        \n+        Function function = lookupFunctionForDefinition(definition);\n+        \n+        if (function != null) {              \n+          for (UseSite useSite : finder.getUseSites(definition)) {\n+            updateFunctionForUse(function, useSite.node);\n+          }\n+        }                      \n+      }\n+    }\n+  }\n+  \n+  /**\n+   * Updates {@link Function} information (such as whether is is aliased\n+   * or exposed to .apply or .call from a {@link NameReferenceGraph.Name}.\n+   * \n+   * Note: this method may be called multiple times per Function, each time\n+   * with a different name.\n+   */\n+  private void updateFunctionForName(Function function, Name name) {\n+    if (name.isAliased()) {\n+      function.isAliased = true; \n+    }   \n+     \n+    if (name.exposedToCallOrApply()) {\n+      function.isExposedToCallOrApply = true;\n+    }\n+  }\n+  \n+  /**\n+   * Updates {@link Function} information (such as whether is is aliased\n+   * or exposed to .apply or .call based a site where the function is used.\n+   * \n+   * Note: this method may be called multiple times per Function, each time\n+   * with a different useNode.\n+   */\n+  private void updateFunctionForUse(Function function, Node useNode) {\n+    Node useParent = useNode.getParent();\n+    int parentType = useParent.getType();\n+    \n+    if ((parentType == Token.CALL || parentType == Token.NEW)\n+        && useParent.getFirstChild() == useNode) {\n+      // Regular call sites don't count as aliases\n+    } else if (NodeUtil.isGet(useParent)) {\n+      // GET{PROP,ELEM} don't count as aliases\n+      // but we have to check for using them in .call and .apply.\n+      \n+      if (NodeUtil.isGetProp(useParent)) {\n+        Node gramps = useParent.getParent();\n+        if (NodeUtil.isFunctionObjectApply(gramps) ||\n+            NodeUtil.isFunctionObjectCall(gramps)) {\n+          function.isExposedToCallOrApply = true;\n+        }\n+      }\n+    } else {\n+      function.isAliased = true;\n+    }\n+  }\n+  \n+  /**\n+   * Returns a {@link CallGraph.Function} for the passed in {@link Definition}\n+   * or null if the definition isn't for a function.\n+   */\n+  private Function lookupFunctionForDefinition(Definition definition) {\n+    if (definition != null && !definition.isExtern()) {\n+      Node rValue = definition.getRValue();\n+      \n+      if (rValue != null && NodeUtil.isFunction(rValue)) {\n+        Function function = functionsByNode.get(rValue);\n+        Preconditions.checkNotNull(function);\n+        \n+        return function;\n+      }\n+    }\n+    \n+    return null;\n   }\n   \n   /**\n     \n     private Node astNode;\n     \n+    private boolean isAliased = false;\n+    \n+    private boolean isExposedToCallOrApply = false;\n+    \n     private Function(Node functionAstNode) {\n       astNode = functionAstNode;\n     }\n       }\n     }\n   \n-    // TODO(dcc): Add supported for querying whether a function is aliased\n-    // or exported. (If a function is not aliased or exported, then\n-    // getCallsitesPossiblyTargetingFunction() truly contains all possible\n-    // targets that could call the function).\n+    /**\n+     * Returns true if the function is aliased.\n+     */\n+    public boolean isAliased() {\n+      return isAliased;\n+    }\n+    \n+    /**\n+     * Returns true if the function is ever exposed to \".call\" or \".apply\".\n+     */\n+    public boolean isExposedToCallOrApply() {\n+      return isExposedToCallOrApply;\n+    }\n   }\n   \n   /**\n--- a/test/com/google/javascript/jscomp/CallGraphTest.java\n+++ b/test/com/google/javascript/jscomp/CallGraphTest.java\n     assertEquals(1, functionC.getCallsitesInFunction().size());\n   }\n   \n+  public void testFunctionGetIsAliased() { \n+    // Aliased by VAR assignment   \n+    String source =\n+        \"function A(){};\\n\" +\n+        \"var ns = {};\\n\" +\n+        \"ns.B = function() {};\\n\" +\n+        \"var C = function() {}\\n\" +\n+        \"var D = function() {}\\n\" +\n+        \"var aliasA = A;\\n\" +\n+        \"var aliasB = ns.B;\\n\" +\n+        \"var aliasC = C;\\n\" +\n+        \"D();\";\n+      \n+    compileAndRunForward(source);\n+  \n+    assertFunctionAliased(true, \"A\");\n+    assertFunctionAliased(true, \"ns.B\");\n+    assertFunctionAliased(true, \"C\");\n+    assertFunctionAliased(false, \"D\");\n+    \n+    // Aliased by normal assignment   \n+    source =\n+        \"function A(){};\\n\" +\n+        \"var ns = {};\\n\" +\n+        \"ns.B = function() {};\\n\" +\n+        \"var C = function() {}\\n\" +\n+        \"ns.D = function() {}\\n\" +\n+        \"var aliasA;\\n\" +\n+        \"aliasA = A;\\n\" +\n+        \"var aliasB = {};\\n\" +\n+        \"aliasB.foo = ns.B;\\n\" +\n+        \"var aliasC;\\n\" +\n+        \"aliasC = C;\\n\" +\n+        \"ns.D();\";\n+      \n+    compileAndRunForward(source);\n+  \n+    assertFunctionAliased(true, \"A\");\n+    assertFunctionAliased(true, \"ns.B\");\n+    assertFunctionAliased(true, \"C\");\n+    assertFunctionAliased(false, \"ns.D\");\n+    \n+    // Aliased by passing as parameter  \n+    source =\n+        \"function A(){};\\n\" +\n+        \"var ns = {};\\n\" +\n+        \"ns.B = function() {};\\n\" +\n+        \"var C = function() {}\\n\" +\n+        \"function D() {}\\n\" +\n+        \"var foo = function(a) {}\\n\" +\n+        \"foo(A);\\n\" +\n+        \"foo(ns.B)\\n\" +\n+        \"foo(C);\\n\" +\n+        \"D();\";\n+      \n+    compileAndRunForward(source);\n+  \n+    assertFunctionAliased(true, \"A\");\n+    assertFunctionAliased(true, \"ns.B\");\n+    assertFunctionAliased(true, \"C\");\n+    assertFunctionAliased(false, \"D\");\n+    \n+    // Not aliased by being target of call\n+    source =\n+        \"function A(){};\\n\" +\n+        \"var ns = {};\\n\" +\n+        \"ns.B = function() {};\\n\" +\n+        \"var C = function() {}\\n\" +\n+        \"A();\\n\" +\n+        \"ns.B();\\n\" +\n+        \"C();\\n\";\n+        \n+    compileAndRunForward(source);\n+    \n+    assertFunctionAliased(false, \"A\");\n+    assertFunctionAliased(false, \"ns.B\");\n+    assertFunctionAliased(false, \"C\");\n+    \n+    // Not aliased by GET{PROP,ELEM}\n+    source =\n+        \"function A(){};\\n\" +\n+        \"var ns = {};\\n\" +\n+        \"ns.B = function() {};\\n\" +\n+        \"var C = function() {}\\n\" +\n+        \"A.foo;\\n\" +\n+        \"ns.B.prototype;\\n\" +\n+        \"C[0];\\n\";\n+        \n+    compileAndRunForward(source);\n+    \n+    assertFunctionAliased(false, \"A\");\n+    assertFunctionAliased(false, \"ns.B\");\n+    assertFunctionAliased(false, \"C\");\n+  }\n+   \n+  public void testFunctionGetIsExposedToCallOrApply() { \n+    // Exposed to call\n+    String source =\n+        \"function A(){};\\n\" +\n+        \"function B(){};\\n\" +\n+        \"function C(){};\\n\" +\n+        \"var x;\\n\" +\n+        \"A.call(x);\\n\" +\n+        \"B.apply(x);\\n\" +\n+        \"C();\\n\";\n+    \n+    CallGraph callGraph = compileAndRunForward(source);\n+  \n+    Function functionA = callGraph.getUniqueFunctionWithName(\"A\");\n+    Function functionB = callGraph.getUniqueFunctionWithName(\"B\");\n+    Function functionC = callGraph.getUniqueFunctionWithName(\"C\");\n+    \n+    assertTrue(functionA.isExposedToCallOrApply());\n+    assertTrue(functionB.isExposedToCallOrApply());\n+    assertFalse(functionC.isExposedToCallOrApply());\n+  }\n+  \n   public void testCallsiteGetAstNode() {\n     String source =\n       \"function A(){B()};\\n\" +\n     return result;\n   }\n  \n+  private void assertFunctionAliased(boolean aliased, String name) {\n+    Function function = currentProcessor.getUniqueFunctionWithName(name);\n+    \n+    assertEquals(aliased, function.isAliased());\n+  }\n+  \n   private CallGraph compileAndRunBackward(String js) {\n     return compileAndRun(SHARED_EXTERNS, js, false, true);\n   }", "timestamp": 1280951098, "metainfo": ""}