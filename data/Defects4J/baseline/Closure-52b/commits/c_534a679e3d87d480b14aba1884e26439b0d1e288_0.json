{"sha": "534a679e3d87d480b14aba1884e26439b0d1e288", "log": "First crack at a pass to process goog.tweak calls. This checks a bunch of error cases, but does not yet have any logic to strip out the calls nor to define alternative default values.  R=nicksantos DELTA=588  (570 added, 1 deleted, 17 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=222   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n           new DiagnosticGroup(TypeValidator.INVALID_CAST));\n \n   public static DiagnosticGroup FILEOVERVIEW_JSDOC =\n-    DiagnosticGroups.registerGroup(\"fileoverviewTags\",\n+      DiagnosticGroups.registerGroup(\"fileoverviewTags\",\n           new DiagnosticGroup(RhinoErrorReporter.EXTRA_FILEOVERVIEW));\n \n   public static DiagnosticGroup STRICT_MODULE_DEP_CHECK =\n-    DiagnosticGroups.registerGroup(\"strictModuleDepCheck\",\n+      DiagnosticGroups.registerGroup(\"strictModuleDepCheck\",\n           new DiagnosticGroup(VarCheck.STRICT_MODULE_DEP_ERROR,\n                               CheckGlobalNames.STRICT_MODULE_DEP_QNAME));\n \n   public static DiagnosticGroup EXTERNS_VALIDATION =\n-    DiagnosticGroups.registerGroup(\"externsValidation\",\n+      DiagnosticGroups.registerGroup(\"externsValidation\",\n           new DiagnosticGroup(VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR,\n                               VarCheck.UNDEFINED_EXTERN_VAR_ERROR));\n \n   public static DiagnosticGroup AMBIGUOUS_FUNCTION_DECL =\n-    DiagnosticGroups.registerGroup(\"ambiguousFunctionDecl\",\n-          new DiagnosticGroup(VariableReferenceCheck.AMBIGUOUS_FUNCTION_DECL));  \n+      DiagnosticGroups.registerGroup(\"ambiguousFunctionDecl\",\n+          new DiagnosticGroup(VariableReferenceCheck.AMBIGUOUS_FUNCTION_DECL));\n \n   public static DiagnosticGroup UNKNOWN_DEFINES =\n-    DiagnosticGroups.registerGroup(\"unknownDefines\",\n+      DiagnosticGroups.registerGroup(\"unknownDefines\",\n           new DiagnosticGroup(ProcessDefines.UNKNOWN_DEFINE_WARNING));\n \n+  public static DiagnosticGroup TWEAKS =\n+      DiagnosticGroups.registerGroup(\"tweakValidation\",\n+          new DiagnosticGroup(\n+              ProcessTweaks.TWEAK_WRONG_GETTER_TYPE_WARNING,\n+              ProcessTweaks.UNKNOWN_TWEAK_WARNING));\n+\n   public static DiagnosticGroup MISSING_PROPERTIES =\n-    DiagnosticGroups.registerGroup(\"missingProperties\",\n+      DiagnosticGroups.registerGroup(\"missingProperties\",\n           new DiagnosticGroup(TypeCheck.INEXISTENT_PROPERTY));\n \n   public static DiagnosticGroup UNDEFINED_VARIABLES =\n           new DiagnosticGroup(VarCheck.UNDEFINED_VAR_ERROR));\n \n   public static DiagnosticGroup CHECK_REGEXP =\n-    DiagnosticGroups.registerGroup(\"checkRegExp\",\n-        new DiagnosticGroup(\n-            CheckRegExp.REGEXP_REFERENCE));\n+      DiagnosticGroups.registerGroup(\"checkRegExp\",\n+          new DiagnosticGroup(\n+              CheckRegExp.REGEXP_REFERENCE));\n \n   public static DiagnosticGroup CHECK_TYPES =\n       DiagnosticGroups.registerGroup(\"checkTypes\",\n               TypeCheck.ALL_DIAGNOSTICS));\n \n   public static DiagnosticGroup CHECK_VARIABLES =\n-    DiagnosticGroups.registerGroup(\"checkVars\",\n-        new DiagnosticGroup(\n-            VarCheck.UNDEFINED_VAR_ERROR,\n-            SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR));\n+      DiagnosticGroups.registerGroup(\"checkVars\",\n+          new DiagnosticGroup(\n+              VarCheck.UNDEFINED_VAR_ERROR,\n+              SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR));\n \n   public static DiagnosticGroup CHECK_USELESS_CODE =\n-    DiagnosticGroups.registerGroup(\"uselessCode\",\n-        new DiagnosticGroup(\n-            CheckSideEffects.USELESS_CODE_ERROR,\n-            CheckUnreachableCode.UNREACHABLE_CODE)); \n+      DiagnosticGroups.registerGroup(\"uselessCode\",\n+          new DiagnosticGroup(\n+              CheckSideEffects.USELESS_CODE_ERROR,\n+              CheckUnreachableCode.UNREACHABLE_CODE)); \n \n   /**\n    * Adds warning levels by name.\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ProcessTweaks.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.CharMatcher;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Process goog.tweak primitives. Checks that:\n+ * <ul>\n+ * <li>parameters to goog.tweak.register* are literals of the correct type.\n+ * <li>the parameter to goog.tweak.get* is a string literal.\n+ * <li>parameters to goog.tweak.overrideDefaultValue are literals of the correct\n+ *     type.\n+ * <li>tweak IDs passed to goog.tweak.get* and goog.tweak.overrideDefaultValue\n+ *     correspond to registered tweaks.\n+ * <li>all calls to goog.tweak.register* and goog.tweak.overrideDefaultValue are\n+ *     within the top-level context.\n+ * <li>each tweak is registered only once.\n+ * <li>calls to goog.tweak.overrideDefaultValue occur before the call to the\n+ *     corresponding goog.tweak.register* function.\n+ * </ul>\n+ * @author agrieve@google.com (Andrew Grieve)\n+ */\n+class ProcessTweaks implements CompilerPass {\n+\n+  private final AbstractCompiler compiler;\n+  private static final CharMatcher ID_MATCHER = CharMatcher.inRange('a', 'z').\n+      or(CharMatcher.inRange('A', 'Z')).or(CharMatcher.anyOf(\"0123456789_.\"));\n+\n+  // Warnings and Errors.\n+  static final DiagnosticType UNKNOWN_TWEAK_WARNING =\n+      DiagnosticType.warning(\n+          \"JSC_UNKNOWN_TWEAK_WARNING\",\n+          \"no tweak registered with ID {0}\");\n+\n+  static final DiagnosticType TWEAK_MULTIPLY_REGISTERED_ERROR =\n+      DiagnosticType.error(\n+          \"JSC_TWEAK_MULTIPLY_REGISTERED_ERROR\",\n+          \"Tweak {0} has already been registered.\");\n+\n+  static final DiagnosticType NON_LITERAL_TWEAK_ID_ERROR =\n+      DiagnosticType.error(\n+          \"JSC_NON_LITERAL_TWEAK_ID_ERROR\",\n+          \"tweak ID must be a string literal\");\n+  \n+  static final DiagnosticType INVALID_TWEAK_DEFAULT_VALUE_ERROR =\n+      DiagnosticType.error(\n+          \"JSC_INVALID_TWEAK_DEFAULT_VALUE_ERROR\",\n+          \"tweak registered with {0} must have a default value that is a \" +\n+          \"literal of type {0}\");\n+\n+  static final DiagnosticType NON_GLOBAL_TWEAK_INIT_ERROR =\n+      DiagnosticType.error(\n+          \"JSC_NON_GLOBAL_TWEAK_INIT_ERROR\",\n+          \"tweak declaration {0} must occur in the global scope\");\n+  \n+  static final DiagnosticType TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR =\n+      DiagnosticType.error(\n+          \"JSC_TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR\",\n+          \"Cannot override the default value of tweak {0} after it has been \" +\n+          \"registered\");\n+  \n+  static final DiagnosticType TWEAK_WRONG_GETTER_TYPE_WARNING =\n+      DiagnosticType.warning(\n+          \"JSC_TWEAK_WRONG_GETTER_TYPE_WARNING\",\n+          \"tweak getter function {0} used for tweak registered using {0}\");\n+\n+  static final DiagnosticType INVALID_TWEAK_ID_ERROR =\n+      DiagnosticType.error(\n+          \"JSC_INVALID_TWEAK_ID_ERROR\",\n+          \"tweak ID contains illegal characters. Only letters, numbers, _ \" +\n+          \"and . are allowed\");\n+\n+  /**\n+   * An enum of goog.tweak functions.\n+   */\n+  private static enum TweakFunction {\n+    REGISTER_BOOLEAN(\"goog.tweak.registerBoolean\", \"boolean\", Token.TRUE,\n+        Token.FALSE),\n+    REGISTER_NUMBER(\"goog.tweak.registerNumber\", \"number\", Token.NUMBER),\n+    REGISTER_STRING(\"goog.tweak.registerString\", \"string\", Token.STRING),\n+    OVERRIDE_DEFAULT_VALUE(\"goog.tweak.overrideDefaultValue\"),\n+    GET_BOOLEAN(\"goog.tweak.getBoolean\", REGISTER_BOOLEAN),\n+    GET_NUMBER(\"goog.tweak.getNumber\", REGISTER_NUMBER),\n+    GET_STRING(\"goog.tweak.getString\", REGISTER_STRING);\n+\n+    final String name;\n+    final String expectedTypeName;\n+    final int validNodeTypeA;\n+    final int validNodeTypeB;\n+    final TweakFunction registerFunction;\n+    \n+    TweakFunction(String name) {\n+      this(name, null, Token.ERROR, Token.ERROR, null);\n+    }\n+    \n+    TweakFunction(String name, String expectedTypeName,\n+        int validNodeTypeA) {\n+      this(name, expectedTypeName, validNodeTypeA, Token.ERROR, null);\n+    }\n+\n+    TweakFunction(String name, String expectedTypeName,\n+        int validNodeTypeA, int validNodeTypeB) {\n+      this(name, expectedTypeName, validNodeTypeA, validNodeTypeB, null);\n+    }\n+\n+    TweakFunction(String name, TweakFunction registerFunction) {\n+      this(name, null, Token.ERROR, Token.ERROR, registerFunction);\n+    }\n+\n+    TweakFunction(String name, String expectedTypeName,\n+        int validNodeTypeA, int validNodeTypeB,\n+        TweakFunction registerFunction) {\n+      this.name = name;\n+      this.expectedTypeName = expectedTypeName;\n+      this.validNodeTypeA = validNodeTypeA;\n+      this.validNodeTypeB = validNodeTypeB;\n+      this.registerFunction = registerFunction;\n+    }\n+    \n+    boolean isValidNodeType(int type) {\n+      return type == validNodeTypeA || type == validNodeTypeB;\n+    }\n+    \n+    boolean isCorrectRegisterFunction(TweakFunction registerFunction) {\n+      Preconditions.checkNotNull(registerFunction);\n+      return this.registerFunction == registerFunction;\n+    }\n+    \n+    boolean isGetterFunction() {\n+      return registerFunction != null;\n+    }\n+\n+    String getName() {\n+      return name;\n+    }\n+\n+    String getExpectedTypeName() {\n+      return expectedTypeName;\n+    }\n+  }\n+  \n+  // A map of function name -> TweakFunction.\n+  private static final Map<String, TweakFunction> TWEAK_FUNCTIONS_MAP;\n+  static {\n+    TWEAK_FUNCTIONS_MAP = Maps.newHashMap();\n+    for (TweakFunction func : TweakFunction.values()) {\n+      TWEAK_FUNCTIONS_MAP.put(func.getName(), func);\n+    }\n+  }\n+          \n+  ProcessTweaks(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    collectTweaks(root);\n+  }\n+\n+  /**\n+   * Finds all calls to goog.tweak functions and emits warnings/errors if any\n+   * of the calls have issues.\n+   * @return A map of {@link TweakInfo} structures, keyed by tweak ID.\n+   */\n+  private Map<String, TweakInfo> collectTweaks(Node root) {\n+    CollectTweaks pass = new CollectTweaks();\n+    NodeTraversal.traverse(compiler, root, pass);\n+    \n+    Map<String, TweakInfo> tweakInfos = pass.allTweaks;\n+    for (TweakInfo tweakInfo: tweakInfos.values()) {\n+      tweakInfo.emitAllWarnings();\n+    }\n+    return tweakInfos;\n+  }\n+\n+  /**\n+   * Processes all calls to goog.tweak functions.\n+   */\n+  private final class CollectTweaks extends AbstractPostOrderCallback {\n+    final Map<String, TweakInfo> allTweaks = Maps.newHashMap();\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() != Token.CALL) {\n+        return;\n+      }\n+\n+      String callName = n.getFirstChild().getQualifiedName();\n+      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n+      if (tweakFunc == null) {\n+        return;\n+      }\n+\n+      // Ensure the first parameter (the tweak ID) is a string literal.\n+      Node tweakIdNode = n.getFirstChild().getNext();\n+      if (tweakIdNode.getType() != Token.STRING) {\n+        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n+        return;\n+      }\n+      String tweakId = tweakIdNode.getString();\n+      \n+      // Make sure there is a TweakInfo structure for it.\n+      TweakInfo tweakInfo = allTweaks.get(tweakId);\n+      if (tweakInfo == null) {\n+        tweakInfo = new TweakInfo(tweakId);\n+        allTweaks.put(tweakId, tweakInfo);\n+      }\n+      \n+      switch (tweakFunc) {\n+        case REGISTER_BOOLEAN:\n+        case REGISTER_NUMBER:\n+        case REGISTER_STRING:\n+          // Ensure the ID contains only valid characters.\n+          if (!ID_MATCHER.matchesAllOf(tweakId)) {\n+            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n+          }\n+\n+          // Ensure tweaks are registered in the global scope.\n+          if (!t.inGlobalScope()) {\n+            compiler.report(\n+                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n+            break;\n+          }\n+          \n+          // Ensure tweaks are registered only once.\n+          if (tweakInfo.isRegistered()) {\n+            compiler.report(\n+                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n+            break;\n+          }\n+          \n+          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n+          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n+              tweakDefaultValueNode);\n+          break;\n+        case OVERRIDE_DEFAULT_VALUE:\n+          // Ensure tweaks overrides occur in the global scope.\n+          if (!t.inGlobalScope()) {\n+            compiler.report(\n+                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n+            break;\n+          }\n+          // Ensure tweak overrides occur before the tweak is registered.\n+          if (tweakInfo.isRegistered()) {\n+            compiler.report(\n+                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n+            break;\n+          }\n+\n+          tweakDefaultValueNode = tweakIdNode.getNext();\n+          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n+              tweakDefaultValueNode);\n+          break;\n+        case GET_BOOLEAN:\n+        case GET_NUMBER:\n+        case GET_STRING:\n+          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Holds information about a call to a goog.tweak function.\n+   */\n+  private static final class TweakFunctionCall {\n+    final String sourceName;\n+    final TweakFunction tweakFunc;\n+    final Node callNode;\n+    final Node valueNode;\n+\n+    TweakFunctionCall(String sourceName, TweakFunction tweakFunc,\n+        Node callNode) {\n+      this(sourceName, tweakFunc, callNode, null);\n+    }\n+    \n+    TweakFunctionCall(String sourceName, TweakFunction tweakFunc, Node callNode,\n+        Node valueNode) {\n+      this.sourceName = sourceName;\n+      this.callNode = callNode;\n+      this.tweakFunc = tweakFunc;\n+      this.valueNode = valueNode;\n+    }\n+    \n+    Node getIdNode() {\n+      return callNode.getFirstChild().getNext();\n+    }\n+  }\n+  \n+  /**\n+   * Stores information about a single tweak.\n+   */\n+  private final class TweakInfo {\n+    final String tweakId;\n+    final List<TweakFunctionCall> functionCalls;\n+    TweakFunctionCall registerCall;\n+    Node defaultValueNode;\n+    \n+    TweakInfo(String tweakId) {\n+      this.tweakId = tweakId;\n+      functionCalls = Lists.newArrayList();\n+    }\n+    \n+    /**\n+     * If this tweak is registered, then looks for type warnings in default\n+     * value parameters and getter functions. If it is not registered, emits an\n+     * error for each function call. \n+     */\n+    void emitAllWarnings() {\n+      if (isRegistered()) {\n+        emitAllTypeWarnings();\n+      } else {\n+        emitUnknownTweakErrors();\n+      }\n+    }\n+\n+    /**\n+     * Emits a warning for each default value parameter that has the wrong type\n+     * and for each getter function that was used for the wrong type of tweak.\n+     */\n+    void emitAllTypeWarnings() {\n+      for (TweakFunctionCall call : functionCalls) {\n+        Node valueNode = call.valueNode;\n+        TweakFunction tweakFunc = call.tweakFunc;\n+        TweakFunction registerFunc = registerCall.tweakFunc;\n+        if (valueNode != null) {\n+          // For register* and overrideDefaultValue calls, ensure the default  \n+          // value is a literal of the correct type.\n+          if (!registerFunc.isValidNodeType(valueNode.getType())) {\n+            compiler.report(JSError.make(call.sourceName,\n+                valueNode, INVALID_TWEAK_DEFAULT_VALUE_ERROR,\n+                registerFunc.getName(),\n+                registerFunc.getExpectedTypeName()));\n+          }\n+        } else if (tweakFunc.isGetterFunction()) {\n+          // For getter calls, ensure the correct getter was used.\n+          if (!tweakFunc.isCorrectRegisterFunction(registerFunc)) {\n+            compiler.report(JSError.make(call.sourceName,\n+                call.callNode, TWEAK_WRONG_GETTER_TYPE_WARNING,\n+                tweakFunc.getName(), registerFunc.getName()));\n+          }\n+        }\n+      }\n+    }\n+    \n+    /**\n+     * Emits an error for each function call that was found.\n+     */\n+    void emitUnknownTweakErrors() {\n+      for (TweakFunctionCall call : functionCalls) {\n+        compiler.report(JSError.make(call.sourceName,\n+            call.getIdNode(), UNKNOWN_TWEAK_WARNING, tweakId));\n+      }\n+    }\n+\n+    void addRegisterCall(String sourceName, TweakFunction tweakFunc,\n+        Node callNode, Node defaultValueNode) {\n+      registerCall = new TweakFunctionCall(sourceName, tweakFunc, callNode,\n+          defaultValueNode);\n+      functionCalls.add(registerCall);\n+      if (this.defaultValueNode == null) {\n+        this.defaultValueNode = defaultValueNode;\n+      }\n+    }\n+    \n+    void addOverrideDefaultValueCall(String sourceName,\n+        TweakFunction tweakFunc, Node callNode, Node defaultValueNode) {\n+      functionCalls.add(new TweakFunctionCall(sourceName, tweakFunc, callNode,\n+          defaultValueNode));\n+      this.defaultValueNode = defaultValueNode;\n+    }\n+    \n+    void addGetterCall(String sourceName, TweakFunction tweakFunc,\n+        Node callNode) {\n+      functionCalls.add(new TweakFunctionCall(sourceName, tweakFunc, callNode));\n+    }\n+\n+    boolean isRegistered() {\n+      return registerCall != null;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ProcessTweaksTest.java\n+/*\n+ * Copyright 2010 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * @author agrieve@google.com (Andrew Grieve)\n+ */\n+public class ProcessTweaksTest extends CompilerTestCase {\n+\n+  public ProcessTweaksTest() {\n+    super(\"var externMethod;\");\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new ProcessTweaks(compiler);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    // Only do one repetition, so that we can make sure the first pass keeps\n+    // GlobalNamespace up to date.\n+    return 1;\n+  }\n+\n+  public void testBasicTweak1() {\n+    testSame(\"goog.tweak.registerBoolean('Foo', 'Description');\" +\n+        \"goog.tweak.getBoolean('Foo')\");\n+  }\n+\n+  public void testBasicTweak2() {\n+    testSame(\"goog.tweak.registerString('Foo', 'Description');\" +\n+        \"goog.tweak.getString('Foo')\");\n+  }\n+\n+  public void testBasicTweak3() {\n+    testSame(\"goog.tweak.registerNumber('Foo', 'Description');\" +\n+        \"goog.tweak.getNumber('Foo')\");\n+  }\n+\n+  public void testBasicTweak4() {\n+    testSame(\"goog.tweak.registerButton('Foo', 'Description', function() {})\");\n+  }\n+\n+  public void testBasicTweak5() {\n+    testSame(\"goog.tweak.registerBoolean('A.b_7', 'Description', true, \" +\n+        \"{ requiresRestart:false })\");\n+  }\n+\n+  public void testBasicTweak6() {\n+    testSame(\"var opts = { requiresRestart:false };\" +\n+        \"goog.tweak.registerBoolean('Foo', 'Description', true, opts)\");\n+  }\n+\n+  public void testNonLiteralId1() {\n+    test(\"goog.tweak.registerBoolean(3, 'Description')\", null,\n+         ProcessTweaks.NON_LITERAL_TWEAK_ID_ERROR);\n+  }\n+\n+  public void testNonLiteralId2() {\n+    test(\"goog.tweak.getBoolean('a' + 'b')\", null,\n+         ProcessTweaks.NON_LITERAL_TWEAK_ID_ERROR);\n+  }\n+  \n+  public void testNonLiteralId3() {\n+    test(\"var CONST = 'foo'; goog.tweak.overrideDefaultValue(CONST, 3)\", null,\n+        ProcessTweaks.NON_LITERAL_TWEAK_ID_ERROR);\n+  }\n+\n+  public void testInvalidId() {\n+    test(\"goog.tweak.registerBoolean('Some ID', 'a')\", null,\n+        ProcessTweaks.INVALID_TWEAK_ID_ERROR);\n+  }\n+  \n+  public void testInvalidDefaultValue1() {\n+    test(\"var val = true; goog.tweak.registerBoolean('Foo', 'desc', val)\", null,\n+         ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_ERROR);\n+  }\n+  \n+  public void testInvalidDefaultValue2() {\n+    test(\"goog.tweak.overrideDefaultValue('Foo', 3 + 1);\" +\n+        \"goog.tweak.registerNumber('Foo', 'desc')\", null,\n+        ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_ERROR);\n+  }\n+\n+  public void testUnknownGetString() {\n+    testSame(\"goog.tweak.getString('huh')\",\n+        ProcessTweaks.UNKNOWN_TWEAK_WARNING);\n+  }\n+  \n+  public void testUnknownGetNumber() {\n+    testSame(\"goog.tweak.getNumber('huh')\",\n+        ProcessTweaks.UNKNOWN_TWEAK_WARNING);\n+  }\n+  \n+  public void testUnknownGetBoolean() {\n+    testSame(\"goog.tweak.getBoolean('huh')\",\n+        ProcessTweaks.UNKNOWN_TWEAK_WARNING);\n+  }\n+\n+  public void testUnknownOverride() {\n+    testSame(\"goog.tweak.overrideDefaultValue('huh', 'val')\",\n+        ProcessTweaks.UNKNOWN_TWEAK_WARNING);\n+  }\n+\n+  public void testDuplicateTweak() {\n+    test(\"goog.tweak.registerBoolean('TweakA', 'desc');\" +\n+        \"goog.tweak.registerBoolean('TweakA', 'desc')\", null,\n+        ProcessTweaks.TWEAK_MULTIPLY_REGISTERED_ERROR);\n+  }\n+\n+  public void testOverrideAfterRegister() {\n+    test(\"goog.tweak.registerBoolean('TweakA', 'desc');\" +\n+        \"goog.tweak.overrideDefaultValue('TweakA', 'val')\",\n+         null, ProcessTweaks.TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR);\n+  }\n+\n+  public void testRegisterInNonGlobalScope() {\n+    test(\"function foo() {goog.tweak.registerBoolean('TweakA', 'desc');};\",\n+        null, ProcessTweaks.NON_GLOBAL_TWEAK_INIT_ERROR);\n+  }\n+\n+  public void testWrongGetter1() {\n+    testSame(\"goog.tweak.registerBoolean('TweakA', 'desc');\" +\n+        \"goog.tweak.getString('TweakA')\",\n+        ProcessTweaks.TWEAK_WRONG_GETTER_TYPE_WARNING);\n+  }\n+  \n+  public void testWrongGetter2() {\n+    testSame(\"goog.tweak.registerString('TweakA', 'desc');\" +\n+        \"goog.tweak.getNumber('TweakA')\",\n+        ProcessTweaks.TWEAK_WRONG_GETTER_TYPE_WARNING);\n+  }\n+  \n+  public void testWrongGetter3() {\n+    testSame(\"goog.tweak.registerNumber('TweakA', 'desc');\" +\n+        \"goog.tweak.getBoolean('TweakA')\",\n+        ProcessTweaks.TWEAK_WRONG_GETTER_TYPE_WARNING);\n+  }\n+\n+  public void testWithNoTweaks() {\n+    testSame(\"var DEF=true;var x={};x.foo={}\");\n+  }\n+}", "timestamp": 1294418478, "metainfo": ""}