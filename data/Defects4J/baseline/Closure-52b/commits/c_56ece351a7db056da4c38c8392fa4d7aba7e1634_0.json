{"sha": "56ece351a7db056da4c38c8392fa4d7aba7e1634", "log": "Add a new placeholder for module wrappers  R=zhuyi DELTA=55  (39 added, 6 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3298   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n   private Function<Integer, Boolean> exitCodeReceiverForTesting = null;\n   private Map<String, String> rootRelativePathsMap = null;\n \n+  private Map<String, String> parsedModuleWrappers = null;\n+\n   // Bookkeeping to measure optimal phase orderings.\n   private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n \n     return wrappers;\n   }\n \n+  private String getModuleOutputFileName(JSModule m) {\n+    return config.moduleOutputPathPrefix + m.getName() + \".js\";\n+  }\n+\n+  @VisibleForTesting\n+  void writeModuleOutput(Appendable out, JSModule m)\n+      throws FlagUsageException, IOException {\n+    if (parsedModuleWrappers == null) {\n+      parsedModuleWrappers = parseModuleWrappers(\n+          config.moduleWrapper,\n+          Lists.newArrayList(compiler.getModuleGraph().getAllModules()));\n+    }\n+\n+    String fileName = getModuleOutputFileName(m);\n+    String baseName = new File(fileName).getName();\n+    writeOutput(out, compiler, compiler.toSource(m),\n+        parsedModuleWrappers.get(m.getName()).replace(\"%basename%\", baseName),\n+        \"%s\");\n+  }\n+\n   /**\n    * Writes code to an output stream, optionally wrapping it in an arbitrary\n    * wrapper that contains a placeholder where the code should be inserted.\n         // Output the source map if requested.\n         outputSourceMap(options, options.jsOutputFile);\n       } else {\n-        String moduleFilePrefix = config.moduleOutputPathPrefix;\n-        maybeCreateDirsForPath(moduleFilePrefix);\n-        Map<String, String> moduleWrappers =\n-            parseModuleWrappers(config.moduleWrapper, modules);\n+        parsedModuleWrappers = parseModuleWrappers(config.moduleWrapper, modules);\n+        maybeCreateDirsForPath(config.moduleOutputPathPrefix);\n \n         // If the source map path is in fact a pattern for each\n         // module, create a stream per-module. Otherwise, create\n             mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m));\n           }\n \n-          Writer writer = fileNameToOutputWriter(\n-              moduleFilePrefix + m.getName() + \".js\");\n+          Writer writer = fileNameToOutputWriter(getModuleOutputFileName(m));\n \n           if (options.sourceMapOutputPath != null) {\n             compiler.getSourceMap().reset();\n           }\n \n-          writeOutput(writer, compiler, compiler.toSource(m),\n-              moduleWrappers.get(m.getName()), \"%s\");\n+          writeModuleOutput(writer, m);\n \n           if (options.sourceMapOutputPath != null) {\n             compiler.getSourceMap().appendTo(mapOut, m.getName());\n     private final List<String> moduleWrapper = Lists.newArrayList();\n \n     /**\n-     * An output wrapper for a javascript module (optional).\n-     * The format is <name>:<wrapper>. The module name must correspond\n-     * with a module specified using --module. The wrapper must\n-     * contain %s as the code placeholder\n+     * An output wrapper for a javascript module (optional). See the flag\n+     * description for formatting requirements.\n      */\n     CommandLineConfig setModuleWrapper(List<String> moduleWrapper) {\n       this.moduleWrapper.clear();\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n         usage = \"An output wrapper for a javascript module (optional). \"\n         + \"The format is <name>:<wrapper>. The module name must correspond \"\n         + \"with a module specified using --module. The wrapper must \"\n-        + \"contain %s as the code placeholder\")\n+        + \"contain %s as the code placeholder. The %basename% placeholder can \"\n+        + \"also be used to substitute the base name of the module output file.\")\n     private List<String> module_wrapper = Lists.newArrayList();\n \n     @Option(name = \"--module_output_path_prefix\",\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n         lastCompiler.getOptions().sourceMapFormat);\n   }\n \n+  public void testModuleWrapperBaseNameExpansion() throws Exception {\n+    useModules = ModulePattern.CHAIN;\n+    args.add(\"--module_wrapper=m0:%s // %basename%\");\n+    testSame(new String[] {\n+      \"var x = 3;\",\n+      \"var y = 4;\"\n+    });\n+\n+    StringBuilder builder = new StringBuilder();\n+    lastCommandLineRunner.writeModuleOutput(\n+        builder,\n+        lastCompiler.getModuleGraph().getRootModule());\n+    assertEquals(\"var x=3; // m0.js\\n\", builder.toString());\n+  }\n+\n   public void testCharSetExpansion() {\n     testSame(\"\");\n     assertEquals(\"US-ASCII\", lastCompiler.getOptions().outputCharset);\n       args.add(\"/path/to/input\" + i + \".js\");\n       if (useModules == ModulePattern.CHAIN) {\n         args.add(\"--module\");\n-        args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n+        args.add(\"m\" + i + \":1\" + (i > 0 ? (\":m\" + (i - 1)) : \"\"));\n       } else if (useModules == ModulePattern.STAR) {\n         args.add(\"--module\");\n-        args.add(\"mod\" + i + \":1\" + (i > 0 ? \":mod0\" : \"\"));\n+        args.add(\"m\" + i + \":1\" + (i > 0 ? \":m0\" : \"\"));\n       }\n     }\n ", "timestamp": 1316542699, "metainfo": ""}