{"sha": "ba0119710233a1be87c10c5e71424dc5922cc627", "log": "Don't inline alias if \"arguments\" are modified or escaped. Fixes issue 378  R=acleung DELTA=235  (228 added, 0 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1089   ", "commit": "\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n     private void doInlinesForScope(NodeTraversal t,\n         Map<Var, ReferenceCollection> referenceMap) {\n \n+      boolean maybeModifiedArguments =\n+          maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);\n       for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n         Var v = it.next();\n \n           // inlining heuristics. See InlineConstantsTest.\n           continue;\n         } else {\n-          inlineNonConstants(v, referenceInfo);\n-        }\n-      }\n+          inlineNonConstants(v, referenceInfo, maybeModifiedArguments);\n+        }\n+      }\n+    }\n+\n+    private boolean maybeEscapedOrModifiedArguments(\n+        Scope scope, Map<Var, ReferenceCollection> referenceMap) {\n+      if (scope.isLocal()) {\n+        Var arguments = scope.getArgumentsVar();\n+        ReferenceCollection refs = referenceMap.get(arguments);\n+        if (refs != null && !refs.references.isEmpty()) {\n+          for (Reference ref : refs.references) {\n+            Node refNode = ref.getNameNode();\n+            Node refParent = ref.getParent();\n+            // Any reference that is not a read of the arguments property\n+            // consider a escape of the arguments object.\n+            if (!(NodeUtil.isGet(refParent)\n+                && refNode == ref.getParent().getFirstChild()\n+                && !isLValue(refParent))) {\n+              return true;\n+            }\n+          }\n+        }\n+      }\n+      return false;\n+    }\n+\n+    private boolean isLValue(Node n) {\n+      Node parent = n.getParent();\n+      return (parent.getType() == Token.INC\n+          || parent.getType() == Token.DEC\n+          || (NodeUtil.isAssignmentOp(parent)\n+          && parent.getFirstChild() == n));\n     }\n \n     private void inlineNonConstants(\n-        Var v, ReferenceCollection referenceInfo) {\n+        Var v, ReferenceCollection referenceInfo,\n+        boolean maybeModifiedArguments) {\n       int refCount = referenceInfo.references.size();\n       Reference declaration = referenceInfo.references.get(0);\n       Reference init = referenceInfo.getInitializingReference();\n       // inline an alias of it. (If the variable was inlined, then the\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n-      if (!staleVars.contains(v) && referenceInfo.isWellDefined() &&\n+      if (!maybeModifiedArguments &&\n+          !staleVars.contains(v) && referenceInfo.isWellDefined() &&\n           referenceInfo.isAssignedOnceInLifetime()) {\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n    */\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() == Token.NAME) {\n-      Var v = t.getScope().getVar(n.getString());\n+      Var v;\n+      if (n.getString().equals(\"arguments\")) {\n+        v = t.getScope().getArgumentsVar();\n+      } else {\n+        v = t.getScope().getVar(n.getString());\n+      }\n       if (v != null && varFilter.apply(v)) {\n         addReference(t, v,\n             new Reference(n, parent, t, blockStack.peek()));\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n   /** Whether this is a bottom scope for the purposes of type inference. */\n   private final boolean isBottom;\n \n+  private Var arguments;\n+\n   /** Stores info about a variable */\n   public static class Var implements StaticSlot<JSType> {\n     /** name */\n      * based on the value reported by {@code NodeUtil}.\n      */\n     public boolean isConst() {\n-      return NodeUtil.isConstantName(nameNode);\n+      return nameNode != null && NodeUtil.isConstantName(nameNode);\n     }\n \n     /**\n   }\n \n   /**\n+   * A special subclass of Var used to distinguish \"arguments\" in the current\n+   * scope.\n+   */\n+  // TODO(johnlenz): Include this the list of Vars for the scope.\n+  public static class Arguments extends Var {\n+    Arguments(Scope scope) {\n+      super(\n+        false, // no inferred\n+        \"arguments\", // always arguments\n+        null,  // no declaration node\n+        // TODO(johnlenz): provide the type of \"Arguments\".\n+        null,  // no type info\n+        scope,\n+        -1,    // no variable index\n+        null,  // input,\n+        false, // not a define\n+        null   // no jsdoc\n+        );\n+    }\n+\n+    @Override public boolean equals(Object other) {\n+      if (!(other instanceof Arguments)) {\n+        return false;\n+      }\n+\n+      Arguments otherVar = (Arguments) other;\n+      return otherVar.scope.getRootNode() == scope.getRootNode();\n+    }\n+\n+    @Override public int hashCode() {\n+      return System.identityHashCode(this);\n+    }\n+  }\n+\n+  /**\n    * Creates a Scope given the parent Scope and the root node of the scope.\n    * @param parent  The parent Scope. Cannot be null.\n    * @param rootNode  Typically the FUNCTION node.\n   }\n \n   /**\n+   * Get a unique VAR object to represents \"arguments\" within this scope\n+   */\n+  public Var getArgumentsVar() {\n+    if (arguments == null) {\n+      arguments = new Arguments(this);\n+    }\n+    return arguments;\n+  }\n+\n+  /**\n    * Returns true if a variable is declared.\n    */\n   public boolean isDeclared(String name, boolean recurse) {\n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n   public void testInlineNamedFunction() {\n     test(\"function f() {} f();\", \"(function f(){})()\");\n   }\n+\n+  public void testIssue378ModifiedArguments1() {\n+    testSame(\n+        \"function g(callback) {\\n\" +\n+        \"  var f = callback;\\n\" +\n+        \"  arguments[0] = this;\\n\" +\n+        \"  f.apply(this, arguments);\\n\" +\n+        \"}\");\n+  }\n+\n+  public void testIssue378ModifiedArguments2() {\n+    testSame(\n+        \"function g(callback) {\\n\" +\n+        \"  /** @const */\\n\" +\n+        \"  var f = callback;\\n\" +\n+        \"  arguments[0] = this;\\n\" +\n+        \"  f.apply(this, arguments);\\n\" +\n+        \"}\");\n+  }\n+\n+  public void testIssue378EscapedArguments1() {\n+    testSame(\n+        \"function g(callback) {\\n\" +\n+        \"  var f = callback;\\n\" +\n+        \"  h(arguments,this);\\n\" +\n+        \"  f.apply(this, arguments);\\n\" +\n+        \"}\\n\" +\n+        \"function h(a,b) {\\n\" +\n+        \"  a[0] = b;\" +\n+        \"}\");\n+  }\n+\n+  public void testIssue378EscapedArguments2() {\n+    testSame(\n+        \"function g(callback) {\\n\" +\n+        \"  /** @const */\\n\" +\n+        \"  var f = callback;\\n\" +\n+        \"  h(arguments,this);\\n\" +\n+        \"  f.apply(this);\\n\" +\n+        \"}\\n\" +\n+        \"function h(a,b) {\\n\" +\n+        \"  a[0] = b;\" +\n+        \"}\");\n+  }\n+\n+  public void testIssue378EscapedArguments3() {\n+    test(\n+        \"function g(callback) {\\n\" +\n+        \"  var f = callback;\\n\" +\n+        \"  f.apply(this, arguments);\\n\" +\n+        \"}\\n\",\n+        \"function g(callback) {\\n\" +\n+        \"  callback.apply(this, arguments);\\n\" +\n+        \"}\\n\");\n+  }\n+\n+  public void testIssue378EscapedArguments4() {\n+    testSame(\n+        \"function g(callback) {\\n\" +\n+        \"  var f = callback;\\n\" +\n+        \"  h(arguments[0],this);\\n\" +\n+        \"  f.apply(this, arguments);\\n\" +\n+        \"}\\n\" +\n+        \"function h(a,b) {\\n\" +\n+        \"  a[0] = b;\" +\n+        \"}\");\n+  }\n+\n+  public void testIssue378ArgumentsRead1() {\n+    test(\n+        \"function g(callback) {\\n\" +\n+        \"  var f = callback;\\n\" +\n+        \"  var g = arguments[0];\\n\" +\n+        \"  f.apply(this, arguments);\\n\" +\n+        \"}\",\n+        \"function g(callback) {\\n\" +\n+        \"  var g = arguments[0];\\n\" +\n+        \"  callback.apply(this, arguments);\\n\" +\n+        \"}\");\n+  }\n+\n+  public void testIssue378ArgumentsRead2() {\n+    test(\n+        \"function g(callback) {\\n\" +\n+        \"  var f = callback;\\n\" +\n+        \"  h(arguments[0],this);\\n\" +\n+        \"  f.apply(this, arguments[0]);\\n\" +\n+        \"}\\n\" +\n+        \"function h(a,b) {\\n\" +\n+        \"  a[0] = b;\" +\n+        \"}\",\n+        \"function g(callback) {\\n\" +\n+        \"  h(arguments[0],this);\\n\" +\n+        \"  callback.apply(this, arguments[0]);\\n\" +\n+        \"}\\n\" +\n+        \"function h(a,b) {\\n\" +\n+        \"  a[0] = b;\" +\n+        \"}\");\n+  }\n+\n+  public void testArgumentsModifiedInOuterFunction() {\n+    test(\n+      \"function g(callback) {\\n\" +\n+      \"  var f = callback;\\n\" +\n+      \"  arguments[0] = this;\\n\" +\n+      \"  f.apply(this, arguments);\\n\" +\n+      \"  function inner(callback) {\" +\n+      \"    var x = callback;\\n\" +\n+      \"    x.apply(this);\\n\" +\n+      \"  }\" +\n+      \"}\",\n+      \"function g(callback) {\\n\" +\n+      \"  var f = callback;\\n\" +\n+      \"  arguments[0] = this;\\n\" +\n+      \"  f.apply(this, arguments);\\n\" +\n+      \"  function inner(callback) {\" +\n+      \"    callback.apply(this);\\n\" +\n+      \"  }\" +\n+      \"}\");\n+  }\n+\n+  public void testArgumentsModifiedInInnerFunction() {\n+    test(\n+      \"function g(callback) {\\n\" +\n+      \"  var f = callback;\\n\" +\n+      \"  f.apply(this, arguments);\\n\" +\n+      \"  function inner(callback) {\" +\n+      \"    var x = callback;\\n\" +\n+      \"    arguments[0] = this;\\n\" +\n+      \"    x.apply(this);\\n\" +\n+      \"  }\" +\n+      \"}\",\n+      \"function g(callback) {\\n\" +\n+      \"  callback.apply(this, arguments);\\n\" +\n+      \"  function inner(callback) {\" +\n+      \"    var x = callback;\\n\" +\n+      \"    arguments[0] = this;\\n\" +\n+      \"    x.apply(this);\\n\" +\n+      \"  }\" +\n+      \"}\");\n+  }\n+\n }", "timestamp": 1301098606, "metainfo": ""}