{"sha": "530ed0eff3806a9bb9dd6b58d15597f9a91c66a6", "log": "Introduce the concept of local object side-effects.  R=avd DELTA=447  (422 added, 3 deleted, 22 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=242506   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n-import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n import com.google.javascript.rhino.Token;\n \n import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n    * annotations, call sites, and functions that may mutate variables\n    * not defined in the local scope.\n    */\n-  private class FunctionAnalyzer implements Callback {\n+  private class FunctionAnalyzer implements ScopedCallback {\n     private final boolean inExterns;\n \n     FunctionAnalyzer(boolean inExterns) {\n         Preconditions.checkNotNull(sideEffectInfo);\n \n         if (NodeUtil.isAssignmentOp(node)) {\n-          visitAssignmentOrUnaryOperatorLhs(\n-              sideEffectInfo, traversal.getScope(), node.getFirstChild());\n+          visitAssignmentOrUnaryOperator(\n+              sideEffectInfo, traversal.getScope(),\n+              node, node.getFirstChild(), node.getLastChild());\n         } else {\n           switch(node.getType()) {\n             case Token.CALL:\n             case Token.DELPROP:\n             case Token.DEC:\n             case Token.INC:\n-              visitAssignmentOrUnaryOperatorLhs(\n-                  sideEffectInfo, traversal.getScope(), node.getFirstChild());\n+              visitAssignmentOrUnaryOperator(\n+                  sideEffectInfo, traversal.getScope(),\n+                  node, node.getFirstChild(), null);\n               break;\n             case Token.NAME:\n-\n               // Variable definition are not side effects.\n               // Just check that the name appears in the context of a\n               // variable declaration.\n               Preconditions.checkArgument(\n                   NodeUtil.isVarDeclaration(node));\n+              Node value = node.getFirstChild();\n+              // Assignment to local, if the value isn't a safe local value,\n+              // new object creation or literal or known primitive result\n+              // value, add it to the local blacklist.\n+              if (value != null && !isKnownLocalValue(value)) {\n+                Scope scope = traversal.getScope();\n+                Var var = scope.getVar(node.getString());\n+                sideEffectInfo.blacklistLocal(var);\n+              }\n               break;\n             case Token.THROW:\n               visitThrow(sideEffectInfo);\n       }\n     }\n \n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      // Nothing to do.\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {\n+      if (t.inGlobalScope()) {\n+        return;\n+      }\n+\n+      // Handle deferred local variable modifications:\n+      //\n+      FunctionInformation sideEffectInfo =\n+        functionSideEffectMap.get(t.getScopeRoot());\n+      if (sideEffectInfo.mutatesGlobalState()){\n+        sideEffectInfo.resetLocalVars();\n+        return;\n+      }\n+\n+      for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {\n+        Var v = i.next();\n+        boolean localVar = false;\n+        // Parameters and catch values come can from other scopes.\n+        if (v.getParentNode().getType() == Token.VAR) {\n+          // TODO(johnlenz): create a useful parameter list\n+          sideEffectInfo.knownLocals.add(v.getName());\n+          localVar = true;\n+        }\n+\n+        // Take care of locals that might have been tainted.\n+        if (!localVar || sideEffectInfo.blacklisted.contains(v)) {\n+          if (sideEffectInfo.taintedLocals.contains(v)) {\n+            // If the function has global side-effects\n+            // don't bother with the local side-effects.\n+            sideEffectInfo.setTaintsUnknown();\n+            sideEffectInfo.resetLocalVars();\n+            break;\n+          }\n+        }\n+      }\n+\n+      sideEffectInfo.taintedLocals = null;\n+      sideEffectInfo.blacklisted = null;\n+    }\n+\n+\n     /**\n      * Record information about the side effects caused by an\n      * assigment or mutating unary operator.\n      *\n      * If the operation modifies this or taints global state, mark the\n      * enclosing function as having those side effects.\n-     */\n-    private void visitAssignmentOrUnaryOperatorLhs(\n-        FunctionInformation sideEffectInfo, Scope scope, Node lhs) {\n+     * @param op operation being performed.\n+     * @param lhs The store location (name or get) being operated on.\n+     * @param rhs The right have value, if any.\n+     */\n+    private void visitAssignmentOrUnaryOperator(\n+        FunctionInformation sideEffectInfo,\n+        Scope scope, Node op, Node lhs, Node rhs) {\n       if (NodeUtil.isName(lhs)) {\n         Var var = scope.getVar(lhs.getString());\n         if (var == null || var.scope != scope) {\n           sideEffectInfo.setTaintsGlobalState();\n-        }\n-      } else if (NodeUtil.isGetProp(lhs)) {\n+        } else {\n+          // Assignment to local, if the value isn't a safe local value,\n+          // a literal or new object creation, add it to the local blacklist.\n+          // parameter values depend on the caller.\n+\n+          // Note: other ops result in the name or prop being assigned a local\n+          // value (x++ results in a number, for instance)\n+          Preconditions.checkState(\n+              NodeUtil.isAssignmentOp(op)\n+              || isIncDec(op) || op.getType() == Token.DELPROP);\n+          if (rhs != null && NodeUtil.isAssign(op) && !isKnownLocalValue(rhs)) {\n+            sideEffectInfo.blacklistLocal(var);\n+          }\n+        }\n+      } else if (NodeUtil.isGet(lhs)) {\n         if (NodeUtil.isThis(lhs.getFirstChild())) {\n           sideEffectInfo.setTaintsThis();\n         } else {\n-          sideEffectInfo.setTaintsUnknown();\n+          Var var = null;\n+          Node objectNode = lhs.getFirstChild();\n+          if (NodeUtil.isName(objectNode)) {\n+            var = scope.getVar(objectNode.getString());\n+          }\n+          if (var == null || var.scope != scope) {\n+            sideEffectInfo.setTaintsUnknown();\n+          } else {\n+            // Maybe a local object modification.  We won't know for sure until\n+            // we exit the scope and can validate the value of the local.\n+            //\n+            sideEffectInfo.addTaintedLocalObject(var);\n+          }\n         }\n       } else {\n-        sideEffectInfo.setTaintsUnknown();\n+        // The only valid lhs expressions are NAME, GETELEM, or GETPROP.\n+        throw new IllegalStateException(\"Unexpected lhs expression:\" + lhs);\n       }\n     }\n \n     }\n   }\n \n+  private static boolean isIncDec(Node n) {\n+    int type = n.getType();\n+    return (type == Token.INC || type == Token.DEC);\n+  }\n+\n+  /**\n+   * @return Whether the node is known to be a value that is not a reference\n+   *     outside the local scope.\n+   */\n+  @VisibleForTesting\n+  static boolean isKnownLocalValue(Node value) {\n+    // TODO(johnlenz): traverse into expression.\n+    // return NodeUtil.isNew(value) || NodeUtil.isLiteralValue(value, true);\n+    switch (value.getType()) {\n+      case Token.ASSIGN:\n+      case Token.COMMA:\n+        return isKnownLocalValue(value.getLastChild());\n+      case Token.AND:\n+      case Token.OR:\n+        return isKnownLocalValue(value.getFirstChild()) &&\n+           isKnownLocalValue(value.getLastChild());\n+      case Token.HOOK:\n+        return isKnownLocalValue(value.getFirstChild().getNext()) &&\n+           isKnownLocalValue(value.getLastChild());\n+      case Token.INC:\n+      case Token.DEC:\n+        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+          return isKnownLocalValue(value.getFirstChild());\n+        } else {\n+          return true;\n+        }\n+      case Token.THIS:\n+        // TODO(johnlenz): maybe redirect this to be a tainting list for 'this'.\n+        return false;\n+      case Token.NAME:\n+        // TODO(johnlenz): add to local tainting list, if the NAME\n+        // is known to be a local.\n+\n+        // \"undefined\", \"NaN\" and \"Infinity\" are allowed.\n+        return NodeUtil.isImmutableValue(value);\n+      case Token.GETELEM:\n+      case Token.GETPROP:\n+        // There is no information about the locality of object properties.\n+        return false;\n+      case Token.CALL:\n+        // TODO(johnlenz): add to local tainting list, if the call result\n+        // is not known to be a local result.\n+        return false;\n+      case Token.NEW:\n+        return true;\n+      case Token.FUNCTION:\n+      case Token.REGEXP:\n+      case Token.ARRAYLIT:\n+      case Token.OBJECTLIT:\n+        // Literals objects with non-literal children are allowed.\n+        return true;\n+      case Token.IN:\n+        // The IN operator is not include in NodeUtil#isSimpleOperator.\n+        return true;\n+      default:\n+        // Other op force a local value:\n+        //  x = '' + g (x is now an local string)\n+        //  x -= g (x is now an local number)\n+        if (NodeUtil.isAssignmentOp(value)\n+            || NodeUtil.isSimpleOperator(value)\n+            || NodeUtil.isImmutableValue(value)) {\n+          return true;\n+        }\n+\n+        throw new IllegalStateException(\n+            \"Unexpected expression node\" + value +\n+            \"\\n parent:\" + value.getParent());\n+    }\n+  }\n+\n   /**\n    * Callback that propagates side effect information across call sites.\n    */\n         // Calling a constructor that modifies \"this\" has no side effects.\n         if (callSite.getType() != Token.NEW) {\n           Node objectNode = getCallThisObject(callSite);\n-          if (objectNode != null && NodeUtil.isThis(objectNode)) {\n+          if (objectNode != null && NodeUtil.isName(objectNode)\n+              && !isCallOrApply(callSite)) {\n+            // Exclude \".call\" and \".apply\" as the value may still be may be\n+            // null or undefined. We don't need to worry about this with a\n+            // direct method call because null and undefined don't have any\n+            // properties.\n+            String name = objectNode.getString();\n+            if (!caller.knownLocals.contains(name)) {\n+              if (!caller.mutatesGlobalState()) {\n+                caller.setTaintsGlobalState();\n+                changed = true;\n+              }\n+            }\n+          } else if (objectNode != null && NodeUtil.isThis(objectNode)) {\n             if (!caller.mutatesThis()) {\n               caller.setTaintsThis();\n               changed = true;\n             }\n+          } else if (objectNode != null && isKnownLocalValue(objectNode)\n+              && !isCallOrApply(callSite)) {\n+            // Modifying 'this' on a known local object doesn't change any\n+            // significant state.\n+            // TODO(johnlenz): We can improve this by including literal values\n+            // that we know for sure are not null.\n           } else if (!caller.mutatesGlobalState()) {\n             caller.setTaintsGlobalState();\n             changed = true;\n    * @return node that will act as \"this\" for the call.\n    */\n   private static Node getCallThisObject(Node callSite) {\n-    Node foo = callSite.getFirstChild();\n-    if (!NodeUtil.isGetProp(foo)) {\n+    Node callTarget = callSite.getFirstChild();\n+    if (!NodeUtil.isGet(callTarget)) {\n \n       // \"this\" is not specified explicitly; call modifies global \"this\".\n       return null;\n     }\n \n-    Node object = null;\n-\n-    String propString = foo.getLastChild().getString();\n+    String propString = callTarget.getLastChild().getString();\n     if (propString.equals(\"call\") || propString.equals(\"apply\")) {\n-      return foo.getNext();\n+      return callTarget.getNext();\n     } else {\n-      return foo.getFirstChild();\n-    }\n+      return callTarget.getFirstChild();\n+    }\n+  }\n+\n+  private static boolean isCallOrApply(Node callSite) {\n+    Node callTarget = callSite.getFirstChild();\n+    if (NodeUtil.isGet(callTarget)) {\n+      String propString = callTarget.getLastChild().getString();\n+      if (propString.equals(\"call\") || propString.equals(\"apply\")) {\n+        return true;\n+      }\n+    }\n+    return false;\n   }\n \n   /**\n   private static class FunctionInformation {\n     private final boolean extern;\n     private final List<Node> callsInFunctionBody = Lists.newArrayList();\n+    private Set<Var> blacklisted = Sets.newHashSet();\n+    private Set<Var> taintedLocals = Sets.newHashSet();\n+    private Set<String> knownLocals = Sets.newHashSet();\n     private boolean pureFunction = false;\n     private boolean functionThrows = false;\n     private boolean taintsGlobalState = false;\n     }\n \n     /**\n+     * @param var\n+     */\n+    void addTaintedLocalObject(Var var) {\n+      taintedLocals.add(var);\n+    }\n+\n+    void resetLocalVars() {\n+      blacklisted = null;\n+      taintedLocals = null;\n+      knownLocals = Collections.emptySet();\n+    }\n+\n+    /**\n+     * @param var\n+     */\n+    public void blacklistLocal(Var var) {\n+      blacklisted.add(var);\n+    }\n+\n+    /**\n      * Function appeared in externs file.\n      */\n     boolean isExtern() {\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CheckLevel;\n                      ImmutableList.<String>of());\n   }\n \n+  public void testLocalizedSideEffects1() throws Exception {\n+    // Returning a function that contains a modification of a local\n+    // is not a global side-effect.\n+    checkMarkedCalls(\"function f() {\" +\n+                     \"  var x = {foo : 0}; return function() {x.foo++};\" +\n+                     \"}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of(\"f\"));\n+  }\n+\n+  public void testLocalizedSideEffects2() throws Exception {\n+    // Calling a function that contains a modification of a local\n+    // is a global side-effect (the value has escaped).\n+    checkMarkedCalls(\"function f() {\" +\n+                     \"  var x = {foo : 0}; (function() {x.foo++})();\" +\n+                     \"}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of());\n+  }\n+\n+  public void testLocalizedSideEffects3() throws Exception {\n+    // A local that might be assigned a gobal value and whose properties\n+    // are modified must be considered a global side-effect.\n+    checkMarkedCalls(\"var g = {foo:1}; function f() {var x = g; x.foo++}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of());\n+  }\n+\n+  public void testLocalizedSideEffects4() throws Exception {\n+    // An array is an local object, assigning a local array is not a global\n+    // side-effect.\n+    checkMarkedCalls(\"function f() {var x = []; x[0] = 1;}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of(\"f\"));\n+  }\n+\n+  public void testLocalizedSideEffects5() throws Exception {\n+    // Assigning a local alias of a global is a global\n+    // side-effect.\n+    checkMarkedCalls(\"var g = [];function f() {var x = g; x[0] = 1;}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of());\n+  }\n+\n+  public void testLocalizedSideEffects6() throws Exception {\n+    // Returning a local object that has been modified\n+    // is not a global side-effect.\n+    checkMarkedCalls(\"function f() {\" +\n+                     \"  var x = {}; x.foo = 1; return x;\" +\n+                     \"}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of(\"f\"));\n+  }\n+\n+  public void testLocalizedSideEffects7() throws Exception {\n+    // Returning a local object that has been modified\n+    // is not a global side-effect.\n+    checkMarkedCalls(\"/** @constructor A */ function A() {};\" +\n+                     \"function f() {\" +\n+                     \"  var a = []; a[1] = 1; return a;\" +\n+                     \"}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of(\"f\"));\n+  }\n+\n+  public void testLocalizedSideEffects8() throws Exception {\n+    // Returning a local object that has been modified\n+    // is not a global side-effect.\n+    checkMarkedCalls(\"/** @constructor A */ function A() {};\" +\n+                     \"function f() {\" +\n+                     \"  var a = new A; a.foo = 1; return a;\" +\n+                     \"}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of(\"A\", \"f\"));\n+  }\n+\n+  public void testLocalizedSideEffects9() throws Exception {\n+    // Returning a local object that has been modified\n+    // is not a global side-effect.\n+    checkMarkedCalls(\"/** @constructor A */ function A() {this.x = 1};\" +\n+                     \"function f() {\" +\n+                     \"  var a = new A; a.foo = 1; return a;\" +\n+                     \"}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of(\"A\", \"f\"));\n+  }\n+\n+  public void testLocalizedSideEffects10() throws Exception {\n+    // Returning a local object that has been modified\n+    // is not a global side-effect.\n+    checkMarkedCalls(\"/** @constructor A */ function A() {};\" +\n+                     \"A.prototype.g = function() {this.x = 1};\" +\n+                     \"function f() {\" +\n+                     \"  var a = new A; a.g(); return a;\" +\n+                     \"}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of(\"A\", \"f\"));\n+  }\n+\n   public void testUnaryOperators1() throws Exception {\n     checkMarkedCalls(\"function f() {var x = 1; x++}\" +\n                      \"f()\",\n   public void testUnaryOperators3() throws Exception {\n     checkMarkedCalls(\"function f() {var x = {foo : 0}; x.foo++}\" +\n                      \"f()\",\n-                     ImmutableList.<String>of());\n+                     ImmutableList.<String>of(\"f\"));\n   }\n \n   public void testUnaryOperators4() throws Exception {\n         \"function g(){var a = new A; a.foo(); return a}\\n\" +\n         \"f(); g()\";\n \n-    checkMarkedCalls(source, ImmutableList.<String>of(\"A\", \"A\", \"f\"));\n+    checkMarkedCalls(source, ImmutableList.<String>of(\"A\", \"A\", \"f\", \"g\"));\n   }\n \n   public void testCallFunctionFOrG() throws Exception {\n     test(\"var f = function() {};\" +\n          \"f.x = /** @nosideeffects */ function() {}\",\n          null, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n+  }\n+\n+  public void testLocalValue1() throws Exception {\n+    // Names are not known to be local.\n+    assertFalse(testLocalValue(\"x\"));\n+    assertFalse(testLocalValue(\"x()\"));\n+    assertFalse(testLocalValue(\"this\"));\n+    assertFalse(testLocalValue(\"arguments\"));\n+\n+    // new objects are local\n+    assertTrue(testLocalValue(\"new x()\"));\n+\n+    // property references are assume to be non-local\n+    assertFalse(testLocalValue(\"(new x()).y\"));\n+    assertFalse(testLocalValue(\"(new x())['y']\"));\n+\n+    // Primitive values are local\n+    assertTrue(testLocalValue(\"null\"));\n+    assertTrue(testLocalValue(\"undefined\"));\n+    assertTrue(testLocalValue(\"Infinity\"));\n+    assertTrue(testLocalValue(\"NaN\"));\n+    assertTrue(testLocalValue(\"1\"));\n+    assertTrue(testLocalValue(\"'a'\"));\n+    assertTrue(testLocalValue(\"true\"));\n+    assertTrue(testLocalValue(\"false\"));\n+    assertTrue(testLocalValue(\"[]\"));\n+    assertTrue(testLocalValue(\"{}\"));\n+\n+    // The contents of arrays and objects don't matter\n+    assertTrue(testLocalValue(\"[x]\"));\n+    assertTrue(testLocalValue(\"{'a':x}\"));\n+\n+    // Pre-increment results in primitive number\n+    assertTrue(testLocalValue(\"++x\"));\n+    assertTrue(testLocalValue(\"--x\"));\n+\n+    // Post-increment, the previous value matters.\n+    assertFalse(testLocalValue(\"x++\"));\n+    assertFalse(testLocalValue(\"x--\"));\n+\n+    // Only the right side of an assign matters\n+    assertTrue(testLocalValue(\"x=1\"));\n+    assertFalse(testLocalValue(\"x=y\"));\n+    // The right hand side of assignment opts don't matter, as they force\n+    // a local result.\n+    assertTrue(testLocalValue(\"x+=y\"));\n+    assertTrue(testLocalValue(\"x*=y\"));\n+    // Comparisons always result in locals, as they force a local boolean\n+    // result.\n+    assertTrue(testLocalValue(\"x==y\"));\n+    assertTrue(testLocalValue(\"x!=y\"));\n+    assertTrue(testLocalValue(\"x>y\"));\n+    // Only the right side of a comma matters\n+    assertTrue(testLocalValue(\"(1,2)\"));\n+    assertTrue(testLocalValue(\"(x,1)\"));\n+    assertFalse(testLocalValue(\"(x,y)\"));\n+\n+    // Both the operands of OR matter\n+    assertTrue(testLocalValue(\"1||2\"));\n+    assertFalse(testLocalValue(\"x||1\"));\n+    assertFalse(testLocalValue(\"x||y\"));\n+    assertFalse(testLocalValue(\"1||y\"));\n+\n+    // Both the operands of AND matter\n+    assertTrue(testLocalValue(\"1&&2\"));\n+    assertFalse(testLocalValue(\"x&&1\"));\n+    assertFalse(testLocalValue(\"x&&y\"));\n+    assertFalse(testLocalValue(\"1&&y\"));\n+\n+    // Only the results of HOOK matter\n+    assertTrue(testLocalValue(\"x?1:2\"));\n+    assertFalse(testLocalValue(\"x?x:2\"));\n+    assertFalse(testLocalValue(\"x?1:x\"));\n+    assertFalse(testLocalValue(\"x?x:y\"));\n+\n+    // Results of ops are local values\n+    assertTrue(testLocalValue(\"!y\"));\n+    assertTrue(testLocalValue(\"~y\"));\n+    assertTrue(testLocalValue(\"y + 1\"));\n+    assertTrue(testLocalValue(\"y + z\"));\n+    assertTrue(testLocalValue(\"y * z\"));\n+\n+    assertTrue(testLocalValue(\"'a' in x\"));\n+    assertTrue(testLocalValue(\"typeof x\"));\n+    assertTrue(testLocalValue(\"x instanceof y\"));\n+\n+    assertTrue(testLocalValue(\"void x\"));\n+    assertTrue(testLocalValue(\"void 0\"));\n+  }\n+\n+  boolean testLocalValue(String js) {\n+     Node root = this.parseExpectedJs(\"var test = \" + js +\";\");\n+     Preconditions.checkState(root.getType() == Token.BLOCK);\n+     Node script = root.getFirstChild();\n+     Preconditions.checkState(script.getType() == Token.SCRIPT);\n+     Node var = script.getFirstChild();\n+     Preconditions.checkState(var.getType() == Token.VAR);\n+     Node name = var.getFirstChild();\n+     Preconditions.checkState(name.getType() == Token.NAME);\n+     Node value = name.getFirstChild();\n+\n+     return PureFunctionIdentifier.isKnownLocalValue(value);\n+\n   }\n \n   void checkMarkedCalls(String source, List<String> expected) {", "timestamp": 1285193685, "metainfo": ""}