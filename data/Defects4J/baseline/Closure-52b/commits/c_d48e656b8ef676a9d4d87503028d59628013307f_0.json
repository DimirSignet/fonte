{"sha": "d48e656b8ef676a9d4d87503028d59628013307f", "log": "Automated g4 rollback.  *** Reason for rollback ***  Breaks builds  *** Original change description ***  Propagate known local value information across functions.  This also fixes problems with incomplete local information.  R=acleung,niranjan DELTA=1003  (254 added, 671 deleted, 78 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n import com.google.common.collect.Sets;\n import com.google.common.io.Files;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n-import com.google.javascript.jscomp.FunctionSideEffectData.CallValueEntry;\n-import com.google.javascript.jscomp.FunctionSideEffectData.KeywordValueEntry;\n-import com.google.javascript.jscomp.FunctionSideEffectData.ValueEntry;\n-import com.google.javascript.jscomp.FunctionSideEffectData.NameValueEntry;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph;\n import java.io.File;\n import java.io.IOException;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n   private final DefinitionProvider definitionProvider;\n \n   // Function node -> function side effects map\n-  private final Map<Node, FunctionSideEffectData> functionSideEffectMap;\n+  private final Map<Node, FunctionInformation> functionSideEffectMap;\n \n   // List of all function call sites; used to iterate in markPureFunctionCalls.\n   private final List<Node> allFunctionCalls;\n     functionNames.process(null, root);\n \n     sb.append(\"Pure functions:\\n\");\n-    for (Map.Entry<Node, FunctionSideEffectData> entry :\n+    for (Map.Entry<Node, FunctionInformation> entry :\n              functionSideEffectMap.entrySet()) {\n       Node function = entry.getKey();\n-      FunctionSideEffectData functionInfo = entry.getValue();\n+      FunctionInformation functionInfo = entry.getValue();\n \n       boolean isPure =\n           functionInfo.mayBePure() && !functionInfo.mayHaveSideEffects();\n     }\n     sb.append(\"\\n\");\n \n-    for (Map.Entry<Node, FunctionSideEffectData> entry :\n+    for (Map.Entry<Node, FunctionInformation> entry :\n              functionSideEffectMap.entrySet()) {\n       Node function = entry.getKey();\n-      FunctionSideEffectData functionInfo = entry.getValue();\n+      FunctionInformation functionInfo = entry.getValue();\n \n       Set<String> depFunctionNames = Sets.newHashSet();\n       for (Node callSite : functionInfo.getCallsInFunctionBody()) {\n    */\n   private void propagateSideEffects() {\n     // Nodes are function declarations; Edges are function call sites.\n-    DiGraph<FunctionSideEffectData, Node> sideEffectGraph =\n-        new LinkedDirectedGraph<FunctionSideEffectData, Node>();\n+    DiGraph<FunctionInformation, Node> sideEffectGraph =\n+        new LinkedDirectedGraph<FunctionInformation, Node>();\n \n     // create graph nodes\n-    for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {\n+    for (FunctionInformation functionInfo : functionSideEffectMap.values()) {\n       sideEffectGraph.createNode(functionInfo);\n     }\n \n     // add connections to called functions and side effect root.\n-    for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {\n+    for (FunctionInformation functionInfo : functionSideEffectMap.values()) {\n       if (!functionInfo.mayHaveSideEffects()) {\n         continue;\n       }\n \n         for (Definition def : defs) {\n           Node defValue = def.getRValue();\n-          FunctionSideEffectData dep = functionSideEffectMap.get(defValue);\n+          FunctionInformation dep = functionSideEffectMap.get(defValue);\n           Preconditions.checkNotNull(dep);\n           sideEffectGraph.connect(dep, callSite, functionInfo);\n         }\n         .computeFixedPoint(sideEffectGraph);\n \n     // Mark remaining functions \"pure\".\n-    for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {\n+    for (FunctionInformation functionInfo : functionSideEffectMap.values()) {\n       if (functionInfo.mayBePure()) {\n         functionInfo.setIsPure();\n       }\n       } else {\n         flags.clearAllFlags();\n         for (Definition def : defs) {\n-          FunctionSideEffectData functionInfo =\n+          FunctionInformation functionInfo =\n               functionSideEffectMap.get(def.getRValue());\n           Preconditions.checkNotNull(functionInfo);\n           // TODO(johnlenz): set the arguments separately from the\n             flags.setMutatesGlobalState();\n           }\n \n-          if (functionInfo.functionThrows()) {\n+          if (functionInfo.functionThrows) {\n             flags.setThrows();\n           }\n \n           if (!NodeUtil.isNew(callNode)) {\n-            if (functionInfo.mutatesThis()) {\n+            if (functionInfo.taintsThis) {\n               flags.setMutatesThis();\n             }\n           }\n \n-          if (functionInfo.hasNonLocalReturnValue()) {\n+          if (functionInfo.taintsReturn) {\n             flags.setReturnsTainted();\n           }\n \n                                   Node node,\n                                   Node parent) {\n \n-\n+      // Functions need to be processed as part of pre-traversal so an\n+      // entry for the enclosing function exists in the\n+      // FunctionInformation map when processing assignments and calls\n+      // inside visit.\n+      if (NodeUtil.isFunction(node)) {\n+        Node gramp = parent.getParent();\n+        visitFunction(traversal, node, parent, gramp);\n+      }\n \n       return true;\n     }\n \n       Node enclosingFunction = traversal.getEnclosingFunction();\n       if (enclosingFunction != null) {\n-        FunctionSideEffectData sideEffectInfo =\n+        FunctionInformation sideEffectInfo =\n             functionSideEffectMap.get(enclosingFunction);\n         Preconditions.checkNotNull(sideEffectInfo);\n \n               // Assignment to local, if the value isn't a safe local value,\n               // new object creation or literal or known primitive result\n               // value, add it to the local blacklist.\n-              if (value != null && !analyzeSet(\n-                      new NameValueEntry(node), value, sideEffectInfo)) {\n+              if (value != null && !NodeUtil.evaluatesToLocalValue(value)) {\n                 Scope scope = traversal.getScope();\n                 Var var = scope.getVar(node.getString());\n-                sideEffectInfo.addNonLocalValue(var);\n+                sideEffectInfo.blacklistLocal(var);\n               }\n               break;\n             case Token.THROW:\n               visitThrow(sideEffectInfo);\n               break;\n             case Token.RETURN:\n-              if (node.hasChildren() && !analyzeSet(\n-                      KeywordValueEntry.RETURN, node.getFirstChild(),\n-                      sideEffectInfo)) {\n+              if (node.hasChildren()\n+                  && !NodeUtil.evaluatesToLocalValue(node.getFirstChild())) {\n                 sideEffectInfo.setTaintsReturn();\n               }\n               break;\n     }\n \n     @Override\n-    public void enterScope(NodeTraversal traversal) {\n-      Node enclosingFunction = traversal.getEnclosingFunction();\n-      if (enclosingFunction != null) {\n-        // Functions need to be processed as part of pre-traversal so an\n-        // entry for the enclosing function exists in the\n-        // FunctionInformation map when processing assignments and calls\n-        // inside visit.\n-        visitFunction(traversal, enclosingFunction);\n-      }\n+    public void enterScope(NodeTraversal t) {\n+      // Nothing to do.\n     }\n \n     @Override\n     public void exitScope(NodeTraversal t) {\n-      if (t.inGlobalScope() || inExterns) {\n+      if (t.inGlobalScope()) {\n         return;\n       }\n \n-      FunctionSideEffectData sideEffectInfo =\n-          functionSideEffectMap.get(t.getScopeRoot());\n-\n-      sideEffectInfo.normalizeValueMaps();\n-    }\n+      // Handle deferred local variable modifications:\n+      //\n+      FunctionInformation sideEffectInfo =\n+        functionSideEffectMap.get(t.getScopeRoot());\n+      if (sideEffectInfo.mutatesGlobalState()){\n+        sideEffectInfo.resetLocalVars();\n+        return;\n+      }\n+\n+      for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {\n+        Var v = i.next();\n+        boolean localVar = false;\n+        // Parameters and catch values come can from other scopes.\n+        if (v.getParentNode().getType() == Token.VAR) {\n+          // TODO(johnlenz): create a useful parameter list\n+          sideEffectInfo.knownLocals.add(v.getName());\n+          localVar = true;\n+        }\n+\n+        // Take care of locals that might have been tainted.\n+        if (!localVar || sideEffectInfo.blacklisted.contains(v)) {\n+          if (sideEffectInfo.taintedLocals.contains(v)) {\n+            // If the function has global side-effects\n+            // don't bother with the local side-effects.\n+            sideEffectInfo.setTaintsUnknown();\n+            sideEffectInfo.resetLocalVars();\n+            break;\n+          }\n+        }\n+      }\n+\n+      sideEffectInfo.taintedLocals = null;\n+      sideEffectInfo.blacklisted = null;\n+    }\n+\n \n     /**\n      * Record information about the side effects caused by an\n-     * assignment or mutating unary operator.\n+     * assigment or mutating unary operator.\n      *\n      * If the operation modifies this or taints global state, mark the\n      * enclosing function as having those side effects.\n      * @param rhs The right have value, if any.\n      */\n     private void visitAssignmentOrUnaryOperator(\n-        FunctionSideEffectData sideEffectInfo,\n+        FunctionInformation sideEffectInfo,\n         Scope scope, Node op, Node lhs, Node rhs) {\n       if (NodeUtil.isName(lhs)) {\n         Var var = scope.getVar(lhs.getString());\n               || isIncDec(op) || op.getType() == Token.DELPROP);\n           if (rhs != null\n               && NodeUtil.isAssign(op)\n-              && !analyzeSet(\n-                new NameValueEntry(lhs), rhs, sideEffectInfo)) {\n-            sideEffectInfo.addNonLocalValue(var);\n+              && !NodeUtil.evaluatesToLocalValue(rhs)) {\n+            sideEffectInfo.blacklistLocal(var);\n           }\n         }\n       } else if (NodeUtil.isGet(lhs)) {\n             // Maybe a local object modification.  We won't know for sure until\n             // we exit the scope and can validate the value of the local.\n             //\n-            sideEffectInfo.addModified(var);\n+            sideEffectInfo.addTaintedLocalObject(var);\n           }\n         }\n       } else {\n     /**\n      * Record information about a call site.\n      */\n-    private void visitCall(FunctionSideEffectData sideEffectInfo, Node node) {\n+    private void visitCall(FunctionInformation sideEffectInfo, Node node) {\n       // Handle special cases (Math, RegEx)\n       if (NodeUtil.isCall(node)\n           && !NodeUtil.functionCallHasSideEffects(node, compiler)) {\n     /**\n      * Record function and check for @nosideeffects annotations.\n      */\n-    private void visitFunction(NodeTraversal traversal, Node node) {\n+    private void visitFunction(NodeTraversal traversal,\n+                               Node node,\n+                               Node parent,\n+                               Node gramp) {\n       Preconditions.checkArgument(!functionSideEffectMap.containsKey(node));\n \n-      FunctionSideEffectData sideEffectInfo = new FunctionSideEffectData(\n-          inExterns, traversal.getScope());\n+      FunctionInformation sideEffectInfo = new FunctionInformation(inExterns);\n       functionSideEffectMap.put(node, sideEffectInfo);\n \n-      if (!inExterns) {\n-        Scope localScope = traversal.getScope();\n-\n-        // Only vars and function declarations maybe known to be local.\n-        // Parameters and catch exception definitions are are not tracked\n-        // so mark them non-local immediately.\n-        Iterator<Var> i = localScope.getVars();\n-        while (i.hasNext()) {\n-          Var v = i.next();\n-          Node parent = v.getParentNode();\n-          if (parent.getType() == Token.LP\n-              || parent.getType() == Token.CATCH) {\n-            // TODO(johnlenz): Allow function parameters\n-            sideEffectInfo.addNonLocalValue(v);\n-          }\n-        }\n-      }\n-\n-      processFunctionAnnotations(sideEffectInfo, traversal, node);\n-    }\n-\n-    /**\n-     * Update the function side effect info for any user provided annotations.\n-     * Reports discovered invalid usages of these annotations.\n-     */\n-    private void processFunctionAnnotations(\n-        FunctionSideEffectData sideEffectInfo,\n-        NodeTraversal traversal, Node function) {\n-      // Infer the locality of the return type\n       if (inExterns) {\n-        JSType jstype = function.getJSType();\n+        JSType jstype = node.getJSType();\n         boolean knownLocalResult = false;\n         if (jstype != null && jstype.isFunctionType()) {\n           FunctionType functionType = (FunctionType) jstype;\n         }\n       }\n \n-      JSDocInfo info = getJSDocInfoForFunction(function);\n+      JSDocInfo info = getJSDocInfoForFunction(node, parent, gramp);\n       if (info != null) {\n         boolean hasSpecificSideEffects = false;\n         if (hasSideEffectsThisAnnotation(info)) {\n             hasSpecificSideEffects = true;\n             sideEffectInfo.setTaintsThis();\n           } else {\n-            traversal.report(function, INVALID_MODIFIES_ANNOTATION);\n+            traversal.report(node, INVALID_MODIFIES_ANNOTATION);\n           }\n         }\n \n             hasSpecificSideEffects = true;\n             sideEffectInfo.setTaintsArguments();\n           } else {\n-            traversal.report(function, INVALID_MODIFIES_ANNOTATION);\n+            traversal.report(node, INVALID_MODIFIES_ANNOTATION);\n           }\n         }\n \n             if (inExterns) {\n               sideEffectInfo.setIsPure();\n             } else {\n-              traversal.report(function, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n+              traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n             }\n           } else if (inExterns) {\n             sideEffectInfo.setTaintsGlobalState();\n     /**\n      * Record that the enclosing function throws.\n      */\n-    private void visitThrow(FunctionSideEffectData sideEffectInfo) {\n+    private void visitThrow(FunctionInformation sideEffectInfo) {\n       sideEffectInfo.setFunctionThrows();\n     }\n \n     /**\n      * Get the doc info associated with the function.\n      */\n-    private JSDocInfo getJSDocInfoForFunction(Node node) {\n-      Node parent = node.getParent();\n+    private JSDocInfo getJSDocInfoForFunction(\n+        Node node, Node parent, Node gramp) {\n       JSDocInfo info = node.getJSDocInfo();\n       if (info != null) {\n         return info;\n       } else if (NodeUtil.isName(parent)) {\n-        Node gramp = parent.getParent();\n         return gramp.hasOneChild() ? gramp.getJSDocInfo() : null;\n       } else if (NodeUtil.isAssign(parent)) {\n         return parent.getJSDocInfo();\n   }\n \n   /**\n-   * Check local values and updates the value influence map.\n-   * @param lValue A var name or token value used in the value influence map.\n-   *\n-   * @return Whether the node is maybe to be a value that has not escaped\n-   *     the local scope.\n+   * @return Whether the node is known to be a value that is not a reference\n+   *     outside the local scope.\n    */\n-  private static boolean analyzeSet(\n-      final ValueEntry lValue,\n-      Node rValue,\n-      final FunctionSideEffectData info) {\n-\n-    final boolean isReturnResult = lValue.equals(KeywordValueEntry.RETURN);\n-\n-    // Create a predicate for NodeUtil#evaluatesToLocalValue.\n-    final Predicate<Node> taintingPredicate = new Predicate<Node>() {\n+  private static boolean isKnownLocalValue(final Node value) {\n+    Predicate<Node> taintingPredicate = new Predicate<Node>() {\n       @Override\n       public boolean apply(Node value) {\n         switch (value.getType()) {\n           case Token.ASSIGN:\n-            // Check the LHS of the assignment, the RHS will be evaluated\n-            // separately.  If the LHS is a local NAME add that dependency on\n-            // that value as it is a alias of the RHS value.\n-\n-            // Aliases of immutable RHS values don't matter, but should already\n-            // be filtered out.\n-            Preconditions.checkState(\n-                !NodeUtil.isImmutableValue(value.getLastChild()));\n-            Node lhs = value.getFirstChild();\n-            if (NodeUtil.isName(lhs)\n-                && info.getScope().isDeclared(lhs.getString(), false)) {\n-              addValue(lhs);\n-              return true;\n-            }\n-            // Don't attempt to track an aliasing property assignment.\n+            // The assignment might cause an alias, look at the lhs.\n             return false;\n           case Token.THIS:\n-            // changes to \"this\" now change \"key\", changes to \"key\" will\n-            // also infer a change to \"this\".\n-            addValue(KeywordValueEntry.THIS);\n-            return true;\n+            // TODO(johnlenz): maybe redirect this to be a tainting list for 'this'.\n+            return false;\n           case Token.NAME:\n-            // add to local tainting list, if the NAME\n+            // TODO(johnlenz): add to local tainting list, if the NAME\n             // is known to be a local.\n-            if (info.getScope().isDeclared(value.getString(), false)) {\n-              addValue(value);\n-              return true;\n-            }\n             return false;\n-          case Token.CALL:\n-            // For calls the taint is the actual call node.\n-            addCall(value);\n-            return true;\n           case Token.GETELEM:\n           case Token.GETPROP:\n             // There is no information about the locality of object properties.\n             return false;\n-          default:\n-            throw new IllegalStateException(\"unexpected\");\n-        }\n-      }\n-\n-      private void addCall(Node callNode) {\n-        Preconditions.checkState(callNode.getType() == Token.CALL);\n-        info.addInfluence(new CallValueEntry(callNode), lValue);\n-      }\n-\n-      private void addValue(Node name) {\n-        ValueEntry value = new NameValueEntry(name);\n-        addValue(value);\n-      }\n-\n-      private void addValue(ValueEntry value) {\n-        // The value and keys maybe aliases\n-        info.addInfluence(value, lValue);\n-        if (!isReturnResult) {\n-          info.addInfluence(lValue, value);\n-        }\n+          case Token.CALL:\n+            // TODO(johnlenz): add to local tainting list, if the call result\n+            // is not known to be a local result.\n+            return false;\n+        }\n+        return false;\n       }\n     };\n \n-    // Walk the expression with the provided predicate.\n-    return NodeUtil.evaluatesToLocalValue(rValue, taintingPredicate);\n-  }\n-\n-  private static Predicate<Node> getLocalPredicate(\n-      final FunctionSideEffectData caller) {\n-    return new Predicate<Node>() {\n-      @Override\n-      public boolean apply(Node value) {\n-        return caller.isLocalValue(value);\n-      }\n-    };\n+    return NodeUtil.evaluatesToLocalValue(value, taintingPredicate);\n   }\n \n   /**\n    * Callback that propagates side effect information across call sites.\n    */\n   private static class SideEffectPropagationCallback\n-      implements EdgeCallback<FunctionSideEffectData, Node> {\n-    public boolean traverseEdge(final FunctionSideEffectData callee,\n-                                final Node callSite,\n-                                final FunctionSideEffectData caller) {\n+      implements EdgeCallback<FunctionInformation, Node> {\n+    public boolean traverseEdge(FunctionInformation callee,\n+                                Node callSite,\n+                                FunctionInformation caller) {\n       Preconditions.checkArgument(callSite.getType() == Token.CALL ||\n                                   callSite.getType() == Token.NEW);\n \n       boolean changed = false;\n-      if (caller.isInformationStable()) {\n-        // There is no more useful information to be gathered.\n-        return false;\n-      }\n-\n       if (!caller.mutatesGlobalState() && callee.mutatesGlobalState()) {\n         caller.setTaintsGlobalState();\n         changed = true;\n       if (!caller.functionThrows() && callee.functionThrows()) {\n         caller.setFunctionThrows();\n         changed = true;\n-      }\n-\n-      Predicate<Node> locals = getLocalPredicate(caller);\n-      if (callee.hasNonLocalReturnValue()) {\n-        if (caller.maybePropagateNonLocal(new CallValueEntry(callSite))) {\n-          changed = true;\n-        }\n       }\n \n       if (callee.mutatesThis()) {\n         // Calling a constructor that modifies \"this\" has no side effects.\n         if (callSite.getType() != Token.NEW) {\n           Node objectNode = getCallThisObject(callSite);\n-          if (objectNode != null && NodeUtil.isThis(objectNode)) {\n+          if (objectNode != null && NodeUtil.isName(objectNode)\n+              && !isCallOrApply(callSite)) {\n+            // Exclude \".call\" and \".apply\" as the value may still be may be\n+            // null or undefined. We don't need to worry about this with a\n+            // direct method call because null and undefined don't have any\n+            // properties.\n+            String name = objectNode.getString();\n+\n+            // TODO(nicksantos): Turn this back on when locals-tracking\n+            // is fixed. See testLocalizedSideEffects11.\n+            //if (!caller.knownLocals.contains(name)) {\n+              if (!caller.mutatesGlobalState()) {\n+                caller.setTaintsGlobalState();\n+                changed = true;\n+              }\n+            //}\n+          } else if (objectNode != null && NodeUtil.isThis(objectNode)) {\n             if (!caller.mutatesThis()) {\n               caller.setTaintsThis();\n               changed = true;\n             }\n-          } else if (objectNode != null && !isCallOrApply(callSite)) {\n-            // Exclude \".call\" and \".apply\" as the value may still be may be\n-            // null or undefined. We don't need to worry about this with a\n-            // direct method call because null and undefined don't have any\n-            // properties.\n+          } else if (objectNode != null\n+              && NodeUtil.evaluatesToLocalValue(objectNode)\n+              && !isCallOrApply(callSite)) {\n+            // Modifying 'this' on a known local object doesn't change any\n+            // significant state.\n             // TODO(johnlenz): We can improve this by including literal values\n             // that we know for sure are not null.\n-\n-            // Modifying 'this' on a known local object doesn't change any\n-            // significant state.\n-            if (!NodeUtil.evaluatesToLocalValue(objectNode, locals)) {\n-              if (!caller.mutatesGlobalState()) {\n-                caller.setTaintsGlobalState();\n-                changed = true;\n-              }\n-            }\n           } else if (!caller.mutatesGlobalState()) {\n             caller.setTaintsGlobalState();\n             changed = true;\n           }\n         }\n-      }\n-\n-      if (caller.isInformationStable()) {\n-        // Once the caller has reach a stable state, clear the local state\n-        // to avoid memory being a memory hog.\n-        caller.clearLocalityState();\n       }\n \n       return changed;\n   }\n \n   /**\n+   * Keeps track of a function's known side effects by type and the\n+   * list of calls that appear in a function's body.\n+   */\n+  private static class FunctionInformation {\n+    private final boolean extern;\n+    private final List<Node> callsInFunctionBody = Lists.newArrayList();\n+    private Set<Var> blacklisted = Sets.newHashSet();\n+    private Set<Var> taintedLocals = Sets.newHashSet();\n+    private Set<String> knownLocals = Sets.newHashSet();\n+    private boolean pureFunction = false;\n+    private boolean functionThrows = false;\n+    private boolean taintsGlobalState = false;\n+    private boolean taintsThis = false;\n+    private boolean taintsArguments = false;\n+    private boolean taintsUnknown = false;\n+    private boolean taintsReturn = false;\n+\n+    FunctionInformation(boolean extern) {\n+      this.extern = extern;\n+      checkInvariant();\n+    }\n+\n+    /**\n+     * @param var\n+     */\n+    void addTaintedLocalObject(Var var) {\n+      taintedLocals.add(var);\n+    }\n+\n+    void resetLocalVars() {\n+      blacklisted = null;\n+      taintedLocals = null;\n+      knownLocals = Collections.emptySet();\n+    }\n+\n+    /**\n+     * @param var\n+     */\n+    public void blacklistLocal(Var var) {\n+      blacklisted.add(var);\n+    }\n+\n+    /**\n+     * @returns false if function known to have side effects.\n+     */\n+    boolean mayBePure() {\n+      return !(functionThrows ||\n+               taintsGlobalState ||\n+               taintsThis ||\n+               taintsArguments ||\n+               taintsUnknown);\n+    }\n+\n+    /**\n+     * @returns false if function known to be pure.\n+     */\n+    boolean mayHaveSideEffects() {\n+      return !pureFunction;\n+    }\n+\n+    /**\n+     * Mark the function as being pure.\n+     */\n+    void setIsPure() {\n+      pureFunction = true;\n+      checkInvariant();\n+    }\n+\n+    /**\n+     * Marks the function as having \"modifies globals\" side effects.\n+     */\n+    void setTaintsGlobalState() {\n+      taintsGlobalState = true;\n+      checkInvariant();\n+    }\n+\n+    /**\n+     * Marks the function as having \"modifies this\" side effects.\n+     */\n+    void setTaintsThis() {\n+      taintsThis = true;\n+      checkInvariant();\n+    }\n+\n+    /**\n+     * Marks the function as having \"modifies arguments\" side effects.\n+     */\n+    void setTaintsArguments() {\n+      taintsArguments = true;\n+      checkInvariant();\n+    }\n+\n+    /**\n+     * Marks the function as having \"throw\" side effects.\n+     */\n+    void setFunctionThrows() {\n+      functionThrows = true;\n+      checkInvariant();\n+    }\n+\n+    /**\n+     * Marks the function as having \"complex\" side effects that are\n+     * not otherwise explicitly tracked.\n+     */\n+    void setTaintsUnknown() {\n+      taintsUnknown = true;\n+      checkInvariant();\n+    }\n+\n+    /**\n+     * Marks the function as having non-local return result.\n+     */\n+    void setTaintsReturn() {\n+      taintsReturn = true;\n+      checkInvariant();\n+    }\n+\n+\n+    /**\n+     * Returns true if function mutates global state.\n+     */\n+    boolean mutatesGlobalState() {\n+      // TODO(johnlenz): track arguments separately.\n+      return taintsGlobalState || taintsArguments || taintsUnknown;\n+    }\n+\n+    /**\n+     * Returns true if function mutates \"this\".\n+     */\n+    boolean mutatesThis() {\n+      return taintsThis;\n+    }\n+\n+    /**\n+     * Returns true if function has an explicit \"throw\".\n+     */\n+    boolean functionThrows() {\n+      return functionThrows;\n+    }\n+\n+    /**\n+     * Verify internal consistency.  Should be called at the end of\n+     * every method that mutates internal state.\n+     */\n+    private void checkInvariant() {\n+      boolean invariant = mayBePure() || mayHaveSideEffects();\n+      if (!invariant) {\n+        throw new IllegalStateException(\"Invariant failed.  \" + toString());\n+      }\n+    }\n+\n+    /**\n+     * Add a CALL or NEW node to the list of calls this function makes.\n+     */\n+    void appendCall(Node callNode) {\n+      callsInFunctionBody.add(callNode);\n+    }\n+\n+    /**\n+     * Gets the list of CALL and NEW nodes.\n+     */\n+    List<Node> getCallsInFunctionBody() {\n+      return callsInFunctionBody;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      List<String> status = Lists.newArrayList();\n+      if (extern) {\n+        status.add(\"extern\");\n+      }\n+\n+      if (pureFunction) {\n+        status.add(\"pure\");\n+      }\n+\n+      if (taintsThis) {\n+        status.add(\"this\");\n+      }\n+\n+      if (taintsGlobalState) {\n+        status.add(\"global\");\n+      }\n+\n+      if (functionThrows) {\n+        status.add(\"throw\");\n+      }\n+\n+      if (taintsUnknown) {\n+        status.add(\"complex\");\n+      }\n+\n+      return \"Side effects: \" + status.toString();\n+    }\n+  }\n+\n+  /**\n    * A compiler pass that constructs a reference graph and drives\n    * the PureFunctionIdentifier across it.\n    */\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n         \"  x.externObjSEThisMethod('') \" +\n         \"};\" +\n         \"f();\",\n-        ImmutableList.<String>of(\"externObjSEThis\", \"f\"));\n+        ImmutableList.<String>of(\"externObjSEThis\"));\n   }\n \n   public void testAnnotationInExterns_new8() throws Exception {\n         prefix + \"return externObj.foo\" + suffix, expected);\n   }\n \n-  public void testResultLocalitySimpleSample() throws Exception {\n-    String prefix = \"var g; function f(){\";\n-    String suffix = \"} f()\";\n-    List<String> expected = ImmutableList.of(\"f\");\n-    List<String> notExpected = ImmutableList.of();\n-\n-    // global result\n-    checkLocalityOfMarkedCalls(\n-      prefix + \"var a = (g = []); return a\" + suffix, notExpected);\n-  }\n-\n   public void testResultLocalitySimple() throws Exception {\n     String prefix = \"var g; function f(){\";\n     String suffix = \"} f()\";\n         prefix + \"return 1; return g\" + suffix, notExpected);\n \n \n-    // local var.\n+    // local var, not yet.\n     checkLocalityOfMarkedCalls(\n-        prefix + \"var a = 1; return a\" + suffix, expected);\n-\n-    // mutate local var.\n+        prefix + \"var a = 1; return a\" + suffix, notExpected);\n+\n+    // mutate local var, not yet.\n     checkLocalityOfMarkedCalls(\n-        prefix + \"var a = 1; a = 2; return a\" + suffix, expected);\n+        prefix + \"var a = 1; a = 2; return a\" + suffix, notExpected);\n     checkLocalityOfMarkedCalls(\n         prefix + \"var a = 1; a = 2; return a + 1\" + suffix, expected);\n-\n-    // Global aliases of immutables is ok.\n-    checkLocalityOfMarkedCalls(\n-        prefix + \"var a = (g = 2); return a\" + suffix, expected);\n-\n-    checkLocalityOfMarkedCalls(\n-       prefix + \"var a = (g = []); return a\" + suffix, notExpected);\n-\n \n     // read from obj literal\n     checkLocalityOfMarkedCalls(\n                      \"  var a = new A; a.g(); return a;\" +\n                      \"}\" +\n                      \"f()\",\n-                     ImmutableList.<String>of(\"A\", \"f\"));\n+                     ImmutableList.<String>of(\"A\"));\n   }\n \n   public void testLocalizedSideEffects11() throws Exception {\n         ImmutableList.of(\"A\", \"B\"));\n   }\n \n-  public void testLocalizedSideEffects12() throws Exception {\n-    // A expression containing an assignment is an alias of the value\n-    checkMarkedCalls(\"var g = 1;\" +\n-                     \"function f() {\" +\n-                     \"  var a = (g = new Foo); return a;\" +\n-                     \"}\" +\n-                     \"f()\",\n-                     ImmutableList.<String>of());\n-  }\n-\n-  public void testLocalizedSideEffects13() throws Exception {\n-    // A expression containing an assignment is an alias of the value, but\n-    // aliasing an immutable value doesn't matter, but the global side-effect\n-    // does.\n-    checkMarkedCalls(\"var g = 1;\" +\n-                     \"function f() {\" +\n-                     \"  var a = (g = 2); return a;\" +\n-                     \"}\" +\n-                     \"f()\",\n-                     ImmutableList.<String>of());\n-  }\n-\n   public void testUnaryOperators1() throws Exception {\n     checkMarkedCalls(\"function f() {var x = 1; x++}\" +\n                      \"f()\",\n         \"function g(){var a = new A; a.foo(); return a}\\n\" +\n         \"f(); g()\";\n \n-    checkMarkedCalls(source, ImmutableList.<String>of(\"A\", \"A\", \"f\", \"g\"));\n+    checkMarkedCalls(source, ImmutableList.<String>of(\"A\", \"A\", \"f\"));\n   }\n \n   public void testCallFunctionFOrG() throws Exception {", "timestamp": 1290484502, "metainfo": ""}