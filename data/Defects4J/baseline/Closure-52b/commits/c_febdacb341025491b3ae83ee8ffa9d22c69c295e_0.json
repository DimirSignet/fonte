{"sha": "febdacb341025491b3ae83ee8ffa9d22c69c295e", "log": "speed up type analysis a bunch, and fix some bugs in record types   R=acleung DELTA=232  (154 added, 54 deleted, 24 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3408   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     // TODO(user): remove in favor of flagging every property access on\n     // non-object.\n     if (!validator.expectNotNullOrUndefined(t, n, childType,\n-            childType + \" has no properties\", getNativeType(OBJECT_TYPE))) {\n+            \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       ensureTyped(t, n);\n       return;\n     }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n     super(registry, name,\n         registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n         nativeType);\n+    setPrettyPrint(true);\n+\n     Preconditions.checkArgument(source == null ||\n         Token.FUNCTION == source.getType());\n     Preconditions.checkNotNull(arrowType);\n   private FunctionType(JSTypeRegistry registry, String name, Node source) {\n     super(registry, name,\n         registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE));\n+    setPrettyPrint(true);\n+\n     Preconditions.checkArgument(source == null ||\n         Token.FUNCTION == source.getType());\n     Preconditions.checkArgument(name != null);\n    */\n   @Override\n   public String toString() {\n-    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {\n+    if (!isPrettyPrint() ||\n+        this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {\n       return \"Function\";\n     }\n+\n+    setPrettyPrint(false);\n \n     StringBuilder b = new StringBuilder(32);\n     b.append(\"function (\");\n     }\n     b.append(\"): \");\n     b.append(call.returnType);\n+\n+    setPrettyPrint(true);\n     return b.toString();\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n   }\n \n   public boolean isRecordType() {\n-    return false;\n+    return toMaybeRecordType() != null;\n+  }\n+\n+  /**\n+   * Downcasts this to a RecordType, or returns null if this is not\n+   * a RecordType.\n+   */\n+  RecordType toMaybeRecordType() {\n+    return null;\n   }\n \n   public boolean isTemplateType() {\n    * @return {@code this &#8744; that}\n    */\n   public JSType getGreatestSubtype(JSType that) {\n-    if (that.isRecordType()) {\n-      // Record types have their own implementation of getGreatestSubtype.\n-      return that.getGreatestSubtype(this);\n-    }\n     return getGreatestSubtype(this, that);\n   }\n \n       return thisType.toMaybeUnionType().meet(thatType);\n     } else if (thatType.isUnionType()) {\n       return thatType.toMaybeUnionType().meet(thisType);\n+    } else if (thisType.isRecordType()) {\n+      return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);\n+    } else if (thatType.isRecordType()) {\n+      return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);\n     }\n \n     if (thisType.isEnumElementType()) {\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n     this.prettyPrint = prettyPrint;\n   }\n \n+  boolean isPrettyPrint() {\n+    return prettyPrint;\n+  }\n+\n   @Override\n   public FunctionType getConstructor() {\n     return null;\n     }\n \n     // record types\n-    if (that instanceof RecordType) {\n-      return RecordType.isSubtype(this, (RecordType) that);\n+    if (that.isRecordType()) {\n+      return RecordType.isSubtype(this, that.toMaybeRecordType());\n     }\n \n     // Interfaces\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n+  RecordType toMaybeRecordType() {\n+    return referencedType.toMaybeRecordType();\n+  }\n+\n+  @Override\n   public UnionType toMaybeUnionType() {\n     return referencedType.toMaybeUnionType();\n   }\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n  * can be assigned to a record of type { a : A }.\n  *\n  */\n-public class RecordType extends PrototypeObjectType {\n+class RecordType extends PrototypeObjectType {\n   private static final long serialVersionUID = 1L;\n \n   private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n    */\n   RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n     super(registry, null, null);\n+    setPrettyPrint(true);\n \n     for (String property : properties.keySet()) {\n       RecordProperty prop = properties.get(property);\n \n   @Override\n   public boolean isEquivalentTo(JSType other) {\n-    if (!(other instanceof RecordType)) {\n+    if (!other.isRecordType()) {\n       return false;\n     }\n \n     // Compare properties.\n-    RecordType otherRecord = (RecordType) other;\n+    RecordType otherRecord = other.toMaybeRecordType();\n+    if (otherRecord == this) {\n+      return true;\n+    }\n+\n     Set<String> keySet = properties.keySet();\n     Map<String, JSType> otherProps = otherRecord.properties;\n     if (!otherProps.keySet().equals(keySet)) {\n       return super.getLeastSupertype(that);\n     }\n \n-    RecordType thatRecord = (RecordType) that;\n+    RecordType thatRecord = that.toMaybeRecordType();\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n     // The least supertype consist of those properties of the record\n     return builder.build();\n   }\n \n-  @Override\n-  public JSType getGreatestSubtype(JSType that) {\n+  JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = (RecordType) that;\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n       return builder.build();\n     }\n \n-    JSType greatestSubtype = super.getGreatestSubtype(that);\n-    if (greatestSubtype.isNoObjectType() && !that.isNoObjectType()) {\n+    JSType greatestSubtype = registry.getNativeType(\n+        JSTypeNative.NO_OBJECT_TYPE);\n+    JSType thatRestrictedToObj =\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE)\n+        .getGreatestSubtype(that);\n+    if (!thatRestrictedToObj.isEmptyType()) {\n       // In this branch, the other type is some object type. We find\n       // the greatest subtype with the following algorithm:\n       // 1) For each property \"x\" of this record type, take the union\n           if (altPropType != null && !alt.isEquivalentTo(this) &&\n               alt.isSubtype(that) &&\n               (propType.isUnknownType() || altPropType.isUnknownType() ||\n-               altPropType.isEquivalentTo(propType))) {\n+                  altPropType.isEquivalentTo(propType))) {\n             builder.addAlternate(alt);\n           }\n         }\n   }\n \n   @Override\n-  public boolean isRecordType() {\n-    return true;\n+  RecordType toMaybeRecordType() {\n+    return this;\n   }\n \n   @Override\n       return false;\n     }\n \n-    return RecordType.isSubtype(this, (RecordType) that);\n+    return RecordType.isSubtype(this, that.toMaybeRecordType());\n   }\n \n   /** Determines if typeA is a subtype of typeB */\n   }\n \n   @Override\n-  public String toString() {\n-    StringBuilder sb = new StringBuilder();\n-    sb.append(\"{\");\n-\n-    int i = 0;\n-\n-    for (String property : properties.keySet()) {\n-      if (i > 0) {\n-        sb.append(\", \");\n-      }\n-\n-      sb.append(property);\n-      sb.append(\": \");\n-      sb.append(properties.get(property).toString());\n-\n-      ++i;\n-    }\n-\n-    sb.append(\"}\");\n-    return sb.toString();\n-  }\n-\n-  @Override\n   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n     for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n       JSType type = entry.getValue();\n--- a/src/com/google/javascript/rhino/testing/Asserts.java\n+++ b/src/com/google/javascript/rhino/testing/Asserts.java\n         \"Actual  : \" + a,\n         b.isEquivalentTo(a));\n   }\n+\n+  /**\n+   * For the given equivalent types, run all type operations that\n+   * should have trivial solutions (getGreatestSubtype, isEquivalentTo, etc)\n+   */\n+  public static void assertEquivalenceOperations(JSType a, JSType b) {\n+    Assert.assertTrue(a.isEquivalentTo(b));\n+    Assert.assertTrue(a.isEquivalentTo(a));\n+    Assert.assertTrue(b.isEquivalentTo(b));\n+    Assert.assertTrue(b.isEquivalentTo(a));\n+\n+    Assert.assertTrue(a.isSubtype(b));\n+    Assert.assertTrue(a.isSubtype(a));\n+    Assert.assertTrue(b.isSubtype(b));\n+    Assert.assertTrue(b.isSubtype(a));\n+\n+    assertTypeEquals(a, a.getGreatestSubtype(b));\n+    assertTypeEquals(a, a.getGreatestSubtype(a));\n+    assertTypeEquals(a, b.getGreatestSubtype(b));\n+    assertTypeEquals(a, b.getGreatestSubtype(a));\n+\n+    assertTypeEquals(a, a.getLeastSupertype(b));\n+    assertTypeEquals(a, a.getLeastSupertype(a));\n+    assertTypeEquals(a, b.getLeastSupertype(b));\n+    assertTypeEquals(a, b.getLeastSupertype(a));\n+  }\n }\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n \n   public void testGetprop1() throws Exception {\n     testTypes(\"/** @return {void}*/function foo(){foo().bar;}\",\n-        \"undefined has no properties\\n\" +\n+        \"No properties on this expression\\n\" +\n         \"found   : undefined\\n\" +\n         \"required: Object\");\n   }\n \n   public void testPropAccess2() throws Exception {\n     testTypes(\"var bar = void 0; bar.baz;\",\n-        \"undefined has no properties\\n\" +\n+        \"No properties on this expression\\n\" +\n         \"found   : undefined\\n\" +\n         \"required: Object\");\n   }\n     // Verifies that we don't emit two warnings, because\n     // the var has been dereferenced after the first one.\n     testTypes(\"var bar = void 0; bar.baz; bar.bax;\",\n-        \"undefined has no properties\\n\" +\n+        \"No properties on this expression\\n\" +\n         \"found   : undefined\\n\" +\n         \"required: Object\");\n   }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n \n   public void testGetprop1() throws Exception {\n     testTypes(\"/** @return {void}*/function foo(){foo().bar;}\",\n-        \"undefined has no properties\\n\" +\n+        \"No properties on this expression\\n\" +\n         \"found   : undefined\\n\" +\n         \"required: Object\");\n   }\n \n   public void testGetprop2() throws Exception {\n     testTypes(\"var x = null; x.alert();\",\n-        \"null has no properties\\n\" +\n+        \"No properties on this expression\\n\" +\n         \"found   : null\\n\" +\n         \"required: Object\");\n   }\n \n   public void testPropAccess2() throws Exception {\n     testTypes(\"var bar = void 0; bar.baz;\",\n-        \"undefined has no properties\\n\" +\n+        \"No properties on this expression\\n\" +\n         \"found   : undefined\\n\" +\n         \"required: Object\");\n   }\n     // Verifies that we don't emit two warnings, because\n     // the var has been dereferenced after the first one.\n     testTypes(\"var bar = void 0; bar.baz; bar.bax;\",\n-        \"undefined has no properties\\n\" +\n+        \"No properties on this expression\\n\" +\n         \"found   : undefined\\n\" +\n         \"required: Object\");\n   }\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.testing.Asserts;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n /**\n     assertFalse(type.isEquivalentTo(null));\n     assertTrue(type.isEquivalentTo(type));\n   }\n+\n+  public void testRecursiveFunction() {\n+    ProxyObjectType loop = new ProxyObjectType(registry, NUMBER_TYPE);\n+    FunctionType fn = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters(loop))\n+        .withReturnType(loop).build();\n+\n+    loop.setReferencedType(fn);\n+    assertEquals(\"function (Function): Function\", fn.toString());\n+\n+    Asserts.assertEquivalenceOperations(fn, loop);\n+  }\n }\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/jstype/RecordTypeTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.testing.Asserts;\n+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+\n+public class RecordTypeTest extends BaseJSTypeTestCase {\n+\n+  public void testRecursiveRecord() {\n+    ProxyObjectType loop = new ProxyObjectType(registry, NUMBER_TYPE);\n+    JSType record = new RecordTypeBuilder(registry)\n+        .addProperty(\"loop\", loop, null)\n+        .addProperty(\"number\", NUMBER_TYPE, null)\n+        .addProperty(\"string\", STRING_TYPE, null)\n+        .build();\n+    assertEquals(\"{loop: number, number: number, string: string}\",\n+        record.toString());\n+\n+    loop.setReferencedType(record);\n+    assertEquals(\"{loop: {...}, number: number, string: string}\",\n+        record.toString());\n+\n+    Asserts.assertEquivalenceOperations(record, loop);\n+  }\n+\n+  public void testLongToString() {\n+    JSType record = new RecordTypeBuilder(registry)\n+        .addProperty(\"a1\", NUMBER_TYPE, null)\n+        .addProperty(\"a2\", NUMBER_TYPE, null)\n+        .addProperty(\"a3\", NUMBER_TYPE, null)\n+        .addProperty(\"a4\", NUMBER_TYPE, null)\n+        .addProperty(\"a5\", NUMBER_TYPE, null)\n+        .addProperty(\"a6\", NUMBER_TYPE, null)\n+        .build();\n+    assertEquals(\"{a1: number, a2: number, a3: number, a4: number, ...}\",\n+        record.toString());\n+  }\n+}", "timestamp": 1317769453, "metainfo": ""}