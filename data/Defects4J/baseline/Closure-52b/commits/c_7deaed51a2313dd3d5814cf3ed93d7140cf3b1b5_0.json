{"sha": "7deaed51a2313dd3d5814cf3ed93d7140cf3b1b5", "log": "build rhino as part of normal ant build  R=johnlenz DELTA=86  (51 added, 8 deleted, 27 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2413   ", "commit": "\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/ClassDefinitionException.java\n+\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * @deprecated The exception is no longer thrown by Rhino runtime as\n+ * {@link EvaluatorException} is used instead.\n+ */\n+public class ClassDefinitionException extends RuntimeException\n+{\n+    static final long serialVersionUID = -5637830967241712746L;\n+\n+    public ClassDefinitionException(String detail) {\n+        super(detail);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/NotAFunctionException.java\n+\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * @deprecated The exception is no longer thrown by Rhino runtime as\n+ * {@link EvaluatorException} is used instead.\n+ */\n+public class NotAFunctionException extends RuntimeException\n+{\n+    static final long serialVersionUID = 6461524852170711724L;\n+\n+    public NotAFunctionException() { }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/PropertyException.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * @deprecated This exception is no longer thrown by Rhino runtime.\n+ */\n+public class PropertyException extends RuntimeException\n+{\n+    static final long serialVersionUID = -8221564865490676219L;\n+\n+    public PropertyException(String detail) {\n+        super(detail);\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/xml/impl/xmlbeans/LogicalEquality.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Ethan Hugg\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml.impl.xmlbeans;\n+\n+import org.apache.xmlbeans.XmlCursor;\n+\n+import java.util.*;\n+\n+\n+public class LogicalEquality\n+{\n+    public static boolean nodesEqual(XmlCursor xmlOne, XmlCursor xmlTwo)\n+    {\n+        boolean result = false;\n+\n+        if (xmlOne.isStartdoc())\n+        {\n+            xmlOne.toFirstContentToken();\n+        }\n+\n+        if (xmlTwo.isStartdoc())\n+        {\n+            xmlTwo.toFirstContentToken();\n+        }\n+\n+        if (xmlOne.currentTokenType() == xmlTwo.currentTokenType())\n+        {\n+            if (xmlOne.isEnddoc())\n+            {\n+                // Both empty\n+                result = true;\n+            }\n+            else if (xmlOne.isAttr())\n+            {\n+                result = attributesEqual(xmlOne, xmlTwo);\n+            }\n+            else if (xmlOne.isText())\n+            {\n+                result = textNodesEqual(xmlOne, xmlTwo);\n+            }\n+            else if (xmlOne.isComment())\n+            {\n+                result = commentsEqual(xmlOne, xmlTwo);\n+            }\n+            else if (xmlOne.isProcinst())\n+            {\n+                result = processingInstructionsEqual(xmlOne, xmlTwo);\n+            }\n+            else if (xmlOne.isStart())\n+            {\n+                // Compare root elements\n+                result = elementsEqual(xmlOne, xmlTwo);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private static boolean elementsEqual(XmlCursor xmlOne, XmlCursor xmlTwo)\n+    {\n+        boolean result = true;\n+\n+        if (!qnamesEqual(xmlOne.getName(), xmlTwo.getName()))\n+        {\n+            result = false;\n+        }\n+        else\n+        {\n+            // These filter out empty text nodes.\n+            nextToken(xmlOne);\n+            nextToken(xmlTwo);\n+\n+            do\n+            {\n+                if (xmlOne.currentTokenType() != xmlTwo.currentTokenType())\n+                {\n+                    // Not same token\n+                    result = false;\n+                    break;\n+                }\n+                else if (xmlOne.isEnd())\n+                {\n+                    // Done with this element, step over end\n+                    break;\n+                }\n+                else if (xmlOne.isEnddoc())\n+                {\n+                    // Shouldn't get here\n+                    break;\n+                }\n+                else if (xmlOne.isAttr())\n+                {\n+                    // This one will move us to the first non-attr token.\n+                    result = attributeListsEqual(xmlOne, xmlTwo);\n+                }\n+                else\n+                {\n+                    if (xmlOne.isText())\n+                    {\n+                        result = textNodesEqual(xmlOne, xmlTwo);\n+                    }\n+                    else if (xmlOne.isComment())\n+                    {\n+                        result = commentsEqual(xmlOne, xmlTwo);\n+                    }\n+                    else if (xmlOne.isProcinst())\n+                    {\n+                        result = processingInstructionsEqual(xmlOne, xmlTwo);\n+                    }\n+                    else if (xmlOne.isStart())\n+                    {\n+                        result = elementsEqual(xmlOne, xmlTwo);\n+                    }\n+                    else\n+                    {\n+                        //XML.log(\"Unknown token type\" + xmlOne.currentTokenType());\n+                    }\n+\n+                    // These filter out empty text nodes.\n+                    nextToken(xmlOne);\n+                    nextToken(xmlTwo);\n+                }\n+            }\n+            while(result);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param xmlOne\n+     * @param xmlTwo\n+     * @return\n+     */\n+    private static boolean attributeListsEqual(XmlCursor xmlOne, XmlCursor xmlTwo)\n+    {\n+        boolean result = true;\n+        TreeMap mapOne = loadAttributeMap(xmlOne);\n+        TreeMap mapTwo = loadAttributeMap(xmlTwo);\n+\n+        if (mapOne.size() != mapTwo.size())\n+        {\n+            result = false;\n+        }\n+        else\n+        {\n+            Set keysOne = mapOne.keySet();\n+            Set keysTwo = mapTwo.keySet();\n+            Iterator itOne = keysOne.iterator();\n+            Iterator itTwo = keysTwo.iterator();\n+\n+            while (result && itOne.hasNext())\n+            {\n+                String valueOne = (String) itOne.next();\n+                String valueTwo = (String) itTwo.next();\n+\n+                if (!valueOne.equals(valueTwo))\n+                {\n+                    result = false;\n+                }\n+                else\n+                {\n+                    javax.xml.namespace.QName qnameOne = (javax.xml.namespace.QName) mapOne.get(valueOne);\n+                    javax.xml.namespace.QName qnameTwo = (javax.xml.namespace.QName) mapTwo.get(valueTwo);\n+\n+                    if (!qnamesEqual(qnameOne, qnameTwo))\n+                    {\n+                        result = false;\n+                    }\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param xml\n+     * @return\n+     */\n+    private static TreeMap loadAttributeMap(XmlCursor xml)\n+    {\n+        TreeMap result = new TreeMap();\n+\n+        while (xml.isAttr())\n+        {\n+            result.put(xml.getTextValue(), xml.getName());\n+            nextToken(xml);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param xmlOne\n+     * @param xmlTwo\n+     * @return\n+     */\n+    private static boolean attributesEqual(XmlCursor xmlOne, XmlCursor xmlTwo)\n+    {\n+        boolean result = false;\n+\n+        if (xmlOne.isAttr() && xmlTwo.isAttr())\n+        {\n+            if (qnamesEqual(xmlOne.getName(), xmlTwo.getName()))\n+            {\n+                if (xmlOne.getTextValue().equals(xmlTwo.getTextValue()))\n+                {\n+                    result = true;\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param xmlOne\n+     * @param xmlTwo\n+     * @return\n+     */\n+    private static boolean textNodesEqual(XmlCursor xmlOne, XmlCursor xmlTwo)\n+    {\n+        boolean result = false;\n+\n+        if (xmlOne.isText() && xmlTwo.isText())\n+        {\n+            if (xmlOne.getChars().equals(xmlTwo.getChars()))\n+            {\n+                result = true;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param xmlOne\n+     * @param xmlTwo\n+     * @return\n+     */\n+    private static boolean commentsEqual(XmlCursor xmlOne, XmlCursor xmlTwo)\n+    {\n+        boolean result = false;\n+\n+        if (xmlOne.isComment() && xmlTwo.isComment())\n+        {\n+            if (xmlOne.getTextValue().equals(xmlTwo.getTextValue()))\n+            {\n+                result = true;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param xmlOne\n+     * @param xmlTwo\n+     * @return\n+     */\n+    private static boolean processingInstructionsEqual(XmlCursor xmlOne, XmlCursor xmlTwo)\n+    {\n+        boolean result = false;\n+\n+        if (xmlOne.isProcinst() && xmlTwo.isProcinst())\n+        {\n+            if (qnamesEqual(xmlOne.getName(), xmlTwo.getName()))\n+            {\n+                if (xmlOne.getTextValue().equals(xmlTwo.getTextValue()))\n+                {\n+                    result = true;\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param qnameOne\n+     * @param qnameTwo\n+     * @return\n+     */\n+    private static boolean qnamesEqual(javax.xml.namespace.QName qnameOne, javax.xml.namespace.QName qnameTwo)\n+    {\n+        boolean result = false;\n+\n+        if (qnameOne.getNamespaceURI().equals(qnameTwo.getNamespaceURI()))\n+        {\n+            if (qnameOne.getLocalPart().equals(qnameTwo.getLocalPart()))\n+            {\n+                return true;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * filter out empty textNodes here\n+     *\n+     * @param xml\n+     */\n+    private static void nextToken(XmlCursor xml)\n+    {\n+        do\n+        {\n+            xml.toNextToken();\n+\n+            if (!xml.isText())\n+            {\n+                // Not a text node\n+                break;\n+            }\n+            else if (xml.getChars().trim().length() > 0)\n+            {\n+                // Text node is not empty\n+                break;\n+            }\n+        }\n+        while (true);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/xml/impl/xmlbeans/Namespace.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml.impl.xmlbeans;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * Class Namespace\n+ *\n+ */\n+class Namespace extends IdScriptableObject\n+{\n+    static final long serialVersionUID = -5765755238131301744L;\n+\n+    private static final Object NAMESPACE_TAG = \"Namespace\";\n+\n+    private XMLLibImpl lib;\n+    private String prefix;\n+    private String uri;\n+\n+    public Namespace(XMLLibImpl lib, String uri)\n+    {\n+        super(lib.globalScope(), lib.namespacePrototype);\n+\n+        if (uri == null)\n+            throw new IllegalArgumentException();\n+\n+        this.lib = lib;\n+        this.prefix = (uri.length() == 0) ? \"\" : null;\n+        this.uri = uri;\n+    }\n+\n+\n+    public Namespace(XMLLibImpl lib, String prefix, String uri)\n+    {\n+        super(lib.globalScope(), lib.namespacePrototype);\n+\n+        if (uri == null)\n+            throw new IllegalArgumentException();\n+        if (uri.length() == 0) {\n+            // prefix should be \"\" for empty uri\n+            if (prefix == null)\n+                throw new IllegalArgumentException();\n+            if (prefix.length() != 0)\n+                throw new IllegalArgumentException();\n+        }\n+\n+        this.lib = lib;\n+        this.prefix = prefix;\n+        this.uri = uri;\n+    }\n+\n+    public void exportAsJSClass(boolean sealed)\n+    {\n+        exportAsJSClass(MAX_PROTOTYPE_ID, lib.globalScope(), sealed);\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public String uri()\n+    {\n+        return uri;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public String prefix()\n+    {\n+        return prefix;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public String toString ()\n+    {\n+        return uri();\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public String toLocaleString ()\n+    {\n+        return toString();\n+    }\n+\n+    public boolean equals(Object obj)\n+    {\n+        if (!(obj instanceof Namespace)) return false;\n+        return equals((Namespace)obj);\n+    }\n+\n+    protected Object equivalentValues(Object value)\n+    {\n+        if (!(value instanceof Namespace)) return Scriptable.NOT_FOUND;\n+        boolean result = equals((Namespace)value);\n+        return result ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    private boolean equals(Namespace n)\n+    {\n+        return uri().equals(n.uri());\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public String getClassName ()\n+    {\n+        return \"Namespace\";\n+    }\n+\n+    /**\n+     *\n+     * @param hint\n+     * @return\n+     */\n+    public Object getDefaultValue (Class hint)\n+    {\n+        return uri();\n+    }\n+\n+// #string_id_map#\n+    private static final int\n+        Id_prefix               = 1,\n+        Id_uri                  = 2,\n+        MAX_INSTANCE_ID         = 2;\n+\n+    protected int getMaxInstanceId()\n+    {\n+        return super.getMaxInstanceId() + MAX_INSTANCE_ID;\n+    }\n+\n+    protected int findInstanceIdInfo(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2004-07-20 19:50:50 CEST\n+        L0: { id = 0; String X = null;\n+            int s_length = s.length();\n+            if (s_length==3) { X=\"uri\";id=Id_uri; }\n+            else if (s_length==6) { X=\"prefix\";id=Id_prefix; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+\n+        if (id == 0) return super.findInstanceIdInfo(s);\n+\n+        int attr;\n+        switch (id) {\n+          case Id_prefix:\n+          case Id_uri:\n+            attr = PERMANENT | READONLY;\n+            break;\n+          default: throw new IllegalStateException();\n+        }\n+        return instanceIdInfo(attr, super.getMaxInstanceId() + id);\n+    }\n+// #/string_id_map#\n+\n+    protected String getInstanceIdName(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_prefix: return \"prefix\";\n+          case Id_uri: return \"uri\";\n+        }\n+        return super.getInstanceIdName(id);\n+    }\n+\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_prefix:\n+            if (prefix == null) return Undefined.instance;\n+            return prefix;\n+          case Id_uri:\n+            return uri;\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+\n+// #string_id_map#\n+    private static final int\n+        Id_constructor          = 1,\n+        Id_toString             = 2,\n+        Id_toSource             = 3,\n+        MAX_PROTOTYPE_ID        = 3;\n+\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2004-08-21 12:07:01 CEST\n+        L0: { id = 0; String X = null; int c;\n+            int s_length = s.length();\n+            if (s_length==8) {\n+                c=s.charAt(3);\n+                if (c=='o') { X=\"toSource\";id=Id_toSource; }\n+                else if (c=='t') { X=\"toString\";id=Id_toString; }\n+            }\n+            else if (s_length==11) { X=\"constructor\";id=Id_constructor; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+// #/string_id_map#\n+\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor: arity=2; s=\"constructor\"; break;\n+          case Id_toString:    arity=0; s=\"toString\";    break;\n+          case Id_toSource:    arity=0; s=\"toSource\";    break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(NAMESPACE_TAG, id, s, arity);\n+    }\n+\n+    public Object execIdCall(IdFunctionObject f,\n+                             Context cx,\n+                             Scriptable scope,\n+                             Scriptable thisObj,\n+                             Object[] args)\n+    {\n+        if (!f.hasTag(NAMESPACE_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_constructor:\n+            return jsConstructor(cx, (thisObj == null), args);\n+          case Id_toString:\n+            return realThis(thisObj, f).toString();\n+          case Id_toSource:\n+            return realThis(thisObj, f).js_toSource();\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private Namespace realThis(Scriptable thisObj, IdFunctionObject f)\n+    {\n+        if(!(thisObj instanceof Namespace))\n+            throw incompatibleCallError(f);\n+        return (Namespace)thisObj;\n+    }\n+\n+    private Object jsConstructor(Context cx, boolean inNewExpr, Object[] args)\n+    {\n+        if (!inNewExpr && args.length == 1) {\n+            return lib.castToNamespace(cx, args[0]);\n+        }\n+\n+        if (args.length == 0) {\n+            return lib.constructNamespace(cx);\n+        } else if (args.length == 1) {\n+            return lib.constructNamespace(cx, args[0]);\n+        } else {\n+            return lib.constructNamespace(cx, args[0], args[1]);\n+        }\n+    }\n+\n+    private String js_toSource()\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        toSourceImpl(prefix, uri, sb);\n+        sb.append(')');\n+        return sb.toString();\n+    }\n+\n+    static void toSourceImpl(String prefix, String uri, StringBuffer sb)\n+    {\n+        sb.append(\"new Namespace(\");\n+        if (uri.length() == 0) {\n+            if (!\"\".equals(prefix)) throw new IllegalArgumentException(prefix);\n+        } else {\n+            sb.append('\\'');\n+            if (prefix != null) {\n+                sb.append(ScriptRuntime.escapeString(prefix, '\\''));\n+                sb.append(\"', '\");\n+            }\n+            sb.append(ScriptRuntime.escapeString(uri, '\\''));\n+            sb.append('\\'');\n+        }\n+        sb.append(')');\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/xml/impl/xmlbeans/NamespaceHelper.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml.impl.xmlbeans;\n+\n+import java.util.*;\n+import org.apache.xmlbeans.XmlCursor;\n+\n+import org.mozilla.javascript.*;\n+\n+class NamespaceHelper\n+{\n+    private XMLLibImpl lib;\n+    private final Map prefixToURI = new HashMap();\n+    private final Map uriToPrefix = new HashMap();\n+    // A set of URIs that are used without explicit namespace declaration in scope.\n+    private final Set undeclared = new HashSet();\n+\n+    private NamespaceHelper(XMLLibImpl lib)\n+    {\n+        this.lib = lib;\n+        // Insert the default namespace\n+        prefixToURI.put(\"\", \"\");\n+        Set prefixes = new HashSet();\n+        prefixes.add(\"\");\n+        uriToPrefix.put(\"\", prefixes);\n+    }\n+\n+    /**\n+     * Declared a new namespace\n+     *\n+     * @param prefix\n+     * @param uri\n+     * @param declarations\n+     */\n+    private void declareNamespace(String prefix, String uri, ObjArray declarations)\n+    {\n+        Set prefixes = (Set)uriToPrefix.get(uri);\n+        if(prefixes == null)\n+        {\n+            prefixes = new HashSet();\n+            uriToPrefix.put(uri, prefixes);\n+        }\n+\n+        if(!prefixes.contains(prefix))\n+        {\n+            String oldURI = (String)prefixToURI.get(prefix);\n+\n+            // Add the new mapping\n+            prefixes.add(prefix);\n+            prefixToURI.put(prefix, uri);\n+            if(declarations != null)\n+                declarations.add(new Namespace(lib, prefix, uri));\n+\n+            if(oldURI != null)\n+            {\n+                // Update the existing mapping\n+                prefixes = (Set)uriToPrefix.get(oldURI);\n+                prefixes.remove(prefix);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Updates the internal state of this NamespaceHelper to reflect the\n+     * existance of the XML token pointed to by the cursor.\n+     */\n+    private void processName(XmlCursor cursor, ObjArray declarations)\n+    {\n+        javax.xml.namespace.QName qname = cursor.getName();\n+        String uri = qname.getNamespaceURI();\n+        Set prefixes = (Set)uriToPrefix.get(uri);\n+        if(prefixes == null || prefixes.size() == 0)\n+        {\n+            undeclared.add(uri);\n+            if(declarations != null)\n+                declarations.add(new Namespace(lib, uri));\n+        }\n+    }\n+\n+    /**\n+     * Updates the internal state of this NamespaceHelper with the\n+     * namespace information of the element pointed to by the cursor.\n+     */\n+    private void update(XmlCursor cursor, ObjArray declarations)\n+    {\n+        // Process the Namespace declarations\n+        cursor.push();\n+        while(cursor.toNextToken().isAnyAttr())\n+        {\n+            if(cursor.isNamespace())\n+            {\n+                javax.xml.namespace.QName name = cursor.getName();\n+                String prefix = name.getLocalPart();\n+                String uri = name.getNamespaceURI();\n+\n+                declareNamespace(prefix, uri, declarations);\n+            }\n+        }\n+        cursor.pop();\n+\n+        // Process the element\n+        processName(cursor, declarations);\n+\n+        // Process the attributes\n+        cursor.push();\n+        boolean hasNext = cursor.toFirstAttribute();\n+        while(hasNext)\n+        {\n+            processName(cursor, declarations);\n+            hasNext = cursor.toNextAttribute();\n+        }\n+        cursor.pop();\n+    }\n+\n+    /**\n+     * @return Object[] array of Namespace objects in scope at the cursor.\n+     */\n+    public static Object[] inScopeNamespaces(XMLLibImpl lib, XmlCursor cursor)\n+    {\n+        ObjArray namespaces = new ObjArray();\n+        NamespaceHelper helper = new NamespaceHelper(lib);\n+\n+        cursor.push();\n+\n+        int depth = 0;\n+        while(cursor.hasPrevToken())\n+        {\n+            if(cursor.isContainer())\n+            {\n+                cursor.push();\n+                depth++;\n+            }\n+\n+            cursor.toParent();\n+        }\n+\n+        for(int i = 0; i < depth; i++)\n+        {\n+            cursor.pop();\n+            helper.update(cursor, null);\n+        }\n+\n+        Iterator i = helper.prefixToURI.entrySet().iterator();\n+        while(i.hasNext())\n+        {\n+            Map.Entry entry = (Map.Entry)i.next();\n+            Namespace ns = new Namespace(lib, (String)entry.getKey(),\n+                                            (String)entry.getValue());\n+            namespaces.add(ns);\n+        }\n+\n+        i = helper.undeclared.iterator();\n+        while(i.hasNext())\n+        {\n+            Namespace ns = new Namespace(lib, (String)i.next());\n+            namespaces.add(ns);\n+        }\n+\n+        cursor.pop();\n+\n+        return namespaces.toArray();\n+    }\n+\n+    static Namespace getNamespace(XMLLibImpl lib, XmlCursor cursor,\n+                                  Object[] inScopeNamespaces)\n+    {\n+        String uri;\n+        String prefix;\n+\n+        if (cursor.isProcinst()) {\n+            uri = \"\";\n+            prefix = \"\";\n+        } else {\n+            javax.xml.namespace.QName qname = cursor.getName();\n+            uri = qname.getNamespaceURI();\n+            prefix = qname.getPrefix();\n+        }\n+\n+        if (inScopeNamespaces == null)\n+            return new Namespace(lib, prefix, uri);\n+\n+        Namespace result = null;\n+        for (int i = 0; i != inScopeNamespaces.length; ++i) {\n+            Namespace ns = (Namespace)inScopeNamespaces[i];\n+            if(ns == null) continue;\n+\n+            String nsURI = ns.uri();\n+            if(nsURI.equals(uri))\n+            {\n+                if(prefix.equals(ns.prefix()))\n+                {\n+                    result = ns;\n+                    break;\n+                }\n+\n+                if(result == null ||\n+                   (result.prefix() == null &&\n+                    ns.prefix() != null))\n+                    result = ns;\n+            }\n+        }\n+\n+        if(result == null)\n+            result = new Namespace(lib, prefix, uri);\n+\n+        return result;\n+    }\n+\n+    /**\n+     * @return List of Namespace objects that are declared in the container pointed to by the cursor.\n+     */\n+    public static Object[] namespaceDeclarations(XMLLibImpl lib, XmlCursor cursor)\n+    {\n+        ObjArray declarations = new ObjArray();\n+        NamespaceHelper helper = new NamespaceHelper(lib);\n+\n+        cursor.push();\n+\n+        int depth = 0;\n+        while(cursor.hasPrevToken())\n+        {\n+            if(cursor.isContainer())\n+            {\n+                cursor.push();\n+                depth++;\n+            }\n+\n+            cursor.toParent();\n+        }\n+\n+        for(int i = 0; i < depth - 1; i++)\n+        {\n+            cursor.pop();\n+            helper.update(cursor, null);\n+        }\n+\n+        if(depth > 0)\n+        {\n+            cursor.pop();\n+            helper.update(cursor, declarations);\n+        }\n+\n+        cursor.pop();\n+\n+        return declarations.toArray();\n+    }\n+\n+    /**\n+     * @return Prefix to URI map of all namespaces in scope at the cursor.\n+     */\n+    public static Map getAllNamespaces(XMLLibImpl lib, XmlCursor cursor)\n+    {\n+        NamespaceHelper helper = new NamespaceHelper(lib);\n+\n+        cursor.push();\n+\n+        int depth = 0;\n+        while(cursor.hasPrevToken())\n+        {\n+            if(cursor.isContainer())\n+            {\n+                cursor.push();\n+                depth++;\n+            }\n+\n+            cursor.toParent();\n+        }\n+\n+        for(int i = 0; i < depth; i++)\n+        {\n+            cursor.pop();\n+            helper.update(cursor, null);\n+        }\n+\n+        cursor.pop();\n+\n+        return helper.prefixToURI;\n+    }\n+\n+    public static void getNamespaces(XmlCursor cursor, Map prefixToURI)\n+    {\n+        cursor.push();\n+        while(cursor.toNextToken().isAnyAttr())\n+        {\n+            if(cursor.isNamespace())\n+            {\n+                javax.xml.namespace.QName name = cursor.getName();\n+                String prefix = name.getLocalPart();\n+                String uri = name.getNamespaceURI();\n+\n+                prefixToURI.put(prefix, uri);\n+            }\n+        }\n+        cursor.pop();\n+    }\n+\n+    public static void removeNamespace(XmlCursor cursor, String prefix)\n+    {\n+        cursor.push();\n+        while(cursor.toNextToken().isAnyAttr())\n+        {\n+            if(cursor.isNamespace())\n+            {\n+                javax.xml.namespace.QName name = cursor.getName();\n+                if(name.getLocalPart().equals(prefix))\n+                {\n+                    cursor.removeXml();\n+                    break;\n+                }\n+            }\n+        }\n+        cursor.pop();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/xml/impl/xmlbeans/QName.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml.impl.xmlbeans;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * Class QName\n+ *\n+ */\n+final class QName extends IdScriptableObject\n+{\n+    static final long serialVersionUID = 416745167693026750L;\n+\n+    private static final Object QNAME_TAG = \"QName\";\n+\n+    XMLLibImpl lib;\n+    private String prefix;\n+    private String localName;\n+    private String uri;\n+\n+    QName(XMLLibImpl lib, String uri, String localName, String prefix)\n+    {\n+        super(lib.globalScope(), lib.qnamePrototype);\n+        if (localName == null) throw new IllegalArgumentException();\n+        this.lib = lib;\n+        this.uri = uri;\n+        this.prefix = prefix;\n+        this.localName = localName;\n+    }\n+\n+    void exportAsJSClass(boolean sealed)\n+    {\n+        exportAsJSClass(MAX_PROTOTYPE_ID, lib.globalScope(), sealed);\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public String toString()\n+    {\n+        String result;\n+\n+        if (uri == null)\n+        {\n+            result = \"*::\".concat(localName);\n+        }\n+        else if(uri.length() == 0)\n+        {\n+            result = localName;\n+        }\n+        else\n+        {\n+            result = uri + \"::\" + localName;\n+        }\n+\n+        return result;\n+    }\n+\n+    public String localName()\n+    {\n+        return localName;\n+    }\n+\n+    String prefix()\n+    {\n+        return (prefix == null) ? prefix : \"\";\n+    }\n+\n+    String uri()\n+    {\n+        return uri;\n+    }\n+\n+    public boolean equals(Object obj)\n+    {\n+        if(!(obj instanceof QName)) return false;\n+        return equals((QName)obj);\n+    }\n+\n+    protected Object equivalentValues(Object value)\n+    {\n+        if(!(value instanceof QName)) return Scriptable.NOT_FOUND;\n+        boolean result = equals((QName)value);\n+        return result ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    private boolean equals(QName q)\n+    {\n+        boolean result;\n+\n+        if (uri == null) {\n+            result = q.uri == null && localName.equals(q.localName);\n+        } else {\n+            result = uri.equals(q.uri) && localName.equals(q.localName);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public String getClassName ()\n+    {\n+        return \"QName\";\n+    }\n+\n+    /**\n+     *\n+     * @param hint\n+     * @return\n+     */\n+    public Object getDefaultValue (Class hint)\n+    {\n+        return toString();\n+    }\n+\n+// #string_id_map#\n+    private static final int\n+        Id_localName            = 1,\n+        Id_uri                  = 2,\n+        MAX_INSTANCE_ID         = 2;\n+\n+    protected int getMaxInstanceId()\n+    {\n+        return super.getMaxInstanceId() + MAX_INSTANCE_ID;\n+    }\n+\n+    protected int findInstanceIdInfo(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2004-07-18 12:32:51 CEST\n+        L0: { id = 0; String X = null;\n+            int s_length = s.length();\n+            if (s_length==3) { X=\"uri\";id=Id_uri; }\n+            else if (s_length==9) { X=\"localName\";id=Id_localName; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+\n+        if (id == 0) return super.findInstanceIdInfo(s);\n+\n+        int attr;\n+        switch (id) {\n+          case Id_localName:\n+          case Id_uri:\n+            attr = PERMANENT | READONLY;\n+            break;\n+          default: throw new IllegalStateException();\n+        }\n+        return instanceIdInfo(attr, super.getMaxInstanceId() + id);\n+    }\n+// #/string_id_map#\n+\n+    protected String getInstanceIdName(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_localName: return \"localName\";\n+          case Id_uri: return \"uri\";\n+        }\n+        return super.getInstanceIdName(id);\n+    }\n+\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_localName: return localName;\n+          case Id_uri: return uri;\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+// #string_id_map#\n+    private static final int\n+        Id_constructor          = 1,\n+        Id_toString             = 2,\n+        Id_toSource             = 3,\n+        MAX_PROTOTYPE_ID        = 3;\n+\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2004-08-21 12:45:13 CEST\n+        L0: { id = 0; String X = null; int c;\n+            int s_length = s.length();\n+            if (s_length==8) {\n+                c=s.charAt(3);\n+                if (c=='o') { X=\"toSource\";id=Id_toSource; }\n+                else if (c=='t') { X=\"toString\";id=Id_toString; }\n+            }\n+            else if (s_length==11) { X=\"constructor\";id=Id_constructor; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+// #/string_id_map#\n+\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor: arity=2; s=\"constructor\"; break;\n+          case Id_toString:    arity=0; s=\"toString\";    break;\n+          case Id_toSource:    arity=0; s=\"toSource\";    break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(QNAME_TAG, id, s, arity);\n+    }\n+\n+    public Object execIdCall(IdFunctionObject f,\n+                             Context cx,\n+                             Scriptable scope,\n+                             Scriptable thisObj,\n+                             Object[] args)\n+    {\n+        if (!f.hasTag(QNAME_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_constructor:\n+            return jsConstructor(cx, (thisObj == null), args);\n+          case Id_toString:\n+            return realThis(thisObj, f).toString();\n+          case Id_toSource:\n+            return realThis(thisObj, f).js_toSource();\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private QName realThis(Scriptable thisObj, IdFunctionObject f)\n+    {\n+        if(!(thisObj instanceof QName))\n+            throw incompatibleCallError(f);\n+        return (QName)thisObj;\n+    }\n+\n+    private Object jsConstructor(Context cx, boolean inNewExpr, Object[] args)\n+    {\n+        if (!inNewExpr && args.length == 1) {\n+            return lib.castToQName(cx, args[0]);\n+        }\n+        if (args.length == 0) {\n+            return lib.constructQName(cx, Undefined.instance);\n+        } else if (args.length == 1) {\n+            return lib.constructQName(cx, args[0]);\n+        } else {\n+            return lib.constructQName(cx, args[0], args[1]);\n+        }\n+    }\n+\n+    private String js_toSource()\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        toSourceImpl(uri, localName, prefix, sb);\n+        sb.append(')');\n+        return sb.toString();\n+    }\n+\n+    private static void toSourceImpl(String uri, String localName,\n+                                     String prefix, StringBuffer sb)\n+    {\n+        sb.append(\"new QName(\");\n+        if (uri == null && prefix == null) {\n+            if (!\"*\".equals(localName)) {\n+                sb.append(\"null, \");\n+            }\n+        } else {\n+            Namespace.toSourceImpl(prefix, uri, sb);\n+            sb.append(\", \");\n+        }\n+        sb.append('\\'');\n+        sb.append(ScriptRuntime.escapeString(localName, '\\''));\n+        sb.append(\"')\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/xml/impl/xmlbeans/XML.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml.impl.xmlbeans;\n+\n+import java.io.Serializable;\n+import java.util.*;\n+\n+import org.mozilla.javascript.*;\n+\n+import org.apache.xmlbeans.XmlCursor;\n+import org.apache.xmlbeans.XmlCursor.XmlBookmark;\n+import org.apache.xmlbeans.XmlCursor.TokenType;\n+import org.apache.xmlbeans.XmlException;\n+import org.apache.xmlbeans.XmlObject;\n+import org.apache.xmlbeans.XmlOptions;\n+\n+class XML extends XMLObjectImpl\n+{\n+    static final long serialVersionUID = -630969919086449092L;\n+\n+    final static class XScriptAnnotation extends XmlBookmark implements Serializable\n+    {\n+        private static final long serialVersionUID = 1L;\n+        \n+        javax.xml.namespace.QName _name;\n+        XML _xScriptXML;\n+\n+\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        //\n+        //  Constructurs\n+        //\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+        XScriptAnnotation (XmlCursor curs)\n+        {\n+            _name = curs.getName();\n+        }\n+\n+    }\n+\n+    /**\n+     *\n+     */\n+    final static class NamespaceDeclarations\n+    {\n+        private int             _prefixIdx;\n+        private StringBuffer    _namespaceDecls;\n+        private String          _defaultNSURI;\n+\n+\n+        NamespaceDeclarations (XmlCursor curs)\n+        {\n+            _prefixIdx = 0;\n+            _namespaceDecls = new StringBuffer();\n+\n+            skipNonElements(curs);\n+            _defaultNSURI = curs.namespaceForPrefix(\"\");\n+\n+            if (isAnyDefaultNamespace())\n+            {\n+                addDecl(\"\", _defaultNSURI);\n+            }\n+        }\n+\n+\n+        private void addDecl (String prefix, String ns)\n+        {\n+            _namespaceDecls.append((prefix.length() > 0 ?\n+                                        \"declare namespace \" + prefix :\n+                                        \"default element namespace\") +\n+                                    \" = \\\"\" + ns + \"\\\"\" + \"\\n\");\n+        }\n+\n+\n+        String getNextPrefix (String ns)\n+        {\n+            String prefix = \"NS\" + _prefixIdx++;\n+\n+            _namespaceDecls.append(\"declare namespace \" + prefix + \" = \" + \"\\\"\" + ns + \"\\\"\" + \"\\n\");\n+\n+            return prefix;\n+        }\n+\n+\n+        boolean isAnyDefaultNamespace ()\n+        {\n+            return _defaultNSURI != null ?_defaultNSURI.length() > 0 : false;\n+        }\n+\n+\n+        String getDeclarations()\n+        {\n+            return _namespaceDecls.toString();\n+        }\n+    }\n+\n+    // Fields\n+    //static final XML prototype = new XML();\n+    private XScriptAnnotation _anno;\n+\n+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    //\n+    //  Constructors\n+    //\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     *\n+     * @param anno\n+     */\n+    private XML(XMLLibImpl lib, XScriptAnnotation anno)\n+    {\n+        super(lib, lib.xmlPrototype);\n+        _anno = anno;\n+        _anno._xScriptXML = this;\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    //\n+    //  Public factories for creating a XScript XML object given an XBean cursor.\n+    //\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+    static XML createEmptyXML(XMLLibImpl lib)\n+    {\n+        XScriptAnnotation anno;\n+\n+        XmlObject xo = XmlObject.Factory.newInstance();\n+        XmlCursor curs = xo.newCursor();\n+        try {\n+            anno = new XScriptAnnotation(curs);\n+            curs.setBookmark(anno);\n+        } finally {\n+            curs.dispose();\n+        }\n+\n+        return new XML(lib, anno);\n+    }\n+\n+    private static XML createXML (XMLLibImpl lib, XmlCursor curs)\n+    {\n+        if (curs.currentTokenType().isStartdoc())\n+        {\n+            curs.toFirstContentToken();\n+        }\n+\n+        XScriptAnnotation anno = findAnnotation(curs);\n+\n+        return new XML(lib, anno);\n+    }\n+\n+    /**\n+     * Special constructor for making an attribute\n+     *\n+     */\n+    private static XML createAttributeXML(XMLLibImpl lib, XmlCursor cursor)\n+    {\n+        if (!cursor.isAttr())\n+            throw new IllegalArgumentException();\n+\n+        XScriptAnnotation anno = new XScriptAnnotation(cursor);\n+        cursor.setBookmark(anno);\n+\n+        return new XML(lib, anno);\n+    }\n+\n+\n+    /**\n+     *\n+     * @param qname\n+     * @param value\n+     * @return\n+     */\n+    static XML createTextElement(XMLLibImpl lib, javax.xml.namespace.QName qname, String value)\n+    {\n+        XScriptAnnotation anno;\n+\n+        XmlObject xo = XmlObject.Factory.newInstance();\n+        XmlCursor cursor = xo.newCursor();\n+        try {\n+            cursor.toNextToken();\n+\n+            cursor.beginElement(qname.getLocalPart(), qname.getNamespaceURI());\n+            //if(namespace.length() > 0)\n+            //    cursor.insertNamespace(\"\", namespace);\n+            cursor.insertChars(value);\n+\n+            cursor.toStartDoc();\n+            cursor.toNextToken();\n+            anno = new XScriptAnnotation(cursor);\n+            cursor.setBookmark(anno);\n+        } finally {\n+            cursor.dispose();\n+        }\n+\n+        return new XML(lib, anno);\n+    }\n+\n+    static XML createFromXmlObject(XMLLibImpl lib, XmlObject xo)\n+    {\n+        XScriptAnnotation anno;\n+        XmlCursor curs = xo.newCursor();\n+        if (curs.currentTokenType().isStartdoc())\n+        {\n+            curs.toFirstContentToken();\n+        }\n+        try {\n+            anno = new XScriptAnnotation(curs);\n+            curs.setBookmark(anno);\n+        } finally {\n+            curs.dispose();\n+        }\n+        return new XML(lib, anno);\n+    }\n+\n+    static XML createFromJS(XMLLibImpl lib, Object inputObject)\n+    {\n+        XmlObject xo;\n+        boolean isText = false;\n+        String frag;\n+\n+        if (inputObject == null || inputObject == Undefined.instance) {\n+            frag = \"\";\n+        } else if (inputObject instanceof XMLObjectImpl) {\n+            // todo: faster way for XMLObjects?\n+            frag = ((XMLObjectImpl) inputObject).toXMLString(0);\n+        } else {\n+            if (inputObject instanceof Wrapper) {\n+                Object wrapped = ((Wrapper)inputObject).unwrap();\n+                if (wrapped instanceof XmlObject) {\n+                    return createFromXmlObject(lib, (XmlObject)wrapped);\n+                }\n+            }\n+            frag = ScriptRuntime.toString(inputObject);\n+        }\n+\n+        if (frag.trim().startsWith(\"<>\"))\n+        {\n+            throw ScriptRuntime.typeError(\"Invalid use of XML object anonymous tags <></>.\");\n+        }\n+\n+        if (frag.indexOf(\"<\") == -1)\n+        {\n+            // Must be solo text node, wrap in XML fragment\n+            isText = true;\n+            frag = \"<textFragment>\" + frag + \"</textFragment>\";\n+        }\n+\n+        XmlOptions options = new XmlOptions();\n+\n+        if (lib.ignoreComments)\n+        {\n+            options.put(XmlOptions.LOAD_STRIP_COMMENTS);\n+        }\n+\n+        if (lib.ignoreProcessingInstructions)\n+        {\n+            options.put(XmlOptions.LOAD_STRIP_PROCINSTS);\n+        }\n+\n+        if (lib.ignoreWhitespace)\n+        {\n+            options.put(XmlOptions.LOAD_STRIP_WHITESPACE);\n+        }\n+\n+        try\n+        {\n+            xo = XmlObject.Factory.parse(frag, options);\n+\n+            // Apply the default namespace\n+            Context cx = Context.getCurrentContext();\n+            String defaultURI = lib.getDefaultNamespaceURI(cx);\n+\n+            if(defaultURI.length() > 0)\n+            {\n+                XmlCursor cursor = xo.newCursor();\n+                boolean isRoot = true;\n+                while(!cursor.toNextToken().isEnddoc())\n+                {\n+                    if(!cursor.isStart()) continue;\n+\n+                    // Check if this element explicitly sets the\n+                    // default namespace\n+                    boolean defaultNSDeclared = false;\n+                    cursor.push();\n+                    while(cursor.toNextToken().isAnyAttr())\n+                    {\n+                        if(cursor.isNamespace())\n+                        {\n+                            if(cursor.getName().getLocalPart().length() == 0)\n+                            {\n+                                defaultNSDeclared = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    cursor.pop();\n+                    if(defaultNSDeclared)\n+                    {\n+                        cursor.toEndToken();\n+                        continue;\n+                    }\n+\n+                    // Check if this element's name is in no namespace\n+                    javax.xml.namespace.QName qname = cursor.getName();\n+                    if(qname.getNamespaceURI().length() == 0)\n+                    {\n+                        // Change the namespace\n+                        qname = new javax.xml.namespace.QName(defaultURI,\n+                                                              qname.getLocalPart());\n+                        cursor.setName(qname);\n+                    }\n+\n+                    if(isRoot)\n+                    {\n+                        // Declare the default namespace\n+                        cursor.push();\n+                        cursor.toNextToken();\n+                        cursor.insertNamespace(\"\", defaultURI);\n+                        cursor.pop();\n+\n+                        isRoot = false;\n+                    }\n+                }\n+                cursor.dispose();\n+            }\n+        }\n+        catch (XmlException xe)\n+        {\n+/*\n+todo need to handle namespace prefix not found in XML look for namespace type in the scope change.\n+\n+            String errorMsg = \"Use of undefined namespace prefix: \";\n+            String msg = xe.getError().getMessage();\n+            if (msg.startsWith(errorMsg))\n+            {\n+                String prefix = msg.substring(errorMsg.length());\n+            }\n+*/\n+            String errMsg = xe.getMessage();\n+            if (errMsg.equals(\"error: Unexpected end of file after null\"))\n+            {\n+                // Create an empty document.\n+                xo = XmlObject.Factory.newInstance();\n+            }\n+            else\n+            {\n+                throw ScriptRuntime.typeError(xe.getMessage());\n+            }\n+        }\n+        catch (Throwable e)\n+        {\n+            // todo: TLL Catch specific exceptions during parse.\n+            throw ScriptRuntime.typeError(\"Not Parsable as XML\");\n+        }\n+\n+        XmlCursor curs = xo.newCursor();\n+        if (curs.currentTokenType().isStartdoc())\n+        {\n+            curs.toFirstContentToken();\n+        }\n+\n+        if (isText)\n+        {\n+            // Move it to point to the text node\n+            curs.toFirstContentToken();\n+        }\n+\n+        XScriptAnnotation anno;\n+        try\n+        {\n+            anno = new XScriptAnnotation(curs);\n+            curs.setBookmark(anno);\n+        }\n+        finally\n+        {\n+            curs.dispose();\n+        }\n+\n+        return new XML(lib, anno);\n+    }\n+\n+    static XML getFromAnnotation(XMLLibImpl lib, XScriptAnnotation anno)\n+    {\n+        if (anno._xScriptXML == null)\n+        {\n+            anno._xScriptXML = new XML(lib, anno);\n+        }\n+\n+        return anno._xScriptXML;\n+    }\n+\n+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    //\n+    //  Private functions:\n+    //\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     *\n+     * @param curs\n+     * @return\n+     */\n+    private static TokenType skipNonElements (XmlCursor curs)\n+    {\n+        TokenType tt = curs.currentTokenType();\n+        while (tt.isComment() || tt.isProcinst())\n+        {\n+            tt = curs.toNextToken();\n+        }\n+\n+        return tt;\n+    }\n+\n+    /**\n+     *\n+     * @param curs\n+     * @return\n+     */\n+    protected static XScriptAnnotation findAnnotation(XmlCursor curs)\n+    {\n+        XmlBookmark anno = curs.getBookmark(XScriptAnnotation.class);\n+        if (anno == null)\n+        {\n+            anno = new XScriptAnnotation(curs);\n+            curs.setBookmark(anno);\n+        }\n+\n+        return (XScriptAnnotation)anno;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private XmlOptions getOptions()\n+    {\n+        XmlOptions options = new XmlOptions();\n+\n+        if (lib.ignoreComments)\n+        {\n+            options.put(XmlOptions.LOAD_STRIP_COMMENTS);\n+        }\n+\n+        if (lib.ignoreProcessingInstructions)\n+        {\n+            options.put(XmlOptions.LOAD_STRIP_PROCINSTS);\n+        }\n+\n+        if (lib.ignoreWhitespace)\n+        {\n+            options.put(XmlOptions.LOAD_STRIP_WHITESPACE);\n+        }\n+\n+        if (lib.prettyPrinting)\n+        {\n+            options.put(XmlOptions.SAVE_PRETTY_PRINT, null);\n+            options.put(XmlOptions.SAVE_PRETTY_PRINT_INDENT, new Integer(lib.prettyIndent));\n+        }\n+\n+        return options;\n+    }\n+\n+\n+    /**\n+     *\n+     * @param cursor\n+     * @param opts\n+     * @return\n+     */\n+    private static String dumpNode(XmlCursor cursor, XmlOptions opts)\n+    {\n+        if (cursor.isText())\n+            return cursor.getChars();\n+\n+        if (cursor.isFinish())\n+            return \"\";\n+\n+        cursor.push();\n+        boolean wanRawText = cursor.isStartdoc() && !cursor.toFirstChild();\n+        cursor.pop();\n+\n+        return wanRawText ? cursor.getTextValue() : cursor.xmlText( opts );\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private XmlCursor newCursor ()\n+    {\n+        XmlCursor curs;\n+\n+        if (_anno != null)\n+        {\n+            curs = _anno.createCursor();\n+            if (curs == null)\n+            {\n+                // Orphaned case.\n+                XmlObject doc = XmlObject.Factory.newInstance();\n+                curs = doc.newCursor();\n+\n+                if (_anno._name != null)\n+                {\n+                    curs.toNextToken();\n+                    curs.insertElement(_anno._name);\n+                    curs.toPrevSibling();\n+                }\n+\n+                curs.setBookmark(_anno);\n+            }\n+        }\n+        else\n+        {\n+            XmlObject doc = XmlObject.Factory.newInstance();\n+            curs = doc.newCursor();\n+        }\n+\n+        return curs;\n+    }\n+\n+    /*\n+     * fUseStartDoc used by child(int index) the index is at startDoc is the element at the top-level\n+     *              otherwise we always want to drill in.\n+     */\n+    private boolean moveToChild(XmlCursor curs, long index, boolean fFirstChild, boolean fUseStartDoc)\n+    {\n+        if (index < 0)\n+            throw new IllegalArgumentException();\n+\n+        long idxChild = 0;\n+\n+        if (!fUseStartDoc && curs.currentTokenType().isStartdoc())\n+        {\n+            // We always move to the children of the top node.\n+            // todo:  This assumes that we want have multiple top-level nodes.  Which we should be able tohave.\n+            curs.toFirstContentToken();\n+        }\n+\n+        TokenType tt = curs.toFirstContentToken();\n+        if (!tt.isNone() && !tt.isEnd())\n+        {\n+            while (true)\n+            {\n+                if (index == idxChild)\n+                {\n+                    return true;\n+                }\n+\n+                tt = curs.currentTokenType();\n+                if (tt.isText())\n+                {\n+                    curs.toNextToken();\n+                }\n+                else if (tt.isStart())\n+                {\n+                    // Need to do this we want to be pointing at the text if that after the end token.\n+                    curs.toEndToken();\n+                    curs.toNextToken();\n+                }\n+                else if (tt.isComment() || tt.isProcinst())\n+                {\n+                    continue;\n+                }\n+                else\n+                {\n+                    break;\n+                }\n+\n+                idxChild++;\n+            }\n+        }\n+        else if (fFirstChild && index == 0)\n+        {\n+            // Drill into where first child would be.\n+//            curs.toFirstContentToken();\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    XmlCursor.TokenType tokenType()\n+    {\n+        XmlCursor.TokenType result;\n+\n+        XmlCursor curs = newCursor();\n+\n+        if (curs.isStartdoc())\n+        {\n+            curs.toFirstContentToken();\n+        }\n+\n+        result = curs.currentTokenType();\n+\n+        curs.dispose();\n+\n+        return result;\n+    }\n+    /**\n+     *\n+     * @param srcCurs\n+     * @param destCurs\n+     * @param fDontMoveIfSame\n+     * @return\n+     */\n+    private boolean moveSrcToDest (XmlCursor srcCurs, XmlCursor destCurs, boolean fDontMoveIfSame)\n+    {\n+        boolean fMovedSomething = true;\n+        TokenType tt;\n+        do\n+        {\n+            if (fDontMoveIfSame && srcCurs.isInSameDocument(destCurs) && (srcCurs.comparePosition(destCurs) == 0))\n+            {\n+                // If the source and destination are pointing at the same place then there's nothing to move.\n+                fMovedSomething = false;\n+                break;\n+            }\n+\n+            // todo ***TLL*** Use replaceContents (when added) and eliminate children removes (see above todo).\n+            if (destCurs.currentTokenType().isStartdoc())\n+            {\n+                destCurs.toNextToken();\n+            }\n+\n+            // todo ***TLL*** Can Eric support notion of copy instead of me copying then moving???\n+            XmlCursor copyCurs = copy(srcCurs);\n+\n+            copyCurs.moveXml(destCurs);\n+\n+            copyCurs.dispose();\n+\n+            tt = srcCurs.currentTokenType();\n+        } while (!tt.isStart() && !tt.isEnd() && !tt.isEnddoc());\n+\n+        return fMovedSomething;\n+    }\n+\n+    /**\n+     *\n+     * @param cursToCopy\n+     * @return\n+     */\n+    private XmlCursor copy (XmlCursor cursToCopy)\n+    {\n+        XmlObject xo = XmlObject.Factory.newInstance();\n+\n+        XmlCursor copyCurs = null;\n+\n+        if (cursToCopy.currentTokenType().isText())\n+        {\n+            try\n+            {\n+                // Try just as a textnode, to do that we need to wrap the text in a special fragment tag\n+                // that is not visible from the XmlCursor.\n+                copyCurs = XmlObject.Factory.parse(\"<x:fragment xmlns:x=\\\"http://www.openuri.org/fragment\\\">\" +\n+                                           cursToCopy.getChars() +\n+                                           \"</x:fragment>\").newCursor();\n+                if (!cursToCopy.toNextSibling())\n+                {\n+                    if (cursToCopy.currentTokenType().isText())\n+                    {\n+                        cursToCopy.toNextToken();   // It's not an element it's text so skip it.\n+                    }\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                throw ScriptRuntime.typeError(ex.getMessage());\n+            }\n+        }\n+        else\n+        {\n+            copyCurs = xo.newCursor();\n+            copyCurs.toFirstContentToken();\n+            if (cursToCopy.currentTokenType() == XmlCursor.TokenType.STARTDOC)\n+            {\n+                cursToCopy.toNextToken();\n+            }\n+            \n+            cursToCopy.copyXml(copyCurs);\n+            if (!cursToCopy.toNextSibling())        // If element skip element.\n+            {\n+                if (cursToCopy.currentTokenType().isText())\n+                {\n+                    cursToCopy.toNextToken();       // It's not an element it's text so skip it.\n+                }\n+            }\n+\n+        }\n+\n+        copyCurs.toStartDoc();\n+        copyCurs.toFirstContentToken();\n+\n+        return copyCurs;\n+    }\n+\n+    private static final int APPEND_CHILD = 1;\n+    private static final int PREPEND_CHILD = 2;\n+\n+    /**\n+     *\n+     * @param curs\n+     * @param xmlToInsert\n+     */\n+    private void insertChild(XmlCursor curs, Object xmlToInsert)\n+    {\n+        if (xmlToInsert == null || xmlToInsert instanceof Undefined)\n+        {\n+            // Do nothing\n+        }\n+        else if (xmlToInsert instanceof XmlCursor)\n+        {\n+            moveSrcToDest((XmlCursor)xmlToInsert, curs, true);\n+        }\n+        else if (xmlToInsert instanceof XML)\n+        {\n+            XML xmlValue = (XML) xmlToInsert;\n+\n+            // If it's an attribute, then change to text node\n+            if (xmlValue.tokenType() == XmlCursor.TokenType.ATTR)\n+            {\n+                insertChild(curs, xmlValue.toString());\n+            }\n+            else\n+            {\n+                XmlCursor cursToInsert = ((XML) xmlToInsert).newCursor();\n+\n+                moveSrcToDest(cursToInsert, curs, true);\n+\n+                cursToInsert.dispose();\n+            }\n+        }\n+        else if (xmlToInsert instanceof XMLList)\n+        {\n+            XMLList list = (XMLList) xmlToInsert;\n+\n+            for (int i = 0; i < list.length(); i++)\n+            {\n+                insertChild(curs, list.item(i));\n+            }\n+        }\n+        else\n+        {\n+            // Convert to string and make XML out of it\n+            String  xmlStr = ScriptRuntime.toString(xmlToInsert);\n+            XmlObject xo = XmlObject.Factory.newInstance();         // Create an empty document.\n+\n+            XmlCursor sourceCurs = xo.newCursor();\n+            sourceCurs.toNextToken();\n+\n+            // To hold the text.\n+            sourceCurs.insertChars(xmlStr);\n+\n+            sourceCurs.toPrevToken();\n+\n+            // Call us again with the cursor.\n+            moveSrcToDest(sourceCurs, curs, true);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param childToMatch\n+     * @param xmlToInsert\n+     * @param addToType\n+     */\n+    private void insertChild(XML childToMatch, Object xmlToInsert, int addToType)\n+    {\n+        XmlCursor curs = newCursor();\n+        TokenType tt = curs.currentTokenType();\n+        XmlCursor xmlChildCursor = childToMatch.newCursor();\n+\n+        if (tt.isStartdoc())\n+        {\n+            tt = curs.toFirstContentToken();\n+        }\n+\n+        if (tt.isContainer())\n+        {\n+            tt = curs.toNextToken();\n+\n+            while (!tt.isEnd())\n+            {\n+                if (tt.isStart())\n+                {\n+                    // See if this child is the same as the one thep passed in\n+                    if (curs.comparePosition(xmlChildCursor) == 0)\n+                    {\n+                        // Found it\n+                        if (addToType == APPEND_CHILD)\n+                        {\n+                            // Move the cursor to just past the end of this element\n+                            curs.toEndToken();\n+                            curs.toNextToken();\n+                        }\n+\n+                        insertChild(curs, xmlToInsert);\n+                        break;\n+                    }\n+                }\n+\n+                // Skip over child elements\n+                if (tt.isStart())\n+                {\n+                    tt = curs.toEndToken();\n+                }\n+\n+                tt = curs.toNextToken();\n+            }\n+\n+        }\n+\n+        xmlChildCursor.dispose();\n+        curs.dispose();\n+    }\n+\n+    /**\n+     *\n+     * @param curs\n+     */\n+    protected void removeToken (XmlCursor curs)\n+    {\n+        XmlObject xo = XmlObject.Factory.newInstance();\n+\n+        // Don't delete anything move to another document so it gets orphaned nicely.\n+        XmlCursor tmpCurs = xo.newCursor();\n+        tmpCurs.toFirstContentToken();\n+\n+\n+        curs.moveXml(tmpCurs);\n+\n+        tmpCurs.dispose();\n+    }\n+\n+    /**\n+     *\n+     * @param index\n+     */\n+    protected void removeChild(long index)\n+    {\n+        XmlCursor curs = newCursor();\n+\n+        if (moveToChild(curs, index, false, false))\n+        {\n+            removeToken(curs);\n+        }\n+\n+        curs.dispose();\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @return\n+     */\n+    protected static javax.xml.namespace.QName computeQName (Object name)\n+    {\n+        if (name instanceof String)\n+        {\n+            String ns = null;\n+            String localName = null;\n+\n+            String fullName = (String)name;\n+            localName = fullName;\n+            if (fullName.startsWith(\"\\\"\"))\n+            {\n+                int idx = fullName.indexOf(\":\");\n+                if (idx != -1)\n+                {\n+                    ns = fullName.substring(1, idx - 1);    // Don't include the \"\" around the namespace\n+                    localName = fullName.substring(idx + 1);\n+                }\n+            }\n+\n+            if (ns == null)\n+            {\n+                return new javax.xml.namespace.QName(localName);\n+            }\n+            else\n+            {\n+                return new javax.xml.namespace.QName(ns, localName);\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     *\n+     * @param destCurs\n+     * @param newValue\n+     */\n+    private void replace(XmlCursor destCurs, XML newValue)\n+    {\n+        if (destCurs.isStartdoc())\n+        {\n+            // Can't overwrite a whole document (user really wants to overwrite the contents of).\n+            destCurs.toFirstContentToken();\n+        }\n+\n+        // Orphan the token -- don't delete it outright on the XmlCursor.\n+        removeToken(destCurs);\n+\n+        XmlCursor srcCurs = newValue.newCursor();\n+        if (srcCurs.currentTokenType().isStartdoc())\n+        {\n+            // Cann't append a whole document (user really wants to append the contents of).\n+            srcCurs.toFirstContentToken();\n+        }\n+\n+        moveSrcToDest(srcCurs, destCurs, false);\n+\n+        // Re-link a new annotation to this cursor -- we just deleted the previous annotation on entrance to replace.\n+        if (!destCurs.toPrevSibling())\n+        {\n+            destCurs.toPrevToken();\n+        }\n+        destCurs.setBookmark(new XScriptAnnotation(destCurs));\n+\n+        // todo would be nice if destCurs.toNextSibling went to where the next token if the cursor was pointing at the last token in the stream.\n+        destCurs.toEndToken();\n+        destCurs.toNextToken();\n+\n+        srcCurs.dispose();\n+    }\n+\n+    /**\n+     *\n+     * @param currXMLNode\n+     * @param xmlValue\n+     * @return\n+     */\n+    private boolean doPut(XMLName name, XML currXMLNode, XMLObjectImpl xmlValue)\n+    {\n+        boolean result = false;\n+        XmlCursor curs = currXMLNode.newCursor();\n+\n+        try\n+        {\n+            // Replace the node with this new xml value.\n+            XML xml;\n+\n+            int toAssignLen = xmlValue.length();\n+\n+            for (int i = 0; i < toAssignLen; i++)\n+            {\n+                if (xmlValue instanceof XMLList)\n+                {\n+                    xml = ((XMLList) xmlValue).item(i);\n+                }\n+                else\n+                {\n+                    xml = (XML) xmlValue;\n+                }\n+\n+                // If it's an attribute or text node, make text node.\n+                XmlCursor.TokenType tt = xml.tokenType();\n+                if (tt == XmlCursor.TokenType.ATTR || tt == XmlCursor.TokenType.TEXT)\n+                {\n+                    xml = makeXmlFromString(lib, name, xml.toString());\n+                }\n+\n+                if (i == 0)\n+                {\n+                    // 1st assignment is replaceChild all others are appendChild\n+                    replace(curs, xml);\n+                }\n+                else\n+                {\n+                    insertChild(curs, xml);\n+                }\n+            }\n+\n+            // We're done we've blown away the node because the rvalue was XML...\n+            result = true;\n+        }\n+        catch (Exception ex)\n+        {\n+            ex.printStackTrace();\n+            throw ScriptRuntime.typeError(ex.getMessage());\n+        }\n+        finally\n+        {\n+            curs.dispose();\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Make a text node element with this element name and text value.\n+     *\n+     * @param name\n+     * @param value\n+     * @return\n+     */\n+    private XML makeXmlFromString(XMLLibImpl lib, XMLName name,\n+                                      String value)\n+    {\n+        XML result;\n+\n+        javax.xml.namespace.QName qname;\n+\n+        try\n+        {\n+            qname = new javax.xml.namespace.QName(name.uri(), name.localName());\n+        }\n+        catch(Exception e)\n+        {\n+            throw ScriptRuntime.typeError(e.getMessage());\n+        }\n+\n+        result = createTextElement(lib, qname, value);\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @return\n+     */\n+    private XMLList matchAttributes(XMLName xmlName)\n+    {\n+        XMLList result = new XMLList(lib);\n+        XmlCursor curs = newCursor();\n+\n+        if (curs.currentTokenType().isStartdoc())\n+        {\n+            curs.toFirstContentToken();\n+        }\n+\n+        if (curs.isStart())\n+        {\n+            if (curs.toFirstAttribute())\n+            {\n+                do\n+                {\n+                    if (qnameMatches(xmlName, curs.getName()))\n+                    {\n+                        result.addToList(createAttributeObject(curs));\n+                    }\n+                } while (curs.toNextAttribute());\n+            }\n+        }\n+\n+        curs.dispose();\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param attrCurs\n+     * @return\n+     */\n+    private XML createAttributeObject (XmlCursor attrCurs)\n+    {\n+        XML result = null;\n+\n+        if (attrCurs.currentTokenType().isAttr())\n+        {\n+            result = createAttributeXML(lib, attrCurs);\n+        }\n+\n+        return result;\n+    }\n+\n+    //\n+    //\n+    //  methods overriding ScriptableObject\n+    //\n+    //\n+\n+    public String getClassName ()\n+    {\n+        return \"XML\";\n+    }\n+\n+    //\n+    //\n+    //  methods overriding IdScriptableObject\n+    //\n+    //\n+\n+    /**\n+     * XML[0] should return this, all other indexes are Undefined\n+     *\n+     * @param index\n+     * @param start\n+     * @return\n+     */\n+    public Object get(int index, Scriptable start)\n+    {\n+        //Log(\"get index: \" + index);\n+\n+        if (index == 0)\n+        {\n+            return this;\n+        }\n+        else\n+        {\n+            return Scriptable.NOT_FOUND;\n+        }\n+    }\n+\n+    /**\n+     * Does the named property exist\n+     *\n+     * @param name\n+     * @param start\n+     * @return\n+     */\n+    boolean hasXMLProperty(XMLName xmlName)\n+    {\n+        boolean result = false;\n+\n+        if (prototypeFlag)\n+        {\n+            String name = xmlName.localName();\n+\n+            if (getMethod(name) != NOT_FOUND)\n+            {\n+                result = true;\n+            }\n+        }\n+        else\n+        {\n+            // Has now should return true if the property would have results > 0 or\n+            // if it's a method name\n+            String name = xmlName.localName();\n+            if ((getPropertyList(xmlName).length() > 0) ||\n+                (getMethod(name) != NOT_FOUND))\n+            {\n+                result = true;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+\n+    /**\n+     *\n+     * @param index\n+     * @param start\n+     * @return\n+     */\n+    public boolean has(int index, Scriptable start)\n+    {\n+        return (index == 0);\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public Object[] getIds()\n+    {\n+        Object[] enumObjs;\n+\n+        if (prototypeFlag)\n+        {\n+            enumObjs = new Object[0];\n+        }\n+        else\n+        {\n+            enumObjs = new Object[1];\n+\n+            enumObjs[0] = new Integer(0);\n+        }\n+\n+        return enumObjs;\n+    }\n+\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public Object [] getIdsForDebug()\n+    {\n+        return getIds();\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @param start\n+     * @return\n+     */\n+    Object getXMLProperty(XMLName xmlName)\n+    {\n+        Object result = NOT_FOUND;\n+\n+        if (prototypeFlag)\n+        {\n+            String name = xmlName.localName();\n+\n+            result = getMethod(name);\n+        }\n+        else\n+        {\n+            result = getPropertyList(xmlName);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @param start\n+     * @param value\n+     */\n+    void putXMLProperty(XMLName xmlName, Object value)\n+    {\n+        //Log(\"put property: \" + name + \" value: \" + value.getClass());\n+\n+        if (prototypeFlag)\n+        {\n+        }\n+        else\n+        {\n+            // Special-case checks for undefined and null\n+            if (value == null)\n+            {\n+                value = \"null\";\n+            }\n+            else if (value instanceof Undefined)\n+            {\n+                value = \"undefined\";\n+            }\n+\n+            // Get the named property\n+            if (xmlName.isAttributeName())\n+            {\n+                setAttribute(xmlName, value);\n+            }\n+            else if (xmlName.uri() == null &&\n+                     xmlName.localName().equals(\"*\"))\n+            {\n+                setChildren(value);\n+            }\n+            else\n+            {\n+                // Convert text into XML if needed.\n+                XMLObjectImpl xmlValue = null;\n+\n+                if (value instanceof XMLObjectImpl)\n+                {\n+                    xmlValue = (XMLObjectImpl) value;\n+\n+                    // Check for attribute type and convert to textNode\n+                    if (xmlValue instanceof XML)\n+                    {\n+                        if (((XML) xmlValue).tokenType() == XmlCursor.TokenType.ATTR)\n+                        {\n+                            xmlValue = makeXmlFromString(lib, xmlName, xmlValue.toString());\n+                        }\n+                    }\n+\n+                    if (xmlValue instanceof XMLList)\n+                    {\n+                        for (int i = 0; i < xmlValue.length(); i++)\n+                        {\n+                            XML xml = ((XMLList) xmlValue).item(i);\n+\n+                            if (xml.tokenType() == XmlCursor.TokenType.ATTR)\n+                            {\n+                                ((XMLList) xmlValue).replace(i, makeXmlFromString(lib, xmlName, xml.toString()));\n+                            }\n+                        }\n+                    }\n+                }\n+                else\n+                {\n+                    xmlValue = makeXmlFromString(lib, xmlName, ScriptRuntime.toString(value));\n+                }\n+\n+                XMLList matches = getPropertyList(xmlName);\n+\n+                if (matches.length() == 0)\n+                {\n+                    appendChild(xmlValue);\n+                }\n+                else\n+                {\n+                    // Remove all other matches\n+                    for (int i = 1; i < matches.length(); i++)\n+                    {\n+                        removeChild(matches.item(i).childIndex());\n+                    }\n+\n+                    // Replace first match with new value.\n+                    doPut(xmlName, matches.item(0), xmlValue);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     *\n+     * @param index\n+     * @param start\n+     * @param value\n+     */\n+    public void put(int index, Scriptable start, Object value)\n+    {\n+        // Spec says assignment to indexed XML object should return type error\n+        throw ScriptRuntime.typeError(\"Assignment to indexed XML is not allowed\");\n+    }\n+\n+\n+    /**\n+     *\n+     * @param name\n+     */\n+    void deleteXMLProperty(XMLName name)\n+    {\n+        if (!name.isDescendants() && name.isAttributeName())\n+        {\n+            XmlCursor curs = newCursor();\n+\n+            // TODO: Cover the case *::name\n+            if (name.localName().equals(\"*\"))\n+            {\n+                // Delete all attributes.\n+                if (curs.toFirstAttribute())\n+                {\n+                    while (curs.currentTokenType().isAttr())\n+                    {\n+                        curs.removeXml();\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                // Delete an attribute.\n+                javax.xml.namespace.QName qname = new javax.xml.namespace.QName(\n+                    name.uri(), name.localName());\n+                curs.removeAttribute(qname);\n+            }\n+\n+            curs.dispose();\n+        }\n+        else\n+        {\n+            XMLList matches = getPropertyList(name);\n+\n+            matches.remove();\n+        }\n+    }\n+\n+\n+    /**\n+     *\n+     * @param index\n+     */\n+    public void delete(int index)\n+    {\n+        if (index == 0)\n+        {\n+            remove();\n+        }\n+    }\n+\n+    //\n+    //\n+    //  package utility functions:\n+    //\n+    //\n+\n+    protected XScriptAnnotation getAnnotation ()\n+    { return _anno; }\n+\n+\n+    protected void changeNS (String oldURI, String newURI)\n+    {\n+        XmlCursor curs = newCursor();\n+        while (curs.toParent()) {\n+          /* Goto the top of the document */\n+        }\n+\n+        TokenType tt = curs.currentTokenType();\n+        if (tt.isStartdoc())\n+        {\n+            tt = curs.toFirstContentToken();\n+        }\n+\n+        if (tt.isStart())\n+        {\n+            do\n+            {\n+                if (tt.isStart() || tt.isAttr() || tt.isNamespace())\n+                {\n+                    javax.xml.namespace.QName currQName = curs.getName();\n+                    if (oldURI.equals(currQName.getNamespaceURI()))\n+                    {\n+                        curs.setName(new javax.xml.namespace.QName(newURI, currQName.getLocalPart()));\n+                    }\n+                }\n+\n+                tt = curs.toNextToken();\n+            } while (!tt.isEnddoc() && !tt.isNone());\n+        }\n+\n+        curs.dispose();\n+    }\n+\n+\n+    /**\n+     *\n+     */\n+    void remove ()\n+    {\n+        XmlCursor childCurs = newCursor();\n+\n+        if (childCurs.currentTokenType().isStartdoc())\n+        {\n+            // Remove on the document removes all children.\n+            TokenType tt = childCurs.toFirstContentToken();\n+            while (!tt.isEnd() && !tt.isEnddoc())\n+            {\n+                removeToken(childCurs);\n+                tt = childCurs.currentTokenType();      // Now see where we're pointing after the delete -- next token.\n+            }\n+        }\n+        else\n+        {\n+                removeToken(childCurs);\n+        }\n+\n+        childCurs.dispose();\n+    }\n+\n+\n+    /**\n+     *\n+     * @param value\n+     */\n+    void replaceAll(XML value)\n+    {\n+        XmlCursor curs = newCursor();\n+\n+        replace(curs, value);\n+        _anno = value._anno;\n+\n+        curs.dispose();\n+    }\n+\n+\n+    /**\n+     *\n+     * @param attrName\n+     * @param value\n+     */\n+    void setAttribute(XMLName xmlName, Object value)\n+    {\n+        if (xmlName.uri() == null &&\n+            xmlName.localName().equals(\"*\"))\n+        {\n+            throw ScriptRuntime.typeError(\"@* assignment not supported.\");\n+        }\n+\n+        XmlCursor curs = newCursor();\n+\n+        String strValue = ScriptRuntime.toString(value);\n+        if (curs.currentTokenType().isStartdoc())\n+        {\n+            curs.toFirstContentToken();\n+        }\n+\n+        javax.xml.namespace.QName qName;\n+\n+        try\n+        {\n+            qName = new javax.xml.namespace.QName(xmlName.uri(), xmlName.localName());\n+        }\n+        catch(Exception e)\n+        {\n+            throw ScriptRuntime.typeError(e.getMessage());\n+        }\n+\n+        if (!curs.setAttributeText(qName, strValue))\n+        {\n+            if (curs.currentTokenType().isStart())\n+            {\n+                // Can only add attributes inside of a start.\n+                curs.toNextToken();\n+            }\n+            curs.insertAttributeWithValue(qName, strValue);\n+        }\n+\n+        curs.dispose();\n+    }\n+\n+    /**\n+     *\n+     * @param namespace\n+     * @return\n+     */\n+    private XMLList allChildNodes(String namespace)\n+    {\n+        XMLList result = new XMLList(lib);\n+        XmlCursor curs = newCursor();\n+        TokenType tt = curs.currentTokenType();\n+        javax.xml.namespace.QName targetProperty = new javax.xml.namespace.QName(namespace, \"*\");\n+\n+        if (tt.isStartdoc())\n+        {\n+            tt = curs.toFirstContentToken();\n+        }\n+\n+        if (tt.isContainer())\n+        {\n+            tt = curs.toFirstContentToken();\n+\n+            while (!tt.isEnd())\n+            {\n+                if (!tt.isStart())\n+                {\n+                    // Not an element\n+                    result.addToList(findAnnotation(curs));\n+\n+                    // Reset target property to null in this case\n+                    targetProperty = null;\n+                }\n+                else\n+                {\n+                    // Match namespace as well if specified\n+                    if (namespace == null ||\n+                        namespace.length() == 0 ||\n+                        namespace.equals(\"*\") ||\n+                        curs.getName().getNamespaceURI().equals(namespace))\n+                    {\n+                        // Add it to the list\n+                        result.addToList(findAnnotation(curs));\n+\n+                        // Set target property if target name is \"*\",\n+                        // Otherwise if target property does not match current, then\n+                        // set to null\n+                        if (targetProperty != null)\n+                        {\n+                            if (targetProperty.getLocalPart().equals(\"*\"))\n+                            {\n+                                targetProperty = curs.getName();\n+                            }\n+                            else if (!targetProperty.getLocalPart().equals(curs.getName().getLocalPart()))\n+                            {\n+                                // Not a match, unset target property\n+                                targetProperty = null;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Skip over child elements\n+                if (tt.isStart())\n+                {\n+                    tt = curs.toEndToken();\n+                }\n+\n+                tt = curs.toNextToken();\n+            }\n+        }\n+\n+        curs.dispose();\n+\n+        // Set the targets for this XMLList.\n+        result.setTargets(this, targetProperty);\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private XMLList matchDescendantAttributes(XMLName xmlName)\n+    {\n+        XMLList result = new XMLList(lib);\n+        XmlCursor curs = newCursor();\n+        TokenType tt = curs.currentTokenType();\n+\n+        // Set the targets for this XMLList.\n+        result.setTargets(this, null);\n+\n+        if (tt.isStartdoc())\n+        {\n+            tt = curs.toFirstContentToken();\n+        }\n+\n+        if (tt.isContainer())\n+        {\n+            int nestLevel = 1;\n+\n+            while (nestLevel > 0)\n+            {\n+                tt = curs.toNextToken();\n+\n+                // Only try to match names for attributes\n+                if (tt.isAttr())\n+                {\n+                    if (qnameMatches(xmlName, curs.getName()))\n+                    {\n+                        result.addToList(findAnnotation(curs));\n+                    }\n+                }\n+\n+                if (tt.isStart())\n+                {\n+                    nestLevel++;\n+                }\n+                else if (tt.isEnd())\n+                {\n+                    nestLevel--;\n+                }\n+                else if (tt.isEnddoc())\n+                {\n+                    // Shouldn't get here, but just in case.\n+                    break;\n+                }\n+            }\n+        }\n+\n+        curs.dispose();\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private XMLList matchDescendantChildren(XMLName xmlName)\n+    {\n+        XMLList result = new XMLList(lib);\n+        XmlCursor curs = newCursor();\n+        TokenType tt = curs.currentTokenType();\n+\n+        // Set the targets for this XMLList.\n+        result.setTargets(this, null);\n+\n+        if (tt.isStartdoc())\n+        {\n+            tt = curs.toFirstContentToken();\n+        }\n+\n+        if (tt.isContainer())\n+        {\n+            int nestLevel = 1;\n+\n+            while (nestLevel > 0)\n+            {\n+                tt = curs.toNextToken();\n+\n+                if (!tt.isAttr() && !tt.isEnd() && !tt.isEnddoc())\n+                {\n+                    // Only try to match names for elements or processing instructions.\n+                    if (!tt.isStart() && !tt.isProcinst())\n+                    {\n+                        // Not an element or procinst, only add if qname is all\n+                        if (xmlName.localName().equals(\"*\"))\n+                        {\n+                            result.addToList(findAnnotation(curs));\n+                        }\n+                    }\n+                    else\n+                    {\n+                        if (qnameMatches(xmlName, curs.getName()))\n+                        {\n+                            result.addToList(findAnnotation(curs));\n+                        }\n+                    }\n+                }\n+\n+                if (tt.isStart())\n+                {\n+                    nestLevel++;\n+                }\n+                else if (tt.isEnd())\n+                {\n+                    nestLevel--;\n+                }\n+                else if (tt.isEnddoc())\n+                {\n+                    // Shouldn't get here, but just in case.\n+                    break;\n+                }\n+            }\n+        }\n+\n+        curs.dispose();\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param tokenType\n+     * @return\n+     */\n+    private XMLList matchChildren(XmlCursor.TokenType tokenType)\n+    {\n+        return matchChildren(tokenType, XMLName.formStar());\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private XMLList matchChildren(XmlCursor.TokenType tokenType, XMLName name)\n+    {\n+        XMLList result = new XMLList(lib);\n+        XmlCursor curs = newCursor();\n+        TokenType tt = curs.currentTokenType();\n+        javax.xml.namespace.QName qname = new javax.xml.namespace.QName(name.uri(), name.localName());\n+        javax.xml.namespace.QName targetProperty = qname;\n+\n+        if (tt.isStartdoc())\n+        {\n+            tt = curs.toFirstContentToken();\n+        }\n+\n+        if (tt.isContainer())\n+        {\n+            tt = curs.toFirstContentToken();\n+\n+            while (!tt.isEnd())\n+            {\n+                if (tt == tokenType)\n+                {\n+                    // Only try to match names for elements or processing instructions.\n+                    if (!tt.isStart() && !tt.isProcinst())\n+                    {\n+                        // Not an element or no name specified.\n+                        result.addToList(findAnnotation(curs));\n+\n+                        // Reset target property to null in this case\n+                        targetProperty = null;\n+                    }\n+                    else\n+                    {\n+                        // Match names as well\n+                        if (qnameMatches(name, curs.getName()))\n+                        {\n+                            // Add it to the list\n+                            result.addToList(findAnnotation(curs));\n+\n+                            // Set target property if target name is \"*\",\n+                            // Otherwise if target property does not match current, then\n+                            // set to null\n+                            if (targetProperty != null)\n+                            {\n+                                if (targetProperty.getLocalPart().equals(\"*\"))\n+                                {\n+                                    targetProperty = curs.getName();\n+                                }\n+                                else if (!targetProperty.getLocalPart().equals(curs.getName().getLocalPart()))\n+                                {\n+                                    // Not a match, unset target property\n+                                    targetProperty = null;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Skip over child elements\n+                if (tt.isStart())\n+                {\n+                    tt = curs.toEndToken();\n+                }\n+\n+                tt = curs.toNextToken();\n+            }\n+        }\n+\n+        curs.dispose();\n+\n+        if (tokenType == XmlCursor.TokenType.START)\n+        {\n+            // Set the targets for this XMLList.\n+            result.setTargets(this, targetProperty);\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /**\n+     *\n+     * @param template\n+     * @param match\n+     * @return\n+     */\n+    private boolean qnameMatches(XMLName template, javax.xml.namespace.QName match)\n+    {\n+        boolean matches = false;\n+\n+        if (template.uri() == null ||\n+            template.uri().equals(match.getNamespaceURI()))\n+        {\n+            // URI OK, test name\n+            if (template.localName().equals(\"*\") ||\n+                template.localName().equals(match.getLocalPart()))\n+            {\n+                matches = true;\n+            }\n+        }\n+\n+        return matches;\n+    }\n+\n+    //\n+    //\n+    // Methods from section 12.4.4 in the spec\n+    //\n+    //\n+\n+    /**\n+     * The addNamespace method adds a namespace declaration to the in scope\n+     * namespaces for this XML object and returns this XML object.\n+     *\n+     * @param toAdd\n+     */\n+    XML addNamespace(Namespace ns)\n+    {\n+        // When a namespace is used it will be added automatically\n+        // to the inScopeNamespaces set. There is no need to add\n+        // Namespaces with undefined prefixes.\n+        String nsPrefix = ns.prefix();\n+        if (nsPrefix == null) return this;\n+\n+        XmlCursor cursor = newCursor();\n+\n+        try\n+        {\n+            if(!cursor.isContainer()) return this;\n+\n+            javax.xml.namespace.QName qname = cursor.getName();\n+            // Don't add a default namespace declarations to containers\n+            // with QNames in no namespace.\n+            if(qname.getNamespaceURI().equals(\"\") &&\n+               nsPrefix.equals(\"\")) return this;\n+\n+            // Get all declared namespaces that are in scope\n+            Map prefixToURI = NamespaceHelper.getAllNamespaces(lib, cursor);\n+\n+            String uri = (String)prefixToURI.get(nsPrefix);\n+            if(uri != null)\n+            {\n+                // Check if the Namespace is not already in scope\n+                if(uri.equals(ns.uri())) return this;\n+\n+                cursor.push();\n+\n+                // Let's see if we have to delete a namespace declaration\n+                while(cursor.toNextToken().isAnyAttr())\n+                {\n+                    if(cursor.isNamespace())\n+                    {\n+                        qname = cursor.getName();\n+                        String prefix = qname.getLocalPart();\n+                        if(prefix.equals(nsPrefix))\n+                        {\n+                            // Delete the current Namespace declaration\n+                            cursor.removeXml();\n+                            break;\n+                        }\n+                    }\n+                }\n+\n+                cursor.pop();\n+            }\n+\n+            cursor.toNextToken();\n+            cursor.insertNamespace(nsPrefix, ns.uri());\n+        }\n+        finally\n+        {\n+            cursor.dispose();\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     *\n+     * @param xml\n+     * @return\n+     */\n+    XML appendChild(Object xml)\n+    {\n+        XmlCursor curs = newCursor();\n+\n+        if (curs.isStartdoc())\n+        {\n+            curs.toFirstContentToken();\n+        }\n+\n+        // Move the cursor to the end of this element\n+        if (curs.isStart())\n+        {\n+            curs.toEndToken();\n+        }\n+\n+        insertChild(curs, xml);\n+\n+        curs.dispose();\n+\n+        return this;\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @return\n+     */\n+    XMLList attribute(XMLName xmlName)\n+    {\n+        return matchAttributes(xmlName);\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    XMLList attributes()\n+    {\n+        XMLName xmlName = XMLName.formStar();\n+        return matchAttributes(xmlName);\n+    }\n+\n+    XMLList child(long index)\n+    {\n+        XMLList result = new XMLList(lib);\n+        result.setTargets(this, null);\n+        result.addToList(getXmlChild(index));\n+        return result;\n+    }\n+\n+    XMLList child(XMLName xmlName)\n+    {\n+        if (xmlName == null)\n+            return new XMLList(lib);\n+\n+        XMLList result;\n+        if (xmlName.localName().equals(\"*\"))\n+        {\n+            result = allChildNodes(xmlName.uri());\n+        }\n+        else\n+        {\n+            result = matchChildren(XmlCursor.TokenType.START, xmlName);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param index\n+     * @return\n+     */\n+    XML getXmlChild(long index)\n+    {\n+        XML result = null;\n+        XmlCursor curs = newCursor();\n+\n+        if (moveToChild(curs, index, false, true))\n+        {\n+            result = createXML(lib, curs);\n+        }\n+\n+        curs.dispose();\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    int childIndex()\n+    {\n+        int index = 0;\n+\n+        XmlCursor curs = newCursor();\n+\n+        TokenType tt = curs.currentTokenType();\n+        while (true)\n+        {\n+            if (tt.isText())\n+            {\n+                index++;\n+                if (!curs.toPrevSibling())\n+                {\n+                    break;\n+                }\n+            }\n+            else if (tt.isStart())\n+            {\n+                tt = curs.toPrevToken();\n+                if (tt.isEnd())\n+                {\n+                    curs.toNextToken();\n+                    if (!curs.toPrevSibling())\n+                    {\n+                        break;\n+                    }\n+\n+                    index++;\n+                }\n+                else\n+                {\n+                    // Hit the parent start tag so get out we're down counting children.\n+                    break;\n+                }\n+            }\n+            else if (tt.isComment() || tt.isProcinst())\n+            {\n+                curs.toPrevToken();\n+            }\n+            else\n+            {\n+                break;\n+            }\n+\n+            tt = curs.currentTokenType();\n+        }\n+\n+        index = curs.currentTokenType().isStartdoc() ? -1 : index;\n+\n+        curs.dispose();\n+\n+        return index;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    XMLList children()\n+    {\n+        return allChildNodes(null);\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    XMLList comments()\n+    {\n+        return matchChildren(XmlCursor.TokenType.COMMENT);\n+    }\n+\n+    /**\n+     *\n+     * @param xml\n+     * @return\n+     */\n+    boolean contains(Object xml)\n+    {\n+        boolean result = false;\n+\n+        if (xml instanceof XML)\n+        {\n+            result = equivalentXml(xml);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object copy()\n+    {\n+        XmlCursor srcCurs = newCursor();\n+\n+        if (srcCurs.isStartdoc())\n+        {\n+            srcCurs.toFirstContentToken();\n+        }\n+\n+        XML xml = createEmptyXML(lib);\n+\n+        XmlCursor destCurs = xml.newCursor();\n+        destCurs.toFirstContentToken();\n+\n+        srcCurs.copyXml(destCurs);\n+\n+        destCurs.dispose();\n+        srcCurs.dispose();\n+\n+        return xml;\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @return\n+     */\n+    XMLList descendants(XMLName xmlName)\n+    {\n+        XMLList result;\n+        if (xmlName.isAttributeName())\n+        {\n+            result = matchDescendantAttributes(xmlName);\n+        }\n+        else\n+        {\n+            result = matchDescendantChildren(xmlName);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * The inScopeNamespaces method returns an Array of Namespace objects\n+     * representing the namespaces in scope for this XML object in the\n+     * context of its parent.\n+     *\n+     * @return Array of all Namespaces in scope for this XML Object.\n+     */\n+    Object[] inScopeNamespaces()\n+    {\n+        XmlCursor cursor = newCursor();\n+        Object[] namespaces = NamespaceHelper.inScopeNamespaces(lib, cursor);\n+        cursor.dispose();\n+        return namespaces;\n+    }\n+\n+    /**\n+     *\n+     * @param child\n+     * @param xml\n+     */\n+    XML insertChildAfter(Object child, Object xml)\n+    {\n+        if (child == null)\n+        {\n+            // Spec says inserting after nothing is the same as prepending\n+            prependChild(xml);\n+        }\n+        else if (child instanceof XML)\n+        {\n+            insertChild((XML) child, xml, APPEND_CHILD);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     *\n+     * @param child\n+     * @param xml\n+     */\n+    XML insertChildBefore(Object child, Object xml)\n+    {\n+        if (child == null)\n+        {\n+            // Spec says inserting before nothing is the same as appending\n+            appendChild(xml);\n+        }\n+        else if (child instanceof XML)\n+        {\n+            insertChild((XML) child, xml, PREPEND_CHILD);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    boolean hasOwnProperty(XMLName xmlName)\n+    {\n+        boolean hasProperty = false;\n+\n+        if (prototypeFlag)\n+        {\n+            String property = xmlName.localName();\n+            hasProperty = (0 != findPrototypeId(property));\n+        }\n+        else\n+        {\n+            hasProperty = (getPropertyList(xmlName).length() > 0);\n+        }\n+\n+        return hasProperty;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    boolean hasComplexContent()\n+    {\n+        return !hasSimpleContent();\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    boolean hasSimpleContent()\n+    {\n+        boolean simpleContent = false;\n+\n+        XmlCursor curs = newCursor();\n+\n+        if (curs.isAttr() || curs.isText()) {\n+            return true;\n+        }\n+\n+        if (curs.isStartdoc())\n+        {\n+            curs.toFirstContentToken();\n+        }\n+\n+        simpleContent = !(curs.toFirstChild());\n+\n+        curs.dispose();\n+\n+        return simpleContent;\n+    }\n+\n+    /**\n+     * Length of an XML object is always 1, it's a list of XML objects of size 1.\n+     *\n+     * @return\n+     */\n+    int length()\n+    {\n+        return 1;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    String localName()\n+    {\n+        XmlCursor cursor = newCursor();\n+        if (cursor.isStartdoc())\n+            cursor.toFirstContentToken();\n+\n+        String name = null;\n+\n+        if(cursor.isStart() ||\n+           cursor.isAttr() ||\n+           cursor.isProcinst())\n+        {\n+            javax.xml.namespace.QName qname = cursor.getName();\n+            name = qname.getLocalPart();\n+        }\n+        cursor.dispose();\n+\n+        return name;\n+    }\n+\n+    /**\n+     * The name method returns the qualified name associated with this XML object.\n+     *\n+     * @return The qualified name associated with this XML object.\n+     */\n+    QName name()\n+    {\n+        XmlCursor cursor = newCursor();\n+        if (cursor.isStartdoc())\n+            cursor.toFirstContentToken();\n+\n+        QName name = null;\n+\n+        if(cursor.isStart() ||\n+           cursor.isAttr() ||\n+           cursor.isProcinst())\n+        {\n+            javax.xml.namespace.QName qname = cursor.getName();\n+            if(cursor.isProcinst())\n+            {\n+                name = new QName(lib, \"\", qname.getLocalPart(), \"\");\n+            }\n+            else\n+            {\n+                String uri = qname.getNamespaceURI();\n+                String prefix = qname.getPrefix();\n+                name = new QName(lib, uri, qname.getLocalPart(), prefix);\n+            }\n+        }\n+\n+        cursor.dispose();\n+\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @param prefix\n+     * @return\n+     */\n+    Object namespace(String prefix)\n+    {\n+        XmlCursor cursor = newCursor();\n+        if (cursor.isStartdoc())\n+        {\n+            cursor.toFirstContentToken();\n+        }\n+\n+        Object result = null;\n+\n+        if (prefix == null)\n+        {\n+            if(cursor.isStart() ||\n+               cursor.isAttr())\n+            {\n+                Object[] inScopeNS = NamespaceHelper.inScopeNamespaces(lib, cursor);\n+                // XXX Is it reaaly necessary to create the second cursor?\n+                XmlCursor cursor2 = newCursor();\n+                if (cursor2.isStartdoc())\n+                    cursor2.toFirstContentToken();\n+\n+                result = NamespaceHelper.getNamespace(lib, cursor2, inScopeNS);\n+\n+                cursor2.dispose();\n+            }\n+        }\n+        else\n+        {\n+            Map prefixToURI = NamespaceHelper.getAllNamespaces(lib, cursor);\n+            String uri = (String)prefixToURI.get(prefix);\n+            result = (uri == null) ? Undefined.instance : new Namespace(lib, prefix, uri);\n+        }\n+\n+        cursor.dispose();\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object[] namespaceDeclarations()\n+    {\n+        XmlCursor cursor = newCursor();\n+        Object[] namespaces = NamespaceHelper.namespaceDeclarations(lib, cursor);\n+        cursor.dispose();\n+        return namespaces;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object nodeKind()\n+    {\n+        String result;\n+        XmlCursor.TokenType tt = tokenType();\n+\n+        if (tt == XmlCursor.TokenType.ATTR)\n+        {\n+            result = \"attribute\";\n+        }\n+        else if (tt == XmlCursor.TokenType.TEXT)\n+        {\n+            result = \"text\";\n+        }\n+        else if (tt == XmlCursor.TokenType.COMMENT)\n+        {\n+            result = \"comment\";\n+        }\n+        else if (tt == XmlCursor.TokenType.PROCINST)\n+        {\n+            result = \"processing-instruction\";\n+        }\n+        else if (tt == XmlCursor.TokenType.START)\n+        {\n+            result = \"element\";\n+        }\n+        else\n+        {\n+            // A non-existant node has the nodeKind() of text\n+            result = \"text\";\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     */\n+    void normalize()\n+    {\n+        XmlCursor curs = newCursor();\n+        TokenType tt = curs.currentTokenType();\n+\n+        // Walk through the tokens removing empty text nodes and merging adjacent text nodes.\n+        if (tt.isStartdoc())\n+        {\n+            tt = curs.toFirstContentToken();\n+        }\n+\n+        if (tt.isContainer())\n+        {\n+            int nestLevel = 1;\n+            String previousText = null;\n+\n+            while (nestLevel > 0)\n+            {\n+                tt = curs.toNextToken();\n+\n+                if (tt == XmlCursor.TokenType.TEXT)\n+                {\n+                    String currentText = curs.getChars().trim();\n+\n+                    if (currentText.trim().length() == 0)\n+                    {\n+                        // Empty text node, remove.\n+                        removeToken(curs);\n+                        curs.toPrevToken();\n+                    }\n+                    else if (previousText == null)\n+                    {\n+                        // No previous text node, reset to trimmed version\n+                        previousText = currentText;\n+                    }\n+                    else\n+                    {\n+                        // It appears that this case never happens with XBeans.\n+                        // Previous text node exists, concatenate\n+                        String newText = previousText + currentText;\n+\n+                        curs.toPrevToken();\n+                        removeToken(curs);\n+                        removeToken(curs);\n+                        curs.insertChars(newText);\n+                    }\n+                }\n+                else\n+                {\n+                    previousText = null;\n+                }\n+\n+                if (tt.isStart())\n+                {\n+                    nestLevel++;\n+                }\n+                else if (tt.isEnd())\n+                {\n+                    nestLevel--;\n+                }\n+                else if (tt.isEnddoc())\n+                {\n+                    // Shouldn't get here, but just in case.\n+                    break;\n+                }\n+            }\n+        }\n+\n+\n+        curs.dispose();\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object parent()\n+    {\n+        Object parent;\n+\n+        XmlCursor curs = newCursor();\n+\n+        if (curs.isStartdoc())\n+        {\n+            // At doc level - no parent\n+            parent = Undefined.instance;\n+        }\n+        else\n+        {\n+            if (curs.toParent())\n+            {\n+                if (curs.isStartdoc())\n+                {\n+                    // Was top-level - no parent\n+                    parent = Undefined.instance;\n+                }\n+                else\n+                {\n+                    parent = getFromAnnotation(lib, findAnnotation(curs));\n+                }\n+            }\n+            else\n+            {\n+                // No parent\n+                parent = Undefined.instance;\n+            }\n+        }\n+\n+        curs.dispose();\n+\n+        return parent;\n+    }\n+\n+    /**\n+     *\n+     * @param xml\n+     * @return\n+     */\n+    XML prependChild (Object xml)\n+    {\n+        XmlCursor curs = newCursor();\n+\n+        if (curs.isStartdoc())\n+        {\n+            curs.toFirstContentToken();\n+        }\n+\n+        // Move the cursor to the first content token\n+        curs.toFirstContentToken();\n+\n+        insertChild(curs, xml);\n+\n+        curs.dispose();\n+\n+        return this;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object processingInstructions(XMLName xmlName)\n+    {\n+        return matchChildren(XmlCursor.TokenType.PROCINST, xmlName);\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @return\n+     */\n+    boolean propertyIsEnumerable(Object name)\n+    {\n+        boolean result;\n+        if (name instanceof Integer) {\n+            result = (((Integer)name).intValue() == 0);\n+        } else if (name instanceof Number) {\n+            double x = ((Number)name).doubleValue();\n+            // Check that number is posotive 0\n+            result = (x == 0.0 && 1.0 / x > 0);\n+        } else {\n+            result = ScriptRuntime.toString(name).equals(\"0\");\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param namespace\n+     */\n+    XML removeNamespace(Namespace ns)\n+    {\n+        XmlCursor cursor = newCursor();\n+\n+        try\n+        {\n+            if(cursor.isStartdoc())\n+                cursor.toFirstContentToken();\n+            if(!cursor.isStart()) return this;\n+\n+            String nsPrefix = ns.prefix();\n+            String nsURI = ns.uri();\n+            Map prefixToURI = new HashMap();\n+            int depth = 1;\n+\n+            while(!(cursor.isEnd() && depth == 0))\n+            {\n+                if(cursor.isStart())\n+                {\n+                    // Get the namespaces declared in this element.\n+                    // The ones with undefined prefixes are not candidates\n+                    // for removal because they are used.\n+                    prefixToURI.clear();\n+                    NamespaceHelper.getNamespaces(cursor, prefixToURI);\n+                    ObjArray inScopeNSBag = new ObjArray();\n+                    Iterator i = prefixToURI.entrySet().iterator();\n+                    while(i.hasNext())\n+                    {\n+                        Map.Entry entry = (Map.Entry)i.next();\n+                        ns = new Namespace(lib, (String)entry.getKey(), (String)entry.getValue());\n+                        inScopeNSBag.add(ns);\n+                    }\n+\n+                    // Add the URI we are looking for to avoid matching\n+                    // non-existing Namespaces.\n+                    ns = new Namespace(lib, nsURI);\n+                    inScopeNSBag.add(ns);\n+\n+                    Object[] inScopeNS = inScopeNSBag.toArray();\n+\n+                    // Check the element name\n+                    Namespace n = NamespaceHelper.getNamespace(lib, cursor,\n+                                                               inScopeNS);\n+                    if(nsURI.equals(n.uri()) &&\n+                       (nsPrefix == null ||\n+                        nsPrefix.equals(n.prefix())))\n+                    {\n+                        // This namespace is used\n+                        return this;\n+                    }\n+\n+                    // Check the attributes\n+                    cursor.push();\n+                    boolean hasNext = cursor.toFirstAttribute();\n+                    while(hasNext)\n+                    {\n+                        n = NamespaceHelper.getNamespace(lib, cursor, inScopeNS);\n+                        if(nsURI.equals(n.uri()) &&\n+                           (nsPrefix == null ||\n+                            nsPrefix.equals(n.prefix())))\n+                        {\n+                            // This namespace is used\n+                            return this;\n+                        }\n+\n+                        hasNext = cursor.toNextAttribute();\n+                    }\n+                    cursor.pop();\n+\n+                    if(nsPrefix == null)\n+                    {\n+                        // Remove all namespaces declarations that match nsURI\n+                        i = prefixToURI.entrySet().iterator();\n+                        while(i.hasNext())\n+                        {\n+                            Map.Entry entry = (Map.Entry)i.next();\n+                            if(entry.getValue().equals(nsURI))\n+                                NamespaceHelper.removeNamespace(cursor, (String)entry.getKey());\n+                        }\n+                    }\n+                    else if(nsURI.equals(prefixToURI.get(nsPrefix)))\n+                    {\n+                        // Remove the namespace declaration that matches nsPrefix\n+                        NamespaceHelper.removeNamespace(cursor, String.valueOf(nsPrefix));\n+                    }\n+                }\n+\n+                switch(cursor.toNextToken().intValue())\n+                {\n+                case XmlCursor.TokenType.INT_START:\n+                    depth++;\n+                    break;\n+                case XmlCursor.TokenType.INT_END:\n+                    depth--;\n+                    break;\n+                }\n+            }\n+        }\n+        finally\n+        {\n+            cursor.dispose();\n+        }\n+\n+        return this;\n+    }\n+\n+    XML replace(long index, Object xml)\n+    {\n+        XMLList xlChildToReplace = child(index);\n+        if (xlChildToReplace.length() > 0)\n+        {\n+            // One exists an that index\n+            XML childToReplace = xlChildToReplace.item(0);\n+            insertChildAfter(childToReplace, xml);\n+            removeChild(index);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     *\n+     * @param propertyName\n+     * @param xml\n+     * @return\n+     */\n+    XML replace(XMLName xmlName, Object xml)\n+    {\n+        putXMLProperty(xmlName, xml);\n+        return this;\n+    }\n+\n+    /**\n+     *\n+     * @param xml\n+     */\n+    XML setChildren(Object xml)\n+    {\n+        // remove all children\n+        XMLName xmlName = XMLName.formStar();\n+        XMLList matches = getPropertyList(xmlName);\n+        matches.remove();\n+\n+        // append new children\n+        appendChild(xml);\n+\n+        return this;\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     */\n+    void setLocalName(String localName)\n+    {\n+        XmlCursor cursor = newCursor();\n+\n+        try\n+        {\n+            if(cursor.isStartdoc())\n+                cursor.toFirstContentToken();\n+\n+            if(cursor.isText() || cursor.isComment()) return;\n+\n+\n+            javax.xml.namespace.QName qname = cursor.getName();\n+            cursor.setName(new javax.xml.namespace.QName(\n+                qname.getNamespaceURI(), localName, qname.getPrefix()));\n+        }\n+        finally\n+        {\n+            cursor.dispose();\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     */\n+    void setName(QName qname)\n+    {\n+        XmlCursor cursor = newCursor();\n+\n+        try\n+        {\n+            if(cursor.isStartdoc())\n+                cursor.toFirstContentToken();\n+\n+            if(cursor.isText() || cursor.isComment()) return;\n+\n+            if(cursor.isProcinst())\n+            {\n+                String localName = qname.localName();\n+                cursor.setName(new javax.xml.namespace.QName(localName));\n+            }\n+            else\n+            {\n+                String prefix = qname.prefix();\n+                if (prefix == null) { prefix = \"\"; }\n+                cursor.setName(new javax.xml.namespace.QName(\n+                    qname.uri(), qname.localName(), prefix));\n+            }\n+        }\n+        finally\n+        {\n+            cursor.dispose();\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param ns\n+     */\n+    void setNamespace(Namespace ns)\n+    {\n+        XmlCursor cursor = newCursor();\n+\n+        try\n+        {\n+            if(cursor.isStartdoc())\n+                cursor.toFirstContentToken();\n+\n+            if(cursor.isText() ||\n+               cursor.isComment() ||\n+               cursor.isProcinst()) return;\n+\n+            String prefix = ns.prefix();\n+            if (prefix == null) {\n+                prefix = \"\";\n+            }\n+            cursor.setName(new javax.xml.namespace.QName(\n+                ns.uri(), localName(), prefix));\n+        }\n+        finally\n+        {\n+            cursor.dispose();\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    XMLList text()\n+    {\n+        return matchChildren(XmlCursor.TokenType.TEXT);\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public String toString()\n+    {\n+        String result;\n+        XmlCursor curs = newCursor();\n+\n+        if (curs.isStartdoc())\n+        {\n+            curs.toFirstContentToken();\n+        }\n+\n+        if (curs.isText())\n+        {\n+             result = curs.getChars();\n+        }\n+        else if (curs.isStart() && hasSimpleContent())\n+        {\n+            result = curs.getTextValue();\n+        }\n+        else\n+        {\n+            result = toXMLString(0);\n+        }\n+\n+        return result;\n+    }\n+\n+    String toSource(int indent)\n+    {\n+        // XXX Does toXMLString always return valid XML literal?\n+        return toXMLString(indent);\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    String toXMLString(int indent)\n+    {\n+        // XXX indent is ignored\n+\n+        String result;\n+\n+        XmlCursor curs = newCursor();\n+\n+        if (curs.isStartdoc())\n+        {\n+            curs.toFirstContentToken();\n+        }\n+\n+        try\n+        {\n+            if (curs.isText())\n+            {\n+                result = curs.getChars();\n+            }\n+            else if (curs.isAttr())\n+            {\n+                result = curs.getTextValue();\n+            }\n+            else if (curs.isComment() || curs.isProcinst())\n+            {\n+                result = XML.dumpNode(curs, getOptions());\n+\n+                // todo: XBeans-dependent hack here\n+                // If it's a comment or PI, take off the xml-frament stuff\n+                String start = \"<xml-fragment>\";\n+                String end = \"</xml-fragment>\";\n+\n+                if (result.startsWith(start))\n+                {\n+                    result = result.substring(start.length());\n+                }\n+\n+                if (result.endsWith(end))\n+                {\n+                    result = result.substring(0, result.length() - end.length());\n+                }\n+            }\n+            else\n+            {\n+                result = XML.dumpNode(curs, getOptions());\n+            }\n+        }\n+        finally\n+        {\n+            curs.dispose();\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object valueOf()\n+    {\n+        return this;\n+    }\n+\n+    //\n+    // Other public Functions from XMLObject\n+    //\n+\n+    /**\n+     *\n+     * @param target\n+     * @return\n+     */\n+    boolean equivalentXml(Object target)\n+    {\n+        boolean result = false;\n+\n+        if (target instanceof XML)\n+        {\n+            XML otherXml = (XML) target;\n+\n+            // Compare with toString() if either side is text node or attribute\n+            // otherwise compare as XML\n+            XmlCursor.TokenType thisTT = tokenType();\n+            XmlCursor.TokenType otherTT = otherXml.tokenType();\n+            if (thisTT == XmlCursor.TokenType.ATTR || otherTT == XmlCursor.TokenType.ATTR ||\n+                thisTT == XmlCursor.TokenType.TEXT || otherTT == XmlCursor.TokenType.TEXT)\n+            {\n+                result = toString().equals(otherXml.toString());\n+            }\n+            else\n+            {\n+                XmlCursor cursOne = newCursor();\n+                XmlCursor cursTwo = otherXml.newCursor();\n+\n+                result = LogicalEquality.nodesEqual(cursOne, cursTwo);\n+\n+                cursOne.dispose();\n+                cursTwo.dispose();\n+\n+// Old way of comparing by string.\n+//                boolean orgPrettyPrinting = prototype.prettyPrinting;\n+//                prototype.prettyPrinting = true;\n+//                result = toXMLString(0).equals(otherXml.toXMLString(0));\n+//                prototype.prettyPrinting = orgPrettyPrinting;\n+            }\n+        }\n+        else if (target instanceof XMLList)\n+        {\n+            XMLList otherList = (XMLList) target;\n+\n+            if (otherList.length() == 1)\n+            {\n+                result = equivalentXml(otherList.getXmlFromAnnotation(0));\n+            }\n+        }\n+        else if (hasSimpleContent())\n+        {\n+            String otherStr = ScriptRuntime.toString(target);\n+\n+            result = toString().equals(otherStr);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @param start\n+     * @return\n+     */\n+    XMLList getPropertyList(XMLName name)\n+    {\n+        XMLList result;\n+\n+        // Get the named property\n+        if (name.isDescendants())\n+        {\n+            result = descendants(name);\n+        }\n+        else if (name.isAttributeName())\n+        {\n+            result = attribute(name);\n+        }\n+        else\n+        {\n+            result = child(name);\n+        }\n+\n+        return result;\n+    }\n+\n+    protected Object jsConstructor(Context cx, boolean inNewExpr,\n+                                   Object[] args)\n+    {\n+        if (args.length == 0) {\n+            return createFromJS(lib, \"\");\n+        } else {\n+            Object arg0 = args[0];\n+            if (!inNewExpr && arg0 instanceof XML) {\n+                // XML(XML) returns the same object.\n+                return arg0;\n+            }\n+            return createFromJS(lib, arg0);\n+        }\n+    }\n+\n+    /**\n+     * See ECMA 357, 11_2_2_1, Semantics, 3_f.\n+     */\n+    public Scriptable getExtraMethodSource(Context cx)\n+    {\n+        if (hasSimpleContent()) {\n+            String src = toString();\n+            return ScriptRuntime.toObjectOrNull(cx, src);\n+        }\n+        return null;\n+    }\n+\n+    XmlObject getXmlObject()\n+    {\n+        XmlObject xo;\n+        XmlCursor cursor = newCursor();\n+        try {\n+            xo = cursor.getObject();\n+        } finally {\n+            cursor.dispose();\n+        }\n+        return xo;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/xml/impl/xmlbeans/XMLCtor.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml.impl.xmlbeans;\n+\n+import org.mozilla.javascript.*;\n+\n+class XMLCtor extends IdFunctionObject\n+{\n+    static final long serialVersionUID = -8708195078359817341L;\n+\n+    private static final Object XMLCTOR_TAG = \"XMLCtor\";\n+\n+    private XMLLibImpl lib;\n+\n+    XMLCtor(XML xml, Object tag, int id, int arity)\n+    {\n+        super(xml, tag, id, arity);\n+        this.lib = xml.lib;\n+        activatePrototypeMap(MAX_FUNCTION_ID);\n+    }\n+\n+    private void writeSetting(Scriptable target)\n+    {\n+        for (int i = 1; i <= MAX_INSTANCE_ID; ++i) {\n+            int id = super.getMaxInstanceId() + i;\n+            String name = getInstanceIdName(id);\n+            Object value = getInstanceIdValue(id);\n+            ScriptableObject.putProperty(target, name, value);\n+        }\n+    }\n+\n+    private void readSettings(Scriptable source)\n+    {\n+        for (int i = 1; i <= MAX_INSTANCE_ID; ++i) {\n+            int id = super.getMaxInstanceId() + i;\n+            String name = getInstanceIdName(id);\n+            Object value = ScriptableObject.getProperty(source, name);\n+            if (value == Scriptable.NOT_FOUND) {\n+                continue;\n+            }\n+            switch (i) {\n+              case Id_ignoreComments:\n+              case Id_ignoreProcessingInstructions:\n+              case Id_ignoreWhitespace:\n+              case Id_prettyPrinting:\n+                if (!(value instanceof Boolean)) {\n+                    continue;\n+                }\n+                break;\n+              case Id_prettyIndent:\n+                if (!(value instanceof Number)) {\n+                    continue;\n+                }\n+                break;\n+              default:\n+                throw new IllegalStateException();\n+            }\n+            setInstanceIdValue(id, value);\n+        }\n+    }\n+\n+// #string_id_map#\n+\n+    private static final int\n+        Id_ignoreComments               = 1,\n+        Id_ignoreProcessingInstructions = 2,\n+        Id_ignoreWhitespace             = 3,\n+        Id_prettyIndent                 = 4,\n+        Id_prettyPrinting               = 5,\n+\n+        MAX_INSTANCE_ID                 = 5;\n+\n+    protected int getMaxInstanceId()\n+    {\n+        return super.getMaxInstanceId() + MAX_INSTANCE_ID;\n+    }\n+\n+    protected int findInstanceIdInfo(String s) {\n+        int id;\n+// #generated# Last update: 2004-07-19 13:03:52 CEST\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 12: X=\"prettyIndent\";id=Id_prettyIndent; break L;\n+            case 14: c=s.charAt(0);\n+                if (c=='i') { X=\"ignoreComments\";id=Id_ignoreComments; }\n+                else if (c=='p') { X=\"prettyPrinting\";id=Id_prettyPrinting; }\n+                break L;\n+            case 16: X=\"ignoreWhitespace\";id=Id_ignoreWhitespace; break L;\n+            case 28: X=\"ignoreProcessingInstructions\";id=Id_ignoreProcessingInstructions; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+\n+        if (id == 0) return super.findInstanceIdInfo(s);\n+\n+        int attr;\n+        switch (id) {\n+          case Id_ignoreComments:\n+          case Id_ignoreProcessingInstructions:\n+          case Id_ignoreWhitespace:\n+          case Id_prettyIndent:\n+          case Id_prettyPrinting:\n+            attr = PERMANENT | DONTENUM;\n+            break;\n+          default: throw new IllegalStateException();\n+        }\n+        return instanceIdInfo(attr, super.getMaxInstanceId() + id);\n+    }\n+\n+// #/string_id_map#\n+\n+    protected String getInstanceIdName(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_ignoreComments:               return \"ignoreComments\";\n+          case Id_ignoreProcessingInstructions: return \"ignoreProcessingInstructions\";\n+          case Id_ignoreWhitespace:             return \"ignoreWhitespace\";\n+          case Id_prettyIndent:                 return \"prettyIndent\";\n+          case Id_prettyPrinting:               return \"prettyPrinting\";\n+        }\n+        return super.getInstanceIdName(id);\n+    }\n+\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_ignoreComments:\n+            return ScriptRuntime.wrapBoolean(lib.ignoreComments);\n+          case Id_ignoreProcessingInstructions:\n+            return ScriptRuntime.wrapBoolean(lib.ignoreProcessingInstructions);\n+          case Id_ignoreWhitespace:\n+            return ScriptRuntime.wrapBoolean(lib.ignoreWhitespace);\n+          case Id_prettyIndent:\n+            return ScriptRuntime.wrapInt(lib.prettyIndent);\n+          case Id_prettyPrinting:\n+            return ScriptRuntime.wrapBoolean(lib.prettyPrinting);\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+    protected void setInstanceIdValue(int id, Object value)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_ignoreComments:\n+            lib.ignoreComments = ScriptRuntime.toBoolean(value);\n+            return;\n+          case Id_ignoreProcessingInstructions:\n+            lib.ignoreProcessingInstructions = ScriptRuntime.toBoolean(value);\n+            return;\n+          case Id_ignoreWhitespace:\n+            lib.ignoreWhitespace = ScriptRuntime.toBoolean(value);\n+            return;\n+          case Id_prettyIndent:\n+            lib.prettyIndent = ScriptRuntime.toInt32(value);\n+            return;\n+          case Id_prettyPrinting:\n+            lib.prettyPrinting = ScriptRuntime.toBoolean(value);\n+            return;\n+        }\n+        super.setInstanceIdValue(id, value);\n+    }\n+\n+// #string_id_map#\n+    private static final int\n+        Id_defaultSettings              = 1,\n+        Id_settings                     = 2,\n+        Id_setSettings                  = 3,\n+        MAX_FUNCTION_ID                 = 3;\n+\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2004-07-19 13:03:52 CEST\n+        L0: { id = 0; String X = null;\n+            int s_length = s.length();\n+            if (s_length==8) { X=\"settings\";id=Id_settings; }\n+            else if (s_length==11) { X=\"setSettings\";id=Id_setSettings; }\n+            else if (s_length==15) { X=\"defaultSettings\";id=Id_defaultSettings; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+// #/string_id_map#\n+\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_defaultSettings:  arity=0; s=\"defaultSettings\";  break;\n+          case Id_settings:         arity=0; s=\"settings\";         break;\n+          case Id_setSettings:      arity=1; s=\"setSettings\";      break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(XMLCTOR_TAG, id, s, arity);\n+    }\n+\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(XMLCTOR_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_defaultSettings: {\n+            lib.defaultSettings();\n+            Scriptable obj = cx.newObject(scope);\n+            writeSetting(obj);\n+            return obj;\n+          }\n+          case Id_settings: {\n+            Scriptable obj = cx.newObject(scope);\n+            writeSetting(obj);\n+            return obj;\n+          }\n+          case Id_setSettings: {\n+            if (args.length == 0\n+                || args[0] == null\n+                || args[0] == Undefined.instance)\n+            {\n+                lib.defaultSettings();\n+            } else if (args[0] instanceof Scriptable) {\n+                readSettings((Scriptable)args[0]);\n+            }\n+            return Undefined.instance;\n+          }\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/xml/impl/xmlbeans/XMLLibImpl.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml.impl.xmlbeans;\n+\n+import java.io.Serializable;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.xml.*;\n+\n+import org.apache.xmlbeans.XmlCursor;\n+import org.apache.xmlbeans.XmlObject;\n+\n+public final class XMLLibImpl extends XMLLib implements Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    private Scriptable globalScope;\n+\n+    XML xmlPrototype;\n+    XMLList xmlListPrototype;\n+    Namespace namespacePrototype;\n+    QName qnamePrototype;\n+\n+\n+    // Environment settings...\n+    boolean ignoreComments;\n+    boolean ignoreProcessingInstructions;\n+    boolean ignoreWhitespace;\n+    boolean prettyPrinting;\n+    int prettyIndent;\n+\n+    Scriptable globalScope()\n+    {\n+        return globalScope;\n+    }\n+\n+    private XMLLibImpl(Scriptable globalScope)\n+    {\n+        this.globalScope = globalScope;\n+        defaultSettings();\n+    }\n+\n+    public static void init(Context cx, Scriptable scope, boolean sealed)\n+    {\n+        // To force LinkageError if XmlObject is not available\n+        XmlObject.class.getName();\n+\n+        XMLLibImpl lib = new XMLLibImpl(scope);\n+        XMLLib bound = lib.bindToScope(scope);\n+        if (bound == lib) {\n+            lib.exportToScope(sealed);\n+        }\n+    }\n+\n+    private void exportToScope(boolean sealed)\n+    {\n+        xmlPrototype = XML.createEmptyXML(this);\n+        xmlListPrototype = new XMLList(this);\n+        namespacePrototype = new Namespace(this, \"\", \"\");\n+        qnamePrototype = new QName(this, \"\", \"\", \"\");\n+\n+        xmlPrototype.exportAsJSClass(sealed);\n+        xmlListPrototype.exportAsJSClass(sealed);\n+        namespacePrototype.exportAsJSClass(sealed);\n+        qnamePrototype.exportAsJSClass(sealed);\n+    }\n+\n+    void defaultSettings()\n+    {\n+        ignoreComments = true;\n+        ignoreProcessingInstructions = true;\n+        ignoreWhitespace = true;\n+        prettyPrinting = true;\n+        prettyIndent = 2;\n+    }\n+\n+    XMLName toAttributeName(Context cx, Object nameValue)\n+    {\n+        String uri;\n+        String localName;\n+\n+        if (nameValue instanceof String) {\n+            uri = \"\";\n+            localName = (String)nameValue;\n+        } else if (nameValue instanceof XMLName) {\n+            XMLName xmlName = (XMLName)nameValue;\n+            if (!xmlName.isAttributeName()) {\n+                xmlName.setAttributeName();\n+            }\n+            return xmlName;\n+        } else if (nameValue instanceof QName) {\n+            QName qname = (QName)nameValue;\n+            uri = qname.uri();\n+            localName = qname.localName();\n+        } else if (nameValue instanceof Boolean\n+                   || nameValue instanceof Number\n+                   || nameValue == Undefined.instance\n+                   || nameValue == null)\n+        {\n+            throw badXMLName(nameValue);\n+        } else {\n+            uri = \"\";\n+            localName = ScriptRuntime.toString(nameValue);\n+        }\n+        XMLName xmlName = XMLName.formProperty(uri, localName);\n+        xmlName.setAttributeName();\n+        return xmlName;\n+    }\n+\n+    private static RuntimeException badXMLName(Object value)\n+    {\n+        String msg;\n+        if (value instanceof Number) {\n+            msg = \"Can not construct XML name from number: \";\n+        } else if (value instanceof Boolean) {\n+            msg = \"Can not construct XML name from boolean: \";\n+        } else if (value == Undefined.instance || value == null) {\n+            msg = \"Can not construct XML name from \";\n+        } else {\n+            throw new IllegalArgumentException(value.toString());\n+        }\n+        return ScriptRuntime.typeError(msg+ScriptRuntime.toString(value));\n+    }\n+\n+    XMLName toXMLName(Context cx, Object nameValue)\n+    {\n+        XMLName result;\n+\n+        if (nameValue instanceof XMLName) {\n+            result = (XMLName)nameValue;\n+        } else if (nameValue instanceof QName) {\n+            QName qname = (QName)nameValue;\n+            result = XMLName.formProperty(qname.uri(), qname.localName());\n+        } else if (nameValue instanceof String) {\n+            result = toXMLNameFromString(cx, (String)nameValue);\n+        } else if (nameValue instanceof Boolean\n+                   || nameValue instanceof Number\n+                   || nameValue == Undefined.instance\n+                   || nameValue == null)\n+        {\n+            throw badXMLName(nameValue);\n+        } else {\n+            String name = ScriptRuntime.toString(nameValue);\n+            result = toXMLNameFromString(cx, name);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * If value represents Uint32 index, make it available through\n+     * ScriptRuntime.lastUint32Result(cx) and return null.\n+     * Otherwise return the same value as toXMLName(cx, value).\n+     */\n+    XMLName toXMLNameOrIndex(Context cx, Object value)\n+    {\n+        XMLName result;\n+\n+        if (value instanceof XMLName) {\n+            result = (XMLName)value;\n+        } else if (value instanceof String) {\n+            String str = (String)value;\n+            long test = ScriptRuntime.testUint32String(str);\n+            if (test >= 0) {\n+                ScriptRuntime.storeUint32Result(cx, test);\n+                result = null;\n+            } else {\n+                result = toXMLNameFromString(cx, str);\n+            }\n+        } else if (value instanceof Number) {\n+            double d = ((Number)value).doubleValue();\n+            long l = (long)d;\n+            if (l == d && 0 <= l && l <= 0xFFFFFFFFL) {\n+                ScriptRuntime.storeUint32Result(cx, l);\n+                result = null;\n+            } else {\n+                throw badXMLName(value);\n+            }\n+        } else if (value instanceof QName) {\n+            QName qname = (QName)value;\n+            String uri = qname.uri();\n+            boolean number = false;\n+            result = null;\n+            if (uri != null && uri.length() == 0) {\n+                // Only in this case qname.toString() can resemble uint32\n+                long test = ScriptRuntime.testUint32String(uri);\n+                if (test >= 0) {\n+                    ScriptRuntime.storeUint32Result(cx, test);\n+                    number = true;\n+                }\n+            }\n+            if (!number) {\n+                result = XMLName.formProperty(uri, qname.localName());\n+            }\n+        } else if (value instanceof Boolean\n+                   || value == Undefined.instance\n+                   || value == null)\n+        {\n+            throw badXMLName(value);\n+        } else {\n+            String str = ScriptRuntime.toString(value);\n+            long test = ScriptRuntime.testUint32String(str);\n+            if (test >= 0) {\n+                ScriptRuntime.storeUint32Result(cx, test);\n+                result = null;\n+            } else {\n+                result = toXMLNameFromString(cx, str);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    XMLName toXMLNameFromString(Context cx, String name)\n+    {\n+        if (name == null)\n+            throw new IllegalArgumentException();\n+\n+        int l = name.length();\n+        if (l != 0) {\n+            char firstChar = name.charAt(0);\n+            if (firstChar == '*') {\n+                if (l == 1) {\n+                    return XMLName.formStar();\n+                }\n+            } else if (firstChar == '@') {\n+                XMLName xmlName = XMLName.formProperty(\"\", name.substring(1));\n+                xmlName.setAttributeName();\n+                return xmlName;\n+            }\n+        }\n+\n+        String uri = getDefaultNamespaceURI(cx);\n+\n+        return XMLName.formProperty(uri, name);\n+    }\n+\n+    Namespace constructNamespace(Context cx, Object uriValue)\n+    {\n+        String prefix;\n+        String uri;\n+\n+        if (uriValue instanceof Namespace) {\n+            Namespace ns = (Namespace)uriValue;\n+            prefix = ns.prefix();\n+            uri = ns.uri();\n+        } else if (uriValue instanceof QName) {\n+            QName qname = (QName)uriValue;\n+            uri = qname.uri();\n+            if (uri != null) {\n+                prefix = qname.prefix();\n+            } else {\n+                uri = qname.toString();\n+                prefix = null;\n+            }\n+        } else {\n+            uri = ScriptRuntime.toString(uriValue);\n+            prefix = (uri.length() == 0) ? \"\" : null;\n+        }\n+\n+        return new Namespace(this, prefix, uri);\n+    }\n+\n+    Namespace castToNamespace(Context cx, Object namescapeObj)\n+    {\n+        if (namescapeObj instanceof Namespace) {\n+            return (Namespace)namescapeObj;\n+        }\n+        return constructNamespace(cx, namescapeObj);\n+    }\n+\n+    Namespace constructNamespace(Context cx)\n+    {\n+        return new Namespace(this, \"\", \"\");\n+    }\n+\n+    public Namespace constructNamespace(Context cx, Object prefixValue,\n+                                        Object uriValue)\n+    {\n+        String prefix;\n+        String uri;\n+\n+        if (uriValue instanceof QName) {\n+            QName qname = (QName)uriValue;\n+            uri = qname.uri();\n+            if (uri == null) {\n+                uri = qname.toString();\n+            }\n+        } else {\n+            uri = ScriptRuntime.toString(uriValue);\n+        }\n+\n+        if (uri.length() == 0) {\n+            if (prefixValue == Undefined.instance) {\n+                prefix = \"\";\n+            } else {\n+                prefix = ScriptRuntime.toString(prefixValue);\n+                if (prefix.length() != 0) {\n+                    throw ScriptRuntime.typeError(\n+                        \"Illegal prefix '\"+prefix+\"' for 'no namespace'.\");\n+                }\n+            }\n+        } else if (prefixValue == Undefined.instance) {\n+            prefix = \"\";\n+        } else if (!isXMLName(cx, prefixValue)) {\n+            prefix = \"\";\n+        } else {\n+            prefix = ScriptRuntime.toString(prefixValue);\n+        }\n+\n+        return new Namespace(this, prefix, uri);\n+    }\n+\n+    String getDefaultNamespaceURI(Context cx)\n+    {\n+        String uri = \"\";\n+        if (cx == null) {\n+            cx = Context.getCurrentContext();\n+        }\n+        if (cx != null) {\n+            Object ns = ScriptRuntime.searchDefaultNamespace(cx);\n+            if (ns != null) {\n+                if (ns instanceof Namespace) {\n+                    uri = ((Namespace)ns).uri();\n+                } else {\n+                    // Should not happen but for now it could\n+                    // due to bad searchDefaultNamespace implementation.\n+                }\n+            }\n+        }\n+        return uri;\n+    }\n+\n+    Namespace getDefaultNamespace(Context cx)\n+    {\n+        if (cx == null) {\n+            cx = Context.getCurrentContext();\n+            if (cx == null) {\n+                return namespacePrototype;\n+            }\n+        }\n+\n+        Namespace result;\n+        Object ns = ScriptRuntime.searchDefaultNamespace(cx);\n+        if (ns == null) {\n+            result = namespacePrototype;\n+        } else {\n+            if (ns instanceof Namespace) {\n+                result = (Namespace)ns;\n+            } else {\n+                // Should not happen but for now it could\n+                // due to bad searchDefaultNamespace implementation.\n+                result = namespacePrototype;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    QName castToQName(Context cx, Object qnameValue)\n+    {\n+        if (qnameValue instanceof QName) {\n+            return (QName)qnameValue;\n+        }\n+        return constructQName(cx, qnameValue);\n+    }\n+\n+    QName constructQName(Context cx, Object nameValue)\n+    {\n+        QName result;\n+\n+        if (nameValue instanceof QName) {\n+            QName qname = (QName)nameValue;\n+            result = new QName(this, qname.uri(), qname.localName(),\n+                               qname.prefix());\n+        } else {\n+            String localName = ScriptRuntime.toString(nameValue);\n+            result = constructQNameFromString(cx, localName);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Optimized version of constructQName for String type\n+     */\n+    QName constructQNameFromString(Context cx, String localName)\n+    {\n+        if (localName == null)\n+            throw new IllegalArgumentException();\n+\n+        String uri;\n+        String prefix;\n+\n+        if (\"*\".equals(localName)) {\n+            uri = null;\n+            prefix = null;\n+        } else {\n+            Namespace ns = getDefaultNamespace(cx);\n+            uri = ns.uri();\n+            prefix = ns.prefix();\n+        }\n+\n+        return new QName(this, uri, localName, prefix);\n+    }\n+\n+    QName constructQName(Context cx, Object namespaceValue, Object nameValue)\n+    {\n+        String uri;\n+        String localName;\n+        String prefix;\n+\n+        if (nameValue instanceof QName) {\n+            QName qname = (QName)nameValue;\n+            localName = qname.localName();\n+        } else {\n+            localName = ScriptRuntime.toString(nameValue);\n+        }\n+\n+        Namespace ns;\n+        if (namespaceValue == Undefined.instance) {\n+            if (\"*\".equals(localName)) {\n+                ns = null;\n+            } else {\n+                ns = getDefaultNamespace(cx);\n+            }\n+        } else if (namespaceValue == null) {\n+            ns = null;\n+        } else if (namespaceValue instanceof Namespace) {\n+            ns = (Namespace)namespaceValue;\n+        } else {\n+            ns = constructNamespace(cx, namespaceValue);\n+        }\n+\n+        if (ns == null) {\n+            uri = null;\n+            prefix = null;\n+        } else {\n+            uri = ns.uri();\n+            prefix = ns.prefix();\n+        }\n+\n+        return new QName(this, uri, localName, prefix);\n+    }\n+\n+    Object addXMLObjects(Context cx, XMLObject obj1, XMLObject obj2)\n+    {\n+        XMLList listToAdd = new XMLList(this);\n+\n+        if (obj1 instanceof XMLList) {\n+            XMLList list1 = (XMLList)obj1;\n+            if (list1.length() == 1) {\n+                listToAdd.addToList(list1.item(0));\n+            } else {\n+                // Might be xmlFragment + xmlFragment + xmlFragment + ...;\n+                // then the result will be an XMLList which we want to be an\n+                // rValue and allow it to be assigned to an lvalue.\n+                listToAdd = new XMLList(this, obj1);\n+            }\n+        } else {\n+            listToAdd.addToList(obj1);\n+        }\n+\n+        if (obj2 instanceof XMLList) {\n+            XMLList list2 = (XMLList)obj2;\n+            for (int i = 0; i < list2.length(); i++) {\n+                listToAdd.addToList(list2.item(i));\n+            }\n+        } else if (obj2 instanceof XML) {\n+            listToAdd.addToList(obj2);\n+        }\n+\n+        return listToAdd;\n+    }\n+\n+    //\n+    //\n+    // Overriding XMLLib methods\n+    //\n+    //\n+\n+    /**\n+     * See E4X 13.1.2.1.\n+     */\n+    public boolean isXMLName(Context cx, Object nameObj)\n+    {\n+        String name;\n+        try {\n+            name = ScriptRuntime.toString(nameObj);\n+        } catch (EcmaError ee) {\n+            if (\"TypeError\".equals(ee.getName())) {\n+                return false;\n+            }\n+            throw ee;\n+        }\n+\n+        // See http://w3.org/TR/xml-names11/#NT-NCName\n+        int length = name.length();\n+        if (length != 0) {\n+            if (isNCNameStartChar(name.charAt(0))) {\n+                for (int i = 1; i != length; ++i) {\n+                    if (!isNCNameChar(name.charAt(i))) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private static boolean isNCNameStartChar(int c)\n+    {\n+        if ((c & ~0x7F) == 0) {\n+            // Optimize for ASCII and use A..Z < _ < a..z\n+            if (c >= 'a') {\n+                return c <= 'z';\n+            } else if (c >= 'A') {\n+                if (c <= 'Z') {\n+                    return true;\n+                }\n+                return c == '_';\n+            }\n+        } else if ((c & ~0x1FFF) == 0) {\n+            return (0xC0 <= c && c <= 0xD6)\n+                   || (0xD8 <= c && c <= 0xF6)\n+                   || (0xF8 <= c && c <= 0x2FF)\n+                   || (0x370 <= c && c <= 0x37D)\n+                   || 0x37F <= c;\n+        }\n+        return (0x200C <= c && c <= 0x200D)\n+               || (0x2070 <= c && c <= 0x218F)\n+               || (0x2C00 <= c && c <= 0x2FEF)\n+               || (0x3001 <= c && c <= 0xD7FF)\n+               || (0xF900 <= c && c <= 0xFDCF)\n+               || (0xFDF0 <= c && c <= 0xFFFD)\n+               || (0x10000 <= c && c <= 0xEFFFF);\n+    }\n+\n+    private static boolean isNCNameChar(int c)\n+    {\n+        if ((c & ~0x7F) == 0) {\n+            // Optimize for ASCII and use - < . < 0..9 < A..Z < _ < a..z\n+            if (c >= 'a') {\n+                return c <= 'z';\n+            } else if (c >= 'A') {\n+                if (c <= 'Z') {\n+                    return true;\n+                }\n+                return c == '_';\n+            } else if (c >= '0') {\n+                return c <= '9';\n+            } else {\n+                return c == '-' || c == '.';\n+            }\n+        } else if ((c & ~0x1FFF) == 0) {\n+            return isNCNameStartChar(c) || c == 0xB7\n+                   || (0x300 <= c && c <= 0x36F);\n+        }\n+        return isNCNameStartChar(c) || (0x203F <= c && c <= 0x2040);\n+    }\n+\n+    XMLName toQualifiedName(Context cx, Object namespaceValue,\n+                            Object nameValue)\n+    {\n+        // This is duplication of constructQName(cx, namespaceValue, nameValue)\n+        // but for XMLName\n+\n+        String uri;\n+        String localName;\n+\n+        if (nameValue instanceof QName) {\n+            QName qname = (QName)nameValue;\n+            localName = qname.localName();\n+        } else {\n+            localName = ScriptRuntime.toString(nameValue);\n+        }\n+\n+        Namespace ns;\n+        if (namespaceValue == Undefined.instance) {\n+            if (\"*\".equals(localName)) {\n+                ns = null;\n+            } else {\n+                ns = getDefaultNamespace(cx);\n+            }\n+        } else if (namespaceValue == null) {\n+            ns = null;\n+        } else if (namespaceValue instanceof Namespace) {\n+            ns = (Namespace)namespaceValue;\n+        } else {\n+            ns = constructNamespace(cx, namespaceValue);\n+        }\n+\n+        if (ns == null) {\n+            uri = null;\n+        } else {\n+            uri = ns.uri();\n+        }\n+\n+        return XMLName.formProperty(uri, localName);\n+    }\n+\n+    public Ref nameRef(Context cx, Object name,\n+                       Scriptable scope, int memberTypeFlags)\n+    {\n+        if ((memberTypeFlags & Node.ATTRIBUTE_FLAG) == 0) {\n+            // should only be called foir cases like @name or @[expr]\n+            throw Kit.codeBug();\n+        }\n+        XMLName xmlName = toAttributeName(cx, name);\n+        return xmlPrimaryReference(cx, xmlName, scope);\n+    }\n+\n+    public Ref nameRef(Context cx, Object namespace, Object name,\n+                       Scriptable scope, int memberTypeFlags)\n+    {\n+        XMLName xmlName = toQualifiedName(cx, namespace, name);\n+        if ((memberTypeFlags & Node.ATTRIBUTE_FLAG) != 0) {\n+            if (!xmlName.isAttributeName()) {\n+                xmlName.setAttributeName();\n+            }\n+        }\n+        return xmlPrimaryReference(cx, xmlName, scope);\n+    }\n+\n+    private Ref xmlPrimaryReference(Context cx, XMLName xmlName,\n+                                    Scriptable scope)\n+    {\n+        XMLObjectImpl xmlObj;\n+        XMLObjectImpl firstXmlObject = null;\n+        for (;;) {\n+            // XML object can only present on scope chain as a wrapper\n+            // of XMLWithScope\n+            if (scope instanceof XMLWithScope) {\n+                xmlObj = (XMLObjectImpl)scope.getPrototype();\n+                if (xmlObj.hasXMLProperty(xmlName)) {\n+                    break;\n+                }\n+                if (firstXmlObject == null) {\n+                    firstXmlObject = xmlObj;\n+                }\n+            }\n+            scope = scope.getParentScope();\n+            if (scope == null) {\n+                xmlObj = firstXmlObject;\n+                break;\n+            }\n+        }\n+\n+        // xmlObj == null corresponds to undefined as the target of\n+        // the reference\n+        if (xmlObj != null) {\n+            xmlName.initXMLObject(xmlObj);\n+        }\n+        return xmlName;\n+    }\n+\n+    /**\n+     * Escapes the reserved characters in a value of an attribute\n+     *\n+     * @param value Unescaped text\n+     * @return The escaped text\n+     */\n+    public String escapeAttributeValue(Object value)\n+    {\n+        String text = ScriptRuntime.toString(value);\n+\n+        if (text.length() == 0) return \"\";\n+\n+        XmlObject xo = XmlObject.Factory.newInstance();\n+\n+        XmlCursor cursor = xo.newCursor();\n+        cursor.toNextToken();\n+        cursor.beginElement(\"a\");\n+        cursor.insertAttributeWithValue(\"a\", text);\n+        cursor.dispose();\n+\n+        String elementText = xo.toString();\n+        int begin = elementText.indexOf('\"');\n+        int end = elementText.lastIndexOf('\"');\n+        return elementText.substring(begin + 1, end);\n+    }\n+\n+    /**\n+     * Escapes the reserved characters in a value of a text node\n+     *\n+     * @param value Unescaped text\n+     * @return The escaped text\n+     */\n+    public String escapeTextValue(Object value)\n+    {\n+        if (value instanceof XMLObjectImpl) {\n+            return ((XMLObjectImpl)value).toXMLString(0);\n+        }\n+\n+        String text = ScriptRuntime.toString(value);\n+\n+        if (text.length() == 0) return text;\n+\n+        XmlObject xo = XmlObject.Factory.newInstance();\n+\n+        XmlCursor cursor = xo.newCursor();\n+        cursor.toNextToken();\n+        cursor.beginElement(\"a\");\n+        cursor.insertChars(text);\n+        cursor.dispose();\n+\n+        String elementText = xo.toString();\n+        int begin = elementText.indexOf('>') + 1;\n+        int end = elementText.lastIndexOf('<');\n+        return (begin < end) ? elementText.substring(begin, end) : \"\";\n+    }\n+\n+    public Object toDefaultXmlNamespace(Context cx, Object uriValue)\n+    {\n+        return constructNamespace(cx, uriValue);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/xml/impl/xmlbeans/XMLList.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml.impl.xmlbeans;\n+\n+import java.util.Vector;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.xml.*;\n+\n+import org.apache.xmlbeans.XmlCursor;\n+\n+class XMLList extends XMLObjectImpl implements Function\n+{\n+    static final long serialVersionUID = -4543618751670781135L;\n+\n+    static class AnnotationList\n+    {\n+        private Vector v;\n+\n+\n+        AnnotationList ()\n+        {\n+            v = new Vector();\n+        }\n+\n+\n+        void add (XML.XScriptAnnotation n)\n+        {\n+            v.add(n);\n+        }\n+\n+\n+        XML.XScriptAnnotation item(int index)\n+        {\n+            return (XML.XScriptAnnotation)(v.get(index));\n+        }\n+\n+\n+        void remove (int index)\n+        {\n+            v.remove(index);\n+        }\n+\n+\n+        int length()\n+        {\n+            return v.size();\n+        }\n+    };\n+\n+\n+    // Fields\n+    private AnnotationList    _annos;\n+\n+    private XMLObjectImpl targetObject = null;\n+    private javax.xml.namespace.QName targetProperty = null;\n+\n+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    //\n+    //  Constructors\n+    //\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     *\n+     */\n+    XMLList(XMLLibImpl lib)\n+    {\n+        super(lib, lib.xmlListPrototype);\n+        _annos = new AnnotationList();\n+    }\n+\n+    /**\n+     *\n+     * @param inputObject\n+     */\n+    XMLList(XMLLibImpl lib, Object inputObject)\n+    {\n+        super(lib, lib.xmlListPrototype);\n+        String frag;\n+\n+        if (inputObject == null || inputObject instanceof Undefined)\n+        {\n+            frag = \"\";\n+        }\n+        else if (inputObject instanceof XML)\n+        {\n+            XML xml = (XML) inputObject;\n+\n+            _annos = new AnnotationList();\n+            _annos.add(xml.getAnnotation());\n+        }\n+        else if (inputObject instanceof XMLList)\n+        {\n+            XMLList xmll = (XMLList) inputObject;\n+\n+            _annos = new AnnotationList();\n+\n+            for (int i = 0; i < xmll._annos.length(); i++)\n+            {\n+                _annos.add(xmll._annos.item(i));\n+            }\n+        }\n+        else\n+        {\n+            frag = ScriptRuntime.toString(inputObject).trim();\n+\n+            if (!frag.startsWith(\"<>\"))\n+            {\n+                frag = \"<>\" + frag + \"</>\";\n+            }\n+\n+            frag = \"<fragment>\" + frag.substring(2);\n+            if (!frag.endsWith(\"</>\"))\n+            {\n+                throw ScriptRuntime.typeError(\"XML with anonymous tag missing end anonymous tag\");\n+            }\n+\n+            frag = frag.substring(0, frag.length() - 3) + \"</fragment>\";\n+\n+            XML orgXML = XML.createFromJS(lib, frag);\n+\n+            // Now orphan the children and add them to our XMLList.\n+            XMLList children = orgXML.children();\n+\n+            _annos = new AnnotationList();\n+\n+            for (int i = 0; i < children._annos.length(); i++)\n+            {\n+                // Copy here is so that they'll be orphaned (parent() will be undefined)\n+                _annos.add(((XML) children.item(i).copy()).getAnnotation());\n+            }\n+        }\n+    }\n+\n+    //\n+    //\n+    // TargetObject/Property accessors\n+    //\n+    //\n+\n+    /**\n+     *\n+     * @param object\n+     * @param property\n+     */\n+    void setTargets(XMLObjectImpl object, javax.xml.namespace.QName property)\n+    {\n+        targetObject = object;\n+        targetProperty = property;\n+    }\n+\n+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    //\n+    //  Private functions\n+    //\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     *\n+     * @param index\n+     * @return\n+     */\n+    XML getXmlFromAnnotation(int index)\n+    {\n+        XML retVal;\n+\n+        if (index >= 0 && index < length())\n+        {\n+            XML.XScriptAnnotation anno = _annos.item(index);\n+            retVal = XML.getFromAnnotation(lib, anno);\n+        }\n+        else\n+        {\n+            retVal = null;\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     *\n+     * @param index\n+     */\n+    private void internalRemoveFromList (int index)\n+    {\n+        _annos.remove(index);\n+    }\n+\n+    /**\n+     *\n+     * @param index\n+     * @param xml\n+     */\n+    void replace(int index, XML xml)\n+    {\n+        if (index < length())\n+        {\n+            AnnotationList newAnnoList = new AnnotationList();\n+\n+            // Copy upto item to replace.\n+            for (int i = 0; i < index; i++)\n+            {\n+                newAnnoList.add(_annos.item(i));\n+            }\n+\n+            newAnnoList.add(xml.getAnnotation());\n+\n+            // Skip over old item we're going to replace we've already add new item on above line.\n+            for (int i = index + 1; i < length(); i++)\n+            {\n+                newAnnoList.add(_annos.item(i));\n+            }\n+\n+            _annos = newAnnoList;\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param index\n+     * @param xml\n+     */\n+    private void insert(int index, XML xml)\n+    {\n+        if (index < length())\n+        {\n+            AnnotationList newAnnoList = new AnnotationList();\n+\n+            // Copy upto item to insert.\n+            for (int i = 0; i < index; i++)\n+            {\n+                newAnnoList.add(_annos.item(i));\n+            }\n+\n+            newAnnoList.add(xml.getAnnotation());\n+\n+            for (int i = index; i < length(); i++)\n+            {\n+                newAnnoList.add(_annos.item(i));\n+            }\n+\n+            _annos = newAnnoList;\n+        }\n+    }\n+\n+    //\n+    //\n+    //  methods overriding ScriptableObject\n+    //\n+    //\n+\n+    public String getClassName ()\n+    {\n+        return \"XMLList\";\n+    }\n+\n+    //\n+    //\n+    //  methods overriding IdScriptableObject\n+    //\n+    //\n+\n+    /**\n+     *\n+     * @param index\n+     * @param start\n+     * @return\n+     */\n+    public Object get(int index, Scriptable start)\n+    {\n+        //Log(\"get index: \" + index);\n+\n+        if (index >= 0 && index < length())\n+        {\n+            return getXmlFromAnnotation(index);\n+        }\n+        else\n+        {\n+            return Scriptable.NOT_FOUND;\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @param start\n+     * @return\n+     */\n+    boolean hasXMLProperty(XMLName xmlName)\n+    {\n+        boolean result = false;\n+\n+        // Has now should return true if the property would have results > 0 or\n+        // if it's a method name\n+        String name = xmlName.localName();\n+        if ((getPropertyList(xmlName).length() > 0) ||\n+            (getMethod(name) != NOT_FOUND))\n+        {\n+            result = true;\n+        }\n+\n+        return result;\n+    }\n+\n+\n+    /**\n+     *\n+     * @param index\n+     * @param start\n+     * @return\n+     */\n+    public boolean has(int index, Scriptable start)\n+    {\n+        return 0 <= index && index < length();\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @param value\n+     */\n+    void putXMLProperty(XMLName xmlName, Object value)\n+    {\n+        //Log(\"put property: \" + name);\n+\n+        // Special-case checks for undefined and null\n+        if (value == null)\n+        {\n+            value = \"null\";\n+        }\n+        else if (value instanceof Undefined)\n+        {\n+            value = \"undefined\";\n+        }\n+\n+        if (length() > 1)\n+        {\n+            throw ScriptRuntime.typeError(\"Assignment to lists with more that one item is not supported\");\n+        }\n+        else if (length() == 0)\n+        {\n+            // Secret sauce for super-expandos.\n+            // We set an element here, and then add ourselves to our target.\n+            if (targetObject != null &&\n+                targetProperty != null &&\n+                !targetProperty.getLocalPart().equals(\"*\"))\n+            {\n+                // Add an empty element with our targetProperty name and then set it.\n+                XML xmlValue = XML.createTextElement(lib, targetProperty, \"\");\n+                addToList(xmlValue);\n+\n+                if(xmlName.isAttributeName())\n+                {\n+                    setAttribute(xmlName, value);\n+                }\n+                else\n+                {\n+                    XML xml = item(0);\n+                    xml.putXMLProperty(xmlName, value);\n+\n+                    // Update the list with the new item at location 0.\n+                    replace(0, item(0));\n+                }\n+\n+                // Now add us to our parent\n+                XMLName name2 = XMLName.formProperty(targetProperty.getNamespaceURI(), targetProperty.getLocalPart());\n+                targetObject.putXMLProperty(name2, this);\n+            }\n+            else\n+            {\n+                throw ScriptRuntime.typeError(\"Assignment to empty XMLList without targets not supported\");\n+            }\n+        }\n+        else if(xmlName.isAttributeName())\n+        {\n+            setAttribute(xmlName, value);\n+        }\n+        else\n+        {\n+            XML xml = item(0);\n+            xml.putXMLProperty(xmlName, value);\n+\n+            // Update the list with the new item at location 0.\n+            replace(0, item(0));\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @return\n+     */\n+    Object getXMLProperty(XMLName name)\n+    {\n+        return getPropertyList(name);\n+    }\n+\n+    /**\n+     *\n+     * @param index\n+     * @param value\n+     */\n+    public void put(int index, Scriptable start, Object value)\n+    {\n+        Object parent = Undefined.instance;\n+        // Convert text into XML if needed.\n+        XMLObject xmlValue;\n+\n+        // Special-case checks for undefined and null\n+        if (value == null)\n+        {\n+            value = \"null\";\n+        }\n+        else if (value instanceof Undefined)\n+        {\n+            value = \"undefined\";\n+        }\n+\n+        if (value instanceof XMLObject)\n+        {\n+            xmlValue = (XMLObject) value;\n+        }\n+        else\n+        {\n+            if (targetProperty == null)\n+            {\n+                xmlValue = XML.createFromJS(lib, value.toString());\n+            }\n+            else\n+            {\n+                xmlValue = XML.createTextElement(lib, targetProperty, value.toString());\n+            }\n+        }\n+\n+        // Find the parent\n+        if (index < length())\n+        {\n+            parent = item(index).parent();\n+        }\n+        else\n+        {\n+            // Appending\n+            parent = parent();\n+        }\n+\n+        if (parent instanceof XML)\n+        {\n+            // found parent, alter doc\n+            XML xmlParent = (XML) parent;\n+\n+            if (index < length())\n+            {\n+                // We're replacing the the node.\n+                XML xmlNode = getXmlFromAnnotation(index);\n+\n+                if (xmlValue instanceof XML)\n+                {\n+                    xmlNode.replaceAll((XML) xmlValue);\n+                    replace(index, xmlNode);\n+                }\n+                else if (xmlValue instanceof XMLList)\n+                {\n+                    // Replace the first one, and add the rest on the list.\n+                    XMLList list = (XMLList) xmlValue;\n+\n+                    if (list.length() > 0)\n+                    {\n+                        int lastIndexAdded = xmlNode.childIndex();\n+                        xmlNode.replaceAll(list.item(0));\n+                        replace(index, list.item(0));\n+\n+                        for (int i = 1; i < list.length(); i++)\n+                        {\n+                            xmlParent.insertChildAfter(xmlParent.getXmlChild(lastIndexAdded), list.item(i));\n+                            lastIndexAdded++;\n+                            insert(index + i, list.item(i));\n+                        }\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                // Appending\n+                xmlParent.appendChild(xmlValue);\n+                addToList(xmlParent.getXmlChild(index));\n+            }\n+        }\n+        else\n+        {\n+            // Don't all have same parent, no underlying doc to alter\n+            if (index < length())\n+            {\n+                XML xmlNode = XML.getFromAnnotation(lib, _annos.item(index));\n+\n+                if (xmlValue instanceof XML)\n+                {\n+                    xmlNode.replaceAll((XML) xmlValue);\n+                    replace(index, xmlNode);\n+                }\n+                else if (xmlValue instanceof XMLList)\n+                {\n+                    // Replace the first one, and add the rest on the list.\n+                    XMLList list = (XMLList) xmlValue;\n+\n+                    if (list.length() > 0)\n+                    {\n+                        xmlNode.replaceAll(list.item(0));\n+                        replace(index, list.item(0));\n+\n+                        for (int i = 1; i < list.length(); i++)\n+                        {\n+                            insert(index + i, list.item(i));\n+                        }\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                addToList(xmlValue);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     *\n+     * @param name\n+     */\n+    void deleteXMLProperty(XMLName name)\n+    {\n+        for (int i = 0; i < length(); i++)\n+        {\n+            XML xml = getXmlFromAnnotation(i);\n+\n+            if (xml.tokenType() == XmlCursor.TokenType.START)\n+            {\n+                xml.deleteXMLProperty(name);\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param index\n+     */\n+    public void delete(int index)\n+    {\n+        if (index >= 0 && index < length())\n+        {\n+            XML xml = getXmlFromAnnotation(index);\n+\n+            xml.remove();\n+\n+            internalRemoveFromList(index);\n+        }\n+    }\n+\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public Object[] getIds()\n+    {\n+        Object enumObjs[];\n+\n+        if (prototypeFlag)\n+        {\n+            enumObjs = new Object[0];\n+        }\n+        else\n+        {\n+            enumObjs = new Object[length()];\n+\n+            for (int i = 0; i < enumObjs.length; i++)\n+            {\n+                enumObjs[i] = new Integer(i);\n+            }\n+        }\n+\n+        return enumObjs;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public Object[] getIdsForDebug()\n+    {\n+        return getIds();\n+    }\n+\n+\n+    // XMLList will remove will delete all items in the list (a set delete) this differs from the XMLList delete operator.\n+    void remove ()\n+    {\n+        int nLen = length();\n+        for (int i = nLen - 1; i >= 0; i--)\n+        {\n+            XML xml = getXmlFromAnnotation(i);\n+            if (xml != null)\n+            {\n+                xml.remove();\n+                internalRemoveFromList(i);\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param index\n+     * @return\n+     */\n+    XML item (int index)\n+    {\n+        return _annos != null\n+            ? getXmlFromAnnotation(index) : XML.createEmptyXML(lib);\n+    }\n+\n+\n+    /**\n+     *\n+     * @param name\n+     * @param value\n+     */\n+    private void setAttribute (XMLName xmlName, Object value)\n+    {\n+        for (int i = 0; i < length(); i++)\n+        {\n+            XML xml = getXmlFromAnnotation(i);\n+            xml.setAttribute(xmlName, value);\n+        }\n+    }\n+\n+\n+    /**\n+     *\n+     * @param toAdd\n+     */\n+    void addToList(Object toAdd)\n+    {\n+        if (toAdd instanceof Undefined)\n+        {\n+            // Missing argument do nothing...\n+            return;\n+        }\n+\n+        if (toAdd instanceof XMLList)\n+        {\n+            XMLList xmlSrc = (XMLList)toAdd;\n+            for (int i = 0; i < xmlSrc.length(); i++)\n+            {\n+                _annos.add((xmlSrc.item(i)).getAnnotation());\n+            }\n+        }\n+        else if (toAdd instanceof XML)\n+        {\n+            _annos.add(((XML)(toAdd)).getAnnotation());\n+        }\n+        else if (toAdd instanceof XML.XScriptAnnotation)\n+        {\n+            _annos.add((XML.XScriptAnnotation)toAdd);\n+        }\n+    }\n+\n+    //\n+    //\n+    // Methods from section 12.4.4 in the spec\n+    //\n+    //\n+\n+    /**\n+     *\n+     * @param toAdd\n+     */\n+    XML addNamespace(Namespace ns)\n+    {\n+        if(length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).addNamespace(ns);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The addNamespace method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param xml\n+     * @return\n+     */\n+    XML appendChild(Object xml)\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).appendChild(xml);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The appendChild method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param attr\n+     * @return\n+     */\n+    XMLList attribute(XMLName xmlName)\n+    {\n+        XMLList result = new XMLList(lib);\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            XML xml = getXmlFromAnnotation(i);\n+            result.addToList(xml.attribute(xmlName));\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    XMLList attributes()\n+    {\n+        XMLList result = new XMLList(lib);\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            XML xml = getXmlFromAnnotation(i);\n+            result.addToList(xml.attributes());\n+        }\n+\n+        return result;\n+    }\n+\n+    XMLList child(long index)\n+    {\n+        XMLList result = new XMLList(lib);\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            result.addToList(getXmlFromAnnotation(i).child(index));\n+        }\n+\n+        return result;\n+    }\n+\n+    XMLList child(XMLName xmlName)\n+    {\n+        XMLList result = new XMLList(lib);\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            result.addToList(getXmlFromAnnotation(i).child(xmlName));\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    int childIndex()\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).childIndex();\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The childIndex method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    XMLList children()\n+    {\n+        Vector v = new Vector();\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            XML xml = getXmlFromAnnotation(i);\n+\n+            if (xml != null)\n+            {\n+                Object o = xml.children();\n+                if (o instanceof XMLList)\n+                {\n+                    XMLList childList = (XMLList)o;\n+\n+                    int cChildren = childList.length();\n+                    for (int j = 0; j < cChildren; j++)\n+                    {\n+                        v.addElement(childList.item(j));\n+                    }\n+                }\n+            }\n+        }\n+\n+        XMLList allChildren = new XMLList(lib);\n+        int sz = v.size();\n+\n+        for (int i = 0; i < sz; i++)\n+        {\n+            allChildren.addToList(v.get(i));\n+        }\n+\n+        return allChildren;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    XMLList comments()\n+    {\n+        XMLList result = new XMLList(lib);\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            XML xml = getXmlFromAnnotation(i);\n+\n+            result.addToList(xml.comments());\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param xml\n+     * @return\n+     */\n+    boolean contains(Object xml)\n+    {\n+        boolean result = false;\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            XML member = getXmlFromAnnotation(i);\n+\n+            if (member.equivalentXml(xml))\n+            {\n+                result = true;\n+                break;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object copy()\n+    {\n+        XMLList result = new XMLList(lib);\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            XML xml = getXmlFromAnnotation(i);\n+            result.addToList(xml.copy());\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    XMLList descendants(XMLName xmlName)\n+    {\n+        XMLList result = new XMLList(lib);\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            XML xml = getXmlFromAnnotation(i);\n+            result.addToList(xml.descendants(xmlName));\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object[] inScopeNamespaces()\n+    {\n+        if(length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).inScopeNamespaces();\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The inScopeNamespaces method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param child\n+     * @param xml\n+     */\n+    XML insertChildAfter(Object child, Object xml)\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).insertChildAfter(child, xml);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The insertChildAfter method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param child\n+     * @param xml\n+     */\n+    XML insertChildBefore(Object child, Object xml)\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).insertChildAfter(child, xml);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The insertChildBefore method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    boolean hasOwnProperty(XMLName xmlName)\n+    {\n+        boolean hasProperty = false;\n+\n+        if (prototypeFlag)\n+        {\n+            String property = xmlName.localName();\n+            hasProperty = (0 != findPrototypeId(property));\n+        }\n+        else\n+        {\n+            hasProperty = (getPropertyList(xmlName).length() > 0);\n+        }\n+\n+        return hasProperty;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    boolean hasComplexContent()\n+    {\n+        boolean complexContent;\n+        int length = length();\n+\n+        if (length == 0)\n+        {\n+            complexContent = false;\n+        }\n+        else if (length == 1)\n+        {\n+            complexContent = getXmlFromAnnotation(0).hasComplexContent();\n+        }\n+        else\n+        {\n+            complexContent = false;\n+\n+            for (int i = 0; i < length; i++)\n+            {\n+                XML nextElement = getXmlFromAnnotation(i);\n+                if (nextElement.tokenType() == XmlCursor.TokenType.START)\n+                {\n+                    complexContent = true;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return complexContent;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    boolean hasSimpleContent()\n+    {\n+        boolean simpleContent;\n+        int length = length();\n+\n+        if (length == 0)\n+        {\n+            simpleContent = true;\n+        }\n+        else if (length == 1)\n+        {\n+            simpleContent = getXmlFromAnnotation(0).hasSimpleContent();\n+        }\n+        else\n+        {\n+            simpleContent = true;\n+\n+            for (int i = 0; i < length; i++)\n+            {\n+                XML nextElement = getXmlFromAnnotation(i);\n+                if (nextElement.tokenType() == XmlCursor.TokenType.START)\n+                {\n+                    simpleContent = false;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return simpleContent;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    int length()\n+    {\n+        int result = 0;\n+\n+        if (_annos != null)\n+        {\n+            result = _annos.length();\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    String localName()\n+    {\n+        if (length() == 1)\n+        {\n+            return name().localName();\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The localName method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    QName name()\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).name();\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The name method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param prefix\n+     * @return\n+     */\n+    Object namespace(String prefix)\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).namespace(prefix);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The namespace method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object[] namespaceDeclarations()\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).namespaceDeclarations();\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The namespaceDeclarations method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object nodeKind()\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).nodeKind();\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The nodeKind method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     */\n+    void normalize()\n+    {\n+        for (int i = 0; i < length(); i++)\n+        {\n+            getXmlFromAnnotation(i).normalize();\n+        }\n+    }\n+\n+    /**\n+     * If list is empty, return undefined, if elements have different parents return undefined,\n+     * If they all have the same parent, return that parent.\n+     *\n+     * @return\n+     */\n+    Object parent()\n+    {\n+        Object sameParent = Undefined.instance;\n+\n+        if ((length() == 0) && (targetObject != null) && (targetObject instanceof XML))\n+        {\n+            sameParent = targetObject;\n+        }\n+        else\n+        {\n+            for (int i = 0; i < length(); i++)\n+            {\n+                Object currParent = getXmlFromAnnotation(i).parent();\n+\n+                if (i == 0)\n+                {\n+                    // Set the first for the rest to compare to.\n+                    sameParent = currParent;\n+                }\n+                else if (sameParent != currParent)\n+                {\n+                    sameParent = Undefined.instance;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // If everything in the list is the sameParent then return that as the parent.\n+        return sameParent;\n+    }\n+\n+    /**\n+     *\n+     * @param xml\n+     * @return\n+     */\n+    XML prependChild(Object xml)\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).prependChild(xml);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The prependChild method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object processingInstructions(XMLName xmlName)\n+    {\n+        XMLList result = new XMLList(lib);\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            XML xml = getXmlFromAnnotation(i);\n+\n+            result.addToList(xml.processingInstructions(xmlName));\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @return\n+     */\n+    boolean propertyIsEnumerable(Object name)\n+    {\n+        long index;\n+        if (name instanceof Integer) {\n+            index = ((Integer)name).intValue();\n+        } else if (name instanceof Number) {\n+            double x = ((Number)name).doubleValue();\n+            index = (long)x;\n+            if (index != x) {\n+                return false;\n+            }\n+            if (index == 0 && 1.0 / x < 0) {\n+                // Negative 0\n+                return false;\n+            }\n+        } else {\n+            String s = ScriptRuntime.toString(name);\n+            index = ScriptRuntime.testUint32String(s);\n+        }\n+        return (0 <= index && index < length());\n+    }\n+\n+    /**\n+     *\n+     * @param ns\n+     */\n+    XML removeNamespace(Namespace ns)\n+    {\n+        if(length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).removeNamespace(ns);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The removeNamespace method works only on lists containing one item\");\n+        }\n+    }\n+\n+    XML replace(long index, Object xml)\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).replace(index, xml);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The replace method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param propertyName\n+     * @param xml\n+     * @return\n+     */\n+    XML replace(XMLName xmlName, Object xml)\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).replace(xmlName, xml);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The replace method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param xml\n+     */\n+    XML setChildren(Object xml)\n+    {\n+        if (length() == 1)\n+        {\n+            return getXmlFromAnnotation(0).setChildren(xml);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The setChildren method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     */\n+    void setLocalName(String localName)\n+    {\n+        if (length() == 1)\n+        {\n+            getXmlFromAnnotation(0).setLocalName(localName);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The setLocalName method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     */\n+    void setName(QName qname)\n+    {\n+        if (length() == 1)\n+        {\n+            getXmlFromAnnotation(0).setName(qname);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The setName method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param ns\n+     */\n+    void setNamespace(Namespace ns)\n+    {\n+        if (length() == 1)\n+        {\n+            getXmlFromAnnotation(0).setNamespace(ns);\n+        }\n+        else\n+        {\n+            throw ScriptRuntime.typeError(\"The setNamespace method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * * @return\n+     */\n+    XMLList text()\n+    {\n+        XMLList result = new XMLList(lib);\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            result.addToList(getXmlFromAnnotation(i).text());\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    public String toString()\n+    {\n+        if (hasSimpleContent())\n+        {\n+            StringBuffer sb = new StringBuffer();\n+\n+            for(int i = 0; i < length(); i++)\n+            {\n+                XML next = getXmlFromAnnotation(i);\n+                sb.append(next.toString());\n+            }\n+\n+            return sb.toString();\n+        }\n+        else\n+        {\n+            return toXMLString(0);\n+        }\n+    }\n+\n+    String toSource(int indent)\n+    {\n+        // XXX indent is ignored\n+        return \"<>\"+toXMLString(0)+\"</>\";\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    String toXMLString(int indent)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+\n+        for(int i = 0; i < length(); i++)\n+        {\n+            if (i > 0)\n+            {\n+                sb.append('\\n');\n+            }\n+\n+            sb.append(getXmlFromAnnotation(i).toXMLString(indent));\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    Object valueOf()\n+    {\n+        return this;\n+    }\n+\n+    //\n+    // Other public Functions from XMLObject\n+    //\n+\n+    /**\n+     *\n+     * @param target\n+     * @return\n+     */\n+    boolean equivalentXml(Object target)\n+    {\n+        boolean result = false;\n+\n+        // Zero length list should equate to undefined\n+        if (target instanceof Undefined && length() == 0)\n+        {\n+            result = true;\n+        }\n+        else if (length() == 1)\n+        {\n+            result = getXmlFromAnnotation(0).equivalentXml(target);\n+        }\n+        else if (target instanceof XMLList)\n+        {\n+            XMLList otherList = (XMLList) target;\n+\n+            if (otherList.length() == length())\n+            {\n+                result = true;\n+\n+                for (int i = 0; i < length(); i++)\n+                {\n+                    if (!getXmlFromAnnotation(i).equivalentXml(otherList.getXmlFromAnnotation(i)))\n+                    {\n+                        result = false;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @param start\n+     * @return\n+     */\n+    private XMLList getPropertyList(XMLName name)\n+    {\n+        XMLList propertyList = new XMLList(lib);\n+        javax.xml.namespace.QName qname = null;\n+\n+        if (!name.isDescendants() && !name.isAttributeName())\n+        {\n+            // Only set the targetProperty if this is a regular child get\n+            // and not a descendant or attribute get\n+            qname = new javax.xml.namespace.QName(name.uri(), name.localName());\n+        }\n+\n+        propertyList.setTargets(this, qname);\n+\n+        for (int i = 0; i < length(); i++)\n+        {\n+            propertyList.addToList(\n+                getXmlFromAnnotation(i).getPropertyList(name));\n+        }\n+\n+        return propertyList;\n+    }\n+\n+    private Object applyOrCall(boolean isApply,\n+                               Context cx, Scriptable scope,\n+                               Scriptable thisObj, Object[] args)\n+    {\n+        String methodName = isApply ? \"apply\" : \"call\";\n+        if(!(thisObj instanceof XMLList) ||\n+           ((XMLList)thisObj).targetProperty == null)\n+            throw ScriptRuntime.typeError1(\"msg.isnt.function\",\n+                                           methodName);\n+\n+        return ScriptRuntime.applyOrCall(isApply, cx, scope, thisObj, args);\n+    }\n+\n+    protected Object jsConstructor(Context cx, boolean inNewExpr,\n+                                   Object[] args)\n+    {\n+        if (args.length == 0) {\n+            return new XMLList(lib);\n+        } else {\n+            Object arg0 = args[0];\n+            if (!inNewExpr && arg0 instanceof XMLList) {\n+                // XMLList(XMLList) returns the same object.\n+                return arg0;\n+            }\n+            return new XMLList(lib, arg0);\n+        }\n+    }\n+\n+    org.apache.xmlbeans.XmlObject getXmlObject()\n+    {\n+        if (length() == 1) {\n+            return getXmlFromAnnotation(0).getXmlObject();\n+        } else {\n+            throw ScriptRuntime.typeError(\"getXmlObject method works only on lists containing one item\");\n+        }\n+    }\n+\n+    /**\n+     * See ECMA 357, 11_2_2_1, Semantics, 3_e.\n+     */\n+    public Scriptable getExtraMethodSource(Context cx)\n+    {\n+        if (length() == 1) {\n+            return getXmlFromAnnotation(0);\n+        }\n+        return null;\n+    }\n+\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        // This XMLList is being called as a Function.\n+        // Let's find the real Function object.\n+        if(targetProperty == null)\n+            throw ScriptRuntime.notFunctionError(this);\n+\n+        String methodName = targetProperty.getLocalPart();\n+\n+        boolean isApply = methodName.equals(\"apply\");\n+        if(isApply || methodName.equals(\"call\"))\n+            return applyOrCall(isApply, cx, scope, thisObj, args);\n+\n+        Callable method = ScriptRuntime.getElemFunctionAndThis(\n+                              this, methodName, cx);\n+        // Call lastStoredScriptable to clear stored thisObj\n+        // but ignore the result as the method should use the supplied\n+        // thisObj, not one from redirected call\n+        ScriptRuntime.lastStoredScriptable(cx);\n+        return method.call(cx, scope, thisObj, args);\n+    }\n+\n+    public Scriptable construct(Context cx, Scriptable scope, Object[] args)\n+    {\n+        throw ScriptRuntime.typeError1(\"msg.not.ctor\", \"XMLList\");\n+    }\n+}\n+\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/xml/impl/xmlbeans/XMLName.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml.impl.xmlbeans;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.Kit;\n+import org.mozilla.javascript.Ref;\n+import org.mozilla.javascript.ScriptRuntime;\n+import org.mozilla.javascript.Undefined;\n+\n+class XMLName extends Ref\n+{\n+    static final long serialVersionUID = 3832176310755686977L;\n+\n+    private String uri;\n+    private String localName;\n+    private boolean isAttributeName;\n+    private boolean isDescendants;\n+    private XMLObjectImpl xmlObject;\n+\n+    private XMLName(String uri, String localName)\n+    {\n+        this.uri = uri;\n+        this.localName = localName;\n+    }\n+\n+    static XMLName formStar()\n+    {\n+        return new XMLName(null, \"*\");\n+    }\n+\n+    static XMLName formProperty(String uri, String localName)\n+    {\n+        return new XMLName(uri, localName);\n+    }\n+\n+    void initXMLObject(XMLObjectImpl xmlObject)\n+    {\n+        if (xmlObject == null) throw new IllegalArgumentException();\n+        if (this.xmlObject != null) throw new IllegalStateException();\n+        this.xmlObject = xmlObject;\n+    }\n+\n+    String uri()\n+    {\n+        return uri;\n+    }\n+\n+    String localName()\n+    {\n+        return localName;\n+    }\n+\n+    boolean isAttributeName()\n+    {\n+        return isAttributeName;\n+    }\n+\n+    void setAttributeName()\n+    {\n+        if (isAttributeName) throw new IllegalStateException();\n+        isAttributeName = true;\n+    }\n+\n+    boolean isDescendants()\n+    {\n+        return isDescendants;\n+    }\n+\n+    void setIsDescendants()\n+    {\n+        if (isDescendants) throw new IllegalStateException();\n+        isDescendants = true;\n+    }\n+\n+    public boolean has(Context cx)\n+    {\n+        if (xmlObject == null) {\n+            return false;\n+        }\n+        return xmlObject.hasXMLProperty(this);\n+    }\n+\n+    public Object get(Context cx)\n+    {\n+        if (xmlObject == null) {\n+            throw ScriptRuntime.undefReadError(Undefined.instance,\n+                                               toString());\n+        }\n+        return xmlObject.getXMLProperty(this);\n+    }\n+\n+    public Object set(Context cx, Object value)\n+    {\n+        if (xmlObject == null) {\n+            throw ScriptRuntime.undefWriteError(Undefined.instance,\n+                                                toString(),\n+                                                value);\n+        }\n+        // Assignment to descendants causes parse error on bad reference\n+        // and this should not be called\n+        if (isDescendants) throw Kit.codeBug();\n+        xmlObject.putXMLProperty(this, value);\n+        return value;\n+    }\n+\n+    public boolean delete(Context cx)\n+    {\n+        if (xmlObject == null) {\n+            return true;\n+        }\n+        xmlObject.deleteXMLProperty(this);\n+        return !xmlObject.hasXMLProperty(this);\n+    }\n+\n+    public String toString()\n+    {\n+        //return qname.localName();\n+        StringBuffer buff = new StringBuffer();\n+        if (isDescendants) buff.append(\"..\");\n+        if (isAttributeName) buff.append('@');\n+        if (uri == null) {\n+            buff.append('*');\n+            if(localName().equals(\"*\")) {\n+                return buff.toString();\n+            }\n+        } else {\n+            buff.append('\"').append(uri()).append('\"');\n+        }\n+        buff.append(':').append(localName());\n+        return buff.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/xml/impl/xmlbeans/XMLObjectImpl.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml.impl.xmlbeans;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.xml.*;\n+\n+/**\n+ *  This abstract class describes what all XML objects (XML, XMLList) should have in common.\n+ *\n+ * @see XML\n+ */\n+abstract class XMLObjectImpl extends XMLObject\n+{\n+    private static final Object XMLOBJECT_TAG = \"XMLObject\";\n+\n+    protected final XMLLibImpl lib;\n+    protected boolean prototypeFlag;\n+\n+    protected XMLObjectImpl(XMLLibImpl lib, XMLObject prototype)\n+    {\n+        super(lib.globalScope(), prototype);\n+        this.lib = lib;\n+    }\n+\n+    /**\n+     * ecmaHas(cx, id) calls this after resolving when id to XMLName\n+     * and checking it is not Uint32 index.\n+     */\n+    abstract boolean hasXMLProperty(XMLName name);\n+\n+    /**\n+     * ecmaGet(cx, id) calls this after resolving when id to XMLName\n+     * and checking it is not Uint32 index.\n+     */\n+    abstract Object getXMLProperty(XMLName name);\n+\n+    /**\n+     * ecmaPut(cx, id, value) calls this after resolving when id to XMLName\n+     * and checking it is not Uint32 index.\n+     */\n+    abstract void putXMLProperty(XMLName name, Object value);\n+\n+    /**\n+     * ecmaDelete(cx, id) calls this after resolving when id to XMLName\n+     * and checking it is not Uint32 index.\n+     */\n+    abstract void deleteXMLProperty(XMLName name);\n+\n+    /**\n+     * Test XML equality with target the target.\n+     */\n+    abstract boolean equivalentXml(Object target);\n+\n+    // Methods from section 12.4.4 in the spec\n+    abstract XML addNamespace(Namespace ns);\n+    abstract XML appendChild(Object xml);\n+    abstract XMLList attribute(XMLName xmlName);\n+    abstract XMLList attributes();\n+    abstract XMLList child(long index);\n+    abstract XMLList child(XMLName xmlName);\n+    abstract int childIndex();\n+    abstract XMLList children();\n+    abstract XMLList comments();\n+    abstract boolean contains(Object xml);\n+    abstract Object copy();\n+    abstract XMLList descendants(XMLName xmlName);\n+    abstract Object[] inScopeNamespaces();\n+    abstract XML insertChildAfter(Object child, Object xml);\n+    abstract XML insertChildBefore(Object child, Object xml);\n+    abstract boolean hasOwnProperty(XMLName xmlName);\n+    abstract boolean hasComplexContent();\n+    abstract boolean hasSimpleContent();\n+    abstract int length();\n+    abstract String localName();\n+    abstract QName name();\n+    abstract Object namespace(String prefix);\n+    abstract Object[] namespaceDeclarations();\n+    abstract Object nodeKind();\n+    abstract void normalize();\n+    abstract Object parent();\n+    abstract XML prependChild(Object xml);\n+    abstract Object processingInstructions(XMLName xmlName);\n+    abstract boolean propertyIsEnumerable(Object member);\n+    abstract XML removeNamespace(Namespace ns);\n+    abstract XML replace(long index, Object xml);\n+    abstract XML replace(XMLName name, Object xml);\n+    abstract XML setChildren(Object xml);\n+    abstract void setLocalName(String name);\n+    abstract void setName(QName xmlName);\n+    abstract void setNamespace(Namespace ns);\n+    abstract XMLList text();\n+    public abstract String toString();\n+    abstract String toSource(int indent);\n+    abstract String toXMLString(int indent);\n+    abstract Object valueOf();\n+\n+    /**\n+     * Extension to access native implementation from scripts\n+     */\n+    abstract org.apache.xmlbeans.XmlObject getXmlObject();\n+\n+    protected abstract Object jsConstructor(Context cx, boolean inNewExpr,\n+                                            Object[] args);\n+\n+\n+    final Object getMethod(String id)\n+    {\n+        return super.get(id, this);\n+    }\n+\n+    //\n+    //\n+    // Methods overriding ScriptableObject\n+    //\n+    //\n+\n+    public final Object getDefaultValue(Class hint)\n+    {\n+        return toString();\n+    }\n+\n+    public void delete(String name)\n+    {\n+        throw new IllegalArgumentException(\"String: [\" + name + \"]\");\n+    }\n+\n+    /**\n+     * XMLObject always compare with any value and equivalentValues\n+     * never returns {@link Scriptable#NOT_FOUND} for them but rather\n+     * calls equivalentXml(value) and wrap the result as Boolean.\n+     */\n+    protected final Object equivalentValues(Object value)\n+    {\n+        boolean result = equivalentXml(value);\n+        return result ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    //\n+    //\n+    // Methods overriding XMLObject\n+    //\n+    //\n+\n+    public final XMLLib lib()\n+    {\n+        return lib;\n+    }\n+\n+    /**\n+     * Implementation of ECMAScript [[Has]]\n+     */\n+    public final boolean ecmaHas(Context cx, Object id)\n+    {\n+        if (cx == null) cx = Context.getCurrentContext();\n+        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);\n+        if (xmlName == null) {\n+            long index = ScriptRuntime.lastUint32Result(cx);\n+            // XXX Fix this cast\n+            return has((int)index, this);\n+        }\n+        return hasXMLProperty(xmlName);\n+    }\n+\n+    /**\n+     * Implementation of ECMAScript [[Get]]\n+     */\n+    public final Object ecmaGet(Context cx, Object id)\n+    {\n+        if (cx == null) cx = Context.getCurrentContext();\n+        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);\n+        if (xmlName == null) {\n+            long index = ScriptRuntime.lastUint32Result(cx);\n+            // XXX Fix this cast\n+            Object result = get((int)index, this);\n+            if (result == Scriptable.NOT_FOUND) {\n+                result = Undefined.instance;\n+            }\n+            return result;\n+        }\n+        return getXMLProperty(xmlName);\n+    }\n+\n+    /**\n+     * Implementation of ECMAScript [[Put]]\n+     */\n+    public final void ecmaPut(Context cx, Object id, Object value)\n+    {\n+        if (cx == null) cx = Context.getCurrentContext();\n+        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);\n+        if (xmlName == null) {\n+            long index = ScriptRuntime.lastUint32Result(cx);\n+            // XXX Fix this cast\n+            put((int)index, this, value);\n+            return;\n+        }\n+        putXMLProperty(xmlName, value);\n+    }\n+\n+    /**\n+     * Implementation of ECMAScript [[Delete]].\n+     */\n+    public final boolean ecmaDelete(Context cx, Object id)\n+    {\n+        if (cx == null) cx = Context.getCurrentContext();\n+        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);\n+        if (xmlName == null) {\n+            long index = ScriptRuntime.lastUint32Result(cx);\n+            // XXX Fix this\n+            delete((int)index);\n+            return true;\n+        }\n+        deleteXMLProperty(xmlName);\n+        return true;\n+    }\n+\n+    public Ref memberRef(Context cx, Object elem, int memberTypeFlags)\n+    {\n+        XMLName xmlName;\n+        if ((memberTypeFlags & Node.ATTRIBUTE_FLAG) != 0) {\n+            xmlName = lib.toAttributeName(cx, elem);\n+        } else {\n+            if ((memberTypeFlags & Node.DESCENDANTS_FLAG) == 0) {\n+                // Code generation would use ecma(Get|Has|Delete|Set) for\n+                // normal name idenrifiers so one ATTRIBUTE_FLAG\n+                // or DESCENDANTS_FLAG has to be set\n+                throw Kit.codeBug();\n+            }\n+            xmlName = lib.toXMLName(cx, elem);\n+        }\n+        if ((memberTypeFlags & Node.DESCENDANTS_FLAG) != 0) {\n+            xmlName.setIsDescendants();\n+        }\n+        xmlName.initXMLObject(this);\n+        return xmlName;\n+    }\n+\n+    /**\n+     * Generic reference to implement x::ns, x.@ns::y, x..@ns::y etc.\n+     */\n+    public Ref memberRef(Context cx, Object namespace, Object elem,\n+                         int memberTypeFlags)\n+    {\n+        XMLName xmlName = lib.toQualifiedName(cx, namespace, elem);\n+        if ((memberTypeFlags & Node.ATTRIBUTE_FLAG) != 0) {\n+            if (!xmlName.isAttributeName()) {\n+                xmlName.setAttributeName();\n+            }\n+        }\n+        if ((memberTypeFlags & Node.DESCENDANTS_FLAG) != 0) {\n+            xmlName.setIsDescendants();\n+        }\n+        xmlName.initXMLObject(this);\n+        return xmlName;\n+    }\n+\n+    public NativeWith enterWith(Scriptable scope)\n+    {\n+        return new XMLWithScope(lib, scope, this);\n+    }\n+\n+    public NativeWith enterDotQuery(Scriptable scope)\n+    {\n+        XMLWithScope xws = new XMLWithScope(lib, scope, this);\n+        xws.initAsDotQuery();\n+        return xws;\n+    }\n+\n+    public final Object addValues(Context cx, boolean thisIsLeft,\n+                                     Object value)\n+    {\n+        if (value instanceof XMLObject) {\n+            XMLObject v1, v2;\n+            if (thisIsLeft) {\n+                v1 = this;\n+                v2 = (XMLObject)value;\n+            } else {\n+                v1 = (XMLObject)value;\n+                v2 = this;\n+            }\n+            return lib.addXMLObjects(cx, v1, v2);\n+        }\n+        if (value == Undefined.instance) {\n+            // both \"xml + undefined\" and \"undefined + xml\" gives String(xml)\n+            return ScriptRuntime.toString(this);\n+        }\n+\n+        return super.addValues(cx, thisIsLeft, value);\n+    }\n+\n+    //\n+    //\n+    // IdScriptableObject machinery\n+    //\n+    //\n+\n+    final void exportAsJSClass(boolean sealed)\n+    {\n+        prototypeFlag = true;\n+        exportAsJSClass(MAX_PROTOTYPE_ID, lib.globalScope(), sealed);\n+    }\n+\n+// #string_id_map#\n+    private final static int\n+        Id_constructor             = 1,\n+\n+        Id_addNamespace            = 2,\n+        Id_appendChild             = 3,\n+        Id_attribute               = 4,\n+        Id_attributes              = 5,\n+        Id_child                   = 6,\n+        Id_childIndex              = 7,\n+        Id_children                = 8,\n+        Id_comments                = 9,\n+        Id_contains                = 10,\n+        Id_copy                    = 11,\n+        Id_descendants             = 12,\n+        Id_inScopeNamespaces       = 13,\n+        Id_insertChildAfter        = 14,\n+        Id_insertChildBefore       = 15,\n+        Id_hasOwnProperty          = 16,\n+        Id_hasComplexContent       = 17,\n+        Id_hasSimpleContent        = 18,\n+        Id_length                  = 19,\n+        Id_localName               = 20,\n+        Id_name                    = 21,\n+        Id_namespace               = 22,\n+        Id_namespaceDeclarations   = 23,\n+        Id_nodeKind                = 24,\n+        Id_normalize               = 25,\n+        Id_parent                  = 26,\n+        Id_prependChild            = 27,\n+        Id_processingInstructions  = 28,\n+        Id_propertyIsEnumerable    = 29,\n+        Id_removeNamespace         = 30,\n+        Id_replace                 = 31,\n+        Id_setChildren             = 32,\n+        Id_setLocalName            = 33,\n+        Id_setName                 = 34,\n+        Id_setNamespace            = 35,\n+        Id_text                    = 36,\n+        Id_toString                = 37,\n+        Id_toSource                = 38,\n+        Id_toXMLString             = 39,\n+        Id_valueOf                 = 40,\n+\n+        Id_getXmlObject            = 41,\n+\n+        MAX_PROTOTYPE_ID           = 41;\n+\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2004-11-10 15:38:11 CET\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 4: c=s.charAt(0);\n+                if (c=='c') { X=\"copy\";id=Id_copy; }\n+                else if (c=='n') { X=\"name\";id=Id_name; }\n+                else if (c=='t') { X=\"text\";id=Id_text; }\n+                break L;\n+            case 5: X=\"child\";id=Id_child; break L;\n+            case 6: c=s.charAt(0);\n+                if (c=='l') { X=\"length\";id=Id_length; }\n+                else if (c=='p') { X=\"parent\";id=Id_parent; }\n+                break L;\n+            case 7: c=s.charAt(0);\n+                if (c=='r') { X=\"replace\";id=Id_replace; }\n+                else if (c=='s') { X=\"setName\";id=Id_setName; }\n+                else if (c=='v') { X=\"valueOf\";id=Id_valueOf; }\n+                break L;\n+            case 8: switch (s.charAt(4)) {\n+                case 'K': X=\"nodeKind\";id=Id_nodeKind; break L;\n+                case 'a': X=\"contains\";id=Id_contains; break L;\n+                case 'd': X=\"children\";id=Id_children; break L;\n+                case 'e': X=\"comments\";id=Id_comments; break L;\n+                case 'r': X=\"toString\";id=Id_toString; break L;\n+                case 'u': X=\"toSource\";id=Id_toSource; break L;\n+                } break L;\n+            case 9: switch (s.charAt(2)) {\n+                case 'c': X=\"localName\";id=Id_localName; break L;\n+                case 'm': X=\"namespace\";id=Id_namespace; break L;\n+                case 'r': X=\"normalize\";id=Id_normalize; break L;\n+                case 't': X=\"attribute\";id=Id_attribute; break L;\n+                } break L;\n+            case 10: c=s.charAt(0);\n+                if (c=='a') { X=\"attributes\";id=Id_attributes; }\n+                else if (c=='c') { X=\"childIndex\";id=Id_childIndex; }\n+                break L;\n+            case 11: switch (s.charAt(0)) {\n+                case 'a': X=\"appendChild\";id=Id_appendChild; break L;\n+                case 'c': X=\"constructor\";id=Id_constructor; break L;\n+                case 'd': X=\"descendants\";id=Id_descendants; break L;\n+                case 's': X=\"setChildren\";id=Id_setChildren; break L;\n+                case 't': X=\"toXMLString\";id=Id_toXMLString; break L;\n+                } break L;\n+            case 12: switch (s.charAt(0)) {\n+                case 'a': X=\"addNamespace\";id=Id_addNamespace; break L;\n+                case 'g': X=\"getXmlObject\";id=Id_getXmlObject; break L;\n+                case 'p': X=\"prependChild\";id=Id_prependChild; break L;\n+                case 's': c=s.charAt(3);\n+                    if (c=='L') { X=\"setLocalName\";id=Id_setLocalName; }\n+                    else if (c=='N') { X=\"setNamespace\";id=Id_setNamespace; }\n+                    break L;\n+                } break L;\n+            case 14: X=\"hasOwnProperty\";id=Id_hasOwnProperty; break L;\n+            case 15: X=\"removeNamespace\";id=Id_removeNamespace; break L;\n+            case 16: c=s.charAt(0);\n+                if (c=='h') { X=\"hasSimpleContent\";id=Id_hasSimpleContent; }\n+                else if (c=='i') { X=\"insertChildAfter\";id=Id_insertChildAfter; }\n+                break L;\n+            case 17: c=s.charAt(3);\n+                if (c=='C') { X=\"hasComplexContent\";id=Id_hasComplexContent; }\n+                else if (c=='c') { X=\"inScopeNamespaces\";id=Id_inScopeNamespaces; }\n+                else if (c=='e') { X=\"insertChildBefore\";id=Id_insertChildBefore; }\n+                break L;\n+            case 20: X=\"propertyIsEnumerable\";id=Id_propertyIsEnumerable; break L;\n+            case 21: X=\"namespaceDeclarations\";id=Id_namespaceDeclarations; break L;\n+            case 22: X=\"processingInstructions\";id=Id_processingInstructions; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+// #/string_id_map#\n+\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor: {\n+            IdFunctionObject ctor;\n+            if (this instanceof XML) {\n+                ctor = new XMLCtor((XML)this, XMLOBJECT_TAG, id, 1);\n+            } else {\n+                ctor = new IdFunctionObject(this, XMLOBJECT_TAG, id, 1);\n+            }\n+            initPrototypeConstructor(ctor);\n+            return;\n+          }\n+\n+          case Id_addNamespace:      arity=1; s=\"addNamespace\";      break;\n+          case Id_appendChild:       arity=1; s=\"appendChild\";       break;\n+          case Id_attribute:         arity=1; s=\"attribute\";         break;\n+          case Id_attributes:        arity=0; s=\"attributes\";        break;\n+          case Id_child:             arity=1; s=\"child\";             break;\n+          case Id_childIndex:        arity=0; s=\"childIndex\";        break;\n+          case Id_children:          arity=0; s=\"children\";          break;\n+          case Id_comments:          arity=0; s=\"comments\";          break;\n+          case Id_contains:          arity=1; s=\"contains\";          break;\n+          case Id_copy:              arity=0; s=\"copy\";              break;\n+          case Id_descendants:       arity=1; s=\"descendants\";       break;\n+          case Id_hasComplexContent: arity=0; s=\"hasComplexContent\"; break;\n+          case Id_hasOwnProperty:    arity=1; s=\"hasOwnProperty\";    break;\n+          case Id_hasSimpleContent:  arity=0; s=\"hasSimpleContent\";  break;\n+          case Id_inScopeNamespaces: arity=0; s=\"inScopeNamespaces\"; break;\n+          case Id_insertChildAfter:  arity=2; s=\"insertChildAfter\";  break;\n+          case Id_insertChildBefore: arity=2; s=\"insertChildBefore\"; break;\n+          case Id_length:            arity=0; s=\"length\";            break;\n+          case Id_localName:         arity=0; s=\"localName\";         break;\n+          case Id_name:              arity=0; s=\"name\";              break;\n+          case Id_namespace:         arity=1; s=\"namespace\";         break;\n+          case Id_namespaceDeclarations:\n+            arity=0; s=\"namespaceDeclarations\"; break;\n+          case Id_nodeKind:          arity=0; s=\"nodeKind\";          break;\n+          case Id_normalize:         arity=0; s=\"normalize\";         break;\n+          case Id_parent:            arity=0; s=\"parent\";            break;\n+          case Id_prependChild:      arity=1; s=\"prependChild\";      break;\n+          case Id_processingInstructions:\n+            arity=1; s=\"processingInstructions\"; break;\n+          case Id_propertyIsEnumerable:\n+            arity=1; s=\"propertyIsEnumerable\"; break;\n+          case Id_removeNamespace:   arity=1; s=\"removeNamespace\";   break;\n+          case Id_replace:           arity=2; s=\"replace\";           break;\n+          case Id_setChildren:       arity=1; s=\"setChildren\";       break;\n+          case Id_setLocalName:      arity=1; s=\"setLocalName\";      break;\n+          case Id_setName:           arity=1; s=\"setName\";           break;\n+          case Id_setNamespace:      arity=1; s=\"setNamespace\";      break;\n+          case Id_text:              arity=0; s=\"text\";              break;\n+          case Id_toString:          arity=0; s=\"toString\";          break;\n+          case Id_toSource:          arity=1; s=\"toSource\";          break;\n+          case Id_toXMLString:       arity=1; s=\"toXMLString\";       break;\n+          case Id_valueOf:           arity=0; s=\"valueOf\";           break;\n+\n+          case Id_getXmlObject:      arity=0; s=\"getXmlObject\";      break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(XMLOBJECT_TAG, id, s, arity);\n+    }\n+\n+    /**\n+     *\n+     * @param f\n+     * @param cx\n+     * @param scope\n+     * @param thisObj\n+     * @param args\n+     * @return\n+     */\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(XMLOBJECT_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        if (id == Id_constructor) {\n+            return jsConstructor(cx, thisObj == null, args);\n+        }\n+\n+        // All (XML|XMLList).prototype methods require thisObj to be XML\n+        if (!(thisObj instanceof XMLObjectImpl))\n+            throw incompatibleCallError(f);\n+        XMLObjectImpl realThis = (XMLObjectImpl)thisObj;\n+\n+        switch (id) {\n+          case Id_addNamespace: {\n+            Namespace ns = lib.castToNamespace(cx, arg(args, 0));\n+            return realThis.addNamespace(ns);\n+          }\n+          case Id_appendChild:\n+            return realThis.appendChild(arg(args, 0));\n+          case Id_attribute: {\n+            XMLName xmlName = lib.toAttributeName(cx, arg(args, 0));\n+            return realThis.attribute(xmlName);\n+          }\n+          case Id_attributes:\n+            return realThis.attributes();\n+          case Id_child: {\n+            XMLName xmlName = lib.toXMLNameOrIndex(cx, arg(args, 0));\n+            if (xmlName == null) {\n+                long index = ScriptRuntime.lastUint32Result(cx);\n+                return realThis.child(index);\n+            } else {\n+                return realThis.child(xmlName);\n+            }\n+          }\n+          case Id_childIndex:\n+            return ScriptRuntime.wrapInt(realThis.childIndex());\n+          case Id_children:\n+            return realThis.children();\n+          case Id_comments:\n+            return realThis.comments();\n+          case Id_contains:\n+            return ScriptRuntime.wrapBoolean(\n+                       realThis.contains(arg(args, 0)));\n+          case Id_copy:\n+            return realThis.copy();\n+          case Id_descendants: {\n+            XMLName xmlName = (args.length == 0)\n+                              ? XMLName.formStar()\n+                              : lib.toXMLName(cx, args[0]);\n+            return realThis.descendants(xmlName);\n+          }\n+          case Id_inScopeNamespaces: {\n+            Object[] array = realThis.inScopeNamespaces();\n+            return cx.newArray(scope, array);\n+          }\n+          case Id_insertChildAfter:\n+            return realThis.insertChildAfter(arg(args, 0), arg(args, 1));\n+          case Id_insertChildBefore:\n+            return realThis.insertChildBefore(arg(args, 0), arg(args, 1));\n+          case Id_hasOwnProperty: {\n+            XMLName xmlName = lib.toXMLName(cx, arg(args, 0));\n+            return ScriptRuntime.wrapBoolean(\n+                       realThis.hasOwnProperty(xmlName));\n+          }\n+          case Id_hasComplexContent:\n+            return ScriptRuntime.wrapBoolean(realThis.hasComplexContent());\n+          case Id_hasSimpleContent:\n+            return ScriptRuntime.wrapBoolean(realThis.hasSimpleContent());\n+          case Id_length:\n+            return ScriptRuntime.wrapInt(realThis.length());\n+          case Id_localName:\n+            return realThis.localName();\n+          case Id_name:\n+            return realThis.name();\n+          case Id_namespace: {\n+            String prefix = (args.length > 0)\n+                            ? ScriptRuntime.toString(args[0]) : null;\n+            return realThis.namespace(prefix);\n+          }\n+          case Id_namespaceDeclarations: {\n+            Object[] array = realThis.namespaceDeclarations();\n+            return cx.newArray(scope, array);\n+          }\n+          case Id_nodeKind:\n+            return realThis.nodeKind();\n+          case Id_normalize:\n+            realThis.normalize();\n+            return Undefined.instance;\n+          case Id_parent:\n+            return realThis.parent();\n+          case Id_prependChild:\n+            return realThis.prependChild(arg(args, 0));\n+          case Id_processingInstructions: {\n+            XMLName xmlName = (args.length > 0)\n+                              ? lib.toXMLName(cx, args[0])\n+                              : XMLName.formStar();\n+            return realThis.processingInstructions(xmlName);\n+          }\n+          case Id_propertyIsEnumerable: {\n+            return ScriptRuntime.wrapBoolean(\n+                       realThis.propertyIsEnumerable(arg(args, 0)));\n+          }\n+          case Id_removeNamespace: {\n+            Namespace ns = lib.castToNamespace(cx, arg(args, 0));\n+            return realThis.removeNamespace(ns);\n+          }\n+          case Id_replace: {\n+            XMLName xmlName = lib.toXMLNameOrIndex(cx, arg(args, 0));\n+            Object arg1 = arg(args, 1);\n+            if (xmlName == null) {\n+                long index = ScriptRuntime.lastUint32Result(cx);\n+                return realThis.replace(index, arg1);\n+            } else {\n+                return realThis.replace(xmlName, arg1);\n+            }\n+          }\n+          case Id_setChildren:\n+            return realThis.setChildren(arg(args, 0));\n+          case Id_setLocalName: {\n+            String localName;\n+            Object arg = arg(args, 0);\n+            if (arg instanceof QName) {\n+                localName = ((QName)arg).localName();\n+            } else {\n+                localName = ScriptRuntime.toString(arg);\n+            }\n+            realThis.setLocalName(localName);\n+            return Undefined.instance;\n+          }\n+          case Id_setName: {\n+            Object arg = (args.length != 0) ? args[0] : Undefined.instance;\n+            QName qname;\n+            if (arg instanceof QName) {\n+                qname = (QName)arg;\n+                if (qname.uri() == null) {\n+                    qname = lib.constructQNameFromString(cx, qname.localName());\n+                } else {\n+                    // E4X 13.4.4.35 requires to always construct QName\n+                    qname = lib.constructQName(cx, qname);\n+                }\n+            } else {\n+                qname = lib.constructQName(cx, arg);\n+            }\n+            realThis.setName(qname);\n+            return Undefined.instance;\n+          }\n+          case Id_setNamespace: {\n+            Namespace ns = lib.castToNamespace(cx, arg(args, 0));\n+            realThis.setNamespace(ns);\n+            return Undefined.instance;\n+          }\n+          case Id_text:\n+            return realThis.text();\n+          case Id_toString:\n+            return realThis.toString();\n+          case Id_toSource: {\n+            int indent = ScriptRuntime.toInt32(args, 0);\n+            return realThis.toSource(indent);\n+          }\n+          case Id_toXMLString: {\n+            int indent = ScriptRuntime.toInt32(args, 0);\n+            return realThis.toXMLString(indent);\n+          }\n+          case Id_valueOf:\n+            return realThis.valueOf();\n+\n+          case Id_getXmlObject: {\n+            org.apache.xmlbeans.XmlObject xmlObject = realThis.getXmlObject();\n+            return Context.javaToJS(xmlObject, scope);\n+          }\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private static Object arg(Object[] args, int i)\n+    {\n+        return (i < args.length) ? args[i] : Undefined.instance;\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/deprecatedsrc/org/mozilla/javascript/xml/impl/xmlbeans/XMLWithScope.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml.impl.xmlbeans;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.xml.*;\n+\n+final class XMLWithScope extends NativeWith\n+{\n+    private static final long serialVersionUID = -696429282095170887L;\n+\n+    private XMLLibImpl lib;\n+    private int         _currIndex;\n+    private XMLList     _xmlList;\n+    private XMLObject   _dqPrototype;\n+\n+    XMLWithScope(XMLLibImpl lib, Scriptable parent, XMLObject prototype)\n+    {\n+        super(parent, prototype);\n+        this.lib = lib;\n+    }\n+\n+    void initAsDotQuery()\n+    {\n+        XMLObject prototype = (XMLObject)getPrototype();\n+        // XMLWithScope also handles the .(xxx) DotQuery for XML\n+        // basically DotQuery is a for/in/with statement and in\n+        // the following 3 statements we setup to signal it's\n+        // DotQuery,\n+        // the index and the object being looped over.  The\n+        // xws.setPrototype is the scope of the object which is\n+        // is a element of the lhs (XMLList).\n+        _currIndex = 0;\n+        _dqPrototype = prototype;\n+        if (prototype instanceof XMLList) {\n+            XMLList xl = (XMLList)prototype;\n+            if (xl.length() > 0) {\n+                setPrototype((Scriptable)(xl.get(0, null)));\n+            }\n+        }\n+        // Always return the outer-most type of XML lValue of\n+        // XML to left of dotQuery.\n+        _xmlList = new XMLList(lib);\n+    }\n+\n+    protected Object updateDotQuery(boolean value)\n+    {\n+        // Return null to continue looping\n+\n+        XMLObject seed = _dqPrototype;\n+        XMLList xmlL = _xmlList;\n+\n+        if (seed instanceof XMLList) {\n+            // We're a list so keep testing each element of the list if the\n+            // result on the top of stack is true then that element is added\n+            // to our result list.  If false, we try the next element.\n+            XMLList orgXmlL = (XMLList)seed;\n+\n+            int idx = _currIndex;\n+\n+            if (value) {\n+                xmlL.addToList(orgXmlL.get(idx, null));\n+            }\n+\n+            // More elements to test?\n+            if (++idx < orgXmlL.length()) {\n+                // Yes, set our new index, get the next element and\n+                // reset the expression to run with this object as\n+                // the WITH selector.\n+                _currIndex = idx;\n+                setPrototype((Scriptable)(orgXmlL.get(idx, null)));\n+\n+                // continue looping\n+                return null;\n+            }\n+        } else {\n+            // If we're not a XMLList then there's no looping\n+            // just return DQPrototype if the result is true.\n+            if (value) {\n+              xmlL.addToList(seed);\n+            }\n+        }\n+\n+        return xmlL;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/Control.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * Example of controlling the JavaScript execution engine.\n+ *\n+ * We evaluate a script and then manipulate the result.\n+ *\n+ */\n+public class Control {\n+\n+    /**\n+     * Main entry point.\n+     *\n+     * Process arguments as would a normal Java program. Also\n+     * create a new Context and associate it with the current thread.\n+     * Then set up the execution environment and begin to\n+     * execute scripts.\n+     */\n+    public static void main(String[] args)\n+    {\n+        Context cx = Context.enter();\n+        try {\n+            // Set version to JavaScript1.2 so that we get object-literal style\n+            // printing instead of \"[object Object]\"\n+            cx.setLanguageVersion(Context.VERSION_1_2);\n+\n+            // Initialize the standard objects (Object, Function, etc.)\n+            // This must be done before scripts can be executed.\n+            Scriptable scope = cx.initStandardObjects();\n+\n+            // Now we can evaluate a script. Let's create a new object\n+            // using the object literal notation.\n+            Object result = cx.evaluateString(scope, \"obj = {a:1, b:['x','y']}\",\n+                                              \"MySource\", 1, null);\n+\n+            Scriptable obj = (Scriptable) scope.get(\"obj\", scope);\n+\n+            // Should print \"obj == result\" (Since the result of an assignment\n+            // expression is the value that was assigned)\n+            System.out.println(\"obj \" + (obj == result ? \"==\" : \"!=\") +\n+                               \" result\");\n+\n+            // Should print \"obj.a == 1\"\n+            System.out.println(\"obj.a == \" + obj.get(\"a\", obj));\n+\n+            Scriptable b = (Scriptable) obj.get(\"b\", obj);\n+\n+            // Should print \"obj.b[0] == x\"\n+            System.out.println(\"obj.b[0] == \" + b.get(0, b));\n+\n+            // Should print \"obj.b[1] == y\"\n+            System.out.println(\"obj.b[1] == \" + b.get(1, b));\n+\n+            // Should print {a:1, b:[\"x\", \"y\"]}\n+            Function fn = (Function) ScriptableObject.getProperty(obj, \"toString\");\n+            System.out.println(fn.call(cx, scope, obj, new Object[0]));\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/Counter.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+\n+public class Counter extends ScriptableObject {\n+    private static final long serialVersionUID = 438270592527335642L;\n+\n+    // The zero-argument constructor used by Rhino runtime to create instances\n+    public Counter() { }\n+\n+    // Method jsConstructor defines the JavaScript constructor\n+    public void jsConstructor(int a) { count = a; }\n+\n+    // The class name is defined by the getClassName method\n+    @Override\n+    public String getClassName() { return \"Counter\"; }\n+\n+    // The method jsGet_count defines the count property.\n+    public int jsGet_count() { return count++; }\n+\n+    // Methods can be defined using the jsFunction_ prefix. Here we define\n+    //  resetCount for JavaScript.\n+    public void jsFunction_resetCount() { count = 0; }\n+\n+    private int count;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/CounterTest.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * An example illustrating how to create a JavaScript object and retrieve\n+ * properties and call methods.\n+ * <p>\n+ * Output should be:\n+ * <pre>\n+ * count = 0\n+ * count = 1\n+ * resetCount\n+ * count = 0\n+ * </pre>\n+ */\n+public class CounterTest {\n+\n+    public static void main(String[] args) throws Exception\n+    {\n+        Context cx = Context.enter();\n+        try {\n+            Scriptable scope = cx.initStandardObjects();\n+            ScriptableObject.defineClass(scope, Counter.class);\n+\n+            Scriptable testCounter = cx.newObject(scope, \"Counter\");\n+\n+            Object count = ScriptableObject.getProperty(testCounter, \"count\");\n+            System.out.println(\"count = \" + count);\n+\n+            count = ScriptableObject.getProperty(testCounter, \"count\");\n+            System.out.println(\"count = \" + count);\n+\n+            ScriptableObject.callMethod(testCounter,\n+                                        \"resetCount\",\n+                                        new Object[0]);\n+            System.out.println(\"resetCount\");\n+\n+            count = ScriptableObject.getProperty(testCounter, \"count\");\n+            System.out.println(\"count = \" + count);\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/DynamicScopes.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * Example of controlling the JavaScript with multiple scopes and threads.\n+ */\n+public class DynamicScopes {\n+\n+    static boolean useDynamicScope;\n+\n+    static class MyFactory extends ContextFactory\n+    {\n+        @Override\n+        protected boolean hasFeature(Context cx, int featureIndex)\n+        {\n+            if (featureIndex == Context.FEATURE_DYNAMIC_SCOPE) {\n+                return useDynamicScope;\n+            }\n+            return super.hasFeature(cx, featureIndex);\n+        }\n+    }\n+\n+    static {\n+        ContextFactory.initGlobal(new MyFactory());\n+    }\n+\n+\n+    /**\n+     * Main entry point.\n+     *\n+     * Set up the shared scope and then spawn new threads that execute\n+     * relative to that shared scope. Try to run functions with and\n+     * without dynamic scope to see the effect.\n+     *\n+     * The expected output is\n+     * <pre>\n+     * sharedScope\n+     * nested:sharedScope\n+     * sharedScope\n+     * nested:sharedScope\n+     * sharedScope\n+     * nested:sharedScope\n+     * thread0\n+     * nested:thread0\n+     * thread1\n+     * nested:thread1\n+     * thread2\n+     * nested:thread2\n+     * </pre>\n+     * The final three lines may be permuted in any order depending on\n+     * thread scheduling.\n+     */\n+    public static void main(String[] args)\n+    {\n+        Context cx = Context.enter();\n+        try {\n+            // Precompile source only once\n+            String source = \"\"\n+                            +\"var x = 'sharedScope';\\n\"\n+                            +\"function f() { return x; }\\n\"\n+                            // Dynamic scope works with nested function too\n+                            +\"function initClosure(prefix) {\\n\"\n+                            +\"    return function test() { return prefix+x; }\\n\"\n+                            +\"}\\n\"\n+                            +\"var closure = initClosure('nested:');\\n\"\n+                            +\"\";\n+            Script script = cx.compileString(source, \"sharedScript\", 1, null);\n+\n+            useDynamicScope = false;\n+            runScripts(cx, script);\n+            useDynamicScope = true;\n+            runScripts(cx, script);\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+    static void runScripts(Context cx, Script script)\n+    {\n+        // Initialize the standard objects (Object, Function, etc.)\n+        // This must be done before scripts can be executed. The call\n+        // returns a new scope that we will share.\n+        ScriptableObject sharedScope = cx.initStandardObjects(null, true);\n+\n+        // Now we can execute the precompiled script against the scope\n+        // to define x variable and f function in the shared scope.\n+        script.exec(cx, sharedScope);\n+\n+        // Now we spawn some threads that execute a script that calls the\n+        // function 'f'. The scope chain looks like this:\n+        // <pre>\n+        //            ------------------                ------------------\n+        //           | per-thread scope | -prototype-> |   shared scope   |\n+        //            ------------------                ------------------\n+        //                    ^\n+        //                    |\n+        //               parentScope\n+        //                    |\n+        //            ------------------\n+        //           | f's activation   |\n+        //            ------------------\n+        // </pre>\n+        // Both the shared scope and the per-thread scope have variables 'x'\n+        // defined in them. If 'f' is compiled with dynamic scope enabled,\n+        // the 'x' from the per-thread scope will be used. Otherwise, the 'x'\n+        // from the shared scope will be used. The 'x' defined in 'g' (which\n+        // calls 'f') should not be seen by 'f'.\n+        final int threadCount = 3;\n+        Thread[] t = new Thread[threadCount];\n+        for (int i=0; i < threadCount; i++) {\n+            String source2 = \"\"\n+                +\"function g() { var x = 'local'; return f(); }\\n\"\n+                +\"java.lang.System.out.println(g());\\n\"\n+                +\"function g2() { var x = 'local'; return closure(); }\\n\"\n+                +\"java.lang.System.out.println(g2());\\n\"\n+                +\"\";\n+            t[i] = new Thread(new PerThread(sharedScope, source2,\n+                                            \"thread\" + i));\n+        }\n+        for (int i=0; i < threadCount; i++)\n+            t[i].start();\n+        // Don't return in this thread until all the spawned threads have\n+        // completed.\n+        for (int i=0; i < threadCount; i++) {\n+            try {\n+                t[i].join();\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    static class PerThread implements Runnable {\n+\n+        PerThread(Scriptable sharedScope, String source, String x) {\n+            this.sharedScope = sharedScope;\n+            this.source = source;\n+            this.x = x;\n+        }\n+\n+        public void run() {\n+            // We need a new Context for this thread.\n+            Context cx = Context.enter();\n+            try {\n+                // We can share the scope.\n+                Scriptable threadScope = cx.newObject(sharedScope);\n+                threadScope.setPrototype(sharedScope);\n+\n+                // We want \"threadScope\" to be a new top-level\n+                // scope, so set its parent scope to null. This\n+                // means that any variables created by assignments\n+                // will be properties of \"threadScope\".\n+                threadScope.setParentScope(null);\n+\n+                // Create a JavaScript property of the thread scope named\n+                // 'x' and save a value for it.\n+                threadScope.put(\"x\", threadScope, x);\n+                cx.evaluateString(threadScope, source, \"threadScript\", 1, null);\n+            } finally {\n+                Context.exit();\n+            }\n+        }\n+        private Scriptable sharedScope;\n+        private String source;\n+        private String x;\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/File.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+import java.io.*;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * Define a simple JavaScript File object.\n+ *\n+ * This isn't intended to be any sort of definitive attempt at a\n+ * standard File object for JavaScript, but instead is an example\n+ * of a more involved definition of a host object.\n+ *\n+ * Example of use of the File object:\n+ * <pre>\n+ * js> defineClass(\"File\")\n+ * js> file = new File(\"myfile.txt\");\n+ * [object File]\n+ * js> file.writeLine(\"one\");                       <i>only now is file actually opened</i>\n+ * js> file.writeLine(\"two\");\n+ * js> file.writeLine(\"thr\", \"ee\");\n+ * js> file.close();                                <i>must close file before we can reopen for reading</i>\n+ * js> var a = file.readLines();                    <i>creates and fills an array with the contents of the file</i>\n+ * js> a;\n+ * one,two,three\n+ * js>\n+ * </pre>\n+ *\n+ *\n+ * File errors or end-of-file signaled by thrown Java exceptions will\n+ * be wrapped as JavaScript exceptions when called from JavaScript,\n+ * and may be caught within JavaScript.\n+ *\n+ */\n+public class File extends ScriptableObject {\n+\n+    /**\n+     *\n+     */\n+    private static final long serialVersionUID = 2549960399774237828L;\n+    /**\n+     * The zero-parameter constructor.\n+     *\n+     * When Context.defineClass is called with this class, it will\n+     * construct File.prototype using this constructor.\n+     */\n+    public File() {\n+    }\n+\n+    /**\n+     * The Java method defining the JavaScript File constructor.\n+     *\n+     * If the constructor has one or more arguments, and the\n+     * first argument is not undefined, the argument is converted\n+     * to a string as used as the filename.<p>\n+     *\n+     * Otherwise System.in or System.out is assumed as appropriate\n+     * to the use.\n+     */\n+    public static Scriptable jsConstructor(Context cx, Object[] args,\n+                                           Function ctorObj,\n+                                           boolean inNewExpr)\n+    {\n+        File result = new File();\n+        if (args.length == 0 || args[0] == Context.getUndefinedValue()) {\n+            result.name = \"\";\n+            result.file = null;\n+        } else {\n+            result.name = Context.toString(args[0]);\n+            result.file = new java.io.File(result.name);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the name of this JavaScript class, \"File\".\n+     */\n+    @Override\n+    public String getClassName() {\n+        return \"File\";\n+    }\n+\n+    /**\n+     * Get the name of the file.\n+     *\n+     * Used to define the \"name\" property.\n+     */\n+    public String jsGet_name() {\n+        return name;\n+    }\n+\n+    /**\n+     * Read the remaining lines in the file and return them in an array.\n+     *\n+     * Implements a JavaScript function.<p>\n+     *\n+     * This is a good example of creating a new array and setting\n+     * elements in that array.\n+     *\n+     * @exception IOException if an error occurred while accessing the file\n+     *            associated with this object\n+     */\n+    public Object jsFunction_readLines()\n+        throws IOException\n+    {\n+        List<String> list = new ArrayList<String>();\n+        String s;\n+        while ((s = jsFunction_readLine()) != null) {\n+            list.add(s);\n+        }\n+        String[] lines = list.toArray(new String[list.size()]);\n+        Scriptable scope = ScriptableObject.getTopLevelScope(this);\n+        Context cx = Context.getCurrentContext();\n+        return cx.newObject(scope, \"Array\", lines);\n+    }\n+\n+    /**\n+     * Read a line.\n+     *\n+     * Implements a JavaScript function.\n+     * @exception IOException if an error occurred while accessing the file\n+     *            associated with this object, or EOFException if the object\n+     *            reached the end of the file\n+     */\n+    public String jsFunction_readLine() throws IOException {\n+        return getReader().readLine();\n+    }\n+\n+    /**\n+     * Read a character.\n+     *\n+     * @exception IOException if an error occurred while accessing the file\n+     *            associated with this object, or EOFException if the object\n+     *            reached the end of the file\n+     */\n+    public String jsFunction_readChar() throws IOException {\n+        int i = getReader().read();\n+        if (i == -1)\n+            return null;\n+        char[] charArray = { (char) i };\n+        return new String(charArray);\n+    }\n+\n+    /**\n+     * Write strings.\n+     *\n+     * Implements a JavaScript function. <p>\n+     *\n+     * This function takes a variable number of arguments, converts\n+     * each argument to a string, and writes that string to the file.\n+     * @exception IOException if an error occurred while accessing the file\n+     *            associated with this object\n+     */\n+    public static void jsFunction_write(Context cx, Scriptable thisObj,\n+                                        Object[] args, Function funObj)\n+        throws IOException\n+    {\n+        write0(thisObj, args, false);\n+    }\n+\n+    /**\n+     * Write strings and a newline.\n+     *\n+     * Implements a JavaScript function.\n+     * @exception IOException if an error occurred while accessing the file\n+     *            associated with this object\n+     *\n+     */\n+    public static void jsFunction_writeLine(Context cx, Scriptable thisObj,\n+                                            Object[] args, Function funObj)\n+        throws IOException\n+    {\n+        write0(thisObj, args, true);\n+    }\n+\n+    public int jsGet_lineNumber()\n+        throws FileNotFoundException\n+    {\n+        return getReader().getLineNumber();\n+    }\n+\n+    /**\n+     * Close the file. It may be reopened.\n+     *\n+     * Implements a JavaScript function.\n+     * @exception IOException if an error occurred while accessing the file\n+     *            associated with this object\n+     */\n+    public void jsFunction_close() throws IOException {\n+        if (reader != null) {\n+            reader.close();\n+            reader = null;\n+        } else if (writer != null) {\n+            writer.close();\n+            writer = null;\n+        }\n+    }\n+\n+    /**\n+     * Finalizer.\n+     *\n+     * Close the file when this object is collected.\n+     */\n+    @Override\n+    protected void finalize() {\n+        try {\n+            jsFunction_close();\n+        }\n+        catch (IOException e) {\n+        }\n+    }\n+\n+    /**\n+     * Get the Java reader.\n+     */\n+    public Object jsFunction_getReader() {\n+        if (reader == null)\n+            return null;\n+        // Here we use toObject() to \"wrap\" the BufferedReader object\n+        // in a Scriptable object so that it can be manipulated by\n+        // JavaScript.\n+        Scriptable parent = ScriptableObject.getTopLevelScope(this);\n+        return Context.javaToJS(reader, parent);\n+    }\n+\n+    /**\n+     * Get the Java writer.\n+     *\n+     * @see File#jsFunction_getReader\n+     *\n+     */\n+    public Object jsFunction_getWriter() {\n+        if (writer == null)\n+            return null;\n+        Scriptable parent = ScriptableObject.getTopLevelScope(this);\n+        return Context.javaToJS(writer, parent);\n+    }\n+\n+    /**\n+     * Get the reader, checking that we're not already writing this file.\n+     */\n+    private LineNumberReader getReader() throws FileNotFoundException {\n+        if (writer != null) {\n+            throw Context.reportRuntimeError(\"already writing file \\\"\"\n+                                             + name\n+                                             + \"\\\"\");\n+        }\n+        if (reader == null)\n+            reader = new LineNumberReader(file == null\n+                                        ? new InputStreamReader(System.in)\n+                                        : new FileReader(file));\n+        return reader;\n+    }\n+\n+    /**\n+     * Perform the guts of write and writeLine.\n+     *\n+     * Since the two functions differ only in whether they write a\n+     * newline character, move the code into a common subroutine.\n+     *\n+     */\n+    private static void write0(Scriptable thisObj, Object[] args, boolean eol)\n+        throws IOException\n+    {\n+        File thisFile = checkInstance(thisObj);\n+        if (thisFile.reader != null) {\n+            throw Context.reportRuntimeError(\"already writing file \\\"\"\n+                                             + thisFile.name\n+                                             + \"\\\"\");\n+        }\n+        if (thisFile.writer == null)\n+            thisFile.writer = new BufferedWriter(\n+                thisFile.file == null ? new OutputStreamWriter(System.out)\n+                                      : new FileWriter(thisFile.file));\n+        for (int i=0; i < args.length; i++) {\n+            String s = Context.toString(args[i]);\n+            thisFile.writer.write(s, 0, s.length());\n+        }\n+        if (eol)\n+            thisFile.writer.newLine();\n+    }\n+\n+    /**\n+     * Perform the instanceof check and return the downcasted File object.\n+     *\n+     * This is necessary since methods may reside in the File.prototype\n+     * object and scripts can dynamically alter prototype chains. For example:\n+     * <pre>\n+     * js> defineClass(\"File\");\n+     * js> o = {};\n+     * [object Object]\n+     * js> o.__proto__ = File.prototype;\n+     * [object File]\n+     * js> o.write(\"hi\");\n+     * js: called on incompatible object\n+     * </pre>\n+     * The runtime will take care of such checks when non-static Java methods\n+     * are defined as JavaScript functions.\n+     */\n+    private static File checkInstance(Scriptable obj) {\n+        if (obj == null || !(obj instanceof File)) {\n+            throw Context.reportRuntimeError(\"called on incompatible object\");\n+        }\n+        return (File) obj;\n+    }\n+\n+    /**\n+     * Some private data for this class.\n+     */\n+    private String name;\n+    private java.io.File file;  // may be null, meaning to use System.out or .in\n+    private LineNumberReader reader;\n+    private BufferedWriter writer;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/Foo.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * An example host object class.\n+ *\n+ * Here's a shell session showing the Foo object in action:\n+ * <pre>\n+ * js> defineClass(\"Foo\")\n+ * js> foo = new Foo();         <i>A constructor call, see <a href=\"#Foo\">Foo</a> below.</i>\n+ * [object Foo]                 <i>The \"Foo\" here comes from <a href\"#getClassName\">getClassName</a>.</i>\n+ * js> foo.counter;             <i>The counter property is defined by the <code>defineProperty</code></i>\n+ * 0                            <i>call below and implemented by the <a href=\"#getCounter\">getCounter</a></i>\n+ * js> foo.counter;             <i>method below.</i>\n+ * 1\n+ * js> foo.counter;\n+ * 2\n+ * js> foo.resetCounter();      <i>Results in a call to <a href=\"#resetCounter\">resetCounter</a>.</i>\n+ * js> foo.counter;             <i>Now the counter has been reset.</i>\n+ * 0\n+ * js> foo.counter;\n+ * 1\n+ * js> bar = new Foo(37);       <i>Create a new instance.</i>\n+ * [object Foo]\n+ * js> bar.counter;             <i>This instance's counter is distinct from</i>\n+ * 37                           <i>the other instance's counter.</i>\n+ * js> foo.varargs(3, \"hi\");    <i>Calls <a href=\"#varargs\">varargs</a>.</i>\n+ * this = [object Foo]; args = [3, hi]\n+ * js> foo[7] = 34;             <i>Since we extended ScriptableObject, we get</i>\n+ * 34                           <i>all the behavior of a JavaScript object</i>\n+ * js> foo.a = 23;              <i>for free.</i>\n+ * 23\n+ * js> foo.a + foo[7];\n+ * 57\n+ * js>\n+ * </pre>\n+ *\n+ * @see org.mozilla.javascript.Context\n+ * @see org.mozilla.javascript.Scriptable\n+ * @see org.mozilla.javascript.ScriptableObject\n+ *\n+ */\n+\n+public class Foo extends ScriptableObject {\n+    private static final long serialVersionUID = -3833489808933339159L;\n+\n+    /**\n+     * The zero-parameter constructor.\n+     *\n+     * When Context.defineClass is called with this class, it will\n+     * construct Foo.prototype using this constructor.\n+     */\n+    public Foo() {\n+    }\n+\n+    /**\n+     * The Java method defining the JavaScript Foo constructor.\n+     *\n+     * Takes an initial value for the counter property.\n+     * Note that in the example Shell session above, we didn't\n+     * supply a argument to the Foo constructor. This means that\n+     * the Undefined value is used as the value of the argument,\n+     * and when the argument is converted to an integer, Undefined\n+     * becomes 0.\n+     */\n+    public Foo(int counterStart) {\n+        counter = counterStart;\n+    }\n+\n+    /**\n+     * Returns the name of this JavaScript class, \"Foo\".\n+     */\n+    @Override\n+    public String getClassName() {\n+        return \"Foo\";\n+    }\n+\n+    /**\n+     * The Java method defining the JavaScript resetCounter function.\n+     *\n+     * Resets the counter to 0.\n+     */\n+    public void jsFunction_resetCounter() {\n+        counter = 0;\n+    }\n+\n+    /**\n+     * The Java method implementing the getter for the counter property.\n+     * <p>\n+     * If \"setCounter\" had been defined in this class, the runtime would\n+     * call the setter when the property is assigned to.\n+     */\n+    public int jsGet_counter() {\n+        return counter++;\n+    }\n+\n+    /**\n+     * An example of a variable-arguments method.\n+     *\n+     * All variable arguments methods must have the same number and\n+     * types of parameters, and must be static. <p>\n+     * @param cx the Context of the current thread\n+     * @param thisObj the JavaScript 'this' value.\n+     * @param args the array of arguments for this call\n+     * @param funObj the function object of the invoked JavaScript function\n+     *               This value is useful to compute a scope using\n+     *               Context.getTopLevelScope().\n+     * @return computes the string values and types of 'this' and\n+     * of each of the supplied arguments and returns them in a string.\n+     *\n+     * @see org.mozilla.javascript.ScriptableObject#getTopLevelScope\n+     */\n+    public static Object jsFunction_varargs(Context cx, Scriptable thisObj,\n+                                            Object[] args, Function funObj)\n+    {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"this = \");\n+        buf.append(Context.toString(thisObj));\n+        buf.append(\"; args = [\");\n+        for (int i=0; i < args.length; i++) {\n+            buf.append(Context.toString(args[i]));\n+            if (i+1 != args.length)\n+                buf.append(\", \");\n+        }\n+        buf.append(\"]\");\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * A piece of private data for this class.\n+     */\n+    private int counter;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/Matrix.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * Matrix: An example host object class that implements the Scriptable interface.\n+ *\n+ * Built-in JavaScript arrays don't handle multiple dimensions gracefully: the\n+ * script writer must create every array in an array of arrays. The Matrix class\n+ * takes care of that by automatically allocating arrays for every index that\n+ * is accessed. What's more, the Matrix constructor takes a integer argument\n+ * that specifies the dimension of the Matrix. If m is a Matrix with dimension 3,\n+ * then m[0] will be a Matrix with dimension 1, and m[0][0] will be an Array.\n+ *\n+ * Here's a shell session showing the Matrix object in action:\n+ * <pre>\n+ * js> defineClass(\"Matrix\")\n+ * js> var m = new Matrix(2); // A constructor call, see \"Matrix(int dimension)\"\n+ * js> m                      // Object.toString will call \"Matrix.getClassName()\"\n+ * [object Matrix]\n+ * js> m[0][0] = 3;\n+ * 3\n+ * js> uneval(m[0]);          // an array was created automatically!\n+ * [3]\n+ * js> uneval(m[1]);          // array is created even if we don't set a value\n+ * []\n+ * js> m.dim;                 // we can access the \"dim\" property\n+ * 2\n+ * js> m.dim = 3;\n+ * 3\n+ * js> m.dim;                 // but not modify the \"dim\" property\n+ * 2\n+ * </pre>\n+ *\n+ * @see org.mozilla.javascript.Context\n+ * @see org.mozilla.javascript.Scriptable\n+ *\n+ */\n+public class Matrix implements Scriptable {\n+\n+    /**\n+     * The zero-parameter constructor.\n+     *\n+     * When ScriptableObject.defineClass is called with this class, it will\n+     * construct Matrix.prototype using this constructor.\n+     */\n+    public Matrix() {\n+    }\n+\n+    /**\n+     * The Java constructor, also used to define the JavaScript constructor.\n+     */\n+    public Matrix(int dimension) {\n+        if (dimension <= 0) {\n+            throw Context.reportRuntimeError(\n+                  \"Dimension of Matrix must be greater than zero\");\n+        }\n+        dim = dimension;\n+        list = new ArrayList<Object>();\n+    }\n+\n+    /**\n+     * Returns the name of this JavaScript class, \"Matrix\".\n+     */\n+    public String getClassName() {\n+        return \"Matrix\";\n+    }\n+\n+    /**\n+     * Defines the \"dim\" property by returning true if name is\n+     * equal to \"dim\".\n+     * <p>\n+     * Defines no other properties, i.e., returns false for\n+     * all other names.\n+     *\n+     * @param name the name of the property\n+     * @param start the object where lookup began\n+     */\n+    public boolean has(String name, Scriptable start) {\n+        return name.equals(\"dim\");\n+    }\n+\n+    /**\n+     * Defines all numeric properties by returning true.\n+     *\n+     * @param index the index of the property\n+     * @param start the object where lookup began\n+     */\n+    public boolean has(int index, Scriptable start) {\n+        return true;\n+    }\n+\n+    /**\n+     * Get the named property.\n+     * <p>\n+     * Handles the \"dim\" property and returns NOT_FOUND for all\n+     * other names.\n+     * @param name the property name\n+     * @param start the object where the lookup began\n+     */\n+    public Object get(String name, Scriptable start) {\n+        if (name.equals(\"dim\"))\n+            return new Integer(dim);\n+\n+        return NOT_FOUND;\n+    }\n+\n+    /**\n+     * Get the indexed property.\n+     * <p>\n+     * Look up the element in the associated list and return\n+     * it if it exists. If it doesn't exist, create it.<p>\n+     * @param index the index of the integral property\n+     * @param start the object where the lookup began\n+     */\n+    public Object get(int index, Scriptable start) {\n+        while (index >= list.size()) {\n+            list.add(null);\n+        }\n+        Object result = list.get(index);\n+        if (result != null)\n+            return result;\n+        if (dim > 2) {\n+            Matrix m = new Matrix(dim-1);\n+            m.setParentScope(getParentScope());\n+            m.setPrototype(getPrototype());\n+            result = m;\n+        } else {\n+            Context cx = Context.getCurrentContext();\n+            Scriptable scope = ScriptableObject.getTopLevelScope(start);\n+            result = cx.newArray(scope, 0);\n+        }\n+        list.set(index, result);\n+        return result;\n+    }\n+\n+    /**\n+     * Set a named property.\n+     *\n+     * We do nothing here, so all properties are effectively read-only.\n+     */\n+    public void put(String name, Scriptable start, Object value) {\n+    }\n+\n+    /**\n+     * Set an indexed property.\n+     *\n+     * We do nothing here, so all properties are effectively read-only.\n+     */\n+    public void put(int index, Scriptable start, Object value) {\n+    }\n+\n+    /**\n+     * Remove a named property.\n+     *\n+     * This method shouldn't even be called since we define all properties\n+     * as PERMANENT.\n+     */\n+    public void delete(String id) {\n+    }\n+\n+    /**\n+     * Remove an indexed property.\n+     *\n+     * This method shouldn't even be called since we define all properties\n+     * as PERMANENT.\n+     */\n+    public void delete(int index) {\n+    }\n+\n+    /**\n+     * Get prototype.\n+     */\n+    public Scriptable getPrototype() {\n+        return prototype;\n+    }\n+\n+    /**\n+     * Set prototype.\n+     */\n+    public void setPrototype(Scriptable prototype) {\n+        this.prototype = prototype;\n+    }\n+\n+    /**\n+     * Get parent.\n+     */\n+    public Scriptable getParentScope() {\n+        return parent;\n+    }\n+\n+    /**\n+     * Set parent.\n+     */\n+    public void setParentScope(Scriptable parent) {\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * Get properties.\n+     *\n+     * We return an empty array since we define all properties to be DONTENUM.\n+     */\n+    public Object[] getIds() {\n+        return new Object[0];\n+    }\n+\n+    /**\n+     * Default value.\n+     *\n+     * Use the convenience method from Context that takes care of calling\n+     * toString, etc.\n+     */\n+    public Object getDefaultValue(Class<?> typeHint) {\n+        return \"[object Matrix]\";\n+    }\n+\n+    /**\n+     * instanceof operator.\n+     *\n+     * We mimick the normal JavaScript instanceof semantics, returning\n+     * true if <code>this</code> appears in <code>value</code>'s prototype\n+     * chain.\n+     */\n+    public boolean hasInstance(Scriptable value) {\n+        Scriptable proto = value.getPrototype();\n+        while (proto != null) {\n+            if (proto.equals(this))\n+                return true;\n+            proto = proto.getPrototype();\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Some private data for this class.\n+     */\n+    private int dim;\n+    private List<Object> list;\n+    private Scriptable prototype, parent;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/PrimitiveWrapFactory.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * An example WrapFactory that can be used to avoid wrapping of Java types\n+ * that can be converted to ECMA primitive values.\n+ * So java.lang.String is mapped to ECMA string, all java.lang.Numbers are\n+ * mapped to ECMA numbers, and java.lang.Booleans are mapped to ECMA booleans\n+ * instead of being wrapped as objects. Additionally java.lang.Character is\n+ * converted to ECMA string with length 1.\n+ * Other types have the default behavior.\n+ * <p>\n+ * Note that calling \"new java.lang.String('foo')\" in JavaScript with this\n+ * wrap factory enabled will still produce a wrapped Java object since the\n+ * WrapFactory.wrapNewObject method is not overridden.\n+ * <p>\n+ * The PrimitiveWrapFactory is enabled on a Context by calling setWrapFactory\n+ * on that context.\n+ */\n+public class PrimitiveWrapFactory extends WrapFactory {\n+  @Override\n+  public Object wrap(Context cx, Scriptable scope, Object obj,\n+                     Class<?> staticType)\n+  {\n+    if (obj instanceof String || obj instanceof Number ||\n+        obj instanceof Boolean)\n+    {\n+      return obj;\n+    } else if (obj instanceof Character) {\n+      char[] a = { ((Character)obj).charValue() };\n+      return new String(a);\n+    }\n+    return super.wrap(cx, scope, obj, staticType);\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/RunScript.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * RunScript: simplest example of controlling execution of Rhino.\n+ *\n+ * Collects its arguments from the command line, executes the\n+ * script, and prints the result.\n+ *\n+ */\n+public class RunScript {\n+    public static void main(String args[])\n+    {\n+        // Creates and enters a Context. The Context stores information\n+        // about the execution environment of a script.\n+        Context cx = Context.enter();\n+        try {\n+            // Initialize the standard objects (Object, Function, etc.)\n+            // This must be done before scripts can be executed. Returns\n+            // a scope object that we use in later calls.\n+            Scriptable scope = cx.initStandardObjects();\n+\n+            // Collect the arguments into a single string.\n+            String s = \"\";\n+            for (int i=0; i < args.length; i++) {\n+                s += args[i];\n+            }\n+\n+            // Now evaluate the string we've colected.\n+            Object result = cx.evaluateString(scope, s, \"<cmd>\", 1, null);\n+\n+            // Convert the result to a string and print it.\n+            System.err.println(Context.toString(result));\n+\n+        } finally {\n+            // Exit from the context.\n+            Context.exit();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/RunScript2.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * RunScript2: Like RunScript, but reflects the System.out into JavaScript.\n+ *\n+ */\n+public class RunScript2 {\n+    public static void main(String args[])\n+    {\n+        Context cx = Context.enter();\n+        try {\n+            Scriptable scope = cx.initStandardObjects();\n+\n+            // Add a global variable \"out\" that is a JavaScript reflection\n+            // of System.out\n+            Object jsOut = Context.javaToJS(System.out, scope);\n+            ScriptableObject.putProperty(scope, \"out\", jsOut);\n+\n+            String s = \"\";\n+            for (int i=0; i < args.length; i++) {\n+                s += args[i];\n+            }\n+            Object result = cx.evaluateString(scope, s, \"<cmd>\", 1, null);\n+            System.err.println(Context.toString(result));\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/RunScript3.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * RunScript3: Example of using JavaScript objects\n+ *\n+ * Collects its arguments from the command line, executes the\n+ * script, and then ...\n+ *\n+ */\n+public class RunScript3 {\n+    public static void main(String args[])\n+    {\n+        Context cx = Context.enter();\n+        try {\n+            Scriptable scope = cx.initStandardObjects();\n+\n+            // Collect the arguments into a single string.\n+            String s = \"\";\n+            for (int i=0; i < args.length; i++) {\n+                s += args[i];\n+            }\n+\n+            // Now evaluate the string we've collected. We'll ignore the result.\n+            cx.evaluateString(scope, s, \"<cmd>\", 1, null);\n+\n+            // Print the value of variable \"x\"\n+            Object x = scope.get(\"x\", scope);\n+            if (x == Scriptable.NOT_FOUND) {\n+                System.out.println(\"x is not defined.\");\n+            } else {\n+                System.out.println(\"x = \" + Context.toString(x));\n+            }\n+\n+            // Call function \"f('my arg')\" and print its result.\n+            Object fObj = scope.get(\"f\", scope);\n+            if (!(fObj instanceof Function)) {\n+                System.out.println(\"f is undefined or not a function.\");\n+            } else {\n+                Object functionArgs[] = { \"my arg\" };\n+                Function f = (Function)fObj;\n+                Object result = f.call(cx, scope, scope, functionArgs);\n+                String report = \"f('my args') = \" + Context.toString(result);\n+                System.out.println(report);\n+            }\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/RunScript4.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * RunScript4: Execute scripts in an environment that includes the\n+ *             example Counter class.\n+ *\n+ */\n+public class RunScript4 {\n+    public static void main(String args[])\n+        throws Exception\n+    {\n+        Context cx = Context.enter();\n+        try {\n+            Scriptable scope = cx.initStandardObjects();\n+\n+            // Use the Counter class to define a Counter constructor\n+            // and prototype in JavaScript.\n+            ScriptableObject.defineClass(scope, Counter.class);\n+\n+            // Create an instance of Counter and assign it to\n+            // the top-level variable \"myCounter\". This is\n+            // equivalent to the JavaScript code\n+            //    myCounter = new Counter(7);\n+            Object[] arg = { new Integer(7) };\n+            Scriptable myCounter = cx.newObject(scope, \"Counter\", arg);\n+            scope.put(\"myCounter\", scope, myCounter);\n+\n+            String s = \"\";\n+            for (int i=0; i < args.length; i++) {\n+                s += args[i];\n+            }\n+            Object result = cx.evaluateString(scope, s, \"<cmd>\", 1, null);\n+            System.err.println(Context.toString(result));\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/examples/Shell.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+import org.mozilla.javascript.*;\n+import java.io.*;\n+\n+/**\n+ * The shell program.\n+ *\n+ * Can execute scripts interactively or in batch mode at the command line.\n+ * An example of controlling the JavaScript engine.\n+ *\n+ */\n+public class Shell extends ScriptableObject\n+{\n+    private static final long serialVersionUID = -5638074146250193112L;\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"global\";\n+    }\n+\n+    /**\n+     * Main entry point.\n+     *\n+     * Process arguments as would a normal Java program. Also\n+     * create a new Context and associate it with the current thread.\n+     * Then set up the execution environment and begin to\n+     * execute scripts.\n+     */\n+    public static void main(String args[]) {\n+        // Associate a new Context with this thread\n+        Context cx = Context.enter();\n+        try {\n+            // Initialize the standard objects (Object, Function, etc.)\n+            // This must be done before scripts can be executed.\n+            Shell shell = new Shell();\n+            cx.initStandardObjects(shell);\n+\n+            // Define some global functions particular to the shell. Note\n+            // that these functions are not part of ECMA.\n+            String[] names = { \"print\", \"quit\", \"version\", \"load\", \"help\" };\n+            shell.defineFunctionProperties(names, Shell.class,\n+                                           ScriptableObject.DONTENUM);\n+\n+            args = processOptions(cx, args);\n+\n+            // Set up \"arguments\" in the global scope to contain the command\n+            // line arguments after the name of the script to execute\n+            Object[] array;\n+            if (args.length == 0) {\n+                array = new Object[0];\n+            } else {\n+                int length = args.length - 1;\n+                array = new Object[length];\n+                System.arraycopy(args, 1, array, 0, length);\n+            }\n+            Scriptable argsObj = cx.newArray(shell, array);\n+            shell.defineProperty(\"arguments\", argsObj,\n+                                 ScriptableObject.DONTENUM);\n+\n+            shell.processSource(cx, args.length == 0 ? null : args[0]);\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+    /**\n+     * Parse arguments.\n+     */\n+    public static String[] processOptions(Context cx, String args[]) {\n+        for (int i=0; i < args.length; i++) {\n+            String arg = args[i];\n+            if (!arg.startsWith(\"-\")) {\n+                String[] result = new String[args.length - i];\n+                for (int j=i; j < args.length; j++)\n+                    result[j-i] = args[j];\n+                return result;\n+            }\n+            if (arg.equals(\"-version\")) {\n+                if (++i == args.length)\n+                    usage(arg);\n+                double d = Context.toNumber(args[i]);\n+                if (d != d)\n+                    usage(arg);\n+                cx.setLanguageVersion((int) d);\n+                continue;\n+            }\n+            usage(arg);\n+        }\n+        return new String[0];\n+    }\n+\n+    /**\n+     * Print a usage message.\n+     */\n+    private static void usage(String s) {\n+        p(\"Didn't understand \\\"\" + s + \"\\\".\");\n+        p(\"Valid arguments are:\");\n+        p(\"-version 100|110|120|130|140|150|160|170\");\n+        System.exit(1);\n+    }\n+\n+    /**\n+     * Print a help message.\n+     *\n+     * This method is defined as a JavaScript function.\n+     */\n+    public void help() {\n+        p(\"\");\n+        p(\"Command                Description\");\n+        p(\"=======                ===========\");\n+        p(\"help()                 Display usage and help messages. \");\n+        p(\"defineClass(className) Define an extension using the Java class\");\n+        p(\"                       named with the string argument. \");\n+        p(\"                       Uses ScriptableObject.defineClass(). \");\n+        p(\"load(['foo.js', ...])  Load JavaScript source files named by \");\n+        p(\"                       string arguments. \");\n+        p(\"loadClass(className)   Load a class named by a string argument.\");\n+        p(\"                       The class must be a script compiled to a\");\n+        p(\"                       class file. \");\n+        p(\"print([expr ...])      Evaluate and print expressions. \");\n+        p(\"quit()                 Quit the shell. \");\n+        p(\"version([number])      Get or set the JavaScript version number.\");\n+        p(\"\");\n+    }\n+\n+    /**\n+     * Print the string values of its arguments.\n+     *\n+     * This method is defined as a JavaScript function.\n+     * Note that its arguments are of the \"varargs\" form, which\n+     * allows it to handle an arbitrary number of arguments\n+     * supplied to the JavaScript function.\n+     *\n+     */\n+    public static void print(Context cx, Scriptable thisObj,\n+                             Object[] args, Function funObj)\n+    {\n+        for (int i=0; i < args.length; i++) {\n+            if (i > 0)\n+                System.out.print(\" \");\n+\n+            // Convert the arbitrary JavaScript value into a string form.\n+            String s = Context.toString(args[i]);\n+\n+            System.out.print(s);\n+        }\n+        System.out.println();\n+    }\n+\n+    /**\n+     * Quit the shell.\n+     *\n+     * This only affects the interactive mode.\n+     *\n+     * This method is defined as a JavaScript function.\n+     */\n+    public void quit()\n+    {\n+        quitting = true;\n+    }\n+\n+    /**\n+     * Get and set the language version.\n+     *\n+     * This method is defined as a JavaScript function.\n+     */\n+    public static double version(Context cx, Scriptable thisObj,\n+                                 Object[] args, Function funObj)\n+    {\n+        double result = cx.getLanguageVersion();\n+        if (args.length > 0) {\n+            double d = Context.toNumber(args[0]);\n+            cx.setLanguageVersion((int) d);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Load and execute a set of JavaScript source files.\n+     *\n+     * This method is defined as a JavaScript function.\n+     *\n+     */\n+    public static void load(Context cx, Scriptable thisObj,\n+                            Object[] args, Function funObj)\n+    {\n+        Shell shell = (Shell)getTopLevelScope(thisObj);\n+        for (int i = 0; i < args.length; i++) {\n+            shell.processSource(cx, Context.toString(args[i]));\n+        }\n+    }\n+\n+\n+    /**\n+     * Evaluate JavaScript source.\n+     *\n+     * @param cx the current context\n+     * @param filename the name of the file to compile, or null\n+     *                 for interactive mode.\n+     */\n+    private void processSource(Context cx, String filename)\n+    {\n+        if (filename == null) {\n+            BufferedReader in = new BufferedReader\n+                (new InputStreamReader(System.in));\n+            String sourceName = \"<stdin>\";\n+            int lineno = 1;\n+            boolean hitEOF = false;\n+            do {\n+                int startline = lineno;\n+                System.err.print(\"js> \");\n+                System.err.flush();\n+                try {\n+                    String source = \"\";\n+                    // Collect lines of source to compile.\n+                    while(true) {\n+                        String newline;\n+                        newline = in.readLine();\n+                        if (newline == null) {\n+                            hitEOF = true;\n+                            break;\n+                        }\n+                        source = source + newline + \"\\n\";\n+                        lineno++;\n+                        // Continue collecting as long as more lines\n+                        // are needed to complete the current\n+                        // statement.  stringIsCompilableUnit is also\n+                        // true if the source statement will result in\n+                        // any error other than one that might be\n+                        // resolved by appending more source.\n+                        if (cx.stringIsCompilableUnit(source))\n+                            break;\n+                    }\n+                    Object result = cx.evaluateString(this, source,\n+                                                      sourceName, startline,\n+                                                      null);\n+                    if (result != Context.getUndefinedValue()) {\n+                        System.err.println(Context.toString(result));\n+                    }\n+                }\n+                catch (WrappedException we) {\n+                    // Some form of exception was caught by JavaScript and\n+                    // propagated up.\n+                    System.err.println(we.getWrappedException().toString());\n+                    we.printStackTrace();\n+                }\n+                catch (EvaluatorException ee) {\n+                    // Some form of JavaScript error.\n+                    System.err.println(\"js: \" + ee.getMessage());\n+                }\n+                catch (JavaScriptException jse) {\n+                    // Some form of JavaScript error.\n+                    System.err.println(\"js: \" + jse.getMessage());\n+                }\n+                catch (IOException ioe) {\n+                    System.err.println(ioe.toString());\n+                }\n+                if (quitting) {\n+                    // The user executed the quit() function.\n+                    break;\n+                }\n+            } while (!hitEOF);\n+            System.err.println();\n+        } else {\n+            FileReader in = null;\n+            try {\n+                in = new FileReader(filename);\n+            }\n+            catch (FileNotFoundException ex) {\n+                Context.reportError(\"Couldn't open file \\\"\" + filename + \"\\\".\");\n+                return;\n+            }\n+\n+            try {\n+                // Here we evalute the entire contents of the file as\n+                // a script. Text is printed only if the print() function\n+                // is called.\n+                cx.evaluateReader(this, in, filename, 1, null);\n+            }\n+            catch (WrappedException we) {\n+                System.err.println(we.getWrappedException().toString());\n+                we.printStackTrace();\n+            }\n+            catch (EvaluatorException ee) {\n+                System.err.println(\"js: \" + ee.getMessage());\n+            }\n+            catch (JavaScriptException jse) {\n+                System.err.println(\"js: \" + jse.getMessage());\n+            }\n+            catch (IOException ioe) {\n+                System.err.println(ioe.toString());\n+            }\n+            finally {\n+                try {\n+                    in.close();\n+                }\n+                catch (IOException ioe) {\n+                    System.err.println(ioe.toString());\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void p(String s) {\n+        System.out.println(s);\n+    }\n+\n+    private boolean quitting;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/classfile/ByteCode.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.classfile;\n+\n+/**\n+ * This class provides opcode values expected by the JVM in Java class files.\n+ *\n+ * It also provides tables for internal use by the ClassFileWriter.\n+ *\n+ */\n+public class ByteCode {\n+\n+    /**\n+     * The byte opcodes defined by the Java Virtual Machine.\n+     */\n+    public static final int\n+        NOP = 0x00,\n+        ACONST_NULL = 0x01,\n+        ICONST_M1 = 0x02,\n+        ICONST_0 = 0x03,\n+        ICONST_1 = 0x04,\n+        ICONST_2 = 0x05,\n+        ICONST_3 = 0x06,\n+        ICONST_4 = 0x07,\n+        ICONST_5 = 0x08,\n+        LCONST_0 = 0x09,\n+        LCONST_1 = 0x0A,\n+        FCONST_0 = 0x0B,\n+        FCONST_1 = 0x0C,\n+        FCONST_2 = 0x0D,\n+        DCONST_0 = 0x0E,\n+        DCONST_1 = 0x0F,\n+        BIPUSH = 0x10,\n+        SIPUSH = 0x11,\n+        LDC = 0x12,\n+        LDC_W = 0x13,\n+        LDC2_W = 0x14,\n+        ILOAD = 0x15,\n+        LLOAD = 0x16,\n+        FLOAD = 0x17,\n+        DLOAD = 0x18,\n+        ALOAD = 0x19,\n+        ILOAD_0 = 0x1A,\n+        ILOAD_1 = 0x1B,\n+        ILOAD_2 = 0x1C,\n+        ILOAD_3 = 0x1D,\n+        LLOAD_0 = 0x1E,\n+        LLOAD_1 = 0x1F,\n+        LLOAD_2 = 0x20,\n+        LLOAD_3 = 0x21,\n+        FLOAD_0 = 0x22,\n+        FLOAD_1 = 0x23,\n+        FLOAD_2 = 0x24,\n+        FLOAD_3 = 0x25,\n+        DLOAD_0 = 0x26,\n+        DLOAD_1 = 0x27,\n+        DLOAD_2 = 0x28,\n+        DLOAD_3 = 0x29,\n+        ALOAD_0 = 0x2A,\n+        ALOAD_1 = 0x2B,\n+        ALOAD_2 = 0x2C,\n+        ALOAD_3 = 0x2D,\n+        IALOAD = 0x2E,\n+        LALOAD = 0x2F,\n+        FALOAD = 0x30,\n+        DALOAD = 0x31,\n+        AALOAD = 0x32,\n+        BALOAD = 0x33,\n+        CALOAD = 0x34,\n+        SALOAD = 0x35,\n+        ISTORE = 0x36,\n+        LSTORE = 0x37,\n+        FSTORE = 0x38,\n+        DSTORE = 0x39,\n+        ASTORE = 0x3A,\n+        ISTORE_0 = 0x3B,\n+        ISTORE_1 = 0x3C,\n+        ISTORE_2 = 0x3D,\n+        ISTORE_3 = 0x3E,\n+        LSTORE_0 = 0x3F,\n+        LSTORE_1 = 0x40,\n+        LSTORE_2 = 0x41,\n+        LSTORE_3 = 0x42,\n+        FSTORE_0 = 0x43,\n+        FSTORE_1 = 0x44,\n+        FSTORE_2 = 0x45,\n+        FSTORE_3 = 0x46,\n+        DSTORE_0 = 0x47,\n+        DSTORE_1 = 0x48,\n+        DSTORE_2 = 0x49,\n+        DSTORE_3 = 0x4A,\n+        ASTORE_0 = 0x4B,\n+        ASTORE_1 = 0x4C,\n+        ASTORE_2 = 0x4D,\n+        ASTORE_3 = 0x4E,\n+        IASTORE = 0x4F,\n+        LASTORE = 0x50,\n+        FASTORE = 0x51,\n+        DASTORE = 0x52,\n+        AASTORE = 0x53,\n+        BASTORE = 0x54,\n+        CASTORE = 0x55,\n+        SASTORE = 0x56,\n+        POP = 0x57,\n+        POP2 = 0x58,\n+        DUP = 0x59,\n+        DUP_X1 = 0x5A,\n+        DUP_X2 = 0x5B,\n+        DUP2 = 0x5C,\n+        DUP2_X1 = 0x5D,\n+        DUP2_X2 = 0x5E,\n+        SWAP = 0x5F,\n+        IADD = 0x60,\n+        LADD = 0x61,\n+        FADD = 0x62,\n+        DADD = 0x63,\n+        ISUB = 0x64,\n+        LSUB = 0x65,\n+        FSUB = 0x66,\n+        DSUB = 0x67,\n+        IMUL = 0x68,\n+        LMUL = 0x69,\n+        FMUL = 0x6A,\n+        DMUL = 0x6B,\n+        IDIV = 0x6C,\n+        LDIV = 0x6D,\n+        FDIV = 0x6E,\n+        DDIV = 0x6F,\n+        IREM = 0x70,\n+        LREM = 0x71,\n+        FREM = 0x72,\n+        DREM = 0x73,\n+        INEG = 0x74,\n+        LNEG = 0x75,\n+        FNEG = 0x76,\n+        DNEG = 0x77,\n+        ISHL = 0x78,\n+        LSHL = 0x79,\n+        ISHR = 0x7A,\n+        LSHR = 0x7B,\n+        IUSHR = 0x7C,\n+        LUSHR = 0x7D,\n+        IAND = 0x7E,\n+        LAND = 0x7F,\n+        IOR = 0x80,\n+        LOR = 0x81,\n+        IXOR = 0x82,\n+        LXOR = 0x83,\n+        IINC = 0x84,\n+        I2L = 0x85,\n+        I2F = 0x86,\n+        I2D = 0x87,\n+        L2I = 0x88,\n+        L2F = 0x89,\n+        L2D = 0x8A,\n+        F2I = 0x8B,\n+        F2L = 0x8C,\n+        F2D = 0x8D,\n+        D2I = 0x8E,\n+        D2L = 0x8F,\n+        D2F = 0x90,\n+        I2B = 0x91,\n+        I2C = 0x92,\n+        I2S = 0x93,\n+        LCMP = 0x94,\n+        FCMPL = 0x95,\n+        FCMPG = 0x96,\n+        DCMPL = 0x97,\n+        DCMPG = 0x98,\n+        IFEQ = 0x99,\n+        IFNE = 0x9A,\n+        IFLT = 0x9B,\n+        IFGE = 0x9C,\n+        IFGT = 0x9D,\n+        IFLE = 0x9E,\n+        IF_ICMPEQ = 0x9F,\n+        IF_ICMPNE = 0xA0,\n+        IF_ICMPLT = 0xA1,\n+        IF_ICMPGE = 0xA2,\n+        IF_ICMPGT = 0xA3,\n+        IF_ICMPLE = 0xA4,\n+        IF_ACMPEQ = 0xA5,\n+        IF_ACMPNE = 0xA6,\n+        GOTO = 0xA7,\n+        JSR = 0xA8,\n+        RET = 0xA9,\n+        TABLESWITCH = 0xAA,\n+        LOOKUPSWITCH = 0xAB,\n+        IRETURN = 0xAC,\n+        LRETURN = 0xAD,\n+        FRETURN = 0xAE,\n+        DRETURN = 0xAF,\n+        ARETURN = 0xB0,\n+        RETURN = 0xB1,\n+        GETSTATIC = 0xB2,\n+        PUTSTATIC = 0xB3,\n+        GETFIELD = 0xB4,\n+        PUTFIELD = 0xB5,\n+        INVOKEVIRTUAL = 0xB6,\n+        INVOKESPECIAL = 0xB7,\n+        INVOKESTATIC = 0xB8,\n+        INVOKEINTERFACE = 0xB9,\n+        NEW = 0xBB,\n+        NEWARRAY = 0xBC,\n+        ANEWARRAY = 0xBD,\n+        ARRAYLENGTH = 0xBE,\n+        ATHROW = 0xBF,\n+        CHECKCAST = 0xC0,\n+        INSTANCEOF = 0xC1,\n+        MONITORENTER = 0xC2,\n+        MONITOREXIT = 0xC3,\n+        WIDE = 0xC4,\n+        MULTIANEWARRAY = 0xC5,\n+        IFNULL = 0xC6,\n+        IFNONNULL = 0xC7,\n+        GOTO_W = 0xC8,\n+        JSR_W = 0xC9,\n+        BREAKPOINT = 0xCA,\n+\n+        IMPDEP1 = 0xFE,\n+        IMPDEP2 = 0xFF;\n+\n+        /**\n+         * Types for the NEWARRAY opcode.\n+         */\n+        public static final byte\n+            T_BOOLEAN = 4,\n+            T_CHAR = 5,\n+            T_FLOAT = 6,\n+            T_DOUBLE = 7,\n+            T_BYTE = 8,\n+            T_SHORT = 9,\n+            T_INT = 10,\n+            T_LONG = 11;\n+\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/classfile/ClassFileWriter.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.classfile;\n+\n+import org.mozilla.javascript.ObjToIntMap;\n+import org.mozilla.javascript.ObjArray;\n+import org.mozilla.javascript.UintMap;\n+\n+import java.io.*;\n+\n+/**\n+ * ClassFileWriter\n+ *\n+ * A ClassFileWriter is used to write a Java class file. Methods are\n+ * provided to create fields and methods, and within methods to write\n+ * Java bytecodes.\n+ *\n+ */\n+public class ClassFileWriter {\n+\n+    /**\n+     * Thrown for cases where the error in generating the class file is\n+     * due to a program size constraints rather than a likely bug in the\n+     * compiler.\n+     */\n+    public static class ClassFileFormatException extends RuntimeException {\n+\n+        private static final long serialVersionUID = 1263998431033790599L;\n+\n+        ClassFileFormatException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    /**\n+     * Construct a ClassFileWriter for a class.\n+     *\n+     * @param className the name of the class to write, including\n+     *        full package qualification.\n+     * @param superClassName the name of the superclass of the class\n+     *        to write, including full package qualification.\n+     * @param sourceFileName the name of the source file to use for\n+     *        producing debug information, or null if debug information\n+     *        is not desired\n+     */\n+    public ClassFileWriter(String className, String superClassName,\n+                           String sourceFileName)\n+    {\n+        generatedClassName = className;\n+        itsConstantPool = new ConstantPool(this);\n+        itsThisClassIndex = itsConstantPool.addClass(className);\n+        itsSuperClassIndex = itsConstantPool.addClass(superClassName);\n+        if (sourceFileName != null)\n+            itsSourceFileNameIndex = itsConstantPool.addUtf8(sourceFileName);\n+        itsFlags = ACC_PUBLIC;\n+    }\n+\n+    public final String getClassName()\n+    {\n+        return generatedClassName;\n+    }\n+\n+    /**\n+     * Add an interface implemented by this class.\n+     *\n+     * This method may be called multiple times for classes that\n+     * implement multiple interfaces.\n+     *\n+     * @param interfaceName a name of an interface implemented\n+     *        by the class being written, including full package\n+     *        qualification.\n+     */\n+    public void addInterface(String interfaceName) {\n+        short interfaceIndex = itsConstantPool.addClass(interfaceName);\n+        itsInterfaces.add(Short.valueOf(interfaceIndex));\n+    }\n+\n+    public static final short\n+        ACC_PUBLIC = 0x0001,\n+        ACC_PRIVATE = 0x0002,\n+        ACC_PROTECTED = 0x0004,\n+        ACC_STATIC = 0x0008,\n+        ACC_FINAL = 0x0010,\n+        ACC_SYNCHRONIZED = 0x0020,\n+        ACC_VOLATILE = 0x0040,\n+        ACC_TRANSIENT = 0x0080,\n+        ACC_NATIVE = 0x0100,\n+        ACC_ABSTRACT = 0x0400;\n+\n+    /**\n+     * Set the class's flags.\n+     *\n+     * Flags must be a set of the following flags, bitwise or'd\n+     * together:\n+     *      ACC_PUBLIC\n+     *      ACC_PRIVATE\n+     *      ACC_PROTECTED\n+     *      ACC_FINAL\n+     *      ACC_ABSTRACT\n+     * TODO: check that this is the appropriate set\n+     * @param flags the set of class flags to set\n+     */\n+    public void setFlags(short flags) {\n+        itsFlags = flags;\n+    }\n+\n+    static String getSlashedForm(String name)\n+    {\n+        return name.replace('.', '/');\n+    }\n+\n+    /**\n+     * Convert Java class name in dot notation into\n+     * \"Lname-with-dots-replaced-by-slashes;\" form suitable for use as\n+     * JVM type signatures.\n+     */\n+    public static String classNameToSignature(String name)\n+    {\n+        int nameLength = name.length();\n+        int colonPos = 1 + nameLength;\n+        char[] buf = new char[colonPos + 1];\n+        buf[0] = 'L';\n+        buf[colonPos] = ';';\n+        name.getChars(0, nameLength, buf, 1);\n+        for (int i = 1; i != colonPos; ++i) {\n+            if (buf[i] == '.') {\n+                buf[i] = '/';\n+            }\n+        }\n+        return new String(buf, 0, colonPos + 1);\n+    }\n+\n+    /**\n+     * Add a field to the class.\n+     *\n+     * @param fieldName the name of the field\n+     * @param type the type of the field using ...\n+     * @param flags the attributes of the field, such as ACC_PUBLIC, etc.\n+     *        bitwise or'd together\n+     */\n+    public void addField(String fieldName, String type, short flags) {\n+        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);\n+        short typeIndex = itsConstantPool.addUtf8(type);\n+        itsFields.add(new ClassFileField(fieldNameIndex, typeIndex, flags));\n+    }\n+\n+    /**\n+     * Add a field to the class.\n+     *\n+     * @param fieldName the name of the field\n+     * @param type the type of the field using ...\n+     * @param flags the attributes of the field, such as ACC_PUBLIC, etc.\n+     *        bitwise or'd together\n+     * @param value an initial integral value\n+     */\n+    public void addField(String fieldName, String type, short flags,\n+                         int value)\n+    {\n+        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);\n+        short typeIndex = itsConstantPool.addUtf8(type);\n+        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,\n+                                                  flags);\n+        field.setAttributes(itsConstantPool.addUtf8(\"ConstantValue\"),\n+                            (short)0,\n+                            (short)0,\n+                            itsConstantPool.addConstant(value));\n+        itsFields.add(field);\n+    }\n+\n+    /**\n+     * Add a field to the class.\n+     *\n+     * @param fieldName the name of the field\n+     * @param type the type of the field using ...\n+     * @param flags the attributes of the field, such as ACC_PUBLIC, etc.\n+     *        bitwise or'd together\n+     * @param value an initial long value\n+     */\n+    public void addField(String fieldName, String type, short flags,\n+                         long value)\n+    {\n+        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);\n+        short typeIndex = itsConstantPool.addUtf8(type);\n+        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,\n+                                                  flags);\n+        field.setAttributes(itsConstantPool.addUtf8(\"ConstantValue\"),\n+                            (short)0,\n+                            (short)2,\n+                            itsConstantPool.addConstant(value));\n+        itsFields.add(field);\n+    }\n+\n+    /**\n+     * Add a field to the class.\n+     *\n+     * @param fieldName the name of the field\n+     * @param type the type of the field using ...\n+     * @param flags the attributes of the field, such as ACC_PUBLIC, etc.\n+     *        bitwise or'd together\n+     * @param value an initial double value\n+     */\n+    public void addField(String fieldName, String type, short flags,\n+                         double value)\n+    {\n+        short fieldNameIndex = itsConstantPool.addUtf8(fieldName);\n+        short typeIndex = itsConstantPool.addUtf8(type);\n+        ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex,\n+                                                  flags);\n+        field.setAttributes(itsConstantPool.addUtf8(\"ConstantValue\"),\n+                            (short)0,\n+                            (short)2,\n+                            itsConstantPool.addConstant(value));\n+        itsFields.add(field);\n+    }\n+\n+    /**\n+     * Add Information about java variable to use when generating the local\n+     * variable table.\n+     *\n+     * @param name variable name.\n+     * @param type variable type as bytecode descriptor string.\n+     * @param startPC the starting bytecode PC where this variable is live,\n+     *                 or -1 if it does not have a Java register.\n+     * @param register the Java register number of variable\n+     *                 or -1 if it does not have a Java register.\n+     */\n+    public void addVariableDescriptor(String name, String type, int startPC, int register)\n+    {\n+        int nameIndex = itsConstantPool.addUtf8(name);\n+        int descriptorIndex = itsConstantPool.addUtf8(type);\n+        int [] chunk = { nameIndex, descriptorIndex, startPC, register };\n+        if (itsVarDescriptors == null) {\n+            itsVarDescriptors = new ObjArray();\n+        }\n+        itsVarDescriptors.add(chunk);\n+    }\n+\n+    /**\n+     * Add a method and begin adding code.\n+     *\n+     * This method must be called before other methods for adding code,\n+     * exception tables, etc. can be invoked.\n+     *\n+     * @param methodName the name of the method\n+     * @param type a string representing the type\n+     * @param flags the attributes of the field, such as ACC_PUBLIC, etc.\n+     *        bitwise or'd together\n+     */\n+    public void startMethod(String methodName, String type, short flags) {\n+        short methodNameIndex = itsConstantPool.addUtf8(methodName);\n+        short typeIndex = itsConstantPool.addUtf8(type);\n+        itsCurrentMethod = new ClassFileMethod(methodNameIndex, typeIndex,\n+                                               flags);\n+        itsMethods.add(itsCurrentMethod);\n+    }\n+\n+    /**\n+     * Complete generation of the method.\n+     *\n+     * After this method is called, no more code can be added to the\n+     * method begun with <code>startMethod</code>.\n+     *\n+     * @param maxLocals the maximum number of local variable slots\n+     *        (a.k.a. Java registers) used by the method\n+     */\n+    public void stopMethod(short maxLocals) {\n+        if (itsCurrentMethod == null)\n+            throw new IllegalStateException(\"No method to stop\");\n+\n+        fixLabelGotos();\n+\n+        itsMaxLocals = maxLocals;\n+\n+        int lineNumberTableLength = 0;\n+        if (itsLineNumberTable != null) {\n+            // 6 bytes for the attribute header\n+            // 2 bytes for the line number count\n+            // 4 bytes for each entry\n+            lineNumberTableLength = 6 + 2 + (itsLineNumberTableTop * 4);\n+        }\n+\n+        int variableTableLength = 0;\n+        if (itsVarDescriptors != null) {\n+            // 6 bytes for the attribute header\n+            // 2 bytes for the variable count\n+            // 10 bytes for each entry\n+            variableTableLength = 6 + 2 + (itsVarDescriptors.size() * 10);\n+        }\n+\n+        int attrLength = 2 +                    // attribute_name_index\n+                         4 +                    // attribute_length\n+                         2 +                    // max_stack\n+                         2 +                    // max_locals\n+                         4 +                    // code_length\n+                         itsCodeBufferTop +\n+                         2 +                    // exception_table_length\n+                         (itsExceptionTableTop * 8) +\n+                         2 +                    // attributes_count\n+                         lineNumberTableLength +\n+                         variableTableLength;\n+\n+        if (attrLength > 65536) {\n+            // See http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html,\n+            // section 4.10, \"The amount of code per non-native, non-abstract\n+            // method is limited to 65536 bytes...\n+            throw new ClassFileFormatException(\n+                \"generated bytecode for method exceeds 64K limit.\");\n+        }\n+        byte[] codeAttribute = new byte[attrLength];\n+        int index = 0;\n+        int codeAttrIndex = itsConstantPool.addUtf8(\"Code\");\n+        index = putInt16(codeAttrIndex, codeAttribute, index);\n+        attrLength -= 6;                 // discount the attribute header\n+        index = putInt32(attrLength, codeAttribute, index);\n+        index = putInt16(itsMaxStack, codeAttribute, index);\n+        index = putInt16(itsMaxLocals, codeAttribute, index);\n+        index = putInt32(itsCodeBufferTop, codeAttribute, index);\n+        System.arraycopy(itsCodeBuffer, 0, codeAttribute, index,\n+                         itsCodeBufferTop);\n+        index += itsCodeBufferTop;\n+\n+        if (itsExceptionTableTop > 0) {\n+            index = putInt16(itsExceptionTableTop, codeAttribute, index);\n+            for (int i = 0; i < itsExceptionTableTop; i++) {\n+                ExceptionTableEntry ete = itsExceptionTable[i];\n+                short startPC = (short)getLabelPC(ete.itsStartLabel);\n+                short endPC = (short)getLabelPC(ete.itsEndLabel);\n+                short handlerPC = (short)getLabelPC(ete.itsHandlerLabel);\n+                short catchType = ete.itsCatchType;\n+                if (startPC == -1)\n+                    throw new IllegalStateException(\"start label not defined\");\n+                if (endPC == -1)\n+                    throw new IllegalStateException(\"end label not defined\");\n+                if (handlerPC == -1)\n+                    throw new IllegalStateException(\n+                        \"handler label not defined\");\n+\n+                index = putInt16(startPC, codeAttribute, index);\n+                index = putInt16(endPC, codeAttribute, index);\n+                index = putInt16(handlerPC, codeAttribute, index);\n+                index = putInt16(catchType, codeAttribute, index);\n+            }\n+        }\n+        else {\n+            // write 0 as exception table length\n+            index = putInt16(0, codeAttribute, index);\n+        }\n+\n+        int attributeCount = 0;\n+        if (itsLineNumberTable != null)\n+            attributeCount++;\n+        if (itsVarDescriptors != null)\n+            attributeCount++;\n+        index = putInt16(attributeCount, codeAttribute, index);\n+\n+        if (itsLineNumberTable != null) {\n+            int lineNumberTableAttrIndex\n+                    = itsConstantPool.addUtf8(\"LineNumberTable\");\n+            index = putInt16(lineNumberTableAttrIndex, codeAttribute, index);\n+            int tableAttrLength = 2 + (itsLineNumberTableTop * 4);\n+            index = putInt32(tableAttrLength, codeAttribute, index);\n+            index = putInt16(itsLineNumberTableTop, codeAttribute, index);\n+            for (int i = 0; i < itsLineNumberTableTop; i++) {\n+                index = putInt32(itsLineNumberTable[i], codeAttribute, index);\n+            }\n+        }\n+\n+        if (itsVarDescriptors != null) {\n+            int variableTableAttrIndex\n+                    = itsConstantPool.addUtf8(\"LocalVariableTable\");\n+            index = putInt16(variableTableAttrIndex, codeAttribute, index);\n+            int varCount = itsVarDescriptors.size();\n+            int tableAttrLength = 2 + (varCount * 10);\n+            index = putInt32(tableAttrLength, codeAttribute, index);\n+            index = putInt16(varCount, codeAttribute, index);\n+            for (int i = 0; i < varCount; i++) {\n+                int[] chunk = (int[])itsVarDescriptors.get(i);\n+                int nameIndex       = chunk[0];\n+                int descriptorIndex = chunk[1];\n+                int startPC         = chunk[2];\n+                int register        = chunk[3];\n+                int length = itsCodeBufferTop - startPC;\n+\n+                index = putInt16(startPC, codeAttribute, index);\n+                index = putInt16(length, codeAttribute, index);\n+                index = putInt16(nameIndex, codeAttribute, index);\n+                index = putInt16(descriptorIndex, codeAttribute, index);\n+                index = putInt16(register, codeAttribute, index);\n+            }\n+        }\n+\n+        itsCurrentMethod.setCodeAttribute(codeAttribute);\n+\n+        itsExceptionTable = null;\n+        itsExceptionTableTop = 0;\n+        itsLineNumberTableTop = 0;\n+        itsCodeBufferTop = 0;\n+        itsCurrentMethod = null;\n+        itsMaxStack = 0;\n+        itsStackTop = 0;\n+        itsLabelTableTop = 0;\n+        itsFixupTableTop = 0;\n+        itsVarDescriptors = null;\n+    }\n+\n+    /**\n+     * Add the single-byte opcode to the current method.\n+     *\n+     * @param theOpCode the opcode of the bytecode\n+     */\n+    public void add(int theOpCode) {\n+        if (opcodeCount(theOpCode) != 0)\n+            throw new IllegalArgumentException(\"Unexpected operands\");\n+        int newStack = itsStackTop + stackChange(theOpCode);\n+        if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);\n+        if (DEBUGCODE)\n+            System.out.println(\"Add \" + bytecodeStr(theOpCode));\n+        addToCodeBuffer(theOpCode);\n+        itsStackTop = (short)newStack;\n+        if (newStack > itsMaxStack) itsMaxStack = (short)newStack;\n+        if (DEBUGSTACK) {\n+            System.out.println(\"After \"+bytecodeStr(theOpCode)\n+                               +\" stack = \"+itsStackTop);\n+        }\n+    }\n+\n+    /**\n+     * Add a single-operand opcode to the current method.\n+     *\n+     * @param theOpCode the opcode of the bytecode\n+     * @param theOperand the operand of the bytecode\n+     */\n+    public void add(int theOpCode, int theOperand) {\n+        if (DEBUGCODE) {\n+            System.out.println(\"Add \"+bytecodeStr(theOpCode)\n+                               +\", \"+Integer.toHexString(theOperand));\n+        }\n+        int newStack = itsStackTop + stackChange(theOpCode);\n+        if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);\n+\n+        switch (theOpCode) {\n+            case ByteCode.GOTO :\n+                // fallthru...\n+            case ByteCode.IFEQ :\n+            case ByteCode.IFNE :\n+            case ByteCode.IFLT :\n+            case ByteCode.IFGE :\n+            case ByteCode.IFGT :\n+            case ByteCode.IFLE :\n+            case ByteCode.IF_ICMPEQ :\n+            case ByteCode.IF_ICMPNE :\n+            case ByteCode.IF_ICMPLT :\n+            case ByteCode.IF_ICMPGE :\n+            case ByteCode.IF_ICMPGT :\n+            case ByteCode.IF_ICMPLE :\n+            case ByteCode.IF_ACMPEQ :\n+            case ByteCode.IF_ACMPNE :\n+            case ByteCode.JSR :\n+            case ByteCode.IFNULL :\n+            case ByteCode.IFNONNULL : {\n+                    if ((theOperand & 0x80000000) != 0x80000000) {\n+                        if ((theOperand < 0) || (theOperand > 65535))\n+                            throw new IllegalArgumentException(\n+                                \"Bad label for branch\");\n+                    }\n+                    int branchPC = itsCodeBufferTop;\n+                    addToCodeBuffer(theOpCode);\n+                    if ((theOperand & 0x80000000) != 0x80000000) {\n+                            // hard displacement\n+                        addToCodeInt16(theOperand);\n+                    }\n+                    else {  // a label\n+                        int targetPC = getLabelPC(theOperand);\n+                        if (DEBUGLABELS) {\n+                            int theLabel = theOperand & 0x7FFFFFFF;\n+                            System.out.println(\"Fixing branch to \" +\n+                                               theLabel + \" at \" + targetPC +\n+                                               \" from \" + branchPC);\n+                        }\n+                        if (targetPC != -1) {\n+                            int offset = targetPC - branchPC;\n+                            addToCodeInt16(offset);\n+                        }\n+                        else {\n+                            addLabelFixup(theOperand, branchPC + 1);\n+                            addToCodeInt16(0);\n+                        }\n+                    }\n+                }\n+                break;\n+\n+            case ByteCode.BIPUSH :\n+                if ((byte)theOperand != theOperand)\n+                    throw new IllegalArgumentException(\"out of range byte\");\n+                addToCodeBuffer(theOpCode);\n+                addToCodeBuffer((byte)theOperand);\n+                break;\n+\n+            case ByteCode.SIPUSH :\n+                if ((short)theOperand != theOperand)\n+                    throw new IllegalArgumentException(\"out of range short\");\n+                addToCodeBuffer(theOpCode);\n+                   addToCodeInt16(theOperand);\n+                break;\n+\n+            case ByteCode.NEWARRAY :\n+                if (!(0 <= theOperand && theOperand < 256))\n+                    throw new IllegalArgumentException(\"out of range index\");\n+                addToCodeBuffer(theOpCode);\n+                addToCodeBuffer(theOperand);\n+                break;\n+\n+            case ByteCode.GETFIELD :\n+            case ByteCode.PUTFIELD :\n+                if (!(0 <= theOperand && theOperand < 65536))\n+                    throw new IllegalArgumentException(\"out of range field\");\n+                addToCodeBuffer(theOpCode);\n+                addToCodeInt16(theOperand);\n+                break;\n+\n+            case ByteCode.LDC :\n+            case ByteCode.LDC_W :\n+            case ByteCode.LDC2_W :\n+                if (!(0 <= theOperand && theOperand < 65536))\n+                    throw new IllegalArgumentException(\"out of range index\");\n+                if (theOperand >= 256\n+                    || theOpCode == ByteCode.LDC_W\n+                    || theOpCode == ByteCode.LDC2_W)\n+                {\n+                    if (theOpCode == ByteCode.LDC) {\n+                        addToCodeBuffer(ByteCode.LDC_W);\n+                    } else {\n+                        addToCodeBuffer(theOpCode);\n+                    }\n+                    addToCodeInt16(theOperand);\n+                } else {\n+                    addToCodeBuffer(theOpCode);\n+                    addToCodeBuffer(theOperand);\n+                }\n+                break;\n+\n+            case ByteCode.RET :\n+            case ByteCode.ILOAD :\n+            case ByteCode.LLOAD :\n+            case ByteCode.FLOAD :\n+            case ByteCode.DLOAD :\n+            case ByteCode.ALOAD :\n+            case ByteCode.ISTORE :\n+            case ByteCode.LSTORE :\n+            case ByteCode.FSTORE :\n+            case ByteCode.DSTORE :\n+            case ByteCode.ASTORE :\n+                if (!(0 <= theOperand && theOperand < 65536))\n+                    throw new ClassFileFormatException(\"out of range variable\");\n+                if (theOperand >= 256) {\n+                    addToCodeBuffer(ByteCode.WIDE);\n+                    addToCodeBuffer(theOpCode);\n+                    addToCodeInt16(theOperand);\n+                }\n+                else {\n+                    addToCodeBuffer(theOpCode);\n+                    addToCodeBuffer(theOperand);\n+                }\n+                break;\n+\n+            default :\n+                throw new IllegalArgumentException(\n+                    \"Unexpected opcode for 1 operand\");\n+        }\n+\n+        itsStackTop = (short)newStack;\n+        if (newStack > itsMaxStack) itsMaxStack = (short)newStack;\n+        if (DEBUGSTACK) {\n+            System.out.println(\"After \"+bytecodeStr(theOpCode)\n+                               +\" stack = \"+itsStackTop);\n+        }\n+    }\n+\n+    /**\n+     * Generate the load constant bytecode for the given integer.\n+     *\n+     * @param k the constant\n+     */\n+    public void addLoadConstant(int k) {\n+        switch (k) {\n+            case 0: add(ByteCode.ICONST_0); break;\n+            case 1: add(ByteCode.ICONST_1); break;\n+            case 2: add(ByteCode.ICONST_2); break;\n+            case 3: add(ByteCode.ICONST_3); break;\n+            case 4: add(ByteCode.ICONST_4); break;\n+            case 5: add(ByteCode.ICONST_5); break;\n+            default:\n+                add(ByteCode.LDC, itsConstantPool.addConstant(k));\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Generate the load constant bytecode for the given long.\n+     *\n+     * @param k the constant\n+     */\n+    public void addLoadConstant(long k) {\n+        add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));\n+    }\n+\n+    /**\n+     * Generate the load constant bytecode for the given float.\n+     *\n+     * @param k the constant\n+     */\n+    public void addLoadConstant(float k) {\n+        add(ByteCode.LDC, itsConstantPool.addConstant(k));\n+    }\n+\n+    /**\n+     * Generate the load constant bytecode for the given double.\n+     *\n+     * @param k the constant\n+     */\n+    public void addLoadConstant(double k) {\n+        add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));\n+    }\n+\n+    /**\n+     * Generate the load constant bytecode for the given string.\n+     *\n+     * @param k the constant\n+     */\n+    public void addLoadConstant(String k) {\n+        add(ByteCode.LDC, itsConstantPool.addConstant(k));\n+    }\n+\n+    /**\n+     * Add the given two-operand bytecode to the current method.\n+     *\n+     * @param theOpCode the opcode of the bytecode\n+     * @param theOperand1 the first operand of the bytecode\n+     * @param theOperand2 the second operand of the bytecode\n+     */\n+    public void add(int theOpCode, int theOperand1, int theOperand2) {\n+        if (DEBUGCODE) {\n+            System.out.println(\"Add \"+bytecodeStr(theOpCode)\n+                               +\", \"+Integer.toHexString(theOperand1)\n+                               +\", \"+Integer.toHexString(theOperand2));\n+        }\n+        int newStack = itsStackTop + stackChange(theOpCode);\n+        if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);\n+\n+        if (theOpCode == ByteCode.IINC) {\n+            if (!(0 <= theOperand1 && theOperand1 < 65536))\n+                throw new ClassFileFormatException(\"out of range variable\");\n+            if (!(0 <= theOperand2 && theOperand2 < 65536))\n+                throw new ClassFileFormatException(\"out of range increment\");\n+\n+            if (theOperand1 > 255 || theOperand2 < -128 || theOperand2 > 127) {\n+                addToCodeBuffer(ByteCode.WIDE);\n+                addToCodeBuffer(ByteCode.IINC);\n+                addToCodeInt16(theOperand1);\n+                addToCodeInt16(theOperand2);\n+            }\n+            else {\n+                addToCodeBuffer(ByteCode.WIDE);\n+                addToCodeBuffer(ByteCode.IINC);\n+                addToCodeBuffer(theOperand1);\n+                addToCodeBuffer(theOperand2);\n+            }\n+        }\n+        else if (theOpCode == ByteCode.MULTIANEWARRAY) {\n+            if (!(0 <= theOperand1 && theOperand1 < 65536))\n+                throw new IllegalArgumentException(\"out of range index\");\n+            if (!(0 <= theOperand2 && theOperand2 < 256))\n+                throw new IllegalArgumentException(\"out of range dimensions\");\n+\n+            addToCodeBuffer(ByteCode.MULTIANEWARRAY);\n+            addToCodeInt16(theOperand1);\n+            addToCodeBuffer(theOperand2);\n+        }\n+        else {\n+            throw new IllegalArgumentException(\n+                \"Unexpected opcode for 2 operands\");\n+        }\n+        itsStackTop = (short)newStack;\n+        if (newStack > itsMaxStack) itsMaxStack = (short)newStack;\n+        if (DEBUGSTACK) {\n+            System.out.println(\"After \"+bytecodeStr(theOpCode)\n+                               +\" stack = \"+itsStackTop);\n+        }\n+\n+    }\n+\n+    public void add(int theOpCode, String className) {\n+        if (DEBUGCODE) {\n+            System.out.println(\"Add \"+bytecodeStr(theOpCode)\n+                               +\", \"+className);\n+        }\n+        int newStack = itsStackTop + stackChange(theOpCode);\n+        if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);\n+        switch (theOpCode) {\n+            case ByteCode.NEW :\n+            case ByteCode.ANEWARRAY :\n+            case ByteCode.CHECKCAST :\n+            case ByteCode.INSTANCEOF : {\n+                short classIndex = itsConstantPool.addClass(className);\n+                addToCodeBuffer(theOpCode);\n+                addToCodeInt16(classIndex);\n+            }\n+            break;\n+\n+            default :\n+                throw new IllegalArgumentException(\n+                    \"bad opcode for class reference\");\n+        }\n+        itsStackTop = (short)newStack;\n+        if (newStack > itsMaxStack) itsMaxStack = (short)newStack;\n+        if (DEBUGSTACK) {\n+            System.out.println(\"After \"+bytecodeStr(theOpCode)\n+                               +\" stack = \"+itsStackTop);\n+        }\n+    }\n+\n+\n+    public void add(int theOpCode, String className, String fieldName,\n+                    String fieldType)\n+    {\n+        if (DEBUGCODE) {\n+            System.out.println(\"Add \"+bytecodeStr(theOpCode)\n+                               +\", \"+className+\", \"+fieldName+\", \"+fieldType);\n+        }\n+        int newStack = itsStackTop + stackChange(theOpCode);\n+        char fieldTypeChar = fieldType.charAt(0);\n+        int fieldSize = (fieldTypeChar == 'J' || fieldTypeChar == 'D')\n+                        ? 2 : 1;\n+        switch (theOpCode) {\n+            case ByteCode.GETFIELD :\n+            case ByteCode.GETSTATIC :\n+                newStack += fieldSize;\n+                break;\n+            case ByteCode.PUTSTATIC :\n+            case ByteCode.PUTFIELD :\n+                newStack -= fieldSize;\n+                break;\n+            default :\n+                throw new IllegalArgumentException(\n+                    \"bad opcode for field reference\");\n+        }\n+        if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);\n+        short fieldRefIndex = itsConstantPool.addFieldRef(className,\n+                                             fieldName, fieldType);\n+        addToCodeBuffer(theOpCode);\n+        addToCodeInt16(fieldRefIndex);\n+\n+        itsStackTop = (short)newStack;\n+        if (newStack > itsMaxStack) itsMaxStack = (short)newStack;\n+        if (DEBUGSTACK) {\n+            System.out.println(\"After \"+bytecodeStr(theOpCode)\n+                               +\" stack = \"+itsStackTop);\n+        }\n+    }\n+\n+    public void addInvoke(int theOpCode, String className, String methodName,\n+                          String methodType)\n+    {\n+        if (DEBUGCODE) {\n+            System.out.println(\"Add \"+bytecodeStr(theOpCode)\n+                               +\", \"+className+\", \"+methodName+\", \"\n+                               +methodType);\n+        }\n+        int parameterInfo = sizeOfParameters(methodType);\n+        int parameterCount = parameterInfo >>> 16;\n+        int stackDiff = (short)parameterInfo;\n+\n+        int newStack = itsStackTop + stackDiff;\n+        newStack += stackChange(theOpCode);     // adjusts for 'this'\n+        if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);\n+\n+        switch (theOpCode) {\n+            case ByteCode.INVOKEVIRTUAL :\n+            case ByteCode.INVOKESPECIAL :\n+            case ByteCode.INVOKESTATIC :\n+            case ByteCode.INVOKEINTERFACE : {\n+                    addToCodeBuffer(theOpCode);\n+                    if (theOpCode == ByteCode.INVOKEINTERFACE) {\n+                        short ifMethodRefIndex\n+                                    = itsConstantPool.addInterfaceMethodRef(\n+                                               className, methodName,\n+                                               methodType);\n+                        addToCodeInt16(ifMethodRefIndex);\n+                        addToCodeBuffer(parameterCount + 1);\n+                        addToCodeBuffer(0);\n+                    }\n+                    else {\n+                        short methodRefIndex = itsConstantPool.addMethodRef(\n+                                               className, methodName,\n+                                               methodType);\n+                        addToCodeInt16(methodRefIndex);\n+                    }\n+                }\n+                break;\n+\n+            default :\n+                throw new IllegalArgumentException(\n+                    \"bad opcode for method reference\");\n+        }\n+        itsStackTop = (short)newStack;\n+        if (newStack > itsMaxStack) itsMaxStack = (short)newStack;\n+        if (DEBUGSTACK) {\n+            System.out.println(\"After \"+bytecodeStr(theOpCode)\n+                               +\" stack = \"+itsStackTop);\n+        }\n+    }\n+\n+    /**\n+     * Generate code to load the given integer on stack.\n+     *\n+     * @param k the constant\n+     */\n+    public void addPush(int k)\n+    {\n+        if ((byte)k == k) {\n+            if (k == -1) {\n+                add(ByteCode.ICONST_M1);\n+            } else if (0 <= k && k <= 5) {\n+                add((byte)(ByteCode.ICONST_0 + k));\n+            } else {\n+                add(ByteCode.BIPUSH, (byte)k);\n+            }\n+        } else if ((short)k == k) {\n+            add(ByteCode.SIPUSH, (short)k);\n+        } else {\n+            addLoadConstant(k);\n+        }\n+    }\n+\n+    public void addPush(boolean k)\n+    {\n+        add(k ? ByteCode.ICONST_1 : ByteCode.ICONST_0);\n+    }\n+\n+    /**\n+     * Generate code to load the given long on stack.\n+     *\n+     * @param k the constant\n+     */\n+    public void addPush(long k)\n+    {\n+        int ik = (int)k;\n+        if (ik == k) {\n+            addPush(ik);\n+            add(ByteCode.I2L);\n+        } else {\n+            addLoadConstant(k);\n+        }\n+    }\n+\n+    /**\n+     * Generate code to load the given double on stack.\n+     *\n+     * @param k the constant\n+     */\n+    public void addPush(double k)\n+    {\n+        if (k == 0.0) {\n+            // zero\n+            add(ByteCode.DCONST_0);\n+            if (1.0 / k < 0) {\n+                // Negative zero\n+                add(ByteCode.DNEG);\n+            }\n+        } else if (k == 1.0 || k == -1.0) {\n+            add(ByteCode.DCONST_1);\n+            if (k < 0) {\n+                add(ByteCode.DNEG);\n+            }\n+        } else {\n+            addLoadConstant(k);\n+        }\n+    }\n+\n+    /**\n+     * Generate the code to leave on stack the given string even if the\n+     * string encoding exeeds the class file limit for single string constant\n+     *\n+     * @param k the constant\n+     */\n+    public void addPush(String k) {\n+        int length = k.length();\n+        int limit = itsConstantPool.getUtfEncodingLimit(k, 0, length);\n+        if (limit == length) {\n+            addLoadConstant(k);\n+            return;\n+        }\n+        // Split string into picies fitting the UTF limit and generate code for\n+        // StringBuffer sb = new StringBuffer(length);\n+        // sb.append(loadConstant(piece_1));\n+        // ...\n+        // sb.append(loadConstant(piece_N));\n+        // sb.toString();\n+        final String SB = \"java/lang/StringBuffer\";\n+        add(ByteCode.NEW, SB);\n+        add(ByteCode.DUP);\n+        addPush(length);\n+        addInvoke(ByteCode.INVOKESPECIAL, SB, \"<init>\", \"(I)V\");\n+        int cursor = 0;\n+        for (;;) {\n+            add(ByteCode.DUP);\n+            String s = k.substring(cursor, limit);\n+            addLoadConstant(s);\n+            addInvoke(ByteCode.INVOKEVIRTUAL, SB, \"append\",\n+                      \"(Ljava/lang/String;)Ljava/lang/StringBuffer;\");\n+            add(ByteCode.POP);\n+            if (limit == length) {\n+                break;\n+            }\n+            cursor = limit;\n+            limit = itsConstantPool.getUtfEncodingLimit(k, limit, length);\n+        }\n+        addInvoke(ByteCode.INVOKEVIRTUAL, SB, \"toString\",\n+                  \"()Ljava/lang/String;\");\n+    }\n+\n+    /**\n+     * Check if k fits limit on string constant size imposed by class file\n+     * format.\n+     *\n+     * @param k the string constant\n+     */\n+    public boolean isUnderStringSizeLimit(String k)\n+    {\n+        return itsConstantPool.isUnderUtfEncodingLimit(k);\n+    }\n+\n+    /**\n+     * Store integer from stack top into the given local.\n+     *\n+     * @param local number of local register\n+     */\n+    public void addIStore(int local)\n+    {\n+        xop(ByteCode.ISTORE_0, ByteCode.ISTORE, local);\n+    }\n+\n+    /**\n+     * Store long from stack top into the given local.\n+     *\n+     * @param local number of local register\n+     */\n+    public void addLStore(int local)\n+    {\n+        xop(ByteCode.LSTORE_0, ByteCode.LSTORE, local);\n+    }\n+\n+    /**\n+     * Store float from stack top into the given local.\n+     *\n+     * @param local number of local register\n+     */\n+    public void addFStore(int local)\n+    {\n+        xop(ByteCode.FSTORE_0, ByteCode.FSTORE, local);\n+    }\n+\n+    /**\n+     * Store double from stack top into the given local.\n+     *\n+     * @param local number of local register\n+     */\n+    public void addDStore(int local)\n+    {\n+        xop(ByteCode.DSTORE_0, ByteCode.DSTORE, local);\n+    }\n+\n+    /**\n+     * Store object from stack top into the given local.\n+     *\n+     * @param local number of local register\n+     */\n+    public void addAStore(int local)\n+    {\n+        xop(ByteCode.ASTORE_0, ByteCode.ASTORE, local);\n+    }\n+\n+    /**\n+     * Load integer from the given local into stack.\n+     *\n+     * @param local number of local register\n+     */\n+    public void addILoad(int local)\n+    {\n+        xop(ByteCode.ILOAD_0, ByteCode.ILOAD, local);\n+    }\n+\n+    /**\n+     * Load long from the given local into stack.\n+     *\n+     * @param local number of local register\n+     */\n+    public void addLLoad(int local)\n+    {\n+        xop(ByteCode.LLOAD_0, ByteCode.LLOAD, local);\n+    }\n+\n+    /**\n+     * Load float from the given local into stack.\n+     *\n+     * @param local number of local register\n+     */\n+    public void addFLoad(int local)\n+    {\n+        xop(ByteCode.FLOAD_0, ByteCode.FLOAD, local);\n+    }\n+\n+    /**\n+     * Load double from the given local into stack.\n+     *\n+     * @param local number of local register\n+     */\n+    public void addDLoad(int local)\n+    {\n+        xop(ByteCode.DLOAD_0, ByteCode.DLOAD, local);\n+    }\n+\n+    /**\n+     * Load object from the given local into stack.\n+     *\n+     * @param local number of local register\n+     */\n+    public void addALoad(int local)\n+    {\n+        xop(ByteCode.ALOAD_0, ByteCode.ALOAD, local);\n+    }\n+\n+    /**\n+     * Load \"this\" into stack.\n+     */\n+    public void addLoadThis()\n+    {\n+        add(ByteCode.ALOAD_0);\n+    }\n+\n+    private void xop(int shortOp, int op, int local)\n+    {\n+        switch (local) {\n+          case 0:\n+            add(shortOp);\n+            break;\n+          case 1:\n+            add(shortOp + 1);\n+            break;\n+          case 2:\n+            add(shortOp + 2);\n+            break;\n+          case 3:\n+            add(shortOp + 3);\n+            break;\n+          default:\n+            add(op, local);\n+        }\n+    }\n+\n+    public int addTableSwitch(int low, int high)\n+    {\n+        if (DEBUGCODE) {\n+            System.out.println(\"Add \"+bytecodeStr(ByteCode.TABLESWITCH)\n+                               +\" \"+low+\" \"+high);\n+        }\n+        if (low > high)\n+            throw new ClassFileFormatException(\"Bad bounds: \"+low+' '+ high);\n+\n+        int newStack = itsStackTop + stackChange(ByteCode.TABLESWITCH);\n+        if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);\n+\n+        int entryCount = high - low + 1;\n+        int padSize = 3 & ~itsCodeBufferTop; // == 3 - itsCodeBufferTop % 4\n+\n+        int N = addReservedCodeSpace(1 + padSize + 4 * (1 + 2 + entryCount));\n+        int switchStart = N;\n+        itsCodeBuffer[N++] = (byte)ByteCode.TABLESWITCH;\n+        while (padSize != 0) {\n+            itsCodeBuffer[N++] = 0;\n+            --padSize;\n+        }\n+        N += 4; // skip default offset\n+        N = putInt32(low, itsCodeBuffer, N);\n+        putInt32(high, itsCodeBuffer, N);\n+\n+        itsStackTop = (short)newStack;\n+        if (newStack > itsMaxStack) itsMaxStack = (short)newStack;\n+        if (DEBUGSTACK) {\n+            System.out.println(\"After \"+bytecodeStr(ByteCode.TABLESWITCH)\n+                               +\" stack = \"+itsStackTop);\n+        }\n+\n+        return switchStart;\n+    }\n+\n+    public final void markTableSwitchDefault(int switchStart)\n+    {\n+        setTableSwitchJump(switchStart, -1, itsCodeBufferTop);\n+    }\n+\n+    public final void markTableSwitchCase(int switchStart, int caseIndex)\n+    {\n+        setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);\n+    }\n+\n+    public final void markTableSwitchCase(int switchStart, int caseIndex,\n+                                          int stackTop)\n+    {\n+        if (!(0 <= stackTop && stackTop <= itsMaxStack))\n+            throw new IllegalArgumentException(\"Bad stack index: \"+stackTop);\n+        itsStackTop = (short)stackTop;\n+        setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);\n+    }\n+\n+    public void setTableSwitchJump(int switchStart, int caseIndex,\n+                                   int jumpTarget)\n+    {\n+        if (!(0 <= jumpTarget && jumpTarget <= itsCodeBufferTop))\n+            throw new IllegalArgumentException(\"Bad jump target: \"+jumpTarget);\n+        if (!(caseIndex >= -1))\n+            throw new IllegalArgumentException(\"Bad case index: \"+caseIndex);\n+\n+        int padSize = 3 & ~switchStart; // == 3 - switchStart % 4\n+        int caseOffset;\n+        if (caseIndex < 0) {\n+            // default label\n+            caseOffset = switchStart + 1 + padSize;\n+        } else {\n+            caseOffset = switchStart + 1 + padSize + 4 * (3 + caseIndex);\n+        }\n+        if (!(0 <= switchStart\n+              && switchStart <= itsCodeBufferTop - 4 * 4 - padSize - 1))\n+        {\n+            throw new IllegalArgumentException(\n+                switchStart+\" is outside a possible range of tableswitch\"\n+                +\" in already generated code\");\n+        }\n+        if ((0xFF & itsCodeBuffer[switchStart]) != ByteCode.TABLESWITCH) {\n+            throw new IllegalArgumentException(\n+                switchStart+\" is not offset of tableswitch statement\");\n+        }\n+        if (!(0 <= caseOffset && caseOffset + 4 <= itsCodeBufferTop)) {\n+            // caseIndex >= -1 does not guarantee that caseOffset >= 0 due\n+            // to a possible overflow.\n+            throw new ClassFileFormatException(\n+                \"Too big case index: \"+caseIndex);\n+        }\n+        // ALERT: perhaps check against case bounds?\n+        putInt32(jumpTarget - switchStart, itsCodeBuffer, caseOffset);\n+    }\n+\n+    public int acquireLabel()\n+    {\n+        int top = itsLabelTableTop;\n+        if (itsLabelTable == null || top == itsLabelTable.length) {\n+            if (itsLabelTable == null) {\n+                itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];\n+            }else {\n+                int[] tmp = new int[itsLabelTable.length * 2];\n+                System.arraycopy(itsLabelTable, 0, tmp, 0, top);\n+                itsLabelTable = tmp;\n+            }\n+        }\n+        itsLabelTableTop = top + 1;\n+        itsLabelTable[top] = -1;\n+        return top | 0x80000000;\n+    }\n+\n+    public void markLabel(int label)\n+    {\n+        if (!(label < 0))\n+            throw new IllegalArgumentException(\"Bad label, no biscuit\");\n+\n+        label &= 0x7FFFFFFF;\n+        if (label > itsLabelTableTop)\n+            throw new IllegalArgumentException(\"Bad label\");\n+\n+        if (itsLabelTable[label] != -1) {\n+            throw new IllegalStateException(\"Can only mark label once\");\n+        }\n+\n+        itsLabelTable[label] = itsCodeBufferTop;\n+    }\n+\n+    public void markLabel(int label, short stackTop)\n+    {\n+        markLabel(label);\n+        itsStackTop = stackTop;\n+    }\n+\n+    public void markHandler(int theLabel) {\n+        itsStackTop = 1;\n+        markLabel(theLabel);\n+    }\n+\n+    private int getLabelPC(int label)\n+    {\n+        if (!(label < 0))\n+            throw new IllegalArgumentException(\"Bad label, no biscuit\");\n+        label &= 0x7FFFFFFF;\n+        if (!(label < itsLabelTableTop))\n+            throw new IllegalArgumentException(\"Bad label\");\n+        return itsLabelTable[label];\n+    }\n+\n+    private void addLabelFixup(int label, int fixupSite)\n+    {\n+        if (!(label < 0))\n+            throw new IllegalArgumentException(\"Bad label, no biscuit\");\n+        label &= 0x7FFFFFFF;\n+        if (!(label < itsLabelTableTop))\n+            throw new IllegalArgumentException(\"Bad label\");\n+        int top = itsFixupTableTop;\n+        if (itsFixupTable == null || top == itsFixupTable.length) {\n+            if (itsFixupTable == null) {\n+                itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];\n+            }else {\n+                long[] tmp = new long[itsFixupTable.length * 2];\n+                System.arraycopy(itsFixupTable, 0, tmp, 0, top);\n+                itsFixupTable = tmp;\n+            }\n+        }\n+        itsFixupTableTop = top + 1;\n+        itsFixupTable[top] = ((long)label << 32) | fixupSite;\n+    }\n+\n+    private  void fixLabelGotos()\n+    {\n+        byte[] codeBuffer = itsCodeBuffer;\n+        for (int i = 0; i < itsFixupTableTop; i++) {\n+            long fixup = itsFixupTable[i];\n+            int label = (int)(fixup >> 32);\n+            int fixupSite = (int)fixup;\n+            int pc = itsLabelTable[label];\n+            if (pc == -1) {\n+                // Unlocated label\n+                throw new RuntimeException();\n+            }\n+            // -1 to get delta from instruction start\n+            int offset = pc - (fixupSite - 1);\n+            if ((short)offset != offset) {\n+                throw new ClassFileFormatException\n+                    (\"Program too complex: too big jump offset\");\n+            }\n+            codeBuffer[fixupSite] = (byte)(offset >> 8);\n+            codeBuffer[fixupSite + 1] = (byte)offset;\n+        }\n+        itsFixupTableTop = 0;\n+    }\n+\n+    /**\n+     * Get the current offset into the code of the current method.\n+     *\n+     * @return an integer representing the offset\n+     */\n+    public int getCurrentCodeOffset() {\n+        return itsCodeBufferTop;\n+    }\n+\n+    public short getStackTop() {\n+        return itsStackTop;\n+    }\n+\n+    public void setStackTop(short n) {\n+        itsStackTop = n;\n+    }\n+\n+    public void adjustStackTop(int delta) {\n+        int newStack = itsStackTop + delta;\n+        if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);\n+        itsStackTop = (short)newStack;\n+        if (newStack > itsMaxStack) itsMaxStack = (short)newStack;\n+        if (DEBUGSTACK) {\n+            System.out.println(\"After \"+\"adjustStackTop(\"+delta+\")\"\n+                               +\" stack = \"+itsStackTop);\n+        }\n+    }\n+\n+    private void addToCodeBuffer(int b)\n+    {\n+        int N = addReservedCodeSpace(1);\n+        itsCodeBuffer[N] = (byte)b;\n+    }\n+\n+    private void addToCodeInt16(int value)\n+    {\n+        int N = addReservedCodeSpace(2);\n+        putInt16(value, itsCodeBuffer, N);\n+    }\n+\n+    private int addReservedCodeSpace(int size)\n+    {\n+        if (itsCurrentMethod == null)\n+            throw new IllegalArgumentException(\"No method to add to\");\n+        int oldTop = itsCodeBufferTop;\n+        int newTop = oldTop + size;\n+        if (newTop > itsCodeBuffer.length) {\n+            int newSize = itsCodeBuffer.length * 2;\n+            if (newTop > newSize) { newSize = newTop; }\n+            byte[] tmp = new byte[newSize];\n+            System.arraycopy(itsCodeBuffer, 0, tmp, 0, oldTop);\n+            itsCodeBuffer = tmp;\n+        }\n+        itsCodeBufferTop = newTop;\n+        return oldTop;\n+    }\n+\n+    public void addExceptionHandler(int startLabel, int endLabel,\n+                                    int handlerLabel, String catchClassName)\n+    {\n+        if ((startLabel & 0x80000000) != 0x80000000)\n+            throw new IllegalArgumentException(\"Bad startLabel\");\n+        if ((endLabel & 0x80000000) != 0x80000000)\n+            throw new IllegalArgumentException(\"Bad endLabel\");\n+        if ((handlerLabel & 0x80000000) != 0x80000000)\n+            throw new IllegalArgumentException(\"Bad handlerLabel\");\n+\n+        /*\n+         * If catchClassName is null, use 0 for the catch_type_index; which\n+         * means catch everything.  (Even when the verifier has let you throw\n+         * something other than a Throwable.)\n+         */\n+        short catch_type_index = (catchClassName == null)\n+                                 ? 0\n+                                 : itsConstantPool.addClass(catchClassName);\n+        ExceptionTableEntry newEntry = new ExceptionTableEntry(\n+                                           startLabel,\n+                                           endLabel,\n+                                           handlerLabel,\n+                                           catch_type_index);\n+        int N = itsExceptionTableTop;\n+        if (N == 0) {\n+            itsExceptionTable = new ExceptionTableEntry[ExceptionTableSize];\n+        } else if (N == itsExceptionTable.length) {\n+            ExceptionTableEntry[] tmp = new ExceptionTableEntry[N * 2];\n+            System.arraycopy(itsExceptionTable, 0, tmp, 0, N);\n+            itsExceptionTable = tmp;\n+        }\n+        itsExceptionTable[N] = newEntry;\n+        itsExceptionTableTop = N + 1;\n+\n+    }\n+\n+    public void addLineNumberEntry(short lineNumber) {\n+        if (itsCurrentMethod == null)\n+            throw new IllegalArgumentException(\"No method to stop\");\n+        int N = itsLineNumberTableTop;\n+        if (N == 0) {\n+            itsLineNumberTable = new int[LineNumberTableSize];\n+        } else if (N == itsLineNumberTable.length) {\n+            int[] tmp = new int[N * 2];\n+            System.arraycopy(itsLineNumberTable, 0, tmp, 0, N);\n+            itsLineNumberTable = tmp;\n+        }\n+        itsLineNumberTable[N] = (itsCodeBufferTop << 16) + lineNumber;\n+        itsLineNumberTableTop = N + 1;\n+    }\n+\n+    /**\n+     * Write the class file to the OutputStream.\n+     *\n+     * @param oStream the stream to write to\n+     * @throws IOException if writing to the stream produces an exception\n+     */\n+    public void write(OutputStream oStream)\n+        throws IOException\n+    {\n+        byte[] array = toByteArray();\n+        oStream.write(array);\n+    }\n+\n+    private int getWriteSize()\n+    {\n+        int size = 0;\n+\n+        if (itsSourceFileNameIndex != 0) {\n+            itsConstantPool.addUtf8(\"SourceFile\");\n+        }\n+\n+        size += 8; //writeLong(FileHeaderConstant);\n+        size += itsConstantPool.getWriteSize();\n+        size += 2; //writeShort(itsFlags);\n+        size += 2; //writeShort(itsThisClassIndex);\n+        size += 2; //writeShort(itsSuperClassIndex);\n+        size += 2; //writeShort(itsInterfaces.size());\n+        size += 2 * itsInterfaces.size();\n+\n+        size += 2; //writeShort(itsFields.size());\n+        for (int i = 0; i < itsFields.size(); i++) {\n+            size += ((ClassFileField)(itsFields.get(i))).getWriteSize();\n+        }\n+\n+        size += 2; //writeShort(itsMethods.size());\n+        for (int i = 0; i < itsMethods.size(); i++) {\n+            size += ((ClassFileMethod)(itsMethods.get(i))).getWriteSize();\n+        }\n+\n+        if (itsSourceFileNameIndex != 0) {\n+            size += 2; //writeShort(1);  attributes count\n+            size += 2; //writeShort(sourceFileAttributeNameIndex);\n+            size += 4; //writeInt(2);\n+            size += 2; //writeShort(itsSourceFileNameIndex);\n+        }else {\n+            size += 2; //out.writeShort(0);  no attributes\n+        }\n+\n+        return size;\n+    }\n+\n+    /**\n+     * Get the class file as array of bytesto the OutputStream.\n+     */\n+    public byte[] toByteArray()\n+    {\n+        int dataSize = getWriteSize();\n+        byte[] data = new byte[dataSize];\n+        int offset = 0;\n+\n+        short sourceFileAttributeNameIndex = 0;\n+        if (itsSourceFileNameIndex != 0) {\n+            sourceFileAttributeNameIndex = itsConstantPool.addUtf8(\n+                                               \"SourceFile\");\n+        }\n+\n+        offset = putInt64(FileHeaderConstant, data, offset);\n+        offset = itsConstantPool.write(data, offset);\n+        offset = putInt16(itsFlags, data, offset);\n+        offset = putInt16(itsThisClassIndex, data, offset);\n+        offset = putInt16(itsSuperClassIndex, data, offset);\n+        offset = putInt16(itsInterfaces.size(), data, offset);\n+        for (int i = 0; i < itsInterfaces.size(); i++) {\n+            int interfaceIndex = ((Short)(itsInterfaces.get(i))).shortValue();\n+            offset = putInt16(interfaceIndex, data, offset);\n+        }\n+        offset = putInt16(itsFields.size(), data, offset);\n+        for (int i = 0; i < itsFields.size(); i++) {\n+            ClassFileField field = (ClassFileField)itsFields.get(i);\n+            offset = field.write(data, offset);\n+        }\n+        offset = putInt16(itsMethods.size(), data, offset);\n+        for (int i = 0; i < itsMethods.size(); i++) {\n+            ClassFileMethod method = (ClassFileMethod)itsMethods.get(i);\n+            offset = method.write(data, offset);\n+        }\n+        if (itsSourceFileNameIndex != 0) {\n+            offset = putInt16(1, data, offset); // attributes count\n+            offset = putInt16(sourceFileAttributeNameIndex, data, offset);\n+            offset = putInt32(2, data, offset);\n+            offset = putInt16(itsSourceFileNameIndex, data, offset);\n+        } else {\n+            offset = putInt16(0, data, offset); // no attributes\n+        }\n+\n+        if (offset != dataSize) {\n+            // Check getWriteSize is consistent with write!\n+            throw new RuntimeException();\n+        }\n+\n+        return data;\n+    }\n+\n+    static int putInt64(long value, byte[] array, int offset)\n+    {\n+        offset = putInt32((int)(value >>> 32), array, offset);\n+        return putInt32((int)value, array, offset);\n+    }\n+\n+    private static void badStack(int value)\n+    {\n+        String s;\n+        if (value < 0) { s = \"Stack underflow: \"+value; }\n+        else { s = \"Too big stack: \"+value; }\n+        throw new IllegalStateException(s);\n+    }\n+\n+    /*\n+        Really weird. Returns an int with # parameters in hi 16 bits, and\n+        stack difference removal of parameters from stack and pushing the\n+        result (it does not take into account removal of this in case of\n+        non-static methods).\n+        If Java really supported references we wouldn't have to be this\n+        perverted.\n+    */\n+    private static int sizeOfParameters(String pString)\n+    {\n+        int length = pString.length();\n+        int rightParenthesis = pString.lastIndexOf(')');\n+        if (3 <= length /* minimal signature takes at least 3 chars: ()V */\n+            && pString.charAt(0) == '('\n+            && 1 <= rightParenthesis && rightParenthesis + 1 < length)\n+        {\n+            boolean ok = true;\n+            int index = 1;\n+            int stackDiff = 0;\n+            int count = 0;\n+        stringLoop:\n+            while (index != rightParenthesis) {\n+                switch (pString.charAt(index)) {\n+                    default:\n+                        ok = false;\n+                        break stringLoop;\n+                    case 'J' :\n+                    case 'D' :\n+                        --stackDiff;\n+                        // fall thru\n+                    case 'B' :\n+                    case 'S' :\n+                    case 'C' :\n+                    case 'I' :\n+                    case 'Z' :\n+                    case 'F' :\n+                        --stackDiff;\n+                        ++count;\n+                        ++index;\n+                        continue;\n+                    case '[' :\n+                        ++index;\n+                        int c = pString.charAt(index);\n+                        while (c == '[') {\n+                            ++index;\n+                            c = pString.charAt(index);\n+                        }\n+                        switch (c) {\n+                            default:\n+                                ok = false;\n+                                break stringLoop;\n+                            case 'J' :\n+                            case 'D' :\n+                            case 'B' :\n+                            case 'S' :\n+                            case 'C' :\n+                            case 'I' :\n+                            case 'Z' :\n+                            case 'F' :\n+                                --stackDiff;\n+                                ++count;\n+                                ++index;\n+                                continue;\n+                            case 'L':\n+                                // fall thru\n+                        }\n+                          // fall thru\n+                    case 'L' : {\n+                        --stackDiff;\n+                        ++count;\n+                        ++index;\n+                        int semicolon = pString.indexOf(';',  index);\n+                        if (!(index + 1 <= semicolon\n+                            && semicolon < rightParenthesis))\n+                        {\n+                            ok = false;\n+                            break stringLoop;\n+                        }\n+                        index = semicolon + 1;\n+                        continue;\n+                    }\n+                }\n+            }\n+            if (ok) {\n+                switch (pString.charAt(rightParenthesis + 1)) {\n+                    default:\n+                        ok = false;\n+                        break;\n+                    case 'J' :\n+                    case 'D' :\n+                        ++stackDiff;\n+                        // fall thru\n+                    case 'B' :\n+                    case 'S' :\n+                    case 'C' :\n+                    case 'I' :\n+                    case 'Z' :\n+                    case 'F' :\n+                    case 'L' :\n+                    case '[' :\n+                        ++stackDiff;\n+                        // fall thru\n+                    case 'V' :\n+                        break;\n+                }\n+                if (ok) {\n+                    return ((count << 16) | (0xFFFF & stackDiff));\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\n+            \"Bad parameter signature: \"+pString);\n+    }\n+\n+    static int putInt16(int value, byte[] array, int offset)\n+    {\n+        array[offset + 0] = (byte)(value >>> 8);\n+        array[offset + 1] = (byte)value;\n+        return offset + 2;\n+    }\n+\n+    static int putInt32(int value, byte[] array, int offset)\n+    {\n+        array[offset + 0] = (byte)(value >>> 24);\n+        array[offset + 1] = (byte)(value >>> 16);\n+        array[offset + 2] = (byte)(value >>> 8);\n+        array[offset + 3] = (byte)value;\n+        return offset + 4;\n+    }\n+\n+    /**\n+     * Number of operands accompanying the opcode.\n+     */\n+    static int opcodeCount(int opcode)\n+    {\n+        switch (opcode) {\n+            case ByteCode.AALOAD:\n+            case ByteCode.AASTORE:\n+            case ByteCode.ACONST_NULL:\n+            case ByteCode.ALOAD_0:\n+            case ByteCode.ALOAD_1:\n+            case ByteCode.ALOAD_2:\n+            case ByteCode.ALOAD_3:\n+            case ByteCode.ARETURN:\n+            case ByteCode.ARRAYLENGTH:\n+            case ByteCode.ASTORE_0:\n+            case ByteCode.ASTORE_1:\n+            case ByteCode.ASTORE_2:\n+            case ByteCode.ASTORE_3:\n+            case ByteCode.ATHROW:\n+            case ByteCode.BALOAD:\n+            case ByteCode.BASTORE:\n+            case ByteCode.BREAKPOINT:\n+            case ByteCode.CALOAD:\n+            case ByteCode.CASTORE:\n+            case ByteCode.D2F:\n+            case ByteCode.D2I:\n+            case ByteCode.D2L:\n+            case ByteCode.DADD:\n+            case ByteCode.DALOAD:\n+            case ByteCode.DASTORE:\n+            case ByteCode.DCMPG:\n+            case ByteCode.DCMPL:\n+            case ByteCode.DCONST_0:\n+            case ByteCode.DCONST_1:\n+            case ByteCode.DDIV:\n+            case ByteCode.DLOAD_0:\n+            case ByteCode.DLOAD_1:\n+            case ByteCode.DLOAD_2:\n+            case ByteCode.DLOAD_3:\n+            case ByteCode.DMUL:\n+            case ByteCode.DNEG:\n+            case ByteCode.DREM:\n+            case ByteCode.DRETURN:\n+            case ByteCode.DSTORE_0:\n+            case ByteCode.DSTORE_1:\n+            case ByteCode.DSTORE_2:\n+            case ByteCode.DSTORE_3:\n+            case ByteCode.DSUB:\n+            case ByteCode.DUP:\n+            case ByteCode.DUP2:\n+            case ByteCode.DUP2_X1:\n+            case ByteCode.DUP2_X2:\n+            case ByteCode.DUP_X1:\n+            case ByteCode.DUP_X2:\n+            case ByteCode.F2D:\n+            case ByteCode.F2I:\n+            case ByteCode.F2L:\n+            case ByteCode.FADD:\n+            case ByteCode.FALOAD:\n+            case ByteCode.FASTORE:\n+            case ByteCode.FCMPG:\n+            case ByteCode.FCMPL:\n+            case ByteCode.FCONST_0:\n+            case ByteCode.FCONST_1:\n+            case ByteCode.FCONST_2:\n+            case ByteCode.FDIV:\n+            case ByteCode.FLOAD_0:\n+            case ByteCode.FLOAD_1:\n+            case ByteCode.FLOAD_2:\n+            case ByteCode.FLOAD_3:\n+            case ByteCode.FMUL:\n+            case ByteCode.FNEG:\n+            case ByteCode.FREM:\n+            case ByteCode.FRETURN:\n+            case ByteCode.FSTORE_0:\n+            case ByteCode.FSTORE_1:\n+            case ByteCode.FSTORE_2:\n+            case ByteCode.FSTORE_3:\n+            case ByteCode.FSUB:\n+            case ByteCode.I2B:\n+            case ByteCode.I2C:\n+            case ByteCode.I2D:\n+            case ByteCode.I2F:\n+            case ByteCode.I2L:\n+            case ByteCode.I2S:\n+            case ByteCode.IADD:\n+            case ByteCode.IALOAD:\n+            case ByteCode.IAND:\n+            case ByteCode.IASTORE:\n+            case ByteCode.ICONST_0:\n+            case ByteCode.ICONST_1:\n+            case ByteCode.ICONST_2:\n+            case ByteCode.ICONST_3:\n+            case ByteCode.ICONST_4:\n+            case ByteCode.ICONST_5:\n+            case ByteCode.ICONST_M1:\n+            case ByteCode.IDIV:\n+            case ByteCode.ILOAD_0:\n+            case ByteCode.ILOAD_1:\n+            case ByteCode.ILOAD_2:\n+            case ByteCode.ILOAD_3:\n+            case ByteCode.IMPDEP1:\n+            case ByteCode.IMPDEP2:\n+            case ByteCode.IMUL:\n+            case ByteCode.INEG:\n+            case ByteCode.IOR:\n+            case ByteCode.IREM:\n+            case ByteCode.IRETURN:\n+            case ByteCode.ISHL:\n+            case ByteCode.ISHR:\n+            case ByteCode.ISTORE_0:\n+            case ByteCode.ISTORE_1:\n+            case ByteCode.ISTORE_2:\n+            case ByteCode.ISTORE_3:\n+            case ByteCode.ISUB:\n+            case ByteCode.IUSHR:\n+            case ByteCode.IXOR:\n+            case ByteCode.L2D:\n+            case ByteCode.L2F:\n+            case ByteCode.L2I:\n+            case ByteCode.LADD:\n+            case ByteCode.LALOAD:\n+            case ByteCode.LAND:\n+            case ByteCode.LASTORE:\n+            case ByteCode.LCMP:\n+            case ByteCode.LCONST_0:\n+            case ByteCode.LCONST_1:\n+            case ByteCode.LDIV:\n+            case ByteCode.LLOAD_0:\n+            case ByteCode.LLOAD_1:\n+            case ByteCode.LLOAD_2:\n+            case ByteCode.LLOAD_3:\n+            case ByteCode.LMUL:\n+            case ByteCode.LNEG:\n+            case ByteCode.LOR:\n+            case ByteCode.LREM:\n+            case ByteCode.LRETURN:\n+            case ByteCode.LSHL:\n+            case ByteCode.LSHR:\n+            case ByteCode.LSTORE_0:\n+            case ByteCode.LSTORE_1:\n+            case ByteCode.LSTORE_2:\n+            case ByteCode.LSTORE_3:\n+            case ByteCode.LSUB:\n+            case ByteCode.LUSHR:\n+            case ByteCode.LXOR:\n+            case ByteCode.MONITORENTER:\n+            case ByteCode.MONITOREXIT:\n+            case ByteCode.NOP:\n+            case ByteCode.POP:\n+            case ByteCode.POP2:\n+            case ByteCode.RETURN:\n+            case ByteCode.SALOAD:\n+            case ByteCode.SASTORE:\n+            case ByteCode.SWAP:\n+            case ByteCode.WIDE:\n+                return 0;\n+            case ByteCode.ALOAD:\n+            case ByteCode.ANEWARRAY:\n+            case ByteCode.ASTORE:\n+            case ByteCode.BIPUSH:\n+            case ByteCode.CHECKCAST:\n+            case ByteCode.DLOAD:\n+            case ByteCode.DSTORE:\n+            case ByteCode.FLOAD:\n+            case ByteCode.FSTORE:\n+            case ByteCode.GETFIELD:\n+            case ByteCode.GETSTATIC:\n+            case ByteCode.GOTO:\n+            case ByteCode.GOTO_W:\n+            case ByteCode.IFEQ:\n+            case ByteCode.IFGE:\n+            case ByteCode.IFGT:\n+            case ByteCode.IFLE:\n+            case ByteCode.IFLT:\n+            case ByteCode.IFNE:\n+            case ByteCode.IFNONNULL:\n+            case ByteCode.IFNULL:\n+            case ByteCode.IF_ACMPEQ:\n+            case ByteCode.IF_ACMPNE:\n+            case ByteCode.IF_ICMPEQ:\n+            case ByteCode.IF_ICMPGE:\n+            case ByteCode.IF_ICMPGT:\n+            case ByteCode.IF_ICMPLE:\n+            case ByteCode.IF_ICMPLT:\n+            case ByteCode.IF_ICMPNE:\n+            case ByteCode.ILOAD:\n+            case ByteCode.INSTANCEOF:\n+            case ByteCode.INVOKEINTERFACE:\n+            case ByteCode.INVOKESPECIAL:\n+            case ByteCode.INVOKESTATIC:\n+            case ByteCode.INVOKEVIRTUAL:\n+            case ByteCode.ISTORE:\n+            case ByteCode.JSR:\n+            case ByteCode.JSR_W:\n+            case ByteCode.LDC:\n+            case ByteCode.LDC2_W:\n+            case ByteCode.LDC_W:\n+            case ByteCode.LLOAD:\n+            case ByteCode.LSTORE:\n+            case ByteCode.NEW:\n+            case ByteCode.NEWARRAY:\n+            case ByteCode.PUTFIELD:\n+            case ByteCode.PUTSTATIC:\n+            case ByteCode.RET:\n+            case ByteCode.SIPUSH:\n+                return 1;\n+\n+            case ByteCode.IINC:\n+            case ByteCode.MULTIANEWARRAY:\n+                return 2;\n+\n+            case ByteCode.LOOKUPSWITCH:\n+            case ByteCode.TABLESWITCH:\n+                return -1;\n+        }\n+        throw new IllegalArgumentException(\"Bad opcode: \"+opcode);\n+    }\n+\n+    /**\n+     *  The effect on the operand stack of a given opcode.\n+     */\n+    static int stackChange(int opcode)\n+    {\n+        // For INVOKE... accounts only for popping this (unless static),\n+        // ignoring parameters and return type\n+        switch (opcode) {\n+            case ByteCode.DASTORE:\n+            case ByteCode.LASTORE:\n+                return -4;\n+\n+            case ByteCode.AASTORE:\n+            case ByteCode.BASTORE:\n+            case ByteCode.CASTORE:\n+            case ByteCode.DCMPG:\n+            case ByteCode.DCMPL:\n+            case ByteCode.FASTORE:\n+            case ByteCode.IASTORE:\n+            case ByteCode.LCMP:\n+            case ByteCode.SASTORE:\n+                return -3;\n+\n+            case ByteCode.DADD:\n+            case ByteCode.DDIV:\n+            case ByteCode.DMUL:\n+            case ByteCode.DREM:\n+            case ByteCode.DRETURN:\n+            case ByteCode.DSTORE:\n+            case ByteCode.DSTORE_0:\n+            case ByteCode.DSTORE_1:\n+            case ByteCode.DSTORE_2:\n+            case ByteCode.DSTORE_3:\n+            case ByteCode.DSUB:\n+            case ByteCode.IF_ACMPEQ:\n+            case ByteCode.IF_ACMPNE:\n+            case ByteCode.IF_ICMPEQ:\n+            case ByteCode.IF_ICMPGE:\n+            case ByteCode.IF_ICMPGT:\n+            case ByteCode.IF_ICMPLE:\n+            case ByteCode.IF_ICMPLT:\n+            case ByteCode.IF_ICMPNE:\n+            case ByteCode.LADD:\n+            case ByteCode.LAND:\n+            case ByteCode.LDIV:\n+            case ByteCode.LMUL:\n+            case ByteCode.LOR:\n+            case ByteCode.LREM:\n+            case ByteCode.LRETURN:\n+            case ByteCode.LSTORE:\n+            case ByteCode.LSTORE_0:\n+            case ByteCode.LSTORE_1:\n+            case ByteCode.LSTORE_2:\n+            case ByteCode.LSTORE_3:\n+            case ByteCode.LSUB:\n+            case ByteCode.LXOR:\n+            case ByteCode.POP2:\n+                return -2;\n+\n+            case ByteCode.AALOAD:\n+            case ByteCode.ARETURN:\n+            case ByteCode.ASTORE:\n+            case ByteCode.ASTORE_0:\n+            case ByteCode.ASTORE_1:\n+            case ByteCode.ASTORE_2:\n+            case ByteCode.ASTORE_3:\n+            case ByteCode.ATHROW:\n+            case ByteCode.BALOAD:\n+            case ByteCode.CALOAD:\n+            case ByteCode.D2F:\n+            case ByteCode.D2I:\n+            case ByteCode.FADD:\n+            case ByteCode.FALOAD:\n+            case ByteCode.FCMPG:\n+            case ByteCode.FCMPL:\n+            case ByteCode.FDIV:\n+            case ByteCode.FMUL:\n+            case ByteCode.FREM:\n+            case ByteCode.FRETURN:\n+            case ByteCode.FSTORE:\n+            case ByteCode.FSTORE_0:\n+            case ByteCode.FSTORE_1:\n+            case ByteCode.FSTORE_2:\n+            case ByteCode.FSTORE_3:\n+            case ByteCode.FSUB:\n+            case ByteCode.GETFIELD:\n+            case ByteCode.IADD:\n+            case ByteCode.IALOAD:\n+            case ByteCode.IAND:\n+            case ByteCode.IDIV:\n+            case ByteCode.IFEQ:\n+            case ByteCode.IFGE:\n+            case ByteCode.IFGT:\n+            case ByteCode.IFLE:\n+            case ByteCode.IFLT:\n+            case ByteCode.IFNE:\n+            case ByteCode.IFNONNULL:\n+            case ByteCode.IFNULL:\n+            case ByteCode.IMUL:\n+            case ByteCode.INVOKEINTERFACE:       //\n+            case ByteCode.INVOKESPECIAL:         // but needs to account for\n+            case ByteCode.INVOKEVIRTUAL:         // pops 'this' (unless static)\n+            case ByteCode.IOR:\n+            case ByteCode.IREM:\n+            case ByteCode.IRETURN:\n+            case ByteCode.ISHL:\n+            case ByteCode.ISHR:\n+            case ByteCode.ISTORE:\n+            case ByteCode.ISTORE_0:\n+            case ByteCode.ISTORE_1:\n+            case ByteCode.ISTORE_2:\n+            case ByteCode.ISTORE_3:\n+            case ByteCode.ISUB:\n+            case ByteCode.IUSHR:\n+            case ByteCode.IXOR:\n+            case ByteCode.L2F:\n+            case ByteCode.L2I:\n+            case ByteCode.LOOKUPSWITCH:\n+            case ByteCode.LSHL:\n+            case ByteCode.LSHR:\n+            case ByteCode.LUSHR:\n+            case ByteCode.MONITORENTER:\n+            case ByteCode.MONITOREXIT:\n+            case ByteCode.POP:\n+            case ByteCode.PUTFIELD:\n+            case ByteCode.SALOAD:\n+            case ByteCode.TABLESWITCH:\n+                return -1;\n+\n+            case ByteCode.ANEWARRAY:\n+            case ByteCode.ARRAYLENGTH:\n+            case ByteCode.BREAKPOINT:\n+            case ByteCode.CHECKCAST:\n+            case ByteCode.D2L:\n+            case ByteCode.DALOAD:\n+            case ByteCode.DNEG:\n+            case ByteCode.F2I:\n+            case ByteCode.FNEG:\n+            case ByteCode.GETSTATIC:\n+            case ByteCode.GOTO:\n+            case ByteCode.GOTO_W:\n+            case ByteCode.I2B:\n+            case ByteCode.I2C:\n+            case ByteCode.I2F:\n+            case ByteCode.I2S:\n+            case ByteCode.IINC:\n+            case ByteCode.IMPDEP1:\n+            case ByteCode.IMPDEP2:\n+            case ByteCode.INEG:\n+            case ByteCode.INSTANCEOF:\n+            case ByteCode.INVOKESTATIC:\n+            case ByteCode.L2D:\n+            case ByteCode.LALOAD:\n+            case ByteCode.LNEG:\n+            case ByteCode.NEWARRAY:\n+            case ByteCode.NOP:\n+            case ByteCode.PUTSTATIC:\n+            case ByteCode.RET:\n+            case ByteCode.RETURN:\n+            case ByteCode.SWAP:\n+            case ByteCode.WIDE:\n+                return 0;\n+\n+            case ByteCode.ACONST_NULL:\n+            case ByteCode.ALOAD:\n+            case ByteCode.ALOAD_0:\n+            case ByteCode.ALOAD_1:\n+            case ByteCode.ALOAD_2:\n+            case ByteCode.ALOAD_3:\n+            case ByteCode.BIPUSH:\n+            case ByteCode.DUP:\n+            case ByteCode.DUP_X1:\n+            case ByteCode.DUP_X2:\n+            case ByteCode.F2D:\n+            case ByteCode.F2L:\n+            case ByteCode.FCONST_0:\n+            case ByteCode.FCONST_1:\n+            case ByteCode.FCONST_2:\n+            case ByteCode.FLOAD:\n+            case ByteCode.FLOAD_0:\n+            case ByteCode.FLOAD_1:\n+            case ByteCode.FLOAD_2:\n+            case ByteCode.FLOAD_3:\n+            case ByteCode.I2D:\n+            case ByteCode.I2L:\n+            case ByteCode.ICONST_0:\n+            case ByteCode.ICONST_1:\n+            case ByteCode.ICONST_2:\n+            case ByteCode.ICONST_3:\n+            case ByteCode.ICONST_4:\n+            case ByteCode.ICONST_5:\n+            case ByteCode.ICONST_M1:\n+            case ByteCode.ILOAD:\n+            case ByteCode.ILOAD_0:\n+            case ByteCode.ILOAD_1:\n+            case ByteCode.ILOAD_2:\n+            case ByteCode.ILOAD_3:\n+            case ByteCode.JSR:\n+            case ByteCode.JSR_W:\n+            case ByteCode.LDC:\n+            case ByteCode.LDC_W:\n+            case ByteCode.MULTIANEWARRAY:\n+            case ByteCode.NEW:\n+            case ByteCode.SIPUSH:\n+                return 1;\n+\n+            case ByteCode.DCONST_0:\n+            case ByteCode.DCONST_1:\n+            case ByteCode.DLOAD:\n+            case ByteCode.DLOAD_0:\n+            case ByteCode.DLOAD_1:\n+            case ByteCode.DLOAD_2:\n+            case ByteCode.DLOAD_3:\n+            case ByteCode.DUP2:\n+            case ByteCode.DUP2_X1:\n+            case ByteCode.DUP2_X2:\n+            case ByteCode.LCONST_0:\n+            case ByteCode.LCONST_1:\n+            case ByteCode.LDC2_W:\n+            case ByteCode.LLOAD:\n+            case ByteCode.LLOAD_0:\n+            case ByteCode.LLOAD_1:\n+            case ByteCode.LLOAD_2:\n+            case ByteCode.LLOAD_3:\n+                return 2;\n+        }\n+        throw new IllegalArgumentException(\"Bad opcode: \"+opcode);\n+    }\n+\n+        /*\n+         * Number of bytes of operands generated after the opcode.\n+         * Not in use currently.\n+         */\n+/*\n+    int extra(int opcode)\n+    {\n+        switch (opcode) {\n+            case ByteCode.AALOAD:\n+            case ByteCode.AASTORE:\n+            case ByteCode.ACONST_NULL:\n+            case ByteCode.ALOAD_0:\n+            case ByteCode.ALOAD_1:\n+            case ByteCode.ALOAD_2:\n+            case ByteCode.ALOAD_3:\n+            case ByteCode.ARETURN:\n+            case ByteCode.ARRAYLENGTH:\n+            case ByteCode.ASTORE_0:\n+            case ByteCode.ASTORE_1:\n+            case ByteCode.ASTORE_2:\n+            case ByteCode.ASTORE_3:\n+            case ByteCode.ATHROW:\n+            case ByteCode.BALOAD:\n+            case ByteCode.BASTORE:\n+            case ByteCode.BREAKPOINT:\n+            case ByteCode.CALOAD:\n+            case ByteCode.CASTORE:\n+            case ByteCode.D2F:\n+            case ByteCode.D2I:\n+            case ByteCode.D2L:\n+            case ByteCode.DADD:\n+            case ByteCode.DALOAD:\n+            case ByteCode.DASTORE:\n+            case ByteCode.DCMPG:\n+            case ByteCode.DCMPL:\n+            case ByteCode.DCONST_0:\n+            case ByteCode.DCONST_1:\n+            case ByteCode.DDIV:\n+            case ByteCode.DLOAD_0:\n+            case ByteCode.DLOAD_1:\n+            case ByteCode.DLOAD_2:\n+            case ByteCode.DLOAD_3:\n+            case ByteCode.DMUL:\n+            case ByteCode.DNEG:\n+            case ByteCode.DREM:\n+            case ByteCode.DRETURN:\n+            case ByteCode.DSTORE_0:\n+            case ByteCode.DSTORE_1:\n+            case ByteCode.DSTORE_2:\n+            case ByteCode.DSTORE_3:\n+            case ByteCode.DSUB:\n+            case ByteCode.DUP2:\n+            case ByteCode.DUP2_X1:\n+            case ByteCode.DUP2_X2:\n+            case ByteCode.DUP:\n+            case ByteCode.DUP_X1:\n+            case ByteCode.DUP_X2:\n+            case ByteCode.F2D:\n+            case ByteCode.F2I:\n+            case ByteCode.F2L:\n+            case ByteCode.FADD:\n+            case ByteCode.FALOAD:\n+            case ByteCode.FASTORE:\n+            case ByteCode.FCMPG:\n+            case ByteCode.FCMPL:\n+            case ByteCode.FCONST_0:\n+            case ByteCode.FCONST_1:\n+            case ByteCode.FCONST_2:\n+            case ByteCode.FDIV:\n+            case ByteCode.FLOAD_0:\n+            case ByteCode.FLOAD_1:\n+            case ByteCode.FLOAD_2:\n+            case ByteCode.FLOAD_3:\n+            case ByteCode.FMUL:\n+            case ByteCode.FNEG:\n+            case ByteCode.FREM:\n+            case ByteCode.FRETURN:\n+            case ByteCode.FSTORE_0:\n+            case ByteCode.FSTORE_1:\n+            case ByteCode.FSTORE_2:\n+            case ByteCode.FSTORE_3:\n+            case ByteCode.FSUB:\n+            case ByteCode.I2B:\n+            case ByteCode.I2C:\n+            case ByteCode.I2D:\n+            case ByteCode.I2F:\n+            case ByteCode.I2L:\n+            case ByteCode.I2S:\n+            case ByteCode.IADD:\n+            case ByteCode.IALOAD:\n+            case ByteCode.IAND:\n+            case ByteCode.IASTORE:\n+            case ByteCode.ICONST_0:\n+            case ByteCode.ICONST_1:\n+            case ByteCode.ICONST_2:\n+            case ByteCode.ICONST_3:\n+            case ByteCode.ICONST_4:\n+            case ByteCode.ICONST_5:\n+            case ByteCode.ICONST_M1:\n+            case ByteCode.IDIV:\n+            case ByteCode.ILOAD_0:\n+            case ByteCode.ILOAD_1:\n+            case ByteCode.ILOAD_2:\n+            case ByteCode.ILOAD_3:\n+            case ByteCode.IMPDEP1:\n+            case ByteCode.IMPDEP2:\n+            case ByteCode.IMUL:\n+            case ByteCode.INEG:\n+            case ByteCode.IOR:\n+            case ByteCode.IREM:\n+            case ByteCode.IRETURN:\n+            case ByteCode.ISHL:\n+            case ByteCode.ISHR:\n+            case ByteCode.ISTORE_0:\n+            case ByteCode.ISTORE_1:\n+            case ByteCode.ISTORE_2:\n+            case ByteCode.ISTORE_3:\n+            case ByteCode.ISUB:\n+            case ByteCode.IUSHR:\n+            case ByteCode.IXOR:\n+            case ByteCode.L2D:\n+            case ByteCode.L2F:\n+            case ByteCode.L2I:\n+            case ByteCode.LADD:\n+            case ByteCode.LALOAD:\n+            case ByteCode.LAND:\n+            case ByteCode.LASTORE:\n+            case ByteCode.LCMP:\n+            case ByteCode.LCONST_0:\n+            case ByteCode.LCONST_1:\n+            case ByteCode.LDIV:\n+            case ByteCode.LLOAD_0:\n+            case ByteCode.LLOAD_1:\n+            case ByteCode.LLOAD_2:\n+            case ByteCode.LLOAD_3:\n+            case ByteCode.LMUL:\n+            case ByteCode.LNEG:\n+            case ByteCode.LOR:\n+            case ByteCode.LREM:\n+            case ByteCode.LRETURN:\n+            case ByteCode.LSHL:\n+            case ByteCode.LSHR:\n+            case ByteCode.LSTORE_0:\n+            case ByteCode.LSTORE_1:\n+            case ByteCode.LSTORE_2:\n+            case ByteCode.LSTORE_3:\n+            case ByteCode.LSUB:\n+            case ByteCode.LUSHR:\n+            case ByteCode.LXOR:\n+            case ByteCode.MONITORENTER:\n+            case ByteCode.MONITOREXIT:\n+            case ByteCode.NOP:\n+            case ByteCode.POP2:\n+            case ByteCode.POP:\n+            case ByteCode.RETURN:\n+            case ByteCode.SALOAD:\n+            case ByteCode.SASTORE:\n+            case ByteCode.SWAP:\n+            case ByteCode.WIDE:\n+                return 0;\n+\n+            case ByteCode.ALOAD:\n+            case ByteCode.ASTORE:\n+            case ByteCode.BIPUSH:\n+            case ByteCode.DLOAD:\n+            case ByteCode.DSTORE:\n+            case ByteCode.FLOAD:\n+            case ByteCode.FSTORE:\n+            case ByteCode.ILOAD:\n+            case ByteCode.ISTORE:\n+            case ByteCode.LDC:\n+            case ByteCode.LLOAD:\n+            case ByteCode.LSTORE:\n+            case ByteCode.NEWARRAY:\n+            case ByteCode.RET:\n+                return 1;\n+\n+            case ByteCode.ANEWARRAY:\n+            case ByteCode.CHECKCAST:\n+            case ByteCode.GETFIELD:\n+            case ByteCode.GETSTATIC:\n+            case ByteCode.GOTO:\n+            case ByteCode.IFEQ:\n+            case ByteCode.IFGE:\n+            case ByteCode.IFGT:\n+            case ByteCode.IFLE:\n+            case ByteCode.IFLT:\n+            case ByteCode.IFNE:\n+            case ByteCode.IFNONNULL:\n+            case ByteCode.IFNULL:\n+            case ByteCode.IF_ACMPEQ:\n+            case ByteCode.IF_ACMPNE:\n+            case ByteCode.IF_ICMPEQ:\n+            case ByteCode.IF_ICMPGE:\n+            case ByteCode.IF_ICMPGT:\n+            case ByteCode.IF_ICMPLE:\n+            case ByteCode.IF_ICMPLT:\n+            case ByteCode.IF_ICMPNE:\n+            case ByteCode.IINC:\n+            case ByteCode.INSTANCEOF:\n+            case ByteCode.INVOKEINTERFACE:\n+            case ByteCode.INVOKESPECIAL:\n+            case ByteCode.INVOKESTATIC:\n+            case ByteCode.INVOKEVIRTUAL:\n+            case ByteCode.JSR:\n+            case ByteCode.LDC2_W:\n+            case ByteCode.LDC_W:\n+            case ByteCode.NEW:\n+            case ByteCode.PUTFIELD:\n+            case ByteCode.PUTSTATIC:\n+            case ByteCode.SIPUSH:\n+                return 2;\n+\n+            case ByteCode.MULTIANEWARRAY:\n+                return 3;\n+\n+            case ByteCode.GOTO_W:\n+            case ByteCode.JSR_W:\n+                return 4;\n+\n+            case ByteCode.LOOKUPSWITCH:    // depends on alignment\n+            case ByteCode.TABLESWITCH: // depends on alignment\n+                return -1;\n+        }\n+        throw new IllegalArgumentException(\"Bad opcode: \"+opcode);\n+    }\n+*/\n+    private static String bytecodeStr(int code)\n+    {\n+        if (DEBUGSTACK || DEBUGCODE) {\n+            switch (code) {\n+                case ByteCode.NOP:              return \"nop\";\n+                case ByteCode.ACONST_NULL:      return \"aconst_null\";\n+                case ByteCode.ICONST_M1:        return \"iconst_m1\";\n+                case ByteCode.ICONST_0:         return \"iconst_0\";\n+                case ByteCode.ICONST_1:         return \"iconst_1\";\n+                case ByteCode.ICONST_2:         return \"iconst_2\";\n+                case ByteCode.ICONST_3:         return \"iconst_3\";\n+                case ByteCode.ICONST_4:         return \"iconst_4\";\n+                case ByteCode.ICONST_5:         return \"iconst_5\";\n+                case ByteCode.LCONST_0:         return \"lconst_0\";\n+                case ByteCode.LCONST_1:         return \"lconst_1\";\n+                case ByteCode.FCONST_0:         return \"fconst_0\";\n+                case ByteCode.FCONST_1:         return \"fconst_1\";\n+                case ByteCode.FCONST_2:         return \"fconst_2\";\n+                case ByteCode.DCONST_0:         return \"dconst_0\";\n+                case ByteCode.DCONST_1:         return \"dconst_1\";\n+                case ByteCode.BIPUSH:           return \"bipush\";\n+                case ByteCode.SIPUSH:           return \"sipush\";\n+                case ByteCode.LDC:              return \"ldc\";\n+                case ByteCode.LDC_W:            return \"ldc_w\";\n+                case ByteCode.LDC2_W:           return \"ldc2_w\";\n+                case ByteCode.ILOAD:            return \"iload\";\n+                case ByteCode.LLOAD:            return \"lload\";\n+                case ByteCode.FLOAD:            return \"fload\";\n+                case ByteCode.DLOAD:            return \"dload\";\n+                case ByteCode.ALOAD:            return \"aload\";\n+                case ByteCode.ILOAD_0:          return \"iload_0\";\n+                case ByteCode.ILOAD_1:          return \"iload_1\";\n+                case ByteCode.ILOAD_2:          return \"iload_2\";\n+                case ByteCode.ILOAD_3:          return \"iload_3\";\n+                case ByteCode.LLOAD_0:          return \"lload_0\";\n+                case ByteCode.LLOAD_1:          return \"lload_1\";\n+                case ByteCode.LLOAD_2:          return \"lload_2\";\n+                case ByteCode.LLOAD_3:          return \"lload_3\";\n+                case ByteCode.FLOAD_0:          return \"fload_0\";\n+                case ByteCode.FLOAD_1:          return \"fload_1\";\n+                case ByteCode.FLOAD_2:          return \"fload_2\";\n+                case ByteCode.FLOAD_3:          return \"fload_3\";\n+                case ByteCode.DLOAD_0:          return \"dload_0\";\n+                case ByteCode.DLOAD_1:          return \"dload_1\";\n+                case ByteCode.DLOAD_2:          return \"dload_2\";\n+                case ByteCode.DLOAD_3:          return \"dload_3\";\n+                case ByteCode.ALOAD_0:          return \"aload_0\";\n+                case ByteCode.ALOAD_1:          return \"aload_1\";\n+                case ByteCode.ALOAD_2:          return \"aload_2\";\n+                case ByteCode.ALOAD_3:          return \"aload_3\";\n+                case ByteCode.IALOAD:           return \"iaload\";\n+                case ByteCode.LALOAD:           return \"laload\";\n+                case ByteCode.FALOAD:           return \"faload\";\n+                case ByteCode.DALOAD:           return \"daload\";\n+                case ByteCode.AALOAD:           return \"aaload\";\n+                case ByteCode.BALOAD:           return \"baload\";\n+                case ByteCode.CALOAD:           return \"caload\";\n+                case ByteCode.SALOAD:           return \"saload\";\n+                case ByteCode.ISTORE:           return \"istore\";\n+                case ByteCode.LSTORE:           return \"lstore\";\n+                case ByteCode.FSTORE:           return \"fstore\";\n+                case ByteCode.DSTORE:           return \"dstore\";\n+                case ByteCode.ASTORE:           return \"astore\";\n+                case ByteCode.ISTORE_0:         return \"istore_0\";\n+                case ByteCode.ISTORE_1:         return \"istore_1\";\n+                case ByteCode.ISTORE_2:         return \"istore_2\";\n+                case ByteCode.ISTORE_3:         return \"istore_3\";\n+                case ByteCode.LSTORE_0:         return \"lstore_0\";\n+                case ByteCode.LSTORE_1:         return \"lstore_1\";\n+                case ByteCode.LSTORE_2:         return \"lstore_2\";\n+                case ByteCode.LSTORE_3:         return \"lstore_3\";\n+                case ByteCode.FSTORE_0:         return \"fstore_0\";\n+                case ByteCode.FSTORE_1:         return \"fstore_1\";\n+                case ByteCode.FSTORE_2:         return \"fstore_2\";\n+                case ByteCode.FSTORE_3:         return \"fstore_3\";\n+                case ByteCode.DSTORE_0:         return \"dstore_0\";\n+                case ByteCode.DSTORE_1:         return \"dstore_1\";\n+                case ByteCode.DSTORE_2:         return \"dstore_2\";\n+                case ByteCode.DSTORE_3:         return \"dstore_3\";\n+                case ByteCode.ASTORE_0:         return \"astore_0\";\n+                case ByteCode.ASTORE_1:         return \"astore_1\";\n+                case ByteCode.ASTORE_2:         return \"astore_2\";\n+                case ByteCode.ASTORE_3:         return \"astore_3\";\n+                case ByteCode.IASTORE:          return \"iastore\";\n+                case ByteCode.LASTORE:          return \"lastore\";\n+                case ByteCode.FASTORE:          return \"fastore\";\n+                case ByteCode.DASTORE:          return \"dastore\";\n+                case ByteCode.AASTORE:          return \"aastore\";\n+                case ByteCode.BASTORE:          return \"bastore\";\n+                case ByteCode.CASTORE:          return \"castore\";\n+                case ByteCode.SASTORE:          return \"sastore\";\n+                case ByteCode.POP:              return \"pop\";\n+                case ByteCode.POP2:             return \"pop2\";\n+                case ByteCode.DUP:              return \"dup\";\n+                case ByteCode.DUP_X1:           return \"dup_x1\";\n+                case ByteCode.DUP_X2:           return \"dup_x2\";\n+                case ByteCode.DUP2:             return \"dup2\";\n+                case ByteCode.DUP2_X1:          return \"dup2_x1\";\n+                case ByteCode.DUP2_X2:          return \"dup2_x2\";\n+                case ByteCode.SWAP:             return \"swap\";\n+                case ByteCode.IADD:             return \"iadd\";\n+                case ByteCode.LADD:             return \"ladd\";\n+                case ByteCode.FADD:             return \"fadd\";\n+                case ByteCode.DADD:             return \"dadd\";\n+                case ByteCode.ISUB:             return \"isub\";\n+                case ByteCode.LSUB:             return \"lsub\";\n+                case ByteCode.FSUB:             return \"fsub\";\n+                case ByteCode.DSUB:             return \"dsub\";\n+                case ByteCode.IMUL:             return \"imul\";\n+                case ByteCode.LMUL:             return \"lmul\";\n+                case ByteCode.FMUL:             return \"fmul\";\n+                case ByteCode.DMUL:             return \"dmul\";\n+                case ByteCode.IDIV:             return \"idiv\";\n+                case ByteCode.LDIV:             return \"ldiv\";\n+                case ByteCode.FDIV:             return \"fdiv\";\n+                case ByteCode.DDIV:             return \"ddiv\";\n+                case ByteCode.IREM:             return \"irem\";\n+                case ByteCode.LREM:             return \"lrem\";\n+                case ByteCode.FREM:             return \"frem\";\n+                case ByteCode.DREM:             return \"drem\";\n+                case ByteCode.INEG:             return \"ineg\";\n+                case ByteCode.LNEG:             return \"lneg\";\n+                case ByteCode.FNEG:             return \"fneg\";\n+                case ByteCode.DNEG:             return \"dneg\";\n+                case ByteCode.ISHL:             return \"ishl\";\n+                case ByteCode.LSHL:             return \"lshl\";\n+                case ByteCode.ISHR:             return \"ishr\";\n+                case ByteCode.LSHR:             return \"lshr\";\n+                case ByteCode.IUSHR:            return \"iushr\";\n+                case ByteCode.LUSHR:            return \"lushr\";\n+                case ByteCode.IAND:             return \"iand\";\n+                case ByteCode.LAND:             return \"land\";\n+                case ByteCode.IOR:              return \"ior\";\n+                case ByteCode.LOR:              return \"lor\";\n+                case ByteCode.IXOR:             return \"ixor\";\n+                case ByteCode.LXOR:             return \"lxor\";\n+                case ByteCode.IINC:             return \"iinc\";\n+                case ByteCode.I2L:              return \"i2l\";\n+                case ByteCode.I2F:              return \"i2f\";\n+                case ByteCode.I2D:              return \"i2d\";\n+                case ByteCode.L2I:              return \"l2i\";\n+                case ByteCode.L2F:              return \"l2f\";\n+                case ByteCode.L2D:              return \"l2d\";\n+                case ByteCode.F2I:              return \"f2i\";\n+                case ByteCode.F2L:              return \"f2l\";\n+                case ByteCode.F2D:              return \"f2d\";\n+                case ByteCode.D2I:              return \"d2i\";\n+                case ByteCode.D2L:              return \"d2l\";\n+                case ByteCode.D2F:              return \"d2f\";\n+                case ByteCode.I2B:              return \"i2b\";\n+                case ByteCode.I2C:              return \"i2c\";\n+                case ByteCode.I2S:              return \"i2s\";\n+                case ByteCode.LCMP:             return \"lcmp\";\n+                case ByteCode.FCMPL:            return \"fcmpl\";\n+                case ByteCode.FCMPG:            return \"fcmpg\";\n+                case ByteCode.DCMPL:            return \"dcmpl\";\n+                case ByteCode.DCMPG:            return \"dcmpg\";\n+                case ByteCode.IFEQ:             return \"ifeq\";\n+                case ByteCode.IFNE:             return \"ifne\";\n+                case ByteCode.IFLT:             return \"iflt\";\n+                case ByteCode.IFGE:             return \"ifge\";\n+                case ByteCode.IFGT:             return \"ifgt\";\n+                case ByteCode.IFLE:             return \"ifle\";\n+                case ByteCode.IF_ICMPEQ:        return \"if_icmpeq\";\n+                case ByteCode.IF_ICMPNE:        return \"if_icmpne\";\n+                case ByteCode.IF_ICMPLT:        return \"if_icmplt\";\n+                case ByteCode.IF_ICMPGE:        return \"if_icmpge\";\n+                case ByteCode.IF_ICMPGT:        return \"if_icmpgt\";\n+                case ByteCode.IF_ICMPLE:        return \"if_icmple\";\n+                case ByteCode.IF_ACMPEQ:        return \"if_acmpeq\";\n+                case ByteCode.IF_ACMPNE:        return \"if_acmpne\";\n+                case ByteCode.GOTO:             return \"goto\";\n+                case ByteCode.JSR:              return \"jsr\";\n+                case ByteCode.RET:              return \"ret\";\n+                case ByteCode.TABLESWITCH:      return \"tableswitch\";\n+                case ByteCode.LOOKUPSWITCH:     return \"lookupswitch\";\n+                case ByteCode.IRETURN:          return \"ireturn\";\n+                case ByteCode.LRETURN:          return \"lreturn\";\n+                case ByteCode.FRETURN:          return \"freturn\";\n+                case ByteCode.DRETURN:          return \"dreturn\";\n+                case ByteCode.ARETURN:          return \"areturn\";\n+                case ByteCode.RETURN:           return \"return\";\n+                case ByteCode.GETSTATIC:        return \"getstatic\";\n+                case ByteCode.PUTSTATIC:        return \"putstatic\";\n+                case ByteCode.GETFIELD:         return \"getfield\";\n+                case ByteCode.PUTFIELD:         return \"putfield\";\n+                case ByteCode.INVOKEVIRTUAL:    return \"invokevirtual\";\n+                case ByteCode.INVOKESPECIAL:    return \"invokespecial\";\n+                case ByteCode.INVOKESTATIC:     return \"invokestatic\";\n+                case ByteCode.INVOKEINTERFACE:  return \"invokeinterface\";\n+                case ByteCode.NEW:              return \"new\";\n+                case ByteCode.NEWARRAY:         return \"newarray\";\n+                case ByteCode.ANEWARRAY:        return \"anewarray\";\n+                case ByteCode.ARRAYLENGTH:      return \"arraylength\";\n+                case ByteCode.ATHROW:           return \"athrow\";\n+                case ByteCode.CHECKCAST:        return \"checkcast\";\n+                case ByteCode.INSTANCEOF:       return \"instanceof\";\n+                case ByteCode.MONITORENTER:     return \"monitorenter\";\n+                case ByteCode.MONITOREXIT:      return \"monitorexit\";\n+                case ByteCode.WIDE:             return \"wide\";\n+                case ByteCode.MULTIANEWARRAY:   return \"multianewarray\";\n+                case ByteCode.IFNULL:           return \"ifnull\";\n+                case ByteCode.IFNONNULL:        return \"ifnonnull\";\n+                case ByteCode.GOTO_W:           return \"goto_w\";\n+                case ByteCode.JSR_W:            return \"jsr_w\";\n+                case ByteCode.BREAKPOINT:       return \"breakpoint\";\n+\n+                case ByteCode.IMPDEP1:          return \"impdep1\";\n+                case ByteCode.IMPDEP2:          return \"impdep2\";\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    final char[] getCharBuffer(int minimalSize)\n+    {\n+        if (minimalSize > tmpCharBuffer.length) {\n+            int newSize = tmpCharBuffer.length * 2;\n+            if (minimalSize > newSize) { newSize = minimalSize; }\n+            tmpCharBuffer = new char[newSize];\n+        }\n+        return tmpCharBuffer;\n+    }\n+\n+    private static final int LineNumberTableSize = 16;\n+    private static final int ExceptionTableSize = 4;\n+\n+    private final static long FileHeaderConstant = 0xCAFEBABE0003002DL;\n+    // Set DEBUG flags to true to get better checking and progress info.\n+    private static final boolean DEBUGSTACK = false;\n+    private static final boolean DEBUGLABELS = false;\n+    private static final boolean DEBUGCODE = false;\n+\n+    private String generatedClassName;\n+\n+    private ExceptionTableEntry itsExceptionTable[];\n+    private int itsExceptionTableTop;\n+\n+    private int itsLineNumberTable[];   // pack start_pc & line_number together\n+    private int itsLineNumberTableTop;\n+\n+    private byte[] itsCodeBuffer = new byte[256];\n+    private int itsCodeBufferTop;\n+\n+    private ConstantPool itsConstantPool;\n+\n+    private ClassFileMethod itsCurrentMethod;\n+    private short itsStackTop;\n+\n+    private short itsMaxStack;\n+    private short itsMaxLocals;\n+\n+    private ObjArray itsMethods = new ObjArray();\n+    private ObjArray itsFields = new ObjArray();\n+    private ObjArray itsInterfaces = new ObjArray();\n+\n+    private short itsFlags;\n+    private short itsThisClassIndex;\n+    private short itsSuperClassIndex;\n+    private short itsSourceFileNameIndex;\n+\n+    private static final int MIN_LABEL_TABLE_SIZE = 32;\n+    private int[] itsLabelTable;\n+    private int itsLabelTableTop;\n+\n+// itsFixupTable[i] = (label_index << 32) | fixup_site\n+    private static final int MIN_FIXUP_TABLE_SIZE = 40;\n+    private long[] itsFixupTable;\n+    private int itsFixupTableTop;\n+    private ObjArray itsVarDescriptors;\n+\n+    private char[] tmpCharBuffer = new char[64];\n+}\n+\n+final class ExceptionTableEntry\n+{\n+\n+    ExceptionTableEntry(int startLabel, int endLabel,\n+                        int handlerLabel, short catchType)\n+    {\n+        itsStartLabel = startLabel;\n+        itsEndLabel = endLabel;\n+        itsHandlerLabel = handlerLabel;\n+        itsCatchType = catchType;\n+    }\n+\n+    int itsStartLabel;\n+    int itsEndLabel;\n+    int itsHandlerLabel;\n+    short itsCatchType;\n+}\n+\n+final class ClassFileField\n+{\n+\n+    ClassFileField(short nameIndex, short typeIndex, short flags)\n+    {\n+        itsNameIndex = nameIndex;\n+        itsTypeIndex = typeIndex;\n+        itsFlags = flags;\n+        itsHasAttributes = false;\n+    }\n+\n+    void setAttributes(short attr1, short attr2, short attr3, int index)\n+    {\n+        itsHasAttributes = true;\n+        itsAttr1 = attr1;\n+        itsAttr2 = attr2;\n+        itsAttr3 = attr3;\n+        itsIndex = index;\n+    }\n+\n+    int write(byte[] data, int offset)\n+    {\n+        offset = ClassFileWriter.putInt16(itsFlags, data, offset);\n+        offset = ClassFileWriter.putInt16(itsNameIndex, data, offset);\n+        offset = ClassFileWriter.putInt16(itsTypeIndex, data, offset);\n+        if (!itsHasAttributes) {\n+            // write 0 attributes\n+            offset = ClassFileWriter.putInt16(0, data, offset);\n+        } else {\n+            offset = ClassFileWriter.putInt16(1, data, offset);\n+            offset = ClassFileWriter.putInt16(itsAttr1, data, offset);\n+            offset = ClassFileWriter.putInt16(itsAttr2, data, offset);\n+            offset = ClassFileWriter.putInt16(itsAttr3, data, offset);\n+            offset = ClassFileWriter.putInt16(itsIndex, data, offset);\n+        }\n+        return offset;\n+    }\n+\n+    int getWriteSize()\n+    {\n+        int size = 2 * 3;\n+        if (!itsHasAttributes) {\n+            size += 2;\n+        } else {\n+            size += 2 + 2 * 4;\n+        }\n+        return size;\n+    }\n+\n+    private short itsNameIndex;\n+    private short itsTypeIndex;\n+    private short itsFlags;\n+    private boolean itsHasAttributes;\n+    private short itsAttr1, itsAttr2, itsAttr3;\n+    private int itsIndex;\n+}\n+\n+final class ClassFileMethod\n+{\n+\n+    ClassFileMethod(short nameIndex, short typeIndex, short flags)\n+    {\n+        itsNameIndex = nameIndex;\n+        itsTypeIndex = typeIndex;\n+        itsFlags = flags;\n+    }\n+\n+    void setCodeAttribute(byte codeAttribute[])\n+    {\n+        itsCodeAttribute = codeAttribute;\n+    }\n+\n+    int write(byte[] data, int offset)\n+    {\n+        offset = ClassFileWriter.putInt16(itsFlags, data, offset);\n+        offset = ClassFileWriter.putInt16(itsNameIndex, data, offset);\n+        offset = ClassFileWriter.putInt16(itsTypeIndex, data, offset);\n+        // Code attribute only\n+        offset = ClassFileWriter.putInt16(1, data, offset);\n+        System.arraycopy(itsCodeAttribute, 0, data, offset,\n+                         itsCodeAttribute.length);\n+        offset += itsCodeAttribute.length;\n+        return offset;\n+    }\n+\n+    int getWriteSize()\n+    {\n+        return 2 * 4 + itsCodeAttribute.length;\n+    }\n+\n+    private short itsNameIndex;\n+    private short itsTypeIndex;\n+    private short itsFlags;\n+    private byte[] itsCodeAttribute;\n+\n+}\n+\n+final class ConstantPool\n+{\n+\n+    ConstantPool(ClassFileWriter cfw)\n+    {\n+        this.cfw = cfw;\n+        itsTopIndex = 1;       // the zero'th entry is reserved\n+        itsPool = new byte[ConstantPoolSize];\n+        itsTop = 0;\n+    }\n+\n+    private static final int ConstantPoolSize = 256;\n+    private static final byte\n+        CONSTANT_Class = 7,\n+        CONSTANT_Fieldref = 9,\n+        CONSTANT_Methodref = 10,\n+        CONSTANT_InterfaceMethodref = 11,\n+        CONSTANT_String = 8,\n+        CONSTANT_Integer = 3,\n+        CONSTANT_Float = 4,\n+        CONSTANT_Long = 5,\n+        CONSTANT_Double = 6,\n+        CONSTANT_NameAndType = 12,\n+        CONSTANT_Utf8 = 1;\n+\n+    int write(byte[] data, int offset)\n+    {\n+        offset = ClassFileWriter.putInt16((short)itsTopIndex, data, offset);\n+        System.arraycopy(itsPool, 0, data, offset, itsTop);\n+        offset += itsTop;\n+        return offset;\n+    }\n+\n+    int getWriteSize()\n+    {\n+        return 2 + itsTop;\n+    }\n+\n+    int addConstant(int k)\n+    {\n+        ensure(5);\n+        itsPool[itsTop++] = CONSTANT_Integer;\n+        itsTop = ClassFileWriter.putInt32(k, itsPool, itsTop);\n+        return (short)(itsTopIndex++);\n+    }\n+\n+    int addConstant(long k)\n+    {\n+        ensure(9);\n+        itsPool[itsTop++] = CONSTANT_Long;\n+        itsTop = ClassFileWriter.putInt64(k, itsPool, itsTop);\n+        int index = itsTopIndex;\n+        itsTopIndex += 2;\n+        return index;\n+    }\n+\n+    int addConstant(float k)\n+    {\n+        ensure(5);\n+        itsPool[itsTop++] = CONSTANT_Float;\n+        int bits = Float.floatToIntBits(k);\n+        itsTop = ClassFileWriter.putInt32(bits, itsPool, itsTop);\n+        return itsTopIndex++;\n+    }\n+\n+    int addConstant(double k)\n+    {\n+        ensure(9);\n+        itsPool[itsTop++] = CONSTANT_Double;\n+        long bits = Double.doubleToLongBits(k);\n+        itsTop = ClassFileWriter.putInt64(bits, itsPool, itsTop);\n+        int index = itsTopIndex;\n+        itsTopIndex += 2;\n+        return index;\n+    }\n+\n+    int addConstant(String k)\n+    {\n+        int utf8Index = 0xFFFF & addUtf8(k);\n+        int theIndex = itsStringConstHash.getInt(utf8Index, -1);\n+        if (theIndex == -1) {\n+            theIndex = itsTopIndex++;\n+            ensure(3);\n+            itsPool[itsTop++] = CONSTANT_String;\n+            itsTop = ClassFileWriter.putInt16(utf8Index, itsPool, itsTop);\n+            itsStringConstHash.put(utf8Index, theIndex);\n+        }\n+        return theIndex;\n+    }\n+\n+    boolean isUnderUtfEncodingLimit(String s)\n+    {\n+        int strLen = s.length();\n+        if (strLen * 3 <= MAX_UTF_ENCODING_SIZE) {\n+            return true;\n+        } else if (strLen > MAX_UTF_ENCODING_SIZE) {\n+            return false;\n+        }\n+        return strLen == getUtfEncodingLimit(s, 0, strLen);\n+    }\n+\n+    /**\n+     * Get maximum i such that <tt>start <= i <= end</tt> and\n+     * <tt>s.substring(start, i)</tt> fits JVM UTF string encoding limit.\n+     */\n+    int getUtfEncodingLimit(String s, int start, int end)\n+    {\n+        if ((end - start) * 3 <= MAX_UTF_ENCODING_SIZE) {\n+            return end;\n+        }\n+        int limit = MAX_UTF_ENCODING_SIZE;\n+        for (int i = start; i != end; i++) {\n+            int c = s.charAt(i);\n+            if (0 != c && c <= 0x7F) {\n+                --limit;\n+            } else if (c < 0x7FF) {\n+                limit -= 2;\n+            } else {\n+                limit -= 3;\n+            }\n+            if (limit < 0) {\n+                return i;\n+            }\n+        }\n+        return end;\n+    }\n+\n+    short addUtf8(String k)\n+    {\n+        int theIndex = itsUtf8Hash.get(k, -1);\n+        if (theIndex == -1) {\n+            int strLen = k.length();\n+            boolean tooBigString;\n+            if (strLen > MAX_UTF_ENCODING_SIZE) {\n+                tooBigString = true;\n+            } else {\n+                tooBigString = false;\n+                // Ask for worst case scenario buffer when each char takes 3\n+                // bytes\n+                ensure(1 + 2 + strLen * 3);\n+                int top = itsTop;\n+\n+                itsPool[top++] = CONSTANT_Utf8;\n+                top += 2; // skip length\n+\n+                char[] chars = cfw.getCharBuffer(strLen);\n+                k.getChars(0, strLen, chars, 0);\n+\n+                for (int i = 0; i != strLen; i++) {\n+                    int c = chars[i];\n+                    if (c != 0 && c <= 0x7F) {\n+                        itsPool[top++] = (byte)c;\n+                    } else if (c > 0x7FF) {\n+                        itsPool[top++] = (byte)(0xE0 | (c >> 12));\n+                        itsPool[top++] = (byte)(0x80 | ((c >> 6) & 0x3F));\n+                        itsPool[top++] = (byte)(0x80 | (c & 0x3F));\n+                    } else {\n+                        itsPool[top++] = (byte)(0xC0 | (c >> 6));\n+                        itsPool[top++] = (byte)(0x80 | (c & 0x3F));\n+                    }\n+                }\n+\n+                int utfLen = top - (itsTop + 1 + 2);\n+                if (utfLen > MAX_UTF_ENCODING_SIZE) {\n+                    tooBigString = true;\n+                } else {\n+                    // Write back length\n+                    itsPool[itsTop + 1] = (byte)(utfLen >>> 8);\n+                    itsPool[itsTop + 2] = (byte)utfLen;\n+\n+                    itsTop = top;\n+                    theIndex = itsTopIndex++;\n+                    itsUtf8Hash.put(k, theIndex);\n+                }\n+            }\n+            if (tooBigString) {\n+                throw new IllegalArgumentException(\"Too big string\");\n+            }\n+        }\n+        return (short)theIndex;\n+    }\n+\n+    private short addNameAndType(String name, String type)\n+    {\n+        short nameIndex = addUtf8(name);\n+        short typeIndex = addUtf8(type);\n+        ensure(5);\n+        itsPool[itsTop++] = CONSTANT_NameAndType;\n+        itsTop = ClassFileWriter.putInt16(nameIndex, itsPool, itsTop);\n+        itsTop = ClassFileWriter.putInt16(typeIndex, itsPool, itsTop);\n+        return (short)(itsTopIndex++);\n+    }\n+\n+    short addClass(String className)\n+    {\n+        int theIndex = itsClassHash.get(className, -1);\n+        if (theIndex == -1) {\n+            String slashed = className;\n+            if (className.indexOf('.') > 0) {\n+                slashed = ClassFileWriter.getSlashedForm(className);\n+                theIndex = itsClassHash.get(slashed, -1);\n+                if (theIndex != -1) {\n+                    itsClassHash.put(className, theIndex);\n+                }\n+            }\n+            if (theIndex == -1) {\n+                int utf8Index = addUtf8(slashed);\n+                ensure(3);\n+                itsPool[itsTop++] = CONSTANT_Class;\n+                itsTop = ClassFileWriter.putInt16(utf8Index, itsPool, itsTop);\n+                theIndex = itsTopIndex++;\n+                itsClassHash.put(slashed, theIndex);\n+                if (className != slashed) {\n+                    itsClassHash.put(className, theIndex);\n+                }\n+            }\n+        }\n+        return (short)theIndex;\n+    }\n+\n+    short addFieldRef(String className, String fieldName, String fieldType)\n+    {\n+        FieldOrMethodRef ref = new FieldOrMethodRef(className, fieldName,\n+                                                    fieldType);\n+\n+        int theIndex = itsFieldRefHash.get(ref, -1);\n+        if (theIndex == -1) {\n+            short ntIndex = addNameAndType(fieldName, fieldType);\n+            short classIndex = addClass(className);\n+            ensure(5);\n+            itsPool[itsTop++] = CONSTANT_Fieldref;\n+            itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);\n+            itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);\n+            theIndex = itsTopIndex++;\n+            itsFieldRefHash.put(ref, theIndex);\n+        }\n+        return (short)theIndex;\n+    }\n+\n+    short addMethodRef(String className, String methodName,\n+                       String methodType)\n+    {\n+        FieldOrMethodRef ref = new FieldOrMethodRef(className, methodName,\n+                                                    methodType);\n+\n+        int theIndex = itsMethodRefHash.get(ref, -1);\n+        if (theIndex == -1) {\n+            short ntIndex = addNameAndType(methodName, methodType);\n+            short classIndex = addClass(className);\n+            ensure(5);\n+            itsPool[itsTop++] = CONSTANT_Methodref;\n+            itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);\n+            itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);\n+            theIndex = itsTopIndex++;\n+            itsMethodRefHash.put(ref, theIndex);\n+        }\n+        return (short)theIndex;\n+    }\n+\n+    short addInterfaceMethodRef(String className,\n+                                String methodName, String methodType)\n+    {\n+        short ntIndex = addNameAndType(methodName, methodType);\n+        short classIndex = addClass(className);\n+        ensure(5);\n+        itsPool[itsTop++] = CONSTANT_InterfaceMethodref;\n+        itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);\n+        itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);\n+        return (short)(itsTopIndex++);\n+    }\n+\n+    void ensure(int howMuch)\n+    {\n+        if (itsTop + howMuch > itsPool.length) {\n+            int newCapacity = itsPool.length * 2;\n+            if (itsTop + howMuch > newCapacity) {\n+                newCapacity = itsTop + howMuch;\n+            }\n+            byte[] tmp = new byte[newCapacity];\n+            System.arraycopy(itsPool, 0, tmp, 0, itsTop);\n+            itsPool = tmp;\n+        }\n+    }\n+\n+    private ClassFileWriter cfw;\n+\n+    private static final int MAX_UTF_ENCODING_SIZE = 65535;\n+\n+    private UintMap itsStringConstHash = new UintMap();\n+    private ObjToIntMap itsUtf8Hash = new ObjToIntMap();\n+    private ObjToIntMap itsFieldRefHash = new ObjToIntMap();\n+    private ObjToIntMap itsMethodRefHash = new ObjToIntMap();\n+    private ObjToIntMap itsClassHash = new ObjToIntMap();\n+\n+    private int itsTop;\n+    private int itsTopIndex;\n+    private byte itsPool[];\n+}\n+\n+final class FieldOrMethodRef\n+{\n+    FieldOrMethodRef(String className, String name, String type)\n+    {\n+        this.className = className;\n+        this.name = name;\n+        this.type = type;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj)\n+    {\n+        if (!(obj instanceof FieldOrMethodRef)) { return false; }\n+        FieldOrMethodRef x = (FieldOrMethodRef)obj;\n+        return className.equals(x.className)\n+            && name.equals(x.name)\n+            && type.equals(x.type);\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        if (hashCode == -1) {\n+            int h1 = className.hashCode();\n+            int h2 = name.hashCode();\n+            int h3 = type.hashCode();\n+            hashCode = h1 ^ h2 ^ h3;\n+        }\n+        return hashCode;\n+    }\n+\n+    private String className;\n+    private String name;\n+    private String type;\n+    private int hashCode = -1;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Arguments.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class implements the \"arguments\" object.\n+ *\n+ * See ECMA 10.1.8\n+ *\n+ * @see org.mozilla.javascript.NativeCall\n+ */\n+final class Arguments extends IdScriptableObject\n+{\n+    static final long serialVersionUID = 4275508002492040609L;\n+\n+    public Arguments(NativeCall activation)\n+    {\n+        this.activation = activation;\n+\n+        Scriptable parent = activation.getParentScope();\n+        setParentScope(parent);\n+        setPrototype(ScriptableObject.getObjectPrototype(parent));\n+\n+        args = activation.originalArgs;\n+        lengthObj = Integer.valueOf(args.length);\n+\n+        NativeFunction f = activation.function;\n+        calleeObj = f;\n+\n+        int version = f.getLanguageVersion();\n+        if (version <= Context.VERSION_1_3\n+            && version != Context.VERSION_DEFAULT)\n+        {\n+            callerObj = null;\n+        } else {\n+            callerObj = NOT_FOUND;\n+        }\n+    }\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"Object\";\n+    }\n+\n+    @Override\n+    public boolean has(int index, Scriptable start)\n+    {\n+        if (0 <= index && index < args.length) {\n+            if (args[index] != NOT_FOUND) {\n+                return true;\n+            }\n+        }\n+        return super.has(index, start);\n+    }\n+\n+    @Override\n+    public Object get(int index, Scriptable start)\n+    {\n+        if (0 <= index && index < args.length) {\n+            Object value = args[index];\n+            if (value != NOT_FOUND) {\n+                if (sharedWithActivation(index)) {\n+                    NativeFunction f = activation.function;\n+                    String argName = f.getParamOrVarName(index);\n+                    value = activation.get(argName, activation);\n+                    if (value == NOT_FOUND) Kit.codeBug();\n+                }\n+                return value;\n+            }\n+        }\n+        return super.get(index, start);\n+    }\n+\n+    private boolean sharedWithActivation(int index)\n+    {\n+        NativeFunction f = activation.function;\n+        int definedCount = f.getParamCount();\n+        if (index < definedCount) {\n+            // Check if argument is not hidden by later argument with the same\n+            // name as hidden arguments are not shared with activation\n+            if (index < definedCount - 1) {\n+                String argName = f.getParamOrVarName(index);\n+                for (int i = index + 1; i < definedCount; i++) {\n+                    if (argName.equals(f.getParamOrVarName(i))) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void put(int index, Scriptable start, Object value)\n+    {\n+        if (0 <= index && index < args.length) {\n+            if (args[index] != NOT_FOUND) {\n+                if (sharedWithActivation(index)) {\n+                    String argName;\n+                    argName = activation.function.getParamOrVarName(index);\n+                    activation.put(argName, activation, value);\n+                    return;\n+                }\n+                synchronized (this) {\n+                    if (args[index] != NOT_FOUND) {\n+                        if (args == activation.originalArgs) {\n+                            args = args.clone();\n+                        }\n+                        args[index] = value;\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+        super.put(index, start, value);\n+    }\n+\n+    @Override\n+    public void delete(int index)\n+    {\n+        if (0 <= index && index < args.length) {\n+            synchronized (this) {\n+                if (args[index] != NOT_FOUND) {\n+                    if (args == activation.originalArgs) {\n+                        args = args.clone();\n+                    }\n+                    args[index] = NOT_FOUND;\n+                    return;\n+                }\n+            }\n+        }\n+        super.delete(index);\n+    }\n+\n+// #string_id_map#\n+\n+    private static final int\n+        Id_callee           = 1,\n+        Id_length           = 2,\n+        Id_caller           = 3,\n+\n+        MAX_INSTANCE_ID     = 3;\n+\n+    @Override\n+    protected int getMaxInstanceId()\n+    {\n+        return MAX_INSTANCE_ID;\n+    }\n+\n+    @Override\n+    protected int findInstanceIdInfo(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-05-09 08:15:04 EDT\n+        L0: { id = 0; String X = null; int c;\n+            if (s.length()==6) {\n+                c=s.charAt(5);\n+                if (c=='e') { X=\"callee\";id=Id_callee; }\n+                else if (c=='h') { X=\"length\";id=Id_length; }\n+                else if (c=='r') { X=\"caller\";id=Id_caller; }\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+\n+        if (id == 0) return super.findInstanceIdInfo(s);\n+\n+        int attr;\n+        switch (id) {\n+          case Id_callee:\n+          case Id_caller:\n+          case Id_length:\n+            attr = DONTENUM;\n+            break;\n+          default: throw new IllegalStateException();\n+        }\n+        return instanceIdInfo(attr, id);\n+    }\n+\n+// #/string_id_map#\n+\n+    @Override\n+    protected String getInstanceIdName(int id)\n+    {\n+        switch (id) {\n+            case Id_callee: return \"callee\";\n+            case Id_length: return \"length\";\n+            case Id_caller: return \"caller\";\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        switch (id) {\n+            case Id_callee: return calleeObj;\n+            case Id_length: return lengthObj;\n+            case Id_caller: {\n+                Object value = callerObj;\n+                if (value == UniqueTag.NULL_VALUE) { value = null; }\n+                else if (value == null) {\n+                    NativeCall caller = activation.parentActivationCall;\n+                    if (caller != null) {\n+                        value = caller.get(\"arguments\", caller);\n+                    }\n+                }\n+                return value;\n+            }\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+    @Override\n+    protected void setInstanceIdValue(int id, Object value)\n+    {\n+        switch (id) {\n+            case Id_callee: calleeObj = value; return;\n+            case Id_length: lengthObj = value; return;\n+            case Id_caller:\n+                callerObj = (value != null) ? value : UniqueTag.NULL_VALUE;\n+                return;\n+        }\n+        super.setInstanceIdValue(id, value);\n+    }\n+\n+    @Override\n+    Object[] getIds(boolean getAll)\n+    {\n+        Object[] ids = super.getIds(getAll);\n+        if (getAll && args.length != 0) {\n+            boolean[] present = null;\n+            int extraCount = args.length;\n+            for (int i = 0; i != ids.length; ++i) {\n+                Object id = ids[i];\n+                if (id instanceof Integer) {\n+                    int index = ((Integer)id).intValue();\n+                    if (0 <= index && index < args.length) {\n+                        if (present == null) {\n+                            present = new boolean[args.length];\n+                        }\n+                        if (!present[index]) {\n+                            present[index] = true;\n+                            extraCount--;\n+                        }\n+                    }\n+                }\n+            }\n+            if (extraCount != 0) {\n+                Object[] tmp = new Object[extraCount + ids.length];\n+                System.arraycopy(ids, 0, tmp, extraCount, ids.length);\n+                ids = tmp;\n+                int offset = 0;\n+                for (int i = 0; i != args.length; ++i) {\n+                    if (present == null || !present[i]) {\n+                        ids[offset] = Integer.valueOf(i);\n+                        ++offset;\n+                    }\n+                }\n+                if (offset != extraCount) Kit.codeBug();\n+            }\n+        }\n+        return ids;\n+    }\n+\n+// Fields to hold caller, callee and length properties,\n+// where NOT_FOUND value tags deleted properties.\n+// In addition if callerObj == NULL_VALUE, it tags null for scripts, as\n+// initial callerObj == null means access to caller arguments available\n+// only in JS <= 1.3 scripts\n+    private Object callerObj;\n+    private Object calleeObj;\n+    private Object lengthObj;\n+\n+    private NativeCall activation;\n+\n+// Initially args holds activation.getOriginalArgs(), but any modification\n+// of its elements triggers creation of a copy. If its element holds NOT_FOUND,\n+// it indicates deleted index, in which case super class is queried.\n+    private Object[] args;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/BaseFunction.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Roger Lawrence\n+ *   Mike McCabe\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * The base class for Function objects\n+ * See ECMA 15.3.\n+ */\n+public class BaseFunction extends IdScriptableObject implements Function\n+{\n+\n+    static final long serialVersionUID = 5311394446546053859L;\n+\n+    private static final Object FUNCTION_TAG = \"Function\";\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        BaseFunction obj = new BaseFunction();\n+        // Function.prototype attributes: see ECMA 15.3.3.1\n+        obj.prototypePropertyAttributes = DONTENUM | READONLY | PERMANENT;\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    public BaseFunction()\n+    {\n+    }\n+\n+    public BaseFunction(Scriptable scope, Scriptable prototype)\n+    {\n+        super(scope, prototype);\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return \"Function\";\n+    }\n+\n+    /**\n+     * Gets the value returned by calling the typeof operator on this object.\n+     * @see org.mozilla.javascript.ScriptableObject#getTypeOf()\n+     * @return \"function\" or \"undefined\" if {@link #avoidObjectDetection()} returns <code>true</code>\n+     */\n+    @Override\n+    public String getTypeOf()\n+    {\n+    \treturn avoidObjectDetection() ? \"undefined\" : \"function\";\n+    }\n+\n+    /**\n+     * Implements the instanceof operator for JavaScript Function objects.\n+     * <p>\n+     * <code>\n+     * foo = new Foo();<br>\n+     * foo instanceof Foo;  // true<br>\n+     * </code>\n+     *\n+     * @param instance The value that appeared on the LHS of the instanceof\n+     *              operator\n+     * @return true if the \"prototype\" property of \"this\" appears in\n+     *              value's prototype chain\n+     *\n+     */\n+    @Override\n+    public boolean hasInstance(Scriptable instance)\n+    {\n+        Object protoProp = ScriptableObject.getProperty(this, \"prototype\");\n+        if (protoProp instanceof Scriptable) {\n+            return ScriptRuntime.jsDelegatesTo(instance, (Scriptable)protoProp);\n+        }\n+        throw ScriptRuntime.typeError1(\"msg.instanceof.bad.prototype\",\n+                                       getFunctionName());\n+    }\n+\n+// #string_id_map#\n+\n+    private static final int\n+        Id_length       = 1,\n+        Id_arity        = 2,\n+        Id_name         = 3,\n+        Id_prototype    = 4,\n+        Id_arguments    = 5,\n+\n+        MAX_INSTANCE_ID = 5;\n+\n+    @Override\n+    protected int getMaxInstanceId()\n+    {\n+        return MAX_INSTANCE_ID;\n+    }\n+\n+    @Override\n+    protected int findInstanceIdInfo(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-05-09 08:15:15 EDT\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 4: X=\"name\";id=Id_name; break L;\n+            case 5: X=\"arity\";id=Id_arity; break L;\n+            case 6: X=\"length\";id=Id_length; break L;\n+            case 9: c=s.charAt(0);\n+                if (c=='a') { X=\"arguments\";id=Id_arguments; }\n+                else if (c=='p') { X=\"prototype\";id=Id_prototype; }\n+                break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+// #/string_id_map#\n+\n+        if (id == 0) return super.findInstanceIdInfo(s);\n+\n+        int attr;\n+        switch (id) {\n+          case Id_length:\n+          case Id_arity:\n+          case Id_name:\n+            attr = DONTENUM | READONLY | PERMANENT;\n+            break;\n+          case Id_prototype:\n+            attr = prototypePropertyAttributes;\n+            break;\n+          case Id_arguments:\n+            attr = DONTENUM | PERMANENT;\n+            break;\n+          default: throw new IllegalStateException();\n+        }\n+        return instanceIdInfo(attr, id);\n+    }\n+\n+    @Override\n+    protected String getInstanceIdName(int id)\n+    {\n+        switch (id) {\n+            case Id_length:       return \"length\";\n+            case Id_arity:        return \"arity\";\n+            case Id_name:         return \"name\";\n+            case Id_prototype:    return \"prototype\";\n+            case Id_arguments:    return \"arguments\";\n+        }\n+        return super.getInstanceIdName(id);\n+    }\n+\n+    @Override\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        switch (id) {\n+          case Id_length:    return ScriptRuntime.wrapInt(getLength());\n+          case Id_arity:     return ScriptRuntime.wrapInt(getArity());\n+          case Id_name:      return getFunctionName();\n+          case Id_prototype: return getPrototypeProperty();\n+          case Id_arguments: return getArguments();\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+    @Override\n+    protected void setInstanceIdValue(int id, Object value)\n+    {\n+        if (id == Id_prototype) {\n+            if ((prototypePropertyAttributes & READONLY) == 0) {\n+                prototypeProperty = (value != null)\n+                                    ? value : UniqueTag.NULL_VALUE;\n+            }\n+            return;\n+        } else if (id == Id_arguments) {\n+            if (value == NOT_FOUND) {\n+                // This should not be called since \"arguments\" is PERMANENT\n+                Kit.codeBug();\n+            }\n+            defaultPut(\"arguments\", value);\n+        }\n+        super.setInstanceIdValue(id, value);\n+    }\n+\n+    @Override\n+    protected void fillConstructorProperties(IdFunctionObject ctor)\n+    {\n+        // Fix up bootstrapping problem: getPrototype of the IdFunctionObject\n+        // can not return Function.prototype because Function object is not\n+        // yet defined.\n+        ctor.setPrototype(this);\n+        super.fillConstructorProperties(ctor);\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor: arity=1; s=\"constructor\"; break;\n+          case Id_toString:    arity=1; s=\"toString\";    break;\n+          case Id_toSource:    arity=1; s=\"toSource\";    break;\n+          case Id_apply:       arity=2; s=\"apply\";       break;\n+          case Id_call:        arity=1; s=\"call\";        break;\n+          case Id_bind:        arity=1; s=\"bind\";        break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(FUNCTION_TAG, id, s, arity);\n+    }\n+\n+    static boolean isApply(IdFunctionObject f) {\n+        return f.hasTag(FUNCTION_TAG) && f.methodId() == Id_apply;\n+    }\n+\n+    static boolean isApplyOrCall(IdFunctionObject f) {\n+        if(f.hasTag(FUNCTION_TAG)) {\n+            switch(f.methodId()) {\n+                case Id_apply:\n+                case Id_call:\n+                    return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(FUNCTION_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_constructor:\n+            return jsConstructor(cx, scope, args);\n+\n+          case Id_toString: {\n+            BaseFunction realf = realFunction(thisObj, f);\n+            int indent = ScriptRuntime.toInt32(args, 0);\n+            return realf.decompile(indent, 0);\n+          }\n+\n+          case Id_toSource: {\n+            BaseFunction realf = realFunction(thisObj, f);\n+            int indent = 0;\n+            int flags = Decompiler.TO_SOURCE_FLAG;\n+            if (args.length != 0) {\n+                indent = ScriptRuntime.toInt32(args[0]);\n+                if (indent >= 0) {\n+                    flags = 0;\n+                } else {\n+                    indent = 0;\n+                }\n+            }\n+            return realf.decompile(indent, flags);\n+          }\n+\n+          case Id_apply:\n+          case Id_call:\n+            return ScriptRuntime.applyOrCall(id == Id_apply,\n+                                             cx, scope, thisObj, args);\n+\n+          case Id_bind:\n+            if ( !(thisObj instanceof Callable) ) {\n+              throw ScriptRuntime.notFunctionError(thisObj);\n+            }\n+            Callable targetFunction = (Callable) thisObj;\n+            int argc = args.length;\n+            final Scriptable boundThis;\n+            final Object[] boundArgs;\n+            if (argc > 0) {\n+              boundThis = ScriptRuntime.toObject(cx, scope, args[0]);\n+              boundArgs = new Object[argc-1];\n+              System.arraycopy(args, 1, boundArgs, 0, argc-1);\n+            } else {\n+              boundThis = ScriptRuntime.toObject(cx, scope, Undefined.instance);\n+              boundArgs = ScriptRuntime.emptyArgs;\n+            }\n+            return new BoundFunction(cx, scope, targetFunction, boundThis, boundArgs);\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private BaseFunction realFunction(Scriptable thisObj, IdFunctionObject f)\n+    {\n+        Object x = thisObj.getDefaultValue(ScriptRuntime.FunctionClass);\n+        if (x instanceof BaseFunction) {\n+            return (BaseFunction)x;\n+        }\n+        throw ScriptRuntime.typeError1(\"msg.incompat.call\",\n+                                       f.getFunctionName());\n+    }\n+\n+    /**\n+     * Make value as DontEnum, DontDelete, ReadOnly\n+     * prototype property of this Function object\n+     */\n+    public void setImmunePrototypeProperty(Object value)\n+    {\n+        if ((prototypePropertyAttributes & READONLY) != 0) {\n+            throw new IllegalStateException();\n+        }\n+        prototypeProperty = (value != null) ? value : UniqueTag.NULL_VALUE;\n+        prototypePropertyAttributes = DONTENUM | PERMANENT | READONLY;\n+    }\n+\n+    protected Scriptable getClassPrototype()\n+    {\n+        Object protoVal = getPrototypeProperty();\n+        if (protoVal instanceof Scriptable) {\n+            return (Scriptable) protoVal;\n+        }\n+        return getClassPrototype(this, \"Object\");\n+    }\n+\n+    /**\n+     * Should be overridden.\n+     */\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        return Undefined.instance;\n+    }\n+\n+    public Scriptable construct(Context cx, Scriptable scope, Object[] args)\n+    {\n+        Scriptable result = createObject(cx, scope);\n+        if (result != null) {\n+            Object val = call(cx, scope, result, args);\n+            if (val instanceof Scriptable) {\n+                result = (Scriptable)val;\n+            }\n+        } else {\n+            Object val = call(cx, scope, null, args);\n+            if (!(val instanceof Scriptable)) {\n+                // It is program error not to return Scriptable from\n+                // the call method if createObject returns null.\n+                throw new IllegalStateException(\n+                    \"Bad implementaion of call as constructor, name=\"\n+                    +getFunctionName()+\" in \"+getClass().getName());\n+            }\n+            result = (Scriptable)val;\n+            if (result.getPrototype() == null) {\n+                result.setPrototype(getClassPrototype());\n+            }\n+            if (result.getParentScope() == null) {\n+                Scriptable parent = getParentScope();\n+                if (result != parent) {\n+                    result.setParentScope(parent);\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Creates new script object.\n+     * The default implementation of {@link #construct} uses the method to\n+     * to get the value for <tt>thisObj</tt> argument when invoking\n+     * {@link #call}.\n+     * The methos is allowed to return <tt>null</tt> to indicate that\n+     * {@link #call} will create a new object itself. In this case\n+     * {@link #construct} will set scope and prototype on the result\n+     * {@link #call} unless they are already set.\n+     */\n+    public Scriptable createObject(Context cx, Scriptable scope)\n+    {\n+        Scriptable newInstance = new NativeObject();\n+        newInstance.setPrototype(getClassPrototype());\n+        newInstance.setParentScope(getParentScope());\n+        return newInstance;\n+    }\n+\n+    /**\n+     * Decompile the source information associated with this js\n+     * function/script back into a string.\n+     *\n+     * @param indent How much to indent the decompiled result.\n+     *\n+     * @param flags Flags specifying format of decompilation output.\n+     */\n+    String decompile(int indent, int flags)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        boolean justbody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));\n+        if (!justbody) {\n+            sb.append(\"function \");\n+            sb.append(getFunctionName());\n+            sb.append(\"() {\\n\\t\");\n+        }\n+        sb.append(\"[native code, arity=\");\n+        sb.append(getArity());\n+        sb.append(\"]\\n\");\n+        if (!justbody) {\n+            sb.append(\"}\\n\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    public int getArity() { return 0; }\n+\n+    public int getLength() { return 0; }\n+\n+    public String getFunctionName()\n+    {\n+        return \"\";\n+    }\n+\n+    final Object getPrototypeProperty() {\n+        Object result = prototypeProperty;\n+        if (result == null) {\n+            synchronized (this) {\n+                result = prototypeProperty;\n+                if (result == null) {\n+                    setupDefaultPrototype();\n+                    result = prototypeProperty;\n+                }\n+            }\n+        }\n+        else if (result == UniqueTag.NULL_VALUE) { result = null; }\n+        return result;\n+    }\n+\n+    private void setupDefaultPrototype()\n+    {\n+        NativeObject obj = new NativeObject();\n+        final int attr = ScriptableObject.DONTENUM;\n+        obj.defineProperty(\"constructor\", this, attr);\n+        // put the prototype property into the object now, then in the\n+        // wacky case of a user defining a function Object(), we don't\n+        // get an infinite loop trying to find the prototype.\n+        prototypeProperty = obj;\n+        Scriptable proto = getObjectPrototype(this);\n+        if (proto != obj) {\n+            // not the one we just made, it must remain grounded\n+            obj.setPrototype(proto);\n+        }\n+    }\n+\n+    private Object getArguments()\n+    {\n+      // <Function name>.arguments is deprecated, so we use a slow\n+      // way of getting it that doesn't add to the invocation cost.\n+      // TODO: add warning, error based on version\n+      Object value = defaultGet(\"arguments\");\n+      if (value != NOT_FOUND) {\n+          // Should after changing <Function name>.arguments its\n+          // activation still be available during Function call?\n+          // This code assumes it should not:\n+          // defaultGet(\"arguments\") != NOT_FOUND\n+          // means assigned arguments\n+          return value;\n+      }\n+      Context cx = Context.getContext();\n+      NativeCall activation = ScriptRuntime.findFunctionActivation(cx, this);\n+      return (activation == null)\n+             ? null\n+             : activation.get(\"arguments\", activation);\n+    }\n+\n+    private static Object jsConstructor(Context cx, Scriptable scope,\n+                                        Object[] args)\n+    {\n+        int arglen = args.length;\n+        StringBuffer sourceBuf = new StringBuffer();\n+\n+        sourceBuf.append(\"function \");\n+        /* version != 1.2 Function constructor behavior -\n+         * print 'anonymous' as the function name if the\n+         * version (under which the function was compiled) is\n+         * less than 1.2... or if it's greater than 1.2, because\n+         * we need to be closer to ECMA.\n+         */\n+        if (cx.getLanguageVersion() != Context.VERSION_1_2) {\n+            sourceBuf.append(\"anonymous\");\n+        }\n+        sourceBuf.append('(');\n+\n+        // Append arguments as coma separated strings\n+        for (int i = 0; i < arglen - 1; i++) {\n+            if (i > 0) {\n+                sourceBuf.append(',');\n+            }\n+            sourceBuf.append(ScriptRuntime.toString(args[i]));\n+        }\n+        sourceBuf.append(\") {\");\n+        if (arglen != 0) {\n+            // append function body\n+            String funBody = ScriptRuntime.toString(args[arglen - 1]);\n+            sourceBuf.append(funBody);\n+        }\n+        sourceBuf.append('}');\n+        String source = sourceBuf.toString();\n+\n+        int[] linep = new int[1];\n+        String filename = Context.getSourcePositionFromStack(linep);\n+        if (filename == null) {\n+            filename = \"<eval'ed string>\";\n+            linep[0] = 1;\n+        }\n+\n+        String sourceURI = ScriptRuntime.\n+            makeUrlForGeneratedScript(false, filename, linep[0]);\n+\n+        Scriptable global = ScriptableObject.getTopLevelScope(scope);\n+\n+        ErrorReporter reporter;\n+        reporter = DefaultErrorReporter.forEval(cx.getErrorReporter());\n+\n+        Evaluator evaluator = Context.createInterpreter();\n+        if (evaluator == null) {\n+            throw new JavaScriptException(\"Interpreter not present\",\n+                    filename, linep[0]);\n+        }\n+\n+        // Compile with explicit interpreter instance to force interpreter\n+        // mode.\n+        return cx.compileFunction(global, source, evaluator, reporter,\n+                                  sourceURI, 1, null);\n+    }\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #string_id_map#\n+// #generated# Last update: 2009-07-24 16:00:52 EST\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 4: c=s.charAt(0);\n+                if (c=='b') { X=\"bind\";id=Id_bind; }\n+                else if (c=='c') { X=\"call\";id=Id_call; }\n+                break L;\n+            case 5: X=\"apply\";id=Id_apply; break L;\n+            case 8: c=s.charAt(3);\n+                if (c=='o') { X=\"toSource\";id=Id_toSource; }\n+                else if (c=='t') { X=\"toString\";id=Id_toString; }\n+                break L;\n+            case 11: X=\"constructor\";id=Id_constructor; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_constructor    = 1,\n+        Id_toString       = 2,\n+        Id_toSource       = 3,\n+        Id_apply          = 4,\n+        Id_call           = 5,\n+        Id_bind           = 6,\n+\n+        MAX_PROTOTYPE_ID  = Id_bind;\n+\n+// #/string_id_map#\n+\n+    private Object prototypeProperty;\n+    // For function object instances, attributes are\n+    //  {configurable:false, enumerable:false};\n+    // see ECMA 15.3.5.2\n+    private int prototypePropertyAttributes = PERMANENT|DONTENUM;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/BoundFunction.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Raphael Speyer\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * The class for results of the Function.bind operation\n+ * EcmaScript 5 spec, 15.3.4.5\n+ */\n+public class BoundFunction extends BaseFunction {\n+  private final Callable targetFunction;\n+  private final Scriptable boundThis;\n+  private final Object[] boundArgs;\n+  private final int length;\n+\n+  public BoundFunction(Context cx, Scriptable scope, Callable targetFunction, Scriptable boundThis,\n+                       Object[] boundArgs)\n+  {\n+    this.targetFunction = targetFunction;\n+    this.boundThis = boundThis;\n+    this.boundArgs = boundArgs;\n+    if (targetFunction instanceof BaseFunction) {\n+      length = Math.max(0, ((BaseFunction) targetFunction).getLength() - boundArgs.length);\n+    } else {\n+      length = 0;\n+    }\n+\n+    ScriptRuntime.setFunctionProtoAndParent(this, scope);\n+\n+    Function thrower = ScriptRuntime.typeErrorThrower();\n+    NativeObject throwing = new NativeObject();\n+    throwing.put(\"get\", throwing, thrower);\n+    throwing.put(\"set\", throwing, thrower);\n+    throwing.put(\"enumerable\", throwing, false);\n+    throwing.put(\"configurable\", throwing, false);\n+    throwing.preventExtensions();\n+\n+    this.defineOwnProperty(cx, \"caller\", throwing);\n+    this.defineOwnProperty(cx, \"arguments\", throwing);\n+  }\n+\n+  @Override\n+  public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] extraArgs)\n+  {\n+    return targetFunction.call(cx, scope, boundThis, concat(boundArgs, extraArgs));\n+  }\n+\n+  @Override\n+  public Scriptable construct(Context cx, Scriptable scope, Object[] extraArgs) {\n+    if (targetFunction instanceof Function) {\n+      return ((Function) targetFunction).construct(cx, scope, concat(boundArgs, extraArgs));\n+    }\n+    throw ScriptRuntime.typeError0(\"msg.not.ctor\");\n+  }\n+\n+  @Override\n+  public boolean hasInstance(Scriptable instance) {\n+    if (targetFunction instanceof Function) {\n+      return ((Function) targetFunction).hasInstance(instance);\n+    }\n+    throw ScriptRuntime.typeError0(\"msg.not.ctor\");\n+  }\n+\n+  @Override\n+  public int getLength() {\n+    return length;\n+  }\n+\n+  private Object[] concat(Object[] first, Object[] second) {\n+    Object[] args = new Object[first.length + second.length];\n+    System.arraycopy(first, 0, args, 0, first.length);\n+    System.arraycopy(second, 0, args, first.length, second.length);\n+    return args;\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Callable.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov, igor@fastmail.fm\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Generic notion of callable object that can execute some script-related code\n+ * upon request with specified values for script scope and this objects.\n+ */\n+public interface Callable\n+{\n+    /**\n+     * Perform the call.\n+     *\n+     * @param cx the current Context for this thread\n+     * @param scope the scope to use to resolve properties.\n+     * @param thisObj the JavaScript <code>this</code> object\n+     * @param args the array of arguments\n+     * @return the result of the call\n+     */\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args);\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ClassCache.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov, igor@fastmail.fm\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.io.Serializable;\n+\n+/**\n+ * Cache of generated classes and data structures to access Java runtime\n+ * from JavaScript.\n+ *\n+ *\n+ * @since Rhino 1.5 Release 5\n+ */\n+public class ClassCache implements Serializable\n+{\n+    private static final long serialVersionUID = -8866246036237312215L;\n+    private static final Object AKEY = \"ClassCache\";\n+    private volatile boolean cachingIsEnabled = true;\n+    private transient HashMap<Class<?>,JavaMembers> classTable;\n+    private transient HashMap<JavaAdapter.JavaAdapterSignature,Class<?>> classAdapterCache;\n+    private transient HashMap<Class<?>,Object> interfaceAdapterCache;\n+    private int generatedClassSerial;\n+    private Scriptable associatedScope;\n+\n+    /**\n+     * Search for ClassCache object in the given scope.\n+     * The method first calls\n+     * {@link ScriptableObject#getTopLevelScope(Scriptable scope)}\n+     * to get the top most scope and then tries to locate associated\n+     * ClassCache object in the prototype chain of the top scope.\n+     *\n+     * @param scope scope to search for ClassCache object.\n+     * @return previously associated ClassCache object or a new instance of\n+     *         ClassCache if no ClassCache object was found.\n+     *\n+     * @see #associate(ScriptableObject topScope)\n+     */\n+    public static ClassCache get(Scriptable scope)\n+    {\n+        ClassCache cache = (ClassCache)\n+                ScriptableObject.getTopScopeValue(scope, AKEY);\n+        if (cache == null) {\n+            throw new RuntimeException(\"Can't find top level scope for \" +\n+                    \"ClassCache.get\");\n+        }\n+        return cache;\n+    }\n+\n+    /**\n+     * Associate ClassCache object with the given top-level scope.\n+     * The ClassCache object can only be associated with the given scope once.\n+     *\n+     * @param topScope scope to associate this ClassCache object with.\n+     * @return true if no previous ClassCache objects were embedded into\n+     *         the scope and this ClassCache were successfully associated\n+     *         or false otherwise.\n+     *\n+     * @see #get(Scriptable scope)\n+     */\n+    public boolean associate(ScriptableObject topScope)\n+    {\n+        if (topScope.getParentScope() != null) {\n+            // Can only associate cache with top level scope\n+            throw new IllegalArgumentException();\n+        }\n+        if (this == topScope.associateValue(AKEY, this)) {\n+            associatedScope = topScope;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Empty caches of generated Java classes and Java reflection information.\n+     */\n+    public synchronized void clearCaches()\n+    {\n+        classTable = null;\n+        classAdapterCache = null;\n+        interfaceAdapterCache = null;\n+    }\n+\n+    /**\n+     * Check if generated Java classes and Java reflection information\n+     * is cached.\n+     */\n+    public final boolean isCachingEnabled()\n+    {\n+        return cachingIsEnabled;\n+    }\n+\n+     /**\n+     * Set whether to cache some values.\n+     * <p>\n+     * By default, the engine will cache the results of\n+     * <tt>Class.getMethods()</tt> and similar calls.\n+     * This can speed execution dramatically, but increases the memory\n+     * footprint. Also, with caching enabled, references may be held to\n+     * objects past the lifetime of any real usage.\n+     * <p>\n+     * If caching is enabled and this method is called with a\n+     * <code>false</code> argument, the caches will be emptied.\n+     * <p>\n+     * Caching is enabled by default.\n+     *\n+     * @param enabled if true, caching is enabled\n+     *\n+     * @see #clearCaches()\n+     */\n+    public synchronized void setCachingEnabled(boolean enabled)\n+    {\n+        if (enabled == cachingIsEnabled)\n+            return;\n+        if (!enabled)\n+            clearCaches();\n+        cachingIsEnabled = enabled;\n+    }\n+\n+    /**\n+     * @return a map from classes to associated JavaMembers objects\n+     */\n+    Map<Class<?>,JavaMembers> getClassCacheMap() {\n+        if (classTable == null) {\n+            classTable = new HashMap<Class<?>,JavaMembers>();\n+        }\n+        return classTable;\n+    }\n+\n+    Map<JavaAdapter.JavaAdapterSignature,Class<?>> getInterfaceAdapterCacheMap()\n+    {\n+        if (classAdapterCache == null) {\n+            classAdapterCache = new HashMap<JavaAdapter.JavaAdapterSignature,Class<?>>();\n+        }\n+        return classAdapterCache;\n+    }\n+\n+    /**\n+     * @deprecated\n+     * The method always returns false.\n+     * @see #setInvokerOptimizationEnabled(boolean enabled)\n+     */\n+    public boolean isInvokerOptimizationEnabled()\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * @deprecated\n+     * The method does nothing.\n+     * Invoker optimization is no longer used by Rhino.\n+     * On modern JDK like 1.4 or 1.5 the disadvantages of the optimization\n+     * like increased memory usage or longer initialization time overweight\n+     * small speed increase that can be gained using generated proxy class\n+     * to replace reflection.\n+     */\n+    public synchronized void setInvokerOptimizationEnabled(boolean enabled)\n+    {\n+    }\n+\n+    /**\n+     * Internal engine method to return serial number for generated classes\n+     * to ensure name uniqueness.\n+     */\n+    public final synchronized int newClassSerialNumber()\n+    {\n+        return ++generatedClassSerial;\n+    }\n+\n+    Object getInterfaceAdapter(Class<?> cl)\n+    {\n+        return interfaceAdapterCache == null\n+                    ? null\n+                    : interfaceAdapterCache.get(cl);\n+    }\n+\n+    synchronized void cacheInterfaceAdapter(Class<?> cl, Object iadapter)\n+    {\n+        if (cachingIsEnabled) {\n+            if (interfaceAdapterCache == null) {\n+                interfaceAdapterCache = new HashMap<Class<?>,Object>();\n+            }\n+            interfaceAdapterCache.put(cl, iadapter);\n+        }\n+    }\n+\n+    Scriptable getAssociatedScope() {\n+        return associatedScope;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ClassShutter.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+Embeddings that wish to filter Java classes that are visible to scripts\n+through the LiveConnect, should implement this interface.\n+\n+@see Context#setClassShutter(ClassShutter)\n+@since 1.5 Release 4\n+@author Norris Boyd\n+*/\n+\n+ public interface ClassShutter {\n+\n+    /**\n+     * Return true iff the Java class with the given name should be exposed\n+     * to scripts.\n+     * <p>\n+     * An embedding may filter which Java classes are exposed through\n+     * LiveConnect to JavaScript scripts.\n+     * <p>\n+     * Due to the fact that there is no package reflection in Java,\n+     * this method will also be called with package names. There\n+     * is no way for Rhino to tell if \"Packages.a.b\" is a package name\n+     * or a class that doesn't exist. What Rhino does is attempt\n+     * to load each segment of \"Packages.a.b.c\": It first attempts to\n+     * load class \"a\", then attempts to load class \"a.b\", then\n+     * finally attempts to load class \"a.b.c\". On a Rhino installation\n+     * without any ClassShutter set, and without any of the\n+     * above classes, the expression \"Packages.a.b.c\" will result in\n+     * a [JavaPackage a.b.c] and not an error.\n+     * <p>\n+     * With ClassShutter supplied, Rhino will first call\n+     * visibleToScripts before attempting to look up the class name. If\n+     * visibleToScripts returns false, the class name lookup is not\n+     * performed and subsequent Rhino execution assumes the class is\n+     * not present. So for \"java.lang.System.out.println\" the lookup\n+     * of \"java.lang.System\" is skipped and thus Rhino assumes that\n+     * \"java.lang.System\" doesn't exist. So then for \"java.lang.System.out\",\n+     * Rhino attempts to load the class \"java.lang.System.out\" because\n+     * it assumes that \"java.lang.System\" is a package name.\n+     * <p>\n+     * @param fullClassName the full name of the class (including the package\n+     *                      name, with '.' as a delimiter). For example the\n+     *                      standard string class is \"java.lang.String\"\n+     * @return whether or not to reveal this class to scripts\n+     */\n+    public boolean visibleToScripts(String fullClassName);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/CodeGenerator.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Patrick Beard\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Ethan Hugg\n+ *   Bob Jervis\n+ *   Terry Lucas\n+ *   Roger Lawrence\n+ *   Milen Nankov\n+ *   Hannes Wallnoefer\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.javascript.ast.AstRoot;\n+import org.mozilla.javascript.ast.ScriptNode;\n+import org.mozilla.javascript.ast.Jump;\n+import org.mozilla.javascript.ast.FunctionNode;\n+\n+/**\n+ * Generates bytecode for the Interpreter.\n+ */\n+class CodeGenerator extends Icode {\n+\n+    private static final int MIN_LABEL_TABLE_SIZE = 32;\n+    private static final int MIN_FIXUP_TABLE_SIZE = 40;\n+\n+    private CompilerEnvirons compilerEnv;\n+\n+    private boolean itsInFunctionFlag;\n+    private boolean itsInTryFlag;\n+\n+    private InterpreterData itsData;\n+\n+    private ScriptNode scriptOrFn;\n+    private int iCodeTop;\n+    private int stackDepth;\n+    private int lineNumber;\n+    private int doubleTableTop;\n+\n+    private ObjToIntMap strings = new ObjToIntMap(20);\n+    private int localTop;\n+    private int[] labelTable;\n+    private int labelTableTop;\n+\n+    // fixupTable[i] = (label_index << 32) | fixup_site\n+    private long[] fixupTable;\n+    private int fixupTableTop;\n+    private ObjArray literalIds = new ObjArray();\n+\n+    private int exceptionTableTop;\n+\n+    // ECF_ or Expression Context Flags constants: for now only TAIL\n+    private static final int ECF_TAIL = 1 << 0;\n+\n+    public InterpreterData compile(CompilerEnvirons compilerEnv,\n+                                   ScriptNode tree,\n+                                   String encodedSource,\n+                                   boolean returnFunction)\n+    {\n+        this.compilerEnv = compilerEnv;\n+\n+        if (Token.printTrees) {\n+            System.out.println(\"before transform:\");\n+            System.out.println(tree.toStringTree(tree));\n+        }\n+\n+        new NodeTransformer().transform(tree);\n+\n+        if (Token.printTrees) {\n+            System.out.println(\"after transform:\");\n+            System.out.println(tree.toStringTree(tree));\n+        }\n+\n+        if (returnFunction) {\n+            scriptOrFn = tree.getFunctionNode(0);\n+        } else {\n+            scriptOrFn = tree;\n+        }\n+        itsData = new InterpreterData(compilerEnv.getLanguageVersion(),\n+                                      scriptOrFn.getSourceName(),\n+                                      encodedSource,\n+                                      ((AstRoot)tree).isInStrictMode());\n+        itsData.topLevel = true;\n+\n+        if (returnFunction) {\n+            generateFunctionICode();\n+        } else {\n+            generateICodeFromTree(scriptOrFn);\n+        }\n+        return itsData;\n+    }\n+\n+    private void generateFunctionICode()\n+    {\n+        itsInFunctionFlag = true;\n+\n+        FunctionNode theFunction = (FunctionNode)scriptOrFn;\n+\n+        itsData.itsFunctionType = theFunction.getFunctionType();\n+        itsData.itsNeedsActivation = theFunction.requiresActivation();\n+        if (theFunction.getFunctionName() != null) {\n+            itsData.itsName = theFunction.getName();\n+        }\n+        if (!theFunction.getIgnoreDynamicScope()) {\n+            if (compilerEnv.isUseDynamicScope()) {\n+                itsData.useDynamicScope = true;\n+            }\n+        }\n+        if (theFunction.isGenerator()) {\n+          addIcode(Icode_GENERATOR);\n+          addUint16(theFunction.getBaseLineno() & 0xFFFF);\n+        }\n+\n+        generateICodeFromTree(theFunction.getLastChild());\n+    }\n+\n+    private void generateICodeFromTree(Node tree)\n+    {\n+        generateNestedFunctions();\n+\n+        generateRegExpLiterals();\n+\n+        visitStatement(tree, 0);\n+        fixLabelGotos();\n+        // add RETURN_RESULT only to scripts as function always ends with RETURN\n+        if (itsData.itsFunctionType == 0) {\n+            addToken(Token.RETURN_RESULT);\n+        }\n+\n+        if (itsData.itsICode.length != iCodeTop) {\n+            // Make itsData.itsICode length exactly iCodeTop to save memory\n+            // and catch bugs with jumps beyond icode as early as possible\n+            byte[] tmp = new byte[iCodeTop];\n+            System.arraycopy(itsData.itsICode, 0, tmp, 0, iCodeTop);\n+            itsData.itsICode = tmp;\n+        }\n+        if (strings.size() == 0) {\n+            itsData.itsStringTable = null;\n+        } else {\n+            itsData.itsStringTable = new String[strings.size()];\n+            ObjToIntMap.Iterator iter = strings.newIterator();\n+            for (iter.start(); !iter.done(); iter.next()) {\n+                String str = (String)iter.getKey();\n+                int index = iter.getValue();\n+                if (itsData.itsStringTable[index] != null) Kit.codeBug();\n+                itsData.itsStringTable[index] = str;\n+            }\n+        }\n+        if (doubleTableTop == 0) {\n+            itsData.itsDoubleTable = null;\n+        } else if (itsData.itsDoubleTable.length != doubleTableTop) {\n+            double[] tmp = new double[doubleTableTop];\n+            System.arraycopy(itsData.itsDoubleTable, 0, tmp, 0,\n+                             doubleTableTop);\n+            itsData.itsDoubleTable = tmp;\n+        }\n+        if (exceptionTableTop != 0\n+            && itsData.itsExceptionTable.length != exceptionTableTop)\n+        {\n+            int[] tmp = new int[exceptionTableTop];\n+            System.arraycopy(itsData.itsExceptionTable, 0, tmp, 0,\n+                             exceptionTableTop);\n+            itsData.itsExceptionTable = tmp;\n+        }\n+\n+        itsData.itsMaxVars = scriptOrFn.getParamAndVarCount();\n+        // itsMaxFrameArray: interpret method needs this amount for its\n+        // stack and sDbl arrays\n+        itsData.itsMaxFrameArray = itsData.itsMaxVars\n+                                   + itsData.itsMaxLocals\n+                                   + itsData.itsMaxStack;\n+\n+        itsData.argNames = scriptOrFn.getParamAndVarNames();\n+        itsData.argIsConst = scriptOrFn.getParamAndVarConst();\n+        itsData.argCount = scriptOrFn.getParamCount();\n+\n+        itsData.encodedSourceStart = scriptOrFn.getEncodedSourceStart();\n+        itsData.encodedSourceEnd = scriptOrFn.getEncodedSourceEnd();\n+\n+        if (literalIds.size() != 0) {\n+            itsData.literalIds = literalIds.toArray();\n+        }\n+\n+        if (Token.printICode) Interpreter.dumpICode(itsData);\n+    }\n+\n+    private void generateNestedFunctions()\n+    {\n+        int functionCount = scriptOrFn.getFunctionCount();\n+        if (functionCount == 0) return;\n+\n+        InterpreterData[] array = new InterpreterData[functionCount];\n+        for (int i = 0; i != functionCount; i++) {\n+            FunctionNode fn = scriptOrFn.getFunctionNode(i);\n+            CodeGenerator gen = new CodeGenerator();\n+            gen.compilerEnv = compilerEnv;\n+            gen.scriptOrFn = fn;\n+            gen.itsData = new InterpreterData(itsData);\n+            gen.generateFunctionICode();\n+            array[i] = gen.itsData;\n+        }\n+        itsData.itsNestedFunctions = array;\n+    }\n+\n+    private void generateRegExpLiterals()\n+    {\n+        int N = scriptOrFn.getRegexpCount();\n+        if (N == 0) return;\n+\n+        Context cx = Context.getContext();\n+        RegExpProxy rep = ScriptRuntime.checkRegExpProxy(cx);\n+        Object[] array = new Object[N];\n+        for (int i = 0; i != N; i++) {\n+            String string = scriptOrFn.getRegexpString(i);\n+            String flags = scriptOrFn.getRegexpFlags(i);\n+            array[i] = rep.compileRegExp(cx, string, flags);\n+        }\n+        itsData.itsRegExpLiterals = array;\n+    }\n+\n+    private void updateLineNumber(Node node)\n+    {\n+        int lineno = node.getLineno();\n+        if (lineno != lineNumber && lineno >= 0) {\n+            if (itsData.firstLinePC < 0) {\n+                itsData.firstLinePC = lineno;\n+            }\n+            lineNumber = lineno;\n+            addIcode(Icode_LINE);\n+            addUint16(lineno & 0xFFFF);\n+        }\n+    }\n+\n+    private RuntimeException badTree(Node node)\n+    {\n+        throw new RuntimeException(node.toString());\n+    }\n+\n+    private void visitStatement(Node node, int initialStackDepth)\n+    {\n+        int type = node.getType();\n+        Node child = node.getFirstChild();\n+        switch (type) {\n+\n+          case Token.FUNCTION:\n+            {\n+                int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);\n+                int fnType = scriptOrFn.getFunctionNode(fnIndex).\n+                                 getFunctionType();\n+                // Only function expressions or function expression\n+                // statements need closure code creating new function\n+                // object on stack as function statements are initialized\n+                // at script/function start.\n+                // In addition, function expressions can not be present here\n+                // at statement level, they must only be present as expressions.\n+                if (fnType == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {\n+                    addIndexOp(Icode_CLOSURE_STMT, fnIndex);\n+                } else {\n+                    if (fnType != FunctionNode.FUNCTION_STATEMENT) {\n+                        throw Kit.codeBug();\n+                    }\n+                }\n+                // For function statements or function expression statements\n+                // in scripts, we need to ensure that the result of the script\n+                // is the function if it is the last statement in the script.\n+                // For example, eval(\"function () {}\") should return a\n+                // function, not undefined.\n+                if (!itsInFunctionFlag) {\n+                    addIndexOp(Icode_CLOSURE_EXPR, fnIndex);\n+                    stackChange(1);\n+                    addIcode(Icode_POP_RESULT);\n+                    stackChange(-1);\n+                }\n+            }\n+            break;\n+\n+          case Token.LABEL:\n+          case Token.LOOP:\n+          case Token.BLOCK:\n+          case Token.EMPTY:\n+          case Token.WITH:\n+            updateLineNumber(node);\n+          case Token.SCRIPT:\n+            // fall through\n+            while (child != null) {\n+                visitStatement(child, initialStackDepth);\n+                child = child.getNext();\n+            }\n+            break;\n+\n+          case Token.ENTERWITH:\n+            visitExpression(child, 0);\n+            addToken(Token.ENTERWITH);\n+            stackChange(-1);\n+            break;\n+\n+          case Token.LEAVEWITH:\n+            addToken(Token.LEAVEWITH);\n+            break;\n+\n+          case Token.LOCAL_BLOCK:\n+            {\n+                int local = allocLocal();\n+                node.putIntProp(Node.LOCAL_PROP, local);\n+                updateLineNumber(node);\n+                while (child != null) {\n+                    visitStatement(child, initialStackDepth);\n+                    child = child.getNext();\n+                }\n+                addIndexOp(Icode_LOCAL_CLEAR, local);\n+                releaseLocal(local);\n+            }\n+            break;\n+\n+          case Token.DEBUGGER:\n+            addIcode(Icode_DEBUGGER);\n+            break;\n+\n+          case Token.SWITCH:\n+            updateLineNumber(node);\n+            // See comments in IRFactory.createSwitch() for description\n+            // of SWITCH node\n+            {\n+                visitExpression(child, 0);\n+                for (Jump caseNode = (Jump)child.getNext();\n+                     caseNode != null;\n+                     caseNode = (Jump)caseNode.getNext())\n+                {\n+                    if (caseNode.getType() != Token.CASE)\n+                        throw badTree(caseNode);\n+                    Node test = caseNode.getFirstChild();\n+                    addIcode(Icode_DUP);\n+                    stackChange(1);\n+                    visitExpression(test, 0);\n+                    addToken(Token.SHEQ);\n+                    stackChange(-1);\n+                    // If true, Icode_IFEQ_POP will jump and remove case\n+                    // value from stack\n+                    addGoto(caseNode.target, Icode_IFEQ_POP);\n+                    stackChange(-1);\n+                }\n+                addIcode(Icode_POP);\n+                stackChange(-1);\n+            }\n+            break;\n+\n+          case Token.TARGET:\n+            markTargetLabel(node);\n+            break;\n+\n+          case Token.IFEQ :\n+          case Token.IFNE :\n+            {\n+                Node target = ((Jump)node).target;\n+                visitExpression(child, 0);\n+                addGoto(target, type);\n+                stackChange(-1);\n+            }\n+            break;\n+\n+          case Token.GOTO:\n+            {\n+                Node target = ((Jump)node).target;\n+                addGoto(target, type);\n+            }\n+            break;\n+\n+          case Token.JSR:\n+            {\n+                Node target = ((Jump)node).target;\n+                addGoto(target, Icode_GOSUB);\n+            }\n+            break;\n+\n+          case Token.FINALLY:\n+            {\n+                // Account for incomming GOTOSUB address\n+                stackChange(1);\n+                int finallyRegister = getLocalBlockRef(node);\n+                addIndexOp(Icode_STARTSUB, finallyRegister);\n+                stackChange(-1);\n+                while (child != null) {\n+                    visitStatement(child, initialStackDepth);\n+                    child = child.getNext();\n+                }\n+                addIndexOp(Icode_RETSUB, finallyRegister);\n+            }\n+            break;\n+\n+          case Token.EXPR_VOID:\n+          case Token.EXPR_RESULT:\n+            updateLineNumber(node);\n+            visitExpression(child, 0);\n+            addIcode((type == Token.EXPR_VOID) ? Icode_POP : Icode_POP_RESULT);\n+            stackChange(-1);\n+            break;\n+\n+          case Token.TRY:\n+            {\n+                Jump tryNode = (Jump)node;\n+                int exceptionObjectLocal = getLocalBlockRef(tryNode);\n+                int scopeLocal = allocLocal();\n+\n+                addIndexOp(Icode_SCOPE_SAVE, scopeLocal);\n+\n+                int tryStart = iCodeTop;\n+                boolean savedFlag = itsInTryFlag;\n+                itsInTryFlag = true;\n+                while (child != null) {\n+                    visitStatement(child, initialStackDepth);\n+                    child = child.getNext();\n+                }\n+                itsInTryFlag = savedFlag;\n+\n+                Node catchTarget = tryNode.target;\n+                if (catchTarget != null) {\n+                    int catchStartPC\n+                        = labelTable[getTargetLabel(catchTarget)];\n+                    addExceptionHandler(\n+                        tryStart, catchStartPC, catchStartPC,\n+                        false, exceptionObjectLocal, scopeLocal);\n+                }\n+                Node finallyTarget = tryNode.getFinally();\n+                if (finallyTarget != null) {\n+                    int finallyStartPC\n+                        = labelTable[getTargetLabel(finallyTarget)];\n+                    addExceptionHandler(\n+                        tryStart, finallyStartPC, finallyStartPC,\n+                        true, exceptionObjectLocal, scopeLocal);\n+                }\n+\n+                addIndexOp(Icode_LOCAL_CLEAR, scopeLocal);\n+                releaseLocal(scopeLocal);\n+            }\n+            break;\n+\n+          case Token.CATCH_SCOPE:\n+            {\n+                int localIndex = getLocalBlockRef(node);\n+                int scopeIndex = node.getExistingIntProp(Node.CATCH_SCOPE_PROP);\n+                String name = child.getString();\n+                child = child.getNext();\n+                visitExpression(child, 0); // load expression object\n+                addStringPrefix(name);\n+                addIndexPrefix(localIndex);\n+                addToken(Token.CATCH_SCOPE);\n+                addUint8(scopeIndex != 0 ? 1 : 0);\n+                stackChange(-1);\n+            }\n+            break;\n+\n+          case Token.THROW:\n+            updateLineNumber(node);\n+            visitExpression(child, 0);\n+            addToken(Token.THROW);\n+            addUint16(lineNumber & 0xFFFF);\n+            stackChange(-1);\n+            break;\n+\n+          case Token.RETHROW:\n+            updateLineNumber(node);\n+            addIndexOp(Token.RETHROW, getLocalBlockRef(node));\n+            break;\n+\n+          case Token.RETURN:\n+            updateLineNumber(node);\n+            if (node.getIntProp(Node.GENERATOR_END_PROP, 0) != 0) {\n+                // We're in a generator, so change RETURN to GENERATOR_END\n+                addIcode(Icode_GENERATOR_END);\n+                addUint16(lineNumber & 0xFFFF);\n+            } else if (child != null) {\n+                visitExpression(child, ECF_TAIL);\n+                addToken(Token.RETURN);\n+                stackChange(-1);\n+            } else {\n+                addIcode(Icode_RETUNDEF);\n+            }\n+            break;\n+\n+          case Token.RETURN_RESULT:\n+            updateLineNumber(node);\n+            addToken(Token.RETURN_RESULT);\n+            break;\n+\n+          case Token.ENUM_INIT_KEYS:\n+          case Token.ENUM_INIT_VALUES:\n+          case Token.ENUM_INIT_ARRAY:\n+            visitExpression(child, 0);\n+            addIndexOp(type, getLocalBlockRef(node));\n+            stackChange(-1);\n+            break;\n+\n+          case Icode_GENERATOR:\n+            break;\n+\n+          default:\n+            throw badTree(node);\n+        }\n+\n+        if (stackDepth != initialStackDepth) {\n+            throw Kit.codeBug();\n+        }\n+    }\n+\n+    private void visitExpression(Node node, int contextFlags)\n+    {\n+        int type = node.getType();\n+        Node child = node.getFirstChild();\n+        int savedStackDepth = stackDepth;\n+        switch (type) {\n+\n+          case Token.FUNCTION:\n+            {\n+                int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);\n+                FunctionNode fn = scriptOrFn.getFunctionNode(fnIndex);\n+                // See comments in visitStatement for Token.FUNCTION case\n+                if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION) {\n+                    throw Kit.codeBug();\n+                }\n+                addIndexOp(Icode_CLOSURE_EXPR, fnIndex);\n+                stackChange(1);\n+            }\n+            break;\n+\n+          case Token.LOCAL_LOAD:\n+            {\n+                int localIndex = getLocalBlockRef(node);\n+                addIndexOp(Token.LOCAL_LOAD, localIndex);\n+                stackChange(1);\n+            }\n+            break;\n+\n+          case Token.COMMA:\n+            {\n+                Node lastChild = node.getLastChild();\n+                while (child != lastChild) {\n+                    visitExpression(child, 0);\n+                    addIcode(Icode_POP);\n+                    stackChange(-1);\n+                    child = child.getNext();\n+                }\n+                // Preserve tail context flag if any\n+                visitExpression(child, contextFlags & ECF_TAIL);\n+            }\n+            break;\n+\n+          case Token.USE_STACK:\n+            // Indicates that stack was modified externally,\n+            // like placed catch object\n+            stackChange(1);\n+            break;\n+\n+          case Token.REF_CALL:\n+          case Token.CALL:\n+          case Token.NEW:\n+            {\n+                if (type == Token.NEW) {\n+                    visitExpression(child, 0);\n+                } else {\n+                    generateCallFunAndThis(child);\n+                }\n+                int argCount = 0;\n+                while ((child = child.getNext()) != null) {\n+                    visitExpression(child, 0);\n+                    ++argCount;\n+                }\n+                int callType = node.getIntProp(Node.SPECIALCALL_PROP,\n+                                               Node.NON_SPECIALCALL);\n+                if (callType != Node.NON_SPECIALCALL) {\n+                    // embed line number and source filename\n+                    addIndexOp(Icode_CALLSPECIAL, argCount);\n+                    addUint8(callType);\n+                    addUint8(type == Token.NEW ? 1 : 0);\n+                    addUint16(lineNumber & 0xFFFF);\n+                } else {\n+                    // Only use the tail call optimization if we're not in a try\n+                    // or we're not generating debug info (since the\n+                    // optimization will confuse the debugger)\n+                    if (type == Token.CALL && (contextFlags & ECF_TAIL) != 0 &&\n+                        !compilerEnv.isGenerateDebugInfo() && !itsInTryFlag)\n+                    {\n+                        type = Icode_TAIL_CALL;\n+                    }\n+                    addIndexOp(type, argCount);\n+                }\n+                // adjust stack\n+                if (type == Token.NEW) {\n+                    // new: f, args -> result\n+                    stackChange(-argCount);\n+                } else {\n+                    // call: f, thisObj, args -> result\n+                    // ref_call: f, thisObj, args -> ref\n+                    stackChange(-1 - argCount);\n+                }\n+                if (argCount > itsData.itsMaxCalleeArgs) {\n+                    itsData.itsMaxCalleeArgs = argCount;\n+                }\n+            }\n+            break;\n+\n+          case Token.AND:\n+          case Token.OR:\n+            {\n+                visitExpression(child, 0);\n+                addIcode(Icode_DUP);\n+                stackChange(1);\n+                int afterSecondJumpStart = iCodeTop;\n+                int jump = (type == Token.AND) ? Token.IFNE : Token.IFEQ;\n+                addGotoOp(jump);\n+                stackChange(-1);\n+                addIcode(Icode_POP);\n+                stackChange(-1);\n+                child = child.getNext();\n+                // Preserve tail context flag if any\n+                visitExpression(child, contextFlags & ECF_TAIL);\n+                resolveForwardGoto(afterSecondJumpStart);\n+            }\n+            break;\n+\n+          case Token.HOOK:\n+            {\n+                Node ifThen = child.getNext();\n+                Node ifElse = ifThen.getNext();\n+                visitExpression(child, 0);\n+                int elseJumpStart = iCodeTop;\n+                addGotoOp(Token.IFNE);\n+                stackChange(-1);\n+                // Preserve tail context flag if any\n+                visitExpression(ifThen, contextFlags & ECF_TAIL);\n+                int afterElseJumpStart = iCodeTop;\n+                addGotoOp(Token.GOTO);\n+                resolveForwardGoto(elseJumpStart);\n+                stackDepth = savedStackDepth;\n+                // Preserve tail context flag if any\n+                visitExpression(ifElse, contextFlags & ECF_TAIL);\n+                resolveForwardGoto(afterElseJumpStart);\n+            }\n+            break;\n+\n+          case Token.GETPROP:\n+          case Token.GETPROPNOWARN:\n+            visitExpression(child, 0);\n+            child = child.getNext();\n+            addStringOp(type, child.getString());\n+            break;\n+\n+          case Token.GETELEM:\n+          case Token.DELPROP:\n+          case Token.BITAND:\n+          case Token.BITOR:\n+          case Token.BITXOR:\n+          case Token.LSH:\n+          case Token.RSH:\n+          case Token.URSH:\n+          case Token.ADD:\n+          case Token.SUB:\n+          case Token.MOD:\n+          case Token.DIV:\n+          case Token.MUL:\n+          case Token.EQ:\n+          case Token.NE:\n+          case Token.SHEQ:\n+          case Token.SHNE:\n+          case Token.IN:\n+          case Token.INSTANCEOF:\n+          case Token.LE:\n+          case Token.LT:\n+          case Token.GE:\n+          case Token.GT:\n+            visitExpression(child, 0);\n+            child = child.getNext();\n+            visitExpression(child, 0);\n+            addToken(type);\n+            stackChange(-1);\n+            break;\n+\n+          case Token.POS:\n+          case Token.NEG:\n+          case Token.NOT:\n+          case Token.BITNOT:\n+          case Token.TYPEOF:\n+          case Token.VOID:\n+            visitExpression(child, 0);\n+            if (type == Token.VOID) {\n+                addIcode(Icode_POP);\n+                addIcode(Icode_UNDEF);\n+            } else {\n+                addToken(type);\n+            }\n+            break;\n+\n+          case Token.GET_REF:\n+          case Token.DEL_REF:\n+            visitExpression(child, 0);\n+            addToken(type);\n+            break;\n+\n+          case Token.SETPROP:\n+          case Token.SETPROP_OP:\n+            {\n+                visitExpression(child, 0);\n+                child = child.getNext();\n+                String property = child.getString();\n+                child = child.getNext();\n+                if (type == Token.SETPROP_OP) {\n+                    addIcode(Icode_DUP);\n+                    stackChange(1);\n+                    addStringOp(Token.GETPROP, property);\n+                    // Compensate for the following USE_STACK\n+                    stackChange(-1);\n+                }\n+                visitExpression(child, 0);\n+                addStringOp(Token.SETPROP, property);\n+                stackChange(-1);\n+            }\n+            break;\n+\n+          case Token.SETELEM:\n+          case Token.SETELEM_OP:\n+            visitExpression(child, 0);\n+            child = child.getNext();\n+            visitExpression(child, 0);\n+            child = child.getNext();\n+            if (type == Token.SETELEM_OP) {\n+                addIcode(Icode_DUP2);\n+                stackChange(2);\n+                addToken(Token.GETELEM);\n+                stackChange(-1);\n+                // Compensate for the following USE_STACK\n+                stackChange(-1);\n+            }\n+            visitExpression(child, 0);\n+            addToken(Token.SETELEM);\n+            stackChange(-2);\n+            break;\n+\n+          case Token.SET_REF:\n+          case Token.SET_REF_OP:\n+            visitExpression(child, 0);\n+            child = child.getNext();\n+            if (type == Token.SET_REF_OP) {\n+                addIcode(Icode_DUP);\n+                stackChange(1);\n+                addToken(Token.GET_REF);\n+                // Compensate for the following USE_STACK\n+                stackChange(-1);\n+            }\n+            visitExpression(child, 0);\n+            addToken(Token.SET_REF);\n+            stackChange(-1);\n+            break;\n+\n+          case Token.STRICT_SETNAME:\n+          case Token.SETNAME:\n+            {\n+                String name = child.getString();\n+                visitExpression(child, 0);\n+                child = child.getNext();\n+                visitExpression(child, 0);\n+                addStringOp(type, name);\n+                stackChange(-1);\n+            }\n+            break;\n+\n+          case Token.SETCONST:\n+            {\n+                String name = child.getString();\n+                visitExpression(child, 0);\n+                child = child.getNext();\n+                visitExpression(child, 0);\n+                addStringOp(Icode_SETCONST, name);\n+                stackChange(-1);\n+            }\n+            break;\n+\n+          case Token.TYPEOFNAME:\n+            {\n+                int index = -1;\n+                // use typeofname if an activation frame exists\n+                // since the vars all exist there instead of in jregs\n+                if (itsInFunctionFlag && !itsData.itsNeedsActivation)\n+                    index = scriptOrFn.getIndexForNameNode(node);\n+                if (index == -1) {\n+                    addStringOp(Icode_TYPEOFNAME, node.getString());\n+                    stackChange(1);\n+                } else {\n+                    addVarOp(Token.GETVAR, index);\n+                    stackChange(1);\n+                    addToken(Token.TYPEOF);\n+                }\n+            }\n+            break;\n+\n+          case Token.BINDNAME:\n+          case Token.NAME:\n+          case Token.STRING:\n+            addStringOp(type, node.getString());\n+            stackChange(1);\n+            break;\n+\n+          case Token.INC:\n+          case Token.DEC:\n+            visitIncDec(node, child);\n+            break;\n+\n+          case Token.NUMBER:\n+            {\n+                double num = node.getDouble();\n+                int inum = (int)num;\n+                if (inum == num) {\n+                    if (inum == 0) {\n+                        addIcode(Icode_ZERO);\n+                        // Check for negative zero\n+                        if (1.0 / num < 0.0) {\n+                            addToken(Token.NEG);\n+                        }\n+                    } else if (inum == 1) {\n+                        addIcode(Icode_ONE);\n+                    } else if ((short)inum == inum) {\n+                        addIcode(Icode_SHORTNUMBER);\n+                        // write short as uin16 bit pattern\n+                        addUint16(inum & 0xFFFF);\n+                    } else {\n+                        addIcode(Icode_INTNUMBER);\n+                        addInt(inum);\n+                    }\n+                } else {\n+                    int index = getDoubleIndex(num);\n+                    addIndexOp(Token.NUMBER, index);\n+                }\n+                stackChange(1);\n+            }\n+            break;\n+\n+          case Token.GETVAR:\n+            {\n+                if (itsData.itsNeedsActivation) Kit.codeBug();\n+                int index = scriptOrFn.getIndexForNameNode(node);\n+                addVarOp(Token.GETVAR, index);\n+                stackChange(1);\n+            }\n+            break;\n+\n+          case Token.SETVAR:\n+            {\n+                if (itsData.itsNeedsActivation) Kit.codeBug();\n+                int index = scriptOrFn.getIndexForNameNode(child);\n+                child = child.getNext();\n+                visitExpression(child, 0);\n+                addVarOp(Token.SETVAR, index);\n+            }\n+            break;\n+\n+          case Token.SETCONSTVAR:\n+            {\n+                if (itsData.itsNeedsActivation) Kit.codeBug();\n+                int index = scriptOrFn.getIndexForNameNode(child);\n+                child = child.getNext();\n+                visitExpression(child, 0);\n+                addVarOp(Token.SETCONSTVAR, index);\n+            }\n+            break;\n+\n+          case Token.NULL:\n+          case Token.THIS:\n+          case Token.THISFN:\n+          case Token.FALSE:\n+          case Token.TRUE:\n+            addToken(type);\n+            stackChange(1);\n+            break;\n+\n+          case Token.ENUM_NEXT:\n+          case Token.ENUM_ID:\n+            addIndexOp(type, getLocalBlockRef(node));\n+            stackChange(1);\n+            break;\n+\n+          case Token.REGEXP:\n+            {\n+                int index = node.getExistingIntProp(Node.REGEXP_PROP);\n+                addIndexOp(Token.REGEXP, index);\n+                stackChange(1);\n+            }\n+            break;\n+\n+          case Token.ARRAYLIT:\n+          case Token.OBJECTLIT:\n+            visitLiteral(node, child);\n+            break;\n+\n+          case Token.ARRAYCOMP:\n+            visitArrayComprehension(node, child, child.getNext());\n+            break;\n+\n+          case Token.REF_SPECIAL:\n+            visitExpression(child, 0);\n+            addStringOp(type, (String)node.getProp(Node.NAME_PROP));\n+            break;\n+\n+          case Token.REF_MEMBER:\n+          case Token.REF_NS_MEMBER:\n+          case Token.REF_NAME:\n+          case Token.REF_NS_NAME:\n+            {\n+                int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0);\n+                // generate possible target, possible namespace and member\n+                int childCount = 0;\n+                do {\n+                    visitExpression(child, 0);\n+                    ++childCount;\n+                    child = child.getNext();\n+                } while (child != null);\n+                addIndexOp(type, memberTypeFlags);\n+                stackChange(1 - childCount);\n+            }\n+            break;\n+\n+          case Token.DOTQUERY:\n+            {\n+                int queryPC;\n+                updateLineNumber(node);\n+                visitExpression(child, 0);\n+                addIcode(Icode_ENTERDQ);\n+                stackChange(-1);\n+                queryPC = iCodeTop;\n+                visitExpression(child.getNext(), 0);\n+                addBackwardGoto(Icode_LEAVEDQ, queryPC);\n+            }\n+            break;\n+\n+          case Token.DEFAULTNAMESPACE :\n+          case Token.ESCXMLATTR :\n+          case Token.ESCXMLTEXT :\n+            visitExpression(child, 0);\n+            addToken(type);\n+            break;\n+\n+          case Token.YIELD:\n+            if (child != null) {\n+                visitExpression(child, 0);\n+            } else {\n+                addIcode(Icode_UNDEF);\n+                stackChange(1);\n+            }\n+            addToken(Token.YIELD);\n+            addUint16(node.getLineno() & 0xFFFF);\n+            break;\n+\n+          case Token.WITHEXPR: {\n+            Node enterWith = node.getFirstChild();\n+            Node with = enterWith.getNext();\n+            visitExpression(enterWith.getFirstChild(), 0);\n+            addToken(Token.ENTERWITH);\n+            stackChange(-1);\n+            visitExpression(with.getFirstChild(), 0);\n+            addToken(Token.LEAVEWITH);\n+            break;\n+          }\n+\n+          default:\n+            throw badTree(node);\n+        }\n+        if (savedStackDepth + 1 != stackDepth) {\n+            Kit.codeBug();\n+        }\n+    }\n+\n+    private void generateCallFunAndThis(Node left)\n+    {\n+        // Generate code to place on stack function and thisObj\n+        int type = left.getType();\n+        switch (type) {\n+          case Token.NAME: {\n+            String name = left.getString();\n+            // stack: ... -> ... function thisObj\n+            addStringOp(Icode_NAME_AND_THIS, name);\n+            stackChange(2);\n+            break;\n+          }\n+          case Token.GETPROP:\n+          case Token.GETELEM: {\n+            Node target = left.getFirstChild();\n+            visitExpression(target, 0);\n+            Node id = target.getNext();\n+            if (type == Token.GETPROP) {\n+                String property = id.getString();\n+                // stack: ... target -> ... function thisObj\n+                addStringOp(Icode_PROP_AND_THIS, property);\n+                stackChange(1);\n+            } else {\n+                visitExpression(id, 0);\n+                // stack: ... target id -> ... function thisObj\n+                addIcode(Icode_ELEM_AND_THIS);\n+            }\n+            break;\n+          }\n+          default:\n+            // Including Token.GETVAR\n+            visitExpression(left, 0);\n+            // stack: ... value -> ... function thisObj\n+            addIcode(Icode_VALUE_AND_THIS);\n+            stackChange(1);\n+            break;\n+        }\n+    }\n+\n+\n+    private void visitIncDec(Node node, Node child)\n+    {\n+        int incrDecrMask = node.getExistingIntProp(Node.INCRDECR_PROP);\n+        int childType = child.getType();\n+        switch (childType) {\n+          case Token.GETVAR : {\n+            if (itsData.itsNeedsActivation) Kit.codeBug();\n+            int i = scriptOrFn.getIndexForNameNode(child);\n+            addVarOp(Icode_VAR_INC_DEC, i);\n+            addUint8(incrDecrMask);\n+            stackChange(1);\n+            break;\n+          }\n+          case Token.NAME : {\n+            String name = child.getString();\n+            addStringOp(Icode_NAME_INC_DEC, name);\n+            addUint8(incrDecrMask);\n+            stackChange(1);\n+            break;\n+          }\n+          case Token.GETPROP : {\n+            Node object = child.getFirstChild();\n+            visitExpression(object, 0);\n+            String property = object.getNext().getString();\n+            addStringOp(Icode_PROP_INC_DEC, property);\n+            addUint8(incrDecrMask);\n+            break;\n+          }\n+          case Token.GETELEM : {\n+            Node object = child.getFirstChild();\n+            visitExpression(object, 0);\n+            Node index = object.getNext();\n+            visitExpression(index, 0);\n+            addIcode(Icode_ELEM_INC_DEC);\n+            addUint8(incrDecrMask);\n+            stackChange(-1);\n+            break;\n+          }\n+          case Token.GET_REF : {\n+            Node ref = child.getFirstChild();\n+            visitExpression(ref, 0);\n+            addIcode(Icode_REF_INC_DEC);\n+            addUint8(incrDecrMask);\n+            break;\n+          }\n+          default : {\n+            throw badTree(node);\n+          }\n+        }\n+    }\n+\n+    private void visitLiteral(Node node, Node child)\n+    {\n+        int type = node.getType();\n+        int count;\n+        Object[] propertyIds = null;\n+        if (type == Token.ARRAYLIT) {\n+            count = 0;\n+            for (Node n = child; n != null; n = n.getNext()) {\n+                ++count;\n+            }\n+        } else if (type == Token.OBJECTLIT) {\n+            propertyIds = (Object[])node.getProp(Node.OBJECT_IDS_PROP);\n+            count = propertyIds.length;\n+        } else {\n+            throw badTree(node);\n+        }\n+        addIndexOp(Icode_LITERAL_NEW, count);\n+        stackChange(2);\n+        while (child != null) {\n+            int childType = child.getType();\n+            if (childType == Token.GET) {\n+                visitExpression(child.getFirstChild(), 0);\n+                addIcode(Icode_LITERAL_GETTER);\n+            } else if (childType == Token.SET) {\n+                visitExpression(child.getFirstChild(), 0);\n+                addIcode(Icode_LITERAL_SETTER);\n+            } else {\n+                visitExpression(child, 0);\n+                addIcode(Icode_LITERAL_SET);\n+            }\n+            stackChange(-1);\n+            child = child.getNext();\n+        }\n+        if (type == Token.ARRAYLIT) {\n+            int[] skipIndexes = (int[])node.getProp(Node.SKIP_INDEXES_PROP);\n+            if (skipIndexes == null) {\n+                addToken(Token.ARRAYLIT);\n+            } else {\n+                int index = literalIds.size();\n+                literalIds.add(skipIndexes);\n+                addIndexOp(Icode_SPARE_ARRAYLIT, index);\n+            }\n+        } else {\n+            int index = literalIds.size();\n+            literalIds.add(propertyIds);\n+            addIndexOp(Token.OBJECTLIT, index);\n+        }\n+        stackChange(-1);\n+    }\n+\n+    private void visitArrayComprehension(Node node, Node initStmt, Node expr)\n+    {\n+        // A bit of a hack: array comprehensions are implemented using\n+        // statement nodes for the iteration, yet they appear in an\n+        // expression context. So we pass the current stack depth to\n+        // visitStatement so it can check that the depth is not altered\n+        // by statements.\n+        visitStatement(initStmt, stackDepth);\n+        visitExpression(expr, 0);\n+    }\n+\n+    private int getLocalBlockRef(Node node)\n+    {\n+        Node localBlock = (Node)node.getProp(Node.LOCAL_BLOCK_PROP);\n+        return localBlock.getExistingIntProp(Node.LOCAL_PROP);\n+    }\n+\n+    private int getTargetLabel(Node target)\n+    {\n+        int label = target.labelId();\n+        if (label != -1) {\n+            return label;\n+        }\n+        label = labelTableTop;\n+        if (labelTable == null || label == labelTable.length) {\n+            if (labelTable == null) {\n+                labelTable = new int[MIN_LABEL_TABLE_SIZE];\n+            }else {\n+                int[] tmp = new int[labelTable.length * 2];\n+                System.arraycopy(labelTable, 0, tmp, 0, label);\n+                labelTable = tmp;\n+            }\n+        }\n+        labelTableTop = label + 1;\n+        labelTable[label] = -1;\n+\n+        target.labelId(label);\n+        return label;\n+    }\n+\n+    private void markTargetLabel(Node target)\n+    {\n+        int label = getTargetLabel(target);\n+        if (labelTable[label] != -1) {\n+            // Can mark label only once\n+            Kit.codeBug();\n+        }\n+        labelTable[label] = iCodeTop;\n+    }\n+\n+    private void addGoto(Node target, int gotoOp)\n+    {\n+        int label = getTargetLabel(target);\n+        if (!(label < labelTableTop)) Kit.codeBug();\n+        int targetPC = labelTable[label];\n+\n+        if (targetPC != -1) {\n+            addBackwardGoto(gotoOp, targetPC);\n+        } else {\n+            int gotoPC = iCodeTop;\n+            addGotoOp(gotoOp);\n+            int top = fixupTableTop;\n+            if (fixupTable == null || top == fixupTable.length) {\n+                if (fixupTable == null) {\n+                    fixupTable = new long[MIN_FIXUP_TABLE_SIZE];\n+                } else {\n+                    long[] tmp = new long[fixupTable.length * 2];\n+                    System.arraycopy(fixupTable, 0, tmp, 0, top);\n+                    fixupTable = tmp;\n+                }\n+            }\n+            fixupTableTop = top + 1;\n+            fixupTable[top] = ((long)label << 32) | gotoPC;\n+        }\n+    }\n+\n+    private void fixLabelGotos()\n+    {\n+        for (int i = 0; i < fixupTableTop; i++) {\n+            long fixup = fixupTable[i];\n+            int label = (int)(fixup >> 32);\n+            int jumpSource = (int)fixup;\n+            int pc = labelTable[label];\n+            if (pc == -1) {\n+                // Unlocated label\n+                throw Kit.codeBug();\n+            }\n+            resolveGoto(jumpSource, pc);\n+        }\n+        fixupTableTop = 0;\n+    }\n+\n+    private void addBackwardGoto(int gotoOp, int jumpPC)\n+    {\n+        int fromPC = iCodeTop;\n+        // Ensure that this is a jump backward\n+        if (fromPC <= jumpPC) throw Kit.codeBug();\n+        addGotoOp(gotoOp);\n+        resolveGoto(fromPC, jumpPC);\n+    }\n+\n+    private void resolveForwardGoto(int fromPC)\n+    {\n+        // Ensure that forward jump skips at least self bytecode\n+        if (iCodeTop < fromPC + 3) throw Kit.codeBug();\n+        resolveGoto(fromPC, iCodeTop);\n+    }\n+\n+    private void resolveGoto(int fromPC, int jumpPC)\n+    {\n+        int offset = jumpPC - fromPC;\n+        // Ensure that jumps do not overlap\n+        if (0 <= offset && offset <= 2) throw Kit.codeBug();\n+        int offsetSite = fromPC + 1;\n+        if (offset != (short)offset) {\n+            if (itsData.longJumps == null) {\n+                itsData.longJumps = new UintMap();\n+            }\n+            itsData.longJumps.put(offsetSite, jumpPC);\n+            offset = 0;\n+        }\n+        byte[] array = itsData.itsICode;\n+        array[offsetSite] = (byte)(offset >> 8);\n+        array[offsetSite + 1] = (byte)offset;\n+    }\n+\n+    private void addToken(int token)\n+    {\n+        if (!Icode.validTokenCode(token)) throw Kit.codeBug();\n+        addUint8(token);\n+    }\n+\n+    private void addIcode(int icode)\n+    {\n+        if (!Icode.validIcode(icode)) throw Kit.codeBug();\n+        // Write negative icode as uint8 bits\n+        addUint8(icode & 0xFF);\n+    }\n+\n+    private void addUint8(int value)\n+    {\n+        if ((value & ~0xFF) != 0) throw Kit.codeBug();\n+        byte[] array = itsData.itsICode;\n+        int top = iCodeTop;\n+        if (top == array.length) {\n+            array = increaseICodeCapacity(1);\n+        }\n+        array[top] = (byte)value;\n+        iCodeTop = top + 1;\n+    }\n+\n+    private void addUint16(int value)\n+    {\n+        if ((value & ~0xFFFF) != 0) throw Kit.codeBug();\n+        byte[] array = itsData.itsICode;\n+        int top = iCodeTop;\n+        if (top + 2 > array.length) {\n+            array = increaseICodeCapacity(2);\n+        }\n+        array[top] = (byte)(value >>> 8);\n+        array[top + 1] = (byte)value;\n+        iCodeTop = top + 2;\n+    }\n+\n+    private void addInt(int i)\n+    {\n+        byte[] array = itsData.itsICode;\n+        int top = iCodeTop;\n+        if (top + 4 > array.length) {\n+            array = increaseICodeCapacity(4);\n+        }\n+        array[top] = (byte)(i >>> 24);\n+        array[top + 1] = (byte)(i >>> 16);\n+        array[top + 2] = (byte)(i >>> 8);\n+        array[top + 3] = (byte)i;\n+        iCodeTop = top + 4;\n+    }\n+\n+    private int getDoubleIndex(double num)\n+    {\n+        int index = doubleTableTop;\n+        if (index == 0) {\n+            itsData.itsDoubleTable = new double[64];\n+        } else if (itsData.itsDoubleTable.length == index) {\n+            double[] na = new double[index * 2];\n+            System.arraycopy(itsData.itsDoubleTable, 0, na, 0, index);\n+            itsData.itsDoubleTable = na;\n+        }\n+        itsData.itsDoubleTable[index] = num;\n+        doubleTableTop = index + 1;\n+        return index;\n+    }\n+\n+    private void addGotoOp(int gotoOp)\n+    {\n+        byte[] array = itsData.itsICode;\n+        int top = iCodeTop;\n+        if (top + 3 > array.length) {\n+            array = increaseICodeCapacity(3);\n+        }\n+        array[top] = (byte)gotoOp;\n+        // Offset would written later\n+        iCodeTop = top + 1 + 2;\n+    }\n+\n+    private void addVarOp(int op, int varIndex)\n+    {\n+        switch (op) {\n+          case Token.SETCONSTVAR:\n+            if (varIndex < 128) {\n+                addIcode(Icode_SETCONSTVAR1);\n+                addUint8(varIndex);\n+                return;\n+            }\n+            addIndexOp(Icode_SETCONSTVAR, varIndex);\n+            return;\n+          case Token.GETVAR:\n+          case Token.SETVAR:\n+            if (varIndex < 128) {\n+                addIcode(op == Token.GETVAR ? Icode_GETVAR1 : Icode_SETVAR1);\n+                addUint8(varIndex);\n+                return;\n+            }\n+            // fallthrough\n+          case Icode_VAR_INC_DEC:\n+            addIndexOp(op, varIndex);\n+            return;\n+        }\n+        throw Kit.codeBug();\n+    }\n+\n+    private void addStringOp(int op, String str)\n+    {\n+        addStringPrefix(str);\n+        if (Icode.validIcode(op)) {\n+            addIcode(op);\n+        } else {\n+            addToken(op);\n+        }\n+    }\n+\n+    private void addIndexOp(int op, int index)\n+    {\n+        addIndexPrefix(index);\n+        if (Icode.validIcode(op)) {\n+            addIcode(op);\n+        } else {\n+            addToken(op);\n+        }\n+    }\n+\n+    private void addStringPrefix(String str)\n+    {\n+        int index = strings.get(str, -1);\n+        if (index == -1) {\n+            index = strings.size();\n+            strings.put(str, index);\n+        }\n+        if (index < 4) {\n+            addIcode(Icode_REG_STR_C0 - index);\n+        } else if (index <= 0xFF) {\n+            addIcode(Icode_REG_STR1);\n+            addUint8(index);\n+         } else if (index <= 0xFFFF) {\n+            addIcode(Icode_REG_STR2);\n+            addUint16(index);\n+         } else {\n+            addIcode(Icode_REG_STR4);\n+            addInt(index);\n+        }\n+    }\n+\n+    private void addIndexPrefix(int index)\n+    {\n+        if (index < 0) Kit.codeBug();\n+        if (index < 6) {\n+            addIcode(Icode_REG_IND_C0 - index);\n+        } else if (index <= 0xFF) {\n+            addIcode(Icode_REG_IND1);\n+            addUint8(index);\n+         } else if (index <= 0xFFFF) {\n+            addIcode(Icode_REG_IND2);\n+            addUint16(index);\n+         } else {\n+            addIcode(Icode_REG_IND4);\n+            addInt(index);\n+        }\n+    }\n+\n+    private void addExceptionHandler(int icodeStart, int icodeEnd,\n+                                     int handlerStart, boolean isFinally,\n+                                     int exceptionObjectLocal, int scopeLocal)\n+    {\n+        int top = exceptionTableTop;\n+        int[] table = itsData.itsExceptionTable;\n+        if (table == null) {\n+            if (top != 0) Kit.codeBug();\n+            table = new int[Interpreter.EXCEPTION_SLOT_SIZE * 2];\n+            itsData.itsExceptionTable = table;\n+        } else if (table.length == top) {\n+            table = new int[table.length * 2];\n+            System.arraycopy(itsData.itsExceptionTable, 0, table, 0, top);\n+            itsData.itsExceptionTable = table;\n+        }\n+        table[top + Interpreter.EXCEPTION_TRY_START_SLOT]  = icodeStart;\n+        table[top + Interpreter.EXCEPTION_TRY_END_SLOT]    = icodeEnd;\n+        table[top + Interpreter.EXCEPTION_HANDLER_SLOT]    = handlerStart;\n+        table[top + Interpreter.EXCEPTION_TYPE_SLOT]     = isFinally ? 1 : 0;\n+        table[top + Interpreter.EXCEPTION_LOCAL_SLOT]    = exceptionObjectLocal;\n+        table[top + Interpreter.EXCEPTION_SCOPE_SLOT]    = scopeLocal;\n+\n+        exceptionTableTop = top + Interpreter.EXCEPTION_SLOT_SIZE;\n+    }\n+\n+    private byte[] increaseICodeCapacity(int extraSize)\n+    {\n+        int capacity = itsData.itsICode.length;\n+        int top = iCodeTop;\n+        if (top + extraSize <= capacity) throw Kit.codeBug();\n+        capacity *= 2;\n+        if (top + extraSize > capacity) {\n+            capacity = top + extraSize;\n+        }\n+        byte[] array = new byte[capacity];\n+        System.arraycopy(itsData.itsICode, 0, array, 0, top);\n+        itsData.itsICode = array;\n+        return array;\n+    }\n+\n+    private void stackChange(int change)\n+    {\n+        if (change <= 0) {\n+            stackDepth += change;\n+        } else {\n+            int newDepth = stackDepth + change;\n+            if (newDepth > itsData.itsMaxStack) {\n+                itsData.itsMaxStack = newDepth;\n+            }\n+            stackDepth = newDepth;\n+        }\n+    }\n+\n+    private int allocLocal()\n+    {\n+        int localSlot = localTop;\n+        ++localTop;\n+        if (localTop > itsData.itsMaxLocals) {\n+            itsData.itsMaxLocals = localTop;\n+        }\n+        return localSlot;\n+    }\n+\n+    private void releaseLocal(int localSlot)\n+    {\n+        --localTop;\n+        if (localSlot != localTop) Kit.codeBug();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/CompilerEnvirons.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov, igor@fastmail.fm\n+ *   Bob Jervis\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.util.Set;\n+\n+import org.mozilla.javascript.ast.ErrorCollector;\n+\n+public class CompilerEnvirons\n+{\n+    public CompilerEnvirons()\n+    {\n+        errorReporter = DefaultErrorReporter.instance;\n+        languageVersion = Context.VERSION_DEFAULT;\n+        generateDebugInfo = true;\n+        useDynamicScope = false;\n+        reservedKeywordAsIdentifier = false;\n+        allowKeywordAsObjectPropertyName = false;\n+        allowMemberExprAsFunctionName = false;\n+        xmlAvailable = true;\n+        optimizationLevel = 0;\n+        generatingSource = true;\n+        strictMode = false;\n+        warningAsError = false;\n+        generateObserverCount = false;\n+        allowSharpComments = false;\n+    }\n+\n+    public void initFromContext(Context cx)\n+    {\n+        setErrorReporter(cx.getErrorReporter());\n+        languageVersion = cx.getLanguageVersion();\n+        useDynamicScope = cx.compileFunctionsWithDynamicScopeFlag;\n+        generateDebugInfo = (!cx.isGeneratingDebugChanged()\n+                             || cx.isGeneratingDebug());\n+        reservedKeywordAsIdentifier\n+            = cx.hasFeature(Context.FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER);\n+        allowKeywordAsObjectPropertyName =\n+            (languageVersion >= Context.VERSION_1_8);\n+        allowMemberExprAsFunctionName\n+            = cx.hasFeature(Context.FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME);\n+        strictMode\n+            = cx.hasFeature(Context.FEATURE_STRICT_MODE);\n+        warningAsError = cx.hasFeature(Context.FEATURE_WARNING_AS_ERROR);\n+        xmlAvailable\n+            = cx.hasFeature(Context.FEATURE_E4X);\n+\n+        optimizationLevel = cx.getOptimizationLevel();\n+\n+        generatingSource = cx.isGeneratingSource();\n+        activationNames = cx.activationNames;\n+\n+        // Observer code generation in compiled code :\n+        generateObserverCount = cx.generateObserverCount;\n+    }\n+\n+    public final ErrorReporter getErrorReporter()\n+    {\n+        return errorReporter;\n+    }\n+\n+    public void setErrorReporter(ErrorReporter errorReporter)\n+    {\n+        if (errorReporter == null) throw new IllegalArgumentException();\n+        this.errorReporter = errorReporter;\n+    }\n+\n+    public final int getLanguageVersion()\n+    {\n+        return languageVersion;\n+    }\n+\n+    public void setLanguageVersion(int languageVersion)\n+    {\n+        Context.checkLanguageVersion(languageVersion);\n+        this.languageVersion = languageVersion;\n+    }\n+\n+    public final boolean isGenerateDebugInfo()\n+    {\n+        return generateDebugInfo;\n+    }\n+\n+    public void setGenerateDebugInfo(boolean flag)\n+    {\n+        this.generateDebugInfo = flag;\n+    }\n+\n+    public final boolean isUseDynamicScope()\n+    {\n+        return useDynamicScope;\n+    }\n+\n+    public final boolean isReservedKeywordAsIdentifier()\n+    {\n+        return reservedKeywordAsIdentifier;\n+    }\n+\n+    public void setReservedKeywordAsIdentifier(boolean flag)\n+    {\n+        reservedKeywordAsIdentifier = flag;\n+    }\n+\n+    public boolean isAllowKeywordAsObjectPropertyName() {\n+      return allowKeywordAsObjectPropertyName;\n+    }\n+\n+    public void setAllowKeywordAsObjectPropertyName(boolean flag) {\n+      this.allowKeywordAsObjectPropertyName = flag;\n+    }\n+\n+    /**\n+     * Extension to ECMA: if 'function &lt;name&gt;' is not followed\n+     * by '(', assume &lt;name&gt; starts a {@code memberExpr}\n+     */\n+    public final boolean isAllowMemberExprAsFunctionName()\n+    {\n+        return allowMemberExprAsFunctionName;\n+    }\n+\n+    public void setAllowMemberExprAsFunctionName(boolean flag)\n+    {\n+        allowMemberExprAsFunctionName = flag;\n+    }\n+\n+    public final boolean isXmlAvailable()\n+    {\n+        return xmlAvailable;\n+    }\n+\n+    public void setXmlAvailable(boolean flag)\n+    {\n+        xmlAvailable = flag;\n+    }\n+\n+    public final int getOptimizationLevel()\n+    {\n+        return optimizationLevel;\n+    }\n+\n+    public void setOptimizationLevel(int level)\n+    {\n+        Context.checkOptimizationLevel(level);\n+        this.optimizationLevel = level;\n+    }\n+\n+    public final boolean isGeneratingSource()\n+    {\n+        return generatingSource;\n+    }\n+\n+    public boolean getWarnTrailingComma() {\n+        return warnTrailingComma;\n+    }\n+\n+    public void setWarnTrailingComma(boolean warn) {\n+        warnTrailingComma = warn;\n+    }\n+\n+    public final boolean isStrictMode()\n+    {\n+        return strictMode;\n+    }\n+\n+    public void setStrictMode(boolean strict)\n+    {\n+        strictMode = strict;\n+    }\n+\n+    public final boolean reportWarningAsError()\n+    {\n+        return warningAsError;\n+    }\n+\n+    /**\n+     * Specify whether or not source information should be generated.\n+     * <p>\n+     * Without source information, evaluating the \"toString\" method\n+     * on JavaScript functions produces only \"[native code]\" for\n+     * the body of the function.\n+     * Note that code generated without source is not fully ECMA\n+     * conformant.\n+     */\n+    public void setGeneratingSource(boolean generatingSource)\n+    {\n+        this.generatingSource = generatingSource;\n+    }\n+\n+    /**\n+     * @return true iff code will be generated with callbacks to enable\n+     * instruction thresholds\n+     */\n+    public boolean isGenerateObserverCount() {\n+    \treturn generateObserverCount;\n+    }\n+\n+   /**\n+     * Turn on or off generation of code with callbacks to\n+     * track the count of executed instructions.\n+     * Currently only affects JVM byte code generation: this slows down the\n+     * generated code, but code generated without the callbacks will not\n+     * be counted toward instruction thresholds. Rhino's interpretive\n+     * mode does instruction counting without inserting callbacks, so\n+     * there is no requirement to compile code differently.\n+     * @param generateObserverCount if true, generated code will contain\n+     * calls to accumulate an estimate of the instructions executed.\n+     */\n+    public void setGenerateObserverCount(boolean generateObserverCount) {\n+        this.generateObserverCount = generateObserverCount;\n+    }\n+\n+    public boolean isRecordingComments() {\n+        return recordingComments;\n+    }\n+\n+    public void setRecordingComments(boolean record) {\n+        recordingComments = record;\n+    }\n+\n+    public boolean isRecordingLocalJsDocComments() {\n+        return recordingLocalJsDocComments;\n+    }\n+\n+    public void setRecordingLocalJsDocComments(boolean record) {\n+        recordingLocalJsDocComments = record;\n+    }\n+\n+    /**\n+     * Turn on or off full error recovery.  In this mode, parse errors do not\n+     * throw an exception, and the parser attempts to build a full syntax tree\n+     * from the input.  Useful for IDEs and other frontends.\n+     */\n+    public void setRecoverFromErrors(boolean recover) {\n+        recoverFromErrors = recover;\n+    }\n+\n+    public boolean recoverFromErrors() {\n+        return recoverFromErrors;\n+    }\n+\n+    /**\n+     * Puts the parser in \"IDE\" mode.  This enables some slightly more expensive\n+     * computations, such as figuring out helpful error bounds.\n+     */\n+    public void setIdeMode(boolean ide) {\n+        ideMode = ide;\n+    }\n+\n+    public boolean isIdeMode() {\n+        return ideMode;\n+    }\n+\n+    public Set<String> getActivationNames() {\n+        return activationNames;\n+    }\n+\n+    public void setActivationNames(Set<String> activationNames) {\n+        this.activationNames = activationNames;\n+    }\n+\n+    /**\n+     * Mozilla sources use the C preprocessor.\n+     */\n+    public void setAllowSharpComments(boolean allow) {\n+        allowSharpComments = allow;\n+    }\n+\n+    public boolean getAllowSharpComments() {\n+        return allowSharpComments;\n+    }\n+\n+    /**\n+     * Returns a {@code CompilerEnvirons} suitable for using Rhino\n+     * in an IDE environment.  Most features are enabled by default.\n+     * The {@link ErrorReporter} is set to an {@link ErrorCollector}.\n+     */\n+    public static CompilerEnvirons ideEnvirons() {\n+      CompilerEnvirons env = new CompilerEnvirons();\n+      env.setRecoverFromErrors(true);\n+      env.setRecordingComments(true);\n+      env.setStrictMode(true);\n+      env.setWarnTrailingComma(true);\n+      env.setLanguageVersion(170);\n+      env.setReservedKeywordAsIdentifier(true);\n+      env.setAllowKeywordAsObjectPropertyName(true);\n+      env.setIdeMode(true);\n+      env.setErrorReporter(new ErrorCollector());\n+      return env;\n+    }\n+\n+    private ErrorReporter errorReporter;\n+\n+    private int languageVersion;\n+    private boolean generateDebugInfo;\n+    private boolean useDynamicScope;\n+    private boolean reservedKeywordAsIdentifier;\n+    private boolean allowKeywordAsObjectPropertyName;\n+    private boolean allowMemberExprAsFunctionName;\n+    private boolean xmlAvailable;\n+    private int optimizationLevel;\n+    private boolean generatingSource;\n+    private boolean strictMode;\n+    private boolean warningAsError;\n+    private boolean generateObserverCount;\n+    private boolean recordingComments;\n+    private boolean recordingLocalJsDocComments;\n+    private boolean recoverFromErrors;\n+    private boolean warnTrailingComma;\n+    private boolean ideMode;\n+    private boolean allowSharpComments;\n+    Set<String> activationNames;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ConstProperties.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Bob Jervis\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+public interface ConstProperties {\n+    /**\n+     * Sets a named const property in this object.\n+     * <p>\n+     * The property is specified by a string name\n+     * as defined for <code>Scriptable.get</code>.\n+     * <p>\n+     * The possible values that may be passed in are as defined for\n+     * <code>Scriptable.get</code>. A class that implements this method may choose\n+     * to ignore calls to set certain properties, in which case those\n+     * properties are effectively read-only.<p>\n+     * For properties defined in a prototype chain,\n+     * use <code>putProperty</code> in ScriptableObject. <p>\n+     * Note that if a property <i>a</i> is defined in the prototype <i>p</i>\n+     * of an object <i>o</i>, then evaluating <code>o.a = 23</code> will cause\n+     * <code>set</code> to be called on the prototype <i>p</i> with\n+     * <i>o</i> as the  <i>start</i> parameter.\n+     * To preserve JavaScript semantics, it is the Scriptable\n+     * object's responsibility to modify <i>o</i>. <p>\n+     * This design allows properties to be defined in prototypes and implemented\n+     * in terms of getters and setters of Java values without consuming slots\n+     * in each instance.<p>\n+     * <p>\n+     * The values that may be set are limited to the following:\n+     * <UL>\n+     * <LI>java.lang.Boolean objects</LI>\n+     * <LI>java.lang.String objects</LI>\n+     * <LI>java.lang.Number objects</LI>\n+     * <LI>org.mozilla.javascript.Scriptable objects</LI>\n+     * <LI>null</LI>\n+     * <LI>The value returned by Context.getUndefinedValue()</LI>\n+     * </UL><p>\n+     * Arbitrary Java objects may be wrapped in a Scriptable by first calling\n+     * <code>Context.toObject</code>. This allows the property of a JavaScript\n+     * object to contain an arbitrary Java object as a value.<p>\n+     * Note that <code>has</code> will be called by the runtime first before\n+     * <code>set</code> is called to determine in which object the\n+     * property is defined.\n+     * Note that this method is not expected to traverse the prototype chain,\n+     * which is different from the ECMA [[Put]] operation.\n+     * @param name the name of the property\n+     * @param start the object whose property is being set\n+     * @param value value to set the property to\n+     * @see org.mozilla.javascript.Scriptable#has(String, Scriptable)\n+     * @see org.mozilla.javascript.Scriptable#get(String, Scriptable)\n+     * @see org.mozilla.javascript.ScriptableObject#putProperty(Scriptable, String, Object)\n+     * @see org.mozilla.javascript.Context#toObject(Object, Scriptable)\n+     */\n+    public void putConst(String name, Scriptable start, Object value);\n+\n+    /**\n+     * Reserves a definition spot for a const.  This will set up a definition\n+     * of the const property, but set its value to undefined.  The semantics of\n+     * the start parameter is the same as for putConst.\n+     * @param name The name of the property.\n+     * @param start The object whose property is being reserved.\n+     */\n+    public void defineConst(String name, Scriptable start);\n+\n+    /**\n+     * Returns true if the named property is defined as a const on this object.\n+     * @param name\n+     * @return true if the named property is defined as a const, false\n+     * otherwise.\n+     */\n+    public boolean isConst(String name);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Context.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *    Bob Jervis\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.io.CharArrayWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.Locale;\n+\n+import org.mozilla.javascript.ast.AstRoot;\n+import org.mozilla.javascript.ast.ScriptNode;\n+import org.mozilla.javascript.debug.DebuggableScript;\n+import org.mozilla.javascript.debug.Debugger;\n+import org.mozilla.javascript.xml.XMLLib;\n+\n+/**\n+ * This class represents the runtime context of an executing script.\n+ *\n+ * Before executing a script, an instance of Context must be created\n+ * and associated with the thread that will be executing the script.\n+ * The Context will be used to store information about the executing\n+ * of the script such as the call stack. Contexts are associated with\n+ * the current thread  using the {@link #call(ContextAction)}\n+ * or {@link #enter()} methods.<p>\n+ *\n+ * Different forms of script execution are supported. Scripts may be\n+ * evaluated from the source directly, or first compiled and then later\n+ * executed. Interactive execution is also supported.<p>\n+ *\n+ * Some aspects of script execution, such as type conversions and\n+ * object creation, may be accessed directly through methods of\n+ * Context.\n+ *\n+ * @see Scriptable\n+ */\n+\n+public class Context\n+{\n+    /**\n+     * Language versions.\n+     *\n+     * All integral values are reserved for future version numbers.\n+     */\n+\n+    /**\n+     * The unknown version.\n+     */\n+    public static final int VERSION_UNKNOWN =   -1;\n+\n+    /**\n+     * The default version.\n+     */\n+    public static final int VERSION_DEFAULT =    0;\n+\n+    /**\n+     * JavaScript 1.0\n+     */\n+    public static final int VERSION_1_0 =      100;\n+\n+    /**\n+     * JavaScript 1.1\n+     */\n+    public static final int VERSION_1_1 =      110;\n+\n+    /**\n+     * JavaScript 1.2\n+     */\n+    public static final int VERSION_1_2 =      120;\n+\n+    /**\n+     * JavaScript 1.3\n+     */\n+    public static final int VERSION_1_3 =      130;\n+\n+    /**\n+     * JavaScript 1.4\n+     */\n+    public static final int VERSION_1_4 =      140;\n+\n+    /**\n+     * JavaScript 1.5\n+     */\n+    public static final int VERSION_1_5 =      150;\n+\n+    /**\n+     * JavaScript 1.6\n+     */\n+    public static final int VERSION_1_6 =      160;\n+\n+    /**\n+     * JavaScript 1.7\n+     */\n+    public static final int VERSION_1_7 =      170;\n+\n+    /**\n+     * JavaScript 1.8\n+     */\n+    public static final int VERSION_1_8 =      180;\n+\n+    /**\n+     * Controls behaviour of <tt>Date.prototype.getYear()</tt>.\n+     * If <tt>hasFeature(FEATURE_NON_ECMA_GET_YEAR)</tt> returns true,\n+     * Date.prototype.getYear subtructs 1900 only if 1900 <= date < 2000.\n+     * The default behavior of {@link #hasFeature(int)} is always to subtruct\n+     * 1900 as rquired by ECMAScript B.2.4.\n+     */\n+    public static final int FEATURE_NON_ECMA_GET_YEAR = 1;\n+\n+    /**\n+     * Control if member expression as function name extension is available.\n+     * If <tt>hasFeature(FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME)</tt> returns\n+     * true, allow <tt>function memberExpression(args) { body }</tt> to be\n+     * syntax sugar for <tt>memberExpression = function(args) { body }</tt>,\n+     * when memberExpression is not a simple identifier.\n+     * See ECMAScript-262, section 11.2 for definition of memberExpression.\n+     * By default {@link #hasFeature(int)} returns false.\n+     */\n+    public static final int FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME = 2;\n+\n+    /**\n+     * Control if reserved keywords are treated as identifiers.\n+     * If <tt>hasFeature(RESERVED_KEYWORD_AS_IDENTIFIER)</tt> returns true,\n+     * treat future reserved keyword (see  Ecma-262, section 7.5.3) as ordinary\n+     * identifiers but warn about this usage.\n+     *\n+     * By default {@link #hasFeature(int)} returns false.\n+     */\n+    public static final int FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER = 3;\n+\n+    /**\n+     * Control if <tt>toString()</tt> should returns the same result\n+     * as  <tt>toSource()</tt> when applied to objects and arrays.\n+     * If <tt>hasFeature(FEATURE_TO_STRING_AS_SOURCE)</tt> returns true,\n+     * calling <tt>toString()</tt> on JS objects gives the same result as\n+     * calling <tt>toSource()</tt>. That is it returns JS source with code\n+     * to create an object with all enumeratable fields of the original object\n+     * instead of printing <tt>[object <i>result of\n+     * {@link Scriptable#getClassName()}</i>]</tt>.\n+     * <p>\n+     * By default {@link #hasFeature(int)} returns true only if\n+     * the current JS version is set to {@link #VERSION_1_2}.\n+     */\n+    public static final int FEATURE_TO_STRING_AS_SOURCE = 4;\n+\n+    /**\n+     * Control if properties <tt>__proto__</tt> and <tt>__parent__</tt>\n+     * are treated specially.\n+     * If <tt>hasFeature(FEATURE_PARENT_PROTO_PROPERTIES)</tt> returns true,\n+     * treat <tt>__parent__</tt> and <tt>__proto__</tt> as special properties.\n+     * <p>\n+     * The properties allow to query and set scope and prototype chains for the\n+     * objects. The special meaning of the properties is available\n+     * only when they are used as the right hand side of the dot operator.\n+     * For example, while <tt>x.__proto__ = y</tt> changes the prototype\n+     * chain of the object <tt>x</tt> to point to <tt>y</tt>,\n+     * <tt>x[\"__proto__\"] = y</tt> simply assigns a new value to the property\n+     * <tt>__proto__</tt> in <tt>x</tt> even when the feature is on.\n+     *\n+     * By default {@link #hasFeature(int)} returns true.\n+     */\n+    public static final int FEATURE_PARENT_PROTO_PROPERTIES = 5;\n+\n+        /**\n+         * @deprecated In previous releases, this name was given to\n+         * FEATURE_PARENT_PROTO_PROPERTIES.\n+         */\n+    public static final int FEATURE_PARENT_PROTO_PROPRTIES = 5;\n+\n+    /**\n+     * Control if support for E4X(ECMAScript for XML) extension is available.\n+     * If hasFeature(FEATURE_E4X) returns true, the XML syntax is available.\n+     * <p>\n+     * By default {@link #hasFeature(int)} returns true if\n+     * the current JS version is set to {@link #VERSION_DEFAULT}\n+     * or is at least {@link #VERSION_1_6}.\n+     * @since 1.6 Release 1\n+     */\n+    public static final int FEATURE_E4X = 6;\n+\n+    /**\n+     * Control if dynamic scope should be used for name access.\n+     * If hasFeature(FEATURE_DYNAMIC_SCOPE) returns true, then the name lookup\n+     * during name resolution will use the top scope of the script or function\n+     * which is at the top of JS execution stack instead of the top scope of the\n+     * script or function from the current stack frame if the top scope of\n+     * the top stack frame contains the top scope of the current stack frame\n+     * on its prototype chain.\n+     * <p>\n+     * This is useful to define shared scope containing functions that can\n+     * be called from scripts and functions using private scopes.\n+     * <p>\n+     * By default {@link #hasFeature(int)} returns false.\n+     * @since 1.6 Release 1\n+     */\n+    public static final int FEATURE_DYNAMIC_SCOPE = 7;\n+\n+    /**\n+     * Control if strict variable mode is enabled.\n+     * When the feature is on Rhino reports runtime errors if assignment\n+     * to a global variable that does not exist is executed. When the feature\n+     * is off such assignments create a new variable in the global scope as\n+     * required by ECMA 262.\n+     * <p>\n+     * By default {@link #hasFeature(int)} returns false.\n+     * @since 1.6 Release 1\n+     */\n+    public static final int FEATURE_STRICT_VARS = 8;\n+\n+    /**\n+     * Control if strict eval mode is enabled.\n+     * When the feature is on Rhino reports runtime errors if non-string\n+     * argument is passed to the eval function. When the feature is off\n+     * eval simply return non-string argument as is without performing any\n+     * evaluation as required by ECMA 262.\n+     * <p>\n+     * By default {@link #hasFeature(int)} returns false.\n+     * @since 1.6 Release 1\n+     */\n+    public static final int FEATURE_STRICT_EVAL = 9;\n+\n+    /**\n+     * When the feature is on Rhino will add a \"fileName\" and \"lineNumber\"\n+     * properties to Error objects automatically. When the feature is off, you\n+     * have to explicitly pass them as the second and third argument to the\n+     * Error constructor. Note that neither behavior is fully ECMA 262\n+     * compliant (as 262 doesn't specify a three-arg constructor), but keeping\n+     * the feature off results in Error objects that don't have\n+     * additional non-ECMA properties when constructed using the ECMA-defined\n+     * single-arg constructor and is thus desirable if a stricter ECMA\n+     * compliance is desired, specifically adherence to the point 15.11.5. of\n+     * the standard.\n+     * <p>\n+     * By default {@link #hasFeature(int)} returns false.\n+     * @since 1.6 Release 6\n+     */\n+    public static final int FEATURE_LOCATION_INFORMATION_IN_ERROR = 10;\n+\n+    /**\n+     * Controls whether JS 1.5 'strict mode' is enabled.\n+     * When the feature is on, Rhino reports more than a dozen different\n+     * warnings.  When the feature is off, these warnings are not generated.\n+     * FEATURE_STRICT_MODE implies FEATURE_STRICT_VARS and FEATURE_STRICT_EVAL.\n+     * <p>\n+     * By default {@link #hasFeature(int)} returns false.\n+     * @since 1.6 Release 6\n+     */\n+    public static final int FEATURE_STRICT_MODE = 11;\n+\n+    /**\n+     * Controls whether a warning should be treated as an error.\n+     * @since 1.6 Release 6\n+     */\n+    public static final int FEATURE_WARNING_AS_ERROR = 12;\n+\n+    /**\n+     * Enables enhanced access to Java.\n+     * Specifically, controls whether private and protected members can be\n+     * accessed, and whether scripts can catch all Java exceptions.\n+     * <p>\n+     * Note that this feature should only be enabled for trusted scripts.\n+     * <p>\n+     * By default {@link #hasFeature(int)} returns false.\n+     * @since 1.7 Release 1\n+     */\n+    public static final int FEATURE_ENHANCED_JAVA_ACCESS = 13;\n+\n+\n+    public static final String languageVersionProperty = \"language version\";\n+    public static final String errorReporterProperty   = \"error reporter\";\n+\n+    /**\n+     * Convenient value to use as zero-length array of objects.\n+     */\n+    public static final Object[] emptyArgs = ScriptRuntime.emptyArgs;\n+\n+    /**\n+     * Creates a new Context. The context will be associated with the {@link\n+     * ContextFactory#getGlobal() global context factory}.\n+     *\n+     * Note that the Context must be associated with a thread before\n+     * it can be used to execute a script.\n+     * @deprecated this constructor is deprecated because it creates a\n+     * dependency on a static singleton context factory. Use\n+     * {@link ContextFactory#enter()} or\n+     * {@link ContextFactory#call(ContextAction)} instead. If you subclass\n+     * this class, consider using {@link #Context(ContextFactory)} constructor\n+     * instead in the subclasses' constructors.\n+     */\n+    public Context()\n+    {\n+        this(ContextFactory.getGlobal());\n+    }\n+\n+    /**\n+     * Creates a new context. Provided as a preferred super constructor for\n+     * subclasses in place of the deprecated default public constructor.\n+     * @param factory the context factory associated with this context (most\n+     * likely, the one that created the context). Can not be null. The context\n+     * features are inherited from the factory, and the context will also\n+     * otherwise use its factory's services.\n+     * @throws IllegalArgumentException if factory parameter is null.\n+     */\n+    protected Context(ContextFactory factory)\n+    {\n+        if(factory == null) {\n+            throw new IllegalArgumentException(\"factory == null\");\n+        }\n+        this.factory = factory;\n+        setLanguageVersion(VERSION_DEFAULT);\n+        optimizationLevel = codegenClass != null ? 0 : -1;\n+        maximumInterpreterStackDepth = Integer.MAX_VALUE;\n+    }\n+\n+    /**\n+     * Get the current Context.\n+     *\n+     * The current Context is per-thread; this method looks up\n+     * the Context associated with the current thread. <p>\n+     *\n+     * @return the Context associated with the current thread, or\n+     *         null if no context is associated with the current\n+     *         thread.\n+     * @see ContextFactory#enterContext()\n+     * @see ContextFactory#call(ContextAction)\n+     */\n+    public static Context getCurrentContext()\n+    {\n+        Object helper = VMBridge.instance.getThreadContextHelper();\n+        return VMBridge.instance.getContext(helper);\n+    }\n+\n+    /**\n+     * Same as calling {@link ContextFactory#enterContext()} on the global\n+     * ContextFactory instance.\n+     * @return a Context associated with the current thread\n+     * @see #getCurrentContext()\n+     * @see #exit()\n+     * @see #call(ContextAction)\n+     */\n+    public static Context enter()\n+    {\n+        return enter(null);\n+    }\n+\n+    /**\n+     * Get a Context associated with the current thread, using\n+     * the given Context if need be.\n+     * <p>\n+     * The same as <code>enter()</code> except that <code>cx</code>\n+     * is associated with the current thread and returned if\n+     * the current thread has no associated context and <code>cx</code>\n+     * is not associated with any other thread.\n+     * @param cx a Context to associate with the thread if possible\n+     * @return a Context associated with the current thread\n+     * @deprecated use {@link ContextFactory#enterContext(Context)} instead as\n+     * this method relies on usage of a static singleton \"global\" ContextFactory.\n+     * @see ContextFactory#enterContext(Context)\n+     * @see ContextFactory#call(ContextAction)\n+     */\n+    public static Context enter(Context cx)\n+    {\n+        return enter(cx, ContextFactory.getGlobal());\n+    }\n+\n+    static final Context enter(Context cx, ContextFactory factory)\n+    {\n+        Object helper = VMBridge.instance.getThreadContextHelper();\n+        Context old = VMBridge.instance.getContext(helper);\n+        if (old != null) {\n+            cx = old;\n+        } else {\n+            if (cx == null) {\n+                cx = factory.makeContext();\n+                if (cx.enterCount != 0) {\n+                    throw new IllegalStateException(\"factory.makeContext() returned Context instance already associated with some thread\");\n+                }\n+                factory.onContextCreated(cx);\n+                if (factory.isSealed() && !cx.isSealed()) {\n+                    cx.seal(null);\n+                }\n+            } else {\n+                if (cx.enterCount != 0) {\n+                    throw new IllegalStateException(\"can not use Context instance already associated with some thread\");\n+                }\n+            }\n+            VMBridge.instance.setContext(helper, cx);\n+        }\n+        ++cx.enterCount;\n+        return cx;\n+     }\n+\n+    /**\n+     * Exit a block of code requiring a Context.\n+     *\n+     * Calling <code>exit()</code> will remove the association between\n+     * the current thread and a Context if the prior call to\n+     * {@link ContextFactory#enterContext()} on this thread newly associated a\n+     * Context with this thread. Once the current thread no longer has an\n+     * associated Context, it cannot be used to execute JavaScript until it is\n+     * again associated with a Context.\n+     * @see ContextFactory#enterContext()\n+     */\n+    public static void exit()\n+    {\n+        Object helper = VMBridge.instance.getThreadContextHelper();\n+        Context cx = VMBridge.instance.getContext(helper);\n+        if (cx == null) {\n+            throw new IllegalStateException(\n+                \"Calling Context.exit without previous Context.enter\");\n+        }\n+        if (cx.enterCount < 1) Kit.codeBug();\n+        if (--cx.enterCount == 0) {\n+            VMBridge.instance.setContext(helper, null);\n+            cx.factory.onContextReleased(cx);\n+        }\n+    }\n+\n+    /**\n+     * Call {@link ContextAction#run(Context cx)}\n+     * using the Context instance associated with the current thread.\n+     * If no Context is associated with the thread, then\n+     * <tt>ContextFactory.getGlobal().makeContext()</tt> will be called to\n+     * construct new Context instance. The instance will be temporary\n+     * associated with the thread during call to\n+     * {@link ContextAction#run(Context)}.\n+     * @deprecated use {@link ContextFactory#call(ContextAction)} instead as\n+     * this method relies on usage of a static singleton \"global\"\n+     * ContextFactory.\n+     * @return The result of {@link ContextAction#run(Context)}.\n+     */\n+    public static Object call(ContextAction action)\n+    {\n+        return call(ContextFactory.getGlobal(), action);\n+    }\n+\n+    /**\n+     * Call {@link\n+     * Callable#call(Context cx, Scriptable scope, Scriptable thisObj,\n+     *               Object[] args)}\n+     * using the Context instance associated with the current thread.\n+     * If no Context is associated with the thread, then\n+     * {@link ContextFactory#makeContext()} will be called to construct\n+     * new Context instance. The instance will be temporary associated\n+     * with the thread during call to {@link ContextAction#run(Context)}.\n+     * <p>\n+     * It is allowed but not advisable to use null for <tt>factory</tt>\n+     * argument in which case the global static singleton ContextFactory\n+     * instance will be used to create new context instances.\n+     * @see ContextFactory#call(ContextAction)\n+     */\n+    public static Object call(ContextFactory factory, final Callable callable,\n+                              final Scriptable scope, final Scriptable thisObj,\n+                              final Object[] args)\n+    {\n+        if(factory == null) {\n+            factory = ContextFactory.getGlobal();\n+        }\n+        return call(factory, new ContextAction() {\n+            public Object run(Context cx) {\n+                return callable.call(cx, scope, thisObj, args);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * The method implements {@link ContextFactory#call(ContextAction)} logic.\n+     */\n+    static Object call(ContextFactory factory, ContextAction action) {\n+        Context cx = enter(null, factory);\n+        try {\n+            return action.run(cx);\n+        }\n+        finally {\n+            exit();\n+        }\n+    }\n+\n+    /**\n+     * @deprecated\n+     * @see ContextFactory#addListener(ContextFactory.Listener)\n+     * @see ContextFactory#getGlobal()\n+     */\n+    public static void addContextListener(ContextListener listener)\n+    {\n+        // Special workaround for the debugger\n+        String DBG = \"org.mozilla.javascript.tools.debugger.Main\";\n+        if (DBG.equals(listener.getClass().getName())) {\n+            Class<?> cl = listener.getClass();\n+            Class<?> factoryClass = Kit.classOrNull(\n+                \"org.mozilla.javascript.ContextFactory\");\n+            Class<?>[] sig = { factoryClass };\n+            Object[] args = { ContextFactory.getGlobal() };\n+            try {\n+                Method m = cl.getMethod(\"attachTo\", sig);\n+                m.invoke(listener, args);\n+            } catch (Exception ex) {\n+                RuntimeException rex = new RuntimeException();\n+                Kit.initCause(rex, ex);\n+                throw rex;\n+            }\n+            return;\n+        }\n+\n+        ContextFactory.getGlobal().addListener(listener);\n+    }\n+\n+    /**\n+     * @deprecated\n+     * @see ContextFactory#removeListener(ContextFactory.Listener)\n+     * @see ContextFactory#getGlobal()\n+     */\n+    public static void removeContextListener(ContextListener listener)\n+    {\n+        ContextFactory.getGlobal().addListener(listener);\n+    }\n+\n+    /**\n+     * Return {@link ContextFactory} instance used to create this Context.\n+     */\n+    public final ContextFactory getFactory()\n+    {\n+        return factory;\n+    }\n+\n+    /**\n+     * Checks if this is a sealed Context. A sealed Context instance does not\n+     * allow to modify any of its properties and will throw an exception\n+     * on any such attempt.\n+     * @see #seal(Object sealKey)\n+     */\n+    public final boolean isSealed()\n+    {\n+        return sealed;\n+    }\n+\n+    /**\n+     * Seal this Context object so any attempt to modify any of its properties\n+     * including calling {@link #enter()} and {@link #exit()} methods will\n+     * throw an exception.\n+     * <p>\n+     * If <tt>sealKey</tt> is not null, calling\n+     * {@link #unseal(Object sealKey)} with the same key unseals\n+     * the object. If <tt>sealKey</tt> is null, unsealing is no longer possible.\n+     *\n+     * @see #isSealed()\n+     * @see #unseal(Object)\n+     */\n+    public final void seal(Object sealKey)\n+    {\n+        if (sealed) onSealedMutation();\n+        sealed = true;\n+        this.sealKey = sealKey;\n+    }\n+\n+    /**\n+     * Unseal previously sealed Context object.\n+     * The <tt>sealKey</tt> argument should not be null and should match\n+     * <tt>sealKey</tt> suplied with the last call to\n+     * {@link #seal(Object)} or an exception will be thrown.\n+     *\n+     * @see #isSealed()\n+     * @see #seal(Object sealKey)\n+     */\n+    public final void unseal(Object sealKey)\n+    {\n+        if (sealKey == null) throw new IllegalArgumentException();\n+        if (this.sealKey != sealKey) throw new IllegalArgumentException();\n+        if (!sealed) throw new IllegalStateException();\n+        sealed = false;\n+        this.sealKey = null;\n+    }\n+\n+    static void onSealedMutation()\n+    {\n+        throw new IllegalStateException();\n+    }\n+\n+    /**\n+     * Get the current language version.\n+     * <p>\n+     * The language version number affects JavaScript semantics as detailed\n+     * in the overview documentation.\n+     *\n+     * @return an integer that is one of VERSION_1_0, VERSION_1_1, etc.\n+     */\n+    public final int getLanguageVersion()\n+    {\n+       return version;\n+    }\n+\n+    /**\n+     * Set the language version.\n+     *\n+     * <p>\n+     * Setting the language version will affect functions and scripts compiled\n+     * subsequently. See the overview documentation for version-specific\n+     * behavior.\n+     *\n+     * @param version the version as specified by VERSION_1_0, VERSION_1_1, etc.\n+     */\n+    public void setLanguageVersion(int version)\n+    {\n+        if (sealed) onSealedMutation();\n+        checkLanguageVersion(version);\n+        Object listeners = propertyListeners;\n+        if (listeners != null && version != this.version) {\n+            firePropertyChangeImpl(listeners, languageVersionProperty,\n+                               Integer.valueOf(this.version),\n+                               Integer.valueOf(version));\n+        }\n+        this.version = version;\n+    }\n+\n+    public static boolean isValidLanguageVersion(int version)\n+    {\n+        switch (version) {\n+            case VERSION_DEFAULT:\n+            case VERSION_1_0:\n+            case VERSION_1_1:\n+            case VERSION_1_2:\n+            case VERSION_1_3:\n+            case VERSION_1_4:\n+            case VERSION_1_5:\n+            case VERSION_1_6:\n+            case VERSION_1_7:\n+            case VERSION_1_8:\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    public static void checkLanguageVersion(int version)\n+    {\n+        if (isValidLanguageVersion(version)) {\n+            return;\n+        }\n+        throw new IllegalArgumentException(\"Bad language version: \"+version);\n+    }\n+\n+    /**\n+     * Get the implementation version.\n+     *\n+     * <p>\n+     * The implementation version is of the form\n+     * <pre>\n+     *    \"<i>name langVer</i> <code>release</code> <i>relNum date</i>\"\n+     * </pre>\n+     * where <i>name</i> is the name of the product, <i>langVer</i> is\n+     * the language version, <i>relNum</i> is the release number, and\n+     * <i>date</i> is the release date for that specific\n+     * release in the form \"yyyy mm dd\".\n+     *\n+     * @return a string that encodes the product, language version, release\n+     *         number, and date.\n+     */\n+    public final String getImplementationVersion()\n+    {\n+        // XXX Probably it would be better to embed this directly into source\n+        // with special build preprocessing but that would require some ant\n+        // tweaking and then replacing token in resource files was simpler\n+        if (implementationVersion == null) {\n+            implementationVersion\n+                = ScriptRuntime.getMessage0(\"implementation.version\");\n+        }\n+        return implementationVersion;\n+    }\n+\n+    /**\n+     * Get the current error reporter.\n+     *\n+     * @see org.mozilla.javascript.ErrorReporter\n+     */\n+    public final ErrorReporter getErrorReporter()\n+    {\n+        if (errorReporter == null) {\n+            return DefaultErrorReporter.instance;\n+        }\n+        return errorReporter;\n+    }\n+\n+    /**\n+     * Change the current error reporter.\n+     *\n+     * @return the previous error reporter\n+     * @see org.mozilla.javascript.ErrorReporter\n+     */\n+    public final ErrorReporter setErrorReporter(ErrorReporter reporter)\n+    {\n+        if (sealed) onSealedMutation();\n+        if (reporter == null) throw new IllegalArgumentException();\n+        ErrorReporter old = getErrorReporter();\n+        if (reporter == old) {\n+            return old;\n+        }\n+        Object listeners = propertyListeners;\n+        if (listeners != null) {\n+            firePropertyChangeImpl(listeners, errorReporterProperty,\n+                                   old, reporter);\n+        }\n+        this.errorReporter = reporter;\n+        return old;\n+    }\n+\n+    /**\n+     * Get the current locale.  Returns the default locale if none has\n+     * been set.\n+     *\n+     * @see java.util.Locale\n+     */\n+\n+    public final Locale getLocale()\n+    {\n+        if (locale == null)\n+            locale = Locale.getDefault();\n+        return locale;\n+    }\n+\n+    /**\n+     * Set the current locale.\n+     *\n+     * @see java.util.Locale\n+     */\n+    public final Locale setLocale(Locale loc)\n+    {\n+        if (sealed) onSealedMutation();\n+        Locale result = locale;\n+        locale = loc;\n+        return result;\n+    }\n+\n+    /**\n+     * Register an object to receive notifications when a bound property\n+     * has changed\n+     * @see java.beans.PropertyChangeEvent\n+     * @see #removePropertyChangeListener(java.beans.PropertyChangeListener)\n+     * @param l the listener\n+     */\n+    public final void addPropertyChangeListener(PropertyChangeListener l)\n+    {\n+        if (sealed) onSealedMutation();\n+        propertyListeners = Kit.addListener(propertyListeners, l);\n+    }\n+\n+    /**\n+     * Remove an object from the list of objects registered to receive\n+     * notification of changes to a bounded property\n+     * @see java.beans.PropertyChangeEvent\n+     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)\n+     * @param l the listener\n+     */\n+    public final void removePropertyChangeListener(PropertyChangeListener l)\n+    {\n+        if (sealed) onSealedMutation();\n+        propertyListeners = Kit.removeListener(propertyListeners, l);\n+    }\n+\n+    /**\n+     * Notify any registered listeners that a bounded property has changed\n+     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)\n+     * @see #removePropertyChangeListener(java.beans.PropertyChangeListener)\n+     * @see java.beans.PropertyChangeListener\n+     * @see java.beans.PropertyChangeEvent\n+     * @param  property  the bound property\n+     * @param  oldValue  the old value\n+     * @param  newValue   the new value\n+     */\n+    final void firePropertyChange(String property, Object oldValue,\n+                                  Object newValue)\n+    {\n+        Object listeners = propertyListeners;\n+        if (listeners != null) {\n+            firePropertyChangeImpl(listeners, property, oldValue, newValue);\n+        }\n+    }\n+\n+    private void firePropertyChangeImpl(Object listeners, String property,\n+                                        Object oldValue, Object newValue)\n+    {\n+        for (int i = 0; ; ++i) {\n+            Object l = Kit.getListener(listeners, i);\n+            if (l == null)\n+                break;\n+            if (l instanceof PropertyChangeListener) {\n+                PropertyChangeListener pcl = (PropertyChangeListener)l;\n+                pcl.propertyChange(new PropertyChangeEvent(\n+                    this, property, oldValue, newValue));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Report a warning using the error reporter for the current thread.\n+     *\n+     * @param message the warning message to report\n+     * @param sourceName a string describing the source, such as a filename\n+     * @param lineno the starting line number\n+     * @param lineSource the text of the line (may be null)\n+     * @param lineOffset the offset into lineSource where problem was detected\n+     * @see org.mozilla.javascript.ErrorReporter\n+     */\n+    public static void reportWarning(String message, String sourceName,\n+                                     int lineno, String lineSource,\n+                                     int lineOffset)\n+    {\n+        Context cx = Context.getContext();\n+        if (cx.hasFeature(FEATURE_WARNING_AS_ERROR))\n+            reportError(message, sourceName, lineno, lineSource, lineOffset);\n+        else\n+            cx.getErrorReporter().warning(message, sourceName, lineno,\n+                                          lineSource, lineOffset);\n+    }\n+\n+    /**\n+     * Report a warning using the error reporter for the current thread.\n+     *\n+     * @param message the warning message to report\n+     * @see org.mozilla.javascript.ErrorReporter\n+     */\n+    public static void reportWarning(String message)\n+    {\n+        int[] linep = { 0 };\n+        String filename = getSourcePositionFromStack(linep);\n+        Context.reportWarning(message, filename, linep[0], null, 0);\n+    }\n+\n+    public static void reportWarning(String message, Throwable t)\n+    {\n+        int[] linep = { 0 };\n+        String filename = getSourcePositionFromStack(linep);\n+        Writer sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw);\n+        pw.println(message);\n+        t.printStackTrace(pw);\n+        pw.flush();\n+        Context.reportWarning(sw.toString(), filename, linep[0], null, 0);\n+    }\n+\n+    /**\n+     * Report an error using the error reporter for the current thread.\n+     *\n+     * @param message the error message to report\n+     * @param sourceName a string describing the source, such as a filename\n+     * @param lineno the starting line number\n+     * @param lineSource the text of the line (may be null)\n+     * @param lineOffset the offset into lineSource where problem was detected\n+     * @see org.mozilla.javascript.ErrorReporter\n+     */\n+    public static void reportError(String message, String sourceName,\n+                                   int lineno, String lineSource,\n+                                   int lineOffset)\n+    {\n+        Context cx = getCurrentContext();\n+        if (cx != null) {\n+            cx.getErrorReporter().error(message, sourceName, lineno,\n+                                        lineSource, lineOffset);\n+        } else {\n+            throw new EvaluatorException(message, sourceName, lineno,\n+                                         lineSource, lineOffset);\n+        }\n+    }\n+\n+    /**\n+     * Report an error using the error reporter for the current thread.\n+     *\n+     * @param message the error message to report\n+     * @see org.mozilla.javascript.ErrorReporter\n+     */\n+    public static void reportError(String message)\n+    {\n+        int[] linep = { 0 };\n+        String filename = getSourcePositionFromStack(linep);\n+        Context.reportError(message, filename, linep[0], null, 0);\n+    }\n+\n+    /**\n+     * Report a runtime error using the error reporter for the current thread.\n+     *\n+     * @param message the error message to report\n+     * @param sourceName a string describing the source, such as a filename\n+     * @param lineno the starting line number\n+     * @param lineSource the text of the line (may be null)\n+     * @param lineOffset the offset into lineSource where problem was detected\n+     * @return a runtime exception that will be thrown to terminate the\n+     *         execution of the script\n+     * @see org.mozilla.javascript.ErrorReporter\n+     */\n+    public static EvaluatorException reportRuntimeError(String message,\n+                                                        String sourceName,\n+                                                        int lineno,\n+                                                        String lineSource,\n+                                                        int lineOffset)\n+    {\n+        Context cx = getCurrentContext();\n+        if (cx != null) {\n+            return cx.getErrorReporter().\n+                            runtimeError(message, sourceName, lineno,\n+                                         lineSource, lineOffset);\n+        } else {\n+            throw new EvaluatorException(message, sourceName, lineno,\n+                                         lineSource, lineOffset);\n+        }\n+    }\n+\n+    static EvaluatorException reportRuntimeError0(String messageId)\n+    {\n+        String msg = ScriptRuntime.getMessage0(messageId);\n+        return reportRuntimeError(msg);\n+    }\n+\n+    static EvaluatorException reportRuntimeError1(String messageId,\n+                                                  Object arg1)\n+    {\n+        String msg = ScriptRuntime.getMessage1(messageId, arg1);\n+        return reportRuntimeError(msg);\n+    }\n+\n+    static EvaluatorException reportRuntimeError2(String messageId,\n+                                                  Object arg1, Object arg2)\n+    {\n+        String msg = ScriptRuntime.getMessage2(messageId, arg1, arg2);\n+        return reportRuntimeError(msg);\n+    }\n+\n+    static EvaluatorException reportRuntimeError3(String messageId,\n+                                                  Object arg1, Object arg2,\n+                                                  Object arg3)\n+    {\n+        String msg = ScriptRuntime.getMessage3(messageId, arg1, arg2, arg3);\n+        return reportRuntimeError(msg);\n+    }\n+\n+    static EvaluatorException reportRuntimeError4(String messageId,\n+                                                  Object arg1, Object arg2,\n+                                                  Object arg3, Object arg4)\n+    {\n+        String msg\n+            = ScriptRuntime.getMessage4(messageId, arg1, arg2, arg3, arg4);\n+        return reportRuntimeError(msg);\n+    }\n+\n+    /**\n+     * Report a runtime error using the error reporter for the current thread.\n+     *\n+     * @param message the error message to report\n+     * @see org.mozilla.javascript.ErrorReporter\n+     */\n+    public static EvaluatorException reportRuntimeError(String message)\n+    {\n+        int[] linep = { 0 };\n+        String filename = getSourcePositionFromStack(linep);\n+        return Context.reportRuntimeError(message, filename, linep[0], null, 0);\n+    }\n+\n+    /**\n+     * Initialize the standard objects.\n+     *\n+     * Creates instances of the standard objects and their constructors\n+     * (Object, String, Number, Date, etc.), setting up 'scope' to act\n+     * as a global object as in ECMA 15.1.<p>\n+     *\n+     * This method must be called to initialize a scope before scripts\n+     * can be evaluated in that scope.<p>\n+     *\n+     * This method does not affect the Context it is called upon.\n+     *\n+     * @return the initialized scope\n+     */\n+    public final ScriptableObject initStandardObjects()\n+    {\n+        return initStandardObjects(null, false);\n+    }\n+\n+    /**\n+     * Initialize the standard objects.\n+     *\n+     * Creates instances of the standard objects and their constructors\n+     * (Object, String, Number, Date, etc.), setting up 'scope' to act\n+     * as a global object as in ECMA 15.1.<p>\n+     *\n+     * This method must be called to initialize a scope before scripts\n+     * can be evaluated in that scope.<p>\n+     *\n+     * This method does not affect the Context it is called upon.\n+     *\n+     * @param scope the scope to initialize, or null, in which case a new\n+     *        object will be created to serve as the scope\n+     * @return the initialized scope. The method returns the value of the scope\n+     *         argument if it is not null or newly allocated scope object which\n+     *         is an instance {@link ScriptableObject}.\n+     */\n+    public final Scriptable initStandardObjects(ScriptableObject scope)\n+    {\n+        return initStandardObjects(scope, false);\n+    }\n+\n+    /**\n+     * Initialize the standard objects.\n+     *\n+     * Creates instances of the standard objects and their constructors\n+     * (Object, String, Number, Date, etc.), setting up 'scope' to act\n+     * as a global object as in ECMA 15.1.<p>\n+     *\n+     * This method must be called to initialize a scope before scripts\n+     * can be evaluated in that scope.<p>\n+     *\n+     * This method does not affect the Context it is called upon.<p>\n+     *\n+     * This form of the method also allows for creating \"sealed\" standard\n+     * objects. An object that is sealed cannot have properties added, changed,\n+     * or removed. This is useful to create a \"superglobal\" that can be shared\n+     * among several top-level objects. Note that sealing is not allowed in\n+     * the current ECMA/ISO language specification, but is likely for\n+     * the next version.\n+     *\n+     * @param scope the scope to initialize, or null, in which case a new\n+     *        object will be created to serve as the scope\n+     * @param sealed whether or not to create sealed standard objects that\n+     *        cannot be modified.\n+     * @return the initialized scope. The method returns the value of the scope\n+     *         argument if it is not null or newly allocated scope object.\n+     * @since 1.4R3\n+     */\n+    public ScriptableObject initStandardObjects(ScriptableObject scope,\n+                                                boolean sealed)\n+    {\n+        return ScriptRuntime.initStandardObjects(this, scope, sealed);\n+    }\n+\n+    /**\n+     * Get the singleton object that represents the JavaScript Undefined value.\n+     */\n+    public static Object getUndefinedValue()\n+    {\n+        return Undefined.instance;\n+    }\n+\n+    /**\n+     * Evaluate a JavaScript source string.\n+     *\n+     * The provided source name and line number are used for error messages\n+     * and for producing debug information.\n+     *\n+     * @param scope the scope to execute in\n+     * @param source the JavaScript source\n+     * @param sourceName a string describing the source, such as a filename\n+     * @param lineno the starting line number\n+     * @param securityDomain an arbitrary object that specifies security\n+     *        information about the origin or owner of the script. For\n+     *        implementations that don't care about security, this value\n+     *        may be null.\n+     * @return the result of evaluating the string\n+     * @see org.mozilla.javascript.SecurityController\n+     */\n+    public final Object evaluateString(Scriptable scope, String source,\n+                                       String sourceName, int lineno,\n+                                       Object securityDomain)\n+    {\n+        Script script = compileString(source, sourceName, lineno,\n+                                      securityDomain);\n+        if (script != null) {\n+            return script.exec(this, scope);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Evaluate a reader as JavaScript source.\n+     *\n+     * All characters of the reader are consumed.\n+     *\n+     * @param scope the scope to execute in\n+     * @param in the Reader to get JavaScript source from\n+     * @param sourceName a string describing the source, such as a filename\n+     * @param lineno the starting line number\n+     * @param securityDomain an arbitrary object that specifies security\n+     *        information about the origin or owner of the script. For\n+     *        implementations that don't care about security, this value\n+     *        may be null.\n+     * @return the result of evaluating the source\n+     *\n+     * @exception IOException if an IOException was generated by the Reader\n+     */\n+    public final Object evaluateReader(Scriptable scope, Reader in,\n+                                       String sourceName, int lineno,\n+                                       Object securityDomain)\n+        throws IOException\n+    {\n+        Script script = compileReader(scope, in, sourceName, lineno,\n+                                      securityDomain);\n+        if (script != null) {\n+            return script.exec(this, scope);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Execute script that may pause execution by capturing a continuation.\n+     * Caller must be prepared to catch a ContinuationPending exception\n+     * and resume execution by calling\n+     * {@link #resumeContinuation(Object, Scriptable, Object)}.\n+     * @param script The script to execute. Script must have been compiled\n+     *      with interpreted mode (optimization level -1)\n+     * @param scope The scope to execute the script against\n+     * @throws ContinuationPending if the script calls a function that results\n+     *      in a call to {@link #captureContinuation()}\n+     * @since 1.7 Release 2\n+     */\n+    public Object executeScriptWithContinuations(Script script,\n+            Scriptable scope)\n+        throws ContinuationPending\n+    {\n+        if (!(script instanceof InterpretedFunction) ||\n+            !((InterpretedFunction)script).isScript())\n+        {\n+            // Can only be applied to scripts\n+            throw new IllegalArgumentException(\"Script argument was not\" +\n+                    \" a script or was not created by interpreted mode \");\n+        }\n+        return callFunctionWithContinuations((InterpretedFunction) script,\n+                scope, ScriptRuntime.emptyArgs);\n+    }\n+\n+    /**\n+     * Call function that may pause execution by capturing a continuation.\n+     * Caller must be prepared to catch a ContinuationPending exception\n+     * and resume execution by calling\n+     * {@link #resumeContinuation(Object, Scriptable, Object)}.\n+     * @param function The function to call. The function must have been\n+     *      compiled with interpreted mode (optimization level -1)\n+     * @param scope The scope to execute the script against\n+     * @param args The arguments for the function\n+     * @throws ContinuationPending if the script calls a function that results\n+     *      in a call to {@link #captureContinuation()}\n+     * @since 1.7 Release 2\n+     */\n+    public Object callFunctionWithContinuations(Callable function,\n+            Scriptable scope, Object[] args)\n+        throws ContinuationPending\n+    {\n+        if (!(function instanceof InterpretedFunction)) {\n+            // Can only be applied to scripts\n+            throw new IllegalArgumentException(\"Function argument was not\" +\n+                    \" created by interpreted mode \");\n+        }\n+        if (ScriptRuntime.hasTopCall(this)) {\n+            throw new IllegalStateException(\"Cannot have any pending top \" +\n+                    \"calls when executing a script with continuations\");\n+        }\n+        // Annotate so we can check later to ensure no java code in\n+        // intervening frames\n+        isContinuationsTopCall = true;\n+        return ScriptRuntime.doTopCall(function, this, scope, scope, args);\n+    }\n+\n+    /**\n+     * Capture a continuation from the current execution. The execution must\n+     * have been started via a call to\n+     * {@link #executeScriptWithContinuations(Script, Scriptable)} or\n+     * {@link #callFunctionWithContinuations(Callable, Scriptable, Object[])}.\n+     * This implies that the code calling\n+     * this method must have been called as a function from the\n+     * JavaScript script. Also, there cannot be any non-JavaScript code\n+     * between the JavaScript frames (e.g., a call to eval()). The\n+     * ContinuationPending exception returned must be thrown.\n+     * @return A ContinuationPending exception that must be thrown\n+     * @since 1.7 Release 2\n+     */\n+    public ContinuationPending captureContinuation() {\n+        return new ContinuationPending(\n+                Interpreter.captureContinuation(this));\n+    }\n+\n+    /**\n+     * Restarts execution of the JavaScript suspended at the call\n+     * to {@link #captureContinuation()}. Execution of the code will resume\n+     * with the functionResult as the result of the call that captured the\n+     * continuation.\n+     * Execution of the script will either conclude normally and the\n+     * result returned, another continuation will be captured and\n+     * thrown, or the script will terminate abnormally and throw an exception.\n+     * @param continuation The value returned by\n+     * {@link ContinuationPending#getContinuation()}\n+     * @param functionResult This value will appear to the code being resumed\n+     *      as the result of the function that captured the continuation\n+     * @throws ContinuationPending if another continuation is captured before\n+     *      the code terminates\n+     * @since 1.7 Release 2\n+     */\n+    public Object resumeContinuation(Object continuation,\n+            Scriptable scope, Object functionResult)\n+            throws ContinuationPending\n+    {\n+        Object[] args = { functionResult };\n+        return Interpreter.restartContinuation(\n+                (org.mozilla.javascript.NativeContinuation) continuation,\n+                this, scope, args);\n+    }\n+\n+    /**\n+     * Check whether a string is ready to be compiled.\n+     * <p>\n+     * stringIsCompilableUnit is intended to support interactive compilation of\n+     * JavaScript.  If compiling the string would result in an error\n+     * that might be fixed by appending more source, this method\n+     * returns false.  In every other case, it returns true.\n+     * <p>\n+     * Interactive shells may accumulate source lines, using this\n+     * method after each new line is appended to check whether the\n+     * statement being entered is complete.\n+     *\n+     * @param source the source buffer to check\n+     * @return whether the source is ready for compilation\n+     * @since 1.4 Release 2\n+     */\n+    public final boolean stringIsCompilableUnit(String source)\n+    {\n+        boolean errorseen = false;\n+        CompilerEnvirons compilerEnv = new CompilerEnvirons();\n+        compilerEnv.initFromContext(this);\n+        // no source name or source text manager, because we're just\n+        // going to throw away the result.\n+        compilerEnv.setGeneratingSource(false);\n+        Parser p = new Parser(compilerEnv, DefaultErrorReporter.instance);\n+        try {\n+            p.parse(source, null, 1);\n+        } catch (EvaluatorException ee) {\n+            errorseen = true;\n+        }\n+        // Return false only if an error occurred as a result of reading past\n+        // the end of the file, i.e. if the source could be fixed by\n+        // appending more source.\n+        if (errorseen && p.eof())\n+            return false;\n+        else\n+            return true;\n+    }\n+\n+    /**\n+     * @deprecated\n+     * @see #compileReader(Reader in, String sourceName, int lineno,\n+     *                     Object securityDomain)\n+     */\n+    public final Script compileReader(Scriptable scope, Reader in,\n+                                      String sourceName, int lineno,\n+                                      Object securityDomain)\n+        throws IOException\n+    {\n+        return compileReader(in, sourceName, lineno, securityDomain);\n+    }\n+\n+    /**\n+     * Compiles the source in the given reader.\n+     * <p>\n+     * Returns a script that may later be executed.\n+     * Will consume all the source in the reader.\n+     *\n+     * @param in the input reader\n+     * @param sourceName a string describing the source, such as a filename\n+     * @param lineno the starting line number for reporting errors\n+     * @param securityDomain an arbitrary object that specifies security\n+     *        information about the origin or owner of the script. For\n+     *        implementations that don't care about security, this value\n+     *        may be null.\n+     * @return a script that may later be executed\n+     * @exception IOException if an IOException was generated by the Reader\n+     * @see org.mozilla.javascript.Script\n+     */\n+    public final Script compileReader(Reader in, String sourceName,\n+                                      int lineno, Object securityDomain)\n+        throws IOException\n+    {\n+        if (lineno < 0) {\n+            // For compatibility IllegalArgumentException can not be thrown here\n+            lineno = 0;\n+        }\n+        return (Script) compileImpl(null, in, null, sourceName, lineno,\n+                                    securityDomain, false, null, null);\n+    }\n+\n+    /**\n+     * Compiles the source in the given string.\n+     * <p>\n+     * Returns a script that may later be executed.\n+     *\n+     * @param source the source string\n+     * @param sourceName a string describing the source, such as a filename\n+     * @param lineno the starting line number for reporting errors. Use\n+     *        0 if the line number is unknown.\n+     * @param securityDomain an arbitrary object that specifies security\n+     *        information about the origin or owner of the script. For\n+     *        implementations that don't care about security, this value\n+     *        may be null.\n+     * @return a script that may later be executed\n+     * @see org.mozilla.javascript.Script\n+     */\n+    public final Script compileString(String source,\n+                                      String sourceName, int lineno,\n+                                      Object securityDomain)\n+    {\n+        if (lineno < 0) {\n+            // For compatibility IllegalArgumentException can not be thrown here\n+            lineno = 0;\n+        }\n+        return compileString(source, null, null, sourceName, lineno,\n+                             securityDomain);\n+    }\n+\n+    final Script compileString(String source,\n+                               Evaluator compiler,\n+                               ErrorReporter compilationErrorReporter,\n+                               String sourceName, int lineno,\n+                               Object securityDomain)\n+    {\n+        try {\n+            return (Script) compileImpl(null, null, source, sourceName, lineno,\n+                                        securityDomain, false,\n+                                        compiler, compilationErrorReporter);\n+        } catch (IOException ex) {\n+            // Should not happen when dealing with source as string\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    /**\n+     * Compile a JavaScript function.\n+     * <p>\n+     * The function source must be a function definition as defined by\n+     * ECMA (e.g., \"function f(a) { return a; }\").\n+     *\n+     * @param scope the scope to compile relative to\n+     * @param source the function definition source\n+     * @param sourceName a string describing the source, such as a filename\n+     * @param lineno the starting line number\n+     * @param securityDomain an arbitrary object that specifies security\n+     *        information about the origin or owner of the script. For\n+     *        implementations that don't care about security, this value\n+     *        may be null.\n+     * @return a Function that may later be called\n+     * @see org.mozilla.javascript.Function\n+     */\n+    public final Function compileFunction(Scriptable scope, String source,\n+                                          String sourceName, int lineno,\n+                                          Object securityDomain)\n+    {\n+        return compileFunction(scope, source, null, null, sourceName, lineno,\n+                               securityDomain);\n+    }\n+\n+    final Function compileFunction(Scriptable scope, String source,\n+                                   Evaluator compiler,\n+                                   ErrorReporter compilationErrorReporter,\n+                                   String sourceName, int lineno,\n+                                   Object securityDomain)\n+    {\n+        try {\n+            return (Function) compileImpl(scope, null, source, sourceName,\n+                                          lineno, securityDomain, true,\n+                                          compiler, compilationErrorReporter);\n+        }\n+        catch (IOException ioe) {\n+            // Should never happen because we just made the reader\n+            // from a String\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    /**\n+     * Decompile the script.\n+     * <p>\n+     * The canonical source of the script is returned.\n+     *\n+     * @param script the script to decompile\n+     * @param indent the number of spaces to indent the result\n+     * @return a string representing the script source\n+     */\n+    public final String decompileScript(Script script, int indent)\n+    {\n+        NativeFunction scriptImpl = (NativeFunction) script;\n+        return scriptImpl.decompile(indent, 0);\n+    }\n+\n+    /**\n+     * Decompile a JavaScript Function.\n+     * <p>\n+     * Decompiles a previously compiled JavaScript function object to\n+     * canonical source.\n+     * <p>\n+     * Returns function body of '[native code]' if no decompilation\n+     * information is available.\n+     *\n+     * @param fun the JavaScript function to decompile\n+     * @param indent the number of spaces to indent the result\n+     * @return a string representing the function source\n+     */\n+    public final String decompileFunction(Function fun, int indent)\n+    {\n+        if (fun instanceof BaseFunction)\n+            return ((BaseFunction)fun).decompile(indent, 0);\n+        else\n+            return \"function \" + fun.getClassName() +\n+                   \"() {\\n\\t[native code]\\n}\\n\";\n+    }\n+\n+    /**\n+     * Decompile the body of a JavaScript Function.\n+     * <p>\n+     * Decompiles the body a previously compiled JavaScript Function\n+     * object to canonical source, omitting the function header and\n+     * trailing brace.\n+     *\n+     * Returns '[native code]' if no decompilation information is available.\n+     *\n+     * @param fun the JavaScript function to decompile\n+     * @param indent the number of spaces to indent the result\n+     * @return a string representing the function body source.\n+     */\n+    public final String decompileFunctionBody(Function fun, int indent)\n+    {\n+        if (fun instanceof BaseFunction) {\n+            BaseFunction bf = (BaseFunction)fun;\n+            return bf.decompile(indent, Decompiler.ONLY_BODY_FLAG);\n+        }\n+        // ALERT: not sure what the right response here is.\n+        return \"[native code]\\n\";\n+    }\n+\n+    /**\n+     * Create a new JavaScript object.\n+     *\n+     * Equivalent to evaluating \"new Object()\".\n+     * @param scope the scope to search for the constructor and to evaluate\n+     *              against\n+     * @return the new object\n+     */\n+    public final Scriptable newObject(Scriptable scope)\n+    {\n+        return newObject(scope, \"Object\", ScriptRuntime.emptyArgs);\n+    }\n+\n+    /**\n+     * Create a new JavaScript object by executing the named constructor.\n+     *\n+     * The call <code>newObject(scope, \"Foo\")</code> is equivalent to\n+     * evaluating \"new Foo()\".\n+     *\n+     * @param scope the scope to search for the constructor and to evaluate against\n+     * @param constructorName the name of the constructor to call\n+     * @return the new object\n+     */\n+    public final Scriptable newObject(Scriptable scope, String constructorName)\n+    {\n+        return newObject(scope, constructorName, ScriptRuntime.emptyArgs);\n+    }\n+\n+    /**\n+     * Creates a new JavaScript object by executing the named constructor.\n+     *\n+     * Searches <code>scope</code> for the named constructor, calls it with\n+     * the given arguments, and returns the result.<p>\n+     *\n+     * The code\n+     * <pre>\n+     * Object[] args = { \"a\", \"b\" };\n+     * newObject(scope, \"Foo\", args)</pre>\n+     * is equivalent to evaluating \"new Foo('a', 'b')\", assuming that the Foo\n+     * constructor has been defined in <code>scope</code>.\n+     *\n+     * @param scope The scope to search for the constructor and to evaluate\n+     *              against\n+     * @param constructorName the name of the constructor to call\n+     * @param args the array of arguments for the constructor\n+     * @return the new object\n+     */\n+    public final Scriptable newObject(Scriptable scope, String constructorName,\n+                                      Object[] args)\n+    {\n+        scope = ScriptableObject.getTopLevelScope(scope);\n+        Function ctor = ScriptRuntime.getExistingCtor(this, scope,\n+                                                      constructorName);\n+        if (args == null) { args = ScriptRuntime.emptyArgs; }\n+        return ctor.construct(this, scope, args);\n+    }\n+\n+    /**\n+     * Create an array with a specified initial length.\n+     * <p>\n+     * @param scope the scope to create the object in\n+     * @param length the initial length (JavaScript arrays may have\n+     *               additional properties added dynamically).\n+     * @return the new array object\n+     */\n+    public final Scriptable newArray(Scriptable scope, int length)\n+    {\n+        NativeArray result = new NativeArray(length);\n+        ScriptRuntime.setObjectProtoAndParent(result, scope);\n+        return result;\n+    }\n+\n+    /**\n+     * Create an array with a set of initial elements.\n+     *\n+     * @param scope the scope to create the object in.\n+     * @param elements the initial elements. Each object in this array\n+     *                 must be an acceptable JavaScript type and type\n+     *                 of array should be exactly Object[], not\n+     *                 SomeObjectSubclass[].\n+     * @return the new array object.\n+     */\n+    public final Scriptable newArray(Scriptable scope, Object[] elements)\n+    {\n+        if (elements.getClass().getComponentType() != ScriptRuntime.ObjectClass)\n+            throw new IllegalArgumentException();\n+        NativeArray result = new NativeArray(elements);\n+        ScriptRuntime.setObjectProtoAndParent(result, scope);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the elements of a JavaScript array.\n+     * <p>\n+     * If the object defines a length property convertible to double number,\n+     * then the number is converted Uint32 value as defined in Ecma 9.6\n+     * and Java array of that size is allocated.\n+     * The array is initialized with the values obtained by\n+     * calling get() on object for each value of i in [0,length-1]. If\n+     * there is not a defined value for a property the Undefined value\n+     * is used to initialize the corresponding element in the array. The\n+     * Java array is then returned.\n+     * If the object doesn't define a length property or it is not a number,\n+     * empty array is returned.\n+     * @param object the JavaScript array or array-like object\n+     * @return a Java array of objects\n+     * @since 1.4 release 2\n+     */\n+    public final Object[] getElements(Scriptable object)\n+    {\n+        return ScriptRuntime.getArrayElements(object);\n+    }\n+\n+    /**\n+     * Convert the value to a JavaScript boolean value.\n+     * <p>\n+     * See ECMA 9.2.\n+     *\n+     * @param value a JavaScript value\n+     * @return the corresponding boolean value converted using\n+     *         the ECMA rules\n+     */\n+    public static boolean toBoolean(Object value)\n+    {\n+        return ScriptRuntime.toBoolean(value);\n+    }\n+\n+    /**\n+     * Convert the value to a JavaScript Number value.\n+     * <p>\n+     * Returns a Java double for the JavaScript Number.\n+     * <p>\n+     * See ECMA 9.3.\n+     *\n+     * @param value a JavaScript value\n+     * @return the corresponding double value converted using\n+     *         the ECMA rules\n+     */\n+    public static double toNumber(Object value)\n+    {\n+        return ScriptRuntime.toNumber(value);\n+    }\n+\n+    /**\n+     * Convert the value to a JavaScript String value.\n+     * <p>\n+     * See ECMA 9.8.\n+     * <p>\n+     * @param value a JavaScript value\n+     * @return the corresponding String value converted using\n+     *         the ECMA rules\n+     */\n+    public static String toString(Object value)\n+    {\n+        return ScriptRuntime.toString(value);\n+    }\n+\n+    /**\n+     * Convert the value to an JavaScript object value.\n+     * <p>\n+     * Note that a scope must be provided to look up the constructors\n+     * for Number, Boolean, and String.\n+     * <p>\n+     * See ECMA 9.9.\n+     * <p>\n+     * Additionally, arbitrary Java objects and classes will be\n+     * wrapped in a Scriptable object with its Java fields and methods\n+     * reflected as JavaScript properties of the object.\n+     *\n+     * @param value any Java object\n+     * @param scope global scope containing constructors for Number,\n+     *              Boolean, and String\n+     * @return new JavaScript object\n+     */\n+    public static Scriptable toObject(Object value, Scriptable scope)\n+    {\n+        return ScriptRuntime.toObject(scope, value);\n+    }\n+\n+    /**\n+     * @deprecated\n+     * @see #toObject(Object, Scriptable)\n+     */\n+    public static Scriptable toObject(Object value, Scriptable scope,\n+                                      Class<?> staticType)\n+    {\n+        return ScriptRuntime.toObject(scope, value);\n+    }\n+\n+    /**\n+     * Convenient method to convert java value to its closest representation\n+     * in JavaScript.\n+     * <p>\n+     * If value is an instance of String, Number, Boolean, Function or\n+     * Scriptable, it is returned as it and will be treated as the corresponding\n+     * JavaScript type of string, number, boolean, function and object.\n+     * <p>\n+     * Note that for Number instances during any arithmetic operation in\n+     * JavaScript the engine will always use the result of\n+     * <tt>Number.doubleValue()</tt> resulting in a precision loss if\n+     * the number can not fit into double.\n+     * <p>\n+     * If value is an instance of Character, it will be converted to string of\n+     * length 1 and its JavaScript type will be string.\n+     * <p>\n+     * The rest of values will be wrapped as LiveConnect objects\n+     * by calling {@link WrapFactory#wrap(Context cx, Scriptable scope,\n+     * Object obj, Class staticType)} as in:\n+     * <pre>\n+     *    Context cx = Context.getCurrentContext();\n+     *    return cx.getWrapFactory().wrap(cx, scope, value, null);\n+     * </pre>\n+     *\n+     * @param value any Java object\n+     * @param scope top scope object\n+     * @return value suitable to pass to any API that takes JavaScript values.\n+     */\n+    public static Object javaToJS(Object value, Scriptable scope)\n+    {\n+        if (value instanceof String || value instanceof Number\n+            || value instanceof Boolean || value instanceof Scriptable)\n+        {\n+            return value;\n+        } else if (value instanceof Character) {\n+            return String.valueOf(((Character)value).charValue());\n+        } else {\n+            Context cx = Context.getContext();\n+            return cx.getWrapFactory().wrap(cx, scope, value, null);\n+        }\n+    }\n+\n+    /**\n+     * Convert a JavaScript value into the desired type.\n+     * Uses the semantics defined with LiveConnect3 and throws an\n+     * Illegal argument exception if the conversion cannot be performed.\n+     * @param value the JavaScript value to convert\n+     * @param desiredType the Java type to convert to. Primitive Java\n+     *        types are represented using the TYPE fields in the corresponding\n+     *        wrapper class in java.lang.\n+     * @return the converted value\n+     * @throws EvaluatorException if the conversion cannot be performed\n+     */\n+    public static Object jsToJava(Object value, Class<?> desiredType)\n+        throws EvaluatorException\n+    {\n+        return NativeJavaObject.coerceTypeImpl(desiredType, value);\n+    }\n+\n+    /**\n+     * @deprecated\n+     * @see #jsToJava(Object, Class)\n+     * @throws IllegalArgumentException if the conversion cannot be performed.\n+     *         Note that {@link #jsToJava(Object, Class)} throws\n+     *         {@link EvaluatorException} instead.\n+     */\n+    public static Object toType(Object value, Class<?> desiredType)\n+        throws IllegalArgumentException\n+    {\n+        try {\n+            return jsToJava(value, desiredType);\n+        } catch (EvaluatorException ex) {\n+            IllegalArgumentException\n+                ex2 = new IllegalArgumentException(ex.getMessage());\n+            Kit.initCause(ex2, ex);\n+            throw ex2;\n+        }\n+    }\n+\n+    /**\n+     * Rethrow the exception wrapping it as the script runtime exception.\n+     * Unless the exception is instance of {@link EcmaError} or\n+     * {@link EvaluatorException} it will be wrapped as\n+     * {@link WrappedException}, a subclass of {@link EvaluatorException}.\n+     * The resulting exception object always contains\n+     * source name and line number of script that triggered exception.\n+     * <p>\n+     * This method always throws an exception, its return value is provided\n+     * only for convenience to allow a usage like:\n+     * <pre>\n+     * throw Context.throwAsScriptRuntimeEx(ex);\n+     * </pre>\n+     * to indicate that code after the method is unreachable.\n+     * @throws EvaluatorException\n+     * @throws EcmaError\n+     */\n+    public static RuntimeException throwAsScriptRuntimeEx(Throwable e)\n+    {\n+        while ((e instanceof InvocationTargetException)) {\n+            e = ((InvocationTargetException) e).getTargetException();\n+        }\n+        // special handling of Error so scripts would not catch them\n+        if (e instanceof Error) {\n+            Context cx = getContext();\n+            if (cx == null ||\n+                !cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS))\n+            {\n+                throw (Error)e;\n+            }\n+        }\n+        if (e instanceof RhinoException) {\n+            throw (RhinoException)e;\n+        }\n+        throw new WrappedException(e);\n+    }\n+\n+    /**\n+     * Tell whether debug information is being generated.\n+     * @since 1.3\n+     */\n+    public final boolean isGeneratingDebug()\n+    {\n+        return generatingDebug;\n+    }\n+\n+    /**\n+     * Specify whether or not debug information should be generated.\n+     * <p>\n+     * Setting the generation of debug information on will set the\n+     * optimization level to zero.\n+     * @since 1.3\n+     */\n+    public final void setGeneratingDebug(boolean generatingDebug)\n+    {\n+        if (sealed) onSealedMutation();\n+        generatingDebugChanged = true;\n+        if (generatingDebug && getOptimizationLevel() > 0)\n+            setOptimizationLevel(0);\n+        this.generatingDebug = generatingDebug;\n+    }\n+\n+    /**\n+     * Tell whether source information is being generated.\n+     * @since 1.3\n+     */\n+    public final boolean isGeneratingSource()\n+    {\n+        return generatingSource;\n+    }\n+\n+    /**\n+     * Specify whether or not source information should be generated.\n+     * <p>\n+     * Without source information, evaluating the \"toString\" method\n+     * on JavaScript functions produces only \"[native code]\" for\n+     * the body of the function.\n+     * Note that code generated without source is not fully ECMA\n+     * conformant.\n+     * @since 1.3\n+     */\n+    public final void setGeneratingSource(boolean generatingSource)\n+    {\n+        if (sealed) onSealedMutation();\n+        this.generatingSource = generatingSource;\n+    }\n+\n+    /**\n+     * Get the current optimization level.\n+     * <p>\n+     * The optimization level is expressed as an integer between -1 and\n+     * 9.\n+     * @since 1.3\n+     *\n+     */\n+    public final int getOptimizationLevel()\n+    {\n+        return optimizationLevel;\n+    }\n+\n+    /**\n+     * Set the current optimization level.\n+     * <p>\n+     * The optimization level is expected to be an integer between -1 and\n+     * 9. Any negative values will be interpreted as -1, and any values\n+     * greater than 9 will be interpreted as 9.\n+     * An optimization level of -1 indicates that interpretive mode will\n+     * always be used. Levels 0 through 9 indicate that class files may\n+     * be generated. Higher optimization levels trade off compile time\n+     * performance for runtime performance.\n+     * The optimizer level can't be set greater than -1 if the optimizer\n+     * package doesn't exist at run time.\n+     * @param optimizationLevel an integer indicating the level of\n+     *        optimization to perform\n+     * @since 1.3\n+     *\n+     */\n+    public final void setOptimizationLevel(int optimizationLevel)\n+    {\n+        if (sealed) onSealedMutation();\n+        if (optimizationLevel == -2) {\n+            // To be compatible with Cocoon fork\n+            optimizationLevel = -1;\n+        }\n+        checkOptimizationLevel(optimizationLevel);\n+        if (codegenClass == null)\n+            optimizationLevel = -1;\n+        this.optimizationLevel = optimizationLevel;\n+    }\n+\n+    public static boolean isValidOptimizationLevel(int optimizationLevel)\n+    {\n+        return -1 <= optimizationLevel && optimizationLevel <= 9;\n+    }\n+\n+    public static void checkOptimizationLevel(int optimizationLevel)\n+    {\n+        if (isValidOptimizationLevel(optimizationLevel)) {\n+            return;\n+        }\n+        throw new IllegalArgumentException(\n+            \"Optimization level outside [-1..9]: \"+optimizationLevel);\n+    }\n+\n+    /**\n+     * Returns the maximum stack depth (in terms of number of call frames)\n+     * allowed in a single invocation of interpreter. If the set depth would be\n+     * exceeded, the interpreter will throw an EvaluatorException in the script.\n+     * Defaults to Integer.MAX_VALUE. The setting only has effect for\n+     * interpreted functions (those compiled with optimization level set to -1).\n+     * As the interpreter doesn't use the Java stack but rather manages its own\n+     * stack in the heap memory, a runaway recursion in interpreted code would\n+     * eventually consume all available memory and cause OutOfMemoryError\n+     * instead of a StackOverflowError limited to only a single thread. This\n+     * setting helps prevent such situations.\n+     *\n+     * @return The current maximum interpreter stack depth.\n+     */\n+    public final int getMaximumInterpreterStackDepth()\n+    {\n+        return maximumInterpreterStackDepth;\n+    }\n+\n+    /**\n+     * Sets the maximum stack depth (in terms of number of call frames)\n+     * allowed in a single invocation of interpreter. If the set depth would be\n+     * exceeded, the interpreter will throw an EvaluatorException in the script.\n+     * Defaults to Integer.MAX_VALUE. The setting only has effect for\n+     * interpreted functions (those compiled with optimization level set to -1).\n+     * As the interpreter doesn't use the Java stack but rather manages its own\n+     * stack in the heap memory, a runaway recursion in interpreted code would\n+     * eventually consume all available memory and cause OutOfMemoryError\n+     * instead of a StackOverflowError limited to only a single thread. This\n+     * setting helps prevent such situations.\n+     *\n+     * @param max the new maximum interpreter stack depth\n+     * @throws IllegalStateException if this context's optimization level is not\n+     * -1\n+     * @throws IllegalArgumentException if the new depth is not at least 1\n+     */\n+    public final void setMaximumInterpreterStackDepth(int max)\n+    {\n+        if(sealed) onSealedMutation();\n+        if(optimizationLevel != -1) {\n+            throw new IllegalStateException(\"Cannot set maximumInterpreterStackDepth when optimizationLevel != -1\");\n+        }\n+        if(max < 1) {\n+            throw new IllegalArgumentException(\"Cannot set maximumInterpreterStackDepth to less than 1\");\n+        }\n+        maximumInterpreterStackDepth = max;\n+    }\n+\n+    /**\n+     * Set the security controller for this context.\n+     * <p> SecurityController may only be set if it is currently null\n+     * and {@link SecurityController#hasGlobal()} is <tt>false</tt>.\n+     * Otherwise a SecurityException is thrown.\n+     * @param controller a SecurityController object\n+     * @throws SecurityException if there is already a SecurityController\n+     *         object for this Context or globally installed.\n+     * @see SecurityController#initGlobal(SecurityController controller)\n+     * @see SecurityController#hasGlobal()\n+     */\n+    public final void setSecurityController(SecurityController controller)\n+    {\n+        if (sealed) onSealedMutation();\n+        if (controller == null) throw new IllegalArgumentException();\n+        if (securityController != null) {\n+            throw new SecurityException(\"Can not overwrite existing SecurityController object\");\n+        }\n+        if (SecurityController.hasGlobal()) {\n+            throw new SecurityException(\"Can not overwrite existing global SecurityController object\");\n+        }\n+        securityController = controller;\n+    }\n+\n+    /**\n+     * Set the LiveConnect access filter for this context.\n+     * <p> {@link ClassShutter} may only be set if it is currently null.\n+     * Otherwise a SecurityException is thrown.\n+     * @param shutter a ClassShutter object\n+     * @throws SecurityException if there is already a ClassShutter\n+     *         object for this Context\n+     */\n+    public synchronized final void setClassShutter(ClassShutter shutter)\n+    {\n+        if (sealed) onSealedMutation();\n+        if (shutter == null) throw new IllegalArgumentException();\n+        if (hasClassShutter) {\n+            throw new SecurityException(\"Cannot overwrite existing \" +\n+                                        \"ClassShutter object\");\n+        }\n+        classShutter = shutter;\n+        hasClassShutter = true;\n+    }\n+\n+    final synchronized ClassShutter getClassShutter()\n+    {\n+        return classShutter;\n+    }\n+\n+    public interface ClassShutterSetter {\n+        public void setClassShutter(ClassShutter shutter);\n+        public ClassShutter getClassShutter();\n+    }\n+\n+    public final synchronized ClassShutterSetter getClassShutterSetter() {\n+        if (hasClassShutter)\n+            return null;\n+        hasClassShutter = true;\n+        return new ClassShutterSetter() {\n+            public void setClassShutter(ClassShutter shutter) {\n+                classShutter = shutter;\n+            }\n+            public ClassShutter getClassShutter() {\n+                return classShutter;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get a value corresponding to a key.\n+     * <p>\n+     * Since the Context is associated with a thread it can be\n+     * used to maintain values that can be later retrieved using\n+     * the current thread.\n+     * <p>\n+     * Note that the values are maintained with the Context, so\n+     * if the Context is disassociated from the thread the values\n+     * cannot be retrieved. Also, if private data is to be maintained\n+     * in this manner the key should be a java.lang.Object\n+     * whose reference is not divulged to untrusted code.\n+     * @param key the key used to lookup the value\n+     * @return a value previously stored using putThreadLocal.\n+     */\n+    public final Object getThreadLocal(Object key)\n+    {\n+        if (threadLocalMap == null)\n+            return null;\n+        return threadLocalMap.get(key);\n+    }\n+\n+    /**\n+     * Put a value that can later be retrieved using a given key.\n+     * <p>\n+     * @param key the key used to index the value\n+     * @param value the value to save\n+     */\n+    public synchronized final void putThreadLocal(Object key, Object value)\n+    {\n+        if (sealed) onSealedMutation();\n+        if (threadLocalMap == null)\n+            threadLocalMap = new HashMap<Object,Object>();\n+        threadLocalMap.put(key, value);\n+    }\n+\n+    /**\n+     * Remove values from thread-local storage.\n+     * @param key the key for the entry to remove.\n+     * @since 1.5 release 2\n+     */\n+    public final void removeThreadLocal(Object key)\n+    {\n+        if (sealed) onSealedMutation();\n+        if (threadLocalMap == null)\n+            return;\n+        threadLocalMap.remove(key);\n+    }\n+\n+    /**\n+     * @deprecated\n+     * @see #FEATURE_DYNAMIC_SCOPE\n+     * @see #hasFeature(int)\n+     */\n+    public final boolean hasCompileFunctionsWithDynamicScope()\n+    {\n+        return compileFunctionsWithDynamicScopeFlag;\n+    }\n+\n+    /**\n+     * @deprecated\n+     * @see #FEATURE_DYNAMIC_SCOPE\n+     * @see #hasFeature(int)\n+     */\n+    public final void setCompileFunctionsWithDynamicScope(boolean flag)\n+    {\n+        if (sealed) onSealedMutation();\n+        compileFunctionsWithDynamicScopeFlag = flag;\n+    }\n+\n+    /**\n+     * @deprecated\n+     * @see ClassCache#get(Scriptable)\n+     * @see ClassCache#setCachingEnabled(boolean)\n+     */\n+    public static void setCachingEnabled(boolean cachingEnabled)\n+    {\n+    }\n+\n+    /**\n+     * Set a WrapFactory for this Context.\n+     * <p>\n+     * The WrapFactory allows custom object wrapping behavior for\n+     * Java object manipulated with JavaScript.\n+     * @see WrapFactory\n+     * @since 1.5 Release 4\n+     */\n+    public final void setWrapFactory(WrapFactory wrapFactory)\n+    {\n+        if (sealed) onSealedMutation();\n+        if (wrapFactory == null) throw new IllegalArgumentException();\n+        this.wrapFactory = wrapFactory;\n+    }\n+\n+    /**\n+     * Return the current WrapFactory, or null if none is defined.\n+     * @see WrapFactory\n+     * @since 1.5 Release 4\n+     */\n+    public final WrapFactory getWrapFactory()\n+    {\n+        if (wrapFactory == null) {\n+            wrapFactory = new WrapFactory();\n+        }\n+        return wrapFactory;\n+    }\n+\n+    /**\n+     * Return the current debugger.\n+     * @return the debugger, or null if none is attached.\n+     */\n+    public final Debugger getDebugger()\n+    {\n+        return debugger;\n+    }\n+\n+    /**\n+     * Return the debugger context data associated with current context.\n+     * @return the debugger data, or null if debugger is not attached\n+     */\n+    public final Object getDebuggerContextData()\n+    {\n+        return debuggerData;\n+    }\n+\n+    /**\n+     * Set the associated debugger.\n+     * @param debugger the debugger to be used on callbacks from\n+     * the engine.\n+     * @param contextData arbitrary object that debugger can use to store\n+     *        per Context data.\n+     */\n+    public final void setDebugger(Debugger debugger, Object contextData)\n+    {\n+        if (sealed) onSealedMutation();\n+        this.debugger = debugger;\n+        debuggerData = contextData;\n+    }\n+\n+    /**\n+     * Return DebuggableScript instance if any associated with the script.\n+     * If callable supports DebuggableScript implementation, the method\n+     * returns it. Otherwise null is returned.\n+     */\n+    public static DebuggableScript getDebuggableView(Script script)\n+    {\n+        if (script instanceof NativeFunction) {\n+            return ((NativeFunction)script).getDebuggableView();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Controls certain aspects of script semantics.\n+     * Should be overwritten to alter default behavior.\n+     * <p>\n+     * The default implementation calls\n+     * {@link ContextFactory#hasFeature(Context cx, int featureIndex)}\n+     * that allows to customize Context behavior without introducing\n+     * Context subclasses.  {@link ContextFactory} documentation gives\n+     * an example of hasFeature implementation.\n+     *\n+     * @param featureIndex feature index to check\n+     * @return true if the <code>featureIndex</code> feature is turned on\n+     * @see #FEATURE_NON_ECMA_GET_YEAR\n+     * @see #FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME\n+     * @see #FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER\n+     * @see #FEATURE_TO_STRING_AS_SOURCE\n+     * @see #FEATURE_PARENT_PROTO_PROPRTIES\n+     * @see #FEATURE_E4X\n+     * @see #FEATURE_DYNAMIC_SCOPE\n+     * @see #FEATURE_STRICT_VARS\n+     * @see #FEATURE_STRICT_EVAL\n+     * @see #FEATURE_LOCATION_INFORMATION_IN_ERROR\n+     * @see #FEATURE_STRICT_MODE\n+     * @see #FEATURE_WARNING_AS_ERROR\n+     * @see #FEATURE_ENHANCED_JAVA_ACCESS\n+     */\n+    public boolean hasFeature(int featureIndex)\n+    {\n+        ContextFactory f = getFactory();\n+        return f.hasFeature(this, featureIndex);\n+    }\n+\n+        /**\n+                Returns an object which specifies an E4X implementation to use within\n+                this <code>Context</code>.  Note\n+                that the XMLLib.Factory interface should be considered experimental.\n+\n+                The default implementation uses the implementation provided by this\n+                <code>Context</code>'s {@link ContextFactory}.\n+\n+                @return An XMLLib.Factory.  Should not return <code>null</code> if\n+                        {@link #FEATURE_E4X} is enabled.  See {@link #hasFeature}.\n+         */\n+        public XMLLib.Factory getE4xImplementationFactory() {\n+                return getFactory().getE4xImplementationFactory();\n+        }\n+\n+    /**\n+     * Get threshold of executed instructions counter that triggers call to\n+     * <code>observeInstructionCount()</code>.\n+     * When the threshold is zero, instruction counting is disabled,\n+     * otherwise each time the run-time executes at least the threshold value\n+     * of script instructions, <code>observeInstructionCount()</code> will\n+     * be called.\n+     */\n+    public final int getInstructionObserverThreshold()\n+    {\n+        return instructionThreshold;\n+    }\n+\n+    /**\n+     * Set threshold of executed instructions counter that triggers call to\n+     * <code>observeInstructionCount()</code>.\n+     * When the threshold is zero, instruction counting is disabled,\n+     * otherwise each time the run-time executes at least the threshold value\n+     * of script instructions, <code>observeInstructionCount()</code> will\n+     * be called.<p/>\n+     * Note that the meaning of \"instruction\" is not guaranteed to be\n+     * consistent between compiled and interpretive modes: executing a given\n+     * script or function in the different modes will result in different\n+     * instruction counts against the threshold.\n+     * {@link #setGenerateObserverCount} is called with true if\n+     * <code>threshold</code> is greater than zero, false otherwise.\n+     * @param threshold The instruction threshold\n+     */\n+    public final void setInstructionObserverThreshold(int threshold)\n+    {\n+        if (sealed) onSealedMutation();\n+        if (threshold < 0) throw new IllegalArgumentException();\n+        instructionThreshold = threshold;\n+        setGenerateObserverCount(threshold > 0);\n+    }\n+\n+    /**\n+     * Turn on or off generation of code with callbacks to\n+     * track the count of executed instructions.\n+     * Currently only affects JVM byte code generation: this slows down the\n+     * generated code, but code generated without the callbacks will not\n+     * be counted toward instruction thresholds. Rhino's interpretive\n+     * mode does instruction counting without inserting callbacks, so\n+     * there is no requirement to compile code differently.\n+     * @param generateObserverCount if true, generated code will contain\n+     * calls to accumulate an estimate of the instructions executed.\n+     */\n+    public void setGenerateObserverCount(boolean generateObserverCount) {\n+        this.generateObserverCount = generateObserverCount;\n+    }\n+\n+    /**\n+     * Allow application to monitor counter of executed script instructions\n+     * in Context subclasses.\n+     * Run-time calls this when instruction counting is enabled and the counter\n+     * reaches limit set by <code>setInstructionObserverThreshold()</code>.\n+     * The method is useful to observe long running scripts and if necessary\n+     * to terminate them.\n+     * <p>\n+     * The default implementation calls\n+     * {@link ContextFactory#observeInstructionCount(Context cx,\n+     *                                               int instructionCount)}\n+     * that allows to customize Context behavior without introducing\n+     * Context subclasses.\n+     *\n+     * @param instructionCount amount of script instruction executed since\n+     * last call to <code>observeInstructionCount</code>\n+     * @throws Error to terminate the script\n+     * @see #setOptimizationLevel(int)\n+     */\n+    protected void observeInstructionCount(int instructionCount)\n+    {\n+        ContextFactory f = getFactory();\n+        f.observeInstructionCount(this, instructionCount);\n+    }\n+\n+    /**\n+     * Create class loader for generated classes.\n+     * The method calls {@link ContextFactory#createClassLoader(ClassLoader)}\n+     * using the result of {@link #getFactory()}.\n+     */\n+    public GeneratedClassLoader createClassLoader(ClassLoader parent)\n+    {\n+        ContextFactory f = getFactory();\n+        return f.createClassLoader(parent);\n+    }\n+\n+    public final ClassLoader getApplicationClassLoader()\n+    {\n+        if (applicationClassLoader == null) {\n+            ContextFactory f = getFactory();\n+            ClassLoader loader = f.getApplicationClassLoader();\n+            if (loader == null) {\n+                ClassLoader threadLoader\n+                    = VMBridge.instance.getCurrentThreadClassLoader();\n+                if (threadLoader != null\n+                    && Kit.testIfCanLoadRhinoClasses(threadLoader))\n+                {\n+                    // Thread.getContextClassLoader is not cached since\n+                    // its caching prevents it from GC which may lead to\n+                    // a memory leak and hides updates to\n+                    // Thread.getContextClassLoader\n+                    return threadLoader;\n+                }\n+                // Thread.getContextClassLoader can not load Rhino classes,\n+                // try to use the loader of ContextFactory or Context\n+                // subclasses.\n+                Class<?> fClass = f.getClass();\n+                if (fClass != ScriptRuntime.ContextFactoryClass) {\n+                    loader = fClass.getClassLoader();\n+                } else {\n+                    loader = getClass().getClassLoader();\n+                }\n+            }\n+            applicationClassLoader = loader;\n+        }\n+        return applicationClassLoader;\n+    }\n+\n+    public final void setApplicationClassLoader(ClassLoader loader)\n+    {\n+        if (sealed) onSealedMutation();\n+        if (loader == null) {\n+            // restore default behaviour\n+            applicationClassLoader = null;\n+            return;\n+        }\n+        if (!Kit.testIfCanLoadRhinoClasses(loader)) {\n+            throw new IllegalArgumentException(\n+                \"Loader can not resolve Rhino classes\");\n+        }\n+        applicationClassLoader = loader;\n+    }\n+\n+    /********** end of API **********/\n+\n+    /**\n+     * Internal method that reports an error for missing calls to\n+     * enter().\n+     */\n+    static Context getContext()\n+    {\n+        Context cx = getCurrentContext();\n+        if (cx == null) {\n+            throw new RuntimeException(\n+                \"No Context associated with current Thread\");\n+        }\n+        return cx;\n+    }\n+\n+    private Object compileImpl(Scriptable scope,\n+                               Reader sourceReader, String sourceString,\n+                               String sourceName, int lineno,\n+                               Object securityDomain, boolean returnFunction,\n+                               Evaluator compiler,\n+                               ErrorReporter compilationErrorReporter)\n+        throws IOException\n+    {\n+        if(sourceName == null) {\n+            sourceName = \"unnamed script\";\n+        }\n+        if (securityDomain != null && getSecurityController() == null) {\n+            throw new IllegalArgumentException(\n+                \"securityDomain should be null if setSecurityController() was never called\");\n+        }\n+\n+        // One of sourceReader or sourceString has to be null\n+        if (!(sourceReader == null ^ sourceString == null)) Kit.codeBug();\n+        // scope should be given if and only if compiling function\n+        if (!(scope == null ^ returnFunction)) Kit.codeBug();\n+\n+        CompilerEnvirons compilerEnv = new CompilerEnvirons();\n+        compilerEnv.initFromContext(this);\n+        if (compilationErrorReporter == null) {\n+            compilationErrorReporter = compilerEnv.getErrorReporter();\n+        }\n+\n+        if (debugger != null) {\n+            if (sourceReader != null) {\n+                sourceString = Kit.readReader(sourceReader);\n+                sourceReader = null;\n+            }\n+        }\n+\n+        Parser p = new Parser(compilerEnv, compilationErrorReporter);\n+        if (returnFunction) {\n+            p.calledByCompileFunction = true;\n+        }\n+        AstRoot ast;\n+        if (sourceString != null) {\n+            ast = p.parse(sourceString, sourceName, lineno);\n+        } else {\n+            ast = p.parse(sourceReader, sourceName, lineno);\n+        }\n+        if (returnFunction) {\n+            // parser no longer adds function to script node\n+            if (!(ast.getFirstChild() != null\n+                  && ast.getFirstChild().getType() == Token.FUNCTION))\n+            {\n+                // XXX: the check just looks for the first child\n+                // and allows for more nodes after it for compatibility\n+                // with sources like function() {};;;\n+                throw new IllegalArgumentException(\n+                    \"compileFunction only accepts source with single JS function: \"+sourceString);\n+            }\n+        }\n+\n+        IRFactory irf = new IRFactory(compilerEnv, compilationErrorReporter);\n+        ScriptNode tree = irf.transformTree(ast);\n+\n+        // discard everything but the IR tree\n+        p = null;\n+        ast = null;\n+        irf = null;\n+\n+        if (compiler == null) {\n+            compiler = createCompiler();\n+        }\n+\n+        Object bytecode = compiler.compile(compilerEnv,\n+                                           tree, tree.getEncodedSource(),\n+                                           returnFunction);\n+        if (debugger != null) {\n+            if (sourceString == null) Kit.codeBug();\n+            if (bytecode instanceof DebuggableScript) {\n+                DebuggableScript dscript = (DebuggableScript)bytecode;\n+                notifyDebugger_r(this, dscript, sourceString);\n+            } else {\n+                throw new RuntimeException(\"NOT SUPPORTED\");\n+            }\n+        }\n+\n+        Object result;\n+        if (returnFunction) {\n+            result = compiler.createFunctionObject(this, scope, bytecode, securityDomain);\n+        } else {\n+            result = compiler.createScriptObject(bytecode, securityDomain);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static void notifyDebugger_r(Context cx, DebuggableScript dscript,\n+                                         String debugSource)\n+    {\n+        cx.debugger.handleCompilationDone(cx, dscript, debugSource);\n+        for (int i = 0; i != dscript.getFunctionCount(); ++i) {\n+            notifyDebugger_r(cx, dscript.getFunction(i), debugSource);\n+        }\n+    }\n+\n+    private static Class<?> codegenClass = Kit.classOrNull(\n+                             \"org.mozilla.javascript.optimizer.Codegen\");\n+    private static Class<?> interpreterClass = Kit.classOrNull(\n+                             \"org.mozilla.javascript.Interpreter\");\n+\n+    private Evaluator createCompiler()\n+    {\n+        Evaluator result = null;\n+        if (optimizationLevel >= 0 && codegenClass != null) {\n+            result = (Evaluator)Kit.newInstanceOrNull(codegenClass);\n+        }\n+        if (result == null) {\n+            result = createInterpreter();\n+        }\n+        return result;\n+    }\n+\n+    static Evaluator createInterpreter()\n+    {\n+        return (Evaluator)Kit.newInstanceOrNull(interpreterClass);\n+    }\n+\n+    static String getSourcePositionFromStack(int[] linep)\n+    {\n+        Context cx = getCurrentContext();\n+        if (cx == null)\n+            return null;\n+        if (cx.lastInterpreterFrame != null) {\n+            Evaluator evaluator = createInterpreter();\n+            if (evaluator != null)\n+                return evaluator.getSourcePositionFromStack(cx, linep);\n+        }\n+        /**\n+         * A bit of a hack, but the only way to get filename and line\n+         * number from an enclosing frame.\n+         */\n+        CharArrayWriter writer = new CharArrayWriter();\n+        RuntimeException re = new RuntimeException();\n+        re.printStackTrace(new PrintWriter(writer));\n+        String s = writer.toString();\n+        int open = -1;\n+        int close = -1;\n+        int colon = -1;\n+        for (int i=0; i < s.length(); i++) {\n+            char c = s.charAt(i);\n+            if (c == ':')\n+                colon = i;\n+            else if (c == '(')\n+                open = i;\n+            else if (c == ')')\n+                close = i;\n+            else if (c == '\\n' && open != -1 && close != -1 && colon != -1 &&\n+                     open < colon && colon < close)\n+            {\n+                String fileStr = s.substring(open + 1, colon);\n+                if (!fileStr.endsWith(\".java\")) {\n+                    String lineStr = s.substring(colon + 1, close);\n+                    try {\n+                        linep[0] = Integer.parseInt(lineStr);\n+                        if (linep[0] < 0) {\n+                            linep[0] = 0;\n+                        }\n+                        return fileStr;\n+                    }\n+                    catch (NumberFormatException e) {\n+                        // fall through\n+                    }\n+                }\n+                open = close = colon = -1;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    RegExpProxy getRegExpProxy()\n+    {\n+        if (regExpProxy == null) {\n+            Class<?> cl = Kit.classOrNull(\n+                          \"org.mozilla.javascript.regexp.RegExpImpl\");\n+            if (cl != null) {\n+                regExpProxy = (RegExpProxy)Kit.newInstanceOrNull(cl);\n+            }\n+        }\n+        return regExpProxy;\n+    }\n+\n+    final boolean isVersionECMA1()\n+    {\n+        return version == VERSION_DEFAULT || version >= VERSION_1_3;\n+    }\n+\n+// The method must NOT be public or protected\n+    SecurityController getSecurityController()\n+    {\n+        SecurityController global = SecurityController.global();\n+        if (global != null) {\n+            return global;\n+        }\n+        return securityController;\n+    }\n+\n+    public final boolean isGeneratingDebugChanged()\n+    {\n+        return generatingDebugChanged;\n+    }\n+\n+    /**\n+     * Add a name to the list of names forcing the creation of real\n+     * activation objects for functions.\n+     *\n+     * @param name the name of the object to add to the list\n+     */\n+    public void addActivationName(String name)\n+    {\n+        if (sealed) onSealedMutation();\n+        if (activationNames == null)\n+            activationNames = new HashSet<String>();\n+        activationNames.add(name);\n+    }\n+\n+    /**\n+     * Check whether the name is in the list of names of objects\n+     * forcing the creation of activation objects.\n+     *\n+     * @param name the name of the object to test\n+     *\n+     * @return true if an function activation object is needed.\n+     */\n+    public final boolean isActivationNeeded(String name)\n+    {\n+        return activationNames != null && activationNames.contains(name);\n+    }\n+\n+    /**\n+     * Remove a name from the list of names forcing the creation of real\n+     * activation objects for functions.\n+     *\n+     * @param name the name of the object to remove from the list\n+     */\n+    public void removeActivationName(String name)\n+    {\n+        if (sealed) onSealedMutation();\n+        if (activationNames != null)\n+            activationNames.remove(name);\n+    }\n+\n+    private static String implementationVersion;\n+\n+    private final ContextFactory factory;\n+    private boolean sealed;\n+    private Object sealKey;\n+\n+    Scriptable topCallScope;\n+    boolean isContinuationsTopCall;\n+    NativeCall currentActivationCall;\n+    XMLLib cachedXMLLib;\n+\n+    // for Objects, Arrays to tag themselves as being printed out,\n+    // so they don't print themselves out recursively.\n+    // Use ObjToIntMap instead of java.util.HashSet for JDK 1.1 compatibility\n+    ObjToIntMap iterating;\n+\n+    Object interpreterSecurityDomain;\n+\n+    int version;\n+\n+    private SecurityController securityController;\n+    private boolean hasClassShutter;\n+    private ClassShutter classShutter;\n+    private ErrorReporter errorReporter;\n+    RegExpProxy regExpProxy;\n+    private Locale locale;\n+    private boolean generatingDebug;\n+    private boolean generatingDebugChanged;\n+    private boolean generatingSource=true;\n+    boolean compileFunctionsWithDynamicScopeFlag;\n+    boolean useDynamicScope;\n+    private int optimizationLevel;\n+    private int maximumInterpreterStackDepth;\n+    private WrapFactory wrapFactory;\n+    Debugger debugger;\n+    private Object debuggerData;\n+    private int enterCount;\n+    private Object propertyListeners;\n+    private Map<Object,Object> threadLocalMap;\n+    private ClassLoader applicationClassLoader;\n+\n+    /**\n+     * This is the list of names of objects forcing the creation of\n+     * function activation records.\n+     */\n+    Set<String> activationNames;\n+\n+    // For the interpreter to store the last frame for error reports etc.\n+    Object lastInterpreterFrame;\n+\n+    // For the interpreter to store information about previous invocations\n+    // interpreter invocations\n+    ObjArray previousInterpreterInvocations;\n+\n+    // For instruction counting (interpreter only)\n+    int instructionCount;\n+    int instructionThreshold;\n+\n+    // It can be used to return the second index-like result from function\n+    int scratchIndex;\n+\n+    // It can be used to return the second uint32 result from function\n+    long scratchUint32;\n+\n+    // It can be used to return the second Scriptable result from function\n+    Scriptable scratchScriptable;\n+\n+    // Generate an observer count on compiled code\n+    public boolean generateObserverCount = false;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ContextAction.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov, igor@fastmail.fm\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Interface to represent arbitrary action that requires to have Context\n+ * object associated with the current thread for its execution.\n+ */\n+public interface ContextAction\n+{\n+    /**\n+     * Execute action using the supplied Context instance.\n+     * When Rhino runtime calls the method, <tt>cx</tt> will be associated\n+     * with the current thread as active context.\n+     *\n+     * @see ContextFactory#call(ContextAction)\n+     */\n+    public Object run(Context cx);\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ContextFactory.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov, igor@fastmail.fm\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+/**\n+ * Factory class that Rhino runtime uses to create new {@link Context}\n+ * instances.  A <code>ContextFactory</code> can also notify listeners\n+ * about context creation and release.\n+ * <p>\n+ * When the Rhino runtime needs to create new {@link Context} instance during\n+ * execution of {@link Context#enter()} or {@link Context}, it will call\n+ * {@link #makeContext()} of the current global ContextFactory.\n+ * See {@link #getGlobal()} and {@link #initGlobal(ContextFactory)}.\n+ * <p>\n+ * It is also possible to use explicit ContextFactory instances for Context\n+ * creation. This is useful to have a set of independent Rhino runtime\n+ * instances under single JVM. See {@link #call(ContextAction)}.\n+ * <p>\n+ * The following example demonstrates Context customization to terminate\n+ * scripts running more then 10 seconds and to provide better compatibility\n+ * with JavaScript code using MSIE-specific features.\n+ * <pre>\n+ * import org.mozilla.javascript.*;\n+ *\n+ * class MyFactory extends ContextFactory\n+ * {\n+ *\n+ *     // Custom {@link Context} to store execution time.\n+ *     private static class MyContext extends Context\n+ *     {\n+ *         long startTime;\n+ *     }\n+ *\n+ *     static {\n+ *         // Initialize GlobalFactory with custom factory\n+ *         ContextFactory.initGlobal(new MyFactory());\n+ *     }\n+ *\n+ *     // Override {@link #makeContext()}\n+ *     protected Context makeContext()\n+ *     {\n+ *         MyContext cx = new MyContext();\n+ *         // Make Rhino runtime to call observeInstructionCount\n+ *         // each 10000 bytecode instructions\n+ *         cx.setInstructionObserverThreshold(10000);\n+ *         return cx;\n+ *     }\n+ *\n+ *     // Override {@link #hasFeature(Context, int)}\n+ *     public boolean hasFeature(Context cx, int featureIndex)\n+ *     {\n+ *         // Turn on maximum compatibility with MSIE scripts\n+ *         switch (featureIndex) {\n+ *             case {@link Context#FEATURE_NON_ECMA_GET_YEAR}:\n+ *                 return true;\n+ *\n+ *             case {@link Context#FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME}:\n+ *                 return true;\n+ *\n+ *             case {@link Context#FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER}:\n+ *                 return true;\n+ *\n+ *             case {@link Context#FEATURE_PARENT_PROTO_PROPERTIES}:\n+ *                 return false;\n+ *         }\n+ *         return super.hasFeature(cx, featureIndex);\n+ *     }\n+ *\n+ *     // Override {@link #observeInstructionCount(Context, int)}\n+ *     protected void observeInstructionCount(Context cx, int instructionCount)\n+ *     {\n+ *         MyContext mcx = (MyContext)cx;\n+ *         long currentTime = System.currentTimeMillis();\n+ *         if (currentTime - mcx.startTime > 10*1000) {\n+ *             // More then 10 seconds from Context creation time:\n+ *             // it is time to stop the script.\n+ *             // Throw Error instance to ensure that script will never\n+ *             // get control back through catch or finally.\n+ *             throw new Error();\n+ *         }\n+ *     }\n+ *\n+ *     // Override {@link #doTopCall(Callable,\n+                               Context, Scriptable,\n+                               Scriptable, Object[])}\n+ *     protected Object doTopCall(Callable callable,\n+ *                                Context cx, Scriptable scope,\n+ *                                Scriptable thisObj, Object[] args)\n+ *     {\n+ *         MyContext mcx = (MyContext)cx;\n+ *         mcx.startTime = System.currentTimeMillis();\n+ *\n+ *         return super.doTopCall(callable, cx, scope, thisObj, args);\n+ *     }\n+ *\n+ * }\n+ *\n+ * </pre>\n+ */\n+\n+public class ContextFactory\n+{\n+    private static volatile boolean hasCustomGlobal;\n+    private static ContextFactory global = new ContextFactory();\n+\n+    private volatile boolean sealed;\n+\n+    private final Object listenersLock = new Object();\n+    private volatile Object listeners;\n+    private boolean disabledListening;\n+    private ClassLoader applicationClassLoader;\n+\n+    /**\n+     * Listener of {@link Context} creation and release events.\n+     */\n+    public interface Listener\n+    {\n+        /**\n+         * Notify about newly created {@link Context} object.\n+         */\n+        public void contextCreated(Context cx);\n+\n+        /**\n+         * Notify that the specified {@link Context} instance is no longer\n+         * associated with the current thread.\n+         */\n+        public void contextReleased(Context cx);\n+    }\n+\n+    /**\n+     * Get global ContextFactory.\n+     *\n+     * @see #hasExplicitGlobal()\n+     * @see #initGlobal(ContextFactory)\n+     */\n+    public static ContextFactory getGlobal()\n+    {\n+        return global;\n+    }\n+\n+    /**\n+     * Check if global factory was set.\n+     * Return true to indicate that {@link #initGlobal(ContextFactory)} was\n+     * already called and false to indicate that the global factory was not\n+     * explicitly set.\n+     *\n+     * @see #getGlobal()\n+     * @see #initGlobal(ContextFactory)\n+     */\n+    public static boolean hasExplicitGlobal()\n+    {\n+        return hasCustomGlobal;\n+    }\n+\n+    /**\n+     * Set global ContextFactory.\n+     * The method can only be called once.\n+     *\n+     * @see #getGlobal()\n+     * @see #hasExplicitGlobal()\n+     */\n+    public synchronized static void initGlobal(ContextFactory factory)\n+    {\n+        if (factory == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (hasCustomGlobal) {\n+            throw new IllegalStateException();\n+        }\n+        hasCustomGlobal = true;\n+        global = factory;\n+    }\n+    \n+    public interface GlobalSetter {\n+        public void setContextFactoryGlobal(ContextFactory factory);\n+        public ContextFactory getContextFactoryGlobal();\n+    }\n+    \n+    public synchronized static GlobalSetter getGlobalSetter() {\n+        if (hasCustomGlobal) {\n+            throw new IllegalStateException();\n+        }\n+        hasCustomGlobal = true;\n+        class GlobalSetterImpl implements GlobalSetter {\n+            public void setContextFactoryGlobal(ContextFactory factory) {\n+                global = factory == null ? new ContextFactory() : factory;\n+            }\n+            public ContextFactory getContextFactoryGlobal() {\n+                return global;\n+            }\n+        }\n+        return new GlobalSetterImpl();\n+    }\n+    \n+    /**\n+     * Create new {@link Context} instance to be associated with the current\n+     * thread.\n+     * This is a callback method used by Rhino to create {@link Context}\n+     * instance when it is necessary to associate one with the current\n+     * execution thread. <tt>makeContext()</tt> is allowed to call\n+     * {@link Context#seal(Object)} on the result to prevent\n+     * {@link Context} changes by hostile scripts or applets.\n+     */\n+    protected Context makeContext()\n+    {\n+        return new Context(this);\n+    }\n+\n+    /**\n+     * Implementation of {@link Context#hasFeature(int featureIndex)}.\n+     * This can be used to customize {@link Context} without introducing\n+     * additional subclasses.\n+     */\n+    protected boolean hasFeature(Context cx, int featureIndex)\n+    {\n+        int version;\n+        switch (featureIndex) {\n+          case Context.FEATURE_NON_ECMA_GET_YEAR:\n+           /*\n+            * During the great date rewrite of 1.3, we tried to track the\n+            * evolving ECMA standard, which then had a definition of\n+            * getYear which always subtracted 1900.  Which we\n+            * implemented, not realizing that it was incompatible with\n+            * the old behavior...  now, rather than thrash the behavior\n+            * yet again, we've decided to leave it with the - 1900\n+            * behavior and point people to the getFullYear method.  But\n+            * we try to protect existing scripts that have specified a\n+            * version...\n+            */\n+            version = cx.getLanguageVersion();\n+            return (version == Context.VERSION_1_0\n+                    || version == Context.VERSION_1_1\n+                    || version == Context.VERSION_1_2);\n+\n+          case Context.FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME:\n+            return false;\n+\n+          case Context.FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER:\n+            return false;\n+\n+          case Context.FEATURE_TO_STRING_AS_SOURCE:\n+            version = cx.getLanguageVersion();\n+            return version == Context.VERSION_1_2;\n+\n+          case Context.FEATURE_PARENT_PROTO_PROPERTIES:\n+            return true;\n+\n+          case Context.FEATURE_E4X:\n+            version = cx.getLanguageVersion();\n+            return (version == Context.VERSION_DEFAULT\n+                    || version >= Context.VERSION_1_6);\n+\n+          case Context.FEATURE_DYNAMIC_SCOPE:\n+            return false;\n+\n+          case Context.FEATURE_STRICT_VARS:\n+            return false;\n+\n+          case Context.FEATURE_STRICT_EVAL:\n+            return false;\n+\n+          case Context.FEATURE_LOCATION_INFORMATION_IN_ERROR:\n+            return false;\n+\n+          case Context.FEATURE_STRICT_MODE:\n+            return false;\n+\n+          case Context.FEATURE_WARNING_AS_ERROR:\n+            return false;\n+\n+          case Context.FEATURE_ENHANCED_JAVA_ACCESS:\n+            return false;\n+        }\n+        // It is a bug to call the method with unknown featureIndex\n+        throw new IllegalArgumentException(String.valueOf(featureIndex));\n+    }\n+\n+    private boolean isDom3Present() {\n+        Class<?> nodeClass = Kit.classOrNull(\"org.w3c.dom.Node\");\n+        if (nodeClass == null) return false;\n+        // Check to see whether DOM3 is present; use a new method defined in\n+        // DOM3 that is vital to our implementation\n+        try {\n+            nodeClass.getMethod(\"getUserData\", new Class<?>[] { String.class });\n+            return true;\n+        } catch (NoSuchMethodException e) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Provides a default\n+     * {@link org.mozilla.javascript.xml.XMLLib.Factory XMLLib.Factory}\n+     * to be used by the <code>Context</code> instances produced by this\n+     * factory. See {@link Context#getE4xImplementationFactory} for details.\n+     * \n+     * May return null, in which case E4X functionality is not supported in\n+     * Rhino.\n+     * \n+     * The default implementation now prefers the DOM3 E4X implementation.\n+     */\n+    protected org.mozilla.javascript.xml.XMLLib.Factory\n+        getE4xImplementationFactory()\n+    {\n+        // Must provide default implementation, rather than abstract method,\n+        // so that past implementors of ContextFactory do not fail at runtime\n+        // upon invocation of this method.\n+        // Note that the default implementation returns null if we\n+        // neither have XMLBeans nor a DOM3 implementation present.\n+\n+        if (isDom3Present()) {\n+            return org.mozilla.javascript.xml.XMLLib.Factory.create(\n+                \"org.mozilla.javascript.xmlimpl.XMLLibImpl\"\n+            );\n+        } else if (Kit.classOrNull(\"org.apache.xmlbeans.XmlCursor\") != null) {\n+            return org.mozilla.javascript.xml.XMLLib.Factory.create(\n+                \"org.mozilla.javascript.xml.impl.xmlbeans.XMLLibImpl\"\n+            );\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+\n+    /**\n+     * Create class loader for generated classes.\n+     * This method creates an instance of the default implementation\n+     * of {@link GeneratedClassLoader}. Rhino uses this interface to load\n+     * generated JVM classes when no {@link SecurityController}\n+     * is installed.\n+     * Application can override the method to provide custom class loading.\n+     */\n+    protected GeneratedClassLoader createClassLoader(final ClassLoader parent)\n+    {\n+        return AccessController.doPrivileged(new PrivilegedAction<DefiningClassLoader>() {\n+            public DefiningClassLoader run(){\n+                return new DefiningClassLoader(parent);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get ClassLoader to use when searching for Java classes.\n+     * Unless it was explicitly initialized with\n+     * {@link #initApplicationClassLoader(ClassLoader)} the method returns\n+     * null to indicate that Thread.getContextClassLoader() should be used.\n+     */\n+    public final ClassLoader getApplicationClassLoader()\n+    {\n+        return applicationClassLoader;\n+    }\n+\n+    /**\n+     * Set explicit class loader to use when searching for Java classes.\n+     *\n+     * @see #getApplicationClassLoader()\n+     */\n+    public final void initApplicationClassLoader(ClassLoader loader)\n+    {\n+        if (loader == null)\n+            throw new IllegalArgumentException(\"loader is null\");\n+        if (!Kit.testIfCanLoadRhinoClasses(loader))\n+            throw new IllegalArgumentException(\n+                \"Loader can not resolve Rhino classes\");\n+\n+        if (this.applicationClassLoader != null)\n+            throw new IllegalStateException(\n+                \"applicationClassLoader can only be set once\");\n+        checkNotSealed();\n+\n+        this.applicationClassLoader = loader;\n+    }\n+\n+    /**\n+     * Execute top call to script or function.\n+     * When the runtime is about to execute a script or function that will\n+     * create the first stack frame with scriptable code, it calls this method\n+     * to perform the real call. In this way execution of any script\n+     * happens inside this function.\n+     */\n+    protected Object doTopCall(Callable callable,\n+                               Context cx, Scriptable scope,\n+                               Scriptable thisObj, Object[] args)\n+    {\n+        return callable.call(cx, scope, thisObj, args);\n+    }\n+\n+    /**\n+     * Implementation of\n+     * {@link Context#observeInstructionCount(int instructionCount)}.\n+     * This can be used to customize {@link Context} without introducing\n+     * additional subclasses.\n+     */\n+    protected void observeInstructionCount(Context cx, int instructionCount) {\n+    }\n+\n+    protected void onContextCreated(Context cx)\n+    {\n+        Object listeners = this.listeners;\n+        for (int i = 0; ; ++i) {\n+            Listener l = (Listener)Kit.getListener(listeners, i);\n+            if (l == null)\n+                break;\n+            l.contextCreated(cx);\n+        }\n+    }\n+\n+    protected void onContextReleased(Context cx)\n+    {\n+        Object listeners = this.listeners;\n+        for (int i = 0; ; ++i) {\n+            Listener l = (Listener)Kit.getListener(listeners, i);\n+            if (l == null)\n+                break;\n+            l.contextReleased(cx);\n+        }\n+    }\n+\n+    public final void addListener(Listener listener)\n+    {\n+        checkNotSealed();\n+        synchronized (listenersLock) {\n+            if (disabledListening) {\n+                throw new IllegalStateException();\n+            }\n+            listeners = Kit.addListener(listeners, listener);\n+        }\n+    }\n+\n+    public final void removeListener(Listener listener)\n+    {\n+        checkNotSealed();\n+        synchronized (listenersLock) {\n+            if (disabledListening) {\n+                throw new IllegalStateException();\n+            }\n+            listeners = Kit.removeListener(listeners, listener);\n+        }\n+    }\n+\n+    /**\n+     * The method is used only to implement\n+     * Context.disableStaticContextListening()\n+     */\n+    final void disableContextListening()\n+    {\n+        checkNotSealed();\n+        synchronized (listenersLock) {\n+            disabledListening = true;\n+            listeners = null;\n+        }\n+    }\n+\n+    /**\n+     * Checks if this is a sealed ContextFactory.\n+     * @see #seal()\n+     */\n+    public final boolean isSealed()\n+    {\n+        return sealed;\n+    }\n+\n+    /**\n+     * Seal this ContextFactory so any attempt to modify it like to add or\n+     * remove its listeners will throw an exception.\n+     * @see #isSealed()\n+     */\n+    public final void seal()\n+    {\n+        checkNotSealed();\n+        sealed = true;\n+    }\n+\n+    protected final void checkNotSealed()\n+    {\n+        if (sealed) throw new IllegalStateException();\n+    }\n+\n+    /**\n+     * Call {@link ContextAction#run(Context cx)}\n+     * using the {@link Context} instance associated with the current thread.\n+     * If no Context is associated with the thread, then\n+     * {@link #makeContext()} will be called to construct\n+     * new Context instance. The instance will be temporary associated\n+     * with the thread during call to {@link ContextAction#run(Context)}.\n+     *\n+     * @see ContextFactory#call(ContextAction)\n+     * @see Context#call(ContextFactory factory, Callable callable,\n+     *                   Scriptable scope, Scriptable thisObj,\n+     *                   Object[] args)\n+     */\n+    public final Object call(ContextAction action)\n+    {\n+        return Context.call(this, action);\n+    }\n+\n+    /**\n+     * Get a context associated with the current thread, creating one if need \n+     * be. The Context stores the execution state of the JavaScript engine, so \n+     * it is required that the context be entered before execution may begin. \n+     * Once a thread has entered a Context, then getCurrentContext() may be \n+     * called to find the context that is associated with the current thread.\n+     * <p>\n+     * Calling <code>enterContext()</code> will return either the Context \n+     * currently associated with the thread, or will create a new context and \n+     * associate it with the current thread. Each call to \n+     * <code>enterContext()</code> must have a matching call to \n+     * {@link Context#exit()}.\n+     * <pre>\n+     *      Context cx = contextFactory.enterContext();\n+     *      try {\n+     *          ...\n+     *          cx.evaluateString(...);\n+     *      } finally {\n+     *          Context.exit();\n+     *      }\n+     * </pre>\n+     * Instead of using <tt>enterContext()</tt>, <tt>exit()</tt> pair consider \n+     * using {@link #call(ContextAction)} which guarantees proper association \n+     * of Context instances with the current thread.\n+     * With this method the above example becomes:\n+     * <pre>\n+     *      ContextFactory.call(new ContextAction() {\n+     *          public Object run(Context cx) {\n+     *              ...\n+     *              cx.evaluateString(...);\n+     *              return null;\n+     *          }\n+     *      });\n+     * </pre>\n+     * @return a Context associated with the current thread\n+     * @see Context#getCurrentContext()\n+     * @see Context#exit()\n+     * @see #call(ContextAction)\n+     */\n+    public Context enterContext()\n+    {\n+        return enterContext(null);\n+    }\n+    \n+    /**\n+     * @deprecated use {@link #enterContext()} instead\n+     * @return a Context associated with the current thread\n+     */\n+    public final Context enter()\n+    {\n+        return enterContext(null);\n+    }\n+\n+    /**\n+     * @deprecated Use {@link Context#exit()} instead.\n+     */\n+    public final void exit()\n+    {\n+        Context.exit();\n+    }\n+\n+    /**\n+     * Get a Context associated with the current thread, using the given \n+     * Context if need be.\n+     * <p>\n+     * The same as <code>enterContext()</code> except that <code>cx</code>\n+     * is associated with the current thread and returned if the current thread\n+     * has no associated context and <code>cx</code> is not associated with any\n+     * other thread.\n+     * @param cx a Context to associate with the thread if possible\n+     * @return a Context associated with the current thread\n+     * @see #enterContext()\n+     * @see #call(ContextAction)\n+     * @throws IllegalStateException if <code>cx</code> is already associated\n+     * with a different thread\n+     */\n+    public final Context enterContext(Context cx)\n+    {\n+        return Context.enter(cx, this);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ContextListener.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * @deprecated Embeddings that wish to customize newly created\n+ * {@link Context} instances should implement\n+ * {@link ContextFactory.Listener}.\n+ */\n+public interface ContextListener extends ContextFactory.Listener\n+{\n+\n+    /**\n+     * @deprecated Rhino runtime never calls the method.\n+     */\n+    public void contextEntered(Context cx);\n+\n+    /**\n+     * @deprecated Rhino runtime never calls the method.\n+     */\n+    public void contextExited(Context cx);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ContinuationPending.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Exception thrown by\n+ * {@link org.mozilla.javascript.Context#executeScriptWithContinuations(Script, Scriptable)}\n+ * and {@link org.mozilla.javascript.Context#callFunctionWithContinuations(Callable, Scriptable, Object[])}\n+ * when execution encounters a continuation captured by\n+ * {@link org.mozilla.javascript.Context#captureContinuation()}.\n+ * Exception will contain the captured state needed to restart the continuation\n+ * with {@link org.mozilla.javascript.Context#resumeContinuation(Object, Scriptable, Object)}.\n+ */\n+public class ContinuationPending extends RuntimeException {\n+    private static final long serialVersionUID = 4956008116771118856L;\n+    private NativeContinuation continuationState;\n+    private Object applicationState;\n+\n+    /**\n+     * Construct a ContinuationPending exception. Internal call only;\n+     * users of the API should get continuations created on their behalf by\n+     * calling {@link org.mozilla.javascript.Context#executeScriptWithContinuations(Script, Scriptable)}\n+     * and {@link org.mozilla.javascript.Context#callFunctionWithContinuations(Callable, Scriptable, Object[])}\n+     * @param continuationState Internal Continuation object\n+     */\n+    ContinuationPending(NativeContinuation continuationState) {\n+        this.continuationState = continuationState;\n+    }\n+\n+    /**\n+     * Get continuation object. The only\n+     * use for this object is to be passed to\n+     * {@link org.mozilla.javascript.Context#resumeContinuation(Object, Scriptable, Object)}.\n+     * @return continuation object\n+     */\n+    public Object getContinuation() {\n+        return continuationState;\n+    }\n+\n+    /**\n+     * @return internal continuation state\n+     */\n+    NativeContinuation getContinuationState() {\n+        return continuationState;\n+    }\n+\n+    /**\n+     * Store an arbitrary object that applications can use to associate\n+     * their state with the continuation.\n+     * @param applicationState arbitrary application state\n+     */\n+    public void setApplicationState(Object applicationState) {\n+        this.applicationState = applicationState;\n+    }\n+\n+    /**\n+     * @return arbitrary application state\n+     */\n+    public Object getApplicationState() {\n+        return applicationState;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/DToA.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Waldemar Horwat\n+ *   Roger Lawrence\n+ *   Attila Szegedi\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+/****************************************************************\n+  *\n+  * The author of this software is David M. Gay.\n+  *\n+  * Copyright (c) 1991, 2000, 2001 by Lucent Technologies.\n+  *\n+  * Permission to use, copy, modify, and distribute this software for any\n+  * purpose without fee is hereby granted, provided that this entire notice\n+  * is included in all copies of any software which is or includes a copy\n+  * or modification of this software and in all copies of the supporting\n+  * documentation for such software.\n+  *\n+  * THIS SOFTWARE IS BEING PROVIDED \"AS IS\", WITHOUT ANY EXPRESS OR IMPLIED\n+  * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR LUCENT MAKES ANY\n+  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY\n+  * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.\n+  *\n+  ***************************************************************/\n+\n+package org.mozilla.javascript;\n+\n+import java.math.BigInteger;\n+\n+class DToA {\n+\n+\n+/* \"-0.0000...(1073 zeros after decimal point)...0001\\0\" is the longest string that we could produce,\n+ * which occurs when printing -5e-324 in binary.  We could compute a better estimate of the size of\n+ * the output string and malloc fewer bytes depending on d and base, but why bother? */\n+\n+    private static final int DTOBASESTR_BUFFER_SIZE = 1078;\n+\n+    private static char BASEDIGIT(int digit) {\n+        return (char)((digit >= 10) ? 'a' - 10 + digit : '0' + digit);\n+    }\n+\n+    static final int\n+        DTOSTR_STANDARD = 0,              /* Either fixed or exponential format; round-trip */\n+        DTOSTR_STANDARD_EXPONENTIAL = 1,  /* Always exponential format; round-trip */\n+        DTOSTR_FIXED = 2,                 /* Round to <precision> digits after the decimal point; exponential if number is large */\n+        DTOSTR_EXPONENTIAL = 3,           /* Always exponential format; <precision> significant digits */\n+        DTOSTR_PRECISION = 4;             /* Either fixed or exponential format; <precision> significant digits */\n+\n+\n+    private static final int Frac_mask = 0xfffff;\n+    private static final int Exp_shift = 20;\n+    private static final int Exp_msk1 = 0x100000;\n+\n+    private static final long Frac_maskL = 0xfffffffffffffL;\n+    private static final int Exp_shiftL = 52;\n+    private static final long Exp_msk1L = 0x10000000000000L;\n+\n+    private static final int Bias = 1023;\n+    private static final int P = 53;\n+\n+    private static final int Exp_shift1 = 20;\n+    private static final int Exp_mask  = 0x7ff00000;\n+    private static final int Exp_mask_shifted = 0x7ff;\n+    private static final int Bndry_mask  = 0xfffff;\n+    private static final int Log2P = 1;\n+\n+    private static final int Sign_bit = 0x80000000;\n+    private static final int Exp_11  = 0x3ff00000;\n+    private static final int Ten_pmax = 22;\n+    private static final int Quick_max = 14;\n+    private static final int Bletch = 0x10;\n+    private static final int Frac_mask1 = 0xfffff;\n+    private static final int Int_max = 14;\n+    private static final int n_bigtens = 5;\n+\n+\n+    private static final double tens[] = {\n+        1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,\n+        1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n+        1e20, 1e21, 1e22\n+    };\n+\n+    private static final double bigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };\n+\n+    private static int lo0bits(int y)\n+    {\n+        int k;\n+        int x = y;\n+\n+        if ((x & 7) != 0) {\n+            if ((x & 1) != 0)\n+                return 0;\n+            if ((x & 2) != 0) {\n+                return 1;\n+            }\n+            return 2;\n+        }\n+        k = 0;\n+        if ((x & 0xffff) == 0) {\n+            k = 16;\n+            x >>>= 16;\n+        }\n+        if ((x & 0xff) == 0) {\n+            k += 8;\n+            x >>>= 8;\n+        }\n+        if ((x & 0xf) == 0) {\n+            k += 4;\n+            x >>>= 4;\n+        }\n+        if ((x & 0x3) == 0) {\n+            k += 2;\n+            x >>>= 2;\n+        }\n+        if ((x & 1) == 0) {\n+            k++;\n+            x >>>= 1;\n+            if ((x & 1) == 0)\n+                return 32;\n+        }\n+        return k;\n+    }\n+\n+    /* Return the number (0 through 32) of most significant zero bits in x. */\n+    private static int hi0bits(int x)\n+    {\n+        int k = 0;\n+\n+        if ((x & 0xffff0000) == 0) {\n+            k = 16;\n+            x <<= 16;\n+        }\n+        if ((x & 0xff000000) == 0) {\n+            k += 8;\n+            x <<= 8;\n+        }\n+        if ((x & 0xf0000000) == 0) {\n+            k += 4;\n+            x <<= 4;\n+        }\n+        if ((x & 0xc0000000) == 0) {\n+            k += 2;\n+            x <<= 2;\n+        }\n+        if ((x & 0x80000000) == 0) {\n+            k++;\n+            if ((x & 0x40000000) == 0)\n+                return 32;\n+        }\n+        return k;\n+    }\n+\n+    private static void stuffBits(byte bits[], int offset, int val)\n+    {\n+        bits[offset] = (byte)(val >> 24);\n+        bits[offset + 1] = (byte)(val >> 16);\n+        bits[offset + 2] = (byte)(val >> 8);\n+        bits[offset + 3] = (byte)(val);\n+    }\n+\n+    /* Convert d into the form b*2^e, where b is an odd integer.  b is the returned\n+     * Bigint and e is the returned binary exponent.  Return the number of significant\n+     * bits in b in bits.  d must be finite and nonzero. */\n+    private static BigInteger d2b(double d, int[] e, int[] bits)\n+    {\n+        byte dbl_bits[];\n+        int i, k, y, z, de;\n+        long dBits = Double.doubleToLongBits(d);\n+        int d0 = (int)(dBits >>> 32);\n+        int d1 = (int)(dBits);\n+\n+        z = d0 & Frac_mask;\n+        d0 &= 0x7fffffff;   /* clear sign bit, which we ignore */\n+\n+        if ((de = (d0 >>> Exp_shift)) != 0)\n+            z |= Exp_msk1;\n+\n+        if ((y = d1) != 0) {\n+            dbl_bits = new byte[8];\n+            k = lo0bits(y);\n+            y >>>= k;\n+            if (k != 0) {\n+                stuffBits(dbl_bits, 4, y | z << (32 - k));\n+                z >>= k;\n+            }\n+            else\n+                stuffBits(dbl_bits, 4, y);\n+            stuffBits(dbl_bits, 0, z);\n+            i = (z != 0) ? 2 : 1;\n+        }\n+        else {\n+    //        JS_ASSERT(z);\n+            dbl_bits = new byte[4];\n+            k = lo0bits(z);\n+            z >>>= k;\n+            stuffBits(dbl_bits, 0, z);\n+            k += 32;\n+            i = 1;\n+        }\n+        if (de != 0) {\n+            e[0] = de - Bias - (P-1) + k;\n+            bits[0] = P - k;\n+        }\n+        else {\n+            e[0] = de - Bias - (P-1) + 1 + k;\n+            bits[0] = 32*i - hi0bits(z);\n+        }\n+        return new BigInteger(dbl_bits);\n+    }\n+\n+    static String JS_dtobasestr(int base, double d)\n+    {\n+        if (!(2 <= base && base <= 36))\n+            throw new IllegalArgumentException(\"Bad base: \"+base);\n+\n+        /* Check for Infinity and NaN */\n+        if (Double.isNaN(d)) {\n+            return \"NaN\";\n+        } else if (Double.isInfinite(d)) {\n+            return (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n+        } else if (d == 0) {\n+            // ALERT: should it distinguish -0.0 from +0.0 ?\n+            return \"0\";\n+        }\n+\n+        boolean negative;\n+        if (d >= 0.0) {\n+            negative = false;\n+        } else {\n+            negative = true;\n+            d = -d;\n+        }\n+\n+        /* Get the integer part of d including '-' sign. */\n+        String intDigits;\n+\n+        double dfloor = Math.floor(d);\n+        long lfloor = (long)dfloor;\n+        if (lfloor == dfloor) {\n+            // int part fits long\n+            intDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n+        } else {\n+            // BigInteger should be used\n+            long floorBits = Double.doubleToLongBits(dfloor);\n+            int exp = (int)(floorBits >> Exp_shiftL) & Exp_mask_shifted;\n+            long mantissa;\n+            if (exp == 0) {\n+                mantissa = (floorBits & Frac_maskL) << 1;\n+            } else {\n+                mantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n+            }\n+            if (negative) {\n+                mantissa = -mantissa;\n+            }\n+            exp -= 1075;\n+            BigInteger x = BigInteger.valueOf(mantissa);\n+            if (exp > 0) {\n+                x = x.shiftLeft(exp);\n+            } else if (exp < 0) {\n+                x = x.shiftRight(-exp);\n+            }\n+            intDigits = x.toString(base);\n+        }\n+\n+        if (d == dfloor) {\n+            // No fraction part\n+            return intDigits;\n+        } else {\n+            /* We have a fraction. */\n+\n+            char[] buffer;       /* The output string */\n+            int p;               /* index to current position in the buffer */\n+            int digit;\n+            double df;           /* The fractional part of d */\n+            BigInteger b;\n+\n+            buffer = new char[DTOBASESTR_BUFFER_SIZE];\n+            p = 0;\n+            df = d - dfloor;\n+\n+            long dBits = Double.doubleToLongBits(d);\n+            int word0 = (int)(dBits >> 32);\n+            int word1 = (int)(dBits);\n+\n+            int[] e = new int[1];\n+            int[] bbits = new int[1];\n+\n+            b = d2b(df, e, bbits);\n+//            JS_ASSERT(e < 0);\n+            /* At this point df = b * 2^e.  e must be less than zero because 0 < df < 1. */\n+\n+            int s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\n+            if (s2 == 0)\n+                s2 = -1;\n+            s2 += Bias + P;\n+            /* 1/2^s2 = (nextDouble(d) - d)/2 */\n+//            JS_ASSERT(-s2 < e);\n+            BigInteger mlo = BigInteger.valueOf(1);\n+            BigInteger mhi = mlo;\n+            if ((word1 == 0) && ((word0 & Bndry_mask) == 0)\n+                && ((word0 & (Exp_mask & Exp_mask << 1)) != 0)) {\n+                /* The special case.  Here we want to be within a quarter of the last input\n+                   significant digit instead of one half of it when the output string's value is less than d.  */\n+                s2 += Log2P;\n+                mhi = BigInteger.valueOf(1<<Log2P);\n+            }\n+\n+            b = b.shiftLeft(e[0] + s2);\n+            BigInteger s = BigInteger.valueOf(1);\n+            s = s.shiftLeft(s2);\n+            /* At this point we have the following:\n+             *   s = 2^s2;\n+             *   1 > df = b/2^s2 > 0;\n+             *   (d - prevDouble(d))/2 = mlo/2^s2;\n+             *   (nextDouble(d) - d)/2 = mhi/2^s2. */\n+            BigInteger bigBase = BigInteger.valueOf(base);\n+\n+            boolean done = false;\n+            do {\n+                b = b.multiply(bigBase);\n+                BigInteger[] divResult = b.divideAndRemainder(s);\n+                b = divResult[1];\n+                digit = (char)(divResult[0].intValue());\n+                if (mlo == mhi)\n+                    mlo = mhi = mlo.multiply(bigBase);\n+                else {\n+                    mlo = mlo.multiply(bigBase);\n+                    mhi = mhi.multiply(bigBase);\n+                }\n+\n+                /* Do we yet have the shortest string that will round to d? */\n+                int j = b.compareTo(mlo);\n+                /* j is b/2^s2 compared with mlo/2^s2. */\n+                BigInteger delta = s.subtract(mhi);\n+                int j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n+                /* j1 is b/2^s2 compared with 1 - mhi/2^s2. */\n+                if (j1 == 0 && ((word1 & 1) == 0)) {\n+                    if (j > 0)\n+                        digit++;\n+                    done = true;\n+                } else\n+                if (j < 0 || (j == 0 && ((word1 & 1) == 0))) {\n+                    if (j1 > 0) {\n+                        /* Either dig or dig+1 would work here as the least significant digit.\n+                           Use whichever would produce an output value closer to d. */\n+                        b = b.shiftLeft(1);\n+                        j1 = b.compareTo(s);\n+                        if (j1 > 0) /* The even test (|| (j1 == 0 && (digit & 1))) is not here because it messes up odd base output\n+                                     * such as 3.5 in base 3.  */\n+                            digit++;\n+                    }\n+                    done = true;\n+                } else if (j1 > 0) {\n+                    digit++;\n+                    done = true;\n+                }\n+//                JS_ASSERT(digit < (uint32)base);\n+                buffer[p++] = BASEDIGIT(digit);\n+            } while (!done);\n+\n+            StringBuffer sb = new StringBuffer(intDigits.length() + 1 + p);\n+            sb.append(intDigits);\n+            sb.append('.');\n+            sb.append(buffer, 0, p);\n+            return sb.toString();\n+        }\n+\n+    }\n+\n+    /* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.\n+     *\n+     * Inspired by \"How to Print Floating-Point Numbers Accurately\" by\n+     * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 92-101].\n+     *\n+     * Modifications:\n+     *  1. Rather than iterating, we use a simple numeric overestimate\n+     *     to determine k = floor(log10(d)).  We scale relevant\n+     *     quantities using O(log2(k)) rather than O(k) multiplications.\n+     *  2. For some modes > 2 (corresponding to ecvt and fcvt), we don't\n+     *     try to generate digits strictly left to right.  Instead, we\n+     *     compute with fewer bits and propagate the carry if necessary\n+     *     when rounding the final digit up.  This is often faster.\n+     *  3. Under the assumption that input will be rounded nearest,\n+     *     mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.\n+     *     That is, we allow equality in stopping tests when the\n+     *     round-nearest rule will give the same floating-point value\n+     *     as would satisfaction of the stopping test with strict\n+     *     inequality.\n+     *  4. We remove common factors of powers of 2 from relevant\n+     *     quantities.\n+     *  5. When converting floating-point integers less than 1e16,\n+     *     we use floating-point arithmetic rather than resorting\n+     *     to multiple-precision integers.\n+     *  6. When asked to produce fewer than 15 digits, we first try\n+     *     to get by with floating-point arithmetic; we resort to\n+     *     multiple-precision integer arithmetic only if we cannot\n+     *     guarantee that the floating-point calculation has given\n+     *     the correctly rounded result.  For k requested digits and\n+     *     \"uniformly\" distributed input, the probability is\n+     *     something like 10^(k-15) that we must resort to the Long\n+     *     calculation.\n+     */\n+\n+    static int word0(double d)\n+    {\n+        long dBits = Double.doubleToLongBits(d);\n+        return (int)(dBits >> 32);\n+    }\n+\n+    static double setWord0(double d, int i)\n+    {\n+        long dBits = Double.doubleToLongBits(d);\n+        dBits = ((long)i << 32) | (dBits & 0x0FFFFFFFFL);\n+        return Double.longBitsToDouble(dBits);\n+    }\n+\n+    static int word1(double d)\n+    {\n+        long dBits = Double.doubleToLongBits(d);\n+        return (int)(dBits);\n+    }\n+\n+    /* Return b * 5^k.  k must be nonnegative. */\n+    // XXXX the C version built a cache of these\n+    static BigInteger pow5mult(BigInteger b, int k)\n+    {\n+        return b.multiply(BigInteger.valueOf(5).pow(k));\n+    }\n+\n+    static boolean roundOff(StringBuffer buf)\n+    {\n+        int i = buf.length();\n+        while (i != 0) {\n+            --i;\n+            char c = buf.charAt(i);\n+            if (c != '9') {\n+                buf.setCharAt(i, (char)(c + 1));\n+                buf.setLength(i + 1);\n+                return false;\n+            }\n+        }\n+        buf.setLength(0);\n+        return true;\n+    }\n+\n+    /* Always emits at least one digit. */\n+    /* If biasUp is set, then rounding in modes 2 and 3 will round away from zero\n+     * when the number is exactly halfway between two representable values.  For example,\n+     * rounding 2.5 to zero digits after the decimal point will return 3 and not 2.\n+     * 2.49 will still round to 2, and 2.51 will still round to 3. */\n+    /* bufsize should be at least 20 for modes 0 and 1.  For the other modes,\n+     * bufsize should be two greater than the maximum number of output characters expected. */\n+    static int\n+    JS_dtoa(double d, int mode, boolean biasUp, int ndigits,\n+                    boolean[] sign, StringBuffer buf)\n+    {\n+        /*  Arguments ndigits, decpt, sign are similar to those\n+            of ecvt and fcvt; trailing zeros are suppressed from\n+            the returned string.  If not null, *rve is set to point\n+            to the end of the return value.  If d is +-Infinity or NaN,\n+            then *decpt is set to 9999.\n+\n+            mode:\n+            0 ==> shortest string that yields d when read in\n+            and rounded to nearest.\n+            1 ==> like 0, but with Steele & White stopping rule;\n+            e.g. with IEEE P754 arithmetic , mode 0 gives\n+            1e23 whereas mode 1 gives 9.999999999999999e22.\n+            2 ==> max(1,ndigits) significant digits.  This gives a\n+            return value similar to that of ecvt, except\n+            that trailing zeros are suppressed.\n+            3 ==> through ndigits past the decimal point.  This\n+            gives a return value similar to that from fcvt,\n+            except that trailing zeros are suppressed, and\n+            ndigits can be negative.\n+            4-9 should give the same return values as 2-3, i.e.,\n+            4 <= mode <= 9 ==> same return as mode\n+            2 + (mode & 1).  These modes are mainly for\n+            debugging; often they run slower but sometimes\n+            faster than modes 2-3.\n+            4,5,8,9 ==> left-to-right digit generation.\n+            6-9 ==> don't try fast floating-point estimate\n+            (if applicable).\n+\n+            Values of mode other than 0-9 are treated as mode 0.\n+\n+            Sufficient space is allocated to the return value\n+            to hold the suppressed trailing zeros.\n+        */\n+\n+        int b2, b5, i, ieps, ilim, ilim0, ilim1,\n+            j, j1, k, k0, m2, m5, s2, s5;\n+        char dig;\n+        long L;\n+        long x;\n+        BigInteger b, b1, delta, mlo, mhi, S;\n+        int[] be = new int[1];\n+        int[] bbits = new int[1];\n+        double d2, ds, eps;\n+        boolean spec_case, denorm, k_check, try_quick, leftright;\n+\n+        if ((word0(d) & Sign_bit) != 0) {\n+            /* set sign for everything, including 0's and NaNs */\n+            sign[0] = true;\n+            // word0(d) &= ~Sign_bit;  /* clear sign bit */\n+            d = setWord0(d, word0(d) & ~Sign_bit);\n+        }\n+        else\n+            sign[0] = false;\n+\n+        if ((word0(d) & Exp_mask) == Exp_mask) {\n+            /* Infinity or NaN */\n+            buf.append(((word1(d) == 0) && ((word0(d) & Frac_mask) == 0)) ? \"Infinity\" : \"NaN\");\n+            return 9999;\n+        }\n+        if (d == 0) {\n+//          no_digits:\n+            buf.setLength(0);\n+            buf.append('0');        /* copy \"0\" to buffer */\n+            return 1;\n+        }\n+\n+        b = d2b(d, be, bbits);\n+        if ((i = (word0(d) >>> Exp_shift1 & (Exp_mask>>Exp_shift1))) != 0) {\n+            d2 = setWord0(d, (word0(d) & Frac_mask1) | Exp_11);\n+            /* log(x)   ~=~ log(1.5) + (x-1.5)/1.5\n+             * log10(x)  =  log(x) / log(10)\n+             *      ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))\n+             * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2)\n+             *\n+             * This suggests computing an approximation k to log10(d) by\n+             *\n+             * k = (i - Bias)*0.301029995663981\n+             *  + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );\n+             *\n+             * We want k to be too large rather than too small.\n+             * The error in the first-order Taylor series approximation\n+             * is in our favor, so we just round up the constant enough\n+             * to compensate for any error in the multiplication of\n+             * (i - Bias) by 0.301029995663981; since |i - Bias| <= 1077,\n+             * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,\n+             * adding 1e-13 to the constant term more than suffices.\n+             * Hence we adjust the constant term to 0.1760912590558.\n+             * (We could get a more accurate k by invoking log10,\n+             *  but this is probably not worthwhile.)\n+             */\n+            i -= Bias;\n+            denorm = false;\n+        }\n+        else {\n+            /* d is denormalized */\n+            i = bbits[0] + be[0] + (Bias + (P-1) - 1);\n+            x = (i > 32) ? word0(d) << (64 - i) | word1(d) >>> (i - 32) : word1(d) << (32 - i);\n+//            d2 = x;\n+//            word0(d2) -= 31*Exp_msk1; /* adjust exponent */\n+            d2 = setWord0(x, word0(x) - 31*Exp_msk1);\n+            i -= (Bias + (P-1) - 1) + 1;\n+            denorm = true;\n+        }\n+        /* At this point d = f*2^i, where 1 <= f < 2.  d2 is an approximation of f. */\n+        ds = (d2-1.5)*0.289529654602168 + 0.1760912590558 + i*0.301029995663981;\n+        k = (int)ds;\n+        if (ds < 0.0 && ds != k)\n+            k--;    /* want k = floor(ds) */\n+        k_check = true;\n+        if (k >= 0 && k <= Ten_pmax) {\n+            if (d < tens[k])\n+                k--;\n+            k_check = false;\n+        }\n+        /* At this point floor(log10(d)) <= k <= floor(log10(d))+1.\n+           If k_check is zero, we're guaranteed that k = floor(log10(d)). */\n+        j = bbits[0] - i - 1;\n+        /* At this point d = b/2^j, where b is an odd integer. */\n+        if (j >= 0) {\n+            b2 = 0;\n+            s2 = j;\n+        }\n+        else {\n+            b2 = -j;\n+            s2 = 0;\n+        }\n+        if (k >= 0) {\n+            b5 = 0;\n+            s5 = k;\n+            s2 += k;\n+        }\n+        else {\n+            b2 -= k;\n+            b5 = -k;\n+            s5 = 0;\n+        }\n+        /* At this point d/10^k = (b * 2^b2 * 5^b5) / (2^s2 * 5^s5), where b is an odd integer,\n+           b2 >= 0, b5 >= 0, s2 >= 0, and s5 >= 0. */\n+        if (mode < 0 || mode > 9)\n+            mode = 0;\n+        try_quick = true;\n+        if (mode > 5) {\n+            mode -= 4;\n+            try_quick = false;\n+        }\n+        leftright = true;\n+        ilim = ilim1 = 0;\n+        switch(mode) {\n+            case 0:\n+            case 1:\n+                ilim = ilim1 = -1;\n+                i = 18;\n+                ndigits = 0;\n+                break;\n+            case 2:\n+                leftright = false;\n+                /* no break */\n+            case 4:\n+                if (ndigits <= 0)\n+                    ndigits = 1;\n+                ilim = ilim1 = i = ndigits;\n+                break;\n+            case 3:\n+                leftright = false;\n+                /* no break */\n+            case 5:\n+                i = ndigits + k + 1;\n+                ilim = i;\n+                ilim1 = i - 1;\n+                if (i <= 0)\n+                    i = 1;\n+        }\n+        /* ilim is the maximum number of significant digits we want, based on k and ndigits. */\n+        /* ilim1 is the maximum number of significant digits we want, based on k and ndigits,\n+           when it turns out that k was computed too high by one. */\n+\n+        boolean fast_failed = false;\n+        if (ilim >= 0 && ilim <= Quick_max && try_quick) {\n+\n+            /* Try to get by with floating-point arithmetic. */\n+\n+            i = 0;\n+            d2 = d;\n+            k0 = k;\n+            ilim0 = ilim;\n+            ieps = 2; /* conservative */\n+            /* Divide d by 10^k, keeping track of the roundoff error and avoiding overflows. */\n+            if (k > 0) {\n+                ds = tens[k&0xf];\n+                j = k >> 4;\n+                if ((j & Bletch) != 0) {\n+                    /* prevent overflows */\n+                    j &= Bletch - 1;\n+                    d /= bigtens[n_bigtens-1];\n+                    ieps++;\n+                }\n+                for(; (j != 0); j >>= 1, i++)\n+                    if ((j & 1) != 0) {\n+                        ieps++;\n+                        ds *= bigtens[i];\n+                    }\n+                d /= ds;\n+            }\n+            else if ((j1 = -k) != 0) {\n+                d *= tens[j1 & 0xf];\n+                for(j = j1 >> 4; (j != 0); j >>= 1, i++)\n+                    if ((j & 1) != 0) {\n+                        ieps++;\n+                        d *= bigtens[i];\n+                    }\n+            }\n+            /* Check that k was computed correctly. */\n+            if (k_check && d < 1.0 && ilim > 0) {\n+                if (ilim1 <= 0)\n+                    fast_failed = true;\n+                else {\n+                    ilim = ilim1;\n+                    k--;\n+                    d *= 10.;\n+                    ieps++;\n+                }\n+            }\n+            /* eps bounds the cumulative error. */\n+//            eps = ieps*d + 7.0;\n+//            word0(eps) -= (P-1)*Exp_msk1;\n+            eps = ieps*d + 7.0;\n+            eps = setWord0(eps, word0(eps) - (P-1)*Exp_msk1);\n+            if (ilim == 0) {\n+                S = mhi = null;\n+                d -= 5.0;\n+                if (d > eps) {\n+                    buf.append('1');\n+                    k++;\n+                    return k + 1;\n+                }\n+                if (d < -eps) {\n+                    buf.setLength(0);\n+                    buf.append('0');        /* copy \"0\" to buffer */\n+                    return 1;\n+                }\n+                fast_failed = true;\n+            }\n+            if (!fast_failed) {\n+                fast_failed = true;\n+                if (leftright) {\n+                    /* Use Steele & White method of only\n+                     * generating digits needed.\n+                     */\n+                    eps = 0.5/tens[ilim-1] - eps;\n+                    for(i = 0;;) {\n+                        L = (long)d;\n+                        d -= L;\n+                        buf.append((char)('0' + L));\n+                        if (d < eps) {\n+                            return k + 1;\n+                        }\n+                        if (1.0 - d < eps) {\n+//                            goto bump_up;\n+                                char lastCh;\n+                                while (true) {\n+                                    lastCh = buf.charAt(buf.length() - 1);\n+                                    buf.setLength(buf.length() - 1);\n+                                    if (lastCh != '9') break;\n+                                    if (buf.length() == 0) {\n+                                        k++;\n+                                        lastCh = '0';\n+                                        break;\n+                                    }\n+                                }\n+                                buf.append((char)(lastCh + 1));\n+                                return k + 1;\n+                        }\n+                        if (++i >= ilim)\n+                            break;\n+                        eps *= 10.0;\n+                        d *= 10.0;\n+                    }\n+                }\n+                else {\n+                    /* Generate ilim digits, then fix them up. */\n+                    eps *= tens[ilim-1];\n+                    for(i = 1;; i++, d *= 10.0) {\n+                        L = (long)d;\n+                        d -= L;\n+                        buf.append((char)('0' + L));\n+                        if (i == ilim) {\n+                            if (d > 0.5 + eps) {\n+//                                goto bump_up;\n+                                char lastCh;\n+                                while (true) {\n+                                    lastCh = buf.charAt(buf.length() - 1);\n+                                    buf.setLength(buf.length() - 1);\n+                                    if (lastCh != '9') break;\n+                                    if (buf.length() == 0) {\n+                                        k++;\n+                                        lastCh = '0';\n+                                        break;\n+                                    }\n+                                }\n+                                buf.append((char)(lastCh + 1));\n+                                return k + 1;\n+                            }\n+                            else\n+                                if (d < 0.5 - eps) {\n+                                    stripTrailingZeroes(buf);                                    \n+//                                    while(*--s == '0') ;\n+//                                    s++;\n+                                    return k + 1;\n+                                }\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            if (fast_failed) {\n+                buf.setLength(0);\n+                d = d2;\n+                k = k0;\n+                ilim = ilim0;\n+            }\n+        }\n+\n+        /* Do we have a \"small\" integer? */\n+\n+        if (be[0] >= 0 && k <= Int_max) {\n+            /* Yes. */\n+            ds = tens[k];\n+            if (ndigits < 0 && ilim <= 0) {\n+                S = mhi = null;\n+                if (ilim < 0 || d < 5*ds || (!biasUp && d == 5*ds)) {\n+                    buf.setLength(0);\n+                    buf.append('0');        /* copy \"0\" to buffer */\n+                    return 1;\n+                }\n+                buf.append('1');\n+                k++;\n+                return k + 1;\n+            }\n+            for(i = 1;; i++) {\n+                L = (long) (d / ds);\n+                d -= L*ds;\n+                buf.append((char)('0' + L));\n+                if (i == ilim) {\n+                    d += d;\n+                    if ((d > ds) || (d == ds && (((L & 1) != 0) || biasUp))) {\n+//                    bump_up:\n+//                        while(*--s == '9')\n+//                            if (s == buf) {\n+//                                k++;\n+//                                *s = '0';\n+//                                break;\n+//                            }\n+//                        ++*s++;\n+                        char lastCh;\n+                        while (true) {\n+                            lastCh = buf.charAt(buf.length() - 1);\n+                            buf.setLength(buf.length() - 1);\n+                            if (lastCh != '9') break;\n+                            if (buf.length() == 0) {\n+                                k++;\n+                                lastCh = '0';\n+                                break;\n+                            }\n+                        }\n+                        buf.append((char)(lastCh + 1));\n+                    }\n+                    break;\n+                }\n+                d *= 10.0;\n+                if (d == 0)\n+                    break;\n+            }\n+            return k + 1;\n+        }\n+\n+        m2 = b2;\n+        m5 = b5;\n+        mhi = mlo = null;\n+        if (leftright) {\n+            if (mode < 2) {\n+                i = (denorm) ? be[0] + (Bias + (P-1) - 1 + 1) : 1 + P - bbits[0];\n+                /* i is 1 plus the number of trailing zero bits in d's significand. Thus,\n+                   (2^m2 * 5^m5) / (2^(s2+i) * 5^s5) = (1/2 lsb of d)/10^k. */\n+            }\n+            else {\n+                j = ilim - 1;\n+                if (m5 >= j)\n+                    m5 -= j;\n+                else {\n+                    s5 += j -= m5;\n+                    b5 += j;\n+                    m5 = 0;\n+                }\n+                if ((i = ilim) < 0) {\n+                    m2 -= i;\n+                    i = 0;\n+                }\n+                /* (2^m2 * 5^m5) / (2^(s2+i) * 5^s5) = (1/2 * 10^(1-ilim))/10^k. */\n+            }\n+            b2 += i;\n+            s2 += i;\n+            mhi = BigInteger.valueOf(1);\n+            /* (mhi * 2^m2 * 5^m5) / (2^s2 * 5^s5) = one-half of last printed (when mode >= 2) or\n+               input (when mode < 2) significant digit, divided by 10^k. */\n+        }\n+        /* We still have d/10^k = (b * 2^b2 * 5^b5) / (2^s2 * 5^s5).  Reduce common factors in\n+           b2, m2, and s2 without changing the equalities. */\n+        if (m2 > 0 && s2 > 0) {\n+            i = (m2 < s2) ? m2 : s2;\n+            b2 -= i;\n+            m2 -= i;\n+            s2 -= i;\n+        }\n+\n+        /* Fold b5 into b and m5 into mhi. */\n+        if (b5 > 0) {\n+            if (leftright) {\n+                if (m5 > 0) {\n+                    mhi = pow5mult(mhi, m5);\n+                    b1 = mhi.multiply(b);\n+                    b = b1;\n+                }\n+                if ((j = b5 - m5) != 0)\n+                    b = pow5mult(b, j);\n+            }\n+            else\n+                b = pow5mult(b, b5);\n+        }\n+        /* Now we have d/10^k = (b * 2^b2) / (2^s2 * 5^s5) and\n+           (mhi * 2^m2) / (2^s2 * 5^s5) = one-half of last printed or input significant digit, divided by 10^k. */\n+\n+        S = BigInteger.valueOf(1);\n+        if (s5 > 0)\n+            S = pow5mult(S, s5);\n+        /* Now we have d/10^k = (b * 2^b2) / (S * 2^s2) and\n+           (mhi * 2^m2) / (S * 2^s2) = one-half of last printed or input significant digit, divided by 10^k. */\n+\n+        /* Check for special case that d is a normalized power of 2. */\n+        spec_case = false;\n+        if (mode < 2) {\n+            if ( (word1(d) == 0) && ((word0(d) & Bndry_mask) == 0)\n+                && ((word0(d) & (Exp_mask & Exp_mask << 1)) != 0)\n+                ) {\n+                /* The special case.  Here we want to be within a quarter of the last input\n+                   significant digit instead of one half of it when the decimal output string's value is less than d.  */\n+                b2 += Log2P;\n+                s2 += Log2P;\n+                spec_case = true;\n+            }\n+        }\n+\n+        /* Arrange for convenient computation of quotients:\n+         * shift left if necessary so divisor has 4 leading 0 bits.\n+         *\n+         * Perhaps we should just compute leading 28 bits of S once\n+         * and for all and pass them and a shift to quorem, so it\n+         * can do shifts and ors to compute the numerator for q.\n+         */\n+        byte [] S_bytes = S.toByteArray();\n+        int S_hiWord = 0;\n+        for (int idx = 0; idx < 4; idx++) {\n+            S_hiWord = (S_hiWord << 8);\n+            if (idx < S_bytes.length)\n+                S_hiWord |= (S_bytes[idx] & 0xFF);\n+        }\n+        if ((i = (((s5 != 0) ? 32 - hi0bits(S_hiWord) : 1) + s2) & 0x1f) != 0)\n+            i = 32 - i;\n+        /* i is the number of leading zero bits in the most significant word of S*2^s2. */\n+        if (i > 4) {\n+            i -= 4;\n+            b2 += i;\n+            m2 += i;\n+            s2 += i;\n+        }\n+        else if (i < 4) {\n+            i += 28;\n+            b2 += i;\n+            m2 += i;\n+            s2 += i;\n+        }\n+        /* Now S*2^s2 has exactly four leading zero bits in its most significant word. */\n+        if (b2 > 0)\n+            b = b.shiftLeft(b2);\n+        if (s2 > 0)\n+            S = S.shiftLeft(s2);\n+        /* Now we have d/10^k = b/S and\n+           (mhi * 2^m2) / S = maximum acceptable error, divided by 10^k. */\n+        if (k_check) {\n+            if (b.compareTo(S) < 0) {\n+                k--;\n+                b = b.multiply(BigInteger.valueOf(10));  /* we botched the k estimate */\n+                if (leftright)\n+                    mhi = mhi.multiply(BigInteger.valueOf(10));\n+                ilim = ilim1;\n+            }\n+        }\n+        /* At this point 1 <= d/10^k = b/S < 10. */\n+\n+        if (ilim <= 0 && mode > 2) {\n+            /* We're doing fixed-mode output and d is less than the minimum nonzero output in this mode.\n+               Output either zero or the minimum nonzero output depending on which is closer to d. */\n+            if ((ilim < 0 )\n+                    || ((i = b.compareTo(S = S.multiply(BigInteger.valueOf(5)))) < 0)\n+                    || ((i == 0 && !biasUp))) {\n+            /* Always emit at least one digit.  If the number appears to be zero\n+               using the current mode, then emit one '0' digit and set decpt to 1. */\n+            /*no_digits:\n+                k = -1 - ndigits;\n+                goto ret; */\n+                buf.setLength(0);\n+                buf.append('0');        /* copy \"0\" to buffer */\n+                return 1;\n+//                goto no_digits;\n+            }\n+//        one_digit:\n+            buf.append('1');\n+            k++;\n+            return k + 1;\n+        }\n+        if (leftright) {\n+            if (m2 > 0)\n+                mhi = mhi.shiftLeft(m2);\n+\n+            /* Compute mlo -- check for special case\n+             * that d is a normalized power of 2.\n+             */\n+\n+            mlo = mhi;\n+            if (spec_case) {\n+                mhi = mlo;\n+                mhi = mhi.shiftLeft(Log2P);\n+            }\n+            /* mlo/S = maximum acceptable error, divided by 10^k, if the output is less than d. */\n+            /* mhi/S = maximum acceptable error, divided by 10^k, if the output is greater than d. */\n+\n+            for(i = 1;;i++) {\n+                BigInteger[] divResult = b.divideAndRemainder(S);\n+                b = divResult[1];\n+                dig = (char)(divResult[0].intValue() + '0');\n+                /* Do we yet have the shortest decimal string\n+                 * that will round to d?\n+                 */\n+                j = b.compareTo(mlo);\n+                /* j is b/S compared with mlo/S. */\n+                delta = S.subtract(mhi);\n+                j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n+                /* j1 is b/S compared with 1 - mhi/S. */\n+                if ((j1 == 0) && (mode == 0) && ((word1(d) & 1) == 0)) {\n+                    if (dig == '9') {\n+                        buf.append('9');\n+                        if (roundOff(buf)) {\n+                            k++;\n+                            buf.append('1');\n+                        }\n+                        return k + 1;\n+//                        goto round_9_up;\n+                    }\n+                    if (j > 0)\n+                        dig++;\n+                    buf.append(dig);\n+                    return k + 1;\n+                }\n+                if ((j < 0)\n+                        || ((j == 0)\n+                            && (mode == 0)\n+                            && ((word1(d) & 1) == 0)\n+                    )) {\n+                    if (j1 > 0) {\n+                        /* Either dig or dig+1 would work here as the least significant decimal digit.\n+                           Use whichever would produce a decimal value closer to d. */\n+                        b = b.shiftLeft(1);\n+                        j1 = b.compareTo(S);\n+                        if (((j1 > 0) || (j1 == 0 && (((dig & 1) == 1) || biasUp)))\n+                            && (dig++ == '9')) {\n+                                buf.append('9');\n+                                if (roundOff(buf)) {\n+                                    k++;\n+                                    buf.append('1');\n+                                }\n+                                return k + 1;\n+//                                goto round_9_up;\n+                        }\n+                    }\n+                    buf.append(dig);\n+                    return k + 1;\n+                }\n+                if (j1 > 0) {\n+                    if (dig == '9') { /* possible if i == 1 */\n+//                    round_9_up:\n+//                        *s++ = '9';\n+//                        goto roundoff;\n+                        buf.append('9');\n+                        if (roundOff(buf)) {\n+                            k++;\n+                            buf.append('1');\n+                        }\n+                        return k + 1;\n+                    }\n+                    buf.append((char)(dig + 1));\n+                    return k + 1;\n+                }\n+                buf.append(dig);\n+                if (i == ilim)\n+                    break;\n+                b = b.multiply(BigInteger.valueOf(10));\n+                if (mlo == mhi)\n+                    mlo = mhi = mhi.multiply(BigInteger.valueOf(10));\n+                else {\n+                    mlo = mlo.multiply(BigInteger.valueOf(10));\n+                    mhi = mhi.multiply(BigInteger.valueOf(10));\n+                }\n+            }\n+        }\n+        else\n+            for(i = 1;; i++) {\n+//                (char)(dig = quorem(b,S) + '0');\n+                BigInteger[] divResult = b.divideAndRemainder(S);\n+                b = divResult[1];\n+                dig = (char)(divResult[0].intValue() + '0');\n+                buf.append(dig);\n+                if (i >= ilim)\n+                    break;\n+                b = b.multiply(BigInteger.valueOf(10));\n+            }\n+\n+        /* Round off last digit */\n+\n+        b = b.shiftLeft(1);\n+        j = b.compareTo(S);\n+        if ((j > 0) || (j == 0 && (((dig & 1) == 1) || biasUp))) {\n+//        roundoff:\n+//            while(*--s == '9')\n+//                if (s == buf) {\n+//                    k++;\n+//                    *s++ = '1';\n+//                    goto ret;\n+//                }\n+//            ++*s++;\n+            if (roundOff(buf)) {\n+                k++;\n+                buf.append('1');\n+                return k + 1;\n+            }\n+        }\n+        else {\n+            stripTrailingZeroes(buf);\n+//            while(*--s == '0') ;\n+//            s++;\n+        }\n+//      ret:\n+//        Bfree(S);\n+//        if (mhi) {\n+//            if (mlo && mlo != mhi)\n+//                Bfree(mlo);\n+//            Bfree(mhi);\n+//        }\n+//      ret1:\n+//        Bfree(b);\n+//        JS_ASSERT(s < buf + bufsize);\n+        return k + 1;\n+    }\n+\n+    private static void \n+    stripTrailingZeroes(StringBuffer buf)\n+    {\n+//      while(*--s == '0') ;\n+//      s++;\n+        int bl = buf.length();\n+        while(bl-->0 && buf.charAt(bl) == '0') {\n+          // empty\n+        }\n+        buf.setLength(bl + 1);\n+    }\n+\n+    /* Mapping of JSDToStrMode -> JS_dtoa mode */\n+    private static final int dtoaModes[] = {\n+        0,   /* DTOSTR_STANDARD */\n+        0,   /* DTOSTR_STANDARD_EXPONENTIAL, */\n+        3,   /* DTOSTR_FIXED, */\n+        2,   /* DTOSTR_EXPONENTIAL, */\n+        2};  /* DTOSTR_PRECISION */\n+\n+    static void\n+    JS_dtostr(StringBuffer buffer, int mode, int precision, double d)\n+    {\n+        int decPt;                                    /* Position of decimal point relative to first digit returned by JS_dtoa */\n+        boolean[] sign = new boolean[1];            /* true if the sign bit was set in d */\n+        int nDigits;                                /* Number of significand digits returned by JS_dtoa */\n+\n+//        JS_ASSERT(bufferSize >= (size_t)(mode <= DTOSTR_STANDARD_EXPONENTIAL ? DTOSTR_STANDARD_BUFFER_SIZE :\n+//                DTOSTR_VARIABLE_BUFFER_SIZE(precision)));\n+\n+        if (mode == DTOSTR_FIXED && (d >= 1e21 || d <= -1e21))\n+            mode = DTOSTR_STANDARD; /* Change mode here rather than below because the buffer may not be large enough to hold a large integer. */\n+\n+        decPt = JS_dtoa(d, dtoaModes[mode], mode >= DTOSTR_FIXED, precision, sign, buffer);\n+        nDigits = buffer.length();\n+\n+        /* If Infinity, -Infinity, or NaN, return the string regardless of the mode. */\n+        if (decPt != 9999) {\n+            boolean exponentialNotation = false;\n+            int minNDigits = 0;         /* Minimum number of significand digits required by mode and precision */\n+            int p;\n+\n+            switch (mode) {\n+                case DTOSTR_STANDARD:\n+                    if (decPt < -5 || decPt > 21)\n+                        exponentialNotation = true;\n+                    else\n+                        minNDigits = decPt;\n+                    break;\n+\n+                case DTOSTR_FIXED:\n+                    if (precision >= 0)\n+                        minNDigits = decPt + precision;\n+                    else\n+                        minNDigits = decPt;\n+                    break;\n+\n+                case DTOSTR_EXPONENTIAL:\n+//                    JS_ASSERT(precision > 0);\n+                    minNDigits = precision;\n+                    /* Fall through */\n+                case DTOSTR_STANDARD_EXPONENTIAL:\n+                    exponentialNotation = true;\n+                    break;\n+\n+                case DTOSTR_PRECISION:\n+//                    JS_ASSERT(precision > 0);\n+                    minNDigits = precision;\n+                    if (decPt < -5 || decPt > precision)\n+                        exponentialNotation = true;\n+                    break;\n+            }\n+\n+            /* If the number has fewer than minNDigits, pad it with zeros at the end */\n+            if (nDigits < minNDigits) {\n+                p = minNDigits;\n+                nDigits = minNDigits;\n+                do {\n+                    buffer.append('0');\n+                } while (buffer.length() != p);\n+            }\n+\n+            if (exponentialNotation) {\n+                /* Insert a decimal point if more than one significand digit */\n+                if (nDigits != 1) {\n+                    buffer.insert(1, '.');\n+                }\n+                buffer.append('e');\n+                if ((decPt - 1) >= 0)\n+                    buffer.append('+');\n+                buffer.append(decPt - 1);\n+//                JS_snprintf(numEnd, bufferSize - (numEnd - buffer), \"e%+d\", decPt-1);\n+            } else if (decPt != nDigits) {\n+                /* Some kind of a fraction in fixed notation */\n+//                JS_ASSERT(decPt <= nDigits);\n+                if (decPt > 0) {\n+                    /* dd...dd . dd...dd */\n+                    buffer.insert(decPt, '.');\n+                } else {\n+                    /* 0 . 00...00dd...dd */\n+                    for (int i = 0; i < 1 - decPt; i++)\n+                        buffer.insert(0, '0');\n+                    buffer.insert(1, '.');\n+                }\n+            }\n+        }\n+\n+        /* If negative and neither -0.0 nor NaN, output a leading '-'. */\n+        if (sign[0] &&\n+                !(word0(d) == Sign_bit && word1(d) == 0) &&\n+                !((word0(d) & Exp_mask) == Exp_mask &&\n+                  ((word1(d) != 0) || ((word0(d) & Frac_mask) != 0)))) {\n+            buffer.insert(0, '-');\n+        }\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Decompiler.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Mike Ang\n+ *   Igor Bukanov\n+ *   Bob Jervis\n+ *   Mike McCabe\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.javascript.ast.FunctionNode;\n+\n+/**\n+ * The following class save decompilation information about the source.\n+ * Source information is returned from the parser as a String\n+ * associated with function nodes and with the toplevel script.  When\n+ * saved in the constant pool of a class, this string will be UTF-8\n+ * encoded, and token values will occupy a single byte.\n+\n+ * Source is saved (mostly) as token numbers.  The tokens saved pretty\n+ * much correspond to the token stream of a 'canonical' representation\n+ * of the input program, as directed by the parser.  (There were a few\n+ * cases where tokens could have been left out where decompiler could\n+ * easily reconstruct them, but I left them in for clarity).  (I also\n+ * looked adding source collection to TokenStream instead, where I\n+ * could have limited the changes to a few lines in getToken... but\n+ * this wouldn't have saved any space in the resulting source\n+ * representation, and would have meant that I'd have to duplicate\n+ * parser logic in the decompiler to disambiguate situations where\n+ * newlines are important.)  The function decompile expands the\n+ * tokens back into their string representations, using simple\n+ * lookahead to correct spacing and indentation.\n+ *\n+ * Assignments are saved as two-token pairs (Token.ASSIGN, op). Number tokens\n+ * are stored inline, as a NUMBER token, a character representing the type, and\n+ * either 1 or 4 characters representing the bit-encoding of the number.  String\n+ * types NAME, STRING and OBJECT are currently stored as a token type,\n+ * followed by a character giving the length of the string (assumed to\n+ * be less than 2^16), followed by the characters of the string\n+ * inlined into the source string.  Changing this to some reference to\n+ * to the string in the compiled class' constant pool would probably\n+ * save a lot of space... but would require some method of deriving\n+ * the final constant pool entry from information available at parse\n+ * time.\n+ */\n+public class Decompiler\n+{\n+    /**\n+     * Flag to indicate that the decompilation should omit the\n+     * function header and trailing brace.\n+     */\n+    public static final int ONLY_BODY_FLAG = 1 << 0;\n+\n+    /**\n+     * Flag to indicate that the decompilation generates toSource result.\n+     */\n+    public static final int TO_SOURCE_FLAG = 1 << 1;\n+\n+    /**\n+     * Decompilation property to specify initial ident value.\n+     */\n+    public static final int INITIAL_INDENT_PROP = 1;\n+\n+    /**\n+     * Decompilation property to specify default identation offset.\n+     */\n+    public static final int INDENT_GAP_PROP = 2;\n+\n+    /**\n+     * Decompilation property to specify identation offset for case labels.\n+     */\n+    public static final int CASE_GAP_PROP = 3;\n+\n+    // Marker to denote the last RC of function so it can be distinguished from\n+    // the last RC of object literals in case of function expressions\n+    private static final int FUNCTION_END = Token.LAST_TOKEN + 1;\n+\n+    String getEncodedSource()\n+    {\n+        return sourceToString(0);\n+    }\n+\n+    int getCurrentOffset()\n+    {\n+        return sourceTop;\n+    }\n+\n+    int markFunctionStart(int functionType)\n+    {\n+        int savedOffset = getCurrentOffset();\n+        addToken(Token.FUNCTION);\n+        append((char)functionType);\n+        return savedOffset;\n+    }\n+\n+    int markFunctionEnd(int functionStart)\n+    {\n+        int offset = getCurrentOffset();\n+        append((char)FUNCTION_END);\n+        return offset;\n+    }\n+\n+    void addToken(int token)\n+    {\n+        if (!(0 <= token && token <= Token.LAST_TOKEN))\n+            throw new IllegalArgumentException();\n+\n+        append((char)token);\n+    }\n+\n+    void addEOL(int token)\n+    {\n+        if (!(0 <= token && token <= Token.LAST_TOKEN))\n+            throw new IllegalArgumentException();\n+\n+        append((char)token);\n+        append((char)Token.EOL);\n+    }\n+\n+    void addName(String str)\n+    {\n+        addToken(Token.NAME);\n+        appendString(str);\n+    }\n+\n+    void addString(String str)\n+    {\n+        addToken(Token.STRING);\n+        appendString(str);\n+    }\n+\n+    void addRegexp(String regexp, String flags)\n+    {\n+        addToken(Token.REGEXP);\n+        appendString('/' + regexp + '/' + flags);\n+    }\n+\n+    void addNumber(double n)\n+    {\n+        addToken(Token.NUMBER);\n+\n+        /* encode the number in the source stream.\n+         * Save as NUMBER type (char | char char char char)\n+         * where type is\n+         * 'D' - double, 'S' - short, 'J' - long.\n+\n+         * We need to retain float vs. integer type info to keep the\n+         * behavior of liveconnect type-guessing the same after\n+         * decompilation.  (Liveconnect tries to present 1.0 to Java\n+         * as a float/double)\n+         * OPT: This is no longer true. We could compress the format.\n+\n+         * This may not be the most space-efficient encoding;\n+         * the chars created below may take up to 3 bytes in\n+         * constant pool UTF-8 encoding, so a Double could take\n+         * up to 12 bytes.\n+         */\n+\n+        long lbits = (long)n;\n+        if (lbits != n) {\n+            // if it's floating point, save as a Double bit pattern.\n+            // (12/15/97 our scanner only returns Double for f.p.)\n+            lbits = Double.doubleToLongBits(n);\n+            append('D');\n+            append((char)(lbits >> 48));\n+            append((char)(lbits >> 32));\n+            append((char)(lbits >> 16));\n+            append((char)lbits);\n+        }\n+        else {\n+            // we can ignore negative values, bc they're already prefixed\n+            // by NEG\n+               if (lbits < 0) Kit.codeBug();\n+\n+            // will it fit in a char?\n+            // this gives a short encoding for integer values up to 2^16.\n+            if (lbits <= Character.MAX_VALUE) {\n+                append('S');\n+                append((char)lbits);\n+            }\n+            else { // Integral, but won't fit in a char. Store as a long.\n+                append('J');\n+                append((char)(lbits >> 48));\n+                append((char)(lbits >> 32));\n+                append((char)(lbits >> 16));\n+                append((char)lbits);\n+            }\n+        }\n+    }\n+\n+    private void appendString(String str)\n+    {\n+        int L = str.length();\n+        int lengthEncodingSize = 1;\n+        if (L >= 0x8000) {\n+            lengthEncodingSize = 2;\n+        }\n+        int nextTop = sourceTop + lengthEncodingSize + L;\n+        if (nextTop > sourceBuffer.length) {\n+            increaseSourceCapacity(nextTop);\n+        }\n+        if (L >= 0x8000) {\n+            // Use 2 chars to encode strings exceeding 32K, were the highest\n+            // bit in the first char indicates presence of the next byte\n+            sourceBuffer[sourceTop] = (char)(0x8000 | (L >>> 16));\n+            ++sourceTop;\n+        }\n+        sourceBuffer[sourceTop] = (char)L;\n+        ++sourceTop;\n+        str.getChars(0, L, sourceBuffer, sourceTop);\n+        sourceTop = nextTop;\n+    }\n+\n+    private void append(char c)\n+    {\n+        if (sourceTop == sourceBuffer.length) {\n+            increaseSourceCapacity(sourceTop + 1);\n+        }\n+        sourceBuffer[sourceTop] = c;\n+        ++sourceTop;\n+    }\n+\n+    private void increaseSourceCapacity(int minimalCapacity)\n+    {\n+        // Call this only when capacity increase is must\n+        if (minimalCapacity <= sourceBuffer.length) Kit.codeBug();\n+        int newCapacity = sourceBuffer.length * 2;\n+        if (newCapacity < minimalCapacity) {\n+            newCapacity = minimalCapacity;\n+        }\n+        char[] tmp = new char[newCapacity];\n+        System.arraycopy(sourceBuffer, 0, tmp, 0, sourceTop);\n+        sourceBuffer = tmp;\n+    }\n+\n+    private String sourceToString(int offset)\n+    {\n+        if (offset < 0 || sourceTop < offset) Kit.codeBug();\n+        return new String(sourceBuffer, offset, sourceTop - offset);\n+    }\n+\n+    /**\n+     * Decompile the source information associated with this js\n+     * function/script back into a string.  For the most part, this\n+     * just means translating tokens back to their string\n+     * representations; there's a little bit of lookahead logic to\n+     * decide the proper spacing/indentation.  Most of the work in\n+     * mapping the original source to the prettyprinted decompiled\n+     * version is done by the parser.\n+     *\n+     * @param source encoded source tree presentation\n+     *\n+     * @param flags flags to select output format\n+     *\n+     * @param properties indentation properties\n+     *\n+     */\n+    public static String decompile(String source, int flags,\n+                                   UintMap properties)\n+    {\n+        int length = source.length();\n+        if (length == 0) { return \"\"; }\n+\n+        int indent = properties.getInt(INITIAL_INDENT_PROP, 0);\n+        if (indent < 0) throw new IllegalArgumentException();\n+        int indentGap = properties.getInt(INDENT_GAP_PROP, 4);\n+        if (indentGap < 0) throw new IllegalArgumentException();\n+        int caseGap = properties.getInt(CASE_GAP_PROP, 2);\n+        if (caseGap < 0) throw new IllegalArgumentException();\n+\n+        StringBuffer result = new StringBuffer();\n+        boolean justFunctionBody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));\n+        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));\n+\n+        // Spew tokens in source, for debugging.\n+        // as TYPE number char\n+        if (printSource) {\n+            System.err.println(\"length:\" + length);\n+            for (int i = 0; i < length; ++i) {\n+                // Note that tokenToName will fail unless Context.printTrees\n+                // is true.\n+                String tokenname = null;\n+                if (Token.printNames) {\n+                    tokenname = Token.name(source.charAt(i));\n+                }\n+                if (tokenname == null) {\n+                    tokenname = \"---\";\n+                }\n+                String pad = tokenname.length() > 7\n+                    ? \"\\t\"\n+                    : \"\\t\\t\";\n+                System.err.println\n+                    (tokenname\n+                     + pad + (int)source.charAt(i)\n+                     + \"\\t'\" + ScriptRuntime.escapeString\n+                     (source.substring(i, i+1))\n+                     + \"'\");\n+            }\n+            System.err.println();\n+        }\n+\n+        int braceNesting = 0;\n+        boolean afterFirstEOL = false;\n+        int i = 0;\n+        int topFunctionType;\n+        if (source.charAt(i) == Token.SCRIPT) {\n+            ++i;\n+            topFunctionType = -1;\n+        } else {\n+            topFunctionType = source.charAt(i + 1);\n+        }\n+\n+        if (!toSource) {\n+            // add an initial newline to exactly match js.\n+            result.append('\\n');\n+            for (int j = 0; j < indent; j++)\n+                result.append(' ');\n+        } else {\n+            if (topFunctionType == FunctionNode.FUNCTION_EXPRESSION) {\n+                result.append('(');\n+            }\n+        }\n+\n+        while (i < length) {\n+            switch(source.charAt(i)) {\n+            case Token.GET:\n+            case Token.SET:\n+                result.append(source.charAt(i) == Token.GET ? \"get \" : \"set \");\n+                ++i;\n+                i = printSourceString(source, i + 1, false, result);\n+                // Now increment one more to get past the FUNCTION token\n+                ++i;\n+                break;\n+\n+            case Token.NAME:\n+            case Token.REGEXP:  // re-wrapped in '/'s in parser...\n+                i = printSourceString(source, i + 1, false, result);\n+                continue;\n+\n+            case Token.STRING:\n+                i = printSourceString(source, i + 1, true, result);\n+                continue;\n+\n+            case Token.NUMBER:\n+                i = printSourceNumber(source, i + 1, result);\n+                continue;\n+\n+            case Token.TRUE:\n+                result.append(\"true\");\n+                break;\n+\n+            case Token.FALSE:\n+                result.append(\"false\");\n+                break;\n+\n+            case Token.NULL:\n+                result.append(\"null\");\n+                break;\n+\n+            case Token.THIS:\n+                result.append(\"this\");\n+                break;\n+\n+            case Token.FUNCTION:\n+                ++i; // skip function type\n+                result.append(\"function \");\n+                break;\n+\n+            case FUNCTION_END:\n+                // Do nothing\n+                break;\n+\n+            case Token.COMMA:\n+                result.append(\", \");\n+                break;\n+\n+            case Token.LC:\n+                ++braceNesting;\n+                if (Token.EOL == getNext(source, length, i))\n+                    indent += indentGap;\n+                result.append('{');\n+                break;\n+\n+            case Token.RC: {\n+                --braceNesting;\n+                /* don't print the closing RC if it closes the\n+                 * toplevel function and we're called from\n+                 * decompileFunctionBody.\n+                 */\n+                if (justFunctionBody && braceNesting == 0)\n+                    break;\n+\n+                result.append('}');\n+                switch (getNext(source, length, i)) {\n+                    case Token.EOL:\n+                    case FUNCTION_END:\n+                        indent -= indentGap;\n+                        break;\n+                    case Token.WHILE:\n+                    case Token.ELSE:\n+                        indent -= indentGap;\n+                        result.append(' ');\n+                        break;\n+                }\n+                break;\n+            }\n+            case Token.LP:\n+                result.append('(');\n+                break;\n+\n+            case Token.RP:\n+                result.append(')');\n+                if (Token.LC == getNext(source, length, i))\n+                    result.append(' ');\n+                break;\n+\n+            case Token.LB:\n+                result.append('[');\n+                break;\n+\n+            case Token.RB:\n+                result.append(']');\n+                break;\n+\n+            case Token.EOL: {\n+                if (toSource) break;\n+                boolean newLine = true;\n+                if (!afterFirstEOL) {\n+                    afterFirstEOL = true;\n+                    if (justFunctionBody) {\n+                        /* throw away just added 'function name(...) {'\n+                         * and restore the original indent\n+                         */\n+                        result.setLength(0);\n+                        indent -= indentGap;\n+                        newLine = false;\n+                    }\n+                }\n+                if (newLine) {\n+                    result.append('\\n');\n+                }\n+\n+                /* add indent if any tokens remain,\n+                 * less setback if next token is\n+                 * a label, case or default.\n+                 */\n+                if (i + 1 < length) {\n+                    int less = 0;\n+                    int nextToken = source.charAt(i + 1);\n+                    if (nextToken == Token.CASE\n+                        || nextToken == Token.DEFAULT)\n+                    {\n+                        less = indentGap - caseGap;\n+                    } else if (nextToken == Token.RC) {\n+                        less = indentGap;\n+                    }\n+\n+                    /* elaborate check against label... skip past a\n+                     * following inlined NAME and look for a COLON.\n+                     */\n+                    else if (nextToken == Token.NAME) {\n+                        int afterName = getSourceStringEnd(source, i + 2);\n+                        if (source.charAt(afterName) == Token.COLON)\n+                            less = indentGap;\n+                    }\n+\n+                    for (; less < indent; less++)\n+                        result.append(' ');\n+                }\n+                break;\n+            }\n+            case Token.DOT:\n+                result.append('.');\n+                break;\n+\n+            case Token.NEW:\n+                result.append(\"new \");\n+                break;\n+\n+            case Token.DELPROP:\n+                result.append(\"delete \");\n+                break;\n+\n+            case Token.IF:\n+                result.append(\"if \");\n+                break;\n+\n+            case Token.ELSE:\n+                result.append(\"else \");\n+                break;\n+\n+            case Token.FOR:\n+                result.append(\"for \");\n+                break;\n+\n+            case Token.IN:\n+                result.append(\" in \");\n+                break;\n+\n+            case Token.WITH:\n+                result.append(\"with \");\n+                break;\n+\n+            case Token.WHILE:\n+                result.append(\"while \");\n+                break;\n+\n+            case Token.DO:\n+                result.append(\"do \");\n+                break;\n+\n+            case Token.TRY:\n+                result.append(\"try \");\n+                break;\n+\n+            case Token.CATCH:\n+                result.append(\"catch \");\n+                break;\n+\n+            case Token.FINALLY:\n+                result.append(\"finally \");\n+                break;\n+\n+            case Token.THROW:\n+                result.append(\"throw \");\n+                break;\n+\n+            case Token.SWITCH:\n+                result.append(\"switch \");\n+                break;\n+\n+            case Token.BREAK:\n+                result.append(\"break\");\n+                if (Token.NAME == getNext(source, length, i))\n+                    result.append(' ');\n+                break;\n+\n+            case Token.CONTINUE:\n+                result.append(\"continue\");\n+                if (Token.NAME == getNext(source, length, i))\n+                    result.append(' ');\n+                break;\n+\n+            case Token.CASE:\n+                result.append(\"case \");\n+                break;\n+\n+            case Token.DEFAULT:\n+                result.append(\"default\");\n+                break;\n+\n+            case Token.RETURN:\n+                result.append(\"return\");\n+                if (Token.SEMI != getNext(source, length, i))\n+                    result.append(' ');\n+                break;\n+\n+            case Token.VAR:\n+                result.append(\"var \");\n+                break;\n+\n+            case Token.LET:\n+              result.append(\"let \");\n+              break;\n+\n+            case Token.SEMI:\n+                result.append(';');\n+                if (Token.EOL != getNext(source, length, i)) {\n+                    // separators in FOR\n+                    result.append(' ');\n+                }\n+                break;\n+\n+            case Token.ASSIGN:\n+                result.append(\" = \");\n+                break;\n+\n+            case Token.ASSIGN_ADD:\n+                result.append(\" += \");\n+                break;\n+\n+            case Token.ASSIGN_SUB:\n+                result.append(\" -= \");\n+                break;\n+\n+            case Token.ASSIGN_MUL:\n+                result.append(\" *= \");\n+                break;\n+\n+            case Token.ASSIGN_DIV:\n+                result.append(\" /= \");\n+                break;\n+\n+            case Token.ASSIGN_MOD:\n+                result.append(\" %= \");\n+                break;\n+\n+            case Token.ASSIGN_BITOR:\n+                result.append(\" |= \");\n+                break;\n+\n+            case Token.ASSIGN_BITXOR:\n+                result.append(\" ^= \");\n+                break;\n+\n+            case Token.ASSIGN_BITAND:\n+                result.append(\" &= \");\n+                break;\n+\n+            case Token.ASSIGN_LSH:\n+                result.append(\" <<= \");\n+                break;\n+\n+            case Token.ASSIGN_RSH:\n+                result.append(\" >>= \");\n+                break;\n+\n+            case Token.ASSIGN_URSH:\n+                result.append(\" >>>= \");\n+                break;\n+\n+            case Token.HOOK:\n+                result.append(\" ? \");\n+                break;\n+\n+            case Token.OBJECTLIT:\n+                // pun OBJECTLIT to mean colon in objlit property\n+                // initialization.\n+                // This needs to be distinct from COLON in the general case\n+                // to distinguish from the colon in a ternary... which needs\n+                // different spacing.\n+                result.append(':');\n+                break;\n+\n+            case Token.COLON:\n+                if (Token.EOL == getNext(source, length, i))\n+                    // it's the end of a label\n+                    result.append(':');\n+                else\n+                    // it's the middle part of a ternary\n+                    result.append(\" : \");\n+                break;\n+\n+            case Token.OR:\n+                result.append(\" || \");\n+                break;\n+\n+            case Token.AND:\n+                result.append(\" && \");\n+                break;\n+\n+            case Token.BITOR:\n+                result.append(\" | \");\n+                break;\n+\n+            case Token.BITXOR:\n+                result.append(\" ^ \");\n+                break;\n+\n+            case Token.BITAND:\n+                result.append(\" & \");\n+                break;\n+\n+            case Token.SHEQ:\n+                result.append(\" === \");\n+                break;\n+\n+            case Token.SHNE:\n+                result.append(\" !== \");\n+                break;\n+\n+            case Token.EQ:\n+                result.append(\" == \");\n+                break;\n+\n+            case Token.NE:\n+                result.append(\" != \");\n+                break;\n+\n+            case Token.LE:\n+                result.append(\" <= \");\n+                break;\n+\n+            case Token.LT:\n+                result.append(\" < \");\n+                break;\n+\n+            case Token.GE:\n+                result.append(\" >= \");\n+                break;\n+\n+            case Token.GT:\n+                result.append(\" > \");\n+                break;\n+\n+            case Token.INSTANCEOF:\n+                result.append(\" instanceof \");\n+                break;\n+\n+            case Token.LSH:\n+                result.append(\" << \");\n+                break;\n+\n+            case Token.RSH:\n+                result.append(\" >> \");\n+                break;\n+\n+            case Token.URSH:\n+                result.append(\" >>> \");\n+                break;\n+\n+            case Token.TYPEOF:\n+                result.append(\"typeof \");\n+                break;\n+\n+            case Token.VOID:\n+                result.append(\"void \");\n+                break;\n+\n+            case Token.CONST:\n+                result.append(\"const \");\n+                break;\n+                \n+            case Token.YIELD:\n+                result.append(\"yield \");\n+                break;\n+            \n+            case Token.NOT:\n+                result.append('!');\n+                break;\n+\n+            case Token.BITNOT:\n+                result.append('~');\n+                break;\n+\n+            case Token.POS:\n+                result.append('+');\n+                break;\n+\n+            case Token.NEG:\n+                result.append('-');\n+                break;\n+\n+            case Token.INC:\n+                result.append(\"++\");\n+                break;\n+\n+            case Token.DEC:\n+                result.append(\"--\");\n+                break;\n+\n+            case Token.ADD:\n+                result.append(\" + \");\n+                break;\n+\n+            case Token.SUB:\n+                result.append(\" - \");\n+                break;\n+\n+            case Token.MUL:\n+                result.append(\" * \");\n+                break;\n+\n+            case Token.DIV:\n+                result.append(\" / \");\n+                break;\n+\n+            case Token.MOD:\n+                result.append(\" % \");\n+                break;\n+\n+            case Token.COLONCOLON:\n+                result.append(\"::\");\n+                break;\n+\n+            case Token.DOTDOT:\n+                result.append(\"..\");\n+                break;\n+\n+            case Token.DOTQUERY:\n+                result.append(\".(\");\n+                break;\n+\n+            case Token.XMLATTR:\n+                result.append('@');\n+                break;\n+\n+            default:\n+                // If we don't know how to decompile it, raise an exception.\n+                throw new RuntimeException(\"Token: \" +\n+                                               Token.name(source.charAt(i)));\n+            }\n+            ++i;\n+        }\n+\n+        if (!toSource) {\n+            // add that trailing newline if it's an outermost function.\n+            if (!justFunctionBody)\n+                result.append('\\n');\n+        } else {\n+            if (topFunctionType == FunctionNode.FUNCTION_EXPRESSION) {\n+                result.append(')');\n+            }\n+        }\n+\n+        return result.toString();\n+    }\n+\n+    private static int getNext(String source, int length, int i)\n+    {\n+        return (i + 1 < length) ? source.charAt(i + 1) : Token.EOF;\n+    }\n+\n+    private static int getSourceStringEnd(String source, int offset)\n+    {\n+        return printSourceString(source, offset, false, null);\n+    }\n+\n+    private static int printSourceString(String source, int offset,\n+                                         boolean asQuotedString,\n+                                         StringBuffer sb)\n+    {\n+        int length = source.charAt(offset);\n+        ++offset;\n+        if ((0x8000 & length) != 0) {\n+            length = ((0x7FFF & length) << 16) | source.charAt(offset);\n+            ++offset;\n+        }\n+        if (sb != null) {\n+            String str = source.substring(offset, offset + length);\n+            if (!asQuotedString) {\n+                sb.append(str);\n+            } else {\n+                sb.append('\"');\n+                sb.append(ScriptRuntime.escapeString(str));\n+                sb.append('\"');\n+            }\n+        }\n+        return offset + length;\n+    }\n+\n+    private static int printSourceNumber(String source, int offset,\n+                                         StringBuffer sb)\n+    {\n+        double number = 0.0;\n+        char type = source.charAt(offset);\n+        ++offset;\n+        if (type == 'S') {\n+            if (sb != null) {\n+                int ival = source.charAt(offset);\n+                number = ival;\n+            }\n+            ++offset;\n+        } else if (type == 'J' || type == 'D') {\n+            if (sb != null) {\n+                long lbits;\n+                lbits = (long)source.charAt(offset) << 48;\n+                lbits |= (long)source.charAt(offset + 1) << 32;\n+                lbits |= (long)source.charAt(offset + 2) << 16;\n+                lbits |= source.charAt(offset + 3);\n+                if (type == 'J') {\n+                    number = lbits;\n+                } else {\n+                    number = Double.longBitsToDouble(lbits);\n+                }\n+            }\n+            offset += 4;\n+        } else {\n+            // Bad source\n+            throw new RuntimeException();\n+        }\n+        if (sb != null) {\n+            sb.append(ScriptRuntime.numberToString(number, 10));\n+        }\n+        return offset;\n+    }\n+\n+    private char[] sourceBuffer = new char[128];\n+\n+// Per script/function source buffer top: parent source does not include a\n+// nested functions source and uses function index as a reference instead.\n+    private int sourceTop;\n+\n+// whether to do a debug print of the source information, when decompiling.\n+    private static final boolean printSource = false;\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/DefaultErrorReporter.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This is the default error reporter for JavaScript.\n+ *\n+ */\n+class DefaultErrorReporter implements ErrorReporter\n+{\n+    static final DefaultErrorReporter instance = new DefaultErrorReporter();\n+\n+    private boolean forEval;\n+    private ErrorReporter chainedReporter;\n+\n+    private DefaultErrorReporter() { }\n+\n+    static ErrorReporter forEval(ErrorReporter reporter)\n+    {\n+        DefaultErrorReporter r = new DefaultErrorReporter();\n+        r.forEval = true;\n+        r.chainedReporter = reporter;\n+        return r;\n+    }\n+\n+    public void warning(String message, String sourceURI, int line,\n+                        String lineText, int lineOffset)\n+    {\n+        if (chainedReporter != null) {\n+            chainedReporter.warning(\n+                message, sourceURI, line, lineText, lineOffset);\n+        } else {\n+            // Do nothing\n+        }\n+    }\n+\n+    public void error(String message, String sourceURI, int line,\n+                      String lineText, int lineOffset)\n+    {\n+        if (forEval) {\n+            // Assume error message strings that start with \"TypeError: \"\n+            // should become TypeError exceptions. A bit of a hack, but we\n+            // don't want to change the ErrorReporter interface.\n+            String error = \"SyntaxError\";\n+            final String TYPE_ERROR_NAME = \"TypeError\";\n+            final String DELIMETER = \": \";\n+            final String prefix = TYPE_ERROR_NAME + DELIMETER;\n+            if (message.startsWith(prefix)) {\n+                error = TYPE_ERROR_NAME;\n+                message = message.substring(prefix.length());\n+            }\n+            throw ScriptRuntime.constructError(error, message, sourceURI,\n+                                               line, lineText, lineOffset);\n+        }\n+        if (chainedReporter != null) {\n+            chainedReporter.error(\n+                message, sourceURI, line, lineText, lineOffset);\n+        } else {\n+            throw runtimeError(\n+                message, sourceURI, line, lineText, lineOffset);\n+        }\n+    }\n+\n+    public EvaluatorException runtimeError(String message, String sourceURI,\n+                                           int line, String lineText,\n+                                           int lineOffset)\n+    {\n+        if (chainedReporter != null) {\n+            return chainedReporter.runtimeError(\n+                message, sourceURI, line, lineText, lineOffset);\n+        } else {\n+            return new EvaluatorException(\n+                message, sourceURI, line, lineText, lineOffset);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/DefiningClassLoader.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Roger Lawrence\n+ *   Patrick Beard\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Load generated classes.\n+ *\n+ */\n+public class DefiningClassLoader extends ClassLoader\n+    implements GeneratedClassLoader\n+{\n+    public DefiningClassLoader() {\n+        this.parentLoader = getClass().getClassLoader();\n+    }\n+\n+    public DefiningClassLoader(ClassLoader parentLoader) {\n+        this.parentLoader = parentLoader;\n+    }\n+\n+    public Class<?> defineClass(String name, byte[] data) {\n+        // Use our own protection domain for the generated classes.\n+        // TODO: we might want to use a separate protection domain for classes\n+        // compiled from scripts, based on where the script was loaded from.\n+        return super.defineClass(name, data, 0, data.length,\n+                SecurityUtilities.getProtectionDomain(getClass()));\n+    }\n+\n+    public void linkClass(Class<?> cl) {\n+        resolveClass(cl);\n+    }\n+\n+    @Override\n+    public Class<?> loadClass(String name, boolean resolve)\n+        throws ClassNotFoundException\n+    {\n+        Class<?> cl = findLoadedClass(name);\n+        if (cl == null) {\n+            if (parentLoader != null) {\n+                cl = parentLoader.loadClass(name);\n+            } else {\n+                cl = findSystemClass(name);\n+            }\n+        }\n+        if (resolve) {\n+            resolveClass(cl);\n+        }\n+        return cl;\n+    }\n+\n+    private final ClassLoader parentLoader;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Delegator.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Delegator.java, released\n+ * Sep 27, 2000.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Matthias Radestock. <matthias@sorted.org>.\n+ * Portions created by the Initial Developer are Copyright (C) 2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This is a helper class for implementing wrappers around Scriptable\n+ * objects. It implements the Function interface and delegates all\n+ * invocations to a delegee Scriptable object. The normal use of this\n+ * class involves creating a sub-class and overriding one or more of\n+ * the methods.\n+ *\n+ * A useful application is the implementation of interceptors,\n+ * pre/post conditions, debugging.\n+ *\n+ * @see Function\n+ * @see Scriptable\n+ */\n+\n+public class Delegator implements Function {\n+\n+    protected Scriptable obj = null;\n+\n+    /**\n+     * Create a Delegator prototype.\n+     *\n+     * This constructor should only be used for creating prototype\n+     * objects of Delegator.\n+     *\n+     * @see org.mozilla.javascript.Delegator#construct\n+     */\n+    public Delegator() {\n+    }\n+\n+    /**\n+     * Create a new Delegator that forwards requests to a delegee\n+     * Scriptable object.\n+     *\n+     * @param obj the delegee\n+     * @see org.mozilla.javascript.Scriptable\n+     */\n+    public Delegator(Scriptable obj) {\n+        this.obj = obj;\n+    }\n+\n+    /**\n+     * Crete new Delegator instance.\n+     * The default implementation calls this.getClass().newInstance().\n+     *\n+     * @see #construct(Context cx, Scriptable scope, Object[] args)\n+     */\n+    protected Delegator newInstance()\n+    {\n+        try {\n+            return this.getClass().newInstance();\n+        } catch (Exception ex) {\n+            throw Context.throwAsScriptRuntimeEx(ex);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve the delegee.\n+     *\n+     * @return the delegee\n+     */\n+    public Scriptable getDelegee() {\n+        return obj;\n+    }\n+    /**\n+     * Set the delegee.\n+     *\n+     * @param obj the delegee\n+     * @see org.mozilla.javascript.Scriptable\n+     */\n+    public void setDelegee(Scriptable obj) {\n+        this.obj = obj;\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#getClassName\n+     */\n+    public String getClassName() {\n+        return obj.getClassName();\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#get(String, Scriptable)\n+     */\n+    public Object get(String name, Scriptable start) {\n+        return obj.get(name,start);\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#get(int, Scriptable)\n+     */\n+    public Object get(int index, Scriptable start) {\n+        return obj.get(index,start);\n+        }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#has(String, Scriptable)\n+     */\n+    public boolean has(String name, Scriptable start) {\n+        return obj.has(name,start);\n+        }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#has(int, Scriptable)\n+     */\n+    public boolean has(int index, Scriptable start) {\n+        return obj.has(index,start);\n+        }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#put(String, Scriptable, Object)\n+     */\n+    public void put(String name, Scriptable start, Object value) {\n+        obj.put(name,start,value);\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#put(int, Scriptable, Object)\n+     */\n+    public void put(int index, Scriptable start, Object value) {\n+        obj.put(index,start,value);\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#delete(String)\n+     */\n+    public void delete(String name) {\n+        obj.delete(name);\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#delete(int)\n+     */\n+    public void delete(int index) {\n+        obj.delete(index);\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#getPrototype\n+     */\n+    public Scriptable getPrototype() {\n+        return obj.getPrototype();\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#setPrototype\n+     */\n+    public void setPrototype(Scriptable prototype) {\n+        obj.setPrototype(prototype);\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#getParentScope\n+     */\n+    public Scriptable getParentScope() {\n+        return obj.getParentScope();\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#setParentScope\n+     */\n+    public void setParentScope(Scriptable parent) {\n+        obj.setParentScope(parent);\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#getIds\n+     */\n+    public Object[] getIds() {\n+        return obj.getIds();\n+    }\n+    /**\n+     * Note that this method does not get forwarded to the delegee if\n+     * the <code>hint</code> parameter is null,\n+     * <code>ScriptRuntime.ScriptableClass</code> or\n+     * <code>ScriptRuntime.FunctionClass</code>. Instead the object\n+     * itself is returned.\n+     *\n+     * @param hint the type hint\n+     * @return the default value\n+     *\n+     * @see org.mozilla.javascript.Scriptable#getDefaultValue\n+     */\n+    public Object getDefaultValue(Class<?> hint) {\n+        return (hint == null ||\n+                hint == ScriptRuntime.ScriptableClass ||\n+                hint == ScriptRuntime.FunctionClass) ?\n+            this : obj.getDefaultValue(hint);\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Scriptable#hasInstance\n+     */\n+    public boolean hasInstance(Scriptable instance) {\n+        return obj.hasInstance(instance);\n+    }\n+    /**\n+     * @see org.mozilla.javascript.Function#call\n+     */\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        return ((Function)obj).call(cx,scope,thisObj,args);\n+    }\n+\n+    /**\n+     * Note that if the <code>delegee</code> is <code>null</code>,\n+     * this method creates a new instance of the Delegator itself\n+     * rathert than forwarding the call to the\n+     * <code>delegee</code>. This permits the use of Delegator\n+     * prototypes.\n+     *\n+     * @param cx the current Context for this thread\n+     * @param scope an enclosing scope of the caller except\n+     *              when the function is called from a closure.\n+     * @param args the array of arguments\n+     * @return the allocated object\n+     *\n+     * @see Function#construct(Context, Scriptable, Object[])\n+     */\n+    public Scriptable construct(Context cx, Scriptable scope, Object[] args)\n+    {\n+        if (obj == null) {\n+            //this little trick allows us to declare prototype objects for\n+            //Delegators\n+            Delegator n = newInstance();\n+            Scriptable delegee;\n+            if (args.length == 0) {\n+                delegee = new NativeObject();\n+            } else {\n+                delegee = ScriptRuntime.toObject(cx, scope, args[0]);\n+            }\n+            n.setDelegee(delegee);\n+            return n;\n+        }\n+        else {\n+            return ((Function)obj).construct(cx,scope,args);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/EcmaError.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * The class of exceptions raised by the engine as described in\n+ * ECMA edition 3. See section 15.11.6 in particular.\n+ */\n+public class EcmaError extends RhinoException\n+{\n+    static final long serialVersionUID = -6261226256957286699L;\n+\n+    private String errorName;\n+    private String errorMessage;\n+\n+    /**\n+     * Create an exception with the specified detail message.\n+     *\n+     * Errors internal to the JavaScript engine will simply throw a\n+     * RuntimeException.\n+     *\n+     * @param sourceName the name of the source responsible for the error\n+     * @param lineNumber the line number of the source\n+     * @param columnNumber the columnNumber of the source (may be zero if\n+     *                     unknown)\n+     * @param lineSource the source of the line containing the error (may be\n+     *                   null if unknown)\n+     */\n+    EcmaError(String errorName, String errorMessage,\n+              String sourceName, int lineNumber,\n+              String lineSource, int columnNumber)\n+    {\n+        recordErrorOrigin(sourceName, lineNumber, lineSource, columnNumber);\n+        this.errorName = errorName;\n+        this.errorMessage = errorMessage;\n+    }\n+\n+    /**\n+     * @deprecated EcmaError error instances should not be constructed\n+     *             explicitly since they are generated by the engine.\n+     */\n+    public EcmaError(Scriptable nativeError, String sourceName,\n+                     int lineNumber, int columnNumber, String lineSource)\n+    {\n+        this(\"InternalError\", ScriptRuntime.toString(nativeError),\n+             sourceName, lineNumber, lineSource, columnNumber);\n+    }\n+\n+    @Override\n+    public String details()\n+    {\n+        return errorName+\": \"+errorMessage;\n+    }\n+\n+    /**\n+     * Gets the name of the error.\n+     *\n+     * ECMA edition 3 defines the following\n+     * errors: EvalError, RangeError, ReferenceError,\n+     * SyntaxError, TypeError, and URIError. Additional error names\n+     * may be added in the future.\n+     *\n+     * See ECMA edition 3, 15.11.7.9.\n+     *\n+     * @return the name of the error.\n+     */\n+    public String getName()\n+    {\n+        return errorName;\n+    }\n+\n+    /**\n+     * Gets the message corresponding to the error.\n+     *\n+     * See ECMA edition 3, 15.11.7.10.\n+     *\n+     * @return an implementation-defined string describing the error.\n+     */\n+    public String getErrorMessage()\n+    {\n+        return errorMessage;\n+    }\n+\n+    /**\n+     * @deprecated Use {@link RhinoException#sourceName()} from the super class.\n+     */\n+    public String getSourceName()\n+    {\n+        return sourceName();\n+    }\n+\n+    /**\n+     * @deprecated Use {@link RhinoException#lineNumber()} from the super class.\n+     */\n+    public int getLineNumber()\n+    {\n+        return lineNumber();\n+    }\n+\n+    /**\n+     * @deprecated\n+     * Use {@link RhinoException#columnNumber()} from the super class.\n+     */\n+    public int getColumnNumber() {\n+        return columnNumber();\n+    }\n+\n+    /**\n+     * @deprecated Use {@link RhinoException#lineSource()} from the super class.\n+     */\n+    public String getLineSource() {\n+        return lineSource();\n+    }\n+\n+    /**\n+     * @deprecated\n+     * Always returns <b>null</b>.\n+     */\n+    public Scriptable getErrorObject()\n+    {\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ErrorReporter.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This is interface defines a protocol for the reporting of\n+ * errors during JavaScript translation or execution.\n+ *\n+ */\n+\n+public interface ErrorReporter {\n+\n+    /**\n+     * Report a warning.\n+     *\n+     * The implementing class may choose to ignore the warning\n+     * if it desires.\n+     *\n+     * @param message a String describing the warning\n+     * @param sourceName a String describing the JavaScript source\n+     * where the warning occured; typically a filename or URL\n+     * @param line the line number associated with the warning\n+     * @param lineSource the text of the line (may be null)\n+     * @param lineOffset the offset into lineSource where problem was detected\n+     */\n+    void warning(String message, String sourceName, int line,\n+                 String lineSource, int lineOffset);\n+\n+    /**\n+     * Report an error.\n+     *\n+     * The implementing class is free to throw an exception if\n+     * it desires.\n+     *\n+     * If execution has not yet begun, the JavaScript engine is\n+     * free to find additional errors rather than terminating\n+     * the translation. It will not execute a script that had\n+     * errors, however.\n+     *\n+     * @param message a String describing the error\n+     * @param sourceName a String describing the JavaScript source\n+     * where the error occured; typically a filename or URL\n+     * @param line the line number associated with the error\n+     * @param lineSource the text of the line (may be null)\n+     * @param lineOffset the offset into lineSource where problem was detected\n+     */\n+    void error(String message, String sourceName, int line,\n+               String lineSource, int lineOffset);\n+\n+    /**\n+     * Creates an EvaluatorException that may be thrown.\n+     *\n+     * runtimeErrors, unlike errors, will always terminate the\n+     * current script.\n+     *\n+     * @param message a String describing the error\n+     * @param sourceName a String describing the JavaScript source\n+     * where the error occured; typically a filename or URL\n+     * @param line the line number associated with the error\n+     * @param lineSource the text of the line (may be null)\n+     * @param lineOffset the offset into lineSource where problem was detected\n+     * @return an EvaluatorException that will be thrown.\n+     */\n+    EvaluatorException runtimeError(String message, String sourceName,\n+                                    int line, String lineSource,\n+                                    int lineOffset);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Evaluator.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.javascript.ast.ScriptNode;\n+\n+import java.util.List;\n+\n+/**\n+ * Abstraction of evaluation, which can be implemented either by an\n+ * interpreter or compiler.\n+ */\n+public interface Evaluator {\n+\n+    /**\n+     * Compile the script or function from intermediate representation\n+     * tree into an executable form.\n+     *\n+     * @param compilerEnv Compiler environment\n+     * @param tree parse tree\n+     * @param encodedSource encoding of the source code for decompilation\n+     * @param returnFunction if true, compiling a function\n+     * @return an opaque object that can be passed to either\n+     *         createFunctionObject or createScriptObject, depending on the\n+     *         value of returnFunction\n+     */\n+    public Object compile(CompilerEnvirons compilerEnv,\n+                          ScriptNode tree,\n+                          String encodedSource,\n+                          boolean returnFunction);\n+\n+    /**\n+     * Create a function object.\n+     *\n+     * @param cx Current context\n+     * @param scope scope of the function\n+     * @param bytecode opaque object returned by compile\n+     * @param staticSecurityDomain security domain\n+     * @return Function object that can be called\n+     */\n+    public Function createFunctionObject(Context cx, Scriptable scope,\n+            Object bytecode, Object staticSecurityDomain);\n+\n+    /**\n+     * Create a script object.\n+     *\n+     * @param bytecode opaque object returned by compile\n+     * @param staticSecurityDomain security domain\n+     * @return Script object that can be evaluated\n+     */\n+    public Script createScriptObject(Object bytecode,\n+                                     Object staticSecurityDomain);\n+\n+    /**\n+     * Capture stack information from the given exception.\n+     * @param ex an exception thrown during execution\n+     */\n+    public void captureStackInfo(RhinoException ex);\n+\n+    /**\n+     * Get the source position information by examining the stack.\n+     * @param cx Context\n+     * @param linep Array object of length >= 1; getSourcePositionFromStack\n+     *              will assign the line number to linep[0].\n+     * @return the name of the file or other source container\n+     */\n+    public String getSourcePositionFromStack(Context cx, int[] linep);\n+\n+    /**\n+     * Given a native stack trace, patch it with script-specific source\n+     * and line information\n+     * @param ex exception\n+     * @param nativeStackTrace the native stack trace\n+     * @return patched stack trace\n+     */\n+    public String getPatchedStack(RhinoException ex,\n+                                  String nativeStackTrace);\n+\n+    /**\n+     * Get the script stack for the given exception\n+     * @param ex exception from execution\n+     * @return list of strings for the stack trace\n+     */\n+    public List<String> getScriptStack(RhinoException ex);\n+\n+    /**\n+     * Mark the given script to indicate it was created by a call to\n+     * eval() or to a Function constructor.\n+     * @param script script to mark as from eval\n+     */\n+    public void setEvalScriptFlag(Script script);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/EvaluatorException.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * The class of exceptions thrown by the JavaScript engine.\n+ */\n+public class EvaluatorException extends RhinoException\n+{\n+    static final long serialVersionUID = -8743165779676009808L;\n+\n+    public EvaluatorException(String detail)\n+    {\n+        super(detail);\n+    }\n+\n+    /**\n+     * Create an exception with the specified detail message.\n+     *\n+     * Errors internal to the JavaScript engine will simply throw a\n+     * RuntimeException.\n+     *\n+     * @param detail the error message\n+     * @param sourceName the name of the source reponsible for the error\n+     * @param lineNumber the line number of the source\n+     */\n+    public EvaluatorException(String detail, String sourceName,\n+                              int lineNumber)\n+    {\n+        this(detail, sourceName, lineNumber, null, 0);\n+    }\n+\n+    /**\n+     * Create an exception with the specified detail message.\n+     *\n+     * Errors internal to the JavaScript engine will simply throw a\n+     * RuntimeException.\n+     *\n+     * @param detail the error message\n+     * @param sourceName the name of the source responsible for the error\n+     * @param lineNumber the line number of the source\n+     * @param columnNumber the columnNumber of the source (may be zero if\n+     *                     unknown)\n+     * @param lineSource the source of the line containing the error (may be\n+     *                   null if unknown)\n+     */\n+    public EvaluatorException(String detail, String sourceName, int lineNumber,\n+                              String lineSource, int columnNumber)\n+    {\n+        super(detail);\n+        recordErrorOrigin(sourceName, lineNumber, lineSource, columnNumber);\n+    }\n+\n+    /**\n+     * @deprecated Use {@link RhinoException#sourceName()} from the super class.\n+     */\n+    public String getSourceName()\n+    {\n+        return sourceName();\n+    }\n+\n+    /**\n+     * @deprecated Use {@link RhinoException#lineNumber()} from the super class.\n+     */\n+    public int getLineNumber()\n+    {\n+        return lineNumber();\n+    }\n+\n+    /**\n+     * @deprecated Use {@link RhinoException#columnNumber()} from the super class.\n+     */\n+    public int getColumnNumber()\n+    {\n+        return columnNumber();\n+    }\n+\n+    /**\n+     * @deprecated Use {@link RhinoException#lineSource()} from the super class.\n+     */\n+    public String getLineSource()\n+    {\n+        return lineSource();\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/FieldAndMethods.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Cameron McCormack\n+ *   Frank Mitchell\n+ *   Mike Shaver\n+ *   Kurt Westerfeld\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+/**\n+ *\n+ * @see JavaMembers\n+ */\n+class FieldAndMethods extends NativeJavaMethod\n+{\n+    static final long serialVersionUID = -9222428244284796755L;\n+\n+    FieldAndMethods(Scriptable scope, MemberBox[] methods, Field field)\n+    {\n+        super(methods);\n+        this.field = field;\n+        setParentScope(scope);\n+        setPrototype(ScriptableObject.getFunctionPrototype(scope));\n+    }\n+\n+    @Override\n+    public Object getDefaultValue(Class<?> hint)\n+    {\n+        if (hint == ScriptRuntime.FunctionClass)\n+            return this;\n+        Object rval;\n+        Class<?> type;\n+        try {\n+            rval = field.get(javaObject);\n+            type = field.getType();\n+        } catch (IllegalAccessException accEx) {\n+            throw Context.reportRuntimeError1(\n+                \"msg.java.internal.private\", field.getName());\n+        }\n+        Context cx  = Context.getContext();\n+        rval = cx.getWrapFactory().wrap(cx, this, rval, type);\n+        if (rval instanceof Scriptable) {\n+            rval = ((Scriptable) rval).getDefaultValue(hint);\n+        }\n+        return rval;\n+    }\n+\n+    Field field;\n+    Object javaObject;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Function.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This is interface that all functions in JavaScript must implement.\n+ * The interface provides for calling functions and constructors.\n+ *\n+ * @see org.mozilla.javascript.Scriptable\n+ */\n+\n+public interface Function extends Scriptable, Callable\n+{\n+    /**\n+     * Call the function.\n+     *\n+     * Note that the array of arguments is not guaranteed to have\n+     * length greater than 0.\n+     *\n+     * @param cx the current Context for this thread\n+     * @param scope the scope to execute the function relative to. This is\n+     *              set to the value returned by getParentScope() except\n+     *              when the function is called from a closure.\n+     * @param thisObj the JavaScript <code>this</code> object\n+     * @param args the array of arguments\n+     * @return the result of the call\n+     */\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args);\n+\n+    /**\n+     * Call the function as a constructor.\n+     *\n+     * This method is invoked by the runtime in order to satisfy a use\n+     * of the JavaScript <code>new</code> operator.  This method is\n+     * expected to create a new object and return it.\n+     *\n+     * @param cx the current Context for this thread\n+     * @param scope an enclosing scope of the caller except\n+     *              when the function is called from a closure.\n+     * @param args the array of arguments\n+     * @return the allocated object\n+     */\n+    public Scriptable construct(Context cx, Scriptable scope, Object[] args);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/FunctionObject.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   David C. Navas\n+ *   Ted Neward\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.reflect.*;\n+import java.io.*;\n+\n+public class FunctionObject extends BaseFunction\n+{\n+    static final long serialVersionUID = -5332312783643935019L;\n+\n+    /**\n+     * Create a JavaScript function object from a Java method.\n+     *\n+     * <p>The <code>member</code> argument must be either a java.lang.reflect.Method\n+     * or a java.lang.reflect.Constructor and must match one of two forms.<p>\n+     *\n+     * The first form is a member with zero or more parameters\n+     * of the following types: Object, String, boolean, Scriptable,\n+     * int, or double. The Long type is not supported\n+     * because the double representation of a long (which is the\n+     * EMCA-mandated storage type for Numbers) may lose precision.\n+     * If the member is a Method, the return value must be void or one\n+     * of the types allowed for parameters.<p>\n+     *\n+     * The runtime will perform appropriate conversions based\n+     * upon the type of the parameter. A parameter type of\n+     * Object specifies that no conversions are to be done. A parameter\n+     * of type String will use Context.toString to convert arguments.\n+     * Similarly, parameters of type double, boolean, and Scriptable\n+     * will cause Context.toNumber, Context.toBoolean, and\n+     * Context.toObject, respectively, to be called.<p>\n+     *\n+     * If the method is not static, the Java 'this' value will\n+     * correspond to the JavaScript 'this' value. Any attempt\n+     * to call the function with a 'this' value that is not\n+     * of the right Java type will result in an error.<p>\n+     *\n+     * The second form is the variable arguments (or \"varargs\")\n+     * form. If the FunctionObject will be used as a constructor,\n+     * the member must have the following parameters\n+     * <pre>\n+     *      (Context cx, Object[] args, Function ctorObj,\n+     *       boolean inNewExpr)</pre>\n+     * and if it is a Method, be static and return an Object result.<p>\n+     *\n+     * Otherwise, if the FunctionObject will <i>not</i> be used to define a\n+     * constructor, the member must be a static Method with parameters\n+     * <pre>\n+     *      (Context cx, Scriptable thisObj, Object[] args,\n+     *       Function funObj) </pre>\n+     * and an Object result.<p>\n+     *\n+     * When the function varargs form is called as part of a function call,\n+     * the <code>args</code> parameter contains the\n+     * arguments, with <code>thisObj</code>\n+     * set to the JavaScript 'this' value. <code>funObj</code>\n+     * is the function object for the invoked function.<p>\n+     *\n+     * When the constructor varargs form is called or invoked while evaluating\n+     * a <code>new</code> expression, <code>args</code> contains the\n+     * arguments, <code>ctorObj</code> refers to this FunctionObject, and\n+     * <code>inNewExpr</code> is true if and only if  a <code>new</code>\n+     * expression caused the call. This supports defining a function that\n+     * has different behavior when called as a constructor than when\n+     * invoked as a normal function call. (For example, the Boolean\n+     * constructor, when called as a function,\n+     * will convert to boolean rather than creating a new object.)<p>\n+     *\n+     * @param name the name of the function\n+     * @param methodOrConstructor a java.lang.reflect.Method or a java.lang.reflect.Constructor\n+     *                            that defines the object\n+     * @param scope enclosing scope of function\n+     * @see org.mozilla.javascript.Scriptable\n+     */\n+    public FunctionObject(String name, Member methodOrConstructor,\n+                          Scriptable scope)\n+    {\n+        if (methodOrConstructor instanceof Constructor) {\n+            member = new MemberBox((Constructor<?>) methodOrConstructor);\n+            isStatic = true; // well, doesn't take a 'this'\n+        } else {\n+            member = new MemberBox((Method) methodOrConstructor);\n+            isStatic = member.isStatic();\n+        }\n+        String methodName = member.getName();\n+        this.functionName = name;\n+        Class<?>[] types = member.argTypes;\n+        int arity = types.length;\n+        if (arity == 4 && (types[1].isArray() || types[2].isArray())) {\n+            // Either variable args or an error.\n+            if (types[1].isArray()) {\n+                if (!isStatic ||\n+                    types[0] != ScriptRuntime.ContextClass ||\n+                    types[1].getComponentType() != ScriptRuntime.ObjectClass ||\n+                    types[2] != ScriptRuntime.FunctionClass ||\n+                    types[3] != Boolean.TYPE)\n+                {\n+                    throw Context.reportRuntimeError1(\n+                        \"msg.varargs.ctor\", methodName);\n+                }\n+                parmsLength = VARARGS_CTOR;\n+            } else {\n+                if (!isStatic ||\n+                    types[0] != ScriptRuntime.ContextClass ||\n+                    types[1] != ScriptRuntime.ScriptableClass ||\n+                    types[2].getComponentType() != ScriptRuntime.ObjectClass ||\n+                    types[3] != ScriptRuntime.FunctionClass)\n+                {\n+                    throw Context.reportRuntimeError1(\n+                        \"msg.varargs.fun\", methodName);\n+                }\n+                parmsLength = VARARGS_METHOD;\n+            }\n+        } else {\n+            parmsLength = arity;\n+            if (arity > 0) {\n+                typeTags = new byte[arity];\n+                for (int i = 0; i != arity; ++i) {\n+                    int tag = getTypeTag(types[i]);\n+                    if (tag == JAVA_UNSUPPORTED_TYPE) {\n+                        throw Context.reportRuntimeError2(\n+                            \"msg.bad.parms\", types[i].getName(), methodName);\n+                    }\n+                    typeTags[i] = (byte)tag;\n+                }\n+            }\n+        }\n+\n+        if (member.isMethod()) {\n+            Method method = member.method();\n+            Class<?> returnType = method.getReturnType();\n+            if (returnType == Void.TYPE) {\n+                hasVoidReturn = true;\n+            } else {\n+                returnTypeTag = getTypeTag(returnType);\n+            }\n+        } else {\n+            Class<?> ctorType = member.getDeclaringClass();\n+            if (!ScriptRuntime.ScriptableClass.isAssignableFrom(ctorType)) {\n+                throw Context.reportRuntimeError1(\n+                    \"msg.bad.ctor.return\", ctorType.getName());\n+            }\n+        }\n+\n+        ScriptRuntime.setFunctionProtoAndParent(this, scope);\n+    }\n+\n+    /**\n+     * @return One of <tt>JAVA_*_TYPE</tt> constants to indicate desired type\n+     *         or {@link #JAVA_UNSUPPORTED_TYPE} if the convertion is not\n+     *         possible\n+     */\n+    public static int getTypeTag(Class<?> type)\n+    {\n+        if (type == ScriptRuntime.StringClass)\n+            return JAVA_STRING_TYPE;\n+        if (type == ScriptRuntime.IntegerClass || type == Integer.TYPE)\n+            return JAVA_INT_TYPE;\n+        if (type == ScriptRuntime.BooleanClass || type == Boolean.TYPE)\n+            return JAVA_BOOLEAN_TYPE;\n+        if (type == ScriptRuntime.DoubleClass || type == Double.TYPE)\n+            return JAVA_DOUBLE_TYPE;\n+        if (ScriptRuntime.ScriptableClass.isAssignableFrom(type))\n+            return JAVA_SCRIPTABLE_TYPE;\n+        if (type == ScriptRuntime.ObjectClass)\n+            return JAVA_OBJECT_TYPE;\n+\n+        // Note that the long type is not supported; see the javadoc for\n+        // the constructor for this class\n+\n+        return JAVA_UNSUPPORTED_TYPE;\n+    }\n+\n+    public static Object convertArg(Context cx, Scriptable scope,\n+                                    Object arg, int typeTag)\n+    {\n+        switch (typeTag) {\n+          case JAVA_STRING_TYPE:\n+              if (arg instanceof String)\n+                return arg;\n+            return ScriptRuntime.toString(arg);\n+          case JAVA_INT_TYPE:\n+              if (arg instanceof Integer)\n+                return arg;\n+            return Integer.valueOf(ScriptRuntime.toInt32(arg));\n+          case JAVA_BOOLEAN_TYPE:\n+              if (arg instanceof Boolean)\n+                return arg;\n+            return ScriptRuntime.toBoolean(arg) ? Boolean.TRUE\n+                                                : Boolean.FALSE;\n+          case JAVA_DOUBLE_TYPE:\n+            if (arg instanceof Double)\n+                return arg;\n+            return new Double(ScriptRuntime.toNumber(arg));\n+          case JAVA_SCRIPTABLE_TYPE:\n+              return ScriptRuntime.toObjectOrNull(cx, arg, scope);\n+          case JAVA_OBJECT_TYPE:\n+            return arg;\n+          default:\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    /**\n+     * Return the value defined by  the method used to construct the object\n+     * (number of parameters of the method, or 1 if the method is a \"varargs\"\n+     * form).\n+     */\n+    @Override\n+    public int getArity() {\n+        return parmsLength < 0 ? 1 : parmsLength;\n+    }\n+\n+    /**\n+     * Return the same value as {@link #getArity()}.\n+     */\n+    @Override\n+    public int getLength() {\n+        return getArity();\n+    }\n+\n+    @Override\n+    public String getFunctionName()\n+    {\n+        return (functionName == null) ? \"\" : functionName;\n+    }\n+\n+    /**\n+     * Get Java method or constructor this function represent.\n+     */\n+    public Member getMethodOrConstructor()\n+    {\n+        if (member.isMethod()) {\n+            return member.method();\n+        } else {\n+            return member.ctor();\n+        }\n+    }\n+\n+    static Method findSingleMethod(Method[] methods, String name)\n+    {\n+        Method found = null;\n+        for (int i = 0, N = methods.length; i != N; ++i) {\n+            Method method = methods[i];\n+            if (method != null && name.equals(method.getName())) {\n+                if (found != null) {\n+                    throw Context.reportRuntimeError2(\n+                        \"msg.no.overload\", name,\n+                        method.getDeclaringClass().getName());\n+                }\n+                found = method;\n+            }\n+        }\n+        return found;\n+    }\n+\n+    /**\n+     * Returns all public methods declared by the specified class. This excludes\n+     * inherited methods.\n+     *\n+     * @param clazz the class from which to pull public declared methods\n+     * @return the public methods declared in the specified class\n+     * @see Class#getDeclaredMethods()\n+     */\n+    static Method[] getMethodList(Class<?> clazz) {\n+        Method[] methods = null;\n+        try {\n+            // getDeclaredMethods may be rejected by the security manager\n+            // but getMethods is more expensive\n+            if (!sawSecurityException)\n+                methods = clazz.getDeclaredMethods();\n+        } catch (SecurityException e) {\n+            // If we get an exception once, give up on getDeclaredMethods\n+            sawSecurityException = true;\n+        }\n+        if (methods == null) {\n+            methods = clazz.getMethods();\n+        }\n+        int count = 0;\n+        for (int i=0; i < methods.length; i++) {\n+            if (sawSecurityException\n+                ? methods[i].getDeclaringClass() != clazz\n+                : !Modifier.isPublic(methods[i].getModifiers()))\n+            {\n+                methods[i] = null;\n+            } else {\n+                count++;\n+            }\n+        }\n+        Method[] result = new Method[count];\n+        int j=0;\n+        for (int i=0; i < methods.length; i++) {\n+            if (methods[i] != null)\n+                result[j++] = methods[i];\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Define this function as a JavaScript constructor.\n+     * <p>\n+     * Sets up the \"prototype\" and \"constructor\" properties. Also\n+     * calls setParent and setPrototype with appropriate values.\n+     * Then adds the function object as a property of the given scope, using\n+     *      <code>prototype.getClassName()</code>\n+     * as the name of the property.\n+     *\n+     * @param scope the scope in which to define the constructor (typically\n+     *              the global object)\n+     * @param prototype the prototype object\n+     * @see org.mozilla.javascript.Scriptable#setParentScope\n+     * @see org.mozilla.javascript.Scriptable#setPrototype\n+     * @see org.mozilla.javascript.Scriptable#getClassName\n+     */\n+    public void addAsConstructor(Scriptable scope, Scriptable prototype)\n+    {\n+        initAsConstructor(scope, prototype);\n+        defineProperty(scope, prototype.getClassName(),\n+                       this, ScriptableObject.DONTENUM);\n+    }\n+\n+    void initAsConstructor(Scriptable scope, Scriptable prototype)\n+    {\n+        ScriptRuntime.setFunctionProtoAndParent(this, scope);\n+        setImmunePrototypeProperty(prototype);\n+\n+        prototype.setParentScope(this);\n+\n+        defineProperty(prototype, \"constructor\", this,\n+                       ScriptableObject.DONTENUM  |\n+                       ScriptableObject.PERMANENT |\n+                       ScriptableObject.READONLY);\n+        setParentScope(scope);\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #getTypeTag(Class)}\n+     * and {@link #convertArg(Context, Scriptable, Object, int)}\n+     * for type conversion.\n+     */\n+    public static Object convertArg(Context cx, Scriptable scope,\n+                                    Object arg, Class<?> desired)\n+    {\n+        int tag = getTypeTag(desired);\n+        if (tag == JAVA_UNSUPPORTED_TYPE) {\n+            throw Context.reportRuntimeError1\n+                (\"msg.cant.convert\", desired.getName());\n+        }\n+        return convertArg(cx, scope, arg, tag);\n+    }\n+\n+    /**\n+     * Performs conversions on argument types if needed and\n+     * invokes the underlying Java method or constructor.\n+     * <p>\n+     * Implements Function.call.\n+     *\n+     * @see org.mozilla.javascript.Function#call(\n+     *          Context, Scriptable, Scriptable, Object[])\n+     */\n+    @Override\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        Object result;\n+        boolean checkMethodResult = false;\n+\n+        if (parmsLength < 0) {\n+            if (parmsLength == VARARGS_METHOD) {\n+                Object[] invokeArgs = { cx, thisObj, args, this };\n+                result = member.invoke(null, invokeArgs);\n+                checkMethodResult = true;\n+            } else {\n+                boolean inNewExpr = (thisObj == null);\n+                Boolean b = inNewExpr ? Boolean.TRUE : Boolean.FALSE;\n+                Object[] invokeArgs = { cx, args, this, b };\n+                result = (member.isCtor())\n+                         ? member.newInstance(invokeArgs)\n+                         : member.invoke(null, invokeArgs);\n+            }\n+\n+        } else {\n+            if (!isStatic) {\n+                Class<?> clazz = member.getDeclaringClass();\n+                if (!clazz.isInstance(thisObj)) {\n+                    boolean compatible = false;\n+                    if (thisObj == scope) {\n+                        Scriptable parentScope = getParentScope();\n+                        if (scope != parentScope) {\n+                            // Call with dynamic scope for standalone function,\n+                            // use parentScope as thisObj\n+                            compatible = clazz.isInstance(parentScope);\n+                            if (compatible) {\n+                                thisObj = parentScope;\n+                            }\n+                        }\n+                    }\n+                    if (!compatible) {\n+                        // Couldn't find an object to call this on.\n+                        throw ScriptRuntime.typeError1(\"msg.incompat.call\",\n+                                                       functionName);\n+                    }\n+                }\n+            }\n+\n+            Object[] invokeArgs;\n+            if (parmsLength == args.length) {\n+                // Do not allocate new argument array if java arguments are\n+                // the same as the original js ones.\n+                invokeArgs = args;\n+                for (int i = 0; i != parmsLength; ++i) {\n+                    Object arg = args[i];\n+                    Object converted = convertArg(cx, scope, arg, typeTags[i]);\n+                    if (arg != converted) {\n+                        if (invokeArgs == args) {\n+                            invokeArgs = args.clone();\n+                        }\n+                        invokeArgs[i] = converted;\n+                    }\n+                }\n+            } else if (parmsLength == 0) {\n+                invokeArgs = ScriptRuntime.emptyArgs;\n+            } else {\n+                invokeArgs = new Object[parmsLength];\n+                for (int i = 0; i != parmsLength; ++i) {\n+                    Object arg = (i < args.length)\n+                                 ? args[i]\n+                                 : Undefined.instance;\n+                    invokeArgs[i] = convertArg(cx, scope, arg, typeTags[i]);\n+                }\n+            }\n+\n+            if (member.isMethod()) {\n+                result = member.invoke(thisObj, invokeArgs);\n+                checkMethodResult = true;\n+            } else {\n+                result = member.newInstance(invokeArgs);\n+            }\n+\n+        }\n+\n+        if (checkMethodResult) {\n+            if (hasVoidReturn) {\n+                result = Undefined.instance;\n+            } else if (returnTypeTag == JAVA_UNSUPPORTED_TYPE) {\n+                result = cx.getWrapFactory().wrap(cx, scope, result, null);\n+            }\n+            // XXX: the code assumes that if returnTypeTag == JAVA_OBJECT_TYPE\n+            // then the Java method did a proper job of converting the\n+            // result to JS primitive or Scriptable to avoid\n+            // potentially costly Context.javaToJS call.\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Return new {@link Scriptable} instance using the default\n+     * constructor for the class of the underlying Java method.\n+     * Return null to indicate that the call method should be used to create\n+     * new objects.\n+     */\n+    @Override\n+    public Scriptable createObject(Context cx, Scriptable scope) {\n+        if (member.isCtor() || parmsLength == VARARGS_CTOR) {\n+            return null;\n+        }\n+        Scriptable result;\n+        try {\n+            result = (Scriptable) member.getDeclaringClass().newInstance();\n+        } catch (Exception ex) {\n+            throw Context.throwAsScriptRuntimeEx(ex);\n+        }\n+\n+        result.setPrototype(getClassPrototype());\n+        result.setParentScope(getParentScope());\n+        return result;\n+    }\n+\n+    boolean isVarArgsMethod() {\n+        return parmsLength == VARARGS_METHOD;\n+    }\n+\n+    boolean isVarArgsConstructor() {\n+        return parmsLength == VARARGS_CTOR;\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException\n+    {\n+        in.defaultReadObject();\n+        if (parmsLength > 0) {\n+            Class<?>[] types = member.argTypes;\n+            typeTags = new byte[parmsLength];\n+            for (int i = 0; i != parmsLength; ++i) {\n+                typeTags[i] = (byte)getTypeTag(types[i]);\n+            }\n+        }\n+        if (member.isMethod()) {\n+            Method method = member.method();\n+            Class<?> returnType = method.getReturnType();\n+            if (returnType == Void.TYPE) {\n+                hasVoidReturn = true;\n+            } else {\n+                returnTypeTag = getTypeTag(returnType);\n+            }\n+        }\n+    }\n+\n+    private static final short VARARGS_METHOD = -1;\n+    private static final short VARARGS_CTOR =   -2;\n+\n+    private static boolean sawSecurityException;\n+\n+    public static final int JAVA_UNSUPPORTED_TYPE = 0;\n+    public static final int JAVA_STRING_TYPE      = 1;\n+    public static final int JAVA_INT_TYPE         = 2;\n+    public static final int JAVA_BOOLEAN_TYPE     = 3;\n+    public static final int JAVA_DOUBLE_TYPE      = 4;\n+    public static final int JAVA_SCRIPTABLE_TYPE  = 5;\n+    public static final int JAVA_OBJECT_TYPE      = 6;\n+\n+    MemberBox member;\n+    private String functionName;\n+    private transient byte[] typeTags;\n+    private int parmsLength;\n+    private transient boolean hasVoidReturn;\n+    private transient int returnTypeTag;\n+    private boolean isStatic;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/GeneratedClassLoader.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Interface to define classes from generated byte code.\n+ */\n+public interface GeneratedClassLoader {\n+\n+    /**\n+     * Define a new Java class.\n+     * Classes created via this method should have the same class loader.\n+     *\n+     * @param name fully qualified class name\n+     * @param data class byte code\n+     * @return new class object\n+     */\n+    public Class<?> defineClass(String name, byte[] data);\n+\n+    /**\n+     * Link the given class.\n+     *\n+     * @param cl Class instance returned from the previous call to\n+     *        {@link #defineClass(String, byte[])}\n+     * @see java.lang.ClassLoader\n+     */\n+    public void linkClass(Class<?> cl);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/IRFactory.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Ethan Hugg\n+ *   Bob Jervis\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.javascript.ast.*;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * This class rewrites the parse tree into an IR suitable for codegen.\n+ *\n+ * @see Node\n+ */\n+public final class IRFactory extends Parser\n+{\n+    private static final int LOOP_DO_WHILE = 0;\n+    private static final int LOOP_WHILE    = 1;\n+    private static final int LOOP_FOR      = 2;\n+\n+    private static final int ALWAYS_TRUE_BOOLEAN = 1;\n+    private static final int ALWAYS_FALSE_BOOLEAN = -1;\n+\n+    private Decompiler decompiler = new Decompiler();\n+\n+    public IRFactory() {\n+        super();\n+    }\n+\n+    public IRFactory(CompilerEnvirons env) {\n+        this(env, env.getErrorReporter());\n+    }\n+\n+    public IRFactory(CompilerEnvirons env, ErrorReporter errorReporter) {\n+        super(env, errorReporter);\n+    }\n+\n+    /**\n+     * Transforms the tree into a lower-level IR suitable for codegen.\n+     * Optionally generates the encoded source.\n+     */\n+    public ScriptNode transformTree(AstRoot root) {\n+        currentScriptOrFn = root;\n+        this.inUseStrictDirective = root.isInStrictMode();\n+        int sourceStartOffset = decompiler.getCurrentOffset();\n+\n+        if (Token.printTrees) {\n+            System.out.println(\"IRFactory.transformTree\");\n+            System.out.println(root.debugPrint());\n+        }\n+        ScriptNode script = (ScriptNode)transform(root);\n+\n+        int sourceEndOffset = decompiler.getCurrentOffset();\n+        script.setEncodedSourceBounds(sourceStartOffset,\n+                                      sourceEndOffset);\n+\n+        if (compilerEnv.isGeneratingSource()) {\n+            script.setEncodedSource(decompiler.getEncodedSource());\n+        }\n+\n+        decompiler = null;\n+        return script;\n+    }\n+\n+    // Might want to convert this to polymorphism - move transform*\n+    // functions into the AstNode subclasses.  OTOH that would make\n+    // IR transformation part of the public AST API - desirable?\n+    // Another possibility:  create AstTransformer interface and adapter.\n+    public Node transform(AstNode node) {\n+        switch (node.getType()) {\n+          case Token.ARRAYCOMP:\n+              return transformArrayComp((ArrayComprehension)node);\n+          case Token.ARRAYLIT:\n+              return transformArrayLiteral((ArrayLiteral)node);\n+          case Token.BLOCK:\n+              return transformBlock(node);\n+          case Token.BREAK:\n+              return transformBreak((BreakStatement)node);\n+          case Token.CALL:\n+              return transformFunctionCall((FunctionCall)node);\n+          case Token.CONTINUE:\n+              return transformContinue((ContinueStatement)node);\n+          case Token.DO:\n+              return transformDoLoop((DoLoop)node);\n+          case Token.EMPTY:\n+              return node;\n+          case Token.FOR:\n+              if (node instanceof ForInLoop) {\n+                  return transformForInLoop((ForInLoop)node);\n+              } else {\n+                  return transformForLoop((ForLoop)node);\n+              }\n+          case Token.FUNCTION:\n+              return transformFunction((FunctionNode)node);\n+          case Token.GETELEM:\n+              return transformElementGet((ElementGet)node);\n+          case Token.GETPROP:\n+              return transformPropertyGet((PropertyGet)node);\n+          case Token.HOOK:\n+              return transformCondExpr((ConditionalExpression)node);\n+          case Token.IF:\n+              return transformIf((IfStatement)node);\n+\n+          case Token.TRUE:\n+          case Token.FALSE:\n+          case Token.THIS:\n+          case Token.NULL:\n+          case Token.DEBUGGER:\n+              return transformLiteral(node);\n+\n+          case Token.NAME:\n+              return transformName((Name)node);\n+          case Token.NUMBER:\n+              return transformNumber((NumberLiteral)node);\n+          case Token.NEW:\n+              return transformNewExpr((NewExpression)node);\n+          case Token.OBJECTLIT:\n+              return transformObjectLiteral((ObjectLiteral)node);\n+          case Token.REGEXP:\n+              return transformRegExp((RegExpLiteral)node);\n+          case Token.RETURN:\n+              return transformReturn((ReturnStatement)node);\n+          case Token.SCRIPT:\n+              return transformScript((ScriptNode)node);\n+          case Token.STRING:\n+              return transformString((StringLiteral)node);\n+          case Token.SWITCH:\n+              return transformSwitch((SwitchStatement)node);\n+          case Token.THROW:\n+              return transformThrow((ThrowStatement)node);\n+          case Token.TRY:\n+              return transformTry((TryStatement)node);\n+          case Token.WHILE:\n+              return transformWhileLoop((WhileLoop)node);\n+          case Token.WITH:\n+              return transformWith((WithStatement)node);\n+          case Token.YIELD:\n+              return transformYield((Yield)node);\n+          default:\n+              if (node instanceof ExpressionStatement) {\n+                  return transformExprStmt((ExpressionStatement)node);\n+              }\n+              if (node instanceof Assignment) {\n+                  return transformAssignment((Assignment)node);\n+              }\n+              if (node instanceof UnaryExpression) {\n+                  return transformUnary((UnaryExpression)node);\n+              }\n+              if (node instanceof XmlMemberGet) {\n+                  return transformXmlMemberGet((XmlMemberGet)node);\n+              }\n+              if (node instanceof InfixExpression) {\n+                  return transformInfix((InfixExpression)node);\n+              }\n+              if (node instanceof VariableDeclaration) {\n+                  return transformVariables((VariableDeclaration)node);\n+              }\n+              if (node instanceof ParenthesizedExpression) {\n+                  return transformParenExpr((ParenthesizedExpression)node);\n+              }\n+              if (node instanceof LabeledStatement) {\n+                  return transformLabeledStatement((LabeledStatement)node);\n+              }\n+              if (node instanceof LetNode) {\n+                  return transformLetNode((LetNode)node);\n+              }\n+              if (node instanceof XmlRef) {\n+                  return transformXmlRef((XmlRef)node);\n+              }\n+              if (node instanceof XmlLiteral) {\n+                  return transformXmlLiteral((XmlLiteral)node);\n+              }\n+              throw new IllegalArgumentException(\"Can't transform: \" + node);\n+        }\n+    }\n+\n+    private Node transformArrayComp(ArrayComprehension node) {\n+        // An array comprehension expression such as\n+        //\n+        //   [expr for (x in foo) for each ([y, z] in bar) if (cond)]\n+        //\n+        // is rewritten approximately as\n+        //\n+        // new Scope(ARRAYCOMP) {\n+        //   new Node(BLOCK) {\n+        //     let tmp1 = new Array;\n+        //     for (let x in foo) {\n+        //       for each (let tmp2 in bar) {\n+        //         if (cond) {\n+        //           tmp1.push([y, z] = tmp2, expr);\n+        //         }\n+        //       }\n+        //     }\n+        //   }\n+        //   createName(tmp1)\n+        // }\n+\n+        int lineno = node.getLineno();\n+        Scope scopeNode = createScopeNode(Token.ARRAYCOMP, lineno);\n+        String arrayName = currentScriptOrFn.getNextTempName();\n+        pushScope(scopeNode);\n+        try {\n+            defineSymbol(Token.LET, arrayName, false);\n+            Node block = new Node(Token.BLOCK, lineno);\n+            Node newArray = createCallOrNew(Token.NEW, createName(\"Array\"));\n+            Node init = new Node(Token.EXPR_VOID,\n+                                 createAssignment(Token.ASSIGN,\n+                                                  createName(arrayName),\n+                                                  newArray),\n+                                 lineno);\n+            block.addChildToBack(init);\n+            block.addChildToBack(arrayCompTransformHelper(node, arrayName));\n+            scopeNode.addChildToBack(block);\n+            scopeNode.addChildToBack(createName(arrayName));\n+            return scopeNode;\n+        } finally {\n+            popScope();\n+        }\n+    }\n+\n+    private Node arrayCompTransformHelper(ArrayComprehension node,\n+                                          String arrayName) {\n+        decompiler.addToken(Token.LB);\n+        int lineno = node.getLineno();\n+        Node expr = transform(node.getResult());\n+\n+        List<ArrayComprehensionLoop> loops = node.getLoops();\n+        int numLoops = loops.size();\n+\n+        // Walk through loops, collecting and defining their iterator symbols.\n+        Node[] iterators = new Node[numLoops];\n+        Node[] iteratedObjs = new Node[numLoops];\n+\n+        for (int i = 0; i < numLoops; i++) {\n+            ArrayComprehensionLoop acl = loops.get(i);\n+            decompiler.addName(\" \");\n+            decompiler.addToken(Token.FOR);\n+            if (acl.isForEach()) {\n+                decompiler.addName(\"each \");\n+            }\n+            decompiler.addToken(Token.LP);\n+\n+            AstNode iter = acl.getIterator();\n+            String name = null;\n+            if (iter.getType() == Token.NAME) {\n+                name = iter.getString();\n+                decompiler.addName(name);\n+            } else {\n+                // destructuring assignment\n+                decompile(iter);\n+                name = currentScriptOrFn.getNextTempName();\n+                defineSymbol(Token.LP, name, false);\n+                expr = createBinary(Token.COMMA,\n+                                    createAssignment(Token.ASSIGN,\n+                                                     iter,\n+                                                     createName(name)),\n+                                    expr);\n+            }\n+            Node init = createName(name);\n+            // Define as a let since we want the scope of the variable to\n+            // be restricted to the array comprehension\n+            defineSymbol(Token.LET, name, false);\n+            iterators[i] = init;\n+\n+            decompiler.addToken(Token.IN);\n+            iteratedObjs[i] = transform(acl.getIteratedObject());\n+            decompiler.addToken(Token.RP);\n+        }\n+\n+        // generate code for tmpArray.push(body)\n+        Node call = createCallOrNew(Token.CALL,\n+                                    createPropertyGet(createName(arrayName),\n+                                                      null,\n+                                                      \"push\", 0));\n+\n+        Node body = new Node(Token.EXPR_VOID, call, lineno);\n+\n+        if (node.getFilter() != null) {\n+            decompiler.addName(\" \");\n+            decompiler.addToken(Token.IF);\n+            decompiler.addToken(Token.LP);\n+            body = createIf(transform(node.getFilter()), body, null, lineno);\n+            decompiler.addToken(Token.RP);\n+        }\n+\n+        // Now walk loops in reverse to build up the body statement.\n+        int pushed = 0;\n+        try {\n+            for (int i = numLoops-1; i >= 0; i--) {\n+                ArrayComprehensionLoop acl = loops.get(i);\n+                Scope loop = createLoopNode(null,  // no label\n+                                            acl.getLineno());\n+                pushScope(loop);\n+                pushed++;\n+                body = createForIn(Token.LET,\n+                                   loop,\n+                                   iterators[i],\n+                                   iteratedObjs[i],\n+                                   body,\n+                                   acl.isForEach());\n+            }\n+        } finally {\n+            for (int i = 0; i < pushed; i++) {\n+                popScope();\n+            }\n+        }\n+\n+        decompiler.addToken(Token.RB);\n+\n+        // Now that we've accumulated any destructuring forms,\n+        // add expr to the call node; it's pushed on each iteration.\n+        call.addChildToBack(expr);\n+        return body;\n+    }\n+\n+    private Node transformArrayLiteral(ArrayLiteral node) {\n+        if (node.isDestructuring()) {\n+            return node;\n+        }\n+        decompiler.addToken(Token.LB);\n+        List<AstNode> elems = node.getElements();\n+        Node array = new Node(Token.ARRAYLIT);\n+        List<Integer> skipIndexes = null;\n+        for (int i = 0; i < elems.size(); ++i) {\n+            AstNode elem = elems.get(i);\n+            if (elem.getType() != Token.EMPTY) {\n+                array.addChildToBack(transform(elem));\n+            } else {\n+                if (skipIndexes == null) {\n+                    skipIndexes = new ArrayList<Integer>();\n+                }\n+                skipIndexes.add(i);\n+            }\n+            if (i < elems.size() - 1)\n+                decompiler.addToken(Token.COMMA);\n+        }\n+        decompiler.addToken(Token.RB);\n+        array.putIntProp(Node.DESTRUCTURING_ARRAY_LENGTH,\n+                         node.getDestructuringLength());\n+        if (skipIndexes != null) {\n+            int[] skips = new int[skipIndexes.size()];\n+            for (int i = 0; i < skipIndexes.size(); i++)\n+                skips[i] = skipIndexes.get(i);\n+            array.putProp(Node.SKIP_INDEXES_PROP, skips);\n+        }\n+        return array;\n+    }\n+\n+    private Node transformAssignment(Assignment node) {\n+        AstNode left = removeParens(node.getLeft());\n+        Node target = null;\n+        if (isDestructuring(left)) {\n+            decompile(left);\n+            target = left;\n+        } else {\n+            target = transform(left);\n+        }\n+        decompiler.addToken(node.getType());\n+        return createAssignment(node.getType(),\n+                                target,\n+                                transform(node.getRight()));\n+    }\n+\n+    private Node transformBlock(AstNode node) {\n+        if (node instanceof Scope) {\n+            pushScope((Scope)node);\n+        }\n+        try {\n+            List<Node> kids = new ArrayList<Node>();\n+            for (Node kid : node) {\n+                kids.add(transform((AstNode)kid));\n+            }\n+            node.removeChildren();\n+            for (Node kid : kids) {\n+                node.addChildToBack(kid);\n+            }\n+            return node;\n+        } finally {\n+            if (node instanceof Scope) {\n+                popScope();\n+            }\n+        }\n+    }\n+\n+    private Node transformBreak(BreakStatement node) {\n+        decompiler.addToken(Token.BREAK);\n+        if (node.getBreakLabel() != null) {\n+            decompiler.addName(node.getBreakLabel().getIdentifier());\n+        }\n+        decompiler.addEOL(Token.SEMI);\n+        return node;\n+    }\n+\n+    private Node transformCondExpr(ConditionalExpression node) {\n+        Node test = transform(node.getTestExpression());\n+        decompiler.addToken(Token.HOOK);\n+        Node ifTrue = transform(node.getTrueExpression());\n+        decompiler.addToken(Token.COLON);\n+        Node ifFalse = transform(node.getFalseExpression());\n+        return createCondExpr(test, ifTrue, ifFalse);\n+    }\n+\n+    private Node transformContinue(ContinueStatement node) {\n+        decompiler.addToken(Token.CONTINUE);\n+        if (node.getLabel() != null) {\n+            decompiler.addName(node.getLabel().getIdentifier());\n+        }\n+        decompiler.addEOL(Token.SEMI);\n+        return node;\n+    }\n+\n+    private Node transformDoLoop(DoLoop loop) {\n+        loop.setType(Token.LOOP);\n+        pushScope(loop);\n+        try {\n+            decompiler.addToken(Token.DO);\n+            decompiler.addEOL(Token.LC);\n+            Node body = transform(loop.getBody());\n+            decompiler.addToken(Token.RC);\n+            decompiler.addToken(Token.WHILE);\n+            decompiler.addToken(Token.LP);\n+            Node cond = transform(loop.getCondition());\n+            decompiler.addToken(Token.RP);\n+            decompiler.addEOL(Token.SEMI);\n+            return createLoop(loop, LOOP_DO_WHILE,\n+                              body, cond, null, null);\n+        } finally {\n+            popScope();\n+        }\n+    }\n+\n+    private Node transformElementGet(ElementGet node) {\n+        // OPT: could optimize to createPropertyGet\n+        // iff elem is string that can not be number\n+        Node target = transform(node.getTarget());\n+        decompiler.addToken(Token.LB);\n+        Node element = transform(node.getElement());\n+        decompiler.addToken(Token.RB);\n+        return new Node(Token.GETELEM, target, element);\n+    }\n+\n+    private Node transformExprStmt(ExpressionStatement node) {\n+        Node expr = transform(node.getExpression());\n+        decompiler.addEOL(Token.SEMI);\n+        return new Node(node.getType(), expr, node.getLineno());\n+    }\n+\n+    private Node transformForInLoop(ForInLoop loop) {\n+        decompiler.addToken(Token.FOR);\n+        if (loop.isForEach())\n+            decompiler.addName(\"each \");\n+        decompiler.addToken(Token.LP);\n+\n+        loop.setType(Token.LOOP);\n+        pushScope(loop);\n+        try {\n+            int declType = -1;\n+            AstNode iter = loop.getIterator();\n+            if (iter instanceof VariableDeclaration) {\n+                declType = ((VariableDeclaration)iter).getType();\n+            }\n+            Node lhs = transform(iter);\n+            decompiler.addToken(Token.IN);\n+            Node obj = transform(loop.getIteratedObject());\n+            decompiler.addToken(Token.RP);\n+            decompiler.addEOL(Token.LC);\n+            Node body = transform(loop.getBody());\n+            decompiler.addEOL(Token.RC);\n+            return createForIn(declType, loop, lhs, obj, body,\n+                               loop.isForEach());\n+        } finally {\n+            popScope();\n+        }\n+    }\n+\n+    private Node transformForLoop(ForLoop loop) {\n+        decompiler.addToken(Token.FOR);\n+        decompiler.addToken(Token.LP);\n+        loop.setType(Token.LOOP);\n+        // XXX: Can't use pushScope/popScope here since 'createFor' may split\n+        // the scope\n+        Scope savedScope = currentScope;\n+        currentScope = loop;\n+        try {\n+            Node init = transform(loop.getInitializer());\n+            decompiler.addToken(Token.SEMI);\n+            Node test = transform(loop.getCondition());\n+            decompiler.addToken(Token.SEMI);\n+            Node incr = transform(loop.getIncrement());\n+            decompiler.addToken(Token.RP);\n+            decompiler.addEOL(Token.LC);\n+            Node body = transform(loop.getBody());\n+            decompiler.addEOL(Token.RC);\n+            return createFor(loop, init, test, incr, body);\n+        } finally {\n+            currentScope = savedScope;\n+        }\n+    }\n+\n+    private Node transformFunction(FunctionNode fn) {\n+        int functionType = fn.getFunctionType();\n+        int start = decompiler.markFunctionStart(functionType);\n+        Node mexpr = decompileFunctionHeader(fn);\n+        int index = currentScriptOrFn.addFunction(fn);\n+\n+        PerFunctionVariables savedVars = new PerFunctionVariables(fn);\n+        try {\n+            // If we start needing to record much more codegen metadata during\n+            // function parsing, we should lump it all into a helper class.\n+            Node destructuring = (Node)fn.getProp(Node.DESTRUCTURING_PARAMS);\n+            fn.removeProp(Node.DESTRUCTURING_PARAMS);\n+\n+            int lineno = fn.getBody().getLineno();\n+            ++nestingOfFunction;  // only for body, not params\n+            Node body = transform(fn.getBody());\n+\n+            if (!fn.isExpressionClosure()) {\n+                decompiler.addToken(Token.RC);\n+            }\n+            fn.setEncodedSourceBounds(start, decompiler.markFunctionEnd(start));\n+\n+            if (functionType != FunctionNode.FUNCTION_EXPRESSION && !fn.isExpressionClosure()) {\n+                // Add EOL only if function is not part of expression\n+                // since it gets SEMI + EOL from Statement in that case\n+                decompiler.addToken(Token.EOL);\n+            }\n+\n+            if (destructuring != null) {\n+                body.addChildToFront(new Node(Token.EXPR_VOID,\n+                                              destructuring, lineno));\n+            }\n+\n+            int syntheticType = fn.getFunctionType();\n+            Node pn = initFunction(fn, index, body, syntheticType);\n+            if (mexpr != null) {\n+                pn = createAssignment(Token.ASSIGN, mexpr, pn);\n+                if (syntheticType != FunctionNode.FUNCTION_EXPRESSION) {\n+                    pn = createExprStatementNoReturn(pn, fn.getLineno());\n+                }\n+            }\n+            return pn;\n+\n+        } finally {\n+            --nestingOfFunction;\n+            savedVars.restore();\n+        }\n+    }\n+\n+    private Node transformFunctionCall(FunctionCall node) {\n+        Node call = createCallOrNew(Token.CALL, transform(node.getTarget()));\n+        call.setLineno(node.getLineno());\n+        decompiler.addToken(Token.LP);\n+        List<AstNode> args = node.getArguments();\n+        for (int i = 0; i < args.size(); i++) {\n+            AstNode arg = args.get(i);\n+            call.addChildToBack(transform(arg));\n+            if (i < args.size() - 1) {\n+                decompiler.addToken(Token.COMMA);\n+            }\n+        }\n+        decompiler.addToken(Token.RP);\n+        return call;\n+    }\n+\n+    private Node transformIf(IfStatement n) {\n+        decompiler.addToken(Token.IF);\n+        decompiler.addToken(Token.LP);\n+        Node cond = transform(n.getCondition());\n+        decompiler.addToken(Token.RP);\n+        decompiler.addEOL(Token.LC);\n+        Node ifTrue = transform(n.getThenPart());\n+        Node ifFalse = null;\n+        if (n.getElsePart() != null) {\n+            decompiler.addToken(Token.RC);\n+            decompiler.addToken(Token.ELSE);\n+            decompiler.addEOL(Token.LC);\n+            ifFalse = transform(n.getElsePart());\n+        }\n+        decompiler.addEOL(Token.RC);\n+        return createIf(cond, ifTrue, ifFalse, n.getLineno());\n+    }\n+\n+    private Node transformInfix(InfixExpression node) {\n+        Node left = transform(node.getLeft());\n+        decompiler.addToken(node.getType());\n+        Node right = transform(node.getRight());\n+        if (node instanceof XmlDotQuery) {\n+            decompiler.addToken(Token.RP);\n+        }\n+        return createBinary(node.getType(), left, right);\n+    }\n+\n+    private Node transformLabeledStatement(LabeledStatement ls) {\n+        for (Label lb : ls.getLabels()) {\n+            decompiler.addName(lb.getName());\n+            decompiler.addEOL(Token.COLON);\n+        }\n+        Label label = ls.getFirstLabel();\n+        Node statement = transform(ls.getStatement());\n+\n+        // Make a target and put it _after_ the statement node.  Add in the\n+        // LABEL node, so breaks get the right target.\n+        Node breakTarget = Node.newTarget();\n+        Node block = new Node(Token.BLOCK, label, statement, breakTarget);\n+        label.target = breakTarget;\n+\n+        return block;\n+    }\n+\n+    private Node transformLetNode(LetNode node) {\n+        pushScope(node);\n+        try {\n+            decompiler.addToken(Token.LET);\n+            decompiler.addToken(Token.LP);\n+            Node vars = transformVariableInitializers(node.getVariables());\n+            decompiler.addToken(Token.RP);\n+            node.addChildToBack(vars);\n+            boolean letExpr = node.getType() == Token.LETEXPR;\n+            if (node.getBody() != null) {\n+                if (letExpr) {\n+                    decompiler.addName(\" \");\n+                } else {\n+                    decompiler.addEOL(Token.LC);\n+                }\n+                node.addChildToBack(transform(node.getBody()));\n+                if (!letExpr) {\n+                    decompiler.addEOL(Token.RC);\n+                }\n+            }\n+            return node;\n+        } finally {\n+            popScope();\n+        }\n+    }\n+\n+    private Node transformLiteral(AstNode node) {\n+        decompiler.addToken(node.getType());\n+        return node;\n+    }\n+\n+    private Node transformName(Name node) {\n+        decompiler.addName(node.getIdentifier());\n+        return node;\n+    }\n+\n+    private Node transformNewExpr(NewExpression node) {\n+        decompiler.addToken(Token.NEW);\n+        Node nx = createCallOrNew(Token.NEW, transform(node.getTarget()));\n+        nx.setLineno(node.getLineno());\n+        List<AstNode> args = node.getArguments();\n+        if (!args.isEmpty())\n+            decompiler.addToken(Token.LP);\n+        for (int i = 0; i < args.size(); i++) {\n+            AstNode arg = args.get(i);\n+            nx.addChildToBack(transform(arg));\n+            if (i < args.size() - 1) {\n+                decompiler.addToken(Token.COMMA);\n+            }\n+        }\n+        if (!args.isEmpty())\n+            decompiler.addToken(Token.RP);\n+        if (node.getInitializer() != null) {\n+            nx.addChildToBack(transformObjectLiteral(node.getInitializer()));\n+        }\n+        return nx;\n+    }\n+\n+    private Node transformNumber(NumberLiteral node) {\n+        decompiler.addNumber(node.getNumber());\n+        return node;\n+    }\n+\n+    private Node transformObjectLiteral(ObjectLiteral node) {\n+        if (node.isDestructuring()) {\n+            return node;\n+        }\n+        // createObjectLiteral rewrites its argument as object\n+        // creation plus object property entries, so later compiler\n+        // stages don't need to know about object literals.\n+        decompiler.addToken(Token.LC);\n+        List<ObjectProperty> elems = node.getElements();\n+        Node object = new Node(Token.OBJECTLIT);\n+        Object[] properties;\n+        if (elems.isEmpty()) {\n+            properties = ScriptRuntime.emptyArgs;\n+        } else {\n+            int size = elems.size(), i = 0;\n+            properties = new Object[size];\n+            for (ObjectProperty prop : elems) {\n+                if (prop.isGetter()) {\n+                    decompiler.addToken(Token.GET);\n+                } else if (prop.isSetter()) {\n+                    decompiler.addToken(Token.SET);\n+                }\n+\n+                properties[i++] = getPropKey(prop.getLeft());\n+\n+                // OBJECTLIT is used as ':' in object literal for\n+                // decompilation to solve spacing ambiguity.\n+                if (!(prop.isGetter() || prop.isSetter())) {\n+                    decompiler.addToken(Token.OBJECTLIT);\n+                }\n+\n+                Node right = transform(prop.getRight());\n+                if (prop.isGetter()) {\n+                    right = createUnary(Token.GET, right);\n+                } else if (prop.isSetter()) {\n+                    right = createUnary(Token.SET, right);\n+                }\n+                object.addChildToBack(right);\n+\n+                if (i < size) {\n+                    decompiler.addToken(Token.COMMA);\n+                }\n+            }\n+        }\n+        decompiler.addToken(Token.RC);\n+        object.putProp(Node.OBJECT_IDS_PROP, properties);\n+        return object;\n+    }\n+\n+    private Object getPropKey(Node id) {\n+        Object key;\n+        if (id instanceof Name) {\n+            String s = ((Name)id).getIdentifier();\n+            decompiler.addName(s);\n+            key = ScriptRuntime.getIndexObject(s);\n+        } else if (id instanceof StringLiteral) {\n+            String s = ((StringLiteral)id).getValue();\n+            decompiler.addString(s);\n+            key = ScriptRuntime.getIndexObject(s);\n+        } else if (id instanceof NumberLiteral) {\n+            double n = ((NumberLiteral)id).getNumber();\n+            decompiler.addNumber(n);\n+            key = ScriptRuntime.getIndexObject(n);\n+        } else {\n+            throw Kit.codeBug();\n+        }\n+        return key;\n+    }\n+\n+    private Node transformParenExpr(ParenthesizedExpression node) {\n+        AstNode expr = node.getExpression();\n+        decompiler.addToken(Token.LP);\n+        int count = 1;\n+        while (expr instanceof ParenthesizedExpression) {\n+            decompiler.addToken(Token.LP);\n+            count++;\n+            expr = ((ParenthesizedExpression)expr).getExpression();\n+        }\n+        Node result = transform(expr);\n+        for (int i = 0; i < count; i++) {\n+            decompiler.addToken(Token.RP);\n+        }\n+        result.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE);\n+        return result;\n+    }\n+\n+    private Node transformPropertyGet(PropertyGet node) {\n+        Node target = transform(node.getTarget());\n+        String name = node.getProperty().getIdentifier();\n+        decompiler.addToken(Token.DOT);\n+        decompiler.addName(name);\n+        return createPropertyGet(target, null, name, 0);\n+    }\n+\n+    private Node transformRegExp(RegExpLiteral node) {\n+        decompiler.addRegexp(node.getValue(), node.getFlags());\n+        currentScriptOrFn.addRegExp(node);\n+        return node;\n+    }\n+\n+    private Node transformReturn(ReturnStatement node) {\n+        if (Boolean.TRUE.equals(node.getProp(Node.EXPRESSION_CLOSURE_PROP))) {\n+            decompiler.addName(\" \");\n+        } else {\n+            decompiler.addToken(Token.RETURN);\n+        }\n+        AstNode rv = node.getReturnValue();\n+        Node value = rv == null ? null : transform(rv);\n+        decompiler.addEOL(Token.SEMI);\n+        return rv == null\n+            ? new Node(Token.RETURN, node.getLineno())\n+            : new Node(Token.RETURN, value, node.getLineno());\n+    }\n+\n+    private Node transformScript(ScriptNode node) {\n+        decompiler.addToken(Token.SCRIPT);\n+        if (currentScope != null) Kit.codeBug();\n+        currentScope = node;\n+        Node body = new Node(Token.BLOCK);\n+        for (Node kid : node) {\n+            body.addChildToBack(transform((AstNode)kid));\n+        }\n+        node.removeChildren();\n+        Node children = body.getFirstChild();\n+        if (children != null) {\n+            node.addChildrenToBack(children);\n+        }\n+        return node;\n+    }\n+\n+    private Node transformString(StringLiteral node) {\n+        decompiler.addString(node.getValue());\n+        return Node.newString(node.getValue());\n+    }\n+\n+    private Node transformSwitch(SwitchStatement node) {\n+        // The switch will be rewritten from:\n+        //\n+        // switch (expr) {\n+        //   case test1: statements1;\n+        //   ...\n+        //   default: statementsDefault;\n+        //   ...\n+        //   case testN: statementsN;\n+        // }\n+        //\n+        // to:\n+        //\n+        // {\n+        //     switch (expr) {\n+        //       case test1: goto label1;\n+        //       ...\n+        //       case testN: goto labelN;\n+        //     }\n+        //     goto labelDefault;\n+        //   label1:\n+        //     statements1;\n+        //   ...\n+        //   labelDefault:\n+        //     statementsDefault;\n+        //   ...\n+        //   labelN:\n+        //     statementsN;\n+        //   breakLabel:\n+        // }\n+        //\n+        // where inside switch each \"break;\" without label will be replaced\n+        // by \"goto breakLabel\".\n+        //\n+        // If the original switch does not have the default label, then\n+        // after the switch he transformed code would contain this goto:\n+        //     goto breakLabel;\n+        // instead of:\n+        //     goto labelDefault;\n+\n+        decompiler.addToken(Token.SWITCH);\n+        decompiler.addToken(Token.LP);\n+        Node switchExpr = transform(node.getExpression());\n+        decompiler.addToken(Token.RP);\n+        node.addChildToBack(switchExpr);\n+\n+        Node block = new Node(Token.BLOCK, node, node.getLineno());\n+        decompiler.addEOL(Token.LC);\n+\n+        for (SwitchCase sc : node.getCases()) {\n+            AstNode expr = sc.getExpression();\n+            Node caseExpr = null;\n+\n+            if (expr != null) {\n+                decompiler.addToken(Token.CASE);\n+                caseExpr = transform(expr);\n+            } else {\n+                decompiler.addToken(Token.DEFAULT);\n+            }\n+            decompiler.addEOL(Token.COLON);\n+\n+            List<AstNode> stmts = sc.getStatements();\n+            Node body = new Block();\n+            if (stmts != null) {\n+                for (AstNode kid : stmts) {\n+                    body.addChildToBack(transform(kid));\n+                }\n+            }\n+            addSwitchCase(block, caseExpr, body);\n+        }\n+        decompiler.addEOL(Token.RC);\n+        closeSwitch(block);\n+        return block;\n+    }\n+\n+    private Node transformThrow(ThrowStatement node) {\n+        decompiler.addToken(Token.THROW);\n+        Node value = transform(node.getExpression());\n+        decompiler.addEOL(Token.SEMI);\n+        return new Node(Token.THROW, value, node.getLineno());\n+    }\n+\n+    private Node transformTry(TryStatement node) {\n+        decompiler.addToken(Token.TRY);\n+        decompiler.addEOL(Token.LC);\n+        Node tryBlock = transform(node.getTryBlock());\n+        decompiler.addEOL(Token.RC);\n+\n+        Node catchBlocks = new Block();\n+        for (CatchClause cc : node.getCatchClauses()) {\n+            decompiler.addToken(Token.CATCH);\n+            decompiler.addToken(Token.LP);\n+\n+            String varName = cc.getVarName().getIdentifier();\n+            decompiler.addName(varName);\n+\n+            Node catchCond = null;\n+            AstNode ccc = cc.getCatchCondition();\n+            if (ccc != null) {\n+                decompiler.addName(\" \");\n+                decompiler.addToken(Token.IF);\n+                catchCond = transform(ccc);\n+            } else {\n+                catchCond = new EmptyExpression();\n+            }\n+            decompiler.addToken(Token.RP);\n+            decompiler.addEOL(Token.LC);\n+\n+            Node body = transform(cc.getBody());\n+            decompiler.addEOL(Token.RC);\n+\n+            catchBlocks.addChildToBack(createCatch(varName, catchCond,\n+                                                   body, cc.getLineno()));\n+        }\n+        Node finallyBlock = null;\n+        if (node.getFinallyBlock() != null) {\n+            decompiler.addToken(Token.FINALLY);\n+            decompiler.addEOL(Token.LC);\n+            finallyBlock = transform(node.getFinallyBlock());\n+            decompiler.addEOL(Token.RC);\n+        }\n+        return createTryCatchFinally(tryBlock, catchBlocks,\n+                                     finallyBlock, node.getLineno());\n+    }\n+\n+    private Node transformUnary(UnaryExpression node) {\n+        int type = node.getType();\n+        if (type == Token.DEFAULTNAMESPACE) {\n+            return transformDefaultXmlNamepace(node);\n+        }\n+        if (node.isPrefix()) {\n+            decompiler.addToken(type);\n+        }\n+        Node child = transform(node.getOperand());\n+        if (node.isPostfix()) {\n+            decompiler.addToken(type);\n+        }\n+        if (type == Token.INC || type == Token.DEC) {\n+            return createIncDec(type, node.isPostfix(), child);\n+        }\n+        return createUnary(type, child);\n+    }\n+\n+    private Node transformVariables(VariableDeclaration node) {\n+        decompiler.addToken(node.getType());\n+        transformVariableInitializers(node);\n+\n+        // Might be most robust to have parser record whether it was\n+        // a variable declaration statement, possibly as a node property.\n+        AstNode parent = node.getParent();\n+        if (!(parent instanceof Loop)\n+            && !(parent instanceof LetNode)) {\n+            decompiler.addEOL(Token.SEMI);\n+        }\n+        return node;\n+    }\n+\n+    private Node transformVariableInitializers(VariableDeclaration node) {\n+        List<VariableInitializer> vars = node.getVariables();\n+        int size = vars.size(), i = 0;\n+        for (VariableInitializer var : vars) {\n+            AstNode target = var.getTarget();\n+            AstNode init = var.getInitializer();\n+\n+            Node left = null;\n+            if (var.isDestructuring()) {\n+                decompile(target);  // decompile but don't transform\n+                left = target;\n+            } else {\n+                left = transform(target);\n+            }\n+\n+            Node right = null;\n+            if (init != null) {\n+                decompiler.addToken(Token.ASSIGN);\n+                right = transform(init);\n+            }\n+\n+            if (var.isDestructuring()) {\n+                if (right == null) {  // TODO:  should this ever happen?\n+                    node.addChildToBack(left);\n+                } else {\n+                    Node d = createDestructuringAssignment(node.getType(),\n+                                                           left, right);\n+                    node.addChildToBack(d);\n+                }\n+            } else {\n+                if (right != null) {\n+                    left.addChildToBack(right);\n+                }\n+                node.addChildToBack(left);\n+            }\n+            if (i++ < size-1) {\n+                decompiler.addToken(Token.COMMA);\n+            }\n+        }\n+        return node;\n+    }\n+\n+    private Node transformWhileLoop(WhileLoop loop) {\n+        decompiler.addToken(Token.WHILE);\n+        loop.setType(Token.LOOP);\n+        pushScope(loop);\n+        try {\n+            decompiler.addToken(Token.LP);\n+            Node cond = transform(loop.getCondition());\n+            decompiler.addToken(Token.RP);\n+            decompiler.addEOL(Token.LC);\n+            Node body = transform(loop.getBody());\n+            decompiler.addEOL(Token.RC);\n+            return createLoop(loop, LOOP_WHILE, body, cond, null, null);\n+        } finally {\n+            popScope();\n+        }\n+    }\n+\n+    private Node transformWith(WithStatement node) {\n+        decompiler.addToken(Token.WITH);\n+        decompiler.addToken(Token.LP);\n+        Node expr = transform(node.getExpression());\n+        decompiler.addToken(Token.RP);\n+        decompiler.addEOL(Token.LC);\n+        Node stmt = transform(node.getStatement());\n+        decompiler.addEOL(Token.RC);\n+        return createWith(expr, stmt, node.getLineno());\n+    }\n+\n+    private Node transformYield(Yield node) {\n+        decompiler.addToken(Token.YIELD);\n+        Node kid = node.getValue() == null ? null : transform(node.getValue());\n+        if (kid != null)\n+            return new Node(Token.YIELD, kid, node.getLineno());\n+        else\n+            return new Node(Token.YIELD, node.getLineno());\n+    }\n+\n+    private Node transformXmlLiteral(XmlLiteral node) {\n+        // a literal like <foo>{bar}</foo> is rewritten as\n+        //   new XML(\"<foo>\" + bar + \"</foo>\");\n+\n+        Node pnXML = new Node(Token.NEW, node.getLineno());\n+        List<XmlFragment> frags = node.getFragments();\n+\n+        XmlString first = (XmlString)frags.get(0);\n+        boolean anon = first.getXml().trim().startsWith(\"<>\");\n+        pnXML.addChildToBack(createName(anon ? \"XMLList\" : \"XML\"));\n+\n+        Node pn = null;\n+        for (XmlFragment frag : frags) {\n+            if (frag instanceof XmlString) {\n+                String xml = ((XmlString)frag).getXml();\n+                decompiler.addName(xml);\n+                if (pn == null) {\n+                    pn = createString(xml);\n+                } else {\n+                    pn = createBinary(Token.ADD, pn, createString(xml));\n+                }\n+            } else {\n+                XmlExpression xexpr = (XmlExpression)frag;\n+                boolean isXmlAttr = xexpr.isXmlAttribute();\n+                Node expr;\n+                decompiler.addToken(Token.LC);\n+                if (xexpr.getExpression() instanceof EmptyExpression) {\n+                    expr = createString(\"\");\n+                } else {\n+                    expr = transform(xexpr.getExpression());\n+                }\n+                decompiler.addToken(Token.RC);\n+                if (isXmlAttr) {\n+                    // Need to put the result in double quotes\n+                    expr = createUnary(Token.ESCXMLATTR, expr);\n+                    Node prepend = createBinary(Token.ADD,\n+                                                createString(\"\\\"\"),\n+                                                expr);\n+                    expr = createBinary(Token.ADD,\n+                                        prepend,\n+                                        createString(\"\\\"\"));\n+                } else {\n+                    expr = createUnary(Token.ESCXMLTEXT, expr);\n+                }\n+                pn = createBinary(Token.ADD, pn, expr);\n+            }\n+        }\n+\n+        pnXML.addChildToBack(pn);\n+        return pnXML;\n+    }\n+\n+    private Node transformXmlMemberGet(XmlMemberGet node) {\n+        XmlRef ref = node.getMemberRef();\n+        Node pn = transform(node.getLeft());\n+        int flags = ref.isAttributeAccess() ? Node.ATTRIBUTE_FLAG : 0;\n+        if (node.getType() == Token.DOTDOT) {\n+            flags |= Node.DESCENDANTS_FLAG;\n+            decompiler.addToken(Token.DOTDOT);\n+        } else {\n+            decompiler.addToken(Token.DOT);\n+        }\n+        return transformXmlRef(pn, ref, flags);\n+    }\n+\n+    // We get here if we weren't a child of a . or .. infix node\n+    private Node transformXmlRef(XmlRef node) {\n+        int memberTypeFlags = node.isAttributeAccess()\n+            ? Node.ATTRIBUTE_FLAG : 0;\n+        return transformXmlRef(null, node, memberTypeFlags);\n+    }\n+\n+    private Node transformXmlRef(Node pn, XmlRef node, int memberTypeFlags) {\n+        if ((memberTypeFlags & Node.ATTRIBUTE_FLAG) != 0)\n+            decompiler.addToken(Token.XMLATTR);\n+        Name namespace = node.getNamespace();\n+        String ns = namespace != null ? namespace.getIdentifier() : null;\n+        if (ns != null) {\n+            decompiler.addName(ns);\n+            decompiler.addToken(Token.COLONCOLON);\n+        }\n+        if (node instanceof XmlPropRef) {\n+            String name = ((XmlPropRef)node).getPropName().getIdentifier();\n+            decompiler.addName(name);\n+            return createPropertyGet(pn, ns, name, memberTypeFlags);\n+        } else {\n+            decompiler.addToken(Token.LB);\n+            Node expr = transform(((XmlElemRef)node).getExpression());\n+            decompiler.addToken(Token.RB);\n+            return createElementGet(pn, ns, expr, memberTypeFlags);\n+        }\n+    }\n+\n+    private Node transformDefaultXmlNamepace(UnaryExpression node) {\n+        decompiler.addToken(Token.DEFAULT);\n+        decompiler.addName(\" xml\");\n+        decompiler.addName(\" namespace\");\n+        decompiler.addToken(Token.ASSIGN);\n+        Node child = transform(node.getOperand());\n+        return createUnary(Token.DEFAULTNAMESPACE, child);\n+    }\n+\n+    /**\n+     * If caseExpression argument is null it indicates a default label.\n+     */\n+    private void addSwitchCase(Node switchBlock, Node caseExpression,\n+                               Node statements)\n+    {\n+        if (switchBlock.getType() != Token.BLOCK) throw Kit.codeBug();\n+        Jump switchNode = (Jump)switchBlock.getFirstChild();\n+        if (switchNode.getType() != Token.SWITCH) throw Kit.codeBug();\n+\n+        Node gotoTarget = Node.newTarget();\n+        if (caseExpression != null) {\n+            Jump caseNode = new Jump(Token.CASE, caseExpression);\n+            caseNode.target = gotoTarget;\n+            switchNode.addChildToBack(caseNode);\n+        } else {\n+            switchNode.setDefault(gotoTarget);\n+        }\n+        switchBlock.addChildToBack(gotoTarget);\n+        switchBlock.addChildToBack(statements);\n+    }\n+\n+    private void closeSwitch(Node switchBlock)\n+    {\n+        if (switchBlock.getType() != Token.BLOCK) throw Kit.codeBug();\n+        Jump switchNode = (Jump)switchBlock.getFirstChild();\n+        if (switchNode.getType() != Token.SWITCH) throw Kit.codeBug();\n+\n+        Node switchBreakTarget = Node.newTarget();\n+        // switchNode.target is only used by NodeTransformer\n+        // to detect switch end\n+        switchNode.target = switchBreakTarget;\n+\n+        Node defaultTarget = switchNode.getDefault();\n+        if (defaultTarget == null) {\n+            defaultTarget = switchBreakTarget;\n+        }\n+\n+        switchBlock.addChildAfter(makeJump(Token.GOTO, defaultTarget),\n+                                  switchNode);\n+        switchBlock.addChildToBack(switchBreakTarget);\n+    }\n+\n+    private Node createExprStatementNoReturn(Node expr, int lineno) {\n+        return new Node(Token.EXPR_VOID, expr, lineno);\n+    }\n+\n+    private Node createString(String string) {\n+        return Node.newString(string);\n+    }\n+\n+    /**\n+     * Catch clause of try/catch/finally\n+     * @param varName the name of the variable to bind to the exception\n+     * @param catchCond the condition under which to catch the exception.\n+     *                  May be null if no condition is given.\n+     * @param stmts the statements in the catch clause\n+     * @param lineno the starting line number of the catch clause\n+     */\n+    private Node createCatch(String varName, Node catchCond, Node stmts,\n+                             int lineno) {\n+        if (catchCond == null) {\n+            catchCond = new Node(Token.EMPTY);\n+        }\n+        return new Node(Token.CATCH, createName(varName),\n+                        catchCond, stmts, lineno);\n+    }\n+\n+    private Node initFunction(FunctionNode fnNode, int functionIndex,\n+                              Node statements, int functionType) {\n+        fnNode.setFunctionType(functionType);\n+        fnNode.addChildToBack(statements);\n+\n+        int functionCount = fnNode.getFunctionCount();\n+        if (functionCount != 0) {\n+            // Functions containing other functions require activation objects\n+            fnNode.setRequiresActivation();\n+        }\n+\n+        if (functionType == FunctionNode.FUNCTION_EXPRESSION) {\n+            Name name = fnNode.getFunctionName();\n+            if (name != null && name.length() != 0) {\n+                // A function expression needs to have its name as a\n+                // variable (if it isn't already allocated as a variable).\n+                // See ECMA Ch. 13.  We add code to the beginning of the\n+                // function to initialize a local variable of the\n+                // function's name to the function value.\n+                Node setFn = new Node(Token.EXPR_VOID,\n+                                 new Node(Token.SETNAME,\n+                                          Node.newString(Token.BINDNAME,\n+                                                         name.getIdentifier()),\n+                                     new Node(Token.THISFN)));\n+                statements.addChildrenToFront(setFn);\n+            }\n+        }\n+\n+        // Add return to end if needed.\n+        Node lastStmt = statements.getLastChild();\n+        if (lastStmt == null || lastStmt.getType() != Token.RETURN) {\n+            statements.addChildToBack(new Node(Token.RETURN));\n+        }\n+\n+        Node result = Node.newString(Token.FUNCTION, fnNode.getName());\n+        result.putIntProp(Node.FUNCTION_PROP, functionIndex);\n+        return result;\n+    }\n+\n+    /**\n+     * Create loop node. The code generator will later call\n+     * createWhile|createDoWhile|createFor|createForIn\n+     * to finish loop generation.\n+     */\n+    private Scope createLoopNode(Node loopLabel, int lineno) {\n+        Scope result = createScopeNode(Token.LOOP, lineno);\n+        if (loopLabel != null) {\n+            ((Jump)loopLabel).setLoop(result);\n+        }\n+        return result;\n+    }\n+\n+    private Node createFor(Scope loop, Node init,\n+                           Node test, Node incr, Node body) {\n+        if (init.getType() == Token.LET) {\n+            // rewrite \"for (let i=s; i < N; i++)...\" as\n+            // \"let (i=s) { for (; i < N; i++)...\" so that \"s\" is evaluated\n+            // outside the scope of the for.\n+            Scope let = Scope.splitScope(loop);\n+            let.setType(Token.LET);\n+            let.addChildrenToBack(init);\n+            let.addChildToBack(createLoop(loop, LOOP_FOR, body, test,\n+                new Node(Token.EMPTY), incr));\n+            return let;\n+        }\n+        return createLoop(loop, LOOP_FOR, body, test, init, incr);\n+    }\n+\n+    private Node createLoop(Jump loop, int loopType, Node body,\n+                            Node cond, Node init, Node incr)\n+    {\n+        Node bodyTarget = Node.newTarget();\n+        Node condTarget = Node.newTarget();\n+        if (loopType == LOOP_FOR && cond.getType() == Token.EMPTY) {\n+            cond = new Node(Token.TRUE);\n+        }\n+        Jump IFEQ = new Jump(Token.IFEQ, cond);\n+        IFEQ.target = bodyTarget;\n+        Node breakTarget = Node.newTarget();\n+\n+        loop.addChildToBack(bodyTarget);\n+        loop.addChildrenToBack(body);\n+        if (loopType == LOOP_WHILE || loopType == LOOP_FOR) {\n+            // propagate lineno to condition\n+            loop.addChildrenToBack(new Node(Token.EMPTY, loop.getLineno()));\n+        }\n+        loop.addChildToBack(condTarget);\n+        loop.addChildToBack(IFEQ);\n+        loop.addChildToBack(breakTarget);\n+\n+        loop.target = breakTarget;\n+        Node continueTarget = condTarget;\n+\n+        if (loopType == LOOP_WHILE || loopType == LOOP_FOR) {\n+            // Just add a GOTO to the condition in the do..while\n+            loop.addChildToFront(makeJump(Token.GOTO, condTarget));\n+\n+            if (loopType == LOOP_FOR) {\n+                int initType = init.getType();\n+                if (initType != Token.EMPTY) {\n+                    if (initType != Token.VAR && initType != Token.LET) {\n+                        init = new Node(Token.EXPR_VOID, init);\n+                    }\n+                    loop.addChildToFront(init);\n+                }\n+                Node incrTarget = Node.newTarget();\n+                loop.addChildAfter(incrTarget, body);\n+                if (incr.getType() != Token.EMPTY) {\n+                    incr = new Node(Token.EXPR_VOID, incr);\n+                    loop.addChildAfter(incr, incrTarget);\n+                }\n+                continueTarget = incrTarget;\n+            }\n+        }\n+\n+        loop.setContinue(continueTarget);\n+        return loop;\n+    }\n+\n+    /**\n+     * Generate IR for a for..in loop.\n+     */\n+    private Node createForIn(int declType, Node loop, Node lhs,\n+                             Node obj, Node body, boolean isForEach)\n+    {\n+        int destructuring = -1;\n+        int destructuringLen = 0;\n+        Node lvalue;\n+        int type = lhs.getType();\n+        if (type == Token.VAR || type == Token.LET) {\n+            Node kid = lhs.getLastChild();\n+            int kidType = kid.getType();\n+            if (kidType == Token.ARRAYLIT || kidType == Token.OBJECTLIT)\n+            {\n+                type = destructuring = kidType;\n+                lvalue = kid;\n+                destructuringLen = 0;\n+                if (kid instanceof ArrayLiteral)\n+                    destructuringLen = ((ArrayLiteral) kid).getDestructuringLength();\n+            } else if (kidType == Token.NAME) {\n+                lvalue = Node.newString(Token.NAME, kid.getString());\n+            } else {\n+                reportError(\"msg.bad.for.in.lhs\");\n+                return null;\n+            }\n+        } else if (type == Token.ARRAYLIT || type == Token.OBJECTLIT) {\n+            destructuring = type;\n+            lvalue = lhs;\n+            destructuringLen = 0;\n+            if (lhs instanceof ArrayLiteral)\n+                destructuringLen = ((ArrayLiteral) lhs).getDestructuringLength();\n+        } else {\n+            lvalue = makeReference(lhs);\n+            if (lvalue == null) {\n+                reportError(\"msg.bad.for.in.lhs\");\n+                return null;\n+            }\n+        }\n+\n+        Node localBlock = new Node(Token.LOCAL_BLOCK);\n+        int initType = isForEach ? Token.ENUM_INIT_VALUES\n+                                 : (destructuring != -1\n+                                    ? Token.ENUM_INIT_ARRAY\n+                                    : Token.ENUM_INIT_KEYS);\n+        Node init = new Node(initType, obj);\n+        init.putProp(Node.LOCAL_BLOCK_PROP, localBlock);\n+        Node cond = new Node(Token.ENUM_NEXT);\n+        cond.putProp(Node.LOCAL_BLOCK_PROP, localBlock);\n+        Node id = new Node(Token.ENUM_ID);\n+        id.putProp(Node.LOCAL_BLOCK_PROP, localBlock);\n+\n+        Node newBody = new Node(Token.BLOCK);\n+        Node assign;\n+        if (destructuring != -1) {\n+            assign = createDestructuringAssignment(declType, lvalue, id);\n+            if (!isForEach && (destructuring == Token.OBJECTLIT ||\n+                               destructuringLen != 2))\n+            {\n+                // destructuring assignment is only allowed in for..each or\n+                // with an array type of length 2 (to hold key and value)\n+                reportError(\"msg.bad.for.in.destruct\");\n+            }\n+        } else {\n+            assign = simpleAssignment(lvalue, id);\n+        }\n+        newBody.addChildToBack(new Node(Token.EXPR_VOID, assign));\n+        newBody.addChildToBack(body);\n+\n+        loop = createLoop((Jump)loop, LOOP_WHILE, newBody, cond, null, null);\n+        loop.addChildToFront(init);\n+        if (type == Token.VAR || type == Token.LET)\n+            loop.addChildToFront(lhs);\n+        localBlock.addChildToBack(loop);\n+\n+        return localBlock;\n+    }\n+\n+    /**\n+     * Try/Catch/Finally\n+     *\n+     * The IRFactory tries to express as much as possible in the tree;\n+     * the responsibilities remaining for Codegen are to add the Java\n+     * handlers: (Either (but not both) of TARGET and FINALLY might not\n+     * be defined)\n+     *\n+     * - a catch handler for javascript exceptions that unwraps the\n+     * exception onto the stack and GOTOes to the catch target\n+     *\n+     * - a finally handler\n+     *\n+     * ... and a goto to GOTO around these handlers.\n+     */\n+    private Node createTryCatchFinally(Node tryBlock, Node catchBlocks,\n+                                       Node finallyBlock, int lineno)\n+    {\n+        boolean hasFinally = (finallyBlock != null)\n+                             && (finallyBlock.getType() != Token.BLOCK\n+                                 || finallyBlock.hasChildren());\n+\n+        // short circuit\n+        if (tryBlock.getType() == Token.BLOCK && !tryBlock.hasChildren()\n+            && !hasFinally)\n+        {\n+            return tryBlock;\n+        }\n+\n+        boolean hasCatch = catchBlocks.hasChildren();\n+\n+        // short circuit\n+        if (!hasFinally && !hasCatch)  {\n+            // bc finally might be an empty block...\n+            return tryBlock;\n+        }\n+\n+        Node handlerBlock  = new Node(Token.LOCAL_BLOCK);\n+        Jump pn = new Jump(Token.TRY, tryBlock, lineno);\n+        pn.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock);\n+\n+        if (hasCatch) {\n+            // jump around catch code\n+            Node endCatch = Node.newTarget();\n+            pn.addChildToBack(makeJump(Token.GOTO, endCatch));\n+\n+            // make a TARGET for the catch that the tcf node knows about\n+            Node catchTarget = Node.newTarget();\n+            pn.target = catchTarget;\n+            // mark it\n+            pn.addChildToBack(catchTarget);\n+\n+            //\n+            //  Given\n+            //\n+            //   try {\n+            //       tryBlock;\n+            //   } catch (e if condition1) {\n+            //       something1;\n+            //   ...\n+            //\n+            //   } catch (e if conditionN) {\n+            //       somethingN;\n+            //   } catch (e) {\n+            //       somethingDefault;\n+            //   }\n+            //\n+            //  rewrite as\n+            //\n+            //   try {\n+            //       tryBlock;\n+            //       goto after_catch:\n+            //   } catch (x) {\n+            //       with (newCatchScope(e, x)) {\n+            //           if (condition1) {\n+            //               something1;\n+            //               goto after_catch;\n+            //           }\n+            //       }\n+            //   ...\n+            //       with (newCatchScope(e, x)) {\n+            //           if (conditionN) {\n+            //               somethingN;\n+            //               goto after_catch;\n+            //           }\n+            //       }\n+            //       with (newCatchScope(e, x)) {\n+            //           somethingDefault;\n+            //           goto after_catch;\n+            //       }\n+            //   }\n+            // after_catch:\n+            //\n+            // If there is no default catch, then the last with block\n+            // arround  \"somethingDefault;\" is replaced by \"rethrow;\"\n+\n+            // It is assumed that catch handler generation will store\n+            // exeception object in handlerBlock register\n+\n+            // Block with local for exception scope objects\n+            Node catchScopeBlock = new Node(Token.LOCAL_BLOCK);\n+\n+            // expects catchblocks children to be (cond block) pairs.\n+            Node cb = catchBlocks.getFirstChild();\n+            boolean hasDefault = false;\n+            int scopeIndex = 0;\n+            while (cb != null) {\n+                int catchLineNo = cb.getLineno();\n+\n+                Node name = cb.getFirstChild();\n+                Node cond = name.getNext();\n+                Node catchStatement = cond.getNext();\n+                cb.removeChild(name);\n+                cb.removeChild(cond);\n+                cb.removeChild(catchStatement);\n+\n+                // Add goto to the catch statement to jump out of catch\n+                // but prefix it with LEAVEWITH since try..catch produces\n+                // \"with\"code in order to limit the scope of the exception\n+                // object.\n+                catchStatement.addChildToBack(new Node(Token.LEAVEWITH));\n+                catchStatement.addChildToBack(makeJump(Token.GOTO, endCatch));\n+\n+                // Create condition \"if\" when present\n+                Node condStmt;\n+                if (cond.getType() == Token.EMPTY) {\n+                    condStmt = catchStatement;\n+                    hasDefault = true;\n+                } else {\n+                    condStmt = createIf(cond, catchStatement, null,\n+                                        catchLineNo);\n+                }\n+\n+                // Generate code to create the scope object and store\n+                // it in catchScopeBlock register\n+                Node catchScope = new Node(Token.CATCH_SCOPE, name,\n+                                           createUseLocal(handlerBlock));\n+                catchScope.putProp(Node.LOCAL_BLOCK_PROP, catchScopeBlock);\n+                catchScope.putIntProp(Node.CATCH_SCOPE_PROP, scopeIndex);\n+                catchScopeBlock.addChildToBack(catchScope);\n+\n+                // Add with statement based on catch scope object\n+                catchScopeBlock.addChildToBack(\n+                    createWith(createUseLocal(catchScopeBlock), condStmt,\n+                               catchLineNo));\n+\n+                // move to next cb\n+                cb = cb.getNext();\n+                ++scopeIndex;\n+            }\n+            pn.addChildToBack(catchScopeBlock);\n+            if (!hasDefault) {\n+                // Generate code to rethrow if no catch clause was executed\n+                Node rethrow = new Node(Token.RETHROW);\n+                rethrow.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock);\n+                pn.addChildToBack(rethrow);\n+            }\n+\n+            pn.addChildToBack(endCatch);\n+        }\n+\n+        if (hasFinally) {\n+            Node finallyTarget = Node.newTarget();\n+            pn.setFinally(finallyTarget);\n+\n+            // add jsr finally to the try block\n+            pn.addChildToBack(makeJump(Token.JSR, finallyTarget));\n+\n+            // jump around finally code\n+            Node finallyEnd = Node.newTarget();\n+            pn.addChildToBack(makeJump(Token.GOTO, finallyEnd));\n+\n+            pn.addChildToBack(finallyTarget);\n+            Node fBlock = new Node(Token.FINALLY, finallyBlock);\n+            fBlock.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock);\n+            pn.addChildToBack(fBlock);\n+\n+            pn.addChildToBack(finallyEnd);\n+        }\n+        handlerBlock.addChildToBack(pn);\n+        return handlerBlock;\n+    }\n+\n+    private Node createWith(Node obj, Node body, int lineno) {\n+        setRequiresActivation();\n+        Node result = new Node(Token.BLOCK, lineno);\n+        result.addChildToBack(new Node(Token.ENTERWITH, obj));\n+        Node bodyNode = new Node(Token.WITH, body, lineno);\n+        result.addChildrenToBack(bodyNode);\n+        result.addChildToBack(new Node(Token.LEAVEWITH));\n+        return result;\n+    }\n+\n+    private Node createIf(Node cond, Node ifTrue, Node ifFalse, int lineno)\n+    {\n+        int condStatus = isAlwaysDefinedBoolean(cond);\n+        if (condStatus == ALWAYS_TRUE_BOOLEAN) {\n+            return ifTrue;\n+        } else if (condStatus == ALWAYS_FALSE_BOOLEAN) {\n+            if (ifFalse != null) {\n+                return ifFalse;\n+            }\n+            // Replace if (false) xxx by empty block\n+            return new Node(Token.BLOCK, lineno);\n+        }\n+\n+        Node result = new Node(Token.BLOCK, lineno);\n+        Node ifNotTarget = Node.newTarget();\n+        Jump IFNE = new Jump(Token.IFNE, cond);\n+        IFNE.target = ifNotTarget;\n+\n+        result.addChildToBack(IFNE);\n+        result.addChildrenToBack(ifTrue);\n+\n+        if (ifFalse != null) {\n+            Node endTarget = Node.newTarget();\n+            result.addChildToBack(makeJump(Token.GOTO, endTarget));\n+            result.addChildToBack(ifNotTarget);\n+            result.addChildrenToBack(ifFalse);\n+            result.addChildToBack(endTarget);\n+        } else {\n+            result.addChildToBack(ifNotTarget);\n+        }\n+\n+        return result;\n+    }\n+\n+    private Node createCondExpr(Node cond, Node ifTrue, Node ifFalse) {\n+        int condStatus = isAlwaysDefinedBoolean(cond);\n+        if (condStatus == ALWAYS_TRUE_BOOLEAN) {\n+            return ifTrue;\n+        } else if (condStatus == ALWAYS_FALSE_BOOLEAN) {\n+            return ifFalse;\n+        }\n+        return new Node(Token.HOOK, cond, ifTrue, ifFalse);\n+    }\n+\n+    private Node createUnary(int nodeType, Node child)\n+    {\n+        int childType = child.getType();\n+        switch (nodeType) {\n+          case Token.DELPROP: {\n+            Node n;\n+            if (childType == Token.NAME) {\n+                // Transform Delete(Name \"a\")\n+                //  to Delete(Bind(\"a\"), String(\"a\"))\n+                child.setType(Token.BINDNAME);\n+                Node left = child;\n+                Node right = Node.newString(child.getString());\n+                n = new Node(nodeType, left, right);\n+            } else if (childType == Token.GETPROP ||\n+                       childType == Token.GETELEM)\n+            {\n+                Node left = child.getFirstChild();\n+                Node right = child.getLastChild();\n+                child.removeChild(left);\n+                child.removeChild(right);\n+                n = new Node(nodeType, left, right);\n+            } else if (childType == Token.GET_REF) {\n+                Node ref = child.getFirstChild();\n+                child.removeChild(ref);\n+                n = new Node(Token.DEL_REF, ref);\n+            } else if (childType == Token.CALL) {\n+                n = new Node(nodeType, new Node(Token.TRUE), child);\n+            } else {\n+                n = new Node(Token.TRUE);\n+            }\n+            return n;\n+          }\n+          case Token.TYPEOF:\n+            if (childType == Token.NAME) {\n+                child.setType(Token.TYPEOFNAME);\n+                return child;\n+            }\n+            break;\n+          case Token.BITNOT:\n+            if (childType == Token.NUMBER) {\n+                int value = ScriptRuntime.toInt32(child.getDouble());\n+                child.setDouble(~value);\n+                return child;\n+            }\n+            break;\n+          case Token.NEG:\n+            if (childType == Token.NUMBER) {\n+                child.setDouble(-child.getDouble());\n+                return child;\n+            }\n+            break;\n+          case Token.NOT: {\n+            int status = isAlwaysDefinedBoolean(child);\n+            if (status != 0) {\n+                int type;\n+                if (status == ALWAYS_TRUE_BOOLEAN) {\n+                    type = Token.FALSE;\n+                } else {\n+                    type = Token.TRUE;\n+                }\n+                if (childType == Token.TRUE || childType == Token.FALSE) {\n+                    child.setType(type);\n+                    return child;\n+                }\n+                return new Node(type);\n+            }\n+            break;\n+          }\n+        }\n+        return new Node(nodeType, child);\n+    }\n+\n+    private Node createCallOrNew(int nodeType, Node child) {\n+        int type = Node.NON_SPECIALCALL;\n+        if (child.getType() == Token.NAME) {\n+            String name = child.getString();\n+            if (name.equals(\"eval\")) {\n+                type = Node.SPECIALCALL_EVAL;\n+            } else if (name.equals(\"With\")) {\n+                type = Node.SPECIALCALL_WITH;\n+            }\n+        } else if (child.getType() == Token.GETPROP) {\n+            String name = child.getLastChild().getString();\n+            if (name.equals(\"eval\")) {\n+                type = Node.SPECIALCALL_EVAL;\n+            }\n+        }\n+        Node node = new Node(nodeType, child);\n+        if (type != Node.NON_SPECIALCALL) {\n+            // Calls to these functions require activation objects.\n+            setRequiresActivation();\n+            node.putIntProp(Node.SPECIALCALL_PROP, type);\n+        }\n+        return node;\n+    }\n+\n+    private Node createIncDec(int nodeType, boolean post, Node child)\n+    {\n+        child = makeReference(child);\n+        int childType = child.getType();\n+\n+        switch (childType) {\n+          case Token.NAME:\n+          case Token.GETPROP:\n+          case Token.GETELEM:\n+          case Token.GET_REF: {\n+            Node n = new Node(nodeType, child);\n+            int incrDecrMask = 0;\n+            if (nodeType == Token.DEC) {\n+                incrDecrMask |= Node.DECR_FLAG;\n+            }\n+            if (post) {\n+                incrDecrMask |= Node.POST_FLAG;\n+            }\n+            n.putIntProp(Node.INCRDECR_PROP, incrDecrMask);\n+            return n;\n+          }\n+        }\n+        throw Kit.codeBug();\n+    }\n+\n+    private Node createPropertyGet(Node target, String namespace, String name,\n+                                   int memberTypeFlags)\n+    {\n+        if (namespace == null && memberTypeFlags == 0) {\n+            if (target == null) {\n+                return createName(name);\n+            }\n+            checkActivationName(name, Token.GETPROP);\n+            if (ScriptRuntime.isSpecialProperty(name)) {\n+                Node ref = new Node(Token.REF_SPECIAL, target);\n+                ref.putProp(Node.NAME_PROP, name);\n+                return new Node(Token.GET_REF, ref);\n+            }\n+            return new Node(Token.GETPROP, target, Node.newString(name));\n+        }\n+        Node elem = Node.newString(name);\n+        memberTypeFlags |= Node.PROPERTY_FLAG;\n+        return createMemberRefGet(target, namespace, elem, memberTypeFlags);\n+    }\n+\n+    /**\n+     * @param target the node before the LB\n+     * @param namespace optional namespace\n+     * @param elem the node in the brackets\n+     * @param memberTypeFlags E4X flags\n+     */\n+    private Node createElementGet(Node target, String namespace, Node elem,\n+                                  int memberTypeFlags)\n+    {\n+        // OPT: could optimize to createPropertyGet\n+        // iff elem is string that can not be number\n+        if (namespace == null && memberTypeFlags == 0) {\n+            // stand-alone [aaa] as primary expression is array literal\n+            // declaration and should not come here!\n+            if (target == null) throw Kit.codeBug();\n+            return new Node(Token.GETELEM, target, elem);\n+        }\n+        return createMemberRefGet(target, namespace, elem, memberTypeFlags);\n+    }\n+\n+    private Node createMemberRefGet(Node target, String namespace, Node elem,\n+                                    int memberTypeFlags)\n+    {\n+        Node nsNode = null;\n+        if (namespace != null) {\n+            // See 11.1.2 in ECMA 357\n+            if (namespace.equals(\"*\")) {\n+                nsNode = new Node(Token.NULL);\n+            } else {\n+                nsNode = createName(namespace);\n+            }\n+        }\n+        Node ref;\n+        if (target == null) {\n+            if (namespace == null) {\n+                ref = new Node(Token.REF_NAME, elem);\n+            } else {\n+                ref = new Node(Token.REF_NS_NAME, nsNode, elem);\n+            }\n+        } else {\n+            if (namespace == null) {\n+                ref = new Node(Token.REF_MEMBER, target, elem);\n+            } else {\n+                ref = new Node(Token.REF_NS_MEMBER, target, nsNode, elem);\n+            }\n+        }\n+        if (memberTypeFlags != 0) {\n+            ref.putIntProp(Node.MEMBER_TYPE_PROP, memberTypeFlags);\n+        }\n+        return new Node(Token.GET_REF, ref);\n+    }\n+\n+    private Node createBinary(int nodeType, Node left, Node right) {\n+        switch (nodeType) {\n+\n+          case Token.ADD:\n+            // numerical addition and string concatenation\n+            if (left.type == Token.STRING) {\n+                String s2;\n+                if (right.type == Token.STRING) {\n+                    s2 = right.getString();\n+                } else if (right.type == Token.NUMBER) {\n+                    s2 = ScriptRuntime.numberToString(right.getDouble(), 10);\n+                } else {\n+                    break;\n+                }\n+                String s1 = left.getString();\n+                left.setString(s1.concat(s2));\n+                return left;\n+            } else if (left.type == Token.NUMBER) {\n+                if (right.type == Token.NUMBER) {\n+                    left.setDouble(left.getDouble() + right.getDouble());\n+                    return left;\n+                } else if (right.type == Token.STRING) {\n+                    String s1, s2;\n+                    s1 = ScriptRuntime.numberToString(left.getDouble(), 10);\n+                    s2 = right.getString();\n+                    right.setString(s1.concat(s2));\n+                    return right;\n+                }\n+            }\n+            // can't do anything if we don't know  both types - since\n+            // 0 + object is supposed to call toString on the object and do\n+            // string concantenation rather than addition\n+            break;\n+\n+          case Token.SUB:\n+            // numerical subtraction\n+            if (left.type == Token.NUMBER) {\n+                double ld = left.getDouble();\n+                if (right.type == Token.NUMBER) {\n+                    //both numbers\n+                    left.setDouble(ld - right.getDouble());\n+                    return left;\n+                } else if (ld == 0.0) {\n+                    // first 0: 0-x -> -x\n+                    return new Node(Token.NEG, right);\n+                }\n+            } else if (right.type == Token.NUMBER) {\n+                if (right.getDouble() == 0.0) {\n+                    //second 0: x - 0 -> +x\n+                    // can not make simply x because x - 0 must be number\n+                    return new Node(Token.POS, left);\n+                }\n+            }\n+            break;\n+\n+          case Token.MUL:\n+            // numerical multiplication\n+            if (left.type == Token.NUMBER) {\n+                double ld = left.getDouble();\n+                if (right.type == Token.NUMBER) {\n+                    //both numbers\n+                    left.setDouble(ld * right.getDouble());\n+                    return left;\n+                } else if (ld == 1.0) {\n+                    // first 1: 1 *  x -> +x\n+                    return new Node(Token.POS, right);\n+                }\n+            } else if (right.type == Token.NUMBER) {\n+                if (right.getDouble() == 1.0) {\n+                    //second 1: x * 1 -> +x\n+                    // can not make simply x because x - 0 must be number\n+                    return new Node(Token.POS, left);\n+                }\n+            }\n+            // can't do x*0: Infinity * 0 gives NaN, not 0\n+            break;\n+\n+          case Token.DIV:\n+            // number division\n+            if (right.type == Token.NUMBER) {\n+                double rd = right.getDouble();\n+                if (left.type == Token.NUMBER) {\n+                    // both constants -- just divide, trust Java to handle x/0\n+                    left.setDouble(left.getDouble() / rd);\n+                    return left;\n+               } else if (rd == 1.0) {\n+                    // second 1: x/1 -> +x\n+                    // not simply x to force number convertion\n+                    return new Node(Token.POS, left);\n+                }\n+            }\n+            break;\n+\n+          case Token.AND: {\n+            // Since x && y gives x, not false, when Boolean(x) is false,\n+            // and y, not Boolean(y), when Boolean(x) is true, x && y\n+            // can only be simplified if x is defined. See bug 309957.\n+\n+            int leftStatus = isAlwaysDefinedBoolean(left);\n+            if (leftStatus == ALWAYS_FALSE_BOOLEAN) {\n+                // if the first one is false, just return it\n+                return left;\n+            } else if (leftStatus == ALWAYS_TRUE_BOOLEAN) {\n+                // if first is true, set to second\n+                return right;\n+            }\n+            break;\n+          }\n+\n+          case Token.OR: {\n+            // Since x || y gives x, not true, when Boolean(x) is true,\n+            // and y, not Boolean(y), when Boolean(x) is false, x || y\n+            // can only be simplified if x is defined. See bug 309957.\n+\n+            int leftStatus = isAlwaysDefinedBoolean(left);\n+            if (leftStatus == ALWAYS_TRUE_BOOLEAN) {\n+                // if the first one is true, just return it\n+                return left;\n+            } else if (leftStatus == ALWAYS_FALSE_BOOLEAN) {\n+                // if first is false, set to second\n+                return right;\n+            }\n+            break;\n+          }\n+        }\n+\n+        return new Node(nodeType, left, right);\n+    }\n+\n+    private Node createAssignment(int assignType, Node left, Node right)\n+    {\n+        Node ref = makeReference(left);\n+        if (ref == null) {\n+            if (left.getType() == Token.ARRAYLIT ||\n+                left.getType() == Token.OBJECTLIT)\n+            {\n+                if (assignType != Token.ASSIGN) {\n+                    reportError(\"msg.bad.destruct.op\");\n+                    return right;\n+                }\n+                return createDestructuringAssignment(-1, left, right);\n+            }\n+            reportError(\"msg.bad.assign.left\");\n+            return right;\n+        }\n+        left = ref;\n+\n+        int assignOp;\n+        switch (assignType) {\n+          case Token.ASSIGN:\n+            return simpleAssignment(left, right);\n+          case Token.ASSIGN_BITOR:  assignOp = Token.BITOR;  break;\n+          case Token.ASSIGN_BITXOR: assignOp = Token.BITXOR; break;\n+          case Token.ASSIGN_BITAND: assignOp = Token.BITAND; break;\n+          case Token.ASSIGN_LSH:    assignOp = Token.LSH;    break;\n+          case Token.ASSIGN_RSH:    assignOp = Token.RSH;    break;\n+          case Token.ASSIGN_URSH:   assignOp = Token.URSH;   break;\n+          case Token.ASSIGN_ADD:    assignOp = Token.ADD;    break;\n+          case Token.ASSIGN_SUB:    assignOp = Token.SUB;    break;\n+          case Token.ASSIGN_MUL:    assignOp = Token.MUL;    break;\n+          case Token.ASSIGN_DIV:    assignOp = Token.DIV;    break;\n+          case Token.ASSIGN_MOD:    assignOp = Token.MOD;    break;\n+          default: throw Kit.codeBug();\n+        }\n+\n+        int nodeType = left.getType();\n+        switch (nodeType) {\n+          case Token.NAME: {\n+            Node op = new Node(assignOp, left, right);\n+            Node lvalueLeft = Node.newString(Token.BINDNAME, left.getString());\n+            return new Node(Token.SETNAME, lvalueLeft, op);\n+          }\n+          case Token.GETPROP:\n+          case Token.GETELEM: {\n+            Node obj = left.getFirstChild();\n+            Node id = left.getLastChild();\n+\n+            int type = nodeType == Token.GETPROP\n+                       ? Token.SETPROP_OP\n+                       : Token.SETELEM_OP;\n+\n+            Node opLeft = new Node(Token.USE_STACK);\n+            Node op = new Node(assignOp, opLeft, right);\n+            return new Node(type, obj, id, op);\n+          }\n+          case Token.GET_REF: {\n+            ref = left.getFirstChild();\n+            checkMutableReference(ref);\n+            Node opLeft = new Node(Token.USE_STACK);\n+            Node op = new Node(assignOp, opLeft, right);\n+            return new Node(Token.SET_REF_OP, ref, op);\n+          }\n+        }\n+\n+        throw Kit.codeBug();\n+    }\n+\n+    private Node createUseLocal(Node localBlock) {\n+        if (Token.LOCAL_BLOCK != localBlock.getType()) throw Kit.codeBug();\n+        Node result = new Node(Token.LOCAL_LOAD);\n+        result.putProp(Node.LOCAL_BLOCK_PROP, localBlock);\n+        return result;\n+    }\n+\n+    private Jump makeJump(int type, Node target) {\n+        Jump n = new Jump(type);\n+        n.target = target;\n+        return n;\n+    }\n+\n+    private Node makeReference(Node node) {\n+        int type = node.getType();\n+        switch (type) {\n+          case Token.NAME:\n+          case Token.GETPROP:\n+          case Token.GETELEM:\n+          case Token.GET_REF:\n+            return node;\n+          case Token.CALL:\n+            node.setType(Token.REF_CALL);\n+            return new Node(Token.GET_REF, node);\n+        }\n+        // Signal caller to report error\n+        return null;\n+    }\n+\n+    // Check if Node always mean true or false in boolean context\n+    private static int isAlwaysDefinedBoolean(Node node) {\n+        switch (node.getType()) {\n+          case Token.FALSE:\n+          case Token.NULL:\n+            return ALWAYS_FALSE_BOOLEAN;\n+          case Token.TRUE:\n+            return ALWAYS_TRUE_BOOLEAN;\n+          case Token.NUMBER: {\n+            double num = node.getDouble();\n+            if (num == num && num != 0.0) {\n+                return ALWAYS_TRUE_BOOLEAN;\n+            } else {\n+                return ALWAYS_FALSE_BOOLEAN;\n+            }\n+          }\n+        }\n+        return 0;\n+    }\n+\n+    // Check if node is the target of a destructuring bind.\n+    boolean isDestructuring(Node n) {\n+        return n instanceof DestructuringForm\n+            && ((DestructuringForm)n).isDestructuring();\n+    }\n+\n+    Node decompileFunctionHeader(FunctionNode fn) {\n+        Node mexpr = null;\n+        if (fn.getFunctionName() != null) {\n+            decompiler.addName(fn.getName());\n+        } else if (fn.getMemberExprNode() != null) {\n+            mexpr = transform(fn.getMemberExprNode());\n+        }\n+        decompiler.addToken(Token.LP);\n+        List<AstNode> params = fn.getParams();\n+        for (int i = 0; i < params.size(); i++) {\n+            decompile(params.get(i));\n+            if (i < params.size() - 1) {\n+                decompiler.addToken(Token.COMMA);\n+            }\n+        }\n+        decompiler.addToken(Token.RP);\n+        if (!fn.isExpressionClosure()) {\n+            decompiler.addEOL(Token.LC);\n+        }\n+        return mexpr;\n+    }\n+\n+    void decompile(AstNode node) {\n+        switch (node.getType()) {\n+          case Token.ARRAYLIT:\n+              decompileArrayLiteral((ArrayLiteral)node);\n+              break;\n+          case Token.OBJECTLIT:\n+              decompileObjectLiteral((ObjectLiteral)node);\n+              break;\n+          case Token.STRING:\n+              decompiler.addString(((StringLiteral)node).getValue());\n+              break;\n+          case Token.NAME:\n+              decompiler.addName(((Name)node).getIdentifier());\n+              break;\n+          case Token.NUMBER:\n+              decompiler.addNumber(((NumberLiteral)node).getNumber());\n+              break;\n+          case Token.GETPROP:\n+              decompilePropertyGet((PropertyGet)node);\n+              break;\n+          case Token.EMPTY:\n+              break;\n+          case Token.GETELEM:\n+              decompileElementGet((ElementGet) node);\n+              break;\n+          default:\n+              Kit.codeBug(\"unexpected token: \"\n+                          + Token.typeToName(node.getType()));\n+        }\n+    }\n+\n+    // used for destructuring forms, since we don't transform() them\n+    void decompileArrayLiteral(ArrayLiteral node) {\n+        decompiler.addToken(Token.LB);\n+        List<AstNode> elems = node.getElements();\n+        int size = elems.size();\n+        for (int i = 0; i < size; i++) {\n+            AstNode elem = elems.get(i);\n+            decompile(elem);\n+            if (i < size - 1) {\n+                decompiler.addToken(Token.COMMA);\n+            }\n+        }\n+        decompiler.addToken(Token.RB);\n+    }\n+\n+    // only used for destructuring forms\n+    void decompileObjectLiteral(ObjectLiteral node) {\n+        decompiler.addToken(Token.LC);\n+        List<ObjectProperty> props = node.getElements();\n+        int size = props.size();\n+        for (int i = 0; i < size; i++) {\n+            ObjectProperty prop = props.get(i);\n+            boolean destructuringShorthand =\n+                    Boolean.TRUE.equals(prop.getProp(Node.DESTRUCTURING_SHORTHAND));\n+            decompile(prop.getLeft());\n+            if (!destructuringShorthand) {\n+                decompiler.addToken(Token.COLON);\n+                decompile(prop.getRight());\n+            }\n+            if (i < size - 1) {\n+                decompiler.addToken(Token.COMMA);\n+            }\n+        }\n+        decompiler.addToken(Token.RC);\n+    }\n+\n+    // only used for destructuring forms\n+    void decompilePropertyGet(PropertyGet node) {\n+        decompile(node.getTarget());\n+        decompiler.addToken(Token.DOT);\n+        decompile(node.getProperty());\n+    }\n+\n+    // only used for destructuring forms\n+    void decompileElementGet(ElementGet node) {\n+        decompile(node.getTarget());\n+        decompiler.addToken(Token.LB);\n+        decompile(node.getElement());\n+        decompiler.addToken(Token.RB);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Icode.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Mike Ang\n+ *   Igor Bukanov\n+ *   Yuh-Ruey Chen\n+ *   Ethan Hugg\n+ *   Bob Jervis\n+ *   Terry Lucas\n+ *   Mike McCabe\n+ *   Milen Nankov\n+ *   Norris Boyd\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Additional interpreter-specific codes\n+ */\n+abstract class Icode {\n+\n+    static final int\n+\n+    // Stack: ... value1 -> ... value1 value1\n+        Icode_DUP                       = -1,\n+\n+    // Stack: ... value2 value1 -> ... value2 value1 value2 value1\n+        Icode_DUP2                      = -2,\n+\n+    // Stack: ... value2 value1 -> ... value1 value2\n+        Icode_SWAP                      = -3,\n+\n+    // Stack: ... value1 -> ...\n+        Icode_POP                       = -4,\n+\n+    // Store stack top into return register and then pop it\n+        Icode_POP_RESULT                = -5,\n+\n+    // To jump conditionally and pop additional stack value\n+        Icode_IFEQ_POP                  = -6,\n+\n+    // various types of ++/--\n+        Icode_VAR_INC_DEC               = -7,\n+        Icode_NAME_INC_DEC              = -8,\n+        Icode_PROP_INC_DEC              = -9,\n+        Icode_ELEM_INC_DEC              = -10,\n+        Icode_REF_INC_DEC               = -11,\n+\n+    // load/save scope from/to local\n+        Icode_SCOPE_LOAD                = -12,\n+        Icode_SCOPE_SAVE                = -13,\n+\n+        Icode_TYPEOFNAME                = -14,\n+\n+    // helper for function calls\n+        Icode_NAME_AND_THIS             = -15,\n+        Icode_PROP_AND_THIS             = -16,\n+        Icode_ELEM_AND_THIS             = -17,\n+        Icode_VALUE_AND_THIS            = -18,\n+\n+    // Create closure object for nested functions\n+        Icode_CLOSURE_EXPR              = -19,\n+        Icode_CLOSURE_STMT              = -20,\n+\n+    // Special calls\n+        Icode_CALLSPECIAL               = -21,\n+\n+    // To return undefined value\n+        Icode_RETUNDEF                  = -22,\n+\n+    // Exception handling implementation\n+        Icode_GOSUB                     = -23,\n+        Icode_STARTSUB                  = -24,\n+        Icode_RETSUB                    = -25,\n+\n+    // To indicating a line number change in icodes.\n+        Icode_LINE                      = -26,\n+\n+    // To store shorts and ints inline\n+        Icode_SHORTNUMBER               = -27,\n+        Icode_INTNUMBER                 = -28,\n+\n+    // To create and populate array to hold values for [] and {} literals\n+        Icode_LITERAL_NEW               = -29,\n+        Icode_LITERAL_SET               = -30,\n+\n+    // Array literal with skipped index like [1,,2]\n+        Icode_SPARE_ARRAYLIT            = -31,\n+\n+    // Load index register to prepare for the following index operation\n+        Icode_REG_IND_C0                = -32,\n+        Icode_REG_IND_C1                = -33,\n+        Icode_REG_IND_C2                = -34,\n+        Icode_REG_IND_C3                = -35,\n+        Icode_REG_IND_C4                = -36,\n+        Icode_REG_IND_C5                = -37,\n+        Icode_REG_IND1                  = -38,\n+        Icode_REG_IND2                  = -39,\n+        Icode_REG_IND4                  = -40,\n+\n+    // Load string register to prepare for the following string operation\n+        Icode_REG_STR_C0                = -41,\n+        Icode_REG_STR_C1                = -42,\n+        Icode_REG_STR_C2                = -43,\n+        Icode_REG_STR_C3                = -44,\n+        Icode_REG_STR1                  = -45,\n+        Icode_REG_STR2                  = -46,\n+        Icode_REG_STR4                  = -47,\n+\n+    // Version of getvar/setvar that read var index directly from bytecode\n+        Icode_GETVAR1                   = -48,\n+        Icode_SETVAR1                   = -49,\n+\n+    // Load unefined\n+        Icode_UNDEF                     = -50,\n+        Icode_ZERO                      = -51,\n+        Icode_ONE                       = -52,\n+\n+    // entrance and exit from .()\n+       Icode_ENTERDQ                    = -53,\n+       Icode_LEAVEDQ                    = -54,\n+\n+       Icode_TAIL_CALL                  = -55,\n+\n+    // Clear local to allow GC its context\n+       Icode_LOCAL_CLEAR                = -56,\n+\n+    // Literal get/set\n+       Icode_LITERAL_GETTER             = -57,\n+       Icode_LITERAL_SETTER             = -58,\n+\n+    // const\n+       Icode_SETCONST                   = -59,\n+       Icode_SETCONSTVAR                = -60,\n+       Icode_SETCONSTVAR1               = -61,\n+\n+    // Generator opcodes (along with Token.YIELD)\n+       Icode_GENERATOR                  = -62,\n+       Icode_GENERATOR_END              = -63,\n+\n+       Icode_DEBUGGER                   = -64,\n+\n+       // Last icode\n+        MIN_ICODE                       = -64;\n+\n+    static String bytecodeName(int bytecode)\n+    {\n+        if (!validBytecode(bytecode)) {\n+            throw new IllegalArgumentException(String.valueOf(bytecode));\n+        }\n+\n+        if (!Token.printICode) {\n+            return String.valueOf(bytecode);\n+        }\n+\n+        if (validTokenCode(bytecode)) {\n+            return Token.name(bytecode);\n+        }\n+\n+        switch (bytecode) {\n+          case Icode_DUP:              return \"DUP\";\n+          case Icode_DUP2:             return \"DUP2\";\n+          case Icode_SWAP:             return \"SWAP\";\n+          case Icode_POP:              return \"POP\";\n+          case Icode_POP_RESULT:       return \"POP_RESULT\";\n+          case Icode_IFEQ_POP:         return \"IFEQ_POP\";\n+          case Icode_VAR_INC_DEC:      return \"VAR_INC_DEC\";\n+          case Icode_NAME_INC_DEC:     return \"NAME_INC_DEC\";\n+          case Icode_PROP_INC_DEC:     return \"PROP_INC_DEC\";\n+          case Icode_ELEM_INC_DEC:     return \"ELEM_INC_DEC\";\n+          case Icode_REF_INC_DEC:      return \"REF_INC_DEC\";\n+          case Icode_SCOPE_LOAD:       return \"SCOPE_LOAD\";\n+          case Icode_SCOPE_SAVE:       return \"SCOPE_SAVE\";\n+          case Icode_TYPEOFNAME:       return \"TYPEOFNAME\";\n+          case Icode_NAME_AND_THIS:    return \"NAME_AND_THIS\";\n+          case Icode_PROP_AND_THIS:    return \"PROP_AND_THIS\";\n+          case Icode_ELEM_AND_THIS:    return \"ELEM_AND_THIS\";\n+          case Icode_VALUE_AND_THIS:   return \"VALUE_AND_THIS\";\n+          case Icode_CLOSURE_EXPR:     return \"CLOSURE_EXPR\";\n+          case Icode_CLOSURE_STMT:     return \"CLOSURE_STMT\";\n+          case Icode_CALLSPECIAL:      return \"CALLSPECIAL\";\n+          case Icode_RETUNDEF:         return \"RETUNDEF\";\n+          case Icode_GOSUB:            return \"GOSUB\";\n+          case Icode_STARTSUB:         return \"STARTSUB\";\n+          case Icode_RETSUB:           return \"RETSUB\";\n+          case Icode_LINE:             return \"LINE\";\n+          case Icode_SHORTNUMBER:      return \"SHORTNUMBER\";\n+          case Icode_INTNUMBER:        return \"INTNUMBER\";\n+          case Icode_LITERAL_NEW:      return \"LITERAL_NEW\";\n+          case Icode_LITERAL_SET:      return \"LITERAL_SET\";\n+          case Icode_SPARE_ARRAYLIT:   return \"SPARE_ARRAYLIT\";\n+          case Icode_REG_IND_C0:       return \"REG_IND_C0\";\n+          case Icode_REG_IND_C1:       return \"REG_IND_C1\";\n+          case Icode_REG_IND_C2:       return \"REG_IND_C2\";\n+          case Icode_REG_IND_C3:       return \"REG_IND_C3\";\n+          case Icode_REG_IND_C4:       return \"REG_IND_C4\";\n+          case Icode_REG_IND_C5:       return \"REG_IND_C5\";\n+          case Icode_REG_IND1:         return \"LOAD_IND1\";\n+          case Icode_REG_IND2:         return \"LOAD_IND2\";\n+          case Icode_REG_IND4:         return \"LOAD_IND4\";\n+          case Icode_REG_STR_C0:       return \"REG_STR_C0\";\n+          case Icode_REG_STR_C1:       return \"REG_STR_C1\";\n+          case Icode_REG_STR_C2:       return \"REG_STR_C2\";\n+          case Icode_REG_STR_C3:       return \"REG_STR_C3\";\n+          case Icode_REG_STR1:         return \"LOAD_STR1\";\n+          case Icode_REG_STR2:         return \"LOAD_STR2\";\n+          case Icode_REG_STR4:         return \"LOAD_STR4\";\n+          case Icode_GETVAR1:          return \"GETVAR1\";\n+          case Icode_SETVAR1:          return \"SETVAR1\";\n+          case Icode_UNDEF:            return \"UNDEF\";\n+          case Icode_ZERO:             return \"ZERO\";\n+          case Icode_ONE:              return \"ONE\";\n+          case Icode_ENTERDQ:          return \"ENTERDQ\";\n+          case Icode_LEAVEDQ:          return \"LEAVEDQ\";\n+          case Icode_TAIL_CALL:        return \"TAIL_CALL\";\n+          case Icode_LOCAL_CLEAR:      return \"LOCAL_CLEAR\";\n+          case Icode_LITERAL_GETTER:   return \"LITERAL_GETTER\";\n+          case Icode_LITERAL_SETTER:   return \"LITERAL_SETTER\";\n+          case Icode_SETCONST:         return \"SETCONST\";\n+          case Icode_SETCONSTVAR:      return \"SETCONSTVAR\";\n+          case Icode_SETCONSTVAR1:     return \"SETCONSTVAR1\";\n+          case Icode_GENERATOR:        return \"GENERATOR\";\n+          case Icode_GENERATOR_END:    return \"GENERATOR_END\";\n+          case Icode_DEBUGGER:         return \"DEBUGGER\";\n+        }\n+\n+        // icode without name\n+        throw new IllegalStateException(String.valueOf(bytecode));\n+    }\n+\n+    static boolean validIcode(int icode)\n+    {\n+        return MIN_ICODE <= icode && icode <= -1;\n+    }\n+\n+    static boolean validTokenCode(int token)\n+    {\n+        return Token.FIRST_BYTECODE_TOKEN <= token\n+               && token <= Token.LAST_BYTECODE_TOKEN;\n+    }\n+\n+    static boolean validBytecode(int bytecode)\n+    {\n+        return validIcode(bytecode) || validTokenCode(bytecode);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/IdFunctionCall.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Master for id-based functions that knows their properties and how to\n+ * execute them.\n+ */\n+public interface IdFunctionCall\n+{\n+    /**\n+     * 'thisObj' will be null if invoked as constructor, in which case\n+     * instance of Scriptable should be returned\n+     */\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args);\n+\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/IdFunctionObject.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+public class IdFunctionObject extends BaseFunction\n+{\n+\n+    static final long serialVersionUID = -5332312783643935019L;\n+\n+    public IdFunctionObject(IdFunctionCall idcall, Object tag, int id, int arity)\n+    {\n+        if (arity < 0)\n+            throw new IllegalArgumentException();\n+\n+        this.idcall = idcall;\n+        this.tag = tag;\n+        this.methodId = id;\n+        this.arity = arity;\n+        if (arity < 0) throw new IllegalArgumentException();\n+    }\n+\n+    public IdFunctionObject(IdFunctionCall idcall, Object tag, int id,\n+                            String name, int arity, Scriptable scope)\n+    {\n+        super(scope, null);\n+\n+        if (arity < 0)\n+            throw new IllegalArgumentException();\n+        if (name == null)\n+            throw new IllegalArgumentException();\n+\n+        this.idcall = idcall;\n+        this.tag = tag;\n+        this.methodId = id;\n+        this.arity = arity;\n+        this.functionName = name;\n+    }\n+\n+    public void initFunction(String name, Scriptable scope)\n+    {\n+        if (name == null) throw new IllegalArgumentException();\n+        if (scope == null) throw new IllegalArgumentException();\n+        this.functionName = name;\n+        setParentScope(scope);\n+    }\n+\n+    public final boolean hasTag(Object tag)\n+    {\n+        return this.tag == tag;\n+    }\n+\n+    public final int methodId()\n+    {\n+        return methodId;\n+    }\n+\n+    public final void markAsConstructor(Scriptable prototypeProperty)\n+    {\n+        useCallAsConstructor = true;\n+        setImmunePrototypeProperty(prototypeProperty);\n+    }\n+\n+    public final void addAsProperty(Scriptable target)\n+    {\n+        ScriptableObject.defineProperty(target, functionName, this,\n+                                        ScriptableObject.DONTENUM);\n+    }\n+\n+    public void exportAsScopeProperty()\n+    {\n+        addAsProperty(getParentScope());\n+    }\n+\n+    @Override\n+    public Scriptable getPrototype()\n+    {\n+        // Lazy initialization of prototype: for native functions this\n+        // may not be called at all\n+        Scriptable proto = super.getPrototype();\n+        if (proto == null) {\n+            proto = getFunctionPrototype(getParentScope());\n+            setPrototype(proto);\n+        }\n+        return proto;\n+    }\n+\n+    @Override\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        return idcall.execIdCall(this, cx, scope, thisObj, args);\n+    }\n+\n+    @Override\n+    public Scriptable createObject(Context cx, Scriptable scope)\n+    {\n+        if (useCallAsConstructor) {\n+            return null;\n+        }\n+        // Throw error if not explicitly coded to be used as constructor,\n+        // to satisfy ECMAScript standard (see bugzilla 202019).\n+        // To follow current (2003-05-01) SpiderMonkey behavior, change it to:\n+        // return super.createObject(cx, scope);\n+        throw ScriptRuntime.typeError1(\"msg.not.ctor\", functionName);\n+    }\n+\n+    @Override\n+    String decompile(int indent, int flags)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        boolean justbody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));\n+        if (!justbody) {\n+            sb.append(\"function \");\n+            sb.append(getFunctionName());\n+            sb.append(\"() { \");\n+        }\n+        sb.append(\"[native code for \");\n+        if (idcall instanceof Scriptable) {\n+            Scriptable sobj = (Scriptable)idcall;\n+            sb.append(sobj.getClassName());\n+            sb.append('.');\n+        }\n+        sb.append(getFunctionName());\n+        sb.append(\", arity=\");\n+        sb.append(getArity());\n+        sb.append(justbody ? \"]\\n\" : \"] }\\n\");\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public int getArity()\n+    {\n+        return arity;\n+    }\n+\n+    @Override\n+    public int getLength() { return getArity(); }\n+\n+    @Override\n+    public String getFunctionName()\n+    {\n+        return (functionName == null) ? \"\" : functionName;\n+    }\n+\n+    public final RuntimeException unknown()\n+    {\n+        // It is program error to call id-like methods for unknown function\n+        return new IllegalArgumentException(\n+            \"BAD FUNCTION ID=\"+methodId+\" MASTER=\"+idcall);\n+    }\n+\n+    private final IdFunctionCall idcall;\n+    private final Object tag;\n+    private final int methodId;\n+    private int arity;\n+    private boolean useCallAsConstructor;\n+    private String functionName;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/IdScriptableObject.java\n+/* -*- Mode: java; tab-width: 4; indent-tabs-mode: 1; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.*;\n+\n+/**\n+Base class for native object implementation that uses IdFunctionObject to export its methods to script via <class-name>.prototype object.\n+\n+Any descendant should implement at least the following methods:\n+    findInstanceIdInfo\n+    getInstanceIdName\n+    execIdCall\n+    methodArity\n+\n+To define non-function properties, the descendant should override\n+    getInstanceIdValue\n+    setInstanceIdValue\n+to get/set property value and provide its default attributes.\n+\n+\n+To customize initialization of constructor and prototype objects, descendant\n+may override scopeInit or fillConstructorProperties methods.\n+\n+*/\n+public abstract class IdScriptableObject extends ScriptableObject\n+    implements IdFunctionCall\n+{\n+    private transient volatile PrototypeValues prototypeValues;\n+\n+    private static final class PrototypeValues implements Serializable\n+    {\n+        static final long serialVersionUID = 3038645279153854371L;\n+\n+        private static final int VALUE_SLOT = 0;\n+        private static final int NAME_SLOT = 1;\n+        private static final int SLOT_SPAN = 2;\n+\n+        private IdScriptableObject obj;\n+        private int maxId;\n+        private volatile Object[] valueArray;\n+        private volatile short[] attributeArray;\n+        private volatile int lastFoundId = 1;\n+\n+        // The following helps to avoid creation of valueArray during runtime\n+        // initialization for common case of \"constructor\" property\n+        int constructorId;\n+        private IdFunctionObject constructor;\n+        private short constructorAttrs;\n+\n+        PrototypeValues(IdScriptableObject obj, int maxId)\n+        {\n+            if (obj == null) throw new IllegalArgumentException();\n+            if (maxId < 1) throw new IllegalArgumentException();\n+            this.obj = obj;\n+            this.maxId = maxId;\n+        }\n+\n+        final int getMaxId()\n+        {\n+            return maxId;\n+        }\n+\n+        final void initValue(int id, String name, Object value, int attributes)\n+        {\n+            if (!(1 <= id && id <= maxId))\n+                throw new IllegalArgumentException();\n+            if (name == null)\n+                throw new IllegalArgumentException();\n+            if (value == NOT_FOUND)\n+                throw new IllegalArgumentException();\n+            ScriptableObject.checkValidAttributes(attributes);\n+            if (obj.findPrototypeId(name) != id)\n+                throw new IllegalArgumentException(name);\n+\n+            if (id == constructorId) {\n+                if (!(value instanceof IdFunctionObject)) {\n+                    throw new IllegalArgumentException(\"consructor should be initialized with IdFunctionObject\");\n+                }\n+                constructor = (IdFunctionObject)value;\n+                constructorAttrs = (short)attributes;\n+                return;\n+            }\n+\n+            initSlot(id, name, value, attributes);\n+        }\n+\n+        private void initSlot(int id, String name, Object value,\n+                              int attributes)\n+        {\n+            Object[] array = valueArray;\n+            if (array == null)\n+                throw new IllegalStateException();\n+\n+            if (value == null) {\n+                value = UniqueTag.NULL_VALUE;\n+            }\n+            int index = (id - 1) * SLOT_SPAN;\n+            synchronized (this) {\n+                Object value2 = array[index + VALUE_SLOT];\n+                if (value2 == null) {\n+                    array[index + VALUE_SLOT] = value;\n+                    array[index + NAME_SLOT] = name;\n+                    attributeArray[id - 1] = (short)attributes;\n+                } else {\n+                    if (!name.equals(array[index + NAME_SLOT]))\n+                         throw new IllegalStateException();\n+                }\n+            }\n+        }\n+\n+        final IdFunctionObject createPrecachedConstructor()\n+        {\n+            if (constructorId != 0) throw new IllegalStateException();\n+            constructorId = obj.findPrototypeId(\"constructor\");\n+            if (constructorId == 0) {\n+                throw new IllegalStateException(\n+                    \"No id for constructor property\");\n+            }\n+            obj.initPrototypeId(constructorId);\n+            if (constructor == null) {\n+                throw new IllegalStateException(\n+                    obj.getClass().getName()+\".initPrototypeId() did not \"\n+                    +\"initialize id=\"+constructorId);\n+            }\n+            constructor.initFunction(obj.getClassName(),\n+                                     ScriptableObject.getTopLevelScope(obj));\n+            constructor.markAsConstructor(obj);\n+            return constructor;\n+        }\n+\n+        final int findId(String name)\n+        {\n+            Object[] array = valueArray;\n+            if (array == null) {\n+                return obj.findPrototypeId(name);\n+            }\n+            int id = lastFoundId;\n+            if (name == array[(id - 1) * SLOT_SPAN + NAME_SLOT]) {\n+                return id;\n+            }\n+            id = obj.findPrototypeId(name);\n+            if (id != 0) {\n+                int nameSlot = (id - 1) * SLOT_SPAN + NAME_SLOT;\n+                // Make cache to work!\n+                array[nameSlot] = name;\n+                lastFoundId = id;\n+            }\n+            return id;\n+        }\n+\n+        final boolean has(int id)\n+        {\n+            Object[] array = valueArray;\n+            if (array == null) {\n+                // Not yet initialized, assume all exists\n+                return true;\n+            }\n+            int valueSlot = (id  - 1) * SLOT_SPAN + VALUE_SLOT;\n+            Object value = array[valueSlot];\n+            if (value == null) {\n+                // The particular entry has not been yet initialized\n+                return true;\n+            }\n+            return value != NOT_FOUND;\n+        }\n+\n+        final Object get(int id)\n+        {\n+            Object value = ensureId(id);\n+            if (value == UniqueTag.NULL_VALUE) {\n+                value = null;\n+            }\n+            return value;\n+        }\n+\n+        final void set(int id, Scriptable start, Object value)\n+        {\n+            if (value == NOT_FOUND) throw new IllegalArgumentException();\n+            ensureId(id);\n+            int attr = attributeArray[id - 1];\n+            if ((attr & READONLY) == 0) {\n+                if (start == obj) {\n+                    if (value == null) {\n+                        value = UniqueTag.NULL_VALUE;\n+                    }\n+                    int valueSlot = (id  - 1) * SLOT_SPAN + VALUE_SLOT;\n+                    synchronized (this) {\n+                        valueArray[valueSlot] = value;\n+                    }\n+                }\n+                else {\n+                    int nameSlot = (id  - 1) * SLOT_SPAN + NAME_SLOT;\n+                    String name = (String)valueArray[nameSlot];\n+                    start.put(name, start, value);\n+                }\n+            }\n+        }\n+\n+        final void delete(int id)\n+        {\n+            ensureId(id);\n+            int attr = attributeArray[id - 1];\n+            if ((attr & PERMANENT) == 0) {\n+                int valueSlot = (id  - 1) * SLOT_SPAN + VALUE_SLOT;\n+                synchronized (this) {\n+                    valueArray[valueSlot] = NOT_FOUND;\n+                    attributeArray[id - 1] = EMPTY;\n+                }\n+            }\n+        }\n+\n+        final int getAttributes(int id)\n+        {\n+            ensureId(id);\n+            return attributeArray[id - 1];\n+        }\n+\n+        final void setAttributes(int id, int attributes)\n+        {\n+            ScriptableObject.checkValidAttributes(attributes);\n+            ensureId(id);\n+            synchronized (this) {\n+                attributeArray[id - 1] = (short)attributes;\n+            }\n+        }\n+\n+        final Object[] getNames(boolean getAll, Object[] extraEntries)\n+        {\n+            Object[] names = null;\n+            int count = 0;\n+            for (int id = 1; id <= maxId; ++id) {\n+                Object value = ensureId(id);\n+                if (getAll || (attributeArray[id - 1] & DONTENUM) == 0) {\n+                    if (value != NOT_FOUND) {\n+                        int nameSlot = (id  - 1) * SLOT_SPAN + NAME_SLOT;\n+                        String name = (String)valueArray[nameSlot];\n+                        if (names == null) {\n+                            names = new Object[maxId];\n+                        }\n+                        names[count++] = name;\n+                    }\n+                }\n+            }\n+            if (count == 0) {\n+                return extraEntries;\n+            } else if (extraEntries == null || extraEntries.length == 0) {\n+                if (count != names.length) {\n+                    Object[] tmp = new Object[count];\n+                    System.arraycopy(names, 0, tmp, 0, count);\n+                    names = tmp;\n+                }\n+                return names;\n+            } else {\n+                int extra = extraEntries.length;\n+                Object[] tmp = new Object[extra + count];\n+                System.arraycopy(extraEntries, 0, tmp, 0, extra);\n+                System.arraycopy(names, 0, tmp, extra, count);\n+                return tmp;\n+            }\n+        }\n+\n+        private Object ensureId(int id)\n+        {\n+            Object[] array = valueArray;\n+            if (array == null) {\n+                synchronized (this) {\n+                    array = valueArray;\n+                    if (array == null) {\n+                        array = new Object[maxId * SLOT_SPAN];\n+                        valueArray = array;\n+                        attributeArray = new short[maxId];\n+                    }\n+                }\n+            }\n+            int valueSlot = (id  - 1) * SLOT_SPAN + VALUE_SLOT;\n+            Object value = array[valueSlot];\n+            if (value == null) {\n+                if (id == constructorId) {\n+                    initSlot(constructorId, \"constructor\",\n+                             constructor, constructorAttrs);\n+                    constructor = null; // no need to refer it any longer\n+                } else {\n+                    obj.initPrototypeId(id);\n+                }\n+                value = array[valueSlot];\n+                if (value == null) {\n+                    throw new IllegalStateException(\n+                        obj.getClass().getName()+\".initPrototypeId(int id) \"\n+                        +\"did not initialize id=\"+id);\n+                }\n+            }\n+            return value;\n+        }\n+    }\n+\n+    public IdScriptableObject()\n+    {\n+    }\n+\n+    public IdScriptableObject(Scriptable scope, Scriptable prototype)\n+    {\n+        super(scope, prototype);\n+    }\n+\n+    protected final Object defaultGet(String name)\n+    {\n+        return super.get(name, this);\n+    }\n+\n+    protected final void defaultPut(String name, Object value)\n+    {\n+        super.put(name, this, value);\n+    }\n+\n+    @Override\n+    public boolean has(String name, Scriptable start)\n+    {\n+        int info = findInstanceIdInfo(name);\n+        if (info != 0) {\n+            int attr = (info >>> 16);\n+            if ((attr & PERMANENT) != 0) {\n+                return true;\n+            }\n+            int id = (info & 0xFFFF);\n+            return NOT_FOUND != getInstanceIdValue(id);\n+        }\n+        if (prototypeValues != null) {\n+            int id = prototypeValues.findId(name);\n+            if (id != 0) {\n+                return prototypeValues.has(id);\n+            }\n+        }\n+        return super.has(name, start);\n+    }\n+\n+    @Override\n+    public Object get(String name, Scriptable start)\n+    {\n+        int info = findInstanceIdInfo(name);\n+        if (info != 0) {\n+            int id = (info & 0xFFFF);\n+            Object value = getInstanceIdValue(id);\n+            if (value != NOT_FOUND) return value;\n+        }\n+        if (prototypeValues != null) {\n+            int id = prototypeValues.findId(name);\n+            if (id != 0) {\n+                Object value = prototypeValues.get(id);\n+                if (value != NOT_FOUND) return value;\n+            }\n+        }\n+        return super.get(name, start);\n+    }\n+\n+    @Override\n+    public void put(String name, Scriptable start, Object value)\n+    {\n+        int info = findInstanceIdInfo(name);\n+        if (info != 0) {\n+            if (start == this && isSealed()) {\n+                throw Context.reportRuntimeError1(\"msg.modify.sealed\",\n+                                                  name);\n+            }\n+            int attr = (info >>> 16);\n+            if ((attr & READONLY) == 0) {\n+                if (start == this) {\n+                    int id = (info & 0xFFFF);\n+                    setInstanceIdValue(id, value);\n+                }\n+                else {\n+                    start.put(name, start, value);\n+                }\n+            }\n+            return;\n+        }\n+        if (prototypeValues != null) {\n+            int id = prototypeValues.findId(name);\n+            if (id != 0) {\n+                if (start == this && isSealed()) {\n+                    throw Context.reportRuntimeError1(\"msg.modify.sealed\",\n+                                                      name);\n+                }\n+                prototypeValues.set(id, start, value);\n+                return;\n+            }\n+        }\n+        super.put(name, start, value);\n+    }\n+\n+    @Override\n+    public void delete(String name)\n+    {\n+        int info = findInstanceIdInfo(name);\n+        if (info != 0) {\n+            // Let the super class to throw exceptions for sealed objects\n+            if (!isSealed()) {\n+                int attr = (info >>> 16);\n+                if ((attr & PERMANENT) == 0) {\n+                    int id = (info & 0xFFFF);\n+                    setInstanceIdValue(id, NOT_FOUND);\n+                }\n+                return;\n+            }\n+        }\n+        if (prototypeValues != null) {\n+            int id = prototypeValues.findId(name);\n+            if (id != 0) {\n+                if (!isSealed()) {\n+                    prototypeValues.delete(id);\n+                }\n+                return;\n+            }\n+        }\n+        super.delete(name);\n+    }\n+\n+    @Override\n+    public int getAttributes(String name)\n+    {\n+        int info = findInstanceIdInfo(name);\n+        if (info != 0) {\n+            int attr = (info >>> 16);\n+            return attr;\n+        }\n+        if (prototypeValues != null) {\n+            int id = prototypeValues.findId(name);\n+            if (id != 0) {\n+                return prototypeValues.getAttributes(id);\n+            }\n+        }\n+        return super.getAttributes(name);\n+    }\n+\n+    @Override\n+    public void setAttributes(String name, int attributes)\n+    {\n+        ScriptableObject.checkValidAttributes(attributes);\n+        int info = findInstanceIdInfo(name);\n+        if (info != 0) {\n+            int currentAttributes = (info >>> 16);\n+            if (attributes != currentAttributes) {\n+                throw new RuntimeException(\n+                    \"Change of attributes for this id is not supported\");\n+            }\n+            return;\n+        }\n+        if (prototypeValues != null) {\n+            int id = prototypeValues.findId(name);\n+            if (id != 0) {\n+                prototypeValues.setAttributes(id, attributes);\n+                return;\n+            }\n+        }\n+        super.setAttributes(name, attributes);\n+    }\n+\n+    @Override\n+    Object[] getIds(boolean getAll)\n+    {\n+        Object[] result = super.getIds(getAll);\n+\n+        if (prototypeValues != null) {\n+            result = prototypeValues.getNames(getAll, result);\n+        }\n+\n+        int maxInstanceId = getMaxInstanceId();\n+        if (maxInstanceId != 0) {\n+            Object[] ids = null;\n+            int count = 0;\n+\n+            for (int id = maxInstanceId; id != 0; --id) {\n+                String name = getInstanceIdName(id);\n+                int info = findInstanceIdInfo(name);\n+                if (info != 0) {\n+                    int attr = (info >>> 16);\n+                    if ((attr & PERMANENT) == 0) {\n+                        if (NOT_FOUND == getInstanceIdValue(id)) {\n+                            continue;\n+                        }\n+                    }\n+                    if (getAll || (attr & DONTENUM) == 0) {\n+                        if (count == 0) {\n+                            // Need extra room for no more then [1..id] names\n+                            ids = new Object[id];\n+                        }\n+                        ids[count++] = name;\n+                    }\n+                }\n+            }\n+            if (count != 0) {\n+                if (result.length == 0 && ids.length == count) {\n+                    result = ids;\n+                }\n+                else {\n+                    Object[] tmp = new Object[result.length + count];\n+                    System.arraycopy(result, 0, tmp, 0, result.length);\n+                    System.arraycopy(ids, 0, tmp, result.length, count);\n+                    result = tmp;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get maximum id findInstanceIdInfo can generate.\n+     */\n+    protected int getMaxInstanceId()\n+    {\n+        return 0;\n+    }\n+\n+    protected static int instanceIdInfo(int attributes, int id)\n+    {\n+        return (attributes << 16) | id;\n+    }\n+\n+    /**\n+     * Map name to id of instance property.\n+     * Should return 0 if not found or the result of\n+     * {@link #instanceIdInfo(int, int)}.\n+     */\n+    protected int findInstanceIdInfo(String name)\n+    {\n+        return 0;\n+    }\n+\n+    /** Map id back to property name it defines.\n+     */\n+    protected String getInstanceIdName(int id)\n+    {\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    /** Get id value.\n+     ** If id value is constant, descendant can call cacheIdValue to store\n+     ** value in the permanent cache.\n+     ** Default implementation creates IdFunctionObject instance for given id\n+     ** and cache its value\n+     */\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        throw new IllegalStateException(String.valueOf(id));\n+    }\n+\n+    /**\n+     * Set or delete id value. If value == NOT_FOUND , the implementation\n+     * should make sure that the following getInstanceIdValue return NOT_FOUND.\n+     */\n+    protected void setInstanceIdValue(int id, Object value)\n+    {\n+        throw new IllegalStateException(String.valueOf(id));\n+    }\n+\n+    /** 'thisObj' will be null if invoked as constructor, in which case\n+     ** instance of Scriptable should be returned. */\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        throw f.unknown();\n+    }\n+\n+    public final IdFunctionObject exportAsJSClass(int maxPrototypeId,\n+                                                  Scriptable scope,\n+                                                  boolean sealed)\n+    {\n+        // Set scope and prototype unless this is top level scope itself\n+        if (scope != this && scope != null) {\n+            setParentScope(scope);\n+            setPrototype(getObjectPrototype(scope));\n+        }\n+\n+        activatePrototypeMap(maxPrototypeId);\n+        IdFunctionObject ctor = prototypeValues.createPrecachedConstructor();\n+        if (sealed) {\n+            sealObject();\n+        }\n+        fillConstructorProperties(ctor);\n+        if (sealed) {\n+            ctor.sealObject();\n+        }\n+        ctor.exportAsScopeProperty();\n+        return ctor;\n+    }\n+\n+    public final boolean hasPrototypeMap()\n+    {\n+        return prototypeValues != null;\n+    }\n+\n+    public final void activatePrototypeMap(int maxPrototypeId)\n+    {\n+        PrototypeValues values = new PrototypeValues(this, maxPrototypeId);\n+        synchronized (this) {\n+            if (prototypeValues != null)\n+                throw new IllegalStateException();\n+            prototypeValues = values;\n+        }\n+    }\n+\n+    public final void initPrototypeMethod(Object tag, int id, String name,\n+                                          int arity)\n+    {\n+        Scriptable scope = ScriptableObject.getTopLevelScope(this);\n+        IdFunctionObject f = newIdFunction(tag, id, name, arity, scope);\n+        prototypeValues.initValue(id, name, f, DONTENUM);\n+    }\n+\n+    public final void initPrototypeConstructor(IdFunctionObject f)\n+    {\n+        int id = prototypeValues.constructorId;\n+        if (id == 0)\n+            throw new IllegalStateException();\n+        if (f.methodId() != id)\n+            throw new IllegalArgumentException();\n+        if (isSealed()) { f.sealObject(); }\n+        prototypeValues.initValue(id, \"constructor\", f, DONTENUM);\n+    }\n+\n+    public final void initPrototypeValue(int id, String name, Object value,\n+                                         int attributes)\n+    {\n+        prototypeValues.initValue(id, name, value, attributes);\n+    }\n+\n+    protected void initPrototypeId(int id)\n+    {\n+        throw new IllegalStateException(String.valueOf(id));\n+    }\n+\n+    protected int findPrototypeId(String name)\n+    {\n+        throw new IllegalStateException(name);\n+    }\n+\n+    protected void fillConstructorProperties(IdFunctionObject ctor)\n+    {\n+    }\n+\n+    protected void addIdFunctionProperty(Scriptable obj, Object tag, int id,\n+                                         String name, int arity)\n+    {\n+        Scriptable scope = ScriptableObject.getTopLevelScope(obj);\n+        IdFunctionObject f = newIdFunction(tag, id, name, arity, scope);\n+        f.addAsProperty(obj);\n+    }\n+\n+    /**\n+     * Utility method to construct type error to indicate incompatible call\n+     * when converting script thisObj to a particular type is not possible.\n+     * Possible usage would be to have a private function like realThis:\n+     * <pre>\n+     *  private static NativeSomething realThis(Scriptable thisObj,\n+     *                                          IdFunctionObject f)\n+     *  {\n+     *      if (!(thisObj instanceof NativeSomething))\n+     *          throw incompatibleCallError(f);\n+     *      return (NativeSomething)thisObj;\n+     * }\n+     * </pre>\n+     * Note that although such function can be implemented universally via\n+     * java.lang.Class.isInstance(), it would be much more slower.\n+     * @param f function that is attempting to convert 'this'\n+     * object.\n+     * @return Scriptable object suitable for a check by the instanceof\n+     * operator.\n+     * @throws RuntimeException if no more instanceof target can be found\n+     */\n+    protected static EcmaError incompatibleCallError(IdFunctionObject f)\n+    {\n+        throw ScriptRuntime.typeError1(\"msg.incompat.call\",\n+                                       f.getFunctionName());\n+    }\n+\n+    private IdFunctionObject newIdFunction(Object tag, int id, String name,\n+                                           int arity, Scriptable scope)\n+    {\n+        IdFunctionObject f = new IdFunctionObject(this, tag, id, name, arity,\n+                                                  scope);\n+        if (isSealed()) { f.sealObject(); }\n+        return f;\n+    }\n+\n+    @Override\n+    public void defineOwnProperty(Context cx, Object key, ScriptableObject desc) {\n+      if (key instanceof String) {\n+        String name = (String) key;\n+        int info = findInstanceIdInfo(name);\n+        if (info != 0) {\n+            int id = (info & 0xFFFF);\n+            if (isAccessorDescriptor(desc)) {\n+              delete(id); // it will be replaced with a slot\n+            } else {\n+              int attr = (info >>> 16);\n+              Object value = getProperty(desc, \"value\");\n+              setInstanceIdValue(id, value == NOT_FOUND ? Undefined.instance : value);\n+              setAttributes(id, applyDescriptorToAttributeBitset(attr, desc));\n+              return;\n+            }\n+        }\n+        if (prototypeValues != null) {\n+            int id = prototypeValues.findId(name);\n+            if (id != 0) {\n+              if (isAccessorDescriptor(desc)) {\n+                prototypeValues.delete(id); // it will be replaced with a slot\n+              } else {\n+                int attr = prototypeValues.getAttributes(id);\n+                Object value = getProperty(desc, \"value\");\n+                prototypeValues.set(id, this, value == NOT_FOUND ? Undefined.instance : value);\n+                prototypeValues.setAttributes(id, applyDescriptorToAttributeBitset(attr, desc));\n+                return;\n+              }\n+            }\n+        }\n+      }\n+      super.defineOwnProperty(cx, key, desc);\n+    }\n+\n+\n+    @Override\n+    protected ScriptableObject getOwnPropertyDescriptor(Context cx, Object id) {\n+      ScriptableObject desc = super.getOwnPropertyDescriptor(cx, id);\n+      if (desc == null && id instanceof String) {\n+        desc = getBuiltInDescriptor((String) id);\n+      }\n+      return desc;\n+    }\n+\n+    private ScriptableObject getBuiltInDescriptor(String name) {\n+      Object value = null;\n+      int attr = EMPTY;\n+\n+      Scriptable scope = getParentScope();\n+      if (scope == null) {\n+        scope = this;\n+      }\n+\n+      int info = findInstanceIdInfo(name);\n+      if (info != 0) {\n+        int id = (info & 0xFFFF);\n+        value = getInstanceIdValue(id);\n+        attr = (info >>> 16);\n+        return buildDataDescriptor(scope, value, attr);\n+      } \n+      if (prototypeValues != null) {\n+        int id = prototypeValues.findId(name);\n+        if (id != 0) {\n+          value = prototypeValues.get(id);\n+          attr = prototypeValues.getAttributes(id);\n+          return buildDataDescriptor(scope, value, attr);\n+        }\n+      }\n+      return null;\n+    }\n+\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException\n+    {\n+        stream.defaultReadObject();\n+        int maxPrototypeId = stream.readInt();\n+        if (maxPrototypeId != 0) {\n+            activatePrototypeMap(maxPrototypeId);\n+        }\n+    }\n+\n+    private void writeObject(ObjectOutputStream stream)\n+        throws IOException\n+    {\n+        stream.defaultWriteObject();\n+        int maxPrototypeId = 0;\n+        if (prototypeValues != null) {\n+            maxPrototypeId = prototypeValues.getMaxId();\n+        }\n+        stream.writeInt(maxPrototypeId);\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ImporterTopLevel.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Matthias Radestock\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Class ImporterTopLevel\n+ *\n+ * This class defines a ScriptableObject that can be instantiated\n+ * as a top-level (\"global\") object to provide functionality similar\n+ * to Java's \"import\" statement.\n+ * <p>\n+ * This class can be used to create a top-level scope using the following code:\n+ * <pre>\n+ *  Scriptable scope = new ImporterTopLevel(cx);\n+ * </pre>\n+ * Then JavaScript code will have access to the following methods:\n+ * <ul>\n+ * <li>importClass - will \"import\" a class by making its unqualified name\n+ *                   available as a property of the top-level scope\n+ * <li>importPackage - will \"import\" all the classes of the package by\n+ *                     searching for unqualified names as classes qualified\n+ *                     by the given package.\n+ * </ul>\n+ * The following code from the shell illustrates this use:\n+ * <pre>\n+ * js> importClass(java.io.File)\n+ * js> f = new File('help.txt')\n+ * help.txt\n+ * js> importPackage(java.util)\n+ * js> v = new Vector()\n+ * []\n+ *\n+ */\n+public class ImporterTopLevel extends IdScriptableObject\n+{\n+    static final long serialVersionUID = -9095380847465315412L;\n+\n+    private static final Object IMPORTER_TAG = \"Importer\";\n+\n+    public ImporterTopLevel() { }\n+\n+    public ImporterTopLevel(Context cx) {\n+        this(cx, false);\n+    }\n+\n+    public ImporterTopLevel(Context cx, boolean sealed)\n+    {\n+        initStandardObjects(cx, sealed);\n+    }\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return (topScopeFlag) ? \"global\" : \"JavaImporter\";\n+    }\n+\n+    public static void init(Context cx, Scriptable scope, boolean sealed)\n+    {\n+        ImporterTopLevel obj = new ImporterTopLevel();\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    public void initStandardObjects(Context cx, boolean sealed)\n+    {\n+        // Assume that Context.initStandardObjects initialize JavaImporter\n+        // property lazily so the above init call is not yet called\n+        cx.initStandardObjects(this, sealed);\n+        topScopeFlag = true;\n+        // If seal is true then exportAsJSClass(cx, seal) would seal\n+        // this obj. Since this is scope as well, it would not allow\n+        // to add variables.\n+        IdFunctionObject ctor = exportAsJSClass(MAX_PROTOTYPE_ID, this, false);\n+        if (sealed) {\n+            ctor.sealObject();\n+        }\n+        // delete \"constructor\" defined by exportAsJSClass so \"constructor\"\n+        // name would refer to Object.constructor\n+        // and not to JavaImporter.prototype.constructor.\n+        delete(\"constructor\");\n+    }\n+\n+    @Override\n+    public boolean has(String name, Scriptable start) {\n+        return super.has(name, start)\n+               || getPackageProperty(name, start) != NOT_FOUND;\n+    }\n+\n+    @Override\n+    public Object get(String name, Scriptable start) {\n+        Object result = super.get(name, start);\n+        if (result != NOT_FOUND)\n+            return result;\n+        result = getPackageProperty(name, start);\n+        return result;\n+    }\n+\n+    private Object getPackageProperty(String name, Scriptable start) {\n+        Object result = NOT_FOUND;\n+        Object[] elements;\n+        synchronized (importedPackages) {\n+            elements = importedPackages.toArray();\n+        }\n+        for (int i=0; i < elements.length; i++) {\n+            NativeJavaPackage p = (NativeJavaPackage) elements[i];\n+            Object v = p.getPkgProperty(name, start, false);\n+            if (v != null && !(v instanceof NativeJavaPackage)) {\n+                if (result == NOT_FOUND) {\n+                    result = v;\n+                } else {\n+                    throw Context.reportRuntimeError2(\n+                        \"msg.ambig.import\", result.toString(), v.toString());\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * @deprecated Kept only for compatibility.\n+     */\n+    public void importPackage(Context cx, Scriptable thisObj, Object[] args,\n+                              Function funObj)\n+    {\n+        js_importPackage(args);\n+    }\n+\n+    private Object js_construct(Scriptable scope, Object[] args)\n+    {\n+        ImporterTopLevel result = new ImporterTopLevel();\n+        for (int i = 0; i != args.length; ++i) {\n+            Object arg = args[i];\n+            if (arg instanceof NativeJavaClass) {\n+                result.importClass((NativeJavaClass)arg);\n+            } else if (arg instanceof NativeJavaPackage) {\n+                result.importPackage((NativeJavaPackage)arg);\n+            } else {\n+                throw Context.reportRuntimeError1(\n+                    \"msg.not.class.not.pkg\", Context.toString(arg));\n+            }\n+        }\n+        // set explicitly prototype and scope\n+        // as otherwise in top scope mode BaseFunction.construct\n+        // would keep them set to null. It also allow to use\n+        // JavaImporter without new and still get properly\n+        // initialized object.\n+        result.setParentScope(scope);\n+        result.setPrototype(this);\n+        return result;\n+    }\n+\n+    private Object js_importClass(Object[] args)\n+    {\n+        for (int i = 0; i != args.length; i++) {\n+            Object arg = args[i];\n+            if (!(arg instanceof NativeJavaClass)) {\n+                throw Context.reportRuntimeError1(\n+                    \"msg.not.class\", Context.toString(arg));\n+            }\n+            importClass((NativeJavaClass)arg);\n+        }\n+        return Undefined.instance;\n+    }\n+\n+    private Object js_importPackage(Object[] args)\n+    {\n+        for (int i = 0; i != args.length; i++) {\n+            Object arg = args[i];\n+            if (!(arg instanceof NativeJavaPackage)) {\n+                throw Context.reportRuntimeError1(\n+                    \"msg.not.pkg\", Context.toString(arg));\n+            }\n+            importPackage((NativeJavaPackage)arg);\n+        }\n+        return Undefined.instance;\n+    }\n+\n+    private void importPackage(NativeJavaPackage pkg)\n+    {\n+        if(pkg == null) {\n+            return;\n+        }\n+        synchronized (importedPackages) {\n+            for (int j = 0; j != importedPackages.size(); j++) {\n+                if (pkg.equals(importedPackages.get(j))) {\n+                    return;\n+                }\n+            }\n+            importedPackages.add(pkg);\n+        }\n+    }\n+\n+    private void importClass(NativeJavaClass cl)\n+    {\n+        String s = cl.getClassObject().getName();\n+        String n = s.substring(s.lastIndexOf('.')+1);\n+        Object val = get(n, this);\n+        if (val != NOT_FOUND && val != cl) {\n+            throw Context.reportRuntimeError1(\"msg.prop.defined\", n);\n+        }\n+        //defineProperty(n, cl, DONTENUM);\n+        put(n, this, cl);\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor:   arity=0; s=\"constructor\";   break;\n+          case Id_importClass:   arity=1; s=\"importClass\";   break;\n+          case Id_importPackage: arity=1; s=\"importPackage\"; break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(IMPORTER_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(IMPORTER_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_constructor:\n+            return js_construct(scope, args);\n+\n+          case Id_importClass:\n+            return realThis(thisObj, f).js_importClass(args);\n+\n+          case Id_importPackage:\n+            return realThis(thisObj, f).js_importPackage(args);\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private ImporterTopLevel realThis(Scriptable thisObj, IdFunctionObject f)\n+    {\n+        if (topScopeFlag) {\n+            // when used as top scope importPackage and importClass are global\n+            // function that ignore thisObj\n+            return this;\n+        }\n+        if (!(thisObj instanceof ImporterTopLevel))\n+            throw incompatibleCallError(f);\n+        return (ImporterTopLevel)thisObj;\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-05-09 08:15:24 EDT\n+        L0: { id = 0; String X = null; int c;\n+            int s_length = s.length();\n+            if (s_length==11) {\n+                c=s.charAt(0);\n+                if (c=='c') { X=\"constructor\";id=Id_constructor; }\n+                else if (c=='i') { X=\"importClass\";id=Id_importClass; }\n+            }\n+            else if (s_length==13) { X=\"importPackage\";id=Id_importPackage; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_constructor          = 1,\n+        Id_importClass          = 2,\n+        Id_importPackage        = 3,\n+        MAX_PROTOTYPE_ID        = 3;\n+\n+// #/string_id_map#\n+\n+    private ObjArray importedPackages = new ObjArray();\n+    private boolean topScopeFlag;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/InterfaceAdapter.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Adapter to use JS function as implementation of Java interfaces with\n+ * single method or multiple methods with the same signature.\n+ */\n+public class InterfaceAdapter\n+{\n+    private final Object proxyHelper;\n+\n+    /**\n+     * Make glue object implementing interface cl that will\n+     * call the supplied JS function when called.\n+     * Only interfaces were all methods have the same signature is supported.\n+     *\n+     * @return The glue object or null if <tt>cl</tt> is not interface or\n+     *         has methods with different signatures.\n+     */\n+    static Object create(Context cx, Class<?> cl, Callable function)\n+    {\n+        if (!cl.isInterface()) throw new IllegalArgumentException();\n+\n+        Scriptable topScope = ScriptRuntime.getTopCallScope(cx);\n+        ClassCache cache = ClassCache.get(topScope);\n+        InterfaceAdapter adapter;\n+        adapter = (InterfaceAdapter)cache.getInterfaceAdapter(cl);\n+        ContextFactory cf = cx.getFactory();\n+        if (adapter == null) {\n+            Method[] methods = cl.getMethods();\n+            if (methods.length == 0) {\n+                throw Context.reportRuntimeError2(\n+                    \"msg.no.empty.interface.conversion\",\n+                    String.valueOf(function),\n+                    cl.getClass().getName());\n+            }\n+            boolean canCallFunction = false;\n+          canCallFunctionChecks: {\n+                Class<?>[] argTypes = methods[0].getParameterTypes();\n+                // check that the rest of methods has the same signature\n+                for (int i = 1; i != methods.length; ++i) {\n+                    Class<?>[] types2 = methods[i].getParameterTypes();\n+                    if (types2.length != argTypes.length) {\n+                        break canCallFunctionChecks;\n+                    }\n+                    for (int j = 0; j != argTypes.length; ++j) {\n+                        if (types2[j] != argTypes[j]) {\n+                            break canCallFunctionChecks;\n+                        }\n+                    }\n+                }\n+                canCallFunction= true;\n+            }\n+            if (!canCallFunction) {\n+                throw Context.reportRuntimeError2(\n+                    \"msg.no.function.interface.conversion\",\n+                    String.valueOf(function),\n+                    cl.getClass().getName());\n+            }\n+            adapter = new InterfaceAdapter(cf, cl);\n+            cache.cacheInterfaceAdapter(cl, adapter);\n+        }\n+        return VMBridge.instance.newInterfaceProxy(\n+            adapter.proxyHelper, cf, adapter, function, topScope);\n+    }\n+\n+    private InterfaceAdapter(ContextFactory cf, Class<?> cl)\n+    {\n+        this.proxyHelper\n+            = VMBridge.instance.getInterfaceProxyHelper(\n+                cf, new Class[] { cl });\n+    }\n+\n+    public Object invoke(ContextFactory cf,\n+                         final Object target,\n+                         final Scriptable topScope,\n+                         final Method method,\n+                         final Object[] args)\n+    {\n+        ContextAction action = new ContextAction() {\n+                public Object run(Context cx)\n+                {\n+                    return invokeImpl(cx, target, topScope, method, args);\n+                }\n+            };\n+        return cf.call(action);\n+    }\n+\n+    Object invokeImpl(Context cx,\n+                      Object target,\n+                      Scriptable topScope,\n+                      Method method,\n+                      Object[] args)\n+    {\n+        int N = (args == null) ? 0 : args.length;\n+\n+        Callable function = (Callable)target;\n+        Scriptable thisObj = topScope;\n+        Object[] jsargs = new Object[N + 1];\n+        jsargs[N] = method.getName();\n+        if (N != 0) {\n+            WrapFactory wf = cx.getWrapFactory();\n+            for (int i = 0; i != N; ++i) {\n+                jsargs[i] = wf.wrap(cx, topScope, args[i], null);\n+            }\n+        }\n+\n+        Object result = function.call(cx, topScope, thisObj, jsargs);\n+        Class<?> javaResultType = method.getReturnType();\n+        if (javaResultType == Void.TYPE) {\n+            result = null;\n+        } else {\n+            result = Context.jsToJava(result, javaResultType);\n+        }\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/InterpretedFunction.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Bob Jervis\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.javascript.debug.DebuggableScript;\n+\n+final class InterpretedFunction extends NativeFunction implements Script\n+{\n+    static final long serialVersionUID = 541475680333911468L;\n+\n+    InterpreterData idata;\n+    SecurityController securityController;\n+    Object securityDomain;\n+    Scriptable[] functionRegExps;\n+\n+    private InterpretedFunction(InterpreterData idata,\n+                                Object staticSecurityDomain)\n+    {\n+        this.idata = idata;\n+\n+        // Always get Context from the current thread to\n+        // avoid security breaches via passing mangled Context instances\n+        // with bogus SecurityController\n+        Context cx = Context.getContext();\n+        SecurityController sc = cx.getSecurityController();\n+        Object dynamicDomain;\n+        if (sc != null) {\n+            dynamicDomain = sc.getDynamicSecurityDomain(staticSecurityDomain);\n+        } else {\n+            if (staticSecurityDomain != null) {\n+                throw new IllegalArgumentException();\n+            }\n+            dynamicDomain = null;\n+        }\n+\n+        this.securityController = sc;\n+        this.securityDomain = dynamicDomain;\n+    }\n+\n+    private InterpretedFunction(InterpretedFunction parent, int index)\n+    {\n+        this.idata = parent.idata.itsNestedFunctions[index];\n+        this.securityController = parent.securityController;\n+        this.securityDomain = parent.securityDomain;\n+    }\n+\n+    /**\n+     * Create script from compiled bytecode.\n+     */\n+    static InterpretedFunction createScript(InterpreterData idata,\n+                                            Object staticSecurityDomain)\n+    {\n+        InterpretedFunction f;\n+        f = new InterpretedFunction(idata, staticSecurityDomain);\n+        return f;\n+    }\n+\n+    /**\n+     * Create function compiled from Function(...) constructor.\n+     */\n+    static InterpretedFunction createFunction(Context cx,Scriptable scope,\n+                                              InterpreterData idata,\n+                                              Object staticSecurityDomain)\n+    {\n+        InterpretedFunction f;\n+        f = new InterpretedFunction(idata, staticSecurityDomain);\n+        f.initInterpretedFunction(cx, scope);\n+        return f;\n+    }\n+\n+    /**\n+     * Create function embedded in script or another function.\n+     */\n+    static InterpretedFunction createFunction(Context cx, Scriptable scope,\n+                                              InterpretedFunction  parent,\n+                                              int index)\n+    {\n+        InterpretedFunction f = new InterpretedFunction(parent, index);\n+        f.initInterpretedFunction(cx, scope);\n+        return f;\n+    }\n+\n+    Scriptable[] createRegExpWraps(Context cx, Scriptable scope)\n+    {\n+        if (idata.itsRegExpLiterals == null) Kit.codeBug();\n+\n+        RegExpProxy rep = ScriptRuntime.checkRegExpProxy(cx);\n+        int N = idata.itsRegExpLiterals.length;\n+        Scriptable[] array = new Scriptable[N];\n+        for (int i = 0; i != N; ++i) {\n+            array[i] = rep.wrapRegExp(cx, scope, idata.itsRegExpLiterals[i]);\n+        }\n+        return array;\n+    }\n+\n+    private void initInterpretedFunction(Context cx, Scriptable scope)\n+    {\n+        initScriptFunction(cx, scope);\n+        if (idata.itsRegExpLiterals != null) {\n+            functionRegExps = createRegExpWraps(cx, scope);\n+        }\n+    }\n+\n+    @Override\n+    public String getFunctionName()\n+    {\n+        return (idata.itsName == null) ? \"\" : idata.itsName;\n+    }\n+\n+    /**\n+     * Calls the function.\n+     * @param cx the current context \n+     * @param scope the scope used for the call\n+     * @param thisObj the value of \"this\"\n+     * @param args function arguments. Must not be null. You can use \n+     * {@link ScriptRuntime#emptyArgs} to pass empty arguments.\n+     * @return the result of the function call.\n+     */\n+    @Override\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        if (!ScriptRuntime.hasTopCall(cx)) {\n+            return ScriptRuntime.doTopCall(this, cx, scope, thisObj, args);\n+        }\n+        return Interpreter.interpret(this, cx, scope, thisObj, args);\n+    }\n+\n+    public Object exec(Context cx, Scriptable scope)\n+    {\n+        if (!isScript()) {\n+            // Can only be applied to scripts\n+            throw new IllegalStateException();\n+        }\n+        if (!ScriptRuntime.hasTopCall(cx)) {\n+            // It will go through \"call\" path. but they are equivalent\n+            return ScriptRuntime.doTopCall(\n+                this, cx, scope, scope, ScriptRuntime.emptyArgs);\n+        }\n+        return Interpreter.interpret(\n+            this, cx, scope, scope, ScriptRuntime.emptyArgs);\n+    }\n+    \n+    public boolean isScript() {\n+        return idata.itsFunctionType == 0;\n+    }\n+\n+    @Override\n+    public String getEncodedSource()\n+    {\n+        return Interpreter.getEncodedSource(idata);\n+    }\n+\n+    @Override\n+    public DebuggableScript getDebuggableView()\n+    {\n+        return idata;\n+    }\n+\n+    @Override\n+    public Object resumeGenerator(Context cx, Scriptable scope, int operation,\n+                                  Object state, Object value)\n+    {\n+        return Interpreter.resumeGenerator(cx, scope, operation, state, value);\n+    }\n+\n+    @Override\n+    protected int getLanguageVersion()\n+    {\n+        return idata.languageVersion;\n+    }\n+\n+    @Override\n+    protected int getParamCount()\n+    {\n+        return idata.argCount;\n+    }\n+\n+    @Override\n+    protected int getParamAndVarCount()\n+    {\n+        return idata.argNames.length;\n+    }\n+\n+    @Override\n+    protected String getParamOrVarName(int index)\n+    {\n+        return idata.argNames[index];\n+    }\n+\n+    @Override\n+    protected boolean getParamOrVarConst(int index)\n+    {\n+        return idata.argIsConst[index];\n+    }\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Patrick Beard\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Ethan Hugg\n+ *   Bob Jervis\n+ *   Terry Lucas\n+ *   Roger Lawrence\n+ *   Milen Nankov\n+ *   Hannes Wallnoefer\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import org.mozilla.javascript.ast.FunctionNode;\n+import org.mozilla.javascript.ast.ScriptNode;\n+import org.mozilla.javascript.ScriptRuntime.NoSuchMethodShim;\n+import org.mozilla.javascript.debug.DebugFrame;\n+\n+public final class Interpreter extends Icode implements Evaluator\n+{\n+    // data for parsing\n+    CompilerEnvirons compilerEnv;\n+    InterpreterData itsData;\n+\n+    static final int EXCEPTION_TRY_START_SLOT  = 0;\n+    static final int EXCEPTION_TRY_END_SLOT    = 1;\n+    static final int EXCEPTION_HANDLER_SLOT    = 2;\n+    static final int EXCEPTION_TYPE_SLOT       = 3;\n+    static final int EXCEPTION_LOCAL_SLOT      = 4;\n+    static final int EXCEPTION_SCOPE_SLOT      = 5;\n+    // SLOT_SIZE: space for try start/end, handler, start, handler type,\n+    //            exception local and scope local\n+    static final int EXCEPTION_SLOT_SIZE       = 6;\n+\n+    /**\n+     * Class to hold data corresponding to one interpreted call stack frame.\n+     */\n+    private static class CallFrame implements Cloneable, Serializable\n+    {\n+        static final long serialVersionUID = -2843792508994958978L;\n+\n+        CallFrame parentFrame;\n+        // amount of stack frames before this one on the interpretation stack\n+        int frameIndex;\n+        // If true indicates read-only frame that is a part of continuation\n+        boolean frozen;\n+\n+        InterpretedFunction fnOrScript;\n+        InterpreterData idata;\n+\n+// Stack structure\n+// stack[0 <= i < localShift]: arguments and local variables\n+// stack[localShift <= i <= emptyStackTop]: used for local temporaries\n+// stack[emptyStackTop < i < stack.length]: stack data\n+// sDbl[i]: if stack[i] is UniqueTag.DOUBLE_MARK, sDbl[i] holds the number value\n+\n+        Object[] stack;\n+        int[] stackAttributes;\n+        double[] sDbl;\n+        CallFrame varSource; // defaults to this unless continuation frame\n+        int localShift;\n+        int emptyStackTop;\n+\n+        DebugFrame debuggerFrame;\n+        boolean useActivation;\n+        boolean isContinuationsTopFrame;\n+\n+        Scriptable thisObj;\n+        Scriptable[] scriptRegExps;\n+\n+// The values that change during interpretation\n+\n+        Object result;\n+        double resultDbl;\n+        int pc;\n+        int pcPrevBranch;\n+        int pcSourceLineStart;\n+        Scriptable scope;\n+\n+        int savedStackTop;\n+        int savedCallOp;\n+        Object throwable;\n+\n+        CallFrame cloneFrozen()\n+        {\n+            if (!frozen) Kit.codeBug();\n+\n+            CallFrame copy;\n+            try {\n+                copy = (CallFrame)clone();\n+            } catch (CloneNotSupportedException ex) {\n+                throw new IllegalStateException();\n+            }\n+\n+            // clone stack but keep varSource to point to values\n+            // from this frame to share variables.\n+\n+            copy.stack = stack.clone();\n+            copy.stackAttributes = stackAttributes.clone();\n+            copy.sDbl = sDbl.clone();\n+\n+            copy.frozen = false;\n+            return copy;\n+        }\n+    }\n+\n+    private static final class ContinuationJump implements Serializable\n+    {\n+        static final long serialVersionUID = 7687739156004308247L;\n+\n+        CallFrame capturedFrame;\n+        CallFrame branchFrame;\n+        Object result;\n+        double resultDbl;\n+\n+        ContinuationJump(NativeContinuation c, CallFrame current)\n+        {\n+            this.capturedFrame = (CallFrame)c.getImplementation();\n+            if (this.capturedFrame == null || current == null) {\n+                // Continuation and current execution does not share\n+                // any frames if there is nothing to capture or\n+                // if there is no currently executed frames\n+                this.branchFrame = null;\n+            } else {\n+                // Search for branch frame where parent frame chains starting\n+                // from captured and current meet.\n+                CallFrame chain1 = this.capturedFrame;\n+                CallFrame chain2 = current;\n+\n+                // First work parents of chain1 or chain2 until the same\n+                // frame depth.\n+                int diff = chain1.frameIndex - chain2.frameIndex;\n+                if (diff != 0) {\n+                    if (diff < 0) {\n+                        // swap to make sure that\n+                        // chain1.frameIndex > chain2.frameIndex and diff > 0\n+                        chain1 = current;\n+                        chain2 = this.capturedFrame;\n+                        diff = -diff;\n+                    }\n+                    do {\n+                        chain1 = chain1.parentFrame;\n+                    } while (--diff != 0);\n+                    if (chain1.frameIndex != chain2.frameIndex) Kit.codeBug();\n+                }\n+\n+                // Now walk parents in parallel until a shared frame is found\n+                // or until the root is reached.\n+                while (chain1 != chain2 && chain1 != null) {\n+                    chain1 = chain1.parentFrame;\n+                    chain2 = chain2.parentFrame;\n+                }\n+\n+                this.branchFrame = chain1;\n+                if (this.branchFrame != null && !this.branchFrame.frozen)\n+                    Kit.codeBug();\n+            }\n+        }\n+    }\n+\n+    private static CallFrame captureFrameForGenerator(CallFrame frame) {\n+      frame.frozen = true;\n+      CallFrame result = frame.cloneFrozen();\n+      frame.frozen = false;\n+\n+      // now isolate this frame from its previous context\n+      result.parentFrame = null;\n+      result.frameIndex = 0;\n+\n+      return result;\n+    }\n+\n+    static {\n+        // Checks for byte code consistencies, good compiler can eliminate them\n+\n+        if (Token.LAST_BYTECODE_TOKEN > 127) {\n+            String str = \"Violation of Token.LAST_BYTECODE_TOKEN <= 127\";\n+            System.err.println(str);\n+            throw new IllegalStateException(str);\n+        }\n+        if (MIN_ICODE < -128) {\n+            String str = \"Violation of Interpreter.MIN_ICODE >= -128\";\n+            System.err.println(str);\n+            throw new IllegalStateException(str);\n+        }\n+    }\n+\n+    public Object compile(CompilerEnvirons compilerEnv,\n+                          ScriptNode tree,\n+                          String encodedSource,\n+                          boolean returnFunction)\n+    {\n+        this.compilerEnv = compilerEnv;\n+        CodeGenerator cgen = new CodeGenerator();\n+        itsData = cgen.compile(compilerEnv, tree, encodedSource, returnFunction);\n+        return itsData;\n+    }\n+\n+    public Script createScriptObject(Object bytecode, Object staticSecurityDomain)\n+    {\n+        if(bytecode != itsData)\n+        {\n+            Kit.codeBug();\n+        }\n+        return InterpretedFunction.createScript(itsData,\n+                                                staticSecurityDomain);\n+    }\n+\n+    public void setEvalScriptFlag(Script script) {\n+        ((InterpretedFunction)script).idata.evalScriptFlag = true;\n+    }\n+\n+\n+    public Function createFunctionObject(Context cx, Scriptable scope,\n+            Object bytecode, Object staticSecurityDomain)\n+    {\n+        if(bytecode != itsData)\n+        {\n+            Kit.codeBug();\n+        }\n+        return InterpretedFunction.createFunction(cx, scope, itsData,\n+                                                  staticSecurityDomain);\n+    }\n+\n+    private static int getShort(byte[] iCode, int pc) {\n+        return (iCode[pc] << 8) | (iCode[pc + 1] & 0xFF);\n+    }\n+\n+    private static int getIndex(byte[] iCode, int pc) {\n+        return ((iCode[pc] & 0xFF) << 8) | (iCode[pc + 1] & 0xFF);\n+    }\n+\n+    private static int getInt(byte[] iCode, int pc) {\n+        return (iCode[pc] << 24) | ((iCode[pc + 1] & 0xFF) << 16)\n+               | ((iCode[pc + 2] & 0xFF) << 8) | (iCode[pc + 3] & 0xFF);\n+    }\n+\n+    private static int getExceptionHandler(CallFrame frame,\n+                                           boolean onlyFinally)\n+    {\n+        int[] exceptionTable = frame.idata.itsExceptionTable;\n+        if (exceptionTable == null) {\n+            // No exception handlers\n+            return -1;\n+        }\n+\n+        // Icode switch in the interpreter increments PC immediately\n+        // and it is necessary to subtract 1 from the saved PC\n+        // to point it before the start of the next instruction.\n+        int pc = frame.pc - 1;\n+\n+        // OPT: use binary search\n+        int best = -1, bestStart = 0, bestEnd = 0;\n+        for (int i = 0; i != exceptionTable.length; i += EXCEPTION_SLOT_SIZE) {\n+            int start = exceptionTable[i + EXCEPTION_TRY_START_SLOT];\n+            int end = exceptionTable[i + EXCEPTION_TRY_END_SLOT];\n+            if (!(start <= pc && pc < end)) {\n+                continue;\n+            }\n+            if (onlyFinally && exceptionTable[i + EXCEPTION_TYPE_SLOT] != 1) {\n+                continue;\n+            }\n+            if (best >= 0) {\n+                // Since handlers always nest and they never have shared end\n+                // although they can share start  it is sufficient to compare\n+                // handlers ends\n+                if (bestEnd < end) {\n+                    continue;\n+                }\n+                // Check the above assumption\n+                if (bestStart > start) Kit.codeBug(); // should be nested\n+                if (bestEnd == end) Kit.codeBug();  // no ens sharing\n+            }\n+            best = i;\n+            bestStart = start;\n+            bestEnd = end;\n+        }\n+        return best;\n+    }\n+\n+    static void dumpICode(InterpreterData idata)\n+    {\n+        if (!Token.printICode) {\n+            return;\n+        }\n+\n+        byte iCode[] = idata.itsICode;\n+        int iCodeLength = iCode.length;\n+        String[] strings = idata.itsStringTable;\n+        PrintStream out = System.out;\n+        out.println(\"ICode dump, for \" + idata.itsName\n+                    + \", length = \" + iCodeLength);\n+        out.println(\"MaxStack = \" + idata.itsMaxStack);\n+\n+        int indexReg = 0;\n+        for (int pc = 0; pc < iCodeLength; ) {\n+            out.flush();\n+            out.print(\" [\" + pc + \"] \");\n+            int token = iCode[pc];\n+            int icodeLength = bytecodeSpan(token);\n+            String tname = Icode.bytecodeName(token);\n+            int old_pc = pc;\n+            ++pc;\n+            switch (token) {\n+              default:\n+                if (icodeLength != 1) Kit.codeBug();\n+                out.println(tname);\n+                break;\n+\n+              case Icode_GOSUB :\n+              case Token.GOTO :\n+              case Token.IFEQ :\n+              case Token.IFNE :\n+              case Icode_IFEQ_POP :\n+              case Icode_LEAVEDQ : {\n+                int newPC = pc + getShort(iCode, pc) - 1;\n+                out.println(tname + \" \" + newPC);\n+                pc += 2;\n+                break;\n+              }\n+              case Icode_VAR_INC_DEC :\n+              case Icode_NAME_INC_DEC :\n+              case Icode_PROP_INC_DEC :\n+              case Icode_ELEM_INC_DEC :\n+              case Icode_REF_INC_DEC: {\n+                int incrDecrType = iCode[pc];\n+                out.println(tname + \" \" + incrDecrType);\n+                ++pc;\n+                break;\n+              }\n+\n+              case Icode_CALLSPECIAL : {\n+                int callType = iCode[pc] & 0xFF;\n+                boolean isNew =  (iCode[pc + 1] != 0);\n+                int line = getIndex(iCode, pc+2);\n+                out.println(tname+\" \"+callType+\" \"+isNew+\" \"+indexReg+\" \"+line);\n+                pc += 4;\n+                break;\n+              }\n+\n+              case Token.CATCH_SCOPE:\n+                {\n+                    boolean afterFisrtFlag =  (iCode[pc] != 0);\n+                    out.println(tname+\" \"+afterFisrtFlag);\n+                    ++pc;\n+                }\n+                break;\n+              case Token.REGEXP :\n+                out.println(tname+\" \"+idata.itsRegExpLiterals[indexReg]);\n+                break;\n+              case Token.OBJECTLIT :\n+              case Icode_SPARE_ARRAYLIT :\n+                out.println(tname+\" \"+idata.literalIds[indexReg]);\n+                break;\n+              case Icode_CLOSURE_EXPR :\n+              case Icode_CLOSURE_STMT :\n+                out.println(tname+\" \"+idata.itsNestedFunctions[indexReg]);\n+                break;\n+              case Token.CALL :\n+              case Icode_TAIL_CALL :\n+              case Token.REF_CALL :\n+              case Token.NEW :\n+                out.println(tname+' '+indexReg);\n+                break;\n+              case Token.THROW :\n+              case Token.YIELD :\n+              case Icode_GENERATOR :\n+              case Icode_GENERATOR_END :\n+              {\n+                int line = getIndex(iCode, pc);\n+                out.println(tname + \" : \" + line);\n+                pc += 2;\n+                break;\n+              }\n+              case Icode_SHORTNUMBER : {\n+                int value = getShort(iCode, pc);\n+                out.println(tname + \" \" + value);\n+                pc += 2;\n+                break;\n+              }\n+              case Icode_INTNUMBER : {\n+                int value = getInt(iCode, pc);\n+                out.println(tname + \" \" + value);\n+                pc += 4;\n+                break;\n+              }\n+              case Token.NUMBER : {\n+                double value = idata.itsDoubleTable[indexReg];\n+                out.println(tname + \" \" + value);\n+                break;\n+              }\n+              case Icode_LINE : {\n+                int line = getIndex(iCode, pc);\n+                out.println(tname + \" : \" + line);\n+                pc += 2;\n+                break;\n+              }\n+              case Icode_REG_STR1: {\n+                String str = strings[0xFF & iCode[pc]];\n+                out.println(tname + \" \\\"\" + str + '\"');\n+                ++pc;\n+                break;\n+              }\n+              case Icode_REG_STR2: {\n+                String str = strings[getIndex(iCode, pc)];\n+                out.println(tname + \" \\\"\" + str + '\"');\n+                pc += 2;\n+                break;\n+              }\n+              case Icode_REG_STR4: {\n+                String str = strings[getInt(iCode, pc)];\n+                out.println(tname + \" \\\"\" + str + '\"');\n+                pc += 4;\n+                break;\n+              }\n+              case Icode_REG_IND_C0:\n+                  indexReg = 0;\n+                  out.println(tname);\n+                  break;\n+              case Icode_REG_IND_C1:\n+                  indexReg = 1;\n+                  out.println(tname);\n+                  break;\n+              case Icode_REG_IND_C2:\n+                  indexReg = 2;\n+                  out.println(tname);\n+                  break;\n+              case Icode_REG_IND_C3:\n+                  indexReg = 3;\n+                  out.println(tname);\n+                  break;\n+              case Icode_REG_IND_C4:\n+                  indexReg = 4;\n+                  out.println(tname);\n+                  break;\n+              case Icode_REG_IND_C5:\n+                  indexReg = 5;\n+                  out.println(tname);\n+                  break;\n+              case Icode_REG_IND1: {\n+                indexReg = 0xFF & iCode[pc];\n+                out.println(tname+\" \"+indexReg);\n+                ++pc;\n+                break;\n+              }\n+              case Icode_REG_IND2: {\n+                indexReg = getIndex(iCode, pc);\n+                out.println(tname+\" \"+indexReg);\n+                pc += 2;\n+                break;\n+              }\n+              case Icode_REG_IND4: {\n+                indexReg = getInt(iCode, pc);\n+                out.println(tname+\" \"+indexReg);\n+                pc += 4;\n+                break;\n+              }\n+              case Icode_GETVAR1:\n+              case Icode_SETVAR1:\n+              case Icode_SETCONSTVAR1:\n+                indexReg = iCode[pc];\n+                out.println(tname+\" \"+indexReg);\n+                ++pc;\n+                break;\n+            }\n+            if (old_pc + icodeLength != pc) Kit.codeBug();\n+        }\n+\n+        int[] table = idata.itsExceptionTable;\n+        if (table != null) {\n+            out.println(\"Exception handlers: \"\n+                         +table.length / EXCEPTION_SLOT_SIZE);\n+            for (int i = 0; i != table.length;\n+                 i += EXCEPTION_SLOT_SIZE)\n+            {\n+                int tryStart       = table[i + EXCEPTION_TRY_START_SLOT];\n+                int tryEnd         = table[i + EXCEPTION_TRY_END_SLOT];\n+                int handlerStart   = table[i + EXCEPTION_HANDLER_SLOT];\n+                int type           = table[i + EXCEPTION_TYPE_SLOT];\n+                int exceptionLocal = table[i + EXCEPTION_LOCAL_SLOT];\n+                int scopeLocal     = table[i + EXCEPTION_SCOPE_SLOT];\n+\n+                out.println(\" tryStart=\"+tryStart+\" tryEnd=\"+tryEnd\n+                            +\" handlerStart=\"+handlerStart\n+                            +\" type=\"+(type == 0 ? \"catch\" : \"finally\")\n+                            +\" exceptionLocal=\"+exceptionLocal);\n+            }\n+        }\n+        out.flush();\n+    }\n+\n+    private static int bytecodeSpan(int bytecode)\n+    {\n+        switch (bytecode) {\n+            case Token.THROW :\n+            case Token.YIELD:\n+            case Icode_GENERATOR:\n+            case Icode_GENERATOR_END:\n+                // source line\n+                return 1 + 2;\n+\n+            case Icode_GOSUB :\n+            case Token.GOTO :\n+            case Token.IFEQ :\n+            case Token.IFNE :\n+            case Icode_IFEQ_POP :\n+            case Icode_LEAVEDQ :\n+                // target pc offset\n+                return 1 + 2;\n+\n+            case Icode_CALLSPECIAL :\n+                // call type\n+                // is new\n+                // line number\n+                return 1 + 1 + 1 + 2;\n+\n+            case Token.CATCH_SCOPE:\n+                // scope flag\n+                return 1 + 1;\n+\n+            case Icode_VAR_INC_DEC:\n+            case Icode_NAME_INC_DEC:\n+            case Icode_PROP_INC_DEC:\n+            case Icode_ELEM_INC_DEC:\n+            case Icode_REF_INC_DEC:\n+                // type of ++/--\n+                return 1 + 1;\n+\n+            case Icode_SHORTNUMBER :\n+                // short number\n+                return 1 + 2;\n+\n+            case Icode_INTNUMBER :\n+                // int number\n+                return 1 + 4;\n+\n+            case Icode_REG_IND1:\n+                // ubyte index\n+                return 1 + 1;\n+\n+            case Icode_REG_IND2:\n+                // ushort index\n+                return 1 + 2;\n+\n+            case Icode_REG_IND4:\n+                // int index\n+                return 1 + 4;\n+\n+            case Icode_REG_STR1:\n+                // ubyte string index\n+                return 1 + 1;\n+\n+            case Icode_REG_STR2:\n+                // ushort string index\n+                return 1 + 2;\n+\n+            case Icode_REG_STR4:\n+                // int string index\n+                return 1 + 4;\n+\n+            case Icode_GETVAR1:\n+            case Icode_SETVAR1:\n+            case Icode_SETCONSTVAR1:\n+                // byte var index\n+                return 1 + 1;\n+\n+            case Icode_LINE :\n+                // line number\n+                return 1 + 2;\n+        }\n+        if (!validBytecode(bytecode)) throw Kit.codeBug();\n+        return 1;\n+    }\n+\n+    static int[] getLineNumbers(InterpreterData data)\n+    {\n+        UintMap presentLines = new UintMap();\n+\n+        byte[] iCode = data.itsICode;\n+        int iCodeLength = iCode.length;\n+        for (int pc = 0; pc != iCodeLength;) {\n+            int bytecode = iCode[pc];\n+            int span = bytecodeSpan(bytecode);\n+            if (bytecode == Icode_LINE) {\n+                if (span != 3) Kit.codeBug();\n+                int line = getIndex(iCode, pc + 1);\n+                presentLines.put(line, 0);\n+            }\n+            pc += span;\n+        }\n+\n+        return presentLines.getKeys();\n+    }\n+\n+    public void captureStackInfo(RhinoException ex)\n+    {\n+        Context cx = Context.getCurrentContext();\n+        if (cx == null || cx.lastInterpreterFrame == null) {\n+            // No interpreter invocations\n+            ex.interpreterStackInfo = null;\n+            ex.interpreterLineData = null;\n+            return;\n+        }\n+        // has interpreter frame on the stack\n+        CallFrame[] array;\n+        if (cx.previousInterpreterInvocations == null\n+            || cx.previousInterpreterInvocations.size() == 0)\n+        {\n+            array = new CallFrame[1];\n+        } else {\n+            int previousCount = cx.previousInterpreterInvocations.size();\n+            if (cx.previousInterpreterInvocations.peek()\n+                == cx.lastInterpreterFrame)\n+            {\n+                // It can happen if exception was generated after\n+                // frame was pushed to cx.previousInterpreterInvocations\n+                // but before assignment to cx.lastInterpreterFrame.\n+                // In this case frames has to be ignored.\n+                --previousCount;\n+            }\n+            array = new CallFrame[previousCount + 1];\n+            cx.previousInterpreterInvocations.toArray(array);\n+        }\n+        array[array.length - 1]  = (CallFrame)cx.lastInterpreterFrame;\n+\n+        int interpreterFrameCount = 0;\n+        for (int i = 0; i != array.length; ++i) {\n+            interpreterFrameCount += 1 + array[i].frameIndex;\n+        }\n+\n+        int[] linePC = new int[interpreterFrameCount];\n+        // Fill linePC with pc positions from all interpreter frames.\n+        // Start from the most nested frame\n+        int linePCIndex = interpreterFrameCount;\n+        for (int i = array.length; i != 0;) {\n+            --i;\n+            CallFrame frame = array[i];\n+            while (frame != null) {\n+                --linePCIndex;\n+                linePC[linePCIndex] = frame.pcSourceLineStart;\n+                frame = frame.parentFrame;\n+            }\n+        }\n+        if (linePCIndex != 0) Kit.codeBug();\n+\n+        ex.interpreterStackInfo = array;\n+        ex.interpreterLineData = linePC;\n+    }\n+\n+    public String getSourcePositionFromStack(Context cx, int[] linep)\n+    {\n+        CallFrame frame = (CallFrame)cx.lastInterpreterFrame;\n+        InterpreterData idata = frame.idata;\n+        if (frame.pcSourceLineStart >= 0) {\n+            linep[0] = getIndex(idata.itsICode, frame.pcSourceLineStart);\n+        } else {\n+            linep[0] = 0;\n+        }\n+        return idata.itsSourceFile;\n+    }\n+\n+    public String getPatchedStack(RhinoException ex,\n+                                  String nativeStackTrace)\n+    {\n+        String tag = \"org.mozilla.javascript.Interpreter.interpretLoop\";\n+        StringBuffer sb = new StringBuffer(nativeStackTrace.length() + 1000);\n+        String lineSeparator = SecurityUtilities.getSystemProperty(\"line.separator\");\n+\n+        CallFrame[] array = (CallFrame[])ex.interpreterStackInfo;\n+        int[] linePC = ex.interpreterLineData;\n+        int arrayIndex = array.length;\n+        int linePCIndex = linePC.length;\n+        int offset = 0;\n+        while (arrayIndex != 0) {\n+            --arrayIndex;\n+            int pos = nativeStackTrace.indexOf(tag, offset);\n+            if (pos < 0) {\n+                break;\n+            }\n+\n+            // Skip tag length\n+            pos += tag.length();\n+            // Skip until the end of line\n+            for (; pos != nativeStackTrace.length(); ++pos) {\n+                char c = nativeStackTrace.charAt(pos);\n+                if (c == '\\n' || c == '\\r') {\n+                    break;\n+                }\n+            }\n+            sb.append(nativeStackTrace.substring(offset, pos));\n+            offset = pos;\n+\n+            CallFrame frame = array[arrayIndex];\n+            while (frame != null) {\n+                if (linePCIndex == 0) Kit.codeBug();\n+                --linePCIndex;\n+                InterpreterData idata = frame.idata;\n+                sb.append(lineSeparator);\n+                sb.append(\"\\tat script\");\n+                if (idata.itsName != null && idata.itsName.length() != 0) {\n+                    sb.append('.');\n+                    sb.append(idata.itsName);\n+                }\n+                sb.append('(');\n+                sb.append(idata.itsSourceFile);\n+                int pc = linePC[linePCIndex];\n+                if (pc >= 0) {\n+                    // Include line info only if available\n+                    sb.append(':');\n+                    sb.append(getIndex(idata.itsICode, pc));\n+                }\n+                sb.append(')');\n+                frame = frame.parentFrame;\n+            }\n+        }\n+        sb.append(nativeStackTrace.substring(offset));\n+\n+        return sb.toString();\n+    }\n+\n+    public List<String> getScriptStack(RhinoException ex)\n+    {\n+        if (ex.interpreterStackInfo == null) {\n+            return null;\n+        }\n+\n+        List<String> list = new ArrayList<String>();\n+        String lineSeparator =\n+                SecurityUtilities.getSystemProperty(\"line.separator\");\n+\n+        CallFrame[] array = (CallFrame[])ex.interpreterStackInfo;\n+        int[] linePC = ex.interpreterLineData;\n+        int arrayIndex = array.length;\n+        int linePCIndex = linePC.length;\n+        while (arrayIndex != 0) {\n+            --arrayIndex;\n+            StringBuilder sb = new StringBuilder();\n+            CallFrame frame = array[arrayIndex];\n+            while (frame != null) {\n+                if (linePCIndex == 0) Kit.codeBug();\n+                --linePCIndex;\n+                InterpreterData idata = frame.idata;\n+                sb.append(\"\\tat \");\n+                sb.append(idata.itsSourceFile);\n+                int pc = linePC[linePCIndex];\n+                if (pc >= 0) {\n+                    // Include line info only if available\n+                    sb.append(':');\n+                    sb.append(getIndex(idata.itsICode, pc));\n+                }\n+                if (idata.itsName != null && idata.itsName.length() != 0) {\n+                    sb.append(\" (\");\n+                    sb.append(idata.itsName);\n+                    sb.append(')');\n+                }\n+                sb.append(lineSeparator);\n+                frame = frame.parentFrame;\n+            }\n+            list.add(sb.toString());\n+        }\n+        return list;\n+    }\n+\n+    static String getEncodedSource(InterpreterData idata)\n+    {\n+        if (idata.encodedSource == null) {\n+            return null;\n+        }\n+        return idata.encodedSource.substring(idata.encodedSourceStart,\n+                                             idata.encodedSourceEnd);\n+    }\n+\n+    private static void initFunction(Context cx, Scriptable scope,\n+                                     InterpretedFunction parent, int index)\n+    {\n+        InterpretedFunction fn;\n+        fn = InterpretedFunction.createFunction(cx, scope, parent, index);\n+        ScriptRuntime.initFunction(cx, scope, fn, fn.idata.itsFunctionType,\n+                                   parent.idata.evalScriptFlag);\n+    }\n+\n+    static Object interpret(InterpretedFunction ifun,\n+                            Context cx, Scriptable scope,\n+                            Scriptable thisObj, Object[] args)\n+    {\n+        if (!ScriptRuntime.hasTopCall(cx)) Kit.codeBug();\n+\n+        if (cx.interpreterSecurityDomain != ifun.securityDomain) {\n+            Object savedDomain = cx.interpreterSecurityDomain;\n+            cx.interpreterSecurityDomain = ifun.securityDomain;\n+            try {\n+                return ifun.securityController.callWithDomain(\n+                    ifun.securityDomain, cx, ifun, scope, thisObj, args);\n+            } finally {\n+                cx.interpreterSecurityDomain = savedDomain;\n+            }\n+        }\n+\n+        CallFrame frame = new CallFrame();\n+        initFrame(cx, scope, thisObj, args, null, 0, args.length,\n+                  ifun, null, frame);\n+        frame.isContinuationsTopFrame = cx.isContinuationsTopCall;\n+        cx.isContinuationsTopCall = false;\n+\n+        return interpretLoop(cx, frame, null);\n+    }\n+\n+    static class GeneratorState {\n+        GeneratorState(int operation, Object value) {\n+            this.operation = operation;\n+            this.value = value;\n+        }\n+        int operation;\n+        Object value;\n+        RuntimeException returnedException;\n+    }\n+\n+    public static Object resumeGenerator(Context cx,\n+                                         Scriptable scope,\n+                                         int operation,\n+                                         Object savedState,\n+                                         Object value)\n+    {\n+      CallFrame frame = (CallFrame) savedState;\n+      GeneratorState generatorState = new GeneratorState(operation, value);\n+      if (operation == NativeGenerator.GENERATOR_CLOSE) {\n+          try {\n+              return interpretLoop(cx, frame, generatorState);\n+          } catch (RuntimeException e) {\n+              // Only propagate exceptions other than closingException\n+              if (e != value)\n+                  throw e;\n+          }\n+          return Undefined.instance;\n+      }\n+      Object result = interpretLoop(cx, frame, generatorState);\n+      if (generatorState.returnedException != null)\n+          throw generatorState.returnedException;\n+      return result;\n+    }\n+\n+    public static Object restartContinuation(NativeContinuation c, Context cx,\n+                                             Scriptable scope, Object[] args)\n+    {\n+        if (!ScriptRuntime.hasTopCall(cx)) {\n+            return ScriptRuntime.doTopCall(c, cx, scope, null, args);\n+        }\n+\n+        Object arg;\n+        if (args.length == 0) {\n+            arg = Undefined.instance;\n+        } else {\n+            arg = args[0];\n+        }\n+\n+        CallFrame capturedFrame = (CallFrame)c.getImplementation();\n+        if (capturedFrame == null) {\n+            // No frames to restart\n+            return arg;\n+        }\n+\n+        ContinuationJump cjump = new ContinuationJump(c, null);\n+\n+        cjump.result = arg;\n+        return interpretLoop(cx, null, cjump);\n+    }\n+\n+    private static Object interpretLoop(Context cx, CallFrame frame,\n+                                        Object throwable)\n+    {\n+        // throwable holds exception object to rethrow or catch\n+        // It is also used for continuation restart in which case\n+        // it holds ContinuationJump\n+\n+        final Object DBL_MRK = UniqueTag.DOUBLE_MARK;\n+        final Object undefined = Undefined.instance;\n+\n+        final boolean instructionCounting = (cx.instructionThreshold != 0);\n+        // arbitrary number to add to instructionCount when calling\n+        // other functions\n+        final int INVOCATION_COST = 100;\n+        // arbitrary exception cost for instruction counting\n+        final int EXCEPTION_COST = 100;\n+\n+        String stringReg = null;\n+        int indexReg = -1;\n+\n+        if (cx.lastInterpreterFrame != null) {\n+            // save the top frame from the previous interpretLoop\n+            // invocation on the stack\n+            if (cx.previousInterpreterInvocations == null) {\n+                cx.previousInterpreterInvocations = new ObjArray();\n+            }\n+            cx.previousInterpreterInvocations.push(cx.lastInterpreterFrame);\n+        }\n+\n+        // When restarting continuation throwable is not null and to jump\n+        // to the code that rewind continuation state indexReg should be set\n+        // to -1.\n+        // With the normal call throwable == null and indexReg == -1 allows to\n+        // catch bugs with using indeReg to access array elements before\n+        // initializing indexReg.\n+\n+        GeneratorState generatorState = null;\n+        if (throwable != null) {\n+            if (throwable instanceof GeneratorState) {\n+              generatorState = (GeneratorState) throwable;\n+\n+              // reestablish this call frame\n+              enterFrame(cx, frame, ScriptRuntime.emptyArgs, true);\n+              throwable = null;\n+            } else if (!(throwable instanceof ContinuationJump)) {\n+                // It should be continuation\n+                Kit.codeBug();\n+            }\n+        }\n+\n+        Object interpreterResult = null;\n+        double interpreterResultDbl = 0.0;\n+\n+        StateLoop: for (;;) {\n+            withoutExceptions: try {\n+\n+                if (throwable != null) {\n+                    // Need to return both 'frame' and 'throwable' from\n+                    // 'processThrowable', so just added a 'throwable'\n+                    // member in 'frame'.\n+                    frame = processThrowable(cx, throwable, frame, indexReg,\n+                                             instructionCounting);\n+                    throwable = frame.throwable;\n+                    frame.throwable = null;\n+                } else {\n+                    if (generatorState == null && frame.frozen) Kit.codeBug();\n+                }\n+\n+                // Use local variables for constant values in frame\n+                // for faster access\n+                Object[] stack = frame.stack;\n+                double[] sDbl = frame.sDbl;\n+                Object[] vars = frame.varSource.stack;\n+                double[] varDbls = frame.varSource.sDbl;\n+                int[] varAttributes = frame.varSource.stackAttributes;\n+                byte[] iCode = frame.idata.itsICode;\n+                String[] strings = frame.idata.itsStringTable;\n+\n+                // Use local for stackTop as well. Since execption handlers\n+                // can only exist at statement level where stack is empty,\n+                // it is necessary to save/restore stackTop only across\n+                // function calls and normal returns.\n+                int stackTop = frame.savedStackTop;\n+\n+                // Store new frame in cx which is used for error reporting etc.\n+                cx.lastInterpreterFrame = frame;\n+\n+                Loop: for (;;) {\n+\n+                    // Exception handler assumes that PC is already incremented\n+                    // pass the instruction start when it searches the\n+                    // exception handler\n+                    int op = iCode[frame.pc++];\n+                    jumplessRun: {\n+\n+    // Back indent to ease implementation reading\n+switch (op) {\n+    case Icode_GENERATOR: {\n+        if (!frame.frozen) {\n+          // First time encountering this opcode: create new generator\n+          // object and return\n+          frame.pc--; // we want to come back here when we resume\n+          CallFrame generatorFrame = captureFrameForGenerator(frame);\n+          generatorFrame.frozen = true;\n+          NativeGenerator generator = new NativeGenerator(frame.scope,\n+              generatorFrame.fnOrScript, generatorFrame);\n+          frame.result = generator;\n+          break Loop;\n+        } else {\n+          // We are now resuming execution. Fall through to YIELD case.\n+        }\n+    }\n+    // fall through...\n+    case Token.YIELD: {\n+        if (!frame.frozen) {\n+            return freezeGenerator(cx, frame, stackTop, generatorState);\n+        } else {\n+            Object obj = thawGenerator(frame, stackTop, generatorState, op);\n+            if (obj != Scriptable.NOT_FOUND) {\n+                throwable = obj;\n+                break withoutExceptions;\n+            }\n+            continue Loop;\n+        }\n+    }\n+    case Icode_GENERATOR_END: {\n+      // throw StopIteration\n+      frame.frozen = true;\n+      int sourceLine = getIndex(iCode, frame.pc);\n+      generatorState.returnedException = new JavaScriptException(\n+          NativeIterator.getStopIterationObject(frame.scope),\n+          frame.idata.itsSourceFile, sourceLine);\n+      break Loop;\n+    }\n+    case Token.STRICT_SETNAME: {\n+        Object rhs = stack[stackTop];\n+        if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Scriptable lhs = (Scriptable)stack[stackTop];\n+        if (lhs != null) {\n+            stack[stackTop] = ScriptRuntime.setName(lhs, rhs, cx,\n+                                                    frame.scope, stringReg);\n+            continue Loop;\n+        }\n+        stack[stackTop] = cx.newObject(frame.scope, \"ReferenceError\",\n+                                       new Object[] { stringReg });\n+    }\n+    /* fall through */\n+    case Token.THROW: {\n+        Object value = stack[stackTop];\n+        if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+\n+        int sourceLine = getIndex(iCode, frame.pc);\n+        throwable = new JavaScriptException(value,\n+                                            frame.idata.itsSourceFile,\n+                                            sourceLine);\n+        break withoutExceptions;\n+    }\n+    case Token.RETHROW: {\n+        indexReg += frame.localShift;\n+        throwable = stack[indexReg];\n+        break withoutExceptions;\n+    }\n+    case Token.GE :\n+    case Token.LE :\n+    case Token.GT :\n+    case Token.LT : {\n+        --stackTop;\n+        Object rhs = stack[stackTop + 1];\n+        Object lhs = stack[stackTop];\n+        boolean valBln;\n+      object_compare:\n+        {\n+          number_compare:\n+            {\n+                double rDbl, lDbl;\n+                if (rhs == DBL_MRK) {\n+                    rDbl = sDbl[stackTop + 1];\n+                    lDbl = stack_double(frame, stackTop);\n+                } else if (lhs == DBL_MRK) {\n+                    rDbl = ScriptRuntime.toNumber(rhs);\n+                    lDbl = sDbl[stackTop];\n+                } else {\n+                    break number_compare;\n+                }\n+                switch (op) {\n+                  case Token.GE:\n+                    valBln = (lDbl >= rDbl);\n+                    break object_compare;\n+                  case Token.LE:\n+                    valBln = (lDbl <= rDbl);\n+                    break object_compare;\n+                  case Token.GT:\n+                    valBln = (lDbl > rDbl);\n+                    break object_compare;\n+                  case Token.LT:\n+                    valBln = (lDbl < rDbl);\n+                    break object_compare;\n+                  default:\n+                    throw Kit.codeBug();\n+                }\n+            }\n+            switch (op) {\n+              case Token.GE:\n+                valBln = ScriptRuntime.cmp_LE(rhs, lhs);\n+                break;\n+              case Token.LE:\n+                valBln = ScriptRuntime.cmp_LE(lhs, rhs);\n+                break;\n+              case Token.GT:\n+                valBln = ScriptRuntime.cmp_LT(rhs, lhs);\n+                break;\n+              case Token.LT:\n+                valBln = ScriptRuntime.cmp_LT(lhs, rhs);\n+                break;\n+              default:\n+                throw Kit.codeBug();\n+            }\n+        }\n+        stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);\n+        continue Loop;\n+    }\n+    case Token.IN :\n+    case Token.INSTANCEOF : {\n+        Object rhs = stack[stackTop];\n+        if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        boolean valBln;\n+        if (op == Token.IN) {\n+            valBln = ScriptRuntime.in(lhs, rhs, cx);\n+        } else {\n+            valBln = ScriptRuntime.instanceOf(lhs, rhs, cx);\n+        }\n+        stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);\n+        continue Loop;\n+    }\n+    case Token.EQ :\n+    case Token.NE : {\n+        --stackTop;\n+        boolean valBln;\n+        Object rhs = stack[stackTop + 1];\n+        Object lhs = stack[stackTop];\n+        if (rhs == DBL_MRK) {\n+            if (lhs == DBL_MRK) {\n+                valBln = (sDbl[stackTop] == sDbl[stackTop + 1]);\n+            } else {\n+                valBln = ScriptRuntime.eqNumber(sDbl[stackTop + 1], lhs);\n+            }\n+        } else {\n+            if (lhs == DBL_MRK) {\n+                valBln = ScriptRuntime.eqNumber(sDbl[stackTop], rhs);\n+            } else {\n+                valBln = ScriptRuntime.eq(lhs, rhs);\n+            }\n+        }\n+        valBln ^= (op == Token.NE);\n+        stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);\n+        continue Loop;\n+    }\n+    case Token.SHEQ :\n+    case Token.SHNE : {\n+        --stackTop;\n+        boolean valBln = shallowEquals(stack, sDbl, stackTop);\n+        valBln ^= (op == Token.SHNE);\n+        stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);\n+        continue Loop;\n+    }\n+    case Token.IFNE :\n+        if (stack_boolean(frame, stackTop--)) {\n+            frame.pc += 2;\n+            continue Loop;\n+        }\n+        break jumplessRun;\n+    case Token.IFEQ :\n+        if (!stack_boolean(frame, stackTop--)) {\n+            frame.pc += 2;\n+            continue Loop;\n+        }\n+        break jumplessRun;\n+    case Icode_IFEQ_POP :\n+        if (!stack_boolean(frame, stackTop--)) {\n+            frame.pc += 2;\n+            continue Loop;\n+        }\n+        stack[stackTop--] = null;\n+        break jumplessRun;\n+    case Token.GOTO :\n+        break jumplessRun;\n+    case Icode_GOSUB :\n+        ++stackTop;\n+        stack[stackTop] = DBL_MRK;\n+        sDbl[stackTop] = frame.pc + 2;\n+        break jumplessRun;\n+    case Icode_STARTSUB :\n+        if (stackTop == frame.emptyStackTop + 1) {\n+            // Call from Icode_GOSUB: store return PC address in the local\n+            indexReg += frame.localShift;\n+            stack[indexReg] = stack[stackTop];\n+            sDbl[indexReg] = sDbl[stackTop];\n+            --stackTop;\n+        } else {\n+            // Call from exception handler: exception object is already stored\n+            // in the local\n+            if (stackTop != frame.emptyStackTop) Kit.codeBug();\n+        }\n+        continue Loop;\n+    case Icode_RETSUB : {\n+        // indexReg: local to store return address\n+        if (instructionCounting) {\n+            addInstructionCount(cx, frame, 0);\n+        }\n+        indexReg += frame.localShift;\n+        Object value = stack[indexReg];\n+        if (value != DBL_MRK) {\n+            // Invocation from exception handler, restore object to rethrow\n+            throwable = value;\n+            break withoutExceptions;\n+        }\n+        // Normal return from GOSUB\n+        frame.pc = (int)sDbl[indexReg];\n+        if (instructionCounting) {\n+            frame.pcPrevBranch = frame.pc;\n+        }\n+        continue Loop;\n+    }\n+    case Icode_POP :\n+        stack[stackTop] = null;\n+        stackTop--;\n+        continue Loop;\n+    case Icode_POP_RESULT :\n+        frame.result = stack[stackTop];\n+        frame.resultDbl = sDbl[stackTop];\n+        stack[stackTop] = null;\n+        --stackTop;\n+        continue Loop;\n+    case Icode_DUP :\n+        stack[stackTop + 1] = stack[stackTop];\n+        sDbl[stackTop + 1] = sDbl[stackTop];\n+        stackTop++;\n+        continue Loop;\n+    case Icode_DUP2 :\n+        stack[stackTop + 1] = stack[stackTop - 1];\n+        sDbl[stackTop + 1] = sDbl[stackTop - 1];\n+        stack[stackTop + 2] = stack[stackTop];\n+        sDbl[stackTop + 2] = sDbl[stackTop];\n+        stackTop += 2;\n+        continue Loop;\n+    case Icode_SWAP : {\n+        Object o = stack[stackTop];\n+        stack[stackTop] = stack[stackTop - 1];\n+        stack[stackTop - 1] = o;\n+        double d = sDbl[stackTop];\n+        sDbl[stackTop] = sDbl[stackTop - 1];\n+        sDbl[stackTop - 1] = d;\n+        continue Loop;\n+    }\n+    case Token.RETURN :\n+        frame.result = stack[stackTop];\n+        frame.resultDbl = sDbl[stackTop];\n+        --stackTop;\n+        break Loop;\n+    case Token.RETURN_RESULT :\n+        break Loop;\n+    case Icode_RETUNDEF :\n+        frame.result = undefined;\n+        break Loop;\n+    case Token.BITNOT : {\n+        int rIntValue = stack_int32(frame, stackTop);\n+        stack[stackTop] = DBL_MRK;\n+        sDbl[stackTop] = ~rIntValue;\n+        continue Loop;\n+    }\n+    case Token.BITAND :\n+    case Token.BITOR :\n+    case Token.BITXOR :\n+    case Token.LSH :\n+    case Token.RSH : {\n+        int lIntValue = stack_int32(frame, stackTop-1);\n+        int rIntValue = stack_int32(frame, stackTop);\n+        stack[--stackTop] = DBL_MRK;\n+        switch (op) {\n+          case Token.BITAND:\n+            lIntValue &= rIntValue;\n+            break;\n+          case Token.BITOR:\n+            lIntValue |= rIntValue;\n+            break;\n+          case Token.BITXOR:\n+            lIntValue ^= rIntValue;\n+            break;\n+          case Token.LSH:\n+            lIntValue <<= rIntValue;\n+            break;\n+          case Token.RSH:\n+            lIntValue >>= rIntValue;\n+            break;\n+        }\n+        sDbl[stackTop] = lIntValue;\n+        continue Loop;\n+    }\n+    case Token.URSH : {\n+        double lDbl = stack_double(frame, stackTop-1);\n+        int rIntValue = stack_int32(frame, stackTop) & 0x1F;\n+        stack[--stackTop] = DBL_MRK;\n+        sDbl[stackTop] = ScriptRuntime.toUint32(lDbl) >>> rIntValue;\n+        continue Loop;\n+    }\n+    case Token.NEG :\n+    case Token.POS : {\n+        double rDbl = stack_double(frame, stackTop);\n+        stack[stackTop] = DBL_MRK;\n+        if (op == Token.NEG) {\n+            rDbl = -rDbl;\n+        }\n+        sDbl[stackTop] = rDbl;\n+        continue Loop;\n+    }\n+    case Token.ADD :\n+        --stackTop;\n+        do_add(stack, sDbl, stackTop, cx);\n+        continue Loop;\n+    case Token.SUB :\n+    case Token.MUL :\n+    case Token.DIV :\n+    case Token.MOD : {\n+        double rDbl = stack_double(frame, stackTop);\n+        --stackTop;\n+        double lDbl = stack_double(frame, stackTop);\n+        stack[stackTop] = DBL_MRK;\n+        switch (op) {\n+          case Token.SUB:\n+            lDbl -= rDbl;\n+            break;\n+          case Token.MUL:\n+            lDbl *= rDbl;\n+            break;\n+          case Token.DIV:\n+            lDbl /= rDbl;\n+            break;\n+          case Token.MOD:\n+            lDbl %= rDbl;\n+            break;\n+        }\n+        sDbl[stackTop] = lDbl;\n+        continue Loop;\n+    }\n+    case Token.NOT :\n+        stack[stackTop] = ScriptRuntime.wrapBoolean(\n+                              !stack_boolean(frame, stackTop));\n+        continue Loop;\n+    case Token.BINDNAME :\n+        stack[++stackTop] = ScriptRuntime.bind(cx, frame.scope, stringReg);\n+        continue Loop;\n+    case Token.SETNAME : {\n+        Object rhs = stack[stackTop];\n+        if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Scriptable lhs = (Scriptable)stack[stackTop];\n+        stack[stackTop] = ScriptRuntime.setName(lhs, rhs, cx,\n+                                                frame.scope, stringReg);\n+        continue Loop;\n+    }\n+    case Icode_SETCONST: {\n+        Object rhs = stack[stackTop];\n+        if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Scriptable lhs = (Scriptable)stack[stackTop];\n+        stack[stackTop] = ScriptRuntime.setConst(lhs, rhs, cx, stringReg);\n+        continue Loop;\n+    }\n+    case Token.DELPROP : {\n+        Object rhs = stack[stackTop];\n+        if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.delete(lhs, rhs, cx);\n+        continue Loop;\n+    }\n+    case Token.GETPROPNOWARN : {\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.getObjectPropNoWarn(lhs, stringReg, cx);\n+        continue Loop;\n+    }\n+    case Token.GETPROP : {\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.getObjectProp(lhs, stringReg, cx, frame.scope);\n+        continue Loop;\n+    }\n+    case Token.SETPROP : {\n+        Object rhs = stack[stackTop];\n+        if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.setObjectProp(lhs, stringReg, rhs,\n+                                                      cx);\n+        continue Loop;\n+    }\n+    case Icode_PROP_INC_DEC : {\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.propIncrDecr(lhs, stringReg,\n+                                                     cx, iCode[frame.pc]);\n+        ++frame.pc;\n+        continue Loop;\n+    }\n+    case Token.GETELEM : {\n+        --stackTop;\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) {\n+            lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        }\n+        Object value;\n+        Object id = stack[stackTop + 1];\n+        if (id != DBL_MRK) {\n+            value = ScriptRuntime.getObjectElem(lhs, id, cx, frame.scope);\n+        } else {\n+            double d = sDbl[stackTop + 1];\n+            value = ScriptRuntime.getObjectIndex(lhs, d, cx);\n+        }\n+        stack[stackTop] = value;\n+        continue Loop;\n+    }\n+    case Token.SETELEM : {\n+        stackTop -= 2;\n+        Object rhs = stack[stackTop + 2];\n+        if (rhs == DBL_MRK) {\n+            rhs = ScriptRuntime.wrapNumber(sDbl[stackTop + 2]);\n+        }\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) {\n+            lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        }\n+        Object value;\n+        Object id = stack[stackTop + 1];\n+        if (id != DBL_MRK) {\n+            value = ScriptRuntime.setObjectElem(lhs, id, rhs, cx);\n+        } else {\n+            double d = sDbl[stackTop + 1];\n+            value = ScriptRuntime.setObjectIndex(lhs, d, rhs, cx);\n+        }\n+        stack[stackTop] = value;\n+        continue Loop;\n+    }\n+    case Icode_ELEM_INC_DEC: {\n+        Object rhs = stack[stackTop];\n+        if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.elemIncrDecr(lhs, rhs, cx,\n+                                                     iCode[frame.pc]);\n+        ++frame.pc;\n+        continue Loop;\n+    }\n+    case Token.GET_REF : {\n+        Ref ref = (Ref)stack[stackTop];\n+        stack[stackTop] = ScriptRuntime.refGet(ref, cx);\n+        continue Loop;\n+    }\n+    case Token.SET_REF : {\n+        Object value = stack[stackTop];\n+        if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Ref ref = (Ref)stack[stackTop];\n+        stack[stackTop] = ScriptRuntime.refSet(ref, value, cx);\n+        continue Loop;\n+    }\n+    case Token.DEL_REF : {\n+        Ref ref = (Ref)stack[stackTop];\n+        stack[stackTop] = ScriptRuntime.refDel(ref, cx);\n+        continue Loop;\n+    }\n+    case Icode_REF_INC_DEC : {\n+        Ref ref = (Ref)stack[stackTop];\n+        stack[stackTop] = ScriptRuntime.refIncrDecr(ref, cx, iCode[frame.pc]);\n+        ++frame.pc;\n+        continue Loop;\n+    }\n+    case Token.LOCAL_LOAD :\n+        ++stackTop;\n+        indexReg += frame.localShift;\n+        stack[stackTop] = stack[indexReg];\n+        sDbl[stackTop] = sDbl[indexReg];\n+        continue Loop;\n+    case Icode_LOCAL_CLEAR :\n+        indexReg += frame.localShift;\n+        stack[indexReg] = null;\n+        continue Loop;\n+    case Icode_NAME_AND_THIS :\n+        // stringReg: name\n+        ++stackTop;\n+        stack[stackTop] = ScriptRuntime.getNameFunctionAndThis(stringReg,\n+                                                               cx, frame.scope);\n+        ++stackTop;\n+        stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);\n+        continue Loop;\n+    case Icode_PROP_AND_THIS: {\n+        Object obj = stack[stackTop];\n+        if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        // stringReg: property\n+        stack[stackTop] = ScriptRuntime.getPropFunctionAndThis(obj, stringReg,\n+                                                               cx, frame.scope);\n+        ++stackTop;\n+        stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);\n+        continue Loop;\n+    }\n+    case Icode_ELEM_AND_THIS: {\n+        Object obj = stack[stackTop - 1];\n+        if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop - 1]);\n+        Object id = stack[stackTop];\n+        if (id == DBL_MRK) id = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop - 1] = ScriptRuntime.getElemFunctionAndThis(obj, id, cx);\n+        stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);\n+        continue Loop;\n+    }\n+    case Icode_VALUE_AND_THIS : {\n+        Object value = stack[stackTop];\n+        if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.getValueFunctionAndThis(value, cx);\n+        ++stackTop;\n+        stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);\n+        continue Loop;\n+    }\n+    case Icode_CALLSPECIAL : {\n+        if (instructionCounting) {\n+            cx.instructionCount += INVOCATION_COST;\n+        }\n+        int callType = iCode[frame.pc] & 0xFF;\n+        boolean isNew =  (iCode[frame.pc + 1] != 0);\n+        int sourceLine = getIndex(iCode, frame.pc + 2);\n+\n+        // indexReg: number of arguments\n+        if (isNew) {\n+            // stack change: function arg0 .. argN -> newResult\n+            stackTop -= indexReg;\n+\n+            Object function = stack[stackTop];\n+            if (function == DBL_MRK)\n+                function = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+            Object[] outArgs = getArgsArray(\n+                                   stack, sDbl, stackTop + 1, indexReg);\n+            stack[stackTop] = ScriptRuntime.newSpecial(\n+                                  cx, function, outArgs, frame.scope, callType);\n+        } else {\n+            // stack change: function thisObj arg0 .. argN -> result\n+            stackTop -= 1 + indexReg;\n+\n+            // Call code generation ensure that stack here\n+            // is ... Callable Scriptable\n+            Scriptable functionThis = (Scriptable)stack[stackTop + 1];\n+            Callable function = (Callable)stack[stackTop];\n+            Object[] outArgs = getArgsArray(\n+                                   stack, sDbl, stackTop + 2, indexReg);\n+            stack[stackTop] = ScriptRuntime.callSpecial(\n+                                  cx, function, functionThis, outArgs,\n+                                  frame.scope, frame.thisObj, callType,\n+                                  frame.idata.itsSourceFile, sourceLine);\n+        }\n+        frame.pc += 4;\n+        continue Loop;\n+    }\n+    case Token.CALL :\n+    case Icode_TAIL_CALL :\n+    case Token.REF_CALL : {\n+        if (instructionCounting) {\n+            cx.instructionCount += INVOCATION_COST;\n+        }\n+        // stack change: function thisObj arg0 .. argN -> result\n+        // indexReg: number of arguments\n+        stackTop -= 1 + indexReg;\n+\n+        // CALL generation ensures that fun and funThisObj\n+        // are already Scriptable and Callable objects respectively\n+        Callable fun = (Callable)stack[stackTop];\n+        Scriptable funThisObj = (Scriptable)stack[stackTop + 1];\n+        if (op == Token.REF_CALL) {\n+            Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 2,\n+                                            indexReg);\n+            stack[stackTop] = ScriptRuntime.callRef(fun, funThisObj,\n+                                                    outArgs, cx);\n+            continue Loop;\n+        }\n+        Scriptable calleeScope = frame.scope;\n+        if (frame.useActivation) {\n+            calleeScope = ScriptableObject.getTopLevelScope(frame.scope);\n+        }\n+        if (fun instanceof InterpretedFunction) {\n+            InterpretedFunction ifun = (InterpretedFunction)fun;\n+            if (frame.fnOrScript.securityDomain == ifun.securityDomain) {\n+                CallFrame callParentFrame = frame;\n+                CallFrame calleeFrame = new CallFrame();\n+                if (op == Icode_TAIL_CALL) {\n+                    // In principle tail call can re-use the current\n+                    // frame and its stack arrays but it is hard to\n+                    // do properly. Any exceptions that can legally\n+                    // happen during frame re-initialization including\n+                    // StackOverflowException during innocent looking\n+                    // System.arraycopy may leave the current frame\n+                    // data corrupted leading to undefined behaviour\n+                    // in the catch code bellow that unwinds JS stack\n+                    // on exceptions. Then there is issue about frame release\n+                    // end exceptions there.\n+                    // To avoid frame allocation a released frame\n+                    // can be cached for re-use which would also benefit\n+                    // non-tail calls but it is not clear that this caching\n+                    // would gain in performance due to potentially\n+                    // bad interaction with GC.\n+                    callParentFrame = frame.parentFrame;\n+                    // Release the current frame. See Bug #344501 to see why\n+                    // it is being done here.\n+                    exitFrame(cx, frame, null);\n+                }\n+                initFrame(cx, calleeScope, funThisObj, stack, sDbl,\n+                          stackTop + 2, indexReg, ifun, callParentFrame,\n+                          calleeFrame);\n+                if (op != Icode_TAIL_CALL) {\n+                    frame.savedStackTop = stackTop;\n+                    frame.savedCallOp = op;\n+                }\n+                frame = calleeFrame;\n+                continue StateLoop;\n+            }\n+        }\n+\n+        if (fun instanceof NativeContinuation) {\n+            // Jump to the captured continuation\n+            ContinuationJump cjump;\n+            cjump = new ContinuationJump((NativeContinuation)fun, frame);\n+\n+            // continuation result is the first argument if any\n+            // of continuation call\n+            if (indexReg == 0) {\n+                cjump.result = undefined;\n+            } else {\n+                cjump.result = stack[stackTop + 2];\n+                cjump.resultDbl = sDbl[stackTop + 2];\n+            }\n+\n+            // Start the real unwind job\n+            throwable = cjump;\n+            break withoutExceptions;\n+        }\n+\n+        if (fun instanceof IdFunctionObject) {\n+            IdFunctionObject ifun = (IdFunctionObject)fun;\n+            if (NativeContinuation.isContinuationConstructor(ifun)) {\n+                frame.stack[stackTop] = captureContinuation(cx,\n+                        frame.parentFrame, false);\n+                continue Loop;\n+            }\n+            // Bug 405654 -- make best effort to keep Function.apply and\n+            // Function.call within this interpreter loop invocation\n+            if (BaseFunction.isApplyOrCall(ifun)) {\n+                Callable applyCallable = ScriptRuntime.getCallable(funThisObj);\n+                if (applyCallable instanceof InterpretedFunction) {\n+                    InterpretedFunction iApplyCallable = (InterpretedFunction)applyCallable;\n+                    if (frame.fnOrScript.securityDomain == iApplyCallable.securityDomain) {\n+                        frame = initFrameForApplyOrCall(cx, frame, indexReg,\n+                                stack, sDbl, stackTop, op, calleeScope, ifun,\n+                                iApplyCallable);\n+                        continue StateLoop;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Bug 447697 -- make best effort to keep __noSuchMethod__ within this  \n+        // interpreter loop invocation\n+        if (fun instanceof NoSuchMethodShim) {\n+            // get the shim and the actual method\n+            NoSuchMethodShim noSuchMethodShim = (NoSuchMethodShim) fun;\n+            Callable noSuchMethodMethod = noSuchMethodShim.noSuchMethodMethod;\n+            // if the method is in fact an InterpretedFunction\n+            if (noSuchMethodMethod instanceof InterpretedFunction) {\n+                InterpretedFunction ifun = (InterpretedFunction) noSuchMethodMethod;\n+                if (frame.fnOrScript.securityDomain == ifun.securityDomain) {\n+                    frame = initFrameForNoSuchMethod(cx, frame, indexReg, stack, sDbl,\n+                                             stackTop, op, funThisObj, calleeScope,\n+                                             noSuchMethodShim, ifun);\n+                    continue StateLoop;\n+                }\n+            }\n+        }\n+\n+        cx.lastInterpreterFrame = frame;\n+        frame.savedCallOp = op;\n+        frame.savedStackTop = stackTop;\n+        stack[stackTop] = fun.call(cx, calleeScope, funThisObj, \n+                getArgsArray(stack, sDbl, stackTop + 2, indexReg));\n+\n+        continue Loop;\n+    }\n+    case Token.NEW : {\n+        if (instructionCounting) {\n+            cx.instructionCount += INVOCATION_COST;\n+        }\n+        // stack change: function arg0 .. argN -> newResult\n+        // indexReg: number of arguments\n+        stackTop -= indexReg;\n+\n+        Object lhs = stack[stackTop];\n+        if (lhs instanceof InterpretedFunction) {\n+            InterpretedFunction f = (InterpretedFunction)lhs;\n+            if (frame.fnOrScript.securityDomain == f.securityDomain) {\n+                Scriptable newInstance = f.createObject(cx, frame.scope);\n+                CallFrame calleeFrame = new CallFrame();\n+                initFrame(cx, frame.scope, newInstance, stack, sDbl,\n+                          stackTop + 1, indexReg, f, frame,\n+                          calleeFrame);\n+\n+                stack[stackTop] = newInstance;\n+                frame.savedStackTop = stackTop;\n+                frame.savedCallOp = op;\n+                frame = calleeFrame;\n+                continue StateLoop;\n+            }\n+        }\n+        if (!(lhs instanceof Function)) {\n+            if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+            throw ScriptRuntime.notFunctionError(lhs);\n+        }\n+        Function fun = (Function)lhs;\n+\n+        if (fun instanceof IdFunctionObject) {\n+            IdFunctionObject ifun = (IdFunctionObject)fun;\n+            if (NativeContinuation.isContinuationConstructor(ifun)) {\n+                frame.stack[stackTop] =\n+                    captureContinuation(cx, frame.parentFrame, false);\n+                continue Loop;\n+            }\n+        }\n+\n+        Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 1, indexReg);\n+        stack[stackTop] = fun.construct(cx, frame.scope, outArgs);\n+        continue Loop;\n+    }\n+    case Token.TYPEOF : {\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.typeof(lhs);\n+        continue Loop;\n+    }\n+    case Icode_TYPEOFNAME :\n+        stack[++stackTop] = ScriptRuntime.typeofName(frame.scope, stringReg);\n+        continue Loop;\n+    case Token.STRING :\n+        stack[++stackTop] = stringReg;\n+        continue Loop;\n+    case Icode_SHORTNUMBER :\n+        ++stackTop;\n+        stack[stackTop] = DBL_MRK;\n+        sDbl[stackTop] = getShort(iCode, frame.pc);\n+        frame.pc += 2;\n+        continue Loop;\n+    case Icode_INTNUMBER :\n+        ++stackTop;\n+        stack[stackTop] = DBL_MRK;\n+        sDbl[stackTop] = getInt(iCode, frame.pc);\n+        frame.pc += 4;\n+        continue Loop;\n+    case Token.NUMBER :\n+        ++stackTop;\n+        stack[stackTop] = DBL_MRK;\n+        sDbl[stackTop] = frame.idata.itsDoubleTable[indexReg];\n+        continue Loop;\n+    case Token.NAME :\n+        stack[++stackTop] = ScriptRuntime.name(cx, frame.scope, stringReg);\n+        continue Loop;\n+    case Icode_NAME_INC_DEC :\n+        stack[++stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, stringReg,\n+                                                       cx, iCode[frame.pc]);\n+        ++frame.pc;\n+        continue Loop;\n+    case Icode_SETCONSTVAR1:\n+        indexReg = iCode[frame.pc++];\n+        // fallthrough\n+    case Token.SETCONSTVAR :\n+        if (!frame.useActivation) {\n+            if ((varAttributes[indexReg] & ScriptableObject.READONLY) == 0) {\n+                throw Context.reportRuntimeError1(\"msg.var.redecl\",\n+                                                  frame.idata.argNames[indexReg]);\n+            }\n+            if ((varAttributes[indexReg] & ScriptableObject.UNINITIALIZED_CONST)\n+                != 0)\n+            {\n+                vars[indexReg] = stack[stackTop];\n+                varAttributes[indexReg] &= ~ScriptableObject.UNINITIALIZED_CONST;\n+                varDbls[indexReg] = sDbl[stackTop];\n+            }\n+        } else {\n+            Object val = stack[stackTop];\n+            if (val == DBL_MRK) val = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+            stringReg = frame.idata.argNames[indexReg];\n+            if (frame.scope instanceof ConstProperties) {\n+                ConstProperties cp = (ConstProperties)frame.scope;\n+                cp.putConst(stringReg, frame.scope, val);\n+            } else\n+                throw Kit.codeBug();\n+        }\n+        continue Loop;\n+    case Icode_SETVAR1:\n+        indexReg = iCode[frame.pc++];\n+        // fallthrough\n+    case Token.SETVAR :\n+        if (!frame.useActivation) {\n+            if ((varAttributes[indexReg] & ScriptableObject.READONLY) == 0) {\n+                vars[indexReg] = stack[stackTop];\n+                varDbls[indexReg] = sDbl[stackTop];\n+            }\n+        } else {\n+            Object val = stack[stackTop];\n+            if (val == DBL_MRK) val = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+            stringReg = frame.idata.argNames[indexReg];\n+            frame.scope.put(stringReg, frame.scope, val);\n+        }\n+        continue Loop;\n+    case Icode_GETVAR1:\n+        indexReg = iCode[frame.pc++];\n+        // fallthrough\n+    case Token.GETVAR :\n+        ++stackTop;\n+        if (!frame.useActivation) {\n+            stack[stackTop] = vars[indexReg];\n+            sDbl[stackTop] = varDbls[indexReg];\n+        } else {\n+            stringReg = frame.idata.argNames[indexReg];\n+            stack[stackTop] = frame.scope.get(stringReg, frame.scope);\n+        }\n+        continue Loop;\n+    case Icode_VAR_INC_DEC : {\n+        // indexReg : varindex\n+        ++stackTop;\n+        int incrDecrMask = iCode[frame.pc];\n+        if (!frame.useActivation) {\n+            stack[stackTop] = DBL_MRK;\n+            Object varValue = vars[indexReg];\n+            double d;\n+            if (varValue == DBL_MRK) {\n+                d = varDbls[indexReg];\n+            } else {\n+                d = ScriptRuntime.toNumber(varValue);\n+                vars[indexReg] = DBL_MRK;\n+            }\n+            double d2 = ((incrDecrMask & Node.DECR_FLAG) == 0)\n+                        ? d + 1.0 : d - 1.0;\n+            varDbls[indexReg] = d2;\n+            sDbl[stackTop] = ((incrDecrMask & Node.POST_FLAG) == 0) ? d2 : d;\n+        } else {\n+            String varName = frame.idata.argNames[indexReg];\n+            stack[stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, varName,\n+                                                         cx, incrDecrMask);\n+        }\n+        ++frame.pc;\n+        continue Loop;\n+    }\n+    case Icode_ZERO :\n+        ++stackTop;\n+        stack[stackTop] = DBL_MRK;\n+        sDbl[stackTop] = 0;\n+        continue Loop;\n+    case Icode_ONE :\n+        ++stackTop;\n+        stack[stackTop] = DBL_MRK;\n+        sDbl[stackTop] = 1;\n+        continue Loop;\n+    case Token.NULL :\n+        stack[++stackTop] = null;\n+        continue Loop;\n+    case Token.THIS :\n+        stack[++stackTop] = frame.thisObj;\n+        continue Loop;\n+    case Token.THISFN :\n+        stack[++stackTop] = frame.fnOrScript;\n+        continue Loop;\n+    case Token.FALSE :\n+        stack[++stackTop] = Boolean.FALSE;\n+        continue Loop;\n+    case Token.TRUE :\n+        stack[++stackTop] = Boolean.TRUE;\n+        continue Loop;\n+    case Icode_UNDEF :\n+        stack[++stackTop] = undefined;\n+        continue Loop;\n+    case Token.ENTERWITH : {\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        frame.scope = ScriptRuntime.enterWith(lhs, cx, frame.scope);\n+        continue Loop;\n+    }\n+    case Token.LEAVEWITH :\n+        frame.scope = ScriptRuntime.leaveWith(frame.scope);\n+        continue Loop;\n+    case Token.CATCH_SCOPE : {\n+        // stack top: exception object\n+        // stringReg: name of exception variable\n+        // indexReg: local for exception scope\n+        --stackTop;\n+        indexReg += frame.localShift;\n+\n+        boolean afterFirstScope =  (frame.idata.itsICode[frame.pc] != 0);\n+        Throwable caughtException = (Throwable)stack[stackTop + 1];\n+        Scriptable lastCatchScope;\n+        if (!afterFirstScope) {\n+            lastCatchScope = null;\n+        } else {\n+            lastCatchScope = (Scriptable)stack[indexReg];\n+        }\n+        stack[indexReg] = ScriptRuntime.newCatchScope(caughtException,\n+                                                      lastCatchScope, stringReg,\n+                                                      cx, frame.scope);\n+        ++frame.pc;\n+        continue Loop;\n+    }\n+    case Token.ENUM_INIT_KEYS :\n+    case Token.ENUM_INIT_VALUES :\n+    case Token.ENUM_INIT_ARRAY : {\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        indexReg += frame.localShift;\n+        int enumType = op == Token.ENUM_INIT_KEYS\n+                         ? ScriptRuntime.ENUMERATE_KEYS :\n+                       op == Token.ENUM_INIT_VALUES\n+                         ? ScriptRuntime.ENUMERATE_VALUES :\n+                       ScriptRuntime.ENUMERATE_ARRAY;\n+        stack[indexReg] = ScriptRuntime.enumInit(lhs, cx, enumType);\n+        continue Loop;\n+    }\n+    case Token.ENUM_NEXT :\n+    case Token.ENUM_ID : {\n+        indexReg += frame.localShift;\n+        Object val = stack[indexReg];\n+        ++stackTop;\n+        stack[stackTop] = (op == Token.ENUM_NEXT)\n+                          ? (Object)ScriptRuntime.enumNext(val)\n+                          : (Object)ScriptRuntime.enumId(val, cx);\n+        continue Loop;\n+    }\n+    case Token.REF_SPECIAL : {\n+        //stringReg: name of special property\n+        Object obj = stack[stackTop];\n+        if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.specialRef(obj, stringReg, cx);\n+        continue Loop;\n+    }\n+    case Token.REF_MEMBER: {\n+        //indexReg: flags\n+        Object elem = stack[stackTop];\n+        if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Object obj = stack[stackTop];\n+        if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.memberRef(obj, elem, cx, indexReg);\n+        continue Loop;\n+    }\n+    case Token.REF_NS_MEMBER: {\n+        //indexReg: flags\n+        Object elem = stack[stackTop];\n+        if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Object ns = stack[stackTop];\n+        if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Object obj = stack[stackTop];\n+        if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.memberRef(obj, ns, elem, cx, indexReg);\n+        continue Loop;\n+    }\n+    case Token.REF_NAME: {\n+        //indexReg: flags\n+        Object name = stack[stackTop];\n+        if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.nameRef(name, cx, frame.scope,\n+                                                indexReg);\n+        continue Loop;\n+    }\n+    case Token.REF_NS_NAME: {\n+        //indexReg: flags\n+        Object name = stack[stackTop];\n+        if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        Object ns = stack[stackTop];\n+        if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.nameRef(ns, name, cx, frame.scope,\n+                                                indexReg);\n+        continue Loop;\n+    }\n+    case Icode_SCOPE_LOAD :\n+        indexReg += frame.localShift;\n+        frame.scope = (Scriptable)stack[indexReg];\n+        continue Loop;\n+    case Icode_SCOPE_SAVE :\n+        indexReg += frame.localShift;\n+        stack[indexReg] = frame.scope;\n+        continue Loop;\n+    case Icode_CLOSURE_EXPR :\n+        stack[++stackTop] = InterpretedFunction.createFunction(cx, frame.scope,\n+                                                               frame.fnOrScript,\n+                                                               indexReg);\n+        continue Loop;\n+    case Icode_CLOSURE_STMT :\n+        initFunction(cx, frame.scope, frame.fnOrScript, indexReg);\n+        continue Loop;\n+    case Token.REGEXP :\n+        stack[++stackTop] = frame.scriptRegExps[indexReg];\n+        continue Loop;\n+    case Icode_LITERAL_NEW :\n+        // indexReg: number of values in the literal\n+        ++stackTop;\n+        stack[stackTop] = new int[indexReg];\n+        ++stackTop;\n+        stack[stackTop] = new Object[indexReg];\n+        sDbl[stackTop] = 0;\n+        continue Loop;\n+    case Icode_LITERAL_SET : {\n+        Object value = stack[stackTop];\n+        if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        int i = (int)sDbl[stackTop];\n+        ((Object[])stack[stackTop])[i] = value;\n+        sDbl[stackTop] = i + 1;\n+        continue Loop;\n+    }\n+    case Icode_LITERAL_GETTER : {\n+        Object value = stack[stackTop];\n+        --stackTop;\n+        int i = (int)sDbl[stackTop];\n+        ((Object[])stack[stackTop])[i] = value;\n+        ((int[])stack[stackTop - 1])[i] = -1;\n+        sDbl[stackTop] = i + 1;\n+        continue Loop;\n+    }\n+    case Icode_LITERAL_SETTER : {\n+        Object value = stack[stackTop];\n+        --stackTop;\n+        int i = (int)sDbl[stackTop];\n+        ((Object[])stack[stackTop])[i] = value;\n+        ((int[])stack[stackTop - 1])[i] = +1;\n+        sDbl[stackTop] = i + 1;\n+        continue Loop;\n+    }\n+    case Token.ARRAYLIT :\n+    case Icode_SPARE_ARRAYLIT :\n+    case Token.OBJECTLIT : {\n+        Object[] data = (Object[])stack[stackTop];\n+        --stackTop;\n+        int[] getterSetters = (int[])stack[stackTop];\n+        Object val;\n+        if (op == Token.OBJECTLIT) {\n+            Object[] ids = (Object[])frame.idata.literalIds[indexReg];\n+            val = ScriptRuntime.newObjectLiteral(ids, data, getterSetters, cx,\n+                    frame.scope);\n+        } else {\n+            int[] skipIndexces = null;\n+            if (op == Icode_SPARE_ARRAYLIT) {\n+                skipIndexces = (int[])frame.idata.literalIds[indexReg];\n+            }\n+            val = ScriptRuntime.newArrayLiteral(data, skipIndexces, cx,\n+                                                frame.scope);\n+        }\n+        stack[stackTop] = val;\n+        continue Loop;\n+    }\n+    case Icode_ENTERDQ : {\n+        Object lhs = stack[stackTop];\n+        if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        --stackTop;\n+        frame.scope = ScriptRuntime.enterDotQuery(lhs, frame.scope);\n+        continue Loop;\n+    }\n+    case Icode_LEAVEDQ : {\n+        boolean valBln = stack_boolean(frame, stackTop);\n+        Object x = ScriptRuntime.updateDotQuery(valBln, frame.scope);\n+        if (x != null) {\n+            stack[stackTop] = x;\n+            frame.scope = ScriptRuntime.leaveDotQuery(frame.scope);\n+            frame.pc += 2;\n+            continue Loop;\n+        }\n+        // reset stack and PC to code after ENTERDQ\n+        --stackTop;\n+        break jumplessRun;\n+    }\n+    case Token.DEFAULTNAMESPACE : {\n+        Object value = stack[stackTop];\n+        if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);\n+        stack[stackTop] = ScriptRuntime.setDefaultNamespace(value, cx);\n+        continue Loop;\n+    }\n+    case Token.ESCXMLATTR : {\n+        Object value = stack[stackTop];\n+        if (value != DBL_MRK) {\n+            stack[stackTop] = ScriptRuntime.escapeAttributeValue(value, cx);\n+        }\n+        continue Loop;\n+    }\n+    case Token.ESCXMLTEXT : {\n+        Object value = stack[stackTop];\n+        if (value != DBL_MRK) {\n+            stack[stackTop] = ScriptRuntime.escapeTextValue(value, cx);\n+        }\n+        continue Loop;\n+    }\n+    case Icode_DEBUGGER:\n+        if (frame.debuggerFrame != null) {\n+            frame.debuggerFrame.onDebuggerStatement(cx);\n+        }\n+        continue Loop;\n+    case Icode_LINE :\n+        frame.pcSourceLineStart = frame.pc;\n+        if (frame.debuggerFrame != null) {\n+            int line = getIndex(iCode, frame.pc);\n+            frame.debuggerFrame.onLineChange(cx, line);\n+        }\n+        frame.pc += 2;\n+        continue Loop;\n+    case Icode_REG_IND_C0:\n+        indexReg = 0;\n+        continue Loop;\n+    case Icode_REG_IND_C1:\n+        indexReg = 1;\n+        continue Loop;\n+    case Icode_REG_IND_C2:\n+        indexReg = 2;\n+        continue Loop;\n+    case Icode_REG_IND_C3:\n+        indexReg = 3;\n+        continue Loop;\n+    case Icode_REG_IND_C4:\n+        indexReg = 4;\n+        continue Loop;\n+    case Icode_REG_IND_C5:\n+        indexReg = 5;\n+        continue Loop;\n+    case Icode_REG_IND1:\n+        indexReg = 0xFF & iCode[frame.pc];\n+        ++frame.pc;\n+        continue Loop;\n+    case Icode_REG_IND2:\n+        indexReg = getIndex(iCode, frame.pc);\n+        frame.pc += 2;\n+        continue Loop;\n+    case Icode_REG_IND4:\n+        indexReg = getInt(iCode, frame.pc);\n+        frame.pc += 4;\n+        continue Loop;\n+    case Icode_REG_STR_C0:\n+        stringReg = strings[0];\n+        continue Loop;\n+    case Icode_REG_STR_C1:\n+        stringReg = strings[1];\n+        continue Loop;\n+    case Icode_REG_STR_C2:\n+        stringReg = strings[2];\n+        continue Loop;\n+    case Icode_REG_STR_C3:\n+        stringReg = strings[3];\n+        continue Loop;\n+    case Icode_REG_STR1:\n+        stringReg = strings[0xFF & iCode[frame.pc]];\n+        ++frame.pc;\n+        continue Loop;\n+    case Icode_REG_STR2:\n+        stringReg = strings[getIndex(iCode, frame.pc)];\n+        frame.pc += 2;\n+        continue Loop;\n+    case Icode_REG_STR4:\n+        stringReg = strings[getInt(iCode, frame.pc)];\n+        frame.pc += 4;\n+        continue Loop;\n+    default :\n+        dumpICode(frame.idata);\n+        throw new RuntimeException(\n+            \"Unknown icode : \"+op+\" @ pc : \"+(frame.pc-1));\n+}  // end of interpreter switch\n+\n+                    } // end of jumplessRun label block\n+\n+                    // This should be reachable only for jump implementation\n+                    // when pc points to encoded target offset\n+                    if (instructionCounting) {\n+                        addInstructionCount(cx, frame, 2);\n+                    }\n+                    int offset = getShort(iCode, frame.pc);\n+                    if (offset != 0) {\n+                        // -1 accounts for pc pointing to jump opcode + 1\n+                        frame.pc += offset - 1;\n+                    } else {\n+                        frame.pc = frame.idata.longJumps.\n+                                       getExistingInt(frame.pc);\n+                    }\n+                    if (instructionCounting) {\n+                        frame.pcPrevBranch = frame.pc;\n+                    }\n+                    continue Loop;\n+\n+                } // end of Loop: for\n+\n+                exitFrame(cx, frame, null);\n+                interpreterResult = frame.result;\n+                interpreterResultDbl = frame.resultDbl;\n+                if (frame.parentFrame != null) {\n+                    frame = frame.parentFrame;\n+                    if (frame.frozen) {\n+                        frame = frame.cloneFrozen();\n+                    }\n+                    setCallResult(\n+                        frame, interpreterResult, interpreterResultDbl);\n+                    interpreterResult = null; // Help GC\n+                    continue StateLoop;\n+                }\n+                break StateLoop;\n+\n+            }  // end of interpreter withoutExceptions: try\n+            catch (Throwable ex) {\n+                if (throwable != null) {\n+                    // This is serious bug and it is better to track it ASAP\n+                    ex.printStackTrace(System.err);\n+                    throw new IllegalStateException();\n+                }\n+                throwable = ex;\n+            }\n+\n+            // This should be reachable only after above catch or from\n+            // finally when it needs to propagate exception or from\n+            // explicit throw\n+            if (throwable == null) Kit.codeBug();\n+\n+            // Exception type\n+            final int EX_CATCH_STATE = 2; // Can execute JS catch\n+            final int EX_FINALLY_STATE = 1; // Can execute JS finally\n+            final int EX_NO_JS_STATE = 0; // Terminate JS execution\n+\n+            int exState;\n+            ContinuationJump cjump = null;\n+\n+            if (generatorState != null &&\n+                generatorState.operation == NativeGenerator.GENERATOR_CLOSE &&\n+                throwable == generatorState.value)\n+            {\n+                exState = EX_FINALLY_STATE;\n+            } else if (throwable instanceof JavaScriptException) {\n+                exState = EX_CATCH_STATE;\n+            } else if (throwable instanceof EcmaError) {\n+                // an offical ECMA error object,\n+                exState = EX_CATCH_STATE;\n+            } else if (throwable instanceof EvaluatorException) {\n+                exState = EX_CATCH_STATE;\n+            } else if (throwable instanceof RuntimeException) {\n+                exState = cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS)\n+                          ? EX_CATCH_STATE\n+                          : EX_FINALLY_STATE;\n+            } else if (throwable instanceof Error) {\n+                exState = cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS)\n+                          ? EX_CATCH_STATE\n+                          : EX_NO_JS_STATE;\n+            } else if (throwable instanceof ContinuationJump) {\n+                // It must be ContinuationJump\n+                exState = EX_FINALLY_STATE;\n+                cjump = (ContinuationJump)throwable;\n+            } else {\n+                exState = cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS)\n+                          ? EX_CATCH_STATE\n+                          : EX_FINALLY_STATE;\n+            }\n+\n+            if (instructionCounting) {\n+                try {\n+                    addInstructionCount(cx, frame, EXCEPTION_COST);\n+                } catch (RuntimeException ex) {\n+                    throwable = ex;\n+                    exState = EX_FINALLY_STATE;\n+                } catch (Error ex) {\n+                    // Error from instruction counting\n+                    //     => unconditionally terminate JS\n+                    throwable = ex;\n+                    cjump = null;\n+                    exState = EX_NO_JS_STATE;\n+                }\n+            }\n+            if (frame.debuggerFrame != null\n+                && throwable instanceof RuntimeException)\n+            {\n+                // Call debugger only for RuntimeException\n+                RuntimeException rex = (RuntimeException)throwable;\n+                try {\n+                    frame.debuggerFrame.onExceptionThrown(cx, rex);\n+                } catch (Throwable ex) {\n+                    // Any exception from debugger\n+                    //     => unconditionally terminate JS\n+                    throwable = ex;\n+                    cjump = null;\n+                    exState = EX_NO_JS_STATE;\n+                }\n+            }\n+\n+            for (;;) {\n+                if (exState != EX_NO_JS_STATE) {\n+                    boolean onlyFinally = (exState != EX_CATCH_STATE);\n+                    indexReg = getExceptionHandler(frame, onlyFinally);\n+                    if (indexReg >= 0) {\n+                        // We caught an exception, restart the loop\n+                        // with exception pending the processing at the loop\n+                        // start\n+                        continue StateLoop;\n+                    }\n+                }\n+                // No allowed exception handlers in this frame, unwind\n+                // to parent and try to look there\n+\n+                exitFrame(cx, frame, throwable);\n+\n+                frame = frame.parentFrame;\n+                if (frame == null) { break; }\n+                if (cjump != null && cjump.branchFrame == frame) {\n+                    // Continuation branch point was hit,\n+                    // restart the state loop to reenter continuation\n+                    indexReg = -1;\n+                    continue StateLoop;\n+                }\n+            }\n+\n+            // No more frames, rethrow the exception or deal with continuation\n+            if (cjump != null) {\n+                if (cjump.branchFrame != null) {\n+                    // The above loop should locate the top frame\n+                    Kit.codeBug();\n+                }\n+                if (cjump.capturedFrame != null) {\n+                    // Restarting detached continuation\n+                    indexReg = -1;\n+                    continue StateLoop;\n+                }\n+                // Return continuation result to the caller\n+                interpreterResult = cjump.result;\n+                interpreterResultDbl = cjump.resultDbl;\n+                throwable = null;\n+            }\n+            break StateLoop;\n+\n+        } // end of StateLoop: for(;;)\n+\n+        // Do cleanups/restorations before the final return or throw\n+\n+        if (cx.previousInterpreterInvocations != null\n+            && cx.previousInterpreterInvocations.size() != 0)\n+        {\n+            cx.lastInterpreterFrame\n+                = cx.previousInterpreterInvocations.pop();\n+        } else {\n+            // It was the last interpreter frame on the stack\n+            cx.lastInterpreterFrame = null;\n+            // Force GC of the value cx.previousInterpreterInvocations\n+            cx.previousInterpreterInvocations = null;\n+        }\n+\n+        if (throwable != null) {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                // Must be instance of Error or code bug\n+                throw (Error)throwable;\n+            }\n+        }\n+\n+        return (interpreterResult != DBL_MRK)\n+               ? interpreterResult\n+               : ScriptRuntime.wrapNumber(interpreterResultDbl);\n+    }\n+\n+    /**\n+     * Call __noSuchMethod__.\n+     */\n+    private static CallFrame initFrameForNoSuchMethod(Context cx,\n+            CallFrame frame, int indexReg, Object[] stack, double[] sDbl,\n+            int stackTop, int op, Scriptable funThisObj, Scriptable calleeScope,\n+            NoSuchMethodShim noSuchMethodShim, InterpretedFunction ifun)\n+    {\n+        // create an args array from the stack\n+        Object[] argsArray = null;\n+        // exactly like getArgsArray except that the first argument\n+        // is the method name from the shim\n+        int shift = stackTop + 2;\n+        Object[] elements = new Object[indexReg];\n+        for (int i=0; i < indexReg; ++i, ++shift) {\n+            Object val = stack[shift];\n+            if (val == UniqueTag.DOUBLE_MARK) {\n+                val = ScriptRuntime.wrapNumber(sDbl[shift]);\n+            }\n+            elements[i] = val;\n+        }\n+        argsArray = new Object[2];\n+        argsArray[0] = noSuchMethodShim.methodName;\n+        argsArray[1] = cx.newArray(calleeScope, elements);\n+        \n+        // exactly the same as if it's a regular InterpretedFunction\n+        CallFrame callParentFrame = frame;\n+        CallFrame calleeFrame = new CallFrame();\n+        if (op == Icode_TAIL_CALL) {\n+            callParentFrame = frame.parentFrame;\n+            exitFrame(cx, frame, null);\n+        }\n+        // init the frame with the underlying method with the \n+        // adjusted args array and shim's function\n+        initFrame(cx, calleeScope, funThisObj, argsArray, null,\n+          0, 2, ifun, callParentFrame, calleeFrame);\n+        if (op != Icode_TAIL_CALL) {\n+            frame.savedStackTop = stackTop;\n+            frame.savedCallOp = op;\n+        }\n+        return calleeFrame;\n+    }\n+    \n+    private static boolean shallowEquals(Object[] stack, double[] sDbl,\n+            int stackTop)\n+    {\n+        Object rhs = stack[stackTop + 1];\n+        Object lhs = stack[stackTop];\n+        final Object DBL_MRK = UniqueTag.DOUBLE_MARK;\n+        double rdbl, ldbl;\n+        if (rhs == DBL_MRK) {\n+            rdbl = sDbl[stackTop + 1];\n+            if (lhs == DBL_MRK) {\n+                ldbl = sDbl[stackTop];\n+            } else if (lhs instanceof Number) {\n+                ldbl = ((Number)lhs).doubleValue();\n+            } else {\n+                return false;\n+            }\n+        } else if (lhs == DBL_MRK) {\n+            ldbl = sDbl[stackTop];\n+            if (rhs == DBL_MRK) {\n+                rdbl = sDbl[stackTop + 1];\n+            } else if (rhs instanceof Number) {\n+                rdbl = ((Number)rhs).doubleValue();\n+            } else {\n+                return false;\n+            }\n+        } else {\n+            return ScriptRuntime.shallowEq(lhs, rhs);\n+        }\n+        return (ldbl == rdbl);\n+    }\n+\n+    private static CallFrame processThrowable(Context cx, Object throwable,\n+                                              CallFrame frame, int indexReg,\n+                                              boolean instructionCounting)\n+    {\n+        // Recovering from exception, indexReg contains\n+        // the index of handler\n+\n+        if (indexReg >= 0) {\n+            // Normal exception handler, transfer\n+            // control appropriately\n+\n+            if (frame.frozen) {\n+                // XXX Deal with exceptios!!!\n+                frame = frame.cloneFrozen();\n+            }\n+\n+            int[] table = frame.idata.itsExceptionTable;\n+\n+            frame.pc = table[indexReg + EXCEPTION_HANDLER_SLOT];\n+            if (instructionCounting) {\n+                frame.pcPrevBranch = frame.pc;\n+            }\n+\n+            frame.savedStackTop = frame.emptyStackTop;\n+            int scopeLocal = frame.localShift\n+                             + table[indexReg\n+                                     + EXCEPTION_SCOPE_SLOT];\n+            int exLocal = frame.localShift\n+                             + table[indexReg\n+                                     + EXCEPTION_LOCAL_SLOT];\n+            frame.scope = (Scriptable)frame.stack[scopeLocal];\n+            frame.stack[exLocal] = throwable;\n+\n+            throwable = null;\n+        } else {\n+            // Continuation restoration\n+            ContinuationJump cjump = (ContinuationJump)throwable;\n+\n+            // Clear throwable to indicate that exceptions are OK\n+            throwable = null;\n+\n+            if (cjump.branchFrame != frame) Kit.codeBug();\n+\n+            // Check that we have at least one frozen frame\n+            // in the case of detached continuation restoration:\n+            // unwind code ensure that\n+            if (cjump.capturedFrame == null) Kit.codeBug();\n+\n+            // Need to rewind branchFrame, capturedFrame\n+            // and all frames in between\n+            int rewindCount = cjump.capturedFrame.frameIndex + 1;\n+            if (cjump.branchFrame != null) {\n+                rewindCount -= cjump.branchFrame.frameIndex;\n+            }\n+\n+            int enterCount = 0;\n+            CallFrame[] enterFrames = null;\n+\n+            CallFrame x = cjump.capturedFrame;\n+            for (int i = 0; i != rewindCount; ++i) {\n+                if (!x.frozen) Kit.codeBug();\n+                if (isFrameEnterExitRequired(x)) {\n+                    if (enterFrames == null) {\n+                        // Allocate enough space to store the rest\n+                        // of rewind frames in case all of them\n+                        // would require to enter\n+                        enterFrames = new CallFrame[rewindCount\n+                                                    - i];\n+                    }\n+                    enterFrames[enterCount] = x;\n+                    ++enterCount;\n+                }\n+                x = x.parentFrame;\n+            }\n+\n+            while (enterCount != 0) {\n+                // execute enter: walk enterFrames in the reverse\n+                // order since they were stored starting from\n+                // the capturedFrame, not branchFrame\n+                --enterCount;\n+                x = enterFrames[enterCount];\n+                enterFrame(cx, x, ScriptRuntime.emptyArgs, true);\n+            }\n+\n+            // Continuation jump is almost done: capturedFrame\n+            // points to the call to the function that captured\n+            // continuation, so clone capturedFrame and\n+            // emulate return that function with the suplied result\n+            frame = cjump.capturedFrame.cloneFrozen();\n+            setCallResult(frame, cjump.result, cjump.resultDbl);\n+            // restart the execution\n+        }\n+        frame.throwable = throwable;\n+        return frame;\n+    }\n+\n+    private static Object freezeGenerator(Context cx, CallFrame frame,\n+                                          int stackTop,\n+                                          GeneratorState generatorState)\n+    {\n+          if (generatorState.operation == NativeGenerator.GENERATOR_CLOSE) {\n+              // Error: no yields when generator is closing\n+              throw ScriptRuntime.typeError0(\"msg.yield.closing\");\n+          }\n+          // return to our caller (which should be a method of NativeGenerator)\n+          frame.frozen = true;\n+          frame.result = frame.stack[stackTop];\n+          frame.resultDbl = frame.sDbl[stackTop];\n+          frame.savedStackTop = stackTop;\n+          frame.pc--; // we want to come back here when we resume\n+          ScriptRuntime.exitActivationFunction(cx);\n+          return (frame.result != UniqueTag.DOUBLE_MARK)\n+              ? frame.result\n+              : ScriptRuntime.wrapNumber(frame.resultDbl);\n+    }\n+\n+    private static Object thawGenerator(CallFrame frame, int stackTop,\n+                                        GeneratorState generatorState, int op)\n+    {\n+          // we are resuming execution\n+          frame.frozen = false;\n+          int sourceLine = getIndex(frame.idata.itsICode, frame.pc);\n+          frame.pc += 2; // skip line number data\n+          if (generatorState.operation == NativeGenerator.GENERATOR_THROW) {\n+              // processing a call to <generator>.throw(exception): must\n+              // act as if exception was thrown from resumption point\n+              return new JavaScriptException(generatorState.value,\n+                                                  frame.idata.itsSourceFile,\n+                                                  sourceLine);\n+          }\n+          if (generatorState.operation == NativeGenerator.GENERATOR_CLOSE) {\n+              return generatorState.value;\n+          }\n+          if (generatorState.operation != NativeGenerator.GENERATOR_SEND)\n+              throw Kit.codeBug();\n+          if (op == Token.YIELD)\n+              frame.stack[stackTop] = generatorState.value;\n+          return Scriptable.NOT_FOUND;\n+    }\n+\n+    private static CallFrame initFrameForApplyOrCall(Context cx, CallFrame frame,\n+            int indexReg, Object[] stack, double[] sDbl, int stackTop, int op,\n+            Scriptable calleeScope, IdFunctionObject ifun,\n+            InterpretedFunction iApplyCallable)\n+    {\n+        Scriptable applyThis;\n+        if (indexReg != 0) {\n+            Object obj = stack[stackTop + 2];\n+            if (obj == UniqueTag.DOUBLE_MARK)\n+                obj = ScriptRuntime.wrapNumber(sDbl[stackTop + 2]);\n+            applyThis = ScriptRuntime.toObjectOrNull(cx, obj);\n+        }\n+        else {\n+            applyThis = null;\n+        }\n+        if (applyThis == null) {\n+            // This covers the case of args[0] == (null|undefined) as well.\n+            applyThis = ScriptRuntime.getTopCallScope(cx);\n+        }\n+        if(op == Icode_TAIL_CALL) {\n+            exitFrame(cx, frame, null);\n+            frame = frame.parentFrame;\n+        }\n+        else {\n+            frame.savedStackTop = stackTop;\n+            frame.savedCallOp = op;\n+        }\n+        CallFrame calleeFrame = new CallFrame();\n+        if(BaseFunction.isApply(ifun)) {\n+            Object[] callArgs = indexReg < 2 ? ScriptRuntime.emptyArgs :\n+                ScriptRuntime.getApplyArguments(cx, stack[stackTop + 3]);\n+            initFrame(cx, calleeScope, applyThis, callArgs, null, 0,\n+                    callArgs.length, iApplyCallable, frame, calleeFrame);\n+        }\n+        else {\n+            // Shift args left\n+            for(int i = 1; i < indexReg; ++i) {\n+                stack[stackTop + 1 + i] = stack[stackTop + 2 + i];\n+                sDbl[stackTop + 1 + i] = sDbl[stackTop + 2 + i];\n+            }\n+            int argCount = indexReg < 2 ? 0 : indexReg - 1;\n+            initFrame(cx, calleeScope, applyThis, stack, sDbl, stackTop + 2,\n+                    argCount, iApplyCallable, frame, calleeFrame);\n+        }\n+\n+        frame = calleeFrame;\n+        return frame;\n+    }\n+\n+    private static void initFrame(Context cx, Scriptable callerScope,\n+                                  Scriptable thisObj,\n+                                  Object[] args, double[] argsDbl,\n+                                  int argShift, int argCount,\n+                                  InterpretedFunction fnOrScript,\n+                                  CallFrame parentFrame, CallFrame frame)\n+    {\n+        InterpreterData idata = fnOrScript.idata;\n+\n+        boolean useActivation = idata.itsNeedsActivation;\n+        DebugFrame debuggerFrame = null;\n+        if (cx.debugger != null) {\n+            debuggerFrame = cx.debugger.getFrame(cx, idata);\n+            if (debuggerFrame != null) {\n+                useActivation = true;\n+            }\n+        }\n+\n+        if (useActivation) {\n+            // Copy args to new array to pass to enterActivationFunction\n+            // or debuggerFrame.onEnter\n+            if (argsDbl != null) {\n+                args = getArgsArray(args, argsDbl, argShift, argCount);\n+            }\n+            argShift = 0;\n+            argsDbl = null;\n+        }\n+\n+        Scriptable scope;\n+        if (idata.itsFunctionType != 0) {\n+            if (!idata.useDynamicScope) {\n+                scope = fnOrScript.getParentScope();\n+            } else {\n+                scope = callerScope;\n+            }\n+\n+            if (useActivation) {\n+                scope = ScriptRuntime.createFunctionActivation(\n+                            fnOrScript, scope, args);\n+            }\n+        } else {\n+            scope = callerScope;\n+            ScriptRuntime.initScript(fnOrScript, thisObj, cx, scope,\n+                                     fnOrScript.idata.evalScriptFlag);\n+        }\n+\n+        if (idata.itsNestedFunctions != null) {\n+            if (idata.itsFunctionType != 0 && !idata.itsNeedsActivation)\n+                Kit.codeBug();\n+            for (int i = 0; i < idata.itsNestedFunctions.length; i++) {\n+                InterpreterData fdata = idata.itsNestedFunctions[i];\n+                if (fdata.itsFunctionType == FunctionNode.FUNCTION_STATEMENT) {\n+                    initFunction(cx, scope, fnOrScript, i);\n+                }\n+            }\n+        }\n+\n+        Scriptable[] scriptRegExps = null;\n+        if (idata.itsRegExpLiterals != null) {\n+            // Wrapped regexps for functions are stored in\n+            // InterpretedFunction\n+            // but for script which should not contain references to scope\n+            // the regexps re-wrapped during each script execution\n+            if (idata.itsFunctionType != 0) {\n+                scriptRegExps = fnOrScript.functionRegExps;\n+            } else {\n+                scriptRegExps = fnOrScript.createRegExpWraps(cx, scope);\n+            }\n+        }\n+\n+        // Initialize args, vars, locals and stack\n+\n+        int emptyStackTop = idata.itsMaxVars + idata.itsMaxLocals - 1;\n+        int maxFrameArray = idata.itsMaxFrameArray;\n+        if (maxFrameArray != emptyStackTop + idata.itsMaxStack + 1)\n+            Kit.codeBug();\n+\n+        Object[] stack;\n+        int[] stackAttributes;\n+        double[] sDbl;\n+        boolean stackReuse;\n+        if (frame.stack != null && maxFrameArray <= frame.stack.length) {\n+            // Reuse stacks from old frame\n+            stackReuse = true;\n+            stack = frame.stack;\n+            stackAttributes = frame.stackAttributes;\n+            sDbl = frame.sDbl;\n+        } else {\n+            stackReuse = false;\n+            stack = new Object[maxFrameArray];\n+            stackAttributes = new int[maxFrameArray];\n+            sDbl = new double[maxFrameArray];\n+        }\n+\n+        int varCount = idata.getParamAndVarCount();\n+        for (int i = 0; i < varCount; i++) {\n+            if (idata.getParamOrVarConst(i))\n+                stackAttributes[i] = ScriptableObject.CONST;\n+        }\n+        int definedArgs = idata.argCount;\n+        if (definedArgs > argCount) { definedArgs = argCount; }\n+\n+        // Fill the frame structure\n+\n+        frame.parentFrame = parentFrame;\n+        frame.frameIndex = (parentFrame == null)\n+                           ? 0 : parentFrame.frameIndex + 1;\n+        if(frame.frameIndex > cx.getMaximumInterpreterStackDepth())\n+        {\n+            throw Context.reportRuntimeError(\"Exceeded maximum stack depth\");\n+        }\n+        frame.frozen = false;\n+\n+        frame.fnOrScript = fnOrScript;\n+        frame.idata = idata;\n+\n+        frame.stack = stack;\n+        frame.stackAttributes = stackAttributes;\n+        frame.sDbl = sDbl;\n+        frame.varSource = frame;\n+        frame.localShift = idata.itsMaxVars;\n+        frame.emptyStackTop = emptyStackTop;\n+\n+        frame.debuggerFrame = debuggerFrame;\n+        frame.useActivation = useActivation;\n+\n+        frame.thisObj = thisObj;\n+        frame.scriptRegExps = scriptRegExps;\n+\n+        // Initialize initial values of variables that change during\n+        // interpretation.\n+        frame.result = Undefined.instance;\n+        frame.pc = 0;\n+        frame.pcPrevBranch = 0;\n+        frame.pcSourceLineStart = idata.firstLinePC;\n+        frame.scope = scope;\n+\n+        frame.savedStackTop = emptyStackTop;\n+        frame.savedCallOp = 0;\n+\n+        System.arraycopy(args, argShift, stack, 0, definedArgs);\n+        if (argsDbl != null) {\n+            System.arraycopy(argsDbl, argShift, sDbl, 0, definedArgs);\n+        }\n+        for (int i = definedArgs; i != idata.itsMaxVars; ++i) {\n+            stack[i] = Undefined.instance;\n+        }\n+        if (stackReuse) {\n+            // Clean the stack part and space beyond stack if any\n+            // of the old array to allow to GC objects there\n+            for (int i = emptyStackTop + 1; i != stack.length; ++i) {\n+                stack[i] = null;\n+            }\n+        }\n+\n+        enterFrame(cx, frame, args, false);\n+    }\n+\n+    private static boolean isFrameEnterExitRequired(CallFrame frame)\n+    {\n+        return frame.debuggerFrame != null || frame.idata.itsNeedsActivation;\n+    }\n+\n+    private static void enterFrame(Context cx, CallFrame frame, Object[] args,\n+                                   boolean continuationRestart)\n+    {\n+        boolean usesActivation = frame.idata.itsNeedsActivation;\n+        boolean isDebugged = frame.debuggerFrame != null;\n+        if(usesActivation || isDebugged) {\n+            Scriptable scope = frame.scope;\n+            if(scope == null) {\n+                Kit.codeBug();\n+            } else if (continuationRestart) {\n+                // Walk the parent chain of frame.scope until a NativeCall is\n+                // found. Normally, frame.scope is a NativeCall when called\n+                // from initFrame() for a debugged or activatable function.\n+                // However, when called from interpretLoop() as part of\n+                // restarting a continuation, it can also be a NativeWith if\n+                // the continuation was captured within a \"with\" or \"catch\"\n+                // block (\"catch\" implicitly uses NativeWith to create a scope\n+                // to expose the exception variable).\n+                for(;;) {\n+                    if(scope instanceof NativeWith) {\n+                        scope = scope.getParentScope();\n+                        if (scope == null || (frame.parentFrame != null &&\n+                                              frame.parentFrame.scope == scope))\n+                        {\n+                            // If we get here, we didn't find a NativeCall in\n+                            // the call chain before reaching parent frame's\n+                            // scope. This should not be possible.\n+                            Kit.codeBug();\n+                            break; // Never reached, but keeps the static analyzer happy about \"scope\" not being null 5 lines above.\n+                        }\n+                    }\n+                    else {\n+                        break;\n+                    }\n+                }\n+            }\n+            if (isDebugged) {\n+                frame.debuggerFrame.onEnter(cx, scope, frame.thisObj, args);\n+            }\n+            // Enter activation only when itsNeedsActivation true,\n+            // since debugger should not interfere with activation\n+            // chaining\n+            if (usesActivation) {\n+                ScriptRuntime.enterActivationFunction(cx, scope);\n+            }\n+        }\n+    }\n+\n+    private static void exitFrame(Context cx, CallFrame frame,\n+                                  Object throwable)\n+    {\n+        if (frame.idata.itsNeedsActivation) {\n+            ScriptRuntime.exitActivationFunction(cx);\n+        }\n+\n+        if (frame.debuggerFrame != null) {\n+            try {\n+                if (throwable instanceof Throwable) {\n+                    frame.debuggerFrame.onExit(cx, true, throwable);\n+                } else {\n+                    Object result;\n+                    ContinuationJump cjump = (ContinuationJump)throwable;\n+                    if (cjump == null) {\n+                        result = frame.result;\n+                    } else {\n+                        result = cjump.result;\n+                    }\n+                    if (result == UniqueTag.DOUBLE_MARK) {\n+                        double resultDbl;\n+                        if (cjump == null) {\n+                            resultDbl = frame.resultDbl;\n+                        } else {\n+                            resultDbl = cjump.resultDbl;\n+                        }\n+                        result = ScriptRuntime.wrapNumber(resultDbl);\n+                    }\n+                    frame.debuggerFrame.onExit(cx, false, result);\n+                }\n+            } catch (Throwable ex) {\n+                System.err.println(\n+\"RHINO USAGE WARNING: onExit terminated with exception\");\n+                ex.printStackTrace(System.err);\n+            }\n+        }\n+    }\n+\n+    private static void setCallResult(CallFrame frame,\n+                                      Object callResult,\n+                                      double callResultDbl)\n+    {\n+        if (frame.savedCallOp == Token.CALL) {\n+            frame.stack[frame.savedStackTop] = callResult;\n+            frame.sDbl[frame.savedStackTop] = callResultDbl;\n+        } else if (frame.savedCallOp == Token.NEW) {\n+            // If construct returns scriptable,\n+            // then it replaces on stack top saved original instance\n+            // of the object.\n+            if (callResult instanceof Scriptable) {\n+                frame.stack[frame.savedStackTop] = callResult;\n+            }\n+        } else {\n+            Kit.codeBug();\n+        }\n+        frame.savedCallOp = 0;\n+    }\n+    \n+    public static NativeContinuation captureContinuation(Context cx) {\n+        if (cx.lastInterpreterFrame == null ||\n+            !(cx.lastInterpreterFrame instanceof CallFrame))\n+        {\n+            throw new IllegalStateException(\"Interpreter frames not found\");\n+        }\n+        return captureContinuation(cx, (CallFrame)cx.lastInterpreterFrame, true);\n+    }\n+\n+    private static NativeContinuation captureContinuation(Context cx, CallFrame frame,\n+        boolean requireContinuationsTopFrame)\n+    {\n+        NativeContinuation c = new NativeContinuation();\n+        ScriptRuntime.setObjectProtoAndParent(\n+            c, ScriptRuntime.getTopCallScope(cx));\n+\n+        // Make sure that all frames are frozen\n+        CallFrame x = frame;\n+        CallFrame outermost = frame;\n+        while (x != null && !x.frozen) {\n+            x.frozen = true;\n+            // Allow to GC unused stack space\n+            for (int i = x.savedStackTop + 1; i != x.stack.length; ++i) {\n+                // Allow to GC unused stack space\n+                x.stack[i] = null;\n+                x.stackAttributes[i] = ScriptableObject.EMPTY;\n+            }\n+            if (x.savedCallOp == Token.CALL) {\n+                // the call will always overwrite the stack top with the result\n+                x.stack[x.savedStackTop] = null;\n+            } else {\n+                if (x.savedCallOp != Token.NEW) Kit.codeBug();\n+                // the new operator uses stack top to store the constructed\n+                // object so it shall not be cleared: see comments in\n+                // setCallResult\n+            }\n+            outermost = x;\n+            x = x.parentFrame;\n+        }\n+        \n+        if (requireContinuationsTopFrame) {\n+            while (outermost.parentFrame != null)\n+                outermost = outermost.parentFrame;\n+    \n+            if (!outermost.isContinuationsTopFrame) {\n+                throw new IllegalStateException(\"Cannot capture continuation \" +\n+                        \"from JavaScript code not called directly by \" +\n+                        \"executeScriptWithContinuations or \" +\n+                        \"callFunctionWithContinuations\");\n+            }\n+        }\n+        \n+        c.initImplementation(frame);\n+        return c;\n+    }\n+\n+    private static int stack_int32(CallFrame frame, int i)\n+    {\n+        Object x = frame.stack[i];\n+        double value;\n+        if (x == UniqueTag.DOUBLE_MARK) {\n+            value = frame.sDbl[i];\n+        } else {\n+            value = ScriptRuntime.toNumber(x);\n+        }\n+        return ScriptRuntime.toInt32(value);\n+    }\n+\n+    private static double stack_double(CallFrame frame, int i)\n+    {\n+        Object x = frame.stack[i];\n+        if (x != UniqueTag.DOUBLE_MARK) {\n+            return ScriptRuntime.toNumber(x);\n+        } else {\n+            return frame.sDbl[i];\n+        }\n+    }\n+\n+    private static boolean stack_boolean(CallFrame frame, int i)\n+    {\n+        Object x = frame.stack[i];\n+        if (x == Boolean.TRUE) {\n+            return true;\n+        } else if (x == Boolean.FALSE) {\n+            return false;\n+        } else if (x == UniqueTag.DOUBLE_MARK) {\n+            double d = frame.sDbl[i];\n+            return d == d && d != 0.0;\n+        } else if (x == null || x == Undefined.instance) {\n+            return false;\n+        } else if (x instanceof Number) {\n+            double d = ((Number)x).doubleValue();\n+            return (d == d && d != 0.0);\n+        } else if (x instanceof Boolean) {\n+            return ((Boolean)x).booleanValue();\n+        } else {\n+            return ScriptRuntime.toBoolean(x);\n+        }\n+    }\n+\n+    private static void do_add(Object[] stack, double[] sDbl, int stackTop,\n+                              Context cx)\n+    {\n+        Object rhs = stack[stackTop + 1];\n+        Object lhs = stack[stackTop];\n+        double d;\n+        boolean leftRightOrder;\n+        if (rhs == UniqueTag.DOUBLE_MARK) {\n+            d = sDbl[stackTop + 1];\n+            if (lhs == UniqueTag.DOUBLE_MARK) {\n+                sDbl[stackTop] += d;\n+                return;\n+            }\n+            leftRightOrder = true;\n+            // fallthrough to object + number code\n+        } else if (lhs == UniqueTag.DOUBLE_MARK) {\n+            d = sDbl[stackTop];\n+            lhs = rhs;\n+            leftRightOrder = false;\n+            // fallthrough to object + number code\n+        } else {\n+            if (lhs instanceof Scriptable || rhs instanceof Scriptable) {\n+                stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);\n+            } else if (lhs instanceof String) {\n+                String lstr = (String)lhs;\n+                String rstr = ScriptRuntime.toString(rhs);\n+                stack[stackTop] = lstr.concat(rstr);\n+            } else if (rhs instanceof String) {\n+                String lstr = ScriptRuntime.toString(lhs);\n+                String rstr = (String)rhs;\n+                stack[stackTop] = lstr.concat(rstr);\n+            } else {\n+                double lDbl = (lhs instanceof Number)\n+                    ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);\n+                double rDbl = (rhs instanceof Number)\n+                    ? ((Number)rhs).doubleValue() : ScriptRuntime.toNumber(rhs);\n+                stack[stackTop] = UniqueTag.DOUBLE_MARK;\n+                sDbl[stackTop] = lDbl + rDbl;\n+            }\n+            return;\n+        }\n+\n+        // handle object(lhs) + number(d) code\n+        if (lhs instanceof Scriptable) {\n+            rhs = ScriptRuntime.wrapNumber(d);\n+            if (!leftRightOrder) {\n+                Object tmp = lhs;\n+                lhs = rhs;\n+                rhs = tmp;\n+            }\n+            stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);\n+        } else if (lhs instanceof String) {\n+            String lstr = (String)lhs;\n+            String rstr = ScriptRuntime.toString(d);\n+            if (leftRightOrder) {\n+                stack[stackTop] = lstr.concat(rstr);\n+            } else {\n+                stack[stackTop] = rstr.concat(lstr);\n+            }\n+        } else {\n+            double lDbl = (lhs instanceof Number)\n+                ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);\n+            stack[stackTop] = UniqueTag.DOUBLE_MARK;\n+            sDbl[stackTop] = lDbl + d;\n+        }\n+    }\n+\n+    private static Object[] getArgsArray(Object[] stack, double[] sDbl,\n+                                         int shift, int count)\n+    {\n+        if (count == 0) {\n+            return ScriptRuntime.emptyArgs;\n+        }\n+        Object[] args = new Object[count];\n+        for (int i = 0; i != count; ++i, ++shift) {\n+            Object val = stack[shift];\n+            if (val == UniqueTag.DOUBLE_MARK) {\n+                val = ScriptRuntime.wrapNumber(sDbl[shift]);\n+            }\n+            args[i] = val;\n+        }\n+        return args;\n+    }\n+\n+    private static void addInstructionCount(Context cx, CallFrame frame,\n+                                            int extra)\n+    {\n+        cx.instructionCount += frame.pc - frame.pcPrevBranch + extra;\n+        if (cx.instructionCount > cx.instructionThreshold) {\n+            cx.observeInstructionCount(cx.instructionCount);\n+            cx.instructionCount = 0;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/InterpreterData.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Bob Jervis\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.Serializable;\n+\n+import org.mozilla.javascript.debug.DebuggableScript;\n+\n+final class InterpreterData implements Serializable, DebuggableScript\n+{\n+    static final long serialVersionUID = 5067677351589230234L;\n+\n+    static final int INITIAL_MAX_ICODE_LENGTH = 1024;\n+    static final int INITIAL_STRINGTABLE_SIZE = 64;\n+    static final int INITIAL_NUMBERTABLE_SIZE = 64;\n+\n+    InterpreterData(int languageVersion, String sourceFile,\n+                    String encodedSource, boolean isStrict)\n+    {\n+        this.languageVersion = languageVersion;\n+        this.itsSourceFile = sourceFile;\n+        this.encodedSource = encodedSource;\n+        this.isStrict = isStrict;\n+        init();\n+    }\n+\n+    InterpreterData(InterpreterData parent)\n+    {\n+        this.parentData = parent;\n+        this.languageVersion = parent.languageVersion;\n+        this.itsSourceFile = parent.itsSourceFile;\n+        this.encodedSource = parent.encodedSource;\n+\n+        init();\n+    }\n+\n+    private void init()\n+    {\n+        itsICode = new byte[INITIAL_MAX_ICODE_LENGTH];\n+        itsStringTable = new String[INITIAL_STRINGTABLE_SIZE];\n+    }\n+\n+    String itsName;\n+    String itsSourceFile;\n+    boolean itsNeedsActivation;\n+    int itsFunctionType;\n+\n+    String[] itsStringTable;\n+    double[] itsDoubleTable;\n+    InterpreterData[] itsNestedFunctions;\n+    Object[] itsRegExpLiterals;\n+\n+    byte[] itsICode;\n+\n+    int[] itsExceptionTable;\n+\n+    int itsMaxVars;\n+    int itsMaxLocals;\n+    int itsMaxStack;\n+    int itsMaxFrameArray;\n+\n+    // see comments in NativeFuncion for definition of argNames and argCount\n+    String[] argNames;\n+    boolean[] argIsConst;\n+    int argCount;\n+\n+    int itsMaxCalleeArgs;\n+\n+    String encodedSource;\n+    int encodedSourceStart;\n+    int encodedSourceEnd;\n+\n+    int languageVersion;\n+\n+    boolean useDynamicScope;\n+    boolean isStrict;\n+    boolean topLevel;\n+\n+    Object[] literalIds;\n+\n+    UintMap longJumps;\n+\n+    int firstLinePC = -1; // PC for the first LINE icode\n+\n+    InterpreterData parentData;\n+\n+    boolean evalScriptFlag; // true if script corresponds to eval() code\n+\n+    public boolean isTopLevel()\n+    {\n+        return topLevel;\n+    }\n+\n+    public boolean isFunction()\n+    {\n+        return itsFunctionType != 0;\n+    }\n+\n+    public String getFunctionName()\n+    {\n+        return itsName;\n+    }\n+\n+    public int getParamCount()\n+    {\n+        return argCount;\n+    }\n+\n+    public int getParamAndVarCount()\n+    {\n+        return argNames.length;\n+    }\n+\n+    public String getParamOrVarName(int index)\n+    {\n+        return argNames[index];\n+    }\n+\n+    public boolean getParamOrVarConst(int index)\n+    {\n+        return argIsConst[index];\n+    }\n+\n+    public String getSourceName()\n+    {\n+        return itsSourceFile;\n+    }\n+\n+    public boolean isGeneratedScript()\n+    {\n+        return ScriptRuntime.isGeneratedScript(itsSourceFile);\n+    }\n+\n+    public int[] getLineNumbers()\n+    {\n+        return Interpreter.getLineNumbers(this);\n+    }\n+\n+    public int getFunctionCount()\n+    {\n+        return (itsNestedFunctions == null) ? 0 : itsNestedFunctions.length;\n+    }\n+\n+    public DebuggableScript getFunction(int index)\n+    {\n+        return itsNestedFunctions[index];\n+    }\n+\n+    public DebuggableScript getParent()\n+    {\n+         return parentData;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/JavaAdapter.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Patrick Beard\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Mike McCabe\n+ *   Matthias Radestock\n+ *   Andi Vajda\n+ *   Andrew Wason\n+ *   Kemal Bayram\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.classfile.*;\n+import java.lang.reflect.*;\n+import java.io.*;\n+import java.security.*;\n+import java.util.*;\n+\n+public final class JavaAdapter implements IdFunctionCall\n+{\n+    /**\n+     * Provides a key with which to distinguish previously generated\n+     * adapter classes stored in a hash table.\n+     */\n+    static class JavaAdapterSignature\n+    {\n+        Class<?> superClass;\n+        Class<?>[] interfaces;\n+        ObjToIntMap names;\n+\n+        JavaAdapterSignature(Class<?> superClass, Class<?>[] interfaces,\n+                             ObjToIntMap names)\n+        {\n+            this.superClass = superClass;\n+            this.interfaces = interfaces;\n+            this.names = names;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj)\n+        {\n+            if (!(obj instanceof JavaAdapterSignature))\n+                return false;\n+            JavaAdapterSignature sig = (JavaAdapterSignature) obj;\n+            if (superClass != sig.superClass)\n+                return false;\n+            if (interfaces != sig.interfaces) {\n+                if (interfaces.length != sig.interfaces.length)\n+                    return false;\n+                for (int i=0; i < interfaces.length; i++)\n+                    if (interfaces[i] != sig.interfaces[i])\n+                        return false;\n+            }\n+            if (names.size() != sig.names.size())\n+                return false;\n+            ObjToIntMap.Iterator iter = new ObjToIntMap.Iterator(names);\n+            for (iter.start(); !iter.done(); iter.next()) {\n+                String name = (String)iter.getKey();\n+                int arity = iter.getValue();\n+                if (arity != names.get(name, arity + 1))\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public int hashCode()\n+        {\n+            return superClass.hashCode()\n+                | (0x9e3779b9 * (names.size() | (interfaces.length << 16)));\n+        }\n+    }\n+\n+    public static void init(Context cx, Scriptable scope, boolean sealed)\n+    {\n+        JavaAdapter obj = new JavaAdapter();\n+        IdFunctionObject ctor = new IdFunctionObject(obj, FTAG, Id_JavaAdapter,\n+                                                     \"JavaAdapter\", 1, scope);\n+        ctor.markAsConstructor(null);\n+        if (sealed) {\n+            ctor.sealObject();\n+        }\n+        ctor.exportAsScopeProperty();\n+    }\n+\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (f.hasTag(FTAG)) {\n+            if (f.methodId() == Id_JavaAdapter) {\n+                return js_createAdapter(cx, scope, args);\n+            }\n+        }\n+        throw f.unknown();\n+    }\n+\n+    public static Object convertResult(Object result, Class<?> c)\n+    {\n+        if (result == Undefined.instance &&\n+            (c != ScriptRuntime.ObjectClass &&\n+             c != ScriptRuntime.StringClass))\n+        {\n+            // Avoid an error for an undefined value; return null instead.\n+            return null;\n+        }\n+        return Context.jsToJava(result, c);\n+    }\n+\n+    public static Scriptable createAdapterWrapper(Scriptable obj,\n+                                                  Object adapter)\n+    {\n+        Scriptable scope = ScriptableObject.getTopLevelScope(obj);\n+        NativeJavaObject res = new NativeJavaObject(scope, adapter, null, true);\n+        res.setPrototype(obj);\n+        return res;\n+    }\n+\n+    public static Object getAdapterSelf(Class<?> adapterClass, Object adapter)\n+        throws NoSuchFieldException, IllegalAccessException\n+    {\n+        Field self = adapterClass.getDeclaredField(\"self\");\n+        return self.get(adapter);\n+    }\n+\n+    static Object js_createAdapter(Context cx, Scriptable scope, Object[] args)\n+    {\n+        int N = args.length;\n+        if (N == 0) {\n+            throw ScriptRuntime.typeError0(\"msg.adapter.zero.args\");\n+        }\n+\n+        Class<?> superClass = null;\n+        Class<?>[] intfs = new Class[N - 1];\n+        int interfaceCount = 0;\n+        for (int i = 0; i != N - 1; ++i) {\n+            Object arg = args[i];\n+            if (!(arg instanceof NativeJavaClass)) {\n+                throw ScriptRuntime.typeError2(\"msg.not.java.class.arg\",\n+                                               String.valueOf(i),\n+                                               ScriptRuntime.toString(arg));\n+            }\n+            Class<?> c = ((NativeJavaClass) arg).getClassObject();\n+            if (!c.isInterface()) {\n+                if (superClass != null) {\n+                    throw ScriptRuntime.typeError2(\"msg.only.one.super\",\n+                              superClass.getName(), c.getName());\n+                }\n+                superClass = c;\n+            } else {\n+                intfs[interfaceCount++] = c;\n+            }\n+        }\n+\n+        if (superClass == null)\n+            superClass = ScriptRuntime.ObjectClass;\n+\n+        Class<?>[] interfaces = new Class[interfaceCount];\n+        System.arraycopy(intfs, 0, interfaces, 0, interfaceCount);\n+        Scriptable obj = ScriptRuntime.toObject(cx, scope, args[N - 1]);\n+\n+        Class<?> adapterClass = getAdapterClass(scope, superClass, interfaces,\n+                                             obj);\n+\n+        Class<?>[] ctorParms = {\n+            ScriptRuntime.ContextFactoryClass,\n+            ScriptRuntime.ScriptableClass\n+        };\n+        Object[] ctorArgs = { cx.getFactory(), obj };\n+        try {\n+            Object adapter = adapterClass.getConstructor(ctorParms).\n+                                 newInstance(ctorArgs);\n+            Object self = getAdapterSelf(adapterClass, adapter);\n+            // Return unwrapped JavaAdapter if it implements Scriptable\n+            if (self instanceof Wrapper) {\n+                Object unwrapped = ((Wrapper) self).unwrap();\n+                if (unwrapped instanceof Scriptable) {\n+                    return unwrapped;\n+                }\n+            }\n+            return self;\n+        } catch (Exception ex) {\n+            throw Context.throwAsScriptRuntimeEx(ex);\n+        }\n+    }\n+\n+    // Needed by NativeJavaObject serializer\n+    public static void writeAdapterObject(Object javaObject,\n+                                          ObjectOutputStream out)\n+        throws IOException\n+    {\n+        Class<?> cl = javaObject.getClass();\n+        out.writeObject(cl.getSuperclass().getName());\n+\n+        Class<?>[] interfaces = cl.getInterfaces();\n+        String[] interfaceNames = new String[interfaces.length];\n+\n+        for (int i=0; i < interfaces.length; i++)\n+            interfaceNames[i] = interfaces[i].getName();\n+\n+        out.writeObject(interfaceNames);\n+\n+        try {\n+            Object delegee = cl.getField(\"delegee\").get(javaObject);\n+            out.writeObject(delegee);\n+            return;\n+        } catch (IllegalAccessException e) {\n+        } catch (NoSuchFieldException e) {\n+        }\n+        throw new IOException();\n+    }\n+\n+    // Needed by NativeJavaObject de-serializer\n+    public static Object readAdapterObject(Scriptable self,\n+                                           ObjectInputStream in)\n+        throws IOException, ClassNotFoundException\n+    {\n+        ContextFactory factory;\n+        Context cx = Context.getCurrentContext();\n+        if (cx != null) {\n+            factory = cx.getFactory();\n+        } else {\n+            factory = null;\n+        }\n+\n+        Class<?> superClass = Class.forName((String)in.readObject());\n+\n+        String[] interfaceNames = (String[])in.readObject();\n+        Class<?>[] interfaces = new Class[interfaceNames.length];\n+\n+        for (int i=0; i < interfaceNames.length; i++)\n+            interfaces[i] = Class.forName(interfaceNames[i]);\n+\n+        Scriptable delegee = (Scriptable)in.readObject();\n+\n+        Class<?> adapterClass = getAdapterClass(self, superClass, interfaces,\n+                                             delegee);\n+\n+        Class<?>[] ctorParms = {\n+            ScriptRuntime.ContextFactoryClass,\n+            ScriptRuntime.ScriptableClass,\n+            ScriptRuntime.ScriptableClass\n+        };\n+        Object[] ctorArgs = { factory, delegee, self };\n+        try {\n+            return adapterClass.getConstructor(ctorParms).newInstance(ctorArgs);\n+        } catch(InstantiationException e) {\n+        } catch(IllegalAccessException e) {\n+        } catch(InvocationTargetException e) {\n+        } catch(NoSuchMethodException e) {\n+        }\n+\n+        throw new ClassNotFoundException(\"adapter\");\n+    }\n+\n+    private static ObjToIntMap getObjectFunctionNames(Scriptable obj)\n+    {\n+        Object[] ids = ScriptableObject.getPropertyIds(obj);\n+        ObjToIntMap map = new ObjToIntMap(ids.length);\n+        for (int i = 0; i != ids.length; ++i) {\n+            if (!(ids[i] instanceof String))\n+                continue;\n+            String id = (String) ids[i];\n+            Object value = ScriptableObject.getProperty(obj, id);\n+            if (value instanceof Function) {\n+                Function f = (Function)value;\n+                int length = ScriptRuntime.toInt32(\n+                                 ScriptableObject.getProperty(f, \"length\"));\n+                if (length < 0) {\n+                    length = 0;\n+                }\n+                map.put(id, length);\n+            }\n+        }\n+        return map;\n+    }\n+\n+    private static Class<?> getAdapterClass(Scriptable scope, Class<?> superClass,\n+                                         Class<?>[] interfaces, Scriptable obj)\n+    {\n+        ClassCache cache = ClassCache.get(scope);\n+        Map<JavaAdapterSignature,Class<?>> generated\n+            = cache.getInterfaceAdapterCacheMap();\n+\n+        ObjToIntMap names = getObjectFunctionNames(obj);\n+        JavaAdapterSignature sig;\n+        sig = new JavaAdapterSignature(superClass, interfaces, names);\n+        Class<?> adapterClass = generated.get(sig);\n+        if (adapterClass == null) {\n+            String adapterName = \"adapter\"\n+                                 + cache.newClassSerialNumber();\n+            byte[] code = createAdapterCode(names, adapterName,\n+                                            superClass, interfaces, null);\n+\n+            adapterClass = loadAdapterClass(adapterName, code);\n+            if (cache.isCachingEnabled()) {\n+                generated.put(sig, adapterClass);\n+            }\n+        }\n+        return adapterClass;\n+    }\n+\n+    public static byte[] createAdapterCode(ObjToIntMap functionNames,\n+                                           String adapterName,\n+                                           Class<?> superClass,\n+                                           Class<?>[] interfaces,\n+                                           String scriptClassName)\n+    {\n+        ClassFileWriter cfw = new ClassFileWriter(adapterName,\n+                                                  superClass.getName(),\n+                                                  \"<adapter>\");\n+        cfw.addField(\"factory\", \"Lorg/mozilla/javascript/ContextFactory;\",\n+                     (short) (ClassFileWriter.ACC_PUBLIC |\n+                              ClassFileWriter.ACC_FINAL));\n+        cfw.addField(\"delegee\", \"Lorg/mozilla/javascript/Scriptable;\",\n+                     (short) (ClassFileWriter.ACC_PUBLIC |\n+                              ClassFileWriter.ACC_FINAL));\n+        cfw.addField(\"self\", \"Lorg/mozilla/javascript/Scriptable;\",\n+                     (short) (ClassFileWriter.ACC_PUBLIC |\n+                              ClassFileWriter.ACC_FINAL));\n+        int interfacesCount = interfaces == null ? 0 : interfaces.length;\n+        for (int i=0; i < interfacesCount; i++) {\n+            if (interfaces[i] != null)\n+                cfw.addInterface(interfaces[i].getName());\n+        }\n+\n+        String superName = superClass.getName().replace('.', '/');\n+        generateCtor(cfw, adapterName, superName);\n+        generateSerialCtor(cfw, adapterName, superName);\n+        if (scriptClassName != null)\n+            generateEmptyCtor(cfw, adapterName, superName, scriptClassName);\n+\n+        ObjToIntMap generatedOverrides = new ObjToIntMap();\n+        ObjToIntMap generatedMethods = new ObjToIntMap();\n+\n+        // generate methods to satisfy all specified interfaces.\n+        for (int i = 0; i < interfacesCount; i++) {\n+            Method[] methods = interfaces[i].getMethods();\n+            for (int j = 0; j < methods.length; j++) {\n+                Method method = methods[j];\n+                int mods = method.getModifiers();\n+                if (Modifier.isStatic(mods) || Modifier.isFinal(mods)) {\n+                    continue;\n+                }\n+                String methodName = method.getName();\n+                Class<?>[] argTypes = method.getParameterTypes();\n+                if (!functionNames.has(methodName)) {\n+                    try {\n+                        superClass.getMethod(methodName, argTypes);\n+                        // The class we're extending implements this method and\n+                        // the JavaScript object doesn't have an override. See\n+                        // bug 61226.\n+                        continue;\n+                    } catch (NoSuchMethodException e) {\n+                        // Not implemented by superclass; fall through\n+                    }\n+                }\n+                // make sure to generate only one instance of a particular\n+                // method/signature.\n+                String methodSignature = getMethodSignature(method, argTypes);\n+                String methodKey = methodName + methodSignature;\n+                if (! generatedOverrides.has(methodKey)) {\n+                    generateMethod(cfw, adapterName, methodName,\n+                                   argTypes, method.getReturnType());\n+                    generatedOverrides.put(methodKey, 0);\n+                    generatedMethods.put(methodName, 0);\n+                }\n+            }\n+        }\n+\n+        // Now, go through the superclass's methods, checking for abstract\n+        // methods or additional methods to override.\n+\n+        // generate any additional overrides that the object might contain.\n+        Method[] methods = getOverridableMethods(superClass);\n+        for (int j = 0; j < methods.length; j++) {\n+            Method method = methods[j];\n+            int mods = method.getModifiers();\n+            // if a method is marked abstract, must implement it or the\n+            // resulting class won't be instantiable. otherwise, if the object\n+            // has a property of the same name, then an override is intended.\n+            boolean isAbstractMethod = Modifier.isAbstract(mods);\n+            String methodName = method.getName();\n+            if (isAbstractMethod || functionNames.has(methodName)) {\n+                // make sure to generate only one instance of a particular\n+                // method/signature.\n+                Class<?>[] argTypes = method.getParameterTypes();\n+                String methodSignature = getMethodSignature(method, argTypes);\n+                String methodKey = methodName + methodSignature;\n+                if (! generatedOverrides.has(methodKey)) {\n+                    generateMethod(cfw, adapterName, methodName,\n+                                   argTypes, method.getReturnType());\n+                    generatedOverrides.put(methodKey, 0);\n+                    generatedMethods.put(methodName, 0);\n+                    \n+                    // if a method was overridden, generate a \"super$method\"\n+                    // which lets the delegate call the superclass' version.\n+                    if (!isAbstractMethod) {\n+                        generateSuper(cfw, adapterName, superName,\n+                                      methodName, methodSignature,\n+                                      argTypes, method.getReturnType());\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Generate Java methods for remaining properties that are not\n+        // overrides.\n+        ObjToIntMap.Iterator iter = new ObjToIntMap.Iterator(functionNames);\n+        for (iter.start(); !iter.done(); iter.next()) {\n+            String functionName = (String)iter.getKey();\n+            if (generatedMethods.has(functionName))\n+                continue;\n+            int length = iter.getValue();\n+            Class<?>[] parms = new Class[length];\n+            for (int k=0; k < length; k++)\n+                parms[k] = ScriptRuntime.ObjectClass;\n+            generateMethod(cfw, adapterName, functionName, parms,\n+                           ScriptRuntime.ObjectClass);\n+        }\n+        return cfw.toByteArray();\n+    }\n+\n+    static Method[] getOverridableMethods(Class<?> c)\n+    {\n+        ArrayList<Method> list = new ArrayList<Method>();\n+        HashSet<String> skip = new HashSet<String>();\n+        while (c != null) {\n+            appendOverridableMethods(c, list, skip);\n+            for (Class<?> intf: c.getInterfaces())\n+                appendOverridableMethods(intf, list, skip);\n+            c = c.getSuperclass();\n+        }\n+        return list.toArray(new Method[list.size()]);\n+    }\n+    \n+    private static void appendOverridableMethods(Class<?> c, \n+            ArrayList<Method> list, HashSet<String> skip)\n+    {\n+        Method[] methods = c.getDeclaredMethods();\n+        for (int i = 0; i < methods.length; i++) {\n+            String methodKey = methods[i].getName() + \n+                getMethodSignature(methods[i],\n+                        methods[i].getParameterTypes());\n+            if (skip.contains(methodKey))\n+                continue; // skip this method\n+            int mods = methods[i].getModifiers();\n+            if (Modifier.isStatic(mods))\n+                continue;\n+            if (Modifier.isFinal(mods)) {\n+                // Make sure we don't add a final method to the list\n+                // of overridable methods.\n+                skip.add(methodKey);\n+                continue;\n+            }\n+            if (Modifier.isPublic(mods) || Modifier.isProtected(mods)) {\n+                list.add(methods[i]);\n+                skip.add(methodKey);\n+            }\n+        }\n+    }\n+\n+    static Class<?> loadAdapterClass(String className, byte[] classBytes)\n+    {\n+        Object staticDomain;\n+        Class<?> domainClass = SecurityController.getStaticSecurityDomainClass();\n+        if(domainClass == CodeSource.class || domainClass == ProtectionDomain.class) {\n+            ProtectionDomain protectionDomain = JavaAdapter.class.getProtectionDomain();\n+            if(domainClass == CodeSource.class) {\n+                staticDomain = protectionDomain == null ? null : protectionDomain.getCodeSource();\n+            }\n+            else {\n+                staticDomain = protectionDomain;\n+            }\n+        }\n+        else {\n+            staticDomain = null;\n+        }\n+        GeneratedClassLoader loader = SecurityController.createLoader(null, \n+                staticDomain);\n+        Class<?> result = loader.defineClass(className, classBytes);\n+        loader.linkClass(result);\n+        return result;\n+    }\n+\n+    public static Function getFunction(Scriptable obj, String functionName)\n+    {\n+        Object x = ScriptableObject.getProperty(obj, functionName);\n+        if (x == Scriptable.NOT_FOUND) {\n+            // This method used to swallow the exception from calling\n+            // an undefined method. People have come to depend on this\n+            // somewhat dubious behavior. It allows people to avoid\n+            // implementing listener methods that they don't care about,\n+            // for instance.\n+            return null;\n+        }\n+        if (!(x instanceof Function))\n+            throw ScriptRuntime.notFunctionError(x, functionName);\n+\n+        return (Function)x;\n+    }\n+\n+    /**\n+     * Utility method which dynamically binds a Context to the current thread,\n+     * if none already exists.\n+     */\n+    public static Object callMethod(ContextFactory factory,\n+                                    final Scriptable thisObj,\n+                                    final Function f, final Object[] args,\n+                                    final long argsToWrap)\n+    {\n+        if (f == null) {\n+            // See comments in getFunction\n+            return Undefined.instance;\n+        }\n+        if (factory == null) {\n+            factory = ContextFactory.getGlobal();\n+        }\n+\n+        final Scriptable scope = f.getParentScope();\n+        if (argsToWrap == 0) {\n+            return Context.call(factory, f, scope, thisObj, args);\n+        }\n+\n+        Context cx = Context.getCurrentContext();\n+        if (cx != null) {\n+            return doCall(cx, scope, thisObj, f, args, argsToWrap);\n+        } else {\n+            return factory.call(new ContextAction() {\n+                public Object run(Context cx)\n+                {\n+                    return doCall(cx, scope, thisObj, f, args, argsToWrap);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static Object doCall(Context cx, Scriptable scope,\n+                                 Scriptable thisObj, Function f,\n+                                 Object[] args, long argsToWrap)\n+    {\n+        // Wrap the rest of objects\n+        for (int i = 0; i != args.length; ++i) {\n+            if (0 != (argsToWrap & (1 << i))) {\n+                Object arg = args[i];\n+                if (!(arg instanceof Scriptable)) {\n+                    args[i] = cx.getWrapFactory().wrap(cx, scope, arg,\n+                                                       null);\n+                }\n+            }\n+        }\n+        return f.call(cx, scope, thisObj, args);\n+    }\n+\n+    public static Scriptable runScript(final Script script)\n+    {\n+        return (Scriptable)ContextFactory.getGlobal().call(\n+            new ContextAction() {\n+                public Object run(Context cx)\n+                {\n+                    ScriptableObject global = ScriptRuntime.getGlobal(cx);\n+                    script.exec(cx, global);\n+                    return global;\n+                }\n+            });\n+    }\n+\n+    private static void generateCtor(ClassFileWriter cfw, String adapterName,\n+                                     String superName)\n+    {\n+        cfw.startMethod(\"<init>\",\n+                        \"(Lorg/mozilla/javascript/ContextFactory;\"\n+                        +\"Lorg/mozilla/javascript/Scriptable;)V\",\n+                        ClassFileWriter.ACC_PUBLIC);\n+\n+        // Invoke base class constructor\n+        cfw.add(ByteCode.ALOAD_0);  // this\n+        cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, \"<init>\", \"()V\");\n+\n+        // Save parameter in instance variable \"factory\"\n+        cfw.add(ByteCode.ALOAD_0);  // this\n+        cfw.add(ByteCode.ALOAD_1);  // first arg: ContextFactory instance\n+        cfw.add(ByteCode.PUTFIELD, adapterName, \"factory\",\n+                \"Lorg/mozilla/javascript/ContextFactory;\");\n+\n+        // Save parameter in instance variable \"delegee\"\n+        cfw.add(ByteCode.ALOAD_0);  // this\n+        cfw.add(ByteCode.ALOAD_2);  // second arg: Scriptable delegee\n+        cfw.add(ByteCode.PUTFIELD, adapterName, \"delegee\",\n+                \"Lorg/mozilla/javascript/Scriptable;\");\n+\n+        cfw.add(ByteCode.ALOAD_0);  // this for the following PUTFIELD for self\n+        // create a wrapper object to be used as \"this\" in method calls\n+        cfw.add(ByteCode.ALOAD_2);  // the Scriptable delegee\n+        cfw.add(ByteCode.ALOAD_0);  // this\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      \"org/mozilla/javascript/JavaAdapter\",\n+                      \"createAdapterWrapper\",\n+                      \"(Lorg/mozilla/javascript/Scriptable;\"\n+                      +\"Ljava/lang/Object;\"\n+                      +\")Lorg/mozilla/javascript/Scriptable;\");\n+        cfw.add(ByteCode.PUTFIELD, adapterName, \"self\",\n+                \"Lorg/mozilla/javascript/Scriptable;\");\n+\n+        cfw.add(ByteCode.RETURN);\n+        cfw.stopMethod((short)3); // 3: this + factory + delegee\n+    }\n+\n+    private static void generateSerialCtor(ClassFileWriter cfw,\n+                                           String adapterName,\n+                                           String superName)\n+    {\n+        cfw.startMethod(\"<init>\",\n+                        \"(Lorg/mozilla/javascript/ContextFactory;\"\n+                        +\"Lorg/mozilla/javascript/Scriptable;\"\n+                        +\"Lorg/mozilla/javascript/Scriptable;\"\n+                        +\")V\",\n+                        ClassFileWriter.ACC_PUBLIC);\n+\n+        // Invoke base class constructor\n+        cfw.add(ByteCode.ALOAD_0);  // this\n+        cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, \"<init>\", \"()V\");\n+\n+        // Save parameter in instance variable \"factory\"\n+        cfw.add(ByteCode.ALOAD_0);  // this\n+        cfw.add(ByteCode.ALOAD_1);  // first arg: ContextFactory instance\n+        cfw.add(ByteCode.PUTFIELD, adapterName, \"factory\",\n+                \"Lorg/mozilla/javascript/ContextFactory;\");\n+\n+        // Save parameter in instance variable \"delegee\"\n+        cfw.add(ByteCode.ALOAD_0);  // this\n+        cfw.add(ByteCode.ALOAD_2);  // second arg: Scriptable delegee\n+        cfw.add(ByteCode.PUTFIELD, adapterName, \"delegee\",\n+                \"Lorg/mozilla/javascript/Scriptable;\");\n+        // save self\n+        cfw.add(ByteCode.ALOAD_0);  // this\n+        cfw.add(ByteCode.ALOAD_3);  // second arg: Scriptable self\n+        cfw.add(ByteCode.PUTFIELD, adapterName, \"self\",\n+                \"Lorg/mozilla/javascript/Scriptable;\");\n+\n+        cfw.add(ByteCode.RETURN);\n+        cfw.stopMethod((short)4); // 4: this + factory + delegee + self\n+    }\n+\n+    private static void generateEmptyCtor(ClassFileWriter cfw,\n+                                          String adapterName,\n+                                          String superName,\n+                                          String scriptClassName)\n+    {\n+        cfw.startMethod(\"<init>\", \"()V\", ClassFileWriter.ACC_PUBLIC);\n+\n+        // Invoke base class constructor\n+        cfw.add(ByteCode.ALOAD_0);  // this\n+        cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, \"<init>\", \"()V\");\n+\n+        // Set factory to null to use current global when necessary\n+        cfw.add(ByteCode.ALOAD_0);\n+        cfw.add(ByteCode.ACONST_NULL);\n+        cfw.add(ByteCode.PUTFIELD, adapterName, \"factory\",\n+                \"Lorg/mozilla/javascript/ContextFactory;\");\n+\n+        // Load script class\n+        cfw.add(ByteCode.NEW, scriptClassName);\n+        cfw.add(ByteCode.DUP);\n+        cfw.addInvoke(ByteCode.INVOKESPECIAL, scriptClassName, \"<init>\", \"()V\");\n+\n+        // Run script and save resulting scope\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      \"org/mozilla/javascript/JavaAdapter\",\n+                      \"runScript\",\n+                      \"(Lorg/mozilla/javascript/Script;\"\n+                      +\")Lorg/mozilla/javascript/Scriptable;\");\n+        cfw.add(ByteCode.ASTORE_1);\n+\n+        // Save the Scriptable in instance variable \"delegee\"\n+        cfw.add(ByteCode.ALOAD_0);  // this\n+        cfw.add(ByteCode.ALOAD_1);  // the Scriptable\n+        cfw.add(ByteCode.PUTFIELD, adapterName, \"delegee\",\n+                \"Lorg/mozilla/javascript/Scriptable;\");\n+\n+        cfw.add(ByteCode.ALOAD_0);  // this for the following PUTFIELD for self\n+        // create a wrapper object to be used as \"this\" in method calls\n+        cfw.add(ByteCode.ALOAD_1);  // the Scriptable\n+        cfw.add(ByteCode.ALOAD_0);  // this\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      \"org/mozilla/javascript/JavaAdapter\",\n+                      \"createAdapterWrapper\",\n+                      \"(Lorg/mozilla/javascript/Scriptable;\"\n+                      +\"Ljava/lang/Object;\"\n+                      +\")Lorg/mozilla/javascript/Scriptable;\");\n+        cfw.add(ByteCode.PUTFIELD, adapterName, \"self\",\n+                \"Lorg/mozilla/javascript/Scriptable;\");\n+\n+        cfw.add(ByteCode.RETURN);\n+        cfw.stopMethod((short)2); // this + delegee\n+    }\n+\n+    /**\n+     * Generates code to wrap Java arguments into Object[].\n+     * Non-primitive Java types are left as-is pending conversion\n+     * in the helper method. Leaves the array object on the top of the stack.\n+     */\n+    static void generatePushWrappedArgs(ClassFileWriter cfw,\n+                                        Class<?>[] argTypes,\n+                                        int arrayLength)\n+    {\n+        // push arguments\n+        cfw.addPush(arrayLength);\n+        cfw.add(ByteCode.ANEWARRAY, \"java/lang/Object\");\n+        int paramOffset = 1;\n+        for (int i = 0; i != argTypes.length; ++i) {\n+            cfw.add(ByteCode.DUP); // duplicate array reference\n+            cfw.addPush(i);\n+            paramOffset += generateWrapArg(cfw, paramOffset, argTypes[i]);\n+            cfw.add(ByteCode.AASTORE);\n+        }\n+    }\n+\n+    /**\n+     * Generates code to wrap Java argument into Object.\n+     * Non-primitive Java types are left unconverted pending conversion\n+     * in the helper method. Leaves the wrapper object on the top of the stack.\n+     */\n+    private static int generateWrapArg(ClassFileWriter cfw, int paramOffset,\n+                                       Class<?> argType)\n+    {\n+        int size = 1;\n+        if (!argType.isPrimitive()) {\n+            cfw.add(ByteCode.ALOAD, paramOffset);\n+\n+        } else if (argType == Boolean.TYPE) {\n+            // wrap boolean values with java.lang.Boolean.\n+            cfw.add(ByteCode.NEW, \"java/lang/Boolean\");\n+            cfw.add(ByteCode.DUP);\n+            cfw.add(ByteCode.ILOAD, paramOffset);\n+            cfw.addInvoke(ByteCode.INVOKESPECIAL, \"java/lang/Boolean\",\n+                          \"<init>\", \"(Z)V\");\n+\n+        } else if (argType == Character.TYPE) {\n+            // Create a string of length 1 using the character parameter.\n+            cfw.add(ByteCode.ILOAD, paramOffset);\n+            cfw.addInvoke(ByteCode.INVOKESTATIC, \"java/lang/String\",\n+                          \"valueOf\", \"(C)Ljava/lang/String;\");\n+\n+        } else {\n+            // convert all numeric values to java.lang.Double.\n+            cfw.add(ByteCode.NEW, \"java/lang/Double\");\n+            cfw.add(ByteCode.DUP);\n+            String typeName = argType.getName();\n+            switch (typeName.charAt(0)) {\n+            case 'b':\n+            case 's':\n+            case 'i':\n+                // load an int value, convert to double.\n+                cfw.add(ByteCode.ILOAD, paramOffset);\n+                cfw.add(ByteCode.I2D);\n+                break;\n+            case 'l':\n+                // load a long, convert to double.\n+                cfw.add(ByteCode.LLOAD, paramOffset);\n+                cfw.add(ByteCode.L2D);\n+                size = 2;\n+                break;\n+            case 'f':\n+                // load a float, convert to double.\n+                cfw.add(ByteCode.FLOAD, paramOffset);\n+                cfw.add(ByteCode.F2D);\n+                break;\n+            case 'd':\n+                cfw.add(ByteCode.DLOAD, paramOffset);\n+                size = 2;\n+                break;\n+            }\n+            cfw.addInvoke(ByteCode.INVOKESPECIAL, \"java/lang/Double\",\n+                          \"<init>\", \"(D)V\");\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Generates code to convert a wrapped value type to a primitive type.\n+     * Handles unwrapping java.lang.Boolean, and java.lang.Number types.\n+     * Generates the appropriate RETURN bytecode.\n+     */\n+    static void generateReturnResult(ClassFileWriter cfw, Class<?> retType,\n+                                     boolean callConvertResult)\n+    {\n+        // wrap boolean values with java.lang.Boolean, convert all other\n+        // primitive values to java.lang.Double.\n+        if (retType == Void.TYPE) {\n+            cfw.add(ByteCode.POP);\n+            cfw.add(ByteCode.RETURN);\n+\n+        } else if (retType == Boolean.TYPE) {\n+            cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                          \"org/mozilla/javascript/Context\",\n+                          \"toBoolean\", \"(Ljava/lang/Object;)Z\");\n+            cfw.add(ByteCode.IRETURN);\n+\n+        } else if (retType == Character.TYPE) {\n+            // characters are represented as strings in JavaScript.\n+            // return the first character.\n+            // first convert the value to a string if possible.\n+            cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                          \"org/mozilla/javascript/Context\",\n+                          \"toString\",\n+                          \"(Ljava/lang/Object;)Ljava/lang/String;\");\n+            cfw.add(ByteCode.ICONST_0);\n+            cfw.addInvoke(ByteCode.INVOKEVIRTUAL, \"java/lang/String\",\n+                          \"charAt\", \"(I)C\");\n+            cfw.add(ByteCode.IRETURN);\n+\n+        } else if (retType.isPrimitive()) {\n+            cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                          \"org/mozilla/javascript/Context\",\n+                          \"toNumber\", \"(Ljava/lang/Object;)D\");\n+            String typeName = retType.getName();\n+            switch (typeName.charAt(0)) {\n+            case 'b':\n+            case 's':\n+            case 'i':\n+                cfw.add(ByteCode.D2I);\n+                cfw.add(ByteCode.IRETURN);\n+                break;\n+            case 'l':\n+                cfw.add(ByteCode.D2L);\n+                cfw.add(ByteCode.LRETURN);\n+                break;\n+            case 'f':\n+                cfw.add(ByteCode.D2F);\n+                cfw.add(ByteCode.FRETURN);\n+                break;\n+            case 'd':\n+                cfw.add(ByteCode.DRETURN);\n+                break;\n+            default:\n+                throw new RuntimeException(\"Unexpected return type \" +\n+                                           retType.toString());\n+            }\n+\n+        } else {\n+            String retTypeStr = retType.getName();\n+            if (callConvertResult) {\n+                cfw.addLoadConstant(retTypeStr);\n+                cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                              \"java/lang/Class\",\n+                              \"forName\",\n+                              \"(Ljava/lang/String;)Ljava/lang/Class;\");\n+\n+                cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                              \"org/mozilla/javascript/JavaAdapter\",\n+                              \"convertResult\",\n+                              \"(Ljava/lang/Object;\"\n+                              +\"Ljava/lang/Class;\"\n+                              +\")Ljava/lang/Object;\");\n+            }\n+            // Now cast to return type\n+            cfw.add(ByteCode.CHECKCAST, retTypeStr);\n+            cfw.add(ByteCode.ARETURN);\n+        }\n+    }\n+\n+    private static void generateMethod(ClassFileWriter cfw, String genName,\n+                                       String methodName, Class<?>[] parms,\n+                                       Class<?> returnType)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        int paramsEnd = appendMethodSignature(parms, returnType, sb);\n+        String methodSignature = sb.toString();\n+        cfw.startMethod(methodName, methodSignature,\n+                        ClassFileWriter.ACC_PUBLIC);\n+\n+        // Prepare stack to call method\n+\n+        // push factory\n+        cfw.add(ByteCode.ALOAD_0);\n+        cfw.add(ByteCode.GETFIELD, genName, \"factory\",\n+                \"Lorg/mozilla/javascript/ContextFactory;\");\n+\n+        // push self\n+        cfw.add(ByteCode.ALOAD_0);\n+        cfw.add(ByteCode.GETFIELD, genName, \"self\",\n+                \"Lorg/mozilla/javascript/Scriptable;\");\n+\n+        // push function\n+        cfw.add(ByteCode.ALOAD_0);\n+        cfw.add(ByteCode.GETFIELD, genName, \"delegee\",\n+                \"Lorg/mozilla/javascript/Scriptable;\");\n+        cfw.addPush(methodName);\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      \"org/mozilla/javascript/JavaAdapter\",\n+                      \"getFunction\",\n+                      \"(Lorg/mozilla/javascript/Scriptable;\"\n+                      +\"Ljava/lang/String;\"\n+                      +\")Lorg/mozilla/javascript/Function;\");\n+\n+        // push arguments\n+        generatePushWrappedArgs(cfw, parms, parms.length);\n+\n+        // push bits to indicate which parameters should be wrapped\n+        if (parms.length > 64) {\n+            // If it will be an issue, then passing a static boolean array\n+            // can be an option, but for now using simple bitmask\n+            throw Context.reportRuntimeError0(\n+                \"JavaAdapter can not subclass methods with more then\"\n+                +\" 64 arguments.\");\n+        }\n+        long convertionMask = 0;\n+        for (int i = 0; i != parms.length; ++i) {\n+            if (!parms[i].isPrimitive()) {\n+                convertionMask |= (1 << i);\n+            }\n+        }\n+        cfw.addPush(convertionMask);\n+\n+        // go through utility method, which creates a Context to run the\n+        // method in.\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      \"org/mozilla/javascript/JavaAdapter\",\n+                      \"callMethod\",\n+                      \"(Lorg/mozilla/javascript/ContextFactory;\"\n+                      +\"Lorg/mozilla/javascript/Scriptable;\"\n+                      +\"Lorg/mozilla/javascript/Function;\"\n+                      +\"[Ljava/lang/Object;\"\n+                      +\"J\"\n+                      +\")Ljava/lang/Object;\");\n+\n+        generateReturnResult(cfw, returnType, true);\n+\n+        cfw.stopMethod((short)paramsEnd);\n+    }\n+\n+    /**\n+     * Generates code to push typed parameters onto the operand stack\n+     * prior to a direct Java method call.\n+     */\n+    private static int generatePushParam(ClassFileWriter cfw, int paramOffset,\n+                                         Class<?> paramType)\n+    {\n+        if (!paramType.isPrimitive()) {\n+            cfw.addALoad(paramOffset);\n+            return 1;\n+        }\n+        String typeName = paramType.getName();\n+        switch (typeName.charAt(0)) {\n+        case 'z':\n+        case 'b':\n+        case 'c':\n+        case 's':\n+        case 'i':\n+            // load an int value, convert to double.\n+            cfw.addILoad(paramOffset);\n+            return 1;\n+        case 'l':\n+            // load a long, convert to double.\n+            cfw.addLLoad(paramOffset);\n+            return 2;\n+        case 'f':\n+            // load a float, convert to double.\n+            cfw.addFLoad(paramOffset);\n+            return 1;\n+        case 'd':\n+            cfw.addDLoad(paramOffset);\n+            return 2;\n+        }\n+        throw Kit.codeBug();\n+    }\n+\n+    /**\n+     * Generates code to return a Java type, after calling a Java method\n+     * that returns the same type.\n+     * Generates the appropriate RETURN bytecode.\n+     */\n+    private static void generatePopResult(ClassFileWriter cfw,\n+                                          Class<?> retType)\n+    {\n+        if (retType.isPrimitive()) {\n+            String typeName = retType.getName();\n+            switch (typeName.charAt(0)) {\n+            case 'b':\n+            case 'c':\n+            case 's':\n+            case 'i':\n+            case 'z':\n+                cfw.add(ByteCode.IRETURN);\n+                break;\n+            case 'l':\n+                cfw.add(ByteCode.LRETURN);\n+                break;\n+            case 'f':\n+                cfw.add(ByteCode.FRETURN);\n+                break;\n+            case 'd':\n+                cfw.add(ByteCode.DRETURN);\n+                break;\n+            }\n+        } else {\n+            cfw.add(ByteCode.ARETURN);\n+        }\n+    }\n+\n+    /**\n+     * Generates a method called \"super$methodName()\" which can be called\n+     * from JavaScript that is equivalent to calling \"super.methodName()\"\n+     * from Java. Eventually, this may be supported directly in JavaScript.\n+     */\n+    private static void generateSuper(ClassFileWriter cfw,\n+                                      String genName, String superName,\n+                                      String methodName, String methodSignature,\n+                                      Class<?>[] parms, Class<?> returnType)\n+    {\n+        cfw.startMethod(\"super$\" + methodName, methodSignature,\n+                        ClassFileWriter.ACC_PUBLIC);\n+\n+        // push \"this\"\n+        cfw.add(ByteCode.ALOAD, 0);\n+\n+        // push the rest of the parameters.\n+        int paramOffset = 1;\n+        for (int i = 0; i < parms.length; i++) {\n+            paramOffset += generatePushParam(cfw, paramOffset, parms[i]);\n+        }\n+\n+        // call the superclass implementation of the method.\n+        cfw.addInvoke(ByteCode.INVOKESPECIAL,\n+                      superName,\n+                      methodName,\n+                      methodSignature);\n+\n+        // now, handle the return type appropriately.\n+        Class<?> retType = returnType;\n+        if (!retType.equals(Void.TYPE)) {\n+            generatePopResult(cfw, retType);\n+        } else {\n+            cfw.add(ByteCode.RETURN);\n+        }\n+        cfw.stopMethod((short)(paramOffset + 1));\n+    }\n+\n+    /**\n+     * Returns a fully qualified method name concatenated with its signature.\n+     */\n+    private static String getMethodSignature(Method method, Class<?>[] argTypes)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        appendMethodSignature(argTypes, method.getReturnType(), sb);\n+        return sb.toString();\n+    }\n+\n+    static int appendMethodSignature(Class<?>[] argTypes,\n+                                     Class<?> returnType,\n+                                     StringBuffer sb)\n+    {\n+        sb.append('(');\n+        int firstLocal = 1 + argTypes.length; // includes this.\n+        for (int i = 0; i < argTypes.length; i++) {\n+            Class<?> type = argTypes[i];\n+            appendTypeString(sb, type);\n+            if (type == Long.TYPE || type == Double.TYPE) {\n+                // adjust for duble slot\n+                ++firstLocal;\n+            }\n+        }\n+        sb.append(')');\n+        appendTypeString(sb, returnType);\n+        return firstLocal;\n+    }\n+\n+    private static StringBuffer appendTypeString(StringBuffer sb, Class<?> type)\n+    {\n+        while (type.isArray()) {\n+            sb.append('[');\n+            type = type.getComponentType();\n+        }\n+        if (type.isPrimitive()) {\n+            char typeLetter;\n+            if (type == Boolean.TYPE) {\n+                typeLetter = 'Z';\n+            } else if (type == Long.TYPE) {\n+                typeLetter = 'J';\n+            } else {\n+                String typeName = type.getName();\n+                typeLetter = Character.toUpperCase(typeName.charAt(0));\n+            }\n+            sb.append(typeLetter);\n+        } else {\n+            sb.append('L');\n+            sb.append(type.getName().replace('.', '/'));\n+            sb.append(';');\n+        }\n+        return sb;\n+    }\n+\n+    static int[] getArgsToConvert(Class<?>[] argTypes)\n+    {\n+        int count = 0;\n+        for (int i = 0; i != argTypes.length; ++i) {\n+            if (!argTypes[i].isPrimitive())\n+                ++count;\n+        }\n+        if (count == 0)\n+            return null;\n+        int[] array = new int[count];\n+        count = 0;\n+        for (int i = 0; i != argTypes.length; ++i) {\n+            if (!argTypes[i].isPrimitive())\n+                array[count++] = i;\n+        }\n+        return array;\n+    }\n+\n+    private static final Object FTAG = \"JavaAdapter\";\n+    private static final int Id_JavaAdapter = 1;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/JavaMembers.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Cameron McCormack\n+ *   Frank Mitchell\n+ *   Mike Shaver\n+ *   Kurt Westerfeld\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+/**\n+ *\n+ * @see NativeJavaObject\n+ * @see NativeJavaClass\n+ */\n+class JavaMembers\n+{\n+    JavaMembers(Scriptable scope, Class<?> cl)\n+    {\n+        this(scope, cl, false);\n+    }\n+\n+    JavaMembers(Scriptable scope, Class<?> cl, boolean includeProtected)\n+    {\n+        try {\n+            Context cx = ContextFactory.getGlobal().enterContext();\n+            ClassShutter shutter = cx.getClassShutter();\n+            if (shutter != null && !shutter.visibleToScripts(cl.getName())) {\n+                throw Context.reportRuntimeError1(\"msg.access.prohibited\",\n+                                                  cl.getName());\n+            }\n+            this.includePrivate = cx.hasFeature(\n+                Context.FEATURE_ENHANCED_JAVA_ACCESS);\n+            this.members = new HashMap<String,Object>();\n+            this.staticMembers = new HashMap<String,Object>();\n+            this.cl = cl;\n+            reflect(scope, includeProtected);\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+    boolean has(String name, boolean isStatic)\n+    {\n+        Map<String,Object> ht = isStatic ? staticMembers : members;\n+        Object obj = ht.get(name);\n+        if (obj != null) {\n+            return true;\n+        }\n+        return findExplicitFunction(name, isStatic) != null;\n+    }\n+\n+    Object get(Scriptable scope, String name, Object javaObject,\n+               boolean isStatic)\n+    {\n+        Map<String,Object> ht = isStatic ? staticMembers : members;\n+        Object member = ht.get(name);\n+        if (!isStatic && member == null) {\n+            // Try to get static member from instance (LC3)\n+            member = staticMembers.get(name);\n+        }\n+        if (member == null) {\n+            member = this.getExplicitFunction(scope, name,\n+                                              javaObject, isStatic);\n+            if (member == null)\n+                return Scriptable.NOT_FOUND;\n+        }\n+        if (member instanceof Scriptable) {\n+            return member;\n+        }\n+        Context cx = Context.getContext();\n+        Object rval;\n+        Class<?> type;\n+        try {\n+            if (member instanceof BeanProperty) {\n+                BeanProperty bp = (BeanProperty) member;\n+                if (bp.getter == null)\n+                    return Scriptable.NOT_FOUND;\n+                rval = bp.getter.invoke(javaObject, Context.emptyArgs);\n+                type = bp.getter.method().getReturnType();\n+            } else {\n+                Field field = (Field) member;\n+                rval = field.get(isStatic ? null : javaObject);\n+                type = field.getType();\n+            }\n+        } catch (Exception ex) {\n+            throw Context.throwAsScriptRuntimeEx(ex);\n+        }\n+        // Need to wrap the object before we return it.\n+        scope = ScriptableObject.getTopLevelScope(scope);\n+        return cx.getWrapFactory().wrap(cx, scope, rval, type);\n+    }\n+\n+    void put(Scriptable scope, String name, Object javaObject,\n+             Object value, boolean isStatic)\n+    {\n+        Map<String,Object> ht = isStatic ? staticMembers : members;\n+        Object member = ht.get(name);\n+        if (!isStatic && member == null) {\n+            // Try to get static member from instance (LC3)\n+            member = staticMembers.get(name);\n+        }\n+        if (member == null)\n+            throw reportMemberNotFound(name);\n+        if (member instanceof FieldAndMethods) {\n+            FieldAndMethods fam = (FieldAndMethods) ht.get(name);\n+            member = fam.field;\n+        }\n+\n+        // Is this a bean property \"set\"?\n+        if (member instanceof BeanProperty) {\n+            BeanProperty bp = (BeanProperty)member;\n+            if (bp.setter == null) {\n+                throw reportMemberNotFound(name);\n+            }\n+            // If there's only one setter or if the value is null, use the\n+            // main setter. Otherwise, let the NativeJavaMethod decide which\n+            // setter to use:\n+            if (bp.setters == null || value == null) {\n+                Class<?> setType = bp.setter.argTypes[0];\n+                Object[] args = { Context.jsToJava(value, setType) };\n+                try {\n+                    bp.setter.invoke(javaObject, args);\n+                } catch (Exception ex) {\n+                  throw Context.throwAsScriptRuntimeEx(ex);\n+                }\n+            } else {\n+                Object[] args = { value };\n+                bp.setters.call(Context.getContext(),\n+                                ScriptableObject.getTopLevelScope(scope),\n+                                scope, args);\n+            }\n+        }\n+        else {\n+            if (!(member instanceof Field)) {\n+                String str = (member == null) ? \"msg.java.internal.private\"\n+                                              : \"msg.java.method.assign\";\n+                throw Context.reportRuntimeError1(str, name);\n+            }\n+            Field field = (Field)member;\n+            Object javaValue = Context.jsToJava(value, field.getType());\n+            try {\n+                field.set(javaObject, javaValue);\n+            } catch (IllegalAccessException accessEx) {\n+                if ((field.getModifiers() & Modifier.FINAL) != 0) {\n+                    // treat Java final the same as JavaScript [[READONLY]]\n+                    return;\n+                }\n+                throw Context.throwAsScriptRuntimeEx(accessEx);\n+            } catch (IllegalArgumentException argEx) {\n+                throw Context.reportRuntimeError3(\n+                    \"msg.java.internal.field.type\",\n+                    value.getClass().getName(), field,\n+                    javaObject.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    Object[] getIds(boolean isStatic)\n+    {\n+        Map<String,Object> map = isStatic ? staticMembers : members;\n+        return map.keySet().toArray(new Object[map.size()]);\n+    }\n+\n+    static String javaSignature(Class<?> type)\n+    {\n+        if (!type.isArray()) {\n+            return type.getName();\n+        } else {\n+            int arrayDimension = 0;\n+            do {\n+                ++arrayDimension;\n+                type = type.getComponentType();\n+            } while (type.isArray());\n+            String name = type.getName();\n+            String suffix = \"[]\";\n+            if (arrayDimension == 1) {\n+                return name.concat(suffix);\n+            } else {\n+                int length = name.length() + arrayDimension * suffix.length();\n+                StringBuffer sb = new StringBuffer(length);\n+                sb.append(name);\n+                while (arrayDimension != 0) {\n+                    --arrayDimension;\n+                    sb.append(suffix);\n+                }\n+                return sb.toString();\n+            }\n+        }\n+    }\n+\n+    static String liveConnectSignature(Class<?>[] argTypes)\n+    {\n+        int N = argTypes.length;\n+        if (N == 0) { return \"()\"; }\n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        for (int i = 0; i != N; ++i) {\n+            if (i != 0) {\n+                sb.append(',');\n+            }\n+            sb.append(javaSignature(argTypes[i]));\n+        }\n+        sb.append(')');\n+        return sb.toString();\n+    }\n+\n+    private MemberBox findExplicitFunction(String name, boolean isStatic)\n+    {\n+        int sigStart = name.indexOf('(');\n+        if (sigStart < 0) { return null; }\n+\n+        Map<String,Object> ht = isStatic ? staticMembers : members;\n+        MemberBox[] methodsOrCtors = null;\n+        boolean isCtor = (isStatic && sigStart == 0);\n+\n+        if (isCtor) {\n+            // Explicit request for an overloaded constructor\n+            methodsOrCtors = ctors;\n+        } else {\n+            // Explicit request for an overloaded method\n+            String trueName = name.substring(0,sigStart);\n+            Object obj = ht.get(trueName);\n+            if (!isStatic && obj == null) {\n+                // Try to get static member from instance (LC3)\n+                obj = staticMembers.get(trueName);\n+            }\n+            if (obj instanceof NativeJavaMethod) {\n+                NativeJavaMethod njm = (NativeJavaMethod)obj;\n+                methodsOrCtors = njm.methods;\n+            }\n+        }\n+\n+        if (methodsOrCtors != null) {\n+            for (int i = 0; i < methodsOrCtors.length; i++) {\n+                Class<?>[] type = methodsOrCtors[i].argTypes;\n+                String sig = liveConnectSignature(type);\n+                if (sigStart + sig.length() == name.length()\n+                    && name.regionMatches(sigStart, sig, 0, sig.length()))\n+                {\n+                    return methodsOrCtors[i];\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private Object getExplicitFunction(Scriptable scope, String name,\n+                                       Object javaObject, boolean isStatic)\n+    {\n+        Map<String,Object> ht = isStatic ? staticMembers : members;\n+        Object member = null;\n+        MemberBox methodOrCtor = findExplicitFunction(name, isStatic);\n+\n+        if (methodOrCtor != null) {\n+            Scriptable prototype =\n+                ScriptableObject.getFunctionPrototype(scope);\n+\n+            if (methodOrCtor.isCtor()) {\n+                NativeJavaConstructor fun =\n+                    new NativeJavaConstructor(methodOrCtor);\n+                fun.setPrototype(prototype);\n+                member = fun;\n+                ht.put(name, fun);\n+            } else {\n+                String trueName = methodOrCtor.getName();\n+                member = ht.get(trueName);\n+\n+                if (member instanceof NativeJavaMethod &&\n+                    ((NativeJavaMethod)member).methods.length > 1 ) {\n+                    NativeJavaMethod fun =\n+                        new NativeJavaMethod(methodOrCtor, name);\n+                    fun.setPrototype(prototype);\n+                    ht.put(name, fun);\n+                    member = fun;\n+                }\n+            }\n+        }\n+\n+        return member;\n+    }\n+\n+    /**\n+     * Retrieves mapping of methods to accessible methods for a class.\n+     * In case the class is not public, retrieves methods with same\n+     * signature as its public methods from public superclasses and\n+     * interfaces (if they exist). Basically upcasts every method to the\n+     * nearest accessible method.\n+     */\n+    private static Method[] discoverAccessibleMethods(Class<?> clazz,\n+                                                      boolean includeProtected,\n+                                                      boolean includePrivate)\n+    {\n+        Map<MethodSignature,Method> map = new HashMap<MethodSignature,Method>();\n+        discoverAccessibleMethods(clazz, map, includeProtected, includePrivate);\n+        return map.values().toArray(new Method[map.size()]);\n+    }\n+\n+    private static void discoverAccessibleMethods(Class<?> clazz,\n+            Map<MethodSignature,Method> map, boolean includeProtected,\n+            boolean includePrivate)\n+    {\n+        if (Modifier.isPublic(clazz.getModifiers()) || includePrivate) {\n+            try {\n+                if (includeProtected || includePrivate) {\n+                    while (clazz != null) {\n+                        try {\n+                            Method[] methods = clazz.getDeclaredMethods();\n+                            for (int i = 0; i < methods.length; i++) {\n+                                Method method = methods[i];\n+                                int mods = method.getModifiers();\n+\n+                                if (Modifier.isPublic(mods) ||\n+                                    Modifier.isProtected(mods) ||\n+                                    includePrivate)\n+                                {\n+                                    if (includePrivate)\n+                                        method.setAccessible(true);\n+                                    map.put(new MethodSignature(method), method);\n+                                }\n+                            }\n+                            clazz = clazz.getSuperclass();\n+                        } catch (SecurityException e) {\n+                            // Some security settings (i.e., applets) disallow\n+                            // access to Class.getDeclaredMethods. Fall back to\n+                            // Class.getMethods.\n+                            Method[] methods = clazz.getMethods();\n+                            for (int i = 0; i < methods.length; i++) {\n+                                Method method = methods[i];\n+                                MethodSignature sig\n+                                    = new MethodSignature(method);\n+                                if (map.get(sig) == null)\n+                                    map.put(sig, method);\n+                            }\n+                            break; // getMethods gets superclass methods, no\n+                                   // need to loop any more\n+                        }\n+                    }\n+                } else {\n+                    Method[] methods = clazz.getMethods();\n+                    for (int i = 0; i < methods.length; i++) {\n+                        Method method = methods[i];\n+                        MethodSignature sig = new MethodSignature(method);\n+                        map.put(sig, method);\n+                    }\n+                }\n+                return;\n+            } catch (SecurityException e) {\n+                Context.reportWarning(\n+                        \"Could not discover accessible methods of class \" +\n+                            clazz.getName() + \" due to lack of privileges, \" +\n+                            \"attemping superclasses/interfaces.\");\n+                // Fall through and attempt to discover superclass/interface\n+                // methods\n+            }\n+        }\n+\n+        Class<?>[] interfaces = clazz.getInterfaces();\n+        for (int i = 0; i < interfaces.length; i++) {\n+            discoverAccessibleMethods(interfaces[i], map, includeProtected,\n+                    includePrivate);\n+        }\n+        Class<?> superclass = clazz.getSuperclass();\n+        if (superclass != null) {\n+            discoverAccessibleMethods(superclass, map, includeProtected,\n+                    includePrivate);\n+        }\n+    }\n+\n+    private static final class MethodSignature\n+    {\n+        private final String name;\n+        private final Class<?>[] args;\n+\n+        private MethodSignature(String name, Class<?>[] args)\n+        {\n+            this.name = name;\n+            this.args = args;\n+        }\n+\n+        MethodSignature(Method method)\n+        {\n+            this(method.getName(), method.getParameterTypes());\n+        }\n+\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if(o instanceof MethodSignature)\n+            {\n+                MethodSignature ms = (MethodSignature)o;\n+                return ms.name.equals(name) && Arrays.equals(args, ms.args);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public int hashCode()\n+        {\n+            return name.hashCode() ^ args.length;\n+        }\n+    }\n+\n+    private void reflect(Scriptable scope, boolean includeProtected)\n+    {\n+        // We reflect methods first, because we want overloaded field/method\n+        // names to be allocated to the NativeJavaMethod before the field\n+        // gets in the way.\n+\n+        Method[] methods = discoverAccessibleMethods(cl, includeProtected,\n+                                                     includePrivate);\n+        for (int i = 0; i < methods.length; i++) {\n+            Method method = methods[i];\n+            int mods = method.getModifiers();\n+            boolean isStatic = Modifier.isStatic(mods);\n+            Map<String,Object> ht = isStatic ? staticMembers : members;\n+            String name = method.getName();\n+            Object value = ht.get(name);\n+            if (value == null) {\n+                ht.put(name, method);\n+            } else {\n+                ObjArray overloadedMethods;\n+                if (value instanceof ObjArray) {\n+                    overloadedMethods = (ObjArray)value;\n+                } else {\n+                    if (!(value instanceof Method)) Kit.codeBug();\n+                    // value should be instance of Method as at this stage\n+                    // staticMembers and members can only contain methods\n+                    overloadedMethods = new ObjArray();\n+                    overloadedMethods.add(value);\n+                    ht.put(name, overloadedMethods);\n+                }\n+                overloadedMethods.add(method);\n+            }\n+        }\n+\n+        // replace Method instances by wrapped NativeJavaMethod objects\n+        // first in staticMembers and then in members\n+        for (int tableCursor = 0; tableCursor != 2; ++tableCursor) {\n+            boolean isStatic = (tableCursor == 0);\n+            Map<String,Object> ht = isStatic ? staticMembers : members;\n+            for (Map.Entry<String, Object> entry: ht.entrySet()) {\n+                MemberBox[] methodBoxes;\n+                Object value = entry.getValue();\n+                if (value instanceof Method) {\n+                    methodBoxes = new MemberBox[1];\n+                    methodBoxes[0] = new MemberBox((Method)value);\n+                } else {\n+                    ObjArray overloadedMethods = (ObjArray)value;\n+                    int N = overloadedMethods.size();\n+                    if (N < 2) Kit.codeBug();\n+                    methodBoxes = new MemberBox[N];\n+                    for (int i = 0; i != N; ++i) {\n+                        Method method = (Method)overloadedMethods.get(i);\n+                        methodBoxes[i] = new MemberBox(method);\n+                    }\n+                }\n+                NativeJavaMethod fun = new NativeJavaMethod(methodBoxes);\n+                if (scope != null) {\n+                    ScriptRuntime.setFunctionProtoAndParent(fun, scope);\n+                }\n+                ht.put(entry.getKey(), fun);\n+            }\n+        }\n+\n+        // Reflect fields.\n+        Field[] fields = getAccessibleFields();\n+        for (int i = 0; i < fields.length; i++) {\n+            Field field = fields[i];\n+            String name = field.getName();\n+            int mods = field.getModifiers();\n+            if (!includePrivate && !Modifier.isPublic(mods)) {\n+                continue;\n+            }\n+            try {\n+                boolean isStatic = Modifier.isStatic(mods);\n+                Map<String,Object> ht = isStatic ? staticMembers : members;\n+                Object member = ht.get(name);\n+                if (member == null) {\n+                    ht.put(name, field);\n+                } else if (member instanceof NativeJavaMethod) {\n+                    NativeJavaMethod method = (NativeJavaMethod) member;\n+                    FieldAndMethods fam\n+                        = new FieldAndMethods(scope, method.methods, field);\n+                    Map<String,FieldAndMethods> fmht = isStatic ? staticFieldAndMethods\n+                                              : fieldAndMethods;\n+                    if (fmht == null) {\n+                        fmht = new HashMap<String,FieldAndMethods>();\n+                        if (isStatic) {\n+                            staticFieldAndMethods = fmht;\n+                        } else {\n+                            fieldAndMethods = fmht;\n+                        }\n+                    }\n+                    fmht.put(name, fam);\n+                    ht.put(name, fam);\n+                } else if (member instanceof Field) {\n+                    Field oldField = (Field) member;\n+                    // If this newly reflected field shadows an inherited field,\n+                    // then replace it. Otherwise, since access to the field\n+                    // would be ambiguous from Java, no field should be\n+                    // reflected.\n+                    // For now, the first field found wins, unless another field\n+                    // explicitly shadows it.\n+                    if (oldField.getDeclaringClass().\n+                            isAssignableFrom(field.getDeclaringClass()))\n+                    {\n+                        ht.put(name, field);\n+                    }\n+                } else {\n+                    // \"unknown member type\"\n+                    Kit.codeBug();\n+                }\n+            } catch (SecurityException e) {\n+                // skip this field\n+                Context.reportWarning(\"Could not access field \"\n+                        + name + \" of class \" + cl.getName() +\n+                        \" due to lack of privileges.\");\n+            }\n+        }\n+\n+        // Create bean properties from corresponding get/set methods first for\n+        // static members and then for instance members\n+        for (int tableCursor = 0; tableCursor != 2; ++tableCursor) {\n+            boolean isStatic = (tableCursor == 0);\n+            Map<String,Object> ht = isStatic ? staticMembers : members;\n+\n+            Map<String,BeanProperty> toAdd = new HashMap<String,BeanProperty>();\n+\n+            // Now, For each member, make \"bean\" properties.\n+            for (String name: ht.keySet()) {\n+                // Is this a getter?\n+                boolean memberIsGetMethod = name.startsWith(\"get\");\n+                boolean memberIsSetMethod = name.startsWith(\"set\");\n+                boolean memberIsIsMethod = name.startsWith(\"is\");\n+                if (memberIsGetMethod || memberIsIsMethod\n+                        || memberIsSetMethod) {\n+                    // Double check name component.\n+                    String nameComponent\n+                        = name.substring(memberIsIsMethod ? 2 : 3);\n+                    if (nameComponent.length() == 0)\n+                        continue;\n+\n+                    // Make the bean property name.\n+                    String beanPropertyName = nameComponent;\n+                    char ch0 = nameComponent.charAt(0);\n+                    if (Character.isUpperCase(ch0)) {\n+                        if (nameComponent.length() == 1) {\n+                            beanPropertyName = nameComponent.toLowerCase();\n+                        } else {\n+                            char ch1 = nameComponent.charAt(1);\n+                            if (!Character.isUpperCase(ch1)) {\n+                                beanPropertyName = Character.toLowerCase(ch0)\n+                                                   +nameComponent.substring(1);\n+                            }\n+                        }\n+                    }\n+\n+                    // If we already have a member by this name, don't do this\n+                    // property.\n+                    if (toAdd.containsKey(beanPropertyName))\n+                        continue;\n+                    Object v = ht.get(beanPropertyName);\n+                    if (v != null) {\n+                        // A private field shouldn't mask a public getter/setter\n+                        if (!includePrivate || !(v instanceof Member) ||\n+                            !Modifier.isPrivate(((Member)v).getModifiers()))\n+\n+                        {\n+                            continue;\n+                        }\n+                    }\n+\n+                    // Find the getter method, or if there is none, the is-\n+                    // method.\n+                    MemberBox getter = null;\n+                    getter = findGetter(isStatic, ht, \"get\", nameComponent);\n+                    // If there was no valid getter, check for an is- method.\n+                    if (getter == null) {\n+                        getter = findGetter(isStatic, ht, \"is\", nameComponent);\n+                    }\n+\n+                    // setter\n+                    MemberBox setter = null;\n+                    NativeJavaMethod setters = null;\n+                    String setterName = \"set\".concat(nameComponent);\n+\n+                    if (ht.containsKey(setterName)) {\n+                        // Is this value a method?\n+                        Object member = ht.get(setterName);\n+                        if (member instanceof NativeJavaMethod) {\n+                            NativeJavaMethod njmSet = (NativeJavaMethod)member;\n+                            if (getter != null) {\n+                                // We have a getter. Now, do we have a matching\n+                                // setter?\n+                                Class<?> type = getter.method().getReturnType();\n+                                setter = extractSetMethod(type, njmSet.methods,\n+                                                            isStatic);\n+                            } else {\n+                                // No getter, find any set method\n+                                setter = extractSetMethod(njmSet.methods,\n+                                                            isStatic);\n+                            }\n+                            if (njmSet.methods.length > 1) {\n+                                setters = njmSet;\n+                            }\n+                        }\n+                    }\n+                    // Make the property.\n+                    BeanProperty bp = new BeanProperty(getter, setter,\n+                                                       setters);\n+                    toAdd.put(beanPropertyName, bp);\n+                }\n+            }\n+\n+            // Add the new bean properties.\n+            for (String key: toAdd.keySet()) {\n+                Object value = toAdd.get(key);\n+                ht.put(key, value);\n+            }\n+        }\n+\n+        // Reflect constructors\n+        Constructor<?>[] constructors = getAccessibleConstructors();\n+        ctors = new MemberBox[constructors.length];\n+        for (int i = 0; i != constructors.length; ++i) {\n+            ctors[i] = new MemberBox(constructors[i]);\n+        }\n+    }\n+\n+    private Constructor<?>[] getAccessibleConstructors()\n+    {\n+      // The JVM currently doesn't allow changing access on java.lang.Class\n+      // constructors, so don't try\n+      if (includePrivate && cl != ScriptRuntime.ClassClass) {\n+          try {\n+              Constructor<?>[] cons = cl.getDeclaredConstructors();\n+              AccessibleObject.setAccessible(cons, true);\n+\n+              return cons;\n+          } catch (SecurityException e) {\n+              // Fall through to !includePrivate case\n+              Context.reportWarning(\"Could not access constructor \" +\n+                    \" of class \" + cl.getName() +\n+                    \" due to lack of privileges.\");\n+          }\n+      }\n+      return cl.getConstructors();\n+    }\n+\n+    private Field[] getAccessibleFields() {\n+        if (includePrivate) {\n+            try {\n+                List<Field> fieldsList = new ArrayList<Field>();\n+                Class<?> currentClass = cl;\n+\n+                while (currentClass != null) {\n+                    // get all declared fields in this class, make them\n+                    // accessible, and save\n+                    Field[] declared = currentClass.getDeclaredFields();\n+                    for (int i = 0; i < declared.length; i++) {\n+                        declared[i].setAccessible(true);\n+                        fieldsList.add(declared[i]);\n+                    }\n+                    // walk up superclass chain.  no need to deal specially with\n+                    // interfaces, since they can't have fields\n+                    currentClass = currentClass.getSuperclass();\n+                }\n+\n+                return fieldsList.toArray(new Field[fieldsList.size()]);\n+            } catch (SecurityException e) {\n+                // fall through to !includePrivate case\n+            }\n+        }\n+        return cl.getFields();\n+    }\n+\n+    private MemberBox findGetter(boolean isStatic, Map<String,Object> ht, String prefix,\n+                                 String propertyName)\n+    {\n+        String getterName = prefix.concat(propertyName);\n+        if (ht.containsKey(getterName)) {\n+            // Check that the getter is a method.\n+            Object member = ht.get(getterName);\n+            if (member instanceof NativeJavaMethod) {\n+                NativeJavaMethod njmGet = (NativeJavaMethod) member;\n+                return extractGetMethod(njmGet.methods, isStatic);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static MemberBox extractGetMethod(MemberBox[] methods,\n+                                              boolean isStatic)\n+    {\n+        // Inspect the list of all MemberBox for the only one having no\n+        // parameters\n+        for (int methodIdx = 0; methodIdx < methods.length; methodIdx++) {\n+            MemberBox method = methods[methodIdx];\n+            // Does getter method have an empty parameter list with a return\n+            // value (eg. a getSomething() or isSomething())?\n+            if (method.argTypes.length == 0\n+                && (!isStatic || method.isStatic()))\n+            {\n+                Class<?> type = method.method().getReturnType();\n+                if (type != Void.TYPE) {\n+                    return method;\n+                }\n+                break;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static MemberBox extractSetMethod(Class<?> type, MemberBox[] methods,\n+                                              boolean isStatic)\n+    {\n+        //\n+        // Note: it may be preferable to allow NativeJavaMethod.findFunction()\n+        //       to find the appropriate setter; unfortunately, it requires an\n+        //       instance of the target arg to determine that.\n+        //\n+\n+        // Make two passes: one to find a method with direct type assignment,\n+        // and one to find a widening conversion.\n+        for (int pass = 1; pass <= 2; ++pass) {\n+            for (int i = 0; i < methods.length; ++i) {\n+                MemberBox method = methods[i];\n+                if (!isStatic || method.isStatic()) {\n+                    Class<?>[] params = method.argTypes;\n+                    if (params.length == 1) {\n+                        if (pass == 1) {\n+                            if (params[0] == type) {\n+                                return method;\n+                            }\n+                        } else {\n+                            if (pass != 2) Kit.codeBug();\n+                            if (params[0].isAssignableFrom(type)) {\n+                                return method;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static MemberBox extractSetMethod(MemberBox[] methods,\n+                                              boolean isStatic)\n+    {\n+\n+        for (int i = 0; i < methods.length; ++i) {\n+            MemberBox method = methods[i];\n+            if (!isStatic || method.isStatic()) {\n+                if (method.method().getReturnType() == Void.TYPE) {\n+                    if (method.argTypes.length == 1) {\n+                        return method;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    Map<String,FieldAndMethods> getFieldAndMethodsObjects(Scriptable scope,\n+            Object javaObject, boolean isStatic)\n+    {\n+        Map<String,FieldAndMethods> ht = isStatic ? staticFieldAndMethods : fieldAndMethods;\n+        if (ht == null)\n+            return null;\n+        int len = ht.size();\n+        Map<String,FieldAndMethods> result = new HashMap<String,FieldAndMethods>(len);\n+        for (FieldAndMethods fam: ht.values()) {\n+            FieldAndMethods famNew = new FieldAndMethods(scope, fam.methods,\n+                                                         fam.field);\n+            famNew.javaObject = javaObject;\n+            result.put(fam.field.getName(), famNew);\n+        }\n+        return result;\n+    }\n+\n+    static JavaMembers lookupClass(Scriptable scope, Class<?> dynamicType,\n+                                   Class<?> staticType, boolean includeProtected)\n+    {\n+        JavaMembers members;\n+        ClassCache cache = ClassCache.get(scope);\n+        Map<Class<?>,JavaMembers> ct = cache.getClassCacheMap();\n+\n+        Class<?> cl = dynamicType;\n+        for (;;) {\n+            members = ct.get(cl);\n+            if (members != null) {\n+                return members;\n+            }\n+            try {\n+                members = new JavaMembers(cache.getAssociatedScope(), cl,\n+                        includeProtected);\n+                break;\n+            } catch (SecurityException e) {\n+                // Reflection may fail for objects that are in a restricted\n+                // access package (e.g. sun.*).  If we get a security\n+                // exception, try again with the static type if it is interface.\n+                // Otherwise, try superclass\n+                if (staticType != null && staticType.isInterface()) {\n+                    cl = staticType;\n+                    staticType = null; // try staticType only once\n+                } else {\n+                    Class<?> parent = cl.getSuperclass();\n+                    if (parent == null) {\n+                        if (cl.isInterface()) {\n+                            // last resort after failed staticType interface\n+                            parent = ScriptRuntime.ObjectClass;\n+                        } else {\n+                            throw e;\n+                        }\n+                    }\n+                    cl = parent;\n+                }\n+            }\n+        }\n+\n+        if (cache.isCachingEnabled())\n+            ct.put(cl, members);\n+        return members;\n+    }\n+\n+    RuntimeException reportMemberNotFound(String memberName)\n+    {\n+        return Context.reportRuntimeError2(\n+            \"msg.java.member.not.found\", cl.getName(), memberName);\n+    }\n+\n+    private Class<?> cl;\n+    private Map<String,Object> members;\n+    private Map<String,FieldAndMethods> fieldAndMethods;\n+    private Map<String,Object> staticMembers;\n+    private Map<String,FieldAndMethods> staticFieldAndMethods;\n+    MemberBox[] ctors;\n+    private boolean includePrivate;\n+}\n+\n+class BeanProperty\n+{\n+    BeanProperty(MemberBox getter, MemberBox setter, NativeJavaMethod setters)\n+    {\n+        this.getter = getter;\n+        this.setter = setter;\n+        this.setters = setters;\n+    }\n+\n+    MemberBox getter;\n+    MemberBox setter;\n+    NativeJavaMethod setters;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/JavaScriptException.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Bojan Cekrlic\n+ *   Hannes Wallnoefer\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Java reflection of JavaScript exceptions.\n+ * Instances of this class are thrown by the JavaScript 'throw' keyword.\n+ *\n+ */\n+public class JavaScriptException extends RhinoException\n+{\n+    static final long serialVersionUID = -7666130513694669293L;\n+\n+    /**\n+     * @deprecated\n+     * Use {@link WrappedException#WrappedException(Throwable)} to report\n+     * exceptions in Java code.\n+     */\n+    public JavaScriptException(Object value)\n+    {\n+        this(value, \"\", 0);\n+    }\n+\n+    /**\n+     * Create a JavaScript exception wrapping the given JavaScript value\n+     *\n+     * @param value the JavaScript value thrown.\n+     */\n+    public JavaScriptException(Object value, String sourceName, int lineNumber)\n+    {\n+        recordErrorOrigin(sourceName, lineNumber, null, 0);\n+        this.value = value;\n+    }\n+\n+    @Override\n+    public String details()\n+    {\n+        if (value == null) {\n+            return \"null\";\n+        } else if (value instanceof NativeError) {\n+            return value.toString();\n+        }\n+        try {\n+            return ScriptRuntime.toString(value);\n+        } catch (RuntimeException rte) {\n+            // ScriptRuntime.toString may throw a RuntimeException\n+            if (value instanceof Scriptable) {\n+                return ScriptRuntime.defaultObjectToString((Scriptable)value);\n+            } else {\n+                return value.toString();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @return the value wrapped by this exception\n+     */\n+    public Object getValue()\n+    {\n+        return value;\n+    }\n+\n+    /**\n+     * @deprecated Use {@link RhinoException#sourceName()} from the super class.\n+     */\n+    public String getSourceName()\n+    {\n+        return sourceName();\n+    }\n+\n+    /**\n+     * @deprecated Use {@link RhinoException#lineNumber()} from the super class.\n+     */\n+    public int getLineNumber()\n+    {\n+        return lineNumber();\n+    }\n+\n+    private Object value;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Kit.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov, igor@fastmail.fm\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+\n+/**\n+ * Collection of utilities\n+ */\n+\n+public class Kit\n+{\n+    /**\n+     * Reflection of Throwable.initCause(Throwable) from JDK 1.4\n+     * or nul if it is not available.\n+     */\n+    private static Method Throwable_initCause = null;\n+\n+    static {\n+        // Are we running on a JDK 1.4 or later system?\n+        try {\n+            Class<?> ThrowableClass = Kit.classOrNull(\"java.lang.Throwable\");\n+            Class<?>[] signature = { ThrowableClass };\n+            Throwable_initCause\n+                = ThrowableClass.getMethod(\"initCause\", signature);\n+        } catch (Exception ex) {\n+            // Assume any exceptions means the method does not exist.\n+        }\n+    }\n+\n+    public static Class<?> classOrNull(String className)\n+    {\n+        try {\n+            return Class.forName(className);\n+        } catch  (ClassNotFoundException ex) {\n+        } catch  (SecurityException ex) {\n+        } catch  (LinkageError ex) {\n+        } catch (IllegalArgumentException e) {\n+            // Can be thrown if name has characters that a class name\n+            // can not contain\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Attempt to load the class of the given name. Note that the type parameter\n+     * isn't checked.\n+     */\n+    public static Class<?> classOrNull(ClassLoader loader, String className)\n+    {\n+        try {\n+            return loader.loadClass(className);\n+        } catch (ClassNotFoundException ex) {\n+        } catch (SecurityException ex) {\n+        } catch (LinkageError ex) {\n+        } catch (IllegalArgumentException e) {\n+            // Can be thrown if name has characters that a class name\n+            // can not contain\n+        }\n+        return null;\n+    }\n+\n+    static Object newInstanceOrNull(Class<?> cl)\n+    {\n+        try {\n+            return cl.newInstance();\n+        } catch (SecurityException x) {\n+        } catch  (LinkageError ex) {\n+        } catch (InstantiationException x) {\n+        } catch (IllegalAccessException x) {\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Check that testClass is accessible from the given loader.\n+     */\n+    static boolean testIfCanLoadRhinoClasses(ClassLoader loader)\n+    {\n+        Class<?> testClass = ScriptRuntime.ContextFactoryClass;\n+        Class<?> x = Kit.classOrNull(loader, testClass.getName());\n+        if (x != testClass) {\n+            // The check covers the case when x == null =>\n+            // loader does not know about testClass or the case\n+            // when x != null && x != testClass =>\n+            // loader loads a class unrelated to testClass\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * If initCause methods exists in Throwable, call\n+     * <tt>ex.initCause(cause)</tt> or otherwise do nothing.\n+     * @return The <tt>ex</tt> argument.\n+     */\n+    public static RuntimeException initCause(RuntimeException ex,\n+                                             Throwable cause)\n+    {\n+        if (Throwable_initCause != null) {\n+            Object[] args = { cause };\n+            try {\n+                Throwable_initCause.invoke(ex, args);\n+            } catch (Exception e) {\n+                // Ignore any exceptions\n+            }\n+        }\n+        return ex;\n+    }\n+\n+    /**\n+     * If character <tt>c</tt> is a hexadecimal digit, return\n+     * <tt>accumulator</tt> * 16 plus corresponding\n+     * number. Otherise return -1.\n+     */\n+    public static int xDigitToInt(int c, int accumulator)\n+    {\n+        check: {\n+            // Use 0..9 < A..Z < a..z\n+            if (c <= '9') {\n+                c -= '0';\n+                if (0 <= c) { break check; }\n+            } else if (c <= 'F') {\n+                if ('A' <= c) {\n+                    c -= ('A' - 10);\n+                    break check;\n+                }\n+            } else if (c <= 'f') {\n+                if ('a' <= c) {\n+                    c -= ('a' - 10);\n+                    break check;\n+                }\n+            }\n+            return -1;\n+        }\n+        return (accumulator << 4) | c;\n+    }\n+\n+    /**\n+     * Add <i>listener</i> to <i>bag</i> of listeners.\n+     * The function does not modify <i>bag</i> and return a new collection\n+     * containing <i>listener</i> and all listeners from <i>bag</i>.\n+     * Bag without listeners always represented as the null value.\n+     * <p>\n+     * Usage example:\n+     * <pre>\n+     *     private volatile Object changeListeners;\n+     *\n+     *     public void addMyListener(PropertyChangeListener l)\n+     *     {\n+     *         synchronized (this) {\n+     *             changeListeners = Kit.addListener(changeListeners, l);\n+     *         }\n+     *     }\n+     *\n+     *     public void removeTextListener(PropertyChangeListener l)\n+     *     {\n+     *         synchronized (this) {\n+     *             changeListeners = Kit.removeListener(changeListeners, l);\n+     *         }\n+     *     }\n+     *\n+     *     public void fireChangeEvent(Object oldValue, Object newValue)\n+     *     {\n+     *     // Get immune local copy\n+     *         Object listeners = changeListeners;\n+     *         if (listeners != null) {\n+     *             PropertyChangeEvent e = new PropertyChangeEvent(\n+     *                 this, \"someProperty\" oldValue, newValue);\n+     *             for (int i = 0; ; ++i) {\n+     *                 Object l = Kit.getListener(listeners, i);\n+     *                 if (l == null)\n+     *                     break;\n+     *                 ((PropertyChangeListener)l).propertyChange(e);\n+     *             }\n+     *         }\n+     *     }\n+     * </pre>\n+     *\n+     * @param listener Listener to add to <i>bag</i>\n+     * @param bag Current collection of listeners.\n+     * @return A new bag containing all listeners from <i>bag</i> and\n+     *          <i>listener</i>.\n+     * @see #removeListener(Object bag, Object listener)\n+     * @see #getListener(Object bag, int index)\n+     */\n+    public static Object addListener(Object bag, Object listener)\n+    {\n+        if (listener == null) throw new IllegalArgumentException();\n+        if (listener instanceof Object[]) throw new IllegalArgumentException();\n+\n+        if (bag == null) {\n+            bag = listener;\n+        } else if (!(bag instanceof Object[])) {\n+            bag = new Object[] { bag, listener };\n+        } else {\n+            Object[] array = (Object[])bag;\n+            int L = array.length;\n+            // bag has at least 2 elements if it is array\n+            if (L < 2) throw new IllegalArgumentException();\n+            Object[] tmp = new Object[L + 1];\n+            System.arraycopy(array, 0, tmp, 0, L);\n+            tmp[L] = listener;\n+            bag = tmp;\n+        }\n+\n+        return bag;\n+    }\n+\n+    /**\n+     * Remove <i>listener</i> from <i>bag</i> of listeners.\n+     * The function does not modify <i>bag</i> and return a new collection\n+     * containing all listeners from <i>bag</i> except <i>listener</i>.\n+     * If <i>bag</i> does not contain <i>listener</i>, the function returns\n+     * <i>bag</i>.\n+     * <p>\n+     * For usage example, see {@link #addListener(Object bag, Object listener)}.\n+     *\n+     * @param listener Listener to remove from <i>bag</i>\n+     * @param bag Current collection of listeners.\n+     * @return A new bag containing all listeners from <i>bag</i> except\n+     *          <i>listener</i>.\n+     * @see #addListener(Object bag, Object listener)\n+     * @see #getListener(Object bag, int index)\n+     */\n+    public static Object removeListener(Object bag, Object listener)\n+    {\n+        if (listener == null) throw new IllegalArgumentException();\n+        if (listener instanceof Object[]) throw new IllegalArgumentException();\n+\n+        if (bag == listener) {\n+            bag = null;\n+        } else if (bag instanceof Object[]) {\n+            Object[] array = (Object[])bag;\n+            int L = array.length;\n+            // bag has at least 2 elements if it is array\n+            if (L < 2) throw new IllegalArgumentException();\n+            if (L == 2) {\n+                if (array[1] == listener) {\n+                    bag = array[0];\n+                } else if (array[0] == listener) {\n+                    bag = array[1];\n+                }\n+            } else {\n+                int i = L;\n+                do {\n+                    --i;\n+                    if (array[i] == listener) {\n+                        Object[] tmp = new Object[L - 1];\n+                        System.arraycopy(array, 0, tmp, 0, i);\n+                        System.arraycopy(array, i + 1, tmp, i, L - (i + 1));\n+                        bag = tmp;\n+                        break;\n+                    }\n+                } while (i != 0);\n+            }\n+        }\n+\n+        return bag;\n+    }\n+\n+    /**\n+     * Get listener at <i>index</i> position in <i>bag</i> or null if\n+     * <i>index</i> equals to number of listeners in <i>bag</i>.\n+     * <p>\n+     * For usage example, see {@link #addListener(Object bag, Object listener)}.\n+     *\n+     * @param bag Current collection of listeners.\n+     * @param index Index of the listener to access.\n+     * @return Listener at the given index or null.\n+     * @see #addListener(Object bag, Object listener)\n+     * @see #removeListener(Object bag, Object listener)\n+     */\n+    public static Object getListener(Object bag, int index)\n+    {\n+        if (index == 0) {\n+            if (bag == null)\n+                return null;\n+            if (!(bag instanceof Object[]))\n+                return bag;\n+            Object[] array = (Object[])bag;\n+            // bag has at least 2 elements if it is array\n+            if (array.length < 2) throw new IllegalArgumentException();\n+            return array[0];\n+        } else if (index == 1) {\n+            if (!(bag instanceof Object[])) {\n+                if (bag == null) throw new IllegalArgumentException();\n+                return null;\n+            }\n+            Object[] array = (Object[])bag;\n+            // the array access will check for index on its own\n+            return array[1];\n+        } else {\n+            // bag has to array\n+            Object[] array = (Object[])bag;\n+            int L = array.length;\n+            if (L < 2) throw new IllegalArgumentException();\n+            if (index == L)\n+                return null;\n+            return array[index];\n+        }\n+    }\n+\n+    static Object initHash(Map<Object,Object> h, Object key, Object initialValue)\n+    {\n+        synchronized (h) {\n+            Object current = h.get(key);\n+            if (current == null) {\n+                h.put(key, initialValue);\n+            } else {\n+                initialValue = current;\n+            }\n+        }\n+        return initialValue;\n+    }\n+\n+    private final static class ComplexKey\n+    {\n+        private Object key1;\n+        private Object key2;\n+        private int hash;\n+\n+        ComplexKey(Object key1, Object key2)\n+        {\n+            this.key1 = key1;\n+            this.key2 = key2;\n+        }\n+\n+        @Override\n+        public boolean equals(Object anotherObj)\n+        {\n+            if (!(anotherObj instanceof ComplexKey))\n+                return false;\n+            ComplexKey another = (ComplexKey)anotherObj;\n+            return key1.equals(another.key1) && key2.equals(another.key2);\n+        }\n+\n+        @Override\n+        public int hashCode()\n+        {\n+            if (hash == 0) {\n+                hash = key1.hashCode() ^ key2.hashCode();\n+            }\n+            return hash;\n+        }\n+    }\n+\n+    public static Object makeHashKeyFromPair(Object key1, Object key2)\n+    {\n+        if (key1 == null) throw new IllegalArgumentException();\n+        if (key2 == null) throw new IllegalArgumentException();\n+        return new ComplexKey(key1, key2);\n+    }\n+\n+    public static String readReader(Reader r)\n+        throws IOException\n+    {\n+        char[] buffer = new char[512];\n+        int cursor = 0;\n+        for (;;) {\n+            int n = r.read(buffer, cursor, buffer.length - cursor);\n+            if (n < 0) { break; }\n+            cursor += n;\n+            if (cursor == buffer.length) {\n+                char[] tmp = new char[buffer.length * 2];\n+                System.arraycopy(buffer, 0, tmp, 0, cursor);\n+                buffer = tmp;\n+            }\n+        }\n+        return new String(buffer, 0, cursor);\n+    }\n+\n+    public static byte[] readStream(InputStream is, int initialBufferCapacity)\n+        throws IOException\n+    {\n+        if (initialBufferCapacity <= 0) {\n+            throw new IllegalArgumentException(\n+                \"Bad initialBufferCapacity: \"+initialBufferCapacity);\n+        }\n+        byte[] buffer = new byte[initialBufferCapacity];\n+        int cursor = 0;\n+        for (;;) {\n+            int n = is.read(buffer, cursor, buffer.length - cursor);\n+            if (n < 0) { break; }\n+            cursor += n;\n+            if (cursor == buffer.length) {\n+                byte[] tmp = new byte[buffer.length * 2];\n+                System.arraycopy(buffer, 0, tmp, 0, cursor);\n+                buffer = tmp;\n+            }\n+        }\n+        if (cursor != buffer.length) {\n+            byte[] tmp = new byte[cursor];\n+            System.arraycopy(buffer, 0, tmp, 0, cursor);\n+            buffer = tmp;\n+        }\n+        return buffer;\n+    }\n+\n+    /**\n+     * Throws RuntimeException to indicate failed assertion.\n+     * The function never returns and its return type is RuntimeException\n+     * only to be able to write <tt>throw Kit.codeBug()</tt> if plain\n+     * <tt>Kit.codeBug()</tt> triggers unreachable code error.\n+     */\n+    public static RuntimeException codeBug()\n+        throws RuntimeException\n+    {\n+        RuntimeException ex = new IllegalStateException(\"FAILED ASSERTION\");\n+        // Print stack trace ASAP\n+        ex.printStackTrace(System.err);\n+        throw ex;\n+    }\n+\n+    /**\n+     * Throws RuntimeException to indicate failed assertion.\n+     * The function never returns and its return type is RuntimeException\n+     * only to be able to write <tt>throw Kit.codeBug()</tt> if plain\n+     * <tt>Kit.codeBug()</tt> triggers unreachable code error.\n+     */\n+    public static RuntimeException codeBug(String msg)\n+        throws RuntimeException\n+    {\n+        msg = \"FAILED ASSERTION: \" + msg;\n+        RuntimeException ex = new IllegalStateException(msg);\n+        // Print stack trace ASAP\n+        ex.printStackTrace(System.err);\n+        throw ex;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/LazilyLoadedCtor.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.reflect.*;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+/**\n+ * Avoid loading classes unless they are used.\n+ *\n+ * <p> This improves startup time and average memory usage.\n+ */\n+public final class LazilyLoadedCtor implements java.io.Serializable {\n+\tprivate static final long serialVersionUID = 1L;\n+\t\n+    private static final int STATE_BEFORE_INIT = 0;\n+    private static final int STATE_INITIALIZING = 1;\n+    private static final int STATE_WITH_VALUE = 2;\n+\n+    private final ScriptableObject scope;\n+    private final String propertyName;\n+    private final String className;\n+    private final boolean sealed;\n+    private final boolean privileged;\n+    private Object initializedValue;\n+    private int state;\n+\n+    public LazilyLoadedCtor(ScriptableObject scope, String propertyName, \n+            String className, boolean sealed)\n+    {\n+        this(scope, propertyName, className, sealed, false);\n+    }\n+\n+    LazilyLoadedCtor(ScriptableObject scope, String propertyName,\n+            String className, boolean sealed, boolean privileged)\n+    {\n+\n+        this.scope = scope;\n+        this.propertyName = propertyName;\n+        this.className = className;\n+        this.sealed = sealed;\n+        this.privileged = privileged;\n+        this.state = STATE_BEFORE_INIT;\n+\n+        scope.addLazilyInitializedValue(propertyName, 0, this,\n+                ScriptableObject.DONTENUM);\n+    }\n+\n+    void init()\n+    {\n+        synchronized (this) {\n+            if (state == STATE_INITIALIZING)\n+                throw new IllegalStateException(\n+                    \"Recursive initialization for \"+propertyName);\n+            if (state == STATE_BEFORE_INIT) {\n+                state = STATE_INITIALIZING;\n+                // Set value now to have something to set in finally block if\n+                // buildValue throws.\n+                Object value = Scriptable.NOT_FOUND;\n+                try {\n+                    value = buildValue();\n+                } finally {\n+                    initializedValue = value;\n+                    state = STATE_WITH_VALUE;\n+                }\n+            }\n+        }\n+    }\n+\n+    Object getValue()\n+    {\n+        if (state != STATE_WITH_VALUE)\n+            throw new IllegalStateException(propertyName);\n+        return initializedValue;\n+    }\n+\n+    private Object buildValue()\n+    {\n+        if(privileged)\n+        {\n+            return AccessController.doPrivileged(new PrivilegedAction<Object>()\n+            {\n+                public Object run()\n+                {\n+                    return buildValue0();\n+                }\n+            });\n+        }\n+        else\n+        {\n+            return buildValue0();\n+        }\n+    }\n+    \n+    private Object buildValue0()\n+    {\n+        Class<? extends Scriptable> cl = cast(Kit.classOrNull(className));\n+        if (cl != null) {\n+            try {\n+                Object value = ScriptableObject.buildClassCtor(scope, cl,\n+                                                               sealed, false);\n+                if (value != null) {\n+                    return value;\n+                }\n+                else {\n+                    // cl has own static initializer which is expected\n+                    // to set the property on its own.\n+                    value = scope.get(propertyName, scope);\n+                    if (value != Scriptable.NOT_FOUND)\n+                        return value;\n+                }\n+            } catch (InvocationTargetException ex) {\n+                Throwable target = ex.getTargetException();\n+                if (target instanceof RuntimeException) {\n+                    throw (RuntimeException)target;\n+                }\n+            } catch (RhinoException ex) {\n+            } catch (InstantiationException ex) {\n+            } catch (IllegalAccessException ex) {\n+            } catch (SecurityException ex) {\n+            }\n+        }\n+        return Scriptable.NOT_FOUND;\n+    }\n+    \n+    @SuppressWarnings({\"unchecked\"})\n+    private Class<? extends Scriptable> cast(Class<?> cl) {\n+        return (Class<? extends Scriptable>)cl;\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/MemberBox.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Felix Meschberger\n+ *   Norris Boyd\n+ *   Ulrike Mueller <umueller@demandware.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.reflect.*;\n+import java.io.*;\n+\n+/**\n+ * Wrappper class for Method and Constructor instances to cache\n+ * getParameterTypes() results, recover from IllegalAccessException\n+ * in some cases and provide serialization support.\n+ *\n+ */\n+\n+final class MemberBox implements Serializable\n+{\n+    static final long serialVersionUID = 6358550398665688245L;\n+\n+    private transient Member memberObject;\n+    transient Class<?>[] argTypes;\n+    transient Object delegateTo;\n+    transient boolean vararg;\n+\n+\n+    MemberBox(Method method)\n+    {\n+        init(method);\n+    }\n+\n+    MemberBox(Constructor<?> constructor)\n+    {\n+        init(constructor);\n+    }\n+\n+    private void init(Method method)\n+    {\n+        this.memberObject = method;\n+        this.argTypes = method.getParameterTypes();\n+        this.vararg = VMBridge.instance.isVarArgs(method);\n+    }\n+\n+    private void init(Constructor<?> constructor)\n+    {\n+        this.memberObject = constructor;\n+        this.argTypes = constructor.getParameterTypes();\n+        this.vararg = VMBridge.instance.isVarArgs(constructor);\n+    }\n+\n+    Method method()\n+    {\n+        return (Method)memberObject;\n+    }\n+\n+    Constructor<?> ctor()\n+    {\n+        return (Constructor<?>)memberObject;\n+    }\n+\n+    Member member()\n+    {\n+        return memberObject;\n+    }\n+\n+    boolean isMethod()\n+    {\n+        return memberObject instanceof Method;\n+    }\n+\n+    boolean isCtor()\n+    {\n+        return memberObject instanceof Constructor;\n+    }\n+\n+    boolean isStatic()\n+    {\n+        return Modifier.isStatic(memberObject.getModifiers());\n+    }\n+\n+    String getName()\n+    {\n+        return memberObject.getName();\n+    }\n+\n+    Class<?> getDeclaringClass()\n+    {\n+        return memberObject.getDeclaringClass();\n+    }\n+\n+    String toJavaDeclaration()\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        if (isMethod()) {\n+            Method method = method();\n+            sb.append(method.getReturnType());\n+            sb.append(' ');\n+            sb.append(method.getName());\n+        } else {\n+            Constructor<?> ctor = ctor();\n+            String name = ctor.getDeclaringClass().getName();\n+            int lastDot = name.lastIndexOf('.');\n+            if (lastDot >= 0) {\n+                name = name.substring(lastDot + 1);\n+            }\n+            sb.append(name);\n+        }\n+        sb.append(JavaMembers.liveConnectSignature(argTypes));\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return memberObject.toString();\n+    }\n+\n+    Object invoke(Object target, Object[] args)\n+    {\n+        Method method = method();\n+        try {\n+            try {\n+                return method.invoke(target, args);\n+            } catch (IllegalAccessException ex) {\n+                Method accessible = searchAccessibleMethod(method, argTypes);\n+                if (accessible != null) {\n+                    memberObject = accessible;\n+                    method = accessible;\n+                } else {\n+                    if (!VMBridge.instance.tryToMakeAccessible(method)) {\n+                        throw Context.throwAsScriptRuntimeEx(ex);\n+                    }\n+                }\n+                // Retry after recovery\n+                return method.invoke(target, args);\n+            }\n+        } catch (InvocationTargetException ite) {\n+            // Must allow ContinuationPending exceptions to propagate unhindered\n+            Throwable e = ite;\n+            do {\n+                e = ((InvocationTargetException) e).getTargetException();\n+            } while ((e instanceof InvocationTargetException));\n+            if (e instanceof ContinuationPending)\n+                throw (ContinuationPending) e;\n+            throw Context.throwAsScriptRuntimeEx(e);\n+        } catch (Exception ex) {\n+            throw Context.throwAsScriptRuntimeEx(ex);\n+        }\n+    }\n+\n+    Object newInstance(Object[] args)\n+    {\n+        Constructor<?> ctor = ctor();\n+        try {\n+            try {\n+                return ctor.newInstance(args);\n+            } catch (IllegalAccessException ex) {\n+                if (!VMBridge.instance.tryToMakeAccessible(ctor)) {\n+                    throw Context.throwAsScriptRuntimeEx(ex);\n+                }\n+            }\n+            return ctor.newInstance(args);\n+        } catch (Exception ex) {\n+            throw Context.throwAsScriptRuntimeEx(ex);\n+        }\n+    }\n+\n+    private static Method searchAccessibleMethod(Method method, Class<?>[] params)\n+    {\n+        int modifiers = method.getModifiers();\n+        if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers)) {\n+            Class<?> c = method.getDeclaringClass();\n+            if (!Modifier.isPublic(c.getModifiers())) {\n+                String name = method.getName();\n+                Class<?>[] intfs = c.getInterfaces();\n+                for (int i = 0, N = intfs.length; i != N; ++i) {\n+                    Class<?> intf = intfs[i];\n+                    if (Modifier.isPublic(intf.getModifiers())) {\n+                        try {\n+                            return intf.getMethod(name, params);\n+                        } catch (NoSuchMethodException ex) {\n+                        } catch (SecurityException ex) {  }\n+                    }\n+                }\n+                for (;;) {\n+                    c = c.getSuperclass();\n+                    if (c == null) { break; }\n+                    if (Modifier.isPublic(c.getModifiers())) {\n+                        try {\n+                            Method m = c.getMethod(name, params);\n+                            int mModifiers = m.getModifiers();\n+                            if (Modifier.isPublic(mModifiers)\n+                                && !Modifier.isStatic(mModifiers))\n+                            {\n+                                return m;\n+                            }\n+                        } catch (NoSuchMethodException ex) {\n+                        } catch (SecurityException ex) {  }\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException\n+    {\n+        in.defaultReadObject();\n+        Member member = readMember(in);\n+        if (member instanceof Method) {\n+            init((Method)member);\n+        } else {\n+            init((Constructor<?>)member);\n+        }\n+    }\n+\n+    private void writeObject(ObjectOutputStream out)\n+        throws IOException\n+    {\n+        out.defaultWriteObject();\n+        writeMember(out, memberObject);\n+    }\n+\n+    /**\n+     * Writes a Constructor or Method object.\n+     *\n+     * Methods and Constructors are not serializable, so we must serialize\n+     * information about the class, the name, and the parameters and\n+     * recreate upon deserialization.\n+     */\n+    private static void writeMember(ObjectOutputStream out, Member member)\n+        throws IOException\n+    {\n+        if (member == null) {\n+            out.writeBoolean(false);\n+            return;\n+        }\n+        out.writeBoolean(true);\n+        if (!(member instanceof Method || member instanceof Constructor))\n+            throw new IllegalArgumentException(\"not Method or Constructor\");\n+        out.writeBoolean(member instanceof Method);\n+        out.writeObject(member.getName());\n+        out.writeObject(member.getDeclaringClass());\n+        if (member instanceof Method) {\n+            writeParameters(out, ((Method) member).getParameterTypes());\n+        } else {\n+            writeParameters(out, ((Constructor<?>) member).getParameterTypes());\n+        }\n+    }\n+\n+    /**\n+     * Reads a Method or a Constructor from the stream.\n+     */\n+    private static Member readMember(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException\n+    {\n+        if (!in.readBoolean())\n+            return null;\n+        boolean isMethod = in.readBoolean();\n+        String name = (String) in.readObject();\n+        Class<?> declaring = (Class<?>) in.readObject();\n+        Class<?>[] parms = readParameters(in);\n+        try {\n+            if (isMethod) {\n+                return declaring.getMethod(name, parms);\n+            } else {\n+                return declaring.getConstructor(parms);\n+            }\n+        } catch (NoSuchMethodException e) {\n+            throw new IOException(\"Cannot find member: \" + e);\n+        }\n+    }\n+\n+    private static final Class<?>[] primitives = {\n+        Boolean.TYPE,\n+        Byte.TYPE,\n+        Character.TYPE,\n+        Double.TYPE,\n+        Float.TYPE,\n+        Integer.TYPE,\n+        Long.TYPE,\n+        Short.TYPE,\n+        Void.TYPE\n+    };\n+\n+    /**\n+     * Writes an array of parameter types to the stream.\n+     *\n+     * Requires special handling because primitive types cannot be\n+     * found upon deserialization by the default Java implementation.\n+     */\n+    private static void writeParameters(ObjectOutputStream out, Class<?>[] parms)\n+        throws IOException\n+    {\n+        out.writeShort(parms.length);\n+    outer:\n+        for (int i=0; i < parms.length; i++) {\n+            Class<?> parm = parms[i];\n+            boolean primitive = parm.isPrimitive();\n+            out.writeBoolean(primitive);\n+            if (!primitive) {\n+                out.writeObject(parm);\n+                continue;\n+            }\n+            for (int j=0; j < primitives.length; j++) {\n+                if (parm.equals(primitives[j])) {\n+                    out.writeByte(j);\n+                    continue outer;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Primitive \" + parm +\n+                                               \" not found\");\n+        }\n+    }\n+\n+    /**\n+     * Reads an array of parameter types from the stream.\n+     */\n+    private static Class<?>[] readParameters(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException\n+    {\n+        Class<?>[] result = new Class[in.readShort()];\n+        for (int i=0; i < result.length; i++) {\n+            if (!in.readBoolean()) {\n+                result[i] = (Class<?>) in.readObject();\n+                continue;\n+            }\n+            result[i] = primitives[in.readByte()];\n+        }\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeArray.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Mike McCabe\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+/**\n+ * This class implements the Array native object.\n+ */\n+public class NativeArray extends IdScriptableObject\n+{\n+    static final long serialVersionUID = 7331366857676127338L;\n+\n+    /*\n+     * Optimization possibilities and open issues:\n+     * - Long vs. double schizophrenia.  I suspect it might be better\n+     * to use double throughout.\n+     *\n+     * - Functions that need a new Array call \"new Array\" in the\n+     * current scope rather than using a hardwired constructor;\n+     * \"Array\" could be redefined.  It turns out that js calls the\n+     * equivalent of \"new Array\" in the current scope, except that it\n+     * always gets at least an object back, even when Array == null.\n+     */\n+\n+    private static final Object ARRAY_TAG = \"Array\";\n+    private static final Integer NEGATIVE_ONE = Integer.valueOf(-1);\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeArray obj = new NativeArray(0);\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    static int getMaximumInitialCapacity() {\n+        return maximumInitialCapacity;\n+    }\n+\n+    static void setMaximumInitialCapacity(int maximumInitialCapacity) {\n+        NativeArray.maximumInitialCapacity = maximumInitialCapacity;\n+    }\n+\n+    public NativeArray(long lengthArg)\n+    {\n+        denseOnly = lengthArg <= maximumInitialCapacity;\n+        if (denseOnly) {\n+            int intLength = (int) lengthArg;\n+            if (intLength < DEFAULT_INITIAL_CAPACITY)\n+                intLength = DEFAULT_INITIAL_CAPACITY;\n+            dense = new Object[intLength];\n+            Arrays.fill(dense, Scriptable.NOT_FOUND);\n+        }\n+        length = lengthArg;\n+    }\n+\n+    public NativeArray(Object[] array)\n+    {\n+        denseOnly = true;\n+        dense = array;\n+        length = array.length;\n+    }\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"Array\";\n+    }\n+\n+    private static final int\n+        Id_length        =  1,\n+        MAX_INSTANCE_ID  =  1;\n+\n+    @Override\n+    protected int getMaxInstanceId()\n+    {\n+        return MAX_INSTANCE_ID;\n+    }\n+\n+    @Override\n+    protected int findInstanceIdInfo(String s)\n+    {\n+        if (s.equals(\"length\")) {\n+            return instanceIdInfo(DONTENUM | PERMANENT, Id_length);\n+        }\n+        return super.findInstanceIdInfo(s);\n+    }\n+\n+    @Override\n+    protected String getInstanceIdName(int id)\n+    {\n+        if (id == Id_length) { return \"length\"; }\n+        return super.getInstanceIdName(id);\n+    }\n+\n+    @Override\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        if (id == Id_length) {\n+            return ScriptRuntime.wrapNumber(length);\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+    @Override\n+    protected void setInstanceIdValue(int id, Object value)\n+    {\n+        if (id == Id_length) {\n+            setLength(value); return;\n+        }\n+        super.setInstanceIdValue(id, value);\n+    }\n+\n+    @Override\n+    protected void fillConstructorProperties(IdFunctionObject ctor)\n+    {\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_join,\n+                \"join\", 1);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_reverse,\n+                \"reverse\", 0);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_sort,\n+                \"sort\", 1);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_push,\n+                \"push\", 1);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_pop,\n+                \"pop\", 0);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_shift,\n+                \"shift\", 0);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_unshift,\n+                \"unshift\", 1);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_splice,\n+                \"splice\", 2);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_concat,\n+                \"concat\", 1);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_slice,\n+                \"slice\", 2);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_indexOf,\n+                \"indexOf\", 2);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_lastIndexOf,\n+                \"lastIndexOf\", 2);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_every,\n+                \"every\", 2);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_filter,\n+                \"filter\", 2);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_forEach,\n+                \"forEach\", 2);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_map,\n+                \"map\", 2);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_some,\n+                \"some\", 2);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_reduce,\n+                \"reduce\", 2);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_reduceRight,\n+                \"reduceRight\", 2);\n+        addIdFunctionProperty(ctor, ARRAY_TAG, ConstructorId_isArray,\n+                \"isArray\", 1);\n+        super.fillConstructorProperties(ctor);\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor:    arity=1; s=\"constructor\";    break;\n+          case Id_toString:       arity=0; s=\"toString\";       break;\n+          case Id_toLocaleString: arity=0; s=\"toLocaleString\"; break;\n+          case Id_toSource:       arity=0; s=\"toSource\";       break;\n+          case Id_join:           arity=1; s=\"join\";           break;\n+          case Id_reverse:        arity=0; s=\"reverse\";        break;\n+          case Id_sort:           arity=1; s=\"sort\";           break;\n+          case Id_push:           arity=1; s=\"push\";           break;\n+          case Id_pop:            arity=0; s=\"pop\";            break;\n+          case Id_shift:          arity=0; s=\"shift\";          break;\n+          case Id_unshift:        arity=1; s=\"unshift\";        break;\n+          case Id_splice:         arity=2; s=\"splice\";         break;\n+          case Id_concat:         arity=1; s=\"concat\";         break;\n+          case Id_slice:          arity=2; s=\"slice\";          break;\n+          case Id_indexOf:        arity=2; s=\"indexOf\";        break;\n+          case Id_lastIndexOf:    arity=2; s=\"lastIndexOf\";    break;\n+          case Id_every:          arity=2; s=\"every\";          break;\n+          case Id_filter:         arity=2; s=\"filter\";         break;\n+          case Id_forEach:        arity=2; s=\"forEach\";        break;\n+          case Id_map:            arity=2; s=\"map\";            break;\n+          case Id_some:           arity=2; s=\"some\";           break;\n+          case Id_reduce:         arity=2; s=\"reduce\";         break;\n+          case Id_reduceRight:    arity=2; s=\"reduceRight\";    break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(ARRAY_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(ARRAY_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+      again:\n+        for (;;) {\n+            switch (id) {\n+              case ConstructorId_join:\n+              case ConstructorId_reverse:\n+              case ConstructorId_sort:\n+              case ConstructorId_push:\n+              case ConstructorId_pop:\n+              case ConstructorId_shift:\n+              case ConstructorId_unshift:\n+              case ConstructorId_splice:\n+              case ConstructorId_concat:\n+              case ConstructorId_slice:\n+              case ConstructorId_indexOf:\n+              case ConstructorId_lastIndexOf:\n+              case ConstructorId_every:\n+              case ConstructorId_filter:\n+              case ConstructorId_forEach:\n+              case ConstructorId_map:\n+              case ConstructorId_some:\n+              case ConstructorId_reduce:\n+              case ConstructorId_reduceRight: {\n+                if (args.length > 0) {\n+                    thisObj = ScriptRuntime.toObject(scope, args[0]);\n+                    Object[] newArgs = new Object[args.length-1];\n+                    for (int i=0; i < newArgs.length; i++)\n+                        newArgs[i] = args[i+1];\n+                    args = newArgs;\n+                }\n+                id = -id;\n+                continue again;\n+              }\n+\n+              case ConstructorId_isArray:\n+                return args.length > 0 && (args[0] instanceof NativeArray);\n+\n+              case Id_constructor: {\n+                boolean inNewExpr = (thisObj == null);\n+                if (!inNewExpr) {\n+                    // IdFunctionObject.construct will set up parent, proto\n+                    return f.construct(cx, scope, args);\n+                }\n+                return jsConstructor(cx, scope, args);\n+              }\n+\n+              case Id_toString:\n+                return toStringHelper(cx, scope, thisObj,\n+                    cx.hasFeature(Context.FEATURE_TO_STRING_AS_SOURCE), false);\n+\n+              case Id_toLocaleString:\n+                return toStringHelper(cx, scope, thisObj, false, true);\n+\n+              case Id_toSource:\n+                return toStringHelper(cx, scope, thisObj, true, false);\n+\n+              case Id_join:\n+                return js_join(cx, thisObj, args);\n+\n+              case Id_reverse:\n+                return js_reverse(cx, thisObj, args);\n+\n+              case Id_sort:\n+                return js_sort(cx, scope, thisObj, args);\n+\n+              case Id_push:\n+                return js_push(cx, thisObj, args);\n+\n+              case Id_pop:\n+                return js_pop(cx, thisObj, args);\n+\n+              case Id_shift:\n+                return js_shift(cx, thisObj, args);\n+\n+              case Id_unshift:\n+                return js_unshift(cx, thisObj, args);\n+\n+              case Id_splice:\n+                return js_splice(cx, scope, thisObj, args);\n+\n+              case Id_concat:\n+                return js_concat(cx, scope, thisObj, args);\n+\n+              case Id_slice:\n+                return js_slice(cx, thisObj, args);\n+\n+              case Id_indexOf:\n+                return indexOfHelper(cx, thisObj, args, false);\n+\n+              case Id_lastIndexOf:\n+                return indexOfHelper(cx, thisObj, args, true);\n+\n+              case Id_every:\n+              case Id_filter:\n+              case Id_forEach:\n+              case Id_map:\n+              case Id_some:\n+                return iterativeMethod(cx, id, scope, thisObj, args);\n+              case Id_reduce:\n+              case Id_reduceRight:\n+                return reduceMethod(cx, id, scope, thisObj, args);\n+            }\n+            throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+    }\n+\n+    @Override\n+    public Object get(int index, Scriptable start)\n+    {\n+        if (!denseOnly && isGetterOrSetter(null, index, false))\n+            return super.get(index, start);\n+        if (dense != null && 0 <= index && index < dense.length)\n+            return dense[index];\n+        return super.get(index, start);\n+    }\n+\n+    @Override\n+    public boolean has(int index, Scriptable start)\n+    {\n+        if (!denseOnly && isGetterOrSetter(null, index, false))\n+            return super.has(index, start);\n+        if (dense != null && 0 <= index && index < dense.length)\n+            return dense[index] != NOT_FOUND;\n+        return super.has(index, start);\n+    }\n+\n+    // if id is an array index (ECMA 15.4.0), return the number,\n+    // otherwise return -1L\n+    private static long toArrayIndex(String id)\n+    {\n+        double d = ScriptRuntime.toNumber(id);\n+        if (d == d) {\n+            long index = ScriptRuntime.toUint32(d);\n+            if (index == d && index != 4294967295L) {\n+                // Assume that ScriptRuntime.toString(index) is the same\n+                // as java.lang.Long.toString(index) for long\n+                if (Long.toString(index).equals(id)) {\n+                    return index;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    public void put(String id, Scriptable start, Object value)\n+    {\n+        super.put(id, start, value);\n+        if (start == this) {\n+            // If the object is sealed, super will throw exception\n+            long index = toArrayIndex(id);\n+            if (index >= length) {\n+                length = index + 1;\n+                denseOnly = false;\n+            }\n+        }\n+    }\n+\n+    private boolean ensureCapacity(int capacity)\n+    {\n+        if (capacity > dense.length) {\n+            if (capacity > MAX_PRE_GROW_SIZE) {\n+                denseOnly = false;\n+                return false;\n+            }\n+            capacity = Math.max(capacity, (int)(dense.length * GROW_FACTOR));\n+            Object[] newDense = new Object[capacity];\n+            System.arraycopy(dense, 0, newDense, 0, dense.length);\n+            Arrays.fill(newDense, dense.length, newDense.length,\n+                        Scriptable.NOT_FOUND);\n+            dense = newDense;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void put(int index, Scriptable start, Object value)\n+    {\n+        if (start == this && !isSealed() && dense != null && 0 <= index &&\n+            (denseOnly || !isGetterOrSetter(null, index, true)))\n+        {\n+            if (index < dense.length) {\n+                dense[index] = value;\n+                if (this.length <= index)\n+                    this.length = (long)index + 1;\n+                return;\n+            } else if (denseOnly && index < dense.length * GROW_FACTOR &&\n+                       ensureCapacity(index+1))\n+            {\n+                dense[index] = value;\n+                this.length = (long)index + 1;\n+                return;\n+            } else {\n+                denseOnly = false;\n+            }\n+        }\n+        super.put(index, start, value);\n+        if (start == this) {\n+            // only set the array length if given an array index (ECMA 15.4.0)\n+            if (this.length <= index) {\n+                // avoid overflowing index!\n+                this.length = (long)index + 1;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void delete(int index)\n+    {\n+        if (dense != null && 0 <= index && index < dense.length &&\n+            !isSealed() && (denseOnly || !isGetterOrSetter(null, index, true)))\n+        {\n+            dense[index] = NOT_FOUND;\n+        } else {\n+            super.delete(index);\n+        }\n+    }\n+\n+    @Override\n+    public Object[] getIds()\n+    {\n+        Object[] superIds = super.getIds();\n+        if (dense == null) { return superIds; }\n+        int N = dense.length;\n+        long currentLength = length;\n+        if (N > currentLength) {\n+            N = (int)currentLength;\n+        }\n+        if (N == 0) { return superIds; }\n+        int superLength = superIds.length;\n+        Object[] ids = new Object[N + superLength];\n+\n+        int presentCount = 0;\n+        for (int i = 0; i != N; ++i) {\n+            // Replace existing elements by their indexes\n+            if (dense[i] != NOT_FOUND) {\n+                ids[presentCount] = Integer.valueOf(i);\n+                ++presentCount;\n+            }\n+        }\n+        if (presentCount != N) {\n+            // dense contains deleted elems, need to shrink the result\n+            Object[] tmp = new Object[presentCount + superLength];\n+            System.arraycopy(ids, 0, tmp, 0, presentCount);\n+            ids = tmp;\n+        }\n+        System.arraycopy(superIds, 0, ids, presentCount, superLength);\n+        return ids;\n+    }\n+\n+    @Override\n+    public Object[] getAllIds()\n+    {\n+      Set<Object> allIds = new LinkedHashSet<Object>(\n+            Arrays.asList(this.getIds()));\n+      allIds.addAll(Arrays.asList(super.getAllIds()));\n+      return allIds.toArray();\n+    }\n+\n+    public Integer[] getIndexIds() {\n+      Object[] ids = getIds();\n+      java.util.List<Integer> indices = new java.util.ArrayList<Integer>(ids.length);\n+      for (Object id : ids) {\n+        int int32Id = ScriptRuntime.toInt32(id);\n+        if (int32Id >= 0 && ScriptRuntime.toString(int32Id).equals(ScriptRuntime.toString(id))) {\n+          indices.add(int32Id);\n+        }\n+      }\n+      return indices.toArray(new Integer[indices.size()]);\n+    }\n+\n+    @Override\n+    public Object getDefaultValue(Class<?> hint)\n+    {\n+        if (hint == ScriptRuntime.NumberClass) {\n+            Context cx = Context.getContext();\n+            if (cx.getLanguageVersion() == Context.VERSION_1_2)\n+                return Long.valueOf(length);\n+        }\n+        return super.getDefaultValue(hint);\n+    }\n+\n+    private ScriptableObject defaultIndexPropertyDescriptor(Object value) {\n+      Scriptable scope = getParentScope();\n+      if (scope == null) scope = this;\n+      ScriptableObject desc = new NativeObject();\n+      ScriptRuntime.setObjectProtoAndParent(desc, scope);\n+      desc.defineProperty(\"value\", value, EMPTY);\n+      desc.defineProperty(\"writable\", true, EMPTY);\n+      desc.defineProperty(\"enumerable\", true, EMPTY);\n+      desc.defineProperty(\"configurable\", true, EMPTY);\n+      return desc;\n+    }\n+\n+    @Override\n+    protected ScriptableObject getOwnPropertyDescriptor(Context cx, Object id) {\n+      if (dense != null) {\n+        int index = toIndex(id);\n+        if (0 <= index && index < length) {\n+          Object value = dense[index];\n+          return defaultIndexPropertyDescriptor(value);\n+        }\n+      }\n+      return super.getOwnPropertyDescriptor(cx, id);\n+    }\n+\n+    @Override\n+    public void defineOwnProperty(Context cx, Object id, ScriptableObject desc) {\n+      if (dense != null) {\n+        Object[] values = dense;\n+        dense = null;\n+        denseOnly = false;\n+        for (int i = 0; i < values.length; i++) {\n+          if (values[i] != NOT_FOUND) {\n+            put(i, this, values[i]);\n+          }\n+        }\n+      }\n+      int index = toIndex(id);\n+      if (index >= length) {\n+        length = index + 1;\n+      }\n+      super.defineOwnProperty(cx, id, desc);\n+    }\n+\n+    private int toIndex(Object id) {\n+      if (id instanceof String) {\n+        return (int) toArrayIndex((String) id);\n+      } else if (id instanceof Number) {\n+        return ((Number) id).intValue();\n+      } else {\n+        return -1;\n+      }\n+    }\n+\n+    /**\n+     * See ECMA 15.4.1,2\n+     */\n+    private static Object jsConstructor(Context cx, Scriptable scope,\n+                                        Object[] args)\n+    {\n+        if (args.length == 0)\n+            return new NativeArray(0);\n+\n+        // Only use 1 arg as first element for version 1.2; for\n+        // any other version (including 1.3) follow ECMA and use it as\n+        // a length.\n+        if (cx.getLanguageVersion() == Context.VERSION_1_2) {\n+            return new NativeArray(args);\n+        } else {\n+            Object arg0 = args[0];\n+            if (args.length > 1 || !(arg0 instanceof Number)) {\n+                return new NativeArray(args);\n+            } else {\n+                long len = ScriptRuntime.toUint32(arg0);\n+                if (len != ((Number)arg0).doubleValue())\n+                    throw Context.reportRuntimeError0(\"msg.arraylength.bad\");\n+                return new NativeArray(len);\n+            }\n+        }\n+    }\n+\n+    public long getLength() {\n+        return length;\n+    }\n+\n+    /** @deprecated Use {@link #getLength()} instead. */\n+    public long jsGet_length() {\n+        return getLength();\n+    }\n+\n+    /**\n+     * Change the value of the internal flag that determines whether all\n+     * storage is handed by a dense backing array rather than an associative\n+     * store.\n+     * @param denseOnly new value for denseOnly flag\n+     * @throws IllegalArgumentException if an attempt is made to enable\n+     *   denseOnly after it was disabled; NativeArray code is not written\n+     *   to handle switching back to a dense representation\n+     */\n+    void setDenseOnly(boolean denseOnly) {\n+        if (denseOnly && !this.denseOnly)\n+            throw new IllegalArgumentException();\n+        this.denseOnly = denseOnly;\n+    }\n+\n+    private void setLength(Object val) {\n+        /* XXX do we satisfy this?\n+         * 15.4.5.1 [[Put]](P, V):\n+         * 1. Call the [[CanPut]] method of A with name P.\n+         * 2. If Result(1) is false, return.\n+         * ?\n+         */\n+\n+        double d = ScriptRuntime.toNumber(val);\n+        long longVal = ScriptRuntime.toUint32(d);\n+        if (longVal != d)\n+            throw Context.reportRuntimeError0(\"msg.arraylength.bad\");\n+\n+        if (denseOnly) {\n+            if (longVal < length) {\n+                // downcast okay because denseOnly\n+                Arrays.fill(dense, (int) longVal, dense.length, NOT_FOUND);\n+                length = longVal;\n+                return;\n+            } else if (longVal < MAX_PRE_GROW_SIZE &&\n+                       longVal < (length * GROW_FACTOR) &&\n+                       ensureCapacity((int)longVal))\n+            {\n+                length = longVal;\n+                return;\n+            } else {\n+                denseOnly = false;\n+            }\n+        }\n+        if (longVal < length) {\n+            // remove all properties between longVal and length\n+            if (length - longVal > 0x1000) {\n+                // assume that the representation is sparse\n+                Object[] e = getIds(); // will only find in object itself\n+                for (int i=0; i < e.length; i++) {\n+                    Object id = e[i];\n+                    if (id instanceof String) {\n+                        // > MAXINT will appear as string\n+                        String strId = (String)id;\n+                        long index = toArrayIndex(strId);\n+                        if (index >= longVal)\n+                            delete(strId);\n+                    } else {\n+                        int index = ((Integer)id).intValue();\n+                        if (index >= longVal)\n+                            delete(index);\n+                    }\n+                }\n+            } else {\n+                // assume a dense representation\n+                for (long i = longVal; i < length; i++) {\n+                    deleteElem(this, i);\n+                }\n+            }\n+        }\n+        length = longVal;\n+    }\n+\n+    /* Support for generic Array-ish objects.  Most of the Array\n+     * functions try to be generic; anything that has a length\n+     * property is assumed to be an array.\n+     * getLengthProperty returns 0 if obj does not have the length property\n+     * or its value is not convertible to a number.\n+     */\n+    static long getLengthProperty(Context cx, Scriptable obj) {\n+        // These will both give numeric lengths within Uint32 range.\n+        if (obj instanceof NativeString) {\n+            return ((NativeString)obj).getLength();\n+        } else if (obj instanceof NativeArray) {\n+            return ((NativeArray)obj).getLength();\n+        }\n+        return ScriptRuntime.toUint32(\n+            ScriptRuntime.getObjectProp(obj, \"length\", cx));\n+    }\n+\n+    private static Object setLengthProperty(Context cx, Scriptable target,\n+                                            long length)\n+    {\n+        return ScriptRuntime.setObjectProp(\n+                   target, \"length\", ScriptRuntime.wrapNumber(length), cx);\n+    }\n+\n+    /* Utility functions to encapsulate index > Integer.MAX_VALUE\n+     * handling.  Also avoids unnecessary object creation that would\n+     * be necessary to use the general ScriptRuntime.get/setElem\n+     * functions... though this is probably premature optimization.\n+     */\n+    private static void deleteElem(Scriptable target, long index) {\n+        int i = (int)index;\n+        if (i == index) { target.delete(i); }\n+        else { target.delete(Long.toString(index)); }\n+    }\n+\n+    private static Object getElem(Context cx, Scriptable target, long index)\n+    {\n+        if (index > Integer.MAX_VALUE) {\n+            String id = Long.toString(index);\n+            return ScriptRuntime.getObjectProp(target, id, cx);\n+        } else {\n+            return ScriptRuntime.getObjectIndex(target, (int)index, cx);\n+        }\n+    }\n+\n+    // same as getElem, but without converting NOT_FOUND to undefined\n+    private static Object getRawElem(Scriptable target, long index) {\n+        if (index > Integer.MAX_VALUE) {\n+            return ScriptableObject.getProperty(target, Long.toString(index));\n+        } else {\n+            return ScriptableObject.getProperty(target, (int) index);\n+        }\n+    }\n+\n+    private static void setElem(Context cx, Scriptable target, long index,\n+                                Object value)\n+    {\n+        if (index > Integer.MAX_VALUE) {\n+            String id = Long.toString(index);\n+            ScriptRuntime.setObjectProp(target, id, value, cx);\n+        } else {\n+            ScriptRuntime.setObjectIndex(target, (int)index, value, cx);\n+        }\n+    }\n+\n+    private static String toStringHelper(Context cx, Scriptable scope,\n+                                         Scriptable thisObj,\n+                                         boolean toSource, boolean toLocale)\n+    {\n+        /* It's probably redundant to handle long lengths in this\n+         * function; StringBuilders are limited to 2^31 in java.\n+         */\n+\n+        long length = getLengthProperty(cx, thisObj);\n+\n+        StringBuilder result = new StringBuilder(256);\n+\n+        // whether to return '4,unquoted,5' or '[4, \"quoted\", 5]'\n+        String separator;\n+\n+        if (toSource) {\n+            result.append('[');\n+            separator = \", \";\n+        } else {\n+            separator = \",\";\n+        }\n+\n+        boolean haslast = false;\n+        long i = 0;\n+\n+        boolean toplevel, iterating;\n+        if (cx.iterating == null) {\n+            toplevel = true;\n+            iterating = false;\n+            cx.iterating = new ObjToIntMap(31);\n+        } else {\n+            toplevel = false;\n+            iterating = cx.iterating.has(thisObj);\n+        }\n+\n+        // Make sure cx.iterating is set to null when done\n+        // so we don't leak memory\n+        try {\n+            if (!iterating) {\n+                cx.iterating.put(thisObj, 0); // stop recursion.\n+                for (i = 0; i < length; i++) {\n+                    if (i > 0) result.append(separator);\n+                    Object elem = getElem(cx, thisObj, i);\n+                    if (elem == null || elem == Undefined.instance) {\n+                        haslast = false;\n+                        continue;\n+                    }\n+                    haslast = true;\n+\n+                    if (toSource) {\n+                        result.append(ScriptRuntime.uneval(cx, scope, elem));\n+\n+                    } else if (elem instanceof String) {\n+                        String s = (String)elem;\n+                        if (toSource) {\n+                            result.append('\\\"');\n+                            result.append(ScriptRuntime.escapeString(s));\n+                            result.append('\\\"');\n+                        } else {\n+                            result.append(s);\n+                        }\n+\n+                    } else {\n+                        if (toLocale)\n+                        {\n+                            Callable fun;\n+                            Scriptable funThis;\n+                            fun = ScriptRuntime.getPropFunctionAndThis(\n+                                      elem, \"toLocaleString\", cx);\n+                            funThis = ScriptRuntime.lastStoredScriptable(cx);\n+                            elem = fun.call(cx, scope, funThis,\n+                                            ScriptRuntime.emptyArgs);\n+                        }\n+                        result.append(ScriptRuntime.toString(elem));\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (toplevel) {\n+                cx.iterating = null;\n+            }\n+        }\n+\n+        if (toSource) {\n+            //for [,,].length behavior; we want toString to be symmetric.\n+            if (!haslast && i > 0)\n+                result.append(\", ]\");\n+            else\n+                result.append(']');\n+        }\n+        return result.toString();\n+    }\n+\n+    /**\n+     * See ECMA 15.4.4.3\n+     */\n+    private static String js_join(Context cx, Scriptable thisObj,\n+                                  Object[] args)\n+    {\n+        long llength = getLengthProperty(cx, thisObj);\n+        int length = (int)llength;\n+        if (llength != length) {\n+            throw Context.reportRuntimeError1(\n+                \"msg.arraylength.too.big\", String.valueOf(llength));\n+        }\n+        // if no args, use \",\" as separator\n+        String separator = (args.length < 1 || args[0] == Undefined.instance)\n+                           ? \",\"\n+                           : ScriptRuntime.toString(args[0]);\n+        if (thisObj instanceof NativeArray) {\n+            NativeArray na = (NativeArray) thisObj;\n+            if (na.denseOnly) {\n+                StringBuilder sb = new StringBuilder();\n+                for (int i = 0; i < length; i++) {\n+                    if (i != 0) {\n+                        sb.append(separator);\n+                    }\n+                    if (i < na.dense.length) {\n+                        Object temp = na.dense[i];\n+                        if (temp != null && temp != Undefined.instance &&\n+                            temp != Scriptable.NOT_FOUND)\n+                        {\n+                            sb.append(ScriptRuntime.toString(temp));\n+                        }\n+                    }\n+                }\n+                return sb.toString();\n+            }\n+        }\n+        if (length == 0) {\n+            return \"\";\n+        }\n+        String[] buf = new String[length];\n+        int total_size = 0;\n+        for (int i = 0; i != length; i++) {\n+            Object temp = getElem(cx, thisObj, i);\n+            if (temp != null && temp != Undefined.instance) {\n+                String str = ScriptRuntime.toString(temp);\n+                total_size += str.length();\n+                buf[i] = str;\n+            }\n+        }\n+        total_size += (length - 1) * separator.length();\n+        StringBuilder sb = new StringBuilder(total_size);\n+        for (int i = 0; i != length; i++) {\n+            if (i != 0) {\n+                sb.append(separator);\n+            }\n+            String str = buf[i];\n+            if (str != null) {\n+                // str == null for undefined or null\n+                sb.append(str);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * See ECMA 15.4.4.4\n+     */\n+    private static Scriptable js_reverse(Context cx, Scriptable thisObj,\n+                                         Object[] args)\n+    {\n+        if (thisObj instanceof NativeArray) {\n+            NativeArray na = (NativeArray) thisObj;\n+            if (na.denseOnly) {\n+                for (int i=0, j=((int)na.length)-1; i < j; i++,j--) {\n+                    Object temp = na.dense[i];\n+                    na.dense[i] = na.dense[j];\n+                    na.dense[j] = temp;\n+                }\n+                return thisObj;\n+            }\n+        }\n+        long len = getLengthProperty(cx, thisObj);\n+\n+        long half = len / 2;\n+        for(long i=0; i < half; i++) {\n+            long j = len - i - 1;\n+            Object temp1 = getElem(cx, thisObj, i);\n+            Object temp2 = getElem(cx, thisObj, j);\n+            setElem(cx, thisObj, i, temp2);\n+            setElem(cx, thisObj, j, temp1);\n+        }\n+        return thisObj;\n+    }\n+\n+    /**\n+     * See ECMA 15.4.4.5\n+     */\n+    private static Scriptable js_sort(final Context cx, final Scriptable scope,\n+            final Scriptable thisObj, final Object[] args)\n+    {\n+        final Comparator<Object> comparator;\n+        if (args.length > 0 && Undefined.instance != args[0]) {\n+            final Callable jsCompareFunction = ScriptRuntime\n+                    .getValueFunctionAndThis(args[0], cx);\n+            final Scriptable funThis = ScriptRuntime.lastStoredScriptable(cx);\n+            final Object[] cmpBuf = new Object[2]; // Buffer for cmp arguments\n+            comparator = new Comparator<Object>() {\n+                public int compare(final Object x, final Object y) {\n+                    // sort undefined to end\n+                    if (x == y) {\n+                        return 0;\n+                    } else if (y == Undefined.instance\n+                            || y == Scriptable.NOT_FOUND) {\n+                        return -1;\n+                    } else if (x == Undefined.instance\n+                            || x == Scriptable.NOT_FOUND) {\n+                        return 1;\n+                    }\n+\n+                    cmpBuf[0] = x;\n+                    cmpBuf[1] = y;\n+                    Object ret = jsCompareFunction.call(cx, scope, funThis,\n+                            cmpBuf);\n+                    final double d = ScriptRuntime.toNumber(ret);\n+                    if (d < 0) {\n+                        return -1;\n+                    } else if (d > 0) {\n+                        return +1;\n+                    }\n+                    return 0; // ??? double and 0???\n+                }\n+            };\n+        } else {\n+            comparator = new Comparator<Object>() {\n+                public int compare(final Object x, final Object y) {\n+                    // sort undefined to end\n+                    if (x == y)\n+                        return 0;\n+                    else if (y == Undefined.instance\n+                            || y == Scriptable.NOT_FOUND) {\n+                        return -1;\n+                    } else if (x == Undefined.instance\n+                            || x == Scriptable.NOT_FOUND) {\n+                        return 1;\n+                    }\n+\n+                    final String a = ScriptRuntime.toString(x);\n+                    final String b = ScriptRuntime.toString(y);\n+                    return a.compareTo(b);\n+                }\n+            };\n+        }\n+\n+        final int length = (int) getLengthProperty(cx, thisObj);\n+        // copy the JS array into a working array, so it can be\n+        // sorted cheaply.\n+        final Object[] working = new Object[length];\n+        for (int i = 0; i != length; ++i) {\n+            working[i] = getElem(cx, thisObj, i);\n+        }\n+\n+        Arrays.sort(working, comparator);\n+\n+        // copy the working array back into thisObj\n+        for (int i = 0; i < length; ++i) {\n+            setElem(cx, thisObj, i, working[i]);\n+        }\n+\n+        return thisObj;\n+    }\n+\n+    /**\n+     * Non-ECMA methods.\n+     */\n+\n+    private static Object js_push(Context cx, Scriptable thisObj,\n+                                  Object[] args)\n+    {\n+        if (thisObj instanceof NativeArray) {\n+            NativeArray na = (NativeArray) thisObj;\n+            if (na.denseOnly &&\n+                na.ensureCapacity((int) na.length + args.length))\n+            {\n+                for (int i = 0; i < args.length; i++) {\n+                    na.dense[(int)na.length++] = args[i];\n+                }\n+                return ScriptRuntime.wrapNumber(na.length);\n+            }\n+        }\n+        long length = getLengthProperty(cx, thisObj);\n+        for (int i = 0; i < args.length; i++) {\n+            setElem(cx, thisObj, length + i, args[i]);\n+        }\n+\n+        length += args.length;\n+        Object lengthObj = setLengthProperty(cx, thisObj, length);\n+\n+        /*\n+         * If JS1.2, follow Perl4 by returning the last thing pushed.\n+         * Otherwise, return the new array length.\n+         */\n+        if (cx.getLanguageVersion() == Context.VERSION_1_2)\n+            // if JS1.2 && no arguments, return undefined.\n+            return args.length == 0\n+                ? Undefined.instance\n+                : args[args.length - 1];\n+\n+        else\n+            return lengthObj;\n+    }\n+\n+    private static Object js_pop(Context cx, Scriptable thisObj,\n+                                 Object[] args)\n+    {\n+        Object result;\n+        if (thisObj instanceof NativeArray) {\n+            NativeArray na = (NativeArray) thisObj;\n+            if (na.denseOnly && na.length > 0) {\n+                na.length--;\n+                result = na.dense[(int)na.length];\n+                na.dense[(int)na.length] = NOT_FOUND;\n+                return result;\n+            }\n+        }\n+        long length = getLengthProperty(cx, thisObj);\n+        if (length > 0) {\n+            length--;\n+\n+            // Get the to-be-deleted property's value.\n+            result = getElem(cx, thisObj, length);\n+\n+            // We don't need to delete the last property, because\n+            // setLength does that for us.\n+        } else {\n+            result = Undefined.instance;\n+        }\n+        // necessary to match js even when length < 0; js pop will give a\n+        // length property to any target it is called on.\n+        setLengthProperty(cx, thisObj, length);\n+\n+        return result;\n+    }\n+\n+    private static Object js_shift(Context cx, Scriptable thisObj,\n+                                   Object[] args)\n+    {\n+        if (thisObj instanceof NativeArray) {\n+            NativeArray na = (NativeArray) thisObj;\n+            if (na.denseOnly && na.length > 0) {\n+                na.length--;\n+                Object result = na.dense[0];\n+                System.arraycopy(na.dense, 1, na.dense, 0, (int)na.length);\n+                na.dense[(int)na.length] = NOT_FOUND;\n+                return result;\n+            }\n+        }\n+        Object result;\n+        long length = getLengthProperty(cx, thisObj);\n+        if (length > 0) {\n+            long i = 0;\n+            length--;\n+\n+            // Get the to-be-deleted property's value.\n+            result = getElem(cx, thisObj, i);\n+\n+            /*\n+             * Slide down the array above the first element.  Leave i\n+             * set to point to the last element.\n+             */\n+            if (length > 0) {\n+                for (i = 1; i <= length; i++) {\n+                    Object temp = getElem(cx, thisObj, i);\n+                    setElem(cx, thisObj, i - 1, temp);\n+                }\n+            }\n+            // We don't need to delete the last property, because\n+            // setLength does that for us.\n+        } else {\n+            result = Undefined.instance;\n+        }\n+        setLengthProperty(cx, thisObj, length);\n+        return result;\n+    }\n+\n+    private static Object js_unshift(Context cx, Scriptable thisObj,\n+                                     Object[] args)\n+    {\n+        if (thisObj instanceof NativeArray) {\n+            NativeArray na = (NativeArray) thisObj;\n+            if (na.denseOnly &&\n+                na.ensureCapacity((int)na.length + args.length))\n+            {\n+                System.arraycopy(na.dense, 0, na.dense, args.length,\n+                                 (int) na.length);\n+                for (int i = 0; i < args.length; i++) {\n+                    na.dense[i] = args[i];\n+                }\n+                na.length += args.length;\n+                return ScriptRuntime.wrapNumber(na.length);\n+            }\n+        }\n+        long length = getLengthProperty(cx, thisObj);\n+        int argc = args.length;\n+\n+        if (args.length > 0) {\n+            /*  Slide up the array to make room for args at the bottom */\n+            if (length > 0) {\n+                for (long last = length - 1; last >= 0; last--) {\n+                    Object temp = getElem(cx, thisObj, last);\n+                    setElem(cx, thisObj, last + argc, temp);\n+                }\n+            }\n+\n+            /* Copy from argv to the bottom of the array. */\n+            for (int i = 0; i < args.length; i++) {\n+                setElem(cx, thisObj, i, args[i]);\n+            }\n+\n+            /* Follow Perl by returning the new array length. */\n+            length += args.length;\n+            return setLengthProperty(cx, thisObj, length);\n+        }\n+        return ScriptRuntime.wrapNumber(length);\n+    }\n+\n+    private static Object js_splice(Context cx, Scriptable scope,\n+                                    Scriptable thisObj, Object[] args)\n+    {\n+    \tNativeArray na = null;\n+    \tboolean denseMode = false;\n+        if (thisObj instanceof NativeArray) {\n+            na = (NativeArray) thisObj;\n+            denseMode = na.denseOnly;\n+        }\n+\n+        /* create an empty Array to return. */\n+        scope = getTopLevelScope(scope);\n+        int argc = args.length;\n+        if (argc == 0)\n+            return ScriptRuntime.newObject(cx, scope, \"Array\", null);\n+        long length = getLengthProperty(cx, thisObj);\n+\n+        /* Convert the first argument into a starting index. */\n+        long begin = toSliceIndex(ScriptRuntime.toInteger(args[0]), length);\n+        argc--;\n+\n+        /* Convert the second argument into count */\n+        long count;\n+        if (args.length == 1) {\n+            count = length - begin;\n+        } else {\n+            double dcount = ScriptRuntime.toInteger(args[1]);\n+            if (dcount < 0) {\n+                count = 0;\n+            } else if (dcount > (length - begin)) {\n+                count = length - begin;\n+            } else {\n+                count = (long)dcount;\n+            }\n+            argc--;\n+        }\n+\n+        long end = begin + count;\n+\n+        /* If there are elements to remove, put them into the return value. */\n+        Object result;\n+        if (count != 0) {\n+            if (count == 1\n+                && (cx.getLanguageVersion() == Context.VERSION_1_2))\n+            {\n+                /*\n+                 * JS lacks \"list context\", whereby in Perl one turns the\n+                 * single scalar that's spliced out into an array just by\n+                 * assigning it to @single instead of $single, or by using it\n+                 * as Perl push's first argument, for instance.\n+                 *\n+                 * JS1.2 emulated Perl too closely and returned a non-Array for\n+                 * the single-splice-out case, requiring callers to test and\n+                 * wrap in [] if necessary.  So JS1.3, default, and other\n+                 * versions all return an array of length 1 for uniformity.\n+                 */\n+                result = getElem(cx, thisObj, begin);\n+            } else {\n+            \tif (denseMode) {\n+                    int intLen = (int) (end - begin);\n+                    Object[] copy = new Object[intLen];\n+                    System.arraycopy(na.dense, (int) begin, copy, 0, intLen);\n+                    result = cx.newArray(scope, copy);\n+            \t} else {\n+            \t\tScriptable resultArray = ScriptRuntime.newObject(cx, scope,\n+                        \"Array\", null);\n+                    for (long last = begin; last != end; last++) {\n+                        Object temp = getElem(cx, thisObj, last);\n+                        setElem(cx, resultArray, last - begin, temp);\n+                    }\n+                    result = resultArray;\n+            \t}\n+            }\n+        } else { // (count == 0)\n+        \tif (cx.getLanguageVersion() == Context.VERSION_1_2) {\n+                /* Emulate C JS1.2; if no elements are removed, return undefined. */\n+                result = Undefined.instance;\n+            } else {\n+            \tresult = ScriptRuntime.newObject(cx, scope, \"Array\", null);\n+        \t}\n+        }\n+\n+        /* Find the direction (up or down) to copy and make way for argv. */\n+        long delta = argc - count;\n+        if (denseMode && length + delta < Integer.MAX_VALUE &&\n+            na.ensureCapacity((int) (length + delta)))\n+        {\n+            System.arraycopy(na.dense, (int) end, na.dense,\n+                             (int) (begin + argc), (int) (length - end));\n+            if (argc > 0) {\n+                System.arraycopy(args, 2, na.dense, (int) begin, argc);\n+            }\n+            if (delta < 0) {\n+                Arrays.fill(na.dense, (int) (length + delta), (int) length,\n+                            NOT_FOUND);\n+            }\n+            na.length = length + delta;\n+            return result;\n+        }\n+\n+        if (delta > 0) {\n+            for (long last = length - 1; last >= end; last--) {\n+                Object temp = getElem(cx, thisObj, last);\n+                setElem(cx, thisObj, last + delta, temp);\n+            }\n+        } else if (delta < 0) {\n+            for (long last = end; last < length; last++) {\n+                Object temp = getElem(cx, thisObj, last);\n+                setElem(cx, thisObj, last + delta, temp);\n+            }\n+        }\n+\n+        /* Copy from argv into the hole to complete the splice. */\n+        int argoffset = args.length - argc;\n+        for (int i = 0; i < argc; i++) {\n+            setElem(cx, thisObj, begin + i, args[i + argoffset]);\n+        }\n+\n+        /* Update length in case we deleted elements from the end. */\n+        setLengthProperty(cx, thisObj, length + delta);\n+        return result;\n+    }\n+\n+    /*\n+     * See Ecma 262v3 15.4.4.4\n+     */\n+    private static Scriptable js_concat(Context cx, Scriptable scope,\n+                                        Scriptable thisObj, Object[] args)\n+    {\n+        // create an empty Array to return.\n+        scope = getTopLevelScope(scope);\n+        Function ctor = ScriptRuntime.getExistingCtor(cx, scope, \"Array\");\n+        Scriptable result = ctor.construct(cx, scope, ScriptRuntime.emptyArgs);\n+        if (thisObj instanceof NativeArray && result instanceof NativeArray) {\n+            NativeArray denseThis = (NativeArray) thisObj;\n+            NativeArray denseResult = (NativeArray) result;\n+            if (denseThis.denseOnly && denseResult.denseOnly) {\n+                // First calculate length of resulting array\n+                boolean canUseDense = true;\n+                int length = (int) denseThis.length;\n+                for (int i = 0; i < args.length && canUseDense; i++) {\n+                    if (args[i] instanceof NativeArray) {\n+                        // only try to use dense approach for Array-like\n+                        // objects that are actually NativeArrays\n+                        final NativeArray arg = (NativeArray) args[i];\n+                        canUseDense = arg.denseOnly;\n+                        length += arg.length;\n+                    } else {\n+                        length++;\n+                    }\n+                }\n+                if (canUseDense && denseResult.ensureCapacity(length)) {\n+                    System.arraycopy(denseThis.dense, 0, denseResult.dense,\n+                                     0, (int) denseThis.length);\n+                    int cursor = (int) denseThis.length;\n+                    for (int i = 0; i < args.length && canUseDense; i++) {\n+                        if (args[i] instanceof NativeArray) {\n+                            NativeArray arg = (NativeArray) args[i];\n+                            System.arraycopy(arg.dense, 0,\n+                                    denseResult.dense, cursor,\n+                                    (int)arg.length);\n+                            cursor += (int)arg.length;\n+                        } else {\n+                            denseResult.dense[cursor++] = args[i];\n+                        }\n+                    }\n+                    denseResult.length = length;\n+                    return result;\n+                }\n+            }\n+        }\n+\n+        long length;\n+        long slot = 0;\n+\n+        /* Put the target in the result array; only add it as an array\n+         * if it looks like one.\n+         */\n+        if (ScriptRuntime.instanceOf(thisObj, ctor, cx)) {\n+            length = getLengthProperty(cx, thisObj);\n+\n+            // Copy from the target object into the result\n+            for (slot = 0; slot < length; slot++) {\n+                Object temp = getElem(cx, thisObj, slot);\n+                setElem(cx, result, slot, temp);\n+            }\n+        } else {\n+            setElem(cx, result, slot++, thisObj);\n+        }\n+\n+        /* Copy from the arguments into the result.  If any argument\n+         * has a numeric length property, treat it as an array and add\n+         * elements separately; otherwise, just copy the argument.\n+         */\n+        for (int i = 0; i < args.length; i++) {\n+            if (ScriptRuntime.instanceOf(args[i], ctor, cx)) {\n+                // ScriptRuntime.instanceOf => instanceof Scriptable\n+                Scriptable arg = (Scriptable)args[i];\n+                length = getLengthProperty(cx, arg);\n+                for (long j = 0; j < length; j++, slot++) {\n+                    Object temp = getElem(cx, arg, j);\n+                    setElem(cx, result, slot, temp);\n+                }\n+            } else {\n+                setElem(cx, result, slot++, args[i]);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private Scriptable js_slice(Context cx, Scriptable thisObj,\n+                                Object[] args)\n+    {\n+        Scriptable scope = getTopLevelScope(this);\n+        Scriptable result = ScriptRuntime.newObject(cx, scope, \"Array\", null);\n+        long length = getLengthProperty(cx, thisObj);\n+\n+        long begin, end;\n+        if (args.length == 0) {\n+            begin = 0;\n+            end = length;\n+        } else {\n+            begin = toSliceIndex(ScriptRuntime.toInteger(args[0]), length);\n+            if (args.length == 1) {\n+                end = length;\n+            } else {\n+                end = toSliceIndex(ScriptRuntime.toInteger(args[1]), length);\n+            }\n+        }\n+\n+        for (long slot = begin; slot < end; slot++) {\n+            Object temp = getElem(cx, thisObj, slot);\n+            setElem(cx, result, slot - begin, temp);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static long toSliceIndex(double value, long length) {\n+        long result;\n+        if (value < 0.0) {\n+            if (value + length < 0.0) {\n+                result = 0;\n+            } else {\n+                result = (long)(value + length);\n+            }\n+        } else if (value > length) {\n+            result = length;\n+        } else {\n+            result = (long)value;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Implements the methods \"indexOf\" and \"lastIndexOf\".\n+     */\n+    private Object indexOfHelper(Context cx, Scriptable thisObj,\n+                                 Object[] args, boolean isLast)\n+    {\n+        Object compareTo = args.length > 0 ? args[0] : Undefined.instance;\n+        long length = getLengthProperty(cx, thisObj);\n+        long start;\n+        if (isLast) {\n+            // lastIndexOf\n+            /*\n+             * From http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Objects:Array:lastIndexOf\n+             * The index at which to start searching backwards. Defaults to the\n+             * array's length, i.e. the whole array will be searched. If the\n+             * index is greater than or equal to the length of the array, the\n+             * whole array will be searched. If negative, it is taken as the\n+             * offset from the end of the array. Note that even when the index\n+             * is negative, the array is still searched from back to front. If\n+             * the calculated index is less than 0, -1 is returned, i.e. the\n+             * array will not be searched.\n+             */\n+            if (args.length < 2) {\n+                // default\n+                start = length-1;\n+            } else {\n+                start = ScriptRuntime.toInt32(ScriptRuntime.toNumber(args[1]));\n+                if (start >= length)\n+                    start = length-1;\n+                else if (start < 0)\n+                    start += length;\n+                // Note that start may be negative, but that's okay\n+                // as the result of -1 will fall out from the code below\n+            }\n+        } else {\n+            // indexOf\n+            /*\n+             * From http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Objects:Array:indexOf\n+             * The index at which to begin the search. Defaults to 0, i.e. the\n+             * whole array will be searched. If the index is greater than or\n+             * equal to the length of the array, -1 is returned, i.e. the array\n+             * will not be searched. If negative, it is taken as the offset from\n+             * the end of the array. Note that even when the index is negative,\n+             * the array is still searched from front to back. If the calculated\n+             * index is less than 0, the whole array will be searched.\n+             */\n+            if (args.length < 2) {\n+                // default\n+                start = 0;\n+            } else {\n+                start = ScriptRuntime.toInt32(ScriptRuntime.toNumber(args[1]));\n+                if (start < 0) {\n+                    start += length;\n+                    if (start < 0)\n+                        start = 0;\n+                }\n+                // Note that start may be > length-1, but that's okay\n+                // as the result of -1 will fall out from the code below\n+            }\n+        }\n+        if (thisObj instanceof NativeArray) {\n+            NativeArray na = (NativeArray) thisObj;\n+            if (na.denseOnly) {\n+                if (isLast) {\n+                  for (int i=(int)start; i >= 0; i--) {\n+                      if (na.dense[i] != Scriptable.NOT_FOUND &&\n+                          ScriptRuntime.shallowEq(na.dense[i], compareTo))\n+                      {\n+                          return Long.valueOf(i);\n+                      }\n+                  }\n+                } else {\n+                  for (int i=(int)start; i < length; i++) {\n+                      if (na.dense[i] != Scriptable.NOT_FOUND &&\n+                          ScriptRuntime.shallowEq(na.dense[i], compareTo))\n+                      {\n+                          return Long.valueOf(i);\n+                      }\n+                  }\n+                }\n+                return NEGATIVE_ONE;\n+            }\n+        }\n+        if (isLast) {\n+          for (long i=start; i >= 0; i--) {\n+              if (ScriptRuntime.shallowEq(getElem(cx, thisObj, i), compareTo)) {\n+                  return new Long(i);\n+              }\n+          }\n+        } else {\n+          for (long i=start; i < length; i++) {\n+              if (ScriptRuntime.shallowEq(getElem(cx, thisObj, i), compareTo)) {\n+                  return new Long(i);\n+              }\n+          }\n+        }\n+        return NEGATIVE_ONE;\n+    }\n+\n+    /**\n+     * Implements the methods \"every\", \"filter\", \"forEach\", \"map\", and \"some\".\n+     */\n+    private Object iterativeMethod(Context cx, int id, Scriptable scope,\n+                                   Scriptable thisObj, Object[] args)\n+    {\n+        Object callbackArg = args.length > 0 ? args[0] : Undefined.instance;\n+        if (callbackArg == null || !(callbackArg instanceof Function)) {\n+            throw ScriptRuntime.notFunctionError(callbackArg);\n+        }\n+        Function f = (Function) callbackArg;\n+        Scriptable parent = ScriptableObject.getTopLevelScope(f);\n+        Scriptable thisArg;\n+        if (args.length < 2 || args[1] == null || args[1] == Undefined.instance)\n+        {\n+            thisArg = parent;\n+        } else {\n+            thisArg = ScriptRuntime.toObject(cx, scope, args[1]);\n+        }\n+        long length = getLengthProperty(cx, thisObj);\n+        Scriptable array = ScriptRuntime.newObject(cx, scope, \"Array\", null);\n+        long j=0;\n+        for (long i=0; i < length; i++) {\n+            Object[] innerArgs = new Object[3];\n+            Object elem = getRawElem(thisObj, i);\n+            if (elem == Scriptable.NOT_FOUND) {\n+                continue;\n+            }\n+            innerArgs[0] = elem;\n+            innerArgs[1] = Long.valueOf(i);\n+            innerArgs[2] = thisObj;\n+            Object result = f.call(cx, parent, thisArg, innerArgs);\n+            switch (id) {\n+              case Id_every:\n+                if (!ScriptRuntime.toBoolean(result))\n+                    return Boolean.FALSE;\n+                break;\n+              case Id_filter:\n+                if (ScriptRuntime.toBoolean(result))\n+                  setElem(cx, array, j++, innerArgs[0]);\n+                break;\n+              case Id_forEach:\n+                break;\n+              case Id_map:\n+                setElem(cx, array, i, result);\n+                break;\n+              case Id_some:\n+                if (ScriptRuntime.toBoolean(result))\n+                    return Boolean.TRUE;\n+                break;\n+            }\n+        }\n+        switch (id) {\n+          case Id_every:\n+            return Boolean.TRUE;\n+          case Id_filter:\n+          case Id_map:\n+            return array;\n+          case Id_some:\n+            return Boolean.FALSE;\n+          case Id_forEach:\n+          default:\n+            return Undefined.instance;\n+        }\n+    }\n+\n+    /**\n+     * Implements the methods \"reduce\" and \"reduceRight\".\n+     */\n+    private Object reduceMethod(Context cx, int id, Scriptable scope,\n+                                   Scriptable thisObj, Object[] args)\n+    {\n+        Object callbackArg = args.length > 0 ? args[0] : Undefined.instance;\n+        if (callbackArg == null || !(callbackArg instanceof Function)) {\n+            throw ScriptRuntime.notFunctionError(callbackArg);\n+        }\n+        Function f = (Function) callbackArg;\n+        Scriptable parent = ScriptableObject.getTopLevelScope(f);\n+        long length = getLengthProperty(cx, thisObj);\n+        // offset hack to serve both reduce and reduceRight with the same loop\n+        long offset = id == Id_reduceRight ? length - 1 : 0;\n+        Object value = args.length > 1 ? args[1] : Scriptable.NOT_FOUND;\n+        for (long i = 0; i < length; i++) {\n+            Object elem = getRawElem(thisObj, Math.abs(i - offset));\n+            if (elem == Scriptable.NOT_FOUND) {\n+                continue;\n+            }\n+            if (value == Scriptable.NOT_FOUND) {\n+                // no initial value passed, use first element found as inital value\n+                value = elem;\n+            } else {\n+                Object[] innerArgs = new Object[4];\n+                innerArgs[0] = value;\n+                innerArgs[1] = elem;\n+                innerArgs[2] = new Long(i);\n+                innerArgs[3] = thisObj;\n+                value = f.call(cx, parent, parent, innerArgs);\n+            }\n+        }\n+        if (value == Scriptable.NOT_FOUND) {\n+            // reproduce spidermonkey error message\n+            throw ScriptRuntime.typeError0(\"msg.empty.array.reduce\");\n+        }\n+        return value;\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2005-09-26 15:47:42 EDT\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 3: c=s.charAt(0);\n+                if (c=='m') { if (s.charAt(2)=='p' && s.charAt(1)=='a') {id=Id_map; break L0;} }\n+                else if (c=='p') { if (s.charAt(2)=='p' && s.charAt(1)=='o') {id=Id_pop; break L0;} }\n+                break L;\n+            case 4: switch (s.charAt(2)) {\n+                case 'i': X=\"join\";id=Id_join; break L;\n+                case 'm': X=\"some\";id=Id_some; break L;\n+                case 'r': X=\"sort\";id=Id_sort; break L;\n+                case 's': X=\"push\";id=Id_push; break L;\n+                } break L;\n+            case 5: c=s.charAt(1);\n+                if (c=='h') { X=\"shift\";id=Id_shift; }\n+                else if (c=='l') { X=\"slice\";id=Id_slice; }\n+                else if (c=='v') { X=\"every\";id=Id_every; }\n+                break L;\n+            case 6: c=s.charAt(0);\n+                if (c=='c') { X=\"concat\";id=Id_concat; }\n+                else if (c=='f') { X=\"filter\";id=Id_filter; }\n+                else if (c=='s') { X=\"splice\";id=Id_splice; }\n+                else if (c=='r') { X=\"reduce\";id=Id_reduce; }\n+                break L;\n+            case 7: switch (s.charAt(0)) {\n+                case 'f': X=\"forEach\";id=Id_forEach; break L;\n+                case 'i': X=\"indexOf\";id=Id_indexOf; break L;\n+                case 'r': X=\"reverse\";id=Id_reverse; break L;\n+                case 'u': X=\"unshift\";id=Id_unshift; break L;\n+                } break L;\n+            case 8: c=s.charAt(3);\n+                if (c=='o') { X=\"toSource\";id=Id_toSource; }\n+                else if (c=='t') { X=\"toString\";id=Id_toString; }\n+                break L;\n+            case 11: c=s.charAt(0);\n+                if (c=='c') { X=\"constructor\";id=Id_constructor; }\n+                else if (c=='l') { X=\"lastIndexOf\";id=Id_lastIndexOf; }\n+                else if (c=='r') { X=\"reduceRight\";id=Id_reduceRight; }\n+                break L;\n+            case 14: X=\"toLocaleString\";id=Id_toLocaleString; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_constructor          = 1,\n+        Id_toString             = 2,\n+        Id_toLocaleString       = 3,\n+        Id_toSource             = 4,\n+        Id_join                 = 5,\n+        Id_reverse              = 6,\n+        Id_sort                 = 7,\n+        Id_push                 = 8,\n+        Id_pop                  = 9,\n+        Id_shift                = 10,\n+        Id_unshift              = 11,\n+        Id_splice               = 12,\n+        Id_concat               = 13,\n+        Id_slice                = 14,\n+        Id_indexOf              = 15,\n+        Id_lastIndexOf          = 16,\n+        Id_every                = 17,\n+        Id_filter               = 18,\n+        Id_forEach              = 19,\n+        Id_map                  = 20,\n+        Id_some                 = 21,\n+        Id_reduce               = 22,\n+        Id_reduceRight          = 23,\n+\n+        MAX_PROTOTYPE_ID        = 23;\n+\n+// #/string_id_map#\n+\n+    private static final int\n+        ConstructorId_join                 = -Id_join,\n+        ConstructorId_reverse              = -Id_reverse,\n+        ConstructorId_sort                 = -Id_sort,\n+        ConstructorId_push                 = -Id_push,\n+        ConstructorId_pop                  = -Id_pop,\n+        ConstructorId_shift                = -Id_shift,\n+        ConstructorId_unshift              = -Id_unshift,\n+        ConstructorId_splice               = -Id_splice,\n+        ConstructorId_concat               = -Id_concat,\n+        ConstructorId_slice                = -Id_slice,\n+        ConstructorId_indexOf              = -Id_indexOf,\n+        ConstructorId_lastIndexOf          = -Id_lastIndexOf,\n+        ConstructorId_every                = -Id_every,\n+        ConstructorId_filter               = -Id_filter,\n+        ConstructorId_forEach              = -Id_forEach,\n+        ConstructorId_map                  = -Id_map,\n+        ConstructorId_some                 = -Id_some,\n+        ConstructorId_reduce               = -Id_reduce,\n+        ConstructorId_reduceRight          = -Id_reduceRight,\n+        ConstructorId_isArray              = -24;\n+\n+    /**\n+     * Internal representation of the JavaScript array's length property.\n+     */\n+    private long length;\n+\n+    /**\n+     * Fast storage for dense arrays. Sparse arrays will use the superclass's\n+     * hashtable storage scheme.\n+     */\n+    private Object[] dense;\n+\n+    /**\n+     * True if all numeric properties are stored in <code>dense</code>.\n+     */\n+    private boolean denseOnly;\n+\n+    /**\n+     * The maximum size of <code>dense</code> that will be allocated initially.\n+     */\n+    private static int maximumInitialCapacity = 10000;\n+\n+    /**\n+     * The default capacity for <code>dense</code>.\n+     */\n+    private static final int DEFAULT_INITIAL_CAPACITY = 10;\n+\n+    /**\n+     * The factor to grow <code>dense</code> by.\n+     */\n+    private static final double GROW_FACTOR = 1.5;\n+    private static final int MAX_PRE_GROW_SIZE = (int)(Integer.MAX_VALUE / GROW_FACTOR);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeBoolean.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Mike McCabe\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class implements the Boolean native object.\n+ * See ECMA 15.6.\n+ */\n+final class NativeBoolean extends IdScriptableObject\n+{\n+    static final long serialVersionUID = -3716996899943880933L;\n+\n+    private static final Object BOOLEAN_TAG = \"Boolean\";\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeBoolean obj = new NativeBoolean(false);\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    private NativeBoolean(boolean b)\n+    {\n+        booleanValue = b;\n+    }\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"Boolean\";\n+    }\n+\n+    @Override\n+    public Object getDefaultValue(Class<?> typeHint) {\n+        // This is actually non-ECMA, but will be proposed\n+        // as a change in round 2.\n+        if (typeHint == ScriptRuntime.BooleanClass)\n+            return ScriptRuntime.wrapBoolean(booleanValue);\n+        return super.getDefaultValue(typeHint);\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor: arity=1; s=\"constructor\"; break;\n+          case Id_toString:    arity=0; s=\"toString\";    break;\n+          case Id_toSource:    arity=0; s=\"toSource\";    break;\n+          case Id_valueOf:     arity=0; s=\"valueOf\";     break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(BOOLEAN_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(BOOLEAN_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+\n+        if (id == Id_constructor) {\n+            boolean b;\n+            if (args.length == 0) {\n+                b = false;\n+            } else {\n+                b = args[0] instanceof ScriptableObject &&\n+                        ((ScriptableObject) args[0]).avoidObjectDetection()\n+                    ? true\n+                    : ScriptRuntime.toBoolean(args[0]);\n+            }\n+            if (thisObj == null) {\n+                // new Boolean(val) creates a new boolean object.\n+                return new NativeBoolean(b);\n+            }\n+            // Boolean(val) converts val to a boolean.\n+            return ScriptRuntime.wrapBoolean(b);\n+        }\n+\n+        // The rest of Boolean.prototype methods require thisObj to be Boolean\n+\n+        if (!(thisObj instanceof NativeBoolean))\n+            throw incompatibleCallError(f);\n+        boolean value = ((NativeBoolean)thisObj).booleanValue;\n+\n+        switch (id) {\n+\n+          case Id_toString:\n+            return value ? \"true\" : \"false\";\n+\n+          case Id_toSource:\n+            return value ? \"(new Boolean(true))\" : \"(new Boolean(false))\";\n+\n+          case Id_valueOf:\n+            return ScriptRuntime.wrapBoolean(value);\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-05-09 08:15:31 EDT\n+        L0: { id = 0; String X = null; int c;\n+            int s_length = s.length();\n+            if (s_length==7) { X=\"valueOf\";id=Id_valueOf; }\n+            else if (s_length==8) {\n+                c=s.charAt(3);\n+                if (c=='o') { X=\"toSource\";id=Id_toSource; }\n+                else if (c=='t') { X=\"toString\";id=Id_toString; }\n+            }\n+            else if (s_length==11) { X=\"constructor\";id=Id_constructor; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_constructor          = 1,\n+        Id_toString             = 2,\n+        Id_toSource             = 3,\n+        Id_valueOf              = 4,\n+        MAX_PROTOTYPE_ID        = 4;\n+\n+// #/string_id_map#\n+\n+    private boolean booleanValue;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeCall.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Bob Jervis\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class implements the activation object.\n+ *\n+ * See ECMA 10.1.6\n+ *\n+ * @see org.mozilla.javascript.Arguments\n+ */\n+public final class NativeCall extends IdScriptableObject\n+{\n+    static final long serialVersionUID = -7471457301304454454L;\n+\n+    private static final Object CALL_TAG = \"Call\";\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeCall obj = new NativeCall();\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    NativeCall() { }\n+\n+    NativeCall(NativeFunction function, Scriptable scope, Object[] args)\n+    {\n+        this.function = function;\n+\n+        setParentScope(scope);\n+        // leave prototype null\n+\n+        this.originalArgs = (args == null) ? ScriptRuntime.emptyArgs : args;\n+\n+        // initialize values of arguments\n+        int paramAndVarCount = function.getParamAndVarCount();\n+        int paramCount = function.getParamCount();\n+        if (paramAndVarCount != 0) {\n+            for (int i = 0; i < paramCount; ++i) {\n+                String name = function.getParamOrVarName(i);\n+                Object val = i < args.length ? args[i]\n+                                             : Undefined.instance;\n+                defineProperty(name, val, PERMANENT);\n+            }\n+        }\n+\n+        // initialize \"arguments\" property but only if it was not overridden by\n+        // the parameter with the same name\n+        if (!super.has(\"arguments\", this)) {\n+            defineProperty(\"arguments\", new Arguments(this), PERMANENT);\n+        }\n+\n+        if (paramAndVarCount != 0) {\n+            for (int i = paramCount; i < paramAndVarCount; ++i) {\n+                String name = function.getParamOrVarName(i);\n+                if (!super.has(name, this)) {\n+                    if (function.getParamOrVarConst(i))\n+                        defineProperty(name, Undefined.instance, CONST);\n+                    else\n+                        defineProperty(name, Undefined.instance, PERMANENT);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"Call\";\n+    }\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        return s.equals(\"constructor\") ? Id_constructor : 0;\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        if (id == Id_constructor) {\n+            arity=1; s=\"constructor\";\n+        } else {\n+            throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(CALL_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(CALL_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        if (id == Id_constructor) {\n+            if (thisObj != null) {\n+                throw Context.reportRuntimeError1(\"msg.only.from.new\", \"Call\");\n+            }\n+            ScriptRuntime.checkDeprecated(cx, \"Call\");\n+            NativeCall result = new NativeCall();\n+            result.setPrototype(getObjectPrototype(scope));\n+            return result;\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private static final int\n+        Id_constructor   = 1,\n+        MAX_PROTOTYPE_ID = 1;\n+\n+    NativeFunction function;\n+    Object[] originalArgs;\n+\n+    transient NativeCall parentActivationCall;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeContinuation.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+public final class NativeContinuation extends IdScriptableObject\n+    implements Function\n+{\n+    static final long serialVersionUID = 1794167133757605367L;\n+\n+    private static final Object FTAG = \"Continuation\";\n+\n+    private Object implementation;\n+\n+    public static void init(Context cx, Scriptable scope, boolean sealed)\n+    {\n+        NativeContinuation obj = new NativeContinuation();\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    public Object getImplementation()\n+    {\n+        return implementation;\n+    }\n+\n+    public void initImplementation(Object implementation)\n+    {\n+        this.implementation = implementation;\n+    }\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"Continuation\";\n+    }\n+\n+    public Scriptable construct(Context cx, Scriptable scope, Object[] args)\n+    {\n+        throw Context.reportRuntimeError(\"Direct call is not supported\");\n+    }\n+\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        return Interpreter.restartContinuation(this, cx, scope, args);\n+    }\n+\n+    public static boolean isContinuationConstructor(IdFunctionObject f)\n+    {\n+        if (f.hasTag(FTAG) && f.methodId() == Id_constructor) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor: arity=0; s=\"constructor\"; break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(FTAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(FTAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_constructor:\n+            throw Context.reportRuntimeError(\"Direct call is not supported\");\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-05-09 08:16:40 EDT\n+        L0: { id = 0; String X = null;\n+            if (s.length()==11) { X=\"constructor\";id=Id_constructor; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_constructor          = 1,\n+        MAX_PROTOTYPE_ID        = 1;\n+\n+// #/string_id_map#\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeDate.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Peter Annema\n+ *   Norris Boyd\n+ *   Mike McCabe\n+ *   Ilya Frank\n+ *\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.util.Date;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+\n+import java.util.TimeZone;\n+import java.util.SimpleTimeZone;\n+\n+/**\n+ * This class implements the Date native object.\n+ * See ECMA 15.9.\n+ */\n+final class NativeDate extends IdScriptableObject\n+{\n+    static final long serialVersionUID = -8307438915861678966L;\n+\n+    private static final Object DATE_TAG = \"Date\";\n+\n+    private static final String js_NaN_date_str = \"Invalid Date\";\n+\n+    private static final DateFormat isoFormat;\n+    static {\n+      isoFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n+      isoFormat.setTimeZone(new SimpleTimeZone(0, \"UTC\"));\n+      isoFormat.setLenient(false);\n+    }\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeDate obj = new NativeDate();\n+        // Set the value of the prototype Date to NaN ('invalid date');\n+        obj.date = ScriptRuntime.NaN;\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    private NativeDate()\n+    {\n+        if (thisTimeZone == null) {\n+            // j.u.TimeZone is synchronized, so setting class statics from it\n+            // should be OK.\n+            thisTimeZone = TimeZone.getDefault();\n+            LocalTZA = thisTimeZone.getRawOffset();\n+        }\n+    }\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"Date\";\n+    }\n+\n+    @Override\n+    public Object getDefaultValue(Class<?> typeHint)\n+    {\n+        if (typeHint == null)\n+            typeHint = ScriptRuntime.StringClass;\n+        return super.getDefaultValue(typeHint);\n+    }\n+\n+    double getJSTimeValue()\n+    {\n+        return date;\n+    }\n+\n+    @Override\n+    protected void fillConstructorProperties(IdFunctionObject ctor)\n+    {\n+        addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_now,\n+                              \"now\", 0);\n+        addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_parse,\n+                              \"parse\", 1);\n+        addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_UTC,\n+                              \"UTC\", 1);\n+        super.fillConstructorProperties(ctor);\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor:        arity=1; s=\"constructor\";        break;\n+          case Id_toString:           arity=0; s=\"toString\";           break;\n+          case Id_toTimeString:       arity=0; s=\"toTimeString\";       break;\n+          case Id_toDateString:       arity=0; s=\"toDateString\";       break;\n+          case Id_toLocaleString:     arity=0; s=\"toLocaleString\";     break;\n+          case Id_toLocaleTimeString: arity=0; s=\"toLocaleTimeString\"; break;\n+          case Id_toLocaleDateString: arity=0; s=\"toLocaleDateString\"; break;\n+          case Id_toUTCString:        arity=0; s=\"toUTCString\";        break;\n+          case Id_toSource:           arity=0; s=\"toSource\";           break;\n+          case Id_valueOf:            arity=0; s=\"valueOf\";            break;\n+          case Id_getTime:            arity=0; s=\"getTime\";            break;\n+          case Id_getYear:            arity=0; s=\"getYear\";            break;\n+          case Id_getFullYear:        arity=0; s=\"getFullYear\";        break;\n+          case Id_getUTCFullYear:     arity=0; s=\"getUTCFullYear\";     break;\n+          case Id_getMonth:           arity=0; s=\"getMonth\";           break;\n+          case Id_getUTCMonth:        arity=0; s=\"getUTCMonth\";        break;\n+          case Id_getDate:            arity=0; s=\"getDate\";            break;\n+          case Id_getUTCDate:         arity=0; s=\"getUTCDate\";         break;\n+          case Id_getDay:             arity=0; s=\"getDay\";             break;\n+          case Id_getUTCDay:          arity=0; s=\"getUTCDay\";          break;\n+          case Id_getHours:           arity=0; s=\"getHours\";           break;\n+          case Id_getUTCHours:        arity=0; s=\"getUTCHours\";        break;\n+          case Id_getMinutes:         arity=0; s=\"getMinutes\";         break;\n+          case Id_getUTCMinutes:      arity=0; s=\"getUTCMinutes\";      break;\n+          case Id_getSeconds:         arity=0; s=\"getSeconds\";         break;\n+          case Id_getUTCSeconds:      arity=0; s=\"getUTCSeconds\";      break;\n+          case Id_getMilliseconds:    arity=0; s=\"getMilliseconds\";    break;\n+          case Id_getUTCMilliseconds: arity=0; s=\"getUTCMilliseconds\"; break;\n+          case Id_getTimezoneOffset:  arity=0; s=\"getTimezoneOffset\";  break;\n+          case Id_setTime:            arity=1; s=\"setTime\";            break;\n+          case Id_setMilliseconds:    arity=1; s=\"setMilliseconds\";    break;\n+          case Id_setUTCMilliseconds: arity=1; s=\"setUTCMilliseconds\"; break;\n+          case Id_setSeconds:         arity=2; s=\"setSeconds\";         break;\n+          case Id_setUTCSeconds:      arity=2; s=\"setUTCSeconds\";      break;\n+          case Id_setMinutes:         arity=3; s=\"setMinutes\";         break;\n+          case Id_setUTCMinutes:      arity=3; s=\"setUTCMinutes\";      break;\n+          case Id_setHours:           arity=4; s=\"setHours\";           break;\n+          case Id_setUTCHours:        arity=4; s=\"setUTCHours\";        break;\n+          case Id_setDate:            arity=1; s=\"setDate\";            break;\n+          case Id_setUTCDate:         arity=1; s=\"setUTCDate\";         break;\n+          case Id_setMonth:           arity=2; s=\"setMonth\";           break;\n+          case Id_setUTCMonth:        arity=2; s=\"setUTCMonth\";        break;\n+          case Id_setFullYear:        arity=3; s=\"setFullYear\";        break;\n+          case Id_setUTCFullYear:     arity=3; s=\"setUTCFullYear\";     break;\n+          case Id_setYear:            arity=1; s=\"setYear\";            break;\n+          case Id_toISOString:        arity=0; s=\"toISOString\";        break;\n+          case Id_toJSON:             arity=1; s=\"toJSON\";             break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(DATE_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(DATE_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case ConstructorId_now:\n+            return ScriptRuntime.wrapNumber(now());\n+\n+          case ConstructorId_parse:\n+            {\n+                String dataStr = ScriptRuntime.toString(args, 0);\n+                return ScriptRuntime.wrapNumber(date_parseString(dataStr));\n+            }\n+\n+          case ConstructorId_UTC:\n+            return ScriptRuntime.wrapNumber(jsStaticFunction_UTC(args));\n+\n+          case Id_constructor:\n+            {\n+                // if called as a function, just return a string\n+                // representing the current time.\n+                if (thisObj != null)\n+                    return date_format(now(), Id_toString);\n+                return jsConstructor(args);\n+            }\n+\n+          case Id_toJSON:\n+            {\n+                if (thisObj instanceof NativeDate) {\n+                    return ((NativeDate) thisObj).toISOString();\n+                }\n+\n+                final String toISOString = \"toISOString\";\n+\n+                Scriptable o = ScriptRuntime.toObject(cx, scope, thisObj);\n+                Object tv = ScriptRuntime.toPrimitive(o, ScriptRuntime.NumberClass);\n+                if (tv instanceof Number) {\n+                    double d = ((Number) tv).doubleValue();\n+                    if (d != d || Double.isInfinite(d)) {\n+                        return null;\n+                    }\n+                }\n+                Object toISO = o.get(toISOString, o);\n+                if (toISO == NOT_FOUND) {\n+                    throw ScriptRuntime.typeError2(\"msg.function.not.found.in\",\n+                            toISOString,\n+                            ScriptRuntime.toString(o));\n+                }\n+                if ( !(toISO instanceof Callable) ) {\n+                    throw ScriptRuntime.typeError3(\"msg.isnt.function.in\",\n+                            toISOString,\n+                            ScriptRuntime.toString(o),\n+                            ScriptRuntime.toString(toISO));\n+                }\n+                Object result = ((Callable) toISO).call(cx, scope, o,\n+                            ScriptRuntime.emptyArgs);\n+                if ( !ScriptRuntime.isPrimitive(result) ) {\n+                    throw ScriptRuntime.typeError1(\"msg.toisostring.must.return.primitive\",\n+                            ScriptRuntime.toString(result));\n+                }\n+                return result;\n+            }\n+\n+        }\n+\n+        // The rest of Date.prototype methods require thisObj to be Date\n+\n+        if (!(thisObj instanceof NativeDate))\n+            throw incompatibleCallError(f);\n+        NativeDate realThis = (NativeDate)thisObj;\n+        double t = realThis.date;\n+\n+        switch (id) {\n+\n+          case Id_toString:\n+          case Id_toTimeString:\n+          case Id_toDateString:\n+            if (t == t) {\n+                return date_format(t, id);\n+            }\n+            return js_NaN_date_str;\n+\n+          case Id_toLocaleString:\n+          case Id_toLocaleTimeString:\n+          case Id_toLocaleDateString:\n+            if (t == t) {\n+                return toLocale_helper(t, id);\n+            }\n+            return js_NaN_date_str;\n+\n+          case Id_toUTCString:\n+            if (t == t) {\n+                return js_toUTCString(t);\n+            }\n+            return js_NaN_date_str;\n+\n+          case Id_toSource:\n+            return \"(new Date(\"+ScriptRuntime.toString(t)+\"))\";\n+\n+          case Id_valueOf:\n+          case Id_getTime:\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_getYear:\n+          case Id_getFullYear:\n+          case Id_getUTCFullYear:\n+            if (t == t) {\n+                if (id != Id_getUTCFullYear) t = LocalTime(t);\n+                t = YearFromTime(t);\n+                if (id == Id_getYear) {\n+                    if (cx.hasFeature(Context.FEATURE_NON_ECMA_GET_YEAR)) {\n+                        if (1900 <= t && t < 2000) {\n+                            t -= 1900;\n+                        }\n+                    } else {\n+                        t -= 1900;\n+                    }\n+                }\n+            }\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_getMonth:\n+          case Id_getUTCMonth:\n+            if (t == t) {\n+                if (id == Id_getMonth) t = LocalTime(t);\n+                t = MonthFromTime(t);\n+            }\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_getDate:\n+          case Id_getUTCDate:\n+            if (t == t) {\n+                if (id == Id_getDate) t = LocalTime(t);\n+                t = DateFromTime(t);\n+            }\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_getDay:\n+          case Id_getUTCDay:\n+            if (t == t) {\n+                if (id == Id_getDay) t = LocalTime(t);\n+                t = WeekDay(t);\n+            }\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_getHours:\n+          case Id_getUTCHours:\n+            if (t == t) {\n+                if (id == Id_getHours) t = LocalTime(t);\n+                t = HourFromTime(t);\n+            }\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_getMinutes:\n+          case Id_getUTCMinutes:\n+            if (t == t) {\n+                if (id == Id_getMinutes) t = LocalTime(t);\n+                t = MinFromTime(t);\n+            }\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_getSeconds:\n+          case Id_getUTCSeconds:\n+            if (t == t) {\n+                if (id == Id_getSeconds) t = LocalTime(t);\n+                t = SecFromTime(t);\n+            }\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_getMilliseconds:\n+          case Id_getUTCMilliseconds:\n+            if (t == t) {\n+                if (id == Id_getMilliseconds) t = LocalTime(t);\n+                t = msFromTime(t);\n+            }\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_getTimezoneOffset:\n+            if (t == t) {\n+                t = (t - LocalTime(t)) / msPerMinute;\n+            }\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_setTime:\n+            t = TimeClip(ScriptRuntime.toNumber(args, 0));\n+            realThis.date = t;\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_setMilliseconds:\n+          case Id_setUTCMilliseconds:\n+          case Id_setSeconds:\n+          case Id_setUTCSeconds:\n+          case Id_setMinutes:\n+          case Id_setUTCMinutes:\n+          case Id_setHours:\n+          case Id_setUTCHours:\n+            t = makeTime(t, args, id);\n+            realThis.date = t;\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_setDate:\n+          case Id_setUTCDate:\n+          case Id_setMonth:\n+          case Id_setUTCMonth:\n+          case Id_setFullYear:\n+          case Id_setUTCFullYear:\n+            t = makeDate(t, args, id);\n+            realThis.date = t;\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_setYear:\n+            {\n+                double year = ScriptRuntime.toNumber(args, 0);\n+\n+                if (year != year || Double.isInfinite(year)) {\n+                    t = ScriptRuntime.NaN;\n+                } else {\n+                    if (t != t) {\n+                        t = 0;\n+                    } else {\n+                        t = LocalTime(t);\n+                    }\n+\n+                    if (year >= 0 && year <= 99)\n+                        year += 1900;\n+\n+                    double day = MakeDay(year, MonthFromTime(t),\n+                                         DateFromTime(t));\n+                    t = MakeDate(day, TimeWithinDay(t));\n+                    t = internalUTC(t);\n+                    t = TimeClip(t);\n+                }\n+            }\n+            realThis.date = t;\n+            return ScriptRuntime.wrapNumber(t);\n+\n+          case Id_toISOString:\n+            return realThis.toISOString();\n+\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+\n+    }\n+\n+    private String toISOString() {\n+        if (date == date) {\n+            synchronized (isoFormat) {\n+                return isoFormat.format(new Date((long) date));\n+            }\n+        }\n+        String msg = ScriptRuntime.getMessage0(\"msg.invalid.date\");\n+        throw ScriptRuntime.constructError(\"RangeError\", msg);\n+    }\n+\n+    /* ECMA helper functions */\n+\n+    private static final double HalfTimeDomain = 8.64e15;\n+    private static final double HoursPerDay    = 24.0;\n+    private static final double MinutesPerHour = 60.0;\n+    private static final double SecondsPerMinute = 60.0;\n+    private static final double msPerSecond    = 1000.0;\n+    private static final double MinutesPerDay  = (HoursPerDay * MinutesPerHour);\n+    private static final double SecondsPerDay  = (MinutesPerDay * SecondsPerMinute);\n+    private static final double SecondsPerHour = (MinutesPerHour * SecondsPerMinute);\n+    private static final double msPerDay       = (SecondsPerDay * msPerSecond);\n+    private static final double msPerHour      = (SecondsPerHour * msPerSecond);\n+    private static final double msPerMinute    = (SecondsPerMinute * msPerSecond);\n+\n+    private static double Day(double t)\n+    {\n+        return Math.floor(t / msPerDay);\n+    }\n+\n+    private static double TimeWithinDay(double t)\n+    {\n+        double result;\n+        result = t % msPerDay;\n+        if (result < 0)\n+            result += msPerDay;\n+        return result;\n+    }\n+\n+    private static boolean IsLeapYear(int year)\n+    {\n+        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);\n+    }\n+\n+    /* math here has to be f.p, because we need\n+     *  floor((1968 - 1969) / 4) == -1\n+     */\n+    private static double DayFromYear(double y)\n+    {\n+        return ((365 * ((y)-1970) + Math.floor(((y)-1969)/4.0)\n+                 - Math.floor(((y)-1901)/100.0) + Math.floor(((y)-1601)/400.0)));\n+    }\n+\n+    private static double TimeFromYear(double y)\n+    {\n+        return DayFromYear(y) * msPerDay;\n+    }\n+\n+    private static int YearFromTime(double t)\n+    {\n+        int lo = (int) Math.floor((t / msPerDay) / 366) + 1970;\n+        int hi = (int) Math.floor((t / msPerDay) / 365) + 1970;\n+        int mid;\n+\n+        /* above doesn't work for negative dates... */\n+        if (hi < lo) {\n+            int temp = lo;\n+            lo = hi;\n+            hi = temp;\n+        }\n+\n+        /* Use a simple binary search algorithm to find the right\n+           year.  This seems like brute force... but the computation\n+           of hi and lo years above lands within one year of the\n+           correct answer for years within a thousand years of\n+           1970; the loop below only requires six iterations\n+           for year 270000. */\n+        while (hi > lo) {\n+            mid = (hi + lo) / 2;\n+            if (TimeFromYear(mid) > t) {\n+                hi = mid - 1;\n+            } else {\n+                lo = mid + 1;\n+                if (TimeFromYear(lo) > t) {\n+                    return mid;\n+                }\n+            }\n+        }\n+        return lo;\n+    }\n+\n+    private static double DayFromMonth(int m, int year)\n+    {\n+        int day = m * 30;\n+\n+        if (m >= 7) { day += m / 2 - 1; }\n+        else if (m >= 2) { day += (m - 1) / 2 - 1; }\n+        else { day += m; }\n+\n+        if (m >= 2 && IsLeapYear(year)) { ++day; }\n+\n+        return day;\n+    }\n+\n+    private static int MonthFromTime(double t)\n+    {\n+        int year = YearFromTime(t);\n+        int d = (int)(Day(t) - DayFromYear(year));\n+\n+        d -= 31 + 28;\n+        if (d < 0) {\n+            return (d < -28) ? 0 : 1;\n+        }\n+\n+        if (IsLeapYear(year)) {\n+            if (d == 0)\n+                return 1; // 29 February\n+            --d;\n+        }\n+\n+        // d: date count from 1 March\n+        int estimate = d / 30; // approx number of month since March\n+        int mstart;\n+        switch (estimate) {\n+            case 0: return 2;\n+            case 1: mstart = 31; break;\n+            case 2: mstart = 31+30; break;\n+            case 3: mstart = 31+30+31; break;\n+            case 4: mstart = 31+30+31+30; break;\n+            case 5: mstart = 31+30+31+30+31; break;\n+            case 6: mstart = 31+30+31+30+31+31; break;\n+            case 7: mstart = 31+30+31+30+31+31+30; break;\n+            case 8: mstart = 31+30+31+30+31+31+30+31; break;\n+            case 9: mstart = 31+30+31+30+31+31+30+31+30; break;\n+            case 10: return 11; //Late december\n+            default: throw Kit.codeBug();\n+        }\n+        // if d < mstart then real month since March == estimate - 1\n+        return (d >= mstart) ? estimate + 2 : estimate + 1;\n+    }\n+\n+    private static int DateFromTime(double t)\n+    {\n+        int year = YearFromTime(t);\n+        int d = (int)(Day(t) - DayFromYear(year));\n+\n+        d -= 31 + 28;\n+        if (d < 0) {\n+            return (d < -28) ? d + 31 + 28 + 1 : d + 28 + 1;\n+        }\n+\n+        if (IsLeapYear(year)) {\n+            if (d == 0)\n+                return 29; // 29 February\n+            --d;\n+        }\n+\n+        // d: date count from 1 March\n+        int mdays, mstart;\n+        switch (d / 30) { // approx number of month since March\n+            case 0: return d + 1;\n+            case 1: mdays = 31; mstart = 31; break;\n+            case 2: mdays = 30; mstart = 31+30; break;\n+            case 3: mdays = 31; mstart = 31+30+31; break;\n+            case 4: mdays = 30; mstart = 31+30+31+30; break;\n+            case 5: mdays = 31; mstart = 31+30+31+30+31; break;\n+            case 6: mdays = 31; mstart = 31+30+31+30+31+31; break;\n+            case 7: mdays = 30; mstart = 31+30+31+30+31+31+30; break;\n+            case 8: mdays = 31; mstart = 31+30+31+30+31+31+30+31; break;\n+            case 9: mdays = 30; mstart = 31+30+31+30+31+31+30+31+30; break;\n+            case 10:\n+                return d - (31+30+31+30+31+31+30+31+30) + 1; //Late december\n+            default: throw Kit.codeBug();\n+        }\n+        d -= mstart;\n+        if (d < 0) {\n+            // wrong estimate: sfhift to previous month\n+            d += mdays;\n+        }\n+        return d + 1;\n+     }\n+\n+    private static int WeekDay(double t)\n+    {\n+        double result;\n+        result = Day(t) + 4;\n+        result = result % 7;\n+        if (result < 0)\n+            result += 7;\n+        return (int) result;\n+    }\n+\n+    private static double now()\n+    {\n+        return System.currentTimeMillis();\n+    }\n+\n+    /* Should be possible to determine the need for this dynamically\n+     * if we go with the workaround... I'm not using it now, because I\n+     * can't think of any clean way to make toLocaleString() and the\n+     * time zone (comment) in toString match the generated string\n+     * values.  Currently it's wrong-but-consistent in all but the\n+     * most recent betas of the JRE - seems to work in 1.1.7.\n+     */\n+    private final static boolean TZO_WORKAROUND = false;\n+    private static double DaylightSavingTA(double t)\n+    {\n+        // Another workaround!  The JRE doesn't seem to know about DST\n+        // before year 1 AD, so we map to equivalent dates for the\n+        // purposes of finding dst.  To be safe, we do this for years\n+        // outside 1970-2038.\n+        if (t < 0.0 || t > 2145916800000.0) {\n+            int year = EquivalentYear(YearFromTime(t));\n+            double day = MakeDay(year, MonthFromTime(t), DateFromTime(t));\n+            t = MakeDate(day, TimeWithinDay(t));\n+        }\n+        if (!TZO_WORKAROUND) {\n+            Date date = new Date((long) t);\n+            if (thisTimeZone.inDaylightTime(date))\n+                return msPerHour;\n+            else\n+                return 0;\n+        } else {\n+            /* Use getOffset if inDaylightTime() is broken, because it\n+             * seems to work acceptably.  We don't switch over to it\n+             * entirely, because it requires (expensive) exploded date arguments,\n+             * and the api makes it impossible to handle dst\n+             * changeovers cleanly.\n+             */\n+\n+            // Hardcode the assumption that the changeover always\n+            // happens at 2:00 AM:\n+            t += LocalTZA + (HourFromTime(t) <= 2 ? msPerHour : 0);\n+\n+            int year = YearFromTime(t);\n+            double offset = thisTimeZone.getOffset(year > 0 ? 1 : 0,\n+                                                   year,\n+                                                   MonthFromTime(t),\n+                                                   DateFromTime(t),\n+                                                   WeekDay(t),\n+                                                   (int)TimeWithinDay(t));\n+\n+            if ((offset - LocalTZA) != 0)\n+                return msPerHour;\n+            else\n+                return 0;\n+            //         return offset - LocalTZA;\n+        }\n+    }\n+\n+    /*\n+     * Find a year for which any given date will fall on the same weekday.\n+     *\n+     * This function should be used with caution when used other than\n+     * for determining DST; it hasn't been proven not to produce an\n+     * incorrect year for times near year boundaries.\n+     */\n+    private static int EquivalentYear(int year)\n+    {\n+        int day = (int) DayFromYear(year) + 4;\n+        day = day % 7;\n+        if (day < 0)\n+            day += 7;\n+        // Years and leap years on which Jan 1 is a Sunday, Monday, etc.\n+        if (IsLeapYear(year)) {\n+            switch (day) {\n+                case 0: return 1984;\n+                case 1: return 1996;\n+                case 2: return 1980;\n+                case 3: return 1992;\n+                case 4: return 1976;\n+                case 5: return 1988;\n+                case 6: return 1972;\n+            }\n+        } else {\n+            switch (day) {\n+                case 0: return 1978;\n+                case 1: return 1973;\n+                case 2: return 1974;\n+                case 3: return 1975;\n+                case 4: return 1981;\n+                case 5: return 1971;\n+                case 6: return 1977;\n+            }\n+        }\n+        // Unreachable\n+        throw Kit.codeBug();\n+    }\n+\n+    private static double LocalTime(double t)\n+    {\n+        return t + LocalTZA + DaylightSavingTA(t);\n+    }\n+\n+    private static double internalUTC(double t)\n+    {\n+        return t - LocalTZA - DaylightSavingTA(t - LocalTZA);\n+    }\n+\n+    private static int HourFromTime(double t)\n+    {\n+        double result;\n+        result = Math.floor(t / msPerHour) % HoursPerDay;\n+        if (result < 0)\n+            result += HoursPerDay;\n+        return (int) result;\n+    }\n+\n+    private static int MinFromTime(double t)\n+    {\n+        double result;\n+        result = Math.floor(t / msPerMinute) % MinutesPerHour;\n+        if (result < 0)\n+            result += MinutesPerHour;\n+        return (int) result;\n+    }\n+\n+    private static int SecFromTime(double t)\n+    {\n+        double result;\n+        result = Math.floor(t / msPerSecond) % SecondsPerMinute;\n+        if (result < 0)\n+            result += SecondsPerMinute;\n+        return (int) result;\n+    }\n+\n+    private static int msFromTime(double t)\n+    {\n+        double result;\n+        result =  t % msPerSecond;\n+        if (result < 0)\n+            result += msPerSecond;\n+        return (int) result;\n+    }\n+\n+    private static double MakeTime(double hour, double min,\n+                                   double sec, double ms)\n+    {\n+        return ((hour * MinutesPerHour + min) * SecondsPerMinute + sec)\n+            * msPerSecond + ms;\n+    }\n+\n+    private static double MakeDay(double year, double month, double date)\n+    {\n+        year += Math.floor(month / 12);\n+\n+        month = month % 12;\n+        if (month < 0)\n+            month += 12;\n+\n+        double yearday = Math.floor(TimeFromYear(year) / msPerDay);\n+        double monthday = DayFromMonth((int)month, (int)year);\n+\n+        return yearday + monthday + date - 1;\n+    }\n+\n+    private static double MakeDate(double day, double time)\n+    {\n+        return day * msPerDay + time;\n+    }\n+\n+    private static double TimeClip(double d)\n+    {\n+        if (d != d ||\n+            d == Double.POSITIVE_INFINITY ||\n+            d == Double.NEGATIVE_INFINITY ||\n+            Math.abs(d) > HalfTimeDomain)\n+        {\n+            return ScriptRuntime.NaN;\n+        }\n+        if (d > 0.0)\n+            return Math.floor(d + 0.);\n+        else\n+            return Math.ceil(d + 0.);\n+    }\n+\n+    /* end of ECMA helper functions */\n+\n+    /* find UTC time from given date... no 1900 correction! */\n+    private static double date_msecFromDate(double year, double mon,\n+                                            double mday, double hour,\n+                                            double min, double sec,\n+                                            double msec)\n+    {\n+        double day;\n+        double time;\n+        double result;\n+\n+        day = MakeDay(year, mon, mday);\n+        time = MakeTime(hour, min, sec, msec);\n+        result = MakeDate(day, time);\n+        return result;\n+    }\n+\n+    /* compute the time in msec (unclipped) from the given args */\n+    private static final int MAXARGS = 7;\n+    private static double date_msecFromArgs(Object[] args)\n+    {\n+        double array[] = new double[MAXARGS];\n+        int loop;\n+        double d;\n+\n+        for (loop = 0; loop < MAXARGS; loop++) {\n+            if (loop < args.length) {\n+                d = ScriptRuntime.toNumber(args[loop]);\n+                if (d != d || Double.isInfinite(d)) {\n+                    return ScriptRuntime.NaN;\n+                }\n+                array[loop] = ScriptRuntime.toInteger(args[loop]);\n+            } else {\n+                if (loop == 2) {\n+                    array[loop] = 1; /* Default the date argument to 1. */\n+                } else {\n+                    array[loop] = 0;\n+                }\n+            }\n+        }\n+\n+        /* adjust 2-digit years into the 20th century */\n+        if (array[0] >= 0 && array[0] <= 99)\n+            array[0] += 1900;\n+\n+        return date_msecFromDate(array[0], array[1], array[2],\n+                                 array[3], array[4], array[5], array[6]);\n+    }\n+\n+    private static double jsStaticFunction_UTC(Object[] args)\n+    {\n+        return TimeClip(date_msecFromArgs(args));\n+    }\n+\n+    private static double date_parseString(String s)\n+    {\n+        try {\n+          if (s.length() == 24) return isoFormat.parse(s).getTime();\n+        } catch (java.text.ParseException ex) {}\n+\n+        int year = -1;\n+        int mon = -1;\n+        int mday = -1;\n+        int hour = -1;\n+        int min = -1;\n+        int sec = -1;\n+        char c = 0;\n+        char si = 0;\n+        int i = 0;\n+        int n = -1;\n+        double tzoffset = -1;\n+        char prevc = 0;\n+        int limit = 0;\n+        boolean seenplusminus = false;\n+\n+        limit = s.length();\n+        while (i < limit) {\n+            c = s.charAt(i);\n+            i++;\n+            if (c <= ' ' || c == ',' || c == '-') {\n+                if (i < limit) {\n+                    si = s.charAt(i);\n+                    if (c == '-' && '0' <= si && si <= '9') {\n+                        prevc = c;\n+                    }\n+                }\n+                continue;\n+            }\n+            if (c == '(') { /* comments) */\n+                int depth = 1;\n+                while (i < limit) {\n+                    c = s.charAt(i);\n+                    i++;\n+                    if (c == '(')\n+                        depth++;\n+                    else if (c == ')')\n+                        if (--depth <= 0)\n+                            break;\n+                }\n+                continue;\n+            }\n+            if ('0' <= c && c <= '9') {\n+                n = c - '0';\n+                while (i < limit && '0' <= (c = s.charAt(i)) && c <= '9') {\n+                    n = n * 10 + c - '0';\n+                    i++;\n+                }\n+\n+                /* allow TZA before the year, so\n+                 * 'Wed Nov 05 21:49:11 GMT-0800 1997'\n+                 * works */\n+\n+                /* uses of seenplusminus allow : in TZA, so Java\n+                 * no-timezone style of GMT+4:30 works\n+                 */\n+                if ((prevc == '+' || prevc == '-')/*  && year>=0 */) {\n+                    /* make ':' case below change tzoffset */\n+                    seenplusminus = true;\n+\n+                    /* offset */\n+                    if (n < 24)\n+                        n = n * 60; /* EG. \"GMT-3\" */\n+                    else\n+                        n = n % 100 + n / 100 * 60; /* eg \"GMT-0430\" */\n+                    if (prevc == '+')       /* plus means east of GMT */\n+                        n = -n;\n+                    if (tzoffset != 0 && tzoffset != -1)\n+                        return ScriptRuntime.NaN;\n+                    tzoffset = n;\n+                } else if (n >= 70  ||\n+                           (prevc == '/' && mon >= 0 && mday >= 0\n+                            && year < 0))\n+                {\n+                    if (year >= 0)\n+                        return ScriptRuntime.NaN;\n+                    else if (c <= ' ' || c == ',' || c == '/' || i >= limit)\n+                        year = n < 100 ? n + 1900 : n;\n+                    else\n+                        return ScriptRuntime.NaN;\n+                } else if (c == ':') {\n+                    if (hour < 0)\n+                        hour = /*byte*/ n;\n+                    else if (min < 0)\n+                        min = /*byte*/ n;\n+                    else\n+                        return ScriptRuntime.NaN;\n+                } else if (c == '/') {\n+                    if (mon < 0)\n+                        mon = /*byte*/ n-1;\n+                    else if (mday < 0)\n+                        mday = /*byte*/ n;\n+                    else\n+                        return ScriptRuntime.NaN;\n+                } else if (i < limit && c != ',' && c > ' ' && c != '-') {\n+                    return ScriptRuntime.NaN;\n+                } else if (seenplusminus && n < 60) {  /* handle GMT-3:30 */\n+                    if (tzoffset < 0)\n+                        tzoffset -= n;\n+                    else\n+                        tzoffset += n;\n+                } else if (hour >= 0 && min < 0) {\n+                    min = /*byte*/ n;\n+                } else if (min >= 0 && sec < 0) {\n+                    sec = /*byte*/ n;\n+                } else if (mday < 0) {\n+                    mday = /*byte*/ n;\n+                } else {\n+                    return ScriptRuntime.NaN;\n+                }\n+                prevc = 0;\n+            } else if (c == '/' || c == ':' || c == '+' || c == '-') {\n+                prevc = c;\n+            } else {\n+                int st = i - 1;\n+                while (i < limit) {\n+                    c = s.charAt(i);\n+                    if (!(('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')))\n+                        break;\n+                    i++;\n+                }\n+                int letterCount = i - st;\n+                if (letterCount < 2)\n+                    return ScriptRuntime.NaN;\n+               /*\n+                * Use ported code from jsdate.c rather than the locale-specific\n+                * date-parsing code from Java, to keep js and rhino consistent.\n+                * Is this the right strategy?\n+                */\n+                String wtb = \"am;pm;\"\n+                            +\"monday;tuesday;wednesday;thursday;friday;\"\n+                            +\"saturday;sunday;\"\n+                            +\"january;february;march;april;may;june;\"\n+                            +\"july;august;september;october;november;december;\"\n+                            +\"gmt;ut;utc;est;edt;cst;cdt;mst;mdt;pst;pdt;\";\n+                int index = 0;\n+                for (int wtbOffset = 0; ;) {\n+                    int wtbNext = wtb.indexOf(';', wtbOffset);\n+                    if (wtbNext < 0)\n+                        return ScriptRuntime.NaN;\n+                    if (wtb.regionMatches(true, wtbOffset, s, st, letterCount))\n+                        break;\n+                    wtbOffset = wtbNext + 1;\n+                    ++index;\n+                }\n+                if (index < 2) {\n+                    /*\n+                     * AM/PM. Count 12:30 AM as 00:30, 12:30 PM as\n+                     * 12:30, instead of blindly adding 12 if PM.\n+                     */\n+                    if (hour > 12 || hour < 0) {\n+                        return ScriptRuntime.NaN;\n+                    } else if (index == 0) {\n+                        // AM\n+                        if (hour == 12)\n+                            hour = 0;\n+                    } else {\n+                        // PM\n+                        if (hour != 12)\n+                            hour += 12;\n+                    }\n+                } else if ((index -= 2) < 7) {\n+                    // ignore week days\n+                } else if ((index -= 7) < 12) {\n+                    // month\n+                    if (mon < 0) {\n+                        mon = index;\n+                    } else {\n+                        return ScriptRuntime.NaN;\n+                    }\n+                } else {\n+                    index -= 12;\n+                    // timezones\n+                    switch (index) {\n+                      case 0 /* gmt */: tzoffset = 0; break;\n+                      case 1 /* ut */:  tzoffset = 0; break;\n+                      case 2 /* utc */: tzoffset = 0; break;\n+                      case 3 /* est */: tzoffset = 5 * 60; break;\n+                      case 4 /* edt */: tzoffset = 4 * 60; break;\n+                      case 5 /* cst */: tzoffset = 6 * 60; break;\n+                      case 6 /* cdt */: tzoffset = 5 * 60; break;\n+                      case 7 /* mst */: tzoffset = 7 * 60; break;\n+                      case 8 /* mdt */: tzoffset = 6 * 60; break;\n+                      case 9 /* pst */: tzoffset = 8 * 60; break;\n+                      case 10 /* pdt */:tzoffset = 7 * 60; break;\n+                      default: Kit.codeBug();\n+                    }\n+                }\n+            }\n+        }\n+        if (year < 0 || mon < 0 || mday < 0)\n+            return ScriptRuntime.NaN;\n+        if (sec < 0)\n+            sec = 0;\n+        if (min < 0)\n+            min = 0;\n+        if (hour < 0)\n+            hour = 0;\n+\n+        double msec = date_msecFromDate(year, mon, mday, hour, min, sec, 0);\n+        if (tzoffset == -1) { /* no time zone specified, have to use local */\n+            return internalUTC(msec);\n+        } else {\n+            return msec + tzoffset * msPerMinute;\n+        }\n+    }\n+\n+    private static String date_format(double t, int methodId)\n+    {\n+        StringBuffer result = new StringBuffer(60);\n+        double local = LocalTime(t);\n+\n+        /* Tue Oct 31 09:41:40 GMT-0800 (PST) 2000 */\n+        /* Tue Oct 31 2000 */\n+        /* 09:41:40 GMT-0800 (PST) */\n+\n+        if (methodId != Id_toTimeString) {\n+            appendWeekDayName(result, WeekDay(local));\n+            result.append(' ');\n+            appendMonthName(result, MonthFromTime(local));\n+            result.append(' ');\n+            append0PaddedUint(result, DateFromTime(local), 2);\n+            result.append(' ');\n+            int year = YearFromTime(local);\n+            if (year < 0) {\n+                result.append('-');\n+                year = -year;\n+            }\n+            append0PaddedUint(result, year, 4);\n+            if (methodId != Id_toDateString)\n+                result.append(' ');\n+        }\n+\n+        if (methodId != Id_toDateString) {\n+            append0PaddedUint(result, HourFromTime(local), 2);\n+            result.append(':');\n+            append0PaddedUint(result, MinFromTime(local), 2);\n+            result.append(':');\n+            append0PaddedUint(result, SecFromTime(local), 2);\n+\n+            // offset from GMT in minutes.  The offset includes daylight\n+            // savings, if it applies.\n+            int minutes = (int) Math.floor((LocalTZA + DaylightSavingTA(t))\n+                                           / msPerMinute);\n+            // map 510 minutes to 0830 hours\n+            int offset = (minutes / 60) * 100 + minutes % 60;\n+            if (offset > 0) {\n+                result.append(\" GMT+\");\n+            } else {\n+                result.append(\" GMT-\");\n+                offset = -offset;\n+            }\n+            append0PaddedUint(result, offset, 4);\n+\n+            if (timeZoneFormatter == null)\n+                timeZoneFormatter = new SimpleDateFormat(\"zzz\");\n+\n+            // Find an equivalent year before getting the timezone\n+            // comment.  See DaylightSavingTA.\n+            if (t < 0.0 || t > 2145916800000.0) {\n+                int equiv = EquivalentYear(YearFromTime(local));\n+                double day = MakeDay(equiv, MonthFromTime(t), DateFromTime(t));\n+                t = MakeDate(day, TimeWithinDay(t));\n+             }\n+            result.append(\" (\");\n+            Date date = new Date((long) t);\n+            synchronized (timeZoneFormatter) {\n+                result.append(timeZoneFormatter.format(date));\n+            }\n+            result.append(')');\n+        }\n+        return result.toString();\n+    }\n+\n+    /* the javascript constructor */\n+    private static Object jsConstructor(Object[] args)\n+    {\n+        NativeDate obj = new NativeDate();\n+\n+        // if called as a constructor with no args,\n+        // return a new Date with the current time.\n+        if (args.length == 0) {\n+            obj.date = now();\n+            return obj;\n+        }\n+\n+        // if called with just one arg -\n+        if (args.length == 1) {\n+            Object arg0 = args[0];\n+            if (arg0 instanceof Scriptable)\n+                arg0 = ((Scriptable) arg0).getDefaultValue(null);\n+            double date;\n+            if (arg0 instanceof String) {\n+                // it's a string; parse it.\n+                date = date_parseString((String)arg0);\n+            } else {\n+                // if it's not a string, use it as a millisecond date\n+                date = ScriptRuntime.toNumber(arg0);\n+            }\n+            obj.date = TimeClip(date);\n+            return obj;\n+        }\n+\n+        double time = date_msecFromArgs(args);\n+\n+        if (!Double.isNaN(time) && !Double.isInfinite(time))\n+            time = TimeClip(internalUTC(time));\n+\n+        obj.date = time;\n+\n+        return obj;\n+    }\n+\n+    private static String toLocale_helper(double t, int methodId)\n+    {\n+        DateFormat formatter;\n+        switch (methodId) {\n+          case Id_toLocaleString:\n+            if (localeDateTimeFormatter == null) {\n+                localeDateTimeFormatter\n+                    = DateFormat.getDateTimeInstance(DateFormat.LONG,\n+                                                     DateFormat.LONG);\n+            }\n+            formatter = localeDateTimeFormatter;\n+            break;\n+          case Id_toLocaleTimeString:\n+            if (localeTimeFormatter == null) {\n+                localeTimeFormatter\n+                    = DateFormat.getTimeInstance(DateFormat.LONG);\n+            }\n+            formatter = localeTimeFormatter;\n+            break;\n+          case Id_toLocaleDateString:\n+            if (localeDateFormatter == null) {\n+                localeDateFormatter\n+                    = DateFormat.getDateInstance(DateFormat.LONG);\n+            }\n+            formatter = localeDateFormatter;\n+            break;\n+          default: throw new AssertionError(); // unreachable\n+        }\n+\n+        synchronized (formatter) {\n+            return formatter.format(new Date((long) t));\n+        }\n+    }\n+\n+    private static String js_toUTCString(double date)\n+    {\n+        StringBuffer result = new StringBuffer(60);\n+\n+        appendWeekDayName(result, WeekDay(date));\n+        result.append(\", \");\n+        append0PaddedUint(result, DateFromTime(date), 2);\n+        result.append(' ');\n+        appendMonthName(result, MonthFromTime(date));\n+        result.append(' ');\n+        int year = YearFromTime(date);\n+        if (year < 0) {\n+            result.append('-'); year = -year;\n+        }\n+        append0PaddedUint(result, year, 4);\n+        result.append(' ');\n+        append0PaddedUint(result, HourFromTime(date), 2);\n+        result.append(':');\n+        append0PaddedUint(result, MinFromTime(date), 2);\n+        result.append(':');\n+        append0PaddedUint(result, SecFromTime(date), 2);\n+        result.append(\" GMT\");\n+        return result.toString();\n+    }\n+\n+    private static void append0PaddedUint(StringBuffer sb, int i, int minWidth)\n+    {\n+        if (i < 0) Kit.codeBug();\n+        int scale = 1;\n+        --minWidth;\n+        if (i >= 10) {\n+            if (i < 1000 * 1000 * 1000) {\n+                for (;;) {\n+                    int newScale = scale * 10;\n+                    if (i < newScale) { break; }\n+                    --minWidth;\n+                    scale = newScale;\n+                }\n+            } else {\n+                // Separated case not to check against 10 * 10^9 overflow\n+                minWidth -= 9;\n+                scale = 1000 * 1000 * 1000;\n+            }\n+        }\n+        while (minWidth > 0) {\n+            sb.append('0');\n+            --minWidth;\n+        }\n+        while (scale != 1) {\n+            sb.append((char)('0' + (i / scale)));\n+            i %= scale;\n+            scale /= 10;\n+        }\n+        sb.append((char)('0' + i));\n+    }\n+\n+    private static void appendMonthName(StringBuffer sb, int index)\n+    {\n+        // Take advantage of the fact that all month abbreviations\n+        // have the same length to minimize amount of strings runtime has\n+        // to keep in memory\n+        String months = \"Jan\"+\"Feb\"+\"Mar\"+\"Apr\"+\"May\"+\"Jun\"\n+                       +\"Jul\"+\"Aug\"+\"Sep\"+\"Oct\"+\"Nov\"+\"Dec\";\n+        index *= 3;\n+        for (int i = 0; i != 3; ++i) {\n+            sb.append(months.charAt(index + i));\n+        }\n+    }\n+\n+    private static void appendWeekDayName(StringBuffer sb, int index)\n+    {\n+        String days = \"Sun\"+\"Mon\"+\"Tue\"+\"Wed\"+\"Thu\"+\"Fri\"+\"Sat\";\n+        index *= 3;\n+        for (int i = 0; i != 3; ++i) {\n+            sb.append(days.charAt(index + i));\n+        }\n+    }\n+\n+    private static double makeTime(double date, Object[] args, int methodId)\n+    {\n+        int maxargs;\n+        boolean local = true;\n+        switch (methodId) {\n+          case Id_setUTCMilliseconds:\n+              local = false;\n+            // fallthrough\n+          case Id_setMilliseconds:\n+            maxargs = 1;\n+            break;\n+\n+          case Id_setUTCSeconds:\n+              local = false;\n+            // fallthrough\n+          case Id_setSeconds:\n+            maxargs = 2;\n+            break;\n+\n+          case Id_setUTCMinutes:\n+              local = false;\n+            // fallthrough\n+          case Id_setMinutes:\n+            maxargs = 3;\n+            break;\n+\n+          case Id_setUTCHours:\n+              local = false;\n+            // fallthrough\n+          case Id_setHours:\n+            maxargs = 4;\n+            break;\n+\n+          default:\n+              Kit.codeBug();\n+            maxargs = 0;\n+        }\n+\n+        int i;\n+        double conv[] = new double[4];\n+        double hour, min, sec, msec;\n+        double lorutime; /* Local or UTC version of date */\n+\n+        double time;\n+        double result;\n+\n+        /* just return NaN if the date is already NaN */\n+        if (date != date)\n+            return date;\n+\n+        /* Satisfy the ECMA rule that if a function is called with\n+         * fewer arguments than the specified formal arguments, the\n+         * remaining arguments are set to undefined.  Seems like all\n+         * the Date.setWhatever functions in ECMA are only varargs\n+         * beyond the first argument; this should be set to undefined\n+         * if it's not given.  This means that \"d = new Date();\n+         * d.setMilliseconds()\" returns NaN.  Blech.\n+         */\n+        if (args.length == 0)\n+            args = ScriptRuntime.padArguments(args, 1);\n+\n+        for (i = 0; i < args.length && i < maxargs; i++) {\n+            conv[i] = ScriptRuntime.toNumber(args[i]);\n+\n+            // limit checks that happen in MakeTime in ECMA.\n+            if (conv[i] != conv[i] || Double.isInfinite(conv[i])) {\n+                return ScriptRuntime.NaN;\n+            }\n+            conv[i] = ScriptRuntime.toInteger(conv[i]);\n+        }\n+\n+        if (local)\n+            lorutime = LocalTime(date);\n+        else\n+            lorutime = date;\n+\n+        i = 0;\n+        int stop = args.length;\n+\n+        if (maxargs >= 4 && i < stop)\n+            hour = conv[i++];\n+        else\n+            hour = HourFromTime(lorutime);\n+\n+        if (maxargs >= 3 && i < stop)\n+            min = conv[i++];\n+        else\n+            min = MinFromTime(lorutime);\n+\n+        if (maxargs >= 2 && i < stop)\n+            sec = conv[i++];\n+        else\n+            sec = SecFromTime(lorutime);\n+\n+        if (maxargs >= 1 && i < stop)\n+            msec = conv[i++];\n+        else\n+            msec = msFromTime(lorutime);\n+\n+        time = MakeTime(hour, min, sec, msec);\n+        result = MakeDate(Day(lorutime), time);\n+\n+        if (local)\n+            result = internalUTC(result);\n+        date = TimeClip(result);\n+\n+        return date;\n+    }\n+\n+    private static double makeDate(double date, Object[] args, int methodId)\n+    {\n+        int maxargs;\n+        boolean local = true;\n+        switch (methodId) {\n+          case Id_setUTCDate:\n+              local = false;\n+            // fallthrough\n+          case Id_setDate:\n+              maxargs = 1;\n+            break;\n+\n+          case Id_setUTCMonth:\n+              local = false;\n+            // fallthrough\n+          case Id_setMonth:\n+              maxargs = 2;\n+            break;\n+\n+          case Id_setUTCFullYear:\n+              local = false;\n+            // fallthrough\n+          case Id_setFullYear:\n+              maxargs = 3;\n+            break;\n+\n+          default:\n+              Kit.codeBug();\n+            maxargs = 0;\n+        }\n+\n+        int i;\n+        double conv[] = new double[3];\n+        double year, month, day;\n+        double lorutime; /* local or UTC version of date */\n+        double result;\n+\n+        /* See arg padding comment in makeTime.*/\n+        if (args.length == 0)\n+            args = ScriptRuntime.padArguments(args, 1);\n+\n+        for (i = 0; i < args.length && i < maxargs; i++) {\n+            conv[i] = ScriptRuntime.toNumber(args[i]);\n+\n+            // limit checks that happen in MakeDate in ECMA.\n+            if (conv[i] != conv[i] || Double.isInfinite(conv[i])) {\n+                return ScriptRuntime.NaN;\n+            }\n+            conv[i] = ScriptRuntime.toInteger(conv[i]);\n+        }\n+\n+        /* return NaN if date is NaN and we're not setting the year,\n+         * If we are, use 0 as the time. */\n+        if (date != date) {\n+            if (args.length < 3) {\n+                return ScriptRuntime.NaN;\n+            } else {\n+                lorutime = 0;\n+            }\n+        } else {\n+            if (local)\n+                lorutime = LocalTime(date);\n+            else\n+                lorutime = date;\n+        }\n+\n+        i = 0;\n+        int stop = args.length;\n+\n+        if (maxargs >= 3 && i < stop)\n+            year = conv[i++];\n+        else\n+            year = YearFromTime(lorutime);\n+\n+        if (maxargs >= 2 && i < stop)\n+            month = conv[i++];\n+        else\n+            month = MonthFromTime(lorutime);\n+\n+        if (maxargs >= 1 && i < stop)\n+            day = conv[i++];\n+        else\n+            day = DateFromTime(lorutime);\n+\n+        day = MakeDay(year, month, day); /* day within year */\n+        result = MakeDate(day, TimeWithinDay(lorutime));\n+\n+        if (local)\n+            result = internalUTC(result);\n+\n+        date = TimeClip(result);\n+\n+        return date;\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2009-07-22 05:44:02 EST\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 6: c=s.charAt(0);\n+                if (c=='g') { X=\"getDay\";id=Id_getDay; }\n+                else if (c=='t') { X=\"toJSON\";id=Id_toJSON; }\n+                break L;\n+            case 7: switch (s.charAt(3)) {\n+                case 'D': c=s.charAt(0);\n+                    if (c=='g') { X=\"getDate\";id=Id_getDate; }\n+                    else if (c=='s') { X=\"setDate\";id=Id_setDate; }\n+                    break L;\n+                case 'T': c=s.charAt(0);\n+                    if (c=='g') { X=\"getTime\";id=Id_getTime; }\n+                    else if (c=='s') { X=\"setTime\";id=Id_setTime; }\n+                    break L;\n+                case 'Y': c=s.charAt(0);\n+                    if (c=='g') { X=\"getYear\";id=Id_getYear; }\n+                    else if (c=='s') { X=\"setYear\";id=Id_setYear; }\n+                    break L;\n+                case 'u': X=\"valueOf\";id=Id_valueOf; break L;\n+                } break L;\n+            case 8: switch (s.charAt(3)) {\n+                case 'H': c=s.charAt(0);\n+                    if (c=='g') { X=\"getHours\";id=Id_getHours; }\n+                    else if (c=='s') { X=\"setHours\";id=Id_setHours; }\n+                    break L;\n+                case 'M': c=s.charAt(0);\n+                    if (c=='g') { X=\"getMonth\";id=Id_getMonth; }\n+                    else if (c=='s') { X=\"setMonth\";id=Id_setMonth; }\n+                    break L;\n+                case 'o': X=\"toSource\";id=Id_toSource; break L;\n+                case 't': X=\"toString\";id=Id_toString; break L;\n+                } break L;\n+            case 9: X=\"getUTCDay\";id=Id_getUTCDay; break L;\n+            case 10: c=s.charAt(3);\n+                if (c=='M') {\n+                    c=s.charAt(0);\n+                    if (c=='g') { X=\"getMinutes\";id=Id_getMinutes; }\n+                    else if (c=='s') { X=\"setMinutes\";id=Id_setMinutes; }\n+                }\n+                else if (c=='S') {\n+                    c=s.charAt(0);\n+                    if (c=='g') { X=\"getSeconds\";id=Id_getSeconds; }\n+                    else if (c=='s') { X=\"setSeconds\";id=Id_setSeconds; }\n+                }\n+                else if (c=='U') {\n+                    c=s.charAt(0);\n+                    if (c=='g') { X=\"getUTCDate\";id=Id_getUTCDate; }\n+                    else if (c=='s') { X=\"setUTCDate\";id=Id_setUTCDate; }\n+                }\n+                break L;\n+            case 11: switch (s.charAt(3)) {\n+                case 'F': c=s.charAt(0);\n+                    if (c=='g') { X=\"getFullYear\";id=Id_getFullYear; }\n+                    else if (c=='s') { X=\"setFullYear\";id=Id_setFullYear; }\n+                    break L;\n+                case 'M': X=\"toGMTString\";id=Id_toGMTString; break L;\n+                case 'S': X=\"toISOString\";id=Id_toISOString; break L;\n+                case 'T': X=\"toUTCString\";id=Id_toUTCString; break L;\n+                case 'U': c=s.charAt(0);\n+                    if (c=='g') {\n+                        c=s.charAt(9);\n+                        if (c=='r') { X=\"getUTCHours\";id=Id_getUTCHours; }\n+                        else if (c=='t') { X=\"getUTCMonth\";id=Id_getUTCMonth; }\n+                    }\n+                    else if (c=='s') {\n+                        c=s.charAt(9);\n+                        if (c=='r') { X=\"setUTCHours\";id=Id_setUTCHours; }\n+                        else if (c=='t') { X=\"setUTCMonth\";id=Id_setUTCMonth; }\n+                    }\n+                    break L;\n+                case 's': X=\"constructor\";id=Id_constructor; break L;\n+                } break L;\n+            case 12: c=s.charAt(2);\n+                if (c=='D') { X=\"toDateString\";id=Id_toDateString; }\n+                else if (c=='T') { X=\"toTimeString\";id=Id_toTimeString; }\n+                break L;\n+            case 13: c=s.charAt(0);\n+                if (c=='g') {\n+                    c=s.charAt(6);\n+                    if (c=='M') { X=\"getUTCMinutes\";id=Id_getUTCMinutes; }\n+                    else if (c=='S') { X=\"getUTCSeconds\";id=Id_getUTCSeconds; }\n+                }\n+                else if (c=='s') {\n+                    c=s.charAt(6);\n+                    if (c=='M') { X=\"setUTCMinutes\";id=Id_setUTCMinutes; }\n+                    else if (c=='S') { X=\"setUTCSeconds\";id=Id_setUTCSeconds; }\n+                }\n+                break L;\n+            case 14: c=s.charAt(0);\n+                if (c=='g') { X=\"getUTCFullYear\";id=Id_getUTCFullYear; }\n+                else if (c=='s') { X=\"setUTCFullYear\";id=Id_setUTCFullYear; }\n+                else if (c=='t') { X=\"toLocaleString\";id=Id_toLocaleString; }\n+                break L;\n+            case 15: c=s.charAt(0);\n+                if (c=='g') { X=\"getMilliseconds\";id=Id_getMilliseconds; }\n+                else if (c=='s') { X=\"setMilliseconds\";id=Id_setMilliseconds; }\n+                break L;\n+            case 17: X=\"getTimezoneOffset\";id=Id_getTimezoneOffset; break L;\n+            case 18: c=s.charAt(0);\n+                if (c=='g') { X=\"getUTCMilliseconds\";id=Id_getUTCMilliseconds; }\n+                else if (c=='s') { X=\"setUTCMilliseconds\";id=Id_setUTCMilliseconds; }\n+                else if (c=='t') {\n+                    c=s.charAt(8);\n+                    if (c=='D') { X=\"toLocaleDateString\";id=Id_toLocaleDateString; }\n+                    else if (c=='T') { X=\"toLocaleTimeString\";id=Id_toLocaleTimeString; }\n+                }\n+                break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        ConstructorId_now       = -3,\n+        ConstructorId_parse     = -2,\n+        ConstructorId_UTC       = -1,\n+\n+        Id_constructor          =  1,\n+        Id_toString             =  2,\n+        Id_toTimeString         =  3,\n+        Id_toDateString         =  4,\n+        Id_toLocaleString       =  5,\n+        Id_toLocaleTimeString   =  6,\n+        Id_toLocaleDateString   =  7,\n+        Id_toUTCString          =  8,\n+        Id_toSource             =  9,\n+        Id_valueOf              = 10,\n+        Id_getTime              = 11,\n+        Id_getYear              = 12,\n+        Id_getFullYear          = 13,\n+        Id_getUTCFullYear       = 14,\n+        Id_getMonth             = 15,\n+        Id_getUTCMonth          = 16,\n+        Id_getDate              = 17,\n+        Id_getUTCDate           = 18,\n+        Id_getDay               = 19,\n+        Id_getUTCDay            = 20,\n+        Id_getHours             = 21,\n+        Id_getUTCHours          = 22,\n+        Id_getMinutes           = 23,\n+        Id_getUTCMinutes        = 24,\n+        Id_getSeconds           = 25,\n+        Id_getUTCSeconds        = 26,\n+        Id_getMilliseconds      = 27,\n+        Id_getUTCMilliseconds   = 28,\n+        Id_getTimezoneOffset    = 29,\n+        Id_setTime              = 30,\n+        Id_setMilliseconds      = 31,\n+        Id_setUTCMilliseconds   = 32,\n+        Id_setSeconds           = 33,\n+        Id_setUTCSeconds        = 34,\n+        Id_setMinutes           = 35,\n+        Id_setUTCMinutes        = 36,\n+        Id_setHours             = 37,\n+        Id_setUTCHours          = 38,\n+        Id_setDate              = 39,\n+        Id_setUTCDate           = 40,\n+        Id_setMonth             = 41,\n+        Id_setUTCMonth          = 42,\n+        Id_setFullYear          = 43,\n+        Id_setUTCFullYear       = 44,\n+        Id_setYear              = 45,\n+        Id_toISOString          = 46,\n+        Id_toJSON               = 47,\n+\n+        MAX_PROTOTYPE_ID        = Id_toJSON;\n+\n+    private static final int\n+        Id_toGMTString  =  Id_toUTCString; // Alias, see Ecma B.2.6\n+// #/string_id_map#\n+\n+    /* cached values */\n+    private static TimeZone thisTimeZone;\n+    private static double LocalTZA;\n+    private static DateFormat timeZoneFormatter;\n+    private static DateFormat localeDateTimeFormatter;\n+    private static DateFormat localeDateFormatter;\n+    private static DateFormat localeTimeFormatter;\n+\n+    private double date;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeError.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ *\n+ * The class of error objects\n+ *\n+ *  ECMA 15.11\n+ */\n+final class NativeError extends IdScriptableObject\n+{\n+    static final long serialVersionUID = -5338413581437645187L;\n+\n+    private static final Object ERROR_TAG = \"Error\";\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeError obj = new NativeError();\n+        ScriptableObject.putProperty(obj, \"name\", \"Error\");\n+        ScriptableObject.putProperty(obj, \"message\", \"\");\n+        ScriptableObject.putProperty(obj, \"fileName\", \"\");\n+        ScriptableObject.putProperty(obj, \"lineNumber\", Integer.valueOf(0));\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    static NativeError make(Context cx, Scriptable scope,\n+                            IdFunctionObject ctorObj, Object[] args)\n+    {\n+        Scriptable proto = (Scriptable)(ctorObj.get(\"prototype\", ctorObj));\n+\n+        NativeError obj = new NativeError();\n+        obj.setPrototype(proto);\n+        obj.setParentScope(scope);\n+\n+        int arglen = args.length;\n+        if (arglen >= 1) {\n+            ScriptableObject.putProperty(obj, \"message\",\n+                    ScriptRuntime.toString(args[0]));\n+            if (arglen >= 2) {\n+                ScriptableObject.putProperty(obj, \"fileName\", args[1]);\n+                if (arglen >= 3) {\n+                    int line = ScriptRuntime.toInt32(args[2]);\n+                    ScriptableObject.putProperty(obj, \"lineNumber\",\n+                            Integer.valueOf(line));\n+                }\n+            }\n+        }\n+        if(arglen < 3 && cx.hasFeature(Context.FEATURE_LOCATION_INFORMATION_IN_ERROR)) {\n+            // Fill in fileName and lineNumber automatically when not specified\n+            // explicitly, see Bugzilla issue #342807\n+            int[] linep = new int[1];\n+            String fileName = Context.getSourcePositionFromStack(linep);\n+            ScriptableObject.putProperty(obj, \"lineNumber\", \n+                    Integer.valueOf(linep[0]));\n+            if(arglen < 2) {\n+                ScriptableObject.putProperty(obj, \"fileName\", fileName);\n+            }\n+        }\n+        return obj;\n+    }\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"Error\";\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return js_toString(this);\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor: arity=1; s=\"constructor\"; break;\n+          case Id_toString:    arity=0; s=\"toString\";    break;\n+          case Id_toSource:    arity=0; s=\"toSource\";    break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(ERROR_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(ERROR_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_constructor:\n+            return make(cx, scope, f, args);\n+\n+          case Id_toString:\n+            return js_toString(thisObj);\n+\n+          case Id_toSource:\n+            return js_toSource(cx, scope, thisObj);\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private static String js_toString(Scriptable thisObj)\n+    {\n+        return getString(thisObj, \"name\")+\": \"+getString(thisObj, \"message\");\n+    }\n+\n+    private static String js_toSource(Context cx, Scriptable scope,\n+                                      Scriptable thisObj)\n+    {\n+        // Emulation of SpiderMonkey behavior\n+        Object name = ScriptableObject.getProperty(thisObj, \"name\");\n+        Object message = ScriptableObject.getProperty(thisObj, \"message\");\n+        Object fileName = ScriptableObject.getProperty(thisObj, \"fileName\");\n+        Object lineNumber = ScriptableObject.getProperty(thisObj, \"lineNumber\");\n+\n+        StringBuffer sb = new StringBuffer();\n+        sb.append(\"(new \");\n+        if (name == NOT_FOUND) {\n+            name = Undefined.instance;\n+        }\n+        sb.append(ScriptRuntime.toString(name));\n+        sb.append(\"(\");\n+        if (message != NOT_FOUND\n+            || fileName != NOT_FOUND\n+            || lineNumber != NOT_FOUND)\n+        {\n+            if (message == NOT_FOUND) {\n+                message = \"\";\n+            }\n+            sb.append(ScriptRuntime.uneval(cx, scope, message));\n+            if (fileName != NOT_FOUND || lineNumber != NOT_FOUND) {\n+                sb.append(\", \");\n+                if (fileName == NOT_FOUND) {\n+                    fileName = \"\";\n+                }\n+                sb.append(ScriptRuntime.uneval(cx, scope, fileName));\n+                if (lineNumber != NOT_FOUND) {\n+                    int line = ScriptRuntime.toInt32(lineNumber);\n+                    if (line != 0) {\n+                        sb.append(\", \");\n+                        sb.append(ScriptRuntime.toString(line));\n+                    }\n+                }\n+            }\n+        }\n+        sb.append(\"))\");\n+        return sb.toString();\n+    }\n+\n+    private static String getString(Scriptable obj, String id)\n+    {\n+        Object value = ScriptableObject.getProperty(obj, id);\n+        if (value == NOT_FOUND) return \"\";\n+        return ScriptRuntime.toString(value);\n+    }\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #string_id_map#\n+// #generated# Last update: 2007-05-09 08:15:45 EDT\n+        L0: { id = 0; String X = null; int c;\n+            int s_length = s.length();\n+            if (s_length==8) {\n+                c=s.charAt(3);\n+                if (c=='o') { X=\"toSource\";id=Id_toSource; }\n+                else if (c=='t') { X=\"toString\";id=Id_toString; }\n+            }\n+            else if (s_length==11) { X=\"constructor\";id=Id_constructor; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_constructor    = 1,\n+        Id_toString       = 2,\n+        Id_toSource       = 3,\n+\n+        MAX_PROTOTYPE_ID  = 3;\n+\n+// #/string_id_map#\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeFunction.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Bob Jervis\n+ *   Roger Lawrence\n+ *   Mike McCabe\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.javascript.debug.DebuggableScript;\n+\n+/**\n+ * This class implements the Function native object.\n+ * See ECMA 15.3.\n+ */\n+public abstract class NativeFunction extends BaseFunction\n+{\n+\n+    public final void initScriptFunction(Context cx, Scriptable scope)\n+    {\n+        ScriptRuntime.setFunctionProtoAndParent(this, scope);\n+    }\n+\n+    /**\n+     * @param indent How much to indent the decompiled result\n+     *\n+     * @param flags Flags specifying format of decompilation output\n+     */\n+    @Override\n+    final String decompile(int indent, int flags)\n+    {\n+        String encodedSource = getEncodedSource();\n+        if (encodedSource == null) {\n+            return super.decompile(indent, flags);\n+        } else {\n+            UintMap properties = new UintMap(1);\n+            properties.put(Decompiler.INITIAL_INDENT_PROP, indent);\n+            return Decompiler.decompile(encodedSource, flags, properties);\n+        }\n+    }\n+\n+    @Override\n+    public int getLength()\n+    {\n+        int paramCount = getParamCount();\n+        if (getLanguageVersion() != Context.VERSION_1_2) {\n+            return paramCount;\n+        }\n+        Context cx = Context.getContext();\n+        NativeCall activation = ScriptRuntime.findFunctionActivation(cx, this);\n+        if (activation == null) {\n+            return paramCount;\n+        }\n+        return activation.originalArgs.length;\n+    }\n+\n+    @Override\n+    public int getArity()\n+    {\n+        return getParamCount();\n+    }\n+\n+    /**\n+     * @deprecated Use {@link BaseFunction#getFunctionName()} instead.\n+     * For backwards compatibility keep an old method name used by\n+     * Batik and possibly others.\n+     */\n+    public String jsGet_name()\n+    {\n+        return getFunctionName();\n+    }\n+\n+    /**\n+     * Get encoded source string.\n+     */\n+    public String getEncodedSource()\n+    {\n+        return null;\n+    }\n+\n+    public DebuggableScript getDebuggableView()\n+    {\n+        return null;\n+    }\n+\n+    /**\n+     * Resume execution of a suspended generator.\n+     * @param cx The current context\n+     * @param scope Scope for the parent generator function\n+     * @param operation The resumption operation (next, send, etc.. )\n+     * @param state The generator state (has locals, stack, etc.)\n+     * @param value The return value of yield (if required).\n+     * @return The next yielded value (if any)\n+     */\n+    public Object resumeGenerator(Context cx, Scriptable scope,\n+                                  int operation, Object state, Object value)\n+    {\n+        throw new EvaluatorException(\"resumeGenerator() not implemented\");\n+    }\n+\n+\n+    protected abstract int getLanguageVersion();\n+\n+    /**\n+     * Get number of declared parameters. It should be 0 for scripts.\n+     */\n+    protected abstract int getParamCount();\n+\n+    /**\n+     * Get number of declared parameters and variables defined through var\n+     * statements.\n+     */\n+    protected abstract int getParamAndVarCount();\n+\n+    /**\n+     * Get parameter or variable name.\n+     * If <tt>index < {@link #getParamCount()}</tt>, then return the name of the\n+     * corresponding parameter. Otherwise return the name of variable.\n+     */\n+    protected abstract String getParamOrVarName(int index);\n+\n+    /**\n+     * Get parameter or variable const-ness.\n+     * If <tt>index < {@link #getParamCount()}</tt>, then return the const-ness\n+     * of the corresponding parameter. Otherwise return whether the variable is\n+     * const.\n+     */\n+    protected boolean getParamOrVarConst(int index)\n+    {\n+        // By default return false to preserve compatibility with existing\n+        // classes subclassing this class, which are mostly generated by jsc\n+        // from earlier Rhino versions. See Bugzilla #396117.\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeGenerator.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class implements generator objects. See\n+ * http://developer.mozilla.org/en/docs/New_in_JavaScript_1.7#Generators\n+ *\n+ */\n+public final class NativeGenerator extends IdScriptableObject {\n+    private static final long serialVersionUID = 1645892441041347273L;\n+\n+    private static final Object GENERATOR_TAG = \"Generator\";\n+\n+    static NativeGenerator init(ScriptableObject scope, boolean sealed) {\n+        // Generator\n+        // Can't use \"NativeGenerator().exportAsJSClass\" since we don't want\n+        // to define \"Generator\" as a constructor in the top-level scope.\n+\n+        NativeGenerator prototype = new NativeGenerator();\n+        if (scope != null) {\n+            prototype.setParentScope(scope);\n+            prototype.setPrototype(getObjectPrototype(scope));\n+        }\n+        prototype.activatePrototypeMap(MAX_PROTOTYPE_ID);\n+        if (sealed) {\n+            prototype.sealObject();\n+        }\n+\n+        // Need to access Generator prototype when constructing\n+        // Generator instances, but don't have a generator constructor\n+        // to use to find the prototype. Use the \"associateValue\"\n+        // approach instead.\n+        if (scope != null) {\n+            scope.associateValue(GENERATOR_TAG, prototype);\n+        }\n+\n+        return prototype;\n+    }\n+\n+    /**\n+     * Only for constructing the prototype object.\n+     */\n+    private NativeGenerator() { }\n+\n+    public NativeGenerator(Scriptable scope, NativeFunction function,\n+                           Object savedState)\n+    {\n+        this.function = function;\n+        this.savedState = savedState;\n+        // Set parent and prototype properties. Since we don't have a\n+        // \"Generator\" constructor in the top scope, we stash the\n+        // prototype in the top scope's associated value.\n+        Scriptable top = ScriptableObject.getTopLevelScope(scope);\n+        this.setParentScope(top);\n+        NativeGenerator prototype = (NativeGenerator)\n+            ScriptableObject.getTopScopeValue(top, GENERATOR_TAG);\n+        this.setPrototype(prototype);\n+    }\n+\n+    public static final int GENERATOR_SEND  = 0,\n+                            GENERATOR_THROW = 1,\n+                            GENERATOR_CLOSE = 2;\n+\n+    @Override\n+    public String getClassName() {\n+        return \"Generator\";\n+    }\n+\n+    /**\n+     * Close the generator if it is still open.\n+     */\n+    @Override\n+    protected void finalize() throws Throwable {\n+        if (savedState != null) {\n+            // This is a little tricky since we are most likely running in\n+            // a different thread. We need to get a Context to run this, and\n+            // we must call \"doTopCall\" since this will likely be the outermost\n+            // JavaScript frame on this thread.\n+            Context cx = Context.getCurrentContext();\n+            ContextFactory factory = cx != null ? cx.getFactory()\n+                                                : ContextFactory.getGlobal();\n+            factory.call(new CloseGeneratorAction(this));\n+        }\n+    }\n+\n+    private static class CloseGeneratorAction implements ContextAction {\n+        private NativeGenerator generator;\n+\n+        CloseGeneratorAction(NativeGenerator generator) {\n+            this.generator = generator;\n+        }\n+\n+        public Object run(Context cx) {\n+            Scriptable scope = ScriptableObject.getTopLevelScope(generator);\n+            Callable closeGenerator = new Callable() {\n+                public Object call(Context cx, Scriptable scope,\n+                                   Scriptable thisObj, Object[] args) {\n+                     return ((NativeGenerator)thisObj).resume(cx, scope,\n+                             GENERATOR_CLOSE, new GeneratorClosedException());\n+                }\n+            };\n+            return ScriptRuntime.doTopCall(closeGenerator, cx, scope,\n+                                           generator, null);\n+        }\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id) {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_close:          arity=1; s=\"close\";          break;\n+          case Id_next:           arity=1; s=\"next\";           break;\n+          case Id_send:           arity=0; s=\"send\";           break;\n+          case Id_throw:          arity=0; s=\"throw\";          break;\n+          case Id___iterator__:   arity=1; s=\"__iterator__\";   break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(GENERATOR_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(GENERATOR_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+\n+        if (!(thisObj instanceof NativeGenerator))\n+            throw incompatibleCallError(f);\n+\n+        NativeGenerator generator = (NativeGenerator) thisObj;\n+\n+        switch (id) {\n+\n+          case Id_close:\n+            // need to run any pending finally clauses\n+            return generator.resume(cx, scope, GENERATOR_CLOSE,\n+                                    new GeneratorClosedException());\n+\n+          case Id_next:\n+            // arguments to next() are ignored\n+            generator.firstTime = false;\n+            return generator.resume(cx, scope, GENERATOR_SEND,\n+                                    Undefined.instance);\n+\n+          case Id_send: {\n+            Object arg = args.length > 0 ? args[0] : Undefined.instance;\n+            if (generator.firstTime && !arg.equals(Undefined.instance)) {\n+                throw ScriptRuntime.typeError0(\"msg.send.newborn\");\n+            }\n+            return generator.resume(cx, scope, GENERATOR_SEND, arg);\n+          }\n+\n+          case Id_throw:\n+            return generator.resume(cx, scope, GENERATOR_THROW,\n+                args.length > 0 ? args[0] : Undefined.instance);\n+\n+          case Id___iterator__:\n+            return thisObj;\n+\n+          default:\n+            throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+    }\n+\n+    private Object resume(Context cx, Scriptable scope, int operation,\n+                          Object value)\n+    {\n+        if (savedState == null) {\n+            if (operation == GENERATOR_CLOSE)\n+                return Undefined.instance;\n+            Object thrown;\n+            if (operation == GENERATOR_THROW) {\n+                thrown = value;\n+            } else {\n+                thrown = NativeIterator.getStopIterationObject(scope);\n+            }\n+            throw new JavaScriptException(thrown, lineSource, lineNumber);\n+        }\n+        try {\n+            synchronized (this) {\n+              // generator execution is necessarily single-threaded and\n+              // non-reentrant.\n+              // See https://bugzilla.mozilla.org/show_bug.cgi?id=349263\n+              if (locked)\n+                  throw ScriptRuntime.typeError0(\"msg.already.exec.gen\");\n+              locked = true;\n+            }\n+            return function.resumeGenerator(cx, scope, operation, savedState,\n+                                            value);\n+        } catch (GeneratorClosedException e) {\n+            // On closing a generator in the compile path, the generator\n+            // throws a special exception. This ensures execution of all pending\n+            // finalizers and will not get caught by user code.\n+            return Undefined.instance;\n+        } catch (RhinoException e) {\n+            lineNumber = e.lineNumber();\n+            lineSource = e.lineSource();\n+            savedState = null;\n+            throw e;\n+        } finally {\n+            synchronized (this) {\n+              locked = false;\n+            }\n+            if (operation == GENERATOR_CLOSE)\n+                savedState = null;\n+        }\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s) {\n+        int id;\n+// #generated# Last update: 2007-06-14 13:13:03 EDT\n+        L0: { id = 0; String X = null; int c;\n+            int s_length = s.length();\n+            if (s_length==4) {\n+                c=s.charAt(0);\n+                if (c=='n') { X=\"next\";id=Id_next; }\n+                else if (c=='s') { X=\"send\";id=Id_send; }\n+            }\n+            else if (s_length==5) {\n+                c=s.charAt(0);\n+                if (c=='c') { X=\"close\";id=Id_close; }\n+                else if (c=='t') { X=\"throw\";id=Id_throw; }\n+            }\n+            else if (s_length==12) { X=\"__iterator__\";id=Id___iterator__; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_close                 = 1,\n+        Id_next                  = 2,\n+        Id_send                  = 3,\n+        Id_throw                 = 4,\n+        Id___iterator__          = 5,\n+        MAX_PROTOTYPE_ID         = 5;\n+\n+// #/string_id_map#\n+    private NativeFunction function;\n+    private Object savedState;\n+    private String lineSource;\n+    private int lineNumber;\n+    private boolean firstTime = true;\n+    private boolean locked;\n+\n+    public static class GeneratorClosedException extends RuntimeException {\n+        private static final long serialVersionUID = 2561315658662379681L;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeGlobal.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Mike McCabe\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.Serializable;\n+\n+import org.mozilla.javascript.xml.XMLLib;\n+import static org.mozilla.javascript.ScriptableObject.DONTENUM;\n+import static org.mozilla.javascript.ScriptableObject.READONLY;\n+import static org.mozilla.javascript.ScriptableObject.PERMANENT;\n+\n+/**\n+ * This class implements the global native object (function and value\n+ * properties only).\n+ *\n+ * See ECMA 15.1.[12].\n+ *\n+ */\n+\n+public class NativeGlobal implements Serializable, IdFunctionCall\n+{\n+    static final long serialVersionUID = 6080442165748707530L;\n+\n+    public static void init(Context cx, Scriptable scope, boolean sealed) {\n+        NativeGlobal obj = new NativeGlobal();\n+\n+        for (int id = 1; id <= LAST_SCOPE_FUNCTION_ID; ++id) {\n+            String name;\n+            int arity = 1;\n+            switch (id) {\n+              case Id_decodeURI:\n+                name = \"decodeURI\";\n+                break;\n+              case Id_decodeURIComponent:\n+                name = \"decodeURIComponent\";\n+                break;\n+              case Id_encodeURI:\n+                name = \"encodeURI\";\n+                break;\n+              case Id_encodeURIComponent:\n+                name = \"encodeURIComponent\";\n+                break;\n+              case Id_escape:\n+                name = \"escape\";\n+                break;\n+              case Id_eval:\n+                name = \"eval\";\n+                break;\n+              case Id_isFinite:\n+                name = \"isFinite\";\n+                break;\n+              case Id_isNaN:\n+                name = \"isNaN\";\n+                break;\n+              case Id_isXMLName:\n+                name = \"isXMLName\";\n+                break;\n+              case Id_parseFloat:\n+                name = \"parseFloat\";\n+                break;\n+              case Id_parseInt:\n+                name = \"parseInt\";\n+                arity = 2;\n+                break;\n+              case Id_unescape:\n+                name = \"unescape\";\n+                break;\n+              case Id_uneval:\n+                name = \"uneval\";\n+                break;\n+              default:\n+                  throw Kit.codeBug();\n+            }\n+            IdFunctionObject f = new IdFunctionObject(obj, FTAG, id, name,\n+                                                      arity, scope);\n+            if (sealed) {\n+                f.sealObject();\n+            }\n+            f.exportAsScopeProperty();\n+        }\n+\n+        ScriptableObject.defineProperty(\n+            scope, \"NaN\", ScriptRuntime.NaNobj,\n+            READONLY|DONTENUM|PERMANENT);\n+        ScriptableObject.defineProperty(\n+            scope, \"Infinity\",\n+            ScriptRuntime.wrapNumber(Double.POSITIVE_INFINITY),\n+            READONLY|DONTENUM|PERMANENT);\n+        ScriptableObject.defineProperty(\n+            scope, \"undefined\", Undefined.instance,\n+            READONLY|DONTENUM|PERMANENT);\n+\n+        String[] errorMethods = {\n+                \"ConversionError\",\n+                \"EvalError\",\n+                \"RangeError\",\n+                \"ReferenceError\",\n+                \"SyntaxError\",\n+                \"TypeError\",\n+                \"URIError\",\n+                \"InternalError\",\n+                \"JavaException\"\n+        };\n+\n+        /*\n+            Each error constructor gets its own Error object as a prototype,\n+            with the 'name' property set to the name of the error.\n+        */\n+        for (int i = 0; i < errorMethods.length; i++) {\n+            String name = errorMethods[i];\n+            ScriptableObject errorProto =\n+              (ScriptableObject) ScriptRuntime.newObject(cx, scope, \"Error\",\n+                                                  ScriptRuntime.emptyArgs);\n+            errorProto.put(\"name\", errorProto, name);\n+            errorProto.put(\"message\", errorProto, \"\");\n+            IdFunctionObject ctor = new IdFunctionObject(obj, FTAG,\n+                                                         Id_new_CommonError,\n+                                                         name, 1, scope);\n+            ctor.markAsConstructor(errorProto);\n+            errorProto.put(\"constructor\", errorProto, ctor);\n+            errorProto.setAttributes(\"constructor\", ScriptableObject.DONTENUM);\n+            if (sealed) {\n+                errorProto.sealObject();\n+                ctor.sealObject();\n+            }\n+            ctor.exportAsScopeProperty();\n+        }\n+    }\n+\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (f.hasTag(FTAG)) {\n+            int methodId = f.methodId();\n+            switch (methodId) {\n+                case Id_decodeURI:\n+                case Id_decodeURIComponent: {\n+                    String str = ScriptRuntime.toString(args, 0);\n+                    return decode(str, methodId == Id_decodeURI);\n+                }\n+\n+                case Id_encodeURI:\n+                case Id_encodeURIComponent: {\n+                    String str = ScriptRuntime.toString(args, 0);\n+                    return encode(str, methodId == Id_encodeURI);\n+                }\n+\n+                case Id_escape:\n+                    return js_escape(args);\n+\n+                case Id_eval:\n+                    return js_eval(cx, scope, args);\n+\n+                case Id_isFinite: {\n+                    boolean result;\n+                    if (args.length < 1) {\n+                        result = false;\n+                    } else {\n+                        double d = ScriptRuntime.toNumber(args[0]);\n+                        result = (d == d\n+                                  && d != Double.POSITIVE_INFINITY\n+                                  && d != Double.NEGATIVE_INFINITY);\n+                    }\n+                    return ScriptRuntime.wrapBoolean(result);\n+                }\n+\n+                case Id_isNaN: {\n+                    // The global method isNaN, as per ECMA-262 15.1.2.6.\n+                    boolean result;\n+                    if (args.length < 1) {\n+                        result = true;\n+                    } else {\n+                        double d = ScriptRuntime.toNumber(args[0]);\n+                        result = (d != d);\n+                    }\n+                    return ScriptRuntime.wrapBoolean(result);\n+                }\n+\n+                case Id_isXMLName: {\n+                    Object name = (args.length == 0)\n+                                  ? Undefined.instance : args[0];\n+                    XMLLib xmlLib = XMLLib.extractFromScope(scope);\n+                    return ScriptRuntime.wrapBoolean(\n+                        xmlLib.isXMLName(cx, name));\n+                }\n+\n+                case Id_parseFloat:\n+                    return js_parseFloat(args);\n+\n+                case Id_parseInt:\n+                    return js_parseInt(args);\n+\n+                case Id_unescape:\n+                    return js_unescape(args);\n+\n+                case Id_uneval: {\n+                    Object value = (args.length != 0)\n+                                   ? args[0] : Undefined.instance;\n+                    return ScriptRuntime.uneval(cx, scope, value);\n+                }\n+\n+                case Id_new_CommonError:\n+                    // The implementation of all the ECMA error constructors\n+                    // (SyntaxError, TypeError, etc.)\n+                    return NativeError.make(cx, scope, f, args);\n+            }\n+        }\n+        throw f.unknown();\n+    }\n+\n+    /**\n+     * The global method parseInt, as per ECMA-262 15.1.2.2.\n+     */\n+    private Object js_parseInt(Object[] args) {\n+        String s = ScriptRuntime.toString(args, 0);\n+        int radix = ScriptRuntime.toInt32(args, 1);\n+\n+        int len = s.length();\n+        if (len == 0)\n+            return ScriptRuntime.NaNobj;\n+\n+        boolean negative = false;\n+        int start = 0;\n+        char c;\n+        do {\n+            c = s.charAt(start);\n+            if (!ScriptRuntime.isStrWhiteSpaceChar(c))\n+                break;\n+            start++;\n+        } while (start < len);\n+\n+        if (c == '+' || (negative = (c == '-')))\n+            start++;\n+\n+        final int NO_RADIX = -1;\n+        if (radix == 0) {\n+            radix = NO_RADIX;\n+        } else if (radix < 2 || radix > 36) {\n+            return ScriptRuntime.NaNobj;\n+        } else if (radix == 16 && len - start > 1 && s.charAt(start) == '0') {\n+            c = s.charAt(start+1);\n+            if (c == 'x' || c == 'X')\n+                start += 2;\n+        }\n+\n+        if (radix == NO_RADIX) {\n+            radix = 10;\n+            if (len - start > 1 && s.charAt(start) == '0') {\n+                c = s.charAt(start+1);\n+                if (c == 'x' || c == 'X') {\n+                    radix = 16;\n+                    start += 2;\n+                } else if ('0' <= c && c <= '9') {\n+                    radix = 8;\n+                    start++;\n+                }\n+            }\n+        }\n+\n+        double d = ScriptRuntime.stringToNumber(s, start, radix);\n+        return ScriptRuntime.wrapNumber(negative ? -d : d);\n+    }\n+\n+    /**\n+     * The global method parseFloat, as per ECMA-262 15.1.2.3.\n+     *\n+     * @param args the arguments to parseFloat, ignoring args[>=1]\n+     */\n+    private Object js_parseFloat(Object[] args)\n+    {\n+        if (args.length < 1)\n+            return ScriptRuntime.NaNobj;\n+\n+        String s = ScriptRuntime.toString(args[0]);\n+        int len = s.length();\n+        int start = 0;\n+        // Scan forward to skip whitespace\n+        char c;\n+        for (;;) {\n+            if (start == len) {\n+                return ScriptRuntime.NaNobj;\n+            }\n+            c = s.charAt(start);\n+            if (!ScriptRuntime.isStrWhiteSpaceChar(c)) {\n+                break;\n+            }\n+            ++start;\n+        }\n+\n+        int i = start;\n+        if (c == '+' || c == '-') {\n+            ++i;\n+            if (i == len) {\n+                return ScriptRuntime.NaNobj;\n+            }\n+            c = s.charAt(i);\n+        }\n+\n+        if (c == 'I') {\n+            // check for \"Infinity\"\n+            if (i+8 <= len && s.regionMatches(i, \"Infinity\", 0, 8)) {\n+                double d;\n+                if (s.charAt(start) == '-') {\n+                    d = Double.NEGATIVE_INFINITY;\n+                } else {\n+                    d = Double.POSITIVE_INFINITY;\n+                }\n+                return ScriptRuntime.wrapNumber(d);\n+            }\n+            return ScriptRuntime.NaNobj;\n+        }\n+\n+        // Find the end of the legal bit\n+        int decimal = -1;\n+        int exponent = -1;\n+        for (; i < len; i++) {\n+            switch (s.charAt(i)) {\n+              case '.':\n+                if (decimal != -1) // Only allow a single decimal point.\n+                    break;\n+                decimal = i;\n+                continue;\n+\n+              case 'e':\n+              case 'E':\n+                if (exponent != -1)\n+                    break;\n+                exponent = i;\n+                continue;\n+\n+              case '+':\n+              case '-':\n+                 // Only allow '+' or '-' after 'e' or 'E'\n+                if (exponent != i-1)\n+                    break;\n+                continue;\n+\n+              case '0': case '1': case '2': case '3': case '4':\n+              case '5': case '6': case '7': case '8': case '9':\n+                continue;\n+\n+              default:\n+                break;\n+            }\n+            break;\n+        }\n+        s = s.substring(start, i);\n+        try {\n+            return Double.valueOf(s);\n+        }\n+        catch (NumberFormatException ex) {\n+            return ScriptRuntime.NaNobj;\n+        }\n+    }\n+\n+    /**\n+     * The global method escape, as per ECMA-262 15.1.2.4.\n+\n+     * Includes code for the 'mask' argument supported by the C escape\n+     * method, which used to be part of the browser imbedding.  Blame\n+     * for the strange constant names should be directed there.\n+     */\n+\n+    private Object js_escape(Object[] args) {\n+        final int\n+            URL_XALPHAS = 1,\n+            URL_XPALPHAS = 2,\n+            URL_PATH = 4;\n+\n+        String s = ScriptRuntime.toString(args, 0);\n+\n+        int mask = URL_XALPHAS | URL_XPALPHAS | URL_PATH;\n+        if (args.length > 1) { // the 'mask' argument.  Non-ECMA.\n+            double d = ScriptRuntime.toNumber(args[1]);\n+            if (d != d || ((mask = (int) d) != d) ||\n+                0 != (mask & ~(URL_XALPHAS | URL_XPALPHAS | URL_PATH)))\n+            {\n+                throw Context.reportRuntimeError0(\"msg.bad.esc.mask\");\n+            }\n+        }\n+\n+        StringBuffer sb = null;\n+        for (int k = 0, L = s.length(); k != L; ++k) {\n+            int c = s.charAt(k);\n+            if (mask != 0\n+                && ((c >= '0' && c <= '9')\n+                    || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')\n+                    || c == '@' || c == '*' || c == '_' || c == '-' || c == '.'\n+                    || (0 != (mask & URL_PATH) && (c == '/' || c == '+'))))\n+            {\n+                if (sb != null) {\n+                    sb.append((char)c);\n+                }\n+            } else {\n+                if (sb == null) {\n+                    sb = new StringBuffer(L + 3);\n+                    sb.append(s);\n+                    sb.setLength(k);\n+                }\n+\n+                int hexSize;\n+                if (c < 256) {\n+                    if (c == ' ' && mask == URL_XPALPHAS) {\n+                        sb.append('+');\n+                        continue;\n+                    }\n+                    sb.append('%');\n+                    hexSize = 2;\n+                } else {\n+                    sb.append('%');\n+                    sb.append('u');\n+                    hexSize = 4;\n+                }\n+\n+                // append hexadecimal form of c left-padded with 0\n+                for (int shift = (hexSize - 1) * 4; shift >= 0; shift -= 4) {\n+                    int digit = 0xf & (c >> shift);\n+                    int hc = (digit < 10) ? '0' + digit : 'A' - 10 + digit;\n+                    sb.append((char)hc);\n+                }\n+            }\n+        }\n+\n+        return (sb == null) ? s : sb.toString();\n+    }\n+\n+    /**\n+     * The global unescape method, as per ECMA-262 15.1.2.5.\n+     */\n+\n+    private Object js_unescape(Object[] args)\n+    {\n+        String s = ScriptRuntime.toString(args, 0);\n+        int firstEscapePos = s.indexOf('%');\n+        if (firstEscapePos >= 0) {\n+            int L = s.length();\n+            char[] buf = s.toCharArray();\n+            int destination = firstEscapePos;\n+            for (int k = firstEscapePos; k != L;) {\n+                char c = buf[k];\n+                ++k;\n+                if (c == '%' && k != L) {\n+                    int end, start;\n+                    if (buf[k] == 'u') {\n+                        start = k + 1;\n+                        end = k + 5;\n+                    } else {\n+                        start = k;\n+                        end = k + 2;\n+                    }\n+                    if (end <= L) {\n+                        int x = 0;\n+                        for (int i = start; i != end; ++i) {\n+                            x = Kit.xDigitToInt(buf[i], x);\n+                        }\n+                        if (x >= 0) {\n+                            c = (char)x;\n+                            k = end;\n+                        }\n+                    }\n+                }\n+                buf[destination] = c;\n+                ++destination;\n+            }\n+            s = new String(buf, 0, destination);\n+        }\n+        return s;\n+    }\n+\n+    /**\n+     * This is an indirect call to eval, and thus uses the global environment.\n+     * Direct calls are executed via ScriptRuntime.callSpecial().\n+     */\n+    private Object js_eval(Context cx, Scriptable scope, Object[] args)\n+    {\n+        Scriptable global = ScriptableObject.getTopLevelScope(scope);\n+        return ScriptRuntime.evalSpecial(cx, global, global, args, \"eval code\", 1);\n+    }\n+\n+    static boolean isEvalFunction(Object functionObj)\n+    {\n+        if (functionObj instanceof IdFunctionObject) {\n+            IdFunctionObject function = (IdFunctionObject)functionObj;\n+            if (function.hasTag(FTAG) && function.methodId() == Id_eval) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @deprecated Use {@link ScriptRuntime#constructError(String,String)}\n+     * instead.\n+     */\n+    public static EcmaError constructError(Context cx,\n+                                           String error,\n+                                           String message,\n+                                           Scriptable scope)\n+    {\n+        return ScriptRuntime.constructError(error, message);\n+    }\n+\n+    /**\n+     * @deprecated Use\n+     * {@link ScriptRuntime#constructError(String,String,String,int,String,int)}\n+     * instead.\n+     */\n+    public static EcmaError constructError(Context cx,\n+                                           String error,\n+                                           String message,\n+                                           Scriptable scope,\n+                                           String sourceName,\n+                                           int lineNumber,\n+                                           int columnNumber,\n+                                           String lineSource)\n+    {\n+        return ScriptRuntime.constructError(error, message,\n+                                            sourceName, lineNumber,\n+                                            lineSource, columnNumber);\n+    }\n+\n+    /*\n+    *   ECMA 3, 15.1.3 URI Handling Function Properties\n+    *\n+    *   The following are implementations of the algorithms\n+    *   given in the ECMA specification for the hidden functions\n+    *   'Encode' and 'Decode'.\n+    */\n+    private static String encode(String str, boolean fullUri) {\n+        byte[] utf8buf = null;\n+        StringBuffer sb = null;\n+\n+        for (int k = 0, length = str.length(); k != length; ++k) {\n+            char C = str.charAt(k);\n+            if (encodeUnescaped(C, fullUri)) {\n+                if (sb != null) {\n+                    sb.append(C);\n+                }\n+            } else {\n+                if (sb == null) {\n+                    sb = new StringBuffer(length + 3);\n+                    sb.append(str);\n+                    sb.setLength(k);\n+                    utf8buf = new byte[6];\n+                }\n+                if (0xDC00 <= C && C <= 0xDFFF) {\n+                    throw Context.reportRuntimeError0(\"msg.bad.uri\");\n+                }\n+                int V;\n+                if (C < 0xD800 || 0xDBFF < C) {\n+                    V = C;\n+                } else {\n+                    k++;\n+                    if (k == length) {\n+                        throw Context.reportRuntimeError0(\"msg.bad.uri\");\n+                    }\n+                    char C2 = str.charAt(k);\n+                    if (!(0xDC00 <= C2 && C2 <= 0xDFFF)) {\n+                        throw Context.reportRuntimeError0(\"msg.bad.uri\");\n+                    }\n+                    V = ((C - 0xD800) << 10) + (C2 - 0xDC00) + 0x10000;\n+                }\n+                int L = oneUcs4ToUtf8Char(utf8buf, V);\n+                for (int j = 0; j < L; j++) {\n+                    int d = 0xff & utf8buf[j];\n+                    sb.append('%');\n+                    sb.append(toHexChar(d >>> 4));\n+                    sb.append(toHexChar(d & 0xf));\n+                }\n+            }\n+        }\n+        return (sb == null) ? str : sb.toString();\n+    }\n+\n+    private static char toHexChar(int i) {\n+        if (i >> 4 != 0) Kit.codeBug();\n+        return (char)((i < 10) ? i + '0' : i - 10 + 'A');\n+    }\n+\n+    private static int unHex(char c) {\n+        if ('A' <= c && c <= 'F') {\n+            return c - 'A' + 10;\n+        } else if ('a' <= c && c <= 'f') {\n+            return c - 'a' + 10;\n+        } else if ('0' <= c && c <= '9') {\n+            return c - '0';\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    private static int unHex(char c1, char c2) {\n+        int i1 = unHex(c1);\n+        int i2 = unHex(c2);\n+        if (i1 >= 0 && i2 >= 0) {\n+            return (i1 << 4) | i2;\n+        }\n+        return -1;\n+    }\n+\n+    private static String decode(String str, boolean fullUri) {\n+        char[] buf = null;\n+        int bufTop = 0;\n+\n+        for (int k = 0, length = str.length(); k != length;) {\n+            char C = str.charAt(k);\n+            if (C != '%') {\n+                if (buf != null) {\n+                    buf[bufTop++] = C;\n+                }\n+                ++k;\n+            } else {\n+                if (buf == null) {\n+                    // decode always compress so result can not be bigger then\n+                    // str.length()\n+                    buf = new char[length];\n+                    str.getChars(0, k, buf, 0);\n+                    bufTop = k;\n+                }\n+                int start = k;\n+                if (k + 3 > length)\n+                    throw Context.reportRuntimeError0(\"msg.bad.uri\");\n+                int B = unHex(str.charAt(k + 1), str.charAt(k + 2));\n+                if (B < 0) throw Context.reportRuntimeError0(\"msg.bad.uri\");\n+                k += 3;\n+                if ((B & 0x80) == 0) {\n+                    C = (char)B;\n+                } else {\n+                    // Decode UTF-8 sequence into ucs4Char and encode it into\n+                    // UTF-16\n+                    int utf8Tail, ucs4Char, minUcs4Char;\n+                    if ((B & 0xC0) == 0x80) {\n+                        // First  UTF-8 should be ouside 0x80..0xBF\n+                        throw Context.reportRuntimeError0(\"msg.bad.uri\");\n+                    } else if ((B & 0x20) == 0) {\n+                        utf8Tail = 1; ucs4Char = B & 0x1F;\n+                        minUcs4Char = 0x80;\n+                    } else if ((B & 0x10) == 0) {\n+                        utf8Tail = 2; ucs4Char = B & 0x0F;\n+                        minUcs4Char = 0x800;\n+                    } else if ((B & 0x08) == 0) {\n+                        utf8Tail = 3; ucs4Char = B & 0x07;\n+                        minUcs4Char = 0x10000;\n+                    } else if ((B & 0x04) == 0) {\n+                        utf8Tail = 4; ucs4Char = B & 0x03;\n+                        minUcs4Char = 0x200000;\n+                    } else if ((B & 0x02) == 0) {\n+                        utf8Tail = 5; ucs4Char = B & 0x01;\n+                        minUcs4Char = 0x4000000;\n+                    } else {\n+                        // First UTF-8 can not be 0xFF or 0xFE\n+                        throw Context.reportRuntimeError0(\"msg.bad.uri\");\n+                    }\n+                    if (k + 3 * utf8Tail > length)\n+                        throw Context.reportRuntimeError0(\"msg.bad.uri\");\n+                    for (int j = 0; j != utf8Tail; j++) {\n+                        if (str.charAt(k) != '%')\n+                            throw Context.reportRuntimeError0(\"msg.bad.uri\");\n+                        B = unHex(str.charAt(k + 1), str.charAt(k + 2));\n+                        if (B < 0 || (B & 0xC0) != 0x80)\n+                            throw Context.reportRuntimeError0(\"msg.bad.uri\");\n+                        ucs4Char = (ucs4Char << 6) | (B & 0x3F);\n+                        k += 3;\n+                    }\n+                    // Check for overlongs and other should-not-present codes\n+                    if (ucs4Char < minUcs4Char\n+                        || ucs4Char == 0xFFFE || ucs4Char == 0xFFFF)\n+                    {\n+                        ucs4Char = 0xFFFD;\n+                    }\n+                    if (ucs4Char >= 0x10000) {\n+                        ucs4Char -= 0x10000;\n+                        if (ucs4Char > 0xFFFFF)\n+                            throw Context.reportRuntimeError0(\"msg.bad.uri\");\n+                        char H = (char)((ucs4Char >>> 10) + 0xD800);\n+                        C = (char)((ucs4Char & 0x3FF) + 0xDC00);\n+                        buf[bufTop++] = H;\n+                    } else {\n+                        C = (char)ucs4Char;\n+                    }\n+                }\n+                if (fullUri && URI_DECODE_RESERVED.indexOf(C) >= 0) {\n+                    for (int x = start; x != k; x++) {\n+                        buf[bufTop++] = str.charAt(x);\n+                    }\n+                } else {\n+                    buf[bufTop++] = C;\n+                }\n+            }\n+        }\n+        return (buf == null) ? str : new String(buf, 0, bufTop);\n+    }\n+\n+    private static boolean encodeUnescaped(char c, boolean fullUri) {\n+        if (('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')\n+            || ('0' <= c && c <= '9'))\n+        {\n+            return true;\n+        }\n+        if (\"-_.!~*'()\".indexOf(c) >= 0)\n+            return true;\n+        if (fullUri) {\n+            return URI_DECODE_RESERVED.indexOf(c) >= 0;\n+        }\n+        return false;\n+    }\n+\n+    private static final String URI_DECODE_RESERVED = \";/?:@&=+$,#\";\n+\n+    /* Convert one UCS-4 char and write it into a UTF-8 buffer, which must be\n+    * at least 6 bytes long.  Return the number of UTF-8 bytes of data written.\n+    */\n+    private static int oneUcs4ToUtf8Char(byte[] utf8Buffer, int ucs4Char) {\n+        int utf8Length = 1;\n+\n+        //JS_ASSERT(ucs4Char <= 0x7FFFFFFF);\n+        if ((ucs4Char & ~0x7F) == 0)\n+            utf8Buffer[0] = (byte)ucs4Char;\n+        else {\n+            int i;\n+            int a = ucs4Char >>> 11;\n+            utf8Length = 2;\n+            while (a != 0) {\n+                a >>>= 5;\n+                utf8Length++;\n+            }\n+            i = utf8Length;\n+            while (--i > 0) {\n+                utf8Buffer[i] = (byte)((ucs4Char & 0x3F) | 0x80);\n+                ucs4Char >>>= 6;\n+            }\n+            utf8Buffer[0] = (byte)(0x100 - (1 << (8-utf8Length)) + ucs4Char);\n+        }\n+        return utf8Length;\n+    }\n+\n+    private static final Object FTAG = \"Global\";\n+\n+    private static final int\n+        Id_decodeURI           =  1,\n+        Id_decodeURIComponent  =  2,\n+        Id_encodeURI           =  3,\n+        Id_encodeURIComponent  =  4,\n+        Id_escape              =  5,\n+        Id_eval                =  6,\n+        Id_isFinite            =  7,\n+        Id_isNaN               =  8,\n+        Id_isXMLName           =  9,\n+        Id_parseFloat          = 10,\n+        Id_parseInt            = 11,\n+        Id_unescape            = 12,\n+        Id_uneval              = 13,\n+\n+        LAST_SCOPE_FUNCTION_ID = 13,\n+\n+        Id_new_CommonError     = 14;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeIterator.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * This class implements iterator objects. See\n+ * http://developer.mozilla.org/en/docs/New_in_JavaScript_1.7#Iterators\n+ *\n+ */\n+public final class NativeIterator extends IdScriptableObject {\n+    private static final long serialVersionUID = -4136968203581667681L;\n+    private static final Object ITERATOR_TAG = \"Iterator\";\n+\n+    static void init(ScriptableObject scope, boolean sealed) {\n+        // Iterator\n+        NativeIterator iterator = new NativeIterator();\n+        iterator.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+\n+        // Generator\n+        NativeGenerator.init(scope, sealed);\n+\n+        // StopIteration\n+        NativeObject obj = new StopIteration();\n+        obj.setPrototype(getObjectPrototype(scope));\n+        obj.setParentScope(scope);\n+        if (sealed) { obj.sealObject(); }\n+        ScriptableObject.defineProperty(scope, STOP_ITERATION, obj,\n+                                        ScriptableObject.DONTENUM);\n+        // Use \"associateValue\" so that generators can continue to\n+        // throw StopIteration even if the property of the global\n+        // scope is replaced or deleted.\n+        scope.associateValue(ITERATOR_TAG, obj);\n+    }\n+\n+    /**\n+     * Only for constructing the prototype object.\n+     */\n+    private NativeIterator() {\n+    }\n+\n+    private NativeIterator(Object objectIterator) {\n+      this.objectIterator = objectIterator;\n+    }\n+\n+    /**\n+     * Get the value of the \"StopIteration\" object. Note that this value\n+     * is stored in the top-level scope using \"associateValue\" so the\n+     * value can still be found even if a script overwrites or deletes\n+     * the global \"StopIteration\" property.\n+     * @param scope a scope whose parent chain reaches a top-level scope\n+     * @return the StopIteration object\n+     */\n+    public static Object getStopIterationObject(Scriptable scope) {\n+        Scriptable top = ScriptableObject.getTopLevelScope(scope);\n+        return ScriptableObject.getTopScopeValue(top, ITERATOR_TAG);\n+    }\n+\n+    private static final String STOP_ITERATION = \"StopIteration\";\n+    public static final String ITERATOR_PROPERTY_NAME = \"__iterator__\";\n+\n+    static class StopIteration extends NativeObject {\n+        private static final long serialVersionUID = 2485151085722377663L;\n+\n+        @Override\n+        public String getClassName() {\n+            return STOP_ITERATION;\n+        }\n+\n+        /* StopIteration has custom instanceof behavior since it\n+         * doesn't have a constructor.\n+         */\n+        @Override\n+        public boolean hasInstance(Scriptable instance) {\n+            return instance instanceof StopIteration;\n+        }\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return \"Iterator\";\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id) {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor:    arity=2; s=\"constructor\";          break;\n+          case Id_next:           arity=0; s=\"next\";                 break;\n+          case Id___iterator__:   arity=1; s=ITERATOR_PROPERTY_NAME; break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(ITERATOR_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(ITERATOR_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+\n+        if (id == Id_constructor) {\n+            return jsConstructor(cx, scope, thisObj, args);\n+        }\n+\n+        if (!(thisObj instanceof NativeIterator))\n+            throw incompatibleCallError(f);\n+\n+        NativeIterator iterator = (NativeIterator) thisObj;\n+\n+        switch (id) {\n+\n+          case Id_next:\n+            return iterator.next(cx, scope);\n+\n+          case Id___iterator__:\n+            /// XXX: what about argument? SpiderMonkey apparently ignores it\n+            return thisObj;\n+\n+          default:\n+            throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+    }\n+\n+    /* The JavaScript constructor */\n+    private static Object jsConstructor(Context cx, Scriptable scope,\n+                                        Scriptable thisObj, Object[] args)\n+    {\n+        if (args.length == 0 || args[0] == null ||\n+            args[0] == Undefined.instance)\n+        {\n+            throw ScriptRuntime.typeError1(\"msg.no.properties\",\n+                                           ScriptRuntime.toString(args[0]));\n+        }\n+        Scriptable obj = ScriptRuntime.toObject(scope, args[0]);\n+        boolean keyOnly = args.length > 1 && ScriptRuntime.toBoolean(args[1]);\n+        if (thisObj != null) {\n+            // Called as a function. Convert to iterator if possible.\n+\n+            // For objects that implement java.lang.Iterable or\n+            // java.util.Iterator, have JavaScript Iterator call the underlying\n+            // iteration methods\n+            Iterator<?> iterator =\n+                VMBridge.instance.getJavaIterator(cx, scope, obj);\n+            if (iterator != null) {\n+                scope = ScriptableObject.getTopLevelScope(scope);\n+                return cx.getWrapFactory().wrap(cx, scope,\n+                        new WrappedJavaIterator(iterator, scope),\n+                        WrappedJavaIterator.class);\n+            }\n+\n+            // Otherwise, just call the runtime routine\n+            Scriptable jsIterator = ScriptRuntime.toIterator(cx, scope, obj,\n+                                                             keyOnly);\n+            if (jsIterator != null) {\n+                return jsIterator;\n+            }\n+        }\n+\n+        // Otherwise, just set up to iterate over the properties of the object.\n+        // Do not call __iterator__ method.\n+        Object objectIterator = ScriptRuntime.enumInit(obj, cx,\n+            keyOnly ? ScriptRuntime.ENUMERATE_KEYS_NO_ITERATOR\n+                    : ScriptRuntime.ENUMERATE_ARRAY_NO_ITERATOR);\n+        ScriptRuntime.setEnumNumbers(objectIterator, true);\n+        NativeIterator result = new NativeIterator(objectIterator);\n+        result.setPrototype(ScriptableObject.getClassPrototype(scope,\n+                                result.getClassName()));\n+        result.setParentScope(scope);\n+        return result;\n+    }\n+\n+    private Object next(Context cx, Scriptable scope) {\n+        Boolean b = ScriptRuntime.enumNext(this.objectIterator);\n+        if (!b.booleanValue()) {\n+            // Out of values. Throw StopIteration.\n+            throw new JavaScriptException(\n+                NativeIterator.getStopIterationObject(scope), null, 0);\n+        }\n+        return ScriptRuntime.enumId(this.objectIterator, cx);\n+    }\n+\n+    static public class WrappedJavaIterator\n+    {\n+        WrappedJavaIterator(Iterator<?> iterator, Scriptable scope) {\n+            this.iterator = iterator;\n+            this.scope = scope;\n+        }\n+\n+        public Object next() {\n+            if (!iterator.hasNext()) {\n+                // Out of values. Throw StopIteration.\n+                throw new JavaScriptException(\n+                    NativeIterator.getStopIterationObject(scope), null, 0);\n+            }\n+            return iterator.next();\n+        }\n+\n+        public Object __iterator__(boolean b) {\n+            return this;\n+        }\n+\n+        private Iterator<?> iterator;\n+        private Scriptable scope;\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s) {\n+        int id;\n+// #generated# Last update: 2007-06-11 09:43:19 EDT\n+        L0: { id = 0; String X = null;\n+            int s_length = s.length();\n+            if (s_length==4) { X=\"next\";id=Id_next; }\n+            else if (s_length==11) { X=\"constructor\";id=Id_constructor; }\n+            else if (s_length==12) { X=\"__iterator__\";id=Id___iterator__; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_constructor           = 1,\n+        Id_next                  = 2,\n+        Id___iterator__          = 3,\n+        MAX_PROTOTYPE_ID         = 3;\n+\n+// #/string_id_map#\n+\n+    private Object objectIterator;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeJSON.java\n+/* -*- Mode: java; tab-width: 4; indent-tabs-mode: 1; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Matthew Crumley\n+ *   Raphael Speyer\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.javascript.json.JsonParser;\n+\n+import java.util.Stack;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.LinkedList;\n+\n+/**\n+ * This class implements the JSON native object.\n+ * See ECMA 15.12.\n+ */\n+final class NativeJSON extends IdScriptableObject\n+{\n+    static final long serialVersionUID = -4567599697595654984L;\n+\n+    private static final Object JSON_TAG = \"JSON\";\n+\n+    private static final int MAX_STRINGIFY_GAP_LENGTH = 10;\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeJSON obj = new NativeJSON();\n+        obj.activatePrototypeMap(MAX_ID);\n+        obj.setPrototype(getObjectPrototype(scope));\n+        obj.setParentScope(scope);\n+        if (sealed) { obj.sealObject(); }\n+        ScriptableObject.defineProperty(scope, \"JSON\", obj,\n+                                        ScriptableObject.DONTENUM);\n+    }\n+\n+    private NativeJSON()\n+    {\n+    }\n+\n+    @Override\n+    public String getClassName() { return \"JSON\"; }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        if (id <= LAST_METHOD_ID) {\n+            String name;\n+            int arity;\n+            switch (id) {\n+              case Id_toSource:  arity = 0; name = \"toSource\";  break;\n+              case Id_parse:     arity = 2; name = \"parse\";     break;\n+              case Id_stringify: arity = 3; name = \"stringify\"; break;\n+              default: throw new IllegalStateException(String.valueOf(id));\n+            }\n+            initPrototypeMethod(JSON_TAG, id, name, arity);\n+        } else {\n+            throw new IllegalStateException(String.valueOf(id));\n+        }\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(JSON_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int methodId = f.methodId();\n+        switch (methodId) {\n+            case Id_toSource:\n+                return \"JSON\";\n+\n+            case Id_parse: {\n+                String jtext = ScriptRuntime.toString(args, 0);\n+                Object reviver = null;\n+                if (args.length > 1) {\n+                    reviver = args[1];\n+                }\n+                if (reviver instanceof Callable) {\n+                  return parse(cx, scope, jtext, (Callable) reviver);\n+                } else {\n+                  return parse(cx, scope, jtext);\n+                }\n+            }\n+\n+            case Id_stringify: {\n+                Object value = null, replacer = null, space = null;\n+                switch (args.length) {\n+                    default:\n+                    case 3: space = args[2];\n+                    case 2: replacer = args[1];\n+                    case 1: value = args[0];\n+                    case 0:\n+                }\n+                return stringify(cx, scope, value, replacer, space);\n+            }\n+\n+            default: throw new IllegalStateException(String.valueOf(methodId));\n+        }\n+    }\n+\n+    private static Object parse(Context cx, Scriptable scope, String jtext) {\n+      try {\n+        return new JsonParser(cx, scope).parseValue(jtext);\n+      } catch (JsonParser.ParseException ex) {\n+        throw ScriptRuntime.constructError(\"SyntaxError\", ex.getMessage());\n+      }\n+    }\n+\n+    public static Object parse(Context cx, Scriptable scope, String jtext,\n+                               Callable reviver)\n+    {\n+      Object unfiltered = parse(cx, scope, jtext);\n+      Scriptable root = cx.newObject(scope);\n+      root.put(\"\", root, unfiltered);\n+      return walk(cx, scope, reviver, root, \"\");\n+    }\n+\n+    private static Object walk(Context cx, Scriptable scope, Callable reviver,\n+                               Scriptable holder, Object name)\n+    {\n+        final Object property;\n+        if (name instanceof Number) {\n+            property = holder.get( ((Number) name).intValue(), holder);\n+        } else {\n+            property = holder.get( ((String) name), holder);\n+        }\n+\n+        if (property instanceof Scriptable) {\n+            Scriptable val = ((Scriptable) property);\n+            if (val instanceof NativeArray) {\n+                int len = (int) ((NativeArray) val).getLength();\n+                for (int i = 0; i < len; i++) {\n+                    Object newElement = walk(cx, scope, reviver, val, i);\n+                    if (newElement == Undefined.instance) {\n+                      val.delete(i);\n+                    } else {\n+                      val.put(i, val, newElement);\n+                    }\n+                }\n+            } else {\n+                Object[] keys = val.getIds();\n+                for (Object p : keys) {\n+                    Object newElement = walk(cx, scope, reviver, val, p);\n+                    if (newElement == Undefined.instance) {\n+                        if (p instanceof Number)\n+                          val.delete(((Number) p).intValue());\n+                        else\n+                          val.delete((String) p);\n+                    } else {\n+                        if (p instanceof Number)\n+                          val.put(((Number) p).intValue(), val, newElement);\n+                        else\n+                          val.put((String) p, val, newElement);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return reviver.call(cx, scope, holder, new Object[] { name, property });\n+    }\n+\n+    private static String repeat(char c, int count) {\n+      char chars[] = new char[count];\n+      Arrays.fill(chars, c);\n+      return new String(chars);\n+    }\n+\n+    private static class StringifyState {\n+        StringifyState(Context cx, Scriptable scope, String indent, String gap,\n+                       Callable replacer, List<Object> propertyList,\n+                       Object space)\n+        {\n+            this.cx = cx;\n+            this.scope = scope;\n+\n+            this.indent = indent;\n+            this.gap = gap;\n+            this.replacer = replacer;\n+            this.propertyList = propertyList;\n+            this.space = space;\n+        }\n+\n+        Stack<Scriptable> stack = new Stack<Scriptable>();\n+        String indent;\n+        String gap;\n+        Callable replacer;\n+        List<Object> propertyList;\n+        Object space;\n+\n+        Context cx;\n+        Scriptable scope;\n+    }\n+\n+    public static Object stringify(Context cx, Scriptable scope, Object value,\n+                                   Object replacer, Object space)\n+    {\n+        String indent = \"\";\n+        String gap = \"\";\n+\n+        List<Object> propertyList = null;\n+        Callable replacerFunction = null;\n+\n+        if (replacer instanceof Callable) {\n+          replacerFunction = (Callable) replacer;\n+        } else if (replacer instanceof NativeArray) {\n+          propertyList = new LinkedList<Object>();\n+          NativeArray replacerArray = (NativeArray) replacer;\n+          for (int i : replacerArray.getIndexIds()) {\n+            Object v = replacerArray.get(i, replacerArray);\n+            if (v instanceof String || v instanceof Number) {\n+              propertyList.add(v);\n+            } else if (v instanceof NativeString || v instanceof NativeNumber) {\n+              propertyList.add(ScriptRuntime.toString(v));\n+            }\n+          }\n+        }\n+\n+        if (space instanceof NativeNumber) {\n+            space = ScriptRuntime.toNumber(space);\n+        } else if (space instanceof NativeString) {\n+            space = ScriptRuntime.toString(space);\n+        }\n+\n+        if (space instanceof Number) {\n+            int gapLength = (int) ScriptRuntime.toInteger(space);\n+            gapLength = Math.min(MAX_STRINGIFY_GAP_LENGTH, gapLength);\n+            gap = (gapLength > 0) ? repeat(' ', gapLength) : \"\";\n+            space = gapLength;\n+        } else if (space instanceof String) {\n+            gap = (String) space;\n+            if (gap.length() > MAX_STRINGIFY_GAP_LENGTH) {\n+              gap = gap.substring(0, MAX_STRINGIFY_GAP_LENGTH);\n+            }\n+        }\n+\n+        StringifyState state = new StringifyState(cx, scope,\n+            indent,\n+            gap,\n+            replacerFunction,\n+            propertyList,\n+            space);\n+\n+        ScriptableObject wrapper = new NativeObject();\n+        wrapper.setParentScope(scope);\n+        wrapper.setPrototype(ScriptableObject.getObjectPrototype(scope));\n+        wrapper.defineProperty(\"\", value, 0);\n+        return str(\"\", wrapper, state);\n+    }\n+\n+    private static Object str(Object key, Scriptable holder,\n+                              StringifyState state)\n+    {\n+        Object value = null;\n+        if (key instanceof String) {\n+            value = getProperty(holder, (String) key);\n+        } else {\n+            value = getProperty(holder, ((Number) key).intValue());\n+        }\n+\n+        if (value instanceof Scriptable) {\n+            Object toJSON = getProperty((Scriptable) value, \"toJSON\");\n+            if (toJSON instanceof Callable) {\n+                value = callMethod(state.cx, (Scriptable) value, \"toJSON\",\n+                                   new Object[] { key });\n+            }\n+        }\n+\n+        if (state.replacer != null) {\n+            value = state.replacer.call(state.cx, state.scope, holder,\n+                                        new Object[] { key, value });\n+        }\n+\n+\n+        if (value instanceof NativeNumber) {\n+            value = ScriptRuntime.toNumber(value);\n+        } else if (value instanceof NativeString) {\n+            value = ScriptRuntime.toString(value);\n+        } else if (value instanceof NativeBoolean) {\n+            value = ((NativeBoolean) value).getDefaultValue(ScriptRuntime.BooleanClass);\n+        }\n+\n+        if (value == null) return \"null\";\n+        if (value.equals(Boolean.TRUE)) return \"true\";\n+        if (value.equals(Boolean.FALSE)) return \"false\";\n+\n+        if (value instanceof String) {\n+            return quote((String) value);\n+        }\n+\n+        if (value instanceof Number) {\n+            double d = ((Number) value).doubleValue();\n+            if (d == d && d != Double.POSITIVE_INFINITY &&\n+                d != Double.NEGATIVE_INFINITY)\n+            {\n+                return ScriptRuntime.toString(value);\n+            } else {\n+                return \"null\";\n+            }\n+        }\n+\n+        if (value instanceof Scriptable && !(value instanceof Callable)) {\n+            if (value instanceof NativeArray) {\n+                return ja((NativeArray) value, state);\n+            }\n+            return jo((Scriptable) value, state);\n+        }\n+\n+        return Undefined.instance;\n+    }\n+\n+    private static String join(Collection<Object> objs, String delimiter) {\n+        if (objs == null || objs.isEmpty()) {\n+            return \"\";\n+        }\n+        Iterator<Object> iter = objs.iterator();\n+        if (!iter.hasNext()) return \"\";\n+        StringBuilder builder = new StringBuilder(iter.next().toString());\n+        while (iter.hasNext()) {\n+            builder.append(delimiter).append(iter.next().toString());\n+        }\n+        return builder.toString();\n+    }\n+\n+    private static String jo(Scriptable value, StringifyState state) {\n+        if (state.stack.search(value) != -1) {\n+            throw ScriptRuntime.typeError0(\"msg.cyclic.value\");\n+        }\n+        state.stack.push(value);\n+\n+        String stepback = state.indent;\n+        state.indent = state.indent + state.gap;\n+        Object[] k = null;\n+        if (state.propertyList != null) {\n+            k = state.propertyList.toArray();\n+        } else {\n+            k = value.getIds();\n+        }\n+\n+        List<Object> partial = new LinkedList<Object>();\n+\n+        for (Object p : k) {\n+            Object strP = str(p, value, state);\n+            if (strP != Undefined.instance) {\n+                String member = quote(p.toString()) + \":\";\n+                if (state.gap.length() > 0) {\n+                    member = member + \" \";\n+                }\n+                member = member + strP;\n+                partial.add(member);\n+            }\n+        }\n+\n+        final String finalValue;\n+\n+        if (partial.isEmpty()) {\n+            finalValue = \"{}\";\n+        } else {\n+            if (state.gap.length() == 0) {\n+                finalValue = '{' + join(partial, \",\") + '}';\n+            } else {\n+                String separator = \",\\n\" + state.indent;\n+                String properties = join(partial, separator);\n+                finalValue = \"{\\n\" + state.indent + properties + '\\n' +\n+                    stepback + '}';\n+            }\n+        }\n+\n+        state.stack.pop();\n+        state.indent = stepback;\n+        return finalValue;\n+    }\n+\n+    private static String ja(NativeArray value, StringifyState state) {\n+        if (state.stack.search(value) != -1) {\n+            throw ScriptRuntime.typeError0(\"msg.cyclic.value\");\n+        }\n+        state.stack.push(value);\n+\n+        String stepback = state.indent;\n+        state.indent = state.indent + state.gap;\n+        List<Object> partial = new LinkedList<Object>();\n+\n+        int len = (int) value.getLength();\n+        for (int index = 0; index < len; index++) {\n+            Object strP = str(index, value, state);\n+            if (strP == Undefined.instance) {\n+                partial.add(\"null\");\n+            } else {\n+                partial.add(strP);\n+            }\n+        }\n+\n+        final String finalValue;\n+\n+        if (partial.isEmpty()) {\n+            finalValue = \"[]\";\n+        } else {\n+            if (state.gap.length() == 0) {\n+                finalValue = '[' + join(partial, \",\") + ']';\n+            } else {\n+                String separator = \",\\n\" + state.indent;\n+                String properties = join(partial, separator);\n+                finalValue = \"[\\n\" + state.indent + properties + '\\n' + stepback + ']';\n+            }\n+        }\n+\n+        state.stack.pop();\n+        state.indent = stepback;\n+        return finalValue;\n+    }\n+\n+    private static String quote(String string) {\n+        StringBuffer product = new StringBuffer(string.length()+2); // two extra chars for \" on either side\n+        product.append('\"');\n+        int length = string.length();\n+        for (int i = 0; i < length; i++) {\n+            char c = string.charAt(i);\n+            switch (c) {\n+                case '\"':\n+                    product.append(\"\\\\\\\"\");\n+                    break;\n+                case '\\\\':\n+                    product.append(\"\\\\\\\\\");\n+                    break;\n+                case '\\b':\n+                    product.append(\"\\\\b\");\n+                    break;\n+                case '\\f':\n+                    product.append(\"\\\\f\");\n+                    break;\n+                case '\\n':\n+                    product.append(\"\\\\n\");\n+                    break;\n+                case '\\r':\n+                    product.append(\"\\\\r\");\n+                    break;\n+                case '\\t':\n+                    product.append(\"\\\\t\");\n+                    break;\n+                default:\n+                    if (c < ' ') {\n+                        product.append(\"\\\\u\");\n+                        String hex = String.format(\"%04x\", (int) c);\n+                        product.append(hex);\n+                    }\n+                    else {\n+                        product.append(c);\n+                    }\n+                    break;\n+            }\n+        }\n+        product.append('\"');\n+        return product.toString();\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2009-05-25 16:01:00 EDT\n+        {   id = 0; String X = null;\n+            L: switch (s.length()) {\n+            case 5: X=\"parse\";id=Id_parse; break L;\n+            case 8: X=\"toSource\";id=Id_toSource; break L;\n+            case 9: X=\"stringify\";id=Id_stringify; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_toSource     = 1,\n+        Id_parse        = 2,\n+        Id_stringify    = 3,\n+        LAST_METHOD_ID  = 3,\n+        MAX_ID          = 3;\n+\n+// #/string_id_map#\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaArray.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Frank Mitchell\n+ *   Mike Shaver\n+ *   Kemal Bayram\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.reflect.Array;\n+\n+/**\n+ * This class reflects Java arrays into the JavaScript environment.\n+ *\n+ * @see NativeJavaClass\n+ * @see NativeJavaObject\n+ * @see NativeJavaPackage\n+ */\n+\n+public class NativeJavaArray extends NativeJavaObject\n+{\n+    static final long serialVersionUID = -924022554283675333L;\n+\n+    @Override\n+    public String getClassName() {\n+        return \"JavaArray\";\n+    }\n+\n+    public static NativeJavaArray wrap(Scriptable scope, Object array) {\n+        return new NativeJavaArray(scope, array);\n+    }\n+\n+    @Override\n+    public Object unwrap() {\n+        return array;\n+    }\n+\n+    public NativeJavaArray(Scriptable scope, Object array) {\n+        super(scope, null, ScriptRuntime.ObjectClass);\n+        Class<?> cl = array.getClass();\n+        if (!cl.isArray()) {\n+            throw new RuntimeException(\"Array expected\");\n+        }\n+        this.array = array;\n+        this.length = Array.getLength(array);\n+        this.cls = cl.getComponentType();\n+    }\n+\n+    @Override\n+    public boolean has(String id, Scriptable start) {\n+        return id.equals(\"length\") || super.has(id, start);\n+    }\n+\n+    @Override\n+    public boolean has(int index, Scriptable start) {\n+        return 0 <= index && index < length;\n+    }\n+\n+    @Override\n+    public Object get(String id, Scriptable start) {\n+        if (id.equals(\"length\"))\n+            return Integer.valueOf(length);\n+        Object result = super.get(id, start);\n+        if (result == NOT_FOUND &&\n+            !ScriptableObject.hasProperty(getPrototype(), id))\n+        {\n+            throw Context.reportRuntimeError2(\n+                \"msg.java.member.not.found\", array.getClass().getName(), id);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object get(int index, Scriptable start) {\n+        if (0 <= index && index < length) {\n+            Context cx = Context.getContext();\n+            Object obj = Array.get(array, index);\n+            return cx.getWrapFactory().wrap(cx, this, obj, cls);\n+        }\n+        return Undefined.instance;\n+    }\n+\n+    @Override\n+    public void put(String id, Scriptable start, Object value) {\n+        // Ignore assignments to \"length\"--it's readonly.\n+        if (!id.equals(\"length\"))\n+            throw Context.reportRuntimeError1(\n+                \"msg.java.array.member.not.found\", id);\n+    }\n+\n+    @Override\n+    public void put(int index, Scriptable start, Object value) {\n+        if (0 <= index && index < length) {\n+            Array.set(array, index, Context.jsToJava(value, cls));\n+        }\n+        else {\n+            throw Context.reportRuntimeError2(\n+                \"msg.java.array.index.out.of.bounds\", String.valueOf(index),\n+                String.valueOf(length - 1));\n+        }\n+    }\n+\n+    @Override\n+    public Object getDefaultValue(Class<?> hint) {\n+        if (hint == null || hint == ScriptRuntime.StringClass)\n+            return array.toString();\n+        if (hint == ScriptRuntime.BooleanClass)\n+            return Boolean.TRUE;\n+        if (hint == ScriptRuntime.NumberClass)\n+            return ScriptRuntime.NaNobj;\n+        return this;\n+    }\n+\n+    @Override\n+    public Object[] getIds() {\n+        Object[] result = new Object[length];\n+        int i = length;\n+        while (--i >= 0)\n+            result[i] = Integer.valueOf(i);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean hasInstance(Scriptable value) {\n+        if (!(value instanceof Wrapper))\n+            return false;\n+        Object instance = ((Wrapper)value).unwrap();\n+        return cls.isInstance(instance);\n+    }\n+\n+    @Override\n+    public Scriptable getPrototype() {\n+        if (prototype == null) {\n+            prototype =\n+                ScriptableObject.getClassPrototype(this.getParentScope(),\n+                                                   \"Array\");\n+        }\n+        return prototype;\n+    }\n+\n+    Object array;\n+    int length;\n+    Class<?> cls;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaClass.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Frank Mitchell\n+ *   Mike Shaver\n+ *   Kurt Westerfeld\n+ *   Kemal Bayram\n+ *   Ulrike Mueller <umueller@demandware.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.reflect.*;\n+import java.util.Map;\n+\n+/**\n+ * This class reflects Java classes into the JavaScript environment, mainly\n+ * for constructors and static members.  We lazily reflect properties,\n+ * and currently do not guarantee that a single j.l.Class is only\n+ * reflected once into the JS environment, although we should.\n+ * The only known case where multiple reflections\n+ * are possible occurs when a j.l.Class is wrapped as part of a\n+ * method return or property access, rather than by walking the\n+ * Packages/java tree.\n+ *\n+ * @see NativeJavaArray\n+ * @see NativeJavaObject\n+ * @see NativeJavaPackage\n+ */\n+\n+public class NativeJavaClass extends NativeJavaObject implements Function\n+{\n+    static final long serialVersionUID = -6460763940409461664L;\n+\n+    // Special property for getting the underlying Java class object.\n+    static final String javaClassPropertyName = \"__javaObject__\";\n+\n+    public NativeJavaClass() {\n+    }\n+\n+    public NativeJavaClass(Scriptable scope, Class<?> cl) {\n+        this.parent = scope;\n+        this.javaObject = cl;\n+        initMembers();\n+    }\n+\n+    @Override\n+    protected void initMembers() {\n+        Class<?> cl = (Class<?>)javaObject;\n+        members = JavaMembers.lookupClass(parent, cl, cl, false);\n+        staticFieldAndMethods\n+            = members.getFieldAndMethodsObjects(this, cl, true);\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return \"JavaClass\";\n+    }\n+\n+    @Override\n+    public boolean has(String name, Scriptable start) {\n+        return members.has(name, true) || javaClassPropertyName.equals(name);\n+    }\n+\n+    @Override\n+    public Object get(String name, Scriptable start) {\n+        // When used as a constructor, ScriptRuntime.newObject() asks\n+        // for our prototype to create an object of the correct type.\n+        // We don't really care what the object is, since we're returning\n+        // one constructed out of whole cloth, so we return null.\n+        if (name.equals(\"prototype\"))\n+            return null;\n+\n+         if (staticFieldAndMethods != null) {\n+            Object result = staticFieldAndMethods.get(name);\n+            if (result != null)\n+                return result;\n+        }\n+\n+        if (members.has(name, true)) {\n+            return members.get(this, name, javaObject, true);\n+        }\n+\n+        if (javaClassPropertyName.equals(name)) {\n+            Context cx = Context.getContext();\n+            Scriptable scope = ScriptableObject.getTopLevelScope(start);\n+            return cx.getWrapFactory().wrap(cx, scope, javaObject,\n+                                            ScriptRuntime.ClassClass);\n+        }\n+\n+        // experimental:  look for nested classes by appending $name to\n+        // current class' name.\n+        Class<?> nestedClass = findNestedClass(getClassObject(), name);\n+        if (nestedClass != null) {\n+            NativeJavaClass nestedValue = new NativeJavaClass\n+                (ScriptableObject.getTopLevelScope(this), nestedClass);\n+            nestedValue.setParentScope(this);\n+            return nestedValue;\n+        }\n+\n+        throw members.reportMemberNotFound(name);\n+    }\n+\n+    @Override\n+    public void put(String name, Scriptable start, Object value) {\n+        members.put(this, name, javaObject, value, true);\n+    }\n+\n+    @Override\n+    public Object[] getIds() {\n+        return members.getIds(true);\n+    }\n+\n+    public Class<?> getClassObject() {\n+        return (Class<?>) super.unwrap();\n+    }\n+\n+    @Override\n+    public Object getDefaultValue(Class<?> hint) {\n+        if (hint == null || hint == ScriptRuntime.StringClass)\n+            return this.toString();\n+        if (hint == ScriptRuntime.BooleanClass)\n+            return Boolean.TRUE;\n+        if (hint == ScriptRuntime.NumberClass)\n+            return ScriptRuntime.NaNobj;\n+        return this;\n+    }\n+\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        // If it looks like a \"cast\" of an object to this class type,\n+        // walk the prototype chain to see if there's a wrapper of a\n+        // object that's an instanceof this class.\n+        if (args.length == 1 && args[0] instanceof Scriptable) {\n+            Class<?> c = getClassObject();\n+            Scriptable p = (Scriptable) args[0];\n+            do {\n+                if (p instanceof Wrapper) {\n+                    Object o = ((Wrapper) p).unwrap();\n+                    if (c.isInstance(o))\n+                        return p;\n+                }\n+                p = p.getPrototype();\n+            } while (p != null);\n+        }\n+        return construct(cx, scope, args);\n+    }\n+\n+    public Scriptable construct(Context cx, Scriptable scope, Object[] args)\n+    {\n+        Class<?> classObject = getClassObject();\n+        int modifiers = classObject.getModifiers();\n+        if (! (Modifier.isInterface(modifiers) ||\n+               Modifier.isAbstract(modifiers)))\n+        {\n+            MemberBox[] ctors = members.ctors;\n+            int index = NativeJavaMethod.findFunction(cx, ctors, args);\n+            if (index < 0) {\n+                String sig = NativeJavaMethod.scriptSignature(args);\n+                throw Context.reportRuntimeError2(\n+                    \"msg.no.java.ctor\", classObject.getName(), sig);\n+            }\n+\n+            // Found the constructor, so try invoking it.\n+            return constructSpecific(cx, scope, args, ctors[index]);\n+        } else {\n+            Scriptable topLevel = ScriptableObject.getTopLevelScope(this);\n+            String msg = \"\";\n+            try {\n+                // trying to construct an interface; use JavaAdapter to\n+                // construct a new class on the fly that implements this\n+                // interface.\n+                Object v = topLevel.get(\"JavaAdapter\", topLevel);\n+                if (v != NOT_FOUND) {\n+                    Function f = (Function) v;\n+                    // Args are (interface, js object)\n+                    Object[] adapterArgs = { this, args[0] };\n+                    return f.construct(cx, topLevel, adapterArgs);\n+                }\n+            } catch (Exception ex) {\n+                // fall through to error\n+                String m = ex.getMessage();\n+                if (m != null)\n+                    msg = m;\n+            }\n+            throw Context.reportRuntimeError2(\n+                \"msg.cant.instantiate\", msg, classObject.getName());\n+        }\n+    }\n+\n+    static Scriptable constructSpecific(Context cx, Scriptable scope,\n+                                        Object[] args, MemberBox ctor)\n+    {\n+        Scriptable topLevel = ScriptableObject.getTopLevelScope(scope);\n+        Class<?>[] argTypes = ctor.argTypes;\n+\n+        if (ctor.vararg) {\n+            // marshall the explicit parameter\n+            Object[] newArgs = new Object[argTypes.length];\n+            for (int i = 0; i < argTypes.length-1; i++) {\n+                newArgs[i] = Context.jsToJava(args[i], argTypes[i]);\n+            }\n+\n+            Object varArgs;\n+\n+            // Handle special situation where a single variable parameter\n+            // is given and it is a Java or ECMA array.\n+            if (args.length == argTypes.length &&\n+                (args[args.length-1] == null ||\n+                 args[args.length-1] instanceof NativeArray ||\n+                 args[args.length-1] instanceof NativeJavaArray))\n+            {\n+                // convert the ECMA array into a native array\n+                varArgs = Context.jsToJava(args[args.length-1],\n+                                           argTypes[argTypes.length - 1]);\n+            } else {\n+                // marshall the variable parameter\n+                Class<?> componentType = argTypes[argTypes.length - 1].\n+                                        getComponentType();\n+                varArgs = Array.newInstance(componentType,\n+                                            args.length - argTypes.length + 1);\n+                for (int i=0; i < Array.getLength(varArgs); i++) {\n+                    Object value = Context.jsToJava(args[argTypes.length-1 + i],\n+                                                    componentType);\n+                    Array.set(varArgs, i, value);\n+                }\n+            }\n+\n+            // add varargs\n+            newArgs[argTypes.length-1] = varArgs;\n+            // replace the original args with the new one\n+            args = newArgs;\n+        } else {\n+            Object[] origArgs = args;\n+            for (int i = 0; i < args.length; i++) {\n+                Object arg = args[i];\n+                Object x = Context.jsToJava(arg, argTypes[i]);\n+                if (x != arg) {\n+                    if (args == origArgs) {\n+                        args = origArgs.clone();\n+                    }\n+                    args[i] = x;\n+                }\n+            }\n+        }\n+\n+        Object instance = ctor.newInstance(args);\n+        // we need to force this to be wrapped, because construct _has_\n+        // to return a scriptable\n+        return cx.getWrapFactory().wrapNewObject(cx, topLevel, instance);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"[JavaClass \" + getClassObject().getName() + \"]\";\n+    }\n+\n+    /**\n+     * Determines if prototype is a wrapped Java object and performs\n+     * a Java \"instanceof\".\n+     * Exception: if value is an instance of NativeJavaClass, it isn't\n+     * considered an instance of the Java class; this forestalls any\n+     * name conflicts between java.lang.Class's methods and the\n+     * static methods exposed by a JavaNativeClass.\n+     */\n+    @Override\n+    public boolean hasInstance(Scriptable value) {\n+\n+        if (value instanceof Wrapper &&\n+            !(value instanceof NativeJavaClass)) {\n+            Object instance = ((Wrapper)value).unwrap();\n+\n+            return getClassObject().isInstance(instance);\n+        }\n+\n+        // value wasn't something we understand\n+        return false;\n+    }\n+\n+    private static Class<?> findNestedClass(Class<?> parentClass, String name) {\n+        String nestedClassName = parentClass.getName() + '$' + name;\n+        ClassLoader loader = parentClass.getClassLoader();\n+        if (loader == null) {\n+            // ALERT: if loader is null, nested class should be loaded\n+            // via system class loader which can be different from the\n+            // loader that brought Rhino classes that Class.forName() would\n+            // use, but ClassLoader.getSystemClassLoader() is Java 2 only\n+            return Kit.classOrNull(nestedClassName);\n+        } else {\n+            return Kit.classOrNull(loader, nestedClassName);\n+        }\n+    }\n+\n+    private Map<String,FieldAndMethods> staticFieldAndMethods;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaConstructor.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Frank Mitchell\n+ *   Mike Shaver\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class reflects a single Java constructor into the JavaScript\n+ * environment.  It satisfies a request for an overloaded constructor,\n+ * as introduced in LiveConnect 3.\n+ * All NativeJavaConstructors behave as JSRef `bound' methods, in that they\n+ * always construct the same NativeJavaClass regardless of any reparenting\n+ * that may occur.\n+ *\n+ * @see NativeJavaMethod\n+ * @see NativeJavaPackage\n+ * @see NativeJavaClass\n+ */\n+\n+public class NativeJavaConstructor extends BaseFunction\n+{\n+    static final long serialVersionUID = -8149253217482668463L;\n+\n+    MemberBox ctor;\n+\n+    public NativeJavaConstructor(MemberBox ctor)\n+    {\n+        this.ctor = ctor;\n+    }\n+\n+    @Override\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        return NativeJavaClass.constructSpecific(cx, scope, args, ctor);\n+    }\n+\n+    @Override\n+    public String getFunctionName()\n+    {\n+        String sig = JavaMembers.liveConnectSignature(ctor.argTypes);\n+        return \"<init>\".concat(sig);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"[JavaConstructor \" + ctor.getName() + \"]\";\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaMethod.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Frank Mitchell\n+ *   Mike Shaver\n+ *   Ulrike Mueller <umueller@demandware.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.reflect.*;\n+\n+/**\n+ * This class reflects Java methods into the JavaScript environment and\n+ * handles overloading of methods.\n+ *\n+ * @see NativeJavaArray\n+ * @see NativeJavaPackage\n+ * @see NativeJavaClass\n+ */\n+\n+public class NativeJavaMethod extends BaseFunction\n+{\n+    static final long serialVersionUID = -3440381785576412928L;\n+\n+    NativeJavaMethod(MemberBox[] methods)\n+    {\n+        this.functionName = methods[0].getName();\n+        this.methods = methods;\n+    }\n+\n+    NativeJavaMethod(MemberBox method, String name)\n+    {\n+        this.functionName = name;\n+        this.methods = new MemberBox[] { method };\n+    }\n+\n+    public NativeJavaMethod(Method method, String name)\n+    {\n+        this(new MemberBox(method), name);\n+    }\n+\n+    @Override\n+    public String getFunctionName()\n+    {\n+        return functionName;\n+    }\n+\n+    static String scriptSignature(Object[] values)\n+    {\n+        StringBuffer sig = new StringBuffer();\n+        for (int i = 0; i != values.length; ++i) {\n+            Object value = values[i];\n+\n+            String s;\n+            if (value == null) {\n+                s = \"null\";\n+            } else if (value instanceof Boolean) {\n+                s = \"boolean\";\n+            } else if (value instanceof String) {\n+                s = \"string\";\n+            } else if (value instanceof Number) {\n+                s = \"number\";\n+            } else if (value instanceof Scriptable) {\n+                if (value instanceof Undefined) {\n+                    s = \"undefined\";\n+                } else if (value instanceof Wrapper) {\n+                    Object wrapped = ((Wrapper)value).unwrap();\n+                    s = wrapped.getClass().getName();\n+                } else if (value instanceof Function) {\n+                    s = \"function\";\n+                } else {\n+                    s = \"object\";\n+                }\n+            } else {\n+                s = JavaMembers.javaSignature(value.getClass());\n+            }\n+\n+            if (i != 0) {\n+                sig.append(',');\n+            }\n+            sig.append(s);\n+        }\n+        return sig.toString();\n+    }\n+\n+    @Override\n+    String decompile(int indent, int flags)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        boolean justbody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));\n+        if (!justbody) {\n+            sb.append(\"function \");\n+            sb.append(getFunctionName());\n+            sb.append(\"() {\");\n+        }\n+        sb.append(\"/*\\n\");\n+        sb.append(toString());\n+        sb.append(justbody ? \"*/\\n\" : \"*/}\\n\");\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        for (int i = 0, N = methods.length; i != N; ++i) {\n+            Method method = methods[i].method();\n+            sb.append(JavaMembers.javaSignature(method.getReturnType()));\n+            sb.append(' ');\n+            sb.append(method.getName());\n+            sb.append(JavaMembers.liveConnectSignature(methods[i].argTypes));\n+            sb.append('\\n');\n+        }\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        // Find a method that matches the types given.\n+        if (methods.length == 0) {\n+            throw new RuntimeException(\"No methods defined for call\");\n+        }\n+\n+        int index = findFunction(cx, methods, args);\n+        if (index < 0) {\n+            Class<?> c = methods[0].method().getDeclaringClass();\n+            String sig = c.getName() + '.' + getFunctionName() + '(' +\n+                         scriptSignature(args) + ')';\n+            throw Context.reportRuntimeError1(\"msg.java.no_such_method\", sig);\n+        }\n+\n+        MemberBox meth = methods[index];\n+        Class<?>[] argTypes = meth.argTypes;\n+\n+        if (meth.vararg) {\n+            // marshall the explicit parameters\n+            Object[] newArgs = new Object[argTypes.length];\n+            for (int i = 0; i < argTypes.length-1; i++) {\n+                newArgs[i] = Context.jsToJava(args[i], argTypes[i]);\n+            }\n+\n+            Object varArgs;\n+\n+            // Handle special situation where a single variable parameter\n+            // is given and it is a Java or ECMA array or is null.\n+            if (args.length == argTypes.length &&\n+                (args[args.length-1] == null ||\n+                 args[args.length-1] instanceof NativeArray ||\n+                 args[args.length-1] instanceof NativeJavaArray))\n+            {\n+                // convert the ECMA array into a native array\n+                varArgs = Context.jsToJava(args[args.length-1],\n+                                           argTypes[argTypes.length - 1]);\n+            } else {\n+                // marshall the variable parameters\n+                Class<?> componentType = argTypes[argTypes.length - 1].\n+                                         getComponentType();\n+                varArgs = Array.newInstance(componentType,\n+                                            args.length - argTypes.length + 1);\n+                for (int i = 0; i < Array.getLength(varArgs); i++) {\n+                    Object value = Context.jsToJava(args[argTypes.length-1 + i],\n+                                                    componentType);\n+                    Array.set(varArgs, i, value);\n+                }\n+            }\n+\n+            // add varargs\n+            newArgs[argTypes.length-1] = varArgs;\n+            // replace the original args with the new one\n+            args = newArgs;\n+        } else {\n+            // First, we marshall the args.\n+            Object[] origArgs = args;\n+            for (int i = 0; i < args.length; i++) {\n+                Object arg = args[i];\n+                Object coerced = Context.jsToJava(arg, argTypes[i]);\n+                if (coerced != arg) {\n+                    if (origArgs == args) {\n+                        args = args.clone();\n+                    }\n+                    args[i] = coerced;\n+                }\n+            }\n+        }\n+        Object javaObject;\n+        if (meth.isStatic()) {\n+            javaObject = null;  // don't need an object\n+        } else {\n+            Scriptable o = thisObj;\n+            Class<?> c = meth.getDeclaringClass();\n+            for (;;) {\n+                if (o == null) {\n+                    throw Context.reportRuntimeError3(\n+                        \"msg.nonjava.method\", getFunctionName(),\n+                        ScriptRuntime.toString(thisObj), c.getName());\n+                }\n+                if (o instanceof Wrapper) {\n+                    javaObject = ((Wrapper)o).unwrap();\n+                    if (c.isInstance(javaObject)) {\n+                        break;\n+                    }\n+                }\n+                o = o.getPrototype();\n+            }\n+        }\n+        if (debug) {\n+            printDebug(\"Calling \", meth, args);\n+        }\n+\n+        Object retval = meth.invoke(javaObject, args);\n+        Class<?> staticType = meth.method().getReturnType();\n+\n+        if (debug) {\n+            Class<?> actualType = (retval == null) ? null\n+                                                : retval.getClass();\n+            System.err.println(\" ----- Returned \" + retval +\n+                               \" actual = \" + actualType +\n+                               \" expect = \" + staticType);\n+        }\n+\n+        Object wrapped = cx.getWrapFactory().wrap(cx, scope,\n+                                                  retval, staticType);\n+        if (debug) {\n+            Class<?> actualType = (wrapped == null) ? null\n+                                                 : wrapped.getClass();\n+            System.err.println(\" ----- Wrapped as \" + wrapped +\n+                               \" class = \" + actualType);\n+        }\n+\n+        if (wrapped == null && staticType == Void.TYPE) {\n+            wrapped = Undefined.instance;\n+        }\n+        return wrapped;\n+    }\n+\n+    /**\n+     * Find the index of the correct function to call given the set of methods\n+     * or constructors and the arguments.\n+     * If no function can be found to call, return -1.\n+     */\n+    static int findFunction(Context cx,\n+                            MemberBox[] methodsOrCtors, Object[] args)\n+    {\n+        if (methodsOrCtors.length == 0) {\n+            return -1;\n+        } else if (methodsOrCtors.length == 1) {\n+            MemberBox member = methodsOrCtors[0];\n+            Class<?>[] argTypes = member.argTypes;\n+            int alength = argTypes.length;\n+\n+            if (member.vararg) {\n+                alength--;\n+                if ( alength > args.length) {\n+                    return -1;\n+                }\n+            } else {\n+                if (alength != args.length) {\n+                    return -1;\n+                }\n+            }\n+            for (int j = 0; j != alength; ++j) {\n+                if (!NativeJavaObject.canConvert(args[j], argTypes[j])) {\n+                    if (debug) printDebug(\"Rejecting (args can't convert) \",\n+                                          member, args);\n+                    return -1;\n+                }\n+            }\n+            if (debug) printDebug(\"Found \", member, args);\n+            return 0;\n+        }\n+\n+        int firstBestFit = -1;\n+        int[] extraBestFits = null;\n+        int extraBestFitsCount = 0;\n+\n+      search:\n+        for (int i = 0; i < methodsOrCtors.length; i++) {\n+            MemberBox member = methodsOrCtors[i];\n+            Class<?>[] argTypes = member.argTypes;\n+            int alength = argTypes.length;\n+            if (member.vararg) {\n+                alength--;\n+                if ( alength > args.length) {\n+                    continue search;\n+                }\n+            } else {\n+                if (alength != args.length) {\n+                    continue search;\n+                }\n+            }\n+            for (int j = 0; j < alength; j++) {\n+                if (!NativeJavaObject.canConvert(args[j], argTypes[j])) {\n+                    if (debug) printDebug(\"Rejecting (args can't convert) \",\n+                                          member, args);\n+                    continue search;\n+                }\n+            }\n+            if (firstBestFit < 0) {\n+                if (debug) printDebug(\"Found first applicable \", member, args);\n+                firstBestFit = i;\n+            } else {\n+                // Compare with all currently fit methods.\n+                // The loop starts from -1 denoting firstBestFit and proceed\n+                // until extraBestFitsCount to avoid extraBestFits allocation\n+                // in the most common case of no ambiguity\n+                int betterCount = 0; // number of times member was prefered over\n+                                     // best fits\n+                int worseCount = 0;  // number of times best fits were prefered\n+                                     // over member\n+                for (int j = -1; j != extraBestFitsCount; ++j) {\n+                    int bestFitIndex;\n+                    if (j == -1) {\n+                        bestFitIndex = firstBestFit;\n+                    } else {\n+                        bestFitIndex = extraBestFits[j];\n+                    }\n+                    MemberBox bestFit = methodsOrCtors[bestFitIndex];\n+                    if (cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS) &&\n+                        (bestFit.member().getModifiers() & Modifier.PUBLIC) !=\n+                            (member.member().getModifiers() & Modifier.PUBLIC))\n+                    {\n+                        // When FEATURE_ENHANCED_JAVA_ACCESS gives us access\n+                        // to non-public members, continue to prefer public\n+                        // methods in overloading\n+                        if ((bestFit.member().getModifiers() & Modifier.PUBLIC) == 0)\n+                            ++betterCount;\n+                        else\n+                            ++worseCount;\n+                    } else {\n+                        int preference = preferSignature(args, argTypes,\n+                                                         member.vararg,\n+                                                         bestFit.argTypes,\n+                                                         bestFit.vararg );\n+                        if (preference == PREFERENCE_AMBIGUOUS) {\n+                            break;\n+                        } else if (preference == PREFERENCE_FIRST_ARG) {\n+                            ++betterCount;\n+                        } else if (preference == PREFERENCE_SECOND_ARG) {\n+                            ++worseCount;\n+                        } else {\n+                            if (preference != PREFERENCE_EQUAL) Kit.codeBug();\n+                            // This should not happen in theory\n+                            // but on some JVMs, Class.getMethods will return all\n+                            // static methods of the class hierarchy, even if\n+                            // a derived class's parameters match exactly.\n+                            // We want to call the derived class's method.\n+                            if (bestFit.isStatic() &&\n+                                bestFit.getDeclaringClass().isAssignableFrom(\n+                                       member.getDeclaringClass()))\n+                            {\n+                                // On some JVMs, Class.getMethods will return all\n+                                // static methods of the class hierarchy, even if\n+                                // a derived class's parameters match exactly.\n+                                // We want to call the derived class's method.\n+                                if (debug) printDebug(\n+                                    \"Substituting (overridden static)\",\n+                                    member, args);\n+                                if (j == -1) {\n+                                    firstBestFit = i;\n+                                } else {\n+                                    extraBestFits[j] = i;\n+                                }\n+                            } else {\n+                                if (debug) printDebug(\n+                                    \"Ignoring same signature member \",\n+                                    member, args);\n+                            }\n+                            continue search;\n+                        }\n+                    }\n+                }\n+                if (betterCount == 1 + extraBestFitsCount) {\n+                    // member was prefered over all best fits\n+                    if (debug) printDebug(\n+                        \"New first applicable \", member, args);\n+                    firstBestFit = i;\n+                    extraBestFitsCount = 0;\n+                } else if (worseCount == 1 + extraBestFitsCount) {\n+                    // all best fits were prefered over member, ignore it\n+                    if (debug) printDebug(\n+                        \"Rejecting (all current bests better) \", member, args);\n+                } else {\n+                    // some ambiguity was present, add member to best fit set\n+                    if (debug) printDebug(\n+                        \"Added to best fit set \", member, args);\n+                    if (extraBestFits == null) {\n+                        // Allocate maximum possible array\n+                        extraBestFits = new int[methodsOrCtors.length - 1];\n+                    }\n+                    extraBestFits[extraBestFitsCount] = i;\n+                    ++extraBestFitsCount;\n+                }\n+            }\n+        }\n+\n+        if (firstBestFit < 0) {\n+            // Nothing was found\n+            return -1;\n+        } else if (extraBestFitsCount == 0) {\n+            // single best fit\n+            return firstBestFit;\n+        }\n+\n+        // report remaining ambiguity\n+        StringBuffer buf = new StringBuffer();\n+        for (int j = -1; j != extraBestFitsCount; ++j) {\n+            int bestFitIndex;\n+            if (j == -1) {\n+                bestFitIndex = firstBestFit;\n+            } else {\n+                bestFitIndex = extraBestFits[j];\n+            }\n+            buf.append(\"\\n    \");\n+            buf.append(methodsOrCtors[bestFitIndex].toJavaDeclaration());\n+        }\n+\n+        MemberBox firstFitMember = methodsOrCtors[firstBestFit];\n+        String memberName = firstFitMember.getName();\n+        String memberClass = firstFitMember.getDeclaringClass().getName();\n+\n+        if (methodsOrCtors[0].isMethod()) {\n+            throw Context.reportRuntimeError3(\n+                \"msg.constructor.ambiguous\",\n+                memberName, scriptSignature(args), buf.toString());\n+        } else {\n+            throw Context.reportRuntimeError4(\n+                \"msg.method.ambiguous\", memberClass,\n+                memberName, scriptSignature(args), buf.toString());\n+        }\n+    }\n+\n+    /** Types are equal */\n+    private static final int PREFERENCE_EQUAL      = 0;\n+    private static final int PREFERENCE_FIRST_ARG  = 1;\n+    private static final int PREFERENCE_SECOND_ARG = 2;\n+    /** No clear \"easy\" conversion */\n+    private static final int PREFERENCE_AMBIGUOUS  = 3;\n+\n+    /**\n+     * Determine which of two signatures is the closer fit.\n+     * Returns one of PREFERENCE_EQUAL, PREFERENCE_FIRST_ARG,\n+     * PREFERENCE_SECOND_ARG, or PREFERENCE_AMBIGUOUS.\n+     */\n+    private static int preferSignature(Object[] args,\n+                                       Class<?>[] sig1,\n+                                       boolean vararg1,\n+                                       Class<?>[] sig2,\n+                                       boolean vararg2 )\n+    {\n+        int totalPreference = 0;\n+        for (int j = 0; j < args.length; j++) {\n+            Class<?> type1 = vararg1 && j >= sig1.length ? sig1[sig1.length-1] : sig1[j];\n+            Class<?> type2 = vararg2 && j >= sig1.length ? sig2[sig1.length-1] : sig2[j];\n+            if (type1 == type2) {\n+                continue;\n+            }\n+            Object arg = args[j];\n+\n+            // Determine which of type1, type2 is easier to convert from arg.\n+\n+            int rank1 = NativeJavaObject.getConversionWeight(arg, type1);\n+            int rank2 = NativeJavaObject.getConversionWeight(arg, type2);\n+\n+            int preference;\n+            if (rank1 < rank2) {\n+                preference = PREFERENCE_FIRST_ARG;\n+            } else if (rank1 > rank2) {\n+                preference = PREFERENCE_SECOND_ARG;\n+            } else {\n+                // Equal ranks\n+                if (rank1 == NativeJavaObject.CONVERSION_NONTRIVIAL) {\n+                    if (type1.isAssignableFrom(type2)) {\n+                        preference = PREFERENCE_SECOND_ARG;\n+                    } else if (type2.isAssignableFrom(type1)) {\n+                        preference = PREFERENCE_FIRST_ARG;\n+                    } else {\n+                        preference = PREFERENCE_AMBIGUOUS;\n+                    }\n+                } else {\n+                    preference = PREFERENCE_AMBIGUOUS;\n+                }\n+            }\n+\n+            totalPreference |= preference;\n+\n+            if (totalPreference == PREFERENCE_AMBIGUOUS) {\n+                break;\n+            }\n+        }\n+        return totalPreference;\n+    }\n+\n+\n+    private static final boolean debug = false;\n+\n+    private static void printDebug(String msg, MemberBox member,\n+                                   Object[] args)\n+    {\n+        if (debug) {\n+            StringBuffer sb = new StringBuffer();\n+            sb.append(\" ----- \");\n+            sb.append(msg);\n+            sb.append(member.getDeclaringClass().getName());\n+            sb.append('.');\n+            if (member.isMethod()) {\n+                sb.append(member.getName());\n+            }\n+            sb.append(JavaMembers.liveConnectSignature(member.argTypes));\n+            sb.append(\" for arguments (\");\n+            sb.append(scriptSignature(args));\n+            sb.append(')');\n+            System.out.println(sb);\n+        }\n+    }\n+\n+    MemberBox[] methods;\n+    private String functionName;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaObject.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Frank Mitchell\n+ *   Mike Shaver\n+ *   Kemal Bayram\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.*;\n+import java.lang.reflect.*;\n+import java.util.Map;\n+import java.util.Date;\n+\n+/**\n+ * This class reflects non-Array Java objects into the JavaScript environment.  It\n+ * reflect fields directly, and uses NativeJavaMethod objects to reflect (possibly\n+ * overloaded) methods.<p>\n+ *\n+ * @see NativeJavaArray\n+ * @see NativeJavaPackage\n+ * @see NativeJavaClass\n+ */\n+\n+public class NativeJavaObject implements Scriptable, Wrapper, Serializable\n+{\n+    static final long serialVersionUID = -6948590651130498591L;\n+\n+    public NativeJavaObject() { }\n+\n+    public NativeJavaObject(Scriptable scope, Object javaObject,\n+                            Class<?> staticType)\n+    {\n+        this(scope, javaObject, staticType, false);\n+    }\n+\n+    public NativeJavaObject(Scriptable scope, Object javaObject,\n+                            Class<?> staticType, boolean isAdapter)\n+    {\n+        this.parent = scope;\n+        this.javaObject = javaObject;\n+        this.staticType = staticType;\n+        this.isAdapter = isAdapter;\n+        initMembers();\n+    }\n+\n+    protected void initMembers() {\n+        Class<?> dynamicType;\n+        if (javaObject != null) {\n+            dynamicType = javaObject.getClass();\n+        } else {\n+            dynamicType = staticType;\n+        }\n+        members = JavaMembers.lookupClass(parent, dynamicType, staticType,\n+                                          isAdapter);\n+        fieldAndMethods\n+            = members.getFieldAndMethodsObjects(this, javaObject, false);\n+    }\n+\n+    public boolean has(String name, Scriptable start) {\n+        return members.has(name, false);\n+    }\n+\n+    public boolean has(int index, Scriptable start) {\n+        return false;\n+    }\n+\n+    public Object get(String name, Scriptable start) {\n+        if (fieldAndMethods != null) {\n+            Object result = fieldAndMethods.get(name);\n+            if (result != null) {\n+                return result;\n+            }\n+        }\n+        // TODO: passing 'this' as the scope is bogus since it has\n+        //  no parent scope\n+        return members.get(this, name, javaObject, false);\n+    }\n+\n+    public Object get(int index, Scriptable start) {\n+        throw members.reportMemberNotFound(Integer.toString(index));\n+    }\n+\n+    public void put(String name, Scriptable start, Object value) {\n+        // We could be asked to modify the value of a property in the\n+        // prototype. Since we can't add a property to a Java object,\n+        // we modify it in the prototype rather than copy it down.\n+        if (prototype == null || members.has(name, false))\n+            members.put(this, name, javaObject, value, false);\n+        else\n+            prototype.put(name, prototype, value);\n+    }\n+\n+    public void put(int index, Scriptable start, Object value) {\n+        throw members.reportMemberNotFound(Integer.toString(index));\n+    }\n+\n+    public boolean hasInstance(Scriptable value) {\n+        // This is an instance of a Java class, so always return false\n+        return false;\n+    }\n+\n+    public void delete(String name) {\n+    }\n+\n+    public void delete(int index) {\n+    }\n+\n+    public Scriptable getPrototype() {\n+        if (prototype == null && javaObject instanceof String) {\n+            return ScriptableObject.getClassPrototype(parent, \"String\");\n+        }\n+        return prototype;\n+    }\n+\n+    /**\n+     * Sets the prototype of the object.\n+     */\n+    public void setPrototype(Scriptable m) {\n+        prototype = m;\n+    }\n+\n+    /**\n+     * Returns the parent (enclosing) scope of the object.\n+     */\n+    public Scriptable getParentScope() {\n+        return parent;\n+    }\n+\n+    /**\n+     * Sets the parent (enclosing) scope of the object.\n+     */\n+    public void setParentScope(Scriptable m) {\n+        parent = m;\n+    }\n+\n+    public Object[] getIds() {\n+        return members.getIds(false);\n+    }\n+\n+/**\n+@deprecated Use {@link Context#getWrapFactory()} together with calling {@link\n+WrapFactory#wrap(Context, Scriptable, Object, Class)}\n+*/\n+    public static Object wrap(Scriptable scope, Object obj, Class<?> staticType) {\n+\n+        Context cx = Context.getContext();\n+        return cx.getWrapFactory().wrap(cx, scope, obj, staticType);\n+    }\n+\n+    public Object unwrap() {\n+        return javaObject;\n+    }\n+\n+    public String getClassName() {\n+        return \"JavaObject\";\n+    }\n+\n+    public Object getDefaultValue(Class<?> hint)\n+    {\n+        Object value;\n+        if (hint == null) {\n+            if (javaObject instanceof Boolean) {\n+                hint = ScriptRuntime.BooleanClass;\n+            }\n+        }\n+        if (hint == null || hint == ScriptRuntime.StringClass) {\n+            value = javaObject.toString();\n+        } else {\n+            String converterName;\n+            if (hint == ScriptRuntime.BooleanClass) {\n+                converterName = \"booleanValue\";\n+            } else if (hint == ScriptRuntime.NumberClass) {\n+                converterName = \"doubleValue\";\n+            } else {\n+                throw Context.reportRuntimeError0(\"msg.default.value\");\n+            }\n+            Object converterObject = get(converterName, this);\n+            if (converterObject instanceof Function) {\n+                Function f = (Function)converterObject;\n+                value = f.call(Context.getContext(), f.getParentScope(),\n+                               this, ScriptRuntime.emptyArgs);\n+            } else {\n+                if (hint == ScriptRuntime.NumberClass\n+                    && javaObject instanceof Boolean)\n+                {\n+                    boolean b = ((Boolean)javaObject).booleanValue();\n+                    value = ScriptRuntime.wrapNumber(b ? 1.0 : 0.0);\n+                } else {\n+                    value = javaObject.toString();\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Determine whether we can/should convert between the given type and the\n+     * desired one.  This should be superceded by a conversion-cost calculation\n+     * function, but for now I'll hide behind precedent.\n+     */\n+    public static boolean canConvert(Object fromObj, Class<?> to) {\n+        int weight = getConversionWeight(fromObj, to);\n+\n+        return (weight < CONVERSION_NONE);\n+    }\n+\n+    private static final int JSTYPE_UNDEFINED   = 0; // undefined type\n+    private static final int JSTYPE_NULL        = 1; // null\n+    private static final int JSTYPE_BOOLEAN     = 2; // boolean\n+    private static final int JSTYPE_NUMBER      = 3; // number\n+    private static final int JSTYPE_STRING      = 4; // string\n+    private static final int JSTYPE_JAVA_CLASS  = 5; // JavaClass\n+    private static final int JSTYPE_JAVA_OBJECT = 6; // JavaObject\n+    private static final int JSTYPE_JAVA_ARRAY  = 7; // JavaArray\n+    private static final int JSTYPE_OBJECT      = 8; // Scriptable\n+\n+    static final byte CONVERSION_TRIVIAL      = 1;\n+    static final byte CONVERSION_NONTRIVIAL   = 0;\n+    static final byte CONVERSION_NONE         = 99;\n+\n+    /**\n+     * Derive a ranking based on how \"natural\" the conversion is.\n+     * The special value CONVERSION_NONE means no conversion is possible,\n+     * and CONVERSION_NONTRIVIAL signals that more type conformance testing\n+     * is required.\n+     * Based on\n+     * <a href=\"http://www.mozilla.org/js/liveconnect/lc3_method_overloading.html\">\n+     * \"preferred method conversions\" from Live Connect 3</a>\n+     */\n+    static int getConversionWeight(Object fromObj, Class<?> to) {\n+        int fromCode = getJSTypeCode(fromObj);\n+\n+        switch (fromCode) {\n+\n+        case JSTYPE_UNDEFINED:\n+            if (to == ScriptRuntime.StringClass ||\n+                to == ScriptRuntime.ObjectClass) {\n+                return 1;\n+            }\n+            break;\n+\n+        case JSTYPE_NULL:\n+            if (!to.isPrimitive()) {\n+                return 1;\n+            }\n+            break;\n+\n+        case JSTYPE_BOOLEAN:\n+            // \"boolean\" is #1\n+            if (to == Boolean.TYPE) {\n+                return 1;\n+            }\n+            else if (to == ScriptRuntime.BooleanClass) {\n+                return 2;\n+            }\n+            else if (to == ScriptRuntime.ObjectClass) {\n+                return 3;\n+            }\n+            else if (to == ScriptRuntime.StringClass) {\n+                return 4;\n+            }\n+            break;\n+\n+        case JSTYPE_NUMBER:\n+            if (to.isPrimitive()) {\n+                if (to == Double.TYPE) {\n+                    return 1;\n+                }\n+                else if (to != Boolean.TYPE) {\n+                    return 1 + getSizeRank(to);\n+                }\n+            }\n+            else {\n+                if (to == ScriptRuntime.StringClass) {\n+                    // native numbers are #1-8\n+                    return 9;\n+                }\n+                else if (to == ScriptRuntime.ObjectClass) {\n+                    return 10;\n+                }\n+                else if (ScriptRuntime.NumberClass.isAssignableFrom(to)) {\n+                    // \"double\" is #1\n+                    return 2;\n+                }\n+            }\n+            break;\n+\n+        case JSTYPE_STRING:\n+            if (to == ScriptRuntime.StringClass) {\n+                return 1;\n+            }\n+            else if (to.isInstance(fromObj)) {\n+                return 2;\n+            }\n+            else if (to.isPrimitive()) {\n+                if (to == Character.TYPE) {\n+                    return 3;\n+                } else if (to != Boolean.TYPE) {\n+                    return 4;\n+                }\n+            }\n+            break;\n+\n+        case JSTYPE_JAVA_CLASS:\n+            if (to == ScriptRuntime.ClassClass) {\n+                return 1;\n+            }\n+            else if (to == ScriptRuntime.ObjectClass) {\n+                return 3;\n+            }\n+            else if (to == ScriptRuntime.StringClass) {\n+                return 4;\n+            }\n+            break;\n+\n+        case JSTYPE_JAVA_OBJECT:\n+        case JSTYPE_JAVA_ARRAY:\n+            Object javaObj = fromObj;\n+            if (javaObj instanceof Wrapper) {\n+                javaObj = ((Wrapper)javaObj).unwrap();\n+            }\n+            if (to.isInstance(javaObj)) {\n+                return CONVERSION_NONTRIVIAL;\n+            }\n+            if (to == ScriptRuntime.StringClass) {\n+                return 2;\n+            }\n+            else if (to.isPrimitive() && to != Boolean.TYPE) {\n+                return (fromCode == JSTYPE_JAVA_ARRAY)\n+                       ? CONVERSION_NONE : 2 + getSizeRank(to);\n+            }\n+            break;\n+\n+        case JSTYPE_OBJECT:\n+            // Other objects takes #1-#3 spots\n+            if (to != ScriptRuntime.ObjectClass && to.isInstance(fromObj)) {\n+                // No conversion required, but don't apply for java.lang.Object\n+                return 1;\n+            }\n+            if (to.isArray()) {\n+                if (fromObj instanceof NativeArray) {\n+                    // This is a native array conversion to a java array\n+                    // Array conversions are all equal, and preferable to object\n+                    // and string conversion, per LC3.\n+                    return 1;\n+                }\n+            }\n+            else if (to == ScriptRuntime.ObjectClass) {\n+                return 2;\n+            }\n+            else if (to == ScriptRuntime.StringClass) {\n+                return 3;\n+            }\n+            else if (to == ScriptRuntime.DateClass) {\n+                if (fromObj instanceof NativeDate) {\n+                    // This is a native date to java date conversion\n+                    return 1;\n+                }\n+            }\n+            else if (to.isInterface()) {\n+                if (fromObj instanceof Function) {\n+                    // See comments in coerceType\n+                    if (to.getMethods().length == 1) {\n+                        return 1;\n+                    }\n+                }\n+                return 11;\n+            }\n+            else if (to.isPrimitive() && to != Boolean.TYPE) {\n+                return 3 + getSizeRank(to);\n+            }\n+            break;\n+        }\n+\n+        return CONVERSION_NONE;\n+    }\n+\n+    static int getSizeRank(Class<?> aType) {\n+        if (aType == Double.TYPE) {\n+            return 1;\n+        }\n+        else if (aType == Float.TYPE) {\n+            return 2;\n+        }\n+        else if (aType == Long.TYPE) {\n+            return 3;\n+        }\n+        else if (aType == Integer.TYPE) {\n+            return 4;\n+        }\n+        else if (aType == Short.TYPE) {\n+            return 5;\n+        }\n+        else if (aType == Character.TYPE) {\n+            return 6;\n+        }\n+        else if (aType == Byte.TYPE) {\n+            return 7;\n+        }\n+        else if (aType == Boolean.TYPE) {\n+            return CONVERSION_NONE;\n+        }\n+        else {\n+            return 8;\n+        }\n+    }\n+\n+    private static int getJSTypeCode(Object value) {\n+        if (value == null) {\n+            return JSTYPE_NULL;\n+        }\n+        else if (value == Undefined.instance) {\n+            return JSTYPE_UNDEFINED;\n+        }\n+        else if (value instanceof String) {\n+            return JSTYPE_STRING;\n+        }\n+        else if (value instanceof Number) {\n+            return JSTYPE_NUMBER;\n+        }\n+        else if (value instanceof Boolean) {\n+            return JSTYPE_BOOLEAN;\n+        }\n+        else if (value instanceof Scriptable) {\n+            if (value instanceof NativeJavaClass) {\n+                return JSTYPE_JAVA_CLASS;\n+            }\n+            else if (value instanceof NativeJavaArray) {\n+                return JSTYPE_JAVA_ARRAY;\n+            }\n+            else if (value instanceof Wrapper) {\n+                return JSTYPE_JAVA_OBJECT;\n+            }\n+            else {\n+                return JSTYPE_OBJECT;\n+            }\n+        }\n+        else if (value instanceof Class) {\n+            return JSTYPE_JAVA_CLASS;\n+        }\n+        else {\n+            Class<?> valueClass = value.getClass();\n+            if (valueClass.isArray()) {\n+                return JSTYPE_JAVA_ARRAY;\n+            }\n+            else {\n+                return JSTYPE_JAVA_OBJECT;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Not intended for public use. Callers should use the\n+     * public API Context.toType.\n+     * @deprecated as of 1.5 Release 4\n+     * @see org.mozilla.javascript.Context#jsToJava(Object, Class)\n+     */\n+    public static Object coerceType(Class<?> type, Object value)\n+    {\n+        return coerceTypeImpl(type, value);\n+    }\n+\n+    /**\n+     * Type-munging for field setting and method invocation.\n+     * Conforms to LC3 specification\n+     */\n+    static Object coerceTypeImpl(Class<?> type, Object value)\n+    {\n+        if (value != null && value.getClass() == type) {\n+            return value;\n+        }\n+\n+        switch (getJSTypeCode(value)) {\n+\n+        case JSTYPE_NULL:\n+            // raise error if type.isPrimitive()\n+            if (type.isPrimitive()) {\n+                reportConversionError(value, type);\n+            }\n+            return null;\n+\n+        case JSTYPE_UNDEFINED:\n+            if (type == ScriptRuntime.StringClass ||\n+                type == ScriptRuntime.ObjectClass) {\n+                return \"undefined\";\n+            }\n+            else {\n+                reportConversionError(\"undefined\", type);\n+            }\n+            break;\n+\n+        case JSTYPE_BOOLEAN:\n+            // Under LC3, only JS Booleans can be coerced into a Boolean value\n+            if (type == Boolean.TYPE ||\n+                type == ScriptRuntime.BooleanClass ||\n+                type == ScriptRuntime.ObjectClass) {\n+                return value;\n+            }\n+            else if (type == ScriptRuntime.StringClass) {\n+                return value.toString();\n+            }\n+            else {\n+                reportConversionError(value, type);\n+            }\n+            break;\n+\n+        case JSTYPE_NUMBER:\n+            if (type == ScriptRuntime.StringClass) {\n+                return ScriptRuntime.toString(value);\n+            }\n+            else if (type == ScriptRuntime.ObjectClass) {\n+                return coerceToNumber(Double.TYPE, value);\n+            }\n+            else if ((type.isPrimitive() && type != Boolean.TYPE) ||\n+                     ScriptRuntime.NumberClass.isAssignableFrom(type)) {\n+                return coerceToNumber(type, value);\n+            }\n+            else {\n+                reportConversionError(value, type);\n+            }\n+            break;\n+\n+        case JSTYPE_STRING:\n+            if (type == ScriptRuntime.StringClass || type.isInstance(value)) {\n+                return value;\n+            }\n+            else if (type == Character.TYPE\n+                     || type == ScriptRuntime.CharacterClass)\n+            {\n+                // Special case for converting a single char string to a\n+                // character\n+                // Placed here because it applies *only* to JS strings,\n+                // not other JS objects converted to strings\n+                if (((String)value).length() == 1) {\n+                    return Character.valueOf(((String)value).charAt(0));\n+                }\n+                else {\n+                    return coerceToNumber(type, value);\n+                }\n+            }\n+            else if ((type.isPrimitive() && type != Boolean.TYPE)\n+                     || ScriptRuntime.NumberClass.isAssignableFrom(type))\n+            {\n+                return coerceToNumber(type, value);\n+            }\n+            else {\n+                reportConversionError(value, type);\n+            }\n+            break;\n+\n+        case JSTYPE_JAVA_CLASS:\n+            if (value instanceof Wrapper) {\n+                value = ((Wrapper)value).unwrap();\n+            }\n+\n+            if (type == ScriptRuntime.ClassClass ||\n+                type == ScriptRuntime.ObjectClass) {\n+                return value;\n+            }\n+            else if (type == ScriptRuntime.StringClass) {\n+                return value.toString();\n+            }\n+            else {\n+                reportConversionError(value, type);\n+            }\n+            break;\n+\n+        case JSTYPE_JAVA_OBJECT:\n+        case JSTYPE_JAVA_ARRAY:\n+            if (value instanceof Wrapper) {\n+              value = ((Wrapper)value).unwrap();\n+            }\n+            if (type.isPrimitive()) {\n+                if (type == Boolean.TYPE) {\n+                    reportConversionError(value, type);\n+                }\n+                return coerceToNumber(type, value);\n+            }\n+            else {\n+              if (type == ScriptRuntime.StringClass) {\n+                    return value.toString();\n+                }\n+                else {\n+                    if (type.isInstance(value)) {\n+                        return value;\n+                    }\n+                    else {\n+                        reportConversionError(value, type);\n+                    }\n+                }\n+            }\n+            break;\n+\n+        case JSTYPE_OBJECT:\n+            if (type == ScriptRuntime.StringClass) {\n+                return ScriptRuntime.toString(value);\n+            }\n+            else if (type.isPrimitive()) {\n+                if (type == Boolean.TYPE) {\n+                    reportConversionError(value, type);\n+                }\n+                return coerceToNumber(type, value);\n+            }\n+            else if (type.isInstance(value)) {\n+                return value;\n+            }\n+            else if (type == ScriptRuntime.DateClass\n+                     && value instanceof NativeDate)\n+            {\n+                double time = ((NativeDate)value).getJSTimeValue();\n+                // XXX: This will replace NaN by 0\n+                return new Date((long)time);\n+            }\n+            else if (type.isArray() && value instanceof NativeArray) {\n+                // Make a new java array, and coerce the JS array components\n+                // to the target (component) type.\n+                NativeArray array = (NativeArray) value;\n+                long length = array.getLength();\n+                Class<?> arrayType = type.getComponentType();\n+                Object Result = Array.newInstance(arrayType, (int)length);\n+                for (int i = 0 ; i < length ; ++i) {\n+                    try  {\n+                        Array.set(Result, i, coerceType(arrayType,\n+                                                        array.get(i, array)));\n+                    }\n+                    catch (EvaluatorException ee) {\n+                        reportConversionError(value, type);\n+                    }\n+                }\n+\n+                return Result;\n+            }\n+            else if (value instanceof Wrapper) {\n+                value = ((Wrapper)value).unwrap();\n+                if (type.isInstance(value))\n+                    return value;\n+                reportConversionError(value, type);\n+            }\n+            else if (type.isInterface() && value instanceof Callable) {\n+                // Try to use function as implementation of Java interface.\n+                //\n+                // XXX: Currently only instances of ScriptableObject are\n+                // supported since the resulting interface proxies should\n+                // be reused next time conversion is made and generic\n+                // Callable has no storage for it. Weak references can\n+                // address it but for now use this restriction.\n+                if (value instanceof ScriptableObject) {\n+                    ScriptableObject so = (ScriptableObject)value;\n+                    Object key = Kit.makeHashKeyFromPair(\n+                        COERCED_INTERFACE_KEY, type);\n+                    Object old = so.getAssociatedValue(key);\n+                    if (old != null) {\n+                        // Function was already wrapped\n+                        return old;\n+                    }\n+                    Context cx = Context.getContext();\n+                    Object glue\n+                        = InterfaceAdapter.create(cx, type, (Callable)value);\n+                    // Store for later retrival\n+                    glue = so.associateValue(key, glue);\n+                    return glue;\n+                }\n+                reportConversionError(value, type);\n+            } else {\n+                reportConversionError(value, type);\n+            }\n+            break;\n+        }\n+\n+        return value;\n+    }\n+\n+    private static Object coerceToNumber(Class<?> type, Object value)\n+    {\n+        Class<?> valueClass = value.getClass();\n+\n+        // Character\n+        if (type == Character.TYPE || type == ScriptRuntime.CharacterClass) {\n+            if (valueClass == ScriptRuntime.CharacterClass) {\n+                return value;\n+            }\n+            return Character.valueOf((char)toInteger(value,\n+                                                 ScriptRuntime.CharacterClass,\n+                                                 Character.MIN_VALUE,\n+                                                 Character.MAX_VALUE));\n+        }\n+\n+        // Double, Float\n+        if (type == ScriptRuntime.ObjectClass ||\n+            type == ScriptRuntime.DoubleClass || type == Double.TYPE) {\n+            return valueClass == ScriptRuntime.DoubleClass\n+                ? value\n+                : new Double(toDouble(value));\n+        }\n+\n+        if (type == ScriptRuntime.FloatClass || type == Float.TYPE) {\n+            if (valueClass == ScriptRuntime.FloatClass) {\n+                return value;\n+            }\n+            else {\n+                double number = toDouble(value);\n+                if (Double.isInfinite(number) || Double.isNaN(number)\n+                    || number == 0.0) {\n+                    return new Float((float)number);\n+                }\n+                else {\n+                    double absNumber = Math.abs(number);\n+                    if (absNumber < Float.MIN_VALUE) {\n+                        return new Float((number > 0.0) ? +0.0 : -0.0);\n+                    }\n+                    else if (absNumber > Float.MAX_VALUE) {\n+                        return new Float((number > 0.0) ?\n+                                         Float.POSITIVE_INFINITY :\n+                                         Float.NEGATIVE_INFINITY);\n+                    }\n+                    else {\n+                        return new Float((float)number);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Integer, Long, Short, Byte\n+        if (type == ScriptRuntime.IntegerClass || type == Integer.TYPE) {\n+            if (valueClass == ScriptRuntime.IntegerClass) {\n+                return value;\n+            }\n+            else {\n+                return Integer.valueOf((int)toInteger(value,\n+                                                  ScriptRuntime.IntegerClass,\n+                                                  Integer.MIN_VALUE,\n+                                                  Integer.MAX_VALUE));\n+            }\n+        }\n+\n+        if (type == ScriptRuntime.LongClass || type == Long.TYPE) {\n+            if (valueClass == ScriptRuntime.LongClass) {\n+                return value;\n+            } else {\n+                /* Long values cannot be expressed exactly in doubles.\n+                 * We thus use the largest and smallest double value that\n+                 * has a value expressible as a long value. We build these\n+                 * numerical values from their hexidecimal representations\n+                 * to avoid any problems caused by attempting to parse a\n+                 * decimal representation.\n+                 */\n+                final double max = Double.longBitsToDouble(0x43dfffffffffffffL);\n+                final double min = Double.longBitsToDouble(0xc3e0000000000000L);\n+                return Long.valueOf(toInteger(value,\n+                                          ScriptRuntime.LongClass,\n+                                          min,\n+                                          max));\n+            }\n+        }\n+\n+        if (type == ScriptRuntime.ShortClass || type == Short.TYPE) {\n+            if (valueClass == ScriptRuntime.ShortClass) {\n+                return value;\n+            }\n+            else {\n+                return Short.valueOf((short)toInteger(value,\n+                                                  ScriptRuntime.ShortClass,\n+                                                  Short.MIN_VALUE,\n+                                                  Short.MAX_VALUE));\n+            }\n+        }\n+\n+        if (type == ScriptRuntime.ByteClass || type == Byte.TYPE) {\n+            if (valueClass == ScriptRuntime.ByteClass) {\n+                return value;\n+            }\n+            else {\n+                return Byte.valueOf((byte)toInteger(value,\n+                                                ScriptRuntime.ByteClass,\n+                                                Byte.MIN_VALUE,\n+                                                Byte.MAX_VALUE));\n+            }\n+        }\n+\n+        return new Double(toDouble(value));\n+    }\n+\n+\n+    private static double toDouble(Object value)\n+    {\n+        if (value instanceof Number) {\n+            return ((Number)value).doubleValue();\n+        }\n+        else if (value instanceof String) {\n+            return ScriptRuntime.toNumber((String)value);\n+        }\n+        else if (value instanceof Scriptable) {\n+            if (value instanceof Wrapper) {\n+                // XXX: optimize tail-recursion?\n+                return toDouble(((Wrapper)value).unwrap());\n+            }\n+            else {\n+                return ScriptRuntime.toNumber(value);\n+            }\n+        }\n+        else {\n+            Method meth;\n+            try {\n+                meth = value.getClass().getMethod(\"doubleValue\",\n+                \t\t                          (Class [])null);\n+            }\n+            catch (NoSuchMethodException e) {\n+                meth = null;\n+            }\n+            catch (SecurityException e) {\n+                meth = null;\n+            }\n+            if (meth != null) {\n+                try {\n+                    return ((Number)meth.invoke(value,\n+                    \t\t                    (Object [])null)).doubleValue();\n+                }\n+                catch (IllegalAccessException e) {\n+                    // XXX: ignore, or error message?\n+                    reportConversionError(value, Double.TYPE);\n+                }\n+                catch (InvocationTargetException e) {\n+                    // XXX: ignore, or error message?\n+                    reportConversionError(value, Double.TYPE);\n+                }\n+            }\n+            return ScriptRuntime.toNumber(value.toString());\n+        }\n+    }\n+\n+    private static long toInteger(Object value, Class<?> type,\n+                                  double min, double max)\n+    {\n+        double d = toDouble(value);\n+\n+        if (Double.isInfinite(d) || Double.isNaN(d)) {\n+            // Convert to string first, for more readable message\n+            reportConversionError(ScriptRuntime.toString(value), type);\n+        }\n+\n+        if (d > 0.0) {\n+            d = Math.floor(d);\n+        }\n+        else {\n+            d = Math.ceil(d);\n+        }\n+\n+        if (d < min || d > max) {\n+            // Convert to string first, for more readable message\n+            reportConversionError(ScriptRuntime.toString(value), type);\n+        }\n+        return (long)d;\n+    }\n+\n+    static void reportConversionError(Object value, Class<?> type)\n+    {\n+        // It uses String.valueOf(value), not value.toString() since\n+        // value can be null, bug 282447.\n+        throw Context.reportRuntimeError2(\n+            \"msg.conversion.not.allowed\",\n+            String.valueOf(value),\n+            JavaMembers.javaSignature(type));\n+    }\n+\n+    private void writeObject(ObjectOutputStream out)\n+        throws IOException\n+    {\n+        out.defaultWriteObject();\n+\n+        out.writeBoolean(isAdapter);\n+        if (isAdapter) {\n+            if (adapter_writeAdapterObject == null) {\n+                throw new IOException();\n+            }\n+            Object[] args = { javaObject, out };\n+            try {\n+                adapter_writeAdapterObject.invoke(null, args);\n+            } catch (Exception ex) {\n+                throw new IOException();\n+            }\n+        } else {\n+            out.writeObject(javaObject);\n+        }\n+\n+        if (staticType != null) {\n+            out.writeObject(staticType.getClass().getName());\n+        } else {\n+            out.writeObject(null);\n+        }\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException\n+    {\n+        in.defaultReadObject();\n+\n+        isAdapter = in.readBoolean();\n+        if (isAdapter) {\n+            if (adapter_readAdapterObject == null)\n+                throw new ClassNotFoundException();\n+            Object[] args = { this, in };\n+            try {\n+                javaObject = adapter_readAdapterObject.invoke(null, args);\n+            } catch (Exception ex) {\n+                throw new IOException();\n+            }\n+        } else {\n+            javaObject = in.readObject();\n+        }\n+\n+        String className = (String)in.readObject();\n+        if (className != null) {\n+            staticType = Class.forName(className);\n+        } else {\n+            staticType = null;\n+        }\n+\n+        initMembers();\n+    }\n+\n+    /**\n+     * The prototype of this object.\n+     */\n+    protected Scriptable prototype;\n+\n+    /**\n+     * The parent scope of this object.\n+     */\n+    protected Scriptable parent;\n+\n+    protected transient Object javaObject;\n+\n+    protected transient Class<?> staticType;\n+    protected transient JavaMembers members;\n+    private transient Map<String,FieldAndMethods> fieldAndMethods;\n+    private transient boolean isAdapter;\n+\n+    private static final Object COERCED_INTERFACE_KEY = \"Coerced Interface\";\n+    private static Method adapter_writeAdapterObject;\n+    private static Method adapter_readAdapterObject;\n+\n+    static {\n+        // Reflection in java is verbose\n+        Class<?>[] sig2 = new Class[2];\n+        Class<?> cl = Kit.classOrNull(\"org.mozilla.javascript.JavaAdapter\");\n+        if (cl != null) {\n+            try {\n+                sig2[0] = ScriptRuntime.ObjectClass;\n+                sig2[1] = Kit.classOrNull(\"java.io.ObjectOutputStream\");\n+                adapter_writeAdapterObject = cl.getMethod(\"writeAdapterObject\",\n+                                                          sig2);\n+\n+                sig2[0] = ScriptRuntime.ScriptableClass;\n+                sig2[1] = Kit.classOrNull(\"java.io.ObjectInputStream\");\n+                adapter_readAdapterObject = cl.getMethod(\"readAdapterObject\",\n+                                                         sig2);\n+\n+            } catch (Exception ex) {\n+                adapter_writeAdapterObject = null;\n+                adapter_readAdapterObject = null;\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaPackage.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Frank Mitchell\n+ *   Mike Shaver\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * This class reflects Java packages into the JavaScript environment.  We\n+ * lazily reflect classes and subpackages, and use a caching/sharing\n+ * system to ensure that members reflected into one JavaPackage appear\n+ * in all other references to the same package (as with Packages.java.lang\n+ * and java.lang).\n+ *\n+ * @see NativeJavaArray\n+ * @see NativeJavaObject\n+ * @see NativeJavaClass\n+ */\n+\n+public class NativeJavaPackage extends ScriptableObject\n+{\n+    static final long serialVersionUID = 7445054382212031523L;\n+\n+    NativeJavaPackage(boolean internalUsage, String packageName,\n+                      ClassLoader classLoader)\n+    {\n+        this.packageName = packageName;\n+        this.classLoader = classLoader;\n+    }\n+\n+    /**\n+     * @deprecated NativeJavaPackage is an internal class, do not use\n+     * it directly.\n+     */\n+    public NativeJavaPackage(String packageName, ClassLoader classLoader) {\n+        this(false, packageName, classLoader);\n+    }\n+\n+    /**\n+     * @deprecated NativeJavaPackage is an internal class, do not use\n+     * it directly.\n+     */\n+    public NativeJavaPackage(String packageName) {\n+        this(false, packageName,\n+             Context.getCurrentContext().getApplicationClassLoader());\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return \"JavaPackage\";\n+    }\n+\n+    @Override\n+    public boolean has(String id, Scriptable start) {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean has(int index, Scriptable start) {\n+        return false;\n+    }\n+\n+    @Override\n+    public void put(String id, Scriptable start, Object value) {\n+        // Can't add properties to Java packages.  Sorry.\n+    }\n+\n+    @Override\n+    public void put(int index, Scriptable start, Object value) {\n+        throw Context.reportRuntimeError0(\"msg.pkg.int\");\n+    }\n+\n+    @Override\n+    public Object get(String id, Scriptable start) {\n+        return getPkgProperty(id, start, true);\n+    }\n+\n+    @Override\n+    public Object get(int index, Scriptable start) {\n+        return NOT_FOUND;\n+    }\n+\n+    // set up a name which is known to be a package so we don't\n+    // need to look for a class by that name\n+    NativeJavaPackage forcePackage(String name, Scriptable scope)\n+    {\n+        Object cached = super.get(name, this);\n+        if (cached != null && cached instanceof NativeJavaPackage) {\n+            return (NativeJavaPackage) cached;\n+        } else {\n+            String newPackage = packageName.length() == 0\n+                                ? name\n+                                : packageName + \".\" + name;\n+            NativeJavaPackage pkg = new NativeJavaPackage(true, newPackage, classLoader);\n+            ScriptRuntime.setObjectProtoAndParent(pkg, scope);\n+            super.put(name, this, pkg);\n+            return pkg;\n+        }\n+    }\n+\n+    synchronized Object getPkgProperty(String name, Scriptable start,\n+                                       boolean createPkg)\n+    {\n+        Object cached = super.get(name, start);\n+        if (cached != NOT_FOUND)\n+            return cached;\n+        if (negativeCache != null && negativeCache.contains(name)) {\n+            // Performance optimization: see bug 421071\n+            return null;\n+        }\n+\n+        String className = (packageName.length() == 0)\n+                               ? name : packageName + '.' + name;\n+        Context cx = Context.getContext();\n+        ClassShutter shutter = cx.getClassShutter();\n+        Scriptable newValue = null;\n+        if (shutter == null || shutter.visibleToScripts(className)) {\n+            Class<?> cl = null;\n+            if (classLoader != null) {\n+                cl = Kit.classOrNull(classLoader, className);\n+            } else {\n+                cl = Kit.classOrNull(className);\n+            }\n+            if (cl != null) {\n+                newValue = new NativeJavaClass(getTopLevelScope(this), cl);\n+                newValue.setPrototype(getPrototype());\n+            }\n+        }\n+        if (newValue == null) {\n+            if (createPkg) {\n+                NativeJavaPackage pkg;\n+                pkg = new NativeJavaPackage(true, className, classLoader);\n+                ScriptRuntime.setObjectProtoAndParent(pkg, getParentScope());\n+                newValue = pkg;\n+            } else {\n+                // add to negative cache\n+                if (negativeCache == null)\n+                    negativeCache = new HashSet<String>();\n+                negativeCache.add(name);\n+            }\n+        }\n+        if (newValue != null) {\n+            // Make it available for fast lookup and sharing of\n+            // lazily-reflected constructors and static members.\n+            super.put(name, start, newValue);\n+        }\n+        return newValue;\n+    }\n+\n+    @Override\n+    public Object getDefaultValue(Class<?> ignored) {\n+        return toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"[JavaPackage \" + packageName + \"]\";\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if(obj instanceof NativeJavaPackage) {\n+            NativeJavaPackage njp = (NativeJavaPackage)obj;\n+            return packageName.equals(njp.packageName) &&\n+                   classLoader == njp.classLoader;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return packageName.hashCode() ^\n+               (classLoader == null ? 0 : classLoader.hashCode());\n+    }\n+\n+    private String packageName;\n+    private ClassLoader classLoader;\n+    private Set<String> negativeCache = null;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaTopPackage.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Frank Mitchell\n+ *   Mike Shaver\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class reflects Java packages into the JavaScript environment.  We\n+ * lazily reflect classes and subpackages, and use a caching/sharing\n+ * system to ensure that members reflected into one JavaPackage appear\n+ * in all other references to the same package (as with Packages.java.lang\n+ * and java.lang).\n+ *\n+ * @see NativeJavaArray\n+ * @see NativeJavaObject\n+ * @see NativeJavaClass\n+ */\n+\n+public class NativeJavaTopPackage\n+    extends NativeJavaPackage implements Function, IdFunctionCall\n+{\n+    static final long serialVersionUID = -1455787259477709999L;\n+\n+    // we know these are packages so we can skip the class check\n+    // note that this is ok even if the package isn't present.\n+    private static final String[][] commonPackages = {\n+            {\"java\", \"lang\", \"reflect\"},\n+            {\"java\", \"io\"},\n+            {\"java\", \"math\"},\n+            {\"java\", \"net\"},\n+            {\"java\", \"util\", \"zip\"},\n+            {\"java\", \"text\", \"resources\"},\n+            {\"java\", \"applet\"},\n+            {\"javax\", \"swing\"}\n+    };\n+\n+    NativeJavaTopPackage(ClassLoader loader)\n+    {\n+        super(true, \"\", loader);\n+    }\n+\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        return construct(cx, scope, args);\n+    }\n+\n+    public Scriptable construct(Context cx, Scriptable scope, Object[] args)\n+    {\n+        ClassLoader loader = null;\n+        if (args.length != 0) {\n+            Object arg = args[0];\n+            if (arg instanceof Wrapper) {\n+                arg = ((Wrapper)arg).unwrap();\n+            }\n+            if (arg instanceof ClassLoader) {\n+                loader = (ClassLoader)arg;\n+            }\n+        }\n+        if (loader == null) {\n+            Context.reportRuntimeError0(\"msg.not.classloader\");\n+            return null;\n+        }\n+        NativeJavaPackage pkg = new NativeJavaPackage(true, \"\", loader);\n+        ScriptRuntime.setObjectProtoAndParent(pkg, scope);\n+        return pkg;\n+    }\n+\n+    public static void init(Context cx, Scriptable scope, boolean sealed)\n+    {\n+        ClassLoader loader = cx.getApplicationClassLoader();\n+        final NativeJavaTopPackage top = new NativeJavaTopPackage(loader);\n+        top.setPrototype(getObjectPrototype(scope));\n+        top.setParentScope(scope);\n+\n+        for (int i = 0; i != commonPackages.length; i++) {\n+            NativeJavaPackage parent = top;\n+            for (int j = 0; j != commonPackages[i].length; j++) {\n+                parent = parent.forcePackage(commonPackages[i][j], scope);\n+            }\n+        }\n+\n+        // getClass implementation\n+        IdFunctionObject getClass = new IdFunctionObject(top, FTAG, Id_getClass,\n+                                                         \"getClass\", 1, scope);\n+\n+        // We want to get a real alias, and not a distinct JavaPackage\n+        // with the same packageName, so that we share classes and top\n+        // that are underneath.\n+        String[] topNames = { \"java\", \"javax\", \"org\", \"com\", \"edu\", \"net\" };\n+        NativeJavaPackage[] topPackages = new NativeJavaPackage[topNames.length];\n+        for (int i=0; i < topNames.length; i++) {\n+            topPackages[i] = (NativeJavaPackage)top.get(topNames[i], top);\n+        }\n+\n+        // It's safe to downcast here since initStandardObjects takes\n+        // a ScriptableObject.\n+        ScriptableObject global = (ScriptableObject) scope;\n+\n+        if (sealed) {\n+            getClass.sealObject();\n+        }\n+        getClass.exportAsScopeProperty();\n+        global.defineProperty(\"Packages\", top, ScriptableObject.DONTENUM);\n+        for (int i=0; i < topNames.length; i++) {\n+            global.defineProperty(topNames[i], topPackages[i],\n+                                  ScriptableObject.DONTENUM);\n+        }\n+    }\n+\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (f.hasTag(FTAG)) {\n+            if (f.methodId() == Id_getClass) {\n+                return js_getClass(cx, scope, args);\n+            }\n+        }\n+        throw f.unknown();\n+    }\n+\n+    private Scriptable js_getClass(Context cx, Scriptable scope, Object[] args)\n+    {\n+        if (args.length > 0  && args[0] instanceof Wrapper) {\n+            Scriptable result = this;\n+            Class<?> cl = ((Wrapper) args[0]).unwrap().getClass();\n+            // Evaluate the class name by getting successive properties of\n+            // the string to find the appropriate NativeJavaClass object\n+            String name = cl.getName();\n+            int offset = 0;\n+            for (;;) {\n+                int index = name.indexOf('.', offset);\n+                String propName = index == -1\n+                                  ? name.substring(offset)\n+                                  : name.substring(offset, index);\n+                Object prop = result.get(propName, result);\n+                if (!(prop instanceof Scriptable))\n+                    break;  // fall through to error\n+                result = (Scriptable) prop;\n+                if (index == -1)\n+                    return result;\n+                offset = index+1;\n+            }\n+        }\n+        throw Context.reportRuntimeError0(\"msg.not.java.obj\");\n+    }\n+\n+    private static final Object FTAG = \"JavaTopPackage\";\n+    private static final int Id_getClass = 1;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeMath.java\n+/* -*- Mode: java; tab-width: 4; indent-tabs-mode: 1; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class implements the Math native object.\n+ * See ECMA 15.8.\n+ */\n+\n+final class NativeMath extends IdScriptableObject\n+{\n+    static final long serialVersionUID = -8838847185801131569L;\n+\n+    private static final Object MATH_TAG = \"Math\";\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeMath obj = new NativeMath();\n+        obj.activatePrototypeMap(MAX_ID);\n+        obj.setPrototype(getObjectPrototype(scope));\n+        obj.setParentScope(scope);\n+        if (sealed) { obj.sealObject(); }\n+        ScriptableObject.defineProperty(scope, \"Math\", obj,\n+                                        ScriptableObject.DONTENUM);\n+    }\n+\n+    private NativeMath()\n+    {\n+    }\n+\n+    @Override\n+    public String getClassName() { return \"Math\"; }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        if (id <= LAST_METHOD_ID) {\n+            String name;\n+            int arity;\n+            switch (id) {\n+              case Id_toSource: arity = 0; name = \"toSource\"; break;\n+              case Id_abs:      arity = 1; name = \"abs\";      break;\n+              case Id_acos:     arity = 1; name = \"acos\";     break;\n+              case Id_asin:     arity = 1; name = \"asin\";     break;\n+              case Id_atan:     arity = 1; name = \"atan\";     break;\n+              case Id_atan2:    arity = 2; name = \"atan2\";    break;\n+              case Id_ceil:     arity = 1; name = \"ceil\";     break;\n+              case Id_cos:      arity = 1; name = \"cos\";      break;\n+              case Id_exp:      arity = 1; name = \"exp\";      break;\n+              case Id_floor:    arity = 1; name = \"floor\";    break;\n+              case Id_log:      arity = 1; name = \"log\";      break;\n+              case Id_max:      arity = 2; name = \"max\";      break;\n+              case Id_min:      arity = 2; name = \"min\";      break;\n+              case Id_pow:      arity = 2; name = \"pow\";      break;\n+              case Id_random:   arity = 0; name = \"random\";   break;\n+              case Id_round:    arity = 1; name = \"round\";    break;\n+              case Id_sin:      arity = 1; name = \"sin\";      break;\n+              case Id_sqrt:     arity = 1; name = \"sqrt\";     break;\n+              case Id_tan:      arity = 1; name = \"tan\";      break;\n+              default: throw new IllegalStateException(String.valueOf(id));\n+            }\n+            initPrototypeMethod(MATH_TAG, id, name, arity);\n+        } else {\n+            String name;\n+            double x;\n+            switch (id) {\n+              case Id_E:       x = Math.E;             name = \"E\";       break;\n+              case Id_PI:      x = Math.PI;            name = \"PI\";      break;\n+              case Id_LN10:    x = 2.302585092994046;  name = \"LN10\";    break;\n+              case Id_LN2:     x = 0.6931471805599453; name = \"LN2\";     break;\n+              case Id_LOG2E:   x = 1.4426950408889634; name = \"LOG2E\";   break;\n+              case Id_LOG10E:  x = 0.4342944819032518; name = \"LOG10E\";  break;\n+              case Id_SQRT1_2: x = 0.7071067811865476; name = \"SQRT1_2\"; break;\n+              case Id_SQRT2:   x = 1.4142135623730951; name = \"SQRT2\";   break;\n+              default: throw new IllegalStateException(String.valueOf(id));\n+            }\n+            initPrototypeValue(id, name, ScriptRuntime.wrapNumber(x),\n+                               DONTENUM | READONLY | PERMANENT);\n+        }\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(MATH_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        double x;\n+        int methodId = f.methodId();\n+        switch (methodId) {\n+            case Id_toSource:\n+                return \"Math\";\n+\n+            case Id_abs:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                // abs(-0.0) should be 0.0, but -0.0 < 0.0 == false\n+                x = (x == 0.0) ? 0.0 : (x < 0.0) ? -x : x;\n+                break;\n+\n+            case Id_acos:\n+            case Id_asin:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                if (x == x && -1.0 <= x && x <= 1.0) {\n+                    x = (methodId == Id_acos) ? Math.acos(x) : Math.asin(x);\n+                } else {\n+                    x = Double.NaN;\n+                }\n+                break;\n+\n+            case Id_atan:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                x = Math.atan(x);\n+                break;\n+\n+            case Id_atan2:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                x = Math.atan2(x, ScriptRuntime.toNumber(args, 1));\n+                break;\n+\n+            case Id_ceil:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                x = Math.ceil(x);\n+                break;\n+\n+            case Id_cos:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                x = (x == Double.POSITIVE_INFINITY\n+                     || x == Double.NEGATIVE_INFINITY)\n+                    ? Double.NaN : Math.cos(x);\n+                break;\n+\n+            case Id_exp:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                x = (x == Double.POSITIVE_INFINITY) ? x\n+                    : (x == Double.NEGATIVE_INFINITY) ? 0.0\n+                    : Math.exp(x);\n+                break;\n+\n+            case Id_floor:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                x = Math.floor(x);\n+                break;\n+\n+            case Id_log:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                // Java's log(<0) = -Infinity; we need NaN\n+                x = (x < 0) ? Double.NaN : Math.log(x);\n+                break;\n+\n+            case Id_max:\n+            case Id_min:\n+                x = (methodId == Id_max)\n+                    ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n+                for (int i = 0; i != args.length; ++i) {\n+                    double d = ScriptRuntime.toNumber(args[i]);\n+                    if (d != d) {\n+                        x = d; // NaN\n+                        break;\n+                    }\n+                    if (methodId == Id_max) {\n+                        // if (x < d) x = d; does not work due to -0.0 >= +0.0\n+                        x = Math.max(x, d);\n+                    } else {\n+                        x = Math.min(x, d);\n+                    }\n+                }\n+                break;\n+\n+            case Id_pow:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                x = js_pow(x, ScriptRuntime.toNumber(args, 1));\n+                break;\n+\n+            case Id_random:\n+                x = Math.random();\n+                break;\n+\n+            case Id_round:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                if (x == x && x != Double.POSITIVE_INFINITY\n+                    && x != Double.NEGATIVE_INFINITY)\n+                {\n+                    // Round only finite x\n+                    long l = Math.round(x);\n+                    if (l != 0) {\n+                        x = l;\n+                    } else {\n+                        // We must propagate the sign of d into the result\n+                        if (x < 0.0) {\n+                            x = ScriptRuntime.negativeZero;\n+                        } else if (x != 0.0) {\n+                            x = 0.0;\n+                        }\n+                    }\n+                }\n+                break;\n+\n+            case Id_sin:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                x = (x == Double.POSITIVE_INFINITY\n+                     || x == Double.NEGATIVE_INFINITY)\n+                    ? Double.NaN : Math.sin(x);\n+                break;\n+\n+            case Id_sqrt:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                x = Math.sqrt(x);\n+                break;\n+\n+            case Id_tan:\n+                x = ScriptRuntime.toNumber(args, 0);\n+                x = Math.tan(x);\n+                break;\n+\n+            default: throw new IllegalStateException(String.valueOf(methodId));\n+        }\n+        return ScriptRuntime.wrapNumber(x);\n+    }\n+\n+    // See Ecma 15.8.2.13\n+    private double js_pow(double x, double y) {\n+        double result;\n+        if (y != y) {\n+            // y is NaN, result is always NaN\n+            result = y;\n+        } else if (y == 0) {\n+            // Java's pow(NaN, 0) = NaN; we need 1\n+            result = 1.0;\n+        } else if (x == 0) {\n+            // Many differences from Java's Math.pow\n+            if (1 / x > 0) {\n+                result = (y > 0) ? 0 : Double.POSITIVE_INFINITY;\n+            } else {\n+                // x is -0, need to check if y is an odd integer\n+                long y_long = (long)y;\n+                if (y_long == y && (y_long & 0x1) != 0) {\n+                    result = (y > 0) ? -0.0 : Double.NEGATIVE_INFINITY;\n+                } else {\n+                    result = (y > 0) ? 0.0 : Double.POSITIVE_INFINITY;\n+                }\n+            }\n+        } else {\n+            result = Math.pow(x, y);\n+            if (result != result) {\n+                // Check for broken Java implementations that gives NaN\n+                // when they should return something else\n+                if (y == Double.POSITIVE_INFINITY) {\n+                    if (x < -1.0 || 1.0 < x) {\n+                        result = Double.POSITIVE_INFINITY;\n+                    } else if (-1.0 < x && x < 1.0) {\n+                        result = 0;\n+                    }\n+                } else if (y == Double.NEGATIVE_INFINITY) {\n+                    if (x < -1.0 || 1.0 < x) {\n+                        result = 0;\n+                    } else if (-1.0 < x && x < 1.0) {\n+                        result = Double.POSITIVE_INFINITY;\n+                    }\n+                } else if (x == Double.POSITIVE_INFINITY) {\n+                    result = (y > 0) ? Double.POSITIVE_INFINITY : 0.0;\n+                } else if (x == Double.NEGATIVE_INFINITY) {\n+                    long y_long = (long)y;\n+                    if (y_long == y && (y_long & 0x1) != 0) {\n+                        // y is odd integer\n+                        result = (y > 0) ? Double.NEGATIVE_INFINITY : -0.0;\n+                    } else {\n+                        result = (y > 0) ? Double.POSITIVE_INFINITY : 0.0;\n+                    }\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2004-03-17 13:51:32 CET\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 1: if (s.charAt(0)=='E') {id=Id_E; break L0;} break L;\n+            case 2: if (s.charAt(0)=='P' && s.charAt(1)=='I') {id=Id_PI; break L0;} break L;\n+            case 3: switch (s.charAt(0)) {\n+                case 'L': if (s.charAt(2)=='2' && s.charAt(1)=='N') {id=Id_LN2; break L0;} break L;\n+                case 'a': if (s.charAt(2)=='s' && s.charAt(1)=='b') {id=Id_abs; break L0;} break L;\n+                case 'c': if (s.charAt(2)=='s' && s.charAt(1)=='o') {id=Id_cos; break L0;} break L;\n+                case 'e': if (s.charAt(2)=='p' && s.charAt(1)=='x') {id=Id_exp; break L0;} break L;\n+                case 'l': if (s.charAt(2)=='g' && s.charAt(1)=='o') {id=Id_log; break L0;} break L;\n+                case 'm': c=s.charAt(2);\n+                    if (c=='n') { if (s.charAt(1)=='i') {id=Id_min; break L0;} }\n+                    else if (c=='x') { if (s.charAt(1)=='a') {id=Id_max; break L0;} }\n+                    break L;\n+                case 'p': if (s.charAt(2)=='w' && s.charAt(1)=='o') {id=Id_pow; break L0;} break L;\n+                case 's': if (s.charAt(2)=='n' && s.charAt(1)=='i') {id=Id_sin; break L0;} break L;\n+                case 't': if (s.charAt(2)=='n' && s.charAt(1)=='a') {id=Id_tan; break L0;} break L;\n+                } break L;\n+            case 4: switch (s.charAt(1)) {\n+                case 'N': X=\"LN10\";id=Id_LN10; break L;\n+                case 'c': X=\"acos\";id=Id_acos; break L;\n+                case 'e': X=\"ceil\";id=Id_ceil; break L;\n+                case 'q': X=\"sqrt\";id=Id_sqrt; break L;\n+                case 's': X=\"asin\";id=Id_asin; break L;\n+                case 't': X=\"atan\";id=Id_atan; break L;\n+                } break L;\n+            case 5: switch (s.charAt(0)) {\n+                case 'L': X=\"LOG2E\";id=Id_LOG2E; break L;\n+                case 'S': X=\"SQRT2\";id=Id_SQRT2; break L;\n+                case 'a': X=\"atan2\";id=Id_atan2; break L;\n+                case 'f': X=\"floor\";id=Id_floor; break L;\n+                case 'r': X=\"round\";id=Id_round; break L;\n+                } break L;\n+            case 6: c=s.charAt(0);\n+                if (c=='L') { X=\"LOG10E\";id=Id_LOG10E; }\n+                else if (c=='r') { X=\"random\";id=Id_random; }\n+                break L;\n+            case 7: X=\"SQRT1_2\";id=Id_SQRT1_2; break L;\n+            case 8: X=\"toSource\";id=Id_toSource; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_toSource     =  1,\n+        Id_abs          =  2,\n+        Id_acos         =  3,\n+        Id_asin         =  4,\n+        Id_atan         =  5,\n+        Id_atan2        =  6,\n+        Id_ceil         =  7,\n+        Id_cos          =  8,\n+        Id_exp          =  9,\n+        Id_floor        = 10,\n+        Id_log          = 11,\n+        Id_max          = 12,\n+        Id_min          = 13,\n+        Id_pow          = 14,\n+        Id_random       = 15,\n+        Id_round        = 16,\n+        Id_sin          = 17,\n+        Id_sqrt         = 18,\n+        Id_tan          = 19,\n+\n+        LAST_METHOD_ID  = 19;\n+\n+    private static final int\n+        Id_E            = LAST_METHOD_ID + 1,\n+        Id_PI           = LAST_METHOD_ID + 2,\n+        Id_LN10         = LAST_METHOD_ID + 3,\n+        Id_LN2          = LAST_METHOD_ID + 4,\n+        Id_LOG2E        = LAST_METHOD_ID + 5,\n+        Id_LOG10E       = LAST_METHOD_ID + 6,\n+        Id_SQRT1_2      = LAST_METHOD_ID + 7,\n+        Id_SQRT2        = LAST_METHOD_ID + 8,\n+\n+        MAX_ID = LAST_METHOD_ID + 8;\n+\n+// #/string_id_map#\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeNumber.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Mike McCabe\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class implements the Number native object.\n+ *\n+ * See ECMA 15.7.\n+ *\n+ */\n+final class NativeNumber extends IdScriptableObject\n+{\n+    static final long serialVersionUID = 3504516769741512101L;\n+\n+    private static final Object NUMBER_TAG = \"Number\";\n+\n+    private static final int MAX_PRECISION = 100;\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeNumber obj = new NativeNumber(0.0);\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    private NativeNumber(double number)\n+    {\n+        doubleValue = number;\n+    }\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"Number\";\n+    }\n+\n+    @Override\n+    protected void fillConstructorProperties(IdFunctionObject ctor)\n+    {\n+        final int attr = ScriptableObject.DONTENUM |\n+                         ScriptableObject.PERMANENT |\n+                         ScriptableObject.READONLY;\n+\n+        ctor.defineProperty(\"NaN\", ScriptRuntime.NaNobj, attr);\n+        ctor.defineProperty(\"POSITIVE_INFINITY\",\n+                            ScriptRuntime.wrapNumber(Double.POSITIVE_INFINITY),\n+                            attr);\n+        ctor.defineProperty(\"NEGATIVE_INFINITY\",\n+                            ScriptRuntime.wrapNumber(Double.NEGATIVE_INFINITY),\n+                            attr);\n+        ctor.defineProperty(\"MAX_VALUE\",\n+                            ScriptRuntime.wrapNumber(Double.MAX_VALUE),\n+                            attr);\n+        ctor.defineProperty(\"MIN_VALUE\",\n+                            ScriptRuntime.wrapNumber(Double.MIN_VALUE),\n+                            attr);\n+\n+        super.fillConstructorProperties(ctor);\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor:    arity=1; s=\"constructor\";    break;\n+          case Id_toString:       arity=1; s=\"toString\";       break;\n+          case Id_toLocaleString: arity=1; s=\"toLocaleString\"; break;\n+          case Id_toSource:       arity=0; s=\"toSource\";       break;\n+          case Id_valueOf:        arity=0; s=\"valueOf\";        break;\n+          case Id_toFixed:        arity=1; s=\"toFixed\";        break;\n+          case Id_toExponential:  arity=1; s=\"toExponential\";  break;\n+          case Id_toPrecision:    arity=1; s=\"toPrecision\";    break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(NUMBER_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(NUMBER_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        if (id == Id_constructor) {\n+            double val = (args.length >= 1)\n+                ? ScriptRuntime.toNumber(args[0]) : 0.0;\n+            if (thisObj == null) {\n+                // new Number(val) creates a new Number object.\n+                return new NativeNumber(val);\n+            }\n+            // Number(val) converts val to a number value.\n+            return ScriptRuntime.wrapNumber(val);\n+        }\n+\n+        // The rest of Number.prototype methods require thisObj to be Number\n+\n+        if (!(thisObj instanceof NativeNumber))\n+            throw incompatibleCallError(f);\n+        double value = ((NativeNumber)thisObj).doubleValue;\n+\n+        switch (id) {\n+\n+          case Id_toString:\n+          case Id_toLocaleString:\n+            {\n+                // toLocaleString is just an alias for toString for now\n+                int base = (args.length == 0)\n+                    ? 10 : ScriptRuntime.toInt32(args[0]);\n+                return ScriptRuntime.numberToString(value, base);\n+            }\n+\n+          case Id_toSource:\n+            return \"(new Number(\"+ScriptRuntime.toString(value)+\"))\";\n+\n+          case Id_valueOf:\n+            return ScriptRuntime.wrapNumber(value);\n+\n+          case Id_toFixed:\n+            return num_to(value, args, DToA.DTOSTR_FIXED,\n+                          DToA.DTOSTR_FIXED, -20, 0);\n+\n+          case Id_toExponential: {\n+              // Handle special values before range check\n+              if(Double.isNaN(value)) {\n+                  return \"NaN\";\n+              }\n+              if(Double.isInfinite(value)) {\n+                  if(value >= 0) {\n+                      return \"Infinity\";\n+                  }\n+                  else {\n+                      return \"-Infinity\";\n+                  }\n+              }\n+              // General case\n+              return num_to(value, args, DToA.DTOSTR_STANDARD_EXPONENTIAL,\n+                      DToA.DTOSTR_EXPONENTIAL, 0, 1);\n+          }\n+\n+          case Id_toPrecision: {\n+              // Undefined precision, fall back to ToString()\n+              if(args.length == 0 || args[0] == Undefined.instance) {\n+                  return ScriptRuntime.numberToString(value, 10);\n+              }\n+              // Handle special values before range check\n+              if(Double.isNaN(value)) {\n+                  return \"NaN\";\n+              }\n+              if(Double.isInfinite(value)) {\n+                  if(value >= 0) {\n+                      return \"Infinity\";\n+                  }\n+                  else {\n+                      return \"-Infinity\";\n+                  }\n+              }\n+              return num_to(value, args, DToA.DTOSTR_STANDARD,\n+                      DToA.DTOSTR_PRECISION, 1, 0);\n+          }\n+\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return ScriptRuntime.numberToString(doubleValue, 10);\n+    }\n+\n+    private static String num_to(double val,\n+                                 Object[] args,\n+                                 int zeroArgMode, int oneArgMode,\n+                                 int precisionMin, int precisionOffset)\n+    {\n+        int precision;\n+        if (args.length == 0) {\n+            precision = 0;\n+            oneArgMode = zeroArgMode;\n+        } else {\n+            /* We allow a larger range of precision than\n+               ECMA requires; this is permitted by ECMA. */\n+            precision = ScriptRuntime.toInt32(args[0]);\n+            if (precision < precisionMin || precision > MAX_PRECISION) {\n+                String msg = ScriptRuntime.getMessage1(\n+                    \"msg.bad.precision\", ScriptRuntime.toString(args[0]));\n+                throw ScriptRuntime.constructError(\"RangeError\", msg);\n+            }\n+        }\n+        StringBuffer sb = new StringBuffer();\n+        DToA.JS_dtostr(sb, oneArgMode, precision + precisionOffset, val);\n+        return sb.toString();\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-05-09 08:15:50 EDT\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 7: c=s.charAt(0);\n+                if (c=='t') { X=\"toFixed\";id=Id_toFixed; }\n+                else if (c=='v') { X=\"valueOf\";id=Id_valueOf; }\n+                break L;\n+            case 8: c=s.charAt(3);\n+                if (c=='o') { X=\"toSource\";id=Id_toSource; }\n+                else if (c=='t') { X=\"toString\";id=Id_toString; }\n+                break L;\n+            case 11: c=s.charAt(0);\n+                if (c=='c') { X=\"constructor\";id=Id_constructor; }\n+                else if (c=='t') { X=\"toPrecision\";id=Id_toPrecision; }\n+                break L;\n+            case 13: X=\"toExponential\";id=Id_toExponential; break L;\n+            case 14: X=\"toLocaleString\";id=Id_toLocaleString; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_constructor           = 1,\n+        Id_toString              = 2,\n+        Id_toLocaleString        = 3,\n+        Id_toSource              = 4,\n+        Id_valueOf               = 5,\n+        Id_toFixed               = 6,\n+        Id_toExponential         = 7,\n+        Id_toPrecision           = 8,\n+        MAX_PROTOTYPE_ID         = 8;\n+\n+// #/string_id_map#\n+\n+    private double doubleValue;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeObject.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Bob Jervis\n+ *   Mike McCabe\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class implements the Object native object.\n+ * See ECMA 15.2.\n+ */\n+public class NativeObject extends IdScriptableObject\n+{\n+    static final long serialVersionUID = -6345305608474346996L;\n+\n+    private static final Object OBJECT_TAG = \"Object\";\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeObject obj = new NativeObject();\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"Object\";\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return ScriptRuntime.defaultObjectToString(this);\n+    }\n+\n+    @Override\n+    protected void fillConstructorProperties(IdFunctionObject ctor)\n+    {\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getPrototypeOf,\n+                \"getPrototypeOf\", 1);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_keys,\n+                \"keys\", 1);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getOwnPropertyNames,\n+                \"getOwnPropertyNames\", 1);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getOwnPropertyDescriptor,\n+                \"getOwnPropertyDescriptor\", 2);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_defineProperty,\n+                \"defineProperty\", 3);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_isExtensible,\n+                \"isExtensible\", 1);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_preventExtensions,\n+                \"preventExtensions\", 1);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_defineProperties,\n+                \"defineProperties\", 2);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_create,\n+                \"create\", 2);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_isSealed,\n+                \"isSealed\", 1);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_isFrozen,\n+                \"isFrozen\", 1);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_seal,\n+                \"seal\", 1);\n+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_freeze,\n+                \"freeze\", 1);\n+        super.fillConstructorProperties(ctor);\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor:    arity=1; s=\"constructor\";    break;\n+          case Id_toString:       arity=0; s=\"toString\";       break;\n+          case Id_toLocaleString: arity=0; s=\"toLocaleString\"; break;\n+          case Id_valueOf:        arity=0; s=\"valueOf\";        break;\n+          case Id_hasOwnProperty: arity=1; s=\"hasOwnProperty\"; break;\n+          case Id_propertyIsEnumerable:\n+            arity=1; s=\"propertyIsEnumerable\"; break;\n+          case Id_isPrototypeOf:  arity=1; s=\"isPrototypeOf\";  break;\n+          case Id_toSource:       arity=0; s=\"toSource\";       break;\n+          case Id___defineGetter__:\n+            arity=2; s=\"__defineGetter__\";     break;\n+          case Id___defineSetter__:\n+            arity=2; s=\"__defineSetter__\";     break;\n+          case Id___lookupGetter__:\n+            arity=1; s=\"__lookupGetter__\";     break;\n+          case Id___lookupSetter__:\n+            arity=1; s=\"__lookupSetter__\";     break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(OBJECT_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(OBJECT_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_constructor: {\n+            if (thisObj != null) {\n+                // BaseFunction.construct will set up parent, proto\n+                return f.construct(cx, scope, args);\n+            }\n+            if (args.length == 0 || args[0] == null\n+                || args[0] == Undefined.instance)\n+            {\n+                return new NativeObject();\n+            }\n+            return ScriptRuntime.toObject(cx, scope, args[0]);\n+          }\n+\n+          case Id_toLocaleString: // For now just alias toString\n+          case Id_toString: {\n+            if (cx.hasFeature(Context.FEATURE_TO_STRING_AS_SOURCE)) {\n+                String s = ScriptRuntime.defaultObjectToSource(cx, scope,\n+                                                               thisObj, args);\n+                int L = s.length();\n+                if (L != 0 && s.charAt(0) == '(' && s.charAt(L - 1) == ')') {\n+                    // Strip () that surrounds toSource\n+                    s = s.substring(1, L - 1);\n+                }\n+                return s;\n+            }\n+            return ScriptRuntime.defaultObjectToString(thisObj);\n+          }\n+\n+          case Id_valueOf:\n+            return thisObj;\n+\n+          case Id_hasOwnProperty: {\n+            boolean result;\n+            if (args.length == 0) {\n+                result = false;\n+            } else {\n+                String s = ScriptRuntime.toStringIdOrIndex(cx, args[0]);\n+                if (s == null) {\n+                    int index = ScriptRuntime.lastIndexResult(cx);\n+                    result = thisObj.has(index, thisObj);\n+                } else {\n+                    result = thisObj.has(s, thisObj);\n+                }\n+            }\n+            return ScriptRuntime.wrapBoolean(result);\n+          }\n+\n+          case Id_propertyIsEnumerable: {\n+            boolean result;\n+            if (args.length == 0) {\n+                result = false;\n+            } else {\n+                String s = ScriptRuntime.toStringIdOrIndex(cx, args[0]);\n+                if (s == null) {\n+                    int index = ScriptRuntime.lastIndexResult(cx);\n+                    result = thisObj.has(index, thisObj);\n+                    if (result && thisObj instanceof ScriptableObject) {\n+                        ScriptableObject so = (ScriptableObject)thisObj;\n+                        int attrs = so.getAttributes(index);\n+                        result = ((attrs & ScriptableObject.DONTENUM) == 0);\n+                    }\n+                } else {\n+                    result = thisObj.has(s, thisObj);\n+                    if (result && thisObj instanceof ScriptableObject) {\n+                        ScriptableObject so = (ScriptableObject)thisObj;\n+                        int attrs = so.getAttributes(s);\n+                        result = ((attrs & ScriptableObject.DONTENUM) == 0);\n+                    }\n+                }\n+            }\n+            return ScriptRuntime.wrapBoolean(result);\n+          }\n+\n+          case Id_isPrototypeOf: {\n+            boolean result = false;\n+            if (args.length != 0 && args[0] instanceof Scriptable) {\n+                Scriptable v = (Scriptable) args[0];\n+                do {\n+                    v = v.getPrototype();\n+                    if (v == thisObj) {\n+                        result = true;\n+                        break;\n+                    }\n+                } while (v != null);\n+            }\n+            return ScriptRuntime.wrapBoolean(result);\n+          }\n+\n+          case Id_toSource:\n+            return ScriptRuntime.defaultObjectToSource(cx, scope, thisObj,\n+                                                       args);\n+          case Id___defineGetter__:\n+          case Id___defineSetter__:\n+            {\n+                if (args.length < 2 || !(args[1] instanceof Callable)) {\n+                    Object badArg = (args.length >= 2 ? args[1]\n+                                     : Undefined.instance);\n+                    throw ScriptRuntime.notFunctionError(badArg);\n+                }\n+                if (!(thisObj instanceof ScriptableObject)) {\n+                    throw Context.reportRuntimeError2(\n+                        \"msg.extend.scriptable\",\n+                        thisObj.getClass().getName(),\n+                        String.valueOf(args[0]));\n+                }\n+                ScriptableObject so = (ScriptableObject)thisObj;\n+                String name = ScriptRuntime.toStringIdOrIndex(cx, args[0]);\n+                int index = (name != null ? 0\n+                             : ScriptRuntime.lastIndexResult(cx));\n+                Callable getterOrSetter = (Callable)args[1];\n+                boolean isSetter = (id == Id___defineSetter__);\n+                so.setGetterOrSetter(name, index, getterOrSetter, isSetter);\n+                if (so instanceof NativeArray)\n+                    ((NativeArray)so).setDenseOnly(false);\n+            }\n+            return Undefined.instance;\n+\n+            case Id___lookupGetter__:\n+            case Id___lookupSetter__:\n+              {\n+                  if (args.length < 1 ||\n+                      !(thisObj instanceof ScriptableObject))\n+                      return Undefined.instance;\n+\n+                  ScriptableObject so = (ScriptableObject)thisObj;\n+                  String name = ScriptRuntime.toStringIdOrIndex(cx, args[0]);\n+                  int index = (name != null ? 0\n+                               : ScriptRuntime.lastIndexResult(cx));\n+                  boolean isSetter = (id == Id___lookupSetter__);\n+                  Object gs;\n+                  for (;;) {\n+                      gs = so.getGetterOrSetter(name, index, isSetter);\n+                      if (gs != null)\n+                          break;\n+                      // If there is no getter or setter for the object itself,\n+                      // how about the prototype?\n+                      Scriptable v = so.getPrototype();\n+                      if (v == null)\n+                          break;\n+                      if (v instanceof ScriptableObject)\n+                          so = (ScriptableObject)v;\n+                      else\n+                          break;\n+                  }\n+                  if (gs != null)\n+                      return gs;\n+              }\n+              return Undefined.instance;\n+\n+          case ConstructorId_getPrototypeOf:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                Scriptable obj = ensureScriptable(arg);\n+                return obj.getPrototype();\n+              }\n+          case ConstructorId_keys:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                Scriptable obj = ensureScriptable(arg);\n+                Object[] ids = obj.getIds();\n+                for (int i = 0; i < ids.length; i++) {\n+                  ids[i] = ScriptRuntime.toString(ids[i]);\n+                }\n+                return cx.newArray(scope, ids);\n+              }\n+          case ConstructorId_getOwnPropertyNames:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                ScriptableObject obj = ensureScriptableObject(arg);\n+                Object[] ids = obj.getAllIds();\n+                for (int i = 0; i < ids.length; i++) {\n+                  ids[i] = ScriptRuntime.toString(ids[i]);\n+                }\n+                return cx.newArray(scope, ids);\n+              }\n+          case ConstructorId_getOwnPropertyDescriptor:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                // TODO(norris): There's a deeper issue here if\n+                // arg instanceof Scriptable. Should we create a new\n+                // interface to admit the new ECMAScript 5 operations?\n+                ScriptableObject obj = ensureScriptableObject(arg);\n+                Object nameArg = args.length < 2 ? Undefined.instance : args[1];\n+                String name = ScriptRuntime.toString(nameArg);\n+                Scriptable desc = obj.getOwnPropertyDescriptor(cx, name);\n+                return desc == null ? Undefined.instance : desc;\n+              }\n+          case ConstructorId_defineProperty:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                ScriptableObject obj = ensureScriptableObject(arg);\n+                Object name = args.length < 2 ? Undefined.instance : args[1];\n+                Object descArg = args.length < 3 ? Undefined.instance : args[2];\n+                ScriptableObject desc = ensureScriptableObject(descArg);\n+                obj.defineOwnProperty(cx, name, desc);\n+                return obj;\n+              }\n+          case ConstructorId_isExtensible:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                ScriptableObject obj = ensureScriptableObject(arg);\n+                return obj.isExtensible();\n+              }\n+          case ConstructorId_preventExtensions:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                ScriptableObject obj = ensureScriptableObject(arg);\n+                obj.preventExtensions();\n+                return obj;\n+              }\n+          case ConstructorId_defineProperties:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                ScriptableObject obj = ensureScriptableObject(arg);\n+                Object propsObj = args.length < 2 ? Undefined.instance : args[1];\n+                Scriptable props = Context.toObject(propsObj, getParentScope());\n+                obj.defineOwnProperties(cx, ensureScriptableObject(props));\n+                return obj;\n+        }\n+          case ConstructorId_create:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                Scriptable obj = (arg == null) ? null : ensureScriptable(arg);\n+\n+                ScriptableObject newObject = new NativeObject();\n+                newObject.setParentScope(this.getParentScope());\n+                newObject.setPrototype(obj);\n+\n+                if (args.length > 1 && args[1] != Undefined.instance) {\n+                  Scriptable props = Context.toObject(args[1], getParentScope());\n+                  newObject.defineOwnProperties(cx, ensureScriptableObject(props));\n+                }\n+\n+                return newObject;\n+              }\n+\n+          case ConstructorId_isSealed:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                ScriptableObject obj = ensureScriptableObject(arg);\n+\n+                if (obj.isExtensible()) return false;\n+\n+                for (Object name: obj.getAllIds()) {\n+                  Object configurable = obj.getOwnPropertyDescriptor(cx, name).get(\"configurable\");\n+                  if (Boolean.TRUE.equals(configurable))\n+                    return false;\n+                }\n+\n+                return true;\n+              }\n+          case ConstructorId_isFrozen:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                ScriptableObject obj = ensureScriptableObject(arg);\n+\n+                if (obj.isExtensible()) return false;\n+\n+                for (Object name: obj.getAllIds()) {\n+                  ScriptableObject desc = obj.getOwnPropertyDescriptor(cx, name);\n+                  if (Boolean.TRUE.equals(desc.get(\"configurable\")))\n+                    return false;\n+                  if (isDataDescriptor(desc) && Boolean.TRUE.equals(desc.get(\"writable\")))\n+                    return false;\n+                }\n+\n+                return true;\n+              }\n+          case ConstructorId_seal:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                ScriptableObject obj = ensureScriptableObject(arg);\n+\n+                for (Object name: obj.getAllIds()) {\n+                  ScriptableObject desc = obj.getOwnPropertyDescriptor(cx, name);\n+                  if (Boolean.TRUE.equals(desc.get(\"configurable\"))) {\n+                    desc.put(\"configurable\", desc, false);\n+                    obj.defineOwnProperty(cx, name, desc);\n+                  }\n+                }\n+                obj.preventExtensions();\n+\n+                return obj;\n+              }\n+          case ConstructorId_freeze:\n+              {\n+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n+                ScriptableObject obj = ensureScriptableObject(arg);\n+\n+                for (Object name: obj.getAllIds()) {\n+                  ScriptableObject desc = obj.getOwnPropertyDescriptor(cx, name);\n+                  if (isDataDescriptor(desc) && Boolean.TRUE.equals(desc.get(\"writable\")))\n+                    desc.put(\"writable\", desc, false);\n+                  if (Boolean.TRUE.equals(desc.get(\"configurable\")))\n+                    desc.put(\"configurable\", desc, false);\n+                  obj.defineOwnProperty(cx, name, desc);\n+                }\n+                obj.preventExtensions();\n+\n+                return obj;\n+              }\n+\n+\n+          default:\n+            throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-05-09 08:15:55 EDT\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 7: X=\"valueOf\";id=Id_valueOf; break L;\n+            case 8: c=s.charAt(3);\n+                if (c=='o') { X=\"toSource\";id=Id_toSource; }\n+                else if (c=='t') { X=\"toString\";id=Id_toString; }\n+                break L;\n+            case 11: X=\"constructor\";id=Id_constructor; break L;\n+            case 13: X=\"isPrototypeOf\";id=Id_isPrototypeOf; break L;\n+            case 14: c=s.charAt(0);\n+                if (c=='h') { X=\"hasOwnProperty\";id=Id_hasOwnProperty; }\n+                else if (c=='t') { X=\"toLocaleString\";id=Id_toLocaleString; }\n+                break L;\n+            case 16: c=s.charAt(2);\n+                if (c=='d') {\n+                    c=s.charAt(8);\n+                    if (c=='G') { X=\"__defineGetter__\";id=Id___defineGetter__; }\n+                    else if (c=='S') { X=\"__defineSetter__\";id=Id___defineSetter__; }\n+                }\n+                else if (c=='l') {\n+                    c=s.charAt(8);\n+                    if (c=='G') { X=\"__lookupGetter__\";id=Id___lookupGetter__; }\n+                    else if (c=='S') { X=\"__lookupSetter__\";id=Id___lookupSetter__; }\n+                }\n+                break L;\n+            case 20: X=\"propertyIsEnumerable\";id=Id_propertyIsEnumerable; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        ConstructorId_getPrototypeOf = -1,\n+        ConstructorId_keys = -2,\n+        ConstructorId_getOwnPropertyNames = -3,\n+        ConstructorId_getOwnPropertyDescriptor = -4,\n+        ConstructorId_defineProperty = -5,\n+        ConstructorId_isExtensible = -6,\n+        ConstructorId_preventExtensions = -7,\n+        ConstructorId_defineProperties= -8,\n+        ConstructorId_create = -9,\n+        ConstructorId_isSealed = -10,\n+        ConstructorId_isFrozen = -11,\n+        ConstructorId_seal = -12,\n+        ConstructorId_freeze = -13,\n+\n+        Id_constructor           = 1,\n+        Id_toString              = 2,\n+        Id_toLocaleString        = 3,\n+        Id_valueOf               = 4,\n+        Id_hasOwnProperty        = 5,\n+        Id_propertyIsEnumerable  = 6,\n+        Id_isPrototypeOf         = 7,\n+        Id_toSource              = 8,\n+        Id___defineGetter__      = 9,\n+        Id___defineSetter__      = 10,\n+        Id___lookupGetter__      = 11,\n+        Id___lookupSetter__      = 12,\n+        MAX_PROTOTYPE_ID         = 12;\n+\n+// #/string_id_map#\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeScript.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Roger Lawrence\n+ *   Mike McCabe\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * The JavaScript Script object.\n+ *\n+ * Note that the C version of the engine uses XDR as the format used\n+ * by freeze and thaw. Since this depends on the internal format of\n+ * structures in the C runtime, we cannot duplicate it.\n+ *\n+ * Since we cannot replace 'this' as a result of the compile method,\n+ * will forward requests to execute to the nonnull 'script' field.\n+ *\n+ * @since 1.3\n+ */\n+\n+class NativeScript extends BaseFunction\n+{\n+    static final long serialVersionUID = -6795101161980121700L;\n+\n+    private static final Object SCRIPT_TAG = \"Script\";\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeScript obj = new NativeScript(null);\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    private NativeScript(Script script)\n+    {\n+        this.script = script;\n+    }\n+\n+    /**\n+     * Returns the name of this JavaScript class, \"Script\".\n+     */\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"Script\";\n+    }\n+\n+    @Override\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        if (script != null) {\n+            return script.exec(cx, scope);\n+        }\n+        return Undefined.instance;\n+    }\n+\n+    @Override\n+    public Scriptable construct(Context cx, Scriptable scope, Object[] args)\n+    {\n+        throw Context.reportRuntimeError0(\"msg.script.is.not.constructor\");\n+    }\n+\n+    @Override\n+    public int getLength()\n+    {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getArity()\n+    {\n+        return 0;\n+    }\n+\n+    @Override\n+    String decompile(int indent, int flags)\n+    {\n+        if (script instanceof NativeFunction) {\n+            return ((NativeFunction)script).decompile(indent, flags);\n+        }\n+        return super.decompile(indent, flags);\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor: arity=1; s=\"constructor\"; break;\n+          case Id_toString:    arity=0; s=\"toString\";    break;\n+          case Id_exec:        arity=0; s=\"exec\";        break;\n+          case Id_compile:     arity=1; s=\"compile\";     break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(SCRIPT_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(SCRIPT_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_constructor: {\n+            String source = (args.length == 0)\n+                            ? \"\"\n+                            : ScriptRuntime.toString(args[0]);\n+            Script script = compile(cx, source);\n+            NativeScript nscript = new NativeScript(script);\n+            ScriptRuntime.setObjectProtoAndParent(nscript, scope);\n+            return nscript;\n+          }\n+\n+          case Id_toString: {\n+            NativeScript real = realThis(thisObj, f);\n+            Script realScript = real.script;\n+            if (realScript == null) { return \"\"; }\n+            return cx.decompileScript(realScript, 0);\n+          }\n+\n+          case Id_exec: {\n+            throw Context.reportRuntimeError1(\n+                \"msg.cant.call.indirect\", \"exec\");\n+          }\n+\n+          case Id_compile: {\n+            NativeScript real = realThis(thisObj, f);\n+            String source = ScriptRuntime.toString(args, 0);\n+            real.script = compile(cx, source);\n+            return real;\n+          }\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private static NativeScript realThis(Scriptable thisObj, IdFunctionObject f)\n+    {\n+        if (!(thisObj instanceof NativeScript))\n+            throw incompatibleCallError(f);\n+        return (NativeScript)thisObj;\n+    }\n+\n+    private static Script compile(Context cx, String source)\n+    {\n+        int[] linep = { 0 };\n+        String filename = Context.getSourcePositionFromStack(linep);\n+        if (filename == null) {\n+            filename = \"<Script object>\";\n+            linep[0] = 1;\n+        }\n+        ErrorReporter reporter;\n+        reporter = DefaultErrorReporter.forEval(cx.getErrorReporter());\n+        return cx.compileString(source, null, reporter, filename,\n+                                linep[0], null);\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-05-09 08:16:01 EDT\n+        L0: { id = 0; String X = null;\n+            L: switch (s.length()) {\n+            case 4: X=\"exec\";id=Id_exec; break L;\n+            case 7: X=\"compile\";id=Id_compile; break L;\n+            case 8: X=\"toString\";id=Id_toString; break L;\n+            case 11: X=\"constructor\";id=Id_constructor; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_constructor    = 1,\n+        Id_toString       = 2,\n+        Id_compile        = 3,\n+        Id_exec           = 4,\n+        MAX_PROTOTYPE_ID  = 4;\n+\n+// #/string_id_map#\n+\n+    private Script script;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeString.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Tom Beauvais\n+ *   Norris Boyd\n+ *   Mike McCabe\n+ *   Cameron McCormack\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.text.Collator;\n+\n+/**\n+ * This class implements the String native object.\n+ *\n+ * See ECMA 15.5.\n+ *\n+ * String methods for dealing with regular expressions are\n+ * ported directly from C. Latest port is from version 1.40.12.19\n+ * in the JSFUN13_BRANCH.\n+ *\n+ */\n+final class NativeString extends IdScriptableObject\n+{\n+    static final long serialVersionUID = 920268368584188687L;\n+\n+    private static final Object STRING_TAG = \"String\";\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeString obj = new NativeString(\"\");\n+        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);\n+    }\n+\n+    private NativeString(String s) {\n+        string = s;\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return \"String\";\n+    }\n+\n+    private static final int\n+        Id_length                    =  1,\n+        MAX_INSTANCE_ID              =  1;\n+\n+    @Override\n+    protected int getMaxInstanceId()\n+    {\n+        return MAX_INSTANCE_ID;\n+    }\n+\n+    @Override\n+    protected int findInstanceIdInfo(String s)\n+    {\n+        if (s.equals(\"length\")) {\n+            return instanceIdInfo(DONTENUM | READONLY | PERMANENT, Id_length);\n+        }\n+        return super.findInstanceIdInfo(s);\n+    }\n+\n+    @Override\n+    protected String getInstanceIdName(int id)\n+    {\n+        if (id == Id_length) { return \"length\"; }\n+        return super.getInstanceIdName(id);\n+    }\n+\n+    @Override\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        if (id == Id_length) {\n+            return ScriptRuntime.wrapInt(string.length());\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+    @Override\n+    protected void fillConstructorProperties(IdFunctionObject ctor)\n+    {\n+        addIdFunctionProperty(ctor, STRING_TAG, ConstructorId_fromCharCode,\n+                \"fromCharCode\", 1);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_charAt, \"charAt\", 2);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_charCodeAt, \"charCodeAt\", 2);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_indexOf, \"indexOf\", 2);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_lastIndexOf, \"lastIndexOf\", 2);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_split, \"split\", 3);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_substring, \"substring\", 3);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_toLowerCase, \"toLowerCase\", 1);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_toUpperCase, \"toUpperCase\", 1);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_substr, \"substr\", 3);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_concat, \"concat\", 2);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_slice, \"slice\", 3);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_equalsIgnoreCase, \"equalsIgnoreCase\", 2);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_match, \"match\", 2);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_search, \"search\", 2);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_replace, \"replace\", 2);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_localeCompare, \"localeCompare\", 2);\n+        addIdFunctionProperty(ctor, STRING_TAG,\n+                ConstructorId_toLocaleLowerCase, \"toLocaleLowerCase\", 1);\n+        super.fillConstructorProperties(ctor);\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor:       arity=1; s=\"constructor\";       break;\n+          case Id_toString:          arity=0; s=\"toString\";          break;\n+          case Id_toSource:          arity=0; s=\"toSource\";          break;\n+          case Id_valueOf:           arity=0; s=\"valueOf\";           break;\n+          case Id_charAt:            arity=1; s=\"charAt\";            break;\n+          case Id_charCodeAt:        arity=1; s=\"charCodeAt\";        break;\n+          case Id_indexOf:           arity=1; s=\"indexOf\";           break;\n+          case Id_lastIndexOf:       arity=1; s=\"lastIndexOf\";       break;\n+          case Id_split:             arity=2; s=\"split\";             break;\n+          case Id_substring:         arity=2; s=\"substring\";         break;\n+          case Id_toLowerCase:       arity=0; s=\"toLowerCase\";       break;\n+          case Id_toUpperCase:       arity=0; s=\"toUpperCase\";       break;\n+          case Id_substr:            arity=2; s=\"substr\";            break;\n+          case Id_concat:            arity=1; s=\"concat\";            break;\n+          case Id_slice:             arity=2; s=\"slice\";             break;\n+          case Id_bold:              arity=0; s=\"bold\";              break;\n+          case Id_italics:           arity=0; s=\"italics\";           break;\n+          case Id_fixed:             arity=0; s=\"fixed\";             break;\n+          case Id_strike:            arity=0; s=\"strike\";            break;\n+          case Id_small:             arity=0; s=\"small\";             break;\n+          case Id_big:               arity=0; s=\"big\";               break;\n+          case Id_blink:             arity=0; s=\"blink\";             break;\n+          case Id_sup:               arity=0; s=\"sup\";               break;\n+          case Id_sub:               arity=0; s=\"sub\";               break;\n+          case Id_fontsize:          arity=0; s=\"fontsize\";          break;\n+          case Id_fontcolor:         arity=0; s=\"fontcolor\";         break;\n+          case Id_link:              arity=0; s=\"link\";              break;\n+          case Id_anchor:            arity=0; s=\"anchor\";            break;\n+          case Id_equals:            arity=1; s=\"equals\";            break;\n+          case Id_equalsIgnoreCase:  arity=1; s=\"equalsIgnoreCase\";  break;\n+          case Id_match:             arity=1; s=\"match\";             break;\n+          case Id_search:            arity=1; s=\"search\";            break;\n+          case Id_replace:           arity=1; s=\"replace\";           break;\n+          case Id_localeCompare:     arity=1; s=\"localeCompare\";     break;\n+          case Id_toLocaleLowerCase: arity=0; s=\"toLocaleLowerCase\"; break;\n+          case Id_toLocaleUpperCase: arity=0; s=\"toLocaleUpperCase\"; break;\n+          case Id_trim:              arity=0; s=\"trim\";              break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(STRING_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(STRING_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+      again:\n+        for(;;) {\n+            switch (id) {\n+              case ConstructorId_charAt:\n+              case ConstructorId_charCodeAt:\n+              case ConstructorId_indexOf:\n+              case ConstructorId_lastIndexOf:\n+              case ConstructorId_split:\n+              case ConstructorId_substring:\n+              case ConstructorId_toLowerCase:\n+              case ConstructorId_toUpperCase:\n+              case ConstructorId_substr:\n+              case ConstructorId_concat:\n+              case ConstructorId_slice:\n+              case ConstructorId_equalsIgnoreCase:\n+              case ConstructorId_match:\n+              case ConstructorId_search:\n+              case ConstructorId_replace:\n+              case ConstructorId_localeCompare:\n+              case ConstructorId_toLocaleLowerCase: {\n+                if (args.length > 0) {\n+                    thisObj = ScriptRuntime.toObject(scope,\n+                            ScriptRuntime.toString(args[0]));\n+                    Object[] newArgs = new Object[args.length-1];\n+                    for (int i=0; i < newArgs.length; i++)\n+                        newArgs[i] = args[i+1];\n+                    args = newArgs;\n+                } else {\n+                    thisObj = ScriptRuntime.toObject(scope,\n+                            ScriptRuntime.toString(thisObj));\n+                }\n+                id = -id;\n+                continue again;\n+              }\n+\n+              case ConstructorId_fromCharCode: {\n+                int N = args.length;\n+                if (N < 1)\n+                    return \"\";\n+                StringBuffer sb = new StringBuffer(N);\n+                for (int i = 0; i != N; ++i) {\n+                    sb.append(ScriptRuntime.toUint16(args[i]));\n+                }\n+                return sb.toString();\n+              }\n+\n+              case Id_constructor: {\n+                String s = (args.length >= 1)\n+                    ? ScriptRuntime.toString(args[0]) : \"\";\n+                if (thisObj == null) {\n+                    // new String(val) creates a new String object.\n+                    return new NativeString(s);\n+                }\n+                // String(val) converts val to a string value.\n+                return s;\n+              }\n+\n+              case Id_toString:\n+              case Id_valueOf:\n+                // ECMA 15.5.4.2: 'the toString function is not generic.\n+                return realThis(thisObj, f).string;\n+\n+              case Id_toSource: {\n+                String s = realThis(thisObj, f).string;\n+                return \"(new String(\\\"\"+ScriptRuntime.escapeString(s)+\"\\\"))\";\n+              }\n+\n+              case Id_charAt:\n+              case Id_charCodeAt: {\n+                 // See ECMA 15.5.4.[4,5]\n+                String target = ScriptRuntime.toString(thisObj);\n+                double pos = ScriptRuntime.toInteger(args, 0);\n+                if (pos < 0 || pos >= target.length()) {\n+                    if (id == Id_charAt) return \"\";\n+                    else return ScriptRuntime.NaNobj;\n+                }\n+                char c = target.charAt((int)pos);\n+                if (id == Id_charAt) return String.valueOf(c);\n+                else return ScriptRuntime.wrapInt(c);\n+              }\n+\n+              case Id_indexOf:\n+                return ScriptRuntime.wrapInt(js_indexOf(\n+                    ScriptRuntime.toString(thisObj), args));\n+\n+              case Id_lastIndexOf:\n+                return ScriptRuntime.wrapInt(js_lastIndexOf(\n+                    ScriptRuntime.toString(thisObj), args));\n+\n+              case Id_split:\n+                return ScriptRuntime.checkRegExpProxy(cx).\n+                  js_split(cx, scope, ScriptRuntime.toString(thisObj),\n+                        args);\n+\n+              case Id_substring:\n+                return js_substring(cx, ScriptRuntime.toString(thisObj), args);\n+\n+              case Id_toLowerCase:\n+                // See ECMA 15.5.4.11\n+                return ScriptRuntime.toString(thisObj).toLowerCase(\n+                         ScriptRuntime.ROOT_LOCALE);\n+\n+              case Id_toUpperCase:\n+                // See ECMA 15.5.4.12\n+                return ScriptRuntime.toString(thisObj).toUpperCase(\n+                         ScriptRuntime.ROOT_LOCALE);\n+\n+              case Id_substr:\n+                return js_substr(ScriptRuntime.toString(thisObj), args);\n+\n+              case Id_concat:\n+                return js_concat(ScriptRuntime.toString(thisObj), args);\n+\n+              case Id_slice:\n+                return js_slice(ScriptRuntime.toString(thisObj), args);\n+\n+              case Id_bold:\n+                return tagify(thisObj, \"b\", null, null);\n+\n+              case Id_italics:\n+                return tagify(thisObj, \"i\", null, null);\n+\n+              case Id_fixed:\n+                return tagify(thisObj, \"tt\", null, null);\n+\n+              case Id_strike:\n+                return tagify(thisObj, \"strike\", null, null);\n+\n+              case Id_small:\n+                return tagify(thisObj, \"small\", null, null);\n+\n+              case Id_big:\n+                return tagify(thisObj, \"big\", null, null);\n+\n+              case Id_blink:\n+                return tagify(thisObj, \"blink\", null, null);\n+\n+              case Id_sup:\n+                return tagify(thisObj, \"sup\", null, null);\n+\n+              case Id_sub:\n+                return tagify(thisObj, \"sub\", null, null);\n+\n+              case Id_fontsize:\n+                return tagify(thisObj, \"font\", \"size\", args);\n+\n+              case Id_fontcolor:\n+                return tagify(thisObj, \"font\", \"color\", args);\n+\n+              case Id_link:\n+                return tagify(thisObj, \"a\", \"href\", args);\n+\n+              case Id_anchor:\n+                return tagify(thisObj, \"a\", \"name\", args);\n+\n+              case Id_equals:\n+              case Id_equalsIgnoreCase: {\n+                String s1 = ScriptRuntime.toString(thisObj);\n+                String s2 = ScriptRuntime.toString(args, 0);\n+                return ScriptRuntime.wrapBoolean(\n+                    (id == Id_equals) ? s1.equals(s2)\n+                                      : s1.equalsIgnoreCase(s2));\n+              }\n+\n+              case Id_match:\n+              case Id_search:\n+              case Id_replace:\n+                {\n+                    int actionType;\n+                    if (id == Id_match) {\n+                        actionType = RegExpProxy.RA_MATCH;\n+                    } else if (id == Id_search) {\n+                        actionType = RegExpProxy.RA_SEARCH;\n+                    } else {\n+                        actionType = RegExpProxy.RA_REPLACE;\n+                    }\n+                    return ScriptRuntime.checkRegExpProxy(cx).\n+                        action(cx, scope, thisObj, args, actionType);\n+                }\n+                // ECMA-262 1 5.5.4.9\n+              case Id_localeCompare:\n+                {\n+                    // For now, create and configure a collator instance. I can't\n+                    // actually imagine that this'd be slower than caching them\n+                    // a la ClassCache, so we aren't trying to outsmart ourselves\n+                    // with a caching mechanism for now.\n+                    Collator collator = Collator.getInstance(cx.getLocale());\n+                    collator.setStrength(Collator.IDENTICAL);\n+                    collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n+                    return ScriptRuntime.wrapNumber(collator.compare(\n+                            ScriptRuntime.toString(thisObj),\n+                            ScriptRuntime.toString(args, 0)));\n+                }\n+              case Id_toLocaleLowerCase:\n+                {\n+                    return ScriptRuntime.toString(thisObj)\n+                            .toLowerCase(cx.getLocale());\n+                }\n+              case Id_toLocaleUpperCase:\n+                {\n+                    return ScriptRuntime.toString(thisObj)\n+                            .toUpperCase(cx.getLocale());\n+                }\n+              case Id_trim:\n+                {\n+                    String str = ScriptRuntime.toString(thisObj);\n+                    char[] chars = str.toCharArray();\n+\n+                    int start = 0;\n+                    while (start < chars.length && ScriptRuntime.isJSWhitespaceOrLineTerminator(chars[start])) {\n+                      start++;\n+                    }\n+                    int end = chars.length;\n+                    while (end > start && ScriptRuntime.isJSWhitespaceOrLineTerminator(chars[end-1])) {\n+                      end--;\n+                    }\n+\n+                    return str.substring(start, end);\n+                }\n+            }\n+            throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+    }\n+\n+    private static NativeString realThis(Scriptable thisObj, IdFunctionObject f)\n+    {\n+        if (!(thisObj instanceof NativeString))\n+            throw incompatibleCallError(f);\n+        return (NativeString)thisObj;\n+    }\n+\n+    /*\n+     * HTML composition aids.\n+     */\n+    private static String tagify(Object thisObj, String tag,\n+                                 String attribute, Object[] args)\n+    {\n+        String str = ScriptRuntime.toString(thisObj);\n+        StringBuffer result = new StringBuffer();\n+        result.append('<');\n+        result.append(tag);\n+        if (attribute != null) {\n+            result.append(' ');\n+            result.append(attribute);\n+            result.append(\"=\\\"\");\n+            result.append(ScriptRuntime.toString(args, 0));\n+            result.append('\"');\n+        }\n+        result.append('>');\n+        result.append(str);\n+        result.append(\"</\");\n+        result.append(tag);\n+        result.append('>');\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return string;\n+    }\n+\n+    /* Make array-style property lookup work for strings.\n+     * XXX is this ECMA?  A version check is probably needed. In js too.\n+     */\n+    @Override\n+    public Object get(int index, Scriptable start) {\n+        if (0 <= index && index < string.length()) {\n+            return string.substring(index, index + 1);\n+        }\n+        return super.get(index, start);\n+    }\n+\n+    @Override\n+    public void put(int index, Scriptable start, Object value) {\n+        if (0 <= index && index < string.length()) {\n+            return;\n+        }\n+        super.put(index, start, value);\n+    }\n+\n+    /*\n+     *\n+     * See ECMA 15.5.4.6.  Uses Java String.indexOf()\n+     * OPT to add - BMH searching from jsstr.c.\n+     */\n+    private static int js_indexOf(String target, Object[] args) {\n+        String search = ScriptRuntime.toString(args, 0);\n+        double begin = ScriptRuntime.toInteger(args, 1);\n+\n+        if (begin > target.length()) {\n+            return -1;\n+        } else {\n+            if (begin < 0)\n+                begin = 0;\n+            return target.indexOf(search, (int)begin);\n+        }\n+    }\n+\n+    /*\n+     *\n+     * See ECMA 15.5.4.7\n+     *\n+     */\n+    private static int js_lastIndexOf(String target, Object[] args) {\n+        String search = ScriptRuntime.toString(args, 0);\n+        double end = ScriptRuntime.toNumber(args, 1);\n+\n+        if (end != end || end > target.length())\n+            end = target.length();\n+        else if (end < 0)\n+            end = 0;\n+\n+        return target.lastIndexOf(search, (int)end);\n+    }\n+\n+\n+    /*\n+     * See ECMA 15.5.4.15\n+     */\n+    private static String js_substring(Context cx, String target,\n+                                       Object[] args)\n+    {\n+        int length = target.length();\n+        double start = ScriptRuntime.toInteger(args, 0);\n+        double end;\n+\n+        if (start < 0)\n+            start = 0;\n+        else if (start > length)\n+            start = length;\n+\n+        if (args.length <= 1 || args[1] == Undefined.instance) {\n+            end = length;\n+        } else {\n+            end = ScriptRuntime.toInteger(args[1]);\n+            if (end < 0)\n+                end = 0;\n+            else if (end > length)\n+                end = length;\n+\n+            // swap if end < start\n+            if (end < start) {\n+                if (cx.getLanguageVersion() != Context.VERSION_1_2) {\n+                    double temp = start;\n+                    start = end;\n+                    end = temp;\n+                } else {\n+                    // Emulate old JDK1.0 java.lang.String.substring()\n+                    end = start;\n+                }\n+            }\n+        }\n+        return target.substring((int)start, (int)end);\n+    }\n+\n+    int getLength() {\n+        return string.length();\n+    }\n+\n+    /*\n+     * Non-ECMA methods.\n+     */\n+    private static String js_substr(String target, Object[] args) {\n+        if (args.length < 1)\n+            return target;\n+\n+        double begin = ScriptRuntime.toInteger(args[0]);\n+        double end;\n+        int length = target.length();\n+\n+        if (begin < 0) {\n+            begin += length;\n+            if (begin < 0)\n+                begin = 0;\n+        } else if (begin > length) {\n+            begin = length;\n+        }\n+\n+        if (args.length == 1) {\n+            end = length;\n+        } else {\n+            end = ScriptRuntime.toInteger(args[1]);\n+            if (end < 0)\n+                end = 0;\n+            end += begin;\n+            if (end > length)\n+                end = length;\n+        }\n+\n+        return target.substring((int)begin, (int)end);\n+    }\n+\n+    /*\n+     * Python-esque sequence operations.\n+     */\n+    private static String js_concat(String target, Object[] args) {\n+        int N = args.length;\n+        if (N == 0) { return target; }\n+        else if (N == 1) {\n+            String arg = ScriptRuntime.toString(args[0]);\n+            return target.concat(arg);\n+        }\n+\n+        // Find total capacity for the final string to avoid unnecessary\n+        // re-allocations in StringBuffer\n+        int size = target.length();\n+        String[] argsAsStrings = new String[N];\n+        for (int i = 0; i != N; ++i) {\n+            String s = ScriptRuntime.toString(args[i]);\n+            argsAsStrings[i] = s;\n+            size += s.length();\n+        }\n+\n+        StringBuffer result = new StringBuffer(size);\n+        result.append(target);\n+        for (int i = 0; i != N; ++i) {\n+            result.append(argsAsStrings[i]);\n+        }\n+        return result.toString();\n+    }\n+\n+    private static String js_slice(String target, Object[] args) {\n+        if (args.length != 0) {\n+            double begin = ScriptRuntime.toInteger(args[0]);\n+            double end;\n+            int length = target.length();\n+            if (begin < 0) {\n+                begin += length;\n+                if (begin < 0)\n+                    begin = 0;\n+            } else if (begin > length) {\n+                begin = length;\n+            }\n+\n+            if (args.length == 1) {\n+                end = length;\n+            } else {\n+                end = ScriptRuntime.toInteger(args[1]);\n+                if (end < 0) {\n+                    end += length;\n+                    if (end < 0)\n+                        end = 0;\n+                } else if (end > length) {\n+                    end = length;\n+                }\n+                if (end < begin)\n+                    end = begin;\n+            }\n+            return target.substring((int)begin, (int)end);\n+        }\n+        return target;\n+    }\n+\n+// #string_id_map#\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2009-07-23 07:32:39 EST\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 3: c=s.charAt(2);\n+                if (c=='b') { if (s.charAt(0)=='s' && s.charAt(1)=='u') {id=Id_sub; break L0;} }\n+                else if (c=='g') { if (s.charAt(0)=='b' && s.charAt(1)=='i') {id=Id_big; break L0;} }\n+                else if (c=='p') { if (s.charAt(0)=='s' && s.charAt(1)=='u') {id=Id_sup; break L0;} }\n+                break L;\n+            case 4: c=s.charAt(0);\n+                if (c=='b') { X=\"bold\";id=Id_bold; }\n+                else if (c=='l') { X=\"link\";id=Id_link; }\n+                else if (c=='t') { X=\"trim\";id=Id_trim; }\n+                break L;\n+            case 5: switch (s.charAt(4)) {\n+                case 'd': X=\"fixed\";id=Id_fixed; break L;\n+                case 'e': X=\"slice\";id=Id_slice; break L;\n+                case 'h': X=\"match\";id=Id_match; break L;\n+                case 'k': X=\"blink\";id=Id_blink; break L;\n+                case 'l': X=\"small\";id=Id_small; break L;\n+                case 't': X=\"split\";id=Id_split; break L;\n+                } break L;\n+            case 6: switch (s.charAt(1)) {\n+                case 'e': X=\"search\";id=Id_search; break L;\n+                case 'h': X=\"charAt\";id=Id_charAt; break L;\n+                case 'n': X=\"anchor\";id=Id_anchor; break L;\n+                case 'o': X=\"concat\";id=Id_concat; break L;\n+                case 'q': X=\"equals\";id=Id_equals; break L;\n+                case 't': X=\"strike\";id=Id_strike; break L;\n+                case 'u': X=\"substr\";id=Id_substr; break L;\n+                } break L;\n+            case 7: switch (s.charAt(1)) {\n+                case 'a': X=\"valueOf\";id=Id_valueOf; break L;\n+                case 'e': X=\"replace\";id=Id_replace; break L;\n+                case 'n': X=\"indexOf\";id=Id_indexOf; break L;\n+                case 't': X=\"italics\";id=Id_italics; break L;\n+                } break L;\n+            case 8: c=s.charAt(4);\n+                if (c=='r') { X=\"toString\";id=Id_toString; }\n+                else if (c=='s') { X=\"fontsize\";id=Id_fontsize; }\n+                else if (c=='u') { X=\"toSource\";id=Id_toSource; }\n+                break L;\n+            case 9: c=s.charAt(0);\n+                if (c=='f') { X=\"fontcolor\";id=Id_fontcolor; }\n+                else if (c=='s') { X=\"substring\";id=Id_substring; }\n+                break L;\n+            case 10: X=\"charCodeAt\";id=Id_charCodeAt; break L;\n+            case 11: switch (s.charAt(2)) {\n+                case 'L': X=\"toLowerCase\";id=Id_toLowerCase; break L;\n+                case 'U': X=\"toUpperCase\";id=Id_toUpperCase; break L;\n+                case 'n': X=\"constructor\";id=Id_constructor; break L;\n+                case 's': X=\"lastIndexOf\";id=Id_lastIndexOf; break L;\n+                } break L;\n+            case 13: X=\"localeCompare\";id=Id_localeCompare; break L;\n+            case 16: X=\"equalsIgnoreCase\";id=Id_equalsIgnoreCase; break L;\n+            case 17: c=s.charAt(8);\n+                if (c=='L') { X=\"toLocaleLowerCase\";id=Id_toLocaleLowerCase; }\n+                else if (c=='U') { X=\"toLocaleUpperCase\";id=Id_toLocaleUpperCase; }\n+                break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        ConstructorId_fromCharCode   = -1,\n+\n+        Id_constructor               = 1,\n+        Id_toString                  = 2,\n+        Id_toSource                  = 3,\n+        Id_valueOf                   = 4,\n+        Id_charAt                    = 5,\n+        Id_charCodeAt                = 6,\n+        Id_indexOf                   = 7,\n+        Id_lastIndexOf               = 8,\n+        Id_split                     = 9,\n+        Id_substring                 = 10,\n+        Id_toLowerCase               = 11,\n+        Id_toUpperCase               = 12,\n+        Id_substr                    = 13,\n+        Id_concat                    = 14,\n+        Id_slice                     = 15,\n+        Id_bold                      = 16,\n+        Id_italics                   = 17,\n+        Id_fixed                     = 18,\n+        Id_strike                    = 19,\n+        Id_small                     = 20,\n+        Id_big                       = 21,\n+        Id_blink                     = 22,\n+        Id_sup                       = 23,\n+        Id_sub                       = 24,\n+        Id_fontsize                  = 25,\n+        Id_fontcolor                 = 26,\n+        Id_link                      = 27,\n+        Id_anchor                    = 28,\n+        Id_equals                    = 29,\n+        Id_equalsIgnoreCase          = 30,\n+        Id_match                     = 31,\n+        Id_search                    = 32,\n+        Id_replace                   = 33,\n+        Id_localeCompare             = 34,\n+        Id_toLocaleLowerCase         = 35,\n+        Id_toLocaleUpperCase         = 36,\n+        Id_trim                      = 37,\n+        MAX_PROTOTYPE_ID             = Id_trim;\n+\n+// #/string_id_map#\n+\n+    private static final int\n+        ConstructorId_charAt         = -Id_charAt,\n+        ConstructorId_charCodeAt     = -Id_charCodeAt,\n+        ConstructorId_indexOf        = -Id_indexOf,\n+        ConstructorId_lastIndexOf    = -Id_lastIndexOf,\n+        ConstructorId_split          = -Id_split,\n+        ConstructorId_substring      = -Id_substring,\n+        ConstructorId_toLowerCase    = -Id_toLowerCase,\n+        ConstructorId_toUpperCase    = -Id_toUpperCase,\n+        ConstructorId_substr         = -Id_substr,\n+        ConstructorId_concat         = -Id_concat,\n+        ConstructorId_slice          = -Id_slice,\n+        ConstructorId_equalsIgnoreCase = -Id_equalsIgnoreCase,\n+        ConstructorId_match          = -Id_match,\n+        ConstructorId_search         = -Id_search,\n+        ConstructorId_replace        = -Id_replace,\n+        ConstructorId_localeCompare  = -Id_localeCompare,\n+        ConstructorId_toLocaleLowerCase = -Id_toLocaleLowerCase;\n+\n+    private String string;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NativeWith.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * This class implements the object lookup required for the\n+ * <code>with</code> statement.\n+ * It simply delegates every action to its prototype except\n+ * for operations on its parent.\n+ */\n+public class NativeWith implements Scriptable, IdFunctionCall, Serializable {\n+    \n+    private static final long serialVersionUID = 1L;\n+\n+    static void init(Scriptable scope, boolean sealed)\n+    {\n+        NativeWith obj = new NativeWith();\n+\n+        obj.setParentScope(scope);\n+        obj.setPrototype(ScriptableObject.getObjectPrototype(scope));\n+\n+        IdFunctionObject ctor = new IdFunctionObject(obj, FTAG, Id_constructor,\n+                                         \"With\", 0, scope);\n+        ctor.markAsConstructor(obj);\n+        if (sealed) {\n+            ctor.sealObject();\n+        }\n+        ctor.exportAsScopeProperty();\n+    }\n+\n+    private NativeWith() {\n+    }\n+\n+    protected NativeWith(Scriptable parent, Scriptable prototype) {\n+        this.parent = parent;\n+        this.prototype = prototype;\n+    }\n+\n+    public String getClassName() {\n+        return \"With\";\n+    }\n+\n+    public boolean has(String id, Scriptable start)\n+    {\n+        return prototype.has(id, prototype);\n+    }\n+\n+    public boolean has(int index, Scriptable start)\n+    {\n+        return prototype.has(index, prototype);\n+    }\n+\n+    public Object get(String id, Scriptable start)\n+    {\n+        if (start == this)\n+            start = prototype;\n+        return prototype.get(id, start);\n+    }\n+\n+    public Object get(int index, Scriptable start)\n+    {\n+        if (start == this)\n+            start = prototype;\n+        return prototype.get(index, start);\n+    }\n+\n+    public void put(String id, Scriptable start, Object value)\n+    {\n+        if (start == this)\n+            start = prototype;\n+        prototype.put(id, start, value);\n+    }\n+\n+    public void put(int index, Scriptable start, Object value)\n+    {\n+        if (start == this)\n+            start = prototype;\n+        prototype.put(index, start, value);\n+    }\n+\n+    public void delete(String id)\n+    {\n+        prototype.delete(id);\n+    }\n+\n+    public void delete(int index)\n+    {\n+        prototype.delete(index);\n+    }\n+\n+    public Scriptable getPrototype() {\n+        return prototype;\n+    }\n+\n+    public void setPrototype(Scriptable prototype) {\n+        this.prototype = prototype;\n+    }\n+\n+    public Scriptable getParentScope() {\n+        return parent;\n+    }\n+\n+    public void setParentScope(Scriptable parent) {\n+        this.parent = parent;\n+    }\n+\n+    public Object[] getIds() {\n+        return prototype.getIds();\n+    }\n+\n+    public Object getDefaultValue(Class<?> typeHint) {\n+        return prototype.getDefaultValue(typeHint);\n+    }\n+\n+    public boolean hasInstance(Scriptable value) {\n+        return prototype.hasInstance(value);\n+    }\n+\n+    /**\n+     * Must return null to continue looping or the final collection result.\n+     */\n+    protected Object updateDotQuery(boolean value)\n+    {\n+        // NativeWith itself does not support it\n+        throw new IllegalStateException();\n+    }\n+\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (f.hasTag(FTAG)) {\n+            if (f.methodId() == Id_constructor) {\n+                throw Context.reportRuntimeError1(\"msg.cant.call.indirect\", \"With\");\n+            }\n+        }\n+        throw f.unknown();\n+    }\n+\n+    static boolean isWithFunction(Object functionObj)\n+    {\n+        if (functionObj instanceof IdFunctionObject) {\n+            IdFunctionObject f = (IdFunctionObject)functionObj;\n+            return f.hasTag(FTAG) && f.methodId() == Id_constructor;\n+        }\n+        return false;\n+    }\n+\n+    static Object newWithSpecial(Context cx, Scriptable scope, Object[] args)\n+    {\n+        ScriptRuntime.checkDeprecated(cx, \"With\");\n+        scope = ScriptableObject.getTopLevelScope(scope);\n+        NativeWith thisObj = new NativeWith();\n+        thisObj.setPrototype(args.length == 0\n+                             ? ScriptableObject.getClassPrototype(scope,\n+                                                                  \"Object\")\n+                             : ScriptRuntime.toObject(cx, scope, args[0]));\n+        thisObj.setParentScope(scope);\n+        return thisObj;\n+    }\n+\n+    private static final Object FTAG = \"With\";\n+\n+    private static final int\n+        Id_constructor = 1;\n+\n+    protected Scriptable prototype;\n+    protected Scriptable parent;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Node.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Roshan James\n+ *   Roger Lawrence\n+ *   Mike McCabe\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.javascript.ast.Comment;\n+import org.mozilla.javascript.ast.FunctionNode;\n+import org.mozilla.javascript.ast.Jump;\n+import org.mozilla.javascript.ast.Name;\n+import org.mozilla.javascript.ast.NumberLiteral;\n+import org.mozilla.javascript.ast.Scope;\n+import org.mozilla.javascript.ast.ScriptNode;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * This class implements the root of the intermediate representation.\n+ *\n+ */\n+public class Node implements Iterable<Node>\n+{\n+    public static final int\n+        FUNCTION_PROP      =  1,\n+        LOCAL_PROP         =  2,\n+        LOCAL_BLOCK_PROP   =  3,\n+        REGEXP_PROP        =  4,\n+        CASEARRAY_PROP     =  5,\n+\n+    //  the following properties are defined and manipulated by the\n+    //  optimizer -\n+    //  TARGETBLOCK_PROP - the block referenced by a branch node\n+    //  VARIABLE_PROP - the variable referenced by a BIND or NAME node\n+    //  ISNUMBER_PROP - this node generates code on Number children and\n+    //                  delivers a Number result (as opposed to Objects)\n+    //  DIRECTCALL_PROP - this call node should emit code to test the function\n+    //                    object against the known class and call direct if it\n+    //                    matches.\n+\n+        TARGETBLOCK_PROP     =  6,\n+        VARIABLE_PROP        =  7,\n+        ISNUMBER_PROP        =  8,\n+        DIRECTCALL_PROP      =  9,\n+        SPECIALCALL_PROP     = 10,\n+        SKIP_INDEXES_PROP    = 11, // array of skipped indexes of array literal\n+        OBJECT_IDS_PROP      = 12, // array of properties for object literal\n+        INCRDECR_PROP        = 13, // pre or post type of increment/decrement\n+        CATCH_SCOPE_PROP     = 14, // index of catch scope block in catch\n+        LABEL_ID_PROP        = 15, // label id: code generation uses it\n+        MEMBER_TYPE_PROP     = 16, // type of element access operation\n+        NAME_PROP            = 17, // property name\n+        CONTROL_BLOCK_PROP   = 18, // flags a control block that can drop off\n+        PARENTHESIZED_PROP   = 19, // expression is parenthesized\n+        GENERATOR_END_PROP   = 20,\n+        DESTRUCTURING_ARRAY_LENGTH = 21,\n+        DESTRUCTURING_NAMES  = 22,\n+        DESTRUCTURING_PARAMS = 23,\n+        JSDOC_PROP           = 24,\n+        EXPRESSION_CLOSURE_PROP = 25, // JS 1.8 expression closure pseudo-return\n+        DESTRUCTURING_SHORTHAND = 26, // JS 1.8 destructuring shorthand\n+        LAST_PROP            = 26;\n+\n+    // values of ISNUMBER_PROP to specify\n+    // which of the children are Number types\n+    public static final int\n+        BOTH = 0,\n+        LEFT = 1,\n+        RIGHT = 2;\n+\n+    public static final int    // values for SPECIALCALL_PROP\n+        NON_SPECIALCALL  = 0,\n+        SPECIALCALL_EVAL = 1,\n+        SPECIALCALL_WITH = 2;\n+\n+    public static final int   // flags for INCRDECR_PROP\n+        DECR_FLAG = 0x1,\n+        POST_FLAG = 0x2;\n+\n+    public static final int   // flags for MEMBER_TYPE_PROP\n+        PROPERTY_FLAG    = 0x1, // property access: element is valid name\n+        ATTRIBUTE_FLAG   = 0x2, // x.@y or x..@y\n+        DESCENDANTS_FLAG = 0x4; // x..y or x..@i\n+\n+    private static class PropListItem\n+    {\n+        PropListItem next;\n+        int type;\n+        int intValue;\n+        Object objectValue;\n+    }\n+\n+    public Node(int nodeType) {\n+        type = nodeType;\n+    }\n+\n+    public Node(int nodeType, Node child) {\n+        type = nodeType;\n+        first = last = child;\n+        child.next = null;\n+    }\n+\n+    public Node(int nodeType, Node left, Node right) {\n+        type = nodeType;\n+        first = left;\n+        last = right;\n+        left.next = right;\n+        right.next = null;\n+    }\n+\n+    public Node(int nodeType, Node left, Node mid, Node right) {\n+        type = nodeType;\n+        first = left;\n+        last = right;\n+        left.next = mid;\n+        mid.next = right;\n+        right.next = null;\n+    }\n+\n+    public Node(int nodeType, int line) {\n+        type = nodeType;\n+        lineno = line;\n+    }\n+\n+    public Node(int nodeType, Node child, int line) {\n+        this(nodeType, child);\n+        lineno = line;\n+    }\n+\n+    public Node(int nodeType, Node left, Node right, int line) {\n+        this(nodeType, left, right);\n+        lineno = line;\n+    }\n+\n+    public Node(int nodeType, Node left, Node mid, Node right, int line) {\n+        this(nodeType, left, mid, right);\n+        lineno = line;\n+    }\n+\n+    public static Node newNumber(double number) {\n+        NumberLiteral n = new NumberLiteral();\n+        n.setNumber(number);\n+        return n;\n+    }\n+\n+    public static Node newString(String str) {\n+        return newString(Token.STRING, str);\n+    }\n+\n+    public static Node newString(int type, String str) {\n+        Name name = new Name();\n+        name.setIdentifier(str);\n+        name.setType(type);\n+        return name;\n+    }\n+\n+    public int getType() {\n+        return type;\n+    }\n+\n+    /**\n+     * Sets the node type and returns this node.\n+     */\n+    public Node setType(int type) {\n+        this.type = type;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the JsDoc comment string attached to this node.\n+     * @return the comment string or {@code null} if no JsDoc is attached to\n+     *     this node\n+     */\n+    public String getJsDoc() {\n+        Comment comment = getJsDocNode();\n+        if (comment != null) {\n+          return comment.getValue();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the JsDoc Comment object attached to this node.\n+     * @return the Comment or {@code null} if no JsDoc is attached to\n+     *     this node\n+     */\n+    public Comment getJsDocNode() {\n+        return (Comment) getProp(JSDOC_PROP);\n+    }\n+\n+    /**\n+     * Sets the JsDoc comment string attached to this node.\n+     */\n+    public void setJsDocNode(Comment jsdocNode) {\n+        putProp(JSDOC_PROP, jsdocNode);\n+    }\n+\n+    public boolean hasChildren() {\n+        return first != null;\n+    }\n+\n+    public Node getFirstChild() {\n+        return first;\n+    }\n+\n+    public Node getLastChild() {\n+        return last;\n+    }\n+\n+    public Node getNext() {\n+        return next;\n+    }\n+\n+    public Node getChildBefore(Node child) {\n+        if (child == first)\n+            return null;\n+        Node n = first;\n+        while (n.next != child) {\n+            n = n.next;\n+            if (n == null)\n+                throw new RuntimeException(\"node is not a child\");\n+        }\n+        return n;\n+    }\n+\n+    public Node getLastSibling() {\n+        Node n = this;\n+        while (n.next != null) {\n+            n = n.next;\n+        }\n+        return n;\n+    }\n+\n+    public void addChildToFront(Node child) {\n+        child.next = first;\n+        first = child;\n+        if (last == null) {\n+            last = child;\n+        }\n+    }\n+\n+    public void addChildToBack(Node child) {\n+        child.next = null;\n+        if (last == null) {\n+            first = last = child;\n+            return;\n+        }\n+        last.next = child;\n+        last = child;\n+    }\n+\n+    public void addChildrenToFront(Node children) {\n+        Node lastSib = children.getLastSibling();\n+        lastSib.next = first;\n+        first = children;\n+        if (last == null) {\n+            last = lastSib;\n+        }\n+    }\n+\n+    public void addChildrenToBack(Node children) {\n+        if (last != null) {\n+            last.next = children;\n+        }\n+        last = children.getLastSibling();\n+        if (first == null) {\n+            first = children;\n+        }\n+    }\n+\n+    /**\n+     * Add 'child' before 'node'.\n+     */\n+    public void addChildBefore(Node newChild, Node node) {\n+        if (newChild.next != null)\n+            throw new RuntimeException(\n+                      \"newChild had siblings in addChildBefore\");\n+        if (first == node) {\n+            newChild.next = first;\n+            first = newChild;\n+            return;\n+        }\n+        Node prev = getChildBefore(node);\n+        addChildAfter(newChild, prev);\n+    }\n+\n+    /**\n+     * Add 'child' after 'node'.\n+     */\n+    public void addChildAfter(Node newChild, Node node) {\n+        if (newChild.next != null)\n+            throw new RuntimeException(\n+                      \"newChild had siblings in addChildAfter\");\n+        newChild.next = node.next;\n+        node.next = newChild;\n+        if (last == node)\n+            last = newChild;\n+    }\n+\n+    public void removeChild(Node child) {\n+        Node prev = getChildBefore(child);\n+        if (prev == null)\n+            first = first.next;\n+        else\n+            prev.next = child.next;\n+        if (child == last) last = prev;\n+        child.next = null;\n+    }\n+\n+    public void replaceChild(Node child, Node newChild) {\n+        newChild.next = child.next;\n+        if (child == first) {\n+            first = newChild;\n+        } else {\n+            Node prev = getChildBefore(child);\n+            prev.next = newChild;\n+        }\n+        if (child == last)\n+            last = newChild;\n+        child.next = null;\n+    }\n+\n+    public void replaceChildAfter(Node prevChild, Node newChild) {\n+        Node child = prevChild.next;\n+        newChild.next = child.next;\n+        prevChild.next = newChild;\n+        if (child == last)\n+            last = newChild;\n+        child.next = null;\n+    }\n+\n+    public void removeChildren() {\n+        first = last = null;\n+    }\n+\n+    private static final Node NOT_SET = new Node(Token.ERROR);\n+\n+    /**\n+     * Iterates over the children of this Node.  Supports child removal.  Not\n+     * thread-safe.  If anyone changes the child list before the iterator\n+     * finishes, the results are undefined and probably bad.\n+     */\n+    public class NodeIterator implements Iterator<Node> {\n+        private Node cursor;  // points to node to be returned next\n+        private Node prev = NOT_SET;\n+        private Node prev2;\n+        private boolean removed = false;\n+\n+        public NodeIterator() {\n+            cursor = Node.this.first;\n+        }\n+\n+        public boolean hasNext() {\n+            return cursor != null;\n+        }\n+\n+        public Node next() {\n+            if (cursor == null) {\n+                throw new NoSuchElementException();\n+            }\n+            removed = false;\n+            prev2 = prev;\n+            prev = cursor;\n+            cursor = cursor.next;\n+            return prev;\n+        }\n+\n+        public void remove() {\n+            if (prev == NOT_SET) {\n+                throw new IllegalStateException(\"next() has not been called\");\n+            }\n+            if (removed) {\n+                throw new IllegalStateException(\n+                    \"remove() already called for current element\");\n+            }\n+            if (prev == first) {\n+                first = prev.next;\n+            } else if (prev == last) {\n+                prev2.next = null;\n+                last = prev2;\n+            } else {\n+                prev2.next = cursor;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns an {@link java.util.Iterator} over the node's children.\n+     */\n+    public Iterator<Node> iterator() {\n+        return new NodeIterator();\n+    }\n+\n+    private static final String propToString(int propType)\n+    {\n+        if (Token.printTrees) {\n+            // If Context.printTrees is false, the compiler\n+            // can remove all these strings.\n+            switch (propType) {\n+                case FUNCTION_PROP:        return \"function\";\n+                case LOCAL_PROP:           return \"local\";\n+                case LOCAL_BLOCK_PROP:     return \"local_block\";\n+                case REGEXP_PROP:          return \"regexp\";\n+                case CASEARRAY_PROP:       return \"casearray\";\n+\n+                case TARGETBLOCK_PROP:     return \"targetblock\";\n+                case VARIABLE_PROP:        return \"variable\";\n+                case ISNUMBER_PROP:        return \"isnumber\";\n+                case DIRECTCALL_PROP:      return \"directcall\";\n+\n+                case SPECIALCALL_PROP:     return \"specialcall\";\n+                case SKIP_INDEXES_PROP:    return \"skip_indexes\";\n+                case OBJECT_IDS_PROP:      return \"object_ids_prop\";\n+                case INCRDECR_PROP:        return \"incrdecr_prop\";\n+                case CATCH_SCOPE_PROP:     return \"catch_scope_prop\";\n+                case LABEL_ID_PROP:        return \"label_id_prop\";\n+                case MEMBER_TYPE_PROP:     return \"member_type_prop\";\n+                case NAME_PROP:            return \"name_prop\";\n+                case CONTROL_BLOCK_PROP:   return \"control_block_prop\";\n+                case PARENTHESIZED_PROP:   return \"parenthesized_prop\";\n+                case GENERATOR_END_PROP:   return \"generator_end\";\n+                case DESTRUCTURING_ARRAY_LENGTH:\n+                                           return \"destructuring_array_length\";\n+                case DESTRUCTURING_NAMES:  return \"destructuring_names\";\n+                case DESTRUCTURING_PARAMS: return \"destructuring_params\";\n+\n+                default: Kit.codeBug();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private PropListItem lookupProperty(int propType)\n+    {\n+        PropListItem x = propListHead;\n+        while (x != null && propType != x.type) {\n+            x = x.next;\n+        }\n+        return x;\n+    }\n+\n+    private PropListItem ensureProperty(int propType)\n+    {\n+        PropListItem item = lookupProperty(propType);\n+        if (item == null) {\n+            item = new PropListItem();\n+            item.type = propType;\n+            item.next = propListHead;\n+            propListHead = item;\n+        }\n+        return item;\n+    }\n+\n+    public void removeProp(int propType)\n+    {\n+        PropListItem x = propListHead;\n+        if (x != null) {\n+            PropListItem prev = null;\n+            while (x.type != propType) {\n+                prev = x;\n+                x = x.next;\n+                if (x == null) { return; }\n+            }\n+            if (prev == null) {\n+                propListHead = x.next;\n+            } else {\n+                prev.next = x.next;\n+            }\n+        }\n+    }\n+\n+    public Object getProp(int propType)\n+    {\n+        PropListItem item = lookupProperty(propType);\n+        if (item == null) { return null; }\n+        return item.objectValue;\n+    }\n+\n+    public int getIntProp(int propType, int defaultValue)\n+    {\n+        PropListItem item = lookupProperty(propType);\n+        if (item == null) { return defaultValue; }\n+        return item.intValue;\n+    }\n+\n+    public int getExistingIntProp(int propType)\n+    {\n+        PropListItem item = lookupProperty(propType);\n+        if (item == null) { Kit.codeBug(); }\n+        return item.intValue;\n+    }\n+\n+    public void putProp(int propType, Object prop)\n+    {\n+        if (prop == null) {\n+            removeProp(propType);\n+        } else {\n+            PropListItem item = ensureProperty(propType);\n+            item.objectValue = prop;\n+        }\n+    }\n+\n+    public void putIntProp(int propType, int prop)\n+    {\n+        PropListItem item = ensureProperty(propType);\n+        item.intValue = prop;\n+    }\n+\n+    /**\n+     * Return the line number recorded for this node.\n+     * @return the line number\n+     */\n+    public int getLineno() {\n+        return lineno;\n+    }\n+\n+    public void setLineno(int lineno) {\n+        this.lineno = lineno;\n+    }\n+\n+    /** Can only be called when <tt>getType() == Token.NUMBER</tt> */\n+    public final double getDouble() {\n+        return ((NumberLiteral)this).getNumber();\n+    }\n+\n+    public final void setDouble(double number) {\n+        ((NumberLiteral)this).setNumber(number);\n+    }\n+\n+    /** Can only be called when node has String context. */\n+    public final String getString() {\n+        return ((Name)this).getIdentifier();\n+    }\n+\n+    /** Can only be called when node has String context. */\n+    public final void setString(String s) {\n+        if (s == null) Kit.codeBug();\n+        ((Name)this).setIdentifier(s);\n+    }\n+\n+    /** Can only be called when node has String context. */\n+    public Scope getScope() {\n+        return ((Name)this).getScope();\n+    }\n+\n+    /** Can only be called when node has String context. */\n+    public void setScope(Scope s) {\n+        if (s == null) Kit.codeBug();\n+        if (!(this instanceof Name)) {\n+            throw Kit.codeBug();\n+        }\n+        ((Name)this).setScope(s);\n+    }\n+\n+    public static Node newTarget()\n+    {\n+        return new Node(Token.TARGET);\n+    }\n+\n+    public final int labelId()\n+    {\n+        if (type != Token.TARGET && type != Token.YIELD) Kit.codeBug();\n+        return getIntProp(LABEL_ID_PROP, -1);\n+    }\n+\n+    public void labelId(int labelId)\n+    {\n+        if (type != Token.TARGET  && type != Token.YIELD) Kit.codeBug();\n+        putIntProp(LABEL_ID_PROP, labelId);\n+    }\n+\n+\n+    /**\n+     * Does consistent-return analysis on the function body when strict mode is\n+     * enabled.\n+     *\n+     *   function (x) { return (x+1) }\n+     * is ok, but\n+     *   function (x) { if (x &lt; 0) return (x+1); }\n+     * is not becuase the function can potentially return a value when the\n+     * condition is satisfied and if not, the function does not explicitly\n+     * return value.\n+     *\n+     * This extends to checking mismatches such as \"return\" and \"return <value>\"\n+     * used in the same function. Warnings are not emitted if inconsistent\n+     * returns exist in code that can be statically shown to be unreachable.\n+     * Ex.\n+     * <pre>function (x) { while (true) { ... if (..) { return value } ... } }\n+     * </pre>\n+     * emits no warning. However if the loop had a break statement, then a\n+     * warning would be emitted.\n+     *\n+     * The consistency analysis looks at control structures such as loops, ifs,\n+     * switch, try-catch-finally blocks, examines the reachable code paths and\n+     * warns the user about an inconsistent set of termination possibilities.\n+     *\n+     * Caveat: Since the parser flattens many control structures into almost\n+     * straight-line code with gotos, it makes such analysis hard. Hence this\n+     * analyser is written to taken advantage of patterns of code generated by\n+     * the parser (for loops, try blocks and such) and does not do a full\n+     * control flow analysis of the gotos and break/continue statements.\n+     * Future changes to the parser will affect this analysis.\n+     */\n+\n+    /**\n+     * These flags enumerate the possible ways a statement/function can\n+     * terminate. These flags are used by endCheck() and by the Parser to\n+     * detect inconsistent return usage.\n+     *\n+     * END_UNREACHED is reserved for code paths that are assumed to always be\n+     * able to execute (example: throw, continue)\n+     *\n+     * END_DROPS_OFF indicates if the statement can transfer control to the\n+     * next one. Statement such as return dont. A compound statement may have\n+     * some branch that drops off control to the next statement.\n+     *\n+     * END_RETURNS indicates that the statement can return (without arguments)\n+     * END_RETURNS_VALUE indicates that the statement can return a value.\n+     *\n+     * A compound statement such as\n+     * if (condition) {\n+     *   return value;\n+     * }\n+     * Will be detected as (END_DROPS_OFF | END_RETURN_VALUE) by endCheck()\n+     */\n+    public static final int END_UNREACHED = 0;\n+    public static final int END_DROPS_OFF = 1;\n+    public static final int END_RETURNS = 2;\n+    public static final int END_RETURNS_VALUE = 4;\n+    public static final int END_YIELDS = 8;\n+\n+    /**\n+     * Checks that every return usage in a function body is consistent with the\n+     * requirements of strict-mode.\n+     * @return true if the function satisfies strict mode requirement.\n+     */\n+    public boolean hasConsistentReturnUsage()\n+    {\n+        int n = endCheck();\n+        return (n & END_RETURNS_VALUE) == 0 ||\n+               (n & (END_DROPS_OFF|END_RETURNS|END_YIELDS)) == 0;\n+    }\n+\n+    /**\n+     * Returns in the then and else blocks must be consistent with each other.\n+     * If there is no else block, then the return statement can fall through.\n+     * @return logical OR of END_* flags\n+     */\n+    private int endCheckIf()\n+    {\n+        Node th, el;\n+        int rv = END_UNREACHED;\n+\n+        th = next;\n+        el = ((Jump)this).target;\n+\n+        rv = th.endCheck();\n+\n+        if (el != null)\n+            rv |= el.endCheck();\n+        else\n+            rv |= END_DROPS_OFF;\n+\n+        return rv;\n+    }\n+\n+    /**\n+     * Consistency of return statements is checked between the case statements.\n+     * If there is no default, then the switch can fall through. If there is a\n+     * default,we check to see if all code paths in the default return or if\n+     * there is a code path that can fall through.\n+     * @return logical OR of END_* flags\n+     */\n+    private int endCheckSwitch()\n+    {\n+        int rv = END_UNREACHED;\n+\n+        // examine the cases\n+//         for (n = first.next; n != null; n = n.next)\n+//         {\n+//             if (n.type == Token.CASE) {\n+//                 rv |= ((Jump)n).target.endCheck();\n+//             } else\n+//                 break;\n+//         }\n+\n+//         // we don't care how the cases drop into each other\n+//         rv &= ~END_DROPS_OFF;\n+\n+//         // examine the default\n+//         n = ((Jump)this).getDefault();\n+//         if (n != null)\n+//             rv |= n.endCheck();\n+//         else\n+//             rv |= END_DROPS_OFF;\n+\n+//         // remove the switch block\n+//         rv |= getIntProp(CONTROL_BLOCK_PROP, END_UNREACHED);\n+\n+        return rv;\n+    }\n+\n+    /**\n+     * If the block has a finally, return consistency is checked in the\n+     * finally block. If all code paths in the finally returns, then the\n+     * returns in the try-catch blocks don't matter. If there is a code path\n+     * that does not return or if there is no finally block, the returns\n+     * of the try and catch blocks are checked for mismatch.\n+     * @return logical OR of END_* flags\n+     */\n+    private int endCheckTry()\n+    {\n+        int rv = END_UNREACHED;\n+\n+        // a TryStatement isn't a jump - needs rewriting\n+\n+        // check the finally if it exists\n+//         n = ((Jump)this).getFinally();\n+//         if(n != null) {\n+//             rv = n.next.first.endCheck();\n+//         } else {\n+//             rv = END_DROPS_OFF;\n+//         }\n+\n+//         // if the finally block always returns, then none of the returns\n+//         // in the try or catch blocks matter\n+//         if ((rv & END_DROPS_OFF) != 0) {\n+//             rv &= ~END_DROPS_OFF;\n+\n+//             // examine the try block\n+//             rv |= first.endCheck();\n+\n+//             // check each catch block\n+//             n = ((Jump)this).target;\n+//             if (n != null)\n+//             {\n+//                 // point to the first catch_scope\n+//                 for (n = n.next.first; n != null; n = n.next.next)\n+//                 {\n+//                     // check the block of user code in the catch_scope\n+//                     rv |= n.next.first.next.first.endCheck();\n+//                 }\n+//             }\n+//         }\n+\n+        return rv;\n+    }\n+\n+    /**\n+     * Return statement in the loop body must be consistent. The default\n+     * assumption for any kind of a loop is that it will eventually terminate.\n+     * The only exception is a loop with a constant true condition. Code that\n+     * follows such a loop is examined only if one can statically determine\n+     * that there is a break out of the loop.\n+     * <pre>\n+     *  for(&lt;&gt; ; &lt;&gt;; &lt;&gt;) {}\n+     *  for(&lt;&gt; in &lt;&gt; ) {}\n+     *  while(&lt;&gt;) { }\n+     *  do { } while(&lt;&gt;)\n+     * </pre>\n+     * @return logical OR of END_* flags\n+     */\n+    private int endCheckLoop()\n+    {\n+        Node n;\n+        int rv = END_UNREACHED;\n+\n+        // To find the loop body, we look at the second to last node of the\n+        // loop node, which should be the predicate that the loop should\n+        // satisfy.\n+        // The target of the predicate is the loop-body for all 4 kinds of\n+        // loops.\n+        for (n = first; n.next != last; n = n.next) {\n+            /* skip */\n+        }\n+        if (n.type != Token.IFEQ)\n+            return END_DROPS_OFF;\n+\n+        // The target's next is the loop body block\n+        rv = ((Jump)n).target.next.endCheck();\n+\n+        // check to see if the loop condition is true\n+        if (n.first.type == Token.TRUE)\n+            rv &= ~END_DROPS_OFF;\n+\n+        // look for effect of breaks\n+        rv |= getIntProp(CONTROL_BLOCK_PROP, END_UNREACHED);\n+\n+        return rv;\n+    }\n+\n+    /**\n+     * A general block of code is examined statement by statement. If any\n+     * statement (even compound ones) returns in all branches, then subsequent\n+     * statements are not examined.\n+     * @return logical OR of END_* flags\n+     */\n+    private int endCheckBlock()\n+    {\n+        Node n;\n+        int rv = END_DROPS_OFF;\n+\n+        // check each statment and if the statement can continue onto the next\n+        // one, then check the next statement\n+        for (n=first; ((rv & END_DROPS_OFF) != 0) && n != null; n = n.next)\n+        {\n+            rv &= ~END_DROPS_OFF;\n+            rv |= n.endCheck();\n+        }\n+        return rv;\n+    }\n+\n+    /**\n+     * A labelled statement implies that there maybe a break to the label. The\n+     * function processes the labelled statement and then checks the\n+     * CONTROL_BLOCK_PROP property to see if there is ever a break to the\n+     * particular label.\n+     * @return logical OR of END_* flags\n+     */\n+    private int endCheckLabel()\n+    {\n+        int rv = END_UNREACHED;\n+\n+        rv = next.endCheck();\n+        rv |= getIntProp(CONTROL_BLOCK_PROP, END_UNREACHED);\n+\n+        return rv;\n+    }\n+\n+    /**\n+     * When a break is encountered annotate the statement being broken\n+     * out of by setting its CONTROL_BLOCK_PROP property.\n+     * @return logical OR of END_* flags\n+     */\n+    private int endCheckBreak()\n+    {\n+        Node n = ((Jump) this).getJumpStatement();\n+        n.putIntProp(CONTROL_BLOCK_PROP, END_DROPS_OFF);\n+        return END_UNREACHED;\n+    }\n+\n+    /**\n+     * endCheck() examines the body of a function, doing a basic reachability\n+     * analysis and returns a combination of flags END_* flags that indicate\n+     * how the function execution can terminate. These constitute only the\n+     * pessimistic set of termination conditions. It is possible that at\n+     * runtime certain code paths will never be actually taken. Hence this\n+     * analysis will flag errors in cases where there may not be errors.\n+     * @return logical OR of END_* flags\n+     */\n+    private int endCheck()\n+    {\n+        switch(type)\n+        {\n+            case Token.BREAK:\n+                return endCheckBreak();\n+\n+            case Token.EXPR_VOID:\n+                if (this.first != null)\n+                    return first.endCheck();\n+                return END_DROPS_OFF;\n+\n+            case Token.YIELD:\n+                return END_YIELDS;\n+\n+            case Token.CONTINUE:\n+            case Token.THROW:\n+                return END_UNREACHED;\n+\n+            case Token.RETURN:\n+                if (this.first != null)\n+                    return END_RETURNS_VALUE;\n+                else\n+                    return END_RETURNS;\n+\n+            case Token.TARGET:\n+                if (next != null)\n+                    return next.endCheck();\n+                else\n+                    return END_DROPS_OFF;\n+\n+            case Token.LOOP:\n+                return endCheckLoop();\n+\n+            case Token.LOCAL_BLOCK:\n+            case Token.BLOCK:\n+                // there are several special kinds of blocks\n+                if (first == null)\n+                    return END_DROPS_OFF;\n+\n+                switch(first.type) {\n+                    case Token.LABEL:\n+                        return first.endCheckLabel();\n+\n+                    case Token.IFNE:\n+                        return first.endCheckIf();\n+\n+                    case Token.SWITCH:\n+                        return first.endCheckSwitch();\n+\n+                    case Token.TRY:\n+                        return first.endCheckTry();\n+\n+                    default:\n+                        return endCheckBlock();\n+                }\n+\n+            default:\n+                return END_DROPS_OFF;\n+        }\n+    }\n+\n+    public boolean hasSideEffects()\n+    {\n+        switch (type) {\n+          case Token.EXPR_VOID:\n+          case Token.COMMA:\n+            if (last != null)\n+                return last.hasSideEffects();\n+            else\n+                return true;\n+\n+          case Token.HOOK:\n+            if (first == null ||\n+                first.next == null ||\n+                first.next.next == null)\n+                Kit.codeBug();\n+            return first.next.hasSideEffects() &&\n+                   first.next.next.hasSideEffects();\n+\n+          case Token.AND:\n+          case Token.OR:\n+            if (first == null || last == null)\n+                Kit.codeBug();\n+            return first.hasSideEffects() || last.hasSideEffects();\n+\n+          case Token.ERROR:         // Avoid cascaded error messages\n+          case Token.EXPR_RESULT:\n+          case Token.ASSIGN:\n+          case Token.ASSIGN_ADD:\n+          case Token.ASSIGN_SUB:\n+          case Token.ASSIGN_MUL:\n+          case Token.ASSIGN_DIV:\n+          case Token.ASSIGN_MOD:\n+          case Token.ASSIGN_BITOR:\n+          case Token.ASSIGN_BITXOR:\n+          case Token.ASSIGN_BITAND:\n+          case Token.ASSIGN_LSH:\n+          case Token.ASSIGN_RSH:\n+          case Token.ASSIGN_URSH:\n+          case Token.ENTERWITH:\n+          case Token.LEAVEWITH:\n+          case Token.RETURN:\n+          case Token.GOTO:\n+          case Token.IFEQ:\n+          case Token.IFNE:\n+          case Token.NEW:\n+          case Token.DELPROP:\n+          case Token.SETNAME:\n+          case Token.SETPROP:\n+          case Token.SETELEM:\n+          case Token.CALL:\n+          case Token.THROW:\n+          case Token.RETHROW:\n+          case Token.SETVAR:\n+          case Token.CATCH_SCOPE:\n+          case Token.RETURN_RESULT:\n+          case Token.SET_REF:\n+          case Token.DEL_REF:\n+          case Token.REF_CALL:\n+          case Token.TRY:\n+          case Token.SEMI:\n+          case Token.INC:\n+          case Token.DEC:\n+          case Token.IF:\n+          case Token.ELSE:\n+          case Token.SWITCH:\n+          case Token.WHILE:\n+          case Token.DO:\n+          case Token.FOR:\n+          case Token.BREAK:\n+          case Token.CONTINUE:\n+          case Token.VAR:\n+          case Token.CONST:\n+          case Token.LET:\n+          case Token.LETEXPR:\n+          case Token.WITH:\n+          case Token.WITHEXPR:\n+          case Token.CATCH:\n+          case Token.FINALLY:\n+          case Token.BLOCK:\n+          case Token.LABEL:\n+          case Token.TARGET:\n+          case Token.LOOP:\n+          case Token.JSR:\n+          case Token.SETPROP_OP:\n+          case Token.SETELEM_OP:\n+          case Token.LOCAL_BLOCK:\n+          case Token.SET_REF_OP:\n+          case Token.YIELD:\n+            return true;\n+\n+          default:\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        if (Token.printTrees) {\n+            StringBuffer sb = new StringBuffer();\n+            toString(new ObjToIntMap(), sb);\n+            return sb.toString();\n+        }\n+        return String.valueOf(type);\n+    }\n+\n+    private void toString(ObjToIntMap printIds, StringBuffer sb)\n+    {\n+        if (Token.printTrees) {\n+            sb.append(Token.name(type));\n+            if (this instanceof Name) {\n+                sb.append(' ');\n+                sb.append(getString());\n+                Scope scope = getScope();\n+                if (scope != null) {\n+                    sb.append(\"[scope: \");\n+                    appendPrintId(scope, printIds, sb);\n+                    sb.append(\"]\");\n+                }\n+            } else if (this instanceof Scope) {\n+                if (this instanceof ScriptNode) {\n+                    ScriptNode sof = (ScriptNode)this;\n+                    if (this instanceof FunctionNode) {\n+                        FunctionNode fn = (FunctionNode)this;\n+                        sb.append(' ');\n+                        sb.append(fn.getName());\n+                    }\n+                    sb.append(\" [source name: \");\n+                    sb.append(sof.getSourceName());\n+                    sb.append(\"] [encoded source length: \");\n+                    sb.append(sof.getEncodedSourceEnd()\n+                              - sof.getEncodedSourceStart());\n+                    sb.append(\"] [base line: \");\n+                    sb.append(sof.getBaseLineno());\n+                    sb.append(\"] [end line: \");\n+                    sb.append(sof.getEndLineno());\n+                    sb.append(']');\n+                }\n+                if (((Scope)this).getSymbolTable() != null) {\n+                    sb.append(\" [scope \");\n+                    appendPrintId(this, printIds, sb);\n+                    sb.append(\": \");\n+                    Iterator<String> iter =\n+                        ((Scope) this).getSymbolTable().keySet().iterator();\n+                    while (iter.hasNext()) {\n+                        sb.append(iter.next());\n+                        sb.append(\" \");\n+                    }\n+                    sb.append(\"]\");\n+                }\n+            } else if (this instanceof Jump) {\n+                Jump jump = (Jump)this;\n+                if (type == Token.BREAK || type == Token.CONTINUE) {\n+                    sb.append(\" [label: \");\n+                    appendPrintId(jump.getJumpStatement(), printIds, sb);\n+                    sb.append(']');\n+                } else if (type == Token.TRY) {\n+                    Node catchNode = jump.target;\n+                    Node finallyTarget = jump.getFinally();\n+                    if (catchNode != null) {\n+                        sb.append(\" [catch: \");\n+                        appendPrintId(catchNode, printIds, sb);\n+                        sb.append(']');\n+                    }\n+                    if (finallyTarget != null) {\n+                        sb.append(\" [finally: \");\n+                        appendPrintId(finallyTarget, printIds, sb);\n+                        sb.append(']');\n+                    }\n+                } else if (type == Token.LABEL || type == Token.LOOP\n+                           || type == Token.SWITCH)\n+                {\n+                    sb.append(\" [break: \");\n+                    appendPrintId(jump.target, printIds, sb);\n+                    sb.append(']');\n+                    if (type == Token.LOOP) {\n+                        sb.append(\" [continue: \");\n+                        appendPrintId(jump.getContinue(), printIds, sb);\n+                        sb.append(']');\n+                    }\n+                } else {\n+                    sb.append(\" [target: \");\n+                    appendPrintId(jump.target, printIds, sb);\n+                    sb.append(']');\n+                }\n+            } else if (type == Token.NUMBER) {\n+                sb.append(' ');\n+                sb.append(getDouble());\n+            } else if (type == Token.TARGET) {\n+                sb.append(' ');\n+                appendPrintId(this, printIds, sb);\n+            }\n+            if (lineno != -1) {\n+                sb.append(' ');\n+                sb.append(lineno);\n+            }\n+\n+            for (PropListItem x = propListHead; x != null; x = x.next) {\n+                int type = x.type;\n+                sb.append(\" [\");\n+                sb.append(propToString(type));\n+                sb.append(\": \");\n+                String value;\n+                switch (type) {\n+                  case TARGETBLOCK_PROP : // can't add this as it recurses\n+                    value = \"target block property\";\n+                    break;\n+                  case LOCAL_BLOCK_PROP :     // can't add this as it is dull\n+                    value = \"last local block\";\n+                    break;\n+                  case ISNUMBER_PROP:\n+                    switch (x.intValue) {\n+                      case BOTH:\n+                        value = \"both\";\n+                        break;\n+                      case RIGHT:\n+                        value = \"right\";\n+                        break;\n+                      case LEFT:\n+                        value = \"left\";\n+                        break;\n+                      default:\n+                        throw Kit.codeBug();\n+                    }\n+                    break;\n+                  case SPECIALCALL_PROP:\n+                    switch (x.intValue) {\n+                      case SPECIALCALL_EVAL:\n+                        value = \"eval\";\n+                        break;\n+                      case SPECIALCALL_WITH:\n+                        value = \"with\";\n+                        break;\n+                      default:\n+                        // NON_SPECIALCALL should not be stored\n+                        throw Kit.codeBug();\n+                    }\n+                    break;\n+                  case OBJECT_IDS_PROP: {\n+                    Object[] a = (Object[]) x.objectValue;\n+                    value = \"[\";\n+                    for (int i=0; i < a.length; i++) {\n+                        value += a[i].toString();\n+                        if (i+1 < a.length)\n+                            value += \", \";\n+                    }\n+                    value += \"]\";\n+                    break;\n+                  }\n+                  default :\n+                    Object obj = x.objectValue;\n+                    if (obj != null) {\n+                        value = obj.toString();\n+                    } else {\n+                        value = String.valueOf(x.intValue);\n+                    }\n+                    break;\n+                }\n+                sb.append(value);\n+                sb.append(']');\n+            }\n+        }\n+    }\n+\n+    public String toStringTree(ScriptNode treeTop) {\n+        if (Token.printTrees) {\n+            StringBuffer sb = new StringBuffer();\n+            toStringTreeHelper(treeTop, this, null, 0, sb);\n+            return sb.toString();\n+        }\n+        return null;\n+    }\n+\n+    private static void toStringTreeHelper(ScriptNode treeTop, Node n,\n+                                           ObjToIntMap printIds,\n+                                           int level, StringBuffer sb)\n+    {\n+        if (Token.printTrees) {\n+            if (printIds == null) {\n+                printIds = new ObjToIntMap();\n+                generatePrintIds(treeTop, printIds);\n+            }\n+            for (int i = 0; i != level; ++i) {\n+                sb.append(\"    \");\n+            }\n+            n.toString(printIds, sb);\n+            sb.append('\\n');\n+            for (Node cursor = n.getFirstChild(); cursor != null;\n+                 cursor = cursor.getNext())\n+            {\n+                if (cursor.getType() == Token.FUNCTION) {\n+                    int fnIndex = cursor.getExistingIntProp(Node.FUNCTION_PROP);\n+                    FunctionNode fn = treeTop.getFunctionNode(fnIndex);\n+                    toStringTreeHelper(fn, fn, null, level + 1, sb);\n+                } else {\n+                    toStringTreeHelper(treeTop, cursor, printIds, level+1, sb);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void generatePrintIds(Node n, ObjToIntMap map)\n+    {\n+        if (Token.printTrees) {\n+            map.put(n, map.size());\n+            for (Node cursor = n.getFirstChild(); cursor != null;\n+                 cursor = cursor.getNext())\n+            {\n+                generatePrintIds(cursor, map);\n+            }\n+        }\n+    }\n+\n+    private static void appendPrintId(Node n, ObjToIntMap printIds,\n+                                      StringBuffer sb)\n+    {\n+        if (Token.printTrees) {\n+            if (n != null) {\n+                int id = printIds.get(n, -1);\n+                sb.append('#');\n+                if (id != -1) {\n+                    sb.append(id + 1);\n+                } else {\n+                    sb.append(\"<not_available>\");\n+                }\n+            }\n+        }\n+    }\n+\n+    protected int type = Token.ERROR; // type of the node, e.g. Token.NAME\n+    protected Node next;             // next sibling\n+    protected Node first;    // first element of a linked list of children\n+    protected Node last;     // last element of a linked list of children\n+    protected int lineno = -1;\n+\n+    /**\n+     * Linked list of properties. Since vast majority of nodes would have\n+     * no more then 2 properties, linked list saves memory and provides\n+     * fast lookup. If this does not holds, propListHead can be replaced\n+     * by UintMap.\n+     */\n+    protected PropListItem propListHead;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/NodeTransformer.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Bob Jervis\n+ *   Roger Lawrence\n+ *   Mike McCabe\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.javascript.ast.AstRoot;\n+import org.mozilla.javascript.ast.FunctionNode;\n+import org.mozilla.javascript.ast.Jump;\n+import org.mozilla.javascript.ast.Scope;\n+import org.mozilla.javascript.ast.ScriptNode;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class transforms a tree to a lower-level representation for codegen.\n+ *\n+ * @see Node\n+ */\n+\n+public class NodeTransformer\n+{\n+\n+    public NodeTransformer()\n+    {\n+    }\n+\n+    public final void transform(ScriptNode tree)\n+    {\n+        transformCompilationUnit(tree);\n+        for (int i = 0; i != tree.getFunctionCount(); ++i) {\n+            FunctionNode fn = tree.getFunctionNode(i);\n+            transform(fn);\n+        }\n+    }\n+\n+    private void transformCompilationUnit(ScriptNode tree)\n+    {\n+        loops = new ObjArray();\n+        loopEnds = new ObjArray();\n+\n+        // to save against upchecks if no finally blocks are used.\n+        hasFinally = false;\n+\n+        // Flatten all only if we are not using scope objects for block scope\n+        boolean createScopeObjects = tree.getType() != Token.FUNCTION ||\n+                                  ((FunctionNode)tree).requiresActivation();\n+        tree.flattenSymbolTable(!createScopeObjects);\n+\n+        //uncomment to print tree before transformation\n+        if (Token.printTrees) System.out.println(tree.toStringTree(tree));\n+        boolean inStrictMode = tree instanceof AstRoot &&\n+                               ((AstRoot)tree).isInStrictMode();\n+        transformCompilationUnit_r(tree, tree, tree, createScopeObjects,\n+                                   inStrictMode);\n+    }\n+\n+    private void transformCompilationUnit_r(final ScriptNode tree,\n+                                            final Node parent,\n+                                            Scope scope,\n+                                            boolean createScopeObjects,\n+                                            boolean inStrictMode)\n+    {\n+        Node node = null;\n+      siblingLoop:\n+        for (;;) {\n+            Node previous = null;\n+            if (node == null) {\n+                node = parent.getFirstChild();\n+            } else {\n+                previous = node;\n+                node = node.getNext();\n+            }\n+            if (node == null) {\n+                break;\n+            }\n+\n+            int type = node.getType();\n+            if (createScopeObjects &&\n+                (type == Token.BLOCK || type == Token.LOOP ||\n+                 type == Token.ARRAYCOMP) &&\n+                (node instanceof Scope))\n+            {\n+                Scope newScope = (Scope) node;\n+                if (newScope.getSymbolTable() != null) {\n+                    // transform to let statement so we get a with statement\n+                    // created to contain scoped let variables\n+                    Node let = new Node(type == Token.ARRAYCOMP ? Token.LETEXPR\n+                                                                : Token.LET);\n+                    Node innerLet = new Node(Token.LET);\n+                    let.addChildToBack(innerLet);\n+                    for (String name: newScope.getSymbolTable().keySet()) {\n+                        innerLet.addChildToBack(Node.newString(Token.NAME, name));\n+                    }\n+                    newScope.setSymbolTable(null); // so we don't transform again\n+                    Node oldNode = node;\n+                    node = replaceCurrent(parent, previous, node, let);\n+                    type = node.getType();\n+                    let.addChildToBack(oldNode);\n+                }\n+            }\n+\n+            switch (type) {\n+\n+              case Token.LABEL:\n+              case Token.SWITCH:\n+              case Token.LOOP:\n+                loops.push(node);\n+                loopEnds.push(((Jump)node).target);\n+                break;\n+\n+              case Token.WITH:\n+              {\n+                loops.push(node);\n+                Node leave = node.getNext();\n+                if (leave.getType() != Token.LEAVEWITH) {\n+                    Kit.codeBug();\n+                }\n+                loopEnds.push(leave);\n+                break;\n+              }\n+\n+              case Token.TRY:\n+              {\n+                Jump jump = (Jump)node;\n+                Node finallytarget = jump.getFinally();\n+                if (finallytarget != null) {\n+                    hasFinally = true;\n+                    loops.push(node);\n+                    loopEnds.push(finallytarget);\n+                }\n+                break;\n+              }\n+\n+              case Token.TARGET:\n+              case Token.LEAVEWITH:\n+                if (!loopEnds.isEmpty() && loopEnds.peek() == node) {\n+                    loopEnds.pop();\n+                    loops.pop();\n+                }\n+                break;\n+\n+              case Token.YIELD:\n+                ((FunctionNode)tree).addResumptionPoint(node);\n+                break;\n+\n+              case Token.RETURN:\n+              {\n+                boolean isGenerator = tree.getType() == Token.FUNCTION\n+                    && ((FunctionNode)tree).isGenerator();\n+                if (isGenerator) {\n+                    node.putIntProp(Node.GENERATOR_END_PROP, 1);\n+                }\n+                /* If we didn't support try/finally, it wouldn't be\n+                 * necessary to put LEAVEWITH nodes here... but as\n+                 * we do need a series of JSR FINALLY nodes before\n+                 * each RETURN, we need to ensure that each finally\n+                 * block gets the correct scope... which could mean\n+                 * that some LEAVEWITH nodes are necessary.\n+                 */\n+                if (!hasFinally)\n+                    break;     // skip the whole mess.\n+                Node unwindBlock = null;\n+                for (int i=loops.size()-1; i >= 0; i--) {\n+                    Node n = (Node) loops.get(i);\n+                    int elemtype = n.getType();\n+                    if (elemtype == Token.TRY || elemtype == Token.WITH) {\n+                        Node unwind;\n+                        if (elemtype == Token.TRY) {\n+                            Jump jsrnode = new Jump(Token.JSR);\n+                            Node jsrtarget = ((Jump)n).getFinally();\n+                            jsrnode.target = jsrtarget;\n+                            unwind = jsrnode;\n+                        } else {\n+                            unwind = new Node(Token.LEAVEWITH);\n+                        }\n+                        if (unwindBlock == null) {\n+                            unwindBlock = new Node(Token.BLOCK,\n+                                                   node.getLineno());\n+                        }\n+                        unwindBlock.addChildToBack(unwind);\n+                    }\n+                }\n+                if (unwindBlock != null) {\n+                    Node returnNode = node;\n+                    Node returnExpr = returnNode.getFirstChild();\n+                    node = replaceCurrent(parent, previous, node, unwindBlock);\n+                    if (returnExpr == null || isGenerator) {\n+                        unwindBlock.addChildToBack(returnNode);\n+                    } else {\n+                        Node store = new Node(Token.EXPR_RESULT, returnExpr);\n+                        unwindBlock.addChildToFront(store);\n+                        returnNode = new Node(Token.RETURN_RESULT);\n+                        unwindBlock.addChildToBack(returnNode);\n+                        // transform return expression\n+                        transformCompilationUnit_r(tree, store, scope,\n+                                                   createScopeObjects,\n+                                                   inStrictMode);\n+                    }\n+                    // skip transformCompilationUnit_r to avoid infinite loop\n+                    continue siblingLoop;\n+                }\n+                break;\n+              }\n+\n+              case Token.BREAK:\n+              case Token.CONTINUE:\n+              {\n+                Jump jump = (Jump)node;\n+                Jump jumpStatement = jump.getJumpStatement();\n+                if (jumpStatement == null) Kit.codeBug();\n+\n+                for (int i = loops.size(); ;) {\n+                    if (i == 0) {\n+                        // Parser/IRFactory ensure that break/continue\n+                        // always has a jump statement associated with it\n+                        // which should be found\n+                        throw Kit.codeBug();\n+                    }\n+                    --i;\n+                    Node n = (Node) loops.get(i);\n+                    if (n == jumpStatement) {\n+                        break;\n+                    }\n+\n+                    int elemtype = n.getType();\n+                    if (elemtype == Token.WITH) {\n+                        Node leave = new Node(Token.LEAVEWITH);\n+                        previous = addBeforeCurrent(parent, previous, node,\n+                                                    leave);\n+                    } else if (elemtype == Token.TRY) {\n+                        Jump tryNode = (Jump)n;\n+                        Jump jsrFinally = new Jump(Token.JSR);\n+                        jsrFinally.target = tryNode.getFinally();\n+                        previous = addBeforeCurrent(parent, previous, node,\n+                                                    jsrFinally);\n+                    }\n+                }\n+\n+                if (type == Token.BREAK) {\n+                    jump.target = jumpStatement.target;\n+                } else {\n+                    jump.target = jumpStatement.getContinue();\n+                }\n+                jump.setType(Token.GOTO);\n+\n+                break;\n+              }\n+\n+              case Token.CALL:\n+                visitCall(node, tree);\n+                break;\n+\n+              case Token.NEW:\n+                visitNew(node, tree);\n+                break;\n+\n+              case Token.LETEXPR:\n+              case Token.LET: {\n+                Node child = node.getFirstChild();\n+                if (child.getType() == Token.LET) {\n+                  // We have a let statement or expression rather than a\n+                  // let declaration\n+                  boolean createWith = tree.getType() != Token.FUNCTION\n+                      || ((FunctionNode)tree).requiresActivation();\n+                  node = visitLet(createWith, parent, previous, node);\n+                  break;\n+                } else {\n+                  // fall through to process let declaration...\n+                }\n+              }\n+              /* fall through */\n+              case Token.CONST:\n+              case Token.VAR:\n+              {\n+                Node result = new Node(Token.BLOCK);\n+                for (Node cursor = node.getFirstChild(); cursor != null;) {\n+                    // Move cursor to next before createAssignment gets chance\n+                    // to change n.next\n+                    Node n = cursor;\n+                    cursor = cursor.getNext();\n+                    if (n.getType() == Token.NAME) {\n+                        if (!n.hasChildren())\n+                            continue;\n+                        Node init = n.getFirstChild();\n+                        n.removeChild(init);\n+                        n.setType(Token.BINDNAME);\n+                        n = new Node(type == Token.CONST ?\n+                                         Token.SETCONST :\n+                                         Token.SETNAME,\n+                                     n, init);\n+                    } else {\n+                        // May be a destructuring assignment already transformed\n+                        // to a LETEXPR\n+                        if (n.getType() != Token.LETEXPR)\n+                            throw Kit.codeBug();\n+                    }\n+                    Node pop = new Node(Token.EXPR_VOID, n, node.getLineno());\n+                    result.addChildToBack(pop);\n+                }\n+                node = replaceCurrent(parent, previous, node, result);\n+                break;\n+              }\n+\n+              case Token.TYPEOFNAME: {\n+                Scope defining = scope.getDefiningScope(node.getString());\n+                if (defining != null) {\n+                    node.setScope(defining);\n+                }\n+              }\n+              break;\n+\n+              case Token.TYPEOF:\n+              case Token.IFNE: {\n+                  /* We want to suppress warnings for undefined property o.p\n+                   * for the following constructs: typeof o.p, if (o.p),\n+                   * if (!o.p), if (o.p == undefined), if (undefined == o.p)\n+                   */\n+            \t  Node child = node.getFirstChild();\n+            \t  if (type == Token.IFNE) {\n+                \t  while (child.getType() == Token.NOT) {\n+                \t      child = child.getFirstChild();\n+                \t  }\n+                \t  if (child.getType() == Token.EQ ||\n+                \t      child.getType() == Token.NE)\n+                \t  {\n+                \t      Node first = child.getFirstChild();\n+                \t      Node last = child.getLastChild();\n+                \t      if (first.getType() == Token.NAME &&\n+                \t          first.getString().equals(\"undefined\"))\n+                \t          child = last;\n+                \t      else if (last.getType() == Token.NAME &&\n+                \t               last.getString().equals(\"undefined\"))\n+                              child = first;\n+                \t  }\n+            \t  }\n+            \t  if (child.getType() == Token.GETPROP)\n+            \t\t  child.setType(Token.GETPROPNOWARN);\n+            \t  break;\n+              }\n+\n+              case Token.SETNAME:\n+                  if (inStrictMode) {\n+                      node.setType(Token.STRICT_SETNAME);\n+                  }\n+                  /* fall through */\n+              case Token.NAME:\n+              case Token.SETCONST:\n+              case Token.DELPROP:\n+              {\n+                // Turn name to var for faster access if possible\n+                if (createScopeObjects) {\n+                    break;\n+                }\n+                Node nameSource;\n+                if (type == Token.NAME) {\n+                    nameSource = node;\n+                } else {\n+                    nameSource = node.getFirstChild();\n+                    if (nameSource.getType() != Token.BINDNAME) {\n+                        if (type == Token.DELPROP) {\n+                            break;\n+                        }\n+                        throw Kit.codeBug();\n+                    }\n+                }\n+                if (nameSource.getScope() != null) {\n+                    break; // already have a scope set\n+                }\n+                String name = nameSource.getString();\n+                Scope defining = scope.getDefiningScope(name);\n+                if (defining != null) {\n+                    nameSource.setScope(defining);\n+                    if (type == Token.NAME) {\n+                        node.setType(Token.GETVAR);\n+                    } else if (type == Token.SETNAME ||\n+                               type == Token.STRICT_SETNAME) {\n+                        node.setType(Token.SETVAR);\n+                        nameSource.setType(Token.STRING);\n+                    } else if (type == Token.SETCONST) {\n+                        node.setType(Token.SETCONSTVAR);\n+                        nameSource.setType(Token.STRING);\n+                    } else if (type == Token.DELPROP) {\n+                        // Local variables are by definition permanent\n+                        Node n = new Node(Token.FALSE);\n+                        node = replaceCurrent(parent, previous, node, n);\n+                    } else {\n+                        throw Kit.codeBug();\n+                    }\n+                }\n+                break;\n+              }\n+            }\n+\n+            transformCompilationUnit_r(tree, node,\n+                node instanceof Scope ? (Scope)node : scope,\n+                createScopeObjects, inStrictMode);\n+        }\n+    }\n+\n+    protected void visitNew(Node node, ScriptNode tree) {\n+    }\n+\n+    protected void visitCall(Node node, ScriptNode tree) {\n+    }\n+\n+    protected Node visitLet(boolean createWith, Node parent, Node previous,\n+                            Node scopeNode)\n+    {\n+        Node vars = scopeNode.getFirstChild();\n+        Node body = vars.getNext();\n+        scopeNode.removeChild(vars);\n+        scopeNode.removeChild(body);\n+        boolean isExpression = scopeNode.getType() == Token.LETEXPR;\n+        Node result;\n+        Node newVars;\n+        if (createWith) {\n+            result = new Node(isExpression ? Token.WITHEXPR : Token.BLOCK);\n+            result = replaceCurrent(parent, previous, scopeNode, result);\n+            ArrayList<Object> list = new ArrayList<Object>();\n+            Node objectLiteral = new Node(Token.OBJECTLIT);\n+            for (Node v=vars.getFirstChild(); v != null; v = v.getNext()) {\n+                Node current = v;\n+                if (current.getType() == Token.LETEXPR) {\n+                    // destructuring in let expr, e.g. let ([x, y] = [3, 4]) {}\n+                    List<?> destructuringNames = (List<?>)\n+                        current.getProp(Node.DESTRUCTURING_NAMES);\n+                    Node c = current.getFirstChild();\n+                    if (c.getType() != Token.LET) throw Kit.codeBug();\n+                    // Add initialization code to front of body\n+                    if (isExpression) {\n+                        body = new Node(Token.COMMA, c.getNext(), body);\n+                    } else {\n+                        body = new Node(Token.BLOCK,\n+                            new Node(Token.EXPR_VOID, c.getNext()),\n+                            body);\n+                    }\n+                    // Update \"list\" and \"objectLiteral\" for the variables\n+                    // defined in the destructuring assignment\n+                    if (destructuringNames != null) {\n+                        list.addAll(destructuringNames);\n+                        for (int i=0; i < destructuringNames.size(); i++) {\n+                            objectLiteral.addChildToBack(\n+                                new Node(Token.VOID, Node.newNumber(0.0)));\n+                        }\n+                    }\n+                    current = c.getFirstChild(); // should be a NAME, checked below\n+                }\n+                if (current.getType() != Token.NAME) throw Kit.codeBug();\n+                list.add(ScriptRuntime.getIndexObject(current.getString()));\n+                Node init = current.getFirstChild();\n+                if (init == null) {\n+                    init = new Node(Token.VOID, Node.newNumber(0.0));\n+                }\n+                objectLiteral.addChildToBack(init);\n+             }\n+             objectLiteral.putProp(Node.OBJECT_IDS_PROP, list.toArray());\n+             newVars = new Node(Token.ENTERWITH, objectLiteral);\n+             result.addChildToBack(newVars);\n+             result.addChildToBack(new Node(Token.WITH, body));\n+             result.addChildToBack(new Node(Token.LEAVEWITH));\n+        } else {\n+            result = new Node(isExpression ? Token.COMMA : Token.BLOCK);\n+            result = replaceCurrent(parent, previous, scopeNode, result);\n+            newVars = new Node(Token.COMMA);\n+            for (Node v=vars.getFirstChild(); v != null; v = v.getNext()) {\n+                Node current = v;\n+                if (current.getType() == Token.LETEXPR) {\n+                    // destructuring in let expr, e.g. let ([x, y] = [3, 4]) {}\n+                    Node c = current.getFirstChild();\n+                    if (c.getType() != Token.LET) throw Kit.codeBug();\n+                    // Add initialization code to front of body\n+                    if (isExpression) {\n+                        body = new Node(Token.COMMA, c.getNext(), body);\n+                    } else {\n+                        body = new Node(Token.BLOCK,\n+                            new Node(Token.EXPR_VOID, c.getNext()),\n+                            body);\n+                    }\n+                    // We're removing the LETEXPR, so move the symbols\n+                    Scope.joinScopes((Scope)current,\n+                                          (Scope)scopeNode);\n+                    current = c.getFirstChild(); // should be a NAME, checked below\n+                }\n+                if (current.getType() != Token.NAME) throw Kit.codeBug();\n+                Node stringNode = Node.newString(current.getString());\n+                stringNode.setScope((Scope)scopeNode);\n+                Node init = current.getFirstChild();\n+                if (init == null) {\n+                    init = new Node(Token.VOID, Node.newNumber(0.0));\n+                }\n+                newVars.addChildToBack(new Node(Token.SETVAR, stringNode, init));\n+            }\n+            if (isExpression) {\n+                result.addChildToBack(newVars);\n+                scopeNode.setType(Token.COMMA);\n+                result.addChildToBack(scopeNode);\n+                scopeNode.addChildToBack(body);\n+                if (body instanceof Scope) {\n+                    Scope scopeParent = ((Scope) body).getParentScope();\n+                    ((Scope) body).setParentScope((Scope)scopeNode);\n+                    ((Scope) scopeNode).setParentScope(scopeParent);\n+                }\n+            } else {\n+                result.addChildToBack(new Node(Token.EXPR_VOID, newVars));\n+                scopeNode.setType(Token.BLOCK);\n+                result.addChildToBack(scopeNode);\n+                scopeNode.addChildrenToBack(body);\n+                if (body instanceof Scope) {\n+                    Scope scopeParent = ((Scope) body).getParentScope();\n+                    ((Scope) body).setParentScope((Scope)scopeNode);\n+                    ((Scope) scopeNode).setParentScope(scopeParent);\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private static Node addBeforeCurrent(Node parent, Node previous,\n+                                         Node current, Node toAdd)\n+    {\n+        if (previous == null) {\n+            if (!(current == parent.getFirstChild())) Kit.codeBug();\n+            parent.addChildToFront(toAdd);\n+        } else {\n+            if (!(current == previous.getNext())) Kit.codeBug();\n+            parent.addChildAfter(toAdd, previous);\n+        }\n+        return toAdd;\n+    }\n+\n+    private static Node replaceCurrent(Node parent, Node previous,\n+                                       Node current, Node replacement)\n+    {\n+        if (previous == null) {\n+            if (!(current == parent.getFirstChild())) Kit.codeBug();\n+            parent.replaceChild(current, replacement);\n+        } else if (previous.next == current) {\n+            // Check cachedPrev.next == current is necessary due to possible\n+            // tree mutations\n+            parent.replaceChildAfter(previous, replacement);\n+        } else {\n+            parent.replaceChild(current, replacement);\n+        }\n+        return replacement;\n+    }\n+\n+    private ObjArray loops;\n+    private ObjArray loopEnds;\n+    private boolean hasFinally;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ObjArray.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.Serializable;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+/**\n+Implementation of resizable array with focus on minimizing memory usage by storing few initial array elements in object fields. Can also be used as a stack.\n+*/\n+\n+public class ObjArray implements Serializable\n+{\n+    static final long serialVersionUID = 4174889037736658296L;\n+\n+    public ObjArray() { }\n+\n+    public final boolean isSealed()\n+    {\n+        return sealed;\n+    }\n+\n+    public final void seal()\n+    {\n+        sealed = true;\n+    }\n+\n+    public final boolean isEmpty()\n+    {\n+        return size == 0;\n+    }\n+\n+    public final int size()\n+    {\n+        return size;\n+    }\n+\n+    public final void setSize(int newSize)\n+    {\n+        if (newSize < 0) throw new IllegalArgumentException();\n+        if (sealed) throw onSeledMutation();\n+        int N = size;\n+        if (newSize < N) {\n+            for (int i = newSize; i != N; ++i) {\n+                setImpl(i, null);\n+            }\n+        } else if (newSize > N) {\n+            if (newSize > FIELDS_STORE_SIZE) {\n+                ensureCapacity(newSize);\n+            }\n+        }\n+        size = newSize;\n+    }\n+\n+    public final Object get(int index)\n+    {\n+        if (!(0 <= index && index < size)) throw onInvalidIndex(index, size);\n+        return getImpl(index);\n+    }\n+\n+    public final void set(int index, Object value)\n+    {\n+        if (!(0 <= index && index < size)) throw onInvalidIndex(index, size);\n+        if (sealed) throw onSeledMutation();\n+        setImpl(index, value);\n+    }\n+\n+    private Object getImpl(int index)\n+    {\n+        switch (index) {\n+            case 0: return f0;\n+            case 1: return f1;\n+            case 2: return f2;\n+            case 3: return f3;\n+            case 4: return f4;\n+        }\n+        return data[index - FIELDS_STORE_SIZE];\n+    }\n+\n+    private void setImpl(int index, Object value)\n+    {\n+        switch (index) {\n+            case 0: f0 = value; break;\n+            case 1: f1 = value; break;\n+            case 2: f2 = value; break;\n+            case 3: f3 = value; break;\n+            case 4: f4 = value; break;\n+            default: data[index - FIELDS_STORE_SIZE] = value;\n+        }\n+\n+    }\n+\n+    public int indexOf(Object obj)\n+    {\n+        int N = size;\n+        for (int i = 0; i != N; ++i) {\n+            Object current = getImpl(i);\n+            if (current == obj || (current != null && current.equals(obj))) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public int lastIndexOf(Object obj)\n+    {\n+        for (int i = size; i != 0;) {\n+            --i;\n+            Object current = getImpl(i);\n+            if (current == obj || (current != null && current.equals(obj))) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public final Object peek()\n+    {\n+        int N = size;\n+        if (N == 0) throw onEmptyStackTopRead();\n+        return getImpl(N - 1);\n+    }\n+\n+    public final Object pop()\n+    {\n+        if (sealed) throw onSeledMutation();\n+        int N = size;\n+        --N;\n+        Object top;\n+        switch (N) {\n+            case -1: throw onEmptyStackTopRead();\n+            case 0: top = f0; f0 = null; break;\n+            case 1: top = f1; f1 = null; break;\n+            case 2: top = f2; f2 = null; break;\n+            case 3: top = f3; f3 = null; break;\n+            case 4: top = f4; f4 = null; break;\n+            default:\n+                top = data[N - FIELDS_STORE_SIZE];\n+                data[N - FIELDS_STORE_SIZE] = null;\n+        }\n+        size = N;\n+        return top;\n+    }\n+\n+    public final void push(Object value)\n+    {\n+        add(value);\n+    }\n+\n+    public final void add(Object value)\n+    {\n+        if (sealed) throw onSeledMutation();\n+        int N = size;\n+        if (N >= FIELDS_STORE_SIZE) {\n+            ensureCapacity(N + 1);\n+        }\n+        size = N + 1;\n+        setImpl(N, value);\n+    }\n+\n+    public final void add(int index, Object value)\n+    {\n+        int N = size;\n+        if (!(0 <= index && index <= N)) throw onInvalidIndex(index, N + 1);\n+        if (sealed) throw onSeledMutation();\n+        Object tmp;\n+        switch (index) {\n+            case 0:\n+                if (N == 0) { f0 = value; break; }\n+                tmp = f0; f0 = value; value = tmp;\n+            case 1:\n+                if (N == 1) { f1 = value; break; }\n+                tmp = f1; f1 = value; value = tmp;\n+            case 2:\n+                if (N == 2) { f2 = value; break; }\n+                tmp = f2; f2 = value; value = tmp;\n+            case 3:\n+                if (N == 3) { f3 = value; break; }\n+                tmp = f3; f3 = value; value = tmp;\n+            case 4:\n+                if (N == 4) { f4 = value; break; }\n+                tmp = f4; f4 = value; value = tmp;\n+\n+                index = FIELDS_STORE_SIZE;\n+            default:\n+                ensureCapacity(N + 1);\n+                if (index != N) {\n+                    System.arraycopy(data, index - FIELDS_STORE_SIZE,\n+                                     data, index - FIELDS_STORE_SIZE + 1,\n+                                     N - index);\n+                }\n+                data[index - FIELDS_STORE_SIZE] = value;\n+        }\n+        size = N + 1;\n+    }\n+\n+    public final void remove(int index)\n+    {\n+        int N = size;\n+        if (!(0 <= index && index < N)) throw onInvalidIndex(index, N);\n+        if (sealed) throw onSeledMutation();\n+        --N;\n+        switch (index) {\n+            case 0:\n+                if (N == 0) { f0 = null; break; }\n+                f0 = f1;\n+            case 1:\n+                if (N == 1) { f1 = null; break; }\n+                f1 = f2;\n+            case 2:\n+                if (N == 2) { f2 = null; break; }\n+                f2 = f3;\n+            case 3:\n+                if (N == 3) { f3 = null; break; }\n+                f3 = f4;\n+            case 4:\n+                if (N == 4) { f4 = null; break; }\n+                f4 = data[0];\n+\n+                index = FIELDS_STORE_SIZE;\n+            default:\n+                if (index != N) {\n+                    System.arraycopy(data, index - FIELDS_STORE_SIZE + 1,\n+                                     data, index - FIELDS_STORE_SIZE,\n+                                     N - index);\n+                }\n+                data[N - FIELDS_STORE_SIZE] = null;\n+        }\n+        size = N;\n+    }\n+\n+    public final void clear()\n+    {\n+        if (sealed) throw onSeledMutation();\n+        int N = size;\n+        for (int i = 0; i != N; ++i) {\n+            setImpl(i, null);\n+        }\n+        size = 0;\n+    }\n+\n+    public final Object[] toArray()\n+    {\n+        Object[] array = new Object[size];\n+        toArray(array, 0);\n+        return array;\n+    }\n+\n+    public final void toArray(Object[] array)\n+    {\n+        toArray(array, 0);\n+    }\n+\n+    public final void toArray(Object[] array, int offset)\n+    {\n+        int N = size;\n+        switch (N) {\n+            default:\n+                System.arraycopy(data, 0, array, offset + FIELDS_STORE_SIZE,\n+                                 N - FIELDS_STORE_SIZE);\n+            case 5: array[offset + 4] = f4;\n+            case 4: array[offset + 3] = f3;\n+            case 3: array[offset + 2] = f2;\n+            case 2: array[offset + 1] = f1;\n+            case 1: array[offset + 0] = f0;\n+            case 0: break;\n+        }\n+    }\n+\n+    private void ensureCapacity(int minimalCapacity)\n+    {\n+        int required = minimalCapacity - FIELDS_STORE_SIZE;\n+        if (required <= 0) throw new IllegalArgumentException();\n+        if (data == null) {\n+            int alloc = FIELDS_STORE_SIZE * 2;\n+            if (alloc < required) {\n+                alloc = required;\n+            }\n+            data = new Object[alloc];\n+        } else {\n+            int alloc = data.length;\n+            if (alloc < required) {\n+                   if (alloc <= FIELDS_STORE_SIZE) {\n+                    alloc = FIELDS_STORE_SIZE * 2;\n+                } else {\n+                    alloc *= 2;\n+                }\n+                if (alloc < required) {\n+                    alloc = required;\n+                }\n+                Object[] tmp = new Object[alloc];\n+                if (size > FIELDS_STORE_SIZE) {\n+                    System.arraycopy(data, 0, tmp, 0,\n+                                     size - FIELDS_STORE_SIZE);\n+                }\n+                data = tmp;\n+            }\n+        }\n+    }\n+\n+    private static RuntimeException onInvalidIndex(int index, int upperBound)\n+    {\n+        // \\u2209 is \"NOT ELEMENT OF\"\n+        String msg = index+\" \\u2209 [0, \"+upperBound+')';\n+        throw new IndexOutOfBoundsException(msg);\n+    }\n+\n+    private static RuntimeException onEmptyStackTopRead()\n+    {\n+        throw new RuntimeException(\"Empty stack\");\n+    }\n+\n+    private static RuntimeException onSeledMutation()\n+    {\n+        throw new IllegalStateException(\"Attempt to modify sealed array\");\n+    }\n+\n+    private void writeObject(ObjectOutputStream os) throws IOException\n+    {\n+        os.defaultWriteObject();\n+        int N = size;\n+        for (int i = 0; i != N; ++i) {\n+            Object obj = getImpl(i);\n+            os.writeObject(obj);\n+        }\n+    }\n+\n+    private void readObject(ObjectInputStream is)\n+        throws IOException, ClassNotFoundException\n+    {\n+        is.defaultReadObject(); // It reads size\n+        int N = size;\n+        if (N > FIELDS_STORE_SIZE) {\n+            data = new Object[N - FIELDS_STORE_SIZE];\n+        }\n+        for (int i = 0; i != N; ++i) {\n+            Object obj = is.readObject();\n+            setImpl(i, obj);\n+        }\n+    }\n+\n+// Number of data elements\n+    private int size;\n+\n+    private boolean sealed;\n+\n+    private static final int FIELDS_STORE_SIZE = 5;\n+    private transient Object f0, f1, f2, f3, f4;\n+    private transient Object[] data;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ObjToIntMap.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.Serializable;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+/**\n+ * Map to associate objects to integers.\n+ * The map does not synchronize any of its operation, so either use\n+ * it from a single thread or do own synchronization or perform all mutation\n+ * operations on one thread before passing the map to others\n+ *\n+ *\n+ */\n+\n+public class ObjToIntMap implements Serializable\n+{\n+    static final long serialVersionUID = -1542220580748809402L;\n+\n+// Map implementation via hashtable,\n+// follows \"The Art of Computer Programming\" by Donald E. Knuth\n+\n+// ObjToIntMap is a copy cat of ObjToIntMap with API adjusted to object keys\n+\n+    public static class Iterator {\n+\n+        Iterator(ObjToIntMap master) {\n+            this.master = master;\n+        }\n+\n+        final void init(Object[] keys, int[] values, int keyCount) {\n+            this.keys = keys;\n+            this.values = values;\n+            this.cursor = -1;\n+            this.remaining = keyCount;\n+        }\n+\n+        public void start() {\n+            master.initIterator(this);\n+            next();\n+        }\n+\n+        public boolean done() {\n+            return remaining < 0;\n+        }\n+\n+        public void next() {\n+            if (remaining == -1) Kit.codeBug();\n+            if (remaining == 0) {\n+                remaining = -1;\n+                cursor = -1;\n+            }else {\n+                for (++cursor; ; ++cursor) {\n+                    Object key = keys[cursor];\n+                    if (key != null && key != DELETED) {\n+                        --remaining;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        public Object getKey() {\n+            Object key = keys[cursor];\n+            if (key == UniqueTag.NULL_VALUE) { key = null; }\n+            return key;\n+        }\n+\n+        public int getValue() {\n+            return values[cursor];\n+        }\n+\n+        public void setValue(int value) {\n+            values[cursor] = value;\n+        }\n+\n+        ObjToIntMap master;\n+        private int cursor;\n+        private int remaining;\n+        private Object[] keys;\n+        private int[] values;\n+    }\n+\n+    public ObjToIntMap() {\n+        this(4);\n+    }\n+\n+    public ObjToIntMap(int keyCountHint) {\n+        if (keyCountHint < 0) Kit.codeBug();\n+        // Table grow when number of stored keys >= 3/4 of max capacity\n+        int minimalCapacity = keyCountHint * 4 / 3;\n+        int i;\n+        for (i = 2; (1 << i) < minimalCapacity; ++i) { }\n+        power = i;\n+        if (check && power < 2) Kit.codeBug();\n+    }\n+\n+    public boolean isEmpty() {\n+        return keyCount == 0;\n+    }\n+\n+    public int size() {\n+        return keyCount;\n+    }\n+\n+    public boolean has(Object key) {\n+        if (key == null) { key = UniqueTag.NULL_VALUE; }\n+        return 0 <= findIndex(key);\n+    }\n+\n+    /**\n+     * Get integer value assigned with key.\n+     * @return key integer value or defaultValue if key is absent\n+     */\n+    public int get(Object key, int defaultValue) {\n+        if (key == null) { key = UniqueTag.NULL_VALUE; }\n+        int index = findIndex(key);\n+        if (0 <= index) {\n+            return values[index];\n+        }\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * Get integer value assigned with key.\n+     * @return key integer value\n+     * @throws RuntimeException if key does not exist\n+     */\n+    public int getExisting(Object key) {\n+        if (key == null) { key = UniqueTag.NULL_VALUE; }\n+        int index = findIndex(key);\n+        if (0 <= index) {\n+            return values[index];\n+        }\n+        // Key must exist\n+        Kit.codeBug();\n+        return 0;\n+    }\n+\n+    public void put(Object key, int value) {\n+        if (key == null) { key = UniqueTag.NULL_VALUE; }\n+        int index = ensureIndex(key);\n+        values[index] = value;\n+    }\n+\n+    /**\n+     * If table already contains a key that equals to keyArg, return that key\n+     * while setting its value to zero, otherwise add keyArg with 0 value to\n+     * the table and return it.\n+     */\n+    public Object intern(Object keyArg) {\n+        boolean nullKey = false;\n+        if (keyArg == null) {\n+            nullKey = true;\n+            keyArg = UniqueTag.NULL_VALUE;\n+        }\n+        int index = ensureIndex(keyArg);\n+        values[index] = 0;\n+        return (nullKey) ? null : keys[index];\n+    }\n+\n+    public void remove(Object key) {\n+        if (key == null) { key = UniqueTag.NULL_VALUE; }\n+        int index = findIndex(key);\n+        if (0 <= index) {\n+            keys[index] = DELETED;\n+            --keyCount;\n+        }\n+    }\n+\n+    public void clear() {\n+        int i = keys.length;\n+        while (i != 0) {\n+            keys[--i] = null;\n+        }\n+        keyCount = 0;\n+        occupiedCount = 0;\n+    }\n+\n+    public Iterator newIterator() {\n+        return new Iterator(this);\n+    }\n+\n+    // The sole purpose of the method is to avoid accessing private fields\n+    // from the Iterator inner class to workaround JDK 1.1 compiler bug which\n+    // generates code triggering VerifierError on recent JVMs\n+    final void initIterator(Iterator i) {\n+        i.init(keys, values, keyCount);\n+    }\n+\n+    /** Return array of present keys */\n+    public Object[] getKeys() {\n+        Object[] array = new Object[keyCount];\n+        getKeys(array, 0);\n+        return array;\n+    }\n+\n+    public void getKeys(Object[] array, int offset) {\n+        int count = keyCount;\n+        for (int i = 0; count != 0; ++i) {\n+            Object key = keys[i];\n+            if (key != null && key != DELETED) {\n+                if (key == UniqueTag.NULL_VALUE) { key = null; }\n+                array[offset] = key;\n+                ++offset;\n+                --count;\n+            }\n+        }\n+    }\n+\n+    private static int tableLookupStep(int fraction, int mask, int power) {\n+        int shift = 32 - 2 * power;\n+        if (shift >= 0) {\n+            return ((fraction >>> shift) & mask) | 1;\n+        }\n+        else {\n+            return (fraction & (mask >>> -shift)) | 1;\n+        }\n+    }\n+\n+    private int findIndex(Object key) {\n+        if (keys != null) {\n+            int hash = key.hashCode();\n+            int fraction = hash * A;\n+            int index = fraction >>> (32 - power);\n+            Object test = keys[index];\n+            if (test != null) {\n+                int N = 1 << power;\n+                if (test == key\n+                    || (values[N + index] == hash && test.equals(key)))\n+                {\n+                    return index;\n+                }\n+                // Search in table after first failed attempt\n+                int mask = N - 1;\n+                int step = tableLookupStep(fraction, mask, power);\n+                int n = 0;\n+                for (;;) {\n+                    if (check) {\n+                        if (n >= occupiedCount) Kit.codeBug();\n+                        ++n;\n+                    }\n+                    index = (index + step) & mask;\n+                    test = keys[index];\n+                    if (test == null) {\n+                        break;\n+                    }\n+                    if (test == key\n+                        || (values[N + index] == hash && test.equals(key)))\n+                    {\n+                        return index;\n+                    }\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+// Insert key that is not present to table without deleted entries\n+// and enough free space\n+    private int insertNewKey(Object key, int hash) {\n+        if (check && occupiedCount != keyCount) Kit.codeBug();\n+        if (check && keyCount == 1 << power) Kit.codeBug();\n+        int fraction = hash * A;\n+        int index = fraction >>> (32 - power);\n+        int N = 1 << power;\n+        if (keys[index] != null) {\n+            int mask = N - 1;\n+            int step = tableLookupStep(fraction, mask, power);\n+            int firstIndex = index;\n+            do {\n+                if (check && keys[index] == DELETED) Kit.codeBug();\n+                index = (index + step) & mask;\n+                if (check && firstIndex == index) Kit.codeBug();\n+            } while (keys[index] != null);\n+        }\n+        keys[index] = key;\n+        values[N + index] = hash;\n+        ++occupiedCount;\n+        ++keyCount;\n+\n+        return index;\n+    }\n+\n+    private void rehashTable() {\n+        if (keys == null) {\n+            if (check && keyCount != 0) Kit.codeBug();\n+            if (check && occupiedCount != 0) Kit.codeBug();\n+            int N = 1 << power;\n+            keys = new Object[N];\n+            values = new int[2 * N];\n+        }\n+        else {\n+            // Check if removing deleted entries would free enough space\n+            if (keyCount * 2 >= occupiedCount) {\n+                // Need to grow: less then half of deleted entries\n+                ++power;\n+            }\n+            int N = 1 << power;\n+            Object[] oldKeys = keys;\n+            int[] oldValues = values;\n+            int oldN = oldKeys.length;\n+            keys = new Object[N];\n+            values = new int[2 * N];\n+\n+            int remaining = keyCount;\n+            occupiedCount = keyCount = 0;\n+            for (int i = 0; remaining != 0; ++i) {\n+                Object key = oldKeys[i];\n+                if (key != null && key != DELETED) {\n+                    int keyHash = oldValues[oldN + i];\n+                    int index = insertNewKey(key, keyHash);\n+                    values[index] = oldValues[i];\n+                    --remaining;\n+                }\n+            }\n+        }\n+    }\n+\n+// Ensure key index creating one if necessary\n+    private int ensureIndex(Object key) {\n+        int hash = key.hashCode();\n+        int index = -1;\n+        int firstDeleted = -1;\n+        if (keys != null) {\n+            int fraction = hash * A;\n+            index = fraction >>> (32 - power);\n+            Object test = keys[index];\n+            if (test != null) {\n+                int N = 1 << power;\n+                if (test == key\n+                    || (values[N + index] == hash && test.equals(key)))\n+                {\n+                    return index;\n+                }\n+                if (test == DELETED) {\n+                    firstDeleted = index;\n+                }\n+\n+                // Search in table after first failed attempt\n+                int mask = N - 1;\n+                int step = tableLookupStep(fraction, mask, power);\n+                int n = 0;\n+                for (;;) {\n+                    if (check) {\n+                        if (n >= occupiedCount) Kit.codeBug();\n+                        ++n;\n+                    }\n+                    index = (index + step) & mask;\n+                    test = keys[index];\n+                    if (test == null) {\n+                        break;\n+                    }\n+                    if (test == key\n+                        || (values[N + index] == hash && test.equals(key)))\n+                    {\n+                        return index;\n+                    }\n+                    if (test == DELETED && firstDeleted < 0) {\n+                        firstDeleted = index;\n+                    }\n+                }\n+            }\n+        }\n+        // Inserting of new key\n+        if (check && keys != null && keys[index] != null)\n+            Kit.codeBug();\n+        if (firstDeleted >= 0) {\n+            index = firstDeleted;\n+        }\n+        else {\n+            // Need to consume empty entry: check occupation level\n+            if (keys == null || occupiedCount * 4 >= (1 << power) * 3) {\n+                // Too litle unused entries: rehash\n+                rehashTable();\n+                return insertNewKey(key, hash);\n+            }\n+            ++occupiedCount;\n+        }\n+        keys[index] = key;\n+        values[(1 << power) + index] = hash;\n+        ++keyCount;\n+        return index;\n+    }\n+\n+    private void writeObject(ObjectOutputStream out)\n+        throws IOException\n+    {\n+        out.defaultWriteObject();\n+\n+        int count = keyCount;\n+        for (int i = 0; count != 0; ++i) {\n+            Object key = keys[i];\n+            if (key != null && key != DELETED) {\n+                --count;\n+                out.writeObject(key);\n+                out.writeInt(values[i]);\n+            }\n+        }\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException\n+    {\n+        in.defaultReadObject();\n+\n+        int writtenKeyCount = keyCount;\n+        if (writtenKeyCount != 0) {\n+            keyCount = 0;\n+            int N = 1 << power;\n+            keys = new Object[N];\n+            values = new int[2 * N];\n+            for (int i = 0; i != writtenKeyCount; ++i) {\n+                Object key = in.readObject();\n+                int hash = key.hashCode();\n+                int index = insertNewKey(key, hash);\n+                values[index] = in.readInt();\n+            }\n+        }\n+    }\n+\n+// A == golden_ratio * (1 << 32) = ((sqrt(5) - 1) / 2) * (1 << 32)\n+// See Knuth etc.\n+    private static final int A = 0x9e3779b9;\n+\n+    private static final Object DELETED = new Object();\n+\n+// Structure of kyes and values arrays (N == 1 << power):\n+// keys[0 <= i < N]: key value or null or DELETED mark\n+// values[0 <= i < N]: value of key at keys[i]\n+// values[N <= i < 2*N]: hash code of key at keys[i-N]\n+\n+    private transient Object[] keys;\n+    private transient int[] values;\n+\n+    private int power;\n+    private int keyCount;\n+    private transient int occupiedCount; // == keyCount + deleted_count\n+\n+// If true, enables consitency checks\n+    private static final boolean check = false;\n+\n+/* TEST START\n+\n+    public static void main(String[] args) {\n+        if (!check) {\n+            System.err.println(\"Set check to true and re-run\");\n+            throw new RuntimeException(\"Set check to true and re-run\");\n+        }\n+\n+        ObjToIntMap map;\n+        map = new ObjToIntMap(0);\n+        testHash(map, 3);\n+        map = new ObjToIntMap(0);\n+        testHash(map, 10 * 1000);\n+        map = new ObjToIntMap();\n+        testHash(map, 10 * 1000);\n+        map = new ObjToIntMap(30 * 1000);\n+        testHash(map, 10 * 100);\n+        map.clear();\n+        testHash(map, 4);\n+        map = new ObjToIntMap(0);\n+        testHash(map, 10 * 100);\n+    }\n+\n+    private static void testHash(ObjToIntMap map, int N) {\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(i);\n+            check(-1 == map.get(key, -1));\n+            map.put(key, i);\n+            check(i == map.get(key, -1));\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(i);\n+            map.put(key, i);\n+            check(i == map.get(key, -1));\n+        }\n+\n+        check(map.size() == N);\n+\n+        System.out.print(\".\"); System.out.flush();\n+        Object[] keys = map.getKeys();\n+        check(keys.length == N);\n+        for (int i = 0; i != N; ++i) {\n+            Object key = keys[i];\n+            check(map.has(key));\n+        }\n+\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(i);\n+            check(i == map.get(key, -1));\n+        }\n+\n+        int Nsqrt = -1;\n+        for (int i = 0; ; ++i) {\n+            if (i * i >= N) {\n+                Nsqrt = i;\n+                break;\n+            }\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(i * i);\n+            map.put(key, i);\n+            check(i == map.get(key, -1));\n+        }\n+\n+        check(map.size() == 2 * N - Nsqrt);\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(i * i);\n+            check(i == map.get(key, -1));\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(-1 - i * i);\n+            map.put(key, i);\n+            check(i == map.get(key, -1));\n+        }\n+\n+        check(map.size() == 3 * N - Nsqrt);\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(-1 - i * i);\n+            map.remove(key);\n+            check(!map.has(key));\n+        }\n+\n+        check(map.size() == 2 * N - Nsqrt);\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(i * i);\n+            check(i == map.get(key, -1));\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(i);\n+            int j = intSqrt(i);\n+            if (j * j == i) {\n+                check(j == map.get(key, -1));\n+            }else {\n+                check(i == map.get(key, -1));\n+            }\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(i * i);\n+            map.remove(key);\n+            check(-2 == map.get(key, -2));\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(i);\n+            map.put(key, i);\n+            check(i == map.get(key, -2));\n+        }\n+\n+        check(map.size() == N);\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(i);\n+            check(i == map.get(key, -1));\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        ObjToIntMap copy = (ObjToIntMap)writeAndRead(map);\n+        check(copy.size() == N);\n+\n+        for (int i = 0; i != N; ++i) {\n+            Object key = testKey(i);\n+            check(i == copy.get(key, -1));\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        checkSameMaps(copy, map);\n+\n+        System.out.println(); System.out.flush();\n+    }\n+\n+    private static void checkSameMaps(ObjToIntMap map1, ObjToIntMap map2) {\n+        check(map1.size() == map2.size());\n+        Object[] keys = map1.getKeys();\n+        check(keys.length == map1.size());\n+        for (int i = 0; i != keys.length; ++i) {\n+            check(map1.get(keys[i], -1) == map2.get(keys[i], -1));\n+        }\n+    }\n+\n+    private static void check(boolean condition) {\n+        if (!condition) Kit.codeBug();\n+    }\n+\n+    private static Object[] testPool;\n+\n+    private static Object testKey(int i) {\n+        int MAX_POOL = 100;\n+        if (0 <= i && i < MAX_POOL) {\n+            if (testPool != null && testPool[i] != null) {\n+                return testPool[i];\n+            }\n+        }\n+        Object x = new Double(i + 0.5);\n+        if (0 <= i && i < MAX_POOL) {\n+            if (testPool == null) {\n+                testPool = new Object[MAX_POOL];\n+            }\n+            testPool[i] = x;\n+        }\n+        return x;\n+    }\n+\n+    private static int intSqrt(int i) {\n+        int approx = (int)Math.sqrt(i) + 1;\n+        while (approx * approx > i) {\n+            --approx;\n+        }\n+        return approx;\n+    }\n+\n+    private static Object writeAndRead(Object obj) {\n+        try {\n+            java.io.ByteArrayOutputStream\n+                bos = new java.io.ByteArrayOutputStream();\n+            java.io.ObjectOutputStream\n+                out = new java.io.ObjectOutputStream(bos);\n+            out.writeObject(obj);\n+            out.close();\n+            byte[] data = bos.toByteArray();\n+            java.io.ByteArrayInputStream\n+                bis = new java.io.ByteArrayInputStream(data);\n+            java.io.ObjectInputStream\n+                in = new java.io.ObjectInputStream(bis);\n+            Object result = in.readObject();\n+            in.close();\n+            return result;\n+        }catch (Exception ex) {\n+            throw new RuntimeException(\"Unexpected\");\n+        }\n+    }\n+\n+// TEST END */\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Parser.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Mike Ang\n+ *   Igor Bukanov\n+ *   Yuh-Ruey Chen\n+ *   Ethan Hugg\n+ *   Bob Jervis\n+ *   Terry Lucas\n+ *   Mike McCabe\n+ *   Milen Nankov\n+ *   Norris Boyd\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.javascript.ast.*;  // we use basically every class\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.HashSet;\n+\n+/**\n+ * This class implements the JavaScript parser.<p>\n+ *\n+ * It is based on the SpiderMonkey C source files jsparse.c and jsparse.h in the\n+ * jsref package.<p>\n+ *\n+ * The parser generates an {@link AstRoot} parse tree representing the source\n+ * code.  No tree rewriting is permitted at this stage, so that the parse tree\n+ * is a faithful representation of the source for frontend processing tools and\n+ * IDEs.<p>\n+ *\n+ * This parser implementation is not intended to be reused after a parse\n+ * finishes, and will throw an IllegalStateException() if invoked again.<p>\n+ *\n+ * @see TokenStream\n+ *\n+ */\n+public class Parser\n+{\n+    /**\n+     * Maximum number of allowed function or constructor arguments,\n+     * to follow SpiderMonkey.\n+     */\n+    public static final int ARGC_LIMIT = 1 << 16;\n+\n+    // TokenInformation flags : currentFlaggedToken stores them together\n+    // with token type\n+    final static int\n+        CLEAR_TI_MASK    = 0xFFFF,  // mask to clear token information bits\n+        TI_AFTER_EOL     = 1 << 16, // first token of the source line\n+        TI_CHECK_LABEL   = 1 << 17; // indicates to check for label\n+\n+    CompilerEnvirons compilerEnv;\n+    private ErrorReporter errorReporter;\n+    private IdeErrorReporter errorCollector;\n+    private String sourceURI;\n+    private char[] sourceChars;\n+\n+    boolean calledByCompileFunction;  // ugly - set directly by Context\n+    private boolean parseFinished;  // set when finished to prevent reuse\n+\n+    private TokenStream ts;\n+    private int currentFlaggedToken = Token.EOF;\n+    private int currentToken;\n+    private int syntaxErrorCount;\n+\n+    private List<Comment> scannedComments;\n+    private Comment currentJsDocComment;\n+\n+    protected int nestingOfFunction;\n+    private LabeledStatement currentLabel;\n+    private boolean inDestructuringAssignment;\n+    protected boolean inUseStrictDirective;\n+\n+    // The following are per function variables and should be saved/restored\n+    // during function parsing.  See PerFunctionVariables class below.\n+    ScriptNode currentScriptOrFn;\n+    Scope currentScope;\n+    int nestingOfWith;\n+    private int endFlags;\n+    private boolean inForInit;  // bound temporarily during forStatement()\n+    private Map<String,LabeledStatement> labelSet;\n+    private List<Loop> loopSet;\n+    private List<Jump> loopAndSwitchSet;\n+    // end of per function variables\n+\n+    // Lacking 2-token lookahead, labels become a problem.\n+    // These vars store the token info of the last matched name,\n+    // iff it wasn't the last matched token.\n+    private int prevNameTokenStart;\n+    private String prevNameTokenString = \"\";\n+    private int prevNameTokenLineno;\n+\n+    // Exception to unwind\n+    private static class ParserException extends RuntimeException\n+    {\n+        static final long serialVersionUID = 5882582646773765630L;\n+    }\n+\n+    public Parser() {\n+        this(new CompilerEnvirons());\n+    }\n+\n+    public Parser(CompilerEnvirons compilerEnv) {\n+        this(compilerEnv, compilerEnv.getErrorReporter());\n+    }\n+\n+    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter) {\n+        this.compilerEnv = compilerEnv;\n+        this.errorReporter = errorReporter;\n+        if (errorReporter instanceof IdeErrorReporter) {\n+            errorCollector = (IdeErrorReporter)errorReporter;\n+        }\n+    }\n+\n+    // Add a strict warning on the last matched token.\n+    void addStrictWarning(String messageId, String messageArg) {\n+        int beg = -1, end = -1;\n+        if (ts != null) {\n+            beg = ts.tokenBeg;\n+            end = ts.tokenEnd - ts.tokenBeg;\n+        }\n+        addStrictWarning(messageId, messageArg, beg, end);\n+    }\n+\n+    void addStrictWarning(String messageId, String messageArg,\n+                          int position, int length) {\n+        if (compilerEnv.isStrictMode())\n+            addWarning(messageId, messageArg, position, length);\n+    }\n+\n+    void addWarning(String messageId, String messageArg) {\n+        int beg = -1, end = -1;\n+        if (ts != null) {\n+            beg = ts.tokenBeg;\n+            end = ts.tokenEnd - ts.tokenBeg;\n+        }\n+        addWarning(messageId, messageArg, beg, end);\n+    }\n+\n+    void addWarning(String messageId, int position, int length) {\n+        addWarning(messageId, null, position, length);\n+    }\n+\n+    void addWarning(String messageId, String messageArg,\n+                    int position, int length)\n+    {\n+        String message = lookupMessage(messageId, messageArg);\n+        if (compilerEnv.reportWarningAsError()) {\n+            addError(messageId, messageArg, position, length);\n+        } else if (errorCollector != null) {\n+            errorCollector.warning(message, sourceURI, position, length);\n+        } else {\n+            errorReporter.warning(message, sourceURI, ts.getLineno(),\n+                                  ts.getLine(), ts.getOffset());\n+        }\n+    }\n+\n+    void addError(String messageId) {\n+        addError(messageId, ts.tokenBeg, ts.tokenEnd - ts.tokenBeg);\n+    }\n+\n+    void addError(String messageId, int position, int length) {\n+        addError(messageId, null, position, length);\n+    }\n+\n+    void addError(String messageId, String messageArg) {\n+        addError(messageId, messageArg, ts.tokenBeg,\n+                 ts.tokenEnd - ts.tokenBeg);\n+    }\n+\n+    void addError(String messageId, String messageArg, int position, int length)\n+    {\n+        ++syntaxErrorCount;\n+        String message = lookupMessage(messageId, messageArg);\n+        if (errorCollector != null) {\n+            errorCollector.error(message, sourceURI, position, length);\n+        } else {\n+            int lineno = 1, offset = 1;\n+            String line = \"\";\n+            if (ts != null) {  // happens in some regression tests\n+                lineno = ts.getLineno();\n+                line = ts.getLine();\n+                offset = ts.getOffset();\n+            }\n+            errorReporter.error(message, sourceURI, lineno, line, offset);\n+        }\n+    }\n+\n+    String lookupMessage(String messageId) {\n+        return lookupMessage(messageId, null);\n+    }\n+\n+    String lookupMessage(String messageId, String messageArg) {\n+        return messageArg == null\n+            ? ScriptRuntime.getMessage0(messageId)\n+            : ScriptRuntime.getMessage1(messageId, messageArg);\n+    }\n+\n+    void reportError(String messageId) {\n+        reportError(messageId, null);\n+    }\n+\n+    void reportError(String messageId, String messageArg) {\n+        if (ts == null) {  // happens in some regression tests\n+            reportError(messageId, messageArg, 1, 1);\n+        } else {\n+            reportError(messageId, messageArg, ts.tokenBeg,\n+                        ts.tokenEnd - ts.tokenBeg);\n+        }\n+    }\n+\n+    void reportError(String messageId, int position, int length)\n+    {\n+        reportError(messageId, null, position, length);\n+    }\n+\n+    void reportError(String messageId, String messageArg, int position,\n+                     int length)\n+    {\n+        addError(messageId, position, length);\n+\n+        if (!compilerEnv.recoverFromErrors()) {\n+            throw new ParserException();\n+        }\n+    }\n+\n+    // Computes the absolute end offset of node N.\n+    // Use with caution!  Assumes n.getPosition() is -absolute-, which\n+    // is only true before the node is added to its parent.\n+    private int getNodeEnd(AstNode n) {\n+        return n.getPosition() + n.getLength();\n+    }\n+\n+    private void recordComment(int lineno, String comment) {\n+        if (scannedComments == null) {\n+            scannedComments = new ArrayList<Comment>();\n+        }\n+        Comment commentNode = new Comment(ts.tokenBeg,\n+                                          ts.getTokenLength(),\n+                                          ts.commentType,\n+                                          comment);\n+        if (ts.commentType == Token.CommentType.JSDOC &&\n+            compilerEnv.isRecordingLocalJsDocComments()) {\n+            currentJsDocComment = commentNode;\n+        }\n+        commentNode.setLineno(lineno);\n+        scannedComments.add(commentNode);\n+    }\n+\n+    private Comment getAndResetJsDoc() {\n+        Comment saved = currentJsDocComment;\n+        currentJsDocComment = null;\n+        return saved;\n+    }\n+\n+    private int getNumberOfEols(String comment) {\n+      int lines = 0;\n+      for (int i = comment.length()-1; i >= 0; i--) {\n+        if (comment.charAt(i) == '\\n') {\n+          lines++;\n+        }\n+      }\n+      return lines;\n+    }\n+\n+    // Returns the next token without consuming it.\n+    // If previous token was consumed, calls scanner to get new token.\n+    // If previous token was -not- consumed, returns it (idempotent).\n+    //\n+    // This function will not return a newline (Token.EOL - instead, it\n+    // gobbles newlines until it finds a non-newline token, and flags\n+    // that token as appearing just after a newline.\n+    //\n+    // This function will also not return a Token.COMMENT.  Instead, it\n+    // records comments in the scannedComments list.  If the token\n+    // returned by this function immediately follows a jsdoc comment,\n+    // the token is flagged as such.\n+    //\n+    // Note that this function always returned the un-flagged token!\n+    // The flags, if any, are saved in currentFlaggedToken.\n+    private int peekToken()\n+        throws IOException\n+    {\n+        // By far the most common case:  last token hasn't been consumed,\n+        // so return already-peeked token.\n+        if (currentFlaggedToken != Token.EOF) {\n+            return currentToken;\n+        }\n+\n+        int lineno = ts.getLineno();\n+        int tt = ts.getToken();\n+        boolean sawEOL = false;\n+\n+        // process comments and whitespace\n+        while (tt == Token.EOL || tt == Token.COMMENT) {\n+            if (tt == Token.EOL) {\n+                lineno++;\n+                sawEOL = true;\n+            } else {\n+                String comment = ts.getAndResetCurrentComment();\n+                if (compilerEnv.isRecordingComments()) {\n+                    recordComment(lineno, comment);\n+                }\n+                // Comments may contain multiple lines, get the number of EoLs\n+                // and increase the lineno\n+                lineno += getNumberOfEols(comment);\n+            }\n+            tt = ts.getToken();\n+        }\n+\n+        currentToken = tt;\n+        currentFlaggedToken = tt | (sawEOL ? TI_AFTER_EOL : 0);\n+        return currentToken;  // return unflagged token\n+    }\n+\n+    private int peekFlaggedToken()\n+        throws IOException\n+    {\n+        peekToken();\n+        return currentFlaggedToken;\n+    }\n+\n+    private void consumeToken() {\n+        currentFlaggedToken = Token.EOF;\n+    }\n+\n+    private int nextToken()\n+        throws IOException\n+    {\n+        int tt = peekToken();\n+        consumeToken();\n+        return tt;\n+    }\n+\n+    private int nextFlaggedToken()\n+        throws IOException\n+    {\n+        peekToken();\n+        int ttFlagged = currentFlaggedToken;\n+        consumeToken();\n+        return ttFlagged;\n+    }\n+\n+    private boolean matchToken(int toMatch)\n+        throws IOException\n+    {\n+        if (peekToken() != toMatch) {\n+            return false;\n+        }\n+        consumeToken();\n+        return true;\n+    }\n+\n+    // Returns Token.EOL if the current token follows a newline, else returns\n+    // the current token.  Used in situations where we don't consider certain\n+    // token types valid if they are preceded by a newline.  One example is the\n+    // postfix ++ or -- operator, which has to be on the same line as its\n+    // operand.\n+    private int peekTokenOrEOL()\n+        throws IOException\n+    {\n+        int tt = peekToken();\n+        // Check for last peeked token flags\n+        if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {\n+            tt = Token.EOL;\n+        }\n+        return tt;\n+    }\n+\n+    private boolean mustMatchToken(int toMatch, String messageId)\n+        throws IOException\n+    {\n+        return mustMatchToken(toMatch, messageId, ts.tokenBeg,\n+                              ts.tokenEnd - ts.tokenBeg);\n+    }\n+\n+    private boolean mustMatchToken(int toMatch, String msgId, int pos, int len)\n+        throws IOException\n+    {\n+        if (matchToken(toMatch)) {\n+            return true;\n+        }\n+        reportError(msgId, pos, len);\n+        return false;\n+    }\n+\n+    private void mustHaveXML() {\n+        if (!compilerEnv.isXmlAvailable()) {\n+            reportError(\"msg.XML.not.available\");\n+        }\n+    }\n+\n+    public boolean eof() {\n+        return ts.eof();\n+    }\n+\n+    boolean insideFunction() {\n+        return nestingOfFunction != 0;\n+    }\n+\n+    void pushScope(Scope scope) {\n+        Scope parent = scope.getParentScope();\n+        // During codegen, parent scope chain may already be initialized,\n+        // in which case we just need to set currentScope variable.\n+        if (parent != null) {\n+            if (parent != currentScope)\n+                codeBug();\n+        } else {\n+            currentScope.addChildScope(scope);\n+        }\n+        currentScope = scope;\n+    }\n+\n+    void popScope() {\n+        currentScope = currentScope.getParentScope();\n+    }\n+\n+    private void enterLoop(Loop loop) {\n+        if (loopSet == null)\n+            loopSet = new ArrayList<Loop>();\n+        loopSet.add(loop);\n+        if (loopAndSwitchSet == null)\n+            loopAndSwitchSet = new ArrayList<Jump>();\n+        loopAndSwitchSet.add(loop);\n+        pushScope(loop);\n+        if (currentLabel != null) {\n+            currentLabel.setStatement(loop);\n+            currentLabel.getFirstLabel().setLoop(loop);\n+            // This is the only time during parsing that we set a node's parent\n+            // before parsing the children.  In order for the child node offsets\n+            // to be correct, we adjust the loop's reported position back to an\n+            // absolute source offset, and restore it when we call exitLoop().\n+            loop.setRelative(-currentLabel.getPosition());\n+        }\n+    }\n+\n+    private void exitLoop() {\n+        Loop loop = loopSet.remove(loopSet.size() - 1);\n+        loopAndSwitchSet.remove(loopAndSwitchSet.size() - 1);\n+        if (loop.getParent() != null) {  // see comment in enterLoop\n+            loop.setRelative(loop.getParent().getPosition());\n+        }\n+        popScope();\n+    }\n+\n+    private void enterSwitch(SwitchStatement node) {\n+        if (loopAndSwitchSet == null)\n+            loopAndSwitchSet = new ArrayList<Jump>();\n+        loopAndSwitchSet.add(node);\n+    }\n+\n+    private void exitSwitch() {\n+        loopAndSwitchSet.remove(loopAndSwitchSet.size() - 1);\n+    }\n+\n+    /**\n+     * Builds a parse tree from the given source string.\n+     *\n+     * @return an {@link AstRoot} object representing the parsed program.  If\n+     * the parse fails, {@code null} will be returned.  (The parse failure will\n+     * result in a call to the {@link ErrorReporter} from\n+     * {@link CompilerEnvirons}.)\n+     */\n+    public AstRoot parse(String sourceString, String sourceURI, int lineno)\n+    {\n+        if (parseFinished) throw new IllegalStateException(\"parser reused\");\n+        this.sourceURI = sourceURI;\n+        if (compilerEnv.isIdeMode()) {\n+            this.sourceChars = sourceString.toCharArray();\n+        }\n+        this.ts = new TokenStream(this, null, sourceString, lineno);\n+        try {\n+            return parse();\n+        } catch (IOException iox) {\n+            // Should never happen\n+            throw new IllegalStateException();\n+        } finally {\n+            parseFinished = true;\n+        }\n+    }\n+\n+    /**\n+     * Builds a parse tree from the given sourcereader.\n+     * @see #parse(String,String,int)\n+     * @throws IOException if the {@link Reader} encounters an error\n+     */\n+    public AstRoot parse(Reader sourceReader, String sourceURI, int lineno)\n+        throws IOException\n+    {\n+        if (parseFinished) throw new IllegalStateException(\"parser reused\");\n+        if (compilerEnv.isIdeMode()) {\n+            return parse(readFully(sourceReader), sourceURI, lineno);\n+        }\n+        try {\n+            this.sourceURI = sourceURI;\n+            ts = new TokenStream(this, sourceReader, null, lineno);\n+            return parse();\n+        } finally {\n+            parseFinished = true;\n+        }\n+    }\n+\n+    private AstRoot parse() throws IOException\n+    {\n+        int pos = 0;\n+        AstRoot root = new AstRoot(pos);\n+        currentScope = currentScriptOrFn = root;\n+\n+        int baseLineno = ts.lineno;  // line number where source starts\n+        int end = pos;  // in case source is empty\n+\n+        boolean inDirectivePrologue = true;\n+        boolean savedStrictMode = inUseStrictDirective;\n+        // TODO: eval code should get strict mode from invoking code\n+        inUseStrictDirective = false;\n+\n+        try {\n+            for (;;) {\n+                int tt = peekToken();\n+                if (tt <= Token.EOF) {\n+                    break;\n+                }\n+\n+                AstNode n;\n+                if (tt == Token.FUNCTION) {\n+                    consumeToken();\n+                    try {\n+                        n = function(calledByCompileFunction\n+                                     ? FunctionNode.FUNCTION_EXPRESSION\n+                                     : FunctionNode.FUNCTION_STATEMENT);\n+                    } catch (ParserException e) {\n+                        break;\n+                    }\n+                } else {\n+                    n = statement();\n+                    if (inDirectivePrologue) {\n+                        String directive = getDirective(n);\n+                        if (directive == null) {\n+                            inDirectivePrologue = false;\n+                        } else if (directive.equals(\"use strict\")) {\n+                            inUseStrictDirective = true;\n+                            root.setInStrictMode(true);\n+                        }\n+                    }\n+\n+                }\n+                end = getNodeEnd(n);\n+                root.addChildToBack(n);\n+                n.setParent(root);\n+            }\n+        } catch (StackOverflowError ex) {\n+            String msg = lookupMessage(\"msg.too.deep.parser.recursion\");\n+            if (!compilerEnv.isIdeMode())\n+                throw Context.reportRuntimeError(msg, sourceURI,\n+                                                 ts.lineno, null, 0);\n+        } finally {\n+            inUseStrictDirective = savedStrictMode;\n+        }\n+\n+        if (this.syntaxErrorCount != 0) {\n+            String msg = String.valueOf(this.syntaxErrorCount);\n+            msg = lookupMessage(\"msg.got.syntax.errors\", msg);\n+            if (!compilerEnv.isIdeMode())\n+                throw errorReporter.runtimeError(msg, sourceURI, baseLineno,\n+                                                 null, 0);\n+        }\n+\n+        // add comments to root in lexical order\n+        if (scannedComments != null) {\n+            // If we find a comment beyond end of our last statement or\n+            // function, extend the root bounds to the end of that comment.\n+            int last = scannedComments.size() - 1;\n+            end = Math.max(end, getNodeEnd(scannedComments.get(last)));\n+            for (Comment c : scannedComments) {\n+                root.addComment(c);\n+            }\n+        }\n+\n+        root.setLength(end - pos);\n+        root.setSourceName(sourceURI);\n+        root.setBaseLineno(baseLineno);\n+        root.setEndLineno(ts.lineno);\n+        return root;\n+    }\n+\n+    private AstNode parseFunctionBody()\n+        throws IOException\n+    {\n+        if (!matchToken(Token.LC)) {\n+            if (compilerEnv.getLanguageVersion() < Context.VERSION_1_8) {\n+                reportError(\"msg.no.brace.body\");\n+            }\n+            return parseFunctionBodyExpr();\n+        }\n+        ++nestingOfFunction;\n+        int pos = ts.tokenBeg;\n+        Block pn = new Block(pos);  // starts at LC position\n+\n+        boolean inDirectivePrologue = true;\n+        boolean savedStrictMode = inUseStrictDirective;\n+        // Don't set 'inUseStrictDirective' to false: inherit strict mode.\n+\n+        pn.setLineno(ts.lineno);\n+        try {\n+            bodyLoop: for (;;) {\n+                AstNode n;\n+                int tt = peekToken();\n+                switch (tt) {\n+                  case Token.ERROR:\n+                  case Token.EOF:\n+                  case Token.RC:\n+                    break bodyLoop;\n+\n+                  case Token.FUNCTION:\n+                    consumeToken();\n+                    n = function(FunctionNode.FUNCTION_STATEMENT);\n+                    break;\n+                  default:\n+                    n = statement();\n+                    if (inDirectivePrologue) {\n+                        String directive = getDirective(n);\n+                        if (directive == null) {\n+                            inDirectivePrologue = false;\n+                        } else if (directive.equals(\"use strict\")) {\n+                            inUseStrictDirective = true;\n+                        }\n+                    }\n+                    break;\n+                }\n+                pn.addStatement(n);\n+            }\n+        } catch (ParserException e) {\n+            // Ignore it\n+        } finally {\n+            --nestingOfFunction;\n+            inUseStrictDirective = savedStrictMode;\n+        }\n+\n+        int end = ts.tokenEnd;\n+        getAndResetJsDoc();\n+        if (mustMatchToken(Token.RC, \"msg.no.brace.after.body\"))\n+            end = ts.tokenEnd;\n+        pn.setLength(end - pos);\n+        return pn;\n+    }\n+\n+    private String getDirective(AstNode n) {\n+        if (n instanceof ExpressionStatement) {\n+            AstNode e = ((ExpressionStatement) n).getExpression();\n+            if (e instanceof StringLiteral) {\n+                return ((StringLiteral) e).getValue();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private void parseFunctionParams(FunctionNode fnNode)\n+        throws IOException\n+    {\n+        if (matchToken(Token.RP)) {\n+            fnNode.setRp(ts.tokenBeg - fnNode.getPosition());\n+            return;\n+        }\n+        // Would prefer not to call createDestructuringAssignment until codegen,\n+        // but the symbol definitions have to happen now, before body is parsed.\n+        Map<String, Node> destructuring = null;\n+        Set<String> paramNames = new HashSet<String>();\n+        do {\n+            int tt = peekToken();\n+            if (tt == Token.LB || tt == Token.LC) {\n+                AstNode expr = destructuringPrimaryExpr();\n+                markDestructuring(expr);\n+                fnNode.addParam(expr);\n+                // Destructuring assignment for parameters: add a dummy\n+                // parameter name, and add a statement to the body to initialize\n+                // variables from the destructuring assignment\n+                if (destructuring == null) {\n+                    destructuring = new HashMap<String, Node>();\n+                }\n+                String pname = currentScriptOrFn.getNextTempName();\n+                defineSymbol(Token.LP, pname, false);\n+                destructuring.put(pname, expr);\n+            } else {\n+                if (mustMatchToken(Token.NAME, \"msg.no.parm\")) {\n+                    fnNode.addParam(createNameNode());\n+                    String paramName = ts.getString();\n+                    defineSymbol(Token.LP, paramName);\n+                    if (this.inUseStrictDirective) {\n+                        if (\"eval\".equals(paramName) ||\n+                            \"arguments\".equals(paramName))\n+                        {\n+                            reportError(\"msg.bad.id.strict\", paramName);\n+                        }\n+                        if (paramNames.contains(paramName))\n+                            addError(\"msg.dup.param.strict\", paramName);\n+                        paramNames.add(paramName);\n+                    }\n+                } else {\n+                    fnNode.addParam(makeErrorNode());\n+                }\n+            }\n+        } while (matchToken(Token.COMMA));\n+\n+        if (destructuring != null) {\n+            Node destructuringNode = new Node(Token.COMMA);\n+            // Add assignment helper for each destructuring parameter\n+            for (Map.Entry<String, Node> param: destructuring.entrySet()) {\n+                Node assign = createDestructuringAssignment(Token.VAR,\n+                        param.getValue(), createName(param.getKey()));\n+                destructuringNode.addChildToBack(assign);\n+\n+            }\n+            fnNode.putProp(Node.DESTRUCTURING_PARAMS, destructuringNode);\n+        }\n+\n+        if (mustMatchToken(Token.RP, \"msg.no.paren.after.parms\")) {\n+            fnNode.setRp(ts.tokenBeg - fnNode.getPosition());\n+        }\n+    }\n+\n+\n+    private AstNode parseFunctionBodyExpr()\n+        throws IOException\n+    {\n+        ++nestingOfFunction;\n+        int lineno = ts.getLineno();\n+        ReturnStatement n = new ReturnStatement(lineno);\n+        n.putProp(Node.EXPRESSION_CLOSURE_PROP, Boolean.TRUE);\n+        try {\n+            n.setReturnValue(assignExpr());\n+        } finally {\n+            --nestingOfFunction;\n+        }\n+        return n;\n+    }\n+\n+    private FunctionNode function(int type)\n+        throws IOException\n+    {\n+        int syntheticType = type;\n+        int baseLineno = ts.lineno;  // line number where source starts\n+        int functionSourceStart = ts.tokenBeg;  // start of \"function\" kwd\n+        Name name = null;\n+        AstNode memberExprNode = null;\n+\n+        if (matchToken(Token.NAME)) {\n+            name = createNameNode(true, Token.NAME);\n+            if (inUseStrictDirective) {\n+                String id = name.getIdentifier();\n+                if (\"eval\".equals(id)|| \"arguments\".equals(id)) {\n+                    reportError(\"msg.bad.id.strict\", id);\n+                }\n+            }\n+            if (!matchToken(Token.LP)) {\n+                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n+                    AstNode memberExprHead = name;\n+                    name = null;\n+                    memberExprNode = memberExprTail(false, memberExprHead);\n+                }\n+                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n+            }\n+        } else if (matchToken(Token.LP)) {\n+            // Anonymous function:  leave name as null\n+        } else {\n+            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n+                // Note that memberExpr can not start with '(' like\n+                // in function (1+2).toString(), because 'function (' already\n+                // processed as anonymous function\n+                memberExprNode = memberExpr(false);\n+            }\n+            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n+        }\n+        int lpPos = currentToken == Token.LP ? ts.tokenBeg : -1;\n+\n+        if (memberExprNode != null) {\n+            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n+        }\n+\n+        if (syntheticType != FunctionNode.FUNCTION_EXPRESSION\n+            && name != null && name.length() > 0) {\n+            // Function statements define a symbol in the enclosing scope\n+            defineSymbol(Token.FUNCTION, name.getIdentifier());\n+        }\n+\n+        FunctionNode fnNode = new FunctionNode(functionSourceStart, name);\n+        fnNode.setFunctionType(type);\n+        if (lpPos != -1)\n+            fnNode.setLp(lpPos - functionSourceStart);\n+\n+        if (insideFunction() || nestingOfWith > 0) {\n+            // 1. Nested functions are not affected by the dynamic scope flag\n+            //    as dynamic scope is already a parent of their scope.\n+            // 2. Functions defined under the with statement also immune to\n+            //    this setup, in which case dynamic scope is ignored in favor\n+            //    of the with object.\n+            fnNode.setIgnoreDynamicScope();\n+        }\n+\n+        fnNode.setJsDocNode(getAndResetJsDoc());\n+\n+        PerFunctionVariables savedVars = new PerFunctionVariables(fnNode);\n+        try {\n+            parseFunctionParams(fnNode);\n+            fnNode.setBody(parseFunctionBody());\n+            fnNode.setEncodedSourceBounds(functionSourceStart, ts.tokenEnd);\n+            fnNode.setLength(ts.tokenEnd - functionSourceStart);\n+\n+            if (compilerEnv.isStrictMode()\n+                && !fnNode.getBody().hasConsistentReturnUsage()) {\n+                String msg = (name != null && name.length() > 0)\n+                           ? \"msg.no.return.value\"\n+                           : \"msg.anon.no.return.value\";\n+                addStrictWarning(msg, name.getIdentifier());\n+            }\n+\n+            // Function expressions define a name only in the body of the\n+            // function, and only if not hidden by a parameter name\n+            if (syntheticType == FunctionNode.FUNCTION_EXPRESSION\n+                && name != null && name.length() > 0\n+                && currentScope.getSymbol(name.getIdentifier()) == null) {\n+                defineSymbol(Token.FUNCTION, name.getIdentifier());\n+            }\n+        } finally {\n+            savedVars.restore();\n+        }\n+\n+        if (memberExprNode != null) {\n+            // TODO(stevey): fix missing functionality\n+            Kit.codeBug();\n+            fnNode.setMemberExprNode(memberExprNode);  // rewrite later\n+            /* old code:\n+            if (memberExprNode != null) {\n+                pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n+                if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n+                    // XXX check JScript behavior: should it be createExprStatement?\n+                    pn = nf.createExprStatementNoReturn(pn, baseLineno);\n+                }\n+            }\n+            */\n+        }\n+\n+        fnNode.setSourceName(sourceURI);\n+        fnNode.setBaseLineno(baseLineno);\n+        fnNode.setEndLineno(ts.lineno);\n+\n+        // Set the parent scope.  Needed for finding undeclared vars.\n+        // Have to wait until after parsing the function to set its parent\n+        // scope, since defineSymbol needs the defining-scope check to stop\n+        // at the function boundary when checking for redeclarations.\n+        if (compilerEnv.isIdeMode()) {\n+            fnNode.setParentScope(currentScope);\n+        }\n+        return fnNode;\n+    }\n+\n+    // This function does not match the closing RC: the caller matches\n+    // the RC so it can provide a suitable error message if not matched.\n+    // This means it's up to the caller to set the length of the node to\n+    // include the closing RC.  The node start pos is set to the\n+    // absolute buffer start position, and the caller should fix it up\n+    // to be relative to the parent node.  All children of this block\n+    // node are given relative start positions and correct lengths.\n+\n+    private AstNode statements(AstNode parent) throws IOException {\n+        if (currentToken != Token.LC  // assertion can be invalid in bad code\n+            && !compilerEnv.isIdeMode()) codeBug();\n+        int pos = ts.tokenBeg;\n+        AstNode block = parent != null ? parent : new Block(pos);\n+        block.setLineno(ts.lineno);\n+\n+        int tt;\n+        while ((tt = peekToken()) > Token.EOF && tt != Token.RC) {\n+            block.addChild(statement());\n+        }\n+        block.setLength(ts.tokenBeg - pos);\n+        return block;\n+    }\n+\n+    private AstNode statements() throws IOException {\n+        return statements(null);\n+    }\n+\n+    private static class ConditionData {\n+        AstNode condition;\n+        int lp = -1;\n+        int rp = -1;\n+    }\n+\n+    // parse and return a parenthesized expression\n+    private ConditionData condition()\n+        throws IOException\n+    {\n+        ConditionData data = new ConditionData();\n+\n+        if (mustMatchToken(Token.LP, \"msg.no.paren.cond\"))\n+            data.lp = ts.tokenBeg;\n+\n+        data.condition = expr();\n+\n+        if (mustMatchToken(Token.RP, \"msg.no.paren.after.cond\"))\n+            data.rp = ts.tokenBeg;\n+\n+        // Report strict warning on code like \"if (a = 7) ...\". Suppress the\n+        // warning if the condition is parenthesized, like \"if ((a = 7)) ...\".\n+        if (data.condition instanceof Assignment) {\n+            addStrictWarning(\"msg.equal.as.assign\", \"\",\n+                             data.condition.getPosition(),\n+                             data.condition.getLength());\n+        }\n+        return data;\n+    }\n+\n+    private AstNode statement()\n+        throws IOException\n+    {\n+        int pos = ts.tokenBeg;\n+        try {\n+            AstNode pn = statementHelper();\n+            if (pn != null) {\n+                if (compilerEnv.isStrictMode() && !pn.hasSideEffects()) {\n+                    int beg = pn.getPosition();\n+                    beg = Math.max(beg, lineBeginningFor(beg));\n+                    addStrictWarning(pn instanceof EmptyExpression\n+                                     ? \"msg.extra.trailing.semi\"\n+                                     : \"msg.no.side.effects\",\n+                                     \"\", beg, nodeEnd(pn) - beg);\n+                }\n+                return pn;\n+            }\n+        } catch (ParserException e) {\n+            // an ErrorNode was added to the ErrorReporter\n+        }\n+\n+        // error:  skip ahead to a probable statement boundary\n+        guessingStatementEnd: for (;;) {\n+            int tt = peekTokenOrEOL();\n+            consumeToken();\n+            switch (tt) {\n+              case Token.ERROR:\n+              case Token.EOF:\n+              case Token.EOL:\n+              case Token.SEMI:\n+                break guessingStatementEnd;\n+            }\n+        }\n+        // We don't make error nodes explicitly part of the tree;\n+        // they get added to the ErrorReporter.  May need to do\n+        // something different here.\n+        return new EmptyExpression(pos, ts.tokenBeg - pos);\n+    }\n+\n+    private AstNode statementHelper()\n+        throws IOException\n+    {\n+        // If the statement is set, then it's been told its label by now.\n+        if (currentLabel != null && currentLabel.getStatement() != null)\n+            currentLabel = null;\n+\n+        AstNode pn = null;\n+        int tt = peekToken(), pos = ts.tokenBeg;\n+\n+        switch (tt) {\n+          case Token.IF:\n+              return ifStatement();\n+\n+          case Token.SWITCH:\n+              return switchStatement();\n+\n+          case Token.WHILE:\n+              return whileLoop();\n+\n+          case Token.DO:\n+              return doLoop();\n+\n+          case Token.FOR:\n+              return forLoop();\n+\n+          case Token.TRY:\n+              return tryStatement();\n+\n+          case Token.THROW:\n+              pn = throwStatement();\n+              break;\n+\n+          case Token.BREAK:\n+              pn = breakStatement();\n+              break;\n+\n+          case Token.CONTINUE:\n+              pn = continueStatement();\n+              break;\n+\n+          case Token.WITH:\n+              if (this.inUseStrictDirective) {\n+                  reportError(\"msg.no.with.strict\");\n+              }\n+              return withStatement();\n+\n+          case Token.CONST:\n+          case Token.VAR:\n+              consumeToken();\n+              int lineno = ts.lineno;\n+              pn = variables(currentToken, ts.tokenBeg);\n+              pn.setLineno(lineno);\n+              break;\n+\n+          case Token.LET:\n+              pn = letStatement();\n+              if (pn instanceof VariableDeclaration\n+                  && peekToken() == Token.SEMI)\n+                  break;\n+              return pn;\n+\n+          case Token.RETURN:\n+          case Token.YIELD:\n+              pn = returnOrYield(tt, false);\n+              break;\n+\n+          case Token.DEBUGGER:\n+              consumeToken();\n+              pn = new KeywordLiteral(ts.tokenBeg,\n+                                      ts.tokenEnd - ts.tokenBeg, tt);\n+              pn.setLineno(ts.lineno);\n+              break;\n+\n+          case Token.LC:\n+              return block();\n+\n+          case Token.ERROR:\n+              consumeToken();\n+              return makeErrorNode();\n+\n+          case Token.SEMI:\n+              consumeToken();\n+              pos = ts.tokenBeg;\n+              pn = new EmptyExpression(pos, ts.tokenEnd - pos);\n+              pn.setLineno(ts.lineno);\n+              return pn;\n+\n+          case Token.FUNCTION:\n+              consumeToken();\n+              return function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);\n+\n+          case Token.DEFAULT :\n+              pn = defaultXmlNamespace();\n+              break;\n+\n+          case Token.NAME:\n+              pn = nameOrLabel();\n+              if (pn instanceof ExpressionStatement)\n+                  break;\n+              return pn;  // LabeledStatement\n+\n+          default:\n+              lineno = ts.lineno;\n+              pn = new ExpressionStatement(expr(), !insideFunction());\n+              pn.setLineno(lineno);\n+              break;\n+        }\n+\n+        autoInsertSemicolon(pn);\n+        return pn;\n+    }\n+\n+    private void autoInsertSemicolon(AstNode pn) throws IOException {\n+        int ttFlagged = peekFlaggedToken();\n+        int pos = pn.getPosition();\n+        switch (ttFlagged & CLEAR_TI_MASK) {\n+          case Token.SEMI:\n+              // Consume ';' as a part of expression\n+              consumeToken();\n+              // extend the node bounds to include the semicolon.\n+              pn.setLength(ts.tokenEnd - pos);\n+              break;\n+          case Token.ERROR:\n+          case Token.EOF:\n+          case Token.RC:\n+              // Autoinsert ;\n+              warnMissingSemi(pos, nodeEnd(pn));\n+              break;\n+          default:\n+              if ((ttFlagged & TI_AFTER_EOL) == 0) {\n+                  // Report error if no EOL or autoinsert ; otherwise\n+                  reportError(\"msg.no.semi.stmt\");\n+              } else {\n+                  warnMissingSemi(pos, nodeEnd(pn));\n+              }\n+              break;\n+        }\n+    }\n+\n+    private IfStatement ifStatement()\n+        throws IOException\n+    {\n+        if (currentToken != Token.IF) codeBug();\n+        consumeToken();\n+        int pos = ts.tokenBeg, lineno = ts.lineno, elsePos = -1;\n+        ConditionData data = condition();\n+        AstNode ifTrue = statement(), ifFalse = null;\n+        if (matchToken(Token.ELSE)) {\n+            elsePos = ts.tokenBeg - pos;\n+            ifFalse = statement();\n+        }\n+        int end = getNodeEnd(ifFalse != null ? ifFalse : ifTrue);\n+        IfStatement pn = new IfStatement(pos, end - pos);\n+        pn.setCondition(data.condition);\n+        pn.setParens(data.lp - pos, data.rp - pos);\n+        pn.setThenPart(ifTrue);\n+        pn.setElsePart(ifFalse);\n+        pn.setElsePosition(elsePos);\n+        pn.setLineno(lineno);\n+        return pn;\n+    }\n+\n+    private SwitchStatement switchStatement()\n+        throws IOException\n+    {\n+        if (currentToken != Token.SWITCH) codeBug();\n+        consumeToken();\n+        int pos = ts.tokenBeg;\n+\n+        SwitchStatement pn = new SwitchStatement(pos);\n+        if (mustMatchToken(Token.LP, \"msg.no.paren.switch\"))\n+            pn.setLp(ts.tokenBeg - pos);\n+        pn.setLineno(ts.lineno);\n+\n+        AstNode discriminant = expr();\n+        pn.setExpression(discriminant);\n+        enterSwitch(pn);\n+\n+        try {\n+            if (mustMatchToken(Token.RP, \"msg.no.paren.after.switch\"))\n+                pn.setRp(ts.tokenBeg - pos);\n+\n+            mustMatchToken(Token.LC, \"msg.no.brace.switch\");\n+\n+            boolean hasDefault = false;\n+            int tt;\n+            switchLoop: for (;;) {\n+                tt = nextToken();\n+                int casePos = ts.tokenBeg;\n+                int caseLineno = ts.lineno;\n+                AstNode caseExpression = null;\n+                switch (tt) {\n+                    case Token.RC:\n+                        pn.setLength(ts.tokenEnd - pos);\n+                        break switchLoop;\n+\n+                    case Token.CASE:\n+                        caseExpression = expr();\n+                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n+                        break;\n+\n+                    case Token.DEFAULT:\n+                        if (hasDefault) {\n+                            reportError(\"msg.double.switch.default\");\n+                        }\n+                        hasDefault = true;\n+                        caseExpression = null;\n+                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n+                        break;\n+\n+                    default:\n+                        reportError(\"msg.bad.switch\");\n+                        break switchLoop;\n+                }\n+\n+                SwitchCase caseNode = new SwitchCase(casePos);\n+                caseNode.setExpression(caseExpression);\n+                caseNode.setLength(ts.tokenEnd - pos);  // include colon\n+                caseNode.setLineno(caseLineno);\n+\n+                while ((tt = peekToken()) != Token.RC\n+                       && tt != Token.CASE\n+                       && tt != Token.DEFAULT\n+                       && tt != Token.EOF)\n+                {\n+                    caseNode.addStatement(statement());  // updates length\n+                }\n+                pn.addCase(caseNode);\n+            }\n+        } finally {\n+            exitSwitch();\n+        }\n+        return pn;\n+    }\n+\n+    private WhileLoop whileLoop()\n+        throws IOException\n+    {\n+        if (currentToken != Token.WHILE) codeBug();\n+        consumeToken();\n+        int pos = ts.tokenBeg;\n+        WhileLoop pn = new WhileLoop(pos);\n+        pn.setLineno(ts.lineno);\n+        enterLoop(pn);\n+        try {\n+            ConditionData data = condition();\n+            pn.setCondition(data.condition);\n+            pn.setParens(data.lp - pos, data.rp - pos);\n+            AstNode body = statement();\n+            pn.setLength(getNodeEnd(body) - pos);\n+            pn.setBody(body);\n+        } finally {\n+            exitLoop();\n+        }\n+        return pn;\n+    }\n+\n+    private DoLoop doLoop()\n+        throws IOException\n+    {\n+        if (currentToken != Token.DO) codeBug();\n+        consumeToken();\n+        int pos = ts.tokenBeg, end;\n+        DoLoop pn = new DoLoop(pos);\n+        pn.setLineno(ts.lineno);\n+        enterLoop(pn);\n+        try {\n+            AstNode body = statement();\n+            mustMatchToken(Token.WHILE, \"msg.no.while.do\");\n+            pn.setWhilePosition(ts.tokenBeg - pos);\n+            ConditionData data = condition();\n+            pn.setCondition(data.condition);\n+            pn.setParens(data.lp - pos, data.rp - pos);\n+            end = getNodeEnd(body);\n+            pn.setBody(body);\n+        } finally {\n+            exitLoop();\n+        }\n+        // Always auto-insert semicolon to follow SpiderMonkey:\n+        // It is required by ECMAScript but is ignored by the rest of\n+        // world, see bug 238945\n+        if (matchToken(Token.SEMI)) {\n+            end = ts.tokenEnd;\n+        }\n+        pn.setLength(end - pos);\n+        return pn;\n+    }\n+\n+    private Loop forLoop()\n+        throws IOException\n+    {\n+        if (currentToken != Token.FOR) codeBug();\n+        consumeToken();\n+        int forPos = ts.tokenBeg, lineno = ts.lineno;\n+        boolean isForEach = false, isForIn = false;\n+        int eachPos = -1, inPos = -1, lp = -1, rp = -1;\n+        AstNode init = null;  // init is also foo in 'foo in object'\n+        AstNode cond = null;  // cond is also object in 'foo in object'\n+        AstNode incr = null;\n+        Loop pn = null;\n+\n+        Scope tempScope = new Scope();\n+        pushScope(tempScope);  // decide below what AST class to use\n+        try {\n+            // See if this is a for each () instead of just a for ()\n+            if (matchToken(Token.NAME)) {\n+                if (\"each\".equals(ts.getString())) {\n+                    isForEach = true;\n+                    eachPos = ts.tokenBeg - forPos;\n+                } else {\n+                    reportError(\"msg.no.paren.for\");\n+                }\n+            }\n+\n+            if (mustMatchToken(Token.LP, \"msg.no.paren.for\"))\n+                lp = ts.tokenBeg - forPos;\n+            int tt = peekToken();\n+\n+            init = forLoopInit(tt);\n+\n+            if (matchToken(Token.IN)) {\n+                isForIn = true;\n+                inPos = ts.tokenBeg - forPos;\n+                cond = expr();  // object over which we're iterating\n+            } else {  // ordinary for-loop\n+                mustMatchToken(Token.SEMI, \"msg.no.semi.for\");\n+                if (peekToken() == Token.SEMI) {\n+                    // no loop condition\n+                    cond = new EmptyExpression(ts.tokenBeg, 1);\n+                    cond.setLineno(ts.lineno);\n+                } else {\n+                    cond = expr();\n+                }\n+\n+                mustMatchToken(Token.SEMI, \"msg.no.semi.for.cond\");\n+                int tmpPos = ts.tokenEnd;\n+                if (peekToken() == Token.RP) {\n+                    incr = new EmptyExpression(tmpPos, 1);\n+                    incr.setLineno(ts.lineno);\n+                } else {\n+                    incr = expr();\n+                }\n+            }\n+\n+            if (mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\"))\n+                rp = ts.tokenBeg - forPos;\n+\n+            if (isForIn) {\n+                ForInLoop fis = new ForInLoop(forPos);\n+                if (init instanceof VariableDeclaration) {\n+                    // check that there was only one variable given\n+                    if (((VariableDeclaration)init).getVariables().size() > 1) {\n+                        reportError(\"msg.mult.index\");\n+                    }\n+                }\n+                fis.setIterator(init);\n+                fis.setIteratedObject(cond);\n+                fis.setInPosition(inPos);\n+                fis.setIsForEach(isForEach);\n+                fis.setEachPosition(eachPos);\n+                pn = fis;\n+            } else {\n+                ForLoop fl = new ForLoop(forPos);\n+                fl.setInitializer(init);\n+                fl.setCondition(cond);\n+                fl.setIncrement(incr);\n+                pn = fl;\n+            }\n+\n+            // replace temp scope with the new loop object\n+            currentScope.replaceWith(pn);\n+            popScope();\n+\n+            // We have to parse the body -after- creating the loop node,\n+            // so that the loop node appears in the loopSet, allowing\n+            // break/continue statements to find the enclosing loop.\n+            enterLoop(pn);\n+            try {\n+                AstNode body = statement();\n+                pn.setLength(getNodeEnd(body) - forPos);\n+                pn.setBody(body);\n+            } finally {\n+                exitLoop();\n+            }\n+\n+        } finally {\n+            if (currentScope == tempScope) {\n+                popScope();\n+            }\n+        }\n+        pn.setParens(lp, rp);\n+        pn.setLineno(lineno);\n+        return pn;\n+    }\n+\n+    private AstNode forLoopInit(int tt) throws IOException {\n+        try {\n+            inForInit = true;  // checked by variables() and relExpr()\n+            AstNode init = null;\n+            if (tt == Token.SEMI) {\n+                init = new EmptyExpression(ts.tokenBeg, 1);\n+                init.setLineno(ts.lineno);\n+            } else if (tt == Token.VAR || tt == Token.LET) {\n+                consumeToken();\n+                init = variables(tt, ts.tokenBeg);\n+            } else {\n+                init = expr();\n+                markDestructuring(init);\n+            }\n+            return init;\n+        } finally {\n+            inForInit = false;\n+        }\n+    }\n+\n+    private TryStatement tryStatement()\n+        throws IOException\n+    {\n+        if (currentToken != Token.TRY) codeBug();\n+        consumeToken();\n+\n+        // Pull out JSDoc info and reset it before recursing.\n+        Comment jsdocNode = getAndResetJsDoc();\n+\n+        int tryPos = ts.tokenBeg, lineno = ts.lineno, finallyPos = -1;\n+        if (peekToken() != Token.LC) {\n+            reportError(\"msg.no.brace.try\");\n+        }\n+        AstNode tryBlock = statement();\n+        int tryEnd = getNodeEnd(tryBlock);\n+\n+        List<CatchClause> clauses = null;\n+\n+        boolean sawDefaultCatch = false;\n+        int peek = peekToken();\n+        if (peek == Token.CATCH) {\n+            while (matchToken(Token.CATCH)) {\n+                int catchLineNum = ts.lineno;\n+                if (sawDefaultCatch) {\n+                    reportError(\"msg.catch.unreachable\");\n+                }\n+                int catchPos = ts.tokenBeg, lp = -1, rp = -1, guardPos = -1;\n+                if (mustMatchToken(Token.LP, \"msg.no.paren.catch\"))\n+                    lp = ts.tokenBeg;\n+\n+                mustMatchToken(Token.NAME, \"msg.bad.catchcond\");\n+                Name varName = createNameNode();\n+                String varNameString = varName.getIdentifier();\n+                if (inUseStrictDirective) {\n+                    if (\"eval\".equals(varNameString) ||\n+                        \"arguments\".equals(varNameString))\n+                    {\n+                        reportError(\"msg.bad.id.strict\", varNameString);\n+                    }\n+                }\n+\n+                AstNode catchCond = null;\n+                if (matchToken(Token.IF)) {\n+                    guardPos = ts.tokenBeg;\n+                    catchCond = expr();\n+                } else {\n+                    sawDefaultCatch = true;\n+                }\n+\n+                if (mustMatchToken(Token.RP, \"msg.bad.catchcond\"))\n+                    rp = ts.tokenBeg;\n+                mustMatchToken(Token.LC, \"msg.no.brace.catchblock\");\n+\n+                Block catchBlock = (Block)statements();\n+                tryEnd = getNodeEnd(catchBlock);\n+                CatchClause catchNode = new CatchClause(catchPos);\n+                catchNode.setVarName(varName);\n+                catchNode.setCatchCondition(catchCond);\n+                catchNode.setBody(catchBlock);\n+                if (guardPos != -1) {\n+                    catchNode.setIfPosition(guardPos - catchPos);\n+                }\n+                catchNode.setParens(lp, rp);\n+                catchNode.setLineno(catchLineNum);\n+\n+                if (mustMatchToken(Token.RC, \"msg.no.brace.after.body\"))\n+                    tryEnd = ts.tokenEnd;\n+                catchNode.setLength(tryEnd - catchPos);\n+                if (clauses == null)\n+                    clauses = new ArrayList<CatchClause>();\n+                clauses.add(catchNode);\n+            }\n+        } else if (peek != Token.FINALLY) {\n+            mustMatchToken(Token.FINALLY, \"msg.try.no.catchfinally\");\n+        }\n+\n+        AstNode finallyBlock = null;\n+        if (matchToken(Token.FINALLY)) {\n+            finallyPos = ts.tokenBeg;\n+            finallyBlock = statement();\n+            tryEnd = getNodeEnd(finallyBlock);\n+        }\n+\n+        TryStatement pn = new TryStatement(tryPos, tryEnd - tryPos);\n+        pn.setTryBlock(tryBlock);\n+        pn.setCatchClauses(clauses);\n+        pn.setFinallyBlock(finallyBlock);\n+        if (finallyPos != -1) {\n+            pn.setFinallyPosition(finallyPos - tryPos);\n+        }\n+        pn.setLineno(lineno);\n+\n+        if (jsdocNode != null) {\n+            pn.setJsDocNode(jsdocNode);\n+        }\n+\n+        return pn;\n+    }\n+\n+    private ThrowStatement throwStatement()\n+        throws IOException\n+    {\n+        if (currentToken != Token.THROW) codeBug();\n+        consumeToken();\n+        int pos = ts.tokenBeg, lineno = ts.lineno;\n+        if (peekTokenOrEOL() == Token.EOL) {\n+            // ECMAScript does not allow new lines before throw expression,\n+            // see bug 256617\n+            reportError(\"msg.bad.throw.eol\");\n+        }\n+        AstNode expr = expr();\n+        ThrowStatement pn = new ThrowStatement(pos, getNodeEnd(expr), expr);\n+        pn.setLineno(lineno);\n+        return pn;\n+    }\n+\n+    // If we match a NAME, consume the token and return the statement\n+    // with that label.  If the name does not match an existing label,\n+    // reports an error.  Returns the labeled statement node, or null if\n+    // the peeked token was not a name.  Side effect:  sets scanner token\n+    // information for the label identifier (tokenBeg, tokenEnd, etc.)\n+\n+    private LabeledStatement matchJumpLabelName()\n+        throws IOException\n+    {\n+        LabeledStatement label = null;\n+\n+        if (peekTokenOrEOL() == Token.NAME) {\n+            consumeToken();\n+            if (labelSet != null) {\n+                label = labelSet.get(ts.getString());\n+            }\n+            if (label == null) {\n+                reportError(\"msg.undef.label\");\n+            }\n+        }\n+\n+        return label;\n+    }\n+\n+    private BreakStatement breakStatement()\n+        throws IOException\n+    {\n+        if (currentToken != Token.BREAK) codeBug();\n+        consumeToken();\n+        int lineno = ts.lineno, pos = ts.tokenBeg, end = ts.tokenEnd;\n+        Name breakLabel = null;\n+        if (peekTokenOrEOL() == Token.NAME) {\n+            breakLabel = createNameNode();\n+            end = getNodeEnd(breakLabel);\n+        }\n+\n+        // matchJumpLabelName only matches if there is one\n+        LabeledStatement labels = matchJumpLabelName();\n+        // always use first label as target\n+        Jump breakTarget = labels == null ? null : labels.getFirstLabel();\n+\n+        if (breakTarget == null && breakLabel == null) {\n+            if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {\n+                if (breakLabel == null) {\n+                    reportError(\"msg.bad.break\", pos, end - pos);\n+                }\n+            } else {\n+                breakTarget = loopAndSwitchSet.get(loopAndSwitchSet.size() - 1);\n+            }\n+        }\n+\n+        BreakStatement pn = new BreakStatement(pos, end - pos);\n+        pn.setBreakLabel(breakLabel);\n+        // can be null if it's a bad break in error-recovery mode\n+        if (breakTarget != null)\n+            pn.setBreakTarget(breakTarget);\n+        pn.setLineno(lineno);\n+        return pn;\n+    }\n+\n+    private ContinueStatement continueStatement()\n+        throws IOException\n+    {\n+        if (currentToken != Token.CONTINUE) codeBug();\n+        consumeToken();\n+        int lineno = ts.lineno, pos = ts.tokenBeg, end = ts.tokenEnd;\n+        Name label = null;\n+        if (peekTokenOrEOL() == Token.NAME) {\n+            label = createNameNode();\n+            end = getNodeEnd(label);\n+        }\n+\n+        // matchJumpLabelName only matches if there is one\n+        LabeledStatement labels = matchJumpLabelName();\n+        Loop target = null;\n+        if (labels == null && label == null) {\n+            if (loopSet == null || loopSet.size() == 0) {\n+                reportError(\"msg.continue.outside\");\n+            } else {\n+                target = loopSet.get(loopSet.size() - 1);\n+            }\n+        } else {\n+            if (labels == null || !(labels.getStatement() instanceof Loop)) {\n+                reportError(\"msg.continue.nonloop\", pos, end - pos);\n+            }\n+            target = labels == null ? null : (Loop)labels.getStatement();\n+        }\n+\n+        ContinueStatement pn = new ContinueStatement(pos, end - pos);\n+        if (target != null)  // can be null in error-recovery mode\n+            pn.setTarget(target);\n+        pn.setLabel(label);\n+        pn.setLineno(lineno);\n+        return pn;\n+    }\n+\n+    private WithStatement withStatement()\n+        throws IOException\n+    {\n+        if (currentToken != Token.WITH) codeBug();\n+        consumeToken();\n+\n+        Comment withComment = getAndResetJsDoc();\n+\n+        int lineno = ts.lineno, pos = ts.tokenBeg, lp = -1, rp = -1;\n+        if (mustMatchToken(Token.LP, \"msg.no.paren.with\"))\n+            lp = ts.tokenBeg;\n+\n+        AstNode obj = expr();\n+\n+        if (mustMatchToken(Token.RP, \"msg.no.paren.after.with\"))\n+            rp = ts.tokenBeg;\n+\n+        ++nestingOfWith;\n+        AstNode body;\n+        try {\n+            body = statement();\n+        } finally {\n+            --nestingOfWith;\n+        }\n+\n+        WithStatement pn = new WithStatement(pos, getNodeEnd(body) - pos);\n+        pn.setJsDocNode(withComment);\n+        pn.setExpression(obj);\n+        pn.setStatement(body);\n+        pn.setParens(lp, rp);\n+        pn.setLineno(lineno);\n+        return pn;\n+    }\n+\n+    private AstNode letStatement()\n+        throws IOException\n+    {\n+        if (currentToken != Token.LET) codeBug();\n+        consumeToken();\n+        int lineno = ts.lineno, pos = ts.tokenBeg;\n+        AstNode pn;\n+        if (peekToken() == Token.LP) {\n+            pn = let(true, pos);\n+        } else {\n+            pn = variables(Token.LET, pos);  // else, e.g.: let x=6, y=7;\n+        }\n+        pn.setLineno(lineno);\n+        return pn;\n+    }\n+\n+    /**\n+     * Returns whether or not the bits in the mask have changed to all set.\n+     * @param before bits before change\n+     * @param after bits after change\n+     * @param mask mask for bits\n+     * @return {@code true} if all the bits in the mask are set in \"after\"\n+     *          but not in \"before\"\n+     */\n+    private static final boolean nowAllSet(int before, int after, int mask) {\n+        return ((before & mask) != mask) && ((after & mask) == mask);\n+    }\n+\n+    private AstNode returnOrYield(int tt, boolean exprContext)\n+        throws IOException\n+    {\n+        if (!insideFunction()) {\n+            reportError(tt == Token.RETURN ? \"msg.bad.return\"\n+                                           : \"msg.bad.yield\");\n+        }\n+        consumeToken();\n+        int lineno = ts.lineno, pos = ts.tokenBeg, end = ts.tokenEnd;\n+\n+        AstNode e = null;\n+        // This is ugly, but we don't want to require a semicolon.\n+        switch (peekTokenOrEOL()) {\n+          case Token.SEMI: case Token.RC:  case Token.RB:    case Token.RP:\n+          case Token.EOF:  case Token.EOL: case Token.ERROR: case Token.YIELD:\n+            break;\n+          default:\n+            e = expr();\n+            end = getNodeEnd(e);\n+        }\n+\n+        int before = endFlags;\n+        AstNode ret;\n+\n+        if (tt == Token.RETURN) {\n+            endFlags |= e == null ? Node.END_RETURNS : Node.END_RETURNS_VALUE;\n+            ret = new ReturnStatement(pos, end - pos, e);\n+\n+            // see if we need a strict mode warning\n+            if (nowAllSet(before, endFlags,\n+                    Node.END_RETURNS|Node.END_RETURNS_VALUE))\n+                addStrictWarning(\"msg.return.inconsistent\", \"\", pos, end - pos);\n+        } else {\n+            if (!insideFunction())\n+                reportError(\"msg.bad.yield\");\n+            endFlags |= Node.END_YIELDS;\n+            ret = new Yield(pos, end - pos, e);\n+            setRequiresActivation();\n+            setIsGenerator();\n+            if (!exprContext) {\n+                ret = new ExpressionStatement(ret);\n+            }\n+        }\n+\n+        // see if we are mixing yields and value returns.\n+        if (insideFunction()\n+            && nowAllSet(before, endFlags,\n+                    Node.END_YIELDS|Node.END_RETURNS_VALUE)) {\n+            Name name = ((FunctionNode)currentScriptOrFn).getFunctionName();\n+            if (name == null || name.length() == 0)\n+                addError(\"msg.anon.generator.returns\", \"\");\n+            else\n+                addError(\"msg.generator.returns\", name.getIdentifier());\n+        }\n+\n+        ret.setLineno(lineno);\n+        return ret;\n+    }\n+\n+    private AstNode block()\n+        throws IOException\n+    {\n+        if (currentToken != Token.LC) codeBug();\n+        consumeToken();\n+        int pos = ts.tokenBeg;\n+        Scope block = new Scope(pos);\n+        block.setLineno(ts.lineno);\n+        pushScope(block);\n+        try {\n+            statements(block);\n+            mustMatchToken(Token.RC, \"msg.no.brace.block\");\n+            block.setLength(ts.tokenEnd - pos);\n+            return block;\n+        } finally {\n+            popScope();\n+        }\n+    }\n+\n+    private AstNode defaultXmlNamespace()\n+        throws IOException\n+    {\n+        if (currentToken != Token.DEFAULT) codeBug();\n+        consumeToken();\n+        mustHaveXML();\n+        setRequiresActivation();\n+        int lineno = ts.lineno, pos = ts.tokenBeg;\n+\n+        if (!(matchToken(Token.NAME) && \"xml\".equals(ts.getString()))) {\n+            reportError(\"msg.bad.namespace\");\n+        }\n+        if (!(matchToken(Token.NAME) && \"namespace\".equals(ts.getString()))) {\n+            reportError(\"msg.bad.namespace\");\n+        }\n+        if (!matchToken(Token.ASSIGN)) {\n+            reportError(\"msg.bad.namespace\");\n+        }\n+\n+        AstNode e = expr();\n+        UnaryExpression dxmln = new UnaryExpression(pos, getNodeEnd(e) - pos);\n+        dxmln.setOperator(Token.DEFAULTNAMESPACE);\n+        dxmln.setOperand(e);\n+        dxmln.setLineno(lineno);\n+\n+        ExpressionStatement es = new ExpressionStatement(dxmln, true);\n+        return es;\n+    }\n+\n+    private void recordLabel(Label label, LabeledStatement bundle)\n+        throws IOException\n+    {\n+        // current token should be colon that primaryExpr left untouched\n+        if (peekToken() != Token.COLON) codeBug();\n+        consumeToken();\n+        String name = label.getName();\n+        if (labelSet == null) {\n+            labelSet = new HashMap<String,LabeledStatement>();\n+        } else {\n+            LabeledStatement ls = labelSet.get(name);\n+            if (ls != null) {\n+                if (compilerEnv.isIdeMode()) {\n+                    Label dup = ls.getLabelByName(name);\n+                    reportError(\"msg.dup.label\",\n+                                dup.getAbsolutePosition(), dup.getLength());\n+                }\n+                reportError(\"msg.dup.label\",\n+                            label.getPosition(), label.getLength());\n+            }\n+        }\n+        bundle.addLabel(label);\n+        labelSet.put(name, bundle);\n+    }\n+\n+    /**\n+     * Found a name in a statement context.  If it's a label, we gather\n+     * up any following labels and the next non-label statement into a\n+     * {@link LabeledStatement} \"bundle\" and return that.  Otherwise we parse\n+     * an expression and return it wrapped in an {@link ExpressionStatement}.\n+     */\n+    private AstNode nameOrLabel()\n+        throws IOException\n+    {\n+        if (currentToken != Token.NAME) throw codeBug();\n+        int pos = ts.tokenBeg;\n+\n+        // set check for label and call down to primaryExpr\n+        currentFlaggedToken |= TI_CHECK_LABEL;\n+        AstNode expr = expr();\n+\n+        if (expr.getType() != Token.LABEL) {\n+            AstNode n = new ExpressionStatement(expr, !insideFunction());\n+            n.lineno = expr.lineno;\n+            return n;\n+        }\n+\n+        LabeledStatement bundle = new LabeledStatement(pos);\n+        recordLabel((Label)expr, bundle);\n+        bundle.setLineno(ts.lineno);\n+        // look for more labels\n+        AstNode stmt = null;\n+        while (peekToken() == Token.NAME) {\n+            currentFlaggedToken |= TI_CHECK_LABEL;\n+            expr = expr();\n+            if (expr.getType() != Token.LABEL) {\n+                stmt = new ExpressionStatement(expr, !insideFunction());\n+                autoInsertSemicolon(stmt);\n+                break;\n+            }\n+            recordLabel((Label)expr, bundle);\n+        }\n+\n+        // no more labels; now parse the labeled statement\n+        try {\n+            currentLabel = bundle;\n+            if (stmt == null) {\n+                stmt = statementHelper();\n+            }\n+        } finally {\n+            currentLabel = null;\n+            // remove the labels for this statement from the global set\n+            for (Label lb : bundle.getLabels()) {\n+                labelSet.remove(lb.getName());\n+            }\n+        }\n+\n+        bundle.setLength(getNodeEnd(stmt) - pos);\n+        bundle.setStatement(stmt);\n+        return bundle;\n+    }\n+\n+    /**\n+     * Parse a 'var' or 'const' statement, or a 'var' init list in a for\n+     * statement.\n+     * @param declType A token value: either VAR, CONST, or LET depending on\n+     * context.\n+     * @param pos the position where the node should start.  It's sometimes\n+     * the var/const/let keyword, and other times the beginning of the first\n+     * token in the first variable declaration.\n+     * @return the parsed variable list\n+     */\n+    private VariableDeclaration variables(int declType, int pos)\n+        throws IOException\n+    {\n+        int end;\n+        VariableDeclaration pn = new VariableDeclaration(pos);\n+        pn.setType(declType);\n+        pn.setLineno(ts.lineno);\n+        Comment varjsdocNode = getAndResetJsDoc();\n+        if (varjsdocNode != null) {\n+            pn.setJsDocNode(varjsdocNode);\n+        }\n+        // Example:\n+        // var foo = {a: 1, b: 2}, bar = [3, 4];\n+        // var {b: s2, a: s1} = foo, x = 6, y, [s3, s4] = bar;\n+        for (;;) {\n+            AstNode destructuring = null;\n+            Name name = null;\n+            int tt = peekToken(), kidPos = ts.tokenBeg;\n+            end = ts.tokenEnd;\n+\n+            if (tt == Token.LB || tt == Token.LC) {\n+                // Destructuring assignment, e.g., var [a,b] = ...\n+                destructuring = destructuringPrimaryExpr();\n+                end = getNodeEnd(destructuring);\n+                if (!(destructuring instanceof DestructuringForm))\n+                    reportError(\"msg.bad.assign.left\", kidPos, end - kidPos);\n+                markDestructuring(destructuring);\n+            } else {\n+                // Simple variable name\n+                mustMatchToken(Token.NAME, \"msg.bad.var\");\n+                name = createNameNode();\n+                name.setLineno(ts.getLineno());\n+                if (inUseStrictDirective) {\n+                    String id = ts.getString();\n+                    if (\"eval\".equals(id) || \"arguments\".equals(ts.getString()))\n+                    {\n+                        reportError(\"msg.bad.id.strict\", id);\n+                    }\n+                }\n+                defineSymbol(declType, ts.getString(), inForInit);\n+            }\n+\n+            int lineno = ts.lineno;\n+\n+            Comment jsdocNode = getAndResetJsDoc();\n+\n+            AstNode init = null;\n+            if (matchToken(Token.ASSIGN)) {\n+                init = assignExpr();\n+                end = getNodeEnd(init);\n+            }\n+\n+            VariableInitializer vi = new VariableInitializer(kidPos, end);\n+            if (destructuring != null) {\n+                if (init == null && !inForInit) {\n+                    reportError(\"msg.destruct.assign.no.init\");\n+                }\n+                vi.setTarget(destructuring);\n+            } else {\n+                vi.setTarget(name);\n+            }\n+            vi.setInitializer(init);\n+            vi.setType(declType);\n+            vi.setJsDocNode(jsdocNode);\n+            vi.setLineno(lineno);\n+            pn.addVariable(vi);\n+\n+            if (!matchToken(Token.COMMA))\n+                break;\n+        }\n+        pn.setLength(end - pos);\n+        return pn;\n+    }\n+\n+    // have to pass in 'let' kwd position to compute kid offsets properly\n+    private AstNode let(boolean isStatement, int pos)\n+        throws IOException\n+    {\n+        LetNode pn = new LetNode(pos);\n+        pn.setLineno(ts.lineno);\n+        if (mustMatchToken(Token.LP, \"msg.no.paren.after.let\"))\n+            pn.setLp(ts.tokenBeg - pos);\n+        pushScope(pn);\n+        try {\n+            VariableDeclaration vars = variables(Token.LET, ts.tokenBeg);\n+            pn.setVariables(vars);\n+            if (mustMatchToken(Token.RP, \"msg.no.paren.let\")) {\n+                pn.setRp(ts.tokenBeg - pos);\n+            }\n+            if (isStatement && peekToken() == Token.LC) {\n+                // let statement\n+                consumeToken();\n+                int beg = ts.tokenBeg;  // position stmt at LC\n+                AstNode stmt = statements();\n+                mustMatchToken(Token.RC, \"msg.no.curly.let\");\n+                stmt.setLength(ts.tokenEnd - beg);\n+                pn.setLength(ts.tokenEnd - pos);\n+                pn.setBody(stmt);\n+                pn.setType(Token.LET);\n+            } else {\n+                // let expression\n+                AstNode expr = expr();\n+                pn.setLength(getNodeEnd(expr) - pos);\n+                pn.setBody(expr);\n+                if (isStatement) {\n+                    // let expression in statement context\n+                    ExpressionStatement es =\n+                            new ExpressionStatement(pn, !insideFunction());\n+                    es.setLineno(pn.getLineno());\n+                    return es;\n+                }\n+            }\n+        } finally {\n+            popScope();\n+        }\n+        return pn;\n+    }\n+\n+    void defineSymbol(int declType, String name) {\n+        defineSymbol(declType, name, false);\n+    }\n+\n+    void defineSymbol(int declType, String name, boolean ignoreNotInBlock) {\n+        if (name == null) {\n+            if (compilerEnv.isIdeMode()) {  // be robust in IDE-mode\n+                return;\n+            } else {\n+                codeBug();\n+            }\n+        }\n+        Scope definingScope = currentScope.getDefiningScope(name);\n+        Symbol symbol = definingScope != null\n+                        ? definingScope.getSymbol(name)\n+                        : null;\n+        int symDeclType = symbol != null ? symbol.getDeclType() : -1;\n+        if (symbol != null\n+            && (symDeclType == Token.CONST\n+                || declType == Token.CONST\n+                || (definingScope == currentScope && symDeclType == Token.LET)))\n+        {\n+            addError(symDeclType == Token.CONST ? \"msg.const.redecl\" :\n+                     symDeclType == Token.LET ? \"msg.let.redecl\" :\n+                     symDeclType == Token.VAR ? \"msg.var.redecl\" :\n+                     symDeclType == Token.FUNCTION ? \"msg.fn.redecl\" :\n+                     \"msg.parm.redecl\", name);\n+            return;\n+        }\n+        switch (declType) {\n+          case Token.LET:\n+              if (!ignoreNotInBlock &&\n+                  ((currentScope.getType() == Token.IF) ||\n+                   currentScope instanceof Loop)) {\n+                  addError(\"msg.let.decl.not.in.block\");\n+                  return;\n+              }\n+              currentScope.putSymbol(new Symbol(declType, name));\n+              return;\n+\n+          case Token.VAR:\n+          case Token.CONST:\n+          case Token.FUNCTION:\n+              if (symbol != null) {\n+                  if (symDeclType == Token.VAR)\n+                      addStrictWarning(\"msg.var.redecl\", name);\n+                  else if (symDeclType == Token.LP) {\n+                      addStrictWarning(\"msg.var.hides.arg\", name);\n+                  }\n+              } else {\n+                  currentScriptOrFn.putSymbol(new Symbol(declType, name));\n+              }\n+              return;\n+\n+          case Token.LP:\n+              if (symbol != null) {\n+                  // must be duplicate parameter. Second parameter hides the\n+                  // first, so go ahead and add the second parameter\n+                  addWarning(\"msg.dup.parms\", name);\n+              }\n+              currentScriptOrFn.putSymbol(new Symbol(declType, name));\n+              return;\n+\n+          default:\n+              throw codeBug();\n+        }\n+    }\n+\n+    private AstNode expr()\n+        throws IOException\n+    {\n+        AstNode pn = assignExpr();\n+        int pos = pn.getPosition();\n+        while (matchToken(Token.COMMA)) {\n+            int lineno = ts.lineno;\n+            int opPos = ts.tokenBeg;\n+            if (compilerEnv.isStrictMode() && !pn.hasSideEffects())\n+                addStrictWarning(\"msg.no.side.effects\", \"\",\n+                                 pos, nodeEnd(pn) - pos);\n+            if (peekToken() == Token.YIELD)\n+                reportError(\"msg.yield.parenthesized\");\n+            pn = new InfixExpression(Token.COMMA, pn, assignExpr(), opPos);\n+            pn.setLineno(lineno);\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode assignExpr()\n+        throws IOException\n+    {\n+        int tt = peekToken();\n+        if (tt == Token.YIELD) {\n+            return returnOrYield(tt, true);\n+        }\n+        AstNode pn = condExpr();\n+        tt = peekToken();\n+        if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {\n+            consumeToken();\n+\n+            // Pull out JSDoc info and reset it before recursing.\n+            Comment jsdocNode = getAndResetJsDoc();\n+\n+            markDestructuring(pn);\n+            int opPos = ts.tokenBeg;\n+            int opLineno = ts.getLineno();\n+\n+            pn = new Assignment(tt, pn, assignExpr(), opPos);\n+\n+            pn.setLineno(opLineno);\n+            if (jsdocNode != null) {\n+                pn.setJsDocNode(jsdocNode);\n+            }\n+        } else if (tt == Token.SEMI) {\n+            // This may be dead code added intentionally, for JSDoc purposes.\n+            // For example: /** @type Number */ C.prototype.x;\n+            if (currentJsDocComment != null) {\n+                pn.setJsDocNode(getAndResetJsDoc());\n+            }\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode condExpr()\n+        throws IOException\n+    {\n+        AstNode pn = orExpr();\n+        if (matchToken(Token.HOOK)) {\n+            int line = ts.lineno;\n+            int qmarkPos = ts.tokenBeg, colonPos = -1;\n+            AstNode ifTrue = assignExpr();\n+            if (mustMatchToken(Token.COLON, \"msg.no.colon.cond\"))\n+                colonPos = ts.tokenBeg;\n+            AstNode ifFalse = assignExpr();\n+            int beg = pn.getPosition(), len = getNodeEnd(ifFalse) - beg;\n+            ConditionalExpression ce = new ConditionalExpression(beg, len);\n+            ce.setLineno(line);\n+            ce.setTestExpression(pn);\n+            ce.setTrueExpression(ifTrue);\n+            ce.setFalseExpression(ifFalse);\n+            ce.setQuestionMarkPosition(qmarkPos - beg);\n+            ce.setColonPosition(colonPos - beg);\n+            pn = ce;\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode orExpr()\n+        throws IOException\n+    {\n+        AstNode pn = andExpr();\n+        if (matchToken(Token.OR)) {\n+            int opPos = ts.tokenBeg;\n+            int lineno = ts.lineno;\n+            pn = new InfixExpression(Token.OR, pn, orExpr(), opPos);\n+            pn.setLineno(lineno);\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode andExpr()\n+        throws IOException\n+    {\n+        AstNode pn = bitOrExpr();\n+        if (matchToken(Token.AND)) {\n+            int opPos = ts.tokenBeg;\n+            int lineno = ts.lineno;\n+            pn = new InfixExpression(Token.AND, pn, andExpr(), opPos);\n+            pn.setLineno(lineno);\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode bitOrExpr()\n+        throws IOException\n+    {\n+        AstNode pn = bitXorExpr();\n+        while (matchToken(Token.BITOR)) {\n+            int opPos = ts.tokenBeg;\n+            int lineno = ts.lineno;\n+            pn = new InfixExpression(Token.BITOR, pn, bitXorExpr(), opPos);\n+            pn.setLineno(lineno);\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode bitXorExpr()\n+        throws IOException\n+    {\n+        AstNode pn = bitAndExpr();\n+        while (matchToken(Token.BITXOR)) {\n+            int opPos = ts.tokenBeg;\n+            int lineno = ts.lineno;\n+            pn = new InfixExpression(Token.BITXOR, pn, bitAndExpr(), opPos);\n+            pn.setLineno(lineno);\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode bitAndExpr()\n+        throws IOException\n+    {\n+        AstNode pn = eqExpr();\n+        while (matchToken(Token.BITAND)) {\n+            int opPos = ts.tokenBeg;\n+            int lineno = ts.lineno;\n+            pn = new InfixExpression(Token.BITAND, pn, eqExpr(), opPos);\n+            pn.setLineno(lineno);\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode eqExpr()\n+        throws IOException\n+    {\n+        AstNode pn = relExpr();\n+        for (;;) {\n+            int tt = peekToken(), opPos = ts.tokenBeg;\n+            int lineno = ts.lineno;\n+            switch (tt) {\n+              case Token.EQ:\n+              case Token.NE:\n+              case Token.SHEQ:\n+              case Token.SHNE:\n+                consumeToken();\n+                int parseToken = tt;\n+                if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {\n+                    // JavaScript 1.2 uses shallow equality for == and != .\n+                    if (tt == Token.EQ)\n+                        parseToken = Token.SHEQ;\n+                    else if (tt == Token.NE)\n+                        parseToken = Token.SHNE;\n+                }\n+                pn = new InfixExpression(parseToken, pn, relExpr(), opPos);\n+                pn.setLineno(lineno);\n+                continue;\n+            }\n+            break;\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode relExpr()\n+        throws IOException\n+    {\n+        AstNode pn = shiftExpr();\n+        for (;;) {\n+            int tt = peekToken(), opPos = ts.tokenBeg;\n+            int line = ts.lineno;\n+            switch (tt) {\n+              case Token.IN:\n+                if (inForInit)\n+                    break;\n+                // fall through\n+              case Token.INSTANCEOF:\n+              case Token.LE:\n+              case Token.LT:\n+              case Token.GE:\n+              case Token.GT:\n+                consumeToken();\n+                pn = new InfixExpression(tt, pn, shiftExpr(), opPos);\n+                pn.setLineno(line);\n+                continue;\n+            }\n+            break;\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode shiftExpr()\n+        throws IOException\n+    {\n+        AstNode pn = addExpr();\n+        for (;;) {\n+            int tt = peekToken(), opPos = ts.tokenBeg;\n+            int lineno = ts.lineno;\n+            switch (tt) {\n+              case Token.LSH:\n+              case Token.URSH:\n+              case Token.RSH:\n+                consumeToken();\n+                pn = new InfixExpression(tt, pn, addExpr(), opPos);\n+                pn.setLineno(lineno);\n+                continue;\n+            }\n+            break;\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode addExpr()\n+        throws IOException\n+    {\n+        AstNode pn = mulExpr();\n+        for (;;) {\n+            int tt = peekToken(), opPos = ts.tokenBeg;\n+            if (tt == Token.ADD || tt == Token.SUB) {\n+                consumeToken();\n+                int lineno = ts.lineno;\n+                pn = new InfixExpression(tt, pn, mulExpr(), opPos);\n+                pn.setLineno(lineno);\n+                continue;\n+            }\n+            break;\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode mulExpr()\n+        throws IOException\n+    {\n+        AstNode pn = unaryExpr();\n+        for (;;) {\n+            int tt = peekToken(), opPos = ts.tokenBeg;\n+            switch (tt) {\n+              case Token.MUL:\n+              case Token.DIV:\n+              case Token.MOD:\n+                consumeToken();\n+                int line = ts.lineno;\n+                pn = new InfixExpression(tt, pn, unaryExpr(), opPos);\n+                pn.setLineno(line);\n+                continue;\n+            }\n+            break;\n+        }\n+        return pn;\n+    }\n+\n+    private AstNode unaryExpr()\n+        throws IOException\n+    {\n+        AstNode node;\n+        int tt = peekToken();\n+        int line = ts.lineno;\n+\n+        switch(tt) {\n+          case Token.VOID:\n+          case Token.NOT:\n+          case Token.BITNOT:\n+          case Token.TYPEOF:\n+              consumeToken();\n+              node = new UnaryExpression(tt, ts.tokenBeg, unaryExpr());\n+              node.setLineno(line);\n+              return node;\n+\n+          case Token.ADD:\n+              consumeToken();\n+              // Convert to special POS token in parse tree\n+              node = new UnaryExpression(Token.POS, ts.tokenBeg, unaryExpr());\n+              node.setLineno(line);\n+              return node;\n+\n+          case Token.SUB:\n+              consumeToken();\n+              // Convert to special NEG token in parse tree\n+              node = new UnaryExpression(Token.NEG, ts.tokenBeg, unaryExpr());\n+              node.setLineno(line);\n+              return node;\n+\n+          case Token.INC:\n+          case Token.DEC:\n+              consumeToken();\n+              UnaryExpression expr = new UnaryExpression(tt, ts.tokenBeg,\n+                                                         memberExpr(true));\n+              expr.setLineno(line);\n+              checkBadIncDec(expr);\n+              return expr;\n+\n+          case Token.DELPROP:\n+              consumeToken();\n+              node = new UnaryExpression(tt, ts.tokenBeg, unaryExpr());\n+              node.setLineno(line);\n+              return node;\n+\n+          case Token.ERROR:\n+              consumeToken();\n+              return makeErrorNode();\n+\n+          case Token.LT:\n+              // XML stream encountered in expression.\n+              if (compilerEnv.isXmlAvailable()) {\n+                  consumeToken();\n+                  return memberExprTail(true, xmlInitializer());\n+              }\n+              // Fall thru to the default handling of RELOP\n+\n+          default:\n+              AstNode pn = memberExpr(true);\n+              // Don't look across a newline boundary for a postfix incop.\n+              tt = peekTokenOrEOL();\n+              if (!(tt == Token.INC || tt == Token.DEC)) {\n+                  return pn;\n+              }\n+              consumeToken();\n+              UnaryExpression uexpr =\n+                      new UnaryExpression(tt, ts.tokenBeg, pn, true);\n+              uexpr.setLineno(line);\n+              checkBadIncDec(uexpr);\n+              return uexpr;\n+        }\n+    }\n+\n+    private AstNode xmlInitializer()\n+        throws IOException\n+    {\n+        if (currentToken != Token.LT) codeBug();\n+        int pos = ts.tokenBeg, tt = ts.getFirstXMLToken();\n+        if (tt != Token.XML && tt != Token.XMLEND) {\n+            reportError(\"msg.syntax\");\n+            return makeErrorNode();\n+        }\n+\n+        XmlLiteral pn = new XmlLiteral(pos);\n+        pn.setLineno(ts.lineno);\n+\n+        for (;;tt = ts.getNextXMLToken()) {\n+            switch (tt) {\n+              case Token.XML:\n+                  pn.addFragment(new XmlString(ts.tokenBeg, ts.getString()));\n+                  mustMatchToken(Token.LC, \"msg.syntax\");\n+                  int beg = ts.tokenBeg;\n+                  AstNode expr = (peekToken() == Token.RC)\n+                                 ? new EmptyExpression(beg, ts.tokenEnd - beg)\n+                                 : expr();\n+                  mustMatchToken(Token.RC, \"msg.syntax\");\n+                  XmlExpression xexpr = new XmlExpression(beg, expr);\n+                  xexpr.setIsXmlAttribute(ts.isXMLAttribute());\n+                  xexpr.setLength(ts.tokenEnd - beg);\n+                  pn.addFragment(xexpr);\n+                  break;\n+\n+              case Token.XMLEND:\n+                  pn.addFragment(new XmlString(ts.tokenBeg, ts.getString()));\n+                  return pn;\n+\n+              default:\n+                  reportError(\"msg.syntax\");\n+                  return makeErrorNode();\n+            }\n+        }\n+    }\n+\n+    private List<AstNode> argumentList()\n+        throws IOException\n+    {\n+        if (matchToken(Token.RP))\n+            return null;\n+\n+        List<AstNode> result = new ArrayList<AstNode>();\n+        boolean wasInForInit = inForInit;\n+        inForInit = false;\n+        try {\n+            do {\n+                if (peekToken() == Token.YIELD)\n+                    reportError(\"msg.yield.parenthesized\");\n+                result.add(assignExpr());\n+            } while (matchToken(Token.COMMA));\n+        } finally {\n+            inForInit = wasInForInit;\n+        }\n+\n+        mustMatchToken(Token.RP, \"msg.no.paren.arg\");\n+        return result;\n+    }\n+\n+    /**\n+     * Parse a new-expression, or if next token isn't {@link Token#NEW},\n+     * a primary expression.\n+     * @param allowCallSyntax passed down to {@link #memberExprTail}\n+     */\n+    private AstNode memberExpr(boolean allowCallSyntax)\n+        throws IOException\n+    {\n+        int tt = peekToken(), lineno = ts.lineno;\n+        AstNode pn;\n+\n+        if (tt != Token.NEW) {\n+            pn = primaryExpr();\n+        } else {\n+            consumeToken();\n+            int pos = ts.tokenBeg;\n+            NewExpression nx = new NewExpression(pos);\n+\n+            AstNode target = memberExpr(false);\n+            int end = getNodeEnd(target);\n+            nx.setTarget(target);\n+\n+            int lp = -1;\n+            if (matchToken(Token.LP)) {\n+                lp = ts.tokenBeg;\n+                List<AstNode> args = argumentList();\n+                if (args != null && args.size() > ARGC_LIMIT)\n+                    reportError(\"msg.too.many.constructor.args\");\n+                int rp = ts.tokenBeg;\n+                end = ts.tokenEnd;\n+                if (args != null)\n+                    nx.setArguments(args);\n+                nx.setParens(lp - pos, rp - pos);\n+            }\n+\n+            // Experimental syntax: allow an object literal to follow a new\n+            // expression, which will mean a kind of anonymous class built with\n+            // the JavaAdapter.  the object literal will be passed as an\n+            // additional argument to the constructor.\n+            if (matchToken(Token.LC)) {\n+                ObjectLiteral initializer = objectLiteral();\n+                end = getNodeEnd(initializer);\n+                nx.setInitializer(initializer);\n+            }\n+            nx.setLength(end - pos);\n+            pn = nx;\n+        }\n+        pn.setLineno(lineno);\n+        AstNode tail = memberExprTail(allowCallSyntax, pn);\n+        return tail;\n+    }\n+\n+    /**\n+     * Parse any number of \"(expr)\", \"[expr]\" \".expr\", \"..expr\",\n+     * or \".(expr)\" constructs trailing the passed expression.\n+     * @param pn the non-null parent node\n+     * @return the outermost (lexically last occurring) expression,\n+     * which will have the passed parent node as a descendant\n+     */\n+    private AstNode memberExprTail(boolean allowCallSyntax, AstNode pn)\n+        throws IOException\n+    {\n+        // we no longer return null for errors, so this won't be null\n+        if (pn == null) codeBug();\n+        int pos = pn.getPosition();\n+        int lineno;\n+      tailLoop:\n+        for (;;) {\n+            int tt = peekToken();\n+            switch (tt) {\n+              case Token.DOT:\n+              case Token.DOTDOT:\n+                  lineno = ts.lineno;\n+                  pn = propertyAccess(tt, pn);\n+                  pn.setLineno(lineno);\n+                  break;\n+\n+              case Token.DOTQUERY:\n+                  consumeToken();\n+                  int opPos = ts.tokenBeg, rp = -1;\n+                  lineno = ts.lineno;\n+                  mustHaveXML();\n+                  setRequiresActivation();\n+                  AstNode filter = expr();\n+                  int end = getNodeEnd(filter);\n+                  if (mustMatchToken(Token.RP, \"msg.no.paren\")) {\n+                      rp = ts.tokenBeg;\n+                      end = ts.tokenEnd;\n+                  }\n+                  XmlDotQuery q = new XmlDotQuery(pos, end - pos);\n+                  q.setLeft(pn);\n+                  q.setRight(filter);\n+                  q.setOperatorPosition(opPos);\n+                  q.setRp(rp - pos);\n+                  q.setLineno(lineno);\n+                  pn = q;\n+                  break;\n+\n+              case Token.LB:\n+                  consumeToken();\n+                  int lb = ts.tokenBeg, rb = -1;\n+                  lineno = ts.lineno;\n+                  AstNode expr = expr();\n+                  end = getNodeEnd(expr);\n+                  if (mustMatchToken(Token.RB, \"msg.no.bracket.index\")) {\n+                      rb = ts.tokenBeg;\n+                      end = ts.tokenEnd;\n+                  }\n+                  ElementGet g = new ElementGet(pos, end - pos);\n+                  g.setTarget(pn);\n+                  g.setElement(expr);\n+                  g.setParens(lb, rb);\n+                  g.setLineno(lineno);\n+                  pn = g;\n+                  break;\n+\n+              case Token.LP:\n+                  if (!allowCallSyntax) {\n+                      break tailLoop;\n+                  }\n+                  lineno = ts.lineno;\n+                  consumeToken();\n+                  checkCallRequiresActivation(pn);\n+                  FunctionCall f = new FunctionCall(pos);\n+                  f.setTarget(pn);\n+                  // Assign the line number for the function call to where\n+                  // the paren appeared, not where the name expression started.\n+                  f.setLineno(lineno);\n+                  f.setLp(ts.tokenBeg - pos);\n+                  List<AstNode> args = argumentList();\n+                  if (args != null && args.size() > ARGC_LIMIT)\n+                      reportError(\"msg.too.many.function.args\");\n+                  f.setArguments(args);\n+                  f.setRp(ts.tokenBeg - pos);\n+                  f.setLength(ts.tokenEnd - pos);\n+                  pn = f;\n+                  break;\n+\n+              default:\n+                  break tailLoop;\n+            }\n+        }\n+        return pn;\n+    }\n+\n+    /**\n+     * Handles any construct following a \".\" or \"..\" operator.\n+     * @param pn the left-hand side (target) of the operator.  Never null.\n+     * @return a PropertyGet, XmlMemberGet, or ErrorNode\n+     */\n+    private AstNode propertyAccess(int tt, AstNode pn)\n+            throws IOException\n+    {\n+        if (pn == null) codeBug();\n+        int memberTypeFlags = 0, lineno = ts.lineno, dotPos = ts.tokenBeg;\n+        consumeToken();\n+\n+        if (tt == Token.DOTDOT) {\n+            mustHaveXML();\n+            memberTypeFlags = Node.DESCENDANTS_FLAG;\n+        }\n+\n+        if (!compilerEnv.isXmlAvailable()) {\n+            int maybeName = nextToken();\n+            if (maybeName != Token.NAME &&\n+                !(compilerEnv.isAllowKeywordAsObjectPropertyName()\n+                && TokenStream.isKeyword(ts.getString()))) {\n+              reportError(\"msg.no.name.after.dot\");\n+            }\n+\n+            Name name = createNameNode(true, Token.GETPROP);\n+            PropertyGet pg = new PropertyGet(pn, name, dotPos);\n+            pg.setLineno(lineno);\n+            return pg;\n+        }\n+\n+        AstNode ref = null;  // right side of . or .. operator\n+\n+        switch (nextToken()) {\n+          case Token.THROW:\n+              // needed for generator.throw();\n+              saveNameTokenData(ts.tokenBeg, \"throw\", ts.lineno);\n+              ref = propertyName(-1, \"throw\", memberTypeFlags);\n+              break;\n+\n+          case Token.NAME:\n+              // handles: name, ns::name, ns::*, ns::[expr]\n+              ref = propertyName(-1, ts.getString(), memberTypeFlags);\n+              break;\n+\n+          case Token.MUL:\n+              // handles: *, *::name, *::*, *::[expr]\n+              saveNameTokenData(ts.tokenBeg, \"*\", ts.lineno);\n+              ref = propertyName(-1, \"*\", memberTypeFlags);\n+              break;\n+\n+          case Token.XMLATTR:\n+              // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',\n+              //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'\n+              ref = attributeAccess();\n+              break;\n+\n+          default:\n+              if (compilerEnv.isAllowKeywordAsObjectPropertyName()\n+                  && TokenStream.isKeyword(ts.getString())) {\n+                ref = propertyName(-1, ts.getString(), memberTypeFlags);\n+              } else {\n+                reportError(\"msg.no.name.after.dot\");\n+                return makeErrorNode();\n+              }\n+        }\n+\n+        boolean xml = ref instanceof XmlRef;\n+        InfixExpression result = xml ? new XmlMemberGet() : new PropertyGet();\n+        if (xml && tt == Token.DOT)\n+            result.setType(Token.DOT);\n+        int pos = pn.getPosition();\n+        result.setPosition(pos);\n+        result.setLength(getNodeEnd(ref) - pos);\n+        result.setOperatorPosition(dotPos - pos);\n+        result.setLineno(lineno);\n+        result.setLeft(pn);  // do this after setting position\n+        result.setRight(ref);\n+        return result;\n+    }\n+\n+    /**\n+     * Xml attribute expression:<p>\n+     *   {@code @attr}, {@code @ns::attr}, {@code @ns::*}, {@code @ns::*},\n+     *   {@code @*}, {@code @*::attr}, {@code @*::*}, {@code @ns::[expr]},\n+     *   {@code @*::[expr]}, {@code @[expr]} <p>\n+     * Called if we peeked an '@' token.\n+     */\n+    private AstNode attributeAccess()\n+        throws IOException\n+    {\n+        int tt = nextToken(), atPos = ts.tokenBeg;\n+\n+        switch (tt) {\n+          // handles: @name, @ns::name, @ns::*, @ns::[expr]\n+          case Token.NAME:\n+              return propertyName(atPos, ts.getString(), 0);\n+\n+          // handles: @*, @*::name, @*::*, @*::[expr]\n+          case Token.MUL:\n+              saveNameTokenData(ts.tokenBeg, \"*\", ts.lineno);\n+              return propertyName(atPos, \"*\", 0);\n+\n+          // handles @[expr]\n+          case Token.LB:\n+              return xmlElemRef(atPos, null, -1);\n+\n+          default:\n+              reportError(\"msg.no.name.after.xmlAttr\");\n+              return makeErrorNode();\n+        }\n+    }\n+\n+    /**\n+     * Check if :: follows name in which case it becomes a qualified name.\n+     *\n+     * @param atPos a natural number if we just read an '@' token, else -1\n+     *\n+     * @param s the name or string that was matched (an identifier, \"throw\" or\n+     * \"*\").\n+     *\n+     * @param memberTypeFlags flags tracking whether we're a '.' or '..' child\n+     *\n+     * @return an XmlRef node if it's an attribute access, a child of a\n+     * '..' operator, or the name is followed by ::.  For a plain name,\n+     * returns a Name node.  Returns an ErrorNode for malformed XML\n+     * expressions.  (For now - might change to return a partial XmlRef.)\n+     */\n+    private AstNode propertyName(int atPos, String s, int memberTypeFlags)\n+        throws IOException\n+    {\n+        int pos = atPos != -1 ? atPos : ts.tokenBeg, lineno = ts.lineno;\n+        int colonPos = -1;\n+        Name name = createNameNode(true, currentToken);\n+        Name ns = null;\n+\n+        if (matchToken(Token.COLONCOLON)) {\n+            ns = name;\n+            colonPos = ts.tokenBeg;\n+\n+            switch (nextToken()) {\n+              // handles name::name\n+              case Token.NAME:\n+                  name = createNameNode();\n+                  break;\n+\n+              // handles name::*\n+              case Token.MUL:\n+                  saveNameTokenData(ts.tokenBeg, \"*\", ts.lineno);\n+                  name = createNameNode(false, -1);\n+                  break;\n+\n+              // handles name::[expr] or *::[expr]\n+              case Token.LB:\n+                  return xmlElemRef(atPos, ns, colonPos);\n+\n+              default:\n+                  reportError(\"msg.no.name.after.coloncolon\");\n+                  return makeErrorNode();\n+            }\n+        }\n+\n+        if (ns == null && memberTypeFlags == 0 && atPos == -1) {\n+            return name;\n+        }\n+\n+        XmlPropRef ref = new XmlPropRef(pos, getNodeEnd(name) - pos);\n+        ref.setAtPos(atPos);\n+        ref.setNamespace(ns);\n+        ref.setColonPos(colonPos);\n+        ref.setPropName(name);\n+        ref.setLineno(lineno);\n+        return ref;\n+    }\n+\n+    /**\n+     * Parse the [expr] portion of an xml element reference, e.g.\n+     * @[expr], @*::[expr], or ns::[expr].\n+     */\n+    private XmlElemRef xmlElemRef(int atPos, Name namespace, int colonPos)\n+        throws IOException\n+    {\n+        int lb = ts.tokenBeg, rb = -1, pos = atPos != -1 ? atPos : lb;\n+        AstNode expr = expr();\n+        int end = getNodeEnd(expr);\n+        if (mustMatchToken(Token.RB, \"msg.no.bracket.index\")) {\n+            rb = ts.tokenBeg;\n+            end = ts.tokenEnd;\n+        }\n+        XmlElemRef ref = new XmlElemRef(pos, end - pos);\n+        ref.setNamespace(namespace);\n+        ref.setColonPos(colonPos);\n+        ref.setAtPos(atPos);\n+        ref.setExpression(expr);\n+        ref.setBrackets(lb, rb);\n+        return ref;\n+    }\n+\n+    private AstNode destructuringPrimaryExpr()\n+        throws IOException, ParserException\n+    {\n+        try {\n+            inDestructuringAssignment = true;\n+            return primaryExpr();\n+        } finally {\n+            inDestructuringAssignment = false;\n+        }\n+    }\n+\n+    private AstNode primaryExpr()\n+        throws IOException\n+    {\n+        int ttFlagged = nextFlaggedToken();\n+        int tt = ttFlagged & CLEAR_TI_MASK;\n+\n+        switch(tt) {\n+          case Token.FUNCTION:\n+              return function(FunctionNode.FUNCTION_EXPRESSION);\n+\n+          case Token.LB:\n+              return arrayLiteral();\n+\n+          case Token.LC:\n+              return objectLiteral();\n+\n+          case Token.LET:\n+              return let(false, ts.tokenBeg);\n+\n+          case Token.LP:\n+              return parenExpr();\n+\n+          case Token.XMLATTR:\n+              mustHaveXML();\n+              return attributeAccess();\n+\n+          case Token.NAME:\n+              return name(ttFlagged, tt);\n+\n+          case Token.NUMBER: {\n+              String s = ts.getString();\n+              if (this.inUseStrictDirective && ts.isNumberOctal()) {\n+                  reportError(\"msg.no.octal.strict\");\n+              }\n+              return new NumberLiteral(ts.tokenBeg,\n+                                       s,\n+                                       ts.getNumber());\n+          }\n+\n+          case Token.STRING:\n+              return createStringLiteral();\n+\n+          case Token.DIV:\n+          case Token.ASSIGN_DIV:\n+              // Got / or /= which in this context means a regexp\n+              ts.readRegExp(tt);\n+              int pos = ts.tokenBeg, end = ts.tokenEnd;\n+              RegExpLiteral re = new RegExpLiteral(pos, end - pos);\n+              re.setValue(ts.getString());\n+              re.setFlags(ts.readAndClearRegExpFlags());\n+              return re;\n+\n+          case Token.NULL:\n+          case Token.THIS:\n+          case Token.FALSE:\n+          case Token.TRUE:\n+              pos = ts.tokenBeg; end = ts.tokenEnd;\n+              return new KeywordLiteral(pos, end - pos, tt);\n+\n+          case Token.RESERVED:\n+              reportError(\"msg.reserved.id\");\n+              break;\n+\n+          case Token.ERROR:\n+              // the scanner or one of its subroutines reported the error.\n+              break;\n+\n+          case Token.EOF:\n+              reportError(\"msg.unexpected.eof\");\n+              break;\n+\n+          default:\n+              reportError(\"msg.syntax\");\n+              break;\n+        }\n+        // should only be reachable in IDE/error-recovery mode\n+        return makeErrorNode();\n+    }\n+\n+    private AstNode parenExpr() throws IOException {\n+        boolean wasInForInit = inForInit;\n+        inForInit = false;\n+        try {\n+            Comment jsdocNode = getAndResetJsDoc();\n+            int lineno = ts.lineno;\n+            AstNode e = expr();\n+            ParenthesizedExpression pn = new ParenthesizedExpression(e);\n+            if (jsdocNode == null) {\n+                jsdocNode = getAndResetJsDoc();\n+            }\n+            if (jsdocNode != null) {\n+                pn.setJsDocNode(jsdocNode);\n+            }\n+            mustMatchToken(Token.RP, \"msg.no.paren\");\n+            pn.setLength(ts.tokenEnd - pn.getPosition());\n+            pn.setLineno(lineno);\n+            return pn;\n+        } finally {\n+            inForInit = wasInForInit;\n+        }\n+    }\n+\n+    private AstNode name(int ttFlagged, int tt) throws IOException {\n+        String nameString = ts.getString();\n+        int namePos = ts.tokenBeg, nameLineno = ts.lineno;\n+        if (0 != (ttFlagged & TI_CHECK_LABEL) && peekToken() == Token.COLON) {\n+            // Do not consume colon.  It is used as an unwind indicator\n+            // to return to statementHelper.\n+            Label label = new Label(namePos, ts.tokenEnd - namePos);\n+            label.setName(nameString);\n+            label.setLineno(ts.lineno);\n+            return label;\n+        }\n+        // Not a label.  Unfortunately peeking the next token to check for\n+        // a colon has biffed ts.tokenBeg, ts.tokenEnd.  We store the name's\n+        // bounds in instance vars and createNameNode uses them.\n+        saveNameTokenData(namePos, nameString, nameLineno);\n+\n+        if (compilerEnv.isXmlAvailable()) {\n+            return propertyName(-1, nameString, 0);\n+        } else {\n+            return createNameNode(true, Token.NAME);\n+        }\n+    }\n+\n+    /**\n+     * May return an {@link ArrayLiteral} or {@link ArrayComprehension}.\n+     */\n+    private AstNode arrayLiteral()\n+        throws IOException\n+    {\n+        if (currentToken != Token.LB) codeBug();\n+        int pos = ts.tokenBeg, end = ts.tokenEnd;\n+        List<AstNode> elements = new ArrayList<AstNode>();\n+        ArrayLiteral pn = new ArrayLiteral(pos);\n+        boolean after_lb_or_comma = true;\n+        int afterComma = -1;\n+        int skipCount = 0;\n+        for (;;) {\n+            int tt = peekToken();\n+            if (tt == Token.COMMA) {\n+                consumeToken();\n+                afterComma = ts.tokenEnd;\n+                if (!after_lb_or_comma) {\n+                    after_lb_or_comma = true;\n+                } else {\n+                    elements.add(new EmptyExpression(ts.tokenBeg, 1));\n+                    skipCount++;\n+                }\n+            } else if (tt == Token.RB) {\n+                consumeToken();\n+                // for ([a,] in obj) is legal, but for ([a] in obj) is\n+                // not since we have both key and value supplied. The\n+                // trick is that [a,] and [a] are equivalent in other\n+                // array literal contexts. So we calculate a special\n+                // length value just for destructuring assignment.\n+                end = ts.tokenEnd;\n+                pn.setDestructuringLength(elements.size() +\n+                                          (after_lb_or_comma ? 1 : 0));\n+                pn.setSkipCount(skipCount);\n+                if (afterComma != -1)\n+                    warnTrailingComma(\"msg.array.trailing.comma\",\n+                                      pos, elements, afterComma);\n+                break;\n+            } else if (tt == Token.FOR && !after_lb_or_comma\n+                       && elements.size() == 1) {\n+                return arrayComprehension(elements.get(0), pos);\n+            } else if (tt == Token.EOF) {\n+                end = ts.tokenBeg;\n+                break;\n+            } else {\n+                if (!after_lb_or_comma) {\n+                    reportError(\"msg.no.bracket.arg\");\n+                }\n+                elements.add(assignExpr());\n+                after_lb_or_comma = false;\n+                afterComma = -1;\n+            }\n+        }\n+        for (AstNode e : elements) {\n+            pn.addElement(e);\n+        }\n+        pn.setLength(end - pos);\n+        return pn;\n+    }\n+\n+    /**\n+     * Parse a JavaScript 1.7 Array comprehension.\n+     * @param result the first expression after the opening left-bracket\n+     * @param pos start of LB token that begins the array comprehension\n+     * @return the array comprehension or an error node\n+     */\n+    private AstNode arrayComprehension(AstNode result, int pos)\n+        throws IOException\n+    {\n+        List<ArrayComprehensionLoop> loops =\n+                new ArrayList<ArrayComprehensionLoop>();\n+        while (peekToken() == Token.FOR) {\n+            loops.add(arrayComprehensionLoop());\n+        }\n+        int ifPos = -1;\n+        ConditionData data = null;\n+        if (peekToken() == Token.IF) {\n+            consumeToken();\n+            ifPos = ts.tokenBeg - pos;\n+            data = condition();\n+        }\n+        mustMatchToken(Token.RB, \"msg.no.bracket.arg\");\n+        ArrayComprehension pn = new ArrayComprehension(pos, ts.tokenEnd - pos);\n+        pn.setResult(result);\n+        pn.setLoops(loops);\n+        if (data != null) {\n+            pn.setIfPosition(ifPos);\n+            pn.setFilter(data.condition);\n+            pn.setFilterLp(data.lp - pos);\n+            pn.setFilterRp(data.rp - pos);\n+        }\n+        return pn;\n+    }\n+\n+    private ArrayComprehensionLoop arrayComprehensionLoop()\n+        throws IOException\n+    {\n+        if (nextToken() != Token.FOR) codeBug();\n+        int pos = ts.tokenBeg;\n+        int eachPos = -1, lp = -1, rp = -1, inPos = -1;\n+        ArrayComprehensionLoop pn = new ArrayComprehensionLoop(pos);\n+\n+        pushScope(pn);\n+        try {\n+            if (matchToken(Token.NAME)) {\n+                if (ts.getString().equals(\"each\")) {\n+                    eachPos = ts.tokenBeg - pos;\n+                } else {\n+                    reportError(\"msg.no.paren.for\");\n+                }\n+            }\n+            if (mustMatchToken(Token.LP, \"msg.no.paren.for\")) {\n+                lp = ts.tokenBeg - pos;\n+            }\n+\n+            AstNode iter = null;\n+            switch (peekToken()) {\n+              case Token.LB:\n+              case Token.LC:\n+                  // handle destructuring assignment\n+                  iter = destructuringPrimaryExpr();\n+                  markDestructuring(iter);\n+                  break;\n+              case Token.NAME:\n+                  consumeToken();\n+                  iter = createNameNode();\n+                  break;\n+              default:\n+                  reportError(\"msg.bad.var\");\n+            }\n+\n+            // Define as a let since we want the scope of the variable to\n+            // be restricted to the array comprehension\n+            if (iter.getType() == Token.NAME) {\n+                defineSymbol(Token.LET, ts.getString(), true);\n+            }\n+\n+            if (mustMatchToken(Token.IN, \"msg.in.after.for.name\"))\n+                inPos = ts.tokenBeg - pos;\n+            AstNode obj = expr();\n+            if (mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\"))\n+                rp = ts.tokenBeg - pos;\n+\n+            pn.setLength(ts.tokenEnd - pos);\n+            pn.setIterator(iter);\n+            pn.setIteratedObject(obj);\n+            pn.setInPosition(inPos);\n+            pn.setEachPosition(eachPos);\n+            pn.setIsForEach(eachPos != -1);\n+            pn.setParens(lp, rp);\n+            return pn;\n+        } finally {\n+            popScope();\n+        }\n+    }\n+\n+    private ObjectLiteral objectLiteral()\n+        throws IOException\n+    {\n+        int pos = ts.tokenBeg, lineno = ts.lineno;\n+        int afterComma = -1;\n+        List<ObjectProperty> elems = new ArrayList<ObjectProperty>();\n+        Set<String> propertyNames = new HashSet<String>();\n+        Comment objJsdocNode = getAndResetJsDoc();\n+\n+      commaLoop:\n+        for (;;) {\n+            String propertyName = null;\n+            int tt = peekToken();\n+            Comment jsdocNode = getAndResetJsDoc();\n+            switch(tt) {\n+              case Token.NAME:\n+                  afterComma = -1;\n+                  Name name = createNameNode();\n+                  propertyName = ts.getString();\n+                  int ppos = ts.tokenBeg;\n+                  consumeToken();\n+\n+                  if ((peekToken() != Token.COLON\n+                      && (\"get\".equals(propertyName)\n+                          || \"set\".equals(propertyName))))\n+                  {\n+                      boolean isGet = \"get\".equals(propertyName);\n+                      AstNode pname = objliteralProperty();\n+                      if (pname == null) {\n+                        propertyName = null;\n+                      } else {\n+                        propertyName = ts.getString();\n+                        ObjectProperty objectProp = getterSetterProperty(\n+                              ppos, pname, isGet);\n+                        pname.setJsDocNode(jsdocNode);\n+                        elems.add(objectProp);\n+                      }\n+                  } else {\n+                      AstNode pname = name;\n+                      pname.setJsDocNode(jsdocNode);\n+                      elems.add(plainProperty(pname, tt));\n+                  }\n+                  break;\n+\n+              case Token.RC:\n+                  if (afterComma != -1 && compilerEnv.getWarnTrailingComma())\n+                      warnTrailingComma(\"msg.extra.trailing.comma\",\n+                                        pos, elems, afterComma);\n+                  break commaLoop;\n+\n+              default:\n+                  AstNode pname = objliteralProperty();\n+                  if (pname == null) {\n+                    propertyName = null;\n+                  } else {\n+                    afterComma = -1;\n+                    propertyName = ts.getString();\n+                    pname.setJsDocNode(jsdocNode);\n+                    elems.add(plainProperty(pname, tt));\n+                  }\n+                  break;\n+            }\n+\n+            if (this.inUseStrictDirective) {\n+                if (propertyNames.contains(propertyName)) {\n+                    addError(\"msg.dup.obj.lit.prop.strict\", propertyName);\n+                }\n+                propertyNames.add(propertyName);\n+            }\n+\n+            // Eat any dangling jsdoc in the property.\n+            getAndResetJsDoc();\n+            jsdocNode = null;\n+\n+            if (matchToken(Token.COMMA)) {\n+                afterComma = ts.tokenEnd;\n+            } else {\n+                break commaLoop;\n+            }\n+        }\n+\n+        mustMatchToken(Token.RC, \"msg.no.brace.prop\");\n+        ObjectLiteral pn = new ObjectLiteral(pos, ts.tokenEnd - pos);\n+        if (objJsdocNode != null) {\n+            pn.setJsDocNode(objJsdocNode);\n+        }\n+        pn.setElements(elems);\n+        pn.setLineno(lineno);\n+        return pn;\n+    }\n+\n+    private AstNode objliteralProperty() throws IOException {\n+        AstNode pname;\n+        int tt = peekToken();\n+        // Comment jsdocNode = getAndResetJsDoc();\n+        switch(tt) {\n+          case Token.NAME:\n+              pname = createNameNode();\n+              break;\n+\n+          case Token.STRING:\n+              pname = createStringLiteral();\n+              break;\n+\n+          case Token.NUMBER:\n+              pname = new NumberLiteral(\n+                  ts.tokenBeg, ts.getString(), ts.getNumber());\n+              break;\n+\n+          default:\n+              if (compilerEnv.isAllowKeywordAsObjectPropertyName()\n+                  && TokenStream.isKeyword(ts.getString())) {\n+                pname = createNameNode();\n+              } else {\n+                reportError(\"msg.bad.prop\");\n+                return null;\n+              }\n+              break;\n+        }\n+\n+        // pname.setJsDocNode(jsdocNode);\n+        consumeToken();\n+        return pname;\n+    }\n+\n+    private ObjectProperty plainProperty(AstNode property, int ptt)\n+        throws IOException\n+    {\n+        // Support, e.g., |var {x, y} = o| as destructuring shorthand\n+        // for |var {x: x, y: y} = o|, as implemented in spidermonkey JS 1.8.\n+        int tt = peekToken();\n+        if ((tt == Token.COMMA || tt == Token.RC) && ptt == Token.NAME\n+                && compilerEnv.getLanguageVersion() >= Context.VERSION_1_8) {\n+            if (!inDestructuringAssignment) {\n+                reportError(\"msg.bad.object.init\");\n+            }\n+            AstNode nn = new Name(property.getPosition(), property.getString());\n+            ObjectProperty pn = new ObjectProperty();\n+            pn.putProp(Node.DESTRUCTURING_SHORTHAND, Boolean.TRUE);\n+            pn.setLeftAndRight(property, nn);\n+            return pn;\n+        }\n+        mustMatchToken(Token.COLON, \"msg.no.colon.prop\");\n+        ObjectProperty pn = new ObjectProperty();\n+        pn.setOperatorPosition(ts.tokenBeg);\n+        pn.setLeftAndRight(property, assignExpr());\n+        return pn;\n+    }\n+\n+    private ObjectProperty getterSetterProperty(int pos, AstNode propName,\n+                                                boolean isGetter)\n+        throws IOException\n+    {\n+        FunctionNode fn = function(FunctionNode.FUNCTION_EXPRESSION);\n+        // We've already parsed the function name, so fn should be anonymous.\n+        Name name = fn.getFunctionName();\n+        if (name != null && name.length() != 0) {\n+            reportError(\"msg.bad.prop\");\n+        }\n+        ObjectProperty pn = new ObjectProperty(pos);\n+        if (isGetter) {\n+            pn.setIsGetter();\n+        } else {\n+            pn.setIsSetter();\n+        }\n+        int end = getNodeEnd(fn);\n+        pn.setLeft(propName);\n+        pn.setRight(fn);\n+        pn.setLength(end - pos);\n+        return pn;\n+    }\n+\n+    private Name createNameNode() {\n+        return createNameNode(false, Token.NAME);\n+    }\n+\n+    /**\n+     * Create a {@code Name} node using the token info from the\n+     * last scanned name.  In some cases we need to either synthesize\n+     * a name node, or we lost the name token information by peeking.\n+     * If the {@code token} parameter is not {@link Token#NAME}, then\n+     * we use token info saved in instance vars.\n+     */\n+    private Name createNameNode(boolean checkActivation, int token) {\n+        int beg = ts.tokenBeg;\n+        String s = ts.getString();\n+        int lineno = ts.lineno;\n+        if (!\"\".equals(prevNameTokenString)) {\n+            beg = prevNameTokenStart;\n+            s = prevNameTokenString;\n+            lineno = prevNameTokenLineno;\n+            prevNameTokenStart = 0;\n+            prevNameTokenString = \"\";\n+            prevNameTokenLineno = 0;\n+        }\n+        if (s == null) {\n+            if (compilerEnv.isIdeMode()) {\n+                s = \"\";\n+            } else {\n+                codeBug();\n+            }\n+        }\n+        Name name = new Name(beg, s);\n+        name.setLineno(lineno);\n+        if (checkActivation) {\n+            checkActivationName(s, token);\n+        }\n+        return name;\n+    }\n+\n+    private StringLiteral createStringLiteral() {\n+        int pos = ts.tokenBeg, end = ts.tokenEnd;\n+        StringLiteral s = new StringLiteral(pos, end - pos);\n+        s.setLineno(ts.lineno);\n+        s.setValue(ts.getString());\n+        s.setQuoteCharacter(ts.getQuoteChar());\n+        return s;\n+    }\n+\n+    protected void checkActivationName(String name, int token) {\n+        if (!insideFunction()) {\n+            return;\n+        }\n+        boolean activation = false;\n+        if (\"arguments\".equals(name)\n+            || (compilerEnv.getActivationNames() != null\n+                && compilerEnv.getActivationNames().contains(name)))\n+        {\n+            activation = true;\n+        } else if (\"length\".equals(name)) {\n+            if (token == Token.GETPROP\n+                && compilerEnv.getLanguageVersion() == Context.VERSION_1_2)\n+            {\n+                // Use of \"length\" in 1.2 requires an activation object.\n+                activation = true;\n+            }\n+        }\n+        if (activation) {\n+            setRequiresActivation();\n+        }\n+    }\n+\n+    protected void setRequiresActivation() {\n+        if (insideFunction()) {\n+            ((FunctionNode)currentScriptOrFn).setRequiresActivation();\n+        }\n+    }\n+\n+    private void checkCallRequiresActivation(AstNode pn) {\n+        if ((pn.getType() == Token.NAME\n+             && \"eval\".equals(((Name)pn).getIdentifier()))\n+            || (pn.getType() == Token.GETPROP &&\n+                \"eval\".equals(((PropertyGet)pn).getProperty().getIdentifier())))\n+            setRequiresActivation();\n+    }\n+\n+    protected void setIsGenerator() {\n+        if (insideFunction()) {\n+            ((FunctionNode)currentScriptOrFn).setIsGenerator();\n+        }\n+    }\n+\n+    private void checkBadIncDec(UnaryExpression expr) {\n+        AstNode op = removeParens(expr.getOperand());\n+        int tt = op.getType();\n+        if (!(tt == Token.NAME\n+              || tt == Token.GETPROP\n+              || tt == Token.GETELEM\n+              || tt == Token.GET_REF\n+              || tt == Token.CALL))\n+            reportError(expr.getType() == Token.INC\n+                        ? \"msg.bad.incr\"\n+                        : \"msg.bad.decr\");\n+    }\n+\n+    private ErrorNode makeErrorNode() {\n+        ErrorNode pn = new ErrorNode(ts.tokenBeg, ts.tokenEnd - ts.tokenBeg);\n+        pn.setLineno(ts.lineno);\n+        return pn;\n+    }\n+\n+    // Return end of node.  Assumes node does NOT have a parent yet.\n+    private int nodeEnd(AstNode node) {\n+        return node.getPosition() + node.getLength();\n+    }\n+\n+    private void saveNameTokenData(int pos, String name, int lineno) {\n+        prevNameTokenStart = pos;\n+        prevNameTokenString = name;\n+        prevNameTokenLineno = lineno;\n+    }\n+\n+    /**\n+     * Return the file offset of the beginning of the input source line\n+     * containing the passed position.\n+     *\n+     * @param pos an offset into the input source stream.  If the offset\n+     * is negative, it's converted to 0, and if it's beyond the end of\n+     * the source buffer, the last source position is used.\n+     *\n+     * @return the offset of the beginning of the line containing pos\n+     * (i.e. 1+ the offset of the first preceding newline).  Returns -1\n+     * if the {@link CompilerEnvirons} is not set to ide-mode,\n+     * and {@link #parse(java.io.Reader,String,int)} was used.\n+     */\n+    private int lineBeginningFor(int pos) {\n+        if (sourceChars == null) {\n+            return -1;\n+        }\n+        if (pos <= 0) {\n+            return 0;\n+        }\n+        char[] buf = sourceChars;\n+        if (pos >= buf.length) {\n+            pos = buf.length - 1;\n+        }\n+        while (--pos >= 0) {\n+            char c = buf[pos];\n+            if (c == '\\n' || c == '\\r') {\n+                return pos + 1; // want position after the newline\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private void warnMissingSemi(int pos, int end) {\n+        // Should probably change this to be a CompilerEnvirons setting,\n+        // with an enum Never, Always, Permissive, where Permissive means\n+        // don't warn for 1-line functions like function (s) {return x+2}\n+        if (compilerEnv.isStrictMode()) {\n+            int beg = Math.max(pos, lineBeginningFor(end));\n+            if (end == -1)\n+                end = ts.cursor;\n+            addStrictWarning(\"msg.missing.semi\", \"\",\n+                             beg, end - beg);\n+        }\n+    }\n+\n+    private void warnTrailingComma(String messageId, int pos,\n+                                   List<?> elems, int commaPos) {\n+        if (compilerEnv.getWarnTrailingComma()) {\n+            // back up from comma to beginning of line or array/objlit\n+            if (!elems.isEmpty()) {\n+                pos = ((AstNode)elems.get(0)).getPosition();\n+            }\n+            pos = Math.max(pos, lineBeginningFor(commaPos));\n+            addWarning(\"msg.extra.trailing.comma\", pos, commaPos - pos);\n+        }\n+    }\n+\n+\n+    private String readFully(Reader reader) throws IOException {\n+        BufferedReader in = new BufferedReader(reader);\n+        try {\n+            char[] cbuf = new char[1024];\n+            StringBuilder sb = new StringBuilder(1024);\n+            int bytes_read;\n+            while ((bytes_read = in.read(cbuf, 0, 1024)) != -1) {\n+                sb.append(cbuf, 0, bytes_read);\n+            }\n+            return sb.toString();\n+        } finally {\n+            in.close();\n+        }\n+    }\n+\n+    // helps reduce clutter in the already-large function() method\n+    protected class PerFunctionVariables\n+    {\n+        private ScriptNode savedCurrentScriptOrFn;\n+        private Scope savedCurrentScope;\n+        private int savedNestingOfWith;\n+        private int savedEndFlags;\n+        private boolean savedInForInit;\n+        private Map<String,LabeledStatement> savedLabelSet;\n+        private List<Loop> savedLoopSet;\n+        private List<Jump> savedLoopAndSwitchSet;\n+\n+        PerFunctionVariables(FunctionNode fnNode) {\n+            savedCurrentScriptOrFn = Parser.this.currentScriptOrFn;\n+            Parser.this.currentScriptOrFn = fnNode;\n+\n+            savedCurrentScope = Parser.this.currentScope;\n+            Parser.this.currentScope = fnNode;\n+\n+            savedNestingOfWith = Parser.this.nestingOfWith;\n+            Parser.this.nestingOfWith = 0;\n+\n+            savedLabelSet = Parser.this.labelSet;\n+            Parser.this.labelSet = null;\n+\n+            savedLoopSet = Parser.this.loopSet;\n+            Parser.this.loopSet = null;\n+\n+            savedLoopAndSwitchSet = Parser.this.loopAndSwitchSet;\n+            Parser.this.loopAndSwitchSet = null;\n+\n+            savedEndFlags = Parser.this.endFlags;\n+            Parser.this.endFlags = 0;\n+\n+            savedInForInit = Parser.this.inForInit;\n+            Parser.this.inForInit = false;\n+        }\n+\n+        void restore() {\n+            Parser.this.currentScriptOrFn = savedCurrentScriptOrFn;\n+            Parser.this.currentScope = savedCurrentScope;\n+            Parser.this.nestingOfWith = savedNestingOfWith;\n+            Parser.this.labelSet = savedLabelSet;\n+            Parser.this.loopSet = savedLoopSet;\n+            Parser.this.loopAndSwitchSet = savedLoopAndSwitchSet;\n+            Parser.this.endFlags = savedEndFlags;\n+            Parser.this.inForInit = savedInForInit;\n+        }\n+    }\n+\n+    /**\n+     * Given a destructuring assignment with a left hand side parsed\n+     * as an array or object literal and a right hand side expression,\n+     * rewrite as a series of assignments to the variables defined in\n+     * left from property accesses to the expression on the right.\n+     * @param type declaration type: Token.VAR or Token.LET or -1\n+     * @param left array or object literal containing NAME nodes for\n+     *        variables to assign\n+     * @param right expression to assign from\n+     * @return expression that performs a series of assignments to\n+     *         the variables defined in left\n+     */\n+    Node createDestructuringAssignment(int type, Node left, Node right)\n+    {\n+        String tempName = currentScriptOrFn.getNextTempName();\n+        Node result = destructuringAssignmentHelper(type, left, right,\n+            tempName);\n+        Node comma = result.getLastChild();\n+        comma.addChildToBack(createName(tempName));\n+        return result;\n+    }\n+\n+    Node destructuringAssignmentHelper(int variableType, Node left,\n+                                       Node right, String tempName)\n+    {\n+        Scope result = createScopeNode(Token.LETEXPR, left.getLineno());\n+        result.addChildToFront(new Node(Token.LET,\n+            createName(Token.NAME, tempName, right)));\n+        try {\n+            pushScope(result);\n+            defineSymbol(Token.LET, tempName, true);\n+        } finally {\n+            popScope();\n+        }\n+        Node comma = new Node(Token.COMMA);\n+        result.addChildToBack(comma);\n+        List<String> destructuringNames = new ArrayList<String>();\n+        boolean empty = true;\n+        switch (left.getType()) {\n+          case Token.ARRAYLIT:\n+              empty = destructuringArray((ArrayLiteral)left,\n+                                         variableType, tempName, comma,\n+                                         destructuringNames);\n+              break;\n+          case Token.OBJECTLIT:\n+              empty = destructuringObject((ObjectLiteral)left,\n+                                          variableType, tempName, comma,\n+                                          destructuringNames);\n+              break;\n+          case Token.GETPROP:\n+          case Token.GETELEM:\n+              comma.addChildToBack(simpleAssignment(left, createName(tempName)));\n+              break;\n+          default:\n+              reportError(\"msg.bad.assign.left\");\n+        }\n+        if (empty) {\n+            // Don't want a COMMA node with no children. Just add a zero.\n+            comma.addChildToBack(createNumber(0));\n+        }\n+        result.putProp(Node.DESTRUCTURING_NAMES, destructuringNames);\n+        return result;\n+    }\n+\n+    boolean destructuringArray(ArrayLiteral array,\n+                               int variableType,\n+                               String tempName,\n+                               Node parent,\n+                               List<String> destructuringNames)\n+    {\n+        boolean empty = true;\n+        int setOp = variableType == Token.CONST\n+            ? Token.SETCONST : Token.SETNAME;\n+        int index = 0;\n+        for (AstNode n : array.getElements()) {\n+            if (n.getType() == Token.EMPTY) {\n+                index++;\n+                continue;\n+            }\n+            Node rightElem = new Node(Token.GETELEM,\n+                                      createName(tempName),\n+                                      createNumber(index));\n+            if (n.getType() == Token.NAME) {\n+                String name = n.getString();\n+                parent.addChildToBack(new Node(setOp,\n+                                              createName(Token.BINDNAME,\n+                                                         name, null),\n+                                              rightElem));\n+                if (variableType != -1) {\n+                    defineSymbol(variableType, name, true);\n+                    destructuringNames.add(name);\n+                }\n+            } else {\n+                parent.addChildToBack\n+                    (destructuringAssignmentHelper\n+                     (variableType, n,\n+                      rightElem,\n+                      currentScriptOrFn.getNextTempName()));\n+            }\n+            index++;\n+            empty = false;\n+        }\n+        return empty;\n+    }\n+\n+    boolean destructuringObject(ObjectLiteral node,\n+                                int variableType,\n+                                String tempName,\n+                                Node parent,\n+                                List<String> destructuringNames)\n+    {\n+        boolean empty = true;\n+        int setOp = variableType == Token.CONST\n+            ? Token.SETCONST : Token.SETNAME;\n+\n+        for (ObjectProperty prop : node.getElements()) {\n+            int lineno = 0;\n+            // This function is sometimes called from the IRFactory when\n+            // when executing regression tests, and in those cases the\n+            // tokenStream isn't set.  Deal with it.\n+            if (ts != null) {\n+              lineno = ts.lineno;\n+            }\n+            AstNode id = prop.getLeft();\n+            Node rightElem = null;\n+            if (id instanceof Name) {\n+                Node s = Node.newString(((Name)id).getIdentifier());\n+                rightElem = new Node(Token.GETPROP, createName(tempName), s);\n+            } else if (id instanceof StringLiteral) {\n+                Node s = Node.newString(((StringLiteral)id).getValue());\n+                rightElem = new Node(Token.GETPROP, createName(tempName), s);\n+            } else if (id instanceof NumberLiteral) {\n+                Node s = createNumber((int)((NumberLiteral)id).getNumber());\n+                rightElem = new Node(Token.GETELEM, createName(tempName), s);\n+            } else {\n+                throw codeBug();\n+            }\n+            rightElem.setLineno(lineno);\n+            AstNode value = prop.getRight();\n+            if (value.getType() == Token.NAME) {\n+                String name = ((Name)value).getIdentifier();\n+                parent.addChildToBack(new Node(setOp,\n+                                              createName(Token.BINDNAME,\n+                                                         name, null),\n+                                              rightElem));\n+                if (variableType != -1) {\n+                    defineSymbol(variableType, name, true);\n+                    destructuringNames.add(name);\n+                }\n+            } else {\n+                parent.addChildToBack\n+                    (destructuringAssignmentHelper\n+                     (variableType, value, rightElem,\n+                      currentScriptOrFn.getNextTempName()));\n+            }\n+            empty = false;\n+        }\n+        return empty;\n+    }\n+\n+    protected Node createName(String name) {\n+        checkActivationName(name, Token.NAME);\n+        return Node.newString(Token.NAME, name);\n+    }\n+\n+    protected Node createName(int type, String name, Node child) {\n+        Node result = createName(name);\n+        result.setType(type);\n+        if (child != null)\n+            result.addChildToBack(child);\n+        return result;\n+    }\n+\n+    protected Node createNumber(double number) {\n+        return Node.newNumber(number);\n+    }\n+\n+    /**\n+     * Create a node that can be used to hold lexically scoped variable\n+     * definitions (via let declarations).\n+     *\n+     * @param token the token of the node to create\n+     * @param lineno line number of source\n+     * @return the created node\n+     */\n+    protected Scope createScopeNode(int token, int lineno) {\n+        Scope scope =new Scope();\n+        scope.setType(token);\n+        scope.setLineno(lineno);\n+        return scope;\n+    }\n+\n+    // Quickie tutorial for some of the interpreter bytecodes.\n+    //\n+    // GETPROP - for normal foo.bar prop access; right side is a name\n+    // GETELEM - for normal foo[bar] element access; rhs is an expr\n+    // SETPROP - for assignment when left side is a GETPROP\n+    // SETELEM - for assignment when left side is a GETELEM\n+    // DELPROP - used for delete foo.bar or foo[bar]\n+    //\n+    // GET_REF, SET_REF, DEL_REF - in general, these mean you're using\n+    // get/set/delete on a right-hand side expression (possibly with no\n+    // explicit left-hand side) that doesn't use the normal JavaScript\n+    // Object (i.e. ScriptableObject) get/set/delete functions, but wants\n+    // to provide its own versions instead.  It will ultimately implement\n+    // Ref, and currently SpecialRef (for __proto__ etc.) and XmlName\n+    // (for E4X XML objects) are the only implementations.  The runtime\n+    // notices these bytecodes and delegates get/set/delete to the object.\n+    //\n+    // BINDNAME:  used in assignments.  LHS is evaluated first to get a\n+    // specific object containing the property (\"binding\" the property\n+    // to the object) so that it's always the same object, regardless of\n+    // side effects in the RHS.\n+\n+    protected Node simpleAssignment(Node left, Node right) {\n+        int nodeType = left.getType();\n+        switch (nodeType) {\n+          case Token.NAME:\n+              if (inUseStrictDirective &&\n+                  \"eval\".equals(((Name) left).getIdentifier()))\n+              {\n+                  reportError(\"msg.bad.id.strict\",\n+                              ((Name) left).getIdentifier());\n+              }\n+              left.setType(Token.BINDNAME);\n+              return new Node(Token.SETNAME, left, right);\n+\n+          case Token.GETPROP:\n+          case Token.GETELEM: {\n+              Node obj, id;\n+              // If it's a PropertyGet or ElementGet, we're in the parse pass.\n+              // We could alternately have PropertyGet and ElementGet\n+              // override getFirstChild/getLastChild and return the appropriate\n+              // field, but that seems just as ugly as this casting.\n+              if (left instanceof PropertyGet) {\n+                  obj = ((PropertyGet)left).getTarget();\n+                  id = ((PropertyGet)left).getProperty();\n+              } else if (left instanceof ElementGet) {\n+                  obj = ((ElementGet)left).getTarget();\n+                  id = ((ElementGet)left).getElement();\n+              } else {\n+                  // This branch is called during IRFactory transform pass.\n+                  obj = left.getFirstChild();\n+                  id = left.getLastChild();\n+              }\n+              int type;\n+              if (nodeType == Token.GETPROP) {\n+                  type = Token.SETPROP;\n+                  // TODO(stevey) - see https://bugzilla.mozilla.org/show_bug.cgi?id=492036\n+                  // The new AST code generates NAME tokens for GETPROP ids where the old parser\n+                  // generated STRING nodes. If we don't set the type to STRING below, this will\n+                  // cause java.lang.VerifyError in codegen for code like\n+                  // \"var obj={p:3};[obj.p]=[9];\"\n+                  id.setType(Token.STRING);\n+              } else {\n+                  type = Token.SETELEM;\n+              }\n+              return new Node(type, obj, id, right);\n+          }\n+          case Token.GET_REF: {\n+              Node ref = left.getFirstChild();\n+              checkMutableReference(ref);\n+              return new Node(Token.SET_REF, ref, right);\n+          }\n+        }\n+\n+        throw codeBug();\n+    }\n+\n+    protected void checkMutableReference(Node n) {\n+        int memberTypeFlags = n.getIntProp(Node.MEMBER_TYPE_PROP, 0);\n+        if ((memberTypeFlags & Node.DESCENDANTS_FLAG) != 0) {\n+            reportError(\"msg.bad.assign.left\");\n+        }\n+    }\n+\n+    // remove any ParenthesizedExpression wrappers\n+    protected AstNode removeParens(AstNode node) {\n+        while (node instanceof ParenthesizedExpression) {\n+            node = ((ParenthesizedExpression)node).getExpression();\n+        }\n+        return node;\n+    }\n+\n+    void markDestructuring(AstNode node) {\n+        if (node instanceof DestructuringForm) {\n+            ((DestructuringForm)node).setIsDestructuring(true);\n+        } else if (node instanceof ParenthesizedExpression) {\n+            markDestructuring(((ParenthesizedExpression)node).getExpression());\n+        }\n+    }\n+\n+    // throw a failed-assertion with some helpful debugging info\n+    private RuntimeException codeBug()\n+        throws RuntimeException\n+    {\n+        throw Kit.codeBug(\"ts.cursor=\" + ts.cursor\n+                          + \", ts.tokenBeg=\" + ts.tokenBeg\n+                          + \", currentToken=\" + currentToken);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/PolicySecurityController.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.ref.SoftReference;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.security.AccessController;\n+import java.security.CodeSource;\n+import java.security.Policy;\n+import java.security.PrivilegedAction;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.security.SecureClassLoader;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+\n+import org.mozilla.classfile.ByteCode;\n+import org.mozilla.classfile.ClassFileWriter;\n+\n+/**\n+ * A security controller relying on Java {@link Policy} in effect. When you use\n+ * this security controller, your securityDomain objects must be instances of\n+ * {@link CodeSource} representing the location from where you load your \n+ * scripts. Any Java policy \"grant\" statements matching the URL and certificate\n+ * in code sources will apply to the scripts. If you specify any certificates \n+ * within your {@link CodeSource} objects, it is your responsibility to verify\n+ * (or not) that the script source files are signed in whatever \n+ * implementation-specific way you're using.\n+ */\n+public class PolicySecurityController extends SecurityController\n+{\n+    private static final byte[] secureCallerImplBytecode = loadBytecode();\n+\n+    // We're storing a CodeSource -> (ClassLoader -> SecureRenderer), since we\n+    // need to have one renderer per class loader. We're using weak hash maps\n+    // and soft references all the way, since we don't want to interfere with\n+    // cleanup of either CodeSource or ClassLoader objects.\n+    private static final Map<CodeSource,Map<ClassLoader,SoftReference<SecureCaller>>>\n+        callers =\n+            new WeakHashMap<CodeSource,Map<ClassLoader,SoftReference<SecureCaller>>>();\n+    \n+    @Override\n+    public Class<?> getStaticSecurityDomainClassInternal() {\n+        return CodeSource.class;\n+    }\n+\n+    private static class Loader extends SecureClassLoader\n+    implements GeneratedClassLoader\n+    {\n+        private final CodeSource codeSource;\n+        \n+        Loader(ClassLoader parent, CodeSource codeSource)\n+        {\n+            super(parent);\n+            this.codeSource = codeSource;\n+        }\n+\n+        public Class<?> defineClass(String name, byte[] data)\n+        {\n+            return defineClass(name, data, 0, data.length, codeSource);\n+        }\n+        \n+        public void linkClass(Class<?> cl)\n+        {\n+            resolveClass(cl);\n+        }\n+    }\n+    \n+    @Override\n+    public GeneratedClassLoader createClassLoader(final ClassLoader parent, \n+            final Object securityDomain)\n+    {\n+        return (Loader)AccessController.doPrivileged(\n+            new PrivilegedAction<Object>()\n+            {\n+                public Object run()\n+                {\n+                    return new Loader(parent, (CodeSource)securityDomain);\n+                }\n+            });\n+    }\n+\n+    @Override\n+    public Object getDynamicSecurityDomain(Object securityDomain)\n+    {\n+        // No separate notion of dynamic security domain - just return what was\n+        // passed in.\n+        return securityDomain;\n+    }\n+\n+    @Override\n+    public Object callWithDomain(final Object securityDomain, final Context cx, \n+            Callable callable, Scriptable scope, Scriptable thisObj, \n+            Object[] args)\n+    {\n+        // Run in doPrivileged as we might be checked for \"getClassLoader\" \n+        // runtime permission\n+        final ClassLoader classLoader = (ClassLoader)AccessController.doPrivileged(\n+            new PrivilegedAction<Object>() {\n+                public Object run() {\n+                    return cx.getApplicationClassLoader();\n+                }\n+            });\n+        final CodeSource codeSource = (CodeSource)securityDomain;\n+        Map<ClassLoader,SoftReference<SecureCaller>> classLoaderMap;\n+        synchronized (callers) {\n+            classLoaderMap = callers.get(codeSource);\n+            if(classLoaderMap == null) {\n+                classLoaderMap = new WeakHashMap<ClassLoader,SoftReference<SecureCaller>>();\n+                callers.put(codeSource, classLoaderMap);\n+            }\n+        }\n+        SecureCaller caller;\n+        synchronized (classLoaderMap) {\n+            SoftReference<SecureCaller> ref = classLoaderMap.get(classLoader);\n+            if (ref != null) {\n+                caller = ref.get();\n+            } else {\n+                caller = null;\n+            }\n+            if (caller == null)\n+            {\n+                try\n+                {\n+                    // Run in doPrivileged as we'll be checked for \n+                    // \"createClassLoader\" runtime permission\n+                    caller = (SecureCaller)AccessController.doPrivileged(\n+                            new PrivilegedExceptionAction<Object>()\n+                    {\n+                        public Object run() throws Exception\n+                        {\n+                            Loader loader = new Loader(classLoader, \n+                                    codeSource);\n+                            Class<?> c = loader.defineClass(\n+                                    SecureCaller.class.getName() + \"Impl\", \n+                                    secureCallerImplBytecode);\n+                            return c.newInstance();\n+                        }\n+                    });\n+                    classLoaderMap.put(classLoader, new SoftReference<SecureCaller>(caller));\n+                }\n+                catch(PrivilegedActionException ex)\n+                {\n+                    throw new UndeclaredThrowableException(ex.getCause());\n+                }\n+            }\n+        }\n+        return caller.call(callable, cx, scope, thisObj, args);\n+    }\n+    \n+    public abstract static class SecureCaller\n+    {\n+        public abstract Object call(Callable callable, Context cx, Scriptable scope, \n+                Scriptable thisObj, Object[] args);\n+    }\n+    \n+    \n+    private static byte[] loadBytecode()\n+    {\n+        String secureCallerClassName = SecureCaller.class.getName();\n+        ClassFileWriter cfw = new ClassFileWriter(\n+                secureCallerClassName + \"Impl\", secureCallerClassName, \n+                \"<generated>\");\n+        cfw.startMethod(\"<init>\", \"()V\", ClassFileWriter.ACC_PUBLIC);\n+        cfw.addALoad(0);\n+        cfw.addInvoke(ByteCode.INVOKESPECIAL, secureCallerClassName, \n+                \"<init>\", \"()V\");\n+        cfw.add(ByteCode.RETURN);\n+        cfw.stopMethod((short)1);\n+        String callableCallSig = \n+            \"Lorg/mozilla/javascript/Context;\" +\n+            \"Lorg/mozilla/javascript/Scriptable;\" +\n+            \"Lorg/mozilla/javascript/Scriptable;\" +\n+            \"[Ljava/lang/Object;)Ljava/lang/Object;\";\n+        \n+        cfw.startMethod(\"call\",\n+                \"(Lorg/mozilla/javascript/Callable;\" + callableCallSig,\n+                (short)(ClassFileWriter.ACC_PUBLIC\n+                        | ClassFileWriter.ACC_FINAL));\n+        for(int i = 1; i < 6; ++i) {\n+            cfw.addALoad(i);\n+        }\n+        cfw.addInvoke(ByteCode.INVOKEINTERFACE, \n+                \"org/mozilla/javascript/Callable\", \"call\", \n+                \"(\" + callableCallSig);\n+        cfw.add(ByteCode.ARETURN);\n+        cfw.stopMethod((short)6);\n+        return cfw.toByteArray();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Ref.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov, igor@fastmail.fm\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Generic notion of reference object that know how to query/modify the\n+ * target objects based on some property/index.\n+ */\n+public abstract class Ref implements Serializable\n+{\n+    public boolean has(Context cx)\n+    {\n+        return true;\n+    }\n+\n+    public abstract Object get(Context cx);\n+\n+    public abstract Object set(Context cx, Object value);\n+\n+    public boolean delete(Context cx)\n+    {\n+        return false;\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/RefCallable.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov, igor@mir2.org\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Object that can allows assignments to the result of function calls.\n+ */\n+public interface RefCallable extends Callable\n+{\n+    /**\n+     * Perform function call in reference context.\n+     * The args array reference should not be stored in any object that is\n+     * can be GC-reachable after this method returns. If this is necessary,\n+     * for example, to implement {@link Ref} methods, then store args.clone(),\n+     * not args array itself.\n+     *\n+     * @param cx the current Context for this thread\n+     * @param thisObj the JavaScript <code>this</code> object\n+     * @param args the array of arguments\n+     */\n+    public Ref refCall(Context cx, Scriptable thisObj, Object[] args);\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/RegExpProxy.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * A proxy for the regexp package, so that the regexp package can be\n+ * loaded optionally.\n+ *\n+ */\n+public interface RegExpProxy\n+{\n+    // Types of regexp actions\n+\n+    public static final int RA_MATCH   = 1;\n+    public static final int RA_REPLACE = 2;\n+    public static final int RA_SEARCH  = 3;\n+\n+    public boolean isRegExp(Scriptable obj);\n+\n+    public Object compileRegExp(Context cx, String source, String flags);\n+\n+    public Scriptable wrapRegExp(Context cx, Scriptable scope,\n+                                 Object compiled);\n+\n+    public Object action(Context cx, Scriptable scope,\n+                         Scriptable thisObj, Object[] args,\n+                         int actionType);\n+\n+    public int find_split(Context cx, Scriptable scope, String target,\n+                          String separator, Scriptable re,\n+                          int[] ip, int[] matchlen,\n+                          boolean[] matched, String[][] parensp);\n+\n+\tpublic Object js_split(Context _cx, Scriptable _scope, String thisString, Object[] _args);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/RhinoException.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+\n+package org.mozilla.javascript;\n+\n+import java.io.CharArrayWriter;\n+import java.io.File;\n+import java.io.FilenameFilter;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.util.List;\n+\n+/**\n+ * The class of exceptions thrown by the JavaScript engine.\n+ */\n+public abstract class RhinoException extends RuntimeException\n+{\n+    RhinoException()\n+    {\n+        Evaluator e = Context.createInterpreter();\n+        if (e != null)\n+            e.captureStackInfo(this);\n+    }\n+\n+    RhinoException(String details)\n+    {\n+        super(details);\n+        Evaluator e = Context.createInterpreter();\n+        if (e != null)\n+            e.captureStackInfo(this);\n+    }\n+\n+    @Override\n+    public final String getMessage()\n+    {\n+        String details = details();\n+        if (sourceName == null || lineNumber <= 0) {\n+            return details;\n+        }\n+        StringBuffer buf = new StringBuffer(details);\n+        buf.append(\" (\");\n+        if (sourceName != null) {\n+            buf.append(sourceName);\n+        }\n+        if (lineNumber > 0) {\n+            buf.append('#');\n+            buf.append(lineNumber);\n+        }\n+        buf.append(')');\n+        return buf.toString();\n+    }\n+\n+    public String details()\n+    {\n+        return super.getMessage();\n+    }\n+\n+    /**\n+     * Get the uri of the script source containing the error, or null\n+     * if that information is not available.\n+     */\n+    public final String sourceName()\n+    {\n+        return sourceName;\n+    }\n+\n+    /**\n+     * Initialize the uri of the script source containing the error.\n+     *\n+     * @param sourceName the uri of the script source responsible for the error.\n+     *                   It should not be <tt>null</tt>.\n+     *\n+     * @throws IllegalStateException if the method is called more then once.\n+     */\n+    public final void initSourceName(String sourceName)\n+    {\n+        if (sourceName == null) throw new IllegalArgumentException();\n+        if (this.sourceName != null) throw new IllegalStateException();\n+        this.sourceName = sourceName;\n+    }\n+\n+    /**\n+     * Returns the line number of the statement causing the error,\n+     * or zero if not available.\n+     */\n+    public final int lineNumber()\n+    {\n+        return lineNumber;\n+    }\n+\n+    /**\n+     * Initialize the line number of the script statement causing the error.\n+     *\n+     * @param lineNumber the line number in the script source.\n+     *                   It should be positive number.\n+     *\n+     * @throws IllegalStateException if the method is called more then once.\n+     */\n+    public final void initLineNumber(int lineNumber)\n+    {\n+        if (lineNumber <= 0) throw new IllegalArgumentException(String.valueOf(lineNumber));\n+        if (this.lineNumber > 0) throw new IllegalStateException();\n+        this.lineNumber = lineNumber;\n+    }\n+\n+    /**\n+     * The column number of the location of the error, or zero if unknown.\n+     */\n+    public final int columnNumber()\n+    {\n+        return columnNumber;\n+    }\n+\n+    /**\n+     * Initialize the column number of the script statement causing the error.\n+     *\n+     * @param columnNumber the column number in the script source.\n+     *                     It should be positive number.\n+     *\n+     * @throws IllegalStateException if the method is called more then once.\n+     */\n+    public final void initColumnNumber(int columnNumber)\n+    {\n+        if (columnNumber <= 0) throw new IllegalArgumentException(String.valueOf(columnNumber));\n+        if (this.columnNumber > 0) throw new IllegalStateException();\n+        this.columnNumber = columnNumber;\n+    }\n+\n+    /**\n+     * The source text of the line causing the error, or null if unknown.\n+     */\n+    public final String lineSource()\n+    {\n+        return lineSource;\n+    }\n+\n+    /**\n+     * Initialize the text of the source line containing the error.\n+     *\n+     * @param lineSource the text of the source line responsible for the error.\n+     *                   It should not be <tt>null</tt>.\n+     *\n+     * @throws IllegalStateException if the method is called more then once.\n+     */\n+    public final void initLineSource(String lineSource)\n+    {\n+        if (lineSource == null) throw new IllegalArgumentException();\n+        if (this.lineSource != null) throw new IllegalStateException();\n+        this.lineSource = lineSource;\n+    }\n+\n+    final void recordErrorOrigin(String sourceName, int lineNumber,\n+                                 String lineSource, int columnNumber)\n+    {\n+        // XXX: for compatibility allow for now -1 to mean 0\n+        if (lineNumber == -1) {\n+            lineNumber = 0;\n+        }\n+\n+        if (sourceName != null) {\n+            initSourceName(sourceName);\n+        }\n+        if (lineNumber != 0) {\n+            initLineNumber(lineNumber);\n+        }\n+        if (lineSource != null) {\n+            initLineSource(lineSource);\n+        }\n+        if (columnNumber != 0) {\n+            initColumnNumber(columnNumber);\n+        }\n+    }\n+\n+    private String generateStackTrace()\n+    {\n+        // Get stable reference to work properly with concurrent access\n+        CharArrayWriter writer = new CharArrayWriter();\n+        super.printStackTrace(new PrintWriter(writer));\n+        String origStackTrace = writer.toString();\n+        Evaluator e = Context.createInterpreter();\n+        if (e != null)\n+            return e.getPatchedStack(this, origStackTrace);\n+        return null;\n+    }\n+\n+    /**\n+     * Get a string representing the script stack of this exception.\n+     * If optimization is enabled, this corresponds to all java stack elements\n+     * with a source name ending with \".js\".\n+     * @return a script stack dump\n+     * @since 1.6R6\n+     */\n+    public String getScriptStackTrace()\n+    {\n+        return getScriptStackTrace(new FilenameFilter() {\n+            public boolean accept(File dir, String name) {\n+                return name.endsWith(\".js\");\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get a string representing the script stack of this exception.\n+     * If optimization is enabled, this corresponds to all java stack elements\n+     * with a source name matching the <code>filter</code>.\n+     * @param filter the file name filter to determine whether a file is a \n+     *               script file\n+     * @return a script stack dump\n+     * @since 1.6R6\n+     */\n+    public String getScriptStackTrace(FilenameFilter filter)\n+    {\n+        List<String> interpreterStack = null;\n+        Evaluator interpreter = Context.createInterpreter();\n+        if (interpreter != null) {\n+            interpreterStack = interpreter.getScriptStack(this);\n+        }\n+        int interpreterStackIndex = 0;\n+        StringBuffer buffer = new StringBuffer();\n+        String lineSeparator = SecurityUtilities.getSystemProperty(\"line.separator\");\n+        StackTraceElement[] stack = getStackTrace();\n+        for (int i = 0; i < stack.length; i++) {\n+            StackTraceElement e = stack[i];\n+            String name = e.getFileName();\n+            if (e.getLineNumber() > -1 && name != null &&\n+                filter.accept(null, name))\n+            {\n+                buffer.append(\"\\tat \");\n+                buffer.append(e.getFileName());\n+                buffer.append(':');\n+                buffer.append(e.getLineNumber());\n+                buffer.append(lineSeparator);\n+            } else if (interpreterStack != null &&\n+                interpreterStack.size() > interpreterStackIndex && \n+                \"org.mozilla.javascript.Interpreter\".equals(e.getClassName()) &&\n+                \"interpretLoop\".equals(e.getMethodName()))\n+            {\n+                buffer.append(interpreterStack.get(interpreterStackIndex++));\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    @Override\n+    public void printStackTrace(PrintWriter s)\n+    {\n+        if (interpreterStackInfo == null) {\n+            super.printStackTrace(s);\n+        } else {\n+            s.print(generateStackTrace());\n+        }\n+    }\n+\n+    @Override\n+    public void printStackTrace(PrintStream s)\n+    {\n+        if (interpreterStackInfo == null) {\n+            super.printStackTrace(s);\n+        } else {\n+            s.print(generateStackTrace());\n+        }\n+    }\n+\n+    private String sourceName;\n+    private int lineNumber;\n+    private String lineSource;\n+    private int columnNumber;\n+\n+    Object interpreterStackInfo;\n+    int[] interpreterLineData;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Script.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * All compiled scripts implement this interface.\n+ * <p>\n+ * This class encapsulates script execution relative to an\n+ * object scope.\n+ * @since 1.3\n+ */\n+\n+public interface Script {\n+\n+    /**\n+     * Execute the script.\n+     * <p>\n+     * The script is executed in a particular runtime Context, which\n+     * must be associated with the current thread.\n+     * The script is executed relative to a scope--definitions and\n+     * uses of global top-level variables and functions will access\n+     * properties of the scope object. For compliant ECMA\n+     * programs, the scope must be an object that has been initialized\n+     * as a global object using <code>Context.initStandardObjects</code>.\n+     * <p>\n+     *\n+     * @param cx the Context associated with the current thread\n+     * @param scope the scope to execute relative to\n+     * @return the result of executing the script\n+     * @see org.mozilla.javascript.Context#initStandardObjects()\n+     */\n+    public Object exec(Context cx, Scriptable scope);\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ScriptRuntime.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Patrick Beard\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Mike Harm\n+ *   Ethan Hugg\n+ *   Bob Jervis\n+ *   Roger Lawrence\n+ *   Terry Lucas\n+ *   Frank Mitchell\n+ *   Milen Nankov\n+ *   Hannes Wallnoefer\n+ *   Andrew Wason\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.*;\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.ResourceBundle;\n+\n+import org.mozilla.javascript.ast.FunctionNode;\n+import org.mozilla.javascript.xml.XMLObject;\n+import org.mozilla.javascript.xml.XMLLib;\n+\n+/**\n+ * This is the class that implements the runtime.\n+ *\n+ */\n+\n+public class ScriptRuntime {\n+\n+    /**\n+     * No instances should be created.\n+     */\n+    protected ScriptRuntime() {\n+    }\n+\n+\n+    /**\n+     * Returns representation of the [[ThrowTypeError]] object.\n+     * See ECMA 5 spec, 13.2.3\n+     */\n+    public static BaseFunction typeErrorThrower() {\n+      if (THROW_TYPE_ERROR == null) {\n+        BaseFunction thrower = new BaseFunction() {\n+          @Override\n+          public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {\n+            throw typeError0(\"msg.op.not.allowed\");\n+          }\n+          @Override\n+          public int getLength() {\n+            return 0;\n+          }\n+        };\n+        thrower.preventExtensions();\n+        THROW_TYPE_ERROR = thrower;\n+      }\n+      return THROW_TYPE_ERROR;\n+    }\n+    private static BaseFunction THROW_TYPE_ERROR = null;\n+\n+    static class NoSuchMethodShim implements Callable {\n+        String methodName;\n+        Callable noSuchMethodMethod;\n+\n+        NoSuchMethodShim(Callable noSuchMethodMethod, String methodName)\n+        {\n+            this.noSuchMethodMethod = noSuchMethodMethod;\n+            this.methodName = methodName;\n+        }\n+        /**\n+         * Perform the call.\n+         *\n+         * @param cx the current Context for this thread\n+         * @param scope the scope to use to resolve properties.\n+         * @param thisObj the JavaScript <code>this</code> object\n+         * @param args the array of arguments\n+         * @return the result of the call\n+         */\n+        public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                           Object[] args)\n+        {\n+            Object[] nestedArgs = new Object[2];\n+\n+            nestedArgs[0] = methodName;\n+            nestedArgs[1] = newArrayLiteral(args, null, cx, scope);\n+            return noSuchMethodMethod.call(cx, scope, thisObj, nestedArgs);\n+        }\n+\n+    }\n+    /*\n+     * There's such a huge space (and some time) waste for the Foo.class\n+     * syntax: the compiler sticks in a test of a static field in the\n+     * enclosing class for null and the code for creating the class value.\n+     * It has to do this since the reference has to get pushed off until\n+     * execution time (i.e. can't force an early load), but for the\n+     * 'standard' classes - especially those in java.lang, we can trust\n+     * that they won't cause problems by being loaded early.\n+     */\n+\n+    public final static Class<?>\n+        BooleanClass      = Kit.classOrNull(\"java.lang.Boolean\"),\n+        ByteClass         = Kit.classOrNull(\"java.lang.Byte\"),\n+        CharacterClass    = Kit.classOrNull(\"java.lang.Character\"),\n+        ClassClass        = Kit.classOrNull(\"java.lang.Class\"),\n+        DoubleClass       = Kit.classOrNull(\"java.lang.Double\"),\n+        FloatClass        = Kit.classOrNull(\"java.lang.Float\"),\n+        IntegerClass      = Kit.classOrNull(\"java.lang.Integer\"),\n+        LongClass         = Kit.classOrNull(\"java.lang.Long\"),\n+        NumberClass       = Kit.classOrNull(\"java.lang.Number\"),\n+        ObjectClass       = Kit.classOrNull(\"java.lang.Object\"),\n+        ShortClass        = Kit.classOrNull(\"java.lang.Short\"),\n+        StringClass       = Kit.classOrNull(\"java.lang.String\"),\n+        DateClass         = Kit.classOrNull(\"java.util.Date\");\n+\n+    public final static Class<?>\n+        ContextClass\n+            = Kit.classOrNull(\"org.mozilla.javascript.Context\"),\n+        ContextFactoryClass\n+            = Kit.classOrNull(\"org.mozilla.javascript.ContextFactory\"),\n+        FunctionClass\n+            = Kit.classOrNull(\"org.mozilla.javascript.Function\"),\n+        ScriptableObjectClass\n+            = Kit.classOrNull(\"org.mozilla.javascript.ScriptableObject\");\n+    public static final Class<Scriptable> ScriptableClass =\n+        Scriptable.class;\n+\n+    private static final String[] lazilyNames = {\n+        \"RegExp\",        \"org.mozilla.javascript.regexp.NativeRegExp\",\n+        \"Packages\",      \"org.mozilla.javascript.NativeJavaTopPackage\",\n+        \"java\",          \"org.mozilla.javascript.NativeJavaTopPackage\",\n+        \"javax\",         \"org.mozilla.javascript.NativeJavaTopPackage\",\n+        \"org\",           \"org.mozilla.javascript.NativeJavaTopPackage\",\n+        \"com\",           \"org.mozilla.javascript.NativeJavaTopPackage\",\n+        \"edu\",           \"org.mozilla.javascript.NativeJavaTopPackage\",\n+        \"net\",           \"org.mozilla.javascript.NativeJavaTopPackage\",\n+        \"getClass\",      \"org.mozilla.javascript.NativeJavaTopPackage\",\n+        \"JavaAdapter\",   \"org.mozilla.javascript.JavaAdapter\",\n+        \"JavaImporter\",  \"org.mozilla.javascript.ImporterTopLevel\",\n+        \"Continuation\",  \"org.mozilla.javascript.NativeContinuation\",\n+        //\tTODO\tGrotesque hack using literal string (xml) just to minimize\n+\t\t//\t\t\tchanges for now\n+        \"XML\",           \"(xml)\",\n+        \"XMLList\",       \"(xml)\",\n+        \"Namespace\",     \"(xml)\",\n+        \"QName\",         \"(xml)\",\n+    };\n+\n+    // Locale object used to request locale-neutral operations.\n+    public static Locale ROOT_LOCALE = new Locale(\"\");\n+\n+    private static final Object LIBRARY_SCOPE_KEY = \"LIBRARY_SCOPE\";\n+\n+    public static boolean isRhinoRuntimeType(Class<?> cl)\n+    {\n+        if (cl.isPrimitive()) {\n+            return (cl != Character.TYPE);\n+        } else {\n+            return (cl == StringClass || cl == BooleanClass\n+                    || NumberClass.isAssignableFrom(cl)\n+                    || ScriptableClass.isAssignableFrom(cl));\n+        }\n+    }\n+\n+    public static ScriptableObject initStandardObjects(Context cx,\n+                                                       ScriptableObject scope,\n+                                                       boolean sealed)\n+    {\n+        if (scope == null) {\n+            scope = new NativeObject();\n+        }\n+        scope.associateValue(LIBRARY_SCOPE_KEY, scope);\n+        (new ClassCache()).associate(scope);\n+\n+        BaseFunction.init(scope, sealed);\n+        NativeObject.init(scope, sealed);\n+\n+        Scriptable objectProto = ScriptableObject.getObjectPrototype(scope);\n+\n+        // Function.prototype.__proto__ should be Object.prototype\n+        Scriptable functionProto = ScriptableObject.getFunctionPrototype(scope);\n+        functionProto.setPrototype(objectProto);\n+\n+        // Set the prototype of the object passed in if need be\n+        if (scope.getPrototype() == null)\n+            scope.setPrototype(objectProto);\n+\n+        // must precede NativeGlobal since it's needed therein\n+        NativeError.init(scope, sealed);\n+        NativeGlobal.init(cx, scope, sealed);\n+\n+        NativeArray.init(scope, sealed);\n+        if (cx.getOptimizationLevel() > 0) {\n+            // When optimizing, attempt to fulfill all requests for new Array(N)\n+            // with a higher threshold before switching to a sparse\n+            // representation\n+            NativeArray.setMaximumInitialCapacity(200000);\n+        }\n+        NativeString.init(scope, sealed);\n+        NativeBoolean.init(scope, sealed);\n+        NativeNumber.init(scope, sealed);\n+        NativeDate.init(scope, sealed);\n+        NativeMath.init(scope, sealed);\n+        NativeJSON.init(scope, sealed);\n+\n+        NativeWith.init(scope, sealed);\n+        NativeCall.init(scope, sealed);\n+        NativeScript.init(scope, sealed);\n+\n+        NativeIterator.init(scope, sealed); // Also initializes NativeGenerator\n+\n+        boolean withXml = cx.hasFeature(Context.FEATURE_E4X) &&\n+                          cx.getE4xImplementationFactory() != null;\n+\n+        for (int i = 0; i != lazilyNames.length; i += 2) {\n+            String topProperty = lazilyNames[i];\n+            String className = lazilyNames[i + 1];\n+            if (!withXml && className.equals(\"(xml)\")) {\n+                continue;\n+            } else if (withXml && className.equals(\"(xml)\")) {\n+\t\t\t\tclassName = cx.getE4xImplementationFactory().\n+                               getImplementationClassName();\n+\t\t\t}\n+            new LazilyLoadedCtor(scope, topProperty, className, sealed, true);\n+        }\n+\n+        return scope;\n+    }\n+\n+    public static ScriptableObject getLibraryScopeOrNull(Scriptable scope)\n+    {\n+        ScriptableObject libScope;\n+        libScope = (ScriptableObject)ScriptableObject.\n+                       getTopScopeValue(scope, LIBRARY_SCOPE_KEY);\n+        return libScope;\n+    }\n+\n+    // It is public so NativeRegExp can access it.\n+    public static boolean isJSLineTerminator(int c)\n+    {\n+        // Optimization for faster check for eol character:\n+        // they do not have 0xDFD0 bits set\n+        if ((c & 0xDFD0) != 0) {\n+            return false;\n+        }\n+        return c == '\\n' || c == '\\r' || c == 0x2028 || c == 0x2029;\n+    }\n+\n+    public static boolean isJSWhitespaceOrLineTerminator(int c) {\n+      return (isStrWhiteSpaceChar(c) || isJSLineTerminator(c));\n+    }\n+\n+    /**\n+     * Indicates if the character is a Str whitespace char according to ECMA spec:\n+     * StrWhiteSpaceChar :::\n+      <TAB>\n+      <SP>\n+      <NBSP>\n+      <FF>\n+      <VT>\n+      <CR>\n+      <LF>\n+      <LS>\n+      <PS>\n+      <USP>\n+      <BOM>\n+     */\n+    static boolean isStrWhiteSpaceChar(int c)\n+    {\n+    \tswitch (c) {\n+    \t\tcase ' ': // <SP>\n+    \t\tcase '\\n': // <LF>\n+    \t\tcase '\\r': // <CR>\n+    \t\tcase '\\t': // <TAB>\n+    \t\tcase '\\u00A0': // <NBSP>\n+    \t\tcase '\\u000C': // <FF>\n+    \t\tcase '\\u000B': // <VT>\n+    \t\tcase '\\u2028': // <LS>\n+    \t\tcase '\\u2029': // <PS>\n+        case '\\uFEFF': // <BOM>\n+    \t\t\treturn true;\n+    \t\tdefault:\n+    \t\t\treturn Character.getType(c) == Character.SPACE_SEPARATOR;\n+    \t}\n+    }\n+\n+    public static Boolean wrapBoolean(boolean b)\n+    {\n+        return b ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    public static Integer wrapInt(int i)\n+    {\n+        return Integer.valueOf(i);\n+    }\n+\n+    public static Number wrapNumber(double x)\n+    {\n+        if (x != x) {\n+            return ScriptRuntime.NaNobj;\n+        }\n+        return new Double(x);\n+    }\n+\n+    /**\n+     * Convert the value to a boolean.\n+     *\n+     * See ECMA 9.2.\n+     */\n+    public static boolean toBoolean(Object val)\n+    {\n+        for (;;) {\n+            if (val instanceof Boolean)\n+                return ((Boolean) val).booleanValue();\n+            if (val == null || val == Undefined.instance)\n+                return false;\n+            if (val instanceof String)\n+                return ((String) val).length() != 0;\n+            if (val instanceof Number) {\n+                double d = ((Number) val).doubleValue();\n+                return (d == d && d != 0.0);\n+            }\n+            if (val instanceof Scriptable) {\n+                if (val instanceof ScriptableObject &&\n+                    ((ScriptableObject) val).avoidObjectDetection())\n+                {\n+                    return false;\n+                }\n+                if (Context.getContext().isVersionECMA1()) {\n+                    // pure ECMA\n+                    return true;\n+                }\n+                // ECMA extension\n+                val = ((Scriptable) val).getDefaultValue(BooleanClass);\n+                if (val instanceof Scriptable)\n+                    throw errorWithClassName(\"msg.primitive.expected\", val);\n+                continue;\n+            }\n+            warnAboutNonJSObject(val);\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Convert the value to a number.\n+     *\n+     * See ECMA 9.3.\n+     */\n+    public static double toNumber(Object val)\n+    {\n+        for (;;) {\n+            if (val instanceof Number)\n+                return ((Number) val).doubleValue();\n+            if (val == null)\n+                return +0.0;\n+            if (val == Undefined.instance)\n+                return NaN;\n+            if (val instanceof String)\n+                return toNumber((String) val);\n+            if (val instanceof Boolean)\n+                return ((Boolean) val).booleanValue() ? 1 : +0.0;\n+            if (val instanceof Scriptable) {\n+                val = ((Scriptable) val).getDefaultValue(NumberClass);\n+                if (val instanceof Scriptable)\n+                    throw errorWithClassName(\"msg.primitive.expected\", val);\n+                continue;\n+            }\n+            warnAboutNonJSObject(val);\n+            return NaN;\n+        }\n+    }\n+\n+    public static double toNumber(Object[] args, int index) {\n+        return (index < args.length) ? toNumber(args[index]) : NaN;\n+    }\n+\n+    // Can not use Double.NaN defined as 0.0d / 0.0 as under the Microsoft VM,\n+    // versions 2.01 and 3.0P1, that causes some uses (returns at least) of\n+    // Double.NaN to be converted to 1.0.\n+    // So we use ScriptRuntime.NaN instead of Double.NaN.\n+    public static final double\n+        NaN = Double.longBitsToDouble(0x7ff8000000000000L);\n+\n+    // A similar problem exists for negative zero.\n+    public static final double\n+        negativeZero = Double.longBitsToDouble(0x8000000000000000L);\n+\n+    public static final Double NaNobj = new Double(NaN);\n+\n+    /*\n+     * Helper function for toNumber, parseInt, and TokenStream.getToken.\n+     */\n+    static double stringToNumber(String s, int start, int radix) {\n+        char digitMax = '9';\n+        char lowerCaseBound = 'a';\n+        char upperCaseBound = 'A';\n+        int len = s.length();\n+        if (radix < 10) {\n+            digitMax = (char) ('0' + radix - 1);\n+        }\n+        if (radix > 10) {\n+            lowerCaseBound = (char) ('a' + radix - 10);\n+            upperCaseBound = (char) ('A' + radix - 10);\n+        }\n+        int end;\n+        double sum = 0.0;\n+        for (end=start; end < len; end++) {\n+            char c = s.charAt(end);\n+            int newDigit;\n+            if ('0' <= c && c <= digitMax)\n+                newDigit = c - '0';\n+            else if ('a' <= c && c < lowerCaseBound)\n+                newDigit = c - 'a' + 10;\n+            else if ('A' <= c && c < upperCaseBound)\n+                newDigit = c - 'A' + 10;\n+            else\n+                break;\n+            sum = sum*radix + newDigit;\n+        }\n+        if (start == end) {\n+            return NaN;\n+        }\n+        if (sum >= 9007199254740992.0) {\n+            if (radix == 10) {\n+                /* If we're accumulating a decimal number and the number\n+                 * is >= 2^53, then the result from the repeated multiply-add\n+                 * above may be inaccurate.  Call Java to get the correct\n+                 * answer.\n+                 */\n+                try {\n+                    return Double.valueOf(s.substring(start, end)).doubleValue();\n+                } catch (NumberFormatException nfe) {\n+                    return NaN;\n+                }\n+            } else if (radix == 2 || radix == 4 || radix == 8 ||\n+                       radix == 16 || radix == 32)\n+            {\n+                /* The number may also be inaccurate for one of these bases.\n+                 * This happens if the addition in value*radix + digit causes\n+                 * a round-down to an even least significant mantissa bit\n+                 * when the first dropped bit is a one.  If any of the\n+                 * following digits in the number (which haven't been added\n+                 * in yet) are nonzero then the correct action would have\n+                 * been to round up instead of down.  An example of this\n+                 * occurs when reading the number 0x1000000000000081, which\n+                 * rounds to 0x1000000000000000 instead of 0x1000000000000100.\n+                 */\n+                int bitShiftInChar = 1;\n+                int digit = 0;\n+\n+                final int SKIP_LEADING_ZEROS = 0;\n+                final int FIRST_EXACT_53_BITS = 1;\n+                final int AFTER_BIT_53         = 2;\n+                final int ZEROS_AFTER_54 = 3;\n+                final int MIXED_AFTER_54 = 4;\n+\n+                int state = SKIP_LEADING_ZEROS;\n+                int exactBitsLimit = 53;\n+                double factor = 0.0;\n+                boolean bit53 = false;\n+                // bit54 is the 54th bit (the first dropped from the mantissa)\n+                boolean bit54 = false;\n+\n+                for (;;) {\n+                    if (bitShiftInChar == 1) {\n+                        if (start == end)\n+                            break;\n+                        digit = s.charAt(start++);\n+                        if ('0' <= digit && digit <= '9')\n+                            digit -= '0';\n+                        else if ('a' <= digit && digit <= 'z')\n+                            digit -= 'a' - 10;\n+                        else\n+                            digit -= 'A' - 10;\n+                        bitShiftInChar = radix;\n+                    }\n+                    bitShiftInChar >>= 1;\n+                    boolean bit = (digit & bitShiftInChar) != 0;\n+\n+                    switch (state) {\n+                      case SKIP_LEADING_ZEROS:\n+                          if (bit) {\n+                            --exactBitsLimit;\n+                            sum = 1.0;\n+                            state = FIRST_EXACT_53_BITS;\n+                        }\n+                        break;\n+                      case FIRST_EXACT_53_BITS:\n+                           sum *= 2.0;\n+                        if (bit)\n+                            sum += 1.0;\n+                        --exactBitsLimit;\n+                        if (exactBitsLimit == 0) {\n+                            bit53 = bit;\n+                            state = AFTER_BIT_53;\n+                        }\n+                        break;\n+                      case AFTER_BIT_53:\n+                        bit54 = bit;\n+                        factor = 2.0;\n+                        state = ZEROS_AFTER_54;\n+                        break;\n+                      case ZEROS_AFTER_54:\n+                        if (bit) {\n+                            state = MIXED_AFTER_54;\n+                        }\n+                        // fallthrough\n+                      case MIXED_AFTER_54:\n+                        factor *= 2;\n+                        break;\n+                    }\n+                }\n+                switch (state) {\n+                  case SKIP_LEADING_ZEROS:\n+                    sum = 0.0;\n+                    break;\n+                  case FIRST_EXACT_53_BITS:\n+                  case AFTER_BIT_53:\n+                    // do nothing\n+                    break;\n+                  case ZEROS_AFTER_54:\n+                    // x1.1 -> x1 + 1 (round up)\n+                    // x0.1 -> x0 (round down)\n+                    if (bit54 & bit53)\n+                        sum += 1.0;\n+                    sum *= factor;\n+                    break;\n+                  case MIXED_AFTER_54:\n+                    // x.100...1.. -> x + 1 (round up)\n+                    // x.0anything -> x (round down)\n+                    if (bit54)\n+                        sum += 1.0;\n+                    sum *= factor;\n+                    break;\n+                }\n+            }\n+            /* We don't worry about inaccurate numbers for any other base. */\n+        }\n+        return sum;\n+    }\n+\n+\n+    /**\n+     * ToNumber applied to the String type\n+     *\n+     * See ECMA 9.3.1\n+     */\n+    public static double toNumber(String s) {\n+        int len = s.length();\n+        int start = 0;\n+        char startChar;\n+        for (;;) {\n+            if (start == len) {\n+                // Empty or contains only whitespace\n+                return +0.0;\n+            }\n+            startChar = s.charAt(start);\n+            if (!ScriptRuntime.isStrWhiteSpaceChar(startChar))\n+                break;\n+            start++;\n+        }\n+\n+        if (startChar == '0') {\n+            if (start + 2 < len) {\n+                int c1 = s.charAt(start + 1);\n+                if (c1 == 'x' || c1 == 'X') {\n+                    // A hexadecimal number\n+                    return stringToNumber(s, start + 2, 16);\n+                }\n+            }\n+        } else if (startChar == '+' || startChar == '-') {\n+            if (start + 3 < len && s.charAt(start + 1) == '0') {\n+                int c2 = s.charAt(start + 2);\n+                if (c2 == 'x' || c2 == 'X') {\n+                    // A hexadecimal number with sign\n+                    double val = stringToNumber(s, start + 3, 16);\n+                    return startChar == '-' ? -val : val;\n+                }\n+            }\n+        }\n+\n+        int end = len - 1;\n+        char endChar;\n+        while (ScriptRuntime.isStrWhiteSpaceChar(endChar = s.charAt(end)))\n+            end--;\n+        if (endChar == 'y') {\n+            // check for \"Infinity\"\n+            if (startChar == '+' || startChar == '-')\n+                start++;\n+            if (start + 7 == end && s.regionMatches(start, \"Infinity\", 0, 8))\n+                return startChar == '-'\n+                    ? Double.NEGATIVE_INFINITY\n+                    : Double.POSITIVE_INFINITY;\n+            return NaN;\n+        }\n+        // A non-hexadecimal, non-infinity number:\n+        // just try a normal floating point conversion\n+        String sub = s.substring(start, end+1);\n+        if (MSJVM_BUG_WORKAROUNDS) {\n+            // The MS JVM will accept non-conformant strings\n+            // rather than throwing a NumberFormatException\n+            // as it should.\n+            for (int i=sub.length()-1; i >= 0; i--) {\n+                char c = sub.charAt(i);\n+                if (('0' <= c && c <= '9') || c == '.' ||\n+                    c == 'e' || c == 'E'  ||\n+                    c == '+' || c == '-')\n+                    continue;\n+                return NaN;\n+            }\n+        }\n+        try {\n+            return Double.valueOf(sub).doubleValue();\n+        } catch (NumberFormatException ex) {\n+            return NaN;\n+        }\n+    }\n+\n+    /**\n+     * Helper function for builtin objects that use the varargs form.\n+     * ECMA function formal arguments are undefined if not supplied;\n+     * this function pads the argument array out to the expected\n+     * length, if necessary.\n+     */\n+    public static Object[] padArguments(Object[] args, int count) {\n+        if (count < args.length)\n+            return args;\n+\n+        int i;\n+        Object[] result = new Object[count];\n+        for (i = 0; i < args.length; i++) {\n+            result[i] = args[i];\n+        }\n+\n+        for (; i < count; i++) {\n+            result[i] = Undefined.instance;\n+        }\n+\n+        return result;\n+    }\n+\n+    /* Work around Microsoft Java VM bugs. */\n+    private final static boolean MSJVM_BUG_WORKAROUNDS = true;\n+\n+    public static String escapeString(String s)\n+    {\n+        return escapeString(s, '\"');\n+    }\n+\n+    /**\n+     * For escaping strings printed by object and array literals; not quite\n+     * the same as 'escape.'\n+     */\n+    public static String escapeString(String s, char escapeQuote)\n+    {\n+        if (!(escapeQuote == '\"' || escapeQuote == '\\'')) Kit.codeBug();\n+        StringBuffer sb = null;\n+\n+        for(int i = 0, L = s.length(); i != L; ++i) {\n+            int c = s.charAt(i);\n+\n+            if (' ' <= c && c <= '~' && c != escapeQuote && c != '\\\\') {\n+                // an ordinary print character (like C isprint()) and not \"\n+                // or \\ .\n+                if (sb != null) {\n+                    sb.append((char)c);\n+                }\n+                continue;\n+            }\n+            if (sb == null) {\n+                sb = new StringBuffer(L + 3);\n+                sb.append(s);\n+                sb.setLength(i);\n+            }\n+\n+            int escape = -1;\n+            switch (c) {\n+                case '\\b':  escape = 'b';  break;\n+                case '\\f':  escape = 'f';  break;\n+                case '\\n':  escape = 'n';  break;\n+                case '\\r':  escape = 'r';  break;\n+                case '\\t':  escape = 't';  break;\n+                case 0xb:   escape = 'v';  break; // Java lacks \\v.\n+                case ' ':   escape = ' ';  break;\n+                case '\\\\':  escape = '\\\\'; break;\n+            }\n+            if (escape >= 0) {\n+                // an \\escaped sort of character\n+                sb.append('\\\\');\n+                sb.append((char)escape);\n+            } else if (c == escapeQuote) {\n+                sb.append('\\\\');\n+                sb.append(escapeQuote);\n+            } else {\n+                int hexSize;\n+                if (c < 256) {\n+                    // 2-digit hex\n+                    sb.append(\"\\\\x\");\n+                    hexSize = 2;\n+                } else {\n+                    // Unicode.\n+                    sb.append(\"\\\\u\");\n+                    hexSize = 4;\n+                }\n+                // append hexadecimal form of c left-padded with 0\n+                for (int shift = (hexSize - 1) * 4; shift >= 0; shift -= 4) {\n+                    int digit = 0xf & (c >> shift);\n+                    int hc = (digit < 10) ? '0' + digit : 'a' - 10 + digit;\n+                    sb.append((char)hc);\n+                }\n+            }\n+        }\n+        return (sb == null) ? s : sb.toString();\n+    }\n+\n+    static boolean isValidIdentifierName(String s)\n+    {\n+        int L = s.length();\n+        if (L == 0)\n+            return false;\n+        if (!Character.isJavaIdentifierStart(s.charAt(0)))\n+            return false;\n+        for (int i = 1; i != L; ++i) {\n+            if (!Character.isJavaIdentifierPart(s.charAt(i)))\n+                return false;\n+        }\n+        return !TokenStream.isKeyword(s);\n+    }\n+\n+    /**\n+     * Convert the value to a string.\n+     *\n+     * See ECMA 9.8.\n+     */\n+    public static String toString(Object val) {\n+        for (;;) {\n+            if (val == null) {\n+                return \"null\";\n+            }\n+            if (val == Undefined.instance) {\n+                return \"undefined\";\n+            }\n+            if (val instanceof String) {\n+                return (String)val;\n+            }\n+            if (val instanceof Number) {\n+                // XXX should we just teach NativeNumber.stringValue()\n+                // about Numbers?\n+                return numberToString(((Number)val).doubleValue(), 10);\n+            }\n+            if (val instanceof Scriptable) {\n+                val = ((Scriptable) val).getDefaultValue(StringClass);\n+                if (val instanceof Scriptable) {\n+                    throw errorWithClassName(\"msg.primitive.expected\", val);\n+                }\n+                continue;\n+            }\n+            return val.toString();\n+        }\n+    }\n+\n+    static String defaultObjectToString(Scriptable obj)\n+    {\n+        return \"[object \" + obj.getClassName() + ']';\n+    }\n+\n+    public static String toString(Object[] args, int index)\n+    {\n+        return (index < args.length) ? toString(args[index]) : \"undefined\";\n+    }\n+\n+    /**\n+     * Optimized version of toString(Object) for numbers.\n+     */\n+    public static String toString(double val) {\n+        return numberToString(val, 10);\n+    }\n+\n+    public static String numberToString(double d, int base) {\n+        if (d != d)\n+            return \"NaN\";\n+        if (d == Double.POSITIVE_INFINITY)\n+            return \"Infinity\";\n+        if (d == Double.NEGATIVE_INFINITY)\n+            return \"-Infinity\";\n+        if (d == 0.0)\n+            return \"0\";\n+\n+        if ((base < 2) || (base > 36)) {\n+            throw Context.reportRuntimeError1(\n+                \"msg.bad.radix\", Integer.toString(base));\n+        }\n+\n+        if (base != 10) {\n+            return DToA.JS_dtobasestr(base, d);\n+        } else {\n+            StringBuffer result = new StringBuffer();\n+            DToA.JS_dtostr(result, DToA.DTOSTR_STANDARD, 0, d);\n+            return result.toString();\n+        }\n+\n+    }\n+\n+    static String uneval(Context cx, Scriptable scope, Object value)\n+    {\n+        if (value == null) {\n+            return \"null\";\n+        }\n+        if (value == Undefined.instance) {\n+            return \"undefined\";\n+        }\n+        if (value instanceof String) {\n+            String escaped = escapeString((String)value);\n+            StringBuffer sb = new StringBuffer(escaped.length() + 2);\n+            sb.append('\\\"');\n+            sb.append(escaped);\n+            sb.append('\\\"');\n+            return sb.toString();\n+        }\n+        if (value instanceof Number) {\n+            double d = ((Number)value).doubleValue();\n+            if (d == 0 && 1 / d < 0) {\n+                return \"-0\";\n+            }\n+            return toString(d);\n+        }\n+        if (value instanceof Boolean) {\n+            return toString(value);\n+        }\n+        if (value instanceof Scriptable) {\n+            Scriptable obj = (Scriptable)value;\n+            // Wrapped Java objects won't have \"toSource\" and will report\n+            // errors for get()s of nonexistent name, so use has() first\n+            if (ScriptableObject.hasProperty(obj, \"toSource\")) {\n+                Object v = ScriptableObject.getProperty(obj, \"toSource\");\n+                if (v instanceof Function) {\n+                    Function f = (Function)v;\n+                    return toString(f.call(cx, scope, obj, emptyArgs));\n+                }\n+            }\n+            return toString(value);\n+        }\n+        warnAboutNonJSObject(value);\n+        return value.toString();\n+    }\n+\n+    static String defaultObjectToSource(Context cx, Scriptable scope,\n+                                        Scriptable thisObj, Object[] args)\n+    {\n+        boolean toplevel, iterating;\n+        if (cx.iterating == null) {\n+            toplevel = true;\n+            iterating = false;\n+            cx.iterating = new ObjToIntMap(31);\n+        } else {\n+            toplevel = false;\n+            iterating = cx.iterating.has(thisObj);\n+        }\n+\n+        StringBuffer result = new StringBuffer(128);\n+        if (toplevel) {\n+            result.append(\"(\");\n+        }\n+        result.append('{');\n+\n+        // Make sure cx.iterating is set to null when done\n+        // so we don't leak memory\n+        try {\n+            if (!iterating) {\n+                cx.iterating.intern(thisObj); // stop recursion.\n+                Object[] ids = thisObj.getIds();\n+                for (int i=0; i < ids.length; i++) {\n+                    Object id = ids[i];\n+                    Object value;\n+                    if (id instanceof Integer) {\n+                        int intId = ((Integer)id).intValue();\n+                        value = thisObj.get(intId, thisObj);\n+                        if (value == Scriptable.NOT_FOUND)\n+                            continue;   // a property has been removed\n+                        if (i > 0)\n+                            result.append(\", \");\n+                        result.append(intId);\n+                    } else {\n+                        String strId = (String)id;\n+                        value = thisObj.get(strId, thisObj);\n+                        if (value == Scriptable.NOT_FOUND)\n+                            continue;   // a property has been removed\n+                        if (i > 0)\n+                            result.append(\", \");\n+                        if (ScriptRuntime.isValidIdentifierName(strId)) {\n+                            result.append(strId);\n+                        } else {\n+                            result.append('\\'');\n+                            result.append(\n+                                ScriptRuntime.escapeString(strId, '\\''));\n+                            result.append('\\'');\n+                        }\n+                    }\n+                    result.append(':');\n+                    result.append(ScriptRuntime.uneval(cx, scope, value));\n+                }\n+            }\n+        } finally {\n+            if (toplevel) {\n+                cx.iterating = null;\n+            }\n+        }\n+\n+        result.append('}');\n+        if (toplevel) {\n+            result.append(')');\n+        }\n+        return result.toString();\n+    }\n+\n+    public static Scriptable toObject(Scriptable scope, Object val)\n+    {\n+        if (val instanceof Scriptable) {\n+            return (Scriptable)val;\n+        }\n+        return toObject(Context.getContext(), scope, val);\n+    }\n+\n+    /**\n+     * Warning: this doesn't allow to resolve primitive prototype properly when many top scopes are involved\n+     */\n+    public static Scriptable toObjectOrNull(Context cx, Object obj)\n+    {\n+        if (obj instanceof Scriptable) {\n+            return (Scriptable)obj;\n+        } else if (obj != null && obj != Undefined.instance) {\n+            return toObject(cx, getTopCallScope(cx), obj);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param scope the scope that should be used to resolve primitive prototype\n+     */\n+    public static Scriptable toObjectOrNull(Context cx, Object obj,\n+                                            final Scriptable scope)\n+    {\n+        if (obj instanceof Scriptable) {\n+            return (Scriptable)obj;\n+        } else if (obj != null && obj != Undefined.instance) {\n+            return toObject(cx, scope, obj);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #toObject(Scriptable, Object)} instead.\n+     */\n+    public static Scriptable toObject(Scriptable scope, Object val,\n+                                      Class<?> staticClass)\n+    {\n+        if (val instanceof Scriptable) {\n+            return (Scriptable)val;\n+        }\n+        return toObject(Context.getContext(), scope, val);\n+    }\n+\n+    /**\n+     * Convert the value to an object.\n+     *\n+     * See ECMA 9.9.\n+     */\n+    public static Scriptable toObject(Context cx, Scriptable scope, Object val)\n+    {\n+        if (val instanceof Scriptable) {\n+            return (Scriptable) val;\n+        }\n+        if (val == null) {\n+            throw typeError0(\"msg.null.to.object\");\n+        }\n+        if (val == Undefined.instance) {\n+            throw typeError0(\"msg.undef.to.object\");\n+        }\n+        String className = val instanceof String ? \"String\" :\n+                           val instanceof Number ? \"Number\" :\n+                           val instanceof Boolean ? \"Boolean\" :\n+                           null;\n+        if (className != null) {\n+            Object[] args = { val };\n+            scope = ScriptableObject.getTopLevelScope(scope);\n+            return newObject(cx, scope, className, args);\n+        }\n+\n+        // Extension: Wrap as a LiveConnect object.\n+        Object wrapped = cx.getWrapFactory().wrap(cx, scope, val, null);\n+        if (wrapped instanceof Scriptable)\n+            return (Scriptable) wrapped;\n+        throw errorWithClassName(\"msg.invalid.type\", val);\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #toObject(Context, Scriptable, Object)} instead.\n+     */\n+    public static Scriptable toObject(Context cx, Scriptable scope, Object val,\n+                                      Class<?> staticClass)\n+    {\n+        return toObject(cx, scope, val);\n+    }\n+\n+    /**\n+     * @deprecated The method is only present for compatibility.\n+     */\n+    public static Object call(Context cx, Object fun, Object thisArg,\n+                              Object[] args, Scriptable scope)\n+    {\n+        if (!(fun instanceof Function)) {\n+            throw notFunctionError(toString(fun));\n+        }\n+        Function function = (Function)fun;\n+        Scriptable thisObj = toObjectOrNull(cx, thisArg);\n+        if (thisObj == null) {\n+            throw undefCallError(thisObj, \"function\");\n+        }\n+        return function.call(cx, scope, thisObj, args);\n+    }\n+\n+    public static Scriptable newObject(Context cx, Scriptable scope,\n+                                       String constructorName, Object[] args)\n+    {\n+        scope = ScriptableObject.getTopLevelScope(scope);\n+        Function ctor = getExistingCtor(cx, scope, constructorName);\n+        if (args == null) { args = ScriptRuntime.emptyArgs; }\n+        return ctor.construct(cx, scope, args);\n+    }\n+\n+    /**\n+     *\n+     * See ECMA 9.4.\n+     */\n+    public static double toInteger(Object val) {\n+        return toInteger(toNumber(val));\n+    }\n+\n+    // convenience method\n+    public static double toInteger(double d) {\n+        // if it's NaN\n+        if (d != d)\n+            return +0.0;\n+\n+        if (d == 0.0 ||\n+            d == Double.POSITIVE_INFINITY ||\n+            d == Double.NEGATIVE_INFINITY)\n+            return d;\n+\n+        if (d > 0.0)\n+            return Math.floor(d);\n+        else\n+            return Math.ceil(d);\n+    }\n+\n+    public static double toInteger(Object[] args, int index) {\n+        return (index < args.length) ? toInteger(args[index]) : +0.0;\n+    }\n+\n+    /**\n+     *\n+     * See ECMA 9.5.\n+     */\n+    public static int toInt32(Object val)\n+    {\n+        // short circuit for common integer values\n+        if (val instanceof Integer)\n+            return ((Integer)val).intValue();\n+\n+        return toInt32(toNumber(val));\n+    }\n+\n+    public static int toInt32(Object[] args, int index) {\n+        return (index < args.length) ? toInt32(args[index]) : 0;\n+    }\n+\n+    public static int toInt32(double d) {\n+        int id = (int)d;\n+        if (id == d) {\n+            // This covers -0.0 as well\n+            return id;\n+        }\n+\n+        if (d != d\n+            || d == Double.POSITIVE_INFINITY\n+            || d == Double.NEGATIVE_INFINITY)\n+        {\n+            return 0;\n+        }\n+\n+        d = (d >= 0) ? Math.floor(d) : Math.ceil(d);\n+\n+        double two32 = 4294967296.0;\n+        d = Math.IEEEremainder(d, two32);\n+        // (double)(long)d == d should hold here\n+\n+        long l = (long)d;\n+        // returning (int)d does not work as d can be outside int range\n+        // but the result must always be 32 lower bits of l\n+        return (int)l;\n+    }\n+\n+    /**\n+     * See ECMA 9.6.\n+     * @return long value representing 32 bits unsigned integer\n+     */\n+    public static long toUint32(double d) {\n+        long l = (long)d;\n+        if (l == d) {\n+            // This covers -0.0 as well\n+            return l & 0xffffffffL;\n+        }\n+\n+        if (d != d\n+            || d == Double.POSITIVE_INFINITY\n+            || d == Double.NEGATIVE_INFINITY)\n+        {\n+            return 0;\n+        }\n+\n+        d = (d >= 0) ? Math.floor(d) : Math.ceil(d);\n+\n+        // 0x100000000 gives me a numeric overflow...\n+        double two32 = 4294967296.0;\n+        l = (long)Math.IEEEremainder(d, two32);\n+\n+        return l & 0xffffffffL;\n+    }\n+\n+    public static long toUint32(Object val) {\n+        return toUint32(toNumber(val));\n+    }\n+\n+    /**\n+     *\n+     * See ECMA 9.7.\n+     */\n+    public static char toUint16(Object val) {\n+        double d = toNumber(val);\n+\n+        int i = (int)d;\n+        if (i == d) {\n+            return (char)i;\n+        }\n+\n+        if (d != d\n+            || d == Double.POSITIVE_INFINITY\n+            || d == Double.NEGATIVE_INFINITY)\n+        {\n+            return 0;\n+        }\n+\n+        d = (d >= 0) ? Math.floor(d) : Math.ceil(d);\n+\n+        int int16 = 0x10000;\n+        i = (int)Math.IEEEremainder(d, int16);\n+\n+        return (char)i;\n+    }\n+\n+    // XXX: this is until setDefaultNamespace will learn how to store NS\n+    // properly and separates namespace form Scriptable.get etc.\n+    private static final String DEFAULT_NS_TAG = \"__default_namespace__\";\n+\n+    public static Object setDefaultNamespace(Object namespace, Context cx)\n+    {\n+        Scriptable scope = cx.currentActivationCall;\n+        if (scope == null) {\n+            scope = getTopCallScope(cx);\n+        }\n+\n+        XMLLib xmlLib = currentXMLLib(cx);\n+        Object ns = xmlLib.toDefaultXmlNamespace(cx, namespace);\n+\n+        // XXX : this should be in separated namesapce from Scriptable.get/put\n+        if (!scope.has(DEFAULT_NS_TAG, scope)) {\n+            // XXX: this is racy of cause\n+            ScriptableObject.defineProperty(scope, DEFAULT_NS_TAG, ns,\n+                                            ScriptableObject.PERMANENT\n+                                            | ScriptableObject.DONTENUM);\n+        } else {\n+            scope.put(DEFAULT_NS_TAG, scope, ns);\n+        }\n+\n+        return Undefined.instance;\n+    }\n+\n+    public static Object searchDefaultNamespace(Context cx)\n+    {\n+        Scriptable scope = cx.currentActivationCall;\n+        if (scope == null) {\n+            scope = getTopCallScope(cx);\n+        }\n+        Object nsObject;\n+        for (;;) {\n+            Scriptable parent = scope.getParentScope();\n+            if (parent == null) {\n+                nsObject = ScriptableObject.getProperty(scope, DEFAULT_NS_TAG);\n+                if (nsObject == Scriptable.NOT_FOUND) {\n+                    return null;\n+                }\n+                break;\n+            }\n+            nsObject = scope.get(DEFAULT_NS_TAG, scope);\n+            if (nsObject != Scriptable.NOT_FOUND) {\n+                break;\n+            }\n+            scope = parent;\n+        }\n+        return nsObject;\n+    }\n+\n+    public static Object getTopLevelProp(Scriptable scope, String id) {\n+        scope = ScriptableObject.getTopLevelScope(scope);\n+        return ScriptableObject.getProperty(scope, id);\n+    }\n+\n+    static Function getExistingCtor(Context cx, Scriptable scope,\n+                                    String constructorName)\n+    {\n+        Object ctorVal = ScriptableObject.getProperty(scope, constructorName);\n+        if (ctorVal instanceof Function) {\n+            return (Function)ctorVal;\n+        }\n+        if (ctorVal == Scriptable.NOT_FOUND) {\n+            throw Context.reportRuntimeError1(\n+                \"msg.ctor.not.found\", constructorName);\n+        } else {\n+            throw Context.reportRuntimeError1(\n+                \"msg.not.ctor\", constructorName);\n+        }\n+    }\n+\n+    /**\n+     * Return -1L if str is not an index or the index value as lower 32\n+     * bits of the result.\n+     */\n+    private static long indexFromString(String str)\n+    {\n+        // The length of the decimal string representation of\n+        //  Integer.MAX_VALUE, 2147483647\n+        final int MAX_VALUE_LENGTH = 10;\n+\n+        int len = str.length();\n+        if (len > 0) {\n+            int i = 0;\n+            boolean negate = false;\n+            int c = str.charAt(0);\n+            if (c == '-') {\n+                if (len > 1) {\n+                    c = str.charAt(1);\n+                    i = 1;\n+                    negate = true;\n+                }\n+            }\n+            c -= '0';\n+            if (0 <= c && c <= 9\n+                && len <= (negate ? MAX_VALUE_LENGTH + 1 : MAX_VALUE_LENGTH))\n+            {\n+                // Use negative numbers to accumulate index to handle\n+                // Integer.MIN_VALUE that is greater by 1 in absolute value\n+                // then Integer.MAX_VALUE\n+                int index = -c;\n+                int oldIndex = 0;\n+                i++;\n+                if (index != 0) {\n+                    // Note that 00, 01, 000 etc. are not indexes\n+                    while (i != len && 0 <= (c = str.charAt(i) - '0') && c <= 9)\n+                    {\n+                        oldIndex = index;\n+                        index = 10 * index - c;\n+                        i++;\n+                    }\n+                }\n+                // Make sure all characters were consumed and that it couldn't\n+                // have overflowed.\n+                if (i == len &&\n+                    (oldIndex > (Integer.MIN_VALUE / 10) ||\n+                     (oldIndex == (Integer.MIN_VALUE / 10) &&\n+                      c <= (negate ? -(Integer.MIN_VALUE % 10)\n+                                   : (Integer.MAX_VALUE % 10)))))\n+                {\n+                    return 0xFFFFFFFFL & (negate ? index : -index);\n+                }\n+            }\n+        }\n+        return -1L;\n+    }\n+\n+    /**\n+     * If str is a decimal presentation of Uint32 value, return it as long.\n+     * Othewise return -1L;\n+     */\n+    public static long testUint32String(String str)\n+    {\n+        // The length of the decimal string representation of\n+        //  UINT32_MAX_VALUE, 4294967296\n+        final int MAX_VALUE_LENGTH = 10;\n+\n+        int len = str.length();\n+        if (1 <= len && len <= MAX_VALUE_LENGTH) {\n+            int c = str.charAt(0);\n+            c -= '0';\n+            if (c == 0) {\n+                // Note that 00,01 etc. are not valid Uint32 presentations\n+                return (len == 1) ? 0L : -1L;\n+            }\n+            if (1 <= c && c <= 9) {\n+                long v = c;\n+                for (int i = 1; i != len; ++i) {\n+                    c = str.charAt(i) - '0';\n+                    if (!(0 <= c && c <= 9)) {\n+                        return -1;\n+                    }\n+                    v = 10 * v + c;\n+                }\n+                // Check for overflow\n+                if ((v >>> 32) == 0) {\n+                    return v;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * If s represents index, then return index value wrapped as Integer\n+     * and othewise return s.\n+     */\n+    static Object getIndexObject(String s)\n+    {\n+        long indexTest = indexFromString(s);\n+        if (indexTest >= 0) {\n+            return Integer.valueOf((int)indexTest);\n+        }\n+        return s;\n+    }\n+\n+    /**\n+     * If d is exact int value, return its value wrapped as Integer\n+     * and othewise return d converted to String.\n+     */\n+    static Object getIndexObject(double d)\n+    {\n+        int i = (int)d;\n+        if (i == d) {\n+            return Integer.valueOf(i);\n+        }\n+        return toString(d);\n+    }\n+\n+    /**\n+     * If toString(id) is a decimal presentation of int32 value, then id\n+     * is index. In this case return null and make the index available\n+     * as ScriptRuntime.lastIndexResult(cx). Otherwise return toString(id).\n+     */\n+    static String toStringIdOrIndex(Context cx, Object id)\n+    {\n+        if (id instanceof Number) {\n+            double d = ((Number)id).doubleValue();\n+            int index = (int)d;\n+            if (index == d) {\n+                storeIndexResult(cx, index);\n+                return null;\n+            }\n+            return toString(id);\n+        } else {\n+            String s;\n+            if (id instanceof String) {\n+                s = (String)id;\n+            } else {\n+                s = toString(id);\n+            }\n+            long indexTest = indexFromString(s);\n+            if (indexTest >= 0) {\n+                storeIndexResult(cx, (int)indexTest);\n+                return null;\n+            }\n+            return s;\n+        }\n+    }\n+\n+    /**\n+     * Call obj.[[Get]](id)\n+     */\n+    public static Object getObjectElem(Object obj, Object elem, Context cx)\n+    {\n+    \treturn getObjectElem(obj, elem, cx, getTopCallScope(cx));\n+    }\n+\n+    /**\n+     * Call obj.[[Get]](id)\n+     */\n+    public static Object getObjectElem(Object obj, Object elem, Context cx, final Scriptable scope)\n+    {\n+        Scriptable sobj = toObjectOrNull(cx, obj, scope);\n+        if (sobj == null) {\n+            throw undefReadError(obj, elem);\n+        }\n+        return getObjectElem(sobj, elem, cx);\n+    }\n+\n+    public static Object getObjectElem(Scriptable obj, Object elem,\n+                                       Context cx)\n+    {\n+        if (obj instanceof XMLObject) {\n+            XMLObject xmlObject = (XMLObject)obj;\n+            return xmlObject.ecmaGet(cx, elem);\n+        }\n+\n+        Object result;\n+\n+        String s = toStringIdOrIndex(cx, elem);\n+        if (s == null) {\n+            int index = lastIndexResult(cx);\n+            result = ScriptableObject.getProperty(obj, index);\n+        } else {\n+            result = ScriptableObject.getProperty(obj, s);\n+        }\n+\n+        if (result == Scriptable.NOT_FOUND) {\n+            result = Undefined.instance;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Version of getObjectElem when elem is a valid JS identifier name.\n+     */\n+    public static Object getObjectProp(Object obj, String property,\n+                                       Context cx)\n+    {\n+        Scriptable sobj = toObjectOrNull(cx, obj);\n+        if (sobj == null) {\n+            throw undefReadError(obj, property);\n+        }\n+        return getObjectProp(sobj, property, cx);\n+    }\n+\n+    /**\n+     * @param scope the scope that should be used to resolve primitive prototype\n+     */\n+    public static Object getObjectProp(Object obj, String property,\n+                                       Context cx, final Scriptable scope)\n+    {\n+        Scriptable sobj = toObjectOrNull(cx, obj, scope);\n+        if (sobj == null) {\n+            throw undefReadError(obj, property);\n+        }\n+        return getObjectProp(sobj, property, cx);\n+    }\n+\n+    public static Object getObjectProp(Scriptable obj, String property,\n+                                       Context cx)\n+    {\n+        if (obj instanceof XMLObject) {\n+            // TODO: Change XMLObject to just use Scriptable interface\n+            // to avoid paying cost of instanceof check on *every property\n+            // lookup* !\n+            XMLObject xmlObject = (XMLObject)obj;\n+            return xmlObject.ecmaGet(cx, property);\n+        }\n+\n+        Object result = ScriptableObject.getProperty(obj, property);\n+        if (result == Scriptable.NOT_FOUND) {\n+            if (cx.hasFeature(Context.FEATURE_STRICT_MODE)) {\n+                Context.reportWarning(ScriptRuntime.getMessage1(\n+                    \"msg.ref.undefined.prop\", property));\n+            }\n+            result = Undefined.instance;\n+        }\n+\n+        return result;\n+    }\n+\n+    public static Object getObjectPropNoWarn(Object obj, String property,\n+                                             Context cx)\n+    {\n+        Scriptable sobj = toObjectOrNull(cx, obj);\n+        if (sobj == null) {\n+            throw undefReadError(obj, property);\n+        }\n+        if (obj instanceof XMLObject) {\n+            // TODO: fix as mentioned in note in method above\n+            getObjectProp(sobj, property, cx);\n+        }\n+        Object result = ScriptableObject.getProperty(sobj, property);\n+        if (result == Scriptable.NOT_FOUND) {\n+          return Undefined.instance;\n+        }\n+        return result;\n+    }\n+\n+    /*\n+     * A cheaper and less general version of the above for well-known argument\n+     * types.\n+     */\n+    public static Object getObjectIndex(Object obj, double dblIndex,\n+                                        Context cx)\n+    {\n+        Scriptable sobj = toObjectOrNull(cx, obj);\n+        if (sobj == null) {\n+            throw undefReadError(obj, toString(dblIndex));\n+        }\n+\n+        int index = (int)dblIndex;\n+        if (index == dblIndex) {\n+            return getObjectIndex(sobj, index, cx);\n+        } else {\n+            String s = toString(dblIndex);\n+            return getObjectProp(sobj, s, cx);\n+        }\n+    }\n+\n+    public static Object getObjectIndex(Scriptable obj, int index,\n+                                        Context cx)\n+    {\n+        if (obj instanceof XMLObject) {\n+            XMLObject xmlObject = (XMLObject)obj;\n+            return xmlObject.ecmaGet(cx, Integer.valueOf(index));\n+        }\n+\n+        Object result = ScriptableObject.getProperty(obj, index);\n+        if (result == Scriptable.NOT_FOUND) {\n+            result = Undefined.instance;\n+        }\n+\n+        return result;\n+    }\n+\n+    /*\n+     * Call obj.[[Put]](id, value)\n+     */\n+    public static Object setObjectElem(Object obj, Object elem, Object value,\n+                                       Context cx)\n+    {\n+        Scriptable sobj = toObjectOrNull(cx, obj);\n+        if (sobj == null) {\n+            throw undefWriteError(obj, elem, value);\n+        }\n+        return setObjectElem(sobj, elem, value, cx);\n+    }\n+\n+    public static Object setObjectElem(Scriptable obj, Object elem,\n+                                       Object value, Context cx)\n+    {\n+        if (obj instanceof XMLObject) {\n+            XMLObject xmlObject = (XMLObject)obj;\n+            xmlObject.ecmaPut(cx, elem, value);\n+            return value;\n+        }\n+\n+        String s = toStringIdOrIndex(cx, elem);\n+        if (s == null) {\n+            int index = lastIndexResult(cx);\n+            ScriptableObject.putProperty(obj, index, value);\n+        } else {\n+            ScriptableObject.putProperty(obj, s, value);\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Version of setObjectElem when elem is a valid JS identifier name.\n+     */\n+    public static Object setObjectProp(Object obj, String property,\n+                                       Object value, Context cx)\n+    {\n+        Scriptable sobj = toObjectOrNull(cx, obj);\n+        if (sobj == null) {\n+            throw undefWriteError(obj, property, value);\n+        }\n+        return setObjectProp(sobj, property, value, cx);\n+    }\n+\n+    public static Object setObjectProp(Scriptable obj, String property,\n+                                       Object value, Context cx)\n+    {\n+        if (obj instanceof XMLObject) {\n+            XMLObject xmlObject = (XMLObject)obj;\n+            xmlObject.ecmaPut(cx, property, value);\n+        } else {\n+            ScriptableObject.putProperty(obj, property, value);\n+        }\n+        return value;\n+    }\n+\n+    /*\n+     * A cheaper and less general version of the above for well-known argument\n+     * types.\n+     */\n+    public static Object setObjectIndex(Object obj, double dblIndex,\n+                                        Object value, Context cx)\n+    {\n+        Scriptable sobj = toObjectOrNull(cx, obj);\n+        if (sobj == null) {\n+            throw undefWriteError(obj, String.valueOf(dblIndex), value);\n+        }\n+\n+        int index = (int)dblIndex;\n+        if (index == dblIndex) {\n+            return setObjectIndex(sobj, index, value, cx);\n+        } else {\n+            String s = toString(dblIndex);\n+            return setObjectProp(sobj, s, value, cx);\n+        }\n+    }\n+\n+    public static Object setObjectIndex(Scriptable obj, int index, Object value,\n+                                        Context cx)\n+    {\n+        if (obj instanceof XMLObject) {\n+            XMLObject xmlObject = (XMLObject)obj;\n+            xmlObject.ecmaPut(cx, Integer.valueOf(index), value);\n+        } else {\n+            ScriptableObject.putProperty(obj, index, value);\n+        }\n+        return value;\n+    }\n+\n+    public static boolean deleteObjectElem(Scriptable target, Object elem,\n+                                           Context cx)\n+    {\n+        boolean result;\n+        if (target instanceof XMLObject) {\n+            XMLObject xmlObject = (XMLObject)target;\n+            result = xmlObject.ecmaDelete(cx, elem);\n+        } else {\n+            String s = toStringIdOrIndex(cx, elem);\n+            if (s == null) {\n+                int index = lastIndexResult(cx);\n+            \ttarget.delete(index);\n+                return !target.has(index, target);\n+            } else {\n+            \ttarget.delete(s);\n+                return !target.has(s, target);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public static boolean hasObjectElem(Scriptable target, Object elem,\n+                                        Context cx)\n+    {\n+        boolean result;\n+\n+        if (target instanceof XMLObject) {\n+            XMLObject xmlObject = (XMLObject)target;\n+            result = xmlObject.ecmaHas(cx, elem);\n+        } else {\n+            String s = toStringIdOrIndex(cx, elem);\n+            if (s == null) {\n+                int index = lastIndexResult(cx);\n+                result = ScriptableObject.hasProperty(target, index);\n+            } else {\n+                result = ScriptableObject.hasProperty(target, s);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public static Object refGet(Ref ref, Context cx)\n+    {\n+        return ref.get(cx);\n+    }\n+\n+    public static Object refSet(Ref ref, Object value, Context cx)\n+    {\n+        return ref.set(cx, value);\n+    }\n+\n+    public static Object refDel(Ref ref, Context cx)\n+    {\n+        return wrapBoolean(ref.delete(cx));\n+    }\n+\n+    static boolean isSpecialProperty(String s)\n+    {\n+        return s.equals(\"__proto__\") || s.equals(\"__parent__\");\n+    }\n+\n+    public static Ref specialRef(Object obj, String specialProperty,\n+                                 Context cx)\n+    {\n+        return SpecialRef.createSpecial(cx, obj, specialProperty);\n+    }\n+\n+    /**\n+     * The delete operator\n+     *\n+     * See ECMA 11.4.1\n+     *\n+     * In ECMA 0.19, the description of the delete operator (11.4.1)\n+     * assumes that the [[Delete]] method returns a value. However,\n+     * the definition of the [[Delete]] operator (8.6.2.5) does not\n+     * define a return value. Here we assume that the [[Delete]]\n+     * method doesn't return a value.\n+     */\n+    public static Object delete(Object obj, Object id, Context cx)\n+    {\n+        Scriptable sobj = toObjectOrNull(cx, obj);\n+        if (sobj == null) {\n+            String idStr = (id == null) ? \"null\" : id.toString();\n+            throw typeError2(\"msg.undef.prop.delete\", toString(obj), idStr);\n+        }\n+        boolean result = deleteObjectElem(sobj, id, cx);\n+        return wrapBoolean(result);\n+    }\n+\n+    /**\n+     * Looks up a name in the scope chain and returns its value.\n+     */\n+    public static Object name(Context cx, Scriptable scope, String name)\n+    {\n+        Scriptable parent = scope.getParentScope();\n+        if (parent == null) {\n+            Object result = topScopeName(cx, scope, name);\n+            if (result == Scriptable.NOT_FOUND) {\n+                throw notFoundError(scope, name);\n+            }\n+            return result;\n+        }\n+\n+        return nameOrFunction(cx, scope, parent, name, false);\n+    }\n+\n+    private static Object nameOrFunction(Context cx, Scriptable scope,\n+                                         Scriptable parentScope, String name,\n+                                         boolean asFunctionCall)\n+    {\n+        Object result;\n+        Scriptable thisObj = scope; // It is used only if asFunctionCall==true.\n+\n+        XMLObject firstXMLObject = null;\n+        for (;;) {\n+            if (scope instanceof NativeWith) {\n+                Scriptable withObj = scope.getPrototype();\n+                if (withObj instanceof XMLObject) {\n+                    XMLObject xmlObj = (XMLObject)withObj;\n+                    if (xmlObj.ecmaHas(cx, name)) {\n+                        // function this should be the target object of with\n+                        thisObj = xmlObj;\n+                        result = xmlObj.ecmaGet(cx, name);\n+                        break;\n+                    }\n+                    if (firstXMLObject == null) {\n+                        firstXMLObject = xmlObj;\n+                    }\n+                } else {\n+                    result = ScriptableObject.getProperty(withObj, name);\n+                    if (result != Scriptable.NOT_FOUND) {\n+                        // function this should be the target object of with\n+                        thisObj = withObj;\n+                        break;\n+                    }\n+                }\n+            } else if (scope instanceof NativeCall) {\n+                // NativeCall does not prototype chain and Scriptable.get\n+                // can be called directly.\n+                result = scope.get(name, scope);\n+                if (result != Scriptable.NOT_FOUND) {\n+                    if (asFunctionCall) {\n+                        // ECMA 262 requires that this for nested funtions\n+                        // should be top scope\n+                        thisObj = ScriptableObject.\n+                                      getTopLevelScope(parentScope);\n+                    }\n+                    break;\n+                }\n+            } else {\n+                // Can happen if Rhino embedding decided that nested\n+                // scopes are useful for what ever reasons.\n+                result = ScriptableObject.getProperty(scope, name);\n+                if (result != Scriptable.NOT_FOUND) {\n+                    thisObj = scope;\n+                    break;\n+                }\n+            }\n+            scope = parentScope;\n+            parentScope = parentScope.getParentScope();\n+            if (parentScope == null) {\n+                result = topScopeName(cx, scope, name);\n+                if (result == Scriptable.NOT_FOUND) {\n+                    if (firstXMLObject == null || asFunctionCall) {\n+                        throw notFoundError(scope, name);\n+                    }\n+                    // The name was not found, but we did find an XML\n+                    // object in the scope chain and we are looking for name,\n+                    // not function. The result should be an empty XMLList\n+                    // in name context.\n+                    result = firstXMLObject.ecmaGet(cx, name);\n+                }\n+                // For top scope thisObj for functions is always scope itself.\n+                thisObj = scope;\n+                break;\n+            }\n+        }\n+\n+        if (asFunctionCall) {\n+            if (!(result instanceof Callable)) {\n+                throw notFunctionError(result, name);\n+            }\n+            storeScriptable(cx, thisObj);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static Object topScopeName(Context cx, Scriptable scope,\n+                                       String name)\n+    {\n+        if (cx.useDynamicScope) {\n+            scope = checkDynamicScope(cx.topCallScope, scope);\n+        }\n+        return ScriptableObject.getProperty(scope, name);\n+    }\n+\n+\n+    /**\n+     * Returns the object in the scope chain that has a given property.\n+     *\n+     * The order of evaluation of an assignment expression involves\n+     * evaluating the lhs to a reference, evaluating the rhs, and then\n+     * modifying the reference with the rhs value. This method is used\n+     * to 'bind' the given name to an object containing that property\n+     * so that the side effects of evaluating the rhs do not affect\n+     * which property is modified.\n+     * Typically used in conjunction with setName.\n+     *\n+     * See ECMA 10.1.4\n+     */\n+    public static Scriptable bind(Context cx, Scriptable scope, String id)\n+    {\n+        Scriptable firstXMLObject = null;\n+        Scriptable parent = scope.getParentScope();\n+        childScopesChecks: if (parent != null) {\n+            // Check for possibly nested \"with\" scopes first\n+            while (scope instanceof NativeWith) {\n+                Scriptable withObj = scope.getPrototype();\n+                if (withObj instanceof XMLObject) {\n+                    XMLObject xmlObject = (XMLObject)withObj;\n+                    if (xmlObject.ecmaHas(cx, id)) {\n+                        return xmlObject;\n+                    }\n+                    if (firstXMLObject == null) {\n+                        firstXMLObject = xmlObject;\n+                    }\n+                } else {\n+                    if (ScriptableObject.hasProperty(withObj, id)) {\n+                        return withObj;\n+                    }\n+                }\n+                scope = parent;\n+                parent = parent.getParentScope();\n+                if (parent == null) {\n+                    break childScopesChecks;\n+                }\n+            }\n+            for (;;) {\n+                if (ScriptableObject.hasProperty(scope, id)) {\n+                    return scope;\n+                }\n+                scope = parent;\n+                parent = parent.getParentScope();\n+                if (parent == null) {\n+                    break childScopesChecks;\n+                }\n+            }\n+        }\n+        // scope here is top scope\n+        if (cx.useDynamicScope) {\n+            scope = checkDynamicScope(cx.topCallScope, scope);\n+        }\n+        if (ScriptableObject.hasProperty(scope, id)) {\n+            return scope;\n+        }\n+        // Nothing was found, but since XML objects always bind\n+        // return one if found\n+        return firstXMLObject;\n+    }\n+\n+    public static Object setName(Scriptable bound, Object value,\n+                                 Context cx, Scriptable scope, String id)\n+    {\n+        if (bound != null) {\n+            if (bound instanceof XMLObject) {\n+                XMLObject xmlObject = (XMLObject)bound;\n+                xmlObject.ecmaPut(cx, id, value);\n+            } else {\n+                ScriptableObject.putProperty(bound, id, value);\n+            }\n+        } else {\n+            // \"newname = 7;\", where 'newname' has not yet\n+            // been defined, creates a new property in the\n+            // top scope unless strict mode is specified.\n+            if (cx.hasFeature(Context.FEATURE_STRICT_MODE) ||\n+                cx.hasFeature(Context.FEATURE_STRICT_VARS))\n+            {\n+                Context.reportWarning(\n+                    ScriptRuntime.getMessage1(\"msg.assn.create.strict\", id));\n+            }\n+            // Find the top scope by walking up the scope chain.\n+            bound = ScriptableObject.getTopLevelScope(scope);\n+            if (cx.useDynamicScope) {\n+                bound = checkDynamicScope(cx.topCallScope, bound);\n+            }\n+            bound.put(id, bound, value);\n+        }\n+        return value;\n+    }\n+\n+    public static Object strictSetName(Scriptable bound, Object value,\n+            Context cx, Scriptable scope, String id) {\n+        if (bound != null) {\n+            // TODO: The LeftHandSide also may not be a reference to a\n+            // data property with the attribute value {[[Writable]]:false},\n+            // to an accessor property with the attribute value\n+            // {[[Put]]:undefined}, nor to a non-existent property of an\n+            // object whose [[Extensible]] internal property has the value\n+            // false. In these cases a TypeError exception is thrown (11.13.1).\n+            if (bound instanceof XMLObject) {\n+                XMLObject xmlObject = (XMLObject) bound;\n+                xmlObject.ecmaPut(cx, id, value);\n+            } else {\n+                ScriptableObject.putProperty(bound, id, value);\n+            }\n+        } else {\n+            // See ES5 8.7.2\n+            int[] linep = new int[1];\n+            String filename = Context.getSourcePositionFromStack(linep);\n+            throw new JavaScriptException(cx.newObject(scope, \"ReferenceError\",\n+                    new Object[] { id }),\n+                    filename,\n+                    linep[0]);\n+        }\n+        return value;\n+    }\n+\n+    public static Object setConst(Scriptable bound, Object value,\n+                                 Context cx, String id)\n+    {\n+        if (bound instanceof XMLObject) {\n+            XMLObject xmlObject = (XMLObject)bound;\n+            xmlObject.ecmaPut(cx, id, value);\n+        } else {\n+            ScriptableObject.putConstProperty(bound, id, value);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * This is the enumeration needed by the for..in statement.\n+     *\n+     * See ECMA 12.6.3.\n+     *\n+     * IdEnumeration maintains a ObjToIntMap to make sure a given\n+     * id is enumerated only once across multiple objects in a\n+     * prototype chain.\n+     *\n+     * XXX - ECMA delete doesn't hide properties in the prototype,\n+     * but js/ref does. This means that the js/ref for..in can\n+     * avoid maintaining a hash table and instead perform lookups\n+     * to see if a given property has already been enumerated.\n+     *\n+     */\n+    private static class IdEnumeration implements Serializable\n+    {\n+        private static final long serialVersionUID = 1L;\n+        Scriptable obj;\n+        Object[] ids;\n+        int index;\n+        ObjToIntMap used;\n+        Object currentId;\n+        int enumType; /* one of ENUM_INIT_KEYS, ENUM_INIT_VALUES,\n+                         ENUM_INIT_ARRAY */\n+\n+        // if true, integer ids will be returned as numbers rather than strings\n+        boolean enumNumbers;\n+\n+        Scriptable iterator;\n+    }\n+\n+    public static Scriptable toIterator(Context cx, Scriptable scope,\n+                                        Scriptable obj, boolean keyOnly)\n+    {\n+        if (ScriptableObject.hasProperty(obj,\n+            NativeIterator.ITERATOR_PROPERTY_NAME))\n+        {\n+            Object v = ScriptableObject.getProperty(obj,\n+                NativeIterator.ITERATOR_PROPERTY_NAME);\n+            if (!(v instanceof Callable)) {\n+               throw typeError0(\"msg.invalid.iterator\");\n+            }\n+            Callable f = (Callable) v;\n+            Object[] args = new Object[] { keyOnly ? Boolean.TRUE\n+                                                   : Boolean.FALSE };\n+            v = f.call(cx, scope, obj, args);\n+            if (!(v instanceof Scriptable)) {\n+                throw typeError0(\"msg.iterator.primitive\");\n+            }\n+            return (Scriptable) v;\n+        }\n+        return null;\n+    }\n+\n+    // for backwards compatibility with generated class files\n+    public static Object enumInit(Object value, Context cx, boolean enumValues)\n+    {\n+        return enumInit(value, cx, enumValues ? ENUMERATE_VALUES\n+                                              : ENUMERATE_KEYS);\n+    }\n+\n+    public static final int ENUMERATE_KEYS = 0;\n+    public static final int ENUMERATE_VALUES = 1;\n+    public static final int ENUMERATE_ARRAY = 2;\n+    public static final int ENUMERATE_KEYS_NO_ITERATOR = 3;\n+    public static final int ENUMERATE_VALUES_NO_ITERATOR = 4;\n+    public static final int ENUMERATE_ARRAY_NO_ITERATOR = 5;\n+\n+    public static Object enumInit(Object value, Context cx, int enumType)\n+    {\n+        IdEnumeration x = new IdEnumeration();\n+        x.obj = toObjectOrNull(cx, value);\n+        if (x.obj == null) {\n+            // null or undefined do not cause errors but rather lead to empty\n+            // \"for in\" loop\n+            return x;\n+        }\n+        x.enumType = enumType;\n+        x.iterator = null;\n+        if (enumType != ENUMERATE_KEYS_NO_ITERATOR &&\n+            enumType != ENUMERATE_VALUES_NO_ITERATOR &&\n+            enumType != ENUMERATE_ARRAY_NO_ITERATOR)\n+        {\n+            x.iterator = toIterator(cx, x.obj.getParentScope(), x.obj,\n+                                    enumType == ScriptRuntime.ENUMERATE_KEYS);\n+        }\n+        if (x.iterator == null) {\n+            // enumInit should read all initial ids before returning\n+            // or \"for (a.i in a)\" would wrongly enumerate i in a as well\n+            enumChangeObject(x);\n+        }\n+\n+        return x;\n+    }\n+\n+    public static void setEnumNumbers(Object enumObj, boolean enumNumbers) {\n+        ((IdEnumeration)enumObj).enumNumbers = enumNumbers;\n+    }\n+\n+    public static Boolean enumNext(Object enumObj)\n+    {\n+        IdEnumeration x = (IdEnumeration)enumObj;\n+        if (x.iterator != null) {\n+            Object v = ScriptableObject.getProperty(x.iterator, \"next\");\n+            if (!(v instanceof Callable))\n+                return Boolean.FALSE;\n+            Callable f = (Callable) v;\n+            Context cx = Context.getContext();\n+            try {\n+                x.currentId = f.call(cx, x.iterator.getParentScope(),\n+                                     x.iterator, emptyArgs);\n+                return Boolean.TRUE;\n+            } catch (JavaScriptException e) {\n+                if (e.getValue() instanceof NativeIterator.StopIteration) {\n+                  return Boolean.FALSE;\n+                }\n+                throw e;\n+            }\n+        }\n+        for (;;) {\n+            if (x.obj == null) {\n+                return Boolean.FALSE;\n+            }\n+            if (x.index == x.ids.length) {\n+                x.obj = x.obj.getPrototype();\n+                enumChangeObject(x);\n+                continue;\n+            }\n+            Object id = x.ids[x.index++];\n+            if (x.used != null && x.used.has(id)) {\n+                continue;\n+            }\n+            if (id instanceof String) {\n+                String strId = (String)id;\n+                if (!x.obj.has(strId, x.obj))\n+                    continue;   // must have been deleted\n+                x.currentId = strId;\n+            } else {\n+                int intId = ((Number)id).intValue();\n+                if (!x.obj.has(intId, x.obj))\n+                    continue;   // must have been deleted\n+                x.currentId = x.enumNumbers ? (Object) (Integer.valueOf(intId))\n+                                            : String.valueOf(intId);\n+            }\n+            return Boolean.TRUE;\n+        }\n+    }\n+\n+    public static Object enumId(Object enumObj, Context cx)\n+    {\n+        IdEnumeration x = (IdEnumeration)enumObj;\n+        if (x.iterator != null) {\n+            return x.currentId;\n+        }\n+        switch (x.enumType) {\n+          case ENUMERATE_KEYS:\n+          case ENUMERATE_KEYS_NO_ITERATOR:\n+            return x.currentId;\n+          case ENUMERATE_VALUES:\n+          case ENUMERATE_VALUES_NO_ITERATOR:\n+            return enumValue(enumObj, cx);\n+          case ENUMERATE_ARRAY:\n+          case ENUMERATE_ARRAY_NO_ITERATOR:\n+            Object[] elements = { x.currentId, enumValue(enumObj, cx) };\n+            return cx.newArray(ScriptableObject.getTopLevelScope(x.obj), elements);\n+          default:\n+            throw Kit.codeBug();\n+        }\n+    }\n+\n+    public static Object enumValue(Object enumObj, Context cx) {\n+        IdEnumeration x = (IdEnumeration)enumObj;\n+\n+        Object result;\n+\n+        String s = toStringIdOrIndex(cx, x.currentId);\n+        if (s == null) {\n+            int index = lastIndexResult(cx);\n+            result = x.obj.get(index, x.obj);\n+        } else {\n+            result = x.obj.get(s, x.obj);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static void enumChangeObject(IdEnumeration x)\n+    {\n+        Object[] ids = null;\n+        while (x.obj != null) {\n+            ids = x.obj.getIds();\n+            if (ids.length != 0) {\n+                break;\n+            }\n+            x.obj = x.obj.getPrototype();\n+        }\n+        if (x.obj != null && x.ids != null) {\n+            Object[] previous = x.ids;\n+            int L = previous.length;\n+            if (x.used == null) {\n+                x.used = new ObjToIntMap(L);\n+            }\n+            for (int i = 0; i != L; ++i) {\n+                x.used.intern(previous[i]);\n+            }\n+        }\n+        x.ids = ids;\n+        x.index = 0;\n+    }\n+\n+    /**\n+     * Prepare for calling name(...): return function corresponding to\n+     * name and make current top scope available\n+     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.\n+     * The caller must call ScriptRuntime.lastStoredScriptable() immediately\n+     * after calling this method.\n+     */\n+    public static Callable getNameFunctionAndThis(String name,\n+                                                  Context cx,\n+                                                  Scriptable scope)\n+    {\n+        Scriptable parent = scope.getParentScope();\n+        if (parent == null) {\n+            Object result = topScopeName(cx, scope, name);\n+            if (!(result instanceof Callable)) {\n+                if (result == Scriptable.NOT_FOUND) {\n+                    throw notFoundError(scope, name);\n+                } else {\n+                    throw notFunctionError(result, name);\n+                }\n+            }\n+            // Top scope is not NativeWith or NativeCall => thisObj == scope\n+            Scriptable thisObj = scope;\n+            storeScriptable(cx, thisObj);\n+            return (Callable)result;\n+        }\n+\n+        // name will call storeScriptable(cx, thisObj);\n+        return (Callable)nameOrFunction(cx, scope, parent, name, true);\n+    }\n+\n+    /**\n+     * Prepare for calling obj[id](...): return function corresponding to\n+     * obj[id] and make obj properly converted to Scriptable available\n+     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.\n+     * The caller must call ScriptRuntime.lastStoredScriptable() immediately\n+     * after calling this method.\n+     */\n+    public static Callable getElemFunctionAndThis(Object obj,\n+                                                  Object elem,\n+                                                  Context cx)\n+    {\n+        String s = toStringIdOrIndex(cx, elem);\n+        if (s != null) {\n+            return getPropFunctionAndThis(obj, s, cx);\n+        }\n+        int index = lastIndexResult(cx);\n+\n+        Scriptable thisObj = toObjectOrNull(cx, obj);\n+        if (thisObj == null) {\n+            throw undefCallError(obj, String.valueOf(index));\n+        }\n+\n+        Object value;\n+        for (;;) {\n+            // Ignore XML lookup as required by ECMA 357, 11.2.2.1\n+            value = ScriptableObject.getProperty(thisObj, index);\n+            if (value != Scriptable.NOT_FOUND) {\n+                break;\n+            }\n+            if (!(thisObj instanceof XMLObject)) {\n+                break;\n+            }\n+            XMLObject xmlObject = (XMLObject)thisObj;\n+            Scriptable extra = xmlObject.getExtraMethodSource(cx);\n+            if (extra == null) {\n+                break;\n+            }\n+            thisObj = extra;\n+        }\n+        if (!(value instanceof Callable)) {\n+            throw notFunctionError(value, elem);\n+        }\n+\n+        storeScriptable(cx, thisObj);\n+        return (Callable)value;\n+    }\n+\n+    /**\n+     * Prepare for calling obj.property(...): return function corresponding to\n+     * obj.property and make obj properly converted to Scriptable available\n+     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.\n+     * The caller must call ScriptRuntime.lastStoredScriptable() immediately\n+     * after calling this method.\n+     * Warning: this doesn't allow to resolve primitive prototype properly when\n+     * many top scopes are involved.\n+     */\n+    public static Callable getPropFunctionAndThis(Object obj,\n+                                                  String property,\n+                                                  Context cx)\n+    {\n+        Scriptable thisObj = toObjectOrNull(cx, obj);\n+        return getPropFunctionAndThisHelper(obj, property, cx, thisObj);\n+    }\n+\n+    /**\n+     * Prepare for calling obj.property(...): return function corresponding to\n+     * obj.property and make obj properly converted to Scriptable available\n+     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.\n+     * The caller must call ScriptRuntime.lastStoredScriptable() immediately\n+     * after calling this method.\n+     */\n+    public static Callable getPropFunctionAndThis(Object obj,\n+                                                  String property,\n+                                                  Context cx, final Scriptable scope)\n+    {\n+        Scriptable thisObj = toObjectOrNull(cx, obj, scope);\n+        return getPropFunctionAndThisHelper(obj, property, cx, thisObj);\n+    }\n+\n+    private static Callable getPropFunctionAndThisHelper(Object obj,\n+          String property, Context cx, Scriptable thisObj)\n+    {\n+        if (thisObj == null) {\n+            throw undefCallError(obj, property);\n+        }\n+\n+        Object value;\n+        for (;;) {\n+            // Ignore XML lookup as required by ECMA 357, 11.2.2.1\n+            value = ScriptableObject.getProperty(thisObj, property);\n+            if (value != Scriptable.NOT_FOUND) {\n+                break;\n+            }\n+            if (!(thisObj instanceof XMLObject)) {\n+                break;\n+            }\n+            XMLObject xmlObject = (XMLObject)thisObj;\n+            Scriptable extra = xmlObject.getExtraMethodSource(cx);\n+            if (extra == null) {\n+                break;\n+            }\n+            thisObj = extra;\n+        }\n+\n+        if (!(value instanceof Callable)) {\n+            Object noSuchMethod = ScriptableObject.getProperty(thisObj, \"__noSuchMethod__\");\n+            if (noSuchMethod instanceof Callable)\n+                value = new NoSuchMethodShim((Callable)noSuchMethod, property);\n+            else\n+                throw notFunctionError(thisObj, value, property);\n+        }\n+\n+        storeScriptable(cx, thisObj);\n+        return (Callable)value;\n+    }\n+\n+    /**\n+     * Prepare for calling <expression>(...): return function corresponding to\n+     * <expression> and make parent scope of the function available\n+     * as ScriptRuntime.lastStoredScriptable() for consumption as thisObj.\n+     * The caller must call ScriptRuntime.lastStoredScriptable() immediately\n+     * after calling this method.\n+     */\n+    public static Callable getValueFunctionAndThis(Object value, Context cx)\n+    {\n+        if (!(value instanceof Callable)) {\n+            throw notFunctionError(value);\n+        }\n+\n+        Callable f = (Callable)value;\n+        Scriptable thisObj = null;\n+        if (f instanceof Scriptable) {\n+            thisObj = ((Scriptable)f).getParentScope();\n+        }\n+        if (thisObj == null) {\n+            if (cx.topCallScope == null) throw new IllegalStateException();\n+            thisObj = cx.topCallScope;\n+        }\n+        if (thisObj.getParentScope() != null) {\n+            if (thisObj instanceof NativeWith) {\n+                // functions defined inside with should have with target\n+                // as their thisObj\n+            } else if (thisObj instanceof NativeCall) {\n+                // nested functions should have top scope as their thisObj\n+                thisObj = ScriptableObject.getTopLevelScope(thisObj);\n+            }\n+        }\n+        storeScriptable(cx, thisObj);\n+        return f;\n+    }\n+\n+    /**\n+     * Perform function call in reference context. Should always\n+     * return value that can be passed to\n+     * {@link #refGet(Ref, Context)} or {@link #refSet(Ref, Object, Context)}\n+     * arbitrary number of times.\n+     * The args array reference should not be stored in any object that is\n+     * can be GC-reachable after this method returns. If this is necessary,\n+     * store args.clone(), not args array itself.\n+     */\n+    public static Ref callRef(Callable function, Scriptable thisObj,\n+                              Object[] args, Context cx)\n+    {\n+        if (function instanceof RefCallable) {\n+            RefCallable rfunction = (RefCallable)function;\n+            Ref ref = rfunction.refCall(cx, thisObj, args);\n+            if (ref == null) {\n+                throw new IllegalStateException(rfunction.getClass().getName()+\".refCall() returned null\");\n+            }\n+            return ref;\n+        }\n+        // No runtime support for now\n+        String msg = getMessage1(\"msg.no.ref.from.function\",\n+                                 toString(function));\n+        throw constructError(\"ReferenceError\", msg);\n+    }\n+\n+    /**\n+     * Operator new.\n+     *\n+     * See ECMA 11.2.2\n+     */\n+    public static Scriptable newObject(Object fun, Context cx,\n+                                       Scriptable scope, Object[] args)\n+    {\n+        if (!(fun instanceof Function)) {\n+            throw notFunctionError(fun);\n+        }\n+        Function function = (Function)fun;\n+        return function.construct(cx, scope, args);\n+    }\n+\n+    public static Object callSpecial(Context cx, Callable fun,\n+                                     Scriptable thisObj,\n+                                     Object[] args, Scriptable scope,\n+                                     Scriptable callerThis, int callType,\n+                                     String filename, int lineNumber)\n+    {\n+        if (callType == Node.SPECIALCALL_EVAL) {\n+            if (thisObj.getParentScope() == null && NativeGlobal.isEvalFunction(fun)) {\n+                return evalSpecial(cx, scope, callerThis, args,\n+                                   filename, lineNumber);\n+            }\n+        } else if (callType == Node.SPECIALCALL_WITH) {\n+            if (NativeWith.isWithFunction(fun)) {\n+                throw Context.reportRuntimeError1(\"msg.only.from.new\",\n+                                                  \"With\");\n+            }\n+        } else {\n+            throw Kit.codeBug();\n+        }\n+\n+        return fun.call(cx, scope, thisObj, args);\n+    }\n+\n+    public static Object newSpecial(Context cx, Object fun,\n+                                    Object[] args, Scriptable scope,\n+                                    int callType)\n+    {\n+        if (callType == Node.SPECIALCALL_EVAL) {\n+            if (NativeGlobal.isEvalFunction(fun)) {\n+                throw typeError1(\"msg.not.ctor\", \"eval\");\n+            }\n+        } else if (callType == Node.SPECIALCALL_WITH) {\n+            if (NativeWith.isWithFunction(fun)) {\n+                return NativeWith.newWithSpecial(cx, scope, args);\n+            }\n+        } else {\n+            throw Kit.codeBug();\n+        }\n+\n+        return newObject(fun, cx, scope, args);\n+    }\n+\n+    /**\n+     * Function.prototype.apply and Function.prototype.call\n+     *\n+     * See Ecma 15.3.4.[34]\n+     */\n+    public static Object applyOrCall(boolean isApply,\n+                                     Context cx, Scriptable scope,\n+                                     Scriptable thisObj, Object[] args)\n+    {\n+        int L = args.length;\n+        Callable function = getCallable(thisObj);\n+\n+        Scriptable callThis = null;\n+        if (L != 0) {\n+            callThis = toObjectOrNull(cx, args[0]);\n+        }\n+        if (callThis == null) {\n+            // This covers the case of args[0] == (null|undefined) as well.\n+            callThis = getTopCallScope(cx);\n+        }\n+\n+        Object[] callArgs;\n+        if (isApply) {\n+            // Follow Ecma 15.3.4.3\n+            callArgs = L <= 1 ? ScriptRuntime.emptyArgs :\n+                getApplyArguments(cx, args[1]);\n+        } else {\n+            // Follow Ecma 15.3.4.4\n+            if (L <= 1) {\n+                callArgs = ScriptRuntime.emptyArgs;\n+            } else {\n+                callArgs = new Object[L - 1];\n+                System.arraycopy(args, 1, callArgs, 0, L - 1);\n+            }\n+        }\n+\n+        return function.call(cx, scope, callThis, callArgs);\n+    }\n+\n+    static Object[] getApplyArguments(Context cx, Object arg1)\n+    {\n+        if (arg1 == null || arg1 == Undefined.instance) {\n+            return ScriptRuntime.emptyArgs;\n+        } else if (arg1 instanceof NativeArray || arg1 instanceof Arguments) {\n+            return cx.getElements((Scriptable) arg1);\n+        } else {\n+            throw ScriptRuntime.typeError0(\"msg.arg.isnt.array\");\n+        }\n+    }\n+\n+    static Callable getCallable(Scriptable thisObj)\n+    {\n+        Callable function;\n+        if (thisObj instanceof Callable) {\n+            function = (Callable)thisObj;\n+        } else {\n+            Object value = thisObj.getDefaultValue(ScriptRuntime.FunctionClass);\n+            if (!(value instanceof Callable)) {\n+                throw ScriptRuntime.notFunctionError(value, thisObj);\n+            }\n+            function = (Callable)value;\n+        }\n+        return function;\n+    }\n+\n+    /**\n+     * The eval function property of the global object.\n+     *\n+     * See ECMA 15.1.2.1\n+     */\n+    public static Object evalSpecial(Context cx, Scriptable scope,\n+                                     Object thisArg, Object[] args,\n+                                     String filename, int lineNumber)\n+    {\n+        if (args.length < 1)\n+            return Undefined.instance;\n+        Object x = args[0];\n+        if (!(x instanceof String)) {\n+            if (cx.hasFeature(Context.FEATURE_STRICT_MODE) ||\n+                cx.hasFeature(Context.FEATURE_STRICT_EVAL))\n+            {\n+                throw Context.reportRuntimeError0(\"msg.eval.nonstring.strict\");\n+            }\n+            String message = ScriptRuntime.getMessage0(\"msg.eval.nonstring\");\n+            Context.reportWarning(message);\n+            return x;\n+        }\n+        if (filename == null) {\n+            int[] linep = new int[1];\n+            filename = Context.getSourcePositionFromStack(linep);\n+            if (filename != null) {\n+                lineNumber = linep[0];\n+            } else {\n+                filename = \"\";\n+            }\n+        }\n+        String sourceName = ScriptRuntime.\n+            makeUrlForGeneratedScript(true, filename, lineNumber);\n+\n+        ErrorReporter reporter;\n+        reporter = DefaultErrorReporter.forEval(cx.getErrorReporter());\n+\n+        Evaluator evaluator = Context.createInterpreter();\n+        if (evaluator == null) {\n+            throw new JavaScriptException(\"Interpreter not present\",\n+                    filename, lineNumber);\n+        }\n+\n+        // Compile with explicit interpreter instance to force interpreter\n+        // mode.\n+        Script script = cx.compileString((String)x, evaluator,\n+                                         reporter, sourceName, 1, null);\n+        evaluator.setEvalScriptFlag(script);\n+        Callable c = (Callable)script;\n+        return c.call(cx, scope, (Scriptable)thisArg, ScriptRuntime.emptyArgs);\n+    }\n+\n+    /**\n+     * The typeof operator\n+     */\n+    public static String typeof(Object value)\n+    {\n+        if (value == null)\n+            return \"object\";\n+        if (value == Undefined.instance)\n+            return \"undefined\";\n+        if (value instanceof ScriptableObject)\n+        \treturn ((ScriptableObject) value).getTypeOf();\n+        if (value instanceof Scriptable)\n+            return (value instanceof Callable) ? \"function\" : \"object\";\n+        if (value instanceof String)\n+            return \"string\";\n+        if (value instanceof Number)\n+            return \"number\";\n+        if (value instanceof Boolean)\n+            return \"boolean\";\n+        throw errorWithClassName(\"msg.invalid.type\", value);\n+    }\n+\n+    /**\n+     * The typeof operator that correctly handles the undefined case\n+     */\n+    public static String typeofName(Scriptable scope, String id)\n+    {\n+        Context cx = Context.getContext();\n+        Scriptable val = bind(cx, scope, id);\n+        if (val == null)\n+            return \"undefined\";\n+        return typeof(getObjectProp(val, id, cx));\n+    }\n+\n+    // neg:\n+    // implement the '-' operator inline in the caller\n+    // as \"-toNumber(val)\"\n+\n+    // not:\n+    // implement the '!' operator inline in the caller\n+    // as \"!toBoolean(val)\"\n+\n+    // bitnot:\n+    // implement the '~' operator inline in the caller\n+    // as \"~toInt32(val)\"\n+\n+    public static Object add(Object val1, Object val2, Context cx)\n+    {\n+        if(val1 instanceof Number && val2 instanceof Number) {\n+            return wrapNumber(((Number)val1).doubleValue() +\n+                              ((Number)val2).doubleValue());\n+        }\n+        if (val1 instanceof XMLObject) {\n+            Object test = ((XMLObject)val1).addValues(cx, true, val2);\n+            if (test != Scriptable.NOT_FOUND) {\n+                return test;\n+            }\n+        }\n+        if (val2 instanceof XMLObject) {\n+            Object test = ((XMLObject)val2).addValues(cx, false, val1);\n+            if (test != Scriptable.NOT_FOUND) {\n+                return test;\n+            }\n+        }\n+        if (val1 instanceof Scriptable)\n+            val1 = ((Scriptable) val1).getDefaultValue(null);\n+        if (val2 instanceof Scriptable)\n+            val2 = ((Scriptable) val2).getDefaultValue(null);\n+        if (!(val1 instanceof String) && !(val2 instanceof String))\n+            if ((val1 instanceof Number) && (val2 instanceof Number))\n+                return wrapNumber(((Number)val1).doubleValue() +\n+                                  ((Number)val2).doubleValue());\n+            else\n+                return wrapNumber(toNumber(val1) + toNumber(val2));\n+        return toString(val1).concat(toString(val2));\n+    }\n+\n+    public static String add(String val1, Object val2) {\n+        return val1.concat(toString(val2));\n+    }\n+\n+    public static String add(Object val1, String val2) {\n+        return toString(val1).concat(val2);\n+    }\n+\n+    /**\n+     * @deprecated The method is only present for compatibility.\n+     */\n+    public static Object nameIncrDecr(Scriptable scopeChain, String id,\n+                                      int incrDecrMask)\n+    {\n+        return nameIncrDecr(scopeChain, id, Context.getContext(), incrDecrMask);\n+    }\n+\n+    public static Object nameIncrDecr(Scriptable scopeChain, String id,\n+                                      Context cx, int incrDecrMask)\n+    {\n+        Scriptable target;\n+        Object value;\n+      search: {\n+            do {\n+                if (cx.useDynamicScope && scopeChain.getParentScope() == null) {\n+                    scopeChain = checkDynamicScope(cx.topCallScope, scopeChain);\n+                }\n+                target = scopeChain;\n+                do {\n+                    value = target.get(id, scopeChain);\n+                    if (value != Scriptable.NOT_FOUND) {\n+                        break search;\n+                    }\n+                    target = target.getPrototype();\n+                } while (target != null);\n+                scopeChain = scopeChain.getParentScope();\n+            } while (scopeChain != null);\n+            throw notFoundError(scopeChain, id);\n+        }\n+        return doScriptableIncrDecr(target, id, scopeChain, value,\n+                                    incrDecrMask);\n+    }\n+\n+    public static Object propIncrDecr(Object obj, String id,\n+                                      Context cx, int incrDecrMask)\n+    {\n+        Scriptable start = toObjectOrNull(cx, obj);\n+        if (start == null) {\n+            throw undefReadError(obj, id);\n+        }\n+\n+        Scriptable target = start;\n+        Object value;\n+      search: {\n+            do {\n+                value = target.get(id, start);\n+                if (value != Scriptable.NOT_FOUND) {\n+                    break search;\n+                }\n+                target = target.getPrototype();\n+            } while (target != null);\n+            start.put(id, start, NaNobj);\n+            return NaNobj;\n+        }\n+        return doScriptableIncrDecr(target, id, start, value,\n+                                    incrDecrMask);\n+    }\n+\n+    private static Object doScriptableIncrDecr(Scriptable target,\n+                                               String id,\n+                                               Scriptable protoChainStart,\n+                                               Object value,\n+                                               int incrDecrMask)\n+    {\n+        boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);\n+        double number;\n+        if (value instanceof Number) {\n+            number = ((Number)value).doubleValue();\n+        } else {\n+            number = toNumber(value);\n+            if (post) {\n+                // convert result to number\n+                value = wrapNumber(number);\n+            }\n+        }\n+        if ((incrDecrMask & Node.DECR_FLAG) == 0) {\n+            ++number;\n+        } else {\n+            --number;\n+        }\n+        Number result = wrapNumber(number);\n+        target.put(id, protoChainStart, result);\n+        if (post) {\n+            return value;\n+        } else {\n+            return result;\n+        }\n+    }\n+\n+    public static Object elemIncrDecr(Object obj, Object index,\n+                                      Context cx, int incrDecrMask)\n+    {\n+        Object value = getObjectElem(obj, index, cx);\n+        boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);\n+        double number;\n+        if (value instanceof Number) {\n+            number = ((Number)value).doubleValue();\n+        } else {\n+            number = toNumber(value);\n+            if (post) {\n+                // convert result to number\n+                value = wrapNumber(number);\n+            }\n+        }\n+        if ((incrDecrMask & Node.DECR_FLAG) == 0) {\n+            ++number;\n+        } else {\n+            --number;\n+        }\n+        Number result = wrapNumber(number);\n+        setObjectElem(obj, index, result, cx);\n+        if (post) {\n+            return value;\n+        } else {\n+            return result;\n+        }\n+    }\n+\n+    public static Object refIncrDecr(Ref ref, Context cx, int incrDecrMask)\n+    {\n+        Object value = ref.get(cx);\n+        boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);\n+        double number;\n+        if (value instanceof Number) {\n+            number = ((Number)value).doubleValue();\n+        } else {\n+            number = toNumber(value);\n+            if (post) {\n+                // convert result to number\n+                value = wrapNumber(number);\n+            }\n+        }\n+        if ((incrDecrMask & Node.DECR_FLAG) == 0) {\n+            ++number;\n+        } else {\n+            --number;\n+        }\n+        Number result = wrapNumber(number);\n+        ref.set(cx, result);\n+        if (post) {\n+            return value;\n+        } else {\n+            return result;\n+        }\n+    }\n+\n+    public static Object toPrimitive(Object val) {\n+        return toPrimitive(val, null);\n+    }\n+\n+    public static Object toPrimitive(Object val, Class<?> typeHint)\n+    {\n+        if (!(val instanceof Scriptable)) {\n+            return val;\n+        }\n+        Scriptable s = (Scriptable)val;\n+        Object result = s.getDefaultValue(typeHint);\n+        if (result instanceof Scriptable)\n+            throw typeError0(\"msg.bad.default.value\");\n+        return result;\n+    }\n+\n+    /**\n+     * Equality\n+     *\n+     * See ECMA 11.9\n+     */\n+    public static boolean eq(Object x, Object y)\n+    {\n+        if (x == null || x == Undefined.instance) {\n+            if (y == null || y == Undefined.instance) {\n+                return true;\n+            }\n+            if (y instanceof ScriptableObject) {\n+                Object test = ((ScriptableObject)y).equivalentValues(x);\n+                if (test != Scriptable.NOT_FOUND) {\n+                    return ((Boolean)test).booleanValue();\n+                }\n+            }\n+            return false;\n+        } else if (x instanceof Number) {\n+            return eqNumber(((Number)x).doubleValue(), y);\n+        } else if (x instanceof String) {\n+            return eqString((String)x, y);\n+        } else if (x instanceof Boolean) {\n+            boolean b = ((Boolean)x).booleanValue();\n+            if (y instanceof Boolean) {\n+                return b == ((Boolean)y).booleanValue();\n+            }\n+            if (y instanceof ScriptableObject) {\n+                Object test = ((ScriptableObject)y).equivalentValues(x);\n+                if (test != Scriptable.NOT_FOUND) {\n+                    return ((Boolean)test).booleanValue();\n+                }\n+            }\n+            return eqNumber(b ? 1.0 : 0.0, y);\n+        } else if (x instanceof Scriptable) {\n+            if (y instanceof Scriptable) {\n+                if (x == y) {\n+                    return true;\n+                }\n+                if (x instanceof ScriptableObject) {\n+                    Object test = ((ScriptableObject)x).equivalentValues(y);\n+                    if (test != Scriptable.NOT_FOUND) {\n+                        return ((Boolean)test).booleanValue();\n+                    }\n+                }\n+                if (y instanceof ScriptableObject) {\n+                    Object test = ((ScriptableObject)y).equivalentValues(x);\n+                    if (test != Scriptable.NOT_FOUND) {\n+                        return ((Boolean)test).booleanValue();\n+                    }\n+                }\n+                if (x instanceof Wrapper && y instanceof Wrapper) {\n+                    // See bug 413838. Effectively an extension to ECMA for\n+                    // the LiveConnect case.\n+                    Object unwrappedX = ((Wrapper)x).unwrap();\n+                    Object unwrappedY = ((Wrapper)y).unwrap();\n+                    return unwrappedX == unwrappedY ||\n+                           (isPrimitive(unwrappedX) &&\n+                            isPrimitive(unwrappedY) &&\n+                            eq(unwrappedX, unwrappedY));\n+                }\n+                return false;\n+            } else if (y instanceof Boolean) {\n+                if (x instanceof ScriptableObject) {\n+                    Object test = ((ScriptableObject)x).equivalentValues(y);\n+                    if (test != Scriptable.NOT_FOUND) {\n+                        return ((Boolean)test).booleanValue();\n+                    }\n+                }\n+                double d = ((Boolean)y).booleanValue() ? 1.0 : 0.0;\n+                return eqNumber(d, x);\n+            } else if (y instanceof Number) {\n+                return eqNumber(((Number)y).doubleValue(), x);\n+            } else if (y instanceof String) {\n+                return eqString((String)y, x);\n+            }\n+            // covers the case when y == Undefined.instance as well\n+            return false;\n+        } else {\n+            warnAboutNonJSObject(x);\n+            return x == y;\n+        }\n+    }\n+\n+    public static boolean isPrimitive(Object obj) {\n+        return obj == null || obj == Undefined.instance ||\n+                (obj instanceof Number) || (obj instanceof String) ||\n+                (obj instanceof Boolean);\n+    }\n+\n+    static boolean eqNumber(double x, Object y)\n+    {\n+        for (;;) {\n+            if (y == null || y == Undefined.instance) {\n+                return false;\n+            } else if (y instanceof Number) {\n+                return x == ((Number)y).doubleValue();\n+            } else if (y instanceof String) {\n+                return x == toNumber(y);\n+            } else if (y instanceof Boolean) {\n+                return x == (((Boolean)y).booleanValue() ? 1.0 : +0.0);\n+            } else if (y instanceof Scriptable) {\n+                if (y instanceof ScriptableObject) {\n+                    Object xval = wrapNumber(x);\n+                    Object test = ((ScriptableObject)y).equivalentValues(xval);\n+                    if (test != Scriptable.NOT_FOUND) {\n+                        return ((Boolean)test).booleanValue();\n+                    }\n+                }\n+                y = toPrimitive(y);\n+            } else {\n+                warnAboutNonJSObject(y);\n+                return false;\n+            }\n+        }\n+    }\n+\n+    private static boolean eqString(String x, Object y)\n+    {\n+        for (;;) {\n+            if (y == null || y == Undefined.instance) {\n+                return false;\n+            } else if (y instanceof String) {\n+                return x.equals(y);\n+            } else if (y instanceof Number) {\n+                return toNumber(x) == ((Number)y).doubleValue();\n+            } else if (y instanceof Boolean) {\n+                return toNumber(x) == (((Boolean)y).booleanValue() ? 1.0 : 0.0);\n+            } else if (y instanceof Scriptable) {\n+                if (y instanceof ScriptableObject) {\n+                    Object test = ((ScriptableObject)y).equivalentValues(x);\n+                    if (test != Scriptable.NOT_FOUND) {\n+                        return ((Boolean)test).booleanValue();\n+                    }\n+                }\n+                y = toPrimitive(y);\n+                continue;\n+            } else {\n+                warnAboutNonJSObject(y);\n+                return false;\n+            }\n+        }\n+    }\n+    public static boolean shallowEq(Object x, Object y)\n+    {\n+        if (x == y) {\n+            if (!(x instanceof Number)) {\n+                return true;\n+            }\n+            // NaN check\n+            double d = ((Number)x).doubleValue();\n+            return d == d;\n+        }\n+        if (x == null || x == Undefined.instance) {\n+            return false;\n+        } else if (x instanceof Number) {\n+            if (y instanceof Number) {\n+                return ((Number)x).doubleValue() == ((Number)y).doubleValue();\n+            }\n+        } else if (x instanceof String) {\n+            if (y instanceof String) {\n+                return x.equals(y);\n+            }\n+        } else if (x instanceof Boolean) {\n+            if (y instanceof Boolean) {\n+                return x.equals(y);\n+            }\n+        } else if (x instanceof Scriptable) {\n+            if (x instanceof Wrapper && y instanceof Wrapper) {\n+                return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();\n+            }\n+        } else {\n+            warnAboutNonJSObject(x);\n+            return x == y;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * The instanceof operator.\n+     *\n+     * @return a instanceof b\n+     */\n+    public static boolean instanceOf(Object a, Object b, Context cx)\n+    {\n+        // Check RHS is an object\n+        if (! (b instanceof Scriptable)) {\n+            throw typeError0(\"msg.instanceof.not.object\");\n+        }\n+\n+        // for primitive values on LHS, return false\n+        if (! (a instanceof Scriptable))\n+            return false;\n+\n+        return ((Scriptable)b).hasInstance((Scriptable)a);\n+    }\n+\n+    /**\n+     * Delegates to\n+     *\n+     * @return true iff rhs appears in lhs' proto chain\n+     */\n+    public static boolean jsDelegatesTo(Scriptable lhs, Scriptable rhs) {\n+        Scriptable proto = lhs.getPrototype();\n+\n+        while (proto != null) {\n+            if (proto.equals(rhs)) return true;\n+            proto = proto.getPrototype();\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * The in operator.\n+     *\n+     * This is a new JS 1.3 language feature.  The in operator mirrors\n+     * the operation of the for .. in construct, and tests whether the\n+     * rhs has the property given by the lhs.  It is different from the\n+     * for .. in construct in that:\n+     * <BR> - it doesn't perform ToObject on the right hand side\n+     * <BR> - it returns true for DontEnum properties.\n+     * @param a the left hand operand\n+     * @param b the right hand operand\n+     *\n+     * @return true if property name or element number a is a property of b\n+     */\n+    public static boolean in(Object a, Object b, Context cx)\n+    {\n+        if (!(b instanceof Scriptable)) {\n+            throw typeError0(\"msg.instanceof.not.object\");\n+        }\n+\n+        return hasObjectElem((Scriptable)b, a, cx);\n+    }\n+\n+    public static boolean cmp_LT(Object val1, Object val2)\n+    {\n+        double d1, d2;\n+        if (val1 instanceof Number && val2 instanceof Number) {\n+            d1 = ((Number)val1).doubleValue();\n+            d2 = ((Number)val2).doubleValue();\n+        } else {\n+            if (val1 instanceof Scriptable)\n+                val1 = ((Scriptable) val1).getDefaultValue(NumberClass);\n+            if (val2 instanceof Scriptable)\n+                val2 = ((Scriptable) val2).getDefaultValue(NumberClass);\n+            if (val1 instanceof String && val2 instanceof String) {\n+                return ((String)val1).compareTo((String)val2) < 0;\n+            }\n+            d1 = toNumber(val1);\n+            d2 = toNumber(val2);\n+        }\n+        return d1 < d2;\n+    }\n+\n+    public static boolean cmp_LE(Object val1, Object val2)\n+    {\n+        double d1, d2;\n+        if (val1 instanceof Number && val2 instanceof Number) {\n+            d1 = ((Number)val1).doubleValue();\n+            d2 = ((Number)val2).doubleValue();\n+        } else {\n+            if (val1 instanceof Scriptable)\n+                val1 = ((Scriptable) val1).getDefaultValue(NumberClass);\n+            if (val2 instanceof Scriptable)\n+                val2 = ((Scriptable) val2).getDefaultValue(NumberClass);\n+            if (val1 instanceof String && val2 instanceof String) {\n+                return ((String)val1).compareTo((String)val2) <= 0;\n+            }\n+            d1 = toNumber(val1);\n+            d2 = toNumber(val2);\n+        }\n+        return d1 <= d2;\n+    }\n+\n+    // ------------------\n+    // Statements\n+    // ------------------\n+\n+    public static ScriptableObject getGlobal(Context cx) {\n+        final String GLOBAL_CLASS = \"org.mozilla.javascript.tools.shell.Global\";\n+        Class<?> globalClass = Kit.classOrNull(GLOBAL_CLASS);\n+        if (globalClass != null) {\n+            try {\n+                Class<?>[] parm = { ScriptRuntime.ContextClass };\n+                Constructor<?> globalClassCtor = globalClass.getConstructor(parm);\n+                Object[] arg = { cx };\n+                return (ScriptableObject) globalClassCtor.newInstance(arg);\n+            } catch (Exception e) {\n+                // fall through...\n+            }\n+        }\n+        return new ImporterTopLevel(cx);\n+    }\n+\n+    public static boolean hasTopCall(Context cx)\n+    {\n+        return (cx.topCallScope != null);\n+    }\n+\n+    public static Scriptable getTopCallScope(Context cx)\n+    {\n+        Scriptable scope = cx.topCallScope;\n+        if (scope == null) {\n+            throw new IllegalStateException();\n+        }\n+        return scope;\n+    }\n+\n+    public static Object doTopCall(Callable callable,\n+                                   Context cx, Scriptable scope,\n+                                   Scriptable thisObj, Object[] args)\n+    {\n+        if (scope == null)\n+            throw new IllegalArgumentException();\n+        if (cx.topCallScope != null) throw new IllegalStateException();\n+\n+        Object result;\n+        cx.topCallScope = ScriptableObject.getTopLevelScope(scope);\n+        cx.useDynamicScope = cx.hasFeature(Context.FEATURE_DYNAMIC_SCOPE);\n+        ContextFactory f = cx.getFactory();\n+        try {\n+            result = f.doTopCall(callable, cx, scope, thisObj, args);\n+        } finally {\n+            cx.topCallScope = null;\n+            // Cleanup cached references\n+            cx.cachedXMLLib = null;\n+\n+            if (cx.currentActivationCall != null) {\n+                // Function should always call exitActivationFunction\n+                // if it creates activation record\n+                throw new IllegalStateException();\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Return <tt>possibleDynamicScope</tt> if <tt>staticTopScope</tt>\n+     * is present on its prototype chain and return <tt>staticTopScope</tt>\n+     * otherwise.\n+     * Should only be called when <tt>staticTopScope</tt> is top scope.\n+     */\n+    static Scriptable checkDynamicScope(Scriptable possibleDynamicScope,\n+                                        Scriptable staticTopScope)\n+    {\n+        // Return cx.topCallScope if scope\n+        if (possibleDynamicScope == staticTopScope) {\n+            return possibleDynamicScope;\n+        }\n+        Scriptable proto = possibleDynamicScope;\n+        for (;;) {\n+            proto = proto.getPrototype();\n+            if (proto == staticTopScope) {\n+                return possibleDynamicScope;\n+            }\n+            if (proto == null) {\n+                return staticTopScope;\n+            }\n+        }\n+    }\n+\n+    public static void addInstructionCount(Context cx, int instructionsToAdd)\n+    {\n+    \tcx.instructionCount += instructionsToAdd;\n+        if (cx.instructionCount > cx.instructionThreshold)\n+        {\n+            cx.observeInstructionCount(cx.instructionCount);\n+            cx.instructionCount = 0;\n+        }\n+    }\n+\n+    public static void initScript(NativeFunction funObj, Scriptable thisObj,\n+                                  Context cx, Scriptable scope,\n+                                  boolean evalScript)\n+    {\n+        if (cx.topCallScope == null)\n+            throw new IllegalStateException();\n+\n+        int varCount = funObj.getParamAndVarCount();\n+        if (varCount != 0) {\n+\n+            Scriptable varScope = scope;\n+            // Never define any variables from var statements inside with\n+            // object. See bug 38590.\n+            while (varScope instanceof NativeWith) {\n+                varScope = varScope.getParentScope();\n+            }\n+\n+            for (int i = varCount; i-- != 0;) {\n+                String name = funObj.getParamOrVarName(i);\n+                boolean isConst = funObj.getParamOrVarConst(i);\n+                // Don't overwrite existing def if already defined in object\n+                // or prototypes of object.\n+                if (!ScriptableObject.hasProperty(scope, name)) {\n+                    if (!evalScript) {\n+                        // Global var definitions are supposed to be DONTDELETE\n+                        if (isConst)\n+                            ScriptableObject.defineConstProperty(varScope, name);\n+                        else\n+                            ScriptableObject.defineProperty(\n+                                varScope, name, Undefined.instance,\n+                                ScriptableObject.PERMANENT);\n+                    } else {\n+                        varScope.put(name, varScope, Undefined.instance);\n+                    }\n+                } else {\n+                    ScriptableObject.redefineProperty(scope, name, isConst);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static Scriptable createFunctionActivation(NativeFunction funObj,\n+                                                      Scriptable scope,\n+                                                      Object[] args)\n+    {\n+        return new NativeCall(funObj, scope, args);\n+    }\n+\n+\n+    public static void enterActivationFunction(Context cx,\n+                                               Scriptable scope)\n+    {\n+        if (cx.topCallScope == null)\n+            throw new IllegalStateException();\n+        NativeCall call = (NativeCall)scope;\n+        call.parentActivationCall = cx.currentActivationCall;\n+        cx.currentActivationCall = call;\n+    }\n+\n+    public static void exitActivationFunction(Context cx)\n+    {\n+        NativeCall call = cx.currentActivationCall;\n+        cx.currentActivationCall = call.parentActivationCall;\n+        call.parentActivationCall = null;\n+    }\n+\n+    static NativeCall findFunctionActivation(Context cx, Function f)\n+    {\n+        NativeCall call = cx.currentActivationCall;\n+        while (call != null) {\n+            if (call.function == f)\n+                return call;\n+            call = call.parentActivationCall;\n+        }\n+        return null;\n+    }\n+\n+    public static Scriptable newCatchScope(Throwable t,\n+                                           Scriptable lastCatchScope,\n+                                           String exceptionName,\n+                                           Context cx, Scriptable scope)\n+    {\n+        Object obj;\n+        boolean cacheObj;\n+\n+      getObj:\n+        if (t instanceof JavaScriptException) {\n+            cacheObj = false;\n+            obj = ((JavaScriptException)t).getValue();\n+        } else {\n+            cacheObj = true;\n+\n+            // Create wrapper object unless it was associated with\n+            // the previous scope object\n+\n+            if (lastCatchScope != null) {\n+                NativeObject last = (NativeObject)lastCatchScope;\n+                obj = last.getAssociatedValue(t);\n+                if (obj == null) Kit.codeBug();\n+                break getObj;\n+            }\n+\n+            RhinoException re;\n+            String errorName;\n+            String errorMsg;\n+            Throwable javaException = null;\n+\n+            if (t instanceof EcmaError) {\n+                EcmaError ee = (EcmaError)t;\n+                re = ee;\n+                errorName = ee.getName();\n+                errorMsg = ee.getErrorMessage();\n+            } else if (t instanceof WrappedException) {\n+                WrappedException we = (WrappedException)t;\n+                re = we;\n+                javaException = we.getWrappedException();\n+                errorName = \"JavaException\";\n+                errorMsg = javaException.getClass().getName()\n+                           +\": \"+javaException.getMessage();\n+            } else if (t instanceof EvaluatorException) {\n+                // Pure evaluator exception, nor WrappedException instance\n+                EvaluatorException ee = (EvaluatorException)t;\n+                re = ee;\n+                errorName = \"InternalError\";\n+                errorMsg = ee.getMessage();\n+            } else if (cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS)) {\n+                // With FEATURE_ENHANCED_JAVA_ACCESS, scripts can catch\n+                // all exception types\n+                re = new WrappedException(t);\n+                errorName = \"JavaException\";\n+                errorMsg = t.toString();\n+            } else {\n+                // Script can catch only instances of JavaScriptException,\n+                // EcmaError and EvaluatorException\n+                throw Kit.codeBug();\n+            }\n+\n+            String sourceUri = re.sourceName();\n+            if (sourceUri == null) {\n+                sourceUri = \"\";\n+            }\n+            int line = re.lineNumber();\n+            Object args[];\n+            if (line > 0) {\n+                args = new Object[] { errorMsg, sourceUri, Integer.valueOf(line) };\n+            } else {\n+                args = new Object[] { errorMsg, sourceUri };\n+            }\n+\n+            Scriptable errorObject = cx.newObject(scope, errorName, args);\n+            ScriptableObject.putProperty(errorObject, \"name\", errorName);\n+\n+            if (javaException != null && isVisible(cx, javaException)) {\n+                Object wrap = cx.getWrapFactory().wrap(cx, scope, javaException,\n+                                                       null);\n+                ScriptableObject.defineProperty(\n+                    errorObject, \"javaException\", wrap,\n+                    ScriptableObject.PERMANENT | ScriptableObject.READONLY);\n+            }\n+            if (isVisible(cx, re)) {\n+                Object wrap = cx.getWrapFactory().wrap(cx, scope, re, null);\n+                ScriptableObject.defineProperty(\n+                        errorObject, \"rhinoException\", wrap,\n+                        ScriptableObject.PERMANENT | ScriptableObject.READONLY);\n+            }\n+            obj = errorObject;\n+        }\n+\n+        NativeObject catchScopeObject = new NativeObject();\n+        // See ECMA 12.4\n+        catchScopeObject.defineProperty(\n+            exceptionName, obj, ScriptableObject.PERMANENT);\n+\n+        if (isVisible(cx, t)) {\n+            // Add special Rhino object __exception__ defined in the catch\n+            // scope that can be used to retrieve the Java exception associated\n+            // with the JavaScript exception (to get stack trace info, etc.)\n+            catchScopeObject.defineProperty(\n+                \"__exception__\", Context.javaToJS(t, scope),\n+                ScriptableObject.PERMANENT|ScriptableObject.DONTENUM);\n+        }\n+\n+        if (cacheObj) {\n+            catchScopeObject.associateValue(t, obj);\n+        }\n+        return catchScopeObject;\n+    }\n+\n+    private static boolean isVisible(Context cx, Object obj) {\n+        ClassShutter shutter = cx.getClassShutter();\n+        return shutter == null ||\n+            shutter.visibleToScripts(obj.getClass().getName());\n+    }\n+\n+    public static Scriptable enterWith(Object obj, Context cx,\n+                                       Scriptable scope)\n+    {\n+        Scriptable sobj = toObjectOrNull(cx, obj);\n+        if (sobj == null) {\n+            throw typeError1(\"msg.undef.with\", toString(obj));\n+        }\n+        if (sobj instanceof XMLObject) {\n+            XMLObject xmlObject = (XMLObject)sobj;\n+            return xmlObject.enterWith(scope);\n+        }\n+        return new NativeWith(scope, sobj);\n+    }\n+\n+    public static Scriptable leaveWith(Scriptable scope)\n+    {\n+        NativeWith nw = (NativeWith)scope;\n+        return nw.getParentScope();\n+    }\n+\n+    public static Scriptable enterDotQuery(Object value, Scriptable scope)\n+    {\n+        if (!(value instanceof XMLObject)) {\n+            throw notXmlError(value);\n+        }\n+        XMLObject object = (XMLObject)value;\n+        return object.enterDotQuery(scope);\n+    }\n+\n+    public static Object updateDotQuery(boolean value, Scriptable scope)\n+    {\n+        // Return null to continue looping\n+        NativeWith nw = (NativeWith)scope;\n+        return nw.updateDotQuery(value);\n+    }\n+\n+    public static Scriptable leaveDotQuery(Scriptable scope)\n+    {\n+        NativeWith nw = (NativeWith)scope;\n+        return nw.getParentScope();\n+    }\n+\n+    public static void setFunctionProtoAndParent(BaseFunction fn,\n+                                                 Scriptable scope)\n+    {\n+        fn.setParentScope(scope);\n+        fn.setPrototype(ScriptableObject.getFunctionPrototype(scope));\n+    }\n+\n+    public static void setObjectProtoAndParent(ScriptableObject object,\n+                                               Scriptable scope)\n+    {\n+        // Compared with function it always sets the scope to top scope\n+        scope = ScriptableObject.getTopLevelScope(scope);\n+        object.setParentScope(scope);\n+        Scriptable proto\n+            = ScriptableObject.getClassPrototype(scope, object.getClassName());\n+        object.setPrototype(proto);\n+    }\n+\n+    public static void initFunction(Context cx, Scriptable scope,\n+                                    NativeFunction function, int type,\n+                                    boolean fromEvalCode)\n+    {\n+        if (type == FunctionNode.FUNCTION_STATEMENT) {\n+            String name = function.getFunctionName();\n+            if (name != null && name.length() != 0) {\n+                if (!fromEvalCode) {\n+                    // ECMA specifies that functions defined in global and\n+                    // function scope outside eval should have DONTDELETE set.\n+                    ScriptableObject.defineProperty\n+                        (scope, name, function, ScriptableObject.PERMANENT);\n+                } else {\n+                    scope.put(name, scope, function);\n+                }\n+            }\n+        } else if (type == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {\n+            String name = function.getFunctionName();\n+            if (name != null && name.length() != 0) {\n+                // Always put function expression statements into initial\n+                // activation object ignoring the with statement to follow\n+                // SpiderMonkey\n+                while (scope instanceof NativeWith) {\n+                    scope = scope.getParentScope();\n+                }\n+                scope.put(name, scope, function);\n+            }\n+        } else {\n+            throw Kit.codeBug();\n+        }\n+    }\n+\n+    public static Scriptable newArrayLiteral(Object[] objects,\n+                                             int[] skipIndices,\n+                                             Context cx, Scriptable scope)\n+    {\n+        final int SKIP_DENSITY = 2;\n+        int count = objects.length;\n+        int skipCount = 0;\n+        if (skipIndices != null) {\n+            skipCount = skipIndices.length;\n+        }\n+        int length = count + skipCount;\n+        if (length > 1 && skipCount * SKIP_DENSITY < length) {\n+            // If not too sparse, create whole array for constructor\n+            Object[] sparse;\n+            if (skipCount == 0) {\n+                sparse = objects;\n+            } else {\n+                sparse = new Object[length];\n+                int skip = 0;\n+                for (int i = 0, j = 0; i != length; ++i) {\n+                    if (skip != skipCount && skipIndices[skip] == i) {\n+                        sparse[i] = Scriptable.NOT_FOUND;\n+                        ++skip;\n+                        continue;\n+                    }\n+                    sparse[i] = objects[j];\n+                    ++j;\n+                }\n+            }\n+            NativeArray array = new NativeArray(sparse);\n+            setObjectProtoAndParent(array, scope);\n+            return array;\n+        }\n+\n+        NativeArray array = new NativeArray(length);\n+        setObjectProtoAndParent(array, scope);\n+\n+        int skip = 0;\n+        for (int i = 0, j = 0; i != length; ++i) {\n+            if (skip != skipCount && skipIndices[skip] == i) {\n+                ++skip;\n+                continue;\n+            }\n+            ScriptableObject.putProperty(array, i, objects[j]);\n+            ++j;\n+        }\n+        return array;\n+    }\n+\n+  /**\n+   * This method is here for backward compat with existing compiled code.  It\n+   * is called when an object literal is compiled.  The next instance will be\n+   * the version called from new code.\n+   * @deprecated This method only present for compatibility.\n+   */\n+    public static Scriptable newObjectLiteral(Object[] propertyIds,\n+                                              Object[] propertyValues,\n+                                              Context cx, Scriptable scope)\n+    {\n+        // This will initialize to all zeros, exactly what we need for old-style\n+        // getterSetters values (no getters or setters in the list)\n+        int [] getterSetters = new int[propertyIds.length];\n+        return newObjectLiteral(propertyIds, propertyValues, getterSetters,\n+                cx, scope);\n+    }\n+\n+    public static Scriptable newObjectLiteral(Object[] propertyIds,\n+                                              Object[] propertyValues,\n+                                              int [] getterSetters,\n+                                              Context cx, Scriptable scope)\n+    {\n+        Scriptable object = cx.newObject(scope);\n+        for (int i = 0, end = propertyIds.length; i != end; ++i) {\n+            Object id = propertyIds[i];\n+            int getterSetter = getterSetters[i];\n+            Object value = propertyValues[i];\n+            if (id instanceof String) {\n+                if (getterSetter == 0) {\n+                    if (isSpecialProperty((String)id)) {\n+                        specialRef(object, (String)id, cx).set(cx, value);\n+                    } else {\n+                        ScriptableObject.putProperty(object, (String)id, value);\n+                    }\n+                } else {\n+                    Callable fun;\n+                    String definer;\n+                    if (getterSetter < 0)   // < 0 means get foo() ...\n+                        definer = \"__defineGetter__\";\n+                    else\n+                        definer = \"__defineSetter__\";\n+                    fun = getPropFunctionAndThis(object, definer, cx);\n+                    // Must consume the last scriptable object in cx\n+                    lastStoredScriptable(cx);\n+                    Object[] outArgs = new Object[2];\n+                    outArgs[0] = id;\n+                    outArgs[1] = value;\n+                    fun.call(cx, scope, object, outArgs);\n+                }\n+            } else {\n+                int index = ((Integer)id).intValue();\n+                ScriptableObject.putProperty(object, index, value);\n+            }\n+        }\n+        return object;\n+    }\n+\n+    public static boolean isArrayObject(Object obj)\n+    {\n+        return obj instanceof NativeArray || obj instanceof Arguments;\n+    }\n+\n+    public static Object[] getArrayElements(Scriptable object)\n+    {\n+        Context cx = Context.getContext();\n+        long longLen = NativeArray.getLengthProperty(cx, object);\n+        if (longLen > Integer.MAX_VALUE) {\n+            // arrays beyond  MAX_INT is not in Java in any case\n+            throw new IllegalArgumentException();\n+        }\n+        int len = (int) longLen;\n+        if (len == 0) {\n+            return ScriptRuntime.emptyArgs;\n+        } else {\n+            Object[] result = new Object[len];\n+            for (int i=0; i < len; i++) {\n+                Object elem = ScriptableObject.getProperty(object, i);\n+                result[i] = (elem == Scriptable.NOT_FOUND) ? Undefined.instance\n+                                                           : elem;\n+            }\n+            return result;\n+        }\n+    }\n+\n+    static void checkDeprecated(Context cx, String name) {\n+        int version = cx.getLanguageVersion();\n+        if (version >= Context.VERSION_1_4 || version == Context.VERSION_DEFAULT) {\n+            String msg = getMessage1(\"msg.deprec.ctor\", name);\n+            if (version == Context.VERSION_DEFAULT)\n+                Context.reportWarning(msg);\n+            else\n+                throw Context.reportRuntimeError(msg);\n+        }\n+    }\n+\n+    public static String getMessage0(String messageId)\n+    {\n+        return getMessage(messageId, null);\n+    }\n+\n+    public static String getMessage1(String messageId, Object arg1)\n+    {\n+        Object[] arguments = {arg1};\n+        return getMessage(messageId, arguments);\n+    }\n+\n+    public static String getMessage2(\n+        String messageId, Object arg1, Object arg2)\n+    {\n+        Object[] arguments = {arg1, arg2};\n+        return getMessage(messageId, arguments);\n+    }\n+\n+    public static String getMessage3(\n+        String messageId, Object arg1, Object arg2, Object arg3)\n+    {\n+        Object[] arguments = {arg1, arg2, arg3};\n+        return getMessage(messageId, arguments);\n+    }\n+\n+    public static String getMessage4(\n+        String messageId, Object arg1, Object arg2, Object arg3, Object arg4)\n+    {\n+        Object[] arguments = {arg1, arg2, arg3, arg4};\n+        return getMessage(messageId, arguments);\n+    }\n+\n+    /**\n+     * This is an interface defining a message provider. Create your\n+     * own implementation to override the default error message provider.\n+     *\n+     */\n+    public interface MessageProvider {\n+\n+        /**\n+         * Returns a textual message identified by the given messageId,\n+         * parameterized by the given arguments.\n+         *\n+         * @param messageId the identifier of the message\n+         * @param arguments the arguments to fill into the message\n+         */\n+        String getMessage(String messageId, Object[] arguments);\n+    }\n+\n+    public static MessageProvider messageProvider = new DefaultMessageProvider();\n+\n+    public static String getMessage(String messageId, Object[] arguments)\n+    {\n+        return messageProvider.getMessage(messageId, arguments);\n+    }\n+\n+    /* OPT there's a noticable delay for the first error!  Maybe it'd\n+     * make sense to use a ListResourceBundle instead of a properties\n+     * file to avoid (synchronized) text parsing.\n+     */\n+    private static class DefaultMessageProvider implements MessageProvider {\n+        public String getMessage(String messageId, Object[] arguments) {\n+            final String defaultResource\n+                = \"org.mozilla.javascript.resources.Messages\";\n+\n+            Context cx = Context.getCurrentContext();\n+            Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();\n+\n+            // ResourceBundle does caching.\n+            ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n+\n+            String formatString;\n+            try {\n+                formatString = rb.getString(messageId);\n+            } catch (java.util.MissingResourceException mre) {\n+                throw new RuntimeException\n+                    (\"no message resource found for message property \"+ messageId);\n+            }\n+\n+            /*\n+             * It's OK to format the string, even if 'arguments' is null;\n+             * we need to format it anyway, to make double ''s collapse to\n+             * single 's.\n+             */\n+            MessageFormat formatter = new MessageFormat(formatString);\n+            return formatter.format(arguments);\n+        }\n+    }\n+\n+    public static EcmaError constructError(String error, String message)\n+    {\n+        int[] linep = new int[1];\n+        String filename = Context.getSourcePositionFromStack(linep);\n+        return constructError(error, message, filename, linep[0], null, 0);\n+    }\n+\n+    public static EcmaError constructError(String error,\n+                                           String message,\n+                                           int lineNumberDelta)\n+    {\n+        int[] linep = new int[1];\n+        String filename = Context.getSourcePositionFromStack(linep);\n+        if (linep[0] != 0) {\n+            linep[0] += lineNumberDelta;\n+        }\n+        return constructError(error, message, filename, linep[0], null, 0);\n+    }\n+\n+    public static EcmaError constructError(String error,\n+                                           String message,\n+                                           String sourceName,\n+                                           int lineNumber,\n+                                           String lineSource,\n+                                           int columnNumber)\n+    {\n+        return new EcmaError(error, message, sourceName,\n+                             lineNumber, lineSource, columnNumber);\n+    }\n+\n+    public static EcmaError typeError(String message)\n+    {\n+        return constructError(\"TypeError\", message);\n+    }\n+\n+    public static EcmaError typeError0(String messageId)\n+    {\n+        String msg = getMessage0(messageId);\n+        return typeError(msg);\n+    }\n+\n+    public static EcmaError typeError1(String messageId, String arg1)\n+    {\n+        String msg = getMessage1(messageId, arg1);\n+        return typeError(msg);\n+    }\n+\n+    public static EcmaError typeError2(String messageId, String arg1,\n+                                       String arg2)\n+    {\n+        String msg = getMessage2(messageId, arg1, arg2);\n+        return typeError(msg);\n+    }\n+\n+    public static EcmaError typeError3(String messageId, String arg1,\n+                                       String arg2, String arg3)\n+    {\n+        String msg = getMessage3(messageId, arg1, arg2, arg3);\n+        return typeError(msg);\n+    }\n+\n+    public static RuntimeException undefReadError(Object object, Object id)\n+    {\n+        String idStr = (id == null) ? \"null\" : id.toString();\n+        return typeError2(\"msg.undef.prop.read\", toString(object), idStr);\n+    }\n+\n+    public static RuntimeException undefCallError(Object object, Object id)\n+    {\n+        String idStr = (id == null) ? \"null\" : id.toString();\n+        return typeError2(\"msg.undef.method.call\", toString(object), idStr);\n+    }\n+\n+    public static RuntimeException undefWriteError(Object object,\n+                                                   Object id,\n+                                                   Object value)\n+    {\n+        String idStr = (id == null) ? \"null\" : id.toString();\n+        String valueStr = (value instanceof Scriptable)\n+                          ? value.toString() : toString(value);\n+        return typeError3(\"msg.undef.prop.write\", toString(object), idStr,\n+                          valueStr);\n+    }\n+\n+    public static RuntimeException notFoundError(Scriptable object,\n+                                                 String property)\n+    {\n+        // XXX: use object to improve the error message\n+        String msg = getMessage1(\"msg.is.not.defined\", property);\n+        throw constructError(\"ReferenceError\", msg);\n+    }\n+\n+    public static RuntimeException notFunctionError(Object value)\n+    {\n+        return notFunctionError(value, value);\n+    }\n+\n+    public static RuntimeException notFunctionError(Object value,\n+                                                    Object messageHelper)\n+    {\n+        // Use value for better error reporting\n+        String msg = (messageHelper == null)\n+                     ? \"null\" : messageHelper.toString();\n+        if (value == Scriptable.NOT_FOUND) {\n+            return typeError1(\"msg.function.not.found\", msg);\n+        }\n+        return typeError2(\"msg.isnt.function\", msg, typeof(value));\n+    }\n+\n+    public static RuntimeException notFunctionError(Object obj, Object value,\n+            String propertyName)\n+    {\n+        // Use obj and value for better error reporting\n+        String objString = toString(obj);\n+        if (value == Scriptable.NOT_FOUND) {\n+            return typeError2(\"msg.function.not.found.in\", propertyName,\n+                    objString);\n+        }\n+        return typeError3(\"msg.isnt.function.in\", propertyName, objString,\n+                          typeof(value));\n+    }\n+\n+    private static RuntimeException notXmlError(Object value)\n+    {\n+        throw typeError1(\"msg.isnt.xml.object\", toString(value));\n+    }\n+\n+    private static void warnAboutNonJSObject(Object nonJSObject)\n+    {\n+        String message =\n+\"RHINO USAGE WARNING: Missed Context.javaToJS() conversion:\\n\"\n++\"Rhino runtime detected object \"+nonJSObject+\" of class \"+nonJSObject.getClass().getName()+\" where it expected String, Number, Boolean or Scriptable instance. Please check your code for missing Context.javaToJS() call.\";\n+        Context.reportWarning(message);\n+        // Just to be sure that it would be noticed\n+        System.err.println(message);\n+    }\n+\n+    public static RegExpProxy getRegExpProxy(Context cx)\n+    {\n+        return cx.getRegExpProxy();\n+    }\n+\n+    public static void setRegExpProxy(Context cx, RegExpProxy proxy)\n+    {\n+        if (proxy == null) throw new IllegalArgumentException();\n+        cx.regExpProxy = proxy;\n+    }\n+\n+    public static RegExpProxy checkRegExpProxy(Context cx)\n+    {\n+        RegExpProxy result = getRegExpProxy(cx);\n+        if (result == null) {\n+            throw Context.reportRuntimeError0(\"msg.no.regexp\");\n+        }\n+        return result;\n+    }\n+\n+    private static XMLLib currentXMLLib(Context cx)\n+    {\n+        // Scripts should be running to access this\n+        if (cx.topCallScope == null)\n+            throw new IllegalStateException();\n+\n+        XMLLib xmlLib = cx.cachedXMLLib;\n+        if (xmlLib == null) {\n+            xmlLib = XMLLib.extractFromScope(cx.topCallScope);\n+            if (xmlLib == null)\n+                throw new IllegalStateException();\n+            cx.cachedXMLLib = xmlLib;\n+        }\n+\n+        return xmlLib;\n+    }\n+\n+    /**\n+     * Escapes the reserved characters in a value of an attribute\n+     *\n+     * @param value Unescaped text\n+     * @return The escaped text\n+     */\n+    public static String escapeAttributeValue(Object value, Context cx)\n+    {\n+        XMLLib xmlLib = currentXMLLib(cx);\n+        return xmlLib.escapeAttributeValue(value);\n+    }\n+\n+    /**\n+     * Escapes the reserved characters in a value of a text node\n+     *\n+     * @param value Unescaped text\n+     * @return The escaped text\n+     */\n+    public static String escapeTextValue(Object value, Context cx)\n+    {\n+        XMLLib xmlLib = currentXMLLib(cx);\n+        return xmlLib.escapeTextValue(value);\n+    }\n+\n+    public static Ref memberRef(Object obj, Object elem,\n+                                Context cx, int memberTypeFlags)\n+    {\n+        if (!(obj instanceof XMLObject)) {\n+            throw notXmlError(obj);\n+        }\n+        XMLObject xmlObject = (XMLObject)obj;\n+        return xmlObject.memberRef(cx, elem, memberTypeFlags);\n+    }\n+\n+    public static Ref memberRef(Object obj, Object namespace, Object elem,\n+                                Context cx, int memberTypeFlags)\n+    {\n+        if (!(obj instanceof XMLObject)) {\n+            throw notXmlError(obj);\n+        }\n+        XMLObject xmlObject = (XMLObject)obj;\n+        return xmlObject.memberRef(cx, namespace, elem, memberTypeFlags);\n+    }\n+\n+    public static Ref nameRef(Object name, Context cx,\n+                              Scriptable scope, int memberTypeFlags)\n+    {\n+        XMLLib xmlLib = currentXMLLib(cx);\n+        return xmlLib.nameRef(cx, name, scope, memberTypeFlags);\n+    }\n+\n+    public static Ref nameRef(Object namespace, Object name, Context cx,\n+                              Scriptable scope, int memberTypeFlags)\n+    {\n+        XMLLib xmlLib = currentXMLLib(cx);\n+        return xmlLib.nameRef(cx, namespace, name, scope, memberTypeFlags);\n+    }\n+\n+    private static void storeIndexResult(Context cx, int index)\n+    {\n+        cx.scratchIndex = index;\n+    }\n+\n+    static int lastIndexResult(Context cx)\n+    {\n+        return cx.scratchIndex;\n+    }\n+\n+    public static void storeUint32Result(Context cx, long value)\n+    {\n+        if ((value >>> 32) != 0)\n+            throw new IllegalArgumentException();\n+        cx.scratchUint32 = value;\n+    }\n+\n+    public static long lastUint32Result(Context cx)\n+    {\n+        long value = cx.scratchUint32;\n+        if ((value >>> 32) != 0)\n+            throw new IllegalStateException();\n+        return value;\n+    }\n+\n+    private static void storeScriptable(Context cx, Scriptable value)\n+    {\n+        // The previously stored scratchScriptable should be consumed\n+        if (cx.scratchScriptable != null)\n+            throw new IllegalStateException();\n+        cx.scratchScriptable = value;\n+    }\n+\n+    public static Scriptable lastStoredScriptable(Context cx)\n+    {\n+        Scriptable result = cx.scratchScriptable;\n+        cx.scratchScriptable = null;\n+        return result;\n+    }\n+\n+    static String makeUrlForGeneratedScript\n+        (boolean isEval, String masterScriptUrl, int masterScriptLine)\n+    {\n+        if (isEval) {\n+            return masterScriptUrl+'#'+masterScriptLine+\"(eval)\";\n+        } else {\n+            return masterScriptUrl+'#'+masterScriptLine+\"(Function)\";\n+        }\n+    }\n+\n+    static boolean isGeneratedScript(String sourceUrl) {\n+        // ALERT: this may clash with a valid URL containing (eval) or\n+        // (Function)\n+        return sourceUrl.indexOf(\"(eval)\") >= 0\n+               || sourceUrl.indexOf(\"(Function)\") >= 0;\n+    }\n+\n+    private static RuntimeException errorWithClassName(String msg, Object val)\n+    {\n+        return Context.reportRuntimeError1(msg, val.getClass().getName());\n+    }\n+\n+    public static final Object[] emptyArgs = new Object[0];\n+    public static final String[] emptyStrings = new String[0];\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Scriptable.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This is interface that all objects in JavaScript must implement.\n+ * The interface provides for the management of properties and for\n+ * performing conversions.\n+ * <p>\n+ * Host system implementors may find it easier to extend the ScriptableObject\n+ * class rather than implementing Scriptable when writing host objects.\n+ * <p>\n+ * There are many static methods defined in ScriptableObject that perform\n+ * the multiple calls to the Scriptable interface needed in order to\n+ * manipulate properties in prototype chains.\n+ * <p>\n+ *\n+ * @see org.mozilla.javascript.ScriptableObject\n+ */\n+\n+public interface Scriptable {\n+\n+    /**\n+     * Get the name of the set of objects implemented by this Java class.\n+     * This corresponds to the [[Class]] operation in ECMA and is used\n+     * by Object.prototype.toString() in ECMA.<p>\n+     * See ECMA 8.6.2 and 15.2.4.2.\n+     */\n+    public String getClassName();\n+\n+    /**\n+     * Value returned from <code>get</code> if the property is not\n+     * found.\n+     */\n+    public static final Object NOT_FOUND = UniqueTag.NOT_FOUND;\n+\n+    /**\n+     * Get a named property from the object.\n+     *\n+     * Looks property up in this object and returns the associated value\n+     * if found. Returns NOT_FOUND if not found.\n+     * Note that this method is not expected to traverse the prototype\n+     * chain. This is different from the ECMA [[Get]] operation.\n+     *\n+     * Depending on the property selector, the runtime will call\n+     * this method or the form of <code>get</code> that takes an\n+     * integer:\n+     * <table>\n+     * <tr><th>JavaScript code</th><th>Java code</th></tr>\n+     * <tr><td>a.b      </td><td>a.get(\"b\", a)</td></tr>\n+     * <tr><td>a[\"foo\"] </td><td>a.get(\"foo\", a)</td></tr>\n+     * <tr><td>a[3]     </td><td>a.get(3, a)</td></tr>\n+     * <tr><td>a[\"3\"]   </td><td>a.get(3, a)</td></tr>\n+     * <tr><td>a[3.0]   </td><td>a.get(3, a)</td></tr>\n+     * <tr><td>a[\"3.0\"] </td><td>a.get(\"3.0\", a)</td></tr>\n+     * <tr><td>a[1.1]   </td><td>a.get(\"1.1\", a)</td></tr>\n+     * <tr><td>a[-4]    </td><td>a.get(-4, a)</td></tr>\n+     * </table>\n+     * <p>\n+     * The values that may be returned are limited to the following:\n+     * <UL>\n+     * <LI>java.lang.Boolean objects</LI>\n+     * <LI>java.lang.String objects</LI>\n+     * <LI>java.lang.Number objects</LI>\n+     * <LI>org.mozilla.javascript.Scriptable objects</LI>\n+     * <LI>null</LI>\n+     * <LI>The value returned by Context.getUndefinedValue()</LI>\n+     * <LI>NOT_FOUND</LI>\n+     * </UL>\n+     * @param name the name of the property\n+     * @param start the object in which the lookup began\n+     * @return the value of the property (may be null), or NOT_FOUND\n+     * @see org.mozilla.javascript.Context#getUndefinedValue\n+     */\n+    public Object get(String name, Scriptable start);\n+\n+    /**\n+     * Get a property from the object selected by an integral index.\n+     *\n+     * Identical to <code>get(String, Scriptable)</code> except that\n+     * an integral index is used to select the property.\n+     *\n+     * @param index the numeric index for the property\n+     * @param start the object in which the lookup began\n+     * @return the value of the property (may be null), or NOT_FOUND\n+     * @see org.mozilla.javascript.Scriptable#get(String,Scriptable)\n+     */\n+    public Object get(int index, Scriptable start);\n+\n+    /**\n+     * Indicates whether or not a named property is defined in an object.\n+     *\n+     * Does not traverse the prototype chain.<p>\n+     *\n+     * The property is specified by a String name\n+     * as defined for the <code>get</code> method.<p>\n+     *\n+     * @param name the name of the property\n+     * @param start the object in which the lookup began\n+     * @return true if and only if the named property is found in the object\n+     * @see org.mozilla.javascript.Scriptable#get(String, Scriptable)\n+     * @see org.mozilla.javascript.ScriptableObject#getProperty(Scriptable, String)\n+     */\n+    public boolean has(String name, Scriptable start);\n+\n+    /**\n+     * Indicates whether or not an indexed  property is defined in an object.\n+     *\n+     * Does not traverse the prototype chain.<p>\n+     *\n+     * The property is specified by an integral index\n+     * as defined for the <code>get</code> method.<p>\n+     *\n+     * @param index the numeric index for the property\n+     * @param start the object in which the lookup began\n+     * @return true if and only if the indexed property is found in the object\n+     * @see org.mozilla.javascript.Scriptable#get(int, Scriptable)\n+     * @see org.mozilla.javascript.ScriptableObject#getProperty(Scriptable, int)\n+     */\n+    public boolean has(int index, Scriptable start);\n+\n+    /**\n+     * Sets a named property in this object.\n+     * <p>\n+     * The property is specified by a string name\n+     * as defined for <code>get</code>.\n+     * <p>\n+     * The possible values that may be passed in are as defined for\n+     * <code>get</code>. A class that implements this method may choose\n+     * to ignore calls to set certain properties, in which case those\n+     * properties are effectively read-only.<p>\n+     * For properties defined in a prototype chain,\n+     * use <code>putProperty</code> in ScriptableObject. <p>\n+     * Note that if a property <i>a</i> is defined in the prototype <i>p</i>\n+     * of an object <i>o</i>, then evaluating <code>o.a = 23</code> will cause\n+     * <code>set</code> to be called on the prototype <i>p</i> with\n+     * <i>o</i> as the  <i>start</i> parameter.\n+     * To preserve JavaScript semantics, it is the Scriptable\n+     * object's responsibility to modify <i>o</i>. <p>\n+     * This design allows properties to be defined in prototypes and implemented\n+     * in terms of getters and setters of Java values without consuming slots\n+     * in each instance.<p>\n+     * <p>\n+     * The values that may be set are limited to the following:\n+     * <UL>\n+     * <LI>java.lang.Boolean objects</LI>\n+     * <LI>java.lang.String objects</LI>\n+     * <LI>java.lang.Number objects</LI>\n+     * <LI>org.mozilla.javascript.Scriptable objects</LI>\n+     * <LI>null</LI>\n+     * <LI>The value returned by Context.getUndefinedValue()</LI>\n+     * </UL><p>\n+     * Arbitrary Java objects may be wrapped in a Scriptable by first calling\n+     * <code>Context.toObject</code>. This allows the property of a JavaScript\n+     * object to contain an arbitrary Java object as a value.<p>\n+     * Note that <code>has</code> will be called by the runtime first before\n+     * <code>set</code> is called to determine in which object the\n+     * property is defined.\n+     * Note that this method is not expected to traverse the prototype chain,\n+     * which is different from the ECMA [[Put]] operation.\n+     * @param name the name of the property\n+     * @param start the object whose property is being set\n+     * @param value value to set the property to\n+     * @see org.mozilla.javascript.Scriptable#has(String, Scriptable)\n+     * @see org.mozilla.javascript.Scriptable#get(String, Scriptable)\n+     * @see org.mozilla.javascript.ScriptableObject#putProperty(Scriptable, String, Object)\n+     * @see org.mozilla.javascript.Context#toObject(Object, Scriptable)\n+     */\n+    public void put(String name, Scriptable start, Object value);\n+\n+    /**\n+     * Sets an indexed property in this object.\n+     * <p>\n+     * The property is specified by an integral index\n+     * as defined for <code>get</code>.<p>\n+     *\n+     * Identical to <code>put(String, Scriptable, Object)</code> except that\n+     * an integral index is used to select the property.\n+     *\n+     * @param index the numeric index for the property\n+     * @param start the object whose property is being set\n+     * @param value value to set the property to\n+     * @see org.mozilla.javascript.Scriptable#has(int, Scriptable)\n+     * @see org.mozilla.javascript.Scriptable#get(int, Scriptable)\n+     * @see org.mozilla.javascript.ScriptableObject#putProperty(Scriptable, int, Object)\n+     * @see org.mozilla.javascript.Context#toObject(Object, Scriptable)\n+     */\n+    public void put(int index, Scriptable start, Object value);\n+\n+    /**\n+     * Removes a property from this object.\n+     * This operation corresponds to the ECMA [[Delete]] except that\n+     * the no result is returned. The runtime will guarantee that this\n+     * method is called only if the property exists. After this method\n+     * is called, the runtime will call Scriptable.has to see if the\n+     * property has been removed in order to determine the boolean\n+     * result of the delete operator as defined by ECMA 11.4.1.\n+     * <p>\n+     * A property can be made permanent by ignoring calls to remove\n+     * it.<p>\n+     * The property is specified by a String name\n+     * as defined for <code>get</code>.\n+     * <p>\n+     * To delete properties defined in a prototype chain,\n+     * see deleteProperty in ScriptableObject.\n+     * @param name the identifier for the property\n+     * @see org.mozilla.javascript.Scriptable#get(String, Scriptable)\n+     * @see org.mozilla.javascript.ScriptableObject#deleteProperty(Scriptable, String)\n+     */\n+    public void delete(String name);\n+\n+    /**\n+     * Removes a property from this object.\n+     *\n+     * The property is specified by an integral index\n+     * as defined for <code>get</code>.\n+     * <p>\n+     * To delete properties defined in a prototype chain,\n+     * see deleteProperty in ScriptableObject.\n+     *\n+     * Identical to <code>delete(String)</code> except that\n+     * an integral index is used to select the property.\n+     *\n+     * @param index the numeric index for the property\n+     * @see org.mozilla.javascript.Scriptable#get(int, Scriptable)\n+     * @see org.mozilla.javascript.ScriptableObject#deleteProperty(Scriptable, int)\n+     */\n+    public void delete(int index);\n+\n+    /**\n+     * Get the prototype of the object.\n+     * @return the prototype\n+     */\n+    public Scriptable getPrototype();\n+\n+    /**\n+     * Set the prototype of the object.\n+     * @param prototype the prototype to set\n+     */\n+    public void setPrototype(Scriptable prototype);\n+\n+    /**\n+     * Get the parent scope of the object.\n+     * @return the parent scope\n+     */\n+    public Scriptable getParentScope();\n+\n+    /**\n+     * Set the parent scope of the object.\n+     * @param parent the parent scope to set\n+     */\n+    public void setParentScope(Scriptable parent);\n+\n+    /**\n+     * Get an array of property ids.\n+     *\n+     * Not all property ids need be returned. Those properties\n+     * whose ids are not returned are considered non-enumerable.\n+     *\n+     * @return an array of Objects. Each entry in the array is either\n+     *         a java.lang.String or a java.lang.Number\n+     */\n+    public Object[] getIds();\n+\n+    /**\n+     * Get the default value of the object with a given hint.\n+     * The hints are String.class for type String, Number.class for type\n+     * Number, Scriptable.class for type Object, and Boolean.class for\n+     * type Boolean. <p>\n+     *\n+     * A <code>hint</code> of null means \"no hint\".\n+     *\n+     * See ECMA 8.6.2.6.\n+     *\n+     * @param hint the type hint\n+     * @return the default value\n+     */\n+    public Object getDefaultValue(Class<?> hint);\n+\n+    /**\n+     * The instanceof operator.\n+     *\n+     * <p>\n+     * The JavaScript code \"lhs instanceof rhs\" causes rhs.hasInstance(lhs) to\n+     * be called.\n+     *\n+     * <p>\n+     * The return value is implementation dependent so that embedded host objects can\n+     * return an appropriate value.  See the JS 1.3 language documentation for more\n+     * detail.\n+     *\n+     * <p>This operator corresponds to the proposed EMCA [[HasInstance]] operator.\n+     *\n+     * @param instance The value that appeared on the LHS of the instanceof\n+     *              operator\n+     *\n+     * @return an implementation dependent value\n+     */\n+    public boolean hasInstance(Scriptable instance);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ScriptableObject.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Daniel Gredler\n+ *   Bob Jervis\n+ *   Roger Lawrence\n+ *   Cameron McCormack\n+ *   Steve Weiss\n+ *   Hannes Wallnoefer\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.reflect.*;\n+import java.lang.annotation.Annotation;\n+import java.util.*;\n+import java.io.*;\n+import org.mozilla.javascript.debug.DebuggableObject;\n+import org.mozilla.javascript.annotations.*;\n+\n+/**\n+ * This is the default implementation of the Scriptable interface. This\n+ * class provides convenient default behavior that makes it easier to\n+ * define host objects.\n+ * <p>\n+ * Various properties and methods of JavaScript objects can be conveniently\n+ * defined using methods of ScriptableObject.\n+ * <p>\n+ * Classes extending ScriptableObject must define the getClassName method.\n+ *\n+ * @see org.mozilla.javascript.Scriptable\n+ */\n+\n+public abstract class ScriptableObject implements Scriptable, Serializable,\n+                                                  DebuggableObject,\n+                                                  ConstProperties, Map\n+{\n+\n+    /**\n+     * The empty property attribute.\n+     *\n+     * Used by getAttributes() and setAttributes().\n+     *\n+     * @see org.mozilla.javascript.ScriptableObject#getAttributes(String)\n+     * @see org.mozilla.javascript.ScriptableObject#setAttributes(String, int)\n+     */\n+    public static final int EMPTY =     0x00;\n+\n+    /**\n+     * Property attribute indicating assignment to this property is ignored.\n+     *\n+     * @see org.mozilla.javascript.ScriptableObject\n+     *      #put(String, Scriptable, Object)\n+     * @see org.mozilla.javascript.ScriptableObject#getAttributes(String)\n+     * @see org.mozilla.javascript.ScriptableObject#setAttributes(String, int)\n+     */\n+    public static final int READONLY =  0x01;\n+\n+    /**\n+     * Property attribute indicating property is not enumerated.\n+     *\n+     * Only enumerated properties will be returned by getIds().\n+     *\n+     * @see org.mozilla.javascript.ScriptableObject#getIds()\n+     * @see org.mozilla.javascript.ScriptableObject#getAttributes(String)\n+     * @see org.mozilla.javascript.ScriptableObject#setAttributes(String, int)\n+     */\n+    public static final int DONTENUM =  0x02;\n+\n+    /**\n+     * Property attribute indicating property cannot be deleted.\n+     *\n+     * @see org.mozilla.javascript.ScriptableObject#delete(String)\n+     * @see org.mozilla.javascript.ScriptableObject#getAttributes(String)\n+     * @see org.mozilla.javascript.ScriptableObject#setAttributes(String, int)\n+     */\n+    public static final int PERMANENT = 0x04;\n+\n+    /**\n+     * Property attribute indicating that this is a const property that has not\n+     * been assigned yet.  The first 'const' assignment to the property will\n+     * clear this bit.\n+     */\n+    public static final int UNINITIALIZED_CONST = 0x08;\n+\n+    public static final int CONST = PERMANENT|READONLY|UNINITIALIZED_CONST;\n+    /**\n+     * The prototype of this object.\n+     */\n+    private Scriptable prototypeObject;\n+\n+    /**\n+     * The parent scope of this object.\n+     */\n+    private Scriptable parentScopeObject;\n+\n+    private static final Slot REMOVED = new Slot(null, 0, READONLY);\n+\n+    static {\n+        REMOVED.wasDeleted = true;\n+    }\n+\n+    private transient Slot[] slots;\n+    // If count >= 0, it gives number of keys or if count < 0,\n+    // it indicates sealed object where ~count gives number of keys\n+    private int count;\n+\n+    // gateways into the definition-order linked list of slots\n+    private transient Slot firstAdded;\n+    private transient Slot lastAdded;\n+\n+    // cache; may be removed for smaller memory footprint\n+    private transient Slot lastAccess = REMOVED;\n+\n+    private volatile Map<Object,Object> associatedValues;\n+\n+    private static final int SLOT_QUERY = 1;\n+    private static final int SLOT_MODIFY = 2;\n+    private static final int SLOT_REMOVE = 3;\n+    private static final int SLOT_MODIFY_GETTER_SETTER = 4;\n+    private static final int SLOT_MODIFY_CONST = 5;\n+    private static final int SLOT_CONVERT_ACCESSOR_TO_DATA = 6;\n+\n+    private boolean isExtensible = true;\n+\n+    private static class Slot implements Serializable\n+    {\n+        private static final long serialVersionUID = -6090581677123995491L;\n+        String name; // This can change due to caching\n+        int indexOrHash;\n+        private volatile short attributes;\n+        transient volatile boolean wasDeleted;\n+        volatile Object value;\n+        transient volatile Slot next; // next in hash table bucket\n+        transient volatile Slot orderedNext; // next in linked list\n+\n+        Slot(String name, int indexOrHash, int attributes)\n+        {\n+            this.name = name;\n+            this.indexOrHash = indexOrHash;\n+            this.attributes = (short)attributes;\n+        }\n+\n+        private void readObject(ObjectInputStream in)\n+            throws IOException, ClassNotFoundException\n+        {\n+            in.defaultReadObject();\n+            if (name != null) {\n+                indexOrHash = name.hashCode();\n+            }\n+        }\n+\n+        final int getAttributes()\n+        {\n+            return attributes;\n+        }\n+\n+        final synchronized void setAttributes(int value)\n+        {\n+            checkValidAttributes(value);\n+            attributes = (short)value;\n+        }\n+\n+        final void checkNotReadonly()\n+        {\n+            if ((attributes & READONLY) != 0) {\n+                String str = (name != null ? name\n+                              : Integer.toString(indexOrHash));\n+                throw Context.reportRuntimeError1(\"msg.modify.readonly\", str);\n+            }\n+        }\n+\n+        ScriptableObject getPropertyDescriptor(Context cx, Scriptable scope) {\n+            return buildDataDescriptor(\n+                scope,\n+                (value == null ? Undefined.instance : value),\n+                attributes);\n+        }\n+\n+    }\n+\n+    protected static ScriptableObject buildDataDescriptor(Scriptable scope, Object value, int attributes) {\n+      ScriptableObject desc = new NativeObject();\n+      ScriptRuntime.setObjectProtoAndParent(desc, scope);\n+\n+      desc.defineProperty(\"value\",        value, EMPTY);\n+      desc.defineProperty(\"writable\",     (attributes & READONLY) == 0, EMPTY);\n+      desc.defineProperty(\"enumerable\",   (attributes & DONTENUM) == 0, EMPTY);\n+      desc.defineProperty(\"configurable\", (attributes & PERMANENT) == 0, EMPTY);\n+      return desc;\n+    }\n+\n+    private static final class GetterSlot extends Slot\n+    {\n+        static final long serialVersionUID = -4900574849788797588L;\n+\n+        Object getter;\n+        Object setter;\n+\n+        GetterSlot(String name, int indexOrHash, int attributes)\n+        {\n+            super(name, indexOrHash, attributes);\n+        }\n+\n+        @Override\n+        ScriptableObject getPropertyDescriptor(Context cx, Scriptable parent) {\n+          ScriptableObject desc = super.getPropertyDescriptor(cx, parent);\n+          desc.delete(\"value\");\n+          desc.delete(\"writable\");\n+          if (getter != null) desc.defineProperty(\"get\", getter, EMPTY);\n+          if (setter != null) desc.defineProperty(\"set\", setter, EMPTY);\n+          return desc;\n+        }\n+    }\n+\n+    static void checkValidAttributes(int attributes)\n+    {\n+        final int mask = READONLY | DONTENUM | PERMANENT | UNINITIALIZED_CONST;\n+        if ((attributes & ~mask) != 0) {\n+            throw new IllegalArgumentException(String.valueOf(attributes));\n+        }\n+    }\n+\n+    public ScriptableObject()\n+    {\n+    }\n+\n+    public ScriptableObject(Scriptable scope, Scriptable prototype)\n+    {\n+        if (scope == null)\n+            throw new IllegalArgumentException();\n+\n+        parentScopeObject = scope;\n+        prototypeObject = prototype;\n+    }\n+\n+    /**\n+     * Gets the value that will be returned by calling the typeof operator on this object.\n+     * @return default is \"object\" unless {@link #avoidObjectDetection()} is <code>true</code> in which\n+     * case it returns \"undefined\"\n+     */\n+    public String getTypeOf() {\n+    \treturn avoidObjectDetection() ? \"undefined\" : \"object\";\n+    }\n+\n+    /**\n+     * Return the name of the class.\n+     *\n+     * This is typically the same name as the constructor.\n+     * Classes extending ScriptableObject must implement this abstract\n+     * method.\n+     */\n+    public abstract String getClassName();\n+\n+    /**\n+     * Returns true if the named property is defined.\n+     *\n+     * @param name the name of the property\n+     * @param start the object in which the lookup began\n+     * @return true if and only if the property was found in the object\n+     */\n+    public boolean has(String name, Scriptable start)\n+    {\n+        return null != getSlot(name, 0, SLOT_QUERY);\n+    }\n+\n+    /**\n+     * Returns true if the property index is defined.\n+     *\n+     * @param index the numeric index for the property\n+     * @param start the object in which the lookup began\n+     * @return true if and only if the property was found in the object\n+     */\n+    public boolean has(int index, Scriptable start)\n+    {\n+        return null != getSlot(null, index, SLOT_QUERY);\n+    }\n+\n+    /**\n+     * Returns the value of the named property or NOT_FOUND.\n+     *\n+     * If the property was created using defineProperty, the\n+     * appropriate getter method is called.\n+     *\n+     * @param name the name of the property\n+     * @param start the object in which the lookup began\n+     * @return the value of the property (may be null), or NOT_FOUND\n+     */\n+    public Object get(String name, Scriptable start)\n+    {\n+        return getImpl(name, 0, start);\n+    }\n+\n+    /**\n+     * Returns the value of the indexed property or NOT_FOUND.\n+     *\n+     * @param index the numeric index for the property\n+     * @param start the object in which the lookup began\n+     * @return the value of the property (may be null), or NOT_FOUND\n+     */\n+    public Object get(int index, Scriptable start)\n+    {\n+        return getImpl(null, index, start);\n+    }\n+\n+    /**\n+     * Sets the value of the named property, creating it if need be.\n+     *\n+     * If the property was created using defineProperty, the\n+     * appropriate setter method is called. <p>\n+     *\n+     * If the property's attributes include READONLY, no action is\n+     * taken.\n+     * This method will actually set the property in the start\n+     * object.\n+     *\n+     * @param name the name of the property\n+     * @param start the object whose property is being set\n+     * @param value value to set the property to\n+     */\n+    public void put(String name, Scriptable start, Object value)\n+    {\n+        if (putImpl(name, 0, start, value, EMPTY))\n+            return;\n+\n+        if (start == this) throw Kit.codeBug();\n+        start.put(name, start, value);\n+    }\n+\n+    /**\n+     * Sets the value of the indexed property, creating it if need be.\n+     *\n+     * @param index the numeric index for the property\n+     * @param start the object whose property is being set\n+     * @param value value to set the property to\n+     */\n+    public void put(int index, Scriptable start, Object value)\n+    {\n+        if (putImpl(null, index, start, value, EMPTY))\n+            return;\n+\n+        if (start == this) throw Kit.codeBug();\n+        start.put(index, start, value);\n+    }\n+\n+    /**\n+     * Removes a named property from the object.\n+     *\n+     * If the property is not found, or it has the PERMANENT attribute,\n+     * no action is taken.\n+     *\n+     * @param name the name of the property\n+     */\n+    public void delete(String name)\n+    {\n+        checkNotSealed(name, 0);\n+        accessSlot(name, 0, SLOT_REMOVE);\n+    }\n+\n+    /**\n+     * Removes the indexed property from the object.\n+     *\n+     * If the property is not found, or it has the PERMANENT attribute,\n+     * no action is taken.\n+     *\n+     * @param index the numeric index for the property\n+     */\n+    public void delete(int index)\n+    {\n+        checkNotSealed(null, index);\n+        accessSlot(null, index, SLOT_REMOVE);\n+    }\n+\n+    /**\n+     * Sets the value of the named const property, creating it if need be.\n+     *\n+     * If the property was created using defineProperty, the\n+     * appropriate setter method is called. <p>\n+     *\n+     * If the property's attributes include READONLY, no action is\n+     * taken.\n+     * This method will actually set the property in the start\n+     * object.\n+     *\n+     * @param name the name of the property\n+     * @param start the object whose property is being set\n+     * @param value value to set the property to\n+     */\n+    public void putConst(String name, Scriptable start, Object value)\n+    {\n+        if (putImpl(name, 0, start, value, READONLY))\n+            return;\n+\n+        if (start == this) throw Kit.codeBug();\n+        if (start instanceof ConstProperties)\n+            ((ConstProperties)start).putConst(name, start, value);\n+        else\n+            start.put(name, start, value);\n+    }\n+\n+    public void defineConst(String name, Scriptable start)\n+    {\n+        if (putImpl(name, 0, start, Undefined.instance, UNINITIALIZED_CONST))\n+            return;\n+\n+        if (start == this) throw Kit.codeBug();\n+        if (start instanceof ConstProperties)\n+            ((ConstProperties)start).defineConst(name, start);\n+    }\n+    /**\n+     * Returns true if the named property is defined as a const on this object.\n+     * @param name\n+     * @return true if the named property is defined as a const, false\n+     * otherwise.\n+     */\n+    public boolean isConst(String name)\n+    {\n+        Slot slot = getSlot(name, 0, SLOT_QUERY);\n+        if (slot == null) {\n+            return false;\n+        }\n+        return (slot.getAttributes() & (PERMANENT|READONLY)) ==\n+                                       (PERMANENT|READONLY);\n+\n+    }\n+    /**\n+     * @deprecated Use {@link #getAttributes(String name)}. The engine always\n+     * ignored the start argument.\n+     */\n+    public final int getAttributes(String name, Scriptable start)\n+    {\n+        return getAttributes(name);\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #getAttributes(int index)}. The engine always\n+     * ignored the start argument.\n+     */\n+    public final int getAttributes(int index, Scriptable start)\n+    {\n+        return getAttributes(index);\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #setAttributes(String name, int attributes)}.\n+     * The engine always ignored the start argument.\n+     */\n+    public final void setAttributes(String name, Scriptable start,\n+                                    int attributes)\n+    {\n+        setAttributes(name, attributes);\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #setAttributes(int index, int attributes)}.\n+     * The engine always ignored the start argument.\n+     */\n+    public void setAttributes(int index, Scriptable start,\n+                              int attributes)\n+    {\n+        setAttributes(index, attributes);\n+    }\n+\n+    /**\n+     * Get the attributes of a named property.\n+     *\n+     * The property is specified by <code>name</code>\n+     * as defined for <code>has</code>.<p>\n+     *\n+     * @param name the identifier for the property\n+     * @return the bitset of attributes\n+     * @exception EvaluatorException if the named property is not found\n+     * @see org.mozilla.javascript.ScriptableObject#has(String, Scriptable)\n+     * @see org.mozilla.javascript.ScriptableObject#READONLY\n+     * @see org.mozilla.javascript.ScriptableObject#DONTENUM\n+     * @see org.mozilla.javascript.ScriptableObject#PERMANENT\n+     * @see org.mozilla.javascript.ScriptableObject#EMPTY\n+     */\n+    public int getAttributes(String name)\n+    {\n+        return findAttributeSlot(name, 0, SLOT_QUERY).getAttributes();\n+    }\n+\n+    /**\n+     * Get the attributes of an indexed property.\n+     *\n+     * @param index the numeric index for the property\n+     * @exception EvaluatorException if the named property is not found\n+     *            is not found\n+     * @return the bitset of attributes\n+     * @see org.mozilla.javascript.ScriptableObject#has(String, Scriptable)\n+     * @see org.mozilla.javascript.ScriptableObject#READONLY\n+     * @see org.mozilla.javascript.ScriptableObject#DONTENUM\n+     * @see org.mozilla.javascript.ScriptableObject#PERMANENT\n+     * @see org.mozilla.javascript.ScriptableObject#EMPTY\n+     */\n+    public int getAttributes(int index)\n+    {\n+        return findAttributeSlot(null, index, SLOT_QUERY).getAttributes();\n+    }\n+\n+    /**\n+     * Set the attributes of a named property.\n+     *\n+     * The property is specified by <code>name</code>\n+     * as defined for <code>has</code>.<p>\n+     *\n+     * The possible attributes are READONLY, DONTENUM,\n+     * and PERMANENT. Combinations of attributes\n+     * are expressed by the bitwise OR of attributes.\n+     * EMPTY is the state of no attributes set. Any unused\n+     * bits are reserved for future use.\n+     *\n+     * @param name the name of the property\n+     * @param attributes the bitset of attributes\n+     * @exception EvaluatorException if the named property is not found\n+     * @see org.mozilla.javascript.Scriptable#has(String, Scriptable)\n+     * @see org.mozilla.javascript.ScriptableObject#READONLY\n+     * @see org.mozilla.javascript.ScriptableObject#DONTENUM\n+     * @see org.mozilla.javascript.ScriptableObject#PERMANENT\n+     * @see org.mozilla.javascript.ScriptableObject#EMPTY\n+     */\n+    public void setAttributes(String name, int attributes)\n+    {\n+        checkNotSealed(name, 0);\n+        findAttributeSlot(name, 0, SLOT_MODIFY).setAttributes(attributes);\n+    }\n+\n+    /**\n+     * Set the attributes of an indexed property.\n+     *\n+     * @param index the numeric index for the property\n+     * @param attributes the bitset of attributes\n+     * @exception EvaluatorException if the named property is not found\n+     * @see org.mozilla.javascript.Scriptable#has(String, Scriptable)\n+     * @see org.mozilla.javascript.ScriptableObject#READONLY\n+     * @see org.mozilla.javascript.ScriptableObject#DONTENUM\n+     * @see org.mozilla.javascript.ScriptableObject#PERMANENT\n+     * @see org.mozilla.javascript.ScriptableObject#EMPTY\n+     */\n+    public void setAttributes(int index, int attributes)\n+    {\n+        checkNotSealed(null, index);\n+        findAttributeSlot(null, index, SLOT_MODIFY).setAttributes(attributes);\n+    }\n+\n+    /**\n+     * XXX: write docs.\n+     */\n+    public void setGetterOrSetter(String name, int index,\n+                                  Callable getterOrSetter, boolean isSetter)\n+    {\n+        setGetterOrSetter(name, index, getterOrSetter, isSetter, false);\n+    }\n+\n+    private void setGetterOrSetter(String name, int index, Callable getterOrSetter, boolean isSetter, boolean force)\n+    {\n+        if (name != null && index != 0)\n+            throw new IllegalArgumentException(name);\n+\n+        if (!force) {\n+          checkNotSealed(name, index);\n+        }\n+\n+        final GetterSlot gslot;\n+        if (isExtensible()) {\n+          gslot = (GetterSlot)getSlot(name, index, SLOT_MODIFY_GETTER_SETTER);\n+        } else {\n+          gslot = (GetterSlot)getSlot(name, index, SLOT_QUERY);\n+          if (gslot == null)\n+            return;\n+        }\n+\n+        if (!force) {\n+          gslot.checkNotReadonly();\n+        }\n+        if (isSetter) {\n+            gslot.setter = getterOrSetter;\n+        } else {\n+            gslot.getter = getterOrSetter;\n+        }\n+        gslot.value = Undefined.instance;\n+    }\n+\n+    /**\n+     * Get the getter or setter for a given property. Used by __lookupGetter__\n+     * and __lookupSetter__.\n+     *\n+     * @param name Name of the object. If nonnull, index must be 0.\n+     * @param index Index of the object. If nonzero, name must be null.\n+     * @param isSetter If true, return the setter, otherwise return the getter.\n+     * @exception IllegalArgumentException if both name and index are nonnull\n+     *            and nonzero respectively.\n+     * @return Null if the property does not exist. Otherwise returns either\n+     *         the getter or the setter for the property, depending on\n+     *         the value of isSetter (may be undefined if unset).\n+     */\n+    public Object getGetterOrSetter(String name, int index, boolean isSetter)\n+    {\n+        if (name != null && index != 0)\n+            throw new IllegalArgumentException(name);\n+        Slot slot = getSlot(name, index, SLOT_QUERY);\n+        if (slot == null)\n+            return null;\n+        if (slot instanceof GetterSlot) {\n+            GetterSlot gslot = (GetterSlot)slot;\n+            Object result = isSetter ? gslot.setter : gslot.getter;\n+            return result != null ? result : Undefined.instance;\n+        } else\n+            return Undefined.instance;\n+    }\n+\n+    /**\n+     * Returns whether a property is a getter or a setter\n+     * @param name property name\n+     * @param index property index\n+     * @param setter true to check for a setter, false for a getter\n+     * @return whether the property is a getter or a setter\n+     */\n+    protected boolean isGetterOrSetter(String name, int index, boolean setter) {\n+        Slot slot = getSlot(name, index, SLOT_QUERY);\n+        if (slot instanceof GetterSlot) {\n+            if (setter && ((GetterSlot)slot).setter != null) return true;\n+            if (!setter && ((GetterSlot)slot).getter != null) return true;\n+        }\n+        return false;\n+    }\n+\n+    void addLazilyInitializedValue(String name, int index,\n+                                   LazilyLoadedCtor init, int attributes)\n+    {\n+        if (name != null && index != 0)\n+            throw new IllegalArgumentException(name);\n+        checkNotSealed(name, index);\n+        GetterSlot gslot = (GetterSlot)getSlot(name, index,\n+                                               SLOT_MODIFY_GETTER_SETTER);\n+        gslot.setAttributes(attributes);\n+        gslot.getter = null;\n+        gslot.setter = null;\n+        gslot.value = init;\n+    }\n+\n+    /**\n+     * Returns the prototype of the object.\n+     */\n+    public Scriptable getPrototype()\n+    {\n+        return prototypeObject;\n+    }\n+\n+    /**\n+     * Sets the prototype of the object.\n+     */\n+    public void setPrototype(Scriptable m)\n+    {\n+        prototypeObject = m;\n+    }\n+\n+    /**\n+     * Returns the parent (enclosing) scope of the object.\n+     */\n+    public Scriptable getParentScope()\n+    {\n+        return parentScopeObject;\n+    }\n+\n+    /**\n+     * Sets the parent (enclosing) scope of the object.\n+     */\n+    public void setParentScope(Scriptable m)\n+    {\n+        parentScopeObject = m;\n+    }\n+\n+    /**\n+     * Returns an array of ids for the properties of the object.\n+     *\n+     * <p>Any properties with the attribute DONTENUM are not listed. <p>\n+     *\n+     * @return an array of java.lang.Objects with an entry for every\n+     * listed property. Properties accessed via an integer index will\n+     * have a corresponding\n+     * Integer entry in the returned array. Properties accessed by\n+     * a String will have a String entry in the returned array.\n+     */\n+    public Object[] getIds() {\n+        return getIds(false);\n+    }\n+\n+    /**\n+     * Returns an array of ids for the properties of the object.\n+     *\n+     * <p>All properties, even those with attribute DONTENUM, are listed. <p>\n+     *\n+     * @return an array of java.lang.Objects with an entry for every\n+     * listed property. Properties accessed via an integer index will\n+     * have a corresponding\n+     * Integer entry in the returned array. Properties accessed by\n+     * a String will have a String entry in the returned array.\n+     */\n+    public Object[] getAllIds() {\n+        return getIds(true);\n+    }\n+\n+    /**\n+     * Implements the [[DefaultValue]] internal method.\n+     *\n+     * <p>Note that the toPrimitive conversion is a no-op for\n+     * every type other than Object, for which [[DefaultValue]]\n+     * is called. See ECMA 9.1.<p>\n+     *\n+     * A <code>hint</code> of null means \"no hint\".\n+     *\n+     * @param typeHint the type hint\n+     * @return the default value for the object\n+     *\n+     * See ECMA 8.6.2.6.\n+     */\n+    public Object getDefaultValue(Class<?> typeHint)\n+    {\n+        return getDefaultValue(this, typeHint);\n+    }\n+\n+    public static Object getDefaultValue(Scriptable object, Class<?> typeHint)\n+    {\n+        Context cx = null;\n+        for (int i=0; i < 2; i++) {\n+            boolean tryToString;\n+            if (typeHint == ScriptRuntime.StringClass) {\n+                tryToString = (i == 0);\n+            } else {\n+                tryToString = (i == 1);\n+            }\n+\n+            String methodName;\n+            Object[] args;\n+            if (tryToString) {\n+                methodName = \"toString\";\n+                args = ScriptRuntime.emptyArgs;\n+            } else {\n+                methodName = \"valueOf\";\n+                args = new Object[1];\n+                String hint;\n+                if (typeHint == null) {\n+                    hint = \"undefined\";\n+                } else if (typeHint == ScriptRuntime.StringClass) {\n+                    hint = \"string\";\n+                } else if (typeHint == ScriptRuntime.ScriptableClass) {\n+                    hint = \"object\";\n+                } else if (typeHint == ScriptRuntime.FunctionClass) {\n+                    hint = \"function\";\n+                } else if (typeHint == ScriptRuntime.BooleanClass\n+                           || typeHint == Boolean.TYPE)\n+                {\n+                    hint = \"boolean\";\n+                } else if (typeHint == ScriptRuntime.NumberClass ||\n+                         typeHint == ScriptRuntime.ByteClass ||\n+                         typeHint == Byte.TYPE ||\n+                         typeHint == ScriptRuntime.ShortClass ||\n+                         typeHint == Short.TYPE ||\n+                         typeHint == ScriptRuntime.IntegerClass ||\n+                         typeHint == Integer.TYPE ||\n+                         typeHint == ScriptRuntime.FloatClass ||\n+                         typeHint == Float.TYPE ||\n+                         typeHint == ScriptRuntime.DoubleClass ||\n+                         typeHint == Double.TYPE)\n+                {\n+                    hint = \"number\";\n+                } else {\n+                    throw Context.reportRuntimeError1(\n+                        \"msg.invalid.type\", typeHint.toString());\n+                }\n+                args[0] = hint;\n+            }\n+            Object v = getProperty(object, methodName);\n+            if (!(v instanceof Function))\n+                continue;\n+            Function fun = (Function) v;\n+            if (cx == null)\n+                cx = Context.getContext();\n+            v = fun.call(cx, fun.getParentScope(), object, args);\n+            if (v != null) {\n+                if (!(v instanceof Scriptable)) {\n+                    return v;\n+                }\n+                if (typeHint == ScriptRuntime.ScriptableClass\n+                    || typeHint == ScriptRuntime.FunctionClass)\n+                {\n+                    return v;\n+                }\n+                if (tryToString && v instanceof Wrapper) {\n+                    // Let a wrapped java.lang.String pass for a primitive\n+                    // string.\n+                    Object u = ((Wrapper)v).unwrap();\n+                    if (u instanceof String)\n+                        return u;\n+                }\n+            }\n+        }\n+        // fall through to error\n+        String arg = (typeHint == null) ? \"undefined\" : typeHint.getName();\n+        throw ScriptRuntime.typeError1(\"msg.default.value\", arg);\n+    }\n+\n+    /**\n+     * Implements the instanceof operator.\n+     *\n+     * <p>This operator has been proposed to ECMA.\n+     *\n+     * @param instance The value that appeared on the LHS of the instanceof\n+     *              operator\n+     * @return true if \"this\" appears in value's prototype chain\n+     *\n+     */\n+    public boolean hasInstance(Scriptable instance) {\n+        // Default for JS objects (other than Function) is to do prototype\n+        // chasing.  This will be overridden in NativeFunction and non-JS\n+        // objects.\n+\n+        return ScriptRuntime.jsDelegatesTo(instance, this);\n+    }\n+\n+    /**\n+     * Emulate the SpiderMonkey (and Firefox) feature of allowing\n+     * custom objects to avoid detection by normal \"object detection\"\n+     * code patterns. This is used to implement document.all.\n+     * See https://bugzilla.mozilla.org/show_bug.cgi?id=412247.\n+     * This is an analog to JOF_DETECTING from SpiderMonkey; see\n+     * https://bugzilla.mozilla.org/show_bug.cgi?id=248549.\n+     * Other than this special case, embeddings should return false.\n+     * @return true if this object should avoid object detection\n+     * @since 1.7R1\n+     */\n+    public boolean avoidObjectDetection() {\n+        return false;\n+    }\n+\n+    /**\n+     * Custom <tt>==</tt> operator.\n+     * Must return {@link Scriptable#NOT_FOUND} if this object does not\n+     * have custom equality operator for the given value,\n+     * <tt>Boolean.TRUE</tt> if this object is equivalent to <tt>value</tt>,\n+     * <tt>Boolean.FALSE</tt> if this object is not equivalent to\n+     * <tt>value</tt>.\n+     * <p>\n+     * The default implementation returns Boolean.TRUE\n+     * if <tt>this == value</tt> or {@link Scriptable#NOT_FOUND} otherwise.\n+     * It indicates that by default custom equality is available only if\n+     * <tt>value</tt> is <tt>this</tt> in which case true is returned.\n+     */\n+    protected Object equivalentValues(Object value)\n+    {\n+        return (this == value) ? Boolean.TRUE : Scriptable.NOT_FOUND;\n+    }\n+\n+    /**\n+     * Defines JavaScript objects from a Java class that implements Scriptable.\n+     *\n+     * If the given class has a method\n+     * <pre>\n+     * static void init(Context cx, Scriptable scope, boolean sealed);</pre>\n+     *\n+     * or its compatibility form\n+     * <pre>\n+     * static void init(Scriptable scope);</pre>\n+     *\n+     * then it is invoked and no further initialization is done.<p>\n+     *\n+     * However, if no such a method is found, then the class's constructors and\n+     * methods are used to initialize a class in the following manner.<p>\n+     *\n+     * First, the zero-parameter constructor of the class is called to\n+     * create the prototype. If no such constructor exists,\n+     * a {@link EvaluatorException} is thrown. <p>\n+     *\n+     * Next, all methods are scanned for special prefixes that indicate that they\n+     * have special meaning for defining JavaScript objects.\n+     * These special prefixes are\n+     * <ul>\n+     * <li><code>jsFunction_</code> for a JavaScript function\n+     * <li><code>jsStaticFunction_</code> for a JavaScript function that\n+     *           is a property of the constructor\n+     * <li><code>jsGet_</code> for a getter of a JavaScript property\n+     * <li><code>jsSet_</code> for a setter of a JavaScript property\n+     * <li><code>jsConstructor</code> for a JavaScript function that\n+     *           is the constructor\n+     * </ul><p>\n+     *\n+     * If the method's name begins with \"jsFunction_\", a JavaScript function\n+     * is created with a name formed from the rest of the Java method name\n+     * following \"jsFunction_\". So a Java method named \"jsFunction_foo\" will\n+     * define a JavaScript method \"foo\". Calling this JavaScript function\n+     * will cause the Java method to be called. The parameters of the method\n+     * must be of number and types as defined by the FunctionObject class.\n+     * The JavaScript function is then added as a property\n+     * of the prototype. <p>\n+     *\n+     * If the method's name begins with \"jsStaticFunction_\", it is handled\n+     * similarly except that the resulting JavaScript function is added as a\n+     * property of the constructor object. The Java method must be static.\n+     *\n+     * If the method's name begins with \"jsGet_\" or \"jsSet_\", the method is\n+     * considered to define a property. Accesses to the defined property\n+     * will result in calls to these getter and setter methods. If no\n+     * setter is defined, the property is defined as READONLY.<p>\n+     *\n+     * If the method's name is \"jsConstructor\", the method is\n+     * considered to define the body of the constructor. Only one\n+     * method of this name may be defined. You may use the varargs forms\n+     * for constructors documented in {@link FunctionObject#FunctionObject(String, Member, Scriptable)}\n+     *\n+     * If no method is found that can serve as constructor, a Java\n+     * constructor will be selected to serve as the JavaScript\n+     * constructor in the following manner. If the class has only one\n+     * Java constructor, that constructor is used to define\n+     * the JavaScript constructor. If the the class has two constructors,\n+     * one must be the zero-argument constructor (otherwise an\n+     * {@link EvaluatorException} would have already been thrown\n+     * when the prototype was to be created). In this case\n+     * the Java constructor with one or more parameters will be used\n+     * to define the JavaScript constructor. If the class has three\n+     * or more constructors, an {@link EvaluatorException}\n+     * will be thrown.<p>\n+     *\n+     * Finally, if there is a method\n+     * <pre>\n+     * static void finishInit(Scriptable scope, FunctionObject constructor,\n+     *                        Scriptable prototype)</pre>\n+     *\n+     * it will be called to finish any initialization. The <code>scope</code>\n+     * argument will be passed, along with the newly created constructor and\n+     * the newly created prototype.<p>\n+     *\n+     * @param scope The scope in which to define the constructor.\n+     * @param clazz The Java class to use to define the JavaScript objects\n+     *              and properties.\n+     * @exception IllegalAccessException if access is not available\n+     *            to a reflected class member\n+     * @exception InstantiationException if unable to instantiate\n+     *            the named class\n+     * @exception InvocationTargetException if an exception is thrown\n+     *            during execution of methods of the named class\n+     * @see org.mozilla.javascript.Function\n+     * @see org.mozilla.javascript.FunctionObject\n+     * @see org.mozilla.javascript.ScriptableObject#READONLY\n+     * @see org.mozilla.javascript.ScriptableObject\n+     *      #defineProperty(String, Class, int)\n+     */\n+    public static <T extends Scriptable> void defineClass(\n+            Scriptable scope, Class<T> clazz)\n+        throws IllegalAccessException, InstantiationException,\n+               InvocationTargetException\n+    {\n+        defineClass(scope, clazz, false, false);\n+    }\n+\n+    /**\n+     * Defines JavaScript objects from a Java class, optionally\n+     * allowing sealing.\n+     *\n+     * Similar to <code>defineClass(Scriptable scope, Class clazz)</code>\n+     * except that sealing is allowed. An object that is sealed cannot have\n+     * properties added or removed. Note that sealing is not allowed in\n+     * the current ECMA/ISO language specification, but is likely for\n+     * the next version.\n+     *\n+     * @param scope The scope in which to define the constructor.\n+     * @param clazz The Java class to use to define the JavaScript objects\n+     *              and properties. The class must implement Scriptable.\n+     * @param sealed Whether or not to create sealed standard objects that\n+     *               cannot be modified.\n+     * @exception IllegalAccessException if access is not available\n+     *            to a reflected class member\n+     * @exception InstantiationException if unable to instantiate\n+     *            the named class\n+     * @exception InvocationTargetException if an exception is thrown\n+     *            during execution of methods of the named class\n+     * @since 1.4R3\n+     */\n+    public static <T extends Scriptable> void defineClass(\n+            Scriptable scope, Class<T> clazz, boolean sealed)\n+        throws IllegalAccessException, InstantiationException,\n+               InvocationTargetException\n+    {\n+        defineClass(scope, clazz, sealed, false);\n+    }\n+\n+    /**\n+     * Defines JavaScript objects from a Java class, optionally\n+     * allowing sealing and mapping of Java inheritance to JavaScript\n+     * prototype-based inheritance.\n+     *\n+     * Similar to <code>defineClass(Scriptable scope, Class clazz)</code>\n+     * except that sealing and inheritance mapping are allowed. An object\n+     * that is sealed cannot have properties added or removed. Note that\n+     * sealing is not allowed in the current ECMA/ISO language specification,\n+     * but is likely for the next version.\n+     *\n+     * @param scope The scope in which to define the constructor.\n+     * @param clazz The Java class to use to define the JavaScript objects\n+     *              and properties. The class must implement Scriptable.\n+     * @param sealed Whether or not to create sealed standard objects that\n+     *               cannot be modified.\n+     * @param mapInheritance Whether or not to map Java inheritance to\n+     *                       JavaScript prototype-based inheritance.\n+     * @return the class name for the prototype of the specified class\n+     * @exception IllegalAccessException if access is not available\n+     *            to a reflected class member\n+     * @exception InstantiationException if unable to instantiate\n+     *            the named class\n+     * @exception InvocationTargetException if an exception is thrown\n+     *            during execution of methods of the named class\n+     * @since 1.6R2\n+     */\n+    public static <T extends Scriptable> String defineClass(\n+            Scriptable scope, Class<T> clazz, boolean sealed,\n+            boolean mapInheritance)\n+        throws IllegalAccessException, InstantiationException,\n+               InvocationTargetException\n+    {\n+        BaseFunction ctor = buildClassCtor(scope, clazz, sealed,\n+                                           mapInheritance);\n+        if (ctor == null)\n+            return null;\n+        String name = ctor.getClassPrototype().getClassName();\n+        defineProperty(scope, name, ctor, ScriptableObject.DONTENUM);\n+        return name;\n+    }\n+\n+    static <T extends Scriptable> BaseFunction buildClassCtor(\n+            Scriptable scope, Class<T> clazz,\n+            boolean sealed,\n+            boolean mapInheritance)\n+        throws IllegalAccessException, InstantiationException,\n+               InvocationTargetException\n+    {\n+        Method[] methods = FunctionObject.getMethodList(clazz);\n+        for (int i=0; i < methods.length; i++) {\n+            Method method = methods[i];\n+            if (!method.getName().equals(\"init\"))\n+                continue;\n+            Class<?>[] parmTypes = method.getParameterTypes();\n+            if (parmTypes.length == 3 &&\n+                parmTypes[0] == ScriptRuntime.ContextClass &&\n+                parmTypes[1] == ScriptRuntime.ScriptableClass &&\n+                parmTypes[2] == Boolean.TYPE &&\n+                Modifier.isStatic(method.getModifiers()))\n+            {\n+                Object args[] = { Context.getContext(), scope,\n+                                  sealed ? Boolean.TRUE : Boolean.FALSE };\n+                method.invoke(null, args);\n+                return null;\n+            }\n+            if (parmTypes.length == 1 &&\n+                parmTypes[0] == ScriptRuntime.ScriptableClass &&\n+                Modifier.isStatic(method.getModifiers()))\n+            {\n+                Object args[] = { scope };\n+                method.invoke(null, args);\n+                return null;\n+            }\n+\n+        }\n+\n+        // If we got here, there isn't an \"init\" method with the right\n+        // parameter types.\n+\n+        Constructor<?>[] ctors = clazz.getConstructors();\n+        Constructor<?> protoCtor = null;\n+        for (int i=0; i < ctors.length; i++) {\n+            if (ctors[i].getParameterTypes().length == 0) {\n+                protoCtor = ctors[i];\n+                break;\n+            }\n+        }\n+        if (protoCtor == null) {\n+            throw Context.reportRuntimeError1(\n+                      \"msg.zero.arg.ctor\", clazz.getName());\n+        }\n+\n+        Scriptable proto = (Scriptable) protoCtor.newInstance(ScriptRuntime.emptyArgs);\n+        String className = proto.getClassName();\n+\n+        // Set the prototype's prototype, trying to map Java inheritance to JS\n+        // prototype-based inheritance if requested to do so.\n+        Scriptable superProto = null;\n+        if (mapInheritance) {\n+            Class<? super T> superClass = clazz.getSuperclass();\n+            if (ScriptRuntime.ScriptableClass.isAssignableFrom(superClass) &&\n+                !Modifier.isAbstract(superClass.getModifiers()))\n+            {\n+                Class<? extends Scriptable> superScriptable =\n+                    extendsScriptable(superClass);\n+                String name = ScriptableObject.defineClass(scope,\n+                        superScriptable, sealed, mapInheritance);\n+                if (name != null) {\n+                    superProto = ScriptableObject.getClassPrototype(scope, name);\n+                }\n+            }\n+        }\n+        if (superProto == null) {\n+            superProto = ScriptableObject.getObjectPrototype(scope);\n+        }\n+        proto.setPrototype(superProto);\n+\n+        // Find out whether there are any methods that begin with\n+        // \"js\". If so, then only methods that begin with special\n+        // prefixes will be defined as JavaScript entities.\n+        final String functionPrefix = \"jsFunction_\";\n+        final String staticFunctionPrefix = \"jsStaticFunction_\";\n+        final String getterPrefix = \"jsGet_\";\n+        final String setterPrefix = \"jsSet_\";\n+        final String ctorName = \"jsConstructor\";\n+\n+        Member ctorMember = findAnnotatedMember(methods, JSConstructor.class);\n+        if (ctorMember == null) {\n+            ctorMember = findAnnotatedMember(ctors, JSConstructor.class);\n+        }\n+        if (ctorMember == null) {\n+            ctorMember = FunctionObject.findSingleMethod(methods, ctorName);\n+        }\n+        if (ctorMember == null) {\n+            if (ctors.length == 1) {\n+                ctorMember = ctors[0];\n+            } else if (ctors.length == 2) {\n+                if (ctors[0].getParameterTypes().length == 0)\n+                    ctorMember = ctors[1];\n+                else if (ctors[1].getParameterTypes().length == 0)\n+                    ctorMember = ctors[0];\n+            }\n+            if (ctorMember == null) {\n+                throw Context.reportRuntimeError1(\n+                          \"msg.ctor.multiple.parms\", clazz.getName());\n+            }\n+        }\n+\n+        FunctionObject ctor = new FunctionObject(className, ctorMember, scope);\n+        if (ctor.isVarArgsMethod()) {\n+            throw Context.reportRuntimeError1\n+                (\"msg.varargs.ctor\", ctorMember.getName());\n+        }\n+        ctor.initAsConstructor(scope, proto);\n+\n+        Method finishInit = null;\n+        HashSet<String> names = new HashSet<String>(methods.length);\n+        for (Method method : methods) {\n+            if (method == ctorMember) {\n+                continue;\n+            }\n+            String name = method.getName();\n+            if (name.equals(\"finishInit\")) {\n+                Class<?>[] parmTypes = method.getParameterTypes();\n+                if (parmTypes.length == 3 &&\n+                    parmTypes[0] == ScriptRuntime.ScriptableClass &&\n+                    parmTypes[1] == FunctionObject.class &&\n+                    parmTypes[2] == ScriptRuntime.ScriptableClass &&\n+                    Modifier.isStatic(method.getModifiers()))\n+                {\n+                    finishInit = method;\n+                    continue;\n+                }\n+            }\n+            // ignore any compiler generated methods.\n+            if (name.indexOf('$') != -1)\n+                continue;\n+            if (name.equals(ctorName))\n+                continue;\n+\n+            Annotation annotation = null;\n+            String prefix = null;\n+            if (method.isAnnotationPresent(JSFunction.class)) {\n+                annotation = method.getAnnotation(JSFunction.class);\n+            } else if (method.isAnnotationPresent(JSStaticFunction.class)) {\n+                annotation = method.getAnnotation(JSStaticFunction.class);\n+            } else if (method.isAnnotationPresent(JSGetter.class)) {\n+                annotation = method.getAnnotation(JSGetter.class);\n+            } else if (method.isAnnotationPresent(JSSetter.class)) {\n+                continue;\n+            }\n+\n+            if (annotation == null) {\n+                if (name.startsWith(functionPrefix)) {\n+                    prefix = functionPrefix;\n+                } else if (name.startsWith(staticFunctionPrefix)) {\n+                    prefix = staticFunctionPrefix;\n+                } else if (name.startsWith(getterPrefix)) {\n+                    prefix = getterPrefix;\n+                } else if (annotation == null) {\n+                    // note that setterPrefix is among the unhandled names here -\n+                    // we deal with that when we see the getter\n+                    continue;\n+                }\n+            }\n+            String propName = getPropertyName(name, prefix, annotation);\n+            if (names.contains(propName)) {\n+                throw Context.reportRuntimeError2(\"duplicate.defineClass.name\",\n+                        name, propName);\n+            }\n+            names.add(propName);\n+            name = propName;\n+            if (annotation instanceof JSGetter || prefix == getterPrefix) {\n+                if (!(proto instanceof ScriptableObject)) {\n+                    throw Context.reportRuntimeError2(\n+                        \"msg.extend.scriptable\",\n+                        proto.getClass().toString(), name);\n+                }\n+                Method setter = findSetterMethod(methods, name, setterPrefix);\n+                int attr = ScriptableObject.PERMANENT |\n+                           ScriptableObject.DONTENUM  |\n+                           (setter != null ? 0\n+                                           : ScriptableObject.READONLY);\n+                ((ScriptableObject) proto).defineProperty(name, null,\n+                                                          method, setter,\n+                                                          attr);\n+                continue;\n+            }\n+\n+            boolean isStatic = annotation instanceof JSStaticFunction\n+                    || prefix == staticFunctionPrefix;\n+            if (isStatic && !Modifier.isStatic(method.getModifiers())) {\n+                throw Context.reportRuntimeError(\n+                        \"jsStaticFunction must be used with static method.\");\n+            }\n+\n+            FunctionObject f = new FunctionObject(name, method, proto);\n+            if (f.isVarArgsConstructor()) {\n+                throw Context.reportRuntimeError1\n+                    (\"msg.varargs.fun\", ctorMember.getName());\n+            }\n+            defineProperty(isStatic ? ctor : proto, name, f, DONTENUM);\n+            if (sealed) {\n+                f.sealObject();\n+            }\n+        }\n+\n+        // Call user code to complete initialization if necessary.\n+        if (finishInit != null) {\n+            Object[] finishArgs = { scope, ctor, proto };\n+            finishInit.invoke(null, finishArgs);\n+        }\n+\n+        // Seal the object if necessary.\n+        if (sealed) {\n+            ctor.sealObject();\n+            if (proto instanceof ScriptableObject) {\n+                ((ScriptableObject) proto).sealObject();\n+            }\n+        }\n+\n+        return ctor;\n+    }\n+\n+    private static Member findAnnotatedMember(AccessibleObject[] members,\n+                                              Class<? extends Annotation> annotation) {\n+        for (AccessibleObject member : members) {\n+            if (member.isAnnotationPresent(annotation)) {\n+                return (Member) member;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static Method findSetterMethod(Method[] methods,\n+                                           String name,\n+                                           String prefix) {\n+        String newStyleName = \"set\"\n+                + Character.toUpperCase(name.charAt(0))\n+                + name.substring(1);\n+        for (Method method : methods) {\n+            JSSetter annotation = method.getAnnotation(JSSetter.class);\n+            if (annotation != null) {\n+                if (name.equals(annotation.value()) ||\n+                        (\"\".equals(annotation.value()) && newStyleName.equals(method.getName()))) {\n+                    return method;\n+                }\n+            }\n+        }\n+        String oldStyleName = prefix + name;\n+        for (Method method : methods) {\n+            if (oldStyleName.equals(method.getName())) {\n+                return method;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static String getPropertyName(String methodName,\n+                                          String prefix,\n+                                          Annotation annotation) {\n+        if (prefix != null) {\n+            return methodName.substring(prefix.length());\n+        }\n+        String propName = null;\n+        if (annotation instanceof JSGetter) {\n+            propName = ((JSGetter) annotation).value();\n+            if (propName == null || propName.length() == 0) {\n+                if (methodName.length() > 3 && methodName.startsWith(\"get\")) {\n+                    propName = methodName.substring(3);\n+                    if (Character.isUpperCase(propName.charAt(0))) {\n+                        if (propName.length() == 1) {\n+                            propName = propName.toLowerCase();\n+                        } else if (!Character.isUpperCase(propName.charAt(1))){\n+                            propName = Character.toLowerCase(propName.charAt(0))\n+                                    + propName.substring(1);\n+                        }\n+                    }\n+                }\n+            }\n+        } else if (annotation instanceof JSFunction) {\n+            propName = ((JSFunction) annotation).value();\n+        } else if (annotation instanceof JSStaticFunction) {\n+            propName = ((JSStaticFunction) annotation).value();\n+        }\n+        if (propName == null || propName.length() == 0) {\n+            propName = methodName;\n+        }\n+        return propName;\n+    }\n+\n+    @SuppressWarnings({\"unchecked\"})\n+    private static <T extends Scriptable> Class<T> extendsScriptable(Class<?> c)\n+    {\n+        if (ScriptRuntime.ScriptableClass.isAssignableFrom(c))\n+            return (Class<T>) c;\n+        return null;\n+    }\n+\n+    /**\n+     * Define a JavaScript property.\n+     *\n+     * Creates the property with an initial value and sets its attributes.\n+     *\n+     * @param propertyName the name of the property to define.\n+     * @param value the initial value of the property\n+     * @param attributes the attributes of the JavaScript property\n+     * @see org.mozilla.javascript.Scriptable#put(String, Scriptable, Object)\n+     */\n+    public void defineProperty(String propertyName, Object value,\n+                               int attributes)\n+    {\n+        checkNotSealed(propertyName, 0);\n+        put(propertyName, this, value);\n+        setAttributes(propertyName, attributes);\n+    }\n+\n+    /**\n+     * Utility method to add properties to arbitrary Scriptable object.\n+     * If destination is instance of ScriptableObject, calls\n+     * defineProperty there, otherwise calls put in destination\n+     * ignoring attributes\n+     */\n+    public static void defineProperty(Scriptable destination,\n+                                      String propertyName, Object value,\n+                                      int attributes)\n+    {\n+        if (!(destination instanceof ScriptableObject)) {\n+            destination.put(propertyName, destination, value);\n+            return;\n+        }\n+        ScriptableObject so = (ScriptableObject)destination;\n+        so.defineProperty(propertyName, value, attributes);\n+    }\n+\n+    /**\n+     * Utility method to add properties to arbitrary Scriptable object.\n+     * If destination is instance of ScriptableObject, calls\n+     * defineProperty there, otherwise calls put in destination\n+     * ignoring attributes\n+     */\n+    public static void defineConstProperty(Scriptable destination,\n+                                           String propertyName)\n+    {\n+        if (destination instanceof ConstProperties) {\n+            ConstProperties cp = (ConstProperties)destination;\n+            cp.defineConst(propertyName, destination);\n+        } else\n+            defineProperty(destination, propertyName, Undefined.instance, CONST);\n+    }\n+\n+    /**\n+     * Define a JavaScript property with getter and setter side effects.\n+     *\n+     * If the setter is not found, the attribute READONLY is added to\n+     * the given attributes. <p>\n+     *\n+     * The getter must be a method with zero parameters, and the setter, if\n+     * found, must be a method with one parameter.<p>\n+     *\n+     * @param propertyName the name of the property to define. This name\n+     *                    also affects the name of the setter and getter\n+     *                    to search for. If the propertyId is \"foo\", then\n+     *                    <code>clazz</code> will be searched for \"getFoo\"\n+     *                    and \"setFoo\" methods.\n+     * @param clazz the Java class to search for the getter and setter\n+     * @param attributes the attributes of the JavaScript property\n+     * @see org.mozilla.javascript.Scriptable#put(String, Scriptable, Object)\n+     */\n+    public void defineProperty(String propertyName, Class<?> clazz,\n+                               int attributes)\n+    {\n+        int length = propertyName.length();\n+        if (length == 0) throw new IllegalArgumentException();\n+        char[] buf = new char[3 + length];\n+        propertyName.getChars(0, length, buf, 3);\n+        buf[3] = Character.toUpperCase(buf[3]);\n+        buf[0] = 'g';\n+        buf[1] = 'e';\n+        buf[2] = 't';\n+        String getterName = new String(buf);\n+        buf[0] = 's';\n+        String setterName = new String(buf);\n+\n+        Method[] methods = FunctionObject.getMethodList(clazz);\n+        Method getter = FunctionObject.findSingleMethod(methods, getterName);\n+        Method setter = FunctionObject.findSingleMethod(methods, setterName);\n+        if (setter == null)\n+            attributes |= ScriptableObject.READONLY;\n+        defineProperty(propertyName, null, getter,\n+                       setter == null ? null : setter, attributes);\n+    }\n+\n+    /**\n+     * Define a JavaScript property.\n+     *\n+     * Use this method only if you wish to define getters and setters for\n+     * a given property in a ScriptableObject. To create a property without\n+     * special getter or setter side effects, use\n+     * <code>defineProperty(String,int)</code>.\n+     *\n+     * If <code>setter</code> is null, the attribute READONLY is added to\n+     * the given attributes.<p>\n+     *\n+     * Several forms of getters or setters are allowed. In all cases the\n+     * type of the value parameter can be any one of the following types:\n+     * Object, String, boolean, Scriptable, byte, short, int, long, float,\n+     * or double. The runtime will perform appropriate conversions based\n+     * upon the type of the parameter (see description in FunctionObject).\n+     * The first forms are nonstatic methods of the class referred to\n+     * by 'this':\n+     * <pre>\n+     * Object getFoo();\n+     * void setFoo(SomeType value);</pre>\n+     * Next are static methods that may be of any class; the object whose\n+     * property is being accessed is passed in as an extra argument:\n+     * <pre>\n+     * static Object getFoo(Scriptable obj);\n+     * static void setFoo(Scriptable obj, SomeType value);</pre>\n+     * Finally, it is possible to delegate to another object entirely using\n+     * the <code>delegateTo</code> parameter. In this case the methods are\n+     * nonstatic methods of the class delegated to, and the object whose\n+     * property is being accessed is passed in as an extra argument:\n+     * <pre>\n+     * Object getFoo(Scriptable obj);\n+     * void setFoo(Scriptable obj, SomeType value);</pre>\n+     *\n+     * @param propertyName the name of the property to define.\n+     * @param delegateTo an object to call the getter and setter methods on,\n+     *                   or null, depending on the form used above.\n+     * @param getter the method to invoke to get the value of the property\n+     * @param setter the method to invoke to set the value of the property\n+     * @param attributes the attributes of the JavaScript property\n+     */\n+    public void defineProperty(String propertyName, Object delegateTo,\n+                               Method getter, Method setter, int attributes)\n+    {\n+        MemberBox getterBox = null;\n+        if (getter != null) {\n+            getterBox = new MemberBox(getter);\n+\n+            boolean delegatedForm;\n+            if (!Modifier.isStatic(getter.getModifiers())) {\n+                delegatedForm = (delegateTo != null);\n+                getterBox.delegateTo = delegateTo;\n+            } else {\n+                delegatedForm = true;\n+                // Ignore delegateTo for static getter but store\n+                // non-null delegateTo indicator.\n+                getterBox.delegateTo = Void.TYPE;\n+            }\n+\n+            String errorId = null;\n+            Class<?>[] parmTypes = getter.getParameterTypes();\n+            if (parmTypes.length == 0) {\n+                if (delegatedForm) {\n+                    errorId = \"msg.obj.getter.parms\";\n+                }\n+            } else if (parmTypes.length == 1) {\n+                Object argType = parmTypes[0];\n+                // Allow ScriptableObject for compatibility\n+                if (!(argType == ScriptRuntime.ScriptableClass ||\n+                      argType == ScriptRuntime.ScriptableObjectClass))\n+                {\n+                    errorId = \"msg.bad.getter.parms\";\n+                } else if (!delegatedForm) {\n+                    errorId = \"msg.bad.getter.parms\";\n+                }\n+            } else {\n+                errorId = \"msg.bad.getter.parms\";\n+            }\n+            if (errorId != null) {\n+                throw Context.reportRuntimeError1(errorId, getter.toString());\n+            }\n+        }\n+\n+        MemberBox setterBox = null;\n+        if (setter != null) {\n+            if (setter.getReturnType() != Void.TYPE)\n+                throw Context.reportRuntimeError1(\"msg.setter.return\",\n+                                                  setter.toString());\n+\n+            setterBox = new MemberBox(setter);\n+\n+            boolean delegatedForm;\n+            if (!Modifier.isStatic(setter.getModifiers())) {\n+                delegatedForm = (delegateTo != null);\n+                setterBox.delegateTo = delegateTo;\n+            } else {\n+                delegatedForm = true;\n+                // Ignore delegateTo for static setter but store\n+                // non-null delegateTo indicator.\n+                setterBox.delegateTo = Void.TYPE;\n+            }\n+\n+            String errorId = null;\n+            Class<?>[] parmTypes = setter.getParameterTypes();\n+            if (parmTypes.length == 1) {\n+                if (delegatedForm) {\n+                    errorId = \"msg.setter2.expected\";\n+                }\n+            } else if (parmTypes.length == 2) {\n+                Object argType = parmTypes[0];\n+                // Allow ScriptableObject for compatibility\n+                if (!(argType == ScriptRuntime.ScriptableClass ||\n+                      argType == ScriptRuntime.ScriptableObjectClass))\n+                {\n+                    errorId = \"msg.setter2.parms\";\n+                } else if (!delegatedForm) {\n+                    errorId = \"msg.setter1.parms\";\n+                }\n+            } else {\n+                errorId = \"msg.setter.parms\";\n+            }\n+            if (errorId != null) {\n+                throw Context.reportRuntimeError1(errorId, setter.toString());\n+            }\n+        }\n+\n+        GetterSlot gslot = (GetterSlot)getSlot(propertyName, 0,\n+                                               SLOT_MODIFY_GETTER_SETTER);\n+        gslot.setAttributes(attributes);\n+        gslot.getter = getterBox;\n+        gslot.setter = setterBox;\n+    }\n+\n+    public void defineOwnProperties(Context cx, ScriptableObject props) {\n+        Object[] ids = props.getIds();\n+        for (Object id : ids) {\n+            String name = ScriptRuntime.toString(id);\n+            Object descObj = props.get(id);\n+            ScriptableObject desc = ensureScriptableObject(descObj);\n+            checkValidPropertyDefinition(getSlot(name, 0, SLOT_QUERY), desc);\n+        }\n+        for (Object id : ids) {\n+            String name = ScriptRuntime.toString(id);\n+            ScriptableObject desc = (ScriptableObject) props.get(id);\n+            defineOwnProperty(cx, name, desc, false);\n+        }\n+    }\n+\n+    /**\n+     * Defines a property on an object\n+     *\n+     * Based on [[DefineOwnProperty]] from 8.12.10 of the spec\n+     *\n+     * @param cx the current Context\n+     * @param id the name/index of the property\n+     * @param desc the new property descriptor, as described in 8.6.1\n+     */\n+    public void defineOwnProperty(Context cx, Object id, ScriptableObject desc) {\n+      defineOwnProperty(cx, id, desc, true);\n+    }\n+\n+    private void defineOwnProperty(Context cx, Object id, ScriptableObject desc, boolean checkValid) {\n+      Slot slot = getSlot(cx, id, SLOT_QUERY);\n+\n+      if (checkValid)\n+        checkValidPropertyDefinition(slot, desc);\n+\n+      final int attributes;\n+      if (slot == null) { // new slot\n+        slot = getSlot(cx, id, SLOT_MODIFY);\n+        attributes = applyDescriptorToAttributeBitset(DONTENUM|READONLY|PERMANENT, desc);\n+      } else {\n+        attributes = applyDescriptorToAttributeBitset(slot.getAttributes(), desc);\n+      }\n+\n+      defineOwnProperty(cx, slot, desc, attributes);\n+    }\n+\n+    private void defineOwnProperty(Context cx, Slot slot, ScriptableObject desc, int attributes) {\n+      if (isAccessorDescriptor(desc)) {\n+        if ( !(slot instanceof GetterSlot) )\n+          slot = getSlot(cx, slot.name, SLOT_MODIFY_GETTER_SETTER);\n+\n+        GetterSlot gslot = (GetterSlot) slot;\n+\n+        Object getter = getProperty(desc, \"get\");\n+        if (getter != NOT_FOUND) {\n+            gslot.getter = getter;\n+        }\n+        Object setter = getProperty(desc, \"set\");\n+        if (setter != NOT_FOUND) {\n+            gslot.setter = setter;\n+        }\n+\n+        gslot.value = Undefined.instance;\n+        gslot.setAttributes(attributes);\n+      } else {\n+        if (slot instanceof GetterSlot && isDataDescriptor(desc)) {\n+            slot = getSlot(cx, slot.name, SLOT_CONVERT_ACCESSOR_TO_DATA);\n+        }\n+\n+        Object value = getProperty(desc, \"value\");\n+        if (value != NOT_FOUND) {\n+            slot.value = value;\n+        }\n+        slot.setAttributes(attributes);\n+      }\n+    }\n+\n+    private void checkValidPropertyDefinition(Slot slot, ScriptableObject desc) {\n+      Object getter = getProperty(desc, \"get\");\n+      if (getter != NOT_FOUND && getter != Undefined.instance && !(getter instanceof Callable)) {\n+        throw ScriptRuntime.notFunctionError(getter);\n+      }\n+      Object setter = getProperty(desc, \"set\");\n+      if (setter != NOT_FOUND && setter != Undefined.instance && !(setter instanceof Callable)) {\n+        throw ScriptRuntime.notFunctionError(setter);\n+      }\n+      if (isDataDescriptor(desc) && isAccessorDescriptor(desc)) {\n+         throw ScriptRuntime.typeError0(\"msg.both.data.and.accessor.desc\");\n+      }\n+\n+      if (slot == null) { // new property\n+        if (!isExtensible()) throw ScriptRuntime.typeError(\"msg.not.extensible\");\n+      } else {\n+        String name = slot.name;\n+        ScriptableObject current = getOwnPropertyDescriptor(Context.getContext(), name);\n+        if (isFalse(current.get(\"configurable\", current))) {\n+          if (isTrue(getProperty(desc, \"configurable\")))\n+            throw ScriptRuntime.typeError1(\"msg.change.configurable.false.to.true\", name);\n+          if (isTrue(current.get(\"enumerable\", current)) != isTrue(getProperty(desc, \"enumerable\")))\n+            throw ScriptRuntime.typeError1(\"msg.change.enumerable.with.configurable.false\", name);\n+\n+          if (isGenericDescriptor(desc)) {\n+            // no further validation required\n+          } else if (isDataDescriptor(desc) && isDataDescriptor(current)) {\n+            if (isFalse(current.get(\"writable\", current))) {\n+              if (isTrue(getProperty(desc, \"writable\")))\n+                throw ScriptRuntime.typeError1(\"msg.change.writable.false.to.true.with.configurable.false\", name);\n+\n+              if (changes(current.get(\"value\", current), getProperty(desc, \"value\")))\n+                throw ScriptRuntime.typeError1(\"msg.change.value.with.writable.false\", name);\n+            }\n+          } else if (isAccessorDescriptor(desc) && isAccessorDescriptor(current)) {\n+              if (changes(current.get(\"set\", current), setter))\n+                throw ScriptRuntime.typeError1(\"msg.change.setter.with.configurable.false\", name);\n+\n+              if (changes(current.get(\"get\", current), getter))\n+                throw ScriptRuntime.typeError1(\"msg.change.getter.with.configurable.false\", name);\n+          } else {\n+            if (isDataDescriptor(current))\n+              throw ScriptRuntime.typeError1(\"msg.change.property.data.to.accessor.with.configurable.false\", name);\n+            else\n+              throw ScriptRuntime.typeError1(\"msg.change.property.accessor.to.data.with.configurable.false\", name);\n+          }\n+        }\n+      }\n+    }\n+\n+    private static boolean isTrue(Object value) {\n+      return (value == NOT_FOUND) ? false : ScriptRuntime.toBoolean(value);\n+    }\n+\n+    private static boolean isFalse(Object value) {\n+      return !isTrue(value);\n+    }\n+\n+    private boolean changes(Object currentValue, Object newValue) {\n+      if (newValue == NOT_FOUND) return false;\n+      if (currentValue == NOT_FOUND) {\n+        currentValue = Undefined.instance;\n+      }\n+      return !ScriptRuntime.shallowEq(currentValue, newValue);\n+    }\n+\n+    protected int applyDescriptorToAttributeBitset(int attributes,\n+                                                 ScriptableObject desc)\n+    {\n+      Object enumerable = getProperty(desc, \"enumerable\");\n+      if (enumerable != NOT_FOUND) {\n+        attributes = ScriptRuntime.toBoolean(enumerable)\n+            ? attributes & ~DONTENUM : attributes | DONTENUM;\n+      }\n+\n+      Object writable = getProperty(desc, \"writable\");\n+      if (writable != NOT_FOUND) {\n+        attributes = ScriptRuntime.toBoolean(writable)\n+            ? attributes & ~READONLY : attributes | READONLY;\n+      }\n+\n+      Object configurable = getProperty(desc, \"configurable\");\n+      if (configurable != NOT_FOUND) {\n+        attributes = ScriptRuntime.toBoolean(configurable)\n+            ? attributes & ~PERMANENT : attributes | PERMANENT;\n+      }\n+\n+      return attributes;\n+    }\n+\n+    protected boolean isDataDescriptor(ScriptableObject desc) {\n+      return hasProperty(desc, \"value\") || hasProperty(desc, \"writable\");\n+    }\n+\n+    protected boolean isAccessorDescriptor(ScriptableObject desc) {\n+      return hasProperty(desc, \"get\") || hasProperty(desc, \"set\");\n+    }\n+\n+    protected boolean isGenericDescriptor(ScriptableObject desc) {\n+      return !isDataDescriptor(desc) && !isAccessorDescriptor(desc);\n+    }\n+\n+    protected Scriptable ensureScriptable(Object arg) {\n+      if ( !(arg instanceof Scriptable) )\n+        throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n+      return (Scriptable) arg;\n+    }\n+\n+    protected ScriptableObject ensureScriptableObject(Object arg) {\n+      if ( !(arg instanceof ScriptableObject) )\n+        throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n+      return (ScriptableObject) arg;\n+    }\n+\n+    /**\n+     * Search for names in a class, adding the resulting methods\n+     * as properties.\n+     *\n+     * <p> Uses reflection to find the methods of the given names. Then\n+     * FunctionObjects are constructed from the methods found, and\n+     * are added to this object as properties with the given names.\n+     *\n+     * @param names the names of the Methods to add as function properties\n+     * @param clazz the class to search for the Methods\n+     * @param attributes the attributes of the new properties\n+     * @see org.mozilla.javascript.FunctionObject\n+     */\n+    public void defineFunctionProperties(String[] names, Class<?> clazz,\n+                                         int attributes)\n+    {\n+        Method[] methods = FunctionObject.getMethodList(clazz);\n+        for (int i=0; i < names.length; i++) {\n+            String name = names[i];\n+            Method m = FunctionObject.findSingleMethod(methods, name);\n+            if (m == null) {\n+                throw Context.reportRuntimeError2(\n+                    \"msg.method.not.found\", name, clazz.getName());\n+            }\n+            FunctionObject f = new FunctionObject(name, m, this);\n+            defineProperty(name, f, attributes);\n+        }\n+    }\n+\n+    /**\n+     * Get the Object.prototype property.\n+     * See ECMA 15.2.4.\n+     */\n+    public static Scriptable getObjectPrototype(Scriptable scope) {\n+        return getClassPrototype(scope, \"Object\");\n+    }\n+\n+    /**\n+     * Get the Function.prototype property.\n+     * See ECMA 15.3.4.\n+     */\n+    public static Scriptable getFunctionPrototype(Scriptable scope) {\n+        return getClassPrototype(scope, \"Function\");\n+    }\n+\n+    /**\n+     * Get the prototype for the named class.\n+     *\n+     * For example, <code>getClassPrototype(s, \"Date\")</code> will first\n+     * walk up the parent chain to find the outermost scope, then will\n+     * search that scope for the Date constructor, and then will\n+     * return Date.prototype. If any of the lookups fail, or\n+     * the prototype is not a JavaScript object, then null will\n+     * be returned.\n+     *\n+     * @param scope an object in the scope chain\n+     * @param className the name of the constructor\n+     * @return the prototype for the named class, or null if it\n+     *         cannot be found.\n+     */\n+    public static Scriptable getClassPrototype(Scriptable scope,\n+                                               String className)\n+    {\n+        scope = getTopLevelScope(scope);\n+        Object ctor = getProperty(scope, className);\n+        Object proto;\n+        if (ctor instanceof BaseFunction) {\n+            proto = ((BaseFunction)ctor).getPrototypeProperty();\n+        } else if (ctor instanceof Scriptable) {\n+            Scriptable ctorObj = (Scriptable)ctor;\n+            proto = ctorObj.get(\"prototype\", ctorObj);\n+        } else {\n+            return null;\n+        }\n+        if (proto instanceof Scriptable) {\n+            return (Scriptable)proto;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the global scope.\n+     *\n+     * <p>Walks the parent scope chain to find an object with a null\n+     * parent scope (the global object).\n+     *\n+     * @param obj a JavaScript object\n+     * @return the corresponding global scope\n+     */\n+    public static Scriptable getTopLevelScope(Scriptable obj)\n+    {\n+        for (;;) {\n+            Scriptable parent = obj.getParentScope();\n+            if (parent == null) {\n+                return obj;\n+            }\n+            obj = parent;\n+        }\n+    }\n+\n+    public boolean isExtensible() {\n+      return isExtensible;\n+    }\n+\n+    public void preventExtensions() {\n+      isExtensible = false;\n+    }\n+\n+    /**\n+     * Seal this object.\n+     *\n+     * It is an error to add properties to or delete properties from\n+     * a sealed object. It is possible to change the value of an\n+     * existing property. Once an object is sealed it may not be unsealed.\n+     *\n+     * @since 1.4R3\n+     */\n+    public synchronized void sealObject() {\n+        if (count >= 0) {\n+            // Make sure all LazilyLoadedCtors are initialized before sealing.\n+            Slot slot = firstAdded;\n+            while (slot != null) {\n+                if (slot.value instanceof LazilyLoadedCtor) {\n+                    LazilyLoadedCtor initializer = (LazilyLoadedCtor) slot.value;\n+                    try {\n+                        initializer.init();\n+                    } finally {\n+                        slot.value = initializer.getValue();\n+                    }\n+                }\n+                slot = slot.orderedNext;\n+            }\n+            count = ~count;\n+        }\n+    }\n+\n+    /**\n+     * Return true if this object is sealed.\n+     *\n+     * @return true if sealed, false otherwise.\n+     * @since 1.4R3\n+     * @see #sealObject()\n+     */\n+    public final boolean isSealed() {\n+        return count < 0;\n+    }\n+\n+    private void checkNotSealed(String name, int index)\n+    {\n+        if (!isSealed())\n+            return;\n+\n+        String str = (name != null) ? name : Integer.toString(index);\n+        throw Context.reportRuntimeError1(\"msg.modify.sealed\", str);\n+    }\n+\n+    /**\n+     * Gets a named property from an object or any object in its prototype chain.\n+     * <p>\n+     * Searches the prototype chain for a property named <code>name</code>.\n+     * <p>\n+     * @param obj a JavaScript object\n+     * @param name a property name\n+     * @return the value of a property with name <code>name</code> found in\n+     *         <code>obj</code> or any object in its prototype chain, or\n+     *         <code>Scriptable.NOT_FOUND</code> if not found\n+     * @since 1.5R2\n+     */\n+    public static Object getProperty(Scriptable obj, String name)\n+    {\n+        Scriptable start = obj;\n+        Object result;\n+        do {\n+            result = obj.get(name, start);\n+            if (result != Scriptable.NOT_FOUND)\n+                break;\n+            obj = obj.getPrototype();\n+        } while (obj != null);\n+        return result;\n+    }\n+\n+    /**\n+     * Gets an indexed property from an object or any object in its prototype chain.\n+     * <p>\n+     * Searches the prototype chain for a property with integral index\n+     * <code>index</code>. Note that if you wish to look for properties with numerical\n+     * but non-integral indicies, you should use getProperty(Scriptable,String) with\n+     * the string value of the index.\n+     * <p>\n+     * @param obj a JavaScript object\n+     * @param index an integral index\n+     * @return the value of a property with index <code>index</code> found in\n+     *         <code>obj</code> or any object in its prototype chain, or\n+     *         <code>Scriptable.NOT_FOUND</code> if not found\n+     * @since 1.5R2\n+     */\n+    public static Object getProperty(Scriptable obj, int index)\n+    {\n+        Scriptable start = obj;\n+        Object result;\n+        do {\n+            result = obj.get(index, start);\n+            if (result != Scriptable.NOT_FOUND)\n+                break;\n+            obj = obj.getPrototype();\n+        } while (obj != null);\n+        return result;\n+    }\n+\n+    /**\n+     * Returns whether a named property is defined in an object or any object\n+     * in its prototype chain.\n+     * <p>\n+     * Searches the prototype chain for a property named <code>name</code>.\n+     * <p>\n+     * @param obj a JavaScript object\n+     * @param name a property name\n+     * @return the true if property was found\n+     * @since 1.5R2\n+     */\n+    public static boolean hasProperty(Scriptable obj, String name)\n+    {\n+        return null != getBase(obj, name);\n+    }\n+\n+    /**\n+     * If hasProperty(obj, name) would return true, then if the property that\n+     * was found is compatible with the new property, this method just returns.\n+     * If the property is not compatible, then an exception is thrown.\n+     *\n+     * A property redefinition is incompatible if the first definition was a\n+     * const declaration or if this one is.  They are compatible only if neither\n+     * was const.\n+     */\n+    public static void redefineProperty(Scriptable obj, String name,\n+                                        boolean isConst)\n+    {\n+        Scriptable base = getBase(obj, name);\n+        if (base == null)\n+            return;\n+        if (base instanceof ConstProperties) {\n+            ConstProperties cp = (ConstProperties)base;\n+\n+            if (cp.isConst(name))\n+                throw Context.reportRuntimeError1(\"msg.const.redecl\", name);\n+        }\n+        if (isConst)\n+            throw Context.reportRuntimeError1(\"msg.var.redecl\", name);\n+    }\n+    /**\n+     * Returns whether an indexed property is defined in an object or any object\n+     * in its prototype chain.\n+     * <p>\n+     * Searches the prototype chain for a property with index <code>index</code>.\n+     * <p>\n+     * @param obj a JavaScript object\n+     * @param index a property index\n+     * @return the true if property was found\n+     * @since 1.5R2\n+     */\n+    public static boolean hasProperty(Scriptable obj, int index)\n+    {\n+        return null != getBase(obj, index);\n+    }\n+\n+    /**\n+     * Puts a named property in an object or in an object in its prototype chain.\n+     * <p>\n+     * Searches for the named property in the prototype chain. If it is found,\n+     * the value of the property in <code>obj</code> is changed through a call\n+     * to {@link Scriptable#put(String, Scriptable, Object)} on the\n+     * prototype passing <code>obj</code> as the <code>start</code> argument.\n+     * This allows the prototype to veto the property setting in case the\n+     * prototype defines the property with [[ReadOnly]] attribute. If the\n+     * property is not found, it is added in <code>obj</code>.\n+     * @param obj a JavaScript object\n+     * @param name a property name\n+     * @param value any JavaScript value accepted by Scriptable.put\n+     * @since 1.5R2\n+     */\n+    public static void putProperty(Scriptable obj, String name, Object value)\n+    {\n+        Scriptable base = getBase(obj, name);\n+        if (base == null)\n+            base = obj;\n+        base.put(name, obj, value);\n+    }\n+\n+    /**\n+     * Puts a named property in an object or in an object in its prototype chain.\n+     * <p>\n+     * Searches for the named property in the prototype chain. If it is found,\n+     * the value of the property in <code>obj</code> is changed through a call\n+     * to {@link Scriptable#put(String, Scriptable, Object)} on the\n+     * prototype passing <code>obj</code> as the <code>start</code> argument.\n+     * This allows the prototype to veto the property setting in case the\n+     * prototype defines the property with [[ReadOnly]] attribute. If the\n+     * property is not found, it is added in <code>obj</code>.\n+     * @param obj a JavaScript object\n+     * @param name a property name\n+     * @param value any JavaScript value accepted by Scriptable.put\n+     * @since 1.5R2\n+     */\n+    public static void putConstProperty(Scriptable obj, String name, Object value)\n+    {\n+        Scriptable base = getBase(obj, name);\n+        if (base == null)\n+            base = obj;\n+        if (base instanceof ConstProperties)\n+            ((ConstProperties)base).putConst(name, obj, value);\n+    }\n+\n+    /**\n+     * Puts an indexed property in an object or in an object in its prototype chain.\n+     * <p>\n+     * Searches for the indexed property in the prototype chain. If it is found,\n+     * the value of the property in <code>obj</code> is changed through a call\n+     * to {@link Scriptable#put(int, Scriptable, Object)} on the prototype\n+     * passing <code>obj</code> as the <code>start</code> argument. This allows\n+     * the prototype to veto the property setting in case the prototype defines\n+     * the property with [[ReadOnly]] attribute. If the property is not found,\n+     * it is added in <code>obj</code>.\n+     * @param obj a JavaScript object\n+     * @param index a property index\n+     * @param value any JavaScript value accepted by Scriptable.put\n+     * @since 1.5R2\n+     */\n+    public static void putProperty(Scriptable obj, int index, Object value)\n+    {\n+        Scriptable base = getBase(obj, index);\n+        if (base == null)\n+            base = obj;\n+        base.put(index, obj, value);\n+    }\n+\n+    /**\n+     * Removes the property from an object or its prototype chain.\n+     * <p>\n+     * Searches for a property with <code>name</code> in obj or\n+     * its prototype chain. If it is found, the object's delete\n+     * method is called.\n+     * @param obj a JavaScript object\n+     * @param name a property name\n+     * @return true if the property doesn't exist or was successfully removed\n+     * @since 1.5R2\n+     */\n+    public static boolean deleteProperty(Scriptable obj, String name)\n+    {\n+        Scriptable base = getBase(obj, name);\n+        if (base == null)\n+            return true;\n+        base.delete(name);\n+        return !base.has(name, obj);\n+    }\n+\n+    /**\n+     * Removes the property from an object or its prototype chain.\n+     * <p>\n+     * Searches for a property with <code>index</code> in obj or\n+     * its prototype chain. If it is found, the object's delete\n+     * method is called.\n+     * @param obj a JavaScript object\n+     * @param index a property index\n+     * @return true if the property doesn't exist or was successfully removed\n+     * @since 1.5R2\n+     */\n+    public static boolean deleteProperty(Scriptable obj, int index)\n+    {\n+        Scriptable base = getBase(obj, index);\n+        if (base == null)\n+            return true;\n+        base.delete(index);\n+        return !base.has(index, obj);\n+    }\n+\n+    /**\n+     * Returns an array of all ids from an object and its prototypes.\n+     * <p>\n+     * @param obj a JavaScript object\n+     * @return an array of all ids from all object in the prototype chain.\n+     *         If a given id occurs multiple times in the prototype chain,\n+     *         it will occur only once in this list.\n+     * @since 1.5R2\n+     */\n+    public static Object[] getPropertyIds(Scriptable obj)\n+    {\n+        if (obj == null) {\n+            return ScriptRuntime.emptyArgs;\n+        }\n+        Object[] result = obj.getIds();\n+        ObjToIntMap map = null;\n+        for (;;) {\n+            obj = obj.getPrototype();\n+            if (obj == null) {\n+                break;\n+            }\n+            Object[] ids = obj.getIds();\n+            if (ids.length == 0) {\n+                continue;\n+            }\n+            if (map == null) {\n+                if (result.length == 0) {\n+                    result = ids;\n+                    continue;\n+                }\n+                map = new ObjToIntMap(result.length + ids.length);\n+                for (int i = 0; i != result.length; ++i) {\n+                    map.intern(result[i]);\n+                }\n+                result = null; // Allow to GC the result\n+            }\n+            for (int i = 0; i != ids.length; ++i) {\n+                map.intern(ids[i]);\n+            }\n+        }\n+        if (map != null) {\n+            result = map.getKeys();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Call a method of an object.\n+     * @param obj the JavaScript object\n+     * @param methodName the name of the function property\n+     * @param args the arguments for the call\n+     *\n+     * @see Context#getCurrentContext()\n+     */\n+    public static Object callMethod(Scriptable obj, String methodName,\n+                                    Object[] args)\n+    {\n+        return callMethod(null, obj, methodName, args);\n+    }\n+\n+    /**\n+     * Call a method of an object.\n+     * @param cx the Context object associated with the current thread.\n+     * @param obj the JavaScript object\n+     * @param methodName the name of the function property\n+     * @param args the arguments for the call\n+     */\n+    public static Object callMethod(Context cx, Scriptable obj,\n+                                    String methodName,\n+                                    Object[] args)\n+    {\n+        Object funObj = getProperty(obj, methodName);\n+        if (!(funObj instanceof Function)) {\n+            throw ScriptRuntime.notFunctionError(obj, methodName);\n+        }\n+        Function fun = (Function)funObj;\n+        // XXX: What should be the scope when calling funObj?\n+        // The following favor scope stored in the object on the assumption\n+        // that is more useful especially under dynamic scope setup.\n+        // An alternative is to check for dynamic scope flag\n+        // and use ScriptableObject.getTopLevelScope(fun) if the flag is not\n+        // set. But that require access to Context and messy code\n+        // so for now it is not checked.\n+        Scriptable scope = ScriptableObject.getTopLevelScope(obj);\n+        if (cx != null) {\n+            return fun.call(cx, scope, obj, args);\n+        } else {\n+            return Context.call(null, fun, scope, obj, args);\n+        }\n+    }\n+\n+    private static Scriptable getBase(Scriptable obj, String name)\n+    {\n+        do {\n+            if (obj.has(name, obj))\n+                break;\n+            obj = obj.getPrototype();\n+        } while(obj != null);\n+        return obj;\n+    }\n+\n+    private static Scriptable getBase(Scriptable obj, int index)\n+    {\n+        do {\n+            if (obj.has(index, obj))\n+                break;\n+            obj = obj.getPrototype();\n+        } while(obj != null);\n+        return obj;\n+    }\n+\n+    /**\n+     * Get arbitrary application-specific value associated with this object.\n+     * @param key key object to select particular value.\n+     * @see #associateValue(Object key, Object value)\n+     */\n+    public final Object getAssociatedValue(Object key)\n+    {\n+        Map<Object,Object> h = associatedValues;\n+        if (h == null)\n+            return null;\n+        return h.get(key);\n+    }\n+\n+    /**\n+     * Get arbitrary application-specific value associated with the top scope\n+     * of the given scope.\n+     * The method first calls {@link #getTopLevelScope(Scriptable scope)}\n+     * and then searches the prototype chain of the top scope for the first\n+     * object containing the associated value with the given key.\n+     *\n+     * @param scope the starting scope.\n+     * @param key key object to select particular value.\n+     * @see #getAssociatedValue(Object key)\n+     */\n+    public static Object getTopScopeValue(Scriptable scope, Object key)\n+    {\n+        scope = ScriptableObject.getTopLevelScope(scope);\n+        for (;;) {\n+            if (scope instanceof ScriptableObject) {\n+                ScriptableObject so = (ScriptableObject)scope;\n+                Object value = so.getAssociatedValue(key);\n+                if (value != null) {\n+                    return value;\n+                }\n+            }\n+            scope = scope.getPrototype();\n+            if (scope == null) {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Associate arbitrary application-specific value with this object.\n+     * Value can only be associated with the given object and key only once.\n+     * The method ignores any subsequent attempts to change the already\n+     * associated value.\n+     * <p> The associated values are not serialized.\n+     * @param key key object to select particular value.\n+     * @param value the value to associate\n+     * @return the passed value if the method is called first time for the\n+     * given key or old value for any subsequent calls.\n+     * @see #getAssociatedValue(Object key)\n+     */\n+    public synchronized final Object associateValue(Object key, Object value)\n+    {\n+        if (value == null) throw new IllegalArgumentException();\n+        Map<Object,Object> h = associatedValues;\n+        if (h == null) {\n+            h = new HashMap<Object,Object>();\n+            associatedValues = h;\n+        }\n+        return Kit.initHash(h, key, value);\n+    }\n+\n+    private Object getImpl(String name, int index, Scriptable start)\n+    {\n+        Slot slot = getSlot(name, index, SLOT_QUERY);\n+        if (slot == null) {\n+            return Scriptable.NOT_FOUND;\n+        }\n+        if (!(slot instanceof GetterSlot)) {\n+            return slot.value;\n+        }\n+        Object getterObj = ((GetterSlot)slot).getter;\n+        if (getterObj != null) {\n+            if (getterObj instanceof MemberBox) {\n+                MemberBox nativeGetter = (MemberBox)getterObj;\n+                Object getterThis;\n+                Object[] args;\n+                if (nativeGetter.delegateTo == null) {\n+                    getterThis = start;\n+                    args = ScriptRuntime.emptyArgs;\n+                } else {\n+                    getterThis = nativeGetter.delegateTo;\n+                    args = new Object[] { start };\n+                }\n+                return nativeGetter.invoke(getterThis, args);\n+            } else {\n+                Function f = (Function)getterObj;\n+                Context cx = Context.getContext();\n+                return f.call(cx, f.getParentScope(), start,\n+                              ScriptRuntime.emptyArgs);\n+            }\n+        }\n+        Object value = slot.value;\n+        if (value instanceof LazilyLoadedCtor) {\n+            LazilyLoadedCtor initializer = (LazilyLoadedCtor)value;\n+            try {\n+                initializer.init();\n+            } finally {\n+                value = initializer.getValue();\n+                slot.value = value;\n+            }\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     *\n+     * @param name\n+     * @param index\n+     * @param start\n+     * @param value\n+     * @param constFlag EMPTY means normal put.  UNINITIALIZED_CONST means\n+     * defineConstProperty.  READONLY means const initialization expression.\n+     * @return false if this != start and no slot was found.  true if this == start\n+     * or this != start and a READONLY slot was found.\n+     */\n+    private boolean putImpl(String name, int index, Scriptable start,\n+                            Object value, int constFlag)\n+    {\n+        Slot slot;\n+        if (this != start) {\n+            slot = getSlot(name, index, SLOT_QUERY);\n+            if (slot == null) {\n+                return false;\n+            }\n+        } else if (!isExtensible()) {\n+            slot = getSlot(name, index, SLOT_QUERY);\n+            if (slot == null) {\n+                return true;\n+            }\n+        } else {\n+            checkNotSealed(name, index);\n+            // either const hoisted declaration or initialization\n+            if (constFlag != EMPTY) {\n+                slot = getSlot(name, index, SLOT_MODIFY_CONST);\n+                int attr = slot.getAttributes();\n+                if ((attr & READONLY) == 0)\n+                    throw Context.reportRuntimeError1(\"msg.var.redecl\", name);\n+                if ((attr & UNINITIALIZED_CONST) != 0) {\n+                    slot.value = value;\n+                    // clear the bit on const initialization\n+                    if (constFlag != UNINITIALIZED_CONST)\n+                        slot.setAttributes(attr & ~UNINITIALIZED_CONST);\n+                }\n+                return true;\n+            }\n+            slot = getSlot(name, index, SLOT_MODIFY);\n+        }\n+        if (slot instanceof GetterSlot) {\n+            Object setterObj = ((GetterSlot)slot).setter;\n+            if (setterObj == null) {\n+                if (((GetterSlot)slot).getter != null) {\n+                  // Based on TC39 ES3.1 Draft of 9-Feb-2009, 8.12.4, step 2,\n+                  // we should throw a TypeError in this case.\n+                  throw ScriptRuntime.typeError1(\"msg.set.prop.no.setter\", name);\n+                }\n+            } else {\n+                Context cx = Context.getContext();\n+                if (setterObj instanceof MemberBox) {\n+                    MemberBox nativeSetter = (MemberBox)setterObj;\n+                    Class<?> pTypes[] = nativeSetter.argTypes;\n+                    // XXX: cache tag since it is already calculated in\n+                    // defineProperty ?\n+                    Class<?> valueType = pTypes[pTypes.length - 1];\n+                    int tag = FunctionObject.getTypeTag(valueType);\n+                    Object actualArg = FunctionObject.convertArg(cx, start,\n+                                                                 value, tag);\n+                    Object setterThis;\n+                    Object[] args;\n+                    if (nativeSetter.delegateTo == null) {\n+                        setterThis = start;\n+                        args = new Object[] { actualArg };\n+                    } else {\n+                        setterThis = nativeSetter.delegateTo;\n+                        args = new Object[] { start, actualArg };\n+                    }\n+                    nativeSetter.invoke(setterThis, args);\n+                } else {\n+                    Function f = (Function)setterObj;\n+                    f.call(cx, f.getParentScope(), start,\n+                           new Object[] { value });\n+                }\n+                return true;\n+            }\n+        } else if ((slot.getAttributes() & READONLY) != 0) {\n+            return true;\n+        }\n+        if (this == start) {\n+            slot.value = value;\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private Slot findAttributeSlot(String name, int index, int accessType)\n+    {\n+        Slot slot = getSlot(name, index, accessType);\n+        if (slot == null) {\n+            String str = (name != null ? name : Integer.toString(index));\n+            throw Context.reportRuntimeError1(\"msg.prop.not.found\", str);\n+        }\n+        return slot;\n+    }\n+\n+    /**\n+     * Locate the slot with given name or index.\n+     *\n+     * @param name property name or null if slot holds spare array index.\n+     * @param index index or 0 if slot holds property name.\n+     */\n+    private Slot getSlot(String name, int index, int accessType)\n+    {\n+        Slot slot;\n+\n+        // Query last access cache and check that it was not deleted.\n+      lastAccessCheck:\n+        {\n+            slot = lastAccess;\n+            if (name != null) {\n+                if (name != slot.name)\n+                    break lastAccessCheck;\n+                // No String.equals here as successful slot search update\n+                // name object with fresh reference of the same string.\n+            } else {\n+                if (slot.name != null || index != slot.indexOrHash)\n+                    break lastAccessCheck;\n+            }\n+\n+            if (slot.wasDeleted)\n+                break lastAccessCheck;\n+\n+            if (accessType == SLOT_MODIFY_GETTER_SETTER &&\n+                !(slot instanceof GetterSlot))\n+                break lastAccessCheck;\n+\n+            if (accessType == SLOT_CONVERT_ACCESSOR_TO_DATA &&\n+                (slot instanceof GetterSlot))\n+                break lastAccessCheck;\n+\n+            return slot;\n+        }\n+\n+        slot = accessSlot(name, index, accessType);\n+        if (slot != null) {\n+            // Update the cache\n+            lastAccess = slot;\n+        }\n+        return slot;\n+    }\n+\n+    private Slot accessSlot(String name, int index, int accessType)\n+    {\n+        int indexOrHash = (name != null ? name.hashCode() : index);\n+\n+        if (accessType == SLOT_QUERY ||\n+            accessType == SLOT_MODIFY ||\n+            accessType == SLOT_MODIFY_CONST ||\n+            accessType == SLOT_MODIFY_GETTER_SETTER ||\n+            accessType == SLOT_CONVERT_ACCESSOR_TO_DATA)\n+        {\n+            // Check the hashtable without using synchronization\n+\n+            Slot[] slotsLocalRef = slots; // Get stable local reference\n+            if (slotsLocalRef == null) {\n+                if (accessType == SLOT_QUERY)\n+                    return null;\n+            } else {\n+                int tableSize = slotsLocalRef.length;\n+                int slotIndex = getSlotIndex(tableSize, indexOrHash);\n+                Slot slot = slotsLocalRef[slotIndex];\n+                while (slot != null) {\n+                    String sname = slot.name;\n+                    if (sname != null) {\n+                        if (sname == name)\n+                            break;\n+                        if (name != null && indexOrHash == slot.indexOrHash) {\n+                            if (name.equals(sname)) {\n+                                // This will avoid calling String.equals when\n+                                // slot is accessed with same string object\n+                                // next time.\n+                                slot.name = name;\n+                                break;\n+                            }\n+                        }\n+                    } else if (name == null &&\n+                               indexOrHash == slot.indexOrHash) {\n+                        break;\n+                    }\n+                    slot = slot.next;\n+                }\n+                if (accessType == SLOT_QUERY) {\n+                    return slot;\n+                } else if (accessType == SLOT_MODIFY) {\n+                    if (slot != null)\n+                        return slot;\n+                } else if (accessType == SLOT_MODIFY_GETTER_SETTER) {\n+                    if (slot instanceof GetterSlot)\n+                        return slot;\n+                } else if (accessType == SLOT_MODIFY_CONST) {\n+                    if (slot != null)\n+                        return slot;\n+                } else if (accessType == SLOT_CONVERT_ACCESSOR_TO_DATA) {\n+                    if ( !(slot instanceof GetterSlot) )\n+                        return slot;\n+                }\n+            }\n+\n+            // A new slot has to be inserted or the old has to be replaced\n+            // by GetterSlot. Time to synchronize.\n+\n+            synchronized (this) {\n+                // Refresh local ref if another thread triggered grow\n+                slotsLocalRef = slots;\n+                int insertPos;\n+                if (count == 0) {\n+                    // Always throw away old slots if any on empty insert\n+                    slotsLocalRef = new Slot[5];\n+                    slots = slotsLocalRef;\n+                    insertPos = getSlotIndex(slotsLocalRef.length, indexOrHash);\n+                } else {\n+                    int tableSize = slotsLocalRef.length;\n+                    insertPos = getSlotIndex(tableSize, indexOrHash);\n+                    Slot prev = slotsLocalRef[insertPos];\n+                    Slot slot = prev;\n+                    while (slot != null) {\n+                        if (slot.indexOrHash == indexOrHash &&\n+                            (slot.name == name ||\n+                             (name != null && name.equals(slot.name))))\n+                        {\n+                            break;\n+                        }\n+                        prev = slot;\n+                        slot = slot.next;\n+                    }\n+\n+                    if (slot != null) {\n+                        // Another thread just added a slot with same\n+                        // name/index before this one entered synchronized\n+                        // block. This is a race in application code and\n+                        // probably indicates bug there. But for the hashtable\n+                        // implementation it is harmless with the only\n+                        // complication is the need to replace the added slot\n+                        // if we need GetterSlot and the old one is not.\n+\n+                        Slot newSlot;\n+\n+                        if (accessType == SLOT_MODIFY_GETTER_SETTER && !(slot instanceof GetterSlot)) {\n+                            newSlot = new GetterSlot(name, indexOrHash, slot.getAttributes());\n+                        } else if (accessType == SLOT_CONVERT_ACCESSOR_TO_DATA && (slot instanceof GetterSlot)) {\n+                            newSlot = new Slot(name, indexOrHash, slot.getAttributes());\n+                        } else if (accessType == SLOT_MODIFY_CONST) {\n+                          return null;\n+                        } else {\n+                          return slot;\n+                        }\n+\n+                        newSlot.value = slot.value;\n+                        newSlot.next = slot.next;\n+                        // add new slot to linked list\n+                        if (lastAdded != null)\n+                            lastAdded.orderedNext = newSlot;\n+                        if (firstAdded == null)\n+                            firstAdded = newSlot;\n+                        lastAdded = newSlot;\n+                        // add new slot to hash table\n+                        if (prev == slot) {\n+                            slotsLocalRef[insertPos] = newSlot;\n+                        } else {\n+                            prev.next = newSlot;\n+                        }\n+                        // other housekeeping\n+                        slot.wasDeleted = true;\n+                        slot.value = null;\n+                        slot.name = null;\n+                        if (slot == lastAccess) {\n+                            lastAccess = REMOVED;\n+                        }\n+                        return newSlot;\n+                    } else {\n+                      // Check if the table is not too full before inserting.\n+                      if (4 * (count + 1) > 3 * slotsLocalRef.length) {\n+                          slotsLocalRef = new Slot[slotsLocalRef.length * 2 + 1];\n+                          copyTable(slots, slotsLocalRef, count);\n+                          slots = slotsLocalRef;\n+                          insertPos = getSlotIndex(slotsLocalRef.length,\n+                                  indexOrHash);\n+                      }\n+                    }\n+                }\n+                Slot newSlot = (accessType == SLOT_MODIFY_GETTER_SETTER\n+                                ? new GetterSlot(name, indexOrHash, 0)\n+                                : new Slot(name, indexOrHash, 0));\n+                if (accessType == SLOT_MODIFY_CONST)\n+                    newSlot.setAttributes(CONST);\n+                ++count;\n+                // add new slot to linked list\n+                if (lastAdded != null)\n+                    lastAdded.orderedNext = newSlot;\n+                if (firstAdded == null)\n+                    firstAdded = newSlot;\n+                lastAdded = newSlot;\n+                // add new slot to hash table, return it\n+                addKnownAbsentSlot(slotsLocalRef, newSlot, insertPos);\n+                return newSlot;\n+            }\n+\n+        } else if (accessType == SLOT_REMOVE) {\n+            synchronized (this) {\n+                Slot[] slotsLocalRef = slots;\n+                if (count != 0) {\n+                    int tableSize = slots.length;\n+                    int slotIndex = getSlotIndex(tableSize, indexOrHash);\n+                    Slot prev = slotsLocalRef[slotIndex];\n+                    Slot slot = prev;\n+                    while (slot != null) {\n+                        if (slot.indexOrHash == indexOrHash &&\n+                            (slot.name == name ||\n+                             (name != null && name.equals(slot.name))))\n+                        {\n+                            break;\n+                        }\n+                        prev = slot;\n+                        slot = slot.next;\n+                    }\n+                    if (slot != null && (slot.getAttributes() & PERMANENT) == 0) {\n+                        count--;\n+                        // remove slot from hash table\n+                        if (prev == slot) {\n+                            slotsLocalRef[slotIndex] = slot.next;\n+                        } else {\n+                            prev.next = slot.next;\n+                        }\n+                        // Mark the slot as removed. It is still referenced\n+                        // from the order-added linked list, but will be\n+                        // cleaned up later\n+                        slot.wasDeleted = true;\n+                        slot.value = null;\n+                        slot.name = null;\n+                        if (slot == lastAccess) {\n+                            lastAccess = REMOVED;\n+                        }\n+                    }\n+                }\n+            }\n+            return null;\n+\n+        } else {\n+            throw Kit.codeBug();\n+        }\n+    }\n+\n+    private static int getSlotIndex(int tableSize, int indexOrHash)\n+    {\n+        return (indexOrHash & 0x7fffffff) % tableSize;\n+    }\n+\n+    // Must be inside synchronized (this)\n+    private static void copyTable(Slot[] slots, Slot[] newSlots, int count)\n+    {\n+        if (count == 0) throw Kit.codeBug();\n+\n+        int tableSize = newSlots.length;\n+        int i = slots.length;\n+        for (;;) {\n+            --i;\n+            Slot slot = slots[i];\n+            while (slot != null) {\n+                int insertPos = getSlotIndex(tableSize, slot.indexOrHash);\n+                Slot next = slot.next;\n+                addKnownAbsentSlot(newSlots, slot, insertPos);\n+                slot.next = null;\n+                slot = next;\n+                if (--count == 0)\n+                    return;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add slot with keys that are known to absent from the table.\n+     * This is an optimization to use when inserting into empty table,\n+     * after table growth or during deserialization.\n+     */\n+    private static void addKnownAbsentSlot(Slot[] slots, Slot slot,\n+                                           int insertPos)\n+    {\n+        if (slots[insertPos] == null) {\n+            slots[insertPos] = slot;\n+        } else {\n+            Slot prev = slots[insertPos];\n+            while (prev.next != null) {\n+                prev = prev.next;\n+            }\n+            prev.next = slot;\n+        }\n+    }\n+\n+    Object[] getIds(boolean getAll) {\n+        Slot[] s = slots;\n+        Object[] a = ScriptRuntime.emptyArgs;\n+        if (s == null)\n+            return a;\n+        int c = 0;\n+        Slot slot = firstAdded;\n+        while (slot != null && slot.wasDeleted) {\n+            // as long as we're traversing the order-added linked list,\n+            // remove deleted slots\n+            slot = slot.orderedNext;\n+        }\n+        firstAdded = slot;\n+        if (slot != null) {\n+            for (;;) {\n+                if (getAll || (slot.getAttributes() & DONTENUM) == 0) {\n+                    if (c == 0)\n+                        a = new Object[s.length];\n+                    a[c++] = slot.name != null\n+                                 ? (Object) slot.name\n+                                 : Integer.valueOf(slot.indexOrHash);\n+                }\n+                Slot next = slot.orderedNext;\n+                while (next != null && next.wasDeleted) {\n+                    // remove deleted slots\n+                    next = next.orderedNext;\n+                }\n+                slot.orderedNext = next;\n+                if (next == null) {\n+                    break;\n+                }\n+                slot = next;\n+            }\n+        }\n+        lastAdded = slot;\n+        if (c == a.length)\n+            return a;\n+        Object[] result = new Object[c];\n+        System.arraycopy(a, 0, result, 0, c);\n+        return result;\n+    }\n+\n+    private synchronized void writeObject(ObjectOutputStream out)\n+        throws IOException\n+    {\n+        out.defaultWriteObject();\n+        int objectsCount = count;\n+        if (objectsCount < 0) {\n+            // \"this\" was sealed\n+            objectsCount = ~objectsCount;\n+        }\n+        if (objectsCount == 0) {\n+            out.writeInt(0);\n+        } else {\n+            out.writeInt(slots.length);\n+            Slot slot = firstAdded;\n+            while (slot != null && slot.wasDeleted) {\n+                // as long as we're traversing the order-added linked list,\n+                // remove deleted slots\n+                slot = slot.orderedNext;\n+            }\n+            firstAdded = slot;\n+            while (slot != null) {\n+                out.writeObject(slot);\n+                Slot next = slot.orderedNext;\n+                while (next != null && next.wasDeleted) {\n+                    // remove deleted slots\n+                    next = next.orderedNext;\n+                }\n+                slot.orderedNext = next;\n+                slot = next;\n+            }\n+        }\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException\n+    {\n+        in.defaultReadObject();\n+        lastAccess = REMOVED;\n+\n+        int tableSize = in.readInt();\n+        if (tableSize != 0) {\n+            slots = new Slot[tableSize];\n+            int objectsCount = count;\n+            if (objectsCount < 0) {\n+                // \"this\" was sealed\n+                objectsCount = ~objectsCount;\n+            }\n+            Slot prev = null;\n+            for (int i=0; i != objectsCount; ++i) {\n+                lastAdded = (Slot)in.readObject();\n+                if (i==0) {\n+                    firstAdded = lastAdded;\n+                } else {\n+                    prev.orderedNext = lastAdded;\n+                }\n+                int slotIndex = getSlotIndex(tableSize, lastAdded.indexOrHash);\n+                addKnownAbsentSlot(slots, lastAdded, slotIndex);\n+                prev = lastAdded;\n+            }\n+        }\n+    }\n+\n+    protected ScriptableObject getOwnPropertyDescriptor(Context cx, Object id) {\n+      Slot slot = getSlot(cx, id, SLOT_QUERY);\n+      if (slot == null) return null;\n+      Scriptable scope = getParentScope();\n+      return slot.getPropertyDescriptor(cx, (scope == null ? this : scope));\n+    }\n+\n+    protected Slot getSlot(Context cx, Object id, int accessType) {\n+      final Slot slot;\n+      String name = ScriptRuntime.toStringIdOrIndex(cx, id);\n+      if (name == null) {\n+        int index = ScriptRuntime.lastIndexResult(cx);\n+        slot = getSlot(null, index, accessType);\n+      } else {\n+        slot = getSlot(name, 0, accessType);\n+      }\n+      return slot;\n+    }\n+\n+    // Methods and classes to implement java.util.Map interface\n+\n+    public int size() {\n+        return count;\n+    }\n+\n+    public boolean isEmpty() {\n+        return count == 0;\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        if (key instanceof String) {\n+            return has((String) key, this);\n+        } else if (key instanceof Number) {\n+            return has(((Number) key).intValue(), this);\n+        }\n+        return false;\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        for (Object obj : values()) {\n+            if (value == obj ||\n+                    value != null && value.equals(obj)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public Object get(Object key) {\n+        Object value = null;\n+        if (key instanceof String) {\n+            value = get((String) key, this);\n+        } else if (key instanceof Number) {\n+            value = get(((Number) key).intValue(), this);\n+        }\n+        if (value == Scriptable.NOT_FOUND || value == Undefined.instance) {\n+            return null;\n+        } else if (value instanceof Wrapper) {\n+            return ((Wrapper) value).unwrap();\n+        } else {\n+            return value;\n+        }\n+    }\n+\n+    public Object remove(Object key) {\n+        Object value = get(key);\n+        if (key instanceof String) {\n+            delete((String) key);\n+        } else if (key instanceof Number) {\n+            delete(((Number) key).intValue());\n+        }\n+        return value;\n+    }\n+\n+    public Set<Object> keySet() {\n+        return new KeySet();\n+    }\n+\n+    public Collection<Object> values() {\n+        return new ValueCollection();\n+    }\n+\n+    public Set<Map.Entry<Object, Object>> entrySet() {\n+        return new EntrySet();\n+    }\n+\n+    public Object put(Object key, Object value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void putAll(Map m) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+\n+    class EntrySet extends AbstractSet<Map.Entry<Object, Object>> {\n+        @Override\n+        public Iterator<Map.Entry<Object, Object>> iterator() {\n+            return new Iterator<Map.Entry<Object, Object>>() {\n+                Object[] ids = getIds();\n+                Object key = null;\n+                int index = 0;\n+\n+                public boolean hasNext() {\n+                    return index < ids.length;\n+                }\n+\n+                public Map.Entry<Object, Object> next() {\n+                    final Object ekey = key = ids[index++];\n+                    final Object value = get(key);\n+                    return new Map.Entry<Object, Object>() {\n+                        public Object getKey() {\n+                            return ekey;\n+                        }\n+\n+                        public Object getValue() {\n+                            return value;\n+                        }\n+\n+                        public Object setValue(Object value) {\n+                            throw new UnsupportedOperationException();\n+                        }\n+\n+                        public boolean equals(Object other) {\n+                            if (!(other instanceof Map.Entry)) {\n+                                return false;\n+                            }\n+                            Map.Entry e = (Map.Entry) other;\n+                            return (ekey == null ? e.getKey() == null : ekey.equals(e.getKey()))\n+                                && (value == null ? e.getValue() == null : value.equals(e.getValue()));\n+                        }\n+\n+                        public int hashCode() {\n+                            return (ekey == null ? 0 : ekey.hashCode()) ^\n+                                   (value == null ? 0 : value.hashCode());\n+                        }\n+\n+                        public String toString() {\n+                            return ekey + \"=\" + value;\n+                        }\n+                    };\n+                }\n+\n+                public void remove() {\n+                    if (key == null) {\n+                        throw new IllegalStateException();\n+                    }\n+                    ScriptableObject.this.remove(key);\n+                    key = null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public int size() {\n+            return count;\n+        }\n+    }\n+\n+    class KeySet extends AbstractSet<Object> {\n+\n+        @Override\n+        public boolean contains(Object key) {\n+            return containsKey(key);\n+        }\n+\n+        @Override\n+        public Iterator<Object> iterator() {\n+            return new Iterator<Object>() {\n+                Object[] ids = getIds();\n+                Object key;\n+                int index = 0;\n+\n+                public boolean hasNext() {\n+                    return index < ids.length;\n+                }\n+\n+                public Object next() {\n+                    return (key = ids[index++]);\n+                }\n+\n+                public void remove() {\n+                    if (key == null) {\n+                        throw new IllegalStateException();\n+                    }\n+                    ScriptableObject.this.remove(key);\n+                    key = null;\n+                }\n+           };\n+        }\n+\n+        @Override\n+        public int size() {\n+            return count;\n+        }\n+    }\n+\n+    class ValueCollection extends AbstractCollection<Object> {\n+\n+        @Override\n+        public Iterator<Object> iterator() {\n+            return new Iterator<Object>() {\n+                Object[] ids = getIds();\n+                Object key;\n+                int index = 0;\n+\n+                public boolean hasNext() {\n+                    return index < ids.length;\n+                }\n+\n+                public Object next() {\n+                    return get((key = ids[index++]));\n+                }\n+\n+                public void remove() {\n+                    if (key == null) {\n+                        throw new IllegalStateException();\n+                    }\n+                    ScriptableObject.this.remove(key);\n+                    key = null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public int size() {\n+            return count;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/SecureCaller.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.ref.SoftReference;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.CodeSource;\n+import java.security.PrivilegedAction;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.security.SecureClassLoader;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+\n+/**\n+ */\n+public abstract class SecureCaller\n+{\n+    private static final byte[] secureCallerImplBytecode = loadBytecode();\n+\n+    // We're storing a CodeSource -> (ClassLoader -> SecureRenderer), since we\n+    // need to have one renderer per class loader. We're using weak hash maps\n+    // and soft references all the way, since we don't want to interfere with\n+    // cleanup of either CodeSource or ClassLoader objects.\n+    private static final Map<CodeSource,Map<ClassLoader,SoftReference<SecureCaller>>>\n+    callers =\n+        new WeakHashMap<CodeSource,Map<ClassLoader,SoftReference<SecureCaller>>>();\n+\n+    public abstract Object call(Callable callable, Context cx,\n+            Scriptable scope, Scriptable thisObj, Object[] args);\n+\n+    /**\n+     * Call the specified callable using a protection domain belonging to the\n+     * specified code source.\n+     */\n+    static Object callSecurely(final CodeSource codeSource, Callable callable,\n+            Context cx, Scriptable scope, Scriptable thisObj, Object[] args)\n+    {\n+        final Thread thread = Thread.currentThread();\n+        // Run in doPrivileged as we might be checked for \"getClassLoader\"\n+        // runtime permission\n+        final ClassLoader classLoader = (ClassLoader)AccessController.doPrivileged(\n+            new PrivilegedAction<Object>() {\n+                public Object run() {\n+                    return thread.getContextClassLoader();\n+                }\n+            });\n+        Map<ClassLoader,SoftReference<SecureCaller>> classLoaderMap;\n+        synchronized(callers)\n+        {\n+            classLoaderMap = callers.get(codeSource);\n+            if(classLoaderMap == null)\n+            {\n+                classLoaderMap = new WeakHashMap<ClassLoader,SoftReference<SecureCaller>>();\n+                callers.put(codeSource, classLoaderMap);\n+            }\n+        }\n+        SecureCaller caller;\n+        synchronized(classLoaderMap)\n+        {\n+            SoftReference<SecureCaller> ref = classLoaderMap.get(classLoader);\n+            if (ref != null) {\n+                caller = ref.get();\n+            } else {\n+                caller = null;\n+            }\n+            if (caller == null) {\n+                try\n+                {\n+                    // Run in doPrivileged as we'll be checked for\n+                    // \"createClassLoader\" runtime permission\n+                    caller = (SecureCaller)AccessController.doPrivileged(\n+                            new PrivilegedExceptionAction<Object>()\n+                    {\n+                        public Object run() throws Exception\n+                        {\n+                            ClassLoader effectiveClassLoader;\n+                            Class<?> thisClass = getClass();\n+                            if(classLoader.loadClass(thisClass.getName()) != thisClass) {\n+                                effectiveClassLoader = thisClass.getClassLoader();\n+                            } else {\n+                                effectiveClassLoader = classLoader;\n+                            }\n+                            SecureClassLoaderImpl secCl =\n+                                new SecureClassLoaderImpl(effectiveClassLoader);\n+                            Class<?> c = secCl.defineAndLinkClass(\n+                                    SecureCaller.class.getName() + \"Impl\",\n+                                    secureCallerImplBytecode, codeSource);\n+                            return c.newInstance();\n+                        }\n+                    });\n+                    classLoaderMap.put(classLoader, new SoftReference<SecureCaller>(caller));\n+                }\n+                catch(PrivilegedActionException ex)\n+                {\n+                    throw new UndeclaredThrowableException(ex.getCause());\n+                }\n+            }\n+        }\n+        return caller.call(callable, cx, scope, thisObj, args);\n+    }\n+\n+    private static class SecureClassLoaderImpl extends SecureClassLoader\n+    {\n+        SecureClassLoaderImpl(ClassLoader parent)\n+        {\n+            super(parent);\n+        }\n+\n+        Class<?> defineAndLinkClass(String name, byte[] bytes, CodeSource cs)\n+        {\n+            Class<?> cl = defineClass(name, bytes, 0, bytes.length, cs);\n+            resolveClass(cl);\n+            return cl;\n+        }\n+    }\n+\n+    private static byte[] loadBytecode()\n+    {\n+        return (byte[])AccessController.doPrivileged(new PrivilegedAction<Object>()\n+        {\n+            public Object run()\n+            {\n+                return loadBytecodePrivileged();\n+            }\n+        });\n+    }\n+\n+    private static byte[] loadBytecodePrivileged()\n+    {\n+        URL url = SecureCaller.class.getResource(\"SecureCallerImpl.clazz\");\n+        try\n+        {\n+            InputStream in = url.openStream();\n+            try\n+            {\n+                ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+                for(;;)\n+                {\n+                    int r = in.read();\n+                    if(r == -1)\n+                    {\n+                        return bout.toByteArray();\n+                    }\n+                    bout.write(r);\n+                }\n+            }\n+            finally\n+            {\n+                in.close();\n+            }\n+        }\n+        catch(IOException e)\n+        {\n+            throw new UndeclaredThrowableException(e);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/SecurityController.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class describes the support needed to implement security.\n+ * <p>\n+ * Three main pieces of functionality are required to implement\n+ * security for JavaScript. First, it must be possible to define\n+ * classes with an associated security domain. (This security\n+ * domain may be any object incorporating notion of access\n+ * restrictions that has meaning to an embedding; for a client-side\n+ * JavaScript embedding this would typically be\n+ * java.security.ProtectionDomain or similar object depending on an\n+ * origin URL and/or a digital certificate.)\n+ * Next it must be possible to get a security domain object that\n+ * allows a particular action only if all security domains\n+ * associated with code on the current Java stack allows it. And\n+ * finally, it must be possible to execute script code with\n+ * associated security domain injected into Java stack.\n+ * <p>\n+ * These three pieces of functionality are encapsulated in the\n+ * SecurityController class.\n+ *\n+ * @see org.mozilla.javascript.Context#setSecurityController(SecurityController)\n+ * @see java.lang.ClassLoader\n+ * @since 1.5 Release 4\n+ */\n+public abstract class SecurityController\n+{\n+    private static SecurityController global;\n+\n+// The method must NOT be public or protected\n+    static SecurityController global()\n+    {\n+        return global;\n+    }\n+\n+    /**\n+     * Check if global {@link SecurityController} was already installed.\n+     * @see #initGlobal(SecurityController controller)\n+     */\n+    public static boolean hasGlobal()\n+    {\n+        return global != null;\n+    }\n+\n+    /**\n+     * Initialize global controller that will be used for all\n+     * security-related operations. The global controller takes precedence\n+     * over already installed {@link Context}-specific controllers and cause\n+     * any subsequent call to\n+     * {@link Context#setSecurityController(SecurityController)}\n+     * to throw an exception.\n+     * <p>\n+     * The method can only be called once.\n+     *\n+     * @see #hasGlobal()\n+     */\n+    public static void initGlobal(SecurityController controller)\n+    {\n+        if (controller == null) throw new IllegalArgumentException();\n+        if (global != null) {\n+            throw new SecurityException(\"Cannot overwrite already installed global SecurityController\");\n+        }\n+        global = controller;\n+    }\n+\n+    /**\n+     * Get class loader-like object that can be used\n+     * to define classes with the given security context.\n+     * @param parentLoader parent class loader to delegate search for classes\n+     *        not defined by the class loader itself\n+     * @param securityDomain some object specifying the security\n+     *        context of the code that is defined by the returned class loader.\n+     */\n+    public abstract GeneratedClassLoader createClassLoader(\n+        ClassLoader parentLoader, Object securityDomain);\n+\n+    /**\n+     * Create {@link GeneratedClassLoader} with restrictions imposed by\n+     * staticDomain and all current stack frames.\n+     * The method uses the SecurityController instance associated with the\n+     * current {@link Context} to construct proper dynamic domain and create\n+     * corresponding class loader.\n+     * <par>\n+     * If no SecurityController is associated with the current {@link Context} ,\n+     * the method calls {@link Context#createClassLoader(ClassLoader parent)}.\n+     *\n+     * @param parent parent class loader. If null,\n+     *        {@link Context#getApplicationClassLoader()} will be used.\n+     * @param staticDomain static security domain.\n+     */\n+    public static GeneratedClassLoader createLoader(\n+        ClassLoader parent, Object staticDomain)\n+    {\n+        Context cx = Context.getContext();\n+        if (parent == null) {\n+            parent = cx.getApplicationClassLoader();\n+        }\n+        SecurityController sc = cx.getSecurityController();\n+        GeneratedClassLoader loader;\n+        if (sc == null) {\n+            loader = cx.createClassLoader(parent);\n+        } else {\n+            Object dynamicDomain = sc.getDynamicSecurityDomain(staticDomain);\n+            loader = sc.createClassLoader(parent, dynamicDomain);\n+        }\n+        return loader;\n+    }\n+\n+    public static Class<?> getStaticSecurityDomainClass() {\n+        SecurityController sc = Context.getContext().getSecurityController();\n+        return sc == null ? null : sc.getStaticSecurityDomainClassInternal(); \n+    }\n+    \n+    public Class<?> getStaticSecurityDomainClassInternal()\n+    {\n+        return null;\n+    }\n+\n+    /**\n+     * Get dynamic security domain that allows an action only if it is allowed\n+     * by the current Java stack and <i>securityDomain</i>. If\n+     * <i>securityDomain</i> is null, return domain representing permissions\n+     * allowed by the current stack.\n+     */\n+    public abstract Object getDynamicSecurityDomain(Object securityDomain);\n+\n+    /**\n+     * Call {@link\n+     * Callable#call(Context cx, Scriptable scope, Scriptable thisObj,\n+     *               Object[] args)}\n+     * of <i>callable</i> under restricted security domain where an action is\n+     * allowed only if it is allowed according to the Java stack on the\n+     * moment of the <i>execWithDomain</i> call and <i>securityDomain</i>.\n+     * Any call to {@link #getDynamicSecurityDomain(Object)} during\n+     * execution of <tt>callable.call(cx, scope, thisObj, args)</tt>\n+     * should return a domain incorporate restrictions imposed by\n+     * <i>securityDomain</i> and Java stack on the moment of callWithDomain\n+     * invocation.\n+     * <p>\n+     * The method should always be overridden, it is not declared abstract\n+     * for compatibility reasons.\n+     */\n+    public Object callWithDomain(Object securityDomain, Context cx,\n+                                 final Callable callable, Scriptable scope,\n+                                 final Scriptable thisObj, final Object[] args)\n+    {\n+        return execWithDomain(cx, scope, new Script()\n+        {\n+            public Object exec(Context cx, Scriptable scope)\n+            {\n+                return callable.call(cx, scope, thisObj, args);\n+            }\n+\n+        }, securityDomain);\n+    }\n+\n+    /**\n+     * @deprecated The application should not override this method and instead\n+     * override\n+     * {@link #callWithDomain(Object securityDomain, Context cx, Callable callable, Scriptable scope, Scriptable thisObj, Object[] args)}.\n+     */\n+    public Object execWithDomain(Context cx, Scriptable scope,\n+                                 Script script, Object securityDomain)\n+    {\n+        throw new IllegalStateException(\"callWithDomain should be overridden\");\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/SecurityUtilities.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.ProtectionDomain;\n+\n+/**\n+ */\n+public class SecurityUtilities\n+{\n+    /**\n+     * Retrieves a system property within a privileged block. Use it only when\n+     * the property is used from within Rhino code and is not passed out of it.\n+     * @param name the name of the system property\n+     * @return the value of the system property\n+     */\n+    public static String getSystemProperty(final String name)\n+    {\n+        return (String)AccessController.doPrivileged(\n+            new PrivilegedAction<Object>()\n+            {\n+                public Object run()\n+                {\n+                    return System.getProperty(name);\n+                }\n+            });\n+    }\n+\n+    public static ProtectionDomain getProtectionDomain(final Class<?> clazz)\n+    {\n+        return (ProtectionDomain)AccessController.doPrivileged(\n+                new PrivilegedAction<Object>()\n+                {\n+                    public Object run()\n+                    {\n+                        return clazz.getProtectionDomain();\n+                    }\n+                });\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/SpecialRef.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov, igor@fastmail.fm\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+class SpecialRef extends Ref\n+{\n+    static final long serialVersionUID = -7521596632456797847L;\n+\n+    private static final int SPECIAL_NONE = 0;\n+    private static final int SPECIAL_PROTO = 1;\n+    private static final int SPECIAL_PARENT = 2;\n+\n+    private Scriptable target;\n+    private int type;\n+    private String name;\n+\n+    private SpecialRef(Scriptable target, int type, String name)\n+    {\n+        this.target = target;\n+        this.type = type;\n+        this.name = name;\n+    }\n+\n+    static Ref createSpecial(Context cx, Object object, String name)\n+    {\n+        Scriptable target = ScriptRuntime.toObjectOrNull(cx, object);\n+        if (target == null) {\n+            throw ScriptRuntime.undefReadError(object, name);\n+        }\n+\n+        int type;\n+        if (name.equals(\"__proto__\")) {\n+            type = SPECIAL_PROTO;\n+        } else if (name.equals(\"__parent__\")) {\n+            type = SPECIAL_PARENT;\n+        } else {\n+            throw new IllegalArgumentException(name);\n+        }\n+\n+        if (!cx.hasFeature(Context.FEATURE_PARENT_PROTO_PROPERTIES)) {\n+            // Clear special after checking for valid name!\n+            type = SPECIAL_NONE;\n+        }\n+\n+        return new SpecialRef(target, type, name);\n+    }\n+\n+    @Override\n+    public Object get(Context cx)\n+    {\n+        switch (type) {\n+          case SPECIAL_NONE:\n+            return ScriptRuntime.getObjectProp(target, name, cx);\n+          case SPECIAL_PROTO:\n+            return target.getPrototype();\n+          case SPECIAL_PARENT:\n+            return target.getParentScope();\n+          default:\n+            throw Kit.codeBug();\n+        }\n+    }\n+\n+    @Override\n+    public Object set(Context cx, Object value)\n+    {\n+        switch (type) {\n+          case SPECIAL_NONE:\n+            return ScriptRuntime.setObjectProp(target, name, value, cx);\n+          case SPECIAL_PROTO:\n+          case SPECIAL_PARENT:\n+            {\n+                Scriptable obj = ScriptRuntime.toObjectOrNull(cx, value);\n+                if (obj != null) {\n+                    // Check that obj does not contain on its prototype/scope\n+                    // chain to prevent cycles\n+                    Scriptable search = obj;\n+                    do {\n+                        if (search == target) {\n+                            throw Context.reportRuntimeError1(\n+                                \"msg.cyclic.value\", name);\n+                        }\n+                        if (type == SPECIAL_PROTO) {\n+                            search = search.getPrototype();\n+                        } else {\n+                            search = search.getParentScope();\n+                        }\n+                    } while (search != null);\n+                }\n+                if (type == SPECIAL_PROTO) {\n+                    target.setPrototype(obj);\n+                } else {\n+                    target.setParentScope(obj);\n+                }\n+                return obj;\n+            }\n+          default:\n+            throw Kit.codeBug();\n+        }\n+    }\n+\n+    @Override\n+    public boolean has(Context cx)\n+    {\n+        if (type == SPECIAL_NONE) {\n+            return ScriptRuntime.hasObjectElem(target, name, cx);\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean delete(Context cx)\n+    {\n+        if (type == SPECIAL_NONE) {\n+            return ScriptRuntime.deleteObjectElem(target, name, cx);\n+        }\n+        return false;\n+    }\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Synchronizer.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Delegator.java, released\n+ * Sep 27, 2000.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Matthias Radestock. <matthias@sorted.org>.\n+ * Portions created by the Initial Developer are Copyright (C) 2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class provides support for implementing Java-style synchronized\n+ * methods in Javascript.\n+ *\n+ * Synchronized functions are created from ordinary Javascript\n+ * functions by the <code>Synchronizer</code> constructor, e.g.\n+ * <code>new Packages.org.mozilla.javascript.Synchronizer(fun)</code>.\n+ * The resulting object is a function that establishes an exclusive\n+ * lock on the <code>this</code> object of its invocation.\n+ *\n+ * The Rhino shell provides a short-cut for the creation of\n+ * synchronized methods: <code>sync(fun)</code> has the same effect as\n+ * calling the above constructor.\n+ *\n+ * @see org.mozilla.javascript.Delegator\n+ */\n+\n+public class Synchronizer extends Delegator {\n+\n+    /**\n+     * Create a new synchronized function from an existing one.\n+     *\n+     * @param obj the existing function\n+     */\n+    public Synchronizer(Scriptable obj) {\n+        super(obj);\n+    }\n+\n+    /**\n+     * @see org.mozilla.javascript.Function#call\n+     */\n+    @Override\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        synchronized(thisObj instanceof Wrapper ? ((Wrapper)thisObj).unwrap() : thisObj) {\n+            return ((Function)obj).call(cx,scope,thisObj,args);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Token.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Roger Lawrence\n+ *   Mike McCabe\n+ *   Igor Bukanov\n+ *   Bob Jervis\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * This class implements the JavaScript scanner.\n+ *\n+ * It is based on the C source files jsscan.c and jsscan.h\n+ * in the jsref package.\n+ *\n+ * @see org.mozilla.javascript.Parser\n+ *\n+ */\n+\n+public class Token\n+{\n+    public static enum CommentType {\n+        LINE, BLOCK, JSDOC, HTML\n+    }\n+\n+    // debug flags\n+    public static final boolean printTrees = false;\n+    static final boolean printICode = false;\n+    static final boolean printNames = printTrees || printICode;\n+\n+    /**\n+     * Token types.  These values correspond to JSTokenType values in\n+     * jsscan.c.\n+     */\n+\n+    public final static int\n+    // start enum\n+        ERROR          = -1, // well-known as the only code < EOF\n+        EOF            = 0,  // end of file token - (not EOF_CHAR)\n+        EOL            = 1,  // end of line\n+\n+        // Interpreter reuses the following as bytecodes\n+        FIRST_BYTECODE_TOKEN    = 2,\n+\n+        ENTERWITH      = 2,\n+        LEAVEWITH      = 3,\n+        RETURN         = 4,\n+        GOTO           = 5,\n+        IFEQ           = 6,\n+        IFNE           = 7,\n+        SETNAME        = 8,\n+        BITOR          = 9,\n+        BITXOR         = 10,\n+        BITAND         = 11,\n+        EQ             = 12,\n+        NE             = 13,\n+        LT             = 14,\n+        LE             = 15,\n+        GT             = 16,\n+        GE             = 17,\n+        LSH            = 18,\n+        RSH            = 19,\n+        URSH           = 20,\n+        ADD            = 21,\n+        SUB            = 22,\n+        MUL            = 23,\n+        DIV            = 24,\n+        MOD            = 25,\n+        NOT            = 26,\n+        BITNOT         = 27,\n+        POS            = 28,\n+        NEG            = 29,\n+        NEW            = 30,\n+        DELPROP        = 31,\n+        TYPEOF         = 32,\n+        GETPROP        = 33,\n+        GETPROPNOWARN  = 34,\n+        SETPROP        = 35,\n+        GETELEM        = 36,\n+        SETELEM        = 37,\n+        CALL           = 38,\n+        NAME           = 39,\n+        NUMBER         = 40,\n+        STRING         = 41,\n+        NULL           = 42,\n+        THIS           = 43,\n+        FALSE          = 44,\n+        TRUE           = 45,\n+        SHEQ           = 46,   // shallow equality (===)\n+        SHNE           = 47,   // shallow inequality (!==)\n+        REGEXP         = 48,\n+        BINDNAME       = 49,\n+        THROW          = 50,\n+        RETHROW        = 51, // rethrow caught exception: catch (e if ) use it\n+        IN             = 52,\n+        INSTANCEOF     = 53,\n+        LOCAL_LOAD     = 54,\n+        GETVAR         = 55,\n+        SETVAR         = 56,\n+        CATCH_SCOPE    = 57,\n+        ENUM_INIT_KEYS = 58,\n+        ENUM_INIT_VALUES = 59,\n+        ENUM_INIT_ARRAY= 60,\n+        ENUM_NEXT      = 61,\n+        ENUM_ID        = 62,\n+        THISFN         = 63,\n+        RETURN_RESULT  = 64, // to return previously stored return result\n+        ARRAYLIT       = 65, // array literal\n+        OBJECTLIT      = 66, // object literal\n+        GET_REF        = 67, // *reference\n+        SET_REF        = 68, // *reference    = something\n+        DEL_REF        = 69, // delete reference\n+        REF_CALL       = 70, // f(args)    = something or f(args)++\n+        REF_SPECIAL    = 71, // reference for special properties like __proto\n+        YIELD          = 72,  // JS 1.7 yield pseudo keyword\n+        STRICT_SETNAME = 73,\n+\n+        // For XML support:\n+        DEFAULTNAMESPACE = 74, // default xml namespace =\n+        ESCXMLATTR     = 75,\n+        ESCXMLTEXT     = 76,\n+        REF_MEMBER     = 77, // Reference for x.@y, x..y etc.\n+        REF_NS_MEMBER  = 78, // Reference for x.ns::y, x..ns::y etc.\n+        REF_NAME       = 79, // Reference for @y, @[y] etc.\n+        REF_NS_NAME    = 80; // Reference for ns::y, @ns::y@[y] etc.\n+\n+        // End of interpreter bytecodes\n+    public final static int\n+        LAST_BYTECODE_TOKEN    = REF_NS_NAME,\n+\n+        TRY            = 81,\n+        SEMI           = 82,  // semicolon\n+        LB             = 83,  // left and right brackets\n+        RB             = 84,\n+        LC             = 85,  // left and right curlies (braces)\n+        RC             = 86,\n+        LP             = 87,  // left and right parentheses\n+        RP             = 88,\n+        COMMA          = 89,  // comma operator\n+\n+        ASSIGN         = 90,  // simple assignment  (=)\n+        ASSIGN_BITOR   = 91,  // |=\n+        ASSIGN_BITXOR  = 92,  // ^=\n+        ASSIGN_BITAND  = 93,  // |=\n+        ASSIGN_LSH     = 94,  // <<=\n+        ASSIGN_RSH     = 95,  // >>=\n+        ASSIGN_URSH    = 96,  // >>>=\n+        ASSIGN_ADD     = 97,  // +=\n+        ASSIGN_SUB     = 98,  // -=\n+        ASSIGN_MUL     = 99,  // *=\n+        ASSIGN_DIV     = 100,  // /=\n+        ASSIGN_MOD     = 101;  // %=\n+\n+    public final static int\n+        FIRST_ASSIGN   = ASSIGN,\n+        LAST_ASSIGN    = ASSIGN_MOD,\n+\n+        HOOK           = 102, // conditional (?:)\n+        COLON          = 103,\n+        OR             = 104, // logical or (||)\n+        AND            = 105, // logical and (&&)\n+        INC            = 106, // increment/decrement (++ --)\n+        DEC            = 107,\n+        DOT            = 108, // member operator (.)\n+        FUNCTION       = 109, // function keyword\n+        EXPORT         = 110, // export keyword\n+        IMPORT         = 111, // import keyword\n+        IF             = 112, // if keyword\n+        ELSE           = 113, // else keyword\n+        SWITCH         = 114, // switch keyword\n+        CASE           = 115, // case keyword\n+        DEFAULT        = 116, // default keyword\n+        WHILE          = 117, // while keyword\n+        DO             = 118, // do keyword\n+        FOR            = 119, // for keyword\n+        BREAK          = 120, // break keyword\n+        CONTINUE       = 121, // continue keyword\n+        VAR            = 122, // var keyword\n+        WITH           = 123, // with keyword\n+        CATCH          = 124, // catch keyword\n+        FINALLY        = 125, // finally keyword\n+        VOID           = 126, // void keyword\n+        RESERVED       = 127, // reserved keywords\n+\n+        EMPTY          = 128,\n+\n+        /* types used for the parse tree - these never get returned\n+         * by the scanner.\n+         */\n+\n+        BLOCK          = 129, // statement block\n+        LABEL          = 130, // label\n+        TARGET         = 131,\n+        LOOP           = 132,\n+        EXPR_VOID      = 133, // expression statement in functions\n+        EXPR_RESULT    = 134, // expression statement in scripts\n+        JSR            = 135,\n+        SCRIPT         = 136, // top-level node for entire script\n+        TYPEOFNAME     = 137, // for typeof(simple-name)\n+        USE_STACK      = 138,\n+        SETPROP_OP     = 139, // x.y op= something\n+        SETELEM_OP     = 140, // x[y] op= something\n+        LOCAL_BLOCK    = 141,\n+        SET_REF_OP     = 142, // *reference op= something\n+\n+        // For XML support:\n+        DOTDOT         = 143,  // member operator (..)\n+        COLONCOLON     = 144,  // namespace::name\n+        XML            = 145,  // XML type\n+        DOTQUERY       = 146,  // .() -- e.g., x.emps.emp.(name == \"terry\")\n+        XMLATTR        = 147,  // @\n+        XMLEND         = 148,\n+\n+        // Optimizer-only-tokens\n+        TO_OBJECT      = 149,\n+        TO_DOUBLE      = 150,\n+\n+        GET            = 151,  // JS 1.5 get pseudo keyword\n+        SET            = 152,  // JS 1.5 set pseudo keyword\n+        LET            = 153,  // JS 1.7 let pseudo keyword\n+        CONST          = 154,\n+        SETCONST       = 155,\n+        SETCONSTVAR    = 156,\n+        ARRAYCOMP      = 157,  // array comprehension\n+        LETEXPR        = 158,\n+        WITHEXPR       = 159,\n+        DEBUGGER       = 160,\n+        COMMENT        = 161,\n+        LAST_TOKEN     = 162;\n+\n+    /**\n+     * Returns a name for the token.  If Rhino is compiled with certain\n+     * hardcoded debugging flags in this file, it calls {@code #typeToName};\n+     * otherwise it returns a string whose value is the token number.\n+     */\n+    public static String name(int token)\n+    {\n+        if (!printNames) {\n+            return String.valueOf(token);\n+        }\n+        return typeToName(token);\n+    }\n+\n+    /**\n+     * Always returns a human-readable string for the token name.\n+     * For instance, {@link #FINALLY} has the name \"FINALLY\".\n+     * @param token the token code\n+     * @return the actual name for the token code\n+     */\n+    public static String typeToName(int token) {\n+        switch (token) {\n+          case ERROR:           return \"ERROR\";\n+          case EOF:             return \"EOF\";\n+          case EOL:             return \"EOL\";\n+          case ENTERWITH:       return \"ENTERWITH\";\n+          case LEAVEWITH:       return \"LEAVEWITH\";\n+          case RETURN:          return \"RETURN\";\n+          case GOTO:            return \"GOTO\";\n+          case IFEQ:            return \"IFEQ\";\n+          case IFNE:            return \"IFNE\";\n+          case SETNAME:         return \"SETNAME\";\n+          case BITOR:           return \"BITOR\";\n+          case BITXOR:          return \"BITXOR\";\n+          case BITAND:          return \"BITAND\";\n+          case EQ:              return \"EQ\";\n+          case NE:              return \"NE\";\n+          case LT:              return \"LT\";\n+          case LE:              return \"LE\";\n+          case GT:              return \"GT\";\n+          case GE:              return \"GE\";\n+          case LSH:             return \"LSH\";\n+          case RSH:             return \"RSH\";\n+          case URSH:            return \"URSH\";\n+          case ADD:             return \"ADD\";\n+          case SUB:             return \"SUB\";\n+          case MUL:             return \"MUL\";\n+          case DIV:             return \"DIV\";\n+          case MOD:             return \"MOD\";\n+          case NOT:             return \"NOT\";\n+          case BITNOT:          return \"BITNOT\";\n+          case POS:             return \"POS\";\n+          case NEG:             return \"NEG\";\n+          case NEW:             return \"NEW\";\n+          case DELPROP:         return \"DELPROP\";\n+          case TYPEOF:          return \"TYPEOF\";\n+          case GETPROP:         return \"GETPROP\";\n+          case GETPROPNOWARN:   return \"GETPROPNOWARN\";\n+          case SETPROP:         return \"SETPROP\";\n+          case GETELEM:         return \"GETELEM\";\n+          case SETELEM:         return \"SETELEM\";\n+          case CALL:            return \"CALL\";\n+          case NAME:            return \"NAME\";\n+          case NUMBER:          return \"NUMBER\";\n+          case STRING:          return \"STRING\";\n+          case NULL:            return \"NULL\";\n+          case THIS:            return \"THIS\";\n+          case FALSE:           return \"FALSE\";\n+          case TRUE:            return \"TRUE\";\n+          case SHEQ:            return \"SHEQ\";\n+          case SHNE:            return \"SHNE\";\n+          case REGEXP:          return \"REGEXP\";\n+          case BINDNAME:        return \"BINDNAME\";\n+          case THROW:           return \"THROW\";\n+          case RETHROW:         return \"RETHROW\";\n+          case IN:              return \"IN\";\n+          case INSTANCEOF:      return \"INSTANCEOF\";\n+          case LOCAL_LOAD:      return \"LOCAL_LOAD\";\n+          case GETVAR:          return \"GETVAR\";\n+          case SETVAR:          return \"SETVAR\";\n+          case CATCH_SCOPE:     return \"CATCH_SCOPE\";\n+          case ENUM_INIT_KEYS:  return \"ENUM_INIT_KEYS\";\n+          case ENUM_INIT_VALUES:return \"ENUM_INIT_VALUES\";\n+          case ENUM_INIT_ARRAY: return \"ENUM_INIT_ARRAY\";\n+          case ENUM_NEXT:       return \"ENUM_NEXT\";\n+          case ENUM_ID:         return \"ENUM_ID\";\n+          case THISFN:          return \"THISFN\";\n+          case RETURN_RESULT:   return \"RETURN_RESULT\";\n+          case ARRAYLIT:        return \"ARRAYLIT\";\n+          case OBJECTLIT:       return \"OBJECTLIT\";\n+          case GET_REF:         return \"GET_REF\";\n+          case SET_REF:         return \"SET_REF\";\n+          case DEL_REF:         return \"DEL_REF\";\n+          case REF_CALL:        return \"REF_CALL\";\n+          case REF_SPECIAL:     return \"REF_SPECIAL\";\n+          case DEFAULTNAMESPACE:return \"DEFAULTNAMESPACE\";\n+          case ESCXMLTEXT:      return \"ESCXMLTEXT\";\n+          case ESCXMLATTR:      return \"ESCXMLATTR\";\n+          case REF_MEMBER:      return \"REF_MEMBER\";\n+          case REF_NS_MEMBER:   return \"REF_NS_MEMBER\";\n+          case REF_NAME:        return \"REF_NAME\";\n+          case REF_NS_NAME:     return \"REF_NS_NAME\";\n+          case TRY:             return \"TRY\";\n+          case SEMI:            return \"SEMI\";\n+          case LB:              return \"LB\";\n+          case RB:              return \"RB\";\n+          case LC:              return \"LC\";\n+          case RC:              return \"RC\";\n+          case LP:              return \"LP\";\n+          case RP:              return \"RP\";\n+          case COMMA:           return \"COMMA\";\n+          case ASSIGN:          return \"ASSIGN\";\n+          case ASSIGN_BITOR:    return \"ASSIGN_BITOR\";\n+          case ASSIGN_BITXOR:   return \"ASSIGN_BITXOR\";\n+          case ASSIGN_BITAND:   return \"ASSIGN_BITAND\";\n+          case ASSIGN_LSH:      return \"ASSIGN_LSH\";\n+          case ASSIGN_RSH:      return \"ASSIGN_RSH\";\n+          case ASSIGN_URSH:     return \"ASSIGN_URSH\";\n+          case ASSIGN_ADD:      return \"ASSIGN_ADD\";\n+          case ASSIGN_SUB:      return \"ASSIGN_SUB\";\n+          case ASSIGN_MUL:      return \"ASSIGN_MUL\";\n+          case ASSIGN_DIV:      return \"ASSIGN_DIV\";\n+          case ASSIGN_MOD:      return \"ASSIGN_MOD\";\n+          case HOOK:            return \"HOOK\";\n+          case COLON:           return \"COLON\";\n+          case OR:              return \"OR\";\n+          case AND:             return \"AND\";\n+          case INC:             return \"INC\";\n+          case DEC:             return \"DEC\";\n+          case DOT:             return \"DOT\";\n+          case FUNCTION:        return \"FUNCTION\";\n+          case EXPORT:          return \"EXPORT\";\n+          case IMPORT:          return \"IMPORT\";\n+          case IF:              return \"IF\";\n+          case ELSE:            return \"ELSE\";\n+          case SWITCH:          return \"SWITCH\";\n+          case CASE:            return \"CASE\";\n+          case DEFAULT:         return \"DEFAULT\";\n+          case WHILE:           return \"WHILE\";\n+          case DO:              return \"DO\";\n+          case FOR:             return \"FOR\";\n+          case BREAK:           return \"BREAK\";\n+          case CONTINUE:        return \"CONTINUE\";\n+          case VAR:             return \"VAR\";\n+          case WITH:            return \"WITH\";\n+          case CATCH:           return \"CATCH\";\n+          case FINALLY:         return \"FINALLY\";\n+          case VOID:            return \"VOID\";\n+          case RESERVED:        return \"RESERVED\";\n+          case EMPTY:           return \"EMPTY\";\n+          case BLOCK:           return \"BLOCK\";\n+          case LABEL:           return \"LABEL\";\n+          case TARGET:          return \"TARGET\";\n+          case LOOP:            return \"LOOP\";\n+          case EXPR_VOID:       return \"EXPR_VOID\";\n+          case EXPR_RESULT:     return \"EXPR_RESULT\";\n+          case JSR:             return \"JSR\";\n+          case SCRIPT:          return \"SCRIPT\";\n+          case TYPEOFNAME:      return \"TYPEOFNAME\";\n+          case USE_STACK:       return \"USE_STACK\";\n+          case SETPROP_OP:      return \"SETPROP_OP\";\n+          case SETELEM_OP:      return \"SETELEM_OP\";\n+          case LOCAL_BLOCK:     return \"LOCAL_BLOCK\";\n+          case SET_REF_OP:      return \"SET_REF_OP\";\n+          case DOTDOT:          return \"DOTDOT\";\n+          case COLONCOLON:      return \"COLONCOLON\";\n+          case XML:             return \"XML\";\n+          case DOTQUERY:        return \"DOTQUERY\";\n+          case XMLATTR:         return \"XMLATTR\";\n+          case XMLEND:          return \"XMLEND\";\n+          case TO_OBJECT:       return \"TO_OBJECT\";\n+          case TO_DOUBLE:       return \"TO_DOUBLE\";\n+          case GET:             return \"GET\";\n+          case SET:             return \"SET\";\n+          case LET:             return \"LET\";\n+          case YIELD:           return \"YIELD\";\n+          case CONST:           return \"CONST\";\n+          case SETCONST:        return \"SETCONST\";\n+          case ARRAYCOMP:       return \"ARRAYCOMP\";\n+          case WITHEXPR:        return \"WITHEXPR\";\n+          case LETEXPR:         return \"LETEXPR\";\n+          case DEBUGGER:        return \"DEBUGGER\";\n+          case COMMENT:         return \"COMMENT\";\n+        }\n+\n+        // Token without name\n+        throw new IllegalStateException(String.valueOf(token));\n+    }\n+\n+    /**\n+     * Return true if the passed code is a valid Token constant.\n+     * @param code a potential token code\n+     * @return true if it's a known token\n+     */\n+    public static boolean isValidToken(int code) {\n+        return code >= ERROR\n+                && code <= LAST_TOKEN;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/TokenStream.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Roger Lawrence\n+ *   Mike McCabe\n+ *   Igor Bukanov\n+ *   Ethan Hugg\n+ *   Bob Jervis\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.*;\n+\n+/**\n+ * This class implements the JavaScript scanner.\n+ *\n+ * It is based on the C source files jsscan.c and jsscan.h\n+ * in the jsref package.\n+ *\n+ * @see org.mozilla.javascript.Parser\n+ *\n+ */\n+\n+class TokenStream\n+{\n+    /*\n+     * For chars - because we need something out-of-range\n+     * to check.  (And checking EOF by exception is annoying.)\n+     * Note distinction from EOF token type!\n+     */\n+    private final static int\n+        EOF_CHAR = -1;\n+\n+    private final static char BYTE_ORDER_MARK = '\\uFEFF';\n+\n+    TokenStream(Parser parser, Reader sourceReader, String sourceString,\n+                int lineno)\n+    {\n+        this.parser = parser;\n+        this.lineno = lineno;\n+        if (sourceReader != null) {\n+            if (sourceString != null) Kit.codeBug();\n+            this.sourceReader = sourceReader;\n+            this.sourceBuffer = new char[512];\n+            this.sourceEnd = 0;\n+        } else {\n+            if (sourceString == null) Kit.codeBug();\n+            this.sourceString = sourceString;\n+            this.sourceEnd = sourceString.length();\n+        }\n+        this.sourceCursor = this.cursor = 0;\n+    }\n+\n+    /* This function uses the cached op, string and number fields in\n+     * TokenStream; if getToken has been called since the passed token\n+     * was scanned, the op or string printed may be incorrect.\n+     */\n+    String tokenToString(int token)\n+    {\n+        if (Token.printTrees) {\n+            String name = Token.name(token);\n+\n+            switch (token) {\n+            case Token.STRING:\n+            case Token.REGEXP:\n+            case Token.NAME:\n+                return name + \" `\" + this.string + \"'\";\n+\n+            case Token.NUMBER:\n+                return \"NUMBER \" + this.number;\n+            }\n+\n+            return name;\n+        }\n+        return \"\";\n+    }\n+\n+    static boolean isKeyword(String s)\n+    {\n+        return Token.EOF != stringToKeyword(s);\n+    }\n+\n+    private static int stringToKeyword(String name)\n+    {\n+// #string_id_map#\n+// The following assumes that Token.EOF == 0\n+        final int\n+            Id_break         = Token.BREAK,\n+            Id_case          = Token.CASE,\n+            Id_continue      = Token.CONTINUE,\n+            Id_default       = Token.DEFAULT,\n+            Id_delete        = Token.DELPROP,\n+            Id_do            = Token.DO,\n+            Id_else          = Token.ELSE,\n+            Id_export        = Token.RESERVED,\n+            Id_false         = Token.FALSE,\n+            Id_for           = Token.FOR,\n+            Id_function      = Token.FUNCTION,\n+            Id_if            = Token.IF,\n+            Id_in            = Token.IN,\n+            Id_let           = Token.LET,  // reserved ES5 strict\n+            Id_new           = Token.NEW,\n+            Id_null          = Token.NULL,\n+            Id_return        = Token.RETURN,\n+            Id_switch        = Token.SWITCH,\n+            Id_this          = Token.THIS,\n+            Id_true          = Token.TRUE,\n+            Id_typeof        = Token.TYPEOF,\n+            Id_var           = Token.VAR,\n+            Id_void          = Token.VOID,\n+            Id_while         = Token.WHILE,\n+            Id_with          = Token.WITH,\n+            Id_yield         = Token.YIELD,  // reserved ES5 strict\n+\n+            // the following are #ifdef RESERVE_JAVA_KEYWORDS in jsscan.c\n+            Id_abstract      = Token.RESERVED,  // ES3 only\n+            Id_boolean       = Token.RESERVED,  // ES3 only\n+            Id_byte          = Token.RESERVED,  // ES3 only\n+            Id_catch         = Token.CATCH,\n+            Id_char          = Token.RESERVED,  // ES3 only\n+            Id_class         = Token.RESERVED,\n+            Id_const         = Token.CONST,     // reserved\n+            Id_debugger      = Token.DEBUGGER,\n+            Id_double        = Token.RESERVED,  // ES3 only\n+            Id_enum          = Token.RESERVED,\n+            Id_extends       = Token.RESERVED,\n+            Id_final         = Token.RESERVED,  // ES3 only\n+            Id_finally       = Token.FINALLY,\n+            Id_float         = Token.RESERVED,  // ES3 only\n+            Id_goto          = Token.RESERVED,  // ES3 only\n+            Id_implements    = Token.RESERVED,  // ES3, ES5 strict\n+            Id_import        = Token.RESERVED,\n+            Id_instanceof    = Token.INSTANCEOF,\n+            Id_int           = Token.RESERVED,  // ES3\n+            Id_interface     = Token.RESERVED,  // ES3, ES5 strict\n+            Id_long          = Token.RESERVED,  // ES3 only\n+            Id_native        = Token.RESERVED,  // ES3 only\n+            Id_package       = Token.RESERVED,  // ES3, ES5 strict\n+            Id_private       = Token.RESERVED,  // ES3, ES5 strict\n+            Id_protected     = Token.RESERVED,  // ES3, ES5 strict\n+            Id_public        = Token.RESERVED,  // ES3, ES5 strict\n+            Id_short         = Token.RESERVED,  // ES3 only\n+            Id_static        = Token.RESERVED,  // ES3, ES5 strict\n+            Id_super         = Token.RESERVED,\n+            Id_synchronized  = Token.RESERVED,  // ES3 only\n+            Id_throw         = Token.THROW,\n+            Id_throws        = Token.RESERVED,  // ES3 only\n+            Id_transient     = Token.RESERVED,  // ES3 only\n+            Id_try           = Token.TRY,\n+            Id_volatile      = Token.RESERVED;  // ES3 only\n+\n+        int id;\n+        String s = name;\n+// #generated# Last update: 2007-04-18 13:53:30 PDT\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 2: c=s.charAt(1);\n+                if (c=='f') { if (s.charAt(0)=='i') {id=Id_if; break L0;} }\n+                else if (c=='n') { if (s.charAt(0)=='i') {id=Id_in; break L0;} }\n+                else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }\n+                break L;\n+            case 3: switch (s.charAt(0)) {\n+                case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {id=Id_for; break L0;} break L;\n+                case 'i': if (s.charAt(2)=='t' && s.charAt(1)=='n') {id=Id_int; break L0;} break L;\n+                case 'l': if (s.charAt(2)=='t' && s.charAt(1)=='e') {id=Id_let; break L0;} break L;\n+                case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {id=Id_new; break L0;} break L;\n+                case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {id=Id_try; break L0;} break L;\n+                case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {id=Id_var; break L0;} break L;\n+                } break L;\n+            case 4: switch (s.charAt(0)) {\n+                case 'b': X=\"byte\";id=Id_byte; break L;\n+                case 'c': c=s.charAt(3);\n+                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {id=Id_case; break L0;} }\n+                    else if (c=='r') { if (s.charAt(2)=='a' && s.charAt(1)=='h') {id=Id_char; break L0;} }\n+                    break L;\n+                case 'e': c=s.charAt(3);\n+                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {id=Id_else; break L0;} }\n+                    else if (c=='m') { if (s.charAt(2)=='u' && s.charAt(1)=='n') {id=Id_enum; break L0;} }\n+                    break L;\n+                case 'g': X=\"goto\";id=Id_goto; break L;\n+                case 'l': X=\"long\";id=Id_long; break L;\n+                case 'n': X=\"null\";id=Id_null; break L;\n+                case 't': c=s.charAt(3);\n+                    if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {id=Id_true; break L0;} }\n+                    else if (c=='s') { if (s.charAt(2)=='i' && s.charAt(1)=='h') {id=Id_this; break L0;} }\n+                    break L;\n+                case 'v': X=\"void\";id=Id_void; break L;\n+                case 'w': X=\"with\";id=Id_with; break L;\n+                } break L;\n+            case 5: switch (s.charAt(2)) {\n+                case 'a': X=\"class\";id=Id_class; break L;\n+                case 'e': c=s.charAt(0);\n+                    if (c=='b') { X=\"break\";id=Id_break; }\n+                    else if (c=='y') { X=\"yield\";id=Id_yield; }\n+                    break L;\n+                case 'i': X=\"while\";id=Id_while; break L;\n+                case 'l': X=\"false\";id=Id_false; break L;\n+                case 'n': c=s.charAt(0);\n+                    if (c=='c') { X=\"const\";id=Id_const; }\n+                    else if (c=='f') { X=\"final\";id=Id_final; }\n+                    break L;\n+                case 'o': c=s.charAt(0);\n+                    if (c=='f') { X=\"float\";id=Id_float; }\n+                    else if (c=='s') { X=\"short\";id=Id_short; }\n+                    break L;\n+                case 'p': X=\"super\";id=Id_super; break L;\n+                case 'r': X=\"throw\";id=Id_throw; break L;\n+                case 't': X=\"catch\";id=Id_catch; break L;\n+                } break L;\n+            case 6: switch (s.charAt(1)) {\n+                case 'a': X=\"native\";id=Id_native; break L;\n+                case 'e': c=s.charAt(0);\n+                    if (c=='d') { X=\"delete\";id=Id_delete; }\n+                    else if (c=='r') { X=\"return\";id=Id_return; }\n+                    break L;\n+                case 'h': X=\"throws\";id=Id_throws; break L;\n+                case 'm': X=\"import\";id=Id_import; break L;\n+                case 'o': X=\"double\";id=Id_double; break L;\n+                case 't': X=\"static\";id=Id_static; break L;\n+                case 'u': X=\"public\";id=Id_public; break L;\n+                case 'w': X=\"switch\";id=Id_switch; break L;\n+                case 'x': X=\"export\";id=Id_export; break L;\n+                case 'y': X=\"typeof\";id=Id_typeof; break L;\n+                } break L;\n+            case 7: switch (s.charAt(1)) {\n+                case 'a': X=\"package\";id=Id_package; break L;\n+                case 'e': X=\"default\";id=Id_default; break L;\n+                case 'i': X=\"finally\";id=Id_finally; break L;\n+                case 'o': X=\"boolean\";id=Id_boolean; break L;\n+                case 'r': X=\"private\";id=Id_private; break L;\n+                case 'x': X=\"extends\";id=Id_extends; break L;\n+                } break L;\n+            case 8: switch (s.charAt(0)) {\n+                case 'a': X=\"abstract\";id=Id_abstract; break L;\n+                case 'c': X=\"continue\";id=Id_continue; break L;\n+                case 'd': X=\"debugger\";id=Id_debugger; break L;\n+                case 'f': X=\"function\";id=Id_function; break L;\n+                case 'v': X=\"volatile\";id=Id_volatile; break L;\n+                } break L;\n+            case 9: c=s.charAt(0);\n+                if (c=='i') { X=\"interface\";id=Id_interface; }\n+                else if (c=='p') { X=\"protected\";id=Id_protected; }\n+                else if (c=='t') { X=\"transient\";id=Id_transient; }\n+                break L;\n+            case 10: c=s.charAt(1);\n+                if (c=='m') { X=\"implements\";id=Id_implements; }\n+                else if (c=='n') { X=\"instanceof\";id=Id_instanceof; }\n+                break L;\n+            case 12: X=\"synchronized\";id=Id_synchronized; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+// #/string_id_map#\n+        if (id == 0) { return Token.EOF; }\n+        return id & 0xff;\n+    }\n+\n+    final String getSourceString() { return sourceString; }\n+\n+    final int getLineno() { return lineno; }\n+\n+    final String getString() { return string; }\n+\n+    final char getQuoteChar() {\n+        return (char) quoteChar;\n+    }\n+\n+    final double getNumber() { return number; }\n+    final boolean isNumberOctal() { return isOctal; }\n+\n+    final boolean eof() { return hitEOF; }\n+\n+    final int getToken() throws IOException\n+    {\n+        int c;\n+\n+    retry:\n+        for (;;) {\n+            // Eat whitespace, possibly sensitive to newlines.\n+            for (;;) {\n+                c = getChar();\n+                if (c == EOF_CHAR) {\n+                    tokenBeg = cursor - 1;\n+                    tokenEnd = cursor;\n+                    return Token.EOF;\n+                } else if (c == '\\n') {\n+                    dirtyLine = false;\n+                    tokenBeg = cursor - 1;\n+                    tokenEnd = cursor;\n+                    return Token.EOL;\n+                } else if (!isJSSpace(c)) {\n+                    if (c != '-') {\n+                        dirtyLine = true;\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            // Assume the token will be 1 char - fixed up below.\n+            tokenBeg = cursor - 1;\n+            tokenEnd = cursor;\n+\n+            if (c == '@') return Token.XMLATTR;\n+\n+            // identifier/keyword/instanceof?\n+            // watch out for starting with a <backslash>\n+            boolean identifierStart;\n+            boolean isUnicodeEscapeStart = false;\n+            if (c == '\\\\') {\n+                c = getChar();\n+                if (c == 'u') {\n+                    identifierStart = true;\n+                    isUnicodeEscapeStart = true;\n+                    stringBufferTop = 0;\n+                } else {\n+                    identifierStart = false;\n+                    ungetChar(c);\n+                    c = '\\\\';\n+                }\n+            } else {\n+                identifierStart = Character.isJavaIdentifierStart((char)c);\n+                if (identifierStart) {\n+                    stringBufferTop = 0;\n+                    addToString(c);\n+                }\n+            }\n+\n+            if (identifierStart) {\n+                boolean containsEscape = isUnicodeEscapeStart;\n+                for (;;) {\n+                    if (isUnicodeEscapeStart) {\n+                        // strictly speaking we should probably push-back\n+                        // all the bad characters if the <backslash>uXXXX\n+                        // sequence is malformed. But since there isn't a\n+                        // correct context(is there?) for a bad Unicode\n+                        // escape sequence in an identifier, we can report\n+                        // an error here.\n+                        int escapeVal = 0;\n+                        for (int i = 0; i != 4; ++i) {\n+                            c = getChar();\n+                            escapeVal = Kit.xDigitToInt(c, escapeVal);\n+                            // Next check takes care about c < 0 and bad escape\n+                            if (escapeVal < 0) { break; }\n+                        }\n+                        if (escapeVal < 0) {\n+                            parser.addError(\"msg.invalid.escape\");\n+                            return Token.ERROR;\n+                        }\n+                        addToString(escapeVal);\n+                        isUnicodeEscapeStart = false;\n+                    } else {\n+                        c = getChar();\n+                        if (c == '\\\\') {\n+                            c = getChar();\n+                            if (c == 'u') {\n+                                isUnicodeEscapeStart = true;\n+                                containsEscape = true;\n+                            } else {\n+                                parser.addError(\"msg.illegal.character\");\n+                                return Token.ERROR;\n+                            }\n+                        } else {\n+                            if (c == EOF_CHAR || c == BYTE_ORDER_MARK\n+                                || !Character.isJavaIdentifierPart((char)c))\n+                            {\n+                                break;\n+                            }\n+                            addToString(c);\n+                        }\n+                    }\n+                }\n+                ungetChar(c);\n+\n+                String str = getStringFromBuffer();\n+                if (!containsEscape) {\n+                    // OPT we shouldn't have to make a string (object!) to\n+                    // check if it's a keyword.\n+\n+                    // Return the corresponding token if it's a keyword\n+                    int result = stringToKeyword(str);\n+                    if (result != Token.EOF) {\n+                        if ((result == Token.LET || result == Token.YIELD) &&\n+                            parser.compilerEnv.getLanguageVersion()\n+                               < Context.VERSION_1_7)\n+                        {\n+                            // LET and YIELD are tokens only in 1.7 and later\n+                            string = result == Token.LET ? \"let\" : \"yield\";\n+                            result = Token.NAME;\n+                        }\n+                        // Save the string in case we need to use in\n+                        // object literal definitions.\n+                        this.string = (String)allStrings.intern(str);\n+                        if (result != Token.RESERVED) {\n+                            return result;\n+                        } else if (!parser.compilerEnv.\n+                                        isReservedKeywordAsIdentifier())\n+                        {\n+                            return result;\n+                        }\n+                    }\n+                } else if (isKeyword(str)) {\n+                  // If a string contains unicodes, and converted to a keyword,\n+                  // we convert the last character back to unicode\n+                  str = convertLastCharToHex(str);\n+                }\n+                this.string = (String)allStrings.intern(str);\n+                return Token.NAME;\n+            }\n+\n+            // is it a number?\n+            if (isDigit(c) || (c == '.' && isDigit(peekChar()))) {\n+                isOctal = false;\n+                stringBufferTop = 0;\n+                int base = 10;\n+\n+                if (c == '0') {\n+                    c = getChar();\n+                    if (c == 'x' || c == 'X') {\n+                        base = 16;\n+                        c = getChar();\n+                    } else if (isDigit(c)) {\n+                        base = 8;\n+                        isOctal = true;\n+                    } else {\n+                        addToString('0');\n+                    }\n+                }\n+\n+                if (base == 16) {\n+                    while (0 <= Kit.xDigitToInt(c, 0)) {\n+                        addToString(c);\n+                        c = getChar();\n+                    }\n+                } else {\n+                    while ('0' <= c && c <= '9') {\n+                        /*\n+                         * We permit 08 and 09 as decimal numbers, which\n+                         * makes our behavior a superset of the ECMA\n+                         * numeric grammar.  We might not always be so\n+                         * permissive, so we warn about it.\n+                         */\n+                        if (base == 8 && c >= '8') {\n+                            parser.addWarning(\"msg.bad.octal.literal\",\n+                                              c == '8' ? \"8\" : \"9\");\n+                            base = 10;\n+                        }\n+                        addToString(c);\n+                        c = getChar();\n+                    }\n+                }\n+\n+                boolean isInteger = true;\n+\n+                if (base == 10 && (c == '.' || c == 'e' || c == 'E')) {\n+                    isInteger = false;\n+                    if (c == '.') {\n+                        do {\n+                            addToString(c);\n+                            c = getChar();\n+                        } while (isDigit(c));\n+                    }\n+                    if (c == 'e' || c == 'E') {\n+                        addToString(c);\n+                        c = getChar();\n+                        if (c == '+' || c == '-') {\n+                            addToString(c);\n+                            c = getChar();\n+                        }\n+                        if (!isDigit(c)) {\n+                            parser.addError(\"msg.missing.exponent\");\n+                            return Token.ERROR;\n+                        }\n+                        do {\n+                            addToString(c);\n+                            c = getChar();\n+                        } while (isDigit(c));\n+                    }\n+                }\n+                ungetChar(c);\n+                String numString = getStringFromBuffer();\n+                this.string = numString;\n+\n+                double dval;\n+                if (base == 10 && !isInteger) {\n+                    try {\n+                        // Use Java conversion to number from string...\n+                        dval = Double.valueOf(numString).doubleValue();\n+                    }\n+                    catch (NumberFormatException ex) {\n+                        parser.addError(\"msg.caught.nfe\");\n+                        return Token.ERROR;\n+                    }\n+                } else {\n+                    dval = ScriptRuntime.stringToNumber(numString, 0, base);\n+                }\n+\n+                this.number = dval;\n+                return Token.NUMBER;\n+            }\n+\n+            // is it a string?\n+            if (c == '\"' || c == '\\'') {\n+                // We attempt to accumulate a string the fast way, by\n+                // building it directly out of the reader.  But if there\n+                // are any escaped characters in the string, we revert to\n+                // building it out of a StringBuffer.\n+\n+                quoteChar = c;\n+                stringBufferTop = 0;\n+\n+                c = getChar(false);\n+            strLoop: while (c != quoteChar) {\n+                    if (c == '\\n' || c == EOF_CHAR) {\n+                        ungetChar(c);\n+                        tokenEnd = cursor;\n+                        parser.addError(\"msg.unterminated.string.lit\");\n+                        return Token.ERROR;\n+                    }\n+\n+                    if (c == '\\\\') {\n+                        // We've hit an escaped character\n+                        int escapeVal;\n+\n+                        c = getChar();\n+                        switch (c) {\n+                        case 'b': c = '\\b'; break;\n+                        case 'f': c = '\\f'; break;\n+                        case 'n': c = '\\n'; break;\n+                        case 'r': c = '\\r'; break;\n+                        case 't': c = '\\t'; break;\n+\n+                        // \\v a late addition to the ECMA spec,\n+                        // it is not in Java, so use 0xb\n+                        case 'v': c = 0xb; break;\n+\n+                        case 'u':\n+                            // Get 4 hex digits; if the u escape is not\n+                            // followed by 4 hex digits, use 'u' + the\n+                            // literal character sequence that follows.\n+                            int escapeStart = stringBufferTop;\n+                            addToString('u');\n+                            escapeVal = 0;\n+                            for (int i = 0; i != 4; ++i) {\n+                                c = getChar();\n+                                escapeVal = Kit.xDigitToInt(c, escapeVal);\n+                                if (escapeVal < 0) {\n+                                    continue strLoop;\n+                                }\n+                                addToString(c);\n+                            }\n+                            // prepare for replace of stored 'u' sequence\n+                            // by escape value\n+                            stringBufferTop = escapeStart;\n+                            c = escapeVal;\n+                            break;\n+                        case 'x':\n+                            // Get 2 hex digits, defaulting to 'x'+literal\n+                            // sequence, as above.\n+                            c = getChar();\n+                            escapeVal = Kit.xDigitToInt(c, 0);\n+                            if (escapeVal < 0) {\n+                                addToString('x');\n+                                continue strLoop;\n+                            } else {\n+                                int c1 = c;\n+                                c = getChar();\n+                                escapeVal = Kit.xDigitToInt(c, escapeVal);\n+                                if (escapeVal < 0) {\n+                                    addToString('x');\n+                                    addToString(c1);\n+                                    continue strLoop;\n+                                } else {\n+                                    // got 2 hex digits\n+                                    c = escapeVal;\n+                                }\n+                            }\n+                            break;\n+\n+                        case '\\n':\n+                            // Remove line terminator after escape to follow\n+                            // SpiderMonkey and C/C++\n+                            c = getChar();\n+                            continue strLoop;\n+\n+                        default:\n+                            if ('0' <= c && c < '8') {\n+                                int val = c - '0';\n+                                c = getChar();\n+                                if ('0' <= c && c < '8') {\n+                                    val = 8 * val + c - '0';\n+                                    c = getChar();\n+                                    if ('0' <= c && c < '8' && val <= 037) {\n+                                        // c is 3rd char of octal sequence only\n+                                        // if the resulting val <= 0377\n+                                        val = 8 * val + c - '0';\n+                                        c = getChar();\n+                                    }\n+                                }\n+                                ungetChar(c);\n+                                c = val;\n+                            }\n+                        }\n+                    }\n+                    addToString(c);\n+                    c = getChar(false);\n+                }\n+\n+                String str = getStringFromBuffer();\n+                this.string = (String)allStrings.intern(str);\n+                return Token.STRING;\n+            }\n+\n+            switch (c) {\n+            case ';': return Token.SEMI;\n+            case '[': return Token.LB;\n+            case ']': return Token.RB;\n+            case '{': return Token.LC;\n+            case '}': return Token.RC;\n+            case '(': return Token.LP;\n+            case ')': return Token.RP;\n+            case ',': return Token.COMMA;\n+            case '?': return Token.HOOK;\n+            case ':':\n+                if (matchChar(':')) {\n+                    return Token.COLONCOLON;\n+                } else {\n+                    return Token.COLON;\n+                }\n+            case '.':\n+                if (matchChar('.')) {\n+                    return Token.DOTDOT;\n+                } else if (matchChar('(')) {\n+                    return Token.DOTQUERY;\n+                } else {\n+                    return Token.DOT;\n+                }\n+\n+            case '|':\n+                if (matchChar('|')) {\n+                    return Token.OR;\n+                } else if (matchChar('=')) {\n+                    return Token.ASSIGN_BITOR;\n+                } else {\n+                    return Token.BITOR;\n+                }\n+\n+            case '^':\n+                if (matchChar('=')) {\n+                    return Token.ASSIGN_BITXOR;\n+                } else {\n+                    return Token.BITXOR;\n+                }\n+\n+            case '&':\n+                if (matchChar('&')) {\n+                    return Token.AND;\n+                } else if (matchChar('=')) {\n+                    return Token.ASSIGN_BITAND;\n+                } else {\n+                    return Token.BITAND;\n+                }\n+\n+            case '=':\n+                if (matchChar('=')) {\n+                    if (matchChar('=')) {\n+                        return Token.SHEQ;\n+                    } else {\n+                        return Token.EQ;\n+                    }\n+                } else {\n+                    return Token.ASSIGN;\n+                }\n+\n+            case '!':\n+                if (matchChar('=')) {\n+                    if (matchChar('=')) {\n+                        return Token.SHNE;\n+                    } else {\n+                        return Token.NE;\n+                    }\n+                } else {\n+                    return Token.NOT;\n+                }\n+\n+            case '<':\n+                /* NB:treat HTML begin-comment as comment-till-eol */\n+                if (matchChar('!')) {\n+                    if (matchChar('-')) {\n+                        if (matchChar('-')) {\n+                            skipLine();\n+                            continue retry;\n+                        }\n+                        ungetCharIgnoreLineEnd('-');\n+                    }\n+                    ungetCharIgnoreLineEnd('!');\n+                }\n+                if (matchChar('<')) {\n+                    if (matchChar('=')) {\n+                        return Token.ASSIGN_LSH;\n+                    } else {\n+                        return Token.LSH;\n+                    }\n+                } else {\n+                    if (matchChar('=')) {\n+                        return Token.LE;\n+                    } else {\n+                        return Token.LT;\n+                    }\n+                }\n+\n+            case '>':\n+                if (matchChar('>')) {\n+                    if (matchChar('>')) {\n+                        if (matchChar('=')) {\n+                            return Token.ASSIGN_URSH;\n+                        } else {\n+                            return Token.URSH;\n+                        }\n+                    } else {\n+                        if (matchChar('=')) {\n+                            return Token.ASSIGN_RSH;\n+                        } else {\n+                            return Token.RSH;\n+                        }\n+                    }\n+                } else {\n+                    if (matchChar('=')) {\n+                        return Token.GE;\n+                    } else {\n+                        return Token.GT;\n+                    }\n+                }\n+\n+            case '*':\n+                if (matchChar('=')) {\n+                    return Token.ASSIGN_MUL;\n+                } else {\n+                    return Token.MUL;\n+                }\n+\n+            case '/':\n+                markCommentStart();\n+                // is it a // comment?\n+                if (matchChar('/')) {\n+                    tokenBeg = cursor - 2;\n+                    skipLine();\n+                    commentType = Token.CommentType.LINE;\n+                    return Token.COMMENT;\n+                }\n+                // is it a /* or /** comment?\n+                if (matchChar('*')) {\n+                    boolean lookForSlash = false;\n+                    tokenBeg = cursor - 2;\n+                    if (matchChar('*')) {\n+                        lookForSlash = true;\n+                        commentType = Token.CommentType.JSDOC;\n+                    } else {\n+                        commentType = Token.CommentType.BLOCK;\n+                    }\n+                    for (;;) {\n+                        c = getChar();\n+                        if (c == EOF_CHAR) {\n+                            tokenEnd = cursor - 1;\n+                            parser.addError(\"msg.unterminated.comment\");\n+                            return Token.COMMENT;\n+                        } else if (c == '*') {\n+                            lookForSlash = true;\n+                        } else if (c == '/') {\n+                            if (lookForSlash) {\n+                                tokenEnd = cursor;\n+                                return Token.COMMENT;\n+                            }\n+                        } else {\n+                            lookForSlash = false;\n+                            tokenEnd = cursor;\n+                        }\n+                    }\n+                }\n+\n+                if (matchChar('=')) {\n+                    return Token.ASSIGN_DIV;\n+                } else {\n+                    return Token.DIV;\n+                }\n+\n+            case '%':\n+                if (matchChar('=')) {\n+                    return Token.ASSIGN_MOD;\n+                } else {\n+                    return Token.MOD;\n+                }\n+\n+            case '~':\n+                return Token.BITNOT;\n+\n+            case '+':\n+                if (matchChar('=')) {\n+                    return Token.ASSIGN_ADD;\n+                } else if (matchChar('+')) {\n+                    return Token.INC;\n+                } else {\n+                    return Token.ADD;\n+                }\n+\n+            case '-':\n+                if (matchChar('=')) {\n+                    c = Token.ASSIGN_SUB;\n+                } else if (matchChar('-')) {\n+                    if (!dirtyLine) {\n+                        // treat HTML end-comment after possible whitespace\n+                        // after line start as comment-until-eol\n+                        if (matchChar('>')) {\n+                            markCommentStart(\"--\");\n+                            skipLine();\n+                            commentType = Token.CommentType.HTML;\n+                            return Token.COMMENT;\n+                        }\n+                    }\n+                    c = Token.DEC;\n+                } else {\n+                    c = Token.SUB;\n+                }\n+                dirtyLine = true;\n+                return c;\n+\n+            default:\n+                parser.addError(\"msg.illegal.character\");\n+                return Token.ERROR;\n+            }\n+        }\n+    }\n+\n+    private static boolean isAlpha(int c)\n+    {\n+        // Use 'Z' < 'a'\n+        if (c <= 'Z') {\n+            return 'A' <= c;\n+        } else {\n+            return 'a' <= c && c <= 'z';\n+        }\n+    }\n+\n+    static boolean isDigit(int c)\n+    {\n+        return '0' <= c && c <= '9';\n+    }\n+\n+    /* As defined in ECMA.  jsscan.c uses C isspace() (which allows\n+     * \\v, I think.)  note that code in getChar() implicitly accepts\n+     * '\\r' == \\u000D as well.\n+     */\n+    static boolean isJSSpace(int c)\n+    {\n+        if (c <= 127) {\n+            return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;\n+        } else {\n+            return c == 0xA0 || c == BYTE_ORDER_MARK\n+                || Character.getType((char)c) == Character.SPACE_SEPARATOR;\n+        }\n+    }\n+\n+    private static boolean isJSFormatChar(int c)\n+    {\n+        return c > 127 && Character.getType((char)c) == Character.FORMAT;\n+    }\n+\n+    /**\n+     * Parser calls the method when it gets / or /= in literal context.\n+     */\n+    void readRegExp(int startToken)\n+        throws IOException\n+    {\n+        int start = tokenBeg;\n+        stringBufferTop = 0;\n+        if (startToken == Token.ASSIGN_DIV) {\n+            // Miss-scanned /=\n+            addToString('=');\n+        } else {\n+            if (startToken != Token.DIV) Kit.codeBug();\n+        }\n+\n+        boolean inCharSet = false; // true if inside a '['..']' pair\n+        int c;\n+        while ((c = getChar()) != '/' || inCharSet) {\n+            if (c == '\\n' || c == EOF_CHAR) {\n+                ungetChar(c);\n+                tokenEnd = cursor - 1;\n+                this.string = new String(stringBuffer, 0, stringBufferTop);\n+                parser.reportError(\"msg.unterminated.re.lit\");\n+                return;\n+            }\n+            if (c == '\\\\') {\n+                addToString(c);\n+                c = getChar();\n+            } else if (c == '[') {\n+                inCharSet = true;\n+            } else if (c == ']') {\n+                inCharSet = false;\n+            }\n+            addToString(c);\n+        }\n+        int reEnd = stringBufferTop;\n+\n+        while (true) {\n+            if (matchChar('g'))\n+                addToString('g');\n+            else if (matchChar('i'))\n+                addToString('i');\n+            else if (matchChar('m'))\n+                addToString('m');\n+            else if (matchChar('y'))  // FireFox 3\n+                addToString('y');\n+            else\n+                break;\n+        }\n+        tokenEnd = start + stringBufferTop + 2;  // include slashes\n+\n+        if (isAlpha(peekChar())) {\n+            parser.reportError(\"msg.invalid.re.flag\");\n+        }\n+\n+        this.string = new String(stringBuffer, 0, reEnd);\n+        this.regExpFlags = new String(stringBuffer, reEnd,\n+                                      stringBufferTop - reEnd);\n+    }\n+\n+    String readAndClearRegExpFlags() {\n+        String flags = this.regExpFlags;\n+        this.regExpFlags = null;\n+        return flags;\n+    }\n+\n+    boolean isXMLAttribute()\n+    {\n+        return xmlIsAttribute;\n+    }\n+\n+    int getFirstXMLToken() throws IOException\n+    {\n+        xmlOpenTagsCount = 0;\n+        xmlIsAttribute = false;\n+        xmlIsTagContent = false;\n+        if (!canUngetChar())\n+            return Token.ERROR;\n+        ungetChar('<');\n+        return getNextXMLToken();\n+    }\n+\n+    int getNextXMLToken() throws IOException\n+    {\n+        tokenBeg = cursor;\n+        stringBufferTop = 0; // remember the XML\n+\n+        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {\n+            if (xmlIsTagContent) {\n+                switch (c) {\n+                case '>':\n+                    addToString(c);\n+                    xmlIsTagContent = false;\n+                    xmlIsAttribute = false;\n+                    break;\n+                case '/':\n+                    addToString(c);\n+                    if (peekChar() == '>') {\n+                        c = getChar();\n+                        addToString(c);\n+                        xmlIsTagContent = false;\n+                        xmlOpenTagsCount--;\n+                    }\n+                    break;\n+                case '{':\n+                    ungetChar(c);\n+                    this.string = getStringFromBuffer();\n+                    return Token.XML;\n+                case '\\'':\n+                case '\"':\n+                    addToString(c);\n+                    if (!readQuotedString(c)) return Token.ERROR;\n+                    break;\n+                case '=':\n+                    addToString(c);\n+                    xmlIsAttribute = true;\n+                    break;\n+                case ' ':\n+                case '\\t':\n+                case '\\r':\n+                case '\\n':\n+                    addToString(c);\n+                    break;\n+                default:\n+                    addToString(c);\n+                    xmlIsAttribute = false;\n+                    break;\n+                }\n+\n+                if (!xmlIsTagContent && xmlOpenTagsCount == 0) {\n+                    this.string = getStringFromBuffer();\n+                    return Token.XMLEND;\n+                }\n+            } else {\n+                switch (c) {\n+                case '<':\n+                    addToString(c);\n+                    c = peekChar();\n+                    switch (c) {\n+                    case '!':\n+                        c = getChar(); // Skip !\n+                        addToString(c);\n+                        c = peekChar();\n+                        switch (c) {\n+                        case '-':\n+                            c = getChar(); // Skip -\n+                            addToString(c);\n+                            c = getChar();\n+                            if (c == '-') {\n+                                addToString(c);\n+                                if(!readXmlComment()) return Token.ERROR;\n+                            } else {\n+                                // throw away the string in progress\n+                                stringBufferTop = 0;\n+                                this.string = null;\n+                                parser.addError(\"msg.XML.bad.form\");\n+                                return Token.ERROR;\n+                            }\n+                            break;\n+                        case '[':\n+                            c = getChar(); // Skip [\n+                            addToString(c);\n+                            if (getChar() == 'C' &&\n+                                getChar() == 'D' &&\n+                                getChar() == 'A' &&\n+                                getChar() == 'T' &&\n+                                getChar() == 'A' &&\n+                                getChar() == '[')\n+                            {\n+                                addToString('C');\n+                                addToString('D');\n+                                addToString('A');\n+                                addToString('T');\n+                                addToString('A');\n+                                addToString('[');\n+                                if (!readCDATA()) return Token.ERROR;\n+\n+                            } else {\n+                                // throw away the string in progress\n+                                stringBufferTop = 0;\n+                                this.string = null;\n+                                parser.addError(\"msg.XML.bad.form\");\n+                                return Token.ERROR;\n+                            }\n+                            break;\n+                        default:\n+                            if(!readEntity()) return Token.ERROR;\n+                            break;\n+                        }\n+                        break;\n+                    case '?':\n+                        c = getChar(); // Skip ?\n+                        addToString(c);\n+                        if (!readPI()) return Token.ERROR;\n+                        break;\n+                    case '/':\n+                        // End tag\n+                        c = getChar(); // Skip /\n+                        addToString(c);\n+                        if (xmlOpenTagsCount == 0) {\n+                            // throw away the string in progress\n+                            stringBufferTop = 0;\n+                            this.string = null;\n+                            parser.addError(\"msg.XML.bad.form\");\n+                            return Token.ERROR;\n+                        }\n+                        xmlIsTagContent = true;\n+                        xmlOpenTagsCount--;\n+                        break;\n+                    default:\n+                        // Start tag\n+                        xmlIsTagContent = true;\n+                        xmlOpenTagsCount++;\n+                        break;\n+                    }\n+                    break;\n+                case '{':\n+                    ungetChar(c);\n+                    this.string = getStringFromBuffer();\n+                    return Token.XML;\n+                default:\n+                    addToString(c);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        tokenEnd = cursor;\n+        stringBufferTop = 0; // throw away the string in progress\n+        this.string = null;\n+        parser.addError(\"msg.XML.bad.form\");\n+        return Token.ERROR;\n+    }\n+\n+    /**\n+     *\n+     */\n+    private boolean readQuotedString(int quote) throws IOException\n+    {\n+        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {\n+            addToString(c);\n+            if (c == quote) return true;\n+        }\n+\n+        stringBufferTop = 0; // throw away the string in progress\n+        this.string = null;\n+        parser.addError(\"msg.XML.bad.form\");\n+        return false;\n+    }\n+\n+    /**\n+     *\n+     */\n+    private boolean readXmlComment() throws IOException\n+    {\n+        for (int c = getChar(); c != EOF_CHAR;) {\n+            addToString(c);\n+            if (c == '-' && peekChar() == '-') {\n+                c = getChar();\n+                addToString(c);\n+                if (peekChar() == '>') {\n+                    c = getChar(); // Skip >\n+                    addToString(c);\n+                    return true;\n+                } else {\n+                    continue;\n+                }\n+            }\n+            c = getChar();\n+        }\n+\n+        stringBufferTop = 0; // throw away the string in progress\n+        this.string = null;\n+        parser.addError(\"msg.XML.bad.form\");\n+        return false;\n+    }\n+\n+    /**\n+     *\n+     */\n+    private boolean readCDATA() throws IOException\n+    {\n+        for (int c = getChar(); c != EOF_CHAR;) {\n+            addToString(c);\n+            if (c == ']' && peekChar() == ']') {\n+                c = getChar();\n+                addToString(c);\n+                if (peekChar() == '>') {\n+                    c = getChar(); // Skip >\n+                    addToString(c);\n+                    return true;\n+                } else {\n+                    continue;\n+                }\n+            }\n+            c = getChar();\n+        }\n+\n+        stringBufferTop = 0; // throw away the string in progress\n+        this.string = null;\n+        parser.addError(\"msg.XML.bad.form\");\n+        return false;\n+    }\n+\n+    /**\n+     *\n+     */\n+    private boolean readEntity() throws IOException\n+    {\n+        int declTags = 1;\n+        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {\n+            addToString(c);\n+            switch (c) {\n+            case '<':\n+                declTags++;\n+                break;\n+            case '>':\n+                declTags--;\n+                if (declTags == 0) return true;\n+                break;\n+            }\n+        }\n+\n+        stringBufferTop = 0; // throw away the string in progress\n+        this.string = null;\n+        parser.addError(\"msg.XML.bad.form\");\n+        return false;\n+    }\n+\n+    /**\n+     *\n+     */\n+    private boolean readPI() throws IOException\n+    {\n+        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {\n+            addToString(c);\n+            if (c == '?' && peekChar() == '>') {\n+                c = getChar(); // Skip >\n+                addToString(c);\n+                return true;\n+            }\n+        }\n+\n+        stringBufferTop = 0; // throw away the string in progress\n+        this.string = null;\n+        parser.addError(\"msg.XML.bad.form\");\n+        return false;\n+    }\n+\n+    private String getStringFromBuffer()\n+    {\n+        tokenEnd = cursor;\n+        return new String(stringBuffer, 0, stringBufferTop);\n+    }\n+\n+    private void addToString(int c)\n+    {\n+        int N = stringBufferTop;\n+        if (N == stringBuffer.length) {\n+            char[] tmp = new char[stringBuffer.length * 2];\n+            System.arraycopy(stringBuffer, 0, tmp, 0, N);\n+            stringBuffer = tmp;\n+        }\n+        stringBuffer[N] = (char)c;\n+        stringBufferTop = N + 1;\n+    }\n+\n+    private boolean canUngetChar() {\n+        return ungetCursor == 0 || ungetBuffer[ungetCursor - 1] != '\\n';\n+    }\n+\n+    private void ungetChar(int c)\n+    {\n+        // can not unread past across line boundary\n+        if (ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\\n')\n+            Kit.codeBug();\n+        ungetBuffer[ungetCursor++] = c;\n+        cursor--;\n+    }\n+\n+    private boolean matchChar(int test) throws IOException\n+    {\n+        int c = getCharIgnoreLineEnd();\n+        if (c == test) {\n+            tokenEnd = cursor;\n+            return true;\n+        } else {\n+            ungetCharIgnoreLineEnd(c);\n+            return false;\n+        }\n+    }\n+\n+    private int peekChar() throws IOException\n+    {\n+        int c = getChar();\n+        ungetChar(c);\n+        return c;\n+    }\n+\n+    private int getChar() throws IOException\n+    {\n+        return getChar(true);\n+    }\n+\n+    private int getChar(boolean skipFormattingChars) throws IOException\n+    {\n+        if (ungetCursor != 0) {\n+            cursor++;\n+            return ungetBuffer[--ungetCursor];\n+        }\n+\n+        for(;;) {\n+            int c;\n+            if (sourceString != null) {\n+                if (sourceCursor == sourceEnd) {\n+                    hitEOF = true;\n+                    return EOF_CHAR;\n+                }\n+                cursor++;\n+                c = sourceString.charAt(sourceCursor++);\n+            } else {\n+                if (sourceCursor == sourceEnd) {\n+                    if (!fillSourceBuffer()) {\n+                        hitEOF = true;\n+                        return EOF_CHAR;\n+                    }\n+                }\n+                cursor++;\n+                c = sourceBuffer[sourceCursor++];\n+            }\n+\n+            if (lineEndChar >= 0) {\n+                if (lineEndChar == '\\r' && c == '\\n') {\n+                    lineEndChar = '\\n';\n+                    continue;\n+                }\n+                lineEndChar = -1;\n+                lineStart = sourceCursor - 1;\n+                lineno++;\n+            }\n+\n+            if (c <= 127) {\n+                if (c == '\\n' || c == '\\r') {\n+                    lineEndChar = c;\n+                    c = '\\n';\n+                }\n+            } else {\n+                if (c == BYTE_ORDER_MARK) return c; // BOM is considered whitespace\n+                if (skipFormattingChars && isJSFormatChar(c)) {\n+                    continue;\n+                }\n+                if (ScriptRuntime.isJSLineTerminator(c)) {\n+                    lineEndChar = c;\n+                    c = '\\n';\n+                }\n+            }\n+            return c;\n+        }\n+    }\n+\n+    private int getCharIgnoreLineEnd() throws IOException\n+    {\n+        if (ungetCursor != 0) {\n+            cursor++;\n+            return ungetBuffer[--ungetCursor];\n+        }\n+\n+        for(;;) {\n+            int c;\n+            if (sourceString != null) {\n+                if (sourceCursor == sourceEnd) {\n+                    hitEOF = true;\n+                    return EOF_CHAR;\n+                }\n+                cursor++;\n+                c = sourceString.charAt(sourceCursor++);\n+            } else {\n+                if (sourceCursor == sourceEnd) {\n+                    if (!fillSourceBuffer()) {\n+                        hitEOF = true;\n+                        return EOF_CHAR;\n+                    }\n+                }\n+                cursor++;\n+                c = sourceBuffer[sourceCursor++];\n+            }\n+\n+            if (c <= 127) {\n+                if (c == '\\n' || c == '\\r') {\n+                    lineEndChar = c;\n+                    c = '\\n';\n+                }\n+            } else {\n+                if (c == BYTE_ORDER_MARK) return c; // BOM is considered whitespace\n+                if (isJSFormatChar(c)) {\n+                    continue;\n+                }\n+                if (ScriptRuntime.isJSLineTerminator(c)) {\n+                    lineEndChar = c;\n+                    c = '\\n';\n+                }\n+            }\n+            return c;\n+        }\n+    }\n+\n+    private void ungetCharIgnoreLineEnd(int c)\n+    {\n+        ungetBuffer[ungetCursor++] = c;\n+        cursor--;\n+    }\n+\n+    private void skipLine() throws IOException\n+    {\n+        // skip to end of line\n+        int c;\n+        while ((c = getChar()) != EOF_CHAR && c != '\\n') { }\n+        ungetChar(c);\n+        tokenEnd = cursor;\n+    }\n+\n+    /**\n+     * Returns the offset into the current line.\n+     */\n+    final int getOffset()\n+    {\n+        int n = sourceCursor - lineStart;\n+        if (lineEndChar >= 0) { --n; }\n+        return n;\n+    }\n+\n+    final String getLine()\n+    {\n+        if (sourceString != null) {\n+            // String case\n+            int lineEnd = sourceCursor;\n+            if (lineEndChar >= 0) {\n+                --lineEnd;\n+            } else {\n+                for (; lineEnd != sourceEnd; ++lineEnd) {\n+                    int c = sourceString.charAt(lineEnd);\n+                    if (ScriptRuntime.isJSLineTerminator(c)) {\n+                        break;\n+                    }\n+                }\n+            }\n+            return sourceString.substring(lineStart, lineEnd);\n+        } else {\n+            // Reader case\n+            int lineLength = sourceCursor - lineStart;\n+            if (lineEndChar >= 0) {\n+                --lineLength;\n+            } else {\n+                // Read until the end of line\n+                for (;; ++lineLength) {\n+                    int i = lineStart + lineLength;\n+                    if (i == sourceEnd) {\n+                        try {\n+                            if (!fillSourceBuffer()) { break; }\n+                        } catch (IOException ioe) {\n+                            // ignore it, we're already displaying an error...\n+                            break;\n+                        }\n+                        // i recalculuation as fillSourceBuffer can move saved\n+                        // line buffer and change lineStart\n+                        i = lineStart + lineLength;\n+                    }\n+                    int c = sourceBuffer[i];\n+                    if (ScriptRuntime.isJSLineTerminator(c)) {\n+                        break;\n+                    }\n+                }\n+            }\n+            return new String(sourceBuffer, lineStart, lineLength);\n+        }\n+    }\n+\n+    private boolean fillSourceBuffer() throws IOException\n+    {\n+        if (sourceString != null) Kit.codeBug();\n+        if (sourceEnd == sourceBuffer.length) {\n+            if (lineStart != 0 && !isMarkingComment()) {\n+                System.arraycopy(sourceBuffer, lineStart, sourceBuffer, 0,\n+                                 sourceEnd - lineStart);\n+                sourceEnd -= lineStart;\n+                sourceCursor -= lineStart;\n+                lineStart = 0;\n+            } else {\n+                char[] tmp = new char[sourceBuffer.length * 2];\n+                System.arraycopy(sourceBuffer, 0, tmp, 0, sourceEnd);\n+                sourceBuffer = tmp;\n+            }\n+        }\n+        int n = sourceReader.read(sourceBuffer, sourceEnd,\n+                                  sourceBuffer.length - sourceEnd);\n+        if (n < 0) {\n+            return false;\n+        }\n+        sourceEnd += n;\n+        return true;\n+    }\n+\n+    /**\n+     * Return the current position of the scanner cursor.\n+     */\n+    public int getCursor() {\n+        return cursor;\n+    }\n+\n+    /**\n+     * Return the absolute source offset of the last scanned token.\n+     */\n+    public int getTokenBeg() {\n+        return tokenBeg;\n+    }\n+\n+    /**\n+     * Return the absolute source end-offset of the last scanned token.\n+     */\n+    public int getTokenEnd() {\n+        return tokenEnd;\n+    }\n+\n+    /**\n+     * Return tokenEnd - tokenBeg\n+     */\n+    public int getTokenLength() {\n+        return tokenEnd - tokenBeg;\n+    }\n+\n+    /**\n+     * Return the type of the last scanned comment.\n+     * @return type of last scanned comment, or 0 if none have been scanned.\n+     */\n+    public Token.CommentType getCommentType() {\n+        return commentType;\n+    }\n+\n+    private void markCommentStart() {\n+        markCommentStart(\"\");\n+    }\n+\n+    private void markCommentStart(String prefix) {\n+        if (parser.compilerEnv.isRecordingComments() && sourceReader != null) {\n+            commentPrefix = prefix;\n+            commentCursor = sourceCursor - 1;\n+        }\n+    }\n+\n+    private boolean isMarkingComment() {\n+        return commentCursor != -1;\n+    }\n+\n+    final String getAndResetCurrentComment() {\n+        if (sourceString != null) {\n+            if (isMarkingComment()) Kit.codeBug();\n+            return sourceString.substring(tokenBeg, tokenEnd);\n+        } else {\n+            if (!isMarkingComment()) Kit.codeBug();\n+            StringBuilder comment = new StringBuilder(commentPrefix);\n+            comment.append(sourceBuffer, commentCursor,\n+                getTokenLength() - commentPrefix.length());\n+            commentCursor = -1;\n+            return comment.toString();\n+        }\n+    }\n+\n+    private String convertLastCharToHex(String str) {\n+      int lastIndex = str.length()-1;\n+      StringBuffer buf = new StringBuffer(\n+          str.substring(0, lastIndex));\n+      buf.append(\"\\\\u\");\n+      String hexCode = Integer.toHexString(str.charAt(lastIndex));\n+      for (int i = 0; i < 4-hexCode.length(); ++i) {\n+        buf.append('0');\n+      }\n+      buf.append(hexCode);\n+      return buf.toString();\n+    }\n+\n+    // stuff other than whitespace since start of line\n+    private boolean dirtyLine;\n+\n+    String regExpFlags;\n+\n+    // Set this to an initial non-null value so that the Parser has\n+    // something to retrieve even if an error has occurred and no\n+    // string is found.  Fosters one class of error, but saves lots of\n+    // code.\n+    private String string = \"\";\n+    private double number;\n+    private boolean isOctal;\n+\n+    // delimiter for last string literal scanned\n+    private int quoteChar;\n+\n+    private char[] stringBuffer = new char[128];\n+    private int stringBufferTop;\n+    private ObjToIntMap allStrings = new ObjToIntMap(50);\n+\n+    // Room to backtrace from to < on failed match of the last - in <!--\n+    private final int[] ungetBuffer = new int[3];\n+    private int ungetCursor;\n+\n+    private boolean hitEOF = false;\n+\n+    private int lineStart = 0;\n+    private int lineEndChar = -1;\n+    int lineno;\n+\n+    private String sourceString;\n+    private Reader sourceReader;\n+    private char[] sourceBuffer;\n+    private int sourceEnd;\n+\n+    // sourceCursor is an index into a small buffer that keeps a\n+    // sliding window of the source stream.\n+    int sourceCursor;\n+\n+    // cursor is a monotonically increasing index into the original\n+    // source stream, tracking exactly how far scanning has progressed.\n+    // Its value is the index of the next character to be scanned.\n+    int cursor;\n+\n+    // Record start and end positions of last scanned token.\n+    int tokenBeg;\n+    int tokenEnd;\n+\n+    // Type of last comment scanned.\n+    Token.CommentType commentType;\n+\n+    // for xml tokenizer\n+    private boolean xmlIsAttribute;\n+    private boolean xmlIsTagContent;\n+    private int xmlOpenTagsCount;\n+\n+    private Parser parser;\n+\n+    private String commentPrefix = \"\";\n+    private int commentCursor = -1;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/UintMap.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.Serializable;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+/**\n+ * Map to associate non-negative integers to objects or integers.\n+ * The map does not synchronize any of its operation, so either use\n+ * it from a single thread or do own synchronization or perform all mutation\n+ * operations on one thread before passing the map to others.\n+ *\n+ *\n+ */\n+\n+public class UintMap implements Serializable\n+{\n+    static final long serialVersionUID = 4242698212885848444L;\n+\n+// Map implementation via hashtable,\n+// follows \"The Art of Computer Programming\" by Donald E. Knuth\n+\n+    public UintMap() {\n+        this(4);\n+    }\n+\n+    public UintMap(int initialCapacity) {\n+        if (initialCapacity < 0) Kit.codeBug();\n+        // Table grow when number of stored keys >= 3/4 of max capacity\n+        int minimalCapacity = initialCapacity * 4 / 3;\n+        int i;\n+        for (i = 2; (1 << i) < minimalCapacity; ++i) { }\n+        power = i;\n+        if (check && power < 2) Kit.codeBug();\n+    }\n+\n+    public boolean isEmpty() {\n+        return keyCount == 0;\n+    }\n+\n+    public int size() {\n+        return keyCount;\n+    }\n+\n+    public boolean has(int key) {\n+        if (key < 0) Kit.codeBug();\n+        return 0 <= findIndex(key);\n+    }\n+\n+    /**\n+     * Get object value assigned with key.\n+     * @return key object value or null if key is absent\n+     */\n+    public Object getObject(int key) {\n+        if (key < 0) Kit.codeBug();\n+        if (values != null) {\n+            int index = findIndex(key);\n+            if (0 <= index) {\n+                return values[index];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get integer value assigned with key.\n+     * @return key integer value or defaultValue if key is absent\n+     */\n+    public int getInt(int key, int defaultValue) {\n+        if (key < 0) Kit.codeBug();\n+        int index = findIndex(key);\n+        if (0 <= index) {\n+            if (ivaluesShift != 0) {\n+                return keys[ivaluesShift + index];\n+            }\n+            return 0;\n+        }\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * Get integer value assigned with key.\n+     * @return key integer value or defaultValue if key does not exist or does\n+     * not have int value\n+     * @throws RuntimeException if key does not exist\n+     */\n+    public int getExistingInt(int key) {\n+        if (key < 0) Kit.codeBug();\n+        int index = findIndex(key);\n+        if (0 <= index) {\n+            if (ivaluesShift != 0) {\n+                return keys[ivaluesShift + index];\n+            }\n+            return 0;\n+        }\n+        // Key must exist\n+        Kit.codeBug();\n+        return 0;\n+    }\n+\n+    /**\n+     * Set object value of the key.\n+     * If key does not exist, also set its int value to 0.\n+     */\n+    public void put(int key, Object value) {\n+        if (key < 0) Kit.codeBug();\n+        int index = ensureIndex(key, false);\n+        if (values == null) {\n+            values = new Object[1 << power];\n+        }\n+        values[index] = value;\n+    }\n+\n+    /**\n+     * Set int value of the key.\n+     * If key does not exist, also set its object value to null.\n+     */\n+    public void put(int key, int value) {\n+        if (key < 0) Kit.codeBug();\n+        int index = ensureIndex(key, true);\n+        if (ivaluesShift == 0) {\n+            int N = 1 << power;\n+            // keys.length can be N * 2 after clear which set ivaluesShift to 0\n+            if (keys.length != N * 2) {\n+                int[] tmp = new int[N * 2];\n+                System.arraycopy(keys, 0, tmp, 0, N);\n+                keys = tmp;\n+            }\n+            ivaluesShift = N;\n+        }\n+        keys[ivaluesShift + index] = value;\n+    }\n+\n+    public void remove(int key) {\n+        if (key < 0) Kit.codeBug();\n+        int index = findIndex(key);\n+        if (0 <= index) {\n+            keys[index] = DELETED;\n+            --keyCount;\n+            // Allow to GC value and make sure that new key with the deleted\n+            // slot shall get proper default values\n+            if (values != null) { values[index] = null; }\n+            if (ivaluesShift != 0) { keys[ivaluesShift + index] = 0; }\n+        }\n+    }\n+\n+    public void clear() {\n+        int N = 1 << power;\n+        if (keys != null) {\n+            for (int i = 0; i != N; ++i) {\n+                keys[i] = EMPTY;\n+            }\n+            if (values != null) {\n+                for (int i = 0; i != N; ++i) {\n+                    values[i] = null;\n+                }\n+            }\n+        }\n+        ivaluesShift = 0;\n+        keyCount = 0;\n+        occupiedCount = 0;\n+    }\n+\n+    /** Return array of present keys */\n+    public int[] getKeys() {\n+        int[] keys = this.keys;\n+        int n = keyCount;\n+        int[] result = new int[n];\n+        for (int i = 0; n != 0; ++i) {\n+            int entry = keys[i];\n+            if (entry != EMPTY && entry != DELETED) {\n+                result[--n] = entry;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private static int tableLookupStep(int fraction, int mask, int power) {\n+        int shift = 32 - 2 * power;\n+        if (shift >= 0) {\n+            return ((fraction >>> shift) & mask) | 1;\n+        }\n+        else {\n+            return (fraction & (mask >>> -shift)) | 1;\n+        }\n+    }\n+\n+    private int findIndex(int key) {\n+        int[] keys = this.keys;\n+        if (keys != null) {\n+            int fraction = key * A;\n+            int index = fraction >>> (32 - power);\n+            int entry = keys[index];\n+            if (entry == key) { return index; }\n+            if (entry != EMPTY) {\n+                // Search in table after first failed attempt\n+                int mask = (1 << power) - 1;\n+                int step = tableLookupStep(fraction, mask, power);\n+                int n = 0;\n+                do {\n+                    if (check) {\n+                        if (n >= occupiedCount) Kit.codeBug();\n+                        ++n;\n+                    }\n+                    index = (index + step) & mask;\n+                    entry = keys[index];\n+                    if (entry == key) { return index; }\n+                } while (entry != EMPTY);\n+            }\n+        }\n+        return -1;\n+    }\n+\n+// Insert key that is not present to table without deleted entries\n+// and enough free space\n+    private int insertNewKey(int key) {\n+        if (check && occupiedCount != keyCount) Kit.codeBug();\n+        if (check && keyCount == 1 << power) Kit.codeBug();\n+        int[] keys = this.keys;\n+        int fraction = key * A;\n+        int index = fraction >>> (32 - power);\n+        if (keys[index] != EMPTY) {\n+            int mask = (1 << power) - 1;\n+            int step = tableLookupStep(fraction, mask, power);\n+            int firstIndex = index;\n+            do {\n+                if (check && keys[index] == DELETED) Kit.codeBug();\n+                index = (index + step) & mask;\n+                if (check && firstIndex == index) Kit.codeBug();\n+            } while (keys[index] != EMPTY);\n+        }\n+        keys[index] = key;\n+        ++occupiedCount;\n+        ++keyCount;\n+        return index;\n+    }\n+\n+    private void rehashTable(boolean ensureIntSpace) {\n+        if (keys != null) {\n+            // Check if removing deleted entries would free enough space\n+            if (keyCount * 2 >= occupiedCount) {\n+                // Need to grow: less then half of deleted entries\n+                ++power;\n+            }\n+        }\n+        int N = 1 << power;\n+        int[] old = keys;\n+        int oldShift = ivaluesShift;\n+        if (oldShift == 0 && !ensureIntSpace) {\n+            keys = new int[N];\n+        }\n+        else {\n+            ivaluesShift = N; keys = new int[N * 2];\n+        }\n+        for (int i = 0; i != N; ++i) { keys[i] = EMPTY; }\n+\n+        Object[] oldValues = values;\n+        if (oldValues != null) { values = new Object[N]; }\n+\n+        int oldCount = keyCount;\n+        occupiedCount = 0;\n+        if (oldCount != 0) {\n+            keyCount = 0;\n+            for (int i = 0, remaining = oldCount; remaining != 0; ++i) {\n+                int key = old[i];\n+                if (key != EMPTY && key != DELETED) {\n+                    int index = insertNewKey(key);\n+                    if (oldValues != null) {\n+                        values[index] = oldValues[i];\n+                    }\n+                    if (oldShift != 0) {\n+                        keys[ivaluesShift + index] = old[oldShift + i];\n+                    }\n+                    --remaining;\n+                }\n+            }\n+        }\n+    }\n+\n+// Ensure key index creating one if necessary\n+    private int ensureIndex(int key, boolean intType) {\n+        int index = -1;\n+        int firstDeleted = -1;\n+        int[] keys = this.keys;\n+        if (keys != null) {\n+            int fraction = key * A;\n+            index = fraction >>> (32 - power);\n+            int entry = keys[index];\n+            if (entry == key) { return index; }\n+            if (entry != EMPTY) {\n+                if (entry == DELETED) { firstDeleted = index; }\n+                // Search in table after first failed attempt\n+                int mask = (1 << power) - 1;\n+                int step = tableLookupStep(fraction, mask, power);\n+                int n = 0;\n+                do {\n+                    if (check) {\n+                        if (n >= occupiedCount) Kit.codeBug();\n+                        ++n;\n+                    }\n+                    index = (index + step) & mask;\n+                    entry = keys[index];\n+                    if (entry == key) { return index; }\n+                    if (entry == DELETED && firstDeleted < 0) {\n+                        firstDeleted = index;\n+                    }\n+                } while (entry != EMPTY);\n+            }\n+        }\n+        // Inserting of new key\n+        if (check && keys != null && keys[index] != EMPTY)\n+            Kit.codeBug();\n+        if (firstDeleted >= 0) {\n+            index = firstDeleted;\n+        }\n+        else {\n+            // Need to consume empty entry: check occupation level\n+            if (keys == null || occupiedCount * 4 >= (1 << power) * 3) {\n+                // Too litle unused entries: rehash\n+                rehashTable(intType);\n+                return insertNewKey(key);\n+            }\n+            ++occupiedCount;\n+        }\n+        keys[index] = key;\n+        ++keyCount;\n+        return index;\n+    }\n+\n+    private void writeObject(ObjectOutputStream out)\n+        throws IOException\n+    {\n+        out.defaultWriteObject();\n+\n+        int count = keyCount;\n+        if (count != 0) {\n+            boolean hasIntValues = (ivaluesShift != 0);\n+            boolean hasObjectValues = (values != null);\n+            out.writeBoolean(hasIntValues);\n+            out.writeBoolean(hasObjectValues);\n+\n+            for (int i = 0; count != 0; ++i) {\n+                int key = keys[i];\n+                if (key != EMPTY && key != DELETED) {\n+                    --count;\n+                    out.writeInt(key);\n+                    if (hasIntValues) {\n+                        out.writeInt(keys[ivaluesShift + i]);\n+                    }\n+                    if (hasObjectValues) {\n+                        out.writeObject(values[i]);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException\n+    {\n+        in.defaultReadObject();\n+\n+        int writtenKeyCount = keyCount;\n+        if (writtenKeyCount != 0) {\n+            keyCount = 0;\n+            boolean hasIntValues = in.readBoolean();\n+            boolean hasObjectValues = in.readBoolean();\n+\n+            int N = 1 << power;\n+            if (hasIntValues) {\n+                keys = new int[2 * N];\n+                ivaluesShift = N;\n+            }else {\n+                keys = new int[N];\n+            }\n+            for (int i = 0; i != N; ++i) {\n+                keys[i] = EMPTY;\n+            }\n+            if (hasObjectValues) {\n+                values = new Object[N];\n+            }\n+            for (int i = 0; i != writtenKeyCount; ++i) {\n+                int key = in.readInt();\n+                int index = insertNewKey(key);\n+                if (hasIntValues) {\n+                    int ivalue = in.readInt();\n+                    keys[ivaluesShift + index] = ivalue;\n+                }\n+                if (hasObjectValues) {\n+                    values[index] = in.readObject();\n+                }\n+            }\n+        }\n+    }\n+\n+// A == golden_ratio * (1 << 32) = ((sqrt(5) - 1) / 2) * (1 << 32)\n+// See Knuth etc.\n+    private static final int A = 0x9e3779b9;\n+\n+    private static final int EMPTY = -1;\n+    private static final int DELETED = -2;\n+\n+// Structure of kyes and values arrays (N == 1 << power):\n+// keys[0 <= i < N]: key value or EMPTY or DELETED mark\n+// values[0 <= i < N]: value of key at keys[i]\n+// keys[N <= i < 2N]: int values of keys at keys[i - N]\n+\n+    private transient int[] keys;\n+    private transient Object[] values;\n+\n+    private int power;\n+    private int keyCount;\n+    private transient int occupiedCount; // == keyCount + deleted_count\n+\n+    // If ivaluesShift != 0, keys[ivaluesShift + index] contains integer\n+    // values associated with keys\n+    private transient int ivaluesShift;\n+\n+// If true, enables consitency checks\n+    private static final boolean check = false;\n+\n+/* TEST START\n+\n+    public static void main(String[] args) {\n+        if (!check) {\n+            System.err.println(\"Set check to true and re-run\");\n+            throw new RuntimeException(\"Set check to true and re-run\");\n+        }\n+\n+        UintMap map;\n+        map = new UintMap();\n+        testHash(map, 2);\n+        map = new UintMap();\n+        testHash(map, 10 * 1000);\n+        map = new UintMap(30 * 1000);\n+        testHash(map, 10 * 100);\n+        map.clear();\n+        testHash(map, 4);\n+        map = new UintMap(0);\n+        testHash(map, 10 * 100);\n+    }\n+\n+    private static void testHash(UintMap map, int N) {\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            map.put(i, i);\n+            check(i == map.getInt(i, -1));\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            map.put(i, i);\n+            check(i == map.getInt(i, -1));\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            map.put(i, new Integer(i));\n+            check(-1 == map.getInt(i, -1));\n+            Integer obj = (Integer)map.getObject(i);\n+            check(obj != null && i == obj.intValue());\n+        }\n+\n+        check(map.size() == N);\n+\n+        System.out.print(\".\"); System.out.flush();\n+        int[] keys = map.getKeys();\n+        check(keys.length == N);\n+        for (int i = 0; i != N; ++i) {\n+            int key = keys[i];\n+            check(map.has(key));\n+            check(!map.isIntType(key));\n+            check(map.isObjectType(key));\n+            Integer obj = (Integer) map.getObject(key);\n+            check(obj != null && key == obj.intValue());\n+        }\n+\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            check(-1 == map.getInt(i, -1));\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            map.put(i * i, i);\n+            check(i == map.getInt(i * i, -1));\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            check(i == map.getInt(i * i, -1));\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        for (int i = 0; i != N; ++i) {\n+            map.put(i * i, new Integer(i));\n+            check(-1 == map.getInt(i * i, -1));\n+            map.remove(i * i);\n+            check(!map.has(i * i));\n+            map.put(i * i, i);\n+            check(map.isIntType(i * i));\n+            check(null == map.getObject(i * i));\n+            map.remove(i * i);\n+            check(!map.isObjectType(i * i));\n+            check(!map.isIntType(i * i));\n+        }\n+\n+        int old_size = map.size();\n+        for (int i = 0; i != N; ++i) {\n+            map.remove(i * i);\n+            check(map.size() == old_size);\n+        }\n+\n+        System.out.print(\".\"); System.out.flush();\n+        map.clear();\n+        check(map.size() == 0);\n+        for (int i = 0; i != N; ++i) {\n+            map.put(i * i, i);\n+            map.put(i * i + 1, new Double(i+0.5));\n+        }\n+        checkSameMaps(map, (UintMap)writeAndRead(map));\n+\n+        System.out.print(\".\"); System.out.flush();\n+        map = new UintMap(0);\n+        checkSameMaps(map, (UintMap)writeAndRead(map));\n+        map = new UintMap(1);\n+        checkSameMaps(map, (UintMap)writeAndRead(map));\n+        map = new UintMap(1000);\n+        checkSameMaps(map, (UintMap)writeAndRead(map));\n+\n+        System.out.print(\".\"); System.out.flush();\n+        map = new UintMap(N / 10);\n+        for (int i = 0; i != N; ++i) {\n+            map.put(2*i+1, i);\n+        }\n+        checkSameMaps(map, (UintMap)writeAndRead(map));\n+\n+        System.out.print(\".\"); System.out.flush();\n+        map = new UintMap(N / 10);\n+        for (int i = 0; i != N; ++i) {\n+            map.put(2*i+1, i);\n+        }\n+        for (int i = 0; i != N / 2; ++i) {\n+            map.remove(2*i+1);\n+        }\n+        checkSameMaps(map, (UintMap)writeAndRead(map));\n+\n+        System.out.print(\".\"); System.out.flush();\n+        map = new UintMap();\n+        for (int i = 0; i != N; ++i) {\n+            map.put(2*i+1, new Double(i + 10));\n+        }\n+        for (int i = 0; i != N / 2; ++i) {\n+            map.remove(2*i+1);\n+        }\n+        checkSameMaps(map, (UintMap)writeAndRead(map));\n+\n+        System.out.println(); System.out.flush();\n+\n+    }\n+\n+    private static void checkSameMaps(UintMap map1, UintMap map2) {\n+        check(map1.size() == map2.size());\n+        int[] keys = map1.getKeys();\n+        check(keys.length == map1.size());\n+        for (int i = 0; i != keys.length; ++i) {\n+            int key = keys[i];\n+            check(map2.has(key));\n+            check(map1.isObjectType(key) == map2.isObjectType(key));\n+            check(map1.isIntType(key) == map2.isIntType(key));\n+            Object o1 = map1.getObject(key);\n+            Object o2 = map2.getObject(key);\n+            if (map1.isObjectType(key)) {\n+                check(o1.equals(o2));\n+            }else {\n+                check(map1.getObject(key) == null);\n+                check(map2.getObject(key) == null);\n+            }\n+            if (map1.isIntType(key)) {\n+                check(map1.getExistingInt(key) == map2.getExistingInt(key));\n+            }else {\n+                check(map1.getInt(key, -10) == -10);\n+                check(map1.getInt(key, -11) == -11);\n+                check(map2.getInt(key, -10) == -10);\n+                check(map2.getInt(key, -11) == -11);\n+            }\n+        }\n+    }\n+\n+    private static void check(boolean condition) {\n+        if (!condition) Kit.codeBug();\n+    }\n+\n+    private static Object writeAndRead(Object obj) {\n+        try {\n+            java.io.ByteArrayOutputStream\n+                bos = new java.io.ByteArrayOutputStream();\n+            java.io.ObjectOutputStream\n+                out = new java.io.ObjectOutputStream(bos);\n+            out.writeObject(obj);\n+            out.close();\n+            byte[] data = bos.toByteArray();\n+            java.io.ByteArrayInputStream\n+                bis = new java.io.ByteArrayInputStream(data);\n+            java.io.ObjectInputStream\n+                in = new java.io.ObjectInputStream(bis);\n+            Object result = in.readObject();\n+            in.close();\n+            return result;\n+        }catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new RuntimeException(\"Unexpected\");\n+        }\n+    }\n+\n+// TEST END */\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Undefined.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * This class implements the Undefined value in JavaScript.\n+ */\n+public class Undefined implements Serializable\n+{\n+    static final long serialVersionUID = 9195680630202616767L;\n+\n+    public static final Object instance = new Undefined();\n+\n+    private Undefined()\n+    {\n+    }\n+\n+    public Object readResolve()\n+    {\n+        return instance;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/UniqueTag.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Class instances represent serializable tags to mark special Object values.\n+ * <p>\n+ * Compatibility note: under jdk 1.1 use\n+ * org.mozilla.javascript.serialize.ScriptableInputStream to read serialized\n+ * instances of UniqueTag as under this JDK version the default\n+ * ObjectInputStream would not restore them correctly as it lacks support\n+ * for readResolve method\n+ */\n+public final class UniqueTag implements Serializable\n+{\n+    static final long serialVersionUID = -4320556826714577259L;\n+\n+    private static final int ID_NOT_FOUND    = 1;\n+    private static final int ID_NULL_VALUE   = 2;\n+    private static final int ID_DOUBLE_MARK  = 3;\n+\n+    /**\n+     * Tag to mark non-existing values.\n+     */\n+    public static final UniqueTag\n+        NOT_FOUND = new UniqueTag(ID_NOT_FOUND);\n+\n+    /**\n+     * Tag to distinguish between uninitialized and null values.\n+     */\n+    public static final UniqueTag\n+        NULL_VALUE = new UniqueTag(ID_NULL_VALUE);\n+\n+    /**\n+     * Tag to indicate that a object represents \"double\" with the real value\n+     * stored somewhere else.\n+     */\n+    public static final UniqueTag\n+        DOUBLE_MARK = new UniqueTag(ID_DOUBLE_MARK);\n+\n+    private final int tagId;\n+\n+    private UniqueTag(int tagId)\n+    {\n+        this.tagId = tagId;\n+    }\n+\n+    public Object readResolve()\n+    {\n+        switch (tagId) {\n+          case ID_NOT_FOUND:\n+            return NOT_FOUND;\n+          case ID_NULL_VALUE:\n+            return NULL_VALUE;\n+          case ID_DOUBLE_MARK:\n+            return DOUBLE_MARK;\n+        }\n+        throw new IllegalStateException(String.valueOf(tagId));\n+    }\n+\n+// Overridden for better debug printouts\n+    @Override\n+    public String toString()\n+    {\n+        String name;\n+        switch (tagId) {\n+          case ID_NOT_FOUND:\n+            name = \"NOT_FOUND\";\n+            break;\n+          case ID_NULL_VALUE:\n+            name = \"NULL_VALUE\";\n+            break;\n+          case ID_DOUBLE_MARK:\n+            name = \"DOUBLE_MARK\";\n+            break;\n+          default:\n+            throw Kit.codeBug();\n+        }\n+        return super.toString()+\": \"+name;\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/VMBridge.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Member;\n+import java.util.Iterator;\n+\n+public abstract class VMBridge\n+{\n+\n+    static final VMBridge instance = makeInstance();\n+\n+    private static VMBridge makeInstance()\n+    {\n+        String[] classNames = {\n+            \"org.mozilla.javascript.VMBridge_custom\",\n+            \"org.mozilla.javascript.jdk15.VMBridge_jdk15\",\n+            \"org.mozilla.javascript.jdk13.VMBridge_jdk13\",\n+            \"org.mozilla.javascript.jdk11.VMBridge_jdk11\",\n+        };\n+        for (int i = 0; i != classNames.length; ++i) {\n+            String className = classNames[i];\n+            Class<?> cl = Kit.classOrNull(className);\n+            if (cl != null) {\n+                VMBridge bridge = (VMBridge)Kit.newInstanceOrNull(cl);\n+                if (bridge != null) {\n+                    return bridge;\n+                }\n+            }\n+        }\n+        throw new IllegalStateException(\"Failed to create VMBridge instance\");\n+    }\n+\n+    /**\n+     * Return a helper object to optimize {@link Context} access.\n+     * <p>\n+     * The runtime will pass the resulting helper object to the subsequent\n+     * calls to {@link #getContext(Object contextHelper)} and\n+     * {@link #setContext(Object contextHelper, Context cx)} methods.\n+     * In this way the implementation can use the helper to cache\n+     * information about current thread to make {@link Context} access faster.\n+     */\n+    protected abstract Object getThreadContextHelper();\n+\n+    /**\n+     * Get {@link Context} instance associated with the current thread\n+     * or null if none.\n+     *\n+     * @param contextHelper The result of {@link #getThreadContextHelper()}\n+     *                      called from the current thread.\n+     */\n+    protected abstract Context getContext(Object contextHelper);\n+\n+    /**\n+     * Associate {@link Context} instance with the current thread or remove\n+     * the current association if <tt>cx</tt> is null.\n+     *\n+     * @param contextHelper The result of {@link #getThreadContextHelper()}\n+     *                      called from the current thread.\n+     */\n+    protected abstract void setContext(Object contextHelper, Context cx);\n+\n+    /**\n+     * Return the ClassLoader instance associated with the current thread.\n+     */\n+    protected abstract ClassLoader getCurrentThreadClassLoader();\n+\n+    /**\n+     * In many JVMSs, public methods in private\n+     * classes are not accessible by default (Sun Bug #4071593).\n+     * VMBridge instance should try to workaround that via, for example,\n+     * calling method.setAccessible(true) when it is available.\n+     * The implementation is responsible to catch all possible exceptions\n+     * like SecurityException if the workaround is not available.\n+     *\n+     * @return true if it was possible to make method accessible\n+     *         or false otherwise.\n+     */\n+    protected abstract boolean tryToMakeAccessible(Object accessibleObject);\n+\n+    /**\n+     * Create helper object to create later proxies implementing the specified\n+     * interfaces later. Under JDK 1.3 the implementation can look like:\n+     * <pre>\n+     * return java.lang.reflect.Proxy.getProxyClass(..., interfaces).\n+     *     getConstructor(new Class[] {\n+     *         java.lang.reflect.InvocationHandler.class });\n+     * </pre>\n+     *\n+     * @param interfaces Array with one or more interface class objects.\n+     */\n+    protected Object getInterfaceProxyHelper(ContextFactory cf,\n+                                             Class<?>[] interfaces)\n+    {\n+        throw Context.reportRuntimeError(\n+            \"VMBridge.getInterfaceProxyHelper is not supported\");\n+    }\n+\n+    /**\n+     * Create proxy object for {@link InterfaceAdapter}. The proxy should call\n+     * {@link InterfaceAdapter#invoke(ContextFactory cf,\n+     *                                Object target,\n+     *                                Scriptable topScope,\n+     *                                Method method,\n+     *                                Object[] args)}\n+     * as implementation of interface methods associated with\n+     * <tt>proxyHelper</tt>.\n+     *\n+     * @param proxyHelper The result of the previous call to\n+     *        {@link #getInterfaceProxyHelper(ContextFactory, Class[])}.\n+     */\n+    protected Object newInterfaceProxy(Object proxyHelper,\n+                                       ContextFactory cf,\n+                                       InterfaceAdapter adapter,\n+                                       Object target,\n+                                       Scriptable topScope)\n+    {\n+        throw Context.reportRuntimeError(\n+            \"VMBridge.newInterfaceProxy is not supported\");\n+    }\n+\n+    /**\n+     * Returns whether or not a given member (method or constructor)\n+     * has variable arguments.\n+     * Variable argument methods have only been supported in Java since\n+     * JDK 1.5.\n+     */\n+    protected abstract boolean isVarArgs(Member member);\n+\n+    /**\n+     * If \"obj\" is a java.util.Iterator or a java.lang.Iterable, return a\n+     * wrapping as a JavaScript Iterator. Otherwise, return null.\n+     * This method is in VMBridge since Iterable is a JDK 1.5 addition.\n+     */\n+    public Iterator<?> getJavaIterator(Context cx, Scriptable scope, Object obj) {\n+        if (obj instanceof Wrapper) {\n+            Object unwrapped = ((Wrapper) obj).unwrap();\n+            Iterator<?> iterator = null;\n+            if (unwrapped instanceof Iterator)\n+                iterator = (Iterator<?>) unwrapped;\n+            return iterator;\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/WrapFactory.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Embeddings that wish to provide their own custom wrappings for Java\n+ * objects may extend this class and call\n+ * {@link Context#setWrapFactory(WrapFactory)}\n+ * Once an instance of this class or an extension of this class is enabled\n+ * for a given context (by calling setWrapFactory on that context), Rhino\n+ * will call the methods of this class whenever it needs to wrap a value\n+ * resulting from a call to a Java method or an access to a Java field.\n+ *\n+ * @see org.mozilla.javascript.Context#setWrapFactory(WrapFactory)\n+ * @since 1.5 Release 4\n+ */\n+public class WrapFactory\n+{\n+    /**\n+     * Wrap the object.\n+     * <p>\n+     * The value returned must be one of\n+     * <UL>\n+     * <LI>java.lang.Boolean</LI>\n+     * <LI>java.lang.String</LI>\n+     * <LI>java.lang.Number</LI>\n+     * <LI>org.mozilla.javascript.Scriptable objects</LI>\n+     * <LI>The value returned by Context.getUndefinedValue()</LI>\n+     * <LI>null</LI>\n+     * </UL>\n+     * @param cx the current Context for this thread\n+     * @param scope the scope of the executing script\n+     * @param obj the object to be wrapped. Note it can be null.\n+     * @param staticType type hint. If security restrictions prevent to wrap\n+              object based on its class, staticType will be used instead.\n+     * @return the wrapped value.\n+     */\n+    public Object wrap(Context cx, Scriptable scope,\n+                       Object obj, Class<?> staticType)\n+    {\n+        if (obj == null || obj == Undefined.instance\n+            || obj instanceof Scriptable)\n+        {\n+            return obj;\n+        }\n+        if (staticType != null && staticType.isPrimitive()) {\n+            if (staticType == Void.TYPE)\n+                return Undefined.instance;\n+            if (staticType == Character.TYPE)\n+                return Integer.valueOf(((Character) obj).charValue());\n+            return obj;\n+        }\n+        if (!isJavaPrimitiveWrap()) {\n+            if (obj instanceof String || obj instanceof Number\n+                || obj instanceof Boolean)\n+            {\n+                return obj;\n+            } else if (obj instanceof Character) {\n+                return String.valueOf(((Character)obj).charValue());\n+            }\n+        }\n+        Class<?> cls = obj.getClass();\n+        if (cls.isArray()) {\n+            return NativeJavaArray.wrap(scope, obj);\n+        }\n+        return wrapAsJavaObject(cx, scope, obj, staticType);\n+    }\n+\n+    /**\n+     * Wrap an object newly created by a constructor call.\n+     * @param cx the current Context for this thread\n+     * @param scope the scope of the executing script\n+     * @param obj the object to be wrapped\n+     * @return the wrapped value.\n+     */\n+    public Scriptable wrapNewObject(Context cx, Scriptable scope, Object obj)\n+    {\n+        if (obj instanceof Scriptable) {\n+            return (Scriptable)obj;\n+        }\n+        Class<?> cls = obj.getClass();\n+        if (cls.isArray()) {\n+            return NativeJavaArray.wrap(scope, obj);\n+        }\n+        return wrapAsJavaObject(cx, scope, obj, null);\n+    }\n+\n+    /**\n+     * Wrap Java object as Scriptable instance to allow full access to its\n+     * methods and fields from JavaScript.\n+     * <p>\n+     * {@link #wrap(Context, Scriptable, Object, Class)} and\n+     * {@link #wrapNewObject(Context, Scriptable, Object)} call this method\n+     * when they can not convert <tt>javaObject</tt> to JavaScript primitive\n+     * value or JavaScript array.\n+     * <p>\n+     * Subclasses can override the method to provide custom wrappers\n+     * for Java objects.\n+     * @param cx the current Context for this thread\n+     * @param scope the scope of the executing script\n+     * @param javaObject the object to be wrapped\n+     * @param staticType type hint. If security restrictions prevent to wrap\n+                object based on its class, staticType will be used instead.\n+     * @return the wrapped value which shall not be null\n+     */\n+    public Scriptable wrapAsJavaObject(Context cx, Scriptable scope,\n+                                       Object javaObject, Class<?> staticType)\n+    {\n+        Scriptable wrap;\n+        wrap = new NativeJavaObject(scope, javaObject, staticType);\n+        return wrap;\n+    }\n+\n+    /**\n+     * Return <code>false</code> if result of Java method, which is instance of\n+     * <code>String</code>, <code>Number</code>, <code>Boolean</code> and\n+     * <code>Character</code>, should be used directly as JavaScript primitive\n+     * type.\n+     * By default the method returns true to indicate that instances of\n+     * <code>String</code>, <code>Number</code>, <code>Boolean</code> and\n+     * <code>Character</code> should be wrapped as any other Java object and\n+     * scripts can access any Java method available in these objects.\n+     * Use {@link #setJavaPrimitiveWrap(boolean)} to change this.\n+     */\n+    public final boolean isJavaPrimitiveWrap()\n+    {\n+        return javaPrimitiveWrap;\n+    }\n+\n+    /**\n+     * @see #isJavaPrimitiveWrap()\n+     */\n+    public final void setJavaPrimitiveWrap(boolean value)\n+    {\n+        Context cx = Context.getCurrentContext();\n+        if (cx != null && cx.isSealed()) {\n+            Context.onSealedMutation();\n+        }\n+        javaPrimitiveWrap = value;\n+    }\n+\n+    private boolean javaPrimitiveWrap = true;\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/WrappedException.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * A wrapper for runtime exceptions.\n+ *\n+ * Used by the JavaScript runtime to wrap and propagate exceptions that occur\n+ * during runtime.\n+ *\n+ */\n+public class WrappedException extends EvaluatorException\n+{\n+    static final long serialVersionUID = -1551979216966520648L;\n+\n+    /**\n+     * @see Context#throwAsScriptRuntimeEx(Throwable e)\n+     */\n+    public WrappedException(Throwable exception)\n+    {\n+        super(\"Wrapped \"+exception.toString());\n+        this.exception = exception;\n+        Kit.initCause(this, exception);\n+\n+        int[] linep = { 0 };\n+        String sourceName = Context.getSourcePositionFromStack(linep);\n+        int lineNumber = linep[0];\n+        if (sourceName != null) {\n+            initSourceName(sourceName);\n+        }\n+        if (lineNumber != 0) {\n+            initLineNumber(lineNumber);\n+        }\n+    }\n+\n+    /**\n+     * Get the wrapped exception.\n+     *\n+     * @return the exception that was presented as a argument to the\n+     *         constructor when this object was created\n+     */\n+    public Throwable getWrappedException()\n+    {\n+        return exception;\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #getWrappedException()} instead.\n+     */\n+    public Object unwrap()\n+    {\n+        return getWrappedException();\n+    }\n+\n+    private Throwable exception;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/Wrapper.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript;\n+\n+/**\n+ * Objects that can wrap other values for reflection in the JS environment\n+ * will implement Wrapper.\n+ *\n+ * Wrapper defines a single method that can be called to unwrap the object.\n+ */\n+\n+public interface Wrapper {\n+\n+    /**\n+     * Unwrap the object by returning the wrapped value.\n+     *\n+     * @return a wrapped value\n+     */\n+    public Object unwrap();\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/annotations/JSConstructor.java\n+package org.mozilla.javascript.annotations;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * An annotation that marks a Java method as JavaScript constructor. This can\n+ * be used as an alternative to the <code>jsConstructor</code> naming convention desribed in\n+ * {@link org.mozilla.javascript.ScriptableObject#defineClass(org.mozilla.javascript.Scriptable, java.lang.Class)}.\n+ */\n+@Documented\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.CONSTRUCTOR, ElementType.METHOD})\n+public @interface JSConstructor {\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/annotations/JSFunction.java\n+package org.mozilla.javascript.annotations;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * An annotation that marks a Java method as JavaScript function. This can\n+ * be used as an alternative to the <code>jsFunction_</code> prefix desribed in\n+ * {@link org.mozilla.javascript.ScriptableObject#defineClass(org.mozilla.javascript.Scriptable, java.lang.Class)}.\n+ */\n+@Documented\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface JSFunction {\n+    String value() default \"\";\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/annotations/JSGetter.java\n+package org.mozilla.javascript.annotations;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * An annotation that marks a Java method as JavaScript getter. This can\n+ * be used as an alternative to the <code>jsGet_</code> prefix desribed in\n+ * {@link org.mozilla.javascript.ScriptableObject#defineClass(org.mozilla.javascript.Scriptable, java.lang.Class)}.\n+ */\n+@Documented\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface JSGetter {\n+    String value() default \"\";\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/annotations/JSSetter.java\n+package org.mozilla.javascript.annotations;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * An annotation that marks a Java method as JavaScript setter. This can\n+ * be used as an alternative to the <code>jsSet_</code> prefix desribed in\n+ * {@link org.mozilla.javascript.ScriptableObject#defineClass(org.mozilla.javascript.Scriptable, java.lang.Class)}.\n+ */\n+@Documented\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface JSSetter {\n+    String value() default \"\";\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/annotations/JSStaticFunction.java\n+package org.mozilla.javascript.annotations;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * An annotation that marks a Java method as JavaScript static function. This can\n+ * be used as an alternative to the <code>jsStaticFunction_</code> prefix desribed in\n+ * {@link org.mozilla.javascript.ScriptableObject#defineClass(org.mozilla.javascript.Scriptable, java.lang.Class)}.\n+ */\n+@Documented\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface JSStaticFunction {\n+    String value() default \"\";\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ArrayComprehension.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * AST node for a JavaScript 1.7 Array comprehension.\n+ * Node type is {@link Token#ARRAYCOMP}.<p>\n+ */\n+public class ArrayComprehension extends Scope {\n+\n+    private AstNode result;\n+    private List<ArrayComprehensionLoop> loops =\n+        new ArrayList<ArrayComprehensionLoop>();\n+    private AstNode filter;\n+    private int ifPosition = -1;\n+    private int lp = -1;\n+    private int rp = -1;\n+\n+    {\n+        type = Token.ARRAYCOMP;\n+    }\n+\n+    public ArrayComprehension() {\n+    }\n+\n+    public ArrayComprehension(int pos) {\n+        super(pos);\n+    }\n+\n+    public ArrayComprehension(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns result expression node (just after opening bracket)\n+     */\n+    public AstNode getResult() {\n+        return result;\n+    }\n+\n+    /**\n+     * Sets result expression, and sets its parent to this node.\n+     * @throws IllegalArgumentException if result is {@code null}\n+     */\n+    public void setResult(AstNode result) {\n+        assertNotNull(result);\n+        this.result = result;\n+        result.setParent(this);\n+    }\n+\n+    /**\n+     * Returns loop list\n+     */\n+    public List<ArrayComprehensionLoop> getLoops() {\n+        return loops;\n+    }\n+\n+    /**\n+     * Sets loop list\n+     * @throws IllegalArgumentException if loops is {@code null}\n+     */\n+    public void setLoops(List<ArrayComprehensionLoop> loops) {\n+        assertNotNull(loops);\n+        this.loops.clear();\n+        for (ArrayComprehensionLoop acl : loops) {\n+            addLoop(acl);\n+        }\n+    }\n+\n+    /**\n+     * Adds a child loop node, and sets its parent to this node.\n+     * @throws IllegalArgumentException if acl is {@code null}\n+     */\n+    public void addLoop(ArrayComprehensionLoop acl) {\n+        assertNotNull(acl);\n+        loops.add(acl);\n+        acl.setParent(this);\n+    }\n+\n+    /**\n+     * Returns filter expression, or {@code null} if not present\n+     */\n+    public AstNode getFilter() {\n+        return filter;\n+    }\n+\n+    /**\n+     * Sets filter expression, and sets its parent to this node.\n+     * Can be {@code null}.\n+     */\n+    public void setFilter(AstNode filter) {\n+        this.filter = filter;\n+        if (filter != null)\n+            filter.setParent(this);\n+    }\n+\n+    /**\n+     * Returns position of 'if' keyword, -1 if not present\n+     */\n+    public int getIfPosition() {\n+        return ifPosition;\n+    }\n+\n+    /**\n+     * Sets position of 'if' keyword\n+     */\n+    public void setIfPosition(int ifPosition) {\n+        this.ifPosition = ifPosition;\n+    }\n+\n+    /**\n+     * Returns filter left paren position, or -1 if no filter\n+     */\n+    public int getFilterLp() {\n+        return lp;\n+    }\n+\n+    /**\n+     * Sets filter left paren position, or -1 if no filter\n+     */\n+    public void setFilterLp(int lp) {\n+        this.lp = lp;\n+    }\n+\n+    /**\n+     * Returns filter right paren position, or -1 if no filter\n+     */\n+    public int getFilterRp() {\n+        return rp;\n+    }\n+\n+    /**\n+     * Sets filter right paren position, or -1 if no filter\n+     */\n+    public void setFilterRp(int rp) {\n+        this.rp = rp;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder(250);\n+        sb.append(\"[\");\n+        sb.append(result.toSource(0));\n+        for (ArrayComprehensionLoop loop : loops) {\n+            sb.append(loop.toSource(0));\n+        }\n+        if (filter != null) {\n+            sb.append(\" if (\");\n+            sb.append(filter.toSource(0));\n+            sb.append(\")\");\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the result expression, the loops, and the optional\n+     * filter.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (!v.visit(this)) {\n+            return;\n+        }\n+        result.visit(v);\n+        for (ArrayComprehensionLoop loop : loops) {\n+            loop.visit(v);\n+        }\n+        if (filter != null) {\n+            filter.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ArrayComprehensionLoop.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for a single 'for (foo in bar)' loop construct in a JavaScript 1.7\n+ * Array comprehension.  This node type is almost equivalent to a\n+ * {@link ForInLoop}, except that it has no body statement.\n+ * Node type is {@link Token#FOR}.<p>\n+ */\n+public class ArrayComprehensionLoop extends ForInLoop {\n+\n+    public ArrayComprehensionLoop() {\n+    }\n+\n+    public ArrayComprehensionLoop(int pos) {\n+        super(pos);\n+    }\n+\n+    public ArrayComprehensionLoop(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns {@code null} for loop body\n+     * @return loop body (always {@code null} for this node type)\n+     */\n+    public AstNode getBody() {\n+        return null;\n+    }\n+\n+    /**\n+     * Throws an exception on attempts to set the loop body.\n+     * @param body loop body\n+     * @throws UnsupportedOperationException\n+     */\n+    public void setBody(AstNode body) {\n+        throw new UnsupportedOperationException(\"this node type has no body\");\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        return makeIndent(depth)\n+                + \" for (\"\n+                + iterator.toSource(0)\n+                + \" in \"\n+                + iteratedObject.toSource(0)\n+                + \")\";\n+    }\n+\n+    /**\n+     * Visits the iterator expression and the iterated object expression.\n+     * There is no body-expression for this loop type.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            iterator.visit(v);\n+            iteratedObject.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ArrayLiteral.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * AST node for an Array literal.  The elements list will always be\n+ * non-{@code null}, although the list will have no elements if the Array literal\n+ * is empty.<p>\n+ *\n+ * Node type is {@link Token#ARRAYLIT}.<p>\n+ *\n+ * <pre><i>ArrayLiteral</i> :\n+ *        <b>[</b> Elisionopt <b>]</b>\n+ *        <b>[</b> ElementList <b>]</b>\n+ *        <b>[</b> ElementList , Elisionopt <b>]</b>\n+ * <i>ElementList</i> :\n+ *        Elisionopt AssignmentExpression\n+ *        ElementList , Elisionopt AssignmentExpression\n+ * <i>Elision</i> :\n+ *        <b>,</b>\n+ *        Elision <b>,</b></pre>\n+ */\n+public class ArrayLiteral extends AstNode implements DestructuringForm {\n+\n+    private static final List<AstNode> NO_ELEMS =\n+        Collections.unmodifiableList(new ArrayList<AstNode>());\n+\n+    private List<AstNode> elements;\n+    private int destructuringLength;\n+    private int skipCount;\n+    private boolean isDestructuring;\n+\n+    {\n+        type = Token.ARRAYLIT;\n+    }\n+\n+    public ArrayLiteral() {\n+    }\n+\n+    public ArrayLiteral(int pos) {\n+        super(pos);\n+    }\n+\n+    public ArrayLiteral(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns the element list\n+     * @return the element list.  If there are no elements, returns an immutable\n+     *         empty list.  Elisions are represented as {@link EmptyExpression}\n+     *         nodes.\n+     */\n+    public List<AstNode> getElements() {\n+        return elements != null ? elements : NO_ELEMS;\n+    }\n+\n+    /**\n+     * Sets the element list, and sets each element's parent to this node.\n+     * @param elements the element list.  Can be {@code null}.\n+     */\n+    public void setElements(List<AstNode> elements) {\n+        if (elements == null) {\n+            this.elements = null;\n+        } else {\n+            if (this.elements != null)\n+                this.elements.clear();\n+            for (AstNode e : elements)\n+                addElement(e);\n+        }\n+    }\n+\n+    /**\n+     * Adds an element to the list, and sets its parent to this node.\n+     * @param element the element to add\n+     * @throws IllegalArgumentException if element is {@code null}.  To indicate\n+     *         an empty element, use an {@link EmptyExpression} node.\n+     */\n+    public void addElement(AstNode element) {\n+        assertNotNull(element);\n+        if (elements == null)\n+            elements = new ArrayList<AstNode>();\n+        elements.add(element);\n+        element.setParent(this);\n+    }\n+\n+    /**\n+     * Returns the number of elements in this {@code Array} literal,\n+     * including empty elements.\n+     */\n+    public int getSize() {\n+        return elements == null ? 0 : elements.size();\n+    }\n+\n+    /**\n+     * Returns element at specified index.\n+     * @param index the index of the element to retrieve\n+     * @return the element\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public AstNode getElement(int index) {\n+        if (elements == null)\n+            throw new IndexOutOfBoundsException(\"no elements\");\n+        return elements.get(index);\n+    }\n+\n+    /**\n+     * Returns destructuring length\n+     */\n+    public int getDestructuringLength() {\n+      return destructuringLength;\n+    }\n+\n+    /**\n+     * Sets destructuring length.  This is set by the parser and used\n+     * by the code generator.  {@code for ([a,] in obj)} is legal,\n+     * but {@code for ([a] in obj)} is not since we have both key and\n+     * value supplied.  The difference is only meaningful in array literals\n+     * used in destructuring-assignment contexts.\n+     */\n+    public void setDestructuringLength(int destructuringLength) {\n+      this.destructuringLength = destructuringLength;\n+    }\n+\n+    /**\n+     * Used by code generator.\n+     * @return the number of empty elements\n+     */\n+    public int getSkipCount() {\n+        return skipCount;\n+    }\n+\n+    /**\n+     * Used by code generator.\n+     * @param count the count of empty elements\n+     */\n+    public void setSkipCount(int count) {\n+        skipCount = count;\n+    }\n+\n+    /**\n+     * Marks this node as being a destructuring form - that is, appearing\n+     * in a context such as {@code for ([a, b] in ...)} where it's the\n+     * target of a destructuring assignment.\n+     */\n+    public void setIsDestructuring(boolean destructuring) {\n+        isDestructuring = destructuring;\n+    }\n+\n+    /**\n+     * Returns true if this node is in a destructuring position:\n+     * a function parameter, the target of a variable initializer, the\n+     * iterator of a for..in loop, etc.\n+     */\n+    public boolean isDestructuring() {\n+        return isDestructuring;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"[\");\n+        if (elements != null) {\n+            printList(elements, sb);\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then visits its element expressions in order.\n+     * Any empty elements are represented by {@link EmptyExpression}\n+     * objects, so the callback will never be passed {@code null}.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            for (AstNode e : getElements()) {\n+                e.visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/Assignment.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+/**\n+ * AST node representing the set of assignment operators such as {@code =},\n+ * {@code *=} and {@code +=}.\n+ */\n+public class Assignment extends InfixExpression {\n+\n+    public Assignment() {\n+    }\n+\n+    public Assignment(int pos) {\n+        super(pos);\n+    }\n+\n+    public Assignment(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    public Assignment(int pos, int len, AstNode left, AstNode right) {\n+        super(pos, len, left, right);\n+    }\n+\n+    public Assignment(AstNode left, AstNode right) {\n+        super(left, right);\n+    }\n+\n+    public Assignment(int operator, AstNode left,\n+                      AstNode right, int operatorPos) {\n+        super(operator, left, right, operatorPos);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/AstNode.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Kit;\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Base class for AST node types.  The goal of the AST is to represent the\n+ * physical source code, to make it useful for code-processing tools such\n+ * as IDEs or pretty-printers.  The parser must not rewrite the parse tree\n+ * when producing this representation. <p>\n+ *\n+ * The {@code AstNode} hierarchy sits atop the older {@link Node} class,\n+ * which was designed for code generation.  The {@code Node} class is a\n+ * flexible, weakly-typed class suitable for creating and rewriting code\n+ * trees, but using it requires you to remember the exact ordering of the\n+ * child nodes, which are kept in a linked list.  The {@code AstNode}\n+ * hierarchy is a strongly-typed facade with named accessors for children\n+ * and common properties, but under the hood it's still using a linked list\n+ * of child nodes.  It isn't a very good idea to use the child list directly\n+ * unless you know exactly what you're doing.</p>\n+ *\n+ * Note that {@code AstNode} records additional information, including\n+ * the node's position, length, and parent node.  Also, some {@code AstNode}\n+ * subclasses record some of their child nodes in instance members, since\n+ * they are not needed for code generation.  In a nutshell, only the code\n+ * generator should be mixing and matching {@code AstNode} and {@code Node}\n+ * objects.<p>\n+ *\n+ * All offset fields in all subclasses of AstNode are relative to their\n+ * parent.  For things like paren, bracket and keyword positions, the\n+ * position is relative to the current node.  The node start position is\n+ * relative to the parent node. <p>\n+ *\n+ * During the actual parsing, node positions are absolute; adding the node to\n+ * its parent fixes up the offsets to be relative.  By the time you see the AST\n+ * (e.g. using the {@code Visitor} interface), the offsets are relative. <p>\n+ *\n+ * {@code AstNode} objects have property lists accessible via the\n+ * {@link #getProp} and {@link #putProp} methods.  The property lists are\n+ * integer-keyed with arbitrary {@code Object} values.  For the most part the\n+ * parser generating the AST avoids using properties, preferring fields for\n+ * elements that are always set.  Property lists are intended for user-defined\n+ * annotations to the tree.  The Rhino code generator acts as a client and\n+ * uses node properties extensively.  You are welcome to use the property-list\n+ * API for anything your client needs.<p>\n+ *\n+ * This hierarchy does not have separate branches for expressions and\n+ * statements, as the distinction in JavaScript is not as clear-cut as in\n+ * Java or C++. <p>\n+ */\n+public abstract class AstNode extends Node implements Comparable<AstNode> {\n+\n+    protected int position = -1;\n+    protected int length = 1;\n+    protected AstNode parent;\n+\n+    private static Map<Integer,String> operatorNames =\n+            new HashMap<Integer,String>();\n+\n+    static {\n+        operatorNames.put(Token.IN, \"in\");\n+        operatorNames.put(Token.TYPEOF, \"typeof\");\n+        operatorNames.put(Token.INSTANCEOF, \"instanceof\");\n+        operatorNames.put(Token.DELPROP, \"delete\");\n+        operatorNames.put(Token.COMMA, \",\");\n+        operatorNames.put(Token.COLON, \":\");\n+        operatorNames.put(Token.OR, \"||\");\n+        operatorNames.put(Token.AND, \"&&\");\n+        operatorNames.put(Token.INC, \"++\");\n+        operatorNames.put(Token.DEC, \"--\");\n+        operatorNames.put(Token.BITOR, \"|\");\n+        operatorNames.put(Token.BITXOR, \"^\");\n+        operatorNames.put(Token.BITAND, \"&\");\n+        operatorNames.put(Token.EQ, \"==\");\n+        operatorNames.put(Token.NE, \"!=\");\n+        operatorNames.put(Token.LT, \"<\");\n+        operatorNames.put(Token.GT, \">\");\n+        operatorNames.put(Token.LE, \"<=\");\n+        operatorNames.put(Token.GE, \">=\");\n+        operatorNames.put(Token.LSH, \"<<\");\n+        operatorNames.put(Token.RSH, \">>\");\n+        operatorNames.put(Token.URSH, \">>>\");\n+        operatorNames.put(Token.ADD, \"+\");\n+        operatorNames.put(Token.SUB, \"-\");\n+        operatorNames.put(Token.MUL, \"*\");\n+        operatorNames.put(Token.DIV, \"/\");\n+        operatorNames.put(Token.MOD, \"%\");\n+        operatorNames.put(Token.NOT, \"!\");\n+        operatorNames.put(Token.BITNOT, \"~\");\n+        operatorNames.put(Token.POS, \"+\");\n+        operatorNames.put(Token.NEG, \"-\");\n+        operatorNames.put(Token.SHEQ, \"===\");\n+        operatorNames.put(Token.SHNE, \"!==\");\n+        operatorNames.put(Token.ASSIGN, \"=\");\n+        operatorNames.put(Token.ASSIGN_BITOR, \"|=\");\n+        operatorNames.put(Token.ASSIGN_BITAND, \"&=\");\n+        operatorNames.put(Token.ASSIGN_LSH, \"<<=\");\n+        operatorNames.put(Token.ASSIGN_RSH, \">>=\");\n+        operatorNames.put(Token.ASSIGN_URSH, \">>>=\");\n+        operatorNames.put(Token.ASSIGN_ADD, \"+=\");\n+        operatorNames.put(Token.ASSIGN_SUB, \"-=\");\n+        operatorNames.put(Token.ASSIGN_MUL, \"*=\");\n+        operatorNames.put(Token.ASSIGN_DIV, \"/=\");\n+        operatorNames.put(Token.ASSIGN_MOD, \"%=\");\n+    }\n+\n+    public static class PositionComparator implements Comparator<AstNode> {\n+        /**\n+         * Sorts nodes by (relative) start position.  The start positions are\n+         * relative to their parent, so this comparator is only meaningful for\n+         * comparing siblings.\n+         */\n+        public int compare(AstNode n1, AstNode n2) {\n+            return n1.position - n2.position;\n+        }\n+    }\n+\n+    public AstNode() {\n+        super(Token.ERROR);\n+    }\n+\n+    /**\n+     * Constructs a new AstNode\n+     * @param pos the start position\n+     */\n+    public AstNode(int pos) {\n+        this();\n+        position = pos;\n+    }\n+\n+    /**\n+     * Constructs a new AstNode\n+     * @param pos the start position\n+     * @param len the number of characters spanned by the node in the source\n+     * text\n+     */\n+    public AstNode(int pos, int len) {\n+        this();\n+        position = pos;\n+        length = len;\n+    }\n+\n+    /**\n+     * Returns relative position in parent\n+     */\n+    public int getPosition() {\n+        return position;\n+    }\n+\n+    /**\n+     * Sets relative position in parent\n+     */\n+    public void setPosition(int position) {\n+        this.position = position;\n+    }\n+\n+    /**\n+     * Returns the absolute document position of the node.\n+     * Computes it by adding the node's relative position\n+     * to the relative positions of all its parents.\n+     */\n+    public int getAbsolutePosition() {\n+        int pos = position;\n+        AstNode parent = this.parent;\n+        while (parent != null) {\n+            pos += parent.getPosition();\n+            parent = parent.getParent();\n+        }\n+        return pos;\n+    }\n+\n+    /**\n+     * Returns node length\n+     */\n+    public int getLength() {\n+        return length;\n+    }\n+\n+    /**\n+     * Sets node length\n+     */\n+    public void setLength(int length) {\n+        this.length = length;\n+    }\n+\n+    /**\n+     * Sets the node start and end positions.\n+     * Computes the length as ({@code end} - {@code position}).\n+     */\n+    public void setBounds(int position, int end) {\n+        setPosition(position);\n+        setLength(end - position);\n+    }\n+\n+    /**\n+     * Make this node's position relative to a parent.\n+     * Typically only used by the parser when constructing the node.\n+     * @param parentPosition the absolute parent position; the\n+     * current node position is assumed to be absolute and is\n+     * decremented by parentPosition.\n+     */\n+    public void setRelative(int parentPosition) {\n+        this.position -= parentPosition;\n+    }\n+\n+    /**\n+     * Returns the node parent, or {@code null} if it has none\n+     */\n+    public AstNode getParent() {\n+        return parent;\n+    }\n+\n+    /**\n+     * Sets the node parent.  This method automatically adjusts the\n+     * current node's start position to be relative to the new parent.\n+     * @param parent the new parent. Can be {@code null}.\n+     */\n+    public void setParent(AstNode parent) {\n+        if (parent == this.parent) {\n+            return;\n+        }\n+\n+        // Convert position back to absolute.\n+        if (this.parent != null) {\n+            setRelative(-this.parent.getPosition());\n+        }\n+\n+        this.parent = parent;\n+        if (parent != null) {\n+            setRelative(parent.getPosition());\n+        }\n+    }\n+\n+    /**\n+     * Adds a child or function to the end of the block.\n+     * Sets the parent of the child to this node, and fixes up\n+     * the start position of the child to be relative to this node.\n+     * Sets the length of this node to include the new child.\n+     * @param kid the child\n+     * @throws IllegalArgumentException if kid is {@code null}\n+     */\n+    public void addChild(AstNode kid) {\n+        assertNotNull(kid);\n+        int end = kid.getPosition() + kid.getLength();\n+        setLength(end - this.getPosition());\n+        addChildToBack(kid);\n+        kid.setParent(this);\n+    }\n+\n+    /**\n+     * Returns the root of the tree containing this node.\n+     * @return the {@link AstRoot} at the root of this node's parent\n+     * chain, or {@code null} if the topmost parent is not an {@code AstRoot}.\n+     */\n+    public AstRoot getAstRoot() {\n+        AstNode parent = this;  // this node could be the AstRoot\n+        while (parent != null && !(parent instanceof AstRoot)) {\n+            parent = parent.getParent();\n+        }\n+        return (AstRoot)parent;\n+    }\n+\n+    /**\n+     * Emits source code for this node.  Callee is responsible for calling this\n+     * function recursively on children, incrementing indent as appropriate.<p>\n+     *\n+     * Note: if the parser was in error-recovery mode, some AST nodes may have\n+     * {@code null} children that are expected to be non-{@code null}\n+     * when no errors are present.  In this situation, the behavior of the\n+     * {@code toSource} method is undefined: {@code toSource}\n+     * implementations may assume that the AST node is error-free, since it is\n+     * intended to be invoked only at runtime after a successful parse.<p>\n+     *\n+     * @param depth the current recursion depth, typically beginning at 0\n+     * when called on the root node.\n+     */\n+    public abstract String toSource(int depth);\n+\n+    /**\n+     * Prints the source indented to depth 0.\n+     */\n+    public String toSource() {\n+        return this.toSource(0);\n+    }\n+\n+    /**\n+     * Constructs an indentation string.\n+     * @param indent the number of indentation steps\n+     */\n+    public String makeIndent(int indent) {\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < indent; i++) {\n+            sb.append(\"  \");\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Returns a short, descriptive name for the node, such as\n+     * \"ArrayComprehension\".\n+     */\n+    public String shortName() {\n+        String classname = getClass().getName();\n+        int last = classname.lastIndexOf(\".\");\n+        return classname.substring(last + 1);\n+    }\n+\n+    /**\n+     * Returns the string name for this operator.\n+     * @param op the token type, e.g. {@link Token#ADD} or {@link Token#TYPEOF}\n+     * @return the source operator string, such as \"+\" or \"typeof\"\n+     */\n+    public static String operatorToString(int op) {\n+        String result = operatorNames.get(op);\n+        if (result == null)\n+            throw new IllegalArgumentException(\"Invalid operator: \" + op);\n+        return result;\n+    }\n+\n+    /**\n+     * Visits this node and its children in an arbitrary order. <p>\n+     *\n+     * It's up to each node subclass to decide the order for processing\n+     * its children.  The subclass also decides (and should document)\n+     * which child nodes are not passed to the {@code NodeVisitor}.\n+     * For instance, nodes representing keywords like {@code each} or\n+     * {@code in} may not be passed to the visitor object.  The visitor\n+     * can simply query the current node for these children if desired.<p>\n+     *\n+     * Generally speaking, the order will be deterministic; the order is\n+     * whatever order is decided by each child node.  Normally child nodes\n+     * will try to visit their children in lexical order, but there may\n+     * be exceptions to this rule.<p>\n+     *\n+     * @param visitor the object to call with this node and its children\n+     */\n+    public abstract void visit(NodeVisitor visitor);\n+\n+    // subclasses with potential side effects should override this\n+    public boolean hasSideEffects()\n+    {\n+        switch (getType()) {\n+          case Token.ASSIGN:\n+          case Token.ASSIGN_ADD:\n+          case Token.ASSIGN_BITAND:\n+          case Token.ASSIGN_BITOR:\n+          case Token.ASSIGN_BITXOR:\n+          case Token.ASSIGN_DIV:\n+          case Token.ASSIGN_LSH:\n+          case Token.ASSIGN_MOD:\n+          case Token.ASSIGN_MUL:\n+          case Token.ASSIGN_RSH:\n+          case Token.ASSIGN_SUB:\n+          case Token.ASSIGN_URSH:\n+          case Token.BLOCK:\n+          case Token.BREAK:\n+          case Token.CALL:\n+          case Token.CATCH:\n+          case Token.CATCH_SCOPE:\n+          case Token.CONST:\n+          case Token.CONTINUE:\n+          case Token.DEC:\n+          case Token.DELPROP:\n+          case Token.DEL_REF:\n+          case Token.DO:\n+          case Token.ELSE:\n+          case Token.ENTERWITH:\n+          case Token.ERROR:         // Avoid cascaded error messages\n+          case Token.EXPORT:\n+          case Token.EXPR_RESULT:\n+          case Token.FINALLY:\n+          case Token.FUNCTION:\n+          case Token.FOR:\n+          case Token.GOTO:\n+          case Token.IF:\n+          case Token.IFEQ:\n+          case Token.IFNE:\n+          case Token.IMPORT:\n+          case Token.INC:\n+          case Token.JSR:\n+          case Token.LABEL:\n+          case Token.LEAVEWITH:\n+          case Token.LET:\n+          case Token.LETEXPR:\n+          case Token.LOCAL_BLOCK:\n+          case Token.LOOP:\n+          case Token.NEW:\n+          case Token.REF_CALL:\n+          case Token.RETHROW:\n+          case Token.RETURN:\n+          case Token.RETURN_RESULT:\n+          case Token.SEMI:\n+          case Token.SETELEM:\n+          case Token.SETELEM_OP:\n+          case Token.SETNAME:\n+          case Token.SETPROP:\n+          case Token.SETPROP_OP:\n+          case Token.SETVAR:\n+          case Token.SET_REF:\n+          case Token.SET_REF_OP:\n+          case Token.SWITCH:\n+          case Token.TARGET:\n+          case Token.THROW:\n+          case Token.TRY:\n+          case Token.VAR:\n+          case Token.WHILE:\n+          case Token.WITH:\n+          case Token.WITHEXPR:\n+          case Token.YIELD:\n+            return true;\n+\n+          default:\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Bounces an IllegalArgumentException up if arg is {@code null}.\n+     * @param arg any method argument\n+     * @throws IllegalArgumentException if the argument is {@code null}\n+     */\n+    protected void assertNotNull(Object arg) {\n+        if (arg == null)\n+            throw new IllegalArgumentException(\"arg cannot be null\");\n+    }\n+\n+    /**\n+     * Prints a comma-separated item list into a {@link StringBuilder}.\n+     * @param items a list to print\n+     * @param sb a {@link StringBuilder} into which to print\n+     */\n+    protected <T extends AstNode> void printList(List<T> items,\n+                                                 StringBuilder sb) {\n+        int max = items.size();\n+        int count = 0;\n+        for (AstNode item : items) {\n+            sb.append(item.toSource(0));\n+            if (count++ < max-1) {\n+                sb.append(\", \");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @see Kit#codeBug\n+     */\n+    public static RuntimeException codeBug()\n+        throws RuntimeException\n+    {\n+        throw Kit.codeBug();\n+    }\n+\n+    // TODO(stevey):  think of a way to have polymorphic toString\n+    // methods while keeping the ability to use Node.toString for\n+    // dumping the IR with Token.printTrees.  Most likely:  change\n+    // Node.toString to be Node.dumpTree and change callers to use that.\n+    // For now, need original toString, to compare output to old Rhino's.\n+\n+//     @Override\n+//     public String toString() {\n+//         return this.getClass().getName() + \": \" +\n+//             Token.typeToName(getType());\n+//     }\n+\n+    /**\n+     * Returns the innermost enclosing function, or {@code null} if not in a\n+     * function.  Begins the search with this node's parent.\n+     * @return the {@link FunctionNode} enclosing this node, else {@code null}\n+     */\n+    public FunctionNode getEnclosingFunction() {\n+        AstNode parent = this.getParent();\n+        while (parent != null && !(parent instanceof FunctionNode)) {\n+            parent = parent.getParent();\n+        }\n+        return (FunctionNode)parent;\n+    }\n+\n+    /**\n+     * Returns the innermost enclosing {@link Scope} node, or {@code null}\n+     * if we're not nested in a scope.  Begins the search with this node's parent.\n+     * Note that this is not the same as the defining scope for a {@link Name}.\n+     *\n+     * @return the {@link Scope} enclosing this node, else {@code null}\n+     */\n+    public Scope getEnclosingScope() {\n+        AstNode parent = this.getParent();\n+        while (parent != null && !(parent instanceof Scope)) {\n+            parent = parent.getParent();\n+        }\n+        return (Scope)parent;\n+    }\n+\n+    /**\n+     * Permits AST nodes to be sorted based on start position and length.\n+     * This makes it easy to sort Comment and Error nodes into a set of\n+     * other AST nodes:  just put them all into a {@link java.util.SortedSet},\n+     * for instance.\n+     * @param other another node\n+     * @return -1 if this node's start position is less than {@code other}'s\n+     * start position.  If tied, -1 if this node's length is less than\n+     * {@code other}'s length.  If the lengths are equal, sorts abitrarily\n+     * on hashcode unless the nodes are the same per {@link #equals}.\n+     */\n+    public int compareTo(AstNode other) {\n+        if (this.equals(other)) return 0;\n+        int abs1 = this.getAbsolutePosition();\n+        int abs2 = other.getAbsolutePosition();\n+        if (abs1 < abs2) return -1;\n+        if (abs2 < abs1) return 1;\n+        int len1 = this.getLength();\n+        int len2 = other.getLength();\n+        if (len1 < len2) return -1;\n+        if (len2 < len1) return 1;\n+        return this.hashCode() - other.hashCode();\n+    }\n+\n+    /**\n+     * Returns the depth of this node.  The root is depth 0, its\n+     * children are depth 1, and so on.\n+     * @return the node depth in the tree\n+     */\n+    public int depth() {\n+        return parent == null ? 0 : 1 + parent.depth();\n+    }\n+\n+    protected static class DebugPrintVisitor implements NodeVisitor {\n+        private StringBuilder buffer;\n+        private static final int DEBUG_INDENT = 2;\n+        public DebugPrintVisitor(StringBuilder buf) {\n+            buffer = buf;\n+        }\n+        public String toString() {\n+            return buffer.toString();\n+        }\n+        private String makeIndent(int depth) {\n+            StringBuilder sb = new StringBuilder(DEBUG_INDENT * depth);\n+            for (int i = 0; i < (DEBUG_INDENT * depth); i++) {\n+                sb.append(\" \");\n+            }\n+            return sb.toString();\n+        }\n+        public boolean visit(AstNode node) {\n+            int tt = node.getType();\n+            String name = Token.typeToName(tt);\n+            buffer.append(node.getAbsolutePosition()).append(\"\\t\");\n+            buffer.append(makeIndent(node.depth()));\n+            buffer.append(name).append(\" \");\n+            buffer.append(node.getPosition()).append(\" \");\n+            buffer.append(node.getLength());\n+            if (tt == Token.NAME) {\n+                buffer.append(\" \").append(((Name)node).getIdentifier());\n+            }\n+            buffer.append(\"\\n\");\n+            return true;  // process kids\n+        }\n+    }\n+\n+    /**\n+     * Return the line number recorded for this node.\n+     * If no line number was recorded, searches the parent chain.\n+     * @return the nearest line number, or -1 if none was found\n+     */\n+    @Override\n+    public int getLineno() {\n+        if (lineno != -1)\n+            return lineno;\n+        if (parent != null)\n+            return parent.getLineno();\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns a debugging representation of the parse tree\n+     * starting at this node.\n+     * @return a very verbose indented printout of the tree.\n+     * The format of each line is:  abs-pos  name position length [identifier]\n+     */\n+    public String debugPrint() {\n+        DebugPrintVisitor dpv = new DebugPrintVisitor(new StringBuilder(1000));\n+        visit(dpv);\n+        return dpv.toString();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/AstRoot.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+/**\n+ * Node for the root of a parse tree.  It contains the statements and functions\n+ * in the script, and a list of {@link Comment} nodes associated with the script\n+ * as a whole.  Node type is {@link Token#SCRIPT}. <p>\n+ *\n+ * Note that the tree itself does not store errors.  To collect the parse errors\n+ * and warnings, pass an {@link org.mozilla.javascript.ErrorReporter} to the\n+ * {@link org.mozilla.javascript.Parser} via the\n+ * {@link org.mozilla.javascript.CompilerEnvirons}.\n+ */\n+public class AstRoot extends ScriptNode {\n+\n+    private SortedSet<Comment> comments;\n+    private boolean inStrictMode;\n+\n+    {\n+        type = Token.SCRIPT;\n+    }\n+\n+    public AstRoot() {\n+    }\n+\n+    public AstRoot(int pos) {\n+        super(pos);\n+    }\n+\n+    /**\n+     * Returns comment set\n+     * @return comment set, sorted by start position. Can be {@code null}.\n+     */\n+    public SortedSet<Comment> getComments() {\n+        return comments;\n+    }\n+\n+    /**\n+     * Sets comment list, and updates the parent of each entry to point\n+     * to this node.  Replaces any existing comments.\n+     * @param comments comment list.  can be {@code null}.\n+     */\n+    public void setComments(SortedSet<Comment> comments) {\n+        if (comments == null) {\n+            this.comments = null;\n+        } else {\n+            if (this.comments != null)\n+                this.comments.clear();\n+            for (Comment c : comments)\n+                addComment(c);\n+        }\n+    }\n+\n+    /**\n+     * Add a comment to the comment set.\n+     * @param comment the comment node.\n+     * @throws IllegalArgumentException if comment is {@code null}\n+     */\n+    public void addComment(Comment comment) {\n+        assertNotNull(comment);\n+        if (comments == null) {\n+            comments = new TreeSet<Comment>(new AstNode.PositionComparator());\n+        }\n+        comments.add(comment);\n+        comment.setParent(this);\n+    }\n+    \n+    public void setInStrictMode(boolean inStrictMode) {\n+        this.inStrictMode = inStrictMode;\n+    }\n+    \n+    public boolean isInStrictMode() {\n+        return inStrictMode;\n+    }\n+\n+    /**\n+     * Visits the comment nodes in the order they appear in the source code.\n+     * The comments are not visited by the {@link #visit} function - you must\n+     * use this function to visit them.\n+     * @param visitor the callback object.  It is passed each comment node.\n+     * The return value is ignored.\n+     */\n+    public void visitComments(NodeVisitor visitor) {\n+        if (comments != null) {\n+            for (Comment c : comments) {\n+                visitor.visit(c);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Visits the AST nodes, then the comment nodes.\n+     * This method is equivalent to calling {@link #visit}, then\n+     * {@link #visitComments}.  The return value\n+     * is ignored while visiting comment nodes.\n+     * @param visitor the callback object.\n+     */\n+    public void visitAll(NodeVisitor visitor) {\n+        visit(visitor);\n+        visitComments(visitor);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        for (Node node : this) {\n+            sb.append(((AstNode)node).toSource(depth));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * A debug-printer that includes comments (at the end).\n+     */\n+    @Override\n+    public String debugPrint() {\n+        DebugPrintVisitor dpv = new DebugPrintVisitor(new StringBuilder(1000));\n+        visitAll(dpv);\n+        return dpv.toString();\n+    }\n+\n+    /**\n+     * Debugging function to check that the parser has set the parent\n+     * link for every node in the tree.\n+     * @throws IllegalStateException if a parent link is missing\n+     */\n+    public void checkParentLinks() {\n+        this.visit(new NodeVisitor() {\n+            public boolean visit(AstNode node) {\n+                int type = node.getType();\n+                if (type == Token.SCRIPT)\n+                    return true;\n+                if (node.getParent() == null)\n+                    throw new IllegalStateException\n+                            (\"No parent for node: \" + node\n+                             + \"\\n\" + node.toSource(0));\n+                return true;\n+            }\n+        });\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/Block.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *   Bob Jervis\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * A block statement delimited by curly braces.  The node position is the\n+ * position of the open-curly, and the length extends to the position of\n+ * the close-curly.  Node type is {@link Token#BLOCK}.\n+ *\n+ * <pre><i>Block</i> :\n+ *     <b>{</b> Statement* <b>}</b></pre>\n+ */\n+public class Block extends AstNode {\n+\n+    {\n+        this.type = Token.BLOCK;\n+    }\n+\n+    public Block() {\n+    }\n+\n+    public Block(int pos) {\n+        super(pos);\n+    }\n+\n+    public Block(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Alias for {@link #addChild}.\n+     */\n+    public void addStatement(AstNode statement) {\n+        addChild(statement);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"{\\n\");\n+        for (Node kid : this) {\n+            sb.append(((AstNode)kid).toSource(depth+1));\n+        }\n+        sb.append(makeIndent(depth));\n+        sb.append(\"}\\n\");\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            for (Node kid : this) {\n+                ((AstNode)kid).visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/BreakStatement.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * A break statement.  Node type is {@link Token#BREAK}.<p>\n+ *\n+ * <pre><i>BreakStatement</i> :\n+ *   <b>break</b> [<i>no LineTerminator here</i>] [Identifier] ;</pre>\n+ */\n+public class BreakStatement extends Jump {\n+\n+    private Name breakLabel;\n+    private AstNode target;\n+\n+    {\n+        type = Token.BREAK;\n+    }\n+\n+    public BreakStatement() {\n+    }\n+\n+    public BreakStatement(int pos) {\n+        // can't call super (Jump) for historical reasons\n+        position = pos;\n+    }\n+\n+    public BreakStatement(int pos, int len) {\n+        position = pos;\n+        length = len;\n+    }\n+\n+    /**\n+     * Returns the intended label of this break statement\n+     * @return the break label.  {@code null} if the source code did\n+     * not specify a specific break label via \"break &lt;target&gt;\".\n+     */\n+    public Name getBreakLabel() {\n+        return breakLabel;\n+    }\n+\n+    /**\n+     * Sets the intended label of this break statement, e.g.  'foo'\n+     * in \"break foo\". Also sets the parent of the label to this node.\n+     * @param label the break label, or {@code null} if the statement is\n+     * just the \"break\" keyword by itself.\n+     */\n+    public void setBreakLabel(Name label) {\n+        breakLabel = label;\n+        if (label != null)\n+            label.setParent(this);\n+    }\n+\n+    /**\n+     * Returns the statement to break to\n+     * @return the break target.  Only {@code null} if the source\n+     * code has an error in it.\n+     */\n+    public AstNode getBreakTarget() {\n+        return target;\n+    }\n+\n+    /**\n+     * Sets the statement to break to.\n+     * @param target the statement to break to\n+     * @throws IllegalArgumentException if target is {@code null}\n+     */\n+    public void setBreakTarget(Jump target) {\n+        assertNotNull(target);\n+        this.target = target;\n+        setJumpStatement(target);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"break\");\n+        if (breakLabel != null) {\n+            sb.append(\" \");\n+            sb.append(breakLabel.toSource(0));\n+        }\n+        sb.append(\";\\n\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then visits the break label if non-{@code null}.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this) && breakLabel != null) {\n+            breakLabel.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/CatchClause.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * Node representing a catch-clause of a try-statement.\n+ * Node type is {@link Token#CATCH}.\n+ *\n+ * <pre><i>CatchClause</i> :\n+ *        <b>catch</b> ( <i><b>Identifier</b></i> [<b>if</b> Expression] ) Block</pre>\n+ */\n+public class CatchClause extends AstNode {\n+\n+    private Name varName;\n+    private AstNode catchCondition;\n+    private Block body;\n+    private int ifPosition = -1;\n+    private int lp = -1;\n+    private int rp = -1;\n+\n+    {\n+        type = Token.CATCH;\n+    }\n+\n+    public CatchClause() {\n+    }\n+\n+    public CatchClause(int pos) {\n+        super(pos);\n+    }\n+\n+    public CatchClause(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns catch variable node\n+     * @return catch variable\n+     */\n+    public Name getVarName() {\n+        return varName;\n+    }\n+\n+    /**\n+     * Sets catch variable node, and sets its parent to this node.\n+     * @param varName catch variable\n+     * @throws IllegalArgumentException if varName is {@code null}\n+     */\n+    public void setVarName(Name varName) {\n+        assertNotNull(varName);\n+        this.varName = varName;\n+        varName.setParent(this);\n+    }\n+\n+    /**\n+     * Returns catch condition node, if present\n+     * @return catch condition node, {@code null} if not present\n+     */\n+    public AstNode getCatchCondition() {\n+        return catchCondition;\n+    }\n+\n+    /**\n+     * Sets catch condition node, and sets its parent to this node.\n+     * @param catchCondition catch condition node.  Can be {@code null}.\n+     */\n+    public void setCatchCondition(AstNode catchCondition) {\n+        this.catchCondition = catchCondition;\n+        if (catchCondition != null)\n+            catchCondition.setParent(this);\n+    }\n+\n+    /**\n+     * Returns catch body\n+     */\n+    public Block getBody() {\n+        return body;\n+    }\n+\n+    /**\n+     * Sets catch body, and sets its parent to this node.\n+     * @throws IllegalArgumentException if body is {@code null}\n+     */\n+    public void setBody(Block body) {\n+        assertNotNull(body);\n+        this.body = body;\n+        body.setParent(this);\n+    }\n+\n+    /**\n+     * Returns left paren position\n+     */\n+    public int getLp() {\n+        return lp;\n+    }\n+\n+    /**\n+     * Sets left paren position\n+     */\n+    public void setLp(int lp) {\n+        this.lp = lp;\n+    }\n+\n+    /**\n+     * Returns right paren position\n+     */\n+    public int getRp() {\n+        return rp;\n+    }\n+\n+    /**\n+     * Sets right paren position\n+     */\n+    public void setRp(int rp) {\n+        this.rp = rp;\n+    }\n+\n+    /**\n+     * Sets both paren positions\n+     */\n+    public void setParens(int lp, int rp) {\n+        this.lp = lp;\n+        this.rp = rp;\n+    }\n+\n+    /**\n+     * Returns position of \"if\" keyword\n+     * @return position of \"if\" keyword, if present, or -1\n+     */\n+    public int getIfPosition() {\n+        return ifPosition;\n+    }\n+\n+    /**\n+     * Sets position of \"if\" keyword\n+     * @param ifPosition position of \"if\" keyword, if present, or -1\n+     */\n+    public void setIfPosition(int ifPosition) {\n+        this.ifPosition = ifPosition;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"catch (\");\n+        sb.append(varName.toSource(0));\n+        if (catchCondition != null) {\n+            sb.append(\" if \");\n+            sb.append(catchCondition.toSource(0));\n+        }\n+        sb.append(\") \");\n+        sb.append(body.toSource(0));\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the catch var name node, the condition if\n+     * non-{@code null}, and the catch body.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            varName.visit(v);\n+            if (catchCondition != null) {\n+                catchCondition.visit(v);\n+            }\n+            body.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/Comment.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * Node representing comments.\n+ * Node type is {@link Token#COMMENT}.<p>\n+ *\n+ * <p>JavaScript effectively has five comment types:\n+ *   <ol>\n+ *     <li>// line comments</li>\n+ *     <li>/<span class=\"none\">* block comments *\\/</li>\n+ *     <li>/<span class=\"none\">** jsdoc comments *\\/</li>\n+ *     <li>&lt;!-- html-open line comments</li>\n+ *     <li>^\\\\s*--&gt; html-close line comments</li>\n+ *   </ol>\n+ *\n+ * <p>The first three should be familiar to Java programmers.  JsDoc comments\n+ * are really just block comments with some conventions about the formatting\n+ * within the comment delimiters.  Line and block comments are described in the\n+ * Ecma-262 specification. <p>\n+ *\n+ * <p>SpiderMonkey and Rhino also support HTML comment syntax, but somewhat\n+ * counterintuitively, the syntax does not produce a block comment.  Instead,\n+ * everything from the string &lt;!-- through the end of the line is considered\n+ * a comment, and if the token --&gt; is the first non-whitespace on the line,\n+ * then the line is considered a line comment.  This is to support parsing\n+ * JavaScript in &lt;script&gt; HTML tags that has been \"hidden\" from very old\n+ * browsers by surrounding it with HTML comment delimiters. <p>\n+ *\n+ * Note the node start position for Comment nodes is still relative to the\n+ * parent, but Comments are always stored directly in the AstRoot node, so\n+ * they are also effectively absolute offsets.\n+ */\n+public class Comment extends AstNode {\n+\n+    private String value;\n+    private Token.CommentType commentType;\n+    private boolean parsed = false;\n+\n+    {\n+        type = Token.COMMENT;\n+    }\n+\n+    /**\n+     * Constructs a new Comment\n+     * @param pos the start position\n+     * @param len the length including delimiter(s)\n+     * @param type the comment type\n+     * @param value the value of the comment, as a string\n+     */\n+    public Comment(int pos, int len, Token.CommentType type, String value) {\n+        super(pos, len);\n+        commentType = type;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Returns the comment style\n+     */\n+    public Token.CommentType getCommentType() {\n+        return commentType;\n+    }\n+\n+    /**\n+     * Sets the comment style\n+     * @param type the comment style, a\n+     * {@link org.mozilla.javascript.Token.CommentType}\n+     */\n+    public void setCommentType(Token.CommentType type) {\n+        this.commentType = type;\n+    }\n+\n+    /**\n+     * Returns a string of the comment value.\n+     */\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder(getLength() + 10);\n+        sb.append(makeIndent(depth));\n+        sb.append(value);\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Comment nodes are not visited during normal visitor traversals,\n+     * but comply with the {@link AstNode#visit} interface.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        v.visit(this);\n+    }\n+\n+    public boolean isParsed() {\n+        return parsed;\n+    }\n+\n+    public void setParsed(boolean parsed) {\n+        this.parsed = parsed;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ConditionalExpression.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node representing the ternary operator.  Node type is\n+ * {@link Token#HOOK}.\n+ *\n+ * <pre><i>ConditionalExpression</i> :\n+ *        LogicalORExpression\n+ *        LogicalORExpression ? AssignmentExpression\n+ *                            : AssignmentExpression</pre>\n+ *\n+ * <i>ConditionalExpressionNoIn</i> :\n+ *        LogicalORExpressionNoIn\n+ *        LogicalORExpressionNoIn ? AssignmentExpression\n+ *                                : AssignmentExpressionNoIn</pre>\n+ */\n+public class ConditionalExpression extends AstNode {\n+\n+    private AstNode testExpression;\n+    private AstNode trueExpression;\n+    private AstNode falseExpression;\n+    private int questionMarkPosition = -1;\n+    private int colonPosition = -1;\n+\n+    {\n+        type = Token.HOOK;\n+    }\n+\n+    public ConditionalExpression() {\n+    }\n+\n+    public ConditionalExpression(int pos) {\n+        super(pos);\n+    }\n+\n+    public ConditionalExpression(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns test expression\n+     */\n+    public AstNode getTestExpression() {\n+        return testExpression;\n+    }\n+\n+    /**\n+     * Sets test expression, and sets its parent.\n+     * @param testExpression test expression\n+     * @throws IllegalArgumentException if testExpression is {@code null}\n+     */\n+    public void setTestExpression(AstNode testExpression) {\n+        assertNotNull(testExpression);\n+        this.testExpression = testExpression;\n+        testExpression.setParent(this);\n+    }\n+\n+    /**\n+     * Returns expression to evaluate if test is true\n+     */\n+    public AstNode getTrueExpression() {\n+        return trueExpression;\n+    }\n+\n+    /**\n+     * Sets expression to evaluate if test is true, and\n+     * sets its parent to this node.\n+     * @param trueExpression expression to evaluate if test is true\n+     * @throws IllegalArgumentException if expression is {@code null}\n+     */\n+    public void setTrueExpression(AstNode trueExpression) {\n+        assertNotNull(trueExpression);\n+        this.trueExpression = trueExpression;\n+        trueExpression.setParent(this);\n+    }\n+\n+    /**\n+     * Returns expression to evaluate if test is false\n+     */\n+    public AstNode getFalseExpression() {\n+        return falseExpression;\n+    }\n+\n+    /**\n+     * Sets expression to evaluate if test is false, and sets its\n+     * parent to this node.\n+     * @param falseExpression expression to evaluate if test is false\n+     * @throws IllegalArgumentException if {@code falseExpression}\n+     * is {@code null}\n+     */\n+    public void setFalseExpression(AstNode falseExpression) {\n+        assertNotNull(falseExpression);\n+        this.falseExpression = falseExpression;\n+        falseExpression.setParent(this);\n+    }\n+\n+    /**\n+     * Returns position of ? token\n+     */\n+    public int getQuestionMarkPosition() {\n+        return questionMarkPosition;\n+    }\n+\n+    /**\n+     * Sets position of ? token\n+     * @param questionMarkPosition position of ? token\n+     */\n+    public void setQuestionMarkPosition(int questionMarkPosition) {\n+        this.questionMarkPosition = questionMarkPosition;\n+    }\n+\n+    /**\n+     * Returns position of : token\n+     */\n+    public int getColonPosition() {\n+        return colonPosition;\n+    }\n+\n+    /**\n+     * Sets position of : token\n+     * @param colonPosition position of : token\n+     */\n+    public void setColonPosition(int colonPosition) {\n+        this.colonPosition = colonPosition;\n+    }\n+\n+    @Override\n+    public boolean hasSideEffects() {\n+        if (testExpression == null\n+            || trueExpression == null\n+            || falseExpression == null) codeBug();\n+        return trueExpression.hasSideEffects()\n+               && falseExpression.hasSideEffects();\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(testExpression.toSource(depth));\n+        sb.append(\" ? \");\n+        sb.append(trueExpression.toSource(0));\n+        sb.append(\" : \");\n+        sb.append(falseExpression.toSource(0));\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the test-expression, the true-expression,\n+     * and the false-expression.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            testExpression.visit(v);\n+            trueExpression.visit(v);\n+            falseExpression.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ContinueStatement.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * A continue statement.\n+ * Node type is {@link Token#CONTINUE}.<p>\n+ *\n+ * <pre><i>ContinueStatement</i> :\n+ *   <b>continue</b> [<i>no LineTerminator here</i>] [Identifier] ;</pre>\n+ */\n+public class ContinueStatement extends Jump {\n+\n+    private Name label;\n+    private Loop target;\n+\n+    {\n+        type = Token.CONTINUE;\n+    }\n+\n+    public ContinueStatement() {\n+    }\n+\n+    public ContinueStatement(int pos) {\n+        this(pos, -1);\n+    }\n+\n+    public ContinueStatement(int pos, int len) {\n+        // can't call super (Jump) for historical reasons\n+        position = pos;\n+        length = len;\n+    }\n+\n+    public ContinueStatement(Name label) {\n+        setLabel(label);\n+    }\n+\n+    public ContinueStatement(int pos, Name label) {\n+        this(pos);\n+        setLabel(label);\n+    }\n+\n+    public ContinueStatement(int pos, int len, Name label) {\n+        this(pos, len);\n+        setLabel(label);\n+    }\n+\n+    /**\n+     * Returns continue target\n+     */\n+    public Loop getTarget() {\n+        return target;\n+    }\n+\n+    /**\n+     * Sets continue target.  Does NOT set the parent of the target node:\n+     * the target node is an ancestor of this node.\n+     * @param target continue target\n+     * @throws IllegalArgumentException if target is {@code null}\n+     */\n+    public void setTarget(Loop target) {\n+        assertNotNull(target);\n+        this.target = target;\n+        setJumpStatement(target);\n+    }\n+\n+    /**\n+     * Returns the intended label of this continue statement\n+     * @return the continue label.  Will be {@code null} if the statement\n+     * consisted only of the keyword \"continue\".\n+     */\n+    public Name getLabel() {\n+        return label;\n+    }\n+\n+    /**\n+     * Sets the intended label of this continue statement.\n+     * Only applies if the statement was of the form \"continue &lt;label&gt;\".\n+     * @param label the continue label, or {@code null} if not present.\n+     */\n+    public void setLabel(Name label) {\n+        this.label = label;\n+        if (label != null)\n+            label.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"continue\");\n+        if (label != null) {\n+            sb.append(\" \");\n+            sb.append(label.toSource(0));\n+        }\n+        sb.append(\";\\n\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then visits the label if non-{@code null}.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this) && label != null) {\n+            label.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/DestructuringForm.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+/**\n+ * Common interface for {@link ArrayLiteral} and {@link ObjectLiteral}\n+ * node types, both of which may appear in \"destructuring\" expressions or\n+ * contexts.\n+ */\n+public interface DestructuringForm {\n+\n+  /**\n+   * Marks this node as being a destructuring form - that is, appearing\n+   * in a context such as {@code for ([a, b] in ...)} where it's the\n+   * target of a destructuring assignment.\n+   */\n+  void setIsDestructuring(boolean destructuring);\n+    \n+  /**\n+   * Returns true if this node is in a destructuring position:\n+   * a function parameter, the target of a variable initializer, the\n+   * iterator of a for..in loop, etc.\n+   */\n+  boolean isDestructuring();\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/DoLoop.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * Do statement.  Node type is {@link Token#DO}.<p>\n+ *\n+ * <pre><i>DoLoop</i>:\n+ * <b>do</b> Statement <b>while</b> <b>(</b> Expression <b>)</b> <b>;</b></pre>\n+ */\n+public class DoLoop extends Loop {\n+\n+    private AstNode condition;\n+    private int whilePosition = -1;\n+\n+    {\n+        type = Token.DO;\n+    }\n+\n+    public DoLoop() {\n+    }\n+\n+    public DoLoop(int pos) {\n+        super(pos);\n+    }\n+\n+    public DoLoop(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns loop condition\n+     */\n+    public AstNode getCondition() {\n+        return condition;\n+    }\n+\n+    /**\n+     * Sets loop condition, and sets its parent to this node.\n+     * @throws IllegalArgumentException if condition is null\n+     */\n+    public void setCondition(AstNode condition) {\n+        assertNotNull(condition);\n+        this.condition = condition;\n+        condition.setParent(this);\n+    }\n+\n+    /**\n+     * Returns source position of \"while\" keyword\n+     */\n+    public int getWhilePosition() {\n+        return whilePosition;\n+    }\n+\n+    /**\n+     * Sets source position of \"while\" keyword\n+     */\n+    public void setWhilePosition(int whilePosition) {\n+        this.whilePosition = whilePosition;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"do \");\n+        sb.append(body.toSource(depth).trim());\n+        sb.append(\" while (\");\n+        sb.append(condition.toSource(0));\n+        sb.append(\");\\n\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the body, and then the while-expression.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            body.visit(v);\n+            condition.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ElementGet.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for an indexed property reference, such as {@code foo['bar']} or\n+ * {@code foo[2]}.  This is sometimes called an \"element-get\" operation, hence\n+ * the name of the node.<p>\n+ *\n+ * Node type is {@link Token#GETELEM}.<p>\n+ *\n+ * The node bounds extend from the beginning position of the target through the\n+ * closing right-bracket.  In the presence of a syntax error, the right bracket\n+ * position is -1, and the node ends at the end of the element expression.\n+ */\n+public class ElementGet extends AstNode {\n+\n+    private AstNode target;\n+    private AstNode element;\n+    private int lb = -1;\n+    private int rb = -1;\n+\n+    {\n+        type = Token.GETELEM;\n+    }\n+\n+    public ElementGet() {\n+    }\n+\n+    public ElementGet(int pos) {\n+        super(pos);\n+    }\n+\n+    public ElementGet(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    public ElementGet(AstNode target, AstNode element) {\n+        setTarget(target);\n+        setElement(element);\n+    }\n+\n+    /**\n+     * Returns the object on which the element is being fetched.\n+     */\n+    public AstNode getTarget() {\n+        return target;\n+    }\n+\n+    /**\n+     * Sets target object, and sets its parent to this node.\n+     * @param target expression evaluating to the object upon which\n+     * to do the element lookup\n+     * @throws IllegalArgumentException if target is {@code null}\n+     */\n+    public void setTarget(AstNode target) {\n+        assertNotNull(target);\n+        this.target = target;\n+        target.setParent(this);\n+    }\n+\n+    /**\n+     * Returns the element being accessed\n+     */\n+    public AstNode getElement() {\n+        return element;\n+    }\n+\n+    /**\n+     * Sets the element being accessed, and sets its parent to this node.\n+     * @throws IllegalArgumentException if element is {@code null}\n+     */\n+    public void setElement(AstNode element) {\n+        assertNotNull(element);\n+        this.element = element;\n+        element.setParent(this);\n+    }\n+\n+    /**\n+     * Returns left bracket position\n+     */\n+    public int getLb() {\n+        return lb;\n+    }\n+\n+    /**\n+     * Sets left bracket position\n+     */\n+    public void setLb(int lb) {\n+        this.lb = lb;\n+    }\n+\n+    /**\n+     * Returns right bracket position, -1 if missing\n+     */\n+    public int getRb() {\n+        return rb;\n+    }\n+\n+    /**\n+     * Sets right bracket position, -1 if not present\n+     */\n+    public void setRb(int rb) {\n+        this.rb = rb;\n+    }\n+\n+    public void setParens(int lb, int rb) {\n+        this.lb = lb;\n+        this.rb = rb;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(target.toSource(0));\n+        sb.append(\"[\");\n+        sb.append(element.toSource(0));\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the target, and the index expression.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            target.visit(v);\n+            element.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/EmptyExpression.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for an empty expression.  Node type is {@link Token#EMPTY}.<p>\n+ *\n+ * To create an empty statement, wrap it with an {@link ExpressionStatement}.\n+ */\n+public class EmptyExpression extends AstNode {\n+\n+    {\n+        type = Token.EMPTY;\n+    }\n+\n+    public EmptyExpression() {\n+    }\n+\n+    public EmptyExpression(int pos) {\n+        super(pos);\n+    }\n+\n+    public EmptyExpression(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        return makeIndent(depth);\n+    }\n+\n+    /**\n+     * Visits this node.  There are no children.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        v.visit(this);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ErrorCollector.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.EvaluatorException;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * An error reporter that gathers the errors and warnings for later display.\n+ * This a useful {@link org.mozilla.javascript.ErrorReporter} when the\n+ * {@link org.mozilla.javascript.CompilerEnvirons} is set to\n+ * ide-mode (for IDEs).\n+ *\n+ */\n+public class ErrorCollector implements IdeErrorReporter {\n+\n+    private List<ParseProblem> errors = new ArrayList<ParseProblem>();\n+\n+    /**\n+     * This is not called during AST generation.\n+     * {@link #warning(String,String,int,int)} is used instead.\n+     * @throws UnsupportedOperationException\n+     */\n+    public void warning(String message, String sourceName, int line,\n+                        String lineSource, int lineOffset) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * @inheritDoc\n+     */\n+    public void warning(String message, String sourceName, int offset, int length)\n+    {\n+        errors.add(new ParseProblem(ParseProblem.Type.Warning,\n+                                    message, sourceName,\n+                                    offset, length));\n+    }\n+\n+    /**\n+     * This is not called during AST generation.\n+     * {@link #warning(String,String,int,int)} is used instead.\n+     * @throws UnsupportedOperationException\n+     */\n+    public void error(String message, String sourceName, int line,\n+                      String lineSource, int lineOffset)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * @inheritDoc\n+     */\n+    public void error(String message, String sourceName,\n+                      int fileOffset, int length)\n+    {\n+        errors.add(new ParseProblem(ParseProblem.Type.Error,\n+                                    message, sourceName,\n+                                    fileOffset, length));\n+    }\n+\n+    /**\n+     * @inheritDoc\n+     */\n+    public EvaluatorException runtimeError(String message, String sourceName,\n+                                           int line, String lineSource,\n+                                           int lineOffset)\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Returns the list of errors and warnings produced during parsing.\n+     */\n+    public List<ParseProblem> getErrors() {\n+        return errors;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(errors.size() * 100);\n+        for (ParseProblem pp : errors) {\n+            sb.append(pp.toString()).append(\"\\n\");\n+        }\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ErrorNode.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node representing a parse error or a warning.  Node type is\n+ * {@link Token#ERROR}.<p>\n+ */\n+public class ErrorNode extends AstNode {\n+\n+    private String message;\n+\n+    {\n+        type = Token.ERROR;\n+    }\n+\n+    public ErrorNode() {\n+    }\n+\n+    public ErrorNode(int pos) {\n+        super(pos);\n+    }\n+\n+    public ErrorNode(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns error message key\n+     */\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    /**\n+     * Sets error message key\n+     */\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        return \"\";\n+    }\n+\n+    /**\n+     * Error nodes are not visited during normal visitor traversals,\n+     * but comply with the {@link AstNode#visit} interface.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        v.visit(this);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ExpressionStatement.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node representing an expression in a statement context.  The node type is\n+ * {@link Token#EXPR_VOID} if inside a function, or else\n+ * {@link Token#EXPR_RESULT} if inside a script.\n+ */\n+public class ExpressionStatement extends AstNode {\n+\n+    private AstNode expr;\n+\n+    {\n+        type = Token.EXPR_VOID;\n+    }\n+\n+    /**\n+     * Called by the parser to set node type to EXPR_RESULT\n+     * if this node is not within a Function.\n+     */\n+    public void setHasResult() {\n+        type = Token.EXPR_RESULT;\n+    }\n+\n+    public ExpressionStatement() {\n+    }\n+\n+    /**\n+     * Constructs a new {@code ExpressionStatement} wrapping\n+     * the specified expression.  Sets this node's position to the\n+     * position of the wrapped node, and sets the wrapped node's\n+     * position to zero.  Sets this node's length to the length of\n+     * the wrapped node.\n+     * @param expr the wrapped expression\n+     * @param hasResult {@code true} if this expression has side\n+     * effects.  If true, sets node type to EXPR_RESULT, else to EXPR_VOID.\n+     */\n+    public ExpressionStatement(AstNode expr, boolean hasResult) {\n+        this(expr);\n+        if (hasResult) setHasResult();\n+    }\n+\n+    /**\n+     * Constructs a new {@code ExpressionStatement} wrapping\n+     * the specified expression.  Sets this node's position to the\n+     * position of the wrapped node, and sets the wrapped node's\n+     * position to zero.  Sets this node's length to the length of\n+     * the wrapped node.\n+     * @param expr the wrapped expression\n+     */\n+    public ExpressionStatement(AstNode expr) {\n+        this(expr.getPosition(), expr.getLength(), expr);\n+    }\n+\n+    public ExpressionStatement(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Constructs a new {@code ExpressionStatement}\n+     * @param expr the wrapped {@link AstNode}.\n+     * The {@code ExpressionStatement}'s bounds are set to those of expr,\n+     * and expr's parent is set to this node.\n+     * @throws IllegalArgumentException if {@code expr} is null\n+     */\n+    public ExpressionStatement(int pos, int len, AstNode expr) {\n+        super(pos, len);\n+        setExpression(expr);\n+    }\n+\n+    /**\n+     * Returns the wrapped expression\n+     */\n+    public AstNode getExpression() {\n+        return expr;\n+    }\n+\n+    /**\n+     * Sets the wrapped expression, and sets its parent to this node.\n+     * @throws IllegalArgumentException} if expression is {@code null}\n+     */\n+    public void setExpression(AstNode expression) {\n+        assertNotNull(expression);\n+        expr = expression;\n+        expression.setParent(this);\n+        setLineno(expression.getLineno());\n+    }\n+\n+    /**\n+     * Returns true if this node has side effects\n+     * @throws IllegalStateException if expression has not yet\n+     * been set.\n+     */\n+    @Override\n+    public boolean hasSideEffects() {\n+        return type == Token.EXPR_RESULT || expr.hasSideEffects();\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(expr.toSource(depth));\n+        sb.append(\";\\n\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the wrapped statement.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            expr.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ForInLoop.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * For-in or for-each-in statement.  Node type is {@link Token#FOR}.<p>\n+ *\n+ * <pre><b>for</b> [<b>each</b>] ( LeftHandSideExpression <b>in</b> Expression ) Statement</pre>\n+ * <pre><b>for</b> [<b>each</b>] ( <b>var</b> VariableDeclarationNoIn <b>in</b> Expression ) Statement</pre>\n+ */\n+public class ForInLoop extends Loop {\n+\n+    protected AstNode iterator;\n+    protected AstNode iteratedObject;\n+    protected int inPosition = -1;\n+    protected int eachPosition = -1;\n+    protected boolean isForEach;\n+\n+    {\n+        type = Token.FOR;\n+    }\n+\n+    public ForInLoop() {\n+    }\n+\n+    public ForInLoop(int pos) {\n+        super(pos);\n+    }\n+\n+    public ForInLoop(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns loop iterator expression\n+     */\n+    public AstNode getIterator() {\n+        return iterator;\n+    }\n+\n+    /**\n+     * Sets loop iterator expression:  the part before the \"in\" keyword.\n+     * Also sets its parent to this node.\n+     * @throws IllegalArgumentException if {@code iterator} is {@code null}\n+     */\n+    public void setIterator(AstNode iterator) {\n+        assertNotNull(iterator);\n+        this.iterator = iterator;\n+        iterator.setParent(this);\n+    }\n+\n+    /**\n+     * Returns object being iterated over\n+     */\n+    public AstNode getIteratedObject() {\n+        return iteratedObject;\n+    }\n+\n+    /**\n+     * Sets object being iterated over, and sets its parent to this node.\n+     * @throws IllegalArgumentException if {@code object} is {@code null}\n+     */\n+    public void setIteratedObject(AstNode object) {\n+        assertNotNull(object);\n+        this.iteratedObject = object;\n+        object.setParent(this);\n+    }\n+\n+    /**\n+     * Returns whether the loop is a for-each loop\n+     */\n+    public boolean isForEach() {\n+        return isForEach;\n+    }\n+\n+    /**\n+     * Sets whether the loop is a for-each loop\n+     */\n+    public void setIsForEach(boolean isForEach) {\n+        this.isForEach = isForEach;\n+    }\n+\n+    /**\n+     * Returns position of \"in\" keyword\n+     */\n+    public int getInPosition() {\n+        return inPosition;\n+    }\n+\n+    /**\n+     * Sets position of \"in\" keyword\n+     * @param inPosition position of \"in\" keyword,\n+     * or -1 if not present (e.g. in presence of a syntax error)\n+     */\n+    public void setInPosition(int inPosition) {\n+        this.inPosition = inPosition;\n+    }\n+\n+    /**\n+     * Returns position of \"each\" keyword\n+     */\n+    public int getEachPosition() {\n+        return eachPosition;\n+    }\n+\n+    /**\n+     * Sets position of \"each\" keyword\n+     * @param eachPosition position of \"each\" keyword,\n+     * or -1 if not present.\n+     */\n+    public void setEachPosition(int eachPosition) {\n+        this.eachPosition = eachPosition;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"for \");\n+        if (isForEach()) {\n+            sb.append(\"each \");\n+        }\n+        sb.append(\"(\");\n+        sb.append(iterator.toSource(0));\n+        sb.append(\" in \");\n+        sb.append(iteratedObject.toSource(0));\n+        sb.append(\") \");\n+        if (body instanceof Block) {\n+            sb.append(body.toSource(depth).trim()).append(\"\\n\");\n+        } else {\n+            sb.append(\"\\n\").append(body.toSource(depth+1));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the iterator, the iterated object, and the body.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            iterator.visit(v);\n+            iteratedObject.visit(v);\n+            body.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ForLoop.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * C-style for-loop statement.\n+ * Node type is {@link Token#FOR}.<p>\n+ *\n+ * <pre><b>for</b> ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement</pre>\n+ * <pre><b>for</b> ( <b>var</b> VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement</pre>\n+ */\n+public class ForLoop extends Loop {\n+\n+    private AstNode initializer;\n+    private AstNode condition;\n+    private AstNode increment;\n+\n+    {\n+        type = Token.FOR;\n+    }\n+\n+    public ForLoop() {\n+    }\n+\n+    public ForLoop(int pos) {\n+        super(pos);\n+    }\n+\n+    public ForLoop(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns loop initializer variable declaration list.\n+     * This is either a {@link VariableDeclaration}, an\n+     * {@link Assignment}, or an {@link InfixExpression} of\n+     * type COMMA that chains multiple variable assignments.\n+     */\n+    public AstNode getInitializer() {\n+        return initializer;\n+    }\n+\n+    /**\n+     * Sets loop initializer expression, and sets its parent\n+     * to this node.  Virtually any expression can be in the initializer,\n+     * so no error-checking is done other than a {@code null}-check.\n+     * @param initializer loop initializer.  Pass an\n+     * {@link EmptyExpression} if the initializer is not specified.\n+     * @throws IllegalArgumentException if condition is {@code null}\n+     */\n+    public void setInitializer(AstNode initializer) {\n+        assertNotNull(initializer);\n+        this.initializer = initializer;\n+        initializer.setParent(this);\n+    }\n+\n+    /**\n+     * Returns loop condition\n+     */\n+    public AstNode getCondition() {\n+        return condition;\n+    }\n+\n+    /**\n+     * Sets loop condition, and sets its parent to this node.\n+     * @param condition loop condition.  Pass an {@link EmptyExpression}\n+     * if the condition is missing.\n+     * @throws IllegalArgumentException} if condition is {@code null}\n+     */\n+    public void setCondition(AstNode condition) {\n+        assertNotNull(condition);\n+        this.condition = condition;\n+        condition.setParent(this);\n+    }\n+\n+    /**\n+     * Returns loop increment expression\n+     */\n+    public AstNode getIncrement() {\n+        return increment;\n+    }\n+\n+    /**\n+     * Sets loop increment expression, and sets its parent to\n+     * this node.\n+     * @param increment loop increment expression.  Pass an\n+     * {@link EmptyExpression} if increment is {@code null}.\n+     * @throws IllegalArgumentException} if increment is {@code null}\n+     */\n+    public void setIncrement(AstNode increment) {\n+        assertNotNull(increment);\n+        this.increment = increment;\n+        increment.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"for (\");\n+        sb.append(initializer.toSource(0));\n+        sb.append(\"; \");\n+        sb.append(condition.toSource(0));\n+        sb.append(\"; \");\n+        sb.append(increment.toSource(0));\n+        sb.append(\") \");\n+        if (body instanceof Block) {\n+            sb.append(body.toSource(depth).trim()).append(\"\\n\");\n+        } else {\n+            sb.append(\"\\n\").append(body.toSource(depth+1));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the initializer expression, the loop condition\n+     * expression, the increment expression, and then the loop body.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            initializer.visit(v);\n+            condition.visit(v);\n+            increment.visit(v);\n+            body.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/FunctionCall.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * AST node for a function call.  Node type is {@link Token#CALL}.<p>\n+ */\n+public class FunctionCall extends AstNode {\n+\n+    protected static final List<AstNode> NO_ARGS =\n+        Collections.unmodifiableList(new ArrayList<AstNode>());\n+        \n+    protected AstNode target;\n+    protected List<AstNode> arguments;\n+    protected int lp = -1;\n+    protected int rp = -1;\n+\n+    {\n+        type = Token.CALL;\n+    }\n+\n+    public FunctionCall() {\n+    }\n+\n+    public FunctionCall(int pos) {\n+        super(pos);\n+    }\n+\n+    public FunctionCall(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns node evaluating to the function to call\n+     */\n+    public AstNode getTarget() {\n+        return target;\n+    }\n+\n+    /**\n+     * Sets node evaluating to the function to call, and sets\n+     * its parent to this node.\n+     * @param target node evaluating to the function to call.\n+     * @throws IllegalArgumentException} if target is {@code null}\n+     */\n+    public void setTarget(AstNode target) {\n+        assertNotNull(target);\n+        this.target = target;\n+        target.setParent(this);\n+    }\n+\n+    /**\n+     * Returns function argument list\n+     * @return function argument list, or an empty immutable list if\n+     *         there are no arguments.\n+     */\n+    public List<AstNode> getArguments() {\n+        return arguments != null ? arguments : NO_ARGS;\n+    }\n+\n+    /**\n+     * Sets function argument list\n+     * @param arguments function argument list.  Can be {@code null},\n+     *        in which case any existing args are removed.\n+     */\n+    public void setArguments(List<AstNode> arguments) {\n+        if (arguments == null) {\n+            this.arguments = null;\n+        } else {\n+            if (this.arguments != null)\n+                this.arguments.clear();\n+            for (AstNode arg : arguments) {\n+                addArgument(arg);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds an argument to the list, and sets its parent to this node.\n+     * @param arg the argument node to add to the list\n+     * @throws IllegalArgumentException} if arg is {@code null}\n+     */\n+    public void addArgument(AstNode arg) {\n+        assertNotNull(arg);\n+        if (arguments == null) {\n+            arguments = new ArrayList<AstNode>();\n+        }\n+        arguments.add(arg);\n+        arg.setParent(this);\n+    }\n+\n+    /**\n+     * Returns left paren position, -1 if missing\n+     */\n+    public int getLp() {\n+        return lp;\n+    }\n+\n+    /**\n+     * Sets left paren position\n+     * @param lp left paren position\n+     */\n+    public void setLp(int lp) {\n+        this.lp = lp;\n+    }\n+\n+    /**\n+     * Returns right paren position, -1 if missing\n+     */\n+    public int getRp() {\n+        return rp;\n+    }\n+\n+    /**\n+     * Sets right paren position\n+     */\n+    public void setRp(int rp) {\n+        this.rp = rp;\n+    }\n+\n+    /**\n+     * Sets both paren positions\n+     */\n+    public void setParens(int lp, int rp) {\n+        this.lp = lp;\n+        this.rp = rp;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(target.toSource(0));\n+        sb.append(\"(\");\n+        if (arguments != null) {\n+            printList(arguments, sb);\n+        }\n+        sb.append(\")\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the target object, and the arguments.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            target.visit(v);\n+            for (AstNode arg : getArguments()) {\n+                arg.visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/FunctionNode.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Bob Jervis\n+ *   Norris Boyd\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A JavaScript function declaration or expression.<p>\n+ * Node type is {@link Token#FUNCTION}.<p>\n+ *\n+ * <pre><i>FunctionDeclaration</i> :\n+ *        <b>function</b> Identifier ( FormalParameterListopt ) { FunctionBody }\n+ * <i>FunctionExpression</i> :\n+ *        <b>function</b> Identifieropt ( FormalParameterListopt ) { FunctionBody }\n+ * <i>FormalParameterList</i> :\n+ *        Identifier\n+ *        FormalParameterList , Identifier\n+ * <i>FunctionBody</i> :\n+ *        SourceElements\n+ * <i>Program</i> :\n+ *        SourceElements\n+ * <i>SourceElements</i> :\n+ *        SourceElement\n+ *        SourceElements SourceElement\n+ * <i>SourceElement</i> :\n+ *        Statement\n+ *        FunctionDeclaration</pre>\n+ *\n+ * JavaScript 1.8 introduces \"function closures\" of the form\n+ *  <pre>function ([params] ) Expression</pre>\n+ *\n+ * In this case the FunctionNode node will have no body but will have an\n+ * expression.\n+ */\n+public class FunctionNode extends ScriptNode {\n+\n+    /**\n+     * There are three types of functions that can be defined. The first\n+     * is a function statement. This is a function appearing as a top-level\n+     * statement (i.e., not nested inside some other statement) in either a\n+     * script or a function.<p>\n+     *\n+     * The second is a function expression, which is a function appearing in\n+     * an expression except for the third type, which is...<p>\n+     *\n+     * The third type is a function expression where the expression is the\n+     * top-level expression in an expression statement.<p>\n+     *\n+     * The three types of functions have different treatment and must be\n+     * distinguished.<p>\n+     */\n+    public static final int FUNCTION_STATEMENT            = 1;\n+    public static final int FUNCTION_EXPRESSION           = 2;\n+    public static final int FUNCTION_EXPRESSION_STATEMENT = 3;\n+\n+    public static enum Form { FUNCTION, GETTER, SETTER }\n+\n+    private static final List<AstNode> NO_PARAMS =\n+        Collections.unmodifiableList(new ArrayList<AstNode>());\n+\n+    private Name functionName;\n+    private List<AstNode> params;\n+    private AstNode body;\n+    private boolean isExpressionClosure;\n+    private Form functionForm = Form.FUNCTION;\n+    private int lp = -1;\n+    private int rp = -1;\n+\n+    // codegen variables\n+    private int functionType;\n+    private boolean needsActivation;\n+    private boolean ignoreDynamicScope;\n+    private boolean isGenerator;\n+    private List<Node> generatorResumePoints;\n+    private Map<Node,int[]> liveLocals;\n+    private AstNode memberExprNode;\n+\n+    {\n+        type = Token.FUNCTION;\n+    }\n+\n+    public FunctionNode() {\n+    }\n+\n+    public FunctionNode(int pos) {\n+        super(pos);\n+    }\n+\n+    public FunctionNode(int pos, Name name) {\n+        super(pos);\n+        setFunctionName(name);\n+    }\n+\n+    /**\n+     * Returns function name\n+     * @return function name, {@code null} for anonymous functions\n+     */\n+    public Name getFunctionName() {\n+        return functionName;\n+    }\n+\n+    /**\n+     * Sets function name, and sets its parent to this node.\n+     * @param name function name, {@code null} for anonymous functions\n+     */\n+    public void setFunctionName(Name name) {\n+        functionName = name;\n+        if (name != null)\n+            name.setParent(this);\n+    }\n+\n+    /**\n+     * Returns the function name as a string\n+     * @return the function name, {@code \"\"} if anonymous\n+     */\n+    public String getName() {\n+        return functionName != null ? functionName.getIdentifier() : \"\";\n+    }\n+\n+    /**\n+     * Returns the function parameter list\n+     * @return the function parameter list.  Returns an immutable empty\n+     *         list if there are no parameters.\n+     */\n+    public List<AstNode> getParams() {\n+        return params != null ? params : NO_PARAMS;\n+    }\n+\n+    /**\n+     * Sets the function parameter list, and sets the parent for\n+     * each element of the list.\n+     * @param params the function parameter list, or {@code null} if no params\n+     */\n+    public void setParams(List<AstNode> params) {\n+        if (params == null) {\n+            this.params = null;\n+        } else {\n+            if (this.params != null)\n+                this.params.clear();\n+            for (AstNode param : params)\n+                addParam(param);\n+        }\n+    }\n+\n+    /**\n+     * Adds a parameter to the function parameter list.\n+     * Sets the parent of the param node to this node.\n+     * @param param the parameter\n+     * @throws IllegalArgumentException if param is {@code null}\n+     */\n+    public void addParam(AstNode param) {\n+        assertNotNull(param);\n+        if (params == null) {\n+            params = new ArrayList<AstNode>();\n+        }\n+        params.add(param);\n+        param.setParent(this);\n+    }\n+\n+    /**\n+     * Returns true if the specified {@link AstNode} node is a parameter\n+     * of this Function node.  This provides a way during AST traversal\n+     * to disambiguate the function name node from the parameter nodes.\n+     */\n+    public boolean isParam(AstNode node) {\n+        return params == null ? false : params.contains(node);\n+    }\n+\n+    /**\n+     * Returns function body.  Normally a {@link Block}, but can be a plain\n+     * {@link AstNode} if it's a function closure.\n+     *\n+     * @return the body.  Can be {@code null} only if the AST is malformed.\n+     */\n+    public AstNode getBody() {\n+        return body;\n+    }\n+\n+    /**\n+     * Sets function body, and sets its parent to this node.\n+     * Also sets the encoded source bounds based on the body bounds.\n+     * Assumes the function node absolute position has already been set,\n+     * and the body node's absolute position and length are set.<p>\n+     *\n+     * @param body function body.  Its parent is set to this node, and its\n+     * position is updated to be relative to this node.\n+     *\n+     * @throws IllegalArgumentException if body is {@code null}\n+     */\n+    public void setBody(AstNode body) {\n+        assertNotNull(body);\n+        this.body = body;\n+        if (Boolean.TRUE.equals(body.getProp(Node.EXPRESSION_CLOSURE_PROP))) {\n+            setIsExpressionClosure(true);\n+        }\n+        int absEnd = body.getPosition() + body.getLength();\n+        body.setParent(this);\n+        this.setLength(absEnd - this.position);\n+        setEncodedSourceBounds(this.position, absEnd);\n+    }\n+\n+    /**\n+     * Returns left paren position, -1 if missing\n+     */\n+    public int getLp() {\n+        return lp;\n+    }\n+\n+    /**\n+     * Sets left paren position\n+     */\n+    public void setLp(int lp) {\n+        this.lp = lp;\n+    }\n+\n+    /**\n+     * Returns right paren position, -1 if missing\n+     */\n+    public int getRp() {\n+        return rp;\n+    }\n+\n+    /**\n+     * Sets right paren position\n+     */\n+    public void setRp(int rp) {\n+        this.rp = rp;\n+    }\n+\n+    /**\n+     * Sets both paren positions\n+     */\n+    public void setParens(int lp, int rp) {\n+        this.lp = lp;\n+        this.rp = rp;\n+    }\n+\n+    /**\n+     * Returns whether this is a 1.8 function closure\n+     */\n+    public boolean isExpressionClosure() {\n+        return isExpressionClosure;\n+    }\n+\n+    /**\n+     * Sets whether this is a 1.8 function closure\n+     */\n+    public void setIsExpressionClosure(boolean isExpressionClosure) {\n+        this.isExpressionClosure = isExpressionClosure;\n+    }\n+\n+    /**\n+     * Return true if this function requires an Ecma-262 Activation object.\n+     * The Activation object is implemented by\n+     * {@link org.mozilla.javascript.NativeCall}, and is fairly expensive\n+     * to create, so when possible, the interpreter attempts to use a plain\n+     * call frame instead.\n+     *\n+     * @return true if this function needs activation.  It could be needed\n+     * if there is a lexical closure, or dynamic scope, or in a number of\n+     * other situations.\n+     */\n+    public boolean requiresActivation() {\n+        return needsActivation;\n+    }\n+\n+    public void setRequiresActivation() {\n+        needsActivation = true;\n+    }\n+\n+    public boolean getIgnoreDynamicScope() {\n+        return ignoreDynamicScope;\n+    }\n+\n+    public void setIgnoreDynamicScope() {\n+        ignoreDynamicScope = true;\n+    }\n+\n+    public boolean isGenerator() {\n+      return isGenerator;\n+    }\n+\n+    public void setIsGenerator() {\n+        isGenerator = true;\n+    }\n+\n+    public void addResumptionPoint(Node target) {\n+        if (generatorResumePoints == null)\n+            generatorResumePoints = new ArrayList<Node>();\n+        generatorResumePoints.add(target);\n+    }\n+\n+    public List<Node> getResumptionPoints() {\n+        return generatorResumePoints;\n+    }\n+\n+    public Map<Node,int[]> getLiveLocals() {\n+        return liveLocals;\n+    }\n+\n+    public void addLiveLocals(Node node, int[] locals) {\n+        if (liveLocals == null)\n+            liveLocals = new HashMap<Node,int[]>();\n+        liveLocals.put(node, locals);\n+    }\n+\n+    @Override\n+    public int addFunction(FunctionNode fnNode) {\n+        int result = super.addFunction(fnNode);\n+        if (getFunctionCount() > 0) {\n+            needsActivation = true;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the function type (statement, expr, statement expr)\n+     */\n+    public int getFunctionType() {\n+        return functionType;\n+    }\n+\n+    public void setFunctionType(int type) {\n+        functionType = type;\n+    }\n+\n+    public boolean isGetterOrSetter() {\n+        return functionForm == Form.GETTER || functionForm == Form.SETTER;\n+    }\n+\n+    public boolean isGetter() {\n+        return functionForm == Form.GETTER;\n+    }\n+\n+    public boolean isSetter() {\n+        return functionForm == Form.SETTER;\n+    }\n+\n+    public void setFunctionIsGetter() {\n+        functionForm = Form.GETTER;\n+    }\n+\n+    public void setFunctionIsSetter() {\n+        functionForm = Form.SETTER;\n+    }\n+\n+    /**\n+     * Rhino supports a nonstandard Ecma extension that allows you to\n+     * say, for instance, function a.b.c(arg1, arg) {...}, and it will\n+     * be rewritten at codegen time to:  a.b.c = function(arg1, arg2) {...}\n+     * If we detect an expression other than a simple Name in the position\n+     * where a function name was expected, we record that expression here.\n+     * <p>\n+     * This extension is only available by setting the CompilerEnv option\n+     * \"isAllowMemberExprAsFunctionName\" in the Parser.\n+     */\n+    public void setMemberExprNode(AstNode node) {\n+        memberExprNode = node;\n+        if (node != null)\n+            node.setParent(this);\n+    }\n+\n+    public AstNode getMemberExprNode() {\n+        return memberExprNode;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"function\");\n+        if (functionName != null) {\n+            sb.append(\" \");\n+            sb.append(functionName.toSource(0));\n+        }\n+        if (params == null) {\n+            sb.append(\"() \");\n+        } else {\n+            sb.append(\"(\");\n+            printList(params, sb);\n+            sb.append(\") \");\n+        }\n+        if (isExpressionClosure) {\n+            sb.append(\" \");\n+            sb.append(getBody().toSource(0));\n+        } else {\n+            sb.append(getBody().toSource(depth).trim());\n+        }\n+        if (functionType == FUNCTION_STATEMENT) {\n+            sb.append(\"\\n\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the function name node if supplied,\n+     * the parameters, and the body.  If there is a member-expr node,\n+     * it is visited last.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            if (functionName != null) {\n+                functionName.visit(v);\n+            }\n+            for (AstNode param : getParams()) {\n+                param.visit(v);\n+            }\n+            getBody().visit(v);\n+            if (!isExpressionClosure) {\n+                if (memberExprNode != null) {\n+                    memberExprNode.visit(v);\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/IdeErrorReporter.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.ErrorReporter;\n+\n+/**\n+ * This is interface defines a protocol for the reporting of\n+ * errors during JavaScript translation in IDE-mode.\n+ * If the {@link org.mozilla.javascript.Parser}'s error reporter is\n+ * set to an instance of this interface, then this interface's\n+ * {@link #warning} and {@link #error} methods are called instead\n+ * of the {@link org.mozilla.javascript.ErrorReporter} versions. <p>\n+ *\n+ * These methods take a source char offset and a length.  The\n+ * rationale is that in interactive IDE-type environments, the source\n+ * is available and the IDE will want to indicate where the error\n+ * occurred and how much code participates in it.  The start and length\n+ * are generally chosen to fit within a single line, for readability,\n+ * but the client is free to use the AST to determine the affected\n+ * node(s) from the start position and change the error or warning's\n+ * display bounds.<p>\n+ *\n+ */\n+public interface IdeErrorReporter extends ErrorReporter {\n+\n+    /**\n+     * Report a warning.<p>\n+     *\n+     * The implementing class may choose to ignore the warning\n+     * if it desires.\n+     *\n+     * @param message a {@code String} describing the warning\n+     * @param sourceName a {@code String} describing the JavaScript source\n+     * where the warning occured; typically a filename or URL\n+     * @param offset the warning's 0-indexed char position in the input stream\n+     * @param length the length of the region contributing to the warning\n+     */\n+    void warning(String message, String sourceName, int offset, int length);\n+\n+    /**\n+     * Report an error.<p>\n+     *\n+     * The implementing class is free to throw an exception if\n+     * it desires.<p>\n+     *\n+     * If execution has not yet begun, the JavaScript engine is\n+     * free to find additional errors rather than terminating\n+     * the translation. It will not execute a script that had\n+     * errors, however.<p>\n+     *\n+     * @param message a String describing the error\n+     * @param sourceName a String describing the JavaScript source\n+     * where the error occured; typically a filename or URL\n+     * @param offset 0-indexed char position of the error in the input stream\n+     * @param length the length of the region contributing to the error\n+     */\n+    void error(String message, String sourceName, int offset, int length);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/IfStatement.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * If-else statement.  Node type is {@link Token#IF}.<p>\n+ *\n+ * <pre><i>IfStatement</i> :\n+ *       <b>if</b> ( Expression ) Statement <b>else</b> Statement\n+ *       <b>if</b> ( Expression ) Statement</pre>\n+ */\n+public class IfStatement extends AstNode {\n+\n+    private AstNode condition;\n+    private AstNode thenPart;\n+    private int elsePosition = -1;\n+    private AstNode elsePart;\n+    private int lp = -1;\n+    private int rp = -1;\n+\n+    {\n+        type = Token.IF;\n+    }\n+\n+    public IfStatement() {\n+    }\n+\n+    public IfStatement(int pos) {\n+        super(pos);\n+    }\n+\n+    public IfStatement(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns if condition\n+     */\n+    public AstNode getCondition() {\n+        return condition;\n+    }\n+\n+    /**\n+     * Sets if condition.\n+     * @throws IllegalArgumentException if {@code condition} is {@code null}.\n+     */\n+    public void setCondition(AstNode condition) {\n+        assertNotNull(condition);\n+        this.condition = condition;\n+        condition.setParent(this);\n+    }\n+\n+    /**\n+     * Returns statement to execute if condition is true\n+     */\n+    public AstNode getThenPart() {\n+        return thenPart;\n+    }\n+\n+    /**\n+     * Sets statement to execute if condition is true\n+     * @throws IllegalArgumentException if thenPart is {@code null}\n+     */\n+    public void setThenPart(AstNode thenPart) {\n+        assertNotNull(thenPart);\n+        this.thenPart = thenPart;\n+        thenPart.setParent(this);\n+    }\n+\n+    /**\n+     * Returns statement to execute if condition is false\n+     */\n+    public AstNode getElsePart() {\n+        return elsePart;\n+    }\n+\n+    /**\n+     * Sets statement to execute if condition is false\n+     * @param elsePart statement to execute if condition is false.\n+     * Can be {@code null}.\n+     */\n+    public void setElsePart(AstNode elsePart) {\n+        this.elsePart = elsePart;\n+        if (elsePart != null)\n+            elsePart.setParent(this);\n+    }\n+\n+    /**\n+     * Returns position of \"else\" keyword, or -1\n+     */\n+    public int getElsePosition() {\n+        return elsePosition;\n+    }\n+\n+    /**\n+     * Sets position of \"else\" keyword, -1 if not present\n+     */\n+    public void setElsePosition(int elsePosition) {\n+        this.elsePosition = elsePosition;\n+    }\n+\n+    /**\n+     * Returns left paren offset\n+     */\n+    public int getLp() {\n+        return lp;\n+    }\n+\n+    /**\n+     * Sets left paren offset\n+     */\n+    public void setLp(int lp) {\n+        this.lp = lp;\n+    }\n+\n+    /**\n+     * Returns right paren position, -1 if missing\n+     */\n+    public int getRp() {\n+        return rp;\n+    }\n+\n+    /**\n+     * Sets right paren position, -1 if missing\n+     */\n+    public void setRp(int rp) {\n+        this.rp = rp;\n+    }\n+\n+    /**\n+     * Sets both paren positions\n+     */\n+    public void setParens(int lp, int rp) {\n+        this.lp = lp;\n+        this.rp = rp;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        String pad = makeIndent(depth);\n+        StringBuilder sb = new StringBuilder(32);\n+        sb.append(pad);\n+        sb.append(\"if (\");\n+        sb.append(condition.toSource(0));\n+        sb.append(\") \");\n+        if (!(thenPart instanceof Block)) {\n+            sb.append(\"\\n\").append(makeIndent(depth));\n+        }\n+        sb.append(thenPart.toSource(depth).trim());\n+        if (elsePart instanceof IfStatement) {\n+            sb.append(\" else \");\n+            sb.append(elsePart.toSource(depth).trim());\n+        } else if (elsePart != null) {\n+            sb.append(\" else \");\n+            sb.append(elsePart.toSource(depth).trim());\n+        }\n+        sb.append(\"\\n\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the condition, the then-part, and\n+     * if supplied, the else-part.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            condition.visit(v);\n+            thenPart.visit(v);\n+            if (elsePart != null) {\n+                elsePart.visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/InfixExpression.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node representing an infix (binary operator) expression.\n+ * The operator is the node's {@link Token} type.\n+ */\n+public class InfixExpression extends AstNode {\n+\n+    protected AstNode left;\n+    protected AstNode right;\n+    protected int operatorPosition = -1;\n+\n+    public InfixExpression() {\n+    }\n+\n+    public InfixExpression(int pos) {\n+        super(pos);\n+    }\n+\n+    public InfixExpression(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    public InfixExpression(int pos, int len,\n+                           AstNode left,\n+                           AstNode right) {\n+        super(pos, len);\n+        setLeft(left);\n+        setRight(right);\n+    }\n+\n+    /**\n+     * Constructs a new {@code InfixExpression}.  Updates bounds to include\n+     * left and right nodes.\n+     */\n+    public InfixExpression(AstNode left, AstNode right) {\n+        setLeftAndRight(left, right);\n+    }\n+\n+    /**\n+     * Constructs a new {@code InfixExpression}.\n+     * @param operatorPos the <em>absolute</em> position of the operator\n+     */\n+    public InfixExpression(int operator, AstNode left,\n+                           AstNode right, int operatorPos) {\n+        setType(operator);\n+        setOperatorPosition(operatorPos - left.getPosition());\n+        setLeftAndRight(left, right);\n+    }\n+\n+    public void setLeftAndRight(AstNode left, AstNode right) {\n+        assertNotNull(left);\n+        assertNotNull(right);\n+        // compute our bounds while children have absolute positions\n+        int beg = left.getPosition();\n+        int end = right.getPosition() + right.getLength();\n+        setBounds(beg, end);\n+        // this updates their positions to be parent-relative\n+        setLeft(left);\n+        setRight(right);\n+    }\n+\n+    /**\n+     * Returns operator token &ndash; alias for {@link #getType}\n+     */\n+    public int getOperator() {\n+        return getType();\n+    }\n+\n+    /**\n+     * Sets operator token &ndash; like {@link #setType}, but throws\n+     * an exception if the operator is invalid.\n+     * @throws IllegalArgumentException if operator is not a valid token\n+     * code\n+     */\n+    public void setOperator(int operator) {\n+        if (!Token.isValidToken(operator))\n+            throw new IllegalArgumentException(\"Invalid token: \" + operator);\n+        setType(operator);\n+    }\n+\n+    /**\n+     * Returns the left-hand side of the expression\n+     */\n+    public AstNode getLeft() {\n+        return left;\n+    }\n+\n+    /**\n+     * Sets the left-hand side of the expression, and sets its\n+     * parent to this node.\n+     * @param left the left-hand side of the expression\n+     * @throws IllegalArgumentException} if left is {@code null}\n+     */\n+    public void setLeft(AstNode left) {\n+        assertNotNull(left);\n+        this.left = left;\n+        left.setParent(this);\n+    }\n+\n+    /**\n+     * Returns the right-hand side of the expression\n+     * @return the right-hand side.  It's usually an\n+     * {@link AstNode} node, but can also be a {@link FunctionNode}\n+     * representing Function expressions.\n+     */\n+    public AstNode getRight() {\n+        return right;\n+    }\n+\n+    /**\n+     * Sets the right-hand side of the expression, and sets its parent to this\n+     * node.\n+     * @throws IllegalArgumentException} if right is {@code null}\n+     */\n+    public void setRight(AstNode right) {\n+        assertNotNull(right);\n+        this.right = right;\n+        right.setParent(this);\n+    }\n+\n+    /**\n+     * Returns relative offset of operator token\n+     */\n+    public int getOperatorPosition() {\n+        return operatorPosition;\n+    }\n+\n+    /**\n+     * Sets operator token's relative offset\n+     * @param operatorPosition offset in parent of operator token\n+     */\n+    public void setOperatorPosition(int operatorPosition) {\n+        this.operatorPosition = operatorPosition;\n+    }\n+\n+    @Override\n+    public boolean hasSideEffects() {\n+        // the null-checks are for malformed expressions in IDE-mode\n+        switch (getType()) {\n+          case Token.COMMA:\n+              return right != null && right.hasSideEffects();\n+          case Token.AND:\n+          case Token.OR:\n+              return left != null && left.hasSideEffects()\n+                      || (right != null && right.hasSideEffects());\n+          default:\n+              return super.hasSideEffects();\n+        }\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(left.toSource());\n+        sb.append(\" \");\n+        sb.append(operatorToString(getType()));\n+        sb.append(\" \");\n+        sb.append(right.toSource());\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the left operand, and the right operand.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            left.visit(v);\n+            right.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/Jump.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Roshan James\n+ *   Roger Lawrence\n+ *   Mike McCabe\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * Used for code generation.  During codegen, the AST is transformed\n+ * into an Intermediate Representation (IR) in which loops, ifs, switches\n+ * and other control-flow statements are rewritten as labeled jumps.\n+ * If the parser is set to IDE-mode, the resulting AST will not contain\n+ * any instances of this class.\n+ */\n+public class Jump extends AstNode {\n+\n+    public Node target;\n+    private Node target2;\n+    private Jump jumpNode;\n+\n+    public Jump() {\n+        type = Token.ERROR;\n+    }\n+\n+    public Jump(int nodeType) {\n+        type = nodeType;\n+    }\n+\n+    public Jump(int type, int lineno) {\n+        this(type);\n+        setLineno(lineno);\n+    }\n+\n+    public Jump(int type, Node child) {\n+        this(type);\n+        addChildToBack(child);\n+    }\n+\n+    public Jump(int type, Node child, int lineno) {\n+        this(type, child);\n+        setLineno(lineno);\n+    }\n+\n+    public Jump getJumpStatement()\n+    {\n+        if (type != Token.BREAK && type != Token.CONTINUE) codeBug();\n+        return jumpNode;\n+    }\n+\n+    public void setJumpStatement(Jump jumpStatement)\n+    {\n+        if (type != Token.BREAK && type != Token.CONTINUE) codeBug();\n+        if (jumpStatement == null) codeBug();\n+        if (this.jumpNode != null) codeBug(); //only once\n+        this.jumpNode = jumpStatement;\n+    }\n+\n+    public Node getDefault()\n+    {\n+        if (type != Token.SWITCH) codeBug();\n+        return target2;\n+    }\n+\n+    public void setDefault(Node defaultTarget)\n+    {\n+        if (type != Token.SWITCH) codeBug();\n+        if (defaultTarget.getType() != Token.TARGET) codeBug();\n+        if (target2 != null) codeBug(); //only once\n+        target2 = defaultTarget;\n+    }\n+\n+    public Node getFinally()\n+    {\n+        if (type != Token.TRY) codeBug();\n+        return target2;\n+    }\n+\n+    public void setFinally(Node finallyTarget)\n+    {\n+        if (type != Token.TRY) codeBug();\n+        if (finallyTarget.getType() != Token.TARGET) codeBug();\n+        if (target2 != null) codeBug(); //only once\n+        target2 = finallyTarget;\n+    }\n+\n+    public Jump getLoop()\n+    {\n+        if (type != Token.LABEL) codeBug();\n+        return jumpNode;\n+    }\n+\n+    public void setLoop(Jump loop)\n+    {\n+        if (type != Token.LABEL) codeBug();\n+        if (loop == null) codeBug();\n+        if (jumpNode != null) codeBug(); //only once\n+        jumpNode = loop;\n+    }\n+\n+    public Node getContinue()\n+    {\n+        if (type != Token.LOOP) codeBug();\n+        return target2;\n+    }\n+\n+    public void setContinue(Node continueTarget)\n+    {\n+        if (type != Token.LOOP) codeBug();\n+        if (continueTarget.getType() != Token.TARGET) codeBug();\n+        if (target2 != null) codeBug(); //only once\n+        target2 = continueTarget;\n+    }\n+\n+    /**\n+     * Jumps are only used directly during code generation, and do\n+     * not support this interface.\n+     * @throws UnsupportedOperationException\n+     */\n+    @Override\n+    public void visit(NodeVisitor visitor) {\n+        throw new UnsupportedOperationException(this.toString());\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        throw new UnsupportedOperationException(this.toString());\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/KeywordLiteral.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for keyword literals:  currently, {@code this},\n+ * {@code null}, {@code true}, {@code false}, and {@code debugger}.\n+ * Node type is one of\n+ * {@link Token#THIS},\n+ * {@link Token#NULL},\n+ * {@link Token#TRUE},\n+ * {@link Token#FALSE}, or\n+ * {@link Token#DEBUGGER}.\n+ */\n+public class KeywordLiteral extends AstNode {\n+\n+    public KeywordLiteral() {\n+    }\n+\n+    public KeywordLiteral(int pos) {\n+        super(pos);\n+    }\n+\n+    public KeywordLiteral(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Constructs a new KeywordLiteral\n+     * @param nodeType the token type\n+     */\n+    public KeywordLiteral(int pos, int len, int nodeType) {\n+        super(pos, len);\n+        setType(nodeType);\n+    }\n+\n+    /**\n+     * Sets node token type\n+     * @throws IllegalArgumentException if {@code nodeType} is unsupported\n+     */\n+    @Override\n+    public KeywordLiteral setType(int nodeType) {\n+        if (!(nodeType == Token.THIS\n+              || nodeType == Token.NULL\n+              || nodeType == Token.TRUE\n+              || nodeType == Token.FALSE\n+              || nodeType == Token.DEBUGGER))\n+            throw new IllegalArgumentException(\"Invalid node type: \"\n+                                               + nodeType);\n+        type = nodeType;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns true if the token type is {@link Token#TRUE} or\n+     * {@link Token#FALSE}.\n+     */\n+    public boolean isBooleanLiteral() {\n+        return type == Token.TRUE || type == Token.FALSE;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        switch (getType()) {\n+        case Token.THIS:\n+            sb.append(\"this\");\n+            break;\n+        case Token.NULL:\n+            sb.append(\"null\");\n+            break;\n+        case Token.TRUE:\n+            sb.append(\"true\");\n+            break;\n+        case Token.FALSE:\n+            sb.append(\"false\");\n+            break;\n+        case Token.DEBUGGER:\n+            sb.append(\"debugger\");\n+            break;\n+        default:\n+            throw new IllegalStateException(\"Invalid keyword literal type: \"\n+                                            + getType());\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node.  There are no children to visit.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        v.visit(this);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/Label.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node representing a label.  It is a distinct node type so it can\n+ * record its length and position for code-processing tools.\n+ * Node type is {@link Token#LABEL}.<p>\n+ */\n+public class Label extends Jump {\n+\n+    private String name;\n+\n+    {\n+        type = Token.LABEL;\n+    }\n+\n+    public Label() {\n+    }\n+\n+    public Label(int pos) {\n+        this(pos, -1);\n+    }\n+\n+    public Label(int pos, int len) {\n+        // can't call super (Jump) for historical reasons\n+        position = pos;\n+        length = len;\n+    }\n+\n+    public Label(int pos, int len, String name) {\n+        this(pos, len);\n+        setName(name);\n+    }\n+\n+    /**\n+     * Returns the label text\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Sets the label text\n+     * @throws IllegalArgumentException if name is {@code null} or the\n+     * empty string.\n+     */\n+    public void setName(String name) {\n+        name = name == null ? null : name.trim();\n+        if (name == null || \"\".equals(name))\n+            throw new IllegalArgumentException(\"invalid label name\");\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(name);\n+        sb.append(\":\\n\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this label.  There are no children to visit.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        v.visit(this);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/LabeledStatement.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A labeled statement.  A statement can have more than one label.  In\n+ * this AST representation, all labels for a statement are collapsed into\n+ * the \"labels\" list of a single {@link LabeledStatement} node. <p>\n+ *\n+ * Node type is {@link Token#EXPR_VOID}. <p>\n+ */\n+public class LabeledStatement extends AstNode {\n+\n+    private List<Label> labels = new ArrayList<Label>();  // always at least 1\n+    private AstNode statement;\n+\n+    {\n+        type = Token.EXPR_VOID;\n+    }\n+\n+    public LabeledStatement() {\n+    }\n+\n+    public LabeledStatement(int pos) {\n+        super(pos);\n+    }\n+\n+    public LabeledStatement(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns label list\n+     */\n+    public List<Label> getLabels() {\n+        return labels;\n+    }\n+\n+    /**\n+     * Sets label list, setting the parent of each label\n+     * in the list.  Replaces any existing labels.\n+     * @throws IllegalArgumentException} if labels is {@code null}\n+     */\n+    public void setLabels(List<Label> labels) {\n+        assertNotNull(labels);\n+        if (this.labels != null)\n+            this.labels.clear();\n+        for (Label l : labels) {\n+            addLabel(l);\n+        }\n+    }\n+\n+    /**\n+     * Adds a label and sets its parent to this node.\n+     * @throws IllegalArgumentException} if label is {@code null}\n+     */\n+    public void addLabel(Label label) {\n+        assertNotNull(label);\n+        labels.add(label);\n+        label.setParent(this);\n+    }\n+\n+    /**\n+     * Returns the labeled statement\n+     */\n+    public AstNode getStatement() {\n+        return statement;\n+    }\n+\n+    /**\n+     * Returns label with specified name from the label list for\n+     * this labeled statement.  Returns {@code null} if there is no\n+     * label with that name in the list.\n+     */\n+    public Label getLabelByName(String name) {\n+        for (Label label : labels) {\n+            if (name.equals(label.getName())) {\n+                return label;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Sets the labeled statement, and sets its parent to this node.\n+     * @throws IllegalArgumentException if {@code statement} is {@code null}\n+     */\n+    public void setStatement(AstNode statement) {\n+        assertNotNull(statement);\n+        this.statement = statement;\n+        statement.setParent(this);\n+    }\n+\n+    public Label getFirstLabel() {\n+        return labels.get(0);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        for (Label label : labels) {\n+            sb.append(label.toSource(depth));  // prints newline\n+        }\n+        sb.append(statement.toSource(depth + 1));\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then each label in the label-list, and finally the\n+     * statement.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            for (AstNode label : labels) {\n+                label.visit(v);\n+            }\n+            statement.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/LetNode.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for let statements and expressions.\n+ * Node type is {@link Token#LET} or {@link Token#LETEXPR}.<p>\n+ *\n+ * <pre> <i>LetStatement</i>:\n+ *     <b>let</b> ( VariableDeclarationList ) Block\n+ * <i>LetExpression</i>:\n+ *     <b>let</b> ( VariableDeclarationList ) Expression</pre>\n+ *\n+ * Note that standalone let-statements with no parens or body block,\n+ * such as {@code let x=6, y=7;}, are represented as a\n+ * {@link VariableDeclaration} node of type {@code Token.LET},\n+ * wrapped with an {@link ExpressionStatement}.<p>\n+ */\n+public class LetNode extends Scope {\n+\n+    private VariableDeclaration variables;\n+    private AstNode body;\n+    private int lp = -1;\n+    private int rp = -1;\n+\n+    {\n+        type = Token.LETEXPR;\n+    }\n+\n+    public LetNode() {\n+    }\n+\n+    public LetNode(int pos) {\n+        super(pos);\n+    }\n+\n+    public LetNode(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns variable list\n+     */\n+    public VariableDeclaration getVariables() {\n+        return variables;\n+    }\n+\n+    /**\n+     * Sets variable list.  Sets list parent to this node.\n+     * @throws IllegalArgumentException if variables is {@code null}\n+     */\n+    public void setVariables(VariableDeclaration variables) {\n+        assertNotNull(variables);\n+        this.variables = variables;\n+        variables.setParent(this);\n+    }\n+\n+    /**\n+     * Returns body statement or expression.  Body is {@code null} if the\n+     * form of the let statement is similar to a VariableDeclaration, with no\n+     * curly-brace.  (This form is used to define let-bound variables in the\n+     * scope of the current block.)<p>\n+     *\n+     * @return the body form\n+     */\n+    public AstNode getBody() {\n+        return body;\n+    }\n+\n+    /**\n+     * Sets body statement or expression.  Also sets the body parent to this\n+     * node.\n+     * @param body the body statement or expression.  May be\n+     * {@code null}.\n+     */\n+    public void setBody(AstNode body) {\n+        this.body = body;\n+        if (body != null)\n+            body.setParent(this);\n+    }\n+\n+    /**\n+     * Returns left paren position, -1 if missing\n+     */\n+    public int getLp() {\n+        return lp;\n+    }\n+\n+    /**\n+     * Sets left paren position\n+     */\n+    public void setLp(int lp) {\n+        this.lp = lp;\n+    }\n+\n+    /**\n+     * Returns right paren position, -1 if missing\n+     */\n+    public int getRp() {\n+        return rp;\n+    }\n+\n+    /**\n+     * Sets right paren position\n+     */\n+    public void setRp(int rp) {\n+        this.rp = rp;\n+    }\n+\n+    /**\n+     * Sets both paren positions\n+     */\n+    public void setParens(int lp, int rp) {\n+        this.lp = lp;\n+        this.rp = rp;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        String pad = makeIndent(depth);\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(pad);\n+        sb.append(\"let (\");\n+        printList(variables.getVariables(), sb);\n+        sb.append(\") \");\n+        if (body != null) {\n+            sb.append(body.toSource(depth));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the variable list, and if present, the body\n+     * expression or statement.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            variables.visit(v);\n+            if (body != null) {\n+                body.visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/Loop.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+/**\n+ * Abstract base type for loops.\n+ */\n+public abstract class Loop extends Scope {\n+\n+    protected AstNode body;\n+    protected int lp = -1;\n+    protected int rp = -1;\n+\n+    public Loop() {\n+    }\n+\n+    public Loop(int pos) {\n+        super(pos);\n+    }\n+\n+    public Loop(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns loop body\n+     */\n+    public AstNode getBody() {\n+        return body;\n+    }\n+\n+    /**\n+     * Sets loop body.  Sets the parent of the body to this loop node,\n+     * and updates its offset to be relative.  Extends the length of this\n+     * node to include the body.\n+     */\n+    public void setBody(AstNode body) {\n+        this.body = body;\n+        int end = body.getPosition() + body.getLength();\n+        this.setLength(end - this.getPosition());\n+        body.setParent(this);\n+    }\n+\n+    /**\n+     * Returns left paren position, -1 if missing\n+     */\n+    public int getLp() {\n+        return lp;\n+    }\n+\n+    /**\n+     * Sets left paren position\n+     */\n+    public void setLp(int lp) {\n+        this.lp = lp;\n+    }\n+\n+    /**\n+     * Returns right paren position, -1 if missing\n+     */\n+    public int getRp() {\n+        return rp;\n+    }\n+\n+    /**\n+     * Sets right paren position\n+     */\n+    public void setRp(int rp) {\n+        this.rp = rp;\n+    }\n+\n+    /**\n+     * Sets both paren positions\n+     */\n+    public void setParens(int lp, int rp) {\n+        this.lp = lp;\n+        this.rp = rp;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/Name.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for a simple name.  A simple name is an identifier that is\n+ * not a keyword. Node type is {@link Token#NAME}.<p>\n+ *\n+ * This node type is also used to represent certain non-identifier names that\n+ * are part of the language syntax.  It's used for the \"get\" and \"set\"\n+ * pseudo-keywords for object-initializer getter/setter properties, and it's\n+ * also used for the \"*\" wildcard in E4X XML namespace and name expressions.\n+ */\n+public class Name extends AstNode {\n+\n+    private String identifier;\n+    private Scope scope;\n+\n+    {\n+        type = Token.NAME;\n+    }\n+\n+    public Name() {\n+    }\n+\n+    public Name(int pos) {\n+        super(pos);\n+    }\n+\n+    public Name(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Constructs a new {@link Name}\n+     * @param pos node start position\n+     * @param len node length\n+     * @param name the identifier associated with this {@code Name} node\n+     */\n+    public Name(int pos, int len, String name) {\n+        super(pos, len);\n+        setIdentifier(name);\n+    }\n+\n+    public Name(int pos, String name) {\n+        super(pos);\n+        setIdentifier(name);\n+        setLength(name.length());\n+    }\n+\n+    /**\n+     * Returns the node's identifier\n+     */\n+    public String getIdentifier() {\n+        return identifier;\n+    }\n+\n+    /**\n+     * Sets the node's identifier\n+     * @throws IllegalArgumentException if identifier is null\n+     */\n+    public void setIdentifier(String identifier) {\n+        assertNotNull(identifier);\n+        this.identifier = identifier;\n+        setLength(identifier.length());\n+    }\n+\n+    /**\n+     * Set the {@link Scope} associated with this node.  This method does not\n+     * set the scope's ast-node field to this node.  The field exists only\n+     * for temporary storage by the code generator.  Not every name has an\n+     * associated scope - typically only function and variable names (but not\n+     * property names) are registered in a scope.\n+     *\n+     * @param s the scope.  Can be null.  Doesn't set any fields in the\n+     * scope.\n+     */\n+    public void setScope(Scope s) {\n+        scope = s;\n+    }\n+\n+    /**\n+     * Return the {@link Scope} associated with this node.  This is\n+     * <em>only</em> used for (and set by) the code generator, so it will always\n+     * be null in frontend AST-processing code.  Use {@link #getDefiningScope}\n+     * to find the lexical {@code Scope} in which this {@code Name} is defined,\n+     * if any.\n+     */\n+    public Scope getScope() {\n+        return scope;\n+    }\n+\n+    /**\n+     * Returns the {@link Scope} in which this {@code Name} is defined.\n+     * @return the scope in which this name is defined, or {@code null}\n+     * if it's not defined in the current lexical scope chain\n+     */\n+    public Scope getDefiningScope() {\n+        Scope enclosing = getEnclosingScope();\n+        String name = getIdentifier();\n+        return enclosing == null ? null : enclosing.getDefiningScope(name);\n+    }\n+\n+    /**\n+     * Return true if this node is known to be defined as a symbol in a\n+     * lexical scope other than the top-level (global) scope.\n+     *\n+     * @return {@code true} if this name appears as local variable, a let-bound\n+     * variable not in the global scope, a function parameter, a loop\n+     * variable, the property named in a {@link PropertyGet}, or in any other\n+     * context where the node is known not to resolve to the global scope.\n+     * Returns {@code false} if the node is defined in the top-level scope\n+     * (i.e., its defining scope is an {@link AstRoot} object), or if its\n+     * name is not defined as a symbol in the symbol table, in which case it\n+     * may be an external or built-in name (or just an error of some sort.)\n+     */\n+    public boolean isLocalName() {\n+        Scope scope = getDefiningScope();\n+        return scope != null && scope.getParentScope() != null;\n+    }\n+\n+    /**\n+     * Return the length of this node's identifier, to let you pretend\n+     * it's a {@link String}.  Don't confuse this method with the\n+     * {@link AstNode#getLength} method, which returns the range of\n+     * characters that this node overlaps in the source input.\n+     */\n+    public int length() {\n+        return identifier == null ? 0 : identifier.length();\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        return makeIndent(depth) + (identifier == null ? \"<null>\" : identifier);\n+    }\n+\n+    /**\n+     * Visits this node.  There are no children to visit.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        v.visit(this);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/NewExpression.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * New expression. Node type is {@link Token#NEW}.<p>\n+ *\n+ * <pre><i>NewExpression</i> :\n+ *      MemberExpression\n+ *      <b>new</b> NewExpression</pre>\n+ *\n+ * This node is a subtype of {@link FunctionCall}, mostly for internal code\n+ * sharing.  Structurally a {@code NewExpression} node is very similar to a\n+ * {@code FunctionCall}, so it made a certain amount of sense.\n+ */\n+public class NewExpression extends FunctionCall {\n+\n+    private ObjectLiteral initializer;\n+\n+    {\n+        type = Token.NEW;\n+    }\n+\n+    public NewExpression() {\n+    }\n+\n+    public NewExpression(int pos) {\n+        super(pos);\n+    }\n+\n+    public NewExpression(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns initializer object, if any.\n+     * @return extra initializer object-literal expression, or {@code null} if\n+     * not specified.\n+     */\n+    public ObjectLiteral getInitializer() {\n+      return initializer;\n+    }\n+\n+    /**\n+     * Sets initializer object.  Rhino supports an experimental syntax\n+     * of the form {@code new expr [ ( arglist ) ] [initializer]},\n+     * in which initializer is an object literal that is used to set\n+     * additional properties on the newly-created {@code expr} object.\n+     *\n+     * @param initializer extra initializer object.\n+     * Can be {@code null}.\n+     */\n+    public void setInitializer(ObjectLiteral initializer) {\n+      this.initializer = initializer;\n+      if (initializer != null)\n+          initializer.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"new \");\n+        sb.append(target.toSource(0));\n+        sb.append(\"(\");\n+        if (arguments != null) {\n+            printList(arguments, sb);\n+        }\n+        sb.append(\")\");\n+        if (initializer != null) {\n+            sb.append(\" \");\n+            sb.append(initializer.toSource(0));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the target, and each argument.  If there is\n+     * a trailing initializer node, visits that last.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            target.visit(v);\n+            for (AstNode arg : getArguments()) {\n+                arg.visit(v);\n+            }\n+            if (initializer != null) {\n+                initializer.visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/NodeVisitor.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+/**\n+ * Simple visitor interface for traversing the AST.  The nodes are visited in\n+ * an arbitrary order.  The visitor must cast nodes to the appropriate\n+ * type based on their token-type.\n+ */\n+public interface NodeVisitor {\n+\n+    /**\n+     * Visits an AST node.\n+     * @param node the AST node.  Will never visit an {@link AstRoot} node,\n+     * since the {@code AstRoot} is where the visiting begins.\n+     * @return {@code true} if the children should be visited.\n+     * If {@code false}, the subtree rooted at this node is skipped.\n+     * The {@code node} argument should <em>never</em> be {@code null} --\n+     * the individual {@link AstNode} classes should skip any children\n+     * that are not present in the source when they invoke this method.\n+     */\n+    boolean visit(AstNode node);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/NumberLiteral.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for a Number literal. Node type is {@link Token#NUMBER}.<p>\n+ */\n+public class NumberLiteral extends AstNode {\n+\n+    private String value;\n+    private double number;\n+\n+    {\n+        type = Token.NUMBER;\n+    }\n+\n+    public NumberLiteral() {\n+    }\n+\n+    public NumberLiteral(int pos) {\n+        super(pos);\n+    }\n+\n+    public NumberLiteral(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Constructor.  Sets the length to the length of the {@code value} string.\n+     */\n+    public NumberLiteral(int pos, String value) {\n+        super(pos);\n+        setValue(value);\n+        setLength(value.length());\n+    }\n+\n+    /**\n+     * Constructor.  Sets the length to the length of the {@code value} string.\n+     */\n+    public NumberLiteral(int pos, String value, double number) {\n+        this(pos, value);\n+        setDouble(number);\n+    }\n+\n+    public NumberLiteral(double number) {\n+        setDouble(number);\n+        setValue(Double.toString(number));\n+    }\n+\n+    /**\n+     * Returns the node's string value (the original source token)\n+     */\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Sets the node's value\n+     * @throws IllegalArgumentException} if value is {@code null}\n+     */\n+    public void setValue(String value) {\n+        assertNotNull(value);\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Gets the {@code double} value.\n+     */\n+    public double getNumber() {\n+        return number;\n+    }\n+\n+    /**\n+     * Sets the node's {@code double} value.\n+     */\n+    public void setNumber(double value) {\n+        number = value;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        return makeIndent(depth) + (value == null ? \"<null>\" : value);\n+    }\n+\n+    /**\n+     * Visits this node.  There are no children to visit.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        v.visit(this);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ObjectLiteral.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * AST node for an Object literal (also called an Object initialiser in\n+ * Ecma-262).  The elements list will always be non-{@code null}, although\n+ * the list will have no elements if the Object literal is empty.<p>\n+ *\n+ * Node type is {@link Token#OBJECTLIT}.<p>\n+ *\n+ * <pre><i>ObjectLiteral</i> :\n+ *       <b>{}</b>\n+ *       <b>{</b> PropertyNameAndValueList <b>}</b>\n+ * <i>PropertyNameAndValueList</i> :\n+ *       PropertyName <b>:</b> AssignmentExpression\n+ *       PropertyNameAndValueList , PropertyName <b>:</b> AssignmentExpression\n+ * <i>PropertyName</i> :\n+ *       Identifier\n+ *       StringLiteral\n+ *       NumericLiteral</pre>\n+ */\n+public class ObjectLiteral extends AstNode implements DestructuringForm {\n+\n+    private static final List<ObjectProperty> NO_ELEMS =\n+        Collections.unmodifiableList(new ArrayList<ObjectProperty>());\n+\n+    private List<ObjectProperty> elements;\n+    boolean isDestructuring;\n+\n+    {\n+        type = Token.OBJECTLIT;\n+    }\n+\n+    public ObjectLiteral() {\n+    }\n+\n+    public ObjectLiteral(int pos) {\n+        super(pos);\n+    }\n+\n+    public ObjectLiteral(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns the element list.  Returns an immutable empty list if there are\n+     * no elements.\n+     */\n+    public List<ObjectProperty> getElements() {\n+        return elements != null ? elements : NO_ELEMS;\n+    }\n+\n+    /**\n+     * Sets the element list, and updates the parent of each element.\n+     * Replaces any existing elements.\n+     * @param elements the element list.  Can be {@code null}.\n+     */\n+    public void setElements(List<ObjectProperty> elements) {\n+        if (elements == null) {\n+            this.elements = null;\n+        } else {\n+            if (this.elements != null)\n+                this.elements.clear();\n+            for (ObjectProperty o : elements)\n+                addElement(o);\n+        }\n+    }\n+\n+    /**\n+     * Adds an element to the list, and sets its parent to this node.\n+     * @param element the property node to append to the end of the list\n+     * @throws IllegalArgumentException} if element is {@code null}\n+     */\n+    public void addElement(ObjectProperty element) {\n+        assertNotNull(element);\n+        if (elements == null) {\n+            elements = new ArrayList<ObjectProperty>();\n+        }\n+        elements.add(element);\n+        element.setParent(this);\n+    }\n+\n+    /**\n+     * Marks this node as being a destructuring form - that is, appearing\n+     * in a context such as {@code for ([a, b] in ...)} where it's the\n+     * target of a destructuring assignment.\n+     */\n+    public void setIsDestructuring(boolean destructuring) {\n+        isDestructuring = destructuring;\n+    }\n+\n+    /**\n+     * Returns true if this node is in a destructuring position:\n+     * a function parameter, the target of a variable initializer, the\n+     * iterator of a for..in loop, etc.\n+     */\n+    public boolean isDestructuring() {\n+        return isDestructuring;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"{\");\n+        if (elements != null) {\n+            printList(elements, sb);\n+        }\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then visits each child property node, in lexical\n+     * (source) order.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            for (ObjectProperty prop : getElements()) {\n+                prop.visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ObjectProperty.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for a single name:value entry in an Object literal.\n+ * For simple entries, the node type is {@link Token#COLON}, and\n+ * the name (left side expression) is either a {@link Name}, a\n+ * {@link StringLiteral} or a {@link NumberLiteral}.<p>\n+ *\n+ * This node type is also used for getter/setter properties in object\n+ * literals.  In this case the node bounds include the \"get\" or \"set\"\n+ * keyword.  The left-hand expression in this case is always a\n+ * {@link Name}, and the overall node type is {@link Token#GET} or\n+ * {@link Token#SET}, as appropriate.<p>\n+ *\n+ * The {@code operatorPosition} field is meaningless if the node is\n+ * a getter or setter.<p>\n+ *\n+ * <pre><i>ObjectProperty</i> :\n+ *       PropertyName <b>:</b> AssignmentExpression\n+ * <i>PropertyName</i> :\n+ *       Identifier\n+ *       StringLiteral\n+ *       NumberLiteral</pre>\n+ */\n+public class ObjectProperty extends InfixExpression {\n+\n+    {\n+        type = Token.COLON;\n+    }\n+\n+    /**\n+     * Sets the node type.  Must be one of\n+     * {@link Token#COLON}, {@link Token#GET}, or {@link Token#SET}.\n+     * @throws IllegalArgumentException if {@code nodeType} is invalid\n+     */\n+    public void setNodeType(int nodeType) {\n+        if (nodeType != Token.COLON\n+            && nodeType != Token.GET\n+            && nodeType != Token.SET)\n+            throw new IllegalArgumentException(\"invalid node type: \"\n+                                               + nodeType);\n+        setType(nodeType);\n+    }\n+\n+    public ObjectProperty() {\n+    }\n+\n+    public ObjectProperty(int pos) {\n+        super(pos);\n+    }\n+\n+    public ObjectProperty(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Marks this node as a \"getter\" property.\n+     */\n+    public void setIsGetter() {\n+        type = Token.GET;\n+    }\n+\n+    /**\n+     * Returns true if this is a getter function.\n+     */\n+    public boolean isGetter() {\n+        return type == Token.GET;\n+    }\n+\n+    /**\n+     * Marks this node as a \"setter\" property.\n+     */\n+    public void setIsSetter() {\n+        type = Token.SET;\n+    }\n+\n+    /**\n+     * Returns true if this is a setter function.\n+     */\n+    public boolean isSetter() {\n+        return type == Token.SET;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        if (isGetter()) {\n+            sb.append(\"get \");\n+        } else if (isSetter()) {\n+            sb.append(\"set \");\n+        }\n+        sb.append(left.toSource(0));\n+        if (type == Token.COLON) {\n+            sb.append(\": \");\n+        }\n+        sb.append(right.toSource(0));\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ParenthesizedExpression.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for a parenthesized expression.\n+ * Node type is {@link Token#LP}.<p>\n+ */\n+public class ParenthesizedExpression extends AstNode {\n+\n+    private AstNode expression;\n+\n+    {\n+        type = Token.LP;\n+    }\n+\n+    public ParenthesizedExpression() {\n+    }\n+\n+    public ParenthesizedExpression(int pos) {\n+        super(pos);\n+    }\n+\n+    public ParenthesizedExpression(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    public ParenthesizedExpression(AstNode expr) {\n+        this(expr != null ? expr.getPosition() : 0,\n+             expr != null ? expr.getLength() : 1,\n+             expr);\n+    }\n+\n+    public ParenthesizedExpression(int pos, int len, AstNode expr) {\n+        super(pos, len);\n+        setExpression(expr);\n+    }\n+\n+    /**\n+     * Returns the expression between the parens\n+     */\n+    public AstNode getExpression() {\n+        return expression;\n+    }\n+\n+    /**\n+     * Sets the expression between the parens, and sets the parent\n+     * to this node.\n+     * @param expression the expression between the parens\n+     * @throws IllegalArgumentException} if expression is {@code null}\n+     */\n+    public void setExpression(AstNode expression) {\n+        assertNotNull(expression);\n+        this.expression = expression;\n+        expression.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        return makeIndent(depth) + \"(\" + expression.toSource(0) + \")\";\n+    }\n+\n+    /**\n+     * Visits this node, then the child expression.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            expression.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ParseProblem.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+/**\n+ * Encapsulates information for a JavaScript parse error or warning.\n+ */\n+public class ParseProblem {\n+\n+    public static enum Type {Error, Warning}\n+\n+    private Type type;\n+    private String message;\n+    private String sourceName;\n+    private int offset;\n+    private int length;\n+\n+    /**\n+     * Constructs a new ParseProblem.\n+     */\n+    public ParseProblem(ParseProblem.Type type, String message,\n+                        String sourceName, int offset, int length) {\n+        setType(type);\n+        setMessage(message);\n+        setSourceName(sourceName);\n+        setFileOffset(offset);\n+        setLength(length);\n+    }\n+\n+    public ParseProblem.Type getType() {\n+        return type;\n+    }\n+\n+    public void setType(ParseProblem.Type type) {\n+        this.type = type;\n+    }\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String msg) {\n+        this.message = msg;\n+    }\n+\n+    public String getSourceName() {\n+        return sourceName;\n+    }\n+\n+    public void setSourceName(String name) {\n+        this.sourceName = name;\n+    }\n+\n+    public int getFileOffset() {\n+        return offset;\n+    }\n+\n+    public void setFileOffset(int offset) {\n+        this.offset = offset;\n+    }\n+\n+    public int getLength() {\n+        return length;\n+    }\n+\n+    public void setLength(int length) {\n+        this.length = length;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(200);\n+        sb.append(sourceName).append(\":\");\n+        sb.append(\"offset=\").append(offset).append(\",\");\n+        sb.append(\"length=\").append(length).append(\",\");\n+        sb.append(type == Type.Error ? \"error: \" : \"warning: \");\n+        sb.append(message);\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/PropertyGet.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for the '.' operator.  Node type is {@link Token#GETPROP}.\n+ */\n+public class PropertyGet extends InfixExpression {\n+\n+    {\n+        type = Token.GETPROP;\n+    }\n+\n+    public PropertyGet() {\n+    }\n+\n+    public PropertyGet(int pos) {\n+        super(pos);\n+    }\n+\n+    public PropertyGet(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    public PropertyGet(int pos, int len, AstNode target, Name property) {\n+        super(pos, len, target, property);\n+    }\n+\n+    /**\n+     * Constructor.  Updates bounds to include left ({@code target}) and\n+     * right ({@code property}) nodes.\n+     */\n+    public PropertyGet(AstNode target, Name property) {\n+        super(target, property);\n+    }\n+\n+    public PropertyGet(AstNode target, Name property, int dotPosition) {\n+        super(Token.GETPROP, target, property, dotPosition);\n+    }\n+\n+    /**\n+     * Returns the object on which the property is being fetched.\n+     * Should never be {@code null}.\n+     */\n+    public AstNode getTarget() {\n+        return getLeft();\n+    }\n+\n+    /**\n+     * Sets target object, and sets its parent to this node.\n+     * @param target expression evaluating to the object upon which\n+     * to do the property lookup\n+     * @throws IllegalArgumentException} if {@code target} is {@code null}\n+     */\n+    public void setTarget(AstNode target) {\n+        setLeft(target);\n+    }\n+\n+    /**\n+     * Returns the property being accessed.\n+     */\n+    public Name getProperty() {\n+        return (Name)getRight();\n+    }\n+\n+    /**\n+     * Sets the property being accessed, and sets its parent to this node.\n+     * @throws IllegalArgumentException} if {@code property} is {@code null}\n+     */\n+    public void setProperty(Name property) {\n+        setRight(property);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(getLeft().toSource(0));\n+        sb.append(\".\");\n+        sb.append(getRight().toSource(0));\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the target expression, and the property name.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            getTarget().visit(v);\n+            getProperty().visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/RegExpLiteral.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for a RegExp literal.\n+ * Node type is {@link Token#REGEXP}.<p>\n+ */\n+public class RegExpLiteral extends AstNode {\n+\n+    private String value;\n+    private String flags;\n+\n+    {\n+        type = Token.REGEXP;\n+    }\n+\n+    public RegExpLiteral() {\n+    }\n+\n+    public RegExpLiteral(int pos) {\n+        super(pos);\n+    }\n+\n+    public RegExpLiteral(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns the regexp string without delimiters\n+     */\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Sets the regexp string without delimiters\n+     * @throws IllegalArgumentException} if value is {@code null}\n+     */\n+    public void setValue(String value) {\n+        assertNotNull(value);\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Returns regexp flags, {@code null} or \"\" if no flags specified\n+     */\n+    public String getFlags() {\n+        return flags;\n+    }\n+\n+    /**\n+     * Sets regexp flags.  Can be {@code null} or \"\".\n+     */\n+    public void setFlags(String flags) {\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        return makeIndent(depth) + \"/\" + value + \"/\"\n+                + (flags == null ? \"\" : flags);\n+    }\n+\n+    /**\n+     * Visits this node.  There are no children to visit.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        v.visit(this);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ReturnStatement.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * Return statement.  Node type is {@link Token#RETURN}.<p>\n+ *\n+ * <pre><i>ReturnStatement</i> :\n+ *      <b>return</b> [<i>no LineTerminator here</i>] [Expression] ;</pre>\n+ */\n+public class ReturnStatement extends AstNode {\n+\n+    private AstNode returnValue;\n+\n+    {\n+        type = Token.RETURN;\n+    }\n+\n+    public ReturnStatement() {\n+    }\n+\n+    public ReturnStatement(int pos) {\n+        super(pos);\n+    }\n+\n+    public ReturnStatement(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    public ReturnStatement(int pos, int len, AstNode returnValue) {\n+        super(pos, len);\n+        setReturnValue(returnValue);\n+    }\n+\n+    /**\n+     * Returns return value, {@code null} if return value is void\n+     */\n+    public AstNode getReturnValue() {\n+        return returnValue;\n+    }\n+\n+    /**\n+     * Sets return value expression, and sets its parent to this node.\n+     * Can be {@code null}.\n+     */\n+    public void setReturnValue(AstNode returnValue) {\n+        this.returnValue = returnValue;\n+        if (returnValue != null)\n+            returnValue.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"return\");\n+        if (returnValue != null) {\n+            sb.append(\" \");\n+            sb.append(returnValue.toSource(0));\n+        }\n+        sb.append(\";\\n\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the return value if specified.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this) && returnValue != null) {\n+            returnValue.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/Scope.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Roger Lawrence\n+ *   Mike McCabe\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Represents a scope in the lexical scope chain.  Base type for\n+ * all {@link AstNode} implementations that can introduce a new scope.\n+ */\n+public class Scope extends Jump {\n+\n+    // Use LinkedHashMap so that the iteration order is the insertion order\n+    protected Map<String,Symbol> symbolTable;\n+    protected Scope parentScope;\n+    protected ScriptNode top;     // current script or function scope\n+\n+    private List<Scope> childScopes;\n+\n+    {\n+        this.type = Token.BLOCK;\n+    }\n+\n+    public Scope() {\n+    }\n+\n+    public Scope(int pos) {\n+        this.position = pos;\n+    }\n+\n+    public Scope(int pos, int len) {\n+        this(pos);\n+        this.length = len;\n+    }\n+\n+    public Scope getParentScope() {\n+        return parentScope;\n+    }\n+\n+    /**\n+     * Sets parent scope\n+     */\n+    public void setParentScope(Scope parentScope) {\n+        this.parentScope = parentScope;\n+        this.top = parentScope == null ? (ScriptNode)this : parentScope.top;\n+    }\n+\n+    /**\n+     * Used only for code generation.\n+     */\n+    public void clearParentScope() {\n+        this.parentScope = null;\n+    }\n+\n+    /**\n+     * Return a list of the scopes whose parent is this scope.\n+     * @return the list of scopes we enclose, or {@code null} if none\n+     */\n+    public List<Scope> getChildScopes() {\n+        return childScopes;\n+    }\n+\n+    /**\n+     * Add a scope to our list of child scopes.\n+     * Sets the child's parent scope to this scope.\n+     * @throws IllegalStateException if the child's parent scope is\n+     * non-{@code null}\n+     */\n+    public void addChildScope(Scope child) {\n+        if (childScopes == null) {\n+            childScopes = new ArrayList<Scope>();\n+        }\n+        childScopes.add(child);\n+        child.setParentScope(this);\n+    }\n+\n+    /**\n+     * Used by the parser; not intended for typical use.\n+     * Changes the parent-scope links for this scope's child scopes\n+     * to the specified new scope.  Copies symbols from this scope\n+     * into new scope.\n+     *\n+     * @param newScope the scope that will replace this one on the\n+     *        scope stack.\n+     */\n+    public void replaceWith(Scope newScope) {\n+        if (childScopes != null) {\n+            for (Scope kid : childScopes) {\n+                newScope.addChildScope(kid);  // sets kid's parent\n+            }\n+            childScopes.clear();\n+            childScopes = null;\n+        }\n+        if (symbolTable != null && !symbolTable.isEmpty()) {\n+            joinScopes(this, newScope);\n+        }\n+    }\n+\n+    /**\n+     * Returns current script or function scope\n+     */\n+    public ScriptNode getTop() {\n+        return top;\n+    }\n+\n+    /**\n+     * Sets top current script or function scope\n+     */\n+    public void setTop(ScriptNode top) {\n+        this.top = top;\n+    }\n+\n+    /**\n+     * Creates a new scope node, moving symbol table information\n+     * from \"scope\" to the new node, and making \"scope\" a nested\n+     * scope contained by the new node.\n+     * Useful for injecting a new scope in a scope chain.\n+     */\n+    public static Scope splitScope(Scope scope) {\n+        Scope result = new Scope(scope.getType());\n+        result.symbolTable = scope.symbolTable;\n+        scope.symbolTable = null;\n+        result.parent = scope.parent;\n+        result.setParentScope(scope.getParentScope());\n+        result.setParentScope(result);\n+        scope.parent = result;\n+        result.top = scope.top;\n+        return result;\n+    }\n+\n+    /**\n+     * Copies all symbols from source scope to dest scope.\n+     */\n+    public static void joinScopes(Scope source, Scope dest) {\n+        Map<String,Symbol> src = source.ensureSymbolTable();\n+        Map<String,Symbol> dst = dest.ensureSymbolTable();\n+        if (!Collections.disjoint(src.keySet(), dst.keySet())) {\n+            codeBug();\n+        }\n+        for (Map.Entry<String, Symbol> entry: src.entrySet()) {\n+            Symbol sym = entry.getValue();\n+            sym.setContainingTable(dest);\n+            dst.put(entry.getKey(), sym);\n+        }\n+    }\n+\n+    /**\n+     * Returns the scope in which this name is defined\n+     * @param name the symbol to look up\n+     * @return this {@link Scope}, one of its parent scopes, or {@code null} if\n+     * the name is not defined any this scope chain\n+     */\n+    public Scope getDefiningScope(String name) {\n+        for (Scope s = this; s != null; s = s.parentScope) {\n+            Map<String,Symbol> symbolTable = s.getSymbolTable();\n+            if (symbolTable != null && symbolTable.containsKey(name)) {\n+                return s;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Looks up a symbol in this scope.\n+     * @param name the symbol name\n+     * @return the Symbol, or {@code null} if not found\n+     */\n+    public Symbol getSymbol(String name) {\n+        return symbolTable == null ? null : symbolTable.get(name);\n+    }\n+\n+    /**\n+     * Enters a symbol into this scope.\n+     */\n+    public void putSymbol(Symbol symbol) {\n+        if (symbol.getName() == null)\n+            throw new IllegalArgumentException(\"null symbol name\");\n+        ensureSymbolTable();\n+        symbolTable.put(symbol.getName(), symbol);\n+        symbol.setContainingTable(this);\n+        top.addSymbol(symbol);\n+    }\n+\n+    /**\n+     * Returns the symbol table for this scope.\n+     * @return the symbol table.  May be {@code null}.\n+     */\n+    public Map<String,Symbol> getSymbolTable() {\n+        return symbolTable;\n+    }\n+\n+    /**\n+     * Sets the symbol table for this scope.  May be {@code null}.\n+     */\n+    public void setSymbolTable(Map<String, Symbol> table) {\n+        symbolTable = table;\n+    }\n+\n+    private Map<String,Symbol> ensureSymbolTable() {\n+        if (symbolTable == null) {\n+            symbolTable = new LinkedHashMap<String,Symbol>(5);\n+        }\n+        return symbolTable;\n+    }\n+\n+    /**\n+     * Returns a copy of the child list, with each child cast to an\n+     * {@link AstNode}.\n+     * @throws ClassCastException if any non-{@code AstNode} objects are\n+     * in the child list, e.g. if this method is called after the code\n+     * generator begins the tree transformation.\n+     */\n+    public List<AstNode> getStatements() {\n+        List<AstNode> stmts = new ArrayList<AstNode>();\n+        Node n = getFirstChild();\n+        while (n != null) {\n+            stmts.add((AstNode)n);\n+            n = n.getNext();\n+        }\n+        return stmts;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"{\\n\");\n+        for (Node kid : this) {\n+            sb.append(((AstNode)kid).toSource(depth+1));\n+        }\n+        sb.append(makeIndent(depth));\n+        sb.append(\"}\\n\");\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            for (Node kid : this) {\n+                ((AstNode)kid).visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ScriptNode.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Bob Jervis\n+ *   Norris Boyd\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Base type for {@link AstRoot} and {@link FunctionNode} nodes, which need to\n+ * collect much of the same information.\n+ */\n+public class ScriptNode extends Scope {\n+\n+    private int encodedSourceStart = -1;\n+    private int encodedSourceEnd = -1;\n+    private String sourceName;\n+    private String encodedSource;\n+    private int endLineno = -1;\n+\n+    private List<FunctionNode> functions;\n+    private List<RegExpLiteral> regexps;\n+    private List<FunctionNode> EMPTY_LIST = Collections.emptyList();\n+\n+    private List<Symbol> symbols = new ArrayList<Symbol>(4);\n+    private int paramCount = 0;\n+    private String[] variableNames;\n+    private boolean[] isConsts;\n+\n+    private Object compilerData;\n+    private int tempNumber = 0;\n+\n+    {\n+        // during parsing, a ScriptNode or FunctionNode's top scope is itself\n+        this.top = this;\n+        this.type = Token.SCRIPT;\n+    }\n+\n+    public ScriptNode() {\n+    }\n+\n+    public ScriptNode(int pos) {\n+        super(pos);\n+    }\n+\n+    /**\n+     * Returns the URI, path or descriptive text indicating the origin\n+     * of this script's source code.\n+     */\n+    public String getSourceName() {\n+        return sourceName;\n+    }\n+\n+    /**\n+     * Sets the URI, path or descriptive text indicating the origin\n+     * of this script's source code.\n+     */\n+    public void setSourceName(String sourceName) {\n+        this.sourceName = sourceName;\n+    }\n+\n+    /**\n+     * Returns the start offset of the encoded source.\n+     * Only valid if {@link #getEncodedSource} returns non-{@code null}.\n+     */\n+    public int getEncodedSourceStart() {\n+        return encodedSourceStart;\n+    }\n+\n+    /**\n+     * Used by code generator.\n+     * @see #getEncodedSource\n+     */\n+    public void setEncodedSourceStart(int start) {\n+        this.encodedSourceStart = start;\n+    }\n+\n+    /**\n+     * Returns the end offset of the encoded source.\n+     * Only valid if {@link #getEncodedSource} returns non-{@code null}.\n+     */\n+    public int getEncodedSourceEnd() {\n+        return encodedSourceEnd;\n+    }\n+\n+    /**\n+     * Used by code generator.\n+     * @see #getEncodedSource\n+     */\n+    public void setEncodedSourceEnd(int end) {\n+        this.encodedSourceEnd = end;\n+    }\n+\n+    /**\n+     * Used by code generator.\n+     * @see #getEncodedSource\n+     */\n+    public void setEncodedSourceBounds(int start, int end) {\n+        this.encodedSourceStart = start;\n+        this.encodedSourceEnd = end;\n+    }\n+\n+    /**\n+     * Used by the code generator.\n+     * @see #getEncodedSource\n+     */\n+    public void setEncodedSource(String encodedSource) {\n+        this.encodedSource = encodedSource;\n+    }\n+\n+    /**\n+     * Returns a canonical version of the source for this script or function,\n+     * for use in implementing the {@code Object.toSource} method of\n+     * JavaScript objects.  This source encoding is only recorded during code\n+     * generation.  It must be passed back to\n+     * {@link org.mozilla.javascript.Decompiler#decompile} to construct the\n+     * human-readable source string.<p>\n+     *\n+     * Given a parsed AST, you can always convert it to source code using the\n+     * {@link AstNode#toSource} method, although it's not guaranteed to produce\n+     * exactly the same results as {@code Object.toSource} with respect to\n+     * formatting, parenthesization and other details.\n+     * \n+     * @return the encoded source, or {@code null} if it was not recorded.\n+     */\n+    public String getEncodedSource() {\n+        return encodedSource;\n+    }\n+\n+    public int getBaseLineno() {\n+        return lineno;\n+    }\n+\n+    /**\n+     * Sets base (starting) line number for this script or function.\n+     * This is a one-time operation, and throws an exception if the\n+     * line number has already been set.\n+     */\n+    public void setBaseLineno(int lineno) {\n+        if (lineno < 0 || this.lineno >= 0) codeBug();\n+        this.lineno = lineno;\n+    }\n+\n+    public int getEndLineno() {\n+        return endLineno;\n+    }\n+\n+    public void setEndLineno(int lineno) {\n+        // One time action\n+        if (lineno < 0 || endLineno >= 0) codeBug();\n+        endLineno = lineno;\n+    }\n+\n+    public int getFunctionCount() {\n+        return functions == null ? 0 : functions.size();\n+    }\n+\n+    public FunctionNode getFunctionNode(int i) {\n+        return functions.get(i);\n+    }\n+\n+    public List<FunctionNode> getFunctions() {\n+        return functions == null ? EMPTY_LIST : functions;\n+    }\n+\n+    /**\n+     * Adds a {@link FunctionNode} to the functions table for codegen.\n+     * Does not set the parent of the node.\n+     * @return the index of the function within its parent\n+     */\n+    public int addFunction(FunctionNode fnNode) {\n+        if (fnNode == null) codeBug();\n+        if (functions == null)\n+            functions = new ArrayList<FunctionNode>();\n+        functions.add(fnNode);\n+        return functions.size() - 1;\n+    }\n+\n+    public int getRegexpCount() {\n+        return regexps == null ? 0 : regexps.size();\n+    }\n+\n+    public String getRegexpString(int index) {\n+        return regexps.get(index).getValue();\n+    }\n+\n+    public String getRegexpFlags(int index) {\n+        return regexps.get(index).getFlags();\n+    }\n+\n+    /**\n+     * Called by IRFactory to add a RegExp to the regexp table.\n+     */\n+    public void addRegExp(RegExpLiteral re) {\n+        if (re == null) codeBug();\n+        if (regexps == null)\n+            regexps = new ArrayList<RegExpLiteral>();\n+        regexps.add(re);\n+        re.putIntProp(REGEXP_PROP, regexps.size() - 1);\n+    }\n+\n+    public int getIndexForNameNode(Node nameNode) {\n+        if (variableNames == null) codeBug();\n+        Scope node = nameNode.getScope();\n+        Symbol symbol = node == null\n+            ? null\n+            : node.getSymbol(((Name)nameNode).getIdentifier());\n+        return (symbol == null) ? -1 : symbol.getIndex();\n+    }\n+\n+    public String getParamOrVarName(int index) {\n+        if (variableNames == null) codeBug();\n+        return variableNames[index];\n+    }\n+\n+    public int getParamCount() {\n+        return paramCount;\n+    }\n+\n+    public int getParamAndVarCount() {\n+        if (variableNames == null) codeBug();\n+        return symbols.size();\n+    }\n+\n+    public String[] getParamAndVarNames() {\n+        if (variableNames == null) codeBug();\n+        return variableNames;\n+    }\n+\n+    public boolean[] getParamAndVarConst() {\n+        if (variableNames == null) codeBug();\n+        return isConsts;\n+    }\n+\n+    void addSymbol(Symbol symbol) {\n+        if (variableNames != null) codeBug();\n+        if (symbol.getDeclType() == Token.LP) {\n+            paramCount++;\n+        }\n+        symbols.add(symbol);\n+    }\n+\n+    public List<Symbol> getSymbols() {\n+        return symbols;\n+    }\n+\n+    public void setSymbols(List<Symbol> symbols) {\n+        this.symbols = symbols;\n+    }\n+\n+    /**\n+     * Assign every symbol a unique integer index. Generate arrays of variable\n+     * names and constness that can be indexed by those indices.\n+     *\n+     * @param flattenAllTables if true, flatten all symbol tables,\n+     * included nested block scope symbol tables. If false, just flatten the\n+     * script's or function's symbol table.\n+     */\n+    public void flattenSymbolTable(boolean flattenAllTables) {\n+        if (!flattenAllTables) {\n+            List<Symbol> newSymbols = new ArrayList<Symbol>();\n+            if (this.symbolTable != null) {\n+                // Just replace \"symbols\" with the symbols in this object's\n+                // symbol table. Can't just work from symbolTable map since\n+                // we need to retain duplicate parameters.\n+                for (int i = 0; i < symbols.size(); i++) {\n+                    Symbol symbol = symbols.get(i);\n+                    if (symbol.getContainingTable() == this) {\n+                        newSymbols.add(symbol);\n+                    }\n+                }\n+            }\n+            symbols = newSymbols;\n+        }\n+        variableNames = new String[symbols.size()];\n+        isConsts = new boolean[symbols.size()];\n+        for (int i = 0; i < symbols.size(); i++) {\n+            Symbol symbol = symbols.get(i);\n+            variableNames[i] = symbol.getName();\n+            isConsts[i] = symbol.getDeclType() == Token.CONST;\n+            symbol.setIndex(i);\n+        }\n+    }\n+\n+    public Object getCompilerData() {\n+        return compilerData;\n+    }\n+\n+    public void setCompilerData(Object data) {\n+        assertNotNull(data);\n+        // Can only call once\n+        if (compilerData != null)\n+            throw new IllegalStateException();\n+        compilerData = data;\n+    }\n+\n+    public String getNextTempName() {\n+        return \"$\" + tempNumber++;\n+    }\n+\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            for (Node kid : this) {\n+                ((AstNode)kid).visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/StringLiteral.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for a single- or double-quoted string literal.\n+ * Node type is {@link Token#STRING}.<p>\n+ */\n+public class StringLiteral extends AstNode {\n+\n+    private String value;\n+    private char quoteChar;\n+\n+    {\n+        type = Token.STRING;\n+    }\n+\n+    public StringLiteral() {\n+    }\n+\n+    public StringLiteral(int pos) {\n+        super(pos);\n+    }\n+\n+    /**\n+     * Creates a string literal node at the specified position.\n+     * @param len the length <em>including</em> the enclosing quotes\n+     */\n+    public StringLiteral(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns the node's value:  the parsed string without the enclosing quotes\n+     * @return the node's value, a {@link String} of unescaped characters\n+     * that includes the delimiter quotes.\n+     */\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the string value, optionally including the enclosing quotes.\n+     */\n+    public String getValue(boolean includeQuotes) {\n+        if (!includeQuotes)\n+            return value;\n+        return quoteChar + value + quoteChar;\n+    }\n+\n+    /**\n+     * Sets the node's value.  Do not include the enclosing quotes.\n+     * @param value the node's value\n+     * @throws IllegalArgumentException} if value is {@code null}\n+     */\n+    public void setValue(String value) {\n+        assertNotNull(value);\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Returns the character used as the delimiter for this string.\n+     */\n+    public char getQuoteCharacter() {\n+        return quoteChar;\n+    }\n+\n+    public void setQuoteCharacter(char c) {\n+        quoteChar = c;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        // TODO(stevey):  make sure this unescapes everything properly\n+        String q = String.valueOf(getQuoteCharacter());\n+        String rep = \"\\\\\\\\\" + q;\n+        String s = value.replaceAll(q, rep);\n+        s = s.replaceAll(\"\\n\", \"\\\\\\\\n\");\n+        s = s.replaceAll(\"\\r\", \"\\\\\\\\r\");\n+        s = s.replaceAll(\"\\t\", \"\\\\\\\\t\");\n+        s = s.replaceAll(\"\\f\", \"\\\\\\\\f\");\n+        return makeIndent(depth) + q + s + q;\n+    }\n+\n+    /**\n+     * Visits this node.  There are no children to visit.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        v.visit(this);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/SwitchCase.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Switch-case AST node type.  The switch case is always part of a\n+ * switch statement.\n+ * Node type is {@link Token#CASE}.<p>\n+ *\n+ * <pre><i>CaseBlock</i> :\n+ *        { [CaseClauses] }\n+ *        { [CaseClauses] DefaultClause [CaseClauses] }\n+ * <i>CaseClauses</i> :\n+ *        CaseClause\n+ *        CaseClauses CaseClause\n+ * <i>CaseClause</i> :\n+ *        <b>case</b> Expression : [StatementList]\n+ * <i>DefaultClause</i> :\n+ *        <b>default</b> : [StatementList]</pre>\n+ */\n+public class SwitchCase extends AstNode {\n+\n+    private AstNode expression;\n+    private List<AstNode> statements;\n+\n+    {\n+        type = Token.CASE;\n+    }\n+\n+    public SwitchCase() {\n+    }\n+\n+    public SwitchCase(int pos) {\n+        super(pos);\n+    }\n+\n+    public SwitchCase(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns the case expression, {@code null} for default case\n+     */\n+    public AstNode getExpression() {\n+        return expression;\n+    }\n+\n+    /**\n+     * Sets the case expression, {@code null} for default case.\n+     * Note that for empty fall-through cases, they still have\n+     * a case expression.  In {@code case 0: case 1: break;} the\n+     * first case has an {@code expression} that is a\n+     * {@link NumberLiteral} with value {@code 0}.\n+     */\n+    public void setExpression(AstNode expression) {\n+        this.expression = expression;\n+        if (expression != null)\n+            expression.setParent(this);\n+    }\n+\n+    /**\n+     * Return true if this is a default case.\n+     * @return true if {@link #getExpression} would return {@code null}\n+     */\n+    public boolean isDefault() {\n+        return expression == null;\n+    }\n+\n+    /**\n+     * Returns statement list, which may be {@code null}.\n+     */\n+    public List<AstNode> getStatements() {\n+        return statements;\n+    }\n+\n+    /**\n+     * Sets statement list.  May be {@code null}.  Replaces any existing\n+     * statements.  Each element in the list has its parent set to this node.\n+     */\n+    public void setStatements(List<AstNode> statements) {\n+        if (this.statements != null) {\n+            this.statements.clear();\n+        }\n+        for (AstNode s : statements) {\n+            addStatement(s);\n+        }\n+    }\n+\n+    /**\n+     * Adds a statement to the end of the statement list.\n+     * Sets the parent of the new statement to this node, updates\n+     * its start offset to be relative to this node, and sets the\n+     * length of this node to include the new child.\n+     *\n+     * @param statement a child statement\n+     * @throws IllegalArgumentException} if statement is {@code null}\n+     */\n+    public void addStatement(AstNode statement) {\n+        assertNotNull(statement);\n+        if (statements == null) {\n+            statements = new ArrayList<AstNode>();\n+        }\n+        int end = statement.getPosition() + statement.getLength();\n+        this.setLength(end - this.getPosition());\n+        statements.add(statement);\n+        statement.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        if (expression == null) {\n+            sb.append(\"default:\\n\");\n+        } else {\n+            sb.append(\"case \");\n+            sb.append(expression.toSource(0));\n+            sb.append(\":\\n\");\n+        }\n+        if (statements != null) {\n+            for (AstNode s : statements) {\n+                sb.append(s.toSource(depth+1));\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the case expression if present, then\n+     * each statement (if any are specified).\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            if (expression != null) {\n+                expression.visit(v);\n+            }\n+            if (statements != null) {\n+                for (AstNode s : statements) {\n+                    s.visit(v);\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/SwitchStatement.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Switch statement AST node type.\n+ * Node type is {@link Token#SWITCH}.<p>\n+ *\n+ * <pre><i>SwitchStatement</i> :\n+ *        <b>switch</b> ( Expression ) CaseBlock\n+ * <i>CaseBlock</i> :\n+ *        { [CaseClauses] }\n+ *        { [CaseClauses] DefaultClause [CaseClauses] }\n+ * <i>CaseClauses</i> :\n+ *        CaseClause\n+ *        CaseClauses CaseClause\n+ * <i>CaseClause</i> :\n+ *        <b>case</b> Expression : [StatementList]\n+ * <i>DefaultClause</i> :\n+ *        <b>default</b> : [StatementList]</pre>\n+ */\n+public class SwitchStatement extends Jump {\n+\n+    private static final List<SwitchCase> NO_CASES =\n+        Collections.unmodifiableList(new ArrayList<SwitchCase>());\n+\n+    private AstNode expression;\n+    private List<SwitchCase> cases;\n+    private int lp = -1;\n+    private int rp = -1;\n+\n+    {\n+        type = Token.SWITCH;\n+    }\n+\n+    public SwitchStatement() {\n+    }\n+\n+    public SwitchStatement(int pos) {\n+        // can't call super (Jump) for historical reasons\n+        position = pos;\n+    }\n+\n+    public SwitchStatement(int pos, int len) {\n+        position = pos;\n+        length = len;\n+    }\n+\n+    /**\n+     * Returns the switch discriminant expression\n+     */\n+    public AstNode getExpression() {\n+        return expression;\n+    }\n+\n+    /**\n+     * Sets the switch discriminant expression, and sets its parent\n+     * to this node.\n+     * @throws IllegalArgumentException} if expression is {@code null}\n+     */\n+    public void setExpression(AstNode expression) {\n+        assertNotNull(expression);\n+        this.expression = expression;\n+        expression.setParent(this);\n+    }\n+\n+    /**\n+     * Returns case statement list.  If there are no cases,\n+     * returns an immutable empty list.\n+     */\n+    public List<SwitchCase> getCases() {\n+        return cases != null ? cases : NO_CASES;\n+    }\n+\n+    /**\n+     * Sets case statement list, and sets the parent of each child\n+     * case to this node.\n+     * @param cases list, which may be {@code null} to remove all the cases\n+     */\n+    public void setCases(List<SwitchCase> cases) {\n+        if (cases == null) {\n+            this.cases = null;\n+        } else {\n+            if (this.cases != null)\n+                this.cases.clear();\n+            for (SwitchCase sc : cases)\n+                addCase(sc);\n+        }\n+    }\n+\n+    /**\n+     * Adds a switch case statement to the end of the list.\n+     * @throws IllegalArgumentException} if switchCase is {@code null}\n+     */\n+    public void addCase(SwitchCase switchCase) {\n+        assertNotNull(switchCase);\n+        if (cases == null) {\n+            cases = new ArrayList<SwitchCase>();\n+        }\n+        cases.add(switchCase);\n+        switchCase.setParent(this);\n+    }\n+\n+    /**\n+     * Returns left paren position, -1 if missing\n+     */\n+    public int getLp() {\n+        return lp;\n+    }\n+\n+    /**\n+     * Sets left paren position\n+     */\n+    public void setLp(int lp) {\n+        this.lp = lp;\n+    }\n+\n+    /**\n+     * Returns right paren position, -1 if missing\n+     */\n+    public int getRp() {\n+        return rp;\n+    }\n+\n+    /**\n+     * Sets right paren position\n+     */\n+    public void setRp(int rp) {\n+        this.rp = rp;\n+    }\n+\n+    /**\n+     * Sets both paren positions\n+     */\n+    public void setParens(int lp, int rp) {\n+        this.lp = lp;\n+        this.rp = rp;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        String pad = makeIndent(depth);\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(pad);\n+        sb.append(\"switch (\");\n+        sb.append(expression.toSource(0));\n+        sb.append(\") {\\n\");\n+        for (SwitchCase sc : cases) {\n+            sb.append(sc.toSource(depth + 1));\n+        }\n+        sb.append(pad);\n+        sb.append(\"}\\n\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the switch-expression, then the cases\n+     * in lexical order.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            expression.visit(v);\n+            for (SwitchCase sc: getCases()) {\n+                sc.visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/Symbol.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Roger Lawrence\n+ *   Mike McCabe\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * Represents a symbol-table entry.\n+ */\n+public class Symbol {\n+\n+    // One of Token.FUNCTION, Token.LP (for parameters), Token.VAR, \n+    // Token.LET, or Token.CONST\n+    private int declType;\n+    private int index = -1;\n+    private String name;\n+    private Node node;\n+    private Scope containingTable;\n+\n+    public Symbol() {\n+    }\n+\n+    /**\n+     * Constructs a new Symbol with a specific name and declaration type\n+     * @param declType {@link Token#FUNCTION}, {@link Token#LP}\n+     * (for params), {@link Token#VAR}, {@link Token#LET} or {@link Token#CONST}\n+     */\n+    public Symbol(int declType, String name) {\n+        setName(name);\n+        setDeclType(declType);\n+    }\n+\n+    /**\n+     * Returns symbol declaration type\n+     */\n+    public int getDeclType() {\n+        return declType;\n+    }\n+\n+    /**\n+     * Sets symbol declaration type\n+     */\n+    public void setDeclType(int declType) {\n+        if (!(declType == Token.FUNCTION\n+              || declType == Token.LP\n+              || declType == Token.VAR\n+              || declType == Token.LET\n+              || declType == Token.CONST))\n+            throw new IllegalArgumentException(\"Invalid declType: \" + declType);\n+        this.declType = declType;\n+    }\n+\n+    /**\n+     * Returns symbol name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Sets symbol name\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Returns the node associated with this identifier\n+     */\n+    public Node getNode() {\n+        return node;\n+    }\n+\n+    /**\n+     * Returns symbol's index in its scope\n+     */\n+    public int getIndex() {\n+        return index;\n+    }\n+\n+    /**\n+     * Sets symbol's index in its scope\n+     */\n+    public void setIndex(int index) {\n+        this.index = index;\n+    }\n+\n+    /**\n+     * Sets the node associated with this identifier\n+     */\n+    public void setNode(Node node) {\n+        this.node = node;\n+    }\n+\n+    /**\n+     * Returns the Scope in which this symbol is entered\n+     */\n+    public Scope getContainingTable() {\n+        return containingTable;\n+    }\n+\n+    /**\n+     * Sets this symbol's Scope\n+     */\n+    public void setContainingTable(Scope containingTable) {\n+        this.containingTable = containingTable;\n+    }\n+\n+    public String getDeclTypeName() {\n+        return Token.typeToName(declType);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder result = new StringBuilder();\n+        result.append(\"Symbol (\");\n+        result.append(getDeclTypeName());\n+        result.append(\") name=\");\n+        result.append(name);\n+        if (node != null) {\n+            result.append(\" line=\");\n+            result.append(node.getLineno());\n+        }\n+        return result.toString();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/ThrowStatement.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * Throw statement.  Node type is {@link Token#THROW}.<p>\n+ *\n+ * <pre><i>ThrowStatement</i> :\n+ *      <b>throw</b> [<i>no LineTerminator here</i>] Expression ;</pre>\n+ */\n+public class ThrowStatement extends AstNode {\n+\n+    private AstNode expression;\n+\n+    {\n+        type = Token.THROW;\n+    }\n+\n+    public ThrowStatement() {\n+    }\n+\n+    public ThrowStatement(int pos) {\n+        super(pos);\n+    }\n+\n+    public ThrowStatement(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    public ThrowStatement(AstNode expr) {\n+        setExpression(expr);\n+    }\n+\n+    public ThrowStatement(int pos, AstNode expr) {\n+        super(pos, expr.getLength());\n+        setExpression(expr);\n+    }\n+\n+    public ThrowStatement(int pos, int len, AstNode expr) {\n+        super(pos, len);\n+        setExpression(expr);\n+    }\n+\n+    /**\n+     * Returns the expression being thrown\n+     */\n+    public AstNode getExpression() {\n+        return expression;\n+    }\n+\n+    /**\n+     * Sets the expression being thrown, and sets its parent\n+     * to this node.\n+     * @throws IllegalArgumentException} if expression is {@code null}\n+     */\n+    public void setExpression(AstNode expression) {\n+        assertNotNull(expression);\n+        this.expression = expression;\n+        expression.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"throw\");\n+        sb.append(\" \");\n+        sb.append(expression.toSource(0));\n+        sb.append(\";\\n\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the thrown expression.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            expression.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/TryStatement.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Try/catch/finally statement.  Node type is {@link Token#TRY}.<p>\n+ *\n+ * <pre><i>TryStatement</i> :\n+ *        <b>try</b> Block Catch\n+ *        <b>try</b> Block Finally\n+ *        <b>try</b> Block Catch Finally\n+ * <i>Catch</i> :\n+ *        <b>catch</b> ( <i><b>Identifier</b></i> ) Block\n+ * <i>Finally</i> :\n+ *        <b>finally</b> Block</pre>\n+ */\n+public class TryStatement extends AstNode {\n+\n+    private static final List<CatchClause> NO_CATCHES =\n+        Collections.unmodifiableList(new ArrayList<CatchClause>());\n+\n+    private AstNode tryBlock;\n+    private List<CatchClause> catchClauses;\n+    private AstNode finallyBlock;\n+    private int finallyPosition = -1;\n+\n+    {\n+        type = Token.TRY;\n+    }\n+\n+    public TryStatement() {\n+    }\n+\n+    public TryStatement(int pos) {\n+        super(pos);\n+    }\n+\n+    public TryStatement(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    public AstNode getTryBlock() {\n+        return tryBlock;\n+    }\n+\n+    /**\n+     * Sets try block.  Also sets its parent to this node.\n+     * @throws IllegalArgumentException} if {@code tryBlock} is {@code null}\n+     */\n+    public void setTryBlock(AstNode tryBlock) {\n+        assertNotNull(tryBlock);\n+        this.tryBlock = tryBlock;\n+        tryBlock.setParent(this);\n+    }\n+\n+    /**\n+     * Returns list of {@link CatchClause} nodes.  If there are no catch\n+     * clauses, returns an immutable empty list.\n+     */\n+    public List<CatchClause> getCatchClauses() {\n+        return catchClauses != null ? catchClauses : NO_CATCHES;\n+    }\n+\n+    /**\n+     * Sets list of {@link CatchClause} nodes.  Also sets their parents\n+     * to this node.  May be {@code null}.  Replaces any existing catch\n+     * clauses for this node.\n+     */\n+    public void setCatchClauses(List<CatchClause> catchClauses) {\n+        if (catchClauses == null) {\n+            this.catchClauses = null;\n+        } else {\n+            if (this.catchClauses != null)\n+                this.catchClauses.clear();\n+            for (CatchClause cc : catchClauses) {\n+                addCatchClause(cc);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add a catch-clause to the end of the list, and sets its parent to\n+     * this node.\n+     * @throws IllegalArgumentException} if {@code clause} is {@code null}\n+     */\n+    public void addCatchClause(CatchClause clause) {\n+        assertNotNull(clause);\n+        if (catchClauses == null) {\n+            catchClauses = new ArrayList<CatchClause>();\n+        }\n+        catchClauses.add(clause);\n+        clause.setParent(this);\n+    }\n+\n+    /**\n+     * Returns finally block, or {@code null} if not present\n+     */\n+    public AstNode getFinallyBlock() {\n+        return finallyBlock;\n+    }\n+\n+    /**\n+     * Sets finally block, and sets its parent to this node.\n+     * May be {@code null}.\n+     */\n+    public void setFinallyBlock(AstNode finallyBlock) {\n+        this.finallyBlock = finallyBlock;\n+        if (finallyBlock != null)\n+            finallyBlock.setParent(this);\n+    }\n+\n+    /**\n+     * Returns position of {@code finally} keyword, if present, or -1\n+     */\n+    public int getFinallyPosition() {\n+        return finallyPosition;\n+    }\n+\n+    /**\n+     * Sets position of {@code finally} keyword, if present, or -1\n+     */\n+    public void setFinallyPosition(int finallyPosition) {\n+        this.finallyPosition = finallyPosition;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder(250);\n+        sb.append(makeIndent(depth));\n+        sb.append(\"try \");\n+        sb.append(tryBlock.toSource(depth).trim());\n+        for (CatchClause cc : getCatchClauses()) {\n+            sb.append(cc.toSource(depth));\n+        }\n+        if (finallyBlock != null) {\n+            sb.append(\" finally \");\n+            sb.append(finallyBlock.toSource(depth));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the try-block, then any catch clauses,\n+     * and then any finally block.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            tryBlock.visit(v);\n+            for (CatchClause cc : getCatchClauses()) {\n+                cc.visit(v);\n+            }\n+            if (finallyBlock != null) {\n+                finallyBlock.visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/UnaryExpression.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node representing unary operators such as {@code ++},\n+ * {@code ~}, {@code typeof} and {@code delete}.  The type field\n+ * is set to the appropriate Token type for the operator.  The node length spans\n+ * from the operator to the end of the operand (for prefix operators) or from\n+ * the start of the operand to the operator (for postfix).<p>\n+ *\n+ * The {@code default xml namespace = &lt;expr&gt;} statement in E4X\n+ * (JavaScript 1.6) is represented as a {@code UnaryExpression} of node\n+ * type {@link Token#DEFAULTNAMESPACE}, wrapped with an\n+ * {@link ExpressionStatement}.\n+ */\n+public class UnaryExpression extends AstNode {\n+\n+    private AstNode operand;\n+    private boolean isPostfix;\n+\n+    public UnaryExpression() {\n+    }\n+\n+    public UnaryExpression(int pos) {\n+        super(pos);\n+    }\n+\n+    /**\n+     * Constructs a new postfix UnaryExpression\n+     */\n+    public UnaryExpression(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Constructs a new prefix UnaryExpression.\n+     */\n+    public UnaryExpression(int operator, int operatorPosition,\n+                           AstNode operand) {\n+        this(operator, operatorPosition, operand, false);\n+    }\n+\n+    /**\n+     * Constructs a new UnaryExpression with the specified operator\n+     * and operand.  It sets the parent of the operand, and sets its own bounds\n+     * to encompass the operator and operand.\n+     * @param operator the node type\n+     * @param operatorPosition the absolute position of the operator.\n+     * @param operand the operand expression\n+     * @param postFix true if the operator follows the operand.  Int\n+     * @throws IllegalArgumentException} if {@code operand} is {@code null}\n+     */\n+    public UnaryExpression(int operator, int operatorPosition,\n+                           AstNode operand, boolean postFix) {\n+        assertNotNull(operand);\n+        int beg = postFix ? operand.getPosition() : operatorPosition;\n+        // JavaScript only has ++ and -- postfix operators, so length is 2\n+        int end = postFix\n+                  ? operatorPosition + 2\n+                  : operand.getPosition() + operand.getLength();\n+        setBounds(beg, end);\n+        setOperator(operator);\n+        setOperand(operand);\n+        isPostfix = postFix;\n+    }\n+\n+    /**\n+     * Returns operator token &ndash; alias for {@link #getType}\n+     */\n+    public int getOperator() {\n+        return type;\n+    }\n+\n+    /**\n+     * Sets operator &ndash; same as {@link #setType}, but throws an\n+     * exception if the operator is invalid\n+     * @throws IllegalArgumentException if operator is not a valid\n+     * Token code\n+     */\n+    public void setOperator(int operator) {\n+        if (!Token.isValidToken(operator))\n+            throw new IllegalArgumentException(\"Invalid token: \" + operator);\n+        setType(operator);\n+    }\n+\n+    public AstNode getOperand() {\n+        return operand;\n+    }\n+\n+    /**\n+     * Sets the operand, and sets its parent to be this node.\n+     * @throws IllegalArgumentException} if {@code operand} is {@code null}\n+     */\n+    public void setOperand(AstNode operand) {\n+        assertNotNull(operand);\n+        this.operand = operand;\n+        operand.setParent(this);\n+    }\n+\n+    /**\n+     * Returns whether the operator is postfix\n+     */\n+    public boolean isPostfix() {\n+        return isPostfix;\n+    }\n+\n+    /**\n+     * Returns whether the operator is prefix\n+     */\n+    public boolean isPrefix() {\n+        return !isPostfix;\n+    }\n+\n+    /**\n+     * Sets whether the operator is postfix\n+     */\n+    public void setIsPostfix(boolean isPostfix) {\n+        this.isPostfix = isPostfix;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        if (!isPostfix) {\n+            sb.append(operatorToString(getType()));\n+            if (getType() == Token.TYPEOF\n+                || getType() == Token.DELPROP) {\n+                sb.append(\" \");\n+            }\n+        }\n+        sb.append(operand.toSource());\n+        if (isPostfix) {\n+            sb.append(operatorToString(getType()));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the operand.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            operand.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/VariableDeclaration.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A list of one or more var, const or let declarations.\n+ * Node type is {@link Token#VAR}, {@link Token#CONST} or\n+ * {@link Token#LET}.<p>\n+ *\n+ * If the node is for {@code var} or {@code const}, the node position\n+ * is the beginning of the {@code var} or {@code const} keyword.\n+ * For {@code let} declarations, the node position coincides with the\n+ * first {@link VariableInitializer} child.<p>\n+ *\n+ * A standalone variable declaration in a statement context is wrapped with an\n+ * {@link ExpressionStatement}.\n+ */\n+public class VariableDeclaration extends AstNode {\n+\n+    private List<VariableInitializer> variables\n+        = new ArrayList<VariableInitializer>();\n+\n+    {\n+        type = Token.VAR;\n+    }\n+\n+    public VariableDeclaration() {\n+    }\n+\n+    public VariableDeclaration(int pos) {\n+        super(pos);\n+    }\n+\n+    public VariableDeclaration(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns variable list.  Never {@code null}.\n+     */\n+    public List<VariableInitializer> getVariables() {\n+        return variables;\n+    }\n+\n+    /**\n+     * Sets variable list\n+     * @throws IllegalArgumentException if variables list is {@code null}\n+     */\n+    public void setVariables(List<VariableInitializer> variables) {\n+        assertNotNull(variables);\n+        this.variables.clear();\n+        for (VariableInitializer vi : variables) {\n+            addVariable(vi);\n+        }\n+    }\n+\n+    /**\n+     * Adds a variable initializer node to the child list.\n+     * Sets initializer node's parent to this node.\n+     * @throws IllegalArgumentException if v is {@code null}\n+     */\n+    public void addVariable(VariableInitializer v) {\n+        assertNotNull(v);\n+        variables.add(v);\n+        v.setParent(this);\n+    }\n+\n+    /**\n+     * Sets the node type and returns this node.\n+     * @throws IllegalArgumentException if {@code declType} is invalid\n+     */\n+    @Override\n+    public org.mozilla.javascript.Node setType(int type) {\n+        if (type != Token.VAR\n+            && type != Token.CONST\n+            && type != Token.LET)\n+            throw new IllegalArgumentException(\"invalid decl type: \" + type);\n+        return super.setType(type);\n+    }\n+\n+    /**\n+     * Returns true if this is a {@code var} (not\n+     * {@code const} or {@code let}) declaration.\n+     * @return true if {@code declType} is {@link Token#VAR}\n+     */\n+    public boolean isVar() {\n+        return type == Token.VAR;\n+    }\n+\n+    /**\n+     * Returns true if this is a {@link Token#CONST} declaration.\n+     */\n+    public boolean isConst() {\n+        return type == Token.CONST;\n+    }\n+\n+    /**\n+     * Returns true if this is a {@link Token#LET} declaration.\n+     */\n+    public boolean isLet() {\n+        return type == Token.LET;\n+    }\n+\n+    private String declTypeName() {\n+        return Token.typeToName(type).toLowerCase();\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(declTypeName());\n+        sb.append(\" \");\n+        printList(variables, sb);\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then each {@link VariableInitializer} child.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            for (AstNode var : variables) {\n+                var.visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/VariableInitializer.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * A variable declaration or initializer, part of a {@link VariableDeclaration}\n+ * expression.  The variable \"target\" can be a simple name or a destructuring\n+ * form.  The initializer, if present, can be any expression.<p>\n+ *\n+ * Node type is one of {@link Token#VAR}, {@link Token#CONST}, or\n+ * {@link Token#LET}.<p>\n+ */\n+public class VariableInitializer extends AstNode {\n+\n+    private AstNode target;\n+    private AstNode initializer;\n+\n+    {\n+        type = Token.VAR;\n+    }\n+\n+    /**\n+     * Sets the node type.\n+     * @throws IllegalArgumentException if {@code nodeType} is not one of\n+     * {@link Token#VAR}, {@link Token#CONST}, or {@link Token#LET}\n+     */\n+    public void setNodeType(int nodeType) {\n+        if (nodeType != Token.VAR\n+            && nodeType != Token.CONST\n+            && nodeType != Token.LET)\n+            throw new IllegalArgumentException(\"invalid node type\");\n+        setType(nodeType);\n+    }\n+\n+    public VariableInitializer() {\n+    }\n+\n+    public VariableInitializer(int pos) {\n+        super(pos);\n+    }\n+\n+    public VariableInitializer(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+\n+    /**\n+     * Returns true if this is a destructuring assignment.  If so, the\n+     * initializer must be non-{@code null}.\n+     * @return {@code true} if the {@code target} field is a destructuring form\n+     * (an {@link ArrayLiteral} or {@link ObjectLiteral} node)\n+     */\n+    public boolean isDestructuring() {\n+        return !(target instanceof Name);\n+    }\n+\n+    /**\n+     * Returns the variable name or destructuring form\n+     */\n+    public AstNode getTarget() {\n+        return target;\n+    }\n+\n+    /**\n+     * Sets the variable name or destructuring form, and sets\n+     * its parent to this node.\n+     * @throws IllegalArgumentException if target is {@code null}\n+     */\n+    public void setTarget(AstNode target) {\n+        // Don't throw exception if target is an \"invalid\" node type.\n+        // See mozilla/js/tests/js1_7/block/regress-350279.js\n+        if (target == null)\n+            throw new IllegalArgumentException(\"invalid target arg\");\n+        this.target = target;\n+        target.setParent(this);\n+    }\n+\n+    /**\n+     * Returns the initial value, or {@code null} if not provided\n+     */\n+    public AstNode getInitializer() {\n+        return initializer;\n+    }\n+\n+    /**\n+     * Sets the initial value expression, and sets its parent to this node.\n+     * @param initializer the initial value.  May be {@code null}.\n+     */\n+    public void setInitializer(AstNode initializer) {\n+        this.initializer = initializer;\n+        if (initializer != null)\n+            initializer.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(target.toSource(0));\n+        if (initializer != null) {\n+            sb.append (\" = \");\n+            sb.append(initializer.toSource(0));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the target expression, then the initializer\n+     * expression if present.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            target.visit(v);\n+            if (initializer != null) {\n+                initializer.visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/WhileLoop.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * While statement.  Node type is {@link Token#WHILE}.<p>\n+ *\n+ * <pre><i>WhileStatement</i>:\n+ *     <b>while</b> <b>(</b> Expression <b>)</b> Statement</pre>\n+ */\n+public class WhileLoop extends Loop {\n+\n+    private AstNode condition;\n+\n+    {\n+        type = Token.WHILE;\n+    }\n+\n+    public WhileLoop() {\n+    }\n+\n+    public WhileLoop(int pos) {\n+        super(pos);\n+    }\n+\n+    public WhileLoop(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns loop condition\n+     */\n+    public AstNode getCondition() {\n+        return condition;\n+    }\n+\n+    /**\n+     * Sets loop condition\n+     * @throws IllegalArgumentException} if condition is {@code null}\n+     */\n+    public void setCondition(AstNode condition) {\n+        assertNotNull(condition);\n+        this.condition = condition;\n+        condition.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"while (\");\n+        sb.append(condition.toSource(0));\n+        sb.append(\") \");\n+        if (body instanceof Block) {\n+            sb.append(body.toSource(depth).trim());\n+            sb.append(\"\\n\");\n+        } else {\n+            sb.append(\"\\n\").append(body.toSource(depth+1));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the condition, then the body.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            condition.visit(v);\n+            body.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/WithStatement.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * With statement.  Node type is {@link Token#WITH}.<p>\n+ *\n+ * <pre><i>WithStatement</i> :\n+ *      <b>with</b> ( Expression ) Statement ;</pre>\n+ */\n+public class WithStatement extends AstNode {\n+\n+    private AstNode expression;\n+    private AstNode statement;\n+    private int lp = -1;\n+    private int rp = -1;\n+\n+    {\n+        type = Token.WITH;\n+    }\n+\n+    public WithStatement() {\n+    }\n+\n+    public WithStatement(int pos) {\n+        super(pos);\n+    }\n+\n+    public WithStatement(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns object expression\n+     */\n+    public AstNode getExpression() {\n+        return expression;\n+    }\n+\n+    /**\n+     * Sets object expression (and its parent link)\n+     * @throws IllegalArgumentException} if expression is {@code null}\n+     */\n+    public void setExpression(AstNode expression) {\n+        assertNotNull(expression);\n+        this.expression = expression;\n+        expression.setParent(this);\n+    }\n+\n+    /**\n+     * Returns the statement or block\n+     */\n+    public AstNode getStatement() {\n+        return statement;\n+    }\n+\n+    /**\n+     * Sets the statement (and sets its parent link)\n+     * @throws IllegalArgumentException} if statement is {@code null}\n+     */\n+    public void setStatement(AstNode statement) {\n+        assertNotNull(statement);\n+        this.statement = statement;\n+        statement.setParent(this);\n+    }\n+\n+    /**\n+     * Returns left paren offset\n+     */\n+    public int getLp() {\n+      return lp;\n+    }\n+\n+    /**\n+     * Sets left paren offset\n+     */\n+    public void setLp(int lp) {\n+      this.lp = lp;\n+    }\n+\n+    /**\n+     * Returns right paren offset\n+     */\n+    public int getRp() {\n+      return rp;\n+    }\n+\n+    /**\n+     * Sets right paren offset\n+     */\n+    public void setRp(int rp) {\n+      this.rp = rp;\n+    }\n+\n+    /**\n+     * Sets both paren positions\n+     */\n+    public void setParens(int lp, int rp) {\n+        this.lp = lp;\n+        this.rp = rp;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(\"with (\");\n+        sb.append(expression.toSource(0));\n+        sb.append(\") \");\n+        sb.append(statement.toSource(depth+1));\n+        if (!(statement instanceof Block)) {\n+            sb.append(\";\\n\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the with-object, then the body statement.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            expression.visit(v);\n+            statement.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/XmlDotQuery.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node representing an E4X {@code foo.(bar)} query expression.\n+ * The node type (operator) is {@link Token#DOTQUERY}.\n+ * Its {@code getLeft} node is the target (\"foo\" in the example),\n+ * and the {@code getRight} node is the filter expression node.<p>\n+ *\n+ * This class exists separately from {@link InfixExpression} largely because it\n+ * has different printing needs.  The position of the left paren is just after\n+ * the dot (operator) position, and the right paren is the final position in the\n+ * bounds of the node.  If the right paren is missing, the node ends at the end\n+ * of the filter expression.\n+ */\n+public class XmlDotQuery extends InfixExpression {\n+\n+    private int rp = -1;\n+\n+    {\n+        type = Token.DOTQUERY;\n+    }\n+\n+    public XmlDotQuery() {\n+    }\n+\n+    public XmlDotQuery(int pos) {\n+        super(pos);\n+    }\n+\n+    public XmlDotQuery(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns right-paren position, -1 if missing.<p>\n+     *\n+     * Note that the left-paren is automatically the character\n+     * immediately after the \".\" in the operator - no whitespace is\n+     * permitted between the dot and lp by the scanner.\n+     */\n+    public int getRp() {\n+        return rp;\n+    }\n+\n+    /**\n+     * Sets right-paren position\n+     */\n+    public void setRp(int rp) {\n+        this.rp = rp;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(getLeft().toSource(0));\n+        sb.append(\".(\");\n+        sb.append(getRight().toSource(0));\n+        sb.append(\")\");\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/XmlElemRef.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for an E4X XML {@code [expr]} member-ref expression.\n+ * The node type is {@link Token#REF_MEMBER}.<p>\n+ *\n+ * Syntax:<p>\n+ *\n+ * <pre> @<i><sub>opt</sub></i> ns:: <i><sub>opt</sub></i> [ expr ]</pre>\n+ *\n+ * Examples include {@code ns::[expr]}, {@code @ns::[expr]}, {@code @[expr]},\n+ * {@code *::[expr]} and {@code @*::[expr]}.<p>\n+ *\n+ * Note that the form {@code [expr]} (i.e. no namespace or\n+ * attribute-qualifier) is not a legal {@code XmlElemRef} expression,\n+ * since it's already used for standard JavaScript {@link ElementGet}\n+ * array-indexing.  Hence, an {@code XmlElemRef} node always has\n+ * either the attribute-qualifier, a non-{@code null} namespace node,\n+ * or both.<p>\n+ *\n+ * The node starts at the {@code @} token, if present.  Otherwise it starts\n+ * at the namespace name.  The node bounds extend through the closing\n+ * right-bracket, or if it is missing due to a syntax error, through the\n+ * end of the index expression.<p>\n+ */\n+public class XmlElemRef extends XmlRef {\n+\n+    private AstNode indexExpr;\n+    private int lb = -1;\n+    private int rb = -1;\n+\n+    {\n+        type = Token.REF_MEMBER;\n+    }\n+\n+    public XmlElemRef() {\n+    }\n+\n+    public XmlElemRef(int pos) {\n+        super(pos);\n+    }\n+\n+    public XmlElemRef(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns index expression: the 'expr' in {@code @[expr]}\n+     * or {@code @*::[expr]}.\n+     */\n+    public AstNode getExpression() {\n+        return indexExpr;\n+    }\n+\n+    /**\n+     * Sets index expression, and sets its parent to this node.\n+     * @throws IllegalArgumentException if {@code expr} is {@code null}\n+     */\n+    public void setExpression(AstNode expr) {\n+        assertNotNull(expr);\n+        indexExpr = expr;\n+        expr.setParent(this);\n+    }\n+\n+    /**\n+     * Returns left bracket position, or -1 if missing.\n+     */\n+    public int getLb() {\n+        return lb;\n+    }\n+\n+    /**\n+     * Sets left bracket position, or -1 if missing.\n+     */\n+    public void setLb(int lb) {\n+        this.lb = lb;\n+    }\n+\n+    /**\n+     * Returns left bracket position, or -1 if missing.\n+     */\n+    public int getRb() {\n+        return rb;\n+    }\n+\n+    /**\n+     * Sets right bracket position, -1 if missing.\n+     */\n+    public void setRb(int rb) {\n+        this.rb = rb;\n+    }\n+\n+    /**\n+     * Sets both bracket positions.\n+     */\n+    public void setBrackets(int lb, int rb) {\n+        this.lb = lb;\n+        this.rb = rb;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        if (isAttributeAccess()) {\n+            sb.append(\"@\");\n+        }\n+        if (namespace != null) {\n+            sb.append(namespace.toSource(0));\n+            sb.append(\"::\");\n+        }\n+        sb.append(\"[\");\n+        sb.append(indexExpr.toSource(0));\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the namespace if provided, then the\n+     * index expression.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            if (namespace != null) {\n+                namespace.visit(v);\n+            }\n+            indexExpr.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/XmlExpression.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for an embedded JavaScript expression within an E4X XML literal.\n+ * Node type, like {@link XmlLiteral}, is {@link Token#XML}.  The node length\n+ * includes the curly braces.\n+ */\n+public class XmlExpression extends XmlFragment {\n+\n+    private AstNode expression;\n+    private boolean isXmlAttribute;\n+\n+    public XmlExpression() {\n+    }\n+\n+    public XmlExpression(int pos) {\n+        super(pos);\n+    }\n+\n+    public XmlExpression(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    public XmlExpression(int pos, AstNode expr) {\n+        super(pos);\n+        setExpression(expr);\n+    }\n+\n+    /**\n+     * Returns the expression embedded in {}\n+     */\n+    public AstNode getExpression() {\n+        return expression;\n+    }\n+\n+    /**\n+     * Sets the expression embedded in {}, and sets its parent to this node.\n+     * @throws IllegalArgumentException if {@code expression} is {@code null}\n+     */\n+    public void setExpression(AstNode expression) {\n+        assertNotNull(expression);\n+        this.expression = expression;\n+        expression.setParent(this);\n+    }\n+\n+    /**\n+     * Returns whether this is part of an xml attribute value\n+     */\n+    public boolean isXmlAttribute() {\n+      return isXmlAttribute;\n+    }\n+\n+    /**\n+     * Sets whether this is part of an xml attribute value\n+     */\n+    public void setIsXmlAttribute(boolean isXmlAttribute) {\n+      this.isXmlAttribute = isXmlAttribute;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        return makeIndent(depth) + \"{\" + expression.toSource(depth) + \"}\";\n+    }\n+\n+    /**\n+     * Visits this node, then the child expression.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            expression.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/XmlFragment.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * Abstract base type for components that comprise an {@link XmlLiteral}\n+ * object. Node type is {@link Token#XML}.<p>\n+ */\n+public abstract class XmlFragment extends AstNode {\n+\n+    {\n+        type = Token.XML;\n+    }\n+\n+    public XmlFragment() {\n+    }\n+\n+    public XmlFragment(int pos) {\n+        super(pos);\n+    }\n+\n+    public XmlFragment(int pos, int len) {\n+        super(pos, len);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/XmlLiteral.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * AST node for an E4X (Ecma-357) embedded XML literal.  Node type is\n+ * {@link Token#XML}.  The parser generates a simple list of strings and\n+ * expressions.  In the future we may parse the XML and produce a richer set of\n+ * nodes, but for now it's just a set of expressions evaluated to produce a\n+ * string to pass to the {@code XML} constructor function.<p>\n+ */\n+public class XmlLiteral extends AstNode {\n+\n+    private List<XmlFragment> fragments = new ArrayList<XmlFragment>();\n+\n+    {\n+        type = Token.XML;\n+    }\n+\n+    public XmlLiteral() {\n+    }\n+\n+    public XmlLiteral(int pos) {\n+        super(pos);\n+    }\n+\n+    public XmlLiteral(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns fragment list - a list of expression nodes.\n+     */\n+    public List<XmlFragment> getFragments() {\n+        return fragments;\n+    }\n+\n+    /**\n+     * Sets fragment list, removing any existing fragments first.\n+     * Sets the parent pointer for each fragment in the list to this node.\n+     * @param fragments fragment list.  Replaces any existing fragments.\n+     * @throws IllegalArgumentException} if {@code fragments} is {@code null}\n+     */\n+    public void setFragments(List<XmlFragment> fragments) {\n+        assertNotNull(fragments);\n+        this.fragments.clear();\n+        for (XmlFragment fragment : fragments)\n+            addFragment(fragment);\n+    }\n+\n+    /**\n+     * Adds a fragment to the fragment list.  Sets its parent to this node.\n+     * @throws IllegalArgumentException} if {@code fragment} is {@code null}\n+     */\n+    public void addFragment(XmlFragment fragment) {\n+        assertNotNull(fragment);\n+        fragments.add(fragment);\n+        fragment.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder(250);\n+        for (XmlFragment frag : fragments) {\n+            sb.append(frag.toSource(0));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then visits each child fragment in lexical order.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            for (XmlFragment frag : fragments) {\n+                frag.visit(v);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/XmlMemberGet.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for E4X \".@\" and \"..\" expressions, such as\n+ * {@code foo..bar}, {@code foo..@bar}, {@code @foo.@bar}, and\n+ * {@code foo..@ns::*}.  The right-hand node is always an\n+ * {@link XmlRef}. <p>\n+ *\n+ * Node type is {@link Token#DOT} or {@link Token#DOTDOT}.\n+ */\n+public class XmlMemberGet extends InfixExpression {\n+\n+    {\n+        type = Token.DOTDOT;\n+    }\n+\n+    public XmlMemberGet() {\n+    }\n+\n+    public XmlMemberGet(int pos) {\n+        super(pos);\n+    }\n+\n+    public XmlMemberGet(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    public XmlMemberGet(int pos, int len, AstNode target, XmlRef ref) {\n+        super(pos, len, target, ref);\n+    }\n+\n+    /**\n+     * Constructs a new {@code XmlMemberGet} node.\n+     * Updates bounds to include {@code target} and {@code ref} nodes.\n+     */\n+    public XmlMemberGet(AstNode target, XmlRef ref) {\n+        super(target, ref);\n+    }\n+\n+    public XmlMemberGet(AstNode target, XmlRef ref, int opPos) {\n+        super(Token.DOTDOT, target, ref, opPos);\n+    }\n+\n+    /**\n+     * Returns the object on which the XML member-ref expression\n+     * is being evaluated.  Should never be {@code null}.\n+     */\n+    public AstNode getTarget() {\n+        return getLeft();\n+    }\n+\n+    /**\n+     * Sets target object, and sets its parent to this node.\n+     * @throws IllegalArgumentException if {@code target} is {@code null}\n+     */\n+    public void setTarget(AstNode target) {\n+        setLeft(target);\n+    }\n+\n+    /**\n+     * Returns the right-side XML member ref expression.\n+     * Should never be {@code null} unless the code is malformed.\n+     */\n+    public XmlRef getMemberRef() {\n+        return (XmlRef)getRight();\n+    }\n+\n+    /**\n+     * Sets the XML member-ref expression, and sets its parent\n+     * to this node.\n+     * @throws IllegalArgumentException if property is {@code null}\n+     */\n+    public void setProperty(XmlRef ref) {\n+        setRight(ref);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        sb.append(getLeft().toSource(0));\n+        sb.append(operatorToString(getType()));\n+        sb.append(getRight().toSource(0));\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/XmlPropRef.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for an E4X XML {@code [expr]} property-ref expression.\n+ * The node type is {@link Token#REF_NAME}.<p>\n+ *\n+ * Syntax:<p>\n+ *\n+ * <pre> @<i><sub>opt</sub></i> ns:: <i><sub>opt</sub></i> name</pre>\n+ *\n+ * Examples include {@code name}, {@code ns::name}, {@code ns::*},\n+ * {@code *::name}, {@code *::*}, {@code @attr}, {@code @ns::attr},\n+ * {@code @ns::*}, {@code @*::attr}, {@code @*::*} and {@code @*}.<p>\n+ *\n+ * The node starts at the {@code @} token, if present.  Otherwise it starts\n+ * at the namespace name.  The node bounds extend through the closing\n+ * right-bracket, or if it is missing due to a syntax error, through the\n+ * end of the index expression.<p>\n+ */\n+public class XmlPropRef extends XmlRef {\n+\n+    private Name propName;\n+\n+    {\n+        type = Token.REF_NAME;\n+    }\n+\n+    public XmlPropRef() {\n+    }\n+\n+    public XmlPropRef(int pos) {\n+        super(pos);\n+    }\n+\n+    public XmlPropRef(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Returns property name.\n+     */\n+    public Name getPropName() {\n+        return propName;\n+    }\n+\n+    /**\n+     * Sets property name, and sets its parent to this node.\n+     * @throws IllegalArgumentException if {@code propName} is {@code null}\n+     */\n+    public void setPropName(Name propName) {\n+        assertNotNull(propName);\n+        this.propName = propName;\n+        propName.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth));\n+        if (isAttributeAccess()) {\n+            sb.append(\"@\");\n+        }\n+        if (namespace != null) {\n+            sb.append(namespace.toSource(0));\n+            sb.append(\"::\");\n+        }\n+        sb.append(propName.toSource(0));\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, then the namespace if present, then the property name.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            if (namespace != null) {\n+                namespace.visit(v);\n+            }\n+            propName.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/XmlRef.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+/**\n+ * Base class for E4X XML attribute-access or property-get expressions.\n+ * Such expressions can take a variety of forms. The general syntax has\n+ * three parts:<p>\n+ *\n+ * <ol>\n+ *  <li>optional: an {@code @}</li>  (specifying an attribute access)</li>\n+ *  <li>optional: a namespace (a {@code Name}) and double-colon</li>\n+ *  <li>required:  either a {@code Name} or a bracketed [expression]</li>\n+ * </ol>\n+ *\n+ * The property-name expressions (examples:  {@code ns::name}, {@code @name})\n+ * are represented as {@link XmlPropRef} nodes.  The bracketed-expression\n+ * versions (examples:  {@code ns::[name]}, {@code @[name]}) become\n+ * {@link XmlElemRef} nodes.<p>\n+ *\n+ * This node type (or more specifically, its subclasses) will\n+ * sometimes be the right-hand child of a {@link PropertyGet} node or\n+ * an {@link XmlMemberGet} node.  The {@code XmlRef} node may also\n+ * be a standalone primary expression with no explicit target, which\n+ * is valid in certain expression contexts such as\n+ * {@code company..employee.(@id &lt; 100)} - in this case, the {@code @id}\n+ * is an {@code XmlRef} that is part of an infix '&lt;' expression\n+ * whose parent is an {@code XmlDotQuery} node.<p>\n+ */\n+public abstract class XmlRef extends AstNode {\n+\n+    protected Name namespace;\n+    protected int atPos = -1;\n+    protected int colonPos = -1;\n+\n+    public XmlRef() {\n+    }\n+\n+    public XmlRef(int pos) {\n+        super(pos);\n+    }\n+\n+    public XmlRef(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    /**\n+     * Return the namespace.  May be {@code @null}.\n+     */\n+    public Name getNamespace() {\n+        return namespace;\n+    }\n+\n+    /**\n+     * Sets namespace, and sets its parent to this node.\n+     * Can be {@code null}.\n+     */\n+    public void setNamespace(Name namespace) {\n+        this.namespace = namespace;\n+        if (namespace != null)\n+            namespace.setParent(this);\n+    }\n+\n+    /**\n+     * Returns {@code true} if this expression began with an {@code @}-token.\n+     */\n+    public boolean isAttributeAccess() {\n+        return atPos >= 0;\n+    }\n+\n+    /**\n+     * Returns position of {@code @}-token, or -1 if this is not\n+     * an attribute-access expression.\n+     */\n+    public int getAtPos() {\n+        return atPos;\n+    }\n+\n+    /**\n+     * Sets position of {@code @}-token, or -1\n+     */\n+    public void setAtPos(int atPos) {\n+        this.atPos = atPos;\n+    }\n+\n+    /**\n+     * Returns position of {@code ::} token, or -1 if not present.\n+     * It will only be present if the namespace node is non-{@code null}.\n+     */\n+    public int getColonPos() {\n+        return colonPos;\n+    }\n+\n+    /**\n+     * Sets position of {@code ::} token, or -1 if not present\n+     */\n+    public void setColonPos(int colonPos) {\n+        this.colonPos = colonPos;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/XmlString.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+/**\n+ * AST node for an XML-text-only component of an XML literal expression.  This\n+ * node differs from a {@link StringLiteral} in that it does not have quotes for\n+ * delimiters.\n+ */\n+public class XmlString extends XmlFragment {\n+\n+    private String xml;\n+\n+    public XmlString() {\n+    }\n+\n+    public XmlString(int pos) {\n+        super(pos);\n+    }\n+\n+    public XmlString(int pos, String s) {\n+        super(pos);\n+        setXml(s);\n+    }\n+\n+    /**\n+     * Sets the string for this XML component.  Sets the length of the\n+     * component to the length of the passed string.\n+     * @param s a string of xml text\n+     * @throws IllegalArgumentException} if {@code s} is {@code null}\n+     */\n+    public void setXml(String s) {\n+        assertNotNull(s);\n+        xml = s;\n+        setLength(s.length());\n+    }\n+\n+    /**\n+     * Returns the xml string for this component.\n+     * Note that it may not be well-formed XML; it is a fragment.\n+     */\n+    public String getXml() {\n+        return xml;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        return makeIndent(depth) + xml;\n+    }\n+\n+    /**\n+     * Visits this node.  There are no children to visit.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        v.visit(this);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/ast/Yield.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for JavaScript 1.7 {@code yield} expression or statement.\n+ * Node type is {@link Token#YIELD}.<p>\n+ *\n+ * <pre><i>Yield</i> :\n+ *   <b>yield</b> [<i>no LineTerminator here</i>] [non-paren Expression] ;</pre>\n+ */\n+public class Yield extends AstNode {\n+\n+    private AstNode value;\n+\n+    {\n+        type = Token.YIELD;\n+    }\n+\n+    public Yield() {\n+    }\n+\n+    public Yield(int pos) {\n+        super(pos);\n+    }\n+\n+    public Yield(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    public Yield(int pos, int len, AstNode value) {\n+        super(pos, len);\n+        setValue(value);\n+    }\n+\n+    /**\n+     * Returns yielded expression, {@code null} if none\n+     */\n+    public AstNode getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Sets yielded expression, and sets its parent to this node.\n+     * @param expr the value to yield. Can be {@code null}.\n+     */\n+    public void setValue(AstNode expr) {\n+        this.value = expr;\n+        if (expr != null)\n+            expr.setParent(this);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        return value == null\n+                ? \"yield\"\n+                : \"yield \" + value.toSource(0);\n+    }\n+\n+    /**\n+     * Visits this node, and if present, the yielded value.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this) && value != null) {\n+            value.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/debug/DebugFrame.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript.debug;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.Scriptable;\n+\n+/**\n+Interface to implement if the application is interested in receiving debug\n+information during execution of a particular script or function.\n+*/\n+public interface DebugFrame {\n+\n+/**\n+Called when execution is ready to start bytecode interpretation for entered a particular function or script.\n+\n+@param cx current Context for this thread\n+@param activation the activation scope for the function or script.\n+@param thisObj value of the JavaScript <code>this</code> object\n+@param args the array of arguments\n+*/\n+    public void onEnter(Context cx, Scriptable activation,\n+                        Scriptable thisObj, Object[] args);\n+/**\n+Called when executed code reaches new line in the source.\n+@param cx current Context for this thread\n+@param lineNumber current line number in the script source\n+*/\n+    public void onLineChange(Context cx, int lineNumber);\n+\n+/**\n+Called when thrown exception is handled by the function or script.\n+@param cx current Context for this thread\n+@param ex exception object\n+*/\n+    public void onExceptionThrown(Context cx, Throwable ex);\n+\n+/**\n+Called when the function or script for this frame is about to return.\n+@param cx current Context for this thread\n+@param byThrow if true function will leave by throwing exception, otherwise it\n+       will execute normal return\n+@param resultOrException function result in case of normal return or\n+       exception object if about to throw exception\n+*/\n+    public void onExit(Context cx, boolean byThrow, Object resultOrException);\n+\n+/**\n+Called when the function or script executes a 'debugger' statement.\n+@param cx current Context for this thread\n+*/\n+    public void onDebuggerStatement(Context cx);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/debug/DebuggableObject.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript.debug;\n+\n+/**\n+ * This interface exposes debugging information from objects.\n+ */\n+public interface DebuggableObject {\n+\n+    /**\n+     * Returns an array of ids for the properties of the object.\n+     *\n+     * <p>All properties, even those with attribute {DontEnum}, are listed.\n+     * This allows the debugger to display all properties of the object.<p>\n+     *\n+     * @return an array of java.lang.Objects with an entry for every\n+     * listed property. Properties accessed via an integer index will\n+     * have a corresponding\n+     * Integer entry in the returned array. Properties accessed by\n+     * a String will have a String entry in the returned array.\n+     */\n+    public Object[] getAllIds();\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/debug/DebuggableScript.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript.debug;\n+\n+/**\n+ * This interface exposes debugging information from executable\n+ * code (either functions or top-level scripts).\n+ */\n+public interface DebuggableScript\n+{\n+    public boolean isTopLevel();\n+\n+    /**\n+     * Returns true if this is a function, false if it is a script.\n+     */\n+    public boolean isFunction();\n+\n+    /**\n+     * Get name of the function described by this script.\n+     * Return null or an empty string if this script is not a function.\n+     */\n+    public String getFunctionName();\n+\n+    /**\n+     * Get number of declared parameters in the function.\n+     * Return 0 if this script is not a function.\n+     *\n+     * @see #getParamAndVarCount()\n+     * @see #getParamOrVarName(int index)\n+     */\n+    public int getParamCount();\n+\n+    /**\n+     * Get number of declared parameters and local variables.\n+     * Return number of declared global variables if this script is not a\n+     * function.\n+     *\n+     * @see #getParamCount()\n+     * @see #getParamOrVarName(int index)\n+     */\n+    public int getParamAndVarCount();\n+\n+    /**\n+     * Get name of a declared parameter or local variable.\n+     * <tt>index</tt> should be less then {@link #getParamAndVarCount()}.\n+     * If <tt>index&nbsp;&lt;&nbsp;{@link #getParamCount()}</tt>, return\n+     * the name of the corresponding parameter, otherwise return the name\n+     * of variable.\n+     * If this script is not function, return the name of the declared\n+     * global variable.\n+     */\n+    public String getParamOrVarName(int index);\n+\n+    /**\n+     * Get the name of the source (usually filename or URL)\n+     * of the script.\n+     */\n+    public String getSourceName();\n+\n+    /**\n+     * Returns true if this script or function were runtime-generated\n+     * from JavaScript using <tt>eval</tt> function or <tt>Function</tt>\n+     * or <tt>Script</tt> constructors.\n+     */\n+    public boolean isGeneratedScript();\n+\n+    /**\n+     * Get array containing the line numbers that\n+     * that can be passed to <code>DebugFrame.onLineChange()<code>.\n+     * Note that line order in the resulting array is arbitrary\n+     */\n+    public int[] getLineNumbers();\n+\n+    public int getFunctionCount();\n+\n+    public DebuggableScript getFunction(int index);\n+\n+    public DebuggableScript getParent();\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/debug/Debugger.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript.debug;\n+\n+import org.mozilla.javascript.Context;\n+\n+/**\n+Interface to implement if the application is interested in receiving debug\n+information.\n+*/\n+public interface Debugger {\n+\n+/**\n+Called when compilation of a particular function or script into internal\n+bytecode is done.\n+\n+@param cx current Context for this thread\n+@param fnOrScript object describing the function or script\n+@param source the function or script source\n+*/\n+    void handleCompilationDone(Context cx, DebuggableScript fnOrScript,\n+                               String source);\n+\n+/**\n+Called when execution entered a particular function or script.\n+\n+@return implementation of DebugFrame which receives debug information during\n+        the function or script execution or null otherwise\n+*/\n+    DebugFrame getFrame(Context cx, DebuggableScript fnOrScript);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/jdk13/VMBridge_jdk13.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.jdk13;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Proxy;\n+\n+import org.mozilla.javascript.*;\n+\n+public class VMBridge_jdk13 extends VMBridge\n+{\n+    private ThreadLocal<Object[]> contextLocal = new ThreadLocal<Object[]>();\n+\n+    @Override\n+    protected Object getThreadContextHelper()\n+    {\n+        // To make subsequent batch calls to getContext/setContext faster\n+        // associate permanently one element array with contextLocal\n+        // so getContext/setContext would need just to read/write the first\n+        // array element.\n+        // Note that it is necessary to use Object[], not Context[] to allow\n+        // garbage collection of Rhino classes. For details see comments\n+        // by Attila Szegedi in\n+        // https://bugzilla.mozilla.org/show_bug.cgi?id=281067#c5\n+\n+        Object[] storage = contextLocal.get();\n+        if (storage == null) {\n+            storage = new Object[1];\n+            contextLocal.set(storage);\n+        }\n+        return storage;\n+    }\n+\n+    @Override\n+    protected Context getContext(Object contextHelper)\n+    {\n+        Object[] storage = (Object[])contextHelper;\n+        return (Context)storage[0];\n+    }\n+\n+    @Override\n+    protected void setContext(Object contextHelper, Context cx)\n+    {\n+        Object[] storage = (Object[])contextHelper;\n+        storage[0] = cx;\n+    }\n+\n+    @Override\n+    protected ClassLoader getCurrentThreadClassLoader()\n+    {\n+        return Thread.currentThread().getContextClassLoader();\n+    }\n+\n+    @Override\n+    protected boolean tryToMakeAccessible(Object accessibleObject)\n+    {\n+        if (!(accessibleObject instanceof AccessibleObject)) {\n+            return false;\n+        }\n+        AccessibleObject accessible = (AccessibleObject)accessibleObject;\n+        if (accessible.isAccessible()) {\n+            return true;\n+        }\n+        try {\n+            accessible.setAccessible(true);\n+        } catch (Exception ex) { }\n+\n+        return accessible.isAccessible();\n+    }\n+\n+    @Override\n+    protected Object getInterfaceProxyHelper(ContextFactory cf,\n+                                             Class<?>[] interfaces)\n+    {\n+        // XXX: How to handle interfaces array withclasses from different\n+        // class loaders? Using cf.getApplicationClassLoader() ?\n+        ClassLoader loader = interfaces[0].getClassLoader();\n+        Class<?> cl = Proxy.getProxyClass(loader, interfaces);\n+        Constructor<?> c;\n+        try {\n+            c = cl.getConstructor(new Class[] { InvocationHandler.class });\n+        } catch (NoSuchMethodException ex) {\n+            // Should not happen\n+            throw Kit.initCause(new IllegalStateException(), ex);\n+        }\n+        return c;\n+    }\n+\n+    @Override\n+    protected Object newInterfaceProxy(Object proxyHelper,\n+                                       final ContextFactory cf,\n+                                       final InterfaceAdapter adapter,\n+                                       final Object target,\n+                                       final Scriptable topScope)\n+    {\n+        Constructor<?> c = (Constructor<?>)proxyHelper;\n+\n+        InvocationHandler handler = new InvocationHandler() {\n+                public Object invoke(Object proxy,\n+                                     Method method,\n+                                     Object[] args)\n+                {\n+                    return adapter.invoke(cf, target, topScope, method, args);\n+                }\n+            };\n+        Object proxy;\n+        try {\n+            proxy = c.newInstance(new Object[] { handler });\n+        } catch (InvocationTargetException ex) {\n+            throw Context.throwAsScriptRuntimeEx(ex);\n+        } catch (IllegalAccessException ex) {\n+            // Shouls not happen\n+            throw Kit.initCause(new IllegalStateException(), ex);\n+        } catch (InstantiationException ex) {\n+            // Shouls not happen\n+            throw Kit.initCause(new IllegalStateException(), ex);\n+        }\n+        return proxy;\n+    }\n+    \n+    @Override\n+    protected boolean isVarArgs(Member member) {\n+      return false;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/jdk15/VMBridge_jdk15.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.jdk15;\n+\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Constructor;\n+import java.util.Iterator;\n+import org.mozilla.javascript.*;\n+\n+public class VMBridge_jdk15 extends org.mozilla.javascript.jdk13.VMBridge_jdk13\n+{\n+    public VMBridge_jdk15() throws SecurityException, InstantiationException {\n+        try {\n+            // Just try and see if we can access the isVarArgs method.\n+            // We want to fail loading if the method does not exist\n+            // so that we can load a bridge to an older JDK instead.\n+            Method.class.getMethod(\"isVarArgs\", (Class[]) null);\n+        } catch (NoSuchMethodException e) {\n+            // Throw a fitting exception that is handled by\n+            // org.mozilla.javascript.Kit.newInstanceOrNull:\n+            throw new InstantiationException(e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isVarArgs(Member member) {\n+        if (member instanceof Method)\n+            return ((Method) member).isVarArgs();\n+        else if (member instanceof Constructor)\n+            return ((Constructor<?>) member).isVarArgs();\n+        else \n+            return false;\n+    }\n+    \n+    /**\n+     * If \"obj\" is a java.util.Iterator or a java.lang.Iterable, return a\n+     * wrapping as a JavaScript Iterator. Otherwise, return null.\n+     * This method is in VMBridge since Iterable is a JDK 1.5 addition.\n+     */\n+    @Override\n+    public Iterator<?> getJavaIterator(Context cx, Scriptable scope, Object obj) {\n+        if (obj instanceof Wrapper) {\n+            Object unwrapped = ((Wrapper) obj).unwrap();\n+            Iterator<?> iterator = null;\n+            if (unwrapped instanceof Iterator)\n+                iterator = (Iterator<?>) unwrapped;\n+            if (unwrapped instanceof Iterable)\n+                iterator = ((Iterable<?>)unwrapped).iterator();\n+            return iterator;\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/json/JsonLexer.java\n+/* -*- Mode: java; tab-width: 4; indent-tabs-mode: 1; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Raphael Speyer\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.json;\n+\n+import java.math.BigDecimal;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import org.mozilla.javascript.Kit;\n+\n+/**\n+ * This class converts a string into a stream of JSON tokens.\n+ *\n+ * See ECMA 15.12.\n+ */\n+public class JsonLexer {\n+  private Token currentToken;\n+  private int offset;\n+  private int beginLexeme, endLexeme;\n+\n+  private char[] input;\n+  private CharSequence seq;\n+\n+  public static enum Token {\n+    NULL(\"null\"),\n+    BOOLEAN(\"true|false\") {\n+      @SuppressWarnings(\"unchecked\")\n+      @Override\n+      public Boolean evaluate(String lexeme) {\n+        return Boolean.valueOf(lexeme);\n+      }\n+    },\n+    NUMBER(\"-?(0|[1-9]\\\\d*)(\\\\.\\\\d+)?([eE][-+]?\\\\d+)?\") {\n+      @SuppressWarnings(\"unchecked\")\n+      @Override\n+      public Number evaluate(String lexeme) {\n+        return toNumber(lexeme);\n+      }\n+    },\n+    STRING(\"\\\"([^\\\\\\\\\\\"\\\\x00-\\\\x1F]|\\\\\\\\([\\\"/\\\\\\\\bfnrt]|u[a-fA-F0-9]{4}))*\\\"\") {\n+      @SuppressWarnings(\"unchecked\")\n+      @Override\n+      public String evaluate(String lexeme) {\n+        return unescape(lexeme);\n+      }\n+    },\n+    OPEN_BRACKET(\"\\\\[\"),\n+    CLOSE_BRACKET(\"]\"),\n+    OPEN_BRACE(\"\\\\{\"),\n+    CLOSE_BRACE(\"}\"),\n+    COMMA(\",\"),\n+    COLON(\":\");\n+\n+    private Pattern pattern;\n+\n+    private Token(String patternString) {\n+      this.pattern = Pattern.compile(patternString);\n+    }\n+\n+    public final int eat(CharSequence rest) {\n+      Matcher matcher = pattern.matcher(rest);\n+      return matcher.lookingAt() ? matcher.end() : 0;\n+    }\n+\n+    /**\n+     * Override to return the Java value for lexemes of this token\n+     */\n+    public <T> T evaluate(String lexeme) {\n+      throw Kit.codeBug(toString()+\" tokens to not represent a complete JSON value\");\n+    }\n+\n+  }\n+\n+  public static final Token[] VALUE_START_TOKENS = new Token[] { Token.NULL,\n+    Token.BOOLEAN, Token.NUMBER, Token.STRING, Token.OPEN_BRACKET,\n+    Token.OPEN_BRACE\n+  };\n+\n+  public JsonLexer(String input) {\n+    reset(input);\n+  }\n+\n+  public void reset(String input) {\n+    this.seq = input;\n+    this.input = input.toCharArray();\n+    this.beginLexeme = 0;\n+    this.endLexeme = 0;\n+    this.offset = 0;\n+    this.currentToken = null;\n+  }\n+\n+  public boolean moveNext() {\n+    eatWhitespace();\n+\n+    CharSequence rest = seq.subSequence(offset, seq.length());\n+\n+    return\n+      eatToken(Token.OPEN_BRACE, rest) ||\n+      eatToken(Token.CLOSE_BRACE, rest) ||\n+      eatToken(Token.OPEN_BRACKET, rest) ||\n+      eatToken(Token.CLOSE_BRACKET, rest) ||\n+      eatToken(Token.COMMA, rest) ||\n+      eatToken(Token.COLON, rest) ||\n+      eatToken(Token.NULL, rest) ||\n+      eatToken(Token.BOOLEAN, rest) ||\n+      eatToken(Token.NUMBER, rest) ||\n+      eatToken(Token.STRING, rest);\n+  }\n+\n+  public String getLexeme() {\n+    return new String(input, beginLexeme, endLexeme - beginLexeme).trim();\n+  }\n+\n+  public Token getToken() {\n+    return currentToken;\n+  }\n+\n+  public long getOffset() {\n+    return offset;\n+  }\n+\n+  private static Number toNumber(String lexeme) {\n+    try {\n+      return Integer.parseInt(lexeme);\n+    } catch (NumberFormatException exi) {\n+      try {\n+        return Long.parseLong(lexeme);\n+      } catch (NumberFormatException exl) {\n+        BigDecimal decimal = new BigDecimal(lexeme);\n+        double doubleValue = decimal.doubleValue();\n+        if (doubleValue == Double.POSITIVE_INFINITY\n+            || doubleValue == Double.NEGATIVE_INFINITY\n+            || new BigDecimal(doubleValue).compareTo(decimal) != 0) {\n+          return decimal;\n+        } else {\n+          return doubleValue;\n+        }\n+      }\n+    }\n+  }\n+\n+  private static String unescape(String lexeme) {\n+    char[] escaped = lexeme.toCharArray();\n+\n+    int start = 0;\n+    int end = escaped.length - 1;\n+    // Skip leading and trailing whitespace\n+    while (escaped[start] != '\"') {\n+      ++start;\n+    }\n+    while (escaped[end] != '\"') {\n+      --end;\n+    }\n+    // Skip the leading quote\n+    ++start;\n+\n+    StringBuffer buffer = new StringBuffer(end - start);\n+    boolean escaping = false;\n+\n+    for (int i = start; i < end; i += 1) {\n+      char c = escaped[i];\n+\n+      if (escaping) {\n+        switch (c) {\n+        case '\"':\n+          buffer.append('\"');\n+          break;\n+        case '\\\\':\n+          buffer.append('\\\\');\n+          break;\n+        case '/':\n+          buffer.append('/');\n+          break;\n+        case 'b':\n+          buffer.append('\\b');\n+          break;\n+        case 'f':\n+          buffer.append('\\f');\n+          break;\n+        case 'n':\n+          buffer.append('\\n');\n+          break;\n+        case 'r':\n+          buffer.append('\\r');\n+          break;\n+        case 't':\n+          buffer.append('\\t');\n+          break;\n+        case 'u':\n+          // interpret the following 4 characters as the hex of the unicode code point\n+          int codePoint = Integer.parseInt(new String(escaped, i + 1, 4), 16);\n+          buffer.appendCodePoint(codePoint);\n+          i += 4;\n+          break;\n+        default:\n+          throw new IllegalArgumentException(\"Illegal escape sequence: '\\\\\" + c + \"'\");\n+        }\n+        escaping = false;\n+      } else {\n+        if (c == '\\\\') {\n+          escaping = true;\n+        } else {\n+          buffer.append(c);\n+        }\n+      }\n+    }\n+\n+    return buffer.toString();\n+  }\n+\n+  private boolean eatToken(Token token, CharSequence rest) {\n+    beginLexeme();\n+\n+    int eaten = token.eat(rest);\n+\n+    if (eaten == 0) return false;\n+\n+    offset += eaten;\n+    endLexeme(token);\n+    return true;\n+  }\n+\n+  private void eatWhitespace() {\n+    while (!finished()) {\n+      char c = input[offset];\n+      if (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n')\n+        offset += 1;\n+      else\n+          break;\n+    }\n+  }\n+\n+  private void beginLexeme() {\n+    this.beginLexeme = this.offset;\n+    this.endLexeme = this.offset;\n+  }\n+\n+  private void endLexeme(Token token) {\n+    this.endLexeme = offset;\n+    this.currentToken = token;\n+  }\n+\n+  public boolean finished() {\n+    return offset >= input.length;\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/json/JsonParser.java\n+/* -*- Mode: java; tab-width: 4; indent-tabs-mode: 1; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Raphael Speyer\n+ *   Hannes Wallnoefer\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.json;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.Scriptable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class converts a stream of JSON tokens into a JSON value.\n+ *\n+ * See ECMA 15.12.\n+ */\n+public class JsonParser {\n+\n+    private Context cx;\n+    private Scriptable scope;\n+\n+    private int pos;\n+    private int length;\n+    private String src;\n+\n+    public JsonParser(Context cx, Scriptable scope) {\n+        this.cx = cx;\n+        this.scope = scope;\n+    }\n+\n+    public synchronized Object parseValue(String json) throws ParseException {\n+        if (json == null) {\n+            throw new ParseException(\"Input string may not be null\");\n+        }\n+        pos = 0;\n+        length = json.length();\n+        src = json;\n+        Object value = readValue();\n+        if (pos < length) {\n+            throw new ParseException(\"Expected end of stream at char \" + pos);\n+        }\n+        return value;\n+    }\n+\n+    private Object readValue() throws ParseException {\n+        while (pos < length) {\n+            char c = src.charAt(pos++);\n+            switch (c) {\n+                case ' ':\n+                case '\\t':\n+                case '\\r':\n+                case '\\n':\n+                    break;\n+                case '{':\n+                    return readObject();\n+                case '[':\n+                    return readArray();\n+                case 't':\n+                    return readTrue();\n+                case 'f':\n+                    return readFalse();\n+                case '\"':\n+                    return readString();\n+                case 'n':\n+                    return readNull();\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                case '0':\n+                case '-':\n+                    return readNumber(c);\n+                default:\n+                    throw new ParseException(\"Unexpected token: \" + c);\n+            }\n+        }\n+        throw new ParseException(\"Empty JSON string\");\n+    }\n+\n+    private Object readObject() throws ParseException {\n+        Scriptable object = cx.newObject(scope);\n+        String id;\n+        Object value;\n+        boolean needsComma = false;\n+        while (pos < length) {\n+            char c = src.charAt(pos++);\n+            switch(c) {\n+                case ' ':\n+                case '\\t':\n+                case '\\r':\n+                case '\\n':\n+                    break;\n+                case '}':\n+                    return object;\n+                case ',':\n+                    if (!needsComma) {\n+                        throw new ParseException(\"Unexpected comma in object literal\");\n+                    }\n+                    needsComma = false;\n+                    break;\n+                case '\"':\n+                    if (needsComma) {\n+                        throw new ParseException(\"Missing comma in object literal\");\n+                    }\n+                    id = readString();\n+                    consume(':');\n+                    value = readValue();\n+                    object.put(id, object, value);\n+                    needsComma = true;\n+                    break;\n+                default:\n+                    throw new ParseException(\"Unexpected token in object literal\");\n+            }\n+        }\n+        throw new ParseException(\"Unterminated object literal\");\n+    }\n+\n+    private Object readArray() throws ParseException {\n+        List<Object> list = new ArrayList<Object>();\n+        boolean needsComma = false;\n+        while (pos < length) {\n+            char c = src.charAt(pos);\n+            switch(c) {\n+                case ' ':\n+                case '\\t':\n+                case '\\r':\n+                case '\\n':\n+                    pos += 1;\n+                    break;\n+                case ']':\n+                    pos += 1;\n+                    return cx.newArray(scope, list.toArray());\n+                case ',':\n+                    if (!needsComma) {\n+                        throw new ParseException(\"Unexpected comma in array literal\");\n+                    }\n+                    needsComma = false;\n+                    pos += 1;\n+                    break;\n+                default:\n+                    if (needsComma) {\n+                        throw new ParseException(\"Missing comma in array literal\");\n+                    }\n+                    list.add(readValue());\n+                    needsComma = true;\n+            }\n+        }\n+        throw new ParseException(\"Unterminated array literal\");\n+    }\n+\n+    private String readString() throws ParseException {\n+        StringBuilder b = new StringBuilder();\n+        while (pos < length) {\n+            char c = src.charAt(pos++);\n+            if (c <= '\\u001F') {\n+                throw new ParseException(\"String contains control character\");\n+            }\n+            switch(c) {\n+                case '\\\\':\n+                    if (pos >= length) {\n+                        throw new ParseException(\"Unterminated string\");\n+                    }\n+                    c = src.charAt(pos++);\n+                    switch (c) {\n+                        case '\"':\n+                            b.append('\"');\n+                            break;\n+                        case '\\\\':\n+                            b.append('\\\\');\n+                            break;\n+                        case '/':\n+                            b.append('/');\n+                            break;\n+                        case 'b':\n+                            b.append('\\b');\n+                            break;\n+                        case 'f':\n+                            b.append('\\f');\n+                            break;\n+                        case 'n':\n+                            b.append('\\n');\n+                            break;\n+                        case 'r':\n+                            b.append('\\r');\n+                            break;\n+                        case 't':\n+                            b.append('\\t');\n+                            break;\n+                        case 'u':\n+                            if (length - pos < 5) {\n+                                throw new ParseException(\"Invalid character code: \\\\u\" + src.substring(pos));\n+                            }\n+                            try {\n+                                b.append((char) Integer.parseInt(src.substring(pos, pos + 4), 16));\n+                                pos += 4;\n+                            } catch (NumberFormatException nfx) {\n+                                throw new ParseException(\"Invalid character code: \" + src.substring(pos, pos + 4));\n+                            }\n+                            break;\n+                        default:\n+                            throw new ParseException(\"Unexcpected character in string: '\\\\\" + c + \"'\");\n+                    }\n+                    break;\n+                case '\"':\n+                    return b.toString();\n+                default:\n+                    b.append(c);\n+                    break;\n+            }\n+        }\n+        throw new ParseException(\"Unterminated string literal\");\n+    }\n+\n+    private Number readNumber(char first) throws ParseException {\n+        StringBuilder b = new StringBuilder();\n+        b.append(first);\n+        while (pos < length) {\n+            char c = src.charAt(pos);\n+            if (!Character.isDigit(c)\n+                    && c != '-'\n+                    && c != '+'\n+                    && c != '.'\n+                    && c != 'e'\n+                    && c != 'E') {\n+                break;\n+            }\n+            pos += 1;\n+            b.append(c);\n+        }\n+        String num = b.toString();\n+        int numLength = num.length();\n+        try {\n+            // check for leading zeroes\n+            for (int i = 0; i < numLength; i++) {\n+                char c = num.charAt(i);\n+                if (Character.isDigit(c)) {\n+                    if (c == '0'\n+                            && numLength > i + 1\n+                            && Character.isDigit(num.charAt(i + 1))) {\n+                        throw new ParseException(\"Unsupported number format: \" + num);\n+                    }\n+                    break;\n+                }\n+            }\n+            double d = Double.valueOf(num);\n+            if ((int)d == d) {\n+                return new Integer((int) d);\n+            } else {\n+                return new Double(d);\n+            }\n+        } catch (NumberFormatException nfe) {\n+            throw new ParseException(\"Unsupported number format: \" + num);\n+        }\n+    }\n+\n+    private Boolean readTrue() throws ParseException {\n+        if (length - pos < 3\n+                || src.charAt(pos) != 'r'\n+                || src.charAt(pos + 1) != 'u'\n+                || src.charAt(pos + 2) != 'e') {\n+            throw new ParseException(\"Unexpected token: t\");\n+        }\n+        pos += 3;\n+        return Boolean.TRUE;\n+    }\n+\n+    private Boolean readFalse() throws ParseException {\n+        if (length - pos < 4\n+                || src.charAt(pos) != 'a'\n+                || src.charAt(pos + 1) != 'l'\n+                || src.charAt(pos + 2) != 's'\n+                || src.charAt(pos + 3) != 'e') {\n+            throw new ParseException(\"Unexpected token: f\");\n+        }\n+        pos += 4;\n+        return Boolean.FALSE;\n+    }\n+\n+    private Object readNull() throws ParseException {\n+        if (length - pos < 3\n+                || src.charAt(pos) != 'u'\n+                || src.charAt(pos + 1) != 'l'\n+                || src.charAt(pos + 2) != 'l') {\n+            throw new ParseException(\"Unexpected token: n\");\n+        }\n+        pos += 3;\n+        return null;\n+    }\n+\n+    private void consume(char token) throws ParseException {\n+        while (pos < length) {\n+            char c = src.charAt(pos++);\n+            switch(c) {\n+                case ' ':\n+                case '\\t':\n+                case '\\r':\n+                case '\\n':\n+                    break;\n+                default:\n+                    if (c == token) {\n+                        return;\n+                    } else {\n+                        throw new ParseException(\"Expected \" + token + \" found \" + c);\n+                    }\n+            }\n+        }\n+    }\n+\n+    public static class ParseException extends Exception {\n+        ParseException(String message) {\n+            super(message);\n+        }\n+\n+        ParseException(Exception cause) {\n+            super(cause);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Block.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Roger Lawrence\n+ *   Cameron McCormack\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.optimizer;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.ast.Jump;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+\n+class Block\n+{\n+\n+    private static class FatBlock\n+    {\n+\n+        private static Block[] reduceToArray(ObjToIntMap map)\n+        {\n+            Block[] result = null;\n+            if (!map.isEmpty()) {\n+                result = new Block[map.size()];\n+                int i = 0;\n+                ObjToIntMap.Iterator iter = map.newIterator();\n+                for (iter.start(); !iter.done(); iter.next()) {\n+                    FatBlock fb = (FatBlock)(iter.getKey());\n+                    result[i++] = fb.realBlock;\n+                }\n+            }\n+            return result;\n+        }\n+\n+        void addSuccessor(FatBlock b)  { successors.put(b, 0); }\n+        void addPredecessor(FatBlock b)  { predecessors.put(b, 0); }\n+\n+        Block[] getSuccessors() { return reduceToArray(successors); }\n+        Block[] getPredecessors() { return reduceToArray(predecessors); }\n+\n+            // all the Blocks that come immediately after this\n+        private ObjToIntMap successors = new ObjToIntMap();\n+            // all the Blocks that come immediately before this\n+        private ObjToIntMap predecessors = new ObjToIntMap();\n+\n+        Block realBlock;\n+    }\n+\n+    Block(int startNodeIndex, int endNodeIndex)\n+    {\n+        itsStartNodeIndex = startNodeIndex;\n+        itsEndNodeIndex = endNodeIndex;\n+    }\n+\n+    static void runFlowAnalyzes(OptFunctionNode fn, Node[] statementNodes)\n+    {\n+        int paramCount = fn.fnode.getParamCount();\n+        int varCount = fn.fnode.getParamAndVarCount();\n+        int[] varTypes = new int[varCount];\n+        // If the variable is a parameter, it could have any type.\n+        for (int i = 0; i != paramCount; ++i) {\n+            varTypes[i] = Optimizer.AnyType;\n+        }\n+        // If the variable is from a \"var\" statement, its typeEvent will be set\n+        // when we see the setVar node.\n+        for (int i = paramCount; i != varCount; ++i) {\n+            varTypes[i] = Optimizer.NoType;\n+        }\n+\n+        Block[] theBlocks = buildBlocks(statementNodes);\n+\n+        if (DEBUG) {\n+            ++debug_blockCount;\n+            System.out.println(\"-------------------\"+fn.fnode.getFunctionName()+\"  \"+debug_blockCount+\"--------\");\n+            System.out.println(toString(theBlocks, statementNodes));\n+        }\n+\n+        reachingDefDataFlow(fn, statementNodes, theBlocks, varTypes);\n+        typeFlow(fn, statementNodes, theBlocks, varTypes);\n+\n+        if (DEBUG) {\n+            for (int i = 0; i < theBlocks.length; i++) {\n+                System.out.println(\"For block \" + theBlocks[i].itsBlockID);\n+                theBlocks[i].printLiveOnEntrySet(fn);\n+            }\n+            System.out.println(\"Variable Table, size = \" + varCount);\n+            for (int i = 0; i != varCount; i++) {\n+                System.out.println(\"[\"+i+\"] type: \"+varTypes[i]);\n+            }\n+        }\n+\n+        for (int i = paramCount; i != varCount; i++) {\n+            if (varTypes[i] == Optimizer.NumberType) {\n+                fn.setIsNumberVar(i);\n+            }\n+        }\n+\n+    }\n+\n+    private static Block[] buildBlocks(Node[] statementNodes)\n+    {\n+            // a mapping from each target node to the block it begins\n+        Map<Node,FatBlock> theTargetBlocks = new HashMap<Node,FatBlock>();\n+        ObjArray theBlocks = new ObjArray();\n+\n+            // there's a block that starts at index 0\n+        int beginNodeIndex = 0;\n+\n+        for (int i = 0; i < statementNodes.length; i++) {\n+            switch (statementNodes[i].getType()) {\n+                case Token.TARGET :\n+                    {\n+                        if (i != beginNodeIndex) {\n+                            FatBlock fb = newFatBlock(beginNodeIndex, i - 1);\n+                            if (statementNodes[beginNodeIndex].getType()\n+                                                        == Token.TARGET)\n+                                theTargetBlocks.put(statementNodes[beginNodeIndex], fb);\n+                            theBlocks.add(fb);\n+                             // start the next block at this node\n+                            beginNodeIndex = i;\n+                        }\n+                    }\n+                    break;\n+                case Token.IFNE :\n+                case Token.IFEQ :\n+                case Token.GOTO :\n+                    {\n+                        FatBlock fb = newFatBlock(beginNodeIndex, i);\n+                        if (statementNodes[beginNodeIndex].getType()\n+                                                       == Token.TARGET)\n+                            theTargetBlocks.put(statementNodes[beginNodeIndex], fb);\n+                        theBlocks.add(fb);\n+                            // start the next block at the next node\n+                        beginNodeIndex = i + 1;\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        if (beginNodeIndex != statementNodes.length) {\n+            FatBlock fb = newFatBlock(beginNodeIndex, statementNodes.length - 1);\n+            if (statementNodes[beginNodeIndex].getType() == Token.TARGET)\n+                theTargetBlocks.put(statementNodes[beginNodeIndex], fb);\n+            theBlocks.add(fb);\n+        }\n+\n+        // build successor and predecessor links\n+\n+        for (int i = 0; i < theBlocks.size(); i++) {\n+            FatBlock fb = (FatBlock)(theBlocks.get(i));\n+\n+            Node blockEndNode = statementNodes[fb.realBlock.itsEndNodeIndex];\n+            int blockEndNodeType = blockEndNode.getType();\n+\n+            if ((blockEndNodeType != Token.GOTO)\n+                                         && (i < (theBlocks.size() - 1))) {\n+                FatBlock fallThruTarget = (FatBlock)(theBlocks.get(i + 1));\n+                fb.addSuccessor(fallThruTarget);\n+                fallThruTarget.addPredecessor(fb);\n+            }\n+\n+\n+            if ( (blockEndNodeType == Token.IFNE)\n+                        || (blockEndNodeType == Token.IFEQ)\n+                                || (blockEndNodeType == Token.GOTO) ) {\n+                Node target = ((Jump)blockEndNode).target;\n+                FatBlock branchTargetBlock = theTargetBlocks.get(target);\n+                target.putProp(Node.TARGETBLOCK_PROP,\n+                                           branchTargetBlock.realBlock);\n+                fb.addSuccessor(branchTargetBlock);\n+                branchTargetBlock.addPredecessor(fb);\n+            }\n+        }\n+\n+        Block[] result = new Block[theBlocks.size()];\n+\n+        for (int i = 0; i < theBlocks.size(); i++) {\n+            FatBlock fb = (FatBlock)(theBlocks.get(i));\n+            Block b = fb.realBlock;\n+            b.itsSuccessors = fb.getSuccessors();\n+            b.itsPredecessors = fb.getPredecessors();\n+            b.itsBlockID = i;\n+            result[i] = b;\n+        }\n+\n+        return result;\n+    }\n+\n+    private static FatBlock newFatBlock(int startNodeIndex, int endNodeIndex)\n+    {\n+        FatBlock fb = new FatBlock();\n+        fb.realBlock = new Block(startNodeIndex, endNodeIndex);\n+        return fb;\n+    }\n+\n+    private static String toString(Block[] blockList, Node[] statementNodes)\n+    {\n+        if (!DEBUG) return null;\n+\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw);\n+\n+        pw.println(blockList.length + \" Blocks\");\n+        for (int i = 0; i < blockList.length; i++) {\n+            Block b = blockList[i];\n+            pw.println(\"#\" + b.itsBlockID);\n+            pw.println(\"from \" + b.itsStartNodeIndex\n+                            + \" \"\n+                            + statementNodes[b.itsStartNodeIndex].toString());\n+            pw.println(\"thru \" + b.itsEndNodeIndex\n+                            + \" \"\n+                            + statementNodes[b.itsEndNodeIndex].toString());\n+            pw.print(\"Predecessors \");\n+            if (b.itsPredecessors != null) {\n+                for (int j = 0; j < b.itsPredecessors.length; j++)\n+                    pw.print(b.itsPredecessors[j].itsBlockID + \" \");\n+                pw.println();\n+            }\n+            else\n+                pw.println(\"none\");\n+            pw.print(\"Successors \");\n+            if (b.itsSuccessors != null) {\n+                for (int j = 0; j < b.itsSuccessors.length; j++)\n+                    pw.print(b.itsSuccessors[j].itsBlockID + \" \");\n+                pw.println();\n+            }\n+            else\n+                pw.println(\"none\");\n+        }\n+        return sw.toString();\n+    }\n+\n+    private static void reachingDefDataFlow(OptFunctionNode fn, Node[] statementNodes, Block theBlocks[], int[] varTypes)\n+    {\n+/*\n+    initialize the liveOnEntry and liveOnExit sets, then discover the variables\n+    that are def'd by each function, and those that are used before being def'd\n+    (hence liveOnEntry)\n+*/\n+        for (int i = 0; i < theBlocks.length; i++) {\n+            theBlocks[i].initLiveOnEntrySets(fn, statementNodes);\n+        }\n+/*\n+    this visits every block starting at the last, re-adding the predecessors of\n+    any block whose inputs change as a result of the dataflow.\n+    REMIND, better would be to visit in CFG postorder\n+*/\n+        boolean visit[] = new boolean[theBlocks.length];\n+        boolean doneOnce[] = new boolean[theBlocks.length];\n+        int vIndex = theBlocks.length - 1;\n+        boolean needRescan = false;\n+        visit[vIndex] = true;\n+        while (true) {\n+            if (visit[vIndex] || !doneOnce[vIndex]) {\n+                doneOnce[vIndex] = true;\n+                visit[vIndex] = false;\n+                if (theBlocks[vIndex].doReachedUseDataFlow()) {\n+                    Block pred[] = theBlocks[vIndex].itsPredecessors;\n+                    if (pred != null) {\n+                        for (int i = 0; i < pred.length; i++) {\n+                            int index = pred[i].itsBlockID;\n+                            visit[index] = true;\n+                            needRescan |= (index > vIndex);\n+                        }\n+                    }\n+                }\n+            }\n+            if (vIndex == 0) {\n+                if (needRescan) {\n+                    vIndex = theBlocks.length - 1;\n+                    needRescan = false;\n+                }\n+                else\n+                    break;\n+            }\n+            else\n+                vIndex--;\n+        }\n+/*\n+        if any variable is live on entry to block 0, we have to mark it as\n+        not jRegable - since it means that someone is trying to access the\n+        'undefined'-ness of that variable.\n+*/\n+\n+        theBlocks[0].markAnyTypeVariables(varTypes);\n+    }\n+\n+    private static void typeFlow(OptFunctionNode fn, Node[] statementNodes, Block theBlocks[], int[] varTypes)\n+    {\n+        boolean visit[] = new boolean[theBlocks.length];\n+        boolean doneOnce[] = new boolean[theBlocks.length];\n+        int vIndex = 0;\n+        boolean needRescan = false;\n+        visit[vIndex] = true;\n+        while (true) {\n+            if (visit[vIndex] || !doneOnce[vIndex]) {\n+                doneOnce[vIndex] = true;\n+                visit[vIndex] = false;\n+                if (theBlocks[vIndex].doTypeFlow(fn, statementNodes, varTypes))\n+                {\n+                    Block succ[] = theBlocks[vIndex].itsSuccessors;\n+                    if (succ != null) {\n+                        for (int i = 0; i < succ.length; i++) {\n+                            int index = succ[i].itsBlockID;\n+                            visit[index] = true;\n+                            needRescan |= (index < vIndex);\n+                        }\n+                    }\n+                }\n+            }\n+            if (vIndex == (theBlocks.length - 1)) {\n+                if (needRescan) {\n+                    vIndex = 0;\n+                    needRescan = false;\n+                }\n+                else\n+                    break;\n+            }\n+            else\n+                vIndex++;\n+        }\n+    }\n+\n+    private static boolean assignType(int[] varTypes, int index, int type)\n+    {\n+        return type != (varTypes[index] |= type);\n+    }\n+\n+    private void markAnyTypeVariables(int[] varTypes)\n+    {\n+        for (int i = 0; i != varTypes.length; i++) {\n+            if (itsLiveOnEntrySet.test(i)) {\n+                assignType(varTypes, i, Optimizer.AnyType);\n+            }\n+        }\n+\n+    }\n+\n+    /*\n+        We're tracking uses and defs - in order to\n+        build the def set and to identify the last use\n+        nodes.\n+\n+        The itsNotDefSet is built reversed then flipped later.\n+\n+    */\n+    private void lookForVariableAccess(OptFunctionNode fn, Node n)\n+    {\n+        switch (n.getType()) {\n+            case Token.DEC :\n+            case Token.INC :\n+                {\n+                    Node child = n.getFirstChild();\n+                    if (child.getType() == Token.GETVAR) {\n+                        int varIndex = fn.getVarIndex(child);\n+                        if (!itsNotDefSet.test(varIndex))\n+                            itsUseBeforeDefSet.set(varIndex);\n+                        itsNotDefSet.set(varIndex);\n+                    }\n+                }\n+                break;\n+            case Token.SETVAR :\n+                {\n+                    Node lhs = n.getFirstChild();\n+                    Node rhs = lhs.getNext();\n+                    lookForVariableAccess(fn, rhs);\n+                    itsNotDefSet.set(fn.getVarIndex(n));\n+                }\n+                break;\n+            case Token.GETVAR :\n+                {\n+                    int varIndex = fn.getVarIndex(n);\n+                    if (!itsNotDefSet.test(varIndex))\n+                        itsUseBeforeDefSet.set(varIndex);\n+                }\n+                break;\n+            default :\n+                Node child = n.getFirstChild();\n+                while (child != null) {\n+                    lookForVariableAccess(fn, child);\n+                    child = child.getNext();\n+                }\n+                break;\n+        }\n+    }\n+\n+    /*\n+        build the live on entry/exit sets.\n+        Then walk the trees looking for defs/uses of variables\n+        and build the def and useBeforeDef sets.\n+    */\n+    private void initLiveOnEntrySets(OptFunctionNode fn, Node[] statementNodes)\n+    {\n+        int listLength = fn.getVarCount();\n+        itsUseBeforeDefSet = new DataFlowBitSet(listLength);\n+        itsNotDefSet = new DataFlowBitSet(listLength);\n+        itsLiveOnEntrySet = new DataFlowBitSet(listLength);\n+        itsLiveOnExitSet = new DataFlowBitSet(listLength);\n+        for (int i = itsStartNodeIndex; i <= itsEndNodeIndex; i++) {\n+            Node n = statementNodes[i];\n+            lookForVariableAccess(fn, n);\n+        }\n+        itsNotDefSet.not();         // truth in advertising\n+    }\n+\n+    /*\n+        the liveOnEntry of each successor is the liveOnExit for this block.\n+        The liveOnEntry for this block is -\n+        liveOnEntry = liveOnExit - defsInThisBlock + useBeforeDefsInThisBlock\n+\n+    */\n+    private boolean doReachedUseDataFlow()\n+    {\n+        itsLiveOnExitSet.clear();\n+        if (itsSuccessors != null)\n+            for (int i = 0; i < itsSuccessors.length; i++)\n+                itsLiveOnExitSet.or(itsSuccessors[i].itsLiveOnEntrySet);\n+        return itsLiveOnEntrySet.df2(itsLiveOnExitSet,\n+                                            itsUseBeforeDefSet, itsNotDefSet);\n+    }\n+\n+    /*\n+        the type of an expression is relatively unknown. Cases we can be sure\n+        about are -\n+            Literals,\n+            Arithmetic operations - always return a Number\n+    */\n+    private static int findExpressionType(OptFunctionNode fn, Node n,\n+                                          int[] varTypes)\n+    {\n+        switch (n.getType()) {\n+          case Token.NUMBER:\n+              return Optimizer.NumberType;\n+\n+          case Token.CALL:\n+          case Token.NEW:\n+          case Token.REF_CALL:\n+              return Optimizer.AnyType;\n+\n+          case Token.GETELEM:\n+             return Optimizer.AnyType;\n+\n+          case Token.GETVAR:\n+              return varTypes[fn.getVarIndex(n)];\n+\n+          case Token.INC:\n+          case Token.DEC:\n+          case Token.MUL:\n+          case Token.DIV:\n+          case Token.MOD:\n+          case Token.BITOR:\n+          case Token.BITXOR:\n+          case Token.BITAND:\n+          case Token.LSH:\n+          case Token.RSH:\n+          case Token.URSH:\n+          case Token.SUB:\n+          case Token.POS:\n+          case Token.NEG:\n+              return Optimizer.NumberType;\n+          \n+          case Token.ARRAYLIT:\n+          case Token.OBJECTLIT:\n+              return Optimizer.AnyType; // XXX: actually, we know it's not\n+                                        // number, but no type yet for that\n+\n+          case Token.ADD: {\n+              // if the lhs & rhs are known to be numbers, we can be sure that's\n+              // the result, otherwise it could be a string.\n+              Node child = n.getFirstChild();\n+              int lType = findExpressionType(fn, child, varTypes);\n+              int rType = findExpressionType(fn, child.getNext(), varTypes);\n+              return lType | rType;    // we're not distinguishing strings yet\n+          }\n+        }\n+\n+        Node child = n.getFirstChild();\n+        if (child == null) {\n+            return Optimizer.AnyType;\n+        } else {\n+            int result = Optimizer.NoType;\n+            while (child != null) {\n+                result |= findExpressionType(fn, child, varTypes);\n+                child = child.getNext();\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static boolean findDefPoints(OptFunctionNode fn, Node n,\n+                                         int[] varTypes)\n+    {\n+        boolean result = false;\n+        Node child = n.getFirstChild();\n+        switch (n.getType()) {\n+          default :\n+            while (child != null) {\n+                result |= findDefPoints(fn, child, varTypes);\n+                child = child.getNext();\n+            }\n+            break;\n+          case Token.DEC :\n+          case Token.INC :\n+            if (child.getType() == Token.GETVAR) {\n+                // theVar is a Number now\n+                int i = fn.getVarIndex(child);\n+                result |= assignType(varTypes, i, Optimizer.NumberType);\n+            }\n+            break;\n+          case Token.SETPROP :\n+          case Token.SETPROP_OP :\n+            if (child.getType() == Token.GETVAR) {\n+                int i = fn.getVarIndex(child);\n+                assignType(varTypes, i, Optimizer.AnyType);\n+            }\n+            while (child != null) {\n+                result |= findDefPoints(fn, child, varTypes);\n+                child = child.getNext();\n+            }\n+            break;\n+          case Token.SETVAR : {\n+            Node rValue = child.getNext();\n+            int theType = findExpressionType(fn, rValue, varTypes);\n+            int i = fn.getVarIndex(n);\n+            result |= assignType(varTypes, i, theType);\n+            break;\n+          }\n+        }\n+        return result;\n+    }\n+\n+    private boolean doTypeFlow(OptFunctionNode fn, Node[] statementNodes,\n+                               int[] varTypes)\n+    {\n+        boolean changed = false;\n+\n+        for (int i = itsStartNodeIndex; i <= itsEndNodeIndex; i++) {\n+            Node n = statementNodes[i];\n+            if (n != null)\n+                changed |= findDefPoints(fn, n, varTypes);\n+        }\n+\n+        return changed;\n+    }\n+\n+    private void printLiveOnEntrySet(OptFunctionNode fn)\n+    {\n+        if (DEBUG) {\n+            for (int i = 0; i < fn.getVarCount(); i++) {\n+                String name = fn.fnode.getParamOrVarName(i);\n+                if (itsUseBeforeDefSet.test(i))\n+                    System.out.println(name + \" is used before def'd\");\n+                if (itsNotDefSet.test(i))\n+                    System.out.println(name + \" is not def'd\");\n+                if (itsLiveOnEntrySet.test(i))\n+                    System.out.println(name + \" is live on entry\");\n+                if (itsLiveOnExitSet.test(i))\n+                    System.out.println(name + \" is live on exit\");\n+            }\n+        }\n+    }\n+\n+        // all the Blocks that come immediately after this\n+    private Block[] itsSuccessors;\n+        // all the Blocks that come immediately before this\n+    private Block[] itsPredecessors;\n+\n+    private int itsStartNodeIndex;       // the Node at the start of the block\n+    private int itsEndNodeIndex;         // the Node at the end of the block\n+\n+    private int itsBlockID;               // a unique index for each block\n+\n+// reaching def bit sets -\n+    private DataFlowBitSet itsLiveOnEntrySet;\n+    private DataFlowBitSet itsLiveOnExitSet;\n+    private DataFlowBitSet itsUseBeforeDefSet;\n+    private DataFlowBitSet itsNotDefSet;\n+\n+    static final boolean DEBUG = false;\n+    private static int debug_blockCount;\n+\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/optimizer/ClassCompiler.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.optimizer;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.ast.AstRoot;\n+import org.mozilla.javascript.ast.FunctionNode;\n+import org.mozilla.javascript.ast.ScriptNode;\n+\n+/**\n+ * Generates class files from script sources.\n+ *\n+ * since 1.5 Release 5\n+ */\n+\n+public class ClassCompiler\n+{\n+    /**\n+     * Construct ClassCompiler that uses the specified compiler environment\n+     * when generating classes.\n+     */\n+    public ClassCompiler(CompilerEnvirons compilerEnv)\n+    {\n+        if (compilerEnv == null) throw new IllegalArgumentException();\n+        this.compilerEnv = compilerEnv;\n+        this.mainMethodClassName = Codegen.DEFAULT_MAIN_METHOD_CLASS;\n+    }\n+\n+    /**\n+     * Set the class name to use for main method implementation.\n+     * The class must have a method matching\n+     * <tt>public static void main(Script sc, String[] args)</tt>, it will be\n+     * called when <tt>main(String[] args)</tt> is called in the generated\n+     * class. The class name should be fully qulified name and include the\n+     * package name like in <tt>org.foo.Bar<tt>.\n+     */\n+    public void setMainMethodClass(String className)\n+    {\n+        // XXX Should this check for a valid class name?\n+        mainMethodClassName = className;\n+    }\n+\n+    /**\n+     * Get the name of the class for main method implementation.\n+     * @see #setMainMethodClass(String)\n+     */\n+    public String getMainMethodClass()\n+    {\n+        return mainMethodClassName;\n+    }\n+\n+    /**\n+     * Get the compiler environment the compiler uses.\n+     */\n+    public CompilerEnvirons getCompilerEnv()\n+    {\n+        return compilerEnv;\n+    }\n+\n+    /**\n+     * Get the class that the generated target will extend.\n+     */\n+    public Class<?> getTargetExtends()\n+    {\n+        return targetExtends;\n+    }\n+\n+    /**\n+     * Set the class that the generated target will extend.\n+     *\n+     * @param extendsClass the class it extends\n+     */\n+    public void setTargetExtends(Class<?> extendsClass)\n+    {\n+        targetExtends = extendsClass;\n+    }\n+\n+    /**\n+     * Get the interfaces that the generated target will implement.\n+     */\n+    public Class<?>[] getTargetImplements()\n+    {\n+        return targetImplements == null ? null : (Class[])targetImplements.clone();\n+    }\n+\n+    /**\n+     * Set the interfaces that the generated target will implement.\n+     *\n+     * @param implementsClasses an array of Class objects, one for each\n+     *                          interface the target will extend\n+     */\n+    public void setTargetImplements(Class<?>[] implementsClasses)\n+    {\n+        targetImplements = implementsClasses == null ? null : (Class[])implementsClasses.clone();\n+    }\n+\n+    /**\n+     * Build class name for a auxiliary class generated by compiler.\n+     * If the compiler needs to generate extra classes beyond the main class,\n+     * it will call this function to build the auxiliary class name.\n+     * The default implementation simply appends auxMarker to mainClassName\n+     * but this can be overridden.\n+     */\n+    protected String makeAuxiliaryClassName(String mainClassName,\n+                                            String auxMarker)\n+    {\n+        return mainClassName+auxMarker;\n+    }\n+\n+    /**\n+     * Compile JavaScript source into one or more Java class files.\n+     * The first compiled class will have name mainClassName.\n+     * If the results of {@link #getTargetExtends()} or\n+     * {@link #getTargetImplements()} are not null, then the first compiled\n+     * class will extend the specified super class and implement\n+     * specified interfaces.\n+     *\n+     * @return array where elements with even indexes specifies class name\n+     *         and the following odd index gives class file body as byte[]\n+     *         array. The initial element of the array always holds\n+     *         mainClassName and array[1] holds its byte code.\n+     */\n+    public Object[] compileToClassFiles(String source,\n+                                        String sourceLocation,\n+                                        int lineno,\n+                                        String mainClassName)\n+    {\n+        Parser p = new Parser(compilerEnv);\n+        AstRoot ast = p.parse(source, sourceLocation, lineno);\n+        IRFactory irf = new IRFactory(compilerEnv);\n+        ScriptNode tree = irf.transformTree(ast);\n+\n+        // release reference to original parse tree & parser\n+        irf = null;\n+        ast = null;\n+        p = null;\n+\n+        Class<?> superClass = getTargetExtends();\n+        Class<?>[] interfaces = getTargetImplements();\n+        String scriptClassName;\n+        boolean isPrimary = (interfaces == null && superClass == null);\n+        if (isPrimary) {\n+            scriptClassName = mainClassName;\n+        } else {\n+            scriptClassName = makeAuxiliaryClassName(mainClassName, \"1\");\n+        }\n+\n+        Codegen codegen = new Codegen();\n+        codegen.setMainMethodClass(mainMethodClassName);\n+        byte[] scriptClassBytes\n+            = codegen.compileToClassFile(compilerEnv, scriptClassName,\n+                                         tree, tree.getEncodedSource(),\n+                                         false);\n+\n+        if (isPrimary) {\n+            return new Object[] { scriptClassName, scriptClassBytes };\n+        }\n+        int functionCount = tree.getFunctionCount();\n+        ObjToIntMap functionNames = new ObjToIntMap(functionCount);\n+        for (int i = 0; i != functionCount; ++i) {\n+            FunctionNode ofn = tree.getFunctionNode(i);\n+            String name = ofn.getName();\n+            if (name != null && name.length() != 0) {\n+                functionNames.put(name, ofn.getParamCount());\n+            }\n+        }\n+        if (superClass == null) {\n+            superClass = ScriptRuntime.ObjectClass;\n+        }\n+        byte[] mainClassBytes\n+            = JavaAdapter.createAdapterCode(\n+                functionNames, mainClassName,\n+                superClass, interfaces, scriptClassName);\n+\n+        return new Object[] { mainClassName, mainClassBytes,\n+                              scriptClassName, scriptClassBytes };\n+    }\n+\n+    private String mainMethodClassName;\n+    private CompilerEnvirons compilerEnv;\n+    private Class<?> targetExtends;\n+    private Class<?>[] targetImplements;\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Codegen.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Kemal Bayram\n+ *   Igor Bukanov\n+ *   Bob Jervis\n+ *   Roger Lawrence\n+ *   Andi Vajda\n+ *   Hannes Wallnoefer\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+\n+package org.mozilla.javascript.optimizer;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.ast.FunctionNode;\n+import org.mozilla.javascript.ast.Jump;\n+import org.mozilla.javascript.ast.Name;\n+import org.mozilla.javascript.ast.ScriptNode;\n+import org.mozilla.classfile.*;\n+import java.util.*;\n+import java.lang.reflect.Constructor;\n+\n+/**\n+ * This class generates code for a given IR tree.\n+ *\n+ */\n+\n+public class Codegen implements Evaluator\n+{\n+    public void captureStackInfo(RhinoException ex) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public String getSourcePositionFromStack(Context cx, int[] linep) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public String getPatchedStack(RhinoException ex, String nativeStackTrace) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public List<String> getScriptStack(RhinoException ex) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void setEvalScriptFlag(Script script) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public Object compile(CompilerEnvirons compilerEnv,\n+                          ScriptNode tree,\n+                          String encodedSource,\n+                          boolean returnFunction)\n+    {\n+        int serial;\n+        synchronized (globalLock) {\n+            serial = ++globalSerialClassCounter;\n+        }\n+\n+        String baseName = \"c\";\n+        if (tree.getSourceName().length() > 0) {\n+          baseName = tree.getSourceName().replaceAll(\"\\\\W\", \"_\");\n+          if (!Character.isJavaIdentifierStart(baseName.charAt(0))) {\n+            baseName = \"_\" + baseName;\n+          }\n+        }\n+\n+        String mainClassName = \"org.mozilla.javascript.gen.\" + baseName + \"_\" + serial;\n+\n+        byte[] mainClassBytes = compileToClassFile(compilerEnv, mainClassName,\n+                                                   tree, encodedSource,\n+                                                   returnFunction);\n+\n+        return new Object[] { mainClassName, mainClassBytes };\n+    }\n+\n+    public Script createScriptObject(Object bytecode,\n+                                     Object staticSecurityDomain)\n+    {\n+        Class<?> cl = defineClass(bytecode, staticSecurityDomain);\n+\n+        Script script;\n+        try {\n+            script = (Script)cl.newInstance();\n+        } catch (Exception ex) {\n+            throw new RuntimeException\n+                (\"Unable to instantiate compiled class:\"+ex.toString());\n+        }\n+        return script;\n+    }\n+\n+    public Function createFunctionObject(Context cx, Scriptable scope,\n+                                         Object bytecode,\n+                                         Object staticSecurityDomain)\n+    {\n+        Class<?> cl = defineClass(bytecode, staticSecurityDomain);\n+\n+        NativeFunction f;\n+        try {\n+            Constructor<?>ctor = cl.getConstructors()[0];\n+            Object[] initArgs = { scope, cx, Integer.valueOf(0) };\n+            f = (NativeFunction)ctor.newInstance(initArgs);\n+        } catch (Exception ex) {\n+            throw new RuntimeException\n+                (\"Unable to instantiate compiled class:\"+ex.toString());\n+        }\n+        return f;\n+    }\n+\n+    private Class<?> defineClass(Object bytecode,\n+                                 Object staticSecurityDomain)\n+    {\n+        Object[] nameBytesPair = (Object[])bytecode;\n+        String className = (String)nameBytesPair[0];\n+        byte[] classBytes = (byte[])nameBytesPair[1];\n+\n+        // The generated classes in this case refer only to Rhino classes\n+        // which must be accessible through this class loader\n+        ClassLoader rhinoLoader = getClass().getClassLoader();\n+        GeneratedClassLoader loader;\n+        loader = SecurityController.createLoader(rhinoLoader,\n+                                                 staticSecurityDomain);\n+        Exception e;\n+        try {\n+            Class<?> cl = loader.defineClass(className, classBytes);\n+            loader.linkClass(cl);\n+            return cl;\n+        } catch (SecurityException x) {\n+            e = x;\n+        } catch (IllegalArgumentException x) {\n+            e = x;\n+        }\n+        throw new RuntimeException(\"Malformed optimizer package \" + e);\n+    }\n+\n+    byte[] compileToClassFile(CompilerEnvirons compilerEnv,\n+                              String mainClassName,\n+                              ScriptNode scriptOrFn,\n+                              String encodedSource,\n+                              boolean returnFunction)\n+    {\n+        this.compilerEnv = compilerEnv;\n+\n+        transform(scriptOrFn);\n+\n+        if (Token.printTrees) {\n+            System.out.println(scriptOrFn.toStringTree(scriptOrFn));\n+        }\n+\n+        if (returnFunction) {\n+            scriptOrFn = scriptOrFn.getFunctionNode(0);\n+        }\n+\n+        initScriptNodesData(scriptOrFn);\n+\n+        this.mainClassName = mainClassName;\n+        this.mainClassSignature\n+            = ClassFileWriter.classNameToSignature(mainClassName);\n+\n+        try {\n+            return generateCode(encodedSource);\n+        } catch (ClassFileWriter.ClassFileFormatException e) {\n+            throw reportClassFileFormatException(scriptOrFn, e.getMessage());\n+        }\n+    }\n+\n+    private RuntimeException reportClassFileFormatException(\n+        ScriptNode scriptOrFn,\n+        String message)\n+    {\n+        String msg = scriptOrFn instanceof FunctionNode\n+        ? ScriptRuntime.getMessage2(\"msg.while.compiling.fn\",\n+            ((FunctionNode)scriptOrFn).getFunctionName(), message)\n+        : ScriptRuntime.getMessage1(\"msg.while.compiling.script\", message);\n+        return Context.reportRuntimeError(msg, scriptOrFn.getSourceName(),\n+            scriptOrFn.getLineno(), null, 0);\n+    }\n+\n+    private void transform(ScriptNode tree)\n+    {\n+        initOptFunctions_r(tree);\n+\n+        int optLevel = compilerEnv.getOptimizationLevel();\n+\n+        Map<String,OptFunctionNode> possibleDirectCalls = null;\n+        if (optLevel > 0) {\n+           /*\n+            * Collect all of the contained functions into a hashtable\n+            * so that the call optimizer can access the class name & parameter\n+            * count for any call it encounters\n+            */\n+            if (tree.getType() == Token.SCRIPT) {\n+                int functionCount = tree.getFunctionCount();\n+                for (int i = 0; i != functionCount; ++i) {\n+                    OptFunctionNode ofn = OptFunctionNode.get(tree, i);\n+                    if (ofn.fnode.getFunctionType()\n+                        == FunctionNode.FUNCTION_STATEMENT)\n+                    {\n+                        String name = ofn.fnode.getName();\n+                        if (name.length() != 0) {\n+                            if (possibleDirectCalls == null) {\n+                                possibleDirectCalls = new HashMap<String,OptFunctionNode>();\n+                            }\n+                            possibleDirectCalls.put(name, ofn);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (possibleDirectCalls != null) {\n+            directCallTargets = new ObjArray();\n+        }\n+\n+        OptTransformer ot = new OptTransformer(possibleDirectCalls,\n+                                               directCallTargets);\n+        ot.transform(tree);\n+\n+        if (optLevel > 0) {\n+            (new Optimizer()).optimize(tree);\n+        }\n+    }\n+\n+    private static void initOptFunctions_r(ScriptNode scriptOrFn)\n+    {\n+        for (int i = 0, N = scriptOrFn.getFunctionCount(); i != N; ++i) {\n+            FunctionNode fn = scriptOrFn.getFunctionNode(i);\n+            new OptFunctionNode(fn);\n+            initOptFunctions_r(fn);\n+        }\n+    }\n+\n+    private void initScriptNodesData(ScriptNode scriptOrFn)\n+    {\n+        ObjArray x = new ObjArray();\n+        collectScriptNodes_r(scriptOrFn, x);\n+\n+        int count = x.size();\n+        scriptOrFnNodes = new ScriptNode[count];\n+        x.toArray(scriptOrFnNodes);\n+\n+        scriptOrFnIndexes = new ObjToIntMap(count);\n+        for (int i = 0; i != count; ++i) {\n+            scriptOrFnIndexes.put(scriptOrFnNodes[i], i);\n+        }\n+    }\n+\n+    private static void collectScriptNodes_r(ScriptNode n,\n+                                                 ObjArray x)\n+    {\n+        x.add(n);\n+        int nestedCount = n.getFunctionCount();\n+        for (int i = 0; i != nestedCount; ++i) {\n+            collectScriptNodes_r(n.getFunctionNode(i), x);\n+        }\n+    }\n+\n+    private byte[] generateCode(String encodedSource)\n+    {\n+        boolean hasScript = (scriptOrFnNodes[0].getType() == Token.SCRIPT);\n+        boolean hasFunctions = (scriptOrFnNodes.length > 1 || !hasScript);\n+\n+        String sourceFile = null;\n+        if (compilerEnv.isGenerateDebugInfo()) {\n+            sourceFile = scriptOrFnNodes[0].getSourceName();\n+        }\n+\n+        ClassFileWriter cfw = new ClassFileWriter(mainClassName,\n+                                                  SUPER_CLASS_NAME,\n+                                                  sourceFile);\n+        cfw.addField(ID_FIELD_NAME, \"I\",\n+                     ClassFileWriter.ACC_PRIVATE);\n+        cfw.addField(DIRECT_CALL_PARENT_FIELD, mainClassSignature,\n+                     ClassFileWriter.ACC_PRIVATE);\n+        cfw.addField(REGEXP_ARRAY_FIELD_NAME, REGEXP_ARRAY_FIELD_TYPE,\n+                     ClassFileWriter.ACC_PRIVATE);\n+\n+        if (hasFunctions) {\n+            generateFunctionConstructor(cfw);\n+        }\n+\n+        if (hasScript) {\n+            cfw.addInterface(\"org/mozilla/javascript/Script\");\n+            generateScriptCtor(cfw);\n+            generateMain(cfw);\n+            generateExecute(cfw);\n+        }\n+\n+        generateCallMethod(cfw);\n+        generateResumeGenerator(cfw);\n+\n+        generateNativeFunctionOverrides(cfw, encodedSource);\n+\n+        int count = scriptOrFnNodes.length;\n+        for (int i = 0; i != count; ++i) {\n+            ScriptNode n = scriptOrFnNodes[i];\n+\n+            BodyCodegen bodygen = new BodyCodegen();\n+            bodygen.cfw = cfw;\n+            bodygen.codegen = this;\n+            bodygen.compilerEnv = compilerEnv;\n+            bodygen.scriptOrFn = n;\n+            bodygen.scriptOrFnIndex = i;\n+\n+            try {\n+                bodygen.generateBodyCode();\n+            } catch (ClassFileWriter.ClassFileFormatException e) {\n+                throw reportClassFileFormatException(n, e.getMessage());\n+            }\n+\n+            if (n.getType() == Token.FUNCTION) {\n+                OptFunctionNode ofn = OptFunctionNode.get(n);\n+                generateFunctionInit(cfw, ofn);\n+                if (ofn.isTargetOfDirectCall()) {\n+                    emitDirectConstructor(cfw, ofn);\n+                }\n+            }\n+        }\n+\n+        if (directCallTargets != null) {\n+            int N = directCallTargets.size();\n+            for (int j = 0; j != N; ++j) {\n+                cfw.addField(getDirectTargetFieldName(j),\n+                             mainClassSignature,\n+                             ClassFileWriter.ACC_PRIVATE);\n+            }\n+        }\n+\n+        emitRegExpInit(cfw);\n+        emitConstantDudeInitializers(cfw);\n+\n+        return cfw.toByteArray();\n+    }\n+\n+    private void emitDirectConstructor(ClassFileWriter cfw,\n+                                       OptFunctionNode ofn)\n+    {\n+/*\n+    we generate ..\n+        Scriptable directConstruct(<directCallArgs>) {\n+            Scriptable newInstance = createObject(cx, scope);\n+            Object val = <body-name>(cx, scope, newInstance, <directCallArgs>);\n+            if (val instanceof Scriptable) {\n+                return (Scriptable) val;\n+            }\n+            return newInstance;\n+        }\n+*/\n+        cfw.startMethod(getDirectCtorName(ofn.fnode),\n+                        getBodyMethodSignature(ofn.fnode),\n+                        (short)(ClassFileWriter.ACC_STATIC\n+                                | ClassFileWriter.ACC_PRIVATE));\n+\n+        int argCount = ofn.fnode.getParamCount();\n+        int firstLocal = (4 + argCount * 3) + 1;\n+\n+        cfw.addALoad(0); // this\n+        cfw.addALoad(1); // cx\n+        cfw.addALoad(2); // scope\n+        cfw.addInvoke(ByteCode.INVOKEVIRTUAL,\n+                      \"org/mozilla/javascript/BaseFunction\",\n+                      \"createObject\",\n+                      \"(Lorg/mozilla/javascript/Context;\"\n+                      +\"Lorg/mozilla/javascript/Scriptable;\"\n+                      +\")Lorg/mozilla/javascript/Scriptable;\");\n+        cfw.addAStore(firstLocal);\n+\n+        cfw.addALoad(0);\n+        cfw.addALoad(1);\n+        cfw.addALoad(2);\n+        cfw.addALoad(firstLocal);\n+        for (int i = 0; i < argCount; i++) {\n+            cfw.addALoad(4 + (i * 3));\n+            cfw.addDLoad(5 + (i * 3));\n+        }\n+        cfw.addALoad(4 + argCount * 3);\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      mainClassName,\n+                      getBodyMethodName(ofn.fnode),\n+                      getBodyMethodSignature(ofn.fnode));\n+        int exitLabel = cfw.acquireLabel();\n+        cfw.add(ByteCode.DUP); // make a copy of direct call result\n+        cfw.add(ByteCode.INSTANCEOF, \"org/mozilla/javascript/Scriptable\");\n+        cfw.add(ByteCode.IFEQ, exitLabel);\n+        // cast direct call result\n+        cfw.add(ByteCode.CHECKCAST, \"org/mozilla/javascript/Scriptable\");\n+        cfw.add(ByteCode.ARETURN);\n+        cfw.markLabel(exitLabel);\n+\n+        cfw.addALoad(firstLocal);\n+        cfw.add(ByteCode.ARETURN);\n+\n+        cfw.stopMethod((short)(firstLocal + 1));\n+    }\n+\n+    static boolean isGenerator(ScriptNode node)\n+    {\n+        return (node.getType() == Token.FUNCTION ) &&\n+                ((FunctionNode)node).isGenerator();\n+    }\n+\n+    // How dispatch to generators works:\n+    // Two methods are generated corresponding to a user-written generator.\n+    // One of these creates a generator object (NativeGenerator), which is\n+    // returned to the user. The other method contains all of the body code\n+    // of the generator.\n+    // When a user calls a generator, the call() method dispatches control to\n+    // to the method that creates the NativeGenerator object. Subsequently when\n+    // the user invokes .next(), .send() or any such method on the generator\n+    // object, the resumeGenerator() below dispatches the call to the\n+    // method corresponding to the generator body. As a matter of convention\n+    // the generator body is given the name of the generator activation function\n+    // appended by \"_gen\".\n+    private void generateResumeGenerator(ClassFileWriter cfw)\n+    {\n+        boolean hasGenerators = false;\n+        for (int i=0; i < scriptOrFnNodes.length; i++) {\n+            if (isGenerator(scriptOrFnNodes[i]))\n+            \thasGenerators = true;\n+        }\n+\n+        // if there are no generators defined, we don't implement a\n+        // resumeGenerator(). The base class provides a default implementation.\n+        if (!hasGenerators)\n+            return;\n+\n+        cfw.startMethod(\"resumeGenerator\",\n+                        \"(Lorg/mozilla/javascript/Context;\" +\n+                        \"Lorg/mozilla/javascript/Scriptable;\" +\n+                        \"ILjava/lang/Object;\" +\n+                        \"Ljava/lang/Object;)Ljava/lang/Object;\",\n+                        (short)(ClassFileWriter.ACC_PUBLIC\n+                                | ClassFileWriter.ACC_FINAL));\n+\n+        // load arguments for dispatch to the corresponding *_gen method\n+        cfw.addALoad(0);\n+        cfw.addALoad(1);\n+        cfw.addALoad(2);\n+        cfw.addALoad(4);\n+        cfw.addALoad(5);\n+        cfw.addILoad(3);\n+\n+        cfw.addLoadThis();\n+        cfw.add(ByteCode.GETFIELD, cfw.getClassName(), ID_FIELD_NAME, \"I\");\n+\n+        int startSwitch = cfw.addTableSwitch(0, scriptOrFnNodes.length - 1);\n+        cfw.markTableSwitchDefault(startSwitch);\n+        int endlabel = cfw.acquireLabel();\n+\n+        for (int i = 0; i < scriptOrFnNodes.length; i++) {\n+            ScriptNode n = scriptOrFnNodes[i];\n+            cfw.markTableSwitchCase(startSwitch, i, (short)6);\n+            if (isGenerator(n)) {\n+                String type = \"(\" +\n+                              mainClassSignature +\n+                              \"Lorg/mozilla/javascript/Context;\" +\n+                              \"Lorg/mozilla/javascript/Scriptable;\" +\n+                              \"Ljava/lang/Object;\" +\n+                              \"Ljava/lang/Object;I)Ljava/lang/Object;\";\n+                cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                              mainClassName,\n+                              getBodyMethodName(n) + \"_gen\",\n+                              type);\n+                cfw.add(ByteCode.ARETURN);\n+            } else {\n+                cfw.add(ByteCode.GOTO, endlabel);\n+            }\n+        }\n+\n+        cfw.markLabel(endlabel);\n+        pushUndefined(cfw);\n+        cfw.add(ByteCode.ARETURN);\n+\n+\n+        // this method uses as many locals as there are arguments (hence 6)\n+        cfw.stopMethod((short)6);\n+    }\n+\n+    private void generateCallMethod(ClassFileWriter cfw)\n+    {\n+        cfw.startMethod(\"call\",\n+                        \"(Lorg/mozilla/javascript/Context;\" +\n+                        \"Lorg/mozilla/javascript/Scriptable;\" +\n+                        \"Lorg/mozilla/javascript/Scriptable;\" +\n+                        \"[Ljava/lang/Object;)Ljava/lang/Object;\",\n+                        (short)(ClassFileWriter.ACC_PUBLIC\n+                                | ClassFileWriter.ACC_FINAL));\n+\n+        // Generate code for:\n+        // if (!ScriptRuntime.hasTopCall(cx)) {\n+        //     return ScriptRuntime.doTopCall(this, cx, scope, thisObj, args);\n+        // }\n+\n+        int nonTopCallLabel = cfw.acquireLabel();\n+        cfw.addALoad(1); //cx\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      \"org/mozilla/javascript/ScriptRuntime\",\n+                      \"hasTopCall\",\n+                      \"(Lorg/mozilla/javascript/Context;\"\n+                      +\")Z\");\n+        cfw.add(ByteCode.IFNE, nonTopCallLabel);\n+        cfw.addALoad(0);\n+        cfw.addALoad(1);\n+        cfw.addALoad(2);\n+        cfw.addALoad(3);\n+        cfw.addALoad(4);\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      \"org/mozilla/javascript/ScriptRuntime\",\n+                      \"doTopCall\",\n+                      \"(Lorg/mozilla/javascript/Callable;\"\n+                      +\"Lorg/mozilla/javascript/Context;\"\n+                      +\"Lorg/mozilla/javascript/Scriptable;\"\n+                      +\"Lorg/mozilla/javascript/Scriptable;\"\n+                      +\"[Ljava/lang/Object;\"\n+                      +\")Ljava/lang/Object;\");\n+        cfw.add(ByteCode.ARETURN);\n+        cfw.markLabel(nonTopCallLabel);\n+\n+        // Now generate switch to call the real methods\n+        cfw.addALoad(0);\n+        cfw.addALoad(1);\n+        cfw.addALoad(2);\n+        cfw.addALoad(3);\n+        cfw.addALoad(4);\n+\n+        int end = scriptOrFnNodes.length;\n+        boolean generateSwitch = (2 <= end);\n+\n+        int switchStart = 0;\n+        int switchStackTop = 0;\n+        if (generateSwitch) {\n+            cfw.addLoadThis();\n+            cfw.add(ByteCode.GETFIELD, cfw.getClassName(), ID_FIELD_NAME, \"I\");\n+            // do switch from (1,  end - 1) mapping 0 to\n+            // the default case\n+            switchStart = cfw.addTableSwitch(1, end - 1);\n+        }\n+\n+        for (int i = 0; i != end; ++i) {\n+            ScriptNode n = scriptOrFnNodes[i];\n+            if (generateSwitch) {\n+                if (i == 0) {\n+                    cfw.markTableSwitchDefault(switchStart);\n+                    switchStackTop = cfw.getStackTop();\n+                } else {\n+                    cfw.markTableSwitchCase(switchStart, i - 1,\n+                                            switchStackTop);\n+                }\n+            }\n+            if (n.getType() == Token.FUNCTION) {\n+                OptFunctionNode ofn = OptFunctionNode.get(n);\n+                if (ofn.isTargetOfDirectCall()) {\n+                    int pcount = ofn.fnode.getParamCount();\n+                    if (pcount != 0) {\n+                        // loop invariant:\n+                        // stack top == arguments array from addALoad4()\n+                        for (int p = 0; p != pcount; ++p) {\n+                            cfw.add(ByteCode.ARRAYLENGTH);\n+                            cfw.addPush(p);\n+                            int undefArg = cfw.acquireLabel();\n+                            int beyond = cfw.acquireLabel();\n+                            cfw.add(ByteCode.IF_ICMPLE, undefArg);\n+                            // get array[p]\n+                            cfw.addALoad(4);\n+                            cfw.addPush(p);\n+                            cfw.add(ByteCode.AALOAD);\n+                            cfw.add(ByteCode.GOTO, beyond);\n+                            cfw.markLabel(undefArg);\n+                            pushUndefined(cfw);\n+                            cfw.markLabel(beyond);\n+                            // Only one push\n+                            cfw.adjustStackTop(-1);\n+                            cfw.addPush(0.0);\n+                            // restore invariant\n+                            cfw.addALoad(4);\n+                        }\n+                    }\n+                }\n+            }\n+            cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                          mainClassName,\n+                          getBodyMethodName(n),\n+                          getBodyMethodSignature(n));\n+            cfw.add(ByteCode.ARETURN);\n+        }\n+        cfw.stopMethod((short)5);\n+        // 5: this, cx, scope, js this, args[]\n+    }\n+\n+    private void generateMain(ClassFileWriter cfw)\n+    {\n+        cfw.startMethod(\"main\", \"([Ljava/lang/String;)V\",\n+                        (short)(ClassFileWriter.ACC_PUBLIC\n+                                | ClassFileWriter.ACC_STATIC));\n+\n+        // load new ScriptImpl()\n+        cfw.add(ByteCode.NEW, cfw.getClassName());\n+        cfw.add(ByteCode.DUP);\n+        cfw.addInvoke(ByteCode.INVOKESPECIAL, cfw.getClassName(),\n+                      \"<init>\", \"()V\");\n+         // load 'args'\n+        cfw.add(ByteCode.ALOAD_0);\n+        // Call mainMethodClass.main(Script script, String[] args)\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      mainMethodClass,\n+                      \"main\",\n+                      \"(Lorg/mozilla/javascript/Script;[Ljava/lang/String;)V\");\n+        cfw.add(ByteCode.RETURN);\n+        // 1 = String[] args\n+        cfw.stopMethod((short)1);\n+    }\n+\n+    private void generateExecute(ClassFileWriter cfw)\n+    {\n+        cfw.startMethod(\"exec\",\n+                        \"(Lorg/mozilla/javascript/Context;\"\n+                        +\"Lorg/mozilla/javascript/Scriptable;\"\n+                        +\")Ljava/lang/Object;\",\n+                        (short)(ClassFileWriter.ACC_PUBLIC\n+                                | ClassFileWriter.ACC_FINAL));\n+\n+        final int CONTEXT_ARG = 1;\n+        final int SCOPE_ARG = 2;\n+\n+        cfw.addLoadThis();\n+        cfw.addALoad(CONTEXT_ARG);\n+        cfw.addALoad(SCOPE_ARG);\n+        cfw.add(ByteCode.DUP);\n+        cfw.add(ByteCode.ACONST_NULL);\n+        cfw.addInvoke(ByteCode.INVOKEVIRTUAL,\n+                      cfw.getClassName(),\n+                      \"call\",\n+                      \"(Lorg/mozilla/javascript/Context;\"\n+                      +\"Lorg/mozilla/javascript/Scriptable;\"\n+                      +\"Lorg/mozilla/javascript/Scriptable;\"\n+                      +\"[Ljava/lang/Object;\"\n+                      +\")Ljava/lang/Object;\");\n+\n+        cfw.add(ByteCode.ARETURN);\n+        // 3 = this + context + scope\n+        cfw.stopMethod((short)3);\n+    }\n+\n+    private void generateScriptCtor(ClassFileWriter cfw)\n+    {\n+        cfw.startMethod(\"<init>\", \"()V\", ClassFileWriter.ACC_PUBLIC);\n+\n+        cfw.addLoadThis();\n+        cfw.addInvoke(ByteCode.INVOKESPECIAL, SUPER_CLASS_NAME,\n+                      \"<init>\", \"()V\");\n+        // set id to 0\n+        cfw.addLoadThis();\n+        cfw.addPush(0);\n+        cfw.add(ByteCode.PUTFIELD, cfw.getClassName(), ID_FIELD_NAME, \"I\");\n+\n+        cfw.add(ByteCode.RETURN);\n+        // 1 parameter = this\n+        cfw.stopMethod((short)1);\n+    }\n+\n+    private void generateFunctionConstructor(ClassFileWriter cfw)\n+    {\n+        final int SCOPE_ARG = 1;\n+        final int CONTEXT_ARG = 2;\n+        final int ID_ARG = 3;\n+\n+        cfw.startMethod(\"<init>\", FUNCTION_CONSTRUCTOR_SIGNATURE,\n+                        ClassFileWriter.ACC_PUBLIC);\n+        cfw.addALoad(0);\n+        cfw.addInvoke(ByteCode.INVOKESPECIAL, SUPER_CLASS_NAME,\n+                      \"<init>\", \"()V\");\n+\n+        cfw.addLoadThis();\n+        cfw.addILoad(ID_ARG);\n+        cfw.add(ByteCode.PUTFIELD, cfw.getClassName(), ID_FIELD_NAME, \"I\");\n+\n+        cfw.addLoadThis();\n+        cfw.addALoad(CONTEXT_ARG);\n+        cfw.addALoad(SCOPE_ARG);\n+\n+        int start = (scriptOrFnNodes[0].getType() == Token.SCRIPT) ? 1 : 0;\n+        int end = scriptOrFnNodes.length;\n+        if (start == end) throw badTree();\n+        boolean generateSwitch = (2 <= end - start);\n+\n+        int switchStart = 0;\n+        int switchStackTop = 0;\n+        if (generateSwitch) {\n+            cfw.addILoad(ID_ARG);\n+            // do switch from (start + 1,  end - 1) mapping start to\n+            // the default case\n+            switchStart = cfw.addTableSwitch(start + 1, end - 1);\n+        }\n+\n+        for (int i = start; i != end; ++i) {\n+            if (generateSwitch) {\n+                if (i == start) {\n+                    cfw.markTableSwitchDefault(switchStart);\n+                    switchStackTop = cfw.getStackTop();\n+                } else {\n+                    cfw.markTableSwitchCase(switchStart, i - 1 - start,\n+                                            switchStackTop);\n+                }\n+            }\n+            OptFunctionNode ofn = OptFunctionNode.get(scriptOrFnNodes[i]);\n+            cfw.addInvoke(ByteCode.INVOKEVIRTUAL,\n+                          mainClassName,\n+                          getFunctionInitMethodName(ofn),\n+                          FUNCTION_INIT_SIGNATURE);\n+            cfw.add(ByteCode.RETURN);\n+        }\n+\n+        // 4 = this + scope + context + id\n+        cfw.stopMethod((short)4);\n+    }\n+\n+    private void generateFunctionInit(ClassFileWriter cfw,\n+                                      OptFunctionNode ofn)\n+    {\n+        final int CONTEXT_ARG = 1;\n+        final int SCOPE_ARG = 2;\n+        cfw.startMethod(getFunctionInitMethodName(ofn),\n+                        FUNCTION_INIT_SIGNATURE,\n+                        (short)(ClassFileWriter.ACC_PRIVATE\n+                                | ClassFileWriter.ACC_FINAL));\n+\n+        // Call NativeFunction.initScriptFunction\n+        cfw.addLoadThis();\n+        cfw.addALoad(CONTEXT_ARG);\n+        cfw.addALoad(SCOPE_ARG);\n+        cfw.addInvoke(ByteCode.INVOKEVIRTUAL,\n+                      \"org/mozilla/javascript/NativeFunction\",\n+                      \"initScriptFunction\",\n+                      \"(Lorg/mozilla/javascript/Context;\"\n+                      +\"Lorg/mozilla/javascript/Scriptable;\"\n+                      +\")V\");\n+\n+        // precompile all regexp literals\n+        int regexpCount = ofn.fnode.getRegexpCount();\n+        if (regexpCount != 0) {\n+            cfw.addLoadThis();\n+            pushRegExpArray(cfw, ofn.fnode, CONTEXT_ARG, SCOPE_ARG);\n+            cfw.add(ByteCode.PUTFIELD, mainClassName,\n+                    REGEXP_ARRAY_FIELD_NAME, REGEXP_ARRAY_FIELD_TYPE);\n+        }\n+\n+        cfw.add(ByteCode.RETURN);\n+        // 3 = (scriptThis/functionRef) + scope + context\n+        cfw.stopMethod((short)3);\n+    }\n+\n+    private void generateNativeFunctionOverrides(ClassFileWriter cfw,\n+                                                 String encodedSource)\n+    {\n+        // Override NativeFunction.getLanguageVersion() with\n+        // public int getLanguageVersion() { return <version-constant>; }\n+\n+        cfw.startMethod(\"getLanguageVersion\", \"()I\",\n+                        ClassFileWriter.ACC_PUBLIC);\n+\n+        cfw.addPush(compilerEnv.getLanguageVersion());\n+        cfw.add(ByteCode.IRETURN);\n+\n+        // 1: this and no argument or locals\n+        cfw.stopMethod((short)1);\n+\n+        // The rest of NativeFunction overrides require specific code for each\n+        // script/function id\n+\n+        final int Do_getFunctionName      = 0;\n+        final int Do_getParamCount        = 1;\n+        final int Do_getParamAndVarCount  = 2;\n+        final int Do_getParamOrVarName    = 3;\n+        final int Do_getEncodedSource     = 4;\n+        final int Do_getParamOrVarConst   = 5;\n+        final int SWITCH_COUNT            = 6;\n+\n+        for (int methodIndex = 0; methodIndex != SWITCH_COUNT; ++methodIndex) {\n+            if (methodIndex == Do_getEncodedSource && encodedSource == null) {\n+                continue;\n+            }\n+\n+            // Generate:\n+            //   prologue;\n+            //   switch over function id to implement function-specific action\n+            //   epilogue\n+\n+            short methodLocals;\n+            switch (methodIndex) {\n+              case Do_getFunctionName:\n+                methodLocals = 1; // Only this\n+                cfw.startMethod(\"getFunctionName\", \"()Ljava/lang/String;\",\n+                                ClassFileWriter.ACC_PUBLIC);\n+                break;\n+              case Do_getParamCount:\n+                methodLocals = 1; // Only this\n+                cfw.startMethod(\"getParamCount\", \"()I\",\n+                                ClassFileWriter.ACC_PUBLIC);\n+                break;\n+              case Do_getParamAndVarCount:\n+                methodLocals = 1; // Only this\n+                cfw.startMethod(\"getParamAndVarCount\", \"()I\",\n+                                ClassFileWriter.ACC_PUBLIC);\n+                break;\n+              case Do_getParamOrVarName:\n+                methodLocals = 1 + 1; // this + paramOrVarIndex\n+                cfw.startMethod(\"getParamOrVarName\", \"(I)Ljava/lang/String;\",\n+                                ClassFileWriter.ACC_PUBLIC);\n+                break;\n+              case Do_getParamOrVarConst:\n+                methodLocals = 1 + 1 + 1; // this + paramOrVarName\n+                cfw.startMethod(\"getParamOrVarConst\", \"(I)Z\",\n+                                ClassFileWriter.ACC_PUBLIC);\n+                break;\n+              case Do_getEncodedSource:\n+                methodLocals = 1; // Only this\n+                cfw.startMethod(\"getEncodedSource\", \"()Ljava/lang/String;\",\n+                                ClassFileWriter.ACC_PUBLIC);\n+                cfw.addPush(encodedSource);\n+                break;\n+              default:\n+                throw Kit.codeBug();\n+            }\n+\n+            int count = scriptOrFnNodes.length;\n+\n+            int switchStart = 0;\n+            int switchStackTop = 0;\n+            if (count > 1) {\n+                // Generate switch but only if there is more then one\n+                // script/function\n+                cfw.addLoadThis();\n+                cfw.add(ByteCode.GETFIELD, cfw.getClassName(),\n+                        ID_FIELD_NAME, \"I\");\n+\n+                // do switch from 1 .. count - 1 mapping 0 to the default case\n+                switchStart = cfw.addTableSwitch(1, count - 1);\n+            }\n+\n+            for (int i = 0; i != count; ++i) {\n+                ScriptNode n = scriptOrFnNodes[i];\n+                if (i == 0) {\n+                    if (count > 1) {\n+                        cfw.markTableSwitchDefault(switchStart);\n+                        switchStackTop = cfw.getStackTop();\n+                    }\n+                } else {\n+                    cfw.markTableSwitchCase(switchStart, i - 1,\n+                                            switchStackTop);\n+                }\n+\n+                // Impelemnet method-specific switch code\n+                switch (methodIndex) {\n+                  case Do_getFunctionName:\n+                    // Push function name\n+                    if (n.getType() == Token.SCRIPT) {\n+                        cfw.addPush(\"\");\n+                    } else {\n+                        String name = ((FunctionNode)n).getName();\n+                        cfw.addPush(name);\n+                    }\n+                    cfw.add(ByteCode.ARETURN);\n+                    break;\n+\n+                  case Do_getParamCount:\n+                    // Push number of defined parameters\n+                    cfw.addPush(n.getParamCount());\n+                    cfw.add(ByteCode.IRETURN);\n+                    break;\n+\n+                  case Do_getParamAndVarCount:\n+                    // Push number of defined parameters and declared variables\n+                    cfw.addPush(n.getParamAndVarCount());\n+                    cfw.add(ByteCode.IRETURN);\n+                    break;\n+\n+                  case Do_getParamOrVarName:\n+                    // Push name of parameter using another switch\n+                    // over paramAndVarCount\n+                    int paramAndVarCount = n.getParamAndVarCount();\n+                    if (paramAndVarCount == 0) {\n+                        // The runtime should never call the method in this\n+                        // case but to make bytecode verifier happy return null\n+                        // as throwing execption takes more code\n+                        cfw.add(ByteCode.ACONST_NULL);\n+                        cfw.add(ByteCode.ARETURN);\n+                    } else if (paramAndVarCount == 1) {\n+                        // As above do not check for valid index but always\n+                        // return the name of the first param\n+                        cfw.addPush(n.getParamOrVarName(0));\n+                        cfw.add(ByteCode.ARETURN);\n+                    } else {\n+                        // Do switch over getParamOrVarName\n+                        cfw.addILoad(1); // param or var index\n+                        // do switch from 1 .. paramAndVarCount - 1 mapping 0\n+                        // to the default case\n+                        int paramSwitchStart = cfw.addTableSwitch(\n+                                                   1, paramAndVarCount - 1);\n+                        for (int j = 0; j != paramAndVarCount; ++j) {\n+                            if (cfw.getStackTop() != 0) Kit.codeBug();\n+                            String s = n.getParamOrVarName(j);\n+                            if (j == 0) {\n+                                cfw.markTableSwitchDefault(paramSwitchStart);\n+                            } else {\n+                                cfw.markTableSwitchCase(paramSwitchStart, j - 1,\n+                                                        0);\n+                            }\n+                            cfw.addPush(s);\n+                            cfw.add(ByteCode.ARETURN);\n+                        }\n+                    }\n+                    break;\n+\n+                    case Do_getParamOrVarConst:\n+                        // Push name of parameter using another switch\n+                        // over paramAndVarCount\n+                        paramAndVarCount = n.getParamAndVarCount();\n+                        boolean [] constness = n.getParamAndVarConst();\n+                        if (paramAndVarCount == 0) {\n+                            // The runtime should never call the method in this\n+                            // case but to make bytecode verifier happy return null\n+                            // as throwing execption takes more code\n+                            cfw.add(ByteCode.ICONST_0);\n+                            cfw.add(ByteCode.IRETURN);\n+                        } else if (paramAndVarCount == 1) {\n+                            // As above do not check for valid index but always\n+                            // return the name of the first param\n+                            cfw.addPush(constness[0]);\n+                            cfw.add(ByteCode.IRETURN);\n+                        } else {\n+                            // Do switch over getParamOrVarName\n+                            cfw.addILoad(1); // param or var index\n+                            // do switch from 1 .. paramAndVarCount - 1 mapping 0\n+                            // to the default case\n+                            int paramSwitchStart = cfw.addTableSwitch(\n+                                                       1, paramAndVarCount - 1);\n+                            for (int j = 0; j != paramAndVarCount; ++j) {\n+                                if (cfw.getStackTop() != 0) Kit.codeBug();\n+                                if (j == 0) {\n+                                    cfw.markTableSwitchDefault(paramSwitchStart);\n+                                } else {\n+                                    cfw.markTableSwitchCase(paramSwitchStart, j - 1,\n+                                                            0);\n+                                }\n+                                cfw.addPush(constness[j]);\n+                                cfw.add(ByteCode.IRETURN);\n+                            }\n+                        }\n+                      break;\n+\n+                  case Do_getEncodedSource:\n+                    // Push number encoded source start and end\n+                    // to prepare for encodedSource.substring(start, end)\n+                    cfw.addPush(n.getEncodedSourceStart());\n+                    cfw.addPush(n.getEncodedSourceEnd());\n+                    cfw.addInvoke(ByteCode.INVOKEVIRTUAL,\n+                                  \"java/lang/String\",\n+                                  \"substring\",\n+                                  \"(II)Ljava/lang/String;\");\n+                    cfw.add(ByteCode.ARETURN);\n+                    break;\n+\n+                  default:\n+                    throw Kit.codeBug();\n+                }\n+            }\n+\n+            cfw.stopMethod(methodLocals);\n+        }\n+    }\n+\n+    private void emitRegExpInit(ClassFileWriter cfw)\n+    {\n+        // precompile all regexp literals\n+\n+        int totalRegCount = 0;\n+        for (int i = 0; i != scriptOrFnNodes.length; ++i) {\n+            totalRegCount += scriptOrFnNodes[i].getRegexpCount();\n+        }\n+        if (totalRegCount == 0) {\n+            return;\n+        }\n+\n+        cfw.startMethod(REGEXP_INIT_METHOD_NAME, REGEXP_INIT_METHOD_SIGNATURE,\n+            (short)(ClassFileWriter.ACC_STATIC | ClassFileWriter.ACC_PRIVATE\n+                    | ClassFileWriter.ACC_SYNCHRONIZED));\n+        cfw.addField(\"_reInitDone\", \"Z\",\n+                     (short)(ClassFileWriter.ACC_STATIC\n+                             | ClassFileWriter.ACC_PRIVATE));\n+        cfw.add(ByteCode.GETSTATIC, mainClassName, \"_reInitDone\", \"Z\");\n+        int doInit = cfw.acquireLabel();\n+        cfw.add(ByteCode.IFEQ, doInit);\n+        cfw.add(ByteCode.RETURN);\n+        cfw.markLabel(doInit);\n+\n+        for (int i = 0; i != scriptOrFnNodes.length; ++i) {\n+            ScriptNode n = scriptOrFnNodes[i];\n+            int regCount = n.getRegexpCount();\n+            for (int j = 0; j != regCount; ++j) {\n+                String reFieldName = getCompiledRegexpName(n, j);\n+                String reFieldType = \"Ljava/lang/Object;\";\n+                String reString = n.getRegexpString(j);\n+                String reFlags = n.getRegexpFlags(j);\n+                cfw.addField(reFieldName, reFieldType,\n+                             (short)(ClassFileWriter.ACC_STATIC\n+                                     | ClassFileWriter.ACC_PRIVATE));\n+                cfw.addALoad(0); // proxy\n+                cfw.addALoad(1); // context\n+                cfw.addPush(reString);\n+                if (reFlags == null) {\n+                    cfw.add(ByteCode.ACONST_NULL);\n+                } else {\n+                    cfw.addPush(reFlags);\n+                }\n+                cfw.addInvoke(ByteCode.INVOKEINTERFACE,\n+                              \"org/mozilla/javascript/RegExpProxy\",\n+                              \"compileRegExp\",\n+                              \"(Lorg/mozilla/javascript/Context;\"\n+                              +\"Ljava/lang/String;Ljava/lang/String;\"\n+                              +\")Ljava/lang/Object;\");\n+                cfw.add(ByteCode.PUTSTATIC, mainClassName,\n+                        reFieldName, reFieldType);\n+            }\n+        }\n+\n+        cfw.addPush(1);\n+        cfw.add(ByteCode.PUTSTATIC, mainClassName, \"_reInitDone\", \"Z\");\n+        cfw.add(ByteCode.RETURN);\n+        cfw.stopMethod((short)2);\n+    }\n+\n+    private void emitConstantDudeInitializers(ClassFileWriter cfw)\n+    {\n+        int N = itsConstantListSize;\n+        if (N == 0)\n+            return;\n+\n+        cfw.startMethod(\"<clinit>\", \"()V\",\n+            (short)(ClassFileWriter.ACC_STATIC | ClassFileWriter.ACC_FINAL));\n+\n+        double[] array = itsConstantList;\n+        for (int i = 0; i != N; ++i) {\n+            double num = array[i];\n+            String constantName = \"_k\" + i;\n+            String constantType = getStaticConstantWrapperType(num);\n+            cfw.addField(constantName, constantType,\n+                         (short)(ClassFileWriter.ACC_STATIC\n+                                 | ClassFileWriter.ACC_PRIVATE));\n+            int inum = (int)num;\n+            if (inum == num) {\n+                cfw.add(ByteCode.NEW, \"java/lang/Integer\");\n+                cfw.add(ByteCode.DUP);\n+                cfw.addPush(inum);\n+                cfw.addInvoke(ByteCode.INVOKESPECIAL, \"java/lang/Integer\",\n+                              \"<init>\", \"(I)V\");\n+            } else {\n+                cfw.addPush(num);\n+                addDoubleWrap(cfw);\n+            }\n+            cfw.add(ByteCode.PUTSTATIC, mainClassName,\n+                    constantName, constantType);\n+        }\n+\n+        cfw.add(ByteCode.RETURN);\n+        cfw.stopMethod((short)0);\n+    }\n+\n+    void pushRegExpArray(ClassFileWriter cfw, ScriptNode n,\n+                         int contextArg, int scopeArg)\n+    {\n+        int regexpCount = n.getRegexpCount();\n+        if (regexpCount == 0) throw badTree();\n+\n+        cfw.addPush(regexpCount);\n+        cfw.add(ByteCode.ANEWARRAY, \"java/lang/Object\");\n+\n+        cfw.addALoad(contextArg);\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      \"org/mozilla/javascript/ScriptRuntime\",\n+                      \"checkRegExpProxy\",\n+                      \"(Lorg/mozilla/javascript/Context;\"\n+                      +\")Lorg/mozilla/javascript/RegExpProxy;\");\n+        // Stack: proxy, array\n+        cfw.add(ByteCode.DUP);\n+        cfw.addALoad(contextArg);\n+        cfw.addInvoke(ByteCode.INVOKESTATIC, mainClassName,\n+                      REGEXP_INIT_METHOD_NAME, REGEXP_INIT_METHOD_SIGNATURE);\n+        for (int i = 0; i != regexpCount; ++i) {\n+            // Stack: proxy, array\n+            cfw.add(ByteCode.DUP2);\n+            cfw.addALoad(contextArg);\n+            cfw.addALoad(scopeArg);\n+            cfw.add(ByteCode.GETSTATIC, mainClassName,\n+                    getCompiledRegexpName(n, i), \"Ljava/lang/Object;\");\n+            // Stack: compiledRegExp, scope, cx, proxy, array, proxy, array\n+            cfw.addInvoke(ByteCode.INVOKEINTERFACE,\n+                          \"org/mozilla/javascript/RegExpProxy\",\n+                          \"wrapRegExp\",\n+                          \"(Lorg/mozilla/javascript/Context;\"\n+                          +\"Lorg/mozilla/javascript/Scriptable;\"\n+                          +\"Ljava/lang/Object;\"\n+                          +\")Lorg/mozilla/javascript/Scriptable;\");\n+            // Stack: wrappedRegExp, array, proxy, array\n+            cfw.addPush(i);\n+            cfw.add(ByteCode.SWAP);\n+            cfw.add(ByteCode.AASTORE);\n+            // Stack: proxy, array\n+        }\n+        // remove proxy\n+        cfw.add(ByteCode.POP);\n+    }\n+\n+    void pushNumberAsObject(ClassFileWriter cfw, double num)\n+    {\n+        if (num == 0.0) {\n+            if (1 / num > 0) {\n+                // +0.0\n+                cfw.add(ByteCode.GETSTATIC,\n+                        \"org/mozilla/javascript/optimizer/OptRuntime\",\n+                        \"zeroObj\", \"Ljava/lang/Double;\");\n+            } else {\n+                cfw.addPush(num);\n+                addDoubleWrap(cfw);\n+            }\n+\n+        } else if (num == 1.0) {\n+            cfw.add(ByteCode.GETSTATIC,\n+                    \"org/mozilla/javascript/optimizer/OptRuntime\",\n+                    \"oneObj\", \"Ljava/lang/Double;\");\n+            return;\n+\n+        } else if (num == -1.0) {\n+            cfw.add(ByteCode.GETSTATIC,\n+                    \"org/mozilla/javascript/optimizer/OptRuntime\",\n+                    \"minusOneObj\", \"Ljava/lang/Double;\");\n+\n+        } else if (num != num) {\n+            cfw.add(ByteCode.GETSTATIC,\n+                    \"org/mozilla/javascript/ScriptRuntime\",\n+                    \"NaNobj\", \"Ljava/lang/Double;\");\n+\n+        } else if (itsConstantListSize >= 2000) {\n+            // There appears to be a limit in the JVM on either the number\n+            // of static fields in a class or the size of the class\n+            // initializer. Either way, we can't have any more than 2000\n+            // statically init'd constants.\n+            cfw.addPush(num);\n+            addDoubleWrap(cfw);\n+\n+        } else {\n+            int N = itsConstantListSize;\n+            int index = 0;\n+            if (N == 0) {\n+                itsConstantList = new double[64];\n+            } else {\n+                double[] array = itsConstantList;\n+                while (index != N && array[index] != num) {\n+                    ++index;\n+                }\n+                if (N == array.length) {\n+                    array = new double[N * 2];\n+                    System.arraycopy(itsConstantList, 0, array, 0, N);\n+                    itsConstantList = array;\n+                }\n+            }\n+            if (index == N) {\n+                itsConstantList[N] = num;\n+                itsConstantListSize = N + 1;\n+            }\n+            String constantName = \"_k\" + index;\n+            String constantType = getStaticConstantWrapperType(num);\n+            cfw.add(ByteCode.GETSTATIC, mainClassName,\n+                    constantName, constantType);\n+        }\n+    }\n+\n+    private static void addDoubleWrap(ClassFileWriter cfw)\n+    {\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      \"org/mozilla/javascript/optimizer/OptRuntime\",\n+                      \"wrapDouble\", \"(D)Ljava/lang/Double;\");\n+    }\n+\n+    private static String getStaticConstantWrapperType(double num)\n+    {\n+        int inum = (int)num;\n+        if (inum == num) {\n+            return \"Ljava/lang/Integer;\";\n+        } else {\n+            return \"Ljava/lang/Double;\";\n+        }\n+    }\n+    static void pushUndefined(ClassFileWriter cfw)\n+    {\n+        cfw.add(ByteCode.GETSTATIC, \"org/mozilla/javascript/Undefined\",\n+                \"instance\", \"Ljava/lang/Object;\");\n+    }\n+\n+    int getIndex(ScriptNode n)\n+    {\n+        return scriptOrFnIndexes.getExisting(n);\n+    }\n+\n+    static String getDirectTargetFieldName(int i)\n+    {\n+        return \"_dt\" + i;\n+    }\n+\n+    String getDirectCtorName(ScriptNode n)\n+    {\n+        return \"_n\" + getIndex(n);\n+    }\n+\n+    String getBodyMethodName(ScriptNode n)\n+    {\n+        return \"_c_\" + cleanName(n) + \"_\" + getIndex(n);\n+    }\n+\n+    /**\n+     * Gets a Java-compatible \"informative\" name for the the ScriptOrFnNode\n+     */\n+    String cleanName(final ScriptNode n)\n+    {\n+      String result = \"\";\n+      if (n instanceof FunctionNode) {\n+        Name name = ((FunctionNode) n).getFunctionName();\n+        if (name == null) {\n+          result = \"anonymous\";\n+        } else {\n+          result = name.getIdentifier();\n+        }\n+      } else {\n+        result = \"script\";\n+      }\n+      return result;\n+    }\n+\n+    String getBodyMethodSignature(ScriptNode n)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        sb.append(mainClassSignature);\n+        sb.append(\"Lorg/mozilla/javascript/Context;\"\n+                  +\"Lorg/mozilla/javascript/Scriptable;\"\n+                  +\"Lorg/mozilla/javascript/Scriptable;\");\n+        if (n.getType() == Token.FUNCTION) {\n+            OptFunctionNode ofn = OptFunctionNode.get(n);\n+            if (ofn.isTargetOfDirectCall()) {\n+                int pCount = ofn.fnode.getParamCount();\n+                for (int i = 0; i != pCount; i++) {\n+                    sb.append(\"Ljava/lang/Object;D\");\n+                }\n+            }\n+        }\n+        sb.append(\"[Ljava/lang/Object;)Ljava/lang/Object;\");\n+        return sb.toString();\n+    }\n+\n+    String getFunctionInitMethodName(OptFunctionNode ofn)\n+    {\n+        return \"_i\"+getIndex(ofn.fnode);\n+    }\n+\n+    String getCompiledRegexpName(ScriptNode n, int regexpIndex)\n+    {\n+        return \"_re\"+getIndex(n)+\"_\"+regexpIndex;\n+    }\n+\n+    static RuntimeException badTree()\n+    {\n+        throw new RuntimeException(\"Bad tree in codegen\");\n+    }\n+\n+     void setMainMethodClass(String className)\n+     {\n+         mainMethodClass = className;\n+     }\n+\n+     static final String DEFAULT_MAIN_METHOD_CLASS\n+        = \"org.mozilla.javascript.optimizer.OptRuntime\";\n+\n+    private static final String SUPER_CLASS_NAME\n+        = \"org.mozilla.javascript.NativeFunction\";\n+\n+    static final String DIRECT_CALL_PARENT_FIELD = \"_dcp\";\n+    private static final String ID_FIELD_NAME = \"_id\";\n+\n+    private static final String REGEXP_INIT_METHOD_NAME = \"_reInit\";\n+    private static final String REGEXP_INIT_METHOD_SIGNATURE\n+        =  \"(Lorg/mozilla/javascript/RegExpProxy;\"\n+           +\"Lorg/mozilla/javascript/Context;\"\n+           +\")V\";\n+    static final String REGEXP_ARRAY_FIELD_NAME = \"_re\";\n+    static final String REGEXP_ARRAY_FIELD_TYPE = \"[Ljava/lang/Object;\";\n+\n+    static final String FUNCTION_INIT_SIGNATURE\n+        =  \"(Lorg/mozilla/javascript/Context;\"\n+           +\"Lorg/mozilla/javascript/Scriptable;\"\n+           +\")V\";\n+\n+   static final String FUNCTION_CONSTRUCTOR_SIGNATURE\n+        = \"(Lorg/mozilla/javascript/Scriptable;\"\n+          +\"Lorg/mozilla/javascript/Context;I)V\";\n+\n+    private static final Object globalLock = new Object();\n+    private static int globalSerialClassCounter;\n+\n+    private CompilerEnvirons compilerEnv;\n+\n+    private ObjArray directCallTargets;\n+    ScriptNode[] scriptOrFnNodes;\n+    private ObjToIntMap scriptOrFnIndexes;\n+\n+    private String mainMethodClass = DEFAULT_MAIN_METHOD_CLASS;\n+\n+    String mainClassName;\n+    String mainClassSignature;\n+\n+    private double[] itsConstantList;\n+    private int itsConstantListSize;\n+}\n+\n+\n+class BodyCodegen\n+{\n+    void generateBodyCode()\n+    {\n+        isGenerator = Codegen.isGenerator(scriptOrFn);\n+\n+        // generate the body of the current function or script object\n+        initBodyGeneration();\n+\n+        if (isGenerator) {\n+\n+            // All functions in the generated bytecode have a unique name. Every\n+            // generator has a unique prefix followed by _gen\n+            String type = \"(\" +\n+                          codegen.mainClassSignature +\n+                          \"Lorg/mozilla/javascript/Context;\" +\n+                          \"Lorg/mozilla/javascript/Scriptable;\" +\n+                          \"Ljava/lang/Object;\" +\n+                          \"Ljava/lang/Object;I)Ljava/lang/Object;\";\n+            cfw.startMethod(codegen.getBodyMethodName(scriptOrFn) + \"_gen\",\n+                    type,\n+                    (short)(ClassFileWriter.ACC_STATIC\n+                            | ClassFileWriter.ACC_PRIVATE));\n+        } else {\n+            cfw.startMethod(codegen.getBodyMethodName(scriptOrFn),\n+                    codegen.getBodyMethodSignature(scriptOrFn),\n+                    (short)(ClassFileWriter.ACC_STATIC\n+                            | ClassFileWriter.ACC_PRIVATE));\n+        }\n+\n+        generatePrologue();\n+        Node treeTop;\n+        if (fnCurrent != null) {\n+            treeTop = scriptOrFn.getLastChild();\n+        } else {\n+            treeTop = scriptOrFn;\n+        }\n+        generateStatement(treeTop);\n+        generateEpilogue();\n+\n+        cfw.stopMethod((short)(localsMax + 1));\n+\n+        if (isGenerator) {\n+            // generate the user visible method which when invoked will\n+            // return a generator object\n+            generateGenerator();\n+        }\n+    }\n+\n+    // This creates a the user-facing function that returns a NativeGenerator\n+    // object.\n+    private void generateGenerator()\n+    {\n+        cfw.startMethod(codegen.getBodyMethodName(scriptOrFn),\n+                        codegen.getBodyMethodSignature(scriptOrFn),\n+                        (short)(ClassFileWriter.ACC_STATIC\n+                                | ClassFileWriter.ACC_PRIVATE));\n+\n+        initBodyGeneration();\n+        argsLocal = firstFreeLocal++;\n+        localsMax = firstFreeLocal;\n+\n+        // get top level scope\n+        if (fnCurrent != null && !inDirectCallFunction\n+            && (!compilerEnv.isUseDynamicScope()\n+                || fnCurrent.fnode.getIgnoreDynamicScope()))\n+        {\n+            // Unless we're either in a direct call or using dynamic scope,\n+            // use the enclosing scope of the function as our variable object.\n+            cfw.addALoad(funObjLocal);\n+            cfw.addInvoke(ByteCode.INVOKEINTERFACE,\n+                          \"org/mozilla/javascript/Scriptable\",\n+                          \"getParentScope\",\n+                          \"()Lorg/mozilla/javascript/Scriptable;\");\n+            cfw.addAStore(variableObjectLocal);\n+        }\n+\n+        // generators are forced to have an activation record\n+        cfw.addALoad(funObjLocal);\n+        cfw.addALoad(variableObjectLocal);\n+        cfw.addALoad(argsLocal);\n+        addScriptRuntimeInvoke(\"createFunctionActivation\",\n+                               \"(Lorg/mozilla/javascript/NativeFunction;\"\n+                               +\"Lorg/mozilla/javascript/Scriptable;\"\n+                               +\"[Ljava/lang/Object;\"\n+                               +\")Lorg/mozilla/javascript/Scriptable;\");\n+        cfw.addAStore(variableObjectLocal);\n+\n+        // create a function object\n+        cfw.add(ByteCode.NEW, codegen.mainClassName);\n+        // Call function constructor\n+        cfw.add(ByteCode.DUP);\n+        cfw.addALoad(variableObjectLocal);\n+        cfw.addALoad(contextLocal);           // load 'cx'\n+        cfw.addPush(scriptOrFnIndex);\n+        cfw.addInvoke(ByteCode.INVOKESPECIAL, codegen.mainClassName,\n+                      \"<init>\", Codegen.FUNCTION_CONSTRUCTOR_SIGNATURE);\n+\n+        // Init mainScript field\n+        cfw.add(ByteCode.DUP);\n+        if (isTopLevel) Kit.codeBug();  // Only functions can be generators\n+        cfw.add(ByteCode.ALOAD_0);\n+        cfw.add(ByteCode.GETFIELD,\n+                codegen.mainClassName,\n+                Codegen.DIRECT_CALL_PARENT_FIELD,\n+                codegen.mainClassSignature);\n+        cfw.add(ByteCode.PUTFIELD,\n+                codegen.mainClassName,\n+                Codegen.DIRECT_CALL_PARENT_FIELD,\n+                codegen.mainClassSignature);\n+\n+        generateNestedFunctionInits();\n+\n+        // create the NativeGenerator object that we return\n+        cfw.addALoad(variableObjectLocal);\n+        cfw.addALoad(thisObjLocal);\n+        cfw.addLoadConstant(maxLocals);\n+        cfw.addLoadConstant(maxStack);\n+        addOptRuntimeInvoke(\"createNativeGenerator\",\n+                               \"(Lorg/mozilla/javascript/NativeFunction;\"\n+                               +\"Lorg/mozilla/javascript/Scriptable;\"\n+                               +\"Lorg/mozilla/javascript/Scriptable;II\"\n+                               +\")Lorg/mozilla/javascript/Scriptable;\");\n+\n+        cfw.add(ByteCode.ARETURN);\n+        cfw.stopMethod((short)(localsMax + 1));\n+    }\n+\n+    private void generateNestedFunctionInits()\n+    {\n+        int functionCount = scriptOrFn.getFunctionCount();\n+        for (int i = 0; i != functionCount; i++) {\n+            OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn, i);\n+            if (ofn.fnode.getFunctionType()\n+                    == FunctionNode.FUNCTION_STATEMENT)\n+            {\n+                visitFunction(ofn, FunctionNode.FUNCTION_STATEMENT);\n+            }\n+        }\n+    }\n+\n+    private void initBodyGeneration()\n+    {\n+        isTopLevel = (scriptOrFn == codegen.scriptOrFnNodes[0]);\n+\n+        varRegisters = null;\n+        if (scriptOrFn.getType() == Token.FUNCTION) {\n+            fnCurrent = OptFunctionNode.get(scriptOrFn);\n+            hasVarsInRegs = !fnCurrent.fnode.requiresActivation();\n+            if (hasVarsInRegs) {\n+                int n = fnCurrent.fnode.getParamAndVarCount();\n+                if (n != 0) {\n+                    varRegisters = new short[n];\n+                }\n+            }\n+            inDirectCallFunction = fnCurrent.isTargetOfDirectCall();\n+            if (inDirectCallFunction && !hasVarsInRegs) Codegen.badTree();\n+        } else {\n+            fnCurrent = null;\n+            hasVarsInRegs = false;\n+            inDirectCallFunction = false;\n+        }\n+\n+        locals = new int[MAX_LOCALS];\n+\n+        funObjLocal = 0;\n+        contextLocal = 1;\n+        variableObjectLocal = 2;\n+        thisObjLocal = 3;\n+        localsMax = (short) 4;  // number of parms + \"this\"\n+        firstFreeLocal = 4;\n+\n+        popvLocal = -1;\n+        argsLocal = -1;\n+        itsZeroArgArray = -1;\n+        itsOneArgArray = -1;\n+        scriptRegexpLocal = -1;\n+        epilogueLabel = -1;\n+        enterAreaStartLabel = -1;\n+        generatorStateLocal = -1;\n+    }\n+\n+    /**\n+     * Generate the prologue for a function or script.\n+     */\n+    private void generatePrologue()\n+    {\n+        if (inDirectCallFunction) {\n+            int directParameterCount = scriptOrFn.getParamCount();\n+            // 0 is reserved for function Object 'this'\n+            // 1 is reserved for context\n+            // 2 is reserved for parentScope\n+            // 3 is reserved for script 'this'\n+            if (firstFreeLocal != 4) Kit.codeBug();\n+            for (int i = 0; i != directParameterCount; ++i) {\n+                varRegisters[i] = firstFreeLocal;\n+                // 3 is 1 for Object parm and 2 for double parm\n+                firstFreeLocal += 3;\n+            }\n+            if (!fnCurrent.getParameterNumberContext()) {\n+                // make sure that all parameters are objects\n+                itsForcedObjectParameters = true;\n+                for (int i = 0; i != directParameterCount; ++i) {\n+                    short reg = varRegisters[i];\n+                    cfw.addALoad(reg);\n+                    cfw.add(ByteCode.GETSTATIC,\n+                            \"java/lang/Void\",\n+                            \"TYPE\",\n+                            \"Ljava/lang/Class;\");\n+                    int isObjectLabel = cfw.acquireLabel();\n+                    cfw.add(ByteCode.IF_ACMPNE, isObjectLabel);\n+                    cfw.addDLoad(reg + 1);\n+                    addDoubleWrap();\n+                    cfw.addAStore(reg);\n+                    cfw.markLabel(isObjectLabel);\n+                }\n+            }\n+        }\n+\n+        if (fnCurrent != null && !inDirectCallFunction\n+            && (!compilerEnv.isUseDynamicScope()\n+                || fnCurrent.fnode.getIgnoreDynamicScope()))\n+        {\n+            // Unless we're either in a direct call or using dynamic scope,\n+            // use the enclosing scope of the function as our variable object.\n+            cfw.addALoad(funObjLocal);\n+            cfw.addInvoke(ByteCode.INVOKEINTERFACE,\n+                          \"org/mozilla/javascript/Scriptable\",\n+                          \"getParentScope\",\n+                          \"()Lorg/mozilla/javascript/Scriptable;\");\n+            cfw.addAStore(variableObjectLocal);\n+        }\n+\n+        // reserve 'args[]'\n+        argsLocal = firstFreeLocal++;\n+        localsMax = firstFreeLocal;\n+\n+        // Generate Generator specific prelude\n+        if (isGenerator) {\n+\n+            // reserve 'args[]'\n+            operationLocal = firstFreeLocal++;\n+            localsMax = firstFreeLocal;\n+\n+            // Local 3 is a reference to a GeneratorState object. The rest\n+            // of codegen expects local 3 to be a reference to the thisObj.\n+            // So move the value in local 3 to generatorStateLocal, and load\n+            // the saved thisObj from the GeneratorState object.\n+            cfw.addALoad(thisObjLocal);\n+            generatorStateLocal = firstFreeLocal++;\n+            localsMax = firstFreeLocal;\n+            cfw.add(ByteCode.CHECKCAST, OptRuntime.GeneratorState.CLASS_NAME);\n+            cfw.add(ByteCode.DUP);\n+            cfw.addAStore(generatorStateLocal);\n+            cfw.add(ByteCode.GETFIELD,\n+                    OptRuntime.GeneratorState.CLASS_NAME,\n+                    OptRuntime.GeneratorState.thisObj_NAME,\n+                    OptRuntime.GeneratorState.thisObj_TYPE);\n+            cfw.addAStore(thisObjLocal);\n+\n+            if (epilogueLabel == -1) {\n+                epilogueLabel = cfw.acquireLabel();\n+            }\n+\n+            List<Node> targets = ((FunctionNode)scriptOrFn).getResumptionPoints();\n+            if (targets != null) {\n+                // get resumption point\n+                generateGetGeneratorResumptionPoint();\n+\n+                // generate dispatch table\n+                generatorSwitch = cfw.addTableSwitch(0,\n+                    targets.size() + GENERATOR_START);\n+                generateCheckForThrowOrClose(-1, false, GENERATOR_START);\n+            }\n+        }\n+\n+        if (fnCurrent == null) {\n+            // See comments in case Token.REGEXP\n+            if (scriptOrFn.getRegexpCount() != 0) {\n+                scriptRegexpLocal = getNewWordLocal();\n+                codegen.pushRegExpArray(cfw, scriptOrFn, contextLocal,\n+                                        variableObjectLocal);\n+                cfw.addAStore(scriptRegexpLocal);\n+            }\n+        }\n+\n+        if (compilerEnv.isGenerateObserverCount())\n+            saveCurrentCodeOffset();\n+\n+        if (hasVarsInRegs) {\n+            // No need to create activation. Pad arguments if need be.\n+            int parmCount = scriptOrFn.getParamCount();\n+            if (parmCount > 0 && !inDirectCallFunction) {\n+                // Set up args array\n+                // check length of arguments, pad if need be\n+                cfw.addALoad(argsLocal);\n+                cfw.add(ByteCode.ARRAYLENGTH);\n+                cfw.addPush(parmCount);\n+                int label = cfw.acquireLabel();\n+                cfw.add(ByteCode.IF_ICMPGE, label);\n+                cfw.addALoad(argsLocal);\n+                cfw.addPush(parmCount);\n+                addScriptRuntimeInvoke(\"padArguments\",\n+                                       \"([Ljava/lang/Object;I\"\n+                                       +\")[Ljava/lang/Object;\");\n+                cfw.addAStore(argsLocal);\n+                cfw.markLabel(label);\n+            }\n+\n+            int paramCount = fnCurrent.fnode.getParamCount();\n+            int varCount = fnCurrent.fnode.getParamAndVarCount();\n+            boolean [] constDeclarations = fnCurrent.fnode.getParamAndVarConst();\n+\n+            // REMIND - only need to initialize the vars that don't get a value\n+            // before the next call and are used in the function\n+            short firstUndefVar = -1;\n+            for (int i = 0; i != varCount; ++i) {\n+                short reg = -1;\n+                if (i < paramCount) {\n+                    if (!inDirectCallFunction) {\n+                        reg = getNewWordLocal();\n+                        cfw.addALoad(argsLocal);\n+                        cfw.addPush(i);\n+                        cfw.add(ByteCode.AALOAD);\n+                        cfw.addAStore(reg);\n+                    }\n+                } else if (fnCurrent.isNumberVar(i)) {\n+                    reg = getNewWordPairLocal(constDeclarations[i]);\n+                    cfw.addPush(0.0);\n+                    cfw.addDStore(reg);\n+                } else {\n+                    reg = getNewWordLocal(constDeclarations[i]);\n+                    if (firstUndefVar == -1) {\n+                        Codegen.pushUndefined(cfw);\n+                        firstUndefVar = reg;\n+                    } else {\n+                        cfw.addALoad(firstUndefVar);\n+                    }\n+                    cfw.addAStore(reg);\n+                }\n+                if (reg >= 0) {\n+                    if (constDeclarations[i]) {\n+                        cfw.addPush(0);\n+                        cfw.addIStore(reg + (fnCurrent.isNumberVar(i) ? 2 : 1));\n+                    }\n+                    varRegisters[i] = reg;\n+                }\n+\n+                // Add debug table entry if we're generating debug info\n+                if (compilerEnv.isGenerateDebugInfo()) {\n+                    String name = fnCurrent.fnode.getParamOrVarName(i);\n+                    String type = fnCurrent.isNumberVar(i)\n+                                      ? \"D\" : \"Ljava/lang/Object;\";\n+                    int startPC = cfw.getCurrentCodeOffset();\n+                    if (reg < 0) {\n+                        reg = varRegisters[i];\n+                    }\n+                    cfw.addVariableDescriptor(name, type, startPC, reg);\n+                }\n+            }\n+\n+            // Skip creating activation object.\n+            return;\n+        }\n+\n+        // skip creating activation object for the body of a generator. The\n+        // activation record required by a generator has already been created\n+        // in generateGenerator().\n+        if (isGenerator)\n+            return;\n+\n+\n+        String debugVariableName;\n+        if (fnCurrent != null) {\n+            debugVariableName = \"activation\";\n+            cfw.addALoad(funObjLocal);\n+            cfw.addALoad(variableObjectLocal);\n+            cfw.addALoad(argsLocal);\n+            addScriptRuntimeInvoke(\"createFunctionActivation\",\n+                                   \"(Lorg/mozilla/javascript/NativeFunction;\"\n+                                   +\"Lorg/mozilla/javascript/Scriptable;\"\n+                                   +\"[Ljava/lang/Object;\"\n+                                   +\")Lorg/mozilla/javascript/Scriptable;\");\n+            cfw.addAStore(variableObjectLocal);\n+            cfw.addALoad(contextLocal);\n+            cfw.addALoad(variableObjectLocal);\n+            addScriptRuntimeInvoke(\"enterActivationFunction\",\n+                                   \"(Lorg/mozilla/javascript/Context;\"\n+                                   +\"Lorg/mozilla/javascript/Scriptable;\"\n+                                   +\")V\");\n+        } else {\n+            debugVariableName = \"global\";\n+            cfw.addALoad(funObjLocal);\n+            cfw.addALoad(thisObjLocal);\n+            cfw.addALoad(contextLocal);\n+            cfw.addALoad(variableObjectLocal);\n+            cfw.addPush(0); // false to indicate it is not eval script\n+            addScriptRuntimeInvoke(\"initScript\",\n+                                   \"(Lorg/mozilla/javascript/NativeFunction;\"\n+                                   +\"Lorg/mozilla/javascript/Scriptable;\"\n+                                   +\"Lorg/mozilla/javascript/Context;\"\n+                                   +\"Lorg/mozilla/javascript/Scriptable;\"\n+                                   +\"Z\"\n+                                   +\")V\");\n+        }\n+\n+        enterAreaStartLabel = cfw.acquireLabel();\n+        epilogueLabel = cfw.acquireLabel();\n+        cfw.markLabel(enterAreaStartLabel);\n+\n+        generateNestedFunctionInits();\n+\n+        // default is to generate debug info\n+        if (compilerEnv.isGenerateDebugInfo()) {\n+            cfw.addVariableDescriptor(debugVariableName,\n+                    \"Lorg/mozilla/javascript/Scriptable;\",\n+                    cfw.getCurrentCodeOffset(), variableObjectLocal);\n+        }\n+\n+        if (fnCurrent == null) {\n+            // OPT: use dataflow to prove that this assignment is dead\n+            popvLocal = getNewWordLocal();\n+            Codegen.pushUndefined(cfw);\n+            cfw.addAStore(popvLocal);\n+\n+            int linenum = scriptOrFn.getEndLineno();\n+            if (linenum != -1)\n+              cfw.addLineNumberEntry((short)linenum);\n+\n+        } else {\n+            if (fnCurrent.itsContainsCalls0) {\n+                itsZeroArgArray = getNewWordLocal();\n+                cfw.add(ByteCode.GETSTATIC,\n+                        \"org/mozilla/javascript/ScriptRuntime\",\n+                        \"emptyArgs\", \"[Ljava/lang/Object;\");\n+                cfw.addAStore(itsZeroArgArray);\n+            }\n+            if (fnCurrent.itsContainsCalls1) {\n+                itsOneArgArray = getNewWordLocal();\n+                cfw.addPush(1);\n+                cfw.add(ByteCode.ANEWARRAY, \"java/lang/Object\");\n+                cfw.addAStore(itsOneArgArray);\n+            }\n+        }\n+    }\n+\n+    private void generateGetGeneratorResumptionPoint()\n+    {\n+        cfw.addALoad(generatorStateLocal);\n+        cfw.add(ByteCode.GETFIELD,\n+                OptRuntime.GeneratorState.CLASS_NAME,\n+                OptRuntime.GeneratorState.resumptionPoint_NAME,\n+                OptRuntime.GeneratorState.resumptionPoint_TYPE);\n+    }\n+\n+    private void generateSetGeneratorResumptionPoint(int nextState)\n+    {\n+        cfw.addALoad(generatorStateLocal);\n+        cfw.addLoadConstant(nextState);\n+        cfw.add(ByteCode.PUTFIELD,\n+                OptRuntime.GeneratorState.CLASS_NAME,\n+                OptRuntime.GeneratorState.resumptionPoint_NAME,\n+                OptRuntime.GeneratorState.resumptionPoint_TYPE);\n+    }\n+\n+    private void generateGetGeneratorStackState()\n+    {\n+        cfw.addALoad(generatorStateLocal);\n+        addOptRuntimeInvoke(\"getGeneratorStackState\",\n+                    \"(Ljava/lang/Object;)[Ljava/lang/Object;\");\n+    }\n+\n+    private void generateEpilogue()\n+    {\n+        if (compilerEnv.isGenerateObserverCount())\n+            addInstructionCount();\n+        if (isGenerator) {\n+            // generate locals initialization\n+            Map<Node,int[]> liveLocals = ((FunctionNode)scriptOrFn).getLiveLocals();\n+            if (liveLocals != null) {\n+                List<Node> nodes = ((FunctionNode)scriptOrFn).getResumptionPoints();\n+                for (int i = 0; i < nodes.size(); i++) {\n+                    Node node = nodes.get(i);\n+                    int[] live = liveLocals.get(node);\n+                    if (live != null) {\n+                        cfw.markTableSwitchCase(generatorSwitch,\n+                            getNextGeneratorState(node));\n+                        generateGetGeneratorLocalsState();\n+                        for (int j = 0; j < live.length; j++) {\n+                                cfw.add(ByteCode.DUP);\n+                                cfw.addLoadConstant(j);\n+                                cfw.add(ByteCode.AALOAD);\n+                                cfw.addAStore(live[j]);\n+                        }\n+                        cfw.add(ByteCode.POP);\n+                        cfw.add(ByteCode.GOTO, getTargetLabel(node));\n+                    }\n+                }\n+            }\n+\n+            // generate dispatch tables for finally\n+            if (finallys != null) {\n+                for (Node n: finallys.keySet()) {\n+                    if (n.getType() == Token.FINALLY) {\n+                        FinallyReturnPoint ret = finallys.get(n);\n+                        // the finally will jump here\n+                        cfw.markLabel(ret.tableLabel, (short)1);\n+\n+                        // start generating a dispatch table\n+                        int startSwitch = cfw.addTableSwitch(0,\n+                                            ret.jsrPoints.size() - 1);\n+                        int c = 0;\n+                        cfw.markTableSwitchDefault(startSwitch);\n+                        for (int i = 0; i < ret.jsrPoints.size(); i++) {\n+                            // generate gotos back to the JSR location\n+                            cfw.markTableSwitchCase(startSwitch, c);\n+                            cfw.add(ByteCode.GOTO,\n+                                    ret.jsrPoints.get(i).intValue());\n+                            c++;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (epilogueLabel != -1) {\n+            cfw.markLabel(epilogueLabel);\n+        }\n+\n+        if (hasVarsInRegs) {\n+            cfw.add(ByteCode.ARETURN);\n+            return;\n+        } else if (isGenerator) {\n+            if (((FunctionNode)scriptOrFn).getResumptionPoints() != null) {\n+                cfw.markTableSwitchDefault(generatorSwitch);\n+            }\n+\n+            // change state for re-entry\n+            generateSetGeneratorResumptionPoint(GENERATOR_TERMINATE);\n+\n+            // throw StopIteration\n+            cfw.addALoad(variableObjectLocal);\n+            addOptRuntimeInvoke(\"throwStopIteration\",\n+                    \"(Ljava/lang/Object;)V\");\n+\n+            Codegen.pushUndefined(cfw);\n+            cfw.add(ByteCode.ARETURN);\n+\n+        } else if (fnCurrent == null) {\n+            cfw.addALoad(popvLocal);\n+            cfw.add(ByteCode.ARETURN);\n+        } else {\n+            generateActivationExit();\n+            cfw.add(ByteCode.ARETURN);\n+\n+            // Generate catch block to catch all and rethrow to call exit code\n+            // under exception propagation as well.\n+\n+            int finallyHandler = cfw.acquireLabel();\n+            cfw.markHandler(finallyHandler);\n+            short exceptionObject = getNewWordLocal();\n+            cfw.addAStore(exceptionObject);\n+\n+            // Duplicate generateActivationExit() in the catch block since it\n+            // takes less space then full-featured ByteCode.JSR/ByteCode.RET\n+            generateActivationExit();\n+\n+            cfw.addALoad(exceptionObject);\n+            releaseWordLocal(exceptionObject);\n+            // rethrow\n+            cfw.add(ByteCode.ATHROW);\n+\n+            // mark the handler\n+            cfw.addExceptionHandler(enterAreaStartLabel, epilogueLabel,\n+                                    finallyHandler, null); // catch any\n+        }\n+    }\n+\n+    private void generateGetGeneratorLocalsState() {\n+        cfw.addALoad(generatorStateLocal);\n+        addOptRuntimeInvoke(\"getGeneratorLocalsState\",\n+                                \"(Ljava/lang/Object;)[Ljava/lang/Object;\");\n+    }\n+\n+    private void generateActivationExit()\n+    {\n+        if (fnCurrent == null || hasVarsInRegs) throw Kit.codeBug();\n+        cfw.addALoad(contextLocal);\n+        addScriptRuntimeInvoke(\"exitActivationFunction\",\n+                               \"(Lorg/mozilla/javascript/Context;)V\");\n+    }\n+\n+    private void generateStatement(Node node)\n+    {\n+        updateLineNumber(node);\n+        int type = node.getType();\n+        Node child = node.getFirstChild();\n+        switch (type) {\n+              case Token.LOOP:\n+              case Token.LABEL:\n+              case Token.WITH:\n+              case Token.SCRIPT:\n+              case Token.BLOCK:\n+              case Token.EMPTY:\n+                // no-ops.\n+                if (compilerEnv.isGenerateObserverCount()) {\n+                    // Need to add instruction count even for no-ops to catch\n+                    // cases like while (1) {}\n+                    addInstructionCount(1);\n+                }\n+                while (child != null) {\n+                    generateStatement(child);\n+                    child = child.getNext();\n+                }\n+                break;\n+\n+              case Token.LOCAL_BLOCK: {\n+                int local = getNewWordLocal();\n+                if (isGenerator) {\n+                    cfw.add(ByteCode.ACONST_NULL);\n+                    cfw.addAStore(local);\n+                }\n+                node.putIntProp(Node.LOCAL_PROP, local);\n+                while (child != null) {\n+                    generateStatement(child);\n+                    child = child.getNext();\n+                }\n+                releaseWordLocal((short)local);\n+                node.removeProp(Node.LOCAL_PROP);\n+                break;\n+              }\n+\n+              case Token.FUNCTION: {\n+                int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);\n+                OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn, fnIndex);\n+                int t = ofn.fnode.getFunctionType();\n+                if (t == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {\n+                    visitFunction(ofn, t);\n+                } else {\n+                    if (t != FunctionNode.FUNCTION_STATEMENT) {\n+                        throw Codegen.badTree();\n+                    }\n+                }\n+                break;\n+              }\n+\n+              case Token.TRY:\n+                visitTryCatchFinally((Jump)node, child);\n+                break;\n+\n+              case Token.CATCH_SCOPE:\n+                {\n+                    // nothing stays on the stack on entry into a catch scope\n+                    cfw.setStackTop((short) 0);\n+\n+                    int local = getLocalBlockRegister(node);\n+                    int scopeIndex\n+                        = node.getExistingIntProp(Node.CATCH_SCOPE_PROP);\n+\n+                    String name = child.getString(); // name of exception\n+                    child = child.getNext();\n+                    generateExpression(child, node); // load expression object\n+                    if (scopeIndex == 0) {\n+                        cfw.add(ByteCode.ACONST_NULL);\n+                    } else {\n+                        // Load previous catch scope object\n+                        cfw.addALoad(local);\n+                    }\n+                    cfw.addPush(name);\n+                    cfw.addALoad(contextLocal);\n+                    cfw.addALoad(variableObjectLocal);\n+\n+                    addScriptRuntimeInvoke(\n+                        \"newCatchScope\",\n+                        \"(Ljava/lang/Throwable;\"\n+                        +\"Lorg/mozilla/javascript/Scriptable;\"\n+                        +\"Ljava/lang/String;\"\n+                        +\"Lorg/mozilla/javascript/Context;\"\n+                        +\"Lorg/mozilla/javascript/Scriptable;\"\n+                        +\")Lorg/mozilla/javascript/Scriptable;\");\n+                    cfw.addAStore(local);\n+                }\n+                break;\n+\n+              case Token.THROW:\n+                generateExpression(child, node);\n+                if (compilerEnv.isGenerateObserverCount())\n+                    addInstructionCount();\n+                generateThrowJavaScriptException();\n+                break;\n+\n+              case Token.RETHROW:\n+                if (compilerEnv.isGenerateObserverCount())\n+                    addInstructionCount();\n+                cfw.addALoad(getLocalBlockRegister(node));\n+                cfw.add(ByteCode.ATHROW);\n+                break;\n+\n+              case Token.RETURN_RESULT:\n+              case Token.RETURN:\n+                if (!isGenerator) {\n+                    if (child != null) {\n+                        generateExpression(child, node);\n+                    } else if (type == Token.RETURN) {\n+                        Codegen.pushUndefined(cfw);\n+                    } else {\n+                        if (popvLocal < 0) throw Codegen.badTree();\n+                        cfw.addALoad(popvLocal);\n+                    }\n+                }\n+                if (compilerEnv.isGenerateObserverCount())\n+                    addInstructionCount();\n+                if (epilogueLabel == -1) {\n+                    if (!hasVarsInRegs) throw Codegen.badTree();\n+                    epilogueLabel = cfw.acquireLabel();\n+                }\n+                cfw.add(ByteCode.GOTO, epilogueLabel);\n+                break;\n+\n+              case Token.SWITCH:\n+                if (compilerEnv.isGenerateObserverCount())\n+                    addInstructionCount();\n+                visitSwitch((Jump)node, child);\n+                break;\n+\n+              case Token.ENTERWITH:\n+                generateExpression(child, node);\n+                cfw.addALoad(contextLocal);\n+                cfw.addALoad(variableObjectLocal);\n+                addScriptRuntimeInvoke(\n+                    \"enterWith\",\n+                    \"(Ljava/lang/Object;\"\n+                    +\"Lorg/mozilla/javascript/Context;\"\n+                    +\"Lorg/mozilla/javascript/Scriptable;\"\n+                    +\")Lorg/mozilla/javascript/Scriptable;\");\n+                cfw.addAStore(variableObjectLocal);\n+                incReferenceWordLocal(variableObjectLocal);\n+                break;\n+\n+              case Token.LEAVEWITH:\n+                cfw.addALoad(variableObjectLocal);\n+                addScriptRuntimeInvoke(\n+                    \"leaveWith\",\n+                    \"(Lorg/mozilla/javascript/Scriptable;\"\n+                    +\")Lorg/mozilla/javascript/Scriptable;\");\n+                cfw.addAStore(variableObjectLocal);\n+                decReferenceWordLocal(variableObjectLocal);\n+                break;\n+\n+              case Token.ENUM_INIT_KEYS:\n+              case Token.ENUM_INIT_VALUES:\n+              case Token.ENUM_INIT_ARRAY:\n+                generateExpression(child, node);\n+                cfw.addALoad(contextLocal);\n+                int enumType = type == Token.ENUM_INIT_KEYS\n+                                   ? ScriptRuntime.ENUMERATE_KEYS :\n+                               type == Token.ENUM_INIT_VALUES\n+                                   ? ScriptRuntime.ENUMERATE_VALUES :\n+                               ScriptRuntime.ENUMERATE_ARRAY;\n+                cfw.addPush(enumType);\n+                addScriptRuntimeInvoke(\"enumInit\",\n+                                       \"(Ljava/lang/Object;\"\n+                                       +\"Lorg/mozilla/javascript/Context;\"\n+                                       +\"I\"\n+                                       +\")Ljava/lang/Object;\");\n+                cfw.addAStore(getLocalBlockRegister(node));\n+                break;\n+\n+              case Token.EXPR_VOID:\n+                if (child.getType() == Token.SETVAR) {\n+                    /* special case this so as to avoid unnecessary\n+                    load's & pop's */\n+                    visitSetVar(child, child.getFirstChild(), false);\n+                }\n+                else if (child.getType() == Token.SETCONSTVAR) {\n+                    /* special case this so as to avoid unnecessary\n+                    load's & pop's */\n+                    visitSetConstVar(child, child.getFirstChild(), false);\n+                }\n+                else if (child.getType() == Token.YIELD) {\n+                    generateYieldPoint(child, false);\n+                }\n+                else {\n+                    generateExpression(child, node);\n+                    if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1)\n+                        cfw.add(ByteCode.POP2);\n+                    else\n+                        cfw.add(ByteCode.POP);\n+                }\n+                break;\n+\n+              case Token.EXPR_RESULT:\n+                generateExpression(child, node);\n+                if (popvLocal < 0) {\n+                    popvLocal = getNewWordLocal();\n+                }\n+                cfw.addAStore(popvLocal);\n+                break;\n+\n+              case Token.TARGET:\n+                {\n+                    if (compilerEnv.isGenerateObserverCount())\n+                        addInstructionCount();\n+                    int label = getTargetLabel(node);\n+                    cfw.markLabel(label);\n+                    if (compilerEnv.isGenerateObserverCount())\n+                        saveCurrentCodeOffset();\n+                }\n+                break;\n+\n+              case Token.JSR:\n+              case Token.GOTO:\n+              case Token.IFEQ:\n+              case Token.IFNE:\n+                if (compilerEnv.isGenerateObserverCount())\n+                    addInstructionCount();\n+                visitGoto((Jump)node, type, child);\n+                break;\n+\n+              case Token.FINALLY:\n+                {\n+                    if (compilerEnv.isGenerateObserverCount())\n+                        saveCurrentCodeOffset();\n+                    // there is exactly one value on the stack when enterring\n+                    // finally blocks: the return address (or its int encoding)\n+                    cfw.setStackTop((short)1);\n+\n+                    // Save return address in a new local\n+                    int finallyRegister = getNewWordLocal();\n+                    if (isGenerator)\n+                        generateIntegerWrap();\n+                    cfw.addAStore(finallyRegister);\n+\n+                    while (child != null) {\n+                        generateStatement(child);\n+                        child = child.getNext();\n+                    }\n+                    if (isGenerator) {\n+                        cfw.addALoad(finallyRegister);\n+                        cfw.add(ByteCode.CHECKCAST, \"java/lang/Integer\");\n+                        generateIntegerUnwrap();\n+                        FinallyReturnPoint ret = finallys.get(node);\n+                        ret.tableLabel = cfw.acquireLabel();\n+                        cfw.add(ByteCode.GOTO, ret.tableLabel);\n+                    } else {\n+                        cfw.add(ByteCode.RET, finallyRegister);\n+                    }\n+                    releaseWordLocal((short)finallyRegister);\n+                }\n+                break;\n+\n+              case Token.DEBUGGER:\n+                break;\n+\n+              default:\n+                throw Codegen.badTree();\n+        }\n+\n+    }\n+\n+    private void generateIntegerWrap()\n+    {\n+        cfw.addInvoke(ByteCode.INVOKESTATIC, \"java/lang/Integer\", \"valueOf\",\n+                \"(I)Ljava/lang/Integer;\");\n+    }\n+\n+\n+    private void generateIntegerUnwrap()\n+    {\n+        cfw.addInvoke(ByteCode.INVOKEVIRTUAL, \"java/lang/Integer\",\n+                \"intValue\", \"()I\");\n+    }\n+\n+\n+    private void generateThrowJavaScriptException()\n+    {\n+        cfw.add(ByteCode.NEW,\n+                        \"org/mozilla/javascript/JavaScriptException\");\n+        cfw.add(ByteCode.DUP_X1);\n+        cfw.add(ByteCode.SWAP);\n+        cfw.addPush(scriptOrFn.getSourceName());\n+        cfw.addPush(itsLineNumber);\n+        cfw.addInvoke(\n+                    ByteCode.INVOKESPECIAL,\n+                    \"org/mozilla/javascript/JavaScriptException\",\n+                    \"<init>\",\n+                    \"(Ljava/lang/Object;Ljava/lang/String;I)V\");\n+        cfw.add(ByteCode.ATHROW);\n+    }\n+\n+    private int getNextGeneratorState(Node node)\n+    {\n+        int nodeIndex = ((FunctionNode)scriptOrFn).getResumptionPoints()\n+                .indexOf(node);\n+        return nodeIndex + GENERATOR_YIELD_START;\n+    }\n+\n+    private void generateExpression(Node node, Node parent)\n+    {\n+        int type = node.getType();\n+        Node child = node.getFirstChild();\n+        switch (type) {\n+              case Token.USE_STACK:\n+                break;\n+\n+              case Token.FUNCTION:\n+                if (fnCurrent != null || parent.getType() != Token.SCRIPT) {\n+                    int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);\n+                    OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn,\n+                                                             fnIndex);\n+                    int t = ofn.fnode.getFunctionType();\n+                    if (t != FunctionNode.FUNCTION_EXPRESSION) {\n+                        throw Codegen.badTree();\n+                    }\n+                    visitFunction(ofn, t);\n+                }\n+                break;\n+\n+              case Token.NAME:\n+                {\n+                    cfw.addALoad(contextLocal);\n+                    cfw.addALoad(variableObjectLocal);\n+                    cfw.addPush(node.getString());\n+                    addScriptRuntimeInvoke(\n+                        \"name\",\n+                        \"(Lorg/mozilla/javascript/Context;\"\n+                        +\"Lorg/mozilla/javascript/Scriptable;\"\n+                        +\"Ljava/lang/String;\"\n+                        +\")Ljava/lang/Object;\");\n+                }\n+                break;\n+\n+              case Token.CALL:\n+              case Token.NEW:\n+                {\n+                    int specialType = node.getIntProp(Node.SPECIALCALL_PROP,\n+                                                      Node.NON_SPECIALCALL);\n+                    if (specialType == Node.NON_SPECIALCALL) {\n+                        OptFunctionNode target;\n+                        target = (OptFunctionNode)node.getProp(\n+                                     Node.DIRECTCALL_PROP);\n+\n+                        if (target != null) {\n+                            visitOptimizedCall(node, target, type, child);\n+                        } else if (type == Token.CALL) {\n+                            visitStandardCall(node, child);\n+                        } else {\n+                            visitStandardNew(node, child);\n+                        }\n+                    } else {\n+                        visitSpecialCall(node, type, specialType, child);\n+                    }\n+                }\n+                break;\n+\n+              case Token.REF_CALL:\n+                generateFunctionAndThisObj(child, node);\n+                // stack: ... functionObj thisObj\n+                child = child.getNext();\n+                generateCallArgArray(node, child, false);\n+                cfw.addALoad(contextLocal);\n+                addScriptRuntimeInvoke(\n+                    \"callRef\",\n+                    \"(Lorg/mozilla/javascript/Callable;\"\n+                    +\"Lorg/mozilla/javascript/Scriptable;\"\n+                    +\"[Ljava/lang/Object;\"\n+                    +\"Lorg/mozilla/javascript/Context;\"\n+                    +\")Lorg/mozilla/javascript/Ref;\");\n+                break;\n+\n+              case Token.NUMBER:\n+                {\n+                    double num = node.getDouble();\n+                    if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {\n+                        cfw.addPush(num);\n+                    } else {\n+                        codegen.pushNumberAsObject(cfw, num);\n+                    }\n+                }\n+                break;\n+\n+              case Token.STRING:\n+                cfw.addPush(node.getString());\n+                break;\n+\n+              case Token.THIS:\n+                cfw.addALoad(thisObjLocal);\n+                break;\n+\n+              case Token.THISFN:\n+                cfw.add(ByteCode.ALOAD_0);\n+                break;\n+\n+              case Token.NULL:\n+                cfw.add(ByteCode.ACONST_NULL);\n+                break;\n+\n+              case Token.TRUE:\n+                cfw.add(ByteCode.GETSTATIC, \"java/lang/Boolean\",\n+                        \"TRUE\", \"Ljava/lang/Boolean;\");\n+                break;\n+\n+              case Token.FALSE:\n+                cfw.add(ByteCode.GETSTATIC, \"java/lang/Boolean\",\n+                        \"FALSE\", \"Ljava/lang/Boolean;\");\n+                break;\n+\n+              case Token.REGEXP:\n+                {\n+                    int i = node.getExistingIntProp(Node.REGEXP_PROP);\n+                    // Scripts can not use REGEXP_ARRAY_FIELD_NAME since\n+                    // it it will make script.exec non-reentrant so they\n+                    // store regexp array in a local variable while\n+                    // functions always access precomputed\n+                    // REGEXP_ARRAY_FIELD_NAME not to consume locals\n+                    if (fnCurrent == null) {\n+                        cfw.addALoad(scriptRegexpLocal);\n+                    } else {\n+                        cfw.addALoad(funObjLocal);\n+                        cfw.add(ByteCode.GETFIELD, codegen.mainClassName,\n+                                Codegen.REGEXP_ARRAY_FIELD_NAME,\n+                                Codegen.REGEXP_ARRAY_FIELD_TYPE);\n+                    }\n+                    cfw.addPush(i);\n+                    cfw.add(ByteCode.AALOAD);\n+                }\n+                break;\n+\n+              case Token.COMMA: {\n+                Node next = child.getNext();\n+                while (next != null) {\n+                    generateExpression(child, node);\n+                    cfw.add(ByteCode.POP);\n+                    child = next;\n+                    next = next.getNext();\n+                }\n+                generateExpression(child, node);\n+                break;\n+              }\n+\n+              case Token.ENUM_NEXT:\n+              case Token.ENUM_ID: {\n+                int local = getLocalBlockRegister(node);\n+                cfw.addALoad(local);\n+                if (type == Token.ENUM_NEXT) {\n+                    addScriptRuntimeInvoke(\n+                        \"enumNext\", \"(Ljava/lang/Object;)Ljava/lang/Boolean;\");\n+                } else {\n+                    cfw.addALoad(contextLocal);\n+                    addScriptRuntimeInvoke(\"enumId\",\n+                                           \"(Ljava/lang/Object;\"\n+                                           +\"Lorg/mozilla/javascript/Context;\"\n+                                           +\")Ljava/lang/Object;\");\n+                }\n+                break;\n+              }\n+\n+              case Token.ARRAYLIT:\n+                visitArrayLiteral(node, child);\n+                break;\n+\n+              case Token.OBJECTLIT:\n+                visitObjectLiteral(node, child);\n+                break;\n+\n+              case Token.NOT: {\n+                int trueTarget = cfw.acquireLabel();\n+                int falseTarget = cfw.acquireLabel();\n+                int beyond = cfw.acquireLabel();\n+                generateIfJump(child, node, trueTarget, falseTarget);\n+\n+                cfw.markLabel(trueTarget);\n+                cfw.add(ByteCode.GETSTATIC, \"java/lang/Boolean\",\n+                                        \"FALSE\", \"Ljava/lang/Boolean;\");\n+                cfw.add(ByteCode.GOTO, beyond);\n+                cfw.markLabel(falseTarget);\n+                cfw.add(ByteCode.GETSTATIC, \"java/lang/Boolean\",\n+                                        \"TRUE\", \"Ljava/lang/Boolean;\");\n+                cfw.markLabel(beyond);\n+                cfw.adjustStackTop(-1);\n+                break;\n+              }\n+\n+              case Token.BITNOT:\n+                generateExpression(child, node);\n+                addScriptRuntimeInvoke(\"toInt32\", \"(Ljava/lang/Object;)I\");\n+                cfw.addPush(-1);         // implement ~a as (a ^ -1)\n+                cfw.add(ByteCode.IXOR);\n+                cfw.add(ByteCode.I2D);\n+                addDoubleWrap();\n+                break;\n+\n+              case Token.VOID:\n+                generateExpression(child, node);\n+                cfw.add(ByteCode.POP);\n+                Codegen.pushUndefined(cfw);\n+                break;\n+\n+              case Token.TYPEOF:\n+                generateExpression(child, node);\n+                addScriptRuntimeInvoke(\"typeof\",\n+                                       \"(Ljava/lang/Object;\"\n+                                       +\")Ljava/lang/String;\");\n+                break;\n+\n+              case Token.TYPEOFNAME:\n+                visitTypeofname(node);\n+                break;\n+\n+              case Token.INC:\n+              case Token.DEC:\n+                visitIncDec(node);\n+                break;\n+\n+              case Token.OR:\n+              case Token.AND: {\n+                    generateExpression(child, node);\n+                    cfw.add(ByteCode.DUP);\n+                    addScriptRuntimeInvoke(\"toBoolean\",\n+                                           \"(Ljava/lang/Object;)Z\");\n+                    int falseTarget = cfw.acquireLabel();\n+                    if (type == Token.AND)\n+                        cfw.add(ByteCode.IFEQ, falseTarget);\n+                    else\n+                        cfw.add(ByteCode.IFNE, falseTarget);\n+                    cfw.add(ByteCode.POP);\n+                    generateExpression(child.getNext(), node);\n+                    cfw.markLabel(falseTarget);\n+                }\n+                break;\n+\n+              case Token.HOOK : {\n+                    Node ifThen = child.getNext();\n+                    Node ifElse = ifThen.getNext();\n+                    generateExpression(child, node);\n+                    addScriptRuntimeInvoke(\"toBoolean\",\n+                                           \"(Ljava/lang/Object;)Z\");\n+                    int elseTarget = cfw.acquireLabel();\n+                    cfw.add(ByteCode.IFEQ, elseTarget);\n+                    short stack = cfw.getStackTop();\n+                    generateExpression(ifThen, node);\n+                    int afterHook = cfw.acquireLabel();\n+                    cfw.add(ByteCode.GOTO, afterHook);\n+                    cfw.markLabel(elseTarget, stack);\n+                    generateExpression(ifElse, node);\n+                    cfw.markLabel(afterHook);\n+                }\n+                break;\n+\n+              case Token.ADD: {\n+                    generateExpression(child, node);\n+                    generateExpression(child.getNext(), node);\n+                    switch (node.getIntProp(Node.ISNUMBER_PROP, -1)) {\n+                      case Node.BOTH:\n+                        cfw.add(ByteCode.DADD);\n+                        break;\n+                      case Node.LEFT:\n+                        addOptRuntimeInvoke(\"add\",\n+                            \"(DLjava/lang/Object;)Ljava/lang/Object;\");\n+                        break;\n+                      case Node.RIGHT:\n+                        addOptRuntimeInvoke(\"add\",\n+                            \"(Ljava/lang/Object;D)Ljava/lang/Object;\");\n+                        break;\n+                      default:\n+                        if (child.getType() == Token.STRING) {\n+                            addScriptRuntimeInvoke(\"add\",\n+                                \"(Ljava/lang/String;\"\n+                                +\"Ljava/lang/Object;\"\n+                                +\")Ljava/lang/String;\");\n+                        } else if (child.getNext().getType() == Token.STRING) {\n+                            addScriptRuntimeInvoke(\"add\",\n+                                \"(Ljava/lang/Object;\"\n+                                +\"Ljava/lang/String;\"\n+                                +\")Ljava/lang/String;\");\n+                        } else {\n+                            cfw.addALoad(contextLocal);\n+                            addScriptRuntimeInvoke(\"add\",\n+                                \"(Ljava/lang/Object;\"\n+                                +\"Ljava/lang/Object;\"\n+                                +\"Lorg/mozilla/javascript/Context;\"\n+                                +\")Ljava/lang/Object;\");\n+                        }\n+                    }\n+                }\n+                break;\n+\n+              case Token.MUL:\n+                visitArithmetic(node, ByteCode.DMUL, child, parent);\n+                break;\n+\n+              case Token.SUB:\n+                visitArithmetic(node, ByteCode.DSUB, child, parent);\n+                break;\n+\n+              case Token.DIV:\n+              case Token.MOD:\n+                visitArithmetic(node, type == Token.DIV\n+                                      ? ByteCode.DDIV\n+                                      : ByteCode.DREM, child, parent);\n+                break;\n+\n+              case Token.BITOR:\n+              case Token.BITXOR:\n+              case Token.BITAND:\n+              case Token.LSH:\n+              case Token.RSH:\n+              case Token.URSH:\n+                visitBitOp(node, type, child);\n+                break;\n+\n+              case Token.POS:\n+              case Token.NEG:\n+                generateExpression(child, node);\n+                addObjectToDouble();\n+                if (type == Token.NEG) {\n+                    cfw.add(ByteCode.DNEG);\n+                }\n+                addDoubleWrap();\n+                break;\n+\n+              case Token.TO_DOUBLE:\n+                // cnvt to double (not Double)\n+                generateExpression(child, node);\n+                addObjectToDouble();\n+                break;\n+\n+              case Token.TO_OBJECT: {\n+                // convert from double\n+                int prop = -1;\n+                if (child.getType() == Token.NUMBER) {\n+                    prop = child.getIntProp(Node.ISNUMBER_PROP, -1);\n+                }\n+                if (prop != -1) {\n+                    child.removeProp(Node.ISNUMBER_PROP);\n+                    generateExpression(child, node);\n+                    child.putIntProp(Node.ISNUMBER_PROP, prop);\n+                } else {\n+                    generateExpression(child, node);\n+                    addDoubleWrap();\n+                }\n+                break;\n+              }\n+\n+              case Token.IN:\n+              case Token.INSTANCEOF:\n+              case Token.LE:\n+              case Token.LT:\n+              case Token.GE:\n+              case Token.GT: {\n+                int trueGOTO = cfw.acquireLabel();\n+                int falseGOTO = cfw.acquireLabel();\n+                visitIfJumpRelOp(node, child, trueGOTO, falseGOTO);\n+                addJumpedBooleanWrap(trueGOTO, falseGOTO);\n+                break;\n+              }\n+\n+              case Token.EQ:\n+              case Token.NE:\n+              case Token.SHEQ:\n+              case Token.SHNE: {\n+                int trueGOTO = cfw.acquireLabel();\n+                int falseGOTO = cfw.acquireLabel();\n+                visitIfJumpEqOp(node, child, trueGOTO, falseGOTO);\n+                addJumpedBooleanWrap(trueGOTO, falseGOTO);\n+                break;\n+              }\n+\n+              case Token.GETPROP:\n+              case Token.GETPROPNOWARN:\n+                visitGetProp(node, child);\n+                break;\n+\n+              case Token.GETELEM:\n+                generateExpression(child, node); // object\n+                generateExpression(child.getNext(), node);  // id\n+                cfw.addALoad(contextLocal);\n+                if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {\n+                    addScriptRuntimeInvoke(\n+                        \"getObjectIndex\",\n+                        \"(Ljava/lang/Object;D\"\n+                        +\"Lorg/mozilla/javascript/Context;\"\n+                        +\")Ljava/lang/Object;\");\n+                }\n+                else {\n+                    cfw.addALoad(variableObjectLocal);\n+                \taddScriptRuntimeInvoke(\n+                        \"getObjectElem\",\n+                        \"(Ljava/lang/Object;\"\n+                        +\"Ljava/lang/Object;\"\n+                        +\"Lorg/mozilla/javascript/Context;\"\n+                        +\"Lorg/mozilla/javascript/Scriptable;\"\n+                        +\")Ljava/lang/Object;\");\n+                }\n+                break;\n+\n+              case Token.GET_REF:\n+                generateExpression(child, node); // reference\n+                cfw.addALoad(contextLocal);\n+                addScriptRuntimeInvoke(\n+                    \"refGet\",\n+                    \"(Lorg/mozilla/javascript/Ref;\"\n+                    +\"Lorg/mozilla/javascript/Context;\"\n+                    +\")Ljava/lang/Object;\");\n+                break;\n+\n+              case Token.GETVAR:\n+                visitGetVar(node);\n+                break;\n+\n+              case Token.SETVAR:\n+                visitSetVar(node, child, true);\n+                break;\n+\n+              case Token.SETNAME:\n+                visitSetName(node, child);\n+                break;\n+\n+              case Token.STRICT_SETNAME:\n+                  visitStrictSetName(node, child);\n+                  break;\n+\n+              case Token.SETCONST:\n+                visitSetConst(node, child);\n+                break;\n+\n+              case Token.SETCONSTVAR:\n+                visitSetConstVar(node, child, true);\n+                break;\n+\n+              case Token.SETPROP:\n+              case Token.SETPROP_OP:\n+                visitSetProp(type, node, child);\n+                break;\n+\n+              case Token.SETELEM:\n+              case Token.SETELEM_OP:\n+                visitSetElem(type, node, child);\n+                break;\n+\n+              case Token.SET_REF:\n+              case Token.SET_REF_OP:\n+                {\n+                    generateExpression(child, node);\n+                    child = child.getNext();\n+                    if (type == Token.SET_REF_OP) {\n+                        cfw.add(ByteCode.DUP);\n+                        cfw.addALoad(contextLocal);\n+                        addScriptRuntimeInvoke(\n+                            \"refGet\",\n+                            \"(Lorg/mozilla/javascript/Ref;\"\n+                            +\"Lorg/mozilla/javascript/Context;\"\n+                            +\")Ljava/lang/Object;\");\n+                    }\n+                    generateExpression(child, node);\n+                    cfw.addALoad(contextLocal);\n+                    addScriptRuntimeInvoke(\n+                        \"refSet\",\n+                        \"(Lorg/mozilla/javascript/Ref;\"\n+                        +\"Ljava/lang/Object;\"\n+                        +\"Lorg/mozilla/javascript/Context;\"\n+                        +\")Ljava/lang/Object;\");\n+                }\n+                break;\n+\n+              case Token.DEL_REF:\n+                generateExpression(child, node);\n+                cfw.addALoad(contextLocal);\n+                addScriptRuntimeInvoke(\"refDel\",\n+                                       \"(Lorg/mozilla/javascript/Ref;\"\n+                                       +\"Lorg/mozilla/javascript/Context;\"\n+                                       +\")Ljava/lang/Object;\");\n+                break;\n+\n+              case Token.DELPROP:\n+                generateExpression(child, node);\n+                child = child.getNext();\n+                generateExpression(child, node);\n+                cfw.addALoad(contextLocal);\n+                addScriptRuntimeInvoke(\"delete\",\n+                                       \"(Ljava/lang/Object;\"\n+                                       +\"Ljava/lang/Object;\"\n+                                       +\"Lorg/mozilla/javascript/Context;\"\n+                                       +\")Ljava/lang/Object;\");\n+                break;\n+\n+              case Token.BINDNAME:\n+                {\n+                    while (child != null) {\n+                        generateExpression(child, node);\n+                        child = child.getNext();\n+                    }\n+                    // Generate code for \"ScriptRuntime.bind(varObj, \"s\")\"\n+                    cfw.addALoad(contextLocal);\n+                    cfw.addALoad(variableObjectLocal);\n+                    cfw.addPush(node.getString());\n+                    addScriptRuntimeInvoke(\n+                        \"bind\",\n+                        \"(Lorg/mozilla/javascript/Context;\"\n+                        +\"Lorg/mozilla/javascript/Scriptable;\"\n+                        +\"Ljava/lang/String;\"\n+                        +\")Lorg/mozilla/javascript/Scriptable;\");\n+                }\n+                break;\n+\n+              case Token.LOCAL_LOAD:\n+                cfw.addALoad(getLocalBlockRegister(node));\n+                break;\n+\n+              case Token.REF_SPECIAL:\n+                {\n+                    String special = (String)node.getProp(Node.NAME_PROP);\n+                    generateExpression(child, node);\n+                    cfw.addPush(special);\n+                    cfw.addALoad(contextLocal);\n+                    addScriptRuntimeInvoke(\n+                        \"specialRef\",\n+                        \"(Ljava/lang/Object;\"\n+                        +\"Ljava/lang/String;\"\n+                        +\"Lorg/mozilla/javascript/Context;\"\n+                        +\")Lorg/mozilla/javascript/Ref;\");\n+                }\n+                break;\n+\n+              case Token.REF_MEMBER:\n+              case Token.REF_NS_MEMBER:\n+              case Token.REF_NAME:\n+              case Token.REF_NS_NAME:\n+                {\n+                    int memberTypeFlags\n+                        = node.getIntProp(Node.MEMBER_TYPE_PROP, 0);\n+                    // generate possible target, possible namespace and member\n+                    do {\n+                        generateExpression(child, node);\n+                        child = child.getNext();\n+                    } while (child != null);\n+                    cfw.addALoad(contextLocal);\n+                    String methodName, signature;\n+                    switch (type) {\n+                      case Token.REF_MEMBER:\n+                        methodName = \"memberRef\";\n+                        signature = \"(Ljava/lang/Object;\"\n+                                    +\"Ljava/lang/Object;\"\n+                                    +\"Lorg/mozilla/javascript/Context;\"\n+                                    +\"I\"\n+                                    +\")Lorg/mozilla/javascript/Ref;\";\n+                        break;\n+                      case Token.REF_NS_MEMBER:\n+                        methodName = \"memberRef\";\n+                        signature = \"(Ljava/lang/Object;\"\n+                                    +\"Ljava/lang/Object;\"\n+                                    +\"Ljava/lang/Object;\"\n+                                    +\"Lorg/mozilla/javascript/Context;\"\n+                                    +\"I\"\n+                                    +\")Lorg/mozilla/javascript/Ref;\";\n+                        break;\n+                      case Token.REF_NAME:\n+                        methodName = \"nameRef\";\n+                        signature = \"(Ljava/lang/Object;\"\n+                                    +\"Lorg/mozilla/javascript/Context;\"\n+                                    +\"Lorg/mozilla/javascript/Scriptable;\"\n+                                    +\"I\"\n+                                    +\")Lorg/mozilla/javascript/Ref;\";\n+                        cfw.addALoad(variableObjectLocal);\n+                        break;\n+                      case Token.REF_NS_NAME:\n+                        methodName = \"nameRef\";\n+                        signature = \"(Ljava/lang/Object;\"\n+                                    +\"Ljava/lang/Object;\"\n+                                    +\"Lorg/mozilla/javascript/Context;\"\n+                                    +\"Lorg/mozilla/javascript/Scriptable;\"\n+                                    +\"I\"\n+                                    +\")Lorg/mozilla/javascript/Ref;\";\n+                        cfw.addALoad(variableObjectLocal);\n+                        break;\n+                      default:\n+                        throw Kit.codeBug();\n+                    }\n+                    cfw.addPush(memberTypeFlags);\n+                    addScriptRuntimeInvoke(methodName, signature);\n+                }\n+                break;\n+\n+              case Token.DOTQUERY:\n+                visitDotQuery(node, child);\n+                break;\n+\n+              case Token.ESCXMLATTR:\n+                generateExpression(child, node);\n+                cfw.addALoad(contextLocal);\n+                addScriptRuntimeInvoke(\"escapeAttributeValue\",\n+                                       \"(Ljava/lang/Object;\"\n+                                       +\"Lorg/mozilla/javascript/Context;\"\n+                                       +\")Ljava/lang/String;\");\n+                break;\n+\n+              case Token.ESCXMLTEXT:\n+                generateExpression(child, node);\n+                cfw.addALoad(contextLocal);\n+                addScriptRuntimeInvoke(\"escapeTextValue\",\n+                                       \"(Ljava/lang/Object;\"\n+                                       +\"Lorg/mozilla/javascript/Context;\"\n+                                       +\")Ljava/lang/String;\");\n+                break;\n+\n+              case Token.DEFAULTNAMESPACE:\n+                generateExpression(child, node);\n+                cfw.addALoad(contextLocal);\n+                addScriptRuntimeInvoke(\"setDefaultNamespace\",\n+                                       \"(Ljava/lang/Object;\"\n+                                       +\"Lorg/mozilla/javascript/Context;\"\n+                                       +\")Ljava/lang/Object;\");\n+                break;\n+\n+              case Token.YIELD:\n+                generateYieldPoint(node, true);\n+                break;\n+\n+              case Token.WITHEXPR: {\n+                Node enterWith = child;\n+                Node with = enterWith.getNext();\n+                Node leaveWith = with.getNext();\n+                generateStatement(enterWith);\n+                generateExpression(with.getFirstChild(), with);\n+                generateStatement(leaveWith);\n+                break;\n+              }\n+\n+              case Token.ARRAYCOMP: {\n+                Node initStmt = child;\n+                Node expr = child.getNext();\n+                generateStatement(initStmt);\n+                generateExpression(expr, node);\n+                break;\n+              }\n+\n+              default:\n+                throw new RuntimeException(\"Unexpected node type \"+type);\n+        }\n+\n+    }\n+\n+    private void generateYieldPoint(Node node, boolean exprContext) {\n+        // save stack state\n+        int top = cfw.getStackTop();\n+        maxStack = maxStack > top ? maxStack : top;\n+        if (cfw.getStackTop() != 0) {\n+            generateGetGeneratorStackState();\n+            for (int i = 0; i < top; i++) {\n+                cfw.add(ByteCode.DUP_X1);\n+                cfw.add(ByteCode.SWAP);\n+                cfw.addLoadConstant(i);\n+                cfw.add(ByteCode.SWAP);\n+                cfw.add(ByteCode.AASTORE);\n+            }\n+            // pop the array object\n+            cfw.add(ByteCode.POP);\n+        }\n+\n+        // generate the yield argument\n+        Node child = node.getFirstChild();\n+        if (child != null)\n+            generateExpression(child, node);\n+        else\n+            Codegen.pushUndefined(cfw);\n+\n+        // change the resumption state\n+        int nextState = getNextGeneratorState(node);\n+        generateSetGeneratorResumptionPoint(nextState);\n+\n+        boolean hasLocals = generateSaveLocals(node);\n+\n+        cfw.add(ByteCode.ARETURN);\n+\n+        generateCheckForThrowOrClose(getTargetLabel(node),\n+                hasLocals, nextState);\n+\n+        // reconstruct the stack\n+        if (top != 0) {\n+            generateGetGeneratorStackState();\n+            for (int i = 0; i < top; i++) {\n+                cfw.add(ByteCode.DUP);\n+                cfw.addLoadConstant(top - i - 1);\n+                cfw.add(ByteCode.AALOAD);\n+                cfw.add(ByteCode.SWAP);\n+            }\n+            cfw.add(ByteCode.POP);\n+        }\n+\n+        // load return value from yield\n+        if (exprContext) {\n+            cfw.addALoad(argsLocal);\n+        }\n+    }\n+\n+    private void generateCheckForThrowOrClose(int label,\n+                                              boolean hasLocals,\n+                                              int nextState) {\n+        int throwLabel = cfw.acquireLabel();\n+        int closeLabel = cfw.acquireLabel();\n+\n+        // throw the user provided object, if the operation is .throw()\n+        cfw.markLabel(throwLabel);\n+        cfw.addALoad(argsLocal);\n+        generateThrowJavaScriptException();\n+\n+        // throw our special internal exception if the generator is being closed\n+        cfw.markLabel(closeLabel);\n+        cfw.addALoad(argsLocal);\n+        cfw.add(ByteCode.CHECKCAST, \"java/lang/Throwable\");\n+        cfw.add(ByteCode.ATHROW);\n+\n+        // mark the re-entry point\n+        // jump here after initializing the locals\n+        if (label != -1)\n+            cfw.markLabel(label);\n+        if (!hasLocals) {\n+            // jump here directly if there are no locals\n+            cfw.markTableSwitchCase(generatorSwitch, nextState);\n+        }\n+\n+        // see if we need to dispatch for .close() or .throw()\n+        cfw.addILoad(operationLocal);\n+        cfw.addLoadConstant(NativeGenerator.GENERATOR_CLOSE);\n+        cfw.add(ByteCode.IF_ICMPEQ, closeLabel);\n+        cfw.addILoad(operationLocal);\n+        cfw.addLoadConstant(NativeGenerator.GENERATOR_THROW);\n+        cfw.add(ByteCode.IF_ICMPEQ, throwLabel);\n+    }\n+\n+    private void generateIfJump(Node node, Node parent,\n+                                int trueLabel, int falseLabel)\n+    {\n+        // System.out.println(\"gen code for \" + node.toString());\n+\n+        int type = node.getType();\n+        Node child = node.getFirstChild();\n+\n+        switch (type) {\n+          case Token.NOT:\n+            generateIfJump(child, node, falseLabel, trueLabel);\n+            break;\n+\n+          case Token.OR:\n+          case Token.AND: {\n+            int interLabel = cfw.acquireLabel();\n+            if (type == Token.AND) {\n+                generateIfJump(child, node, interLabel, falseLabel);\n+            }\n+            else {\n+                generateIfJump(child, node, trueLabel, interLabel);\n+            }\n+            cfw.markLabel(interLabel);\n+            child = child.getNext();\n+            generateIfJump(child, node, trueLabel, falseLabel);\n+            break;\n+          }\n+\n+          case Token.IN:\n+          case Token.INSTANCEOF:\n+          case Token.LE:\n+          case Token.LT:\n+          case Token.GE:\n+          case Token.GT:\n+            visitIfJumpRelOp(node, child, trueLabel, falseLabel);\n+            break;\n+\n+          case Token.EQ:\n+          case Token.NE:\n+          case Token.SHEQ:\n+          case Token.SHNE:\n+            visitIfJumpEqOp(node, child, trueLabel, falseLabel);\n+            break;\n+\n+          default:\n+            // Generate generic code for non-optimized jump\n+            generateExpression(node, parent);\n+            addScriptRuntimeInvoke(\"toBoolean\", \"(Ljava/lang/Object;)Z\");\n+            cfw.add(ByteCode.IFNE, trueLabel);\n+            cfw.add(ByteCode.GOTO, falseLabel);\n+        }\n+    }\n+\n+    private void visitFunction(OptFunctionNode ofn, int functionType)\n+    {\n+        int fnIndex = codegen.getIndex(ofn.fnode);\n+        cfw.add(ByteCode.NEW, codegen.mainClassName);\n+        // Call function constructor\n+        cfw.add(ByteCode.DUP);\n+        cfw.addALoad(variableObjectLocal);\n+        cfw.addALoad(contextLocal);           // load 'cx'\n+        cfw.addPush(fnIndex);\n+        cfw.addInvoke(ByteCode.INVOKESPECIAL, codegen.mainClassName,\n+                      \"<init>\", Codegen.FUNCTION_CONSTRUCTOR_SIGNATURE);\n+\n+        // Init mainScript field;\n+        cfw.add(ByteCode.DUP);\n+        if (isTopLevel) {\n+            cfw.add(ByteCode.ALOAD_0);\n+        } else {\n+            cfw.add(ByteCode.ALOAD_0);\n+            cfw.add(ByteCode.GETFIELD,\n+                    codegen.mainClassName,\n+                    Codegen.DIRECT_CALL_PARENT_FIELD,\n+                    codegen.mainClassSignature);\n+        }\n+        cfw.add(ByteCode.PUTFIELD,\n+                codegen.mainClassName,\n+                Codegen.DIRECT_CALL_PARENT_FIELD,\n+                codegen.mainClassSignature);\n+\n+        int directTargetIndex = ofn.getDirectTargetIndex();\n+        if (directTargetIndex >= 0) {\n+            cfw.add(ByteCode.DUP);\n+            if (isTopLevel) {\n+                cfw.add(ByteCode.ALOAD_0);\n+            } else {\n+                cfw.add(ByteCode.ALOAD_0);\n+                cfw.add(ByteCode.GETFIELD,\n+                        codegen.mainClassName,\n+                        Codegen.DIRECT_CALL_PARENT_FIELD,\n+                        codegen.mainClassSignature);\n+            }\n+            cfw.add(ByteCode.SWAP);\n+            cfw.add(ByteCode.PUTFIELD,\n+                    codegen.mainClassName,\n+                    Codegen.getDirectTargetFieldName(directTargetIndex),\n+                    codegen.mainClassSignature);\n+        }\n+\n+        if (functionType == FunctionNode.FUNCTION_EXPRESSION) {\n+            // Leave closure object on stack and do not pass it to\n+            // initFunction which suppose to connect statements to scope\n+            return;\n+        }\n+        cfw.addPush(functionType);\n+        cfw.addALoad(variableObjectLocal);\n+        cfw.addALoad(contextLocal);           // load 'cx'\n+        addOptRuntimeInvoke(\"initFunction\",\n+                            \"(Lorg/mozilla/javascript/NativeFunction;\"\n+                            +\"I\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\"Lorg/mozilla/javascript/Context;\"\n+                            +\")V\");\n+    }\n+\n+    private int getTargetLabel(Node target)\n+    {\n+        int labelId = target.labelId();\n+        if (labelId == -1) {\n+            labelId = cfw.acquireLabel();\n+            target.labelId(labelId);\n+        }\n+        return labelId;\n+    }\n+\n+    private void visitGoto(Jump node, int type, Node child)\n+    {\n+        Node target = node.target;\n+        if (type == Token.IFEQ || type == Token.IFNE) {\n+            if (child == null) throw Codegen.badTree();\n+            int targetLabel = getTargetLabel(target);\n+            int fallThruLabel = cfw.acquireLabel();\n+            if (type == Token.IFEQ)\n+                generateIfJump(child, node, targetLabel, fallThruLabel);\n+            else\n+                generateIfJump(child, node, fallThruLabel, targetLabel);\n+            cfw.markLabel(fallThruLabel);\n+        } else {\n+            if (type == Token.JSR) {\n+                if (isGenerator) {\n+                    addGotoWithReturn(target);\n+                } else {\n+                    addGoto(target, ByteCode.JSR);\n+                }\n+            } else {\n+                addGoto(target, ByteCode.GOTO);\n+            }\n+        }\n+    }\n+\n+    private void addGotoWithReturn(Node target) {\n+        FinallyReturnPoint ret = finallys.get(target);\n+        cfw.addLoadConstant(ret.jsrPoints.size());\n+        addGoto(target, ByteCode.GOTO);\n+        int retLabel = cfw.acquireLabel();\n+        cfw.markLabel(retLabel);\n+        ret.jsrPoints.add(Integer.valueOf(retLabel));\n+    }\n+\n+    private void visitArrayLiteral(Node node, Node child)\n+    {\n+        int count = 0;\n+        for (Node cursor = child; cursor != null; cursor = cursor.getNext()) {\n+            ++count;\n+        }\n+        // load array to store array literal objects\n+        addNewObjectArray(count);\n+        for (int i = 0; i != count; ++i) {\n+            cfw.add(ByteCode.DUP);\n+            cfw.addPush(i);\n+            generateExpression(child, node);\n+            cfw.add(ByteCode.AASTORE);\n+            child = child.getNext();\n+        }\n+        int[] skipIndexes = (int[])node.getProp(Node.SKIP_INDEXES_PROP);\n+        if (skipIndexes == null) {\n+            cfw.add(ByteCode.ACONST_NULL);\n+            cfw.add(ByteCode.ICONST_0);\n+        } else {\n+            cfw.addPush(OptRuntime.encodeIntArray(skipIndexes));\n+            cfw.addPush(skipIndexes.length);\n+        }\n+        cfw.addALoad(contextLocal);\n+        cfw.addALoad(variableObjectLocal);\n+        addOptRuntimeInvoke(\"newArrayLiteral\",\n+             \"([Ljava/lang/Object;\"\n+             +\"Ljava/lang/String;\"\n+             +\"I\"\n+             +\"Lorg/mozilla/javascript/Context;\"\n+             +\"Lorg/mozilla/javascript/Scriptable;\"\n+             +\")Lorg/mozilla/javascript/Scriptable;\");\n+    }\n+\n+    private void visitObjectLiteral(Node node, Node child)\n+    {\n+        Object[] properties = (Object[])node.getProp(Node.OBJECT_IDS_PROP);\n+        int count = properties.length;\n+\n+        // load array with property ids\n+        addNewObjectArray(count);\n+        for (int i = 0; i != count; ++i) {\n+            cfw.add(ByteCode.DUP);\n+            cfw.addPush(i);\n+            Object id = properties[i];\n+            if (id instanceof String) {\n+                cfw.addPush((String)id);\n+            } else {\n+                cfw.addPush(((Integer)id).intValue());\n+                addScriptRuntimeInvoke(\"wrapInt\", \"(I)Ljava/lang/Integer;\");\n+            }\n+            cfw.add(ByteCode.AASTORE);\n+        }\n+        // load array with property values\n+        addNewObjectArray(count);\n+        Node child2 = child;\n+        for (int i = 0; i != count; ++i) {\n+            cfw.add(ByteCode.DUP);\n+            cfw.addPush(i);\n+            int childType = child.getType();\n+            if (childType == Token.GET) {\n+                generateExpression(child.getFirstChild(), node);\n+            } else if (childType == Token.SET) {\n+                generateExpression(child.getFirstChild(), node);\n+            } else {\n+                generateExpression(child, node);\n+            }\n+            cfw.add(ByteCode.AASTORE);\n+            child = child.getNext();\n+        }\n+        // load array with getterSetter values\n+        cfw.addPush(count);\n+        cfw.add(ByteCode.NEWARRAY, ByteCode.T_INT);\n+        for (int i = 0; i != count; ++i) {\n+            cfw.add(ByteCode.DUP);\n+            cfw.addPush(i);\n+            int childType = child2.getType();\n+            if (childType == Token.GET) {\n+                cfw.add(ByteCode.ICONST_M1);\n+            } else if (childType == Token.SET) {\n+                cfw.add(ByteCode.ICONST_1);\n+            } else {\n+                cfw.add(ByteCode.ICONST_0);\n+            }\n+            cfw.add(ByteCode.IASTORE);\n+            child2 = child2.getNext();\n+        }\n+\n+        cfw.addALoad(contextLocal);\n+        cfw.addALoad(variableObjectLocal);\n+        addScriptRuntimeInvoke(\"newObjectLiteral\",\n+             \"([Ljava/lang/Object;\"\n+             +\"[Ljava/lang/Object;\"\n+             +\"[I\"\n+             +\"Lorg/mozilla/javascript/Context;\"\n+             +\"Lorg/mozilla/javascript/Scriptable;\"\n+             +\")Lorg/mozilla/javascript/Scriptable;\");\n+    }\n+\n+    private void visitSpecialCall(Node node, int type, int specialType,\n+                                  Node child)\n+    {\n+        cfw.addALoad(contextLocal);\n+\n+        if (type == Token.NEW) {\n+            generateExpression(child, node);\n+            // stack: ... cx functionObj\n+        } else {\n+            generateFunctionAndThisObj(child, node);\n+            // stack: ... cx functionObj thisObj\n+        }\n+        child = child.getNext();\n+\n+        generateCallArgArray(node, child, false);\n+\n+        String methodName;\n+        String callSignature;\n+\n+        if (type == Token.NEW) {\n+            methodName = \"newObjectSpecial\";\n+            callSignature = \"(Lorg/mozilla/javascript/Context;\"\n+                            +\"Ljava/lang/Object;\"\n+                            +\"[Ljava/lang/Object;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\"I\" // call type\n+                            +\")Ljava/lang/Object;\";\n+            cfw.addALoad(variableObjectLocal);\n+            cfw.addALoad(thisObjLocal);\n+            cfw.addPush(specialType);\n+        } else {\n+            methodName = \"callSpecial\";\n+            callSignature = \"(Lorg/mozilla/javascript/Context;\"\n+                            +\"Lorg/mozilla/javascript/Callable;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\"[Ljava/lang/Object;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\"I\" // call type\n+                            +\"Ljava/lang/String;I\"  // filename, linenumber\n+                            +\")Ljava/lang/Object;\";\n+            cfw.addALoad(variableObjectLocal);\n+            cfw.addALoad(thisObjLocal);\n+            cfw.addPush(specialType);\n+            String sourceName = scriptOrFn.getSourceName();\n+            cfw.addPush(sourceName == null ? \"\" : sourceName);\n+            cfw.addPush(itsLineNumber);\n+        }\n+\n+        addOptRuntimeInvoke(methodName, callSignature);\n+    }\n+\n+    private void visitStandardCall(Node node, Node child)\n+    {\n+        if (node.getType() != Token.CALL) throw Codegen.badTree();\n+\n+        Node firstArgChild = child.getNext();\n+        int childType = child.getType();\n+\n+        String methodName;\n+        String signature;\n+\n+        if (firstArgChild == null) {\n+            if (childType == Token.NAME) {\n+                // name() call\n+                String name = child.getString();\n+                cfw.addPush(name);\n+                methodName = \"callName0\";\n+                signature = \"(Ljava/lang/String;\"\n+                            +\"Lorg/mozilla/javascript/Context;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\")Ljava/lang/Object;\";\n+            } else if (childType == Token.GETPROP) {\n+                // x.name() call\n+                Node propTarget = child.getFirstChild();\n+                generateExpression(propTarget, node);\n+                Node id = propTarget.getNext();\n+                String property = id.getString();\n+                cfw.addPush(property);\n+                methodName = \"callProp0\";\n+                signature = \"(Ljava/lang/Object;\"\n+                            +\"Ljava/lang/String;\"\n+                            +\"Lorg/mozilla/javascript/Context;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\")Ljava/lang/Object;\";\n+            } else if (childType == Token.GETPROPNOWARN) {\n+                throw Kit.codeBug();\n+            } else {\n+                generateFunctionAndThisObj(child, node);\n+                methodName = \"call0\";\n+                signature = \"(Lorg/mozilla/javascript/Callable;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\"Lorg/mozilla/javascript/Context;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\")Ljava/lang/Object;\";\n+            }\n+\n+        } else if (childType == Token.NAME) {\n+            // XXX: this optimization is only possible if name\n+            // resolution\n+            // is not affected by arguments evaluation and currently\n+            // there are no checks for it\n+            String name = child.getString();\n+            generateCallArgArray(node, firstArgChild, false);\n+            cfw.addPush(name);\n+            methodName = \"callName\";\n+            signature = \"([Ljava/lang/Object;\"\n+                        +\"Ljava/lang/String;\"\n+                        +\"Lorg/mozilla/javascript/Context;\"\n+                        +\"Lorg/mozilla/javascript/Scriptable;\"\n+                        +\")Ljava/lang/Object;\";\n+        } else {\n+            int argCount = 0;\n+            for (Node arg = firstArgChild; arg != null; arg = arg.getNext()) {\n+                ++argCount;\n+            }\n+            generateFunctionAndThisObj(child, node);\n+            // stack: ... functionObj thisObj\n+            if (argCount == 1) {\n+                generateExpression(firstArgChild, node);\n+                methodName = \"call1\";\n+                signature = \"(Lorg/mozilla/javascript/Callable;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\"Ljava/lang/Object;\"\n+                            +\"Lorg/mozilla/javascript/Context;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\")Ljava/lang/Object;\";\n+            } else if (argCount == 2) {\n+                generateExpression(firstArgChild, node);\n+                generateExpression(firstArgChild.getNext(), node);\n+                methodName = \"call2\";\n+                signature = \"(Lorg/mozilla/javascript/Callable;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\"Ljava/lang/Object;\"\n+                            +\"Ljava/lang/Object;\"\n+                            +\"Lorg/mozilla/javascript/Context;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\")Ljava/lang/Object;\";\n+            } else {\n+                generateCallArgArray(node, firstArgChild, false);\n+                methodName = \"callN\";\n+                signature = \"(Lorg/mozilla/javascript/Callable;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\"[Ljava/lang/Object;\"\n+                            +\"Lorg/mozilla/javascript/Context;\"\n+                            +\"Lorg/mozilla/javascript/Scriptable;\"\n+                            +\")Ljava/lang/Object;\";\n+            }\n+        }\n+\n+        cfw.addALoad(contextLocal);\n+        cfw.addALoad(variableObjectLocal);\n+        addOptRuntimeInvoke(methodName, signature);\n+    }\n+\n+    private void visitStandardNew(Node node, Node child)\n+    {\n+        if (node.getType() != Token.NEW) throw Codegen.badTree();\n+\n+        Node firstArgChild = child.getNext();\n+\n+        generateExpression(child, node);\n+        // stack: ... functionObj\n+        cfw.addALoad(contextLocal);\n+        cfw.addALoad(variableObjectLocal);\n+        // stack: ... functionObj cx scope\n+        generateCallArgArray(node, firstArgChild, false);\n+        addScriptRuntimeInvoke(\n+            \"newObject\",\n+            \"(Ljava/lang/Object;\"\n+            +\"Lorg/mozilla/javascript/Context;\"\n+            +\"Lorg/mozilla/javascript/Scriptable;\"\n+            +\"[Ljava/lang/Object;\"\n+            +\")Lorg/mozilla/javascript/Scriptable;\");\n+    }\n+\n+    private void visitOptimizedCall(Node node, OptFunctionNode target,\n+                                    int type, Node child)\n+    {\n+        Node firstArgChild = child.getNext();\n+\n+        short thisObjLocal = 0;\n+        if (type == Token.NEW) {\n+            generateExpression(child, node);\n+        } else {\n+            generateFunctionAndThisObj(child, node);\n+            thisObjLocal = getNewWordLocal();\n+            cfw.addAStore(thisObjLocal);\n+        }\n+        // stack: ... functionObj\n+\n+        int beyond = cfw.acquireLabel();\n+\n+        int directTargetIndex = target.getDirectTargetIndex();\n+        if (isTopLevel) {\n+            cfw.add(ByteCode.ALOAD_0);\n+        } else {\n+            cfw.add(ByteCode.ALOAD_0);\n+            cfw.add(ByteCode.GETFIELD, codegen.mainClassName,\n+                    Codegen.DIRECT_CALL_PARENT_FIELD,\n+                    codegen.mainClassSignature);\n+        }\n+        cfw.add(ByteCode.GETFIELD, codegen.mainClassName,\n+                Codegen.getDirectTargetFieldName(directTargetIndex),\n+                codegen.mainClassSignature);\n+\n+        cfw.add(ByteCode.DUP2);\n+        // stack: ... functionObj directFunct functionObj directFunct\n+\n+        int regularCall = cfw.acquireLabel();\n+        cfw.add(ByteCode.IF_ACMPNE, regularCall);\n+\n+        // stack: ... functionObj directFunct\n+        short stackHeight = cfw.getStackTop();\n+        cfw.add(ByteCode.SWAP);\n+        cfw.add(ByteCode.POP);\n+        // stack: ... directFunct\n+        if (compilerEnv.isUseDynamicScope()) {\n+            cfw.addALoad(contextLocal);\n+            cfw.addALoad(variableObjectLocal);\n+        } else {\n+            cfw.add(ByteCode.DUP);\n+            // stack: ... directFunct directFunct\n+            cfw.addInvoke(ByteCode.INVOKEINTERFACE,\n+                          \"org/mozilla/javascript/Scriptable\",\n+                          \"getParentScope\",\n+                          \"()Lorg/mozilla/javascript/Scriptable;\");\n+            // stack: ... directFunct scope\n+            cfw.addALoad(contextLocal);\n+            // stack: ... directFunct scope cx\n+            cfw.add(ByteCode.SWAP);\n+        }\n+        // stack: ... directFunc cx scope\n+\n+        if (type == Token.NEW) {\n+            cfw.add(ByteCode.ACONST_NULL);\n+        } else {\n+            cfw.addALoad(thisObjLocal);\n+        }\n+        // stack: ... directFunc cx scope thisObj\n+/*\n+Remember that directCall parameters are paired in 1 aReg and 1 dReg\n+If the argument is an incoming arg, just pass the orginal pair thru.\n+Else, if the argument is known to be typed 'Number', pass Void.TYPE\n+in the aReg and the number is the dReg\n+Else pass the JS object in the aReg and 0.0 in the dReg.\n+*/\n+        Node argChild = firstArgChild;\n+        while (argChild != null) {\n+            int dcp_register = nodeIsDirectCallParameter(argChild);\n+            if (dcp_register >= 0) {\n+                cfw.addALoad(dcp_register);\n+                cfw.addDLoad(dcp_register + 1);\n+            } else if (argChild.getIntProp(Node.ISNUMBER_PROP, -1)\n+                       == Node.BOTH)\n+            {\n+                cfw.add(ByteCode.GETSTATIC,\n+                        \"java/lang/Void\",\n+                        \"TYPE\",\n+                        \"Ljava/lang/Class;\");\n+                generateExpression(argChild, node);\n+            } else {\n+                generateExpression(argChild, node);\n+                cfw.addPush(0.0);\n+            }\n+            argChild = argChild.getNext();\n+        }\n+\n+        cfw.add(ByteCode.GETSTATIC,\n+                \"org/mozilla/javascript/ScriptRuntime\",\n+                \"emptyArgs\", \"[Ljava/lang/Object;\");\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      codegen.mainClassName,\n+                      (type == Token.NEW)\n+                          ? codegen.getDirectCtorName(target.fnode)\n+                          : codegen.getBodyMethodName(target.fnode),\n+                      codegen.getBodyMethodSignature(target.fnode));\n+\n+        cfw.add(ByteCode.GOTO, beyond);\n+\n+        cfw.markLabel(regularCall, stackHeight);\n+        // stack: ... functionObj directFunct\n+        cfw.add(ByteCode.POP);\n+        cfw.addALoad(contextLocal);\n+        cfw.addALoad(variableObjectLocal);\n+        // stack: ... functionObj cx scope\n+        if (type != Token.NEW) {\n+            cfw.addALoad(thisObjLocal);\n+            releaseWordLocal(thisObjLocal);\n+            // stack: ... functionObj cx scope thisObj\n+        }\n+        // XXX: this will generate code for the child array the second time,\n+        // so expression code generation better not to alter tree structure...\n+        generateCallArgArray(node, firstArgChild, true);\n+\n+        if (type == Token.NEW) {\n+            addScriptRuntimeInvoke(\n+                \"newObject\",\n+                \"(Ljava/lang/Object;\"\n+                +\"Lorg/mozilla/javascript/Context;\"\n+                +\"Lorg/mozilla/javascript/Scriptable;\"\n+                +\"[Ljava/lang/Object;\"\n+                +\")Lorg/mozilla/javascript/Scriptable;\");\n+        } else {\n+            cfw.addInvoke(ByteCode.INVOKEINTERFACE,\n+                \"org/mozilla/javascript/Callable\",\n+                \"call\",\n+                \"(Lorg/mozilla/javascript/Context;\"\n+                +\"Lorg/mozilla/javascript/Scriptable;\"\n+                +\"Lorg/mozilla/javascript/Scriptable;\"\n+                +\"[Ljava/lang/Object;\"\n+                +\")Ljava/lang/Object;\");\n+        }\n+\n+        cfw.markLabel(beyond);\n+    }\n+\n+    private void generateCallArgArray(Node node, Node argChild, boolean directCall)\n+    {\n+        int argCount = 0;\n+        for (Node child = argChild; child != null; child = child.getNext()) {\n+            ++argCount;\n+        }\n+        // load array object to set arguments\n+        if (argCount == 1 && itsOneArgArray >= 0) {\n+            cfw.addALoad(itsOneArgArray);\n+        } else {\n+            addNewObjectArray(argCount);\n+        }\n+        // Copy arguments into it\n+        for (int i = 0; i != argCount; ++i) {\n+            // If we are compiling a generator an argument could be the result\n+            // of a yield. In that case we will have an immediate on the stack\n+            // which we need to avoid\n+            if (!isGenerator) {\n+                cfw.add(ByteCode.DUP);\n+                cfw.addPush(i);\n+            }\n+\n+            if (!directCall) {\n+                generateExpression(argChild, node);\n+            } else {\n+                // If this has also been a directCall sequence, the Number\n+                // flag will have remained set for any parameter so that\n+                // the values could be copied directly into the outgoing\n+                // args. Here we want to force it to be treated as not in\n+                // a Number context, so we set the flag off.\n+                int dcp_register = nodeIsDirectCallParameter(argChild);\n+                if (dcp_register >= 0) {\n+                    dcpLoadAsObject(dcp_register);\n+                } else {\n+                    generateExpression(argChild, node);\n+                    int childNumberFlag\n+                            = argChild.getIntProp(Node.ISNUMBER_PROP, -1);\n+                    if (childNumberFlag == Node.BOTH) {\n+                        addDoubleWrap();\n+                    }\n+                }\n+            }\n+\n+            // When compiling generators, any argument to a method may be a\n+            // yield expression. Hence we compile the argument first and then\n+            // load the argument index and assign the value to the args array.\n+            if (isGenerator) {\n+                short tempLocal = getNewWordLocal();\n+                cfw.addAStore(tempLocal);\n+                cfw.add(ByteCode.CHECKCAST, \"[Ljava/lang/Object;\");\n+                cfw.add(ByteCode.DUP);\n+                cfw.addPush(i);\n+                cfw.addALoad(tempLocal);\n+                releaseWordLocal(tempLocal);\n+            }\n+\n+            cfw.add(ByteCode.AASTORE);\n+\n+            argChild = argChild.getNext();\n+        }\n+    }\n+\n+    private void generateFunctionAndThisObj(Node node, Node parent)\n+    {\n+        // Place on stack (function object, function this) pair\n+        int type = node.getType();\n+        switch (node.getType()) {\n+          case Token.GETPROPNOWARN:\n+            throw Kit.codeBug();\n+\n+          case Token.GETPROP:\n+          case Token.GETELEM: {\n+            Node target = node.getFirstChild();\n+            generateExpression(target, node);\n+            Node id = target.getNext();\n+            if (type == Token.GETPROP) {\n+                String property = id.getString();\n+                cfw.addPush(property);\n+                cfw.addALoad(contextLocal);\n+                cfw.addALoad(variableObjectLocal);\n+                addScriptRuntimeInvoke(\n+                    \"getPropFunctionAndThis\",\n+                    \"(Ljava/lang/Object;\"\n+                    +\"Ljava/lang/String;\"\n+                    +\"Lorg/mozilla/javascript/Context;\"\n+                    +\"Lorg/mozilla/javascript/Scriptable;\"\n+                    +\")Lorg/mozilla/javascript/Callable;\");\n+            } else {\n+                // Optimizer do not optimize this case for now\n+                if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1)\n+                    throw Codegen.badTree();\n+                generateExpression(id, node);  // id\n+                cfw.addALoad(contextLocal);\n+                addScriptRuntimeInvoke(\n+                    \"getElemFunctionAndThis\",\n+                    \"(Ljava/lang/Object;\"\n+                    +\"Ljava/lang/Object;\"\n+                    +\"Lorg/mozilla/javascript/Context;\"\n+                    +\")Lorg/mozilla/javascript/Callable;\");\n+            }\n+            break;\n+          }\n+\n+          case Token.NAME: {\n+            String name = node.getString();\n+            cfw.addPush(name);\n+            cfw.addALoad(contextLocal);\n+            cfw.addALoad(variableObjectLocal);\n+            addScriptRuntimeInvoke(\n+                \"getNameFunctionAndThis\",\n+                \"(Ljava/lang/String;\"\n+                +\"Lorg/mozilla/javascript/Context;\"\n+                +\"Lorg/mozilla/javascript/Scriptable;\"\n+                +\")Lorg/mozilla/javascript/Callable;\");\n+            break;\n+          }\n+\n+          default: // including GETVAR\n+            generateExpression(node, parent);\n+            cfw.addALoad(contextLocal);\n+            addScriptRuntimeInvoke(\n+                \"getValueFunctionAndThis\",\n+                \"(Ljava/lang/Object;\"\n+                +\"Lorg/mozilla/javascript/Context;\"\n+                +\")Lorg/mozilla/javascript/Callable;\");\n+            break;\n+        }\n+        // Get thisObj prepared by get(Name|Prop|Elem|Value)FunctionAndThis\n+        cfw.addALoad(contextLocal);\n+        addScriptRuntimeInvoke(\n+            \"lastStoredScriptable\",\n+            \"(Lorg/mozilla/javascript/Context;\"\n+            +\")Lorg/mozilla/javascript/Scriptable;\");\n+    }\n+\n+    private void updateLineNumber(Node node)\n+    {\n+        itsLineNumber = node.getLineno();\n+        if (itsLineNumber == -1)\n+            return;\n+        cfw.addLineNumberEntry((short)itsLineNumber);\n+    }\n+\n+    private void visitTryCatchFinally(Jump node, Node child)\n+    {\n+        /* Save the variable object, in case there are with statements\n+         * enclosed by the try block and we catch some exception.\n+         * We'll restore it for the catch block so that catch block\n+         * statements get the right scope.\n+         */\n+\n+        // OPT we only need to do this if there are enclosed WITH\n+        // statements; could statically check and omit this if there aren't any.\n+\n+        // XXX OPT Maybe instead do syntactic transforms to associate\n+        // each 'with' with a try/finally block that does the exitwith.\n+\n+        short savedVariableObject = getNewWordLocal();\n+        cfw.addALoad(variableObjectLocal);\n+        cfw.addAStore(savedVariableObject);\n+\n+        /*\n+         * Generate the code for the tree; most of the work is done in IRFactory\n+         * and NodeTransformer;  Codegen just adds the java handlers for the\n+         * javascript catch and finally clauses.  */\n+\n+        int startLabel = cfw.acquireLabel();\n+        cfw.markLabel(startLabel, (short)0);\n+\n+        Node catchTarget = node.target;\n+        Node finallyTarget = node.getFinally();\n+\n+        // create a table for the equivalent of JSR returns\n+        if (isGenerator && finallyTarget != null) {\n+            FinallyReturnPoint ret = new FinallyReturnPoint();\n+            if (finallys == null) {\n+                finallys = new HashMap<Node,FinallyReturnPoint>();\n+            }\n+            // add the finally target to hashtable\n+            finallys.put(finallyTarget, ret);\n+            // add the finally node as well to the hash table\n+            finallys.put(finallyTarget.getNext(), ret);\n+        }\n+\n+        while (child != null) {\n+            generateStatement(child);\n+            child = child.getNext();\n+        }\n+\n+        // control flow skips the handlers\n+        int realEnd = cfw.acquireLabel();\n+        cfw.add(ByteCode.GOTO, realEnd);\n+\n+        int exceptionLocal = getLocalBlockRegister(node);\n+        // javascript handler; unwrap exception and GOTO to javascript\n+        // catch area.\n+        if (catchTarget != null) {\n+            // get the label to goto\n+            int catchLabel = catchTarget.labelId();\n+\n+            generateCatchBlock(JAVASCRIPT_EXCEPTION, savedVariableObject,\n+                               catchLabel, startLabel, exceptionLocal);\n+            /*\n+             * catch WrappedExceptions, see if they are wrapped\n+             * JavaScriptExceptions. Otherwise, rethrow.\n+             */\n+            generateCatchBlock(EVALUATOR_EXCEPTION, savedVariableObject,\n+                               catchLabel, startLabel, exceptionLocal);\n+\n+            /*\n+                we also need to catch EcmaErrors and feed the\n+                associated error object to the handler\n+            */\n+            generateCatchBlock(ECMAERROR_EXCEPTION, savedVariableObject,\n+                               catchLabel, startLabel, exceptionLocal);\n+\n+            Context cx = Context.getCurrentContext();\n+            if (cx != null &&\n+                cx.hasFeature(Context.FEATURE_ENHANCED_JAVA_ACCESS))\n+            {\n+                generateCatchBlock(THROWABLE_EXCEPTION, savedVariableObject,\n+                                   catchLabel, startLabel, exceptionLocal);\n+            }\n+        }\n+\n+        // finally handler; catch all exceptions, store to a local; JSR to\n+        // the finally, then re-throw.\n+        if (finallyTarget != null) {\n+            int finallyHandler = cfw.acquireLabel();\n+            cfw.markHandler(finallyHandler);\n+            cfw.addAStore(exceptionLocal);\n+\n+            // reset the variable object local\n+            cfw.addALoad(savedVariableObject);\n+            cfw.addAStore(variableObjectLocal);\n+\n+            // get the label to JSR to\n+            int finallyLabel = finallyTarget.labelId();\n+            if (isGenerator)\n+                addGotoWithReturn(finallyTarget);\n+            else\n+                cfw.add(ByteCode.JSR, finallyLabel);\n+\n+            // rethrow\n+            cfw.addALoad(exceptionLocal);\n+            if (isGenerator)\n+                cfw.add(ByteCode.CHECKCAST, \"java/lang/Throwable\");\n+            cfw.add(ByteCode.ATHROW);\n+\n+            // mark the handler\n+            cfw.addExceptionHandler(startLabel, finallyLabel,\n+                                    finallyHandler, null); // catch any\n+        }\n+        releaseWordLocal(savedVariableObject);\n+        cfw.markLabel(realEnd);\n+    }\n+\n+    private static final int JAVASCRIPT_EXCEPTION  = 0;\n+    private static final int EVALUATOR_EXCEPTION   = 1;\n+    private static final int ECMAERROR_EXCEPTION   = 2;\n+    private static final int THROWABLE_EXCEPTION   = 3;\n+\n+    private void generateCatchBlock(int exceptionType,\n+                                    short savedVariableObject,\n+                                    int catchLabel, int startLabel,\n+                                    int exceptionLocal)\n+    {\n+        int handler = cfw.acquireLabel();\n+        cfw.markHandler(handler);\n+\n+        // MS JVM gets cranky if the exception object is left on the stack\n+        cfw.addAStore(exceptionLocal);\n+\n+        // reset the variable object local\n+        cfw.addALoad(savedVariableObject);\n+        cfw.addAStore(variableObjectLocal);\n+\n+        String exceptionName;\n+        if (exceptionType == JAVASCRIPT_EXCEPTION) {\n+            exceptionName = \"org/mozilla/javascript/JavaScriptException\";\n+        } else if (exceptionType == EVALUATOR_EXCEPTION) {\n+            exceptionName = \"org/mozilla/javascript/EvaluatorException\";\n+        } else if (exceptionType == ECMAERROR_EXCEPTION) {\n+            exceptionName = \"org/mozilla/javascript/EcmaError\";\n+        } else if (exceptionType == THROWABLE_EXCEPTION) {\n+            exceptionName = \"java/lang/Throwable\";\n+        } else {\n+            throw Kit.codeBug();\n+        }\n+\n+        // mark the handler\n+        cfw.addExceptionHandler(startLabel, catchLabel, handler,\n+                                exceptionName);\n+\n+        cfw.add(ByteCode.GOTO, catchLabel);\n+    }\n+\n+\n+    private boolean generateSaveLocals(Node node)\n+    {\n+        int count = 0;\n+        for (int i = 0; i < firstFreeLocal; i++) {\n+            if (locals[i] != 0)\n+                count++;\n+        }\n+\n+        if (count == 0) {\n+            ((FunctionNode)scriptOrFn).addLiveLocals(node, null);\n+            return false;\n+        }\n+\n+        // calculate the max locals\n+        maxLocals = maxLocals > count ? maxLocals : count;\n+\n+        // create a locals list\n+        int[] ls = new int[count];\n+        int s = 0;\n+        for (int i = 0; i < firstFreeLocal; i++) {\n+            if (locals[i] != 0) {\n+                ls[s] = i;\n+                s++;\n+            }\n+        }\n+\n+        // save the locals\n+        ((FunctionNode)scriptOrFn).addLiveLocals(node, ls);\n+\n+        // save locals\n+        generateGetGeneratorLocalsState();\n+        for (int i = 0; i < count; i++) {\n+            cfw.add(ByteCode.DUP);\n+            cfw.addLoadConstant(i);\n+            cfw.addALoad(ls[i]);\n+            cfw.add(ByteCode.AASTORE);\n+        }\n+        // pop the array off the stack\n+        cfw.add(ByteCode.POP);\n+\n+        return true;\n+    }\n+\n+    private void visitSwitch(Jump switchNode, Node child)\n+    {\n+        // See comments in IRFactory.createSwitch() for description\n+        // of SWITCH node\n+\n+        generateExpression(child, switchNode);\n+        // save selector value\n+        short selector = getNewWordLocal();\n+        cfw.addAStore(selector);\n+\n+        for (Jump caseNode = (Jump)child.getNext();\n+             caseNode != null;\n+             caseNode = (Jump)caseNode.getNext())\n+        {\n+            if (caseNode.getType() != Token.CASE)\n+                throw Codegen.badTree();\n+            Node test = caseNode.getFirstChild();\n+            generateExpression(test, caseNode);\n+            cfw.addALoad(selector);\n+            addScriptRuntimeInvoke(\"shallowEq\",\n+                                   \"(Ljava/lang/Object;\"\n+                                   +\"Ljava/lang/Object;\"\n+                                   +\")Z\");\n+            addGoto(caseNode.target, ByteCode.IFNE);\n+        }\n+        releaseWordLocal(selector);\n+    }\n+\n+    private void visitTypeofname(Node node)\n+    {\n+        if (hasVarsInRegs) {\n+            int varIndex = fnCurrent.fnode.getIndexForNameNode(node);\n+            if (varIndex >= 0) {\n+                if (fnCurrent.isNumberVar(varIndex)) {\n+                    cfw.addPush(\"number\");\n+                } else if (varIsDirectCallParameter(varIndex)) {\n+                    int dcp_register = varRegisters[varIndex];\n+                    cfw.addALoad(dcp_register);\n+                    cfw.add(ByteCode.GETSTATIC, \"java/lang/Void\", \"TYPE\",\n+                            \"Ljava/lang/Class;\");\n+                    int isNumberLabel = cfw.acquireLabel();\n+                    cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);\n+                    short stack = cfw.getStackTop();\n+                    cfw.addALoad(dcp_register);\n+                    addScriptRuntimeInvoke(\"typeof\",\n+                                           \"(Ljava/lang/Object;\"\n+                                           +\")Ljava/lang/String;\");\n+                    int beyond = cfw.acquireLabel();\n+                    cfw.add(ByteCode.GOTO, beyond);\n+                    cfw.markLabel(isNumberLabel, stack);\n+                    cfw.addPush(\"number\");\n+                    cfw.markLabel(beyond);\n+                } else {\n+                    cfw.addALoad(varRegisters[varIndex]);\n+                    addScriptRuntimeInvoke(\"typeof\",\n+                                           \"(Ljava/lang/Object;\"\n+                                           +\")Ljava/lang/String;\");\n+                }\n+                return;\n+            }\n+        }\n+        cfw.addALoad(variableObjectLocal);\n+        cfw.addPush(node.getString());\n+        addScriptRuntimeInvoke(\"typeofName\",\n+                               \"(Lorg/mozilla/javascript/Scriptable;\"\n+                               +\"Ljava/lang/String;\"\n+                               +\")Ljava/lang/String;\");\n+    }\n+\n+    /**\n+     * Save the current code offset. This saved code offset is used to\n+     * compute instruction counts in subsequent calls to\n+     * {@link #addInstructionCount()}.\n+     */\n+    private void saveCurrentCodeOffset() {\n+        savedCodeOffset = cfw.getCurrentCodeOffset();\n+    }\n+\n+    /**\n+     * Generate calls to ScriptRuntime.addInstructionCount to keep track of\n+     * executed instructions and call <code>observeInstructionCount()</code>\n+     * if a threshold is exceeded.<br>\n+     * Calculates the count from getCurrentCodeOffset - savedCodeOffset\n+     */\n+    private void addInstructionCount() {\n+        int count = cfw.getCurrentCodeOffset() - savedCodeOffset;\n+        if (count == 0)\n+            return;\n+        addInstructionCount(count);\n+    }\n+\n+    /**\n+     * Generate calls to ScriptRuntime.addInstructionCount to keep track of\n+     * executed instructions and call <code>observeInstructionCount()</code>\n+     * if a threshold is exceeded.<br>\n+     * Takes the count as a parameter - used to add monitoring to loops and\n+     * other blocks that don't have any ops - this allows\n+     * for monitoring/killing of while(true) loops and such.\n+     */\n+    private void addInstructionCount(int count) {\n+        cfw.addALoad(contextLocal);\n+        cfw.addPush(count);\n+        addScriptRuntimeInvoke(\"addInstructionCount\",\n+                \"(Lorg/mozilla/javascript/Context;\"\n+                +\"I)V\");\n+    }\n+\n+    private void visitIncDec(Node node)\n+    {\n+        int incrDecrMask = node.getExistingIntProp(Node.INCRDECR_PROP);\n+        Node child = node.getFirstChild();\n+        switch (child.getType()) {\n+          case Token.GETVAR:\n+            if (!hasVarsInRegs) Kit.codeBug();\n+            if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {\n+                boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);\n+                int varIndex = fnCurrent.getVarIndex(child);\n+                short reg = varRegisters[varIndex];\n+                int offset = varIsDirectCallParameter(varIndex) ? 1 : 0;\n+                cfw.addDLoad(reg + offset);\n+                if (post) {\n+                    cfw.add(ByteCode.DUP2);\n+                }\n+                cfw.addPush(1.0);\n+                if ((incrDecrMask & Node.DECR_FLAG) == 0) {\n+                    cfw.add(ByteCode.DADD);\n+                } else {\n+                    cfw.add(ByteCode.DSUB);\n+                }\n+                if (!post) {\n+                    cfw.add(ByteCode.DUP2);\n+                }\n+                cfw.addDStore(reg + offset);\n+            } else {\n+                boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);\n+                int varIndex = fnCurrent.getVarIndex(child);\n+                short reg = varRegisters[varIndex];\n+                cfw.addALoad(reg);\n+                if (post) {\n+                    cfw.add(ByteCode.DUP);\n+                }\n+                addObjectToDouble();\n+                cfw.addPush(1.0);\n+                if ((incrDecrMask & Node.DECR_FLAG) == 0) {\n+                    cfw.add(ByteCode.DADD);\n+                } else {\n+                    cfw.add(ByteCode.DSUB);\n+                }\n+                addDoubleWrap();\n+                if (!post) {\n+                    cfw.add(ByteCode.DUP);\n+                }\n+                cfw.addAStore(reg);\n+                break;\n+            }\n+            break;\n+          case Token.NAME:\n+            cfw.addALoad(variableObjectLocal);\n+            cfw.addPush(child.getString());          // push name\n+            cfw.addALoad(contextLocal);\n+            cfw.addPush(incrDecrMask);\n+            addScriptRuntimeInvoke(\"nameIncrDecr\",\n+                \"(Lorg/mozilla/javascript/Scriptable;\"\n+                +\"Ljava/lang/String;\"\n+                +\"Lorg/mozilla/javascript/Context;\"\n+                +\"I)Ljava/lang/Object;\");\n+            break;\n+          case Token.GETPROPNOWARN:\n+            throw Kit.codeBug();\n+          case Token.GETPROP: {\n+            Node getPropChild = child.getFirstChild();\n+            generateExpression(getPropChild, node);\n+            generateExpression(getPropChild.getNext(), node);\n+            cfw.addALoad(contextLocal);\n+            cfw.addPush(incrDecrMask);\n+            addScriptRuntimeInvoke(\"propIncrDecr\",\n+                                   \"(Ljava/lang/Object;\"\n+                                   +\"Ljava/lang/String;\"\n+                                   +\"Lorg/mozilla/javascript/Context;\"\n+                                   +\"I)Ljava/lang/Object;\");\n+            break;\n+          }\n+          case Token.GETELEM: {\n+            Node elemChild = child.getFirstChild();\n+            generateExpression(elemChild, node);\n+            generateExpression(elemChild.getNext(), node);\n+            cfw.addALoad(contextLocal);\n+            cfw.addPush(incrDecrMask);\n+            if (elemChild.getNext().getIntProp(Node.ISNUMBER_PROP, -1) != -1) {\n+              addOptRuntimeInvoke(\"elemIncrDecr\",\n+                  \"(Ljava/lang/Object;\"\n+                  +\"D\"\n+                  +\"Lorg/mozilla/javascript/Context;\"\n+                  +\"I\"\n+                  +\")Ljava/lang/Object;\");\n+            } else {\n+              addScriptRuntimeInvoke(\"elemIncrDecr\",\n+                  \"(Ljava/lang/Object;\"\n+                  +\"Ljava/lang/Object;\"\n+                  +\"Lorg/mozilla/javascript/Context;\"\n+                  +\"I\"\n+                  +\")Ljava/lang/Object;\");\n+            }\n+            break;\n+          }\n+          case Token.GET_REF: {\n+            Node refChild = child.getFirstChild();\n+            generateExpression(refChild, node);\n+            cfw.addALoad(contextLocal);\n+            cfw.addPush(incrDecrMask);\n+            addScriptRuntimeInvoke(\n+                \"refIncrDecr\",\n+                \"(Lorg/mozilla/javascript/Ref;\"\n+                +\"Lorg/mozilla/javascript/Context;\"\n+                +\"I)Ljava/lang/Object;\");\n+            break;\n+          }\n+          default:\n+            Codegen.badTree();\n+        }\n+    }\n+\n+    private static boolean isArithmeticNode(Node node)\n+    {\n+        int type = node.getType();\n+        return (type == Token.SUB)\n+                  || (type == Token.MOD)\n+                        || (type == Token.DIV)\n+                              || (type == Token.MUL);\n+    }\n+\n+    private void visitArithmetic(Node node, int opCode, Node child,\n+                                 Node parent)\n+    {\n+        int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);\n+        if (childNumberFlag != -1) {\n+            generateExpression(child, node);\n+            generateExpression(child.getNext(), node);\n+            cfw.add(opCode);\n+        }\n+        else {\n+            boolean childOfArithmetic = isArithmeticNode(parent);\n+            generateExpression(child, node);\n+            if (!isArithmeticNode(child))\n+                addObjectToDouble();\n+            generateExpression(child.getNext(), node);\n+            if (!isArithmeticNode(child.getNext()))\n+                  addObjectToDouble();\n+            cfw.add(opCode);\n+            if (!childOfArithmetic) {\n+                addDoubleWrap();\n+            }\n+        }\n+    }\n+\n+    private void visitBitOp(Node node, int type, Node child)\n+    {\n+        int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);\n+        generateExpression(child, node);\n+\n+        // special-case URSH; work with the target arg as a long, so\n+        // that we can return a 32-bit unsigned value, and call\n+        // toUint32 instead of toInt32.\n+        if (type == Token.URSH) {\n+            addScriptRuntimeInvoke(\"toUint32\", \"(Ljava/lang/Object;)J\");\n+            generateExpression(child.getNext(), node);\n+            addScriptRuntimeInvoke(\"toInt32\", \"(Ljava/lang/Object;)I\");\n+            // Looks like we need to explicitly mask the shift to 5 bits -\n+            // LUSHR takes 6 bits.\n+            cfw.addPush(31);\n+            cfw.add(ByteCode.IAND);\n+            cfw.add(ByteCode.LUSHR);\n+            cfw.add(ByteCode.L2D);\n+            addDoubleWrap();\n+            return;\n+        }\n+        if (childNumberFlag == -1) {\n+            addScriptRuntimeInvoke(\"toInt32\", \"(Ljava/lang/Object;)I\");\n+            generateExpression(child.getNext(), node);\n+            addScriptRuntimeInvoke(\"toInt32\", \"(Ljava/lang/Object;)I\");\n+        }\n+        else {\n+            addScriptRuntimeInvoke(\"toInt32\", \"(D)I\");\n+            generateExpression(child.getNext(), node);\n+            addScriptRuntimeInvoke(\"toInt32\", \"(D)I\");\n+        }\n+        switch (type) {\n+          case Token.BITOR:\n+            cfw.add(ByteCode.IOR);\n+            break;\n+          case Token.BITXOR:\n+            cfw.add(ByteCode.IXOR);\n+            break;\n+          case Token.BITAND:\n+            cfw.add(ByteCode.IAND);\n+            break;\n+          case Token.RSH:\n+            cfw.add(ByteCode.ISHR);\n+            break;\n+          case Token.LSH:\n+            cfw.add(ByteCode.ISHL);\n+            break;\n+          default:\n+            throw Codegen.badTree();\n+        }\n+        cfw.add(ByteCode.I2D);\n+        if (childNumberFlag == -1) {\n+            addDoubleWrap();\n+        }\n+    }\n+\n+    private int nodeIsDirectCallParameter(Node node)\n+    {\n+        if (node.getType() == Token.GETVAR\n+            && inDirectCallFunction && !itsForcedObjectParameters)\n+        {\n+            int varIndex = fnCurrent.getVarIndex(node);\n+            if (fnCurrent.isParameter(varIndex)) {\n+                return varRegisters[varIndex];\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private boolean varIsDirectCallParameter(int varIndex)\n+    {\n+        return fnCurrent.isParameter(varIndex)\n+            && inDirectCallFunction && !itsForcedObjectParameters;\n+    }\n+\n+    private void genSimpleCompare(int type, int trueGOTO, int falseGOTO)\n+    {\n+        if (trueGOTO == -1) throw Codegen.badTree();\n+        switch (type) {\n+            case Token.LE :\n+                cfw.add(ByteCode.DCMPG);\n+                cfw.add(ByteCode.IFLE, trueGOTO);\n+                break;\n+            case Token.GE :\n+                cfw.add(ByteCode.DCMPL);\n+                cfw.add(ByteCode.IFGE, trueGOTO);\n+                break;\n+            case Token.LT :\n+                cfw.add(ByteCode.DCMPG);\n+                cfw.add(ByteCode.IFLT, trueGOTO);\n+                break;\n+            case Token.GT :\n+                cfw.add(ByteCode.DCMPL);\n+                cfw.add(ByteCode.IFGT, trueGOTO);\n+                break;\n+            default :\n+                throw Codegen.badTree();\n+\n+        }\n+        if (falseGOTO != -1)\n+            cfw.add(ByteCode.GOTO, falseGOTO);\n+    }\n+\n+    private void visitIfJumpRelOp(Node node, Node child,\n+                                  int trueGOTO, int falseGOTO)\n+    {\n+        if (trueGOTO == -1 || falseGOTO == -1) throw Codegen.badTree();\n+        int type = node.getType();\n+        Node rChild = child.getNext();\n+        if (type == Token.INSTANCEOF || type == Token.IN) {\n+            generateExpression(child, node);\n+            generateExpression(rChild, node);\n+            cfw.addALoad(contextLocal);\n+            addScriptRuntimeInvoke(\n+                (type == Token.INSTANCEOF) ? \"instanceOf\" : \"in\",\n+                \"(Ljava/lang/Object;\"\n+                +\"Ljava/lang/Object;\"\n+                +\"Lorg/mozilla/javascript/Context;\"\n+                +\")Z\");\n+            cfw.add(ByteCode.IFNE, trueGOTO);\n+            cfw.add(ByteCode.GOTO, falseGOTO);\n+            return;\n+        }\n+        int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);\n+        int left_dcp_register = nodeIsDirectCallParameter(child);\n+        int right_dcp_register = nodeIsDirectCallParameter(rChild);\n+        if (childNumberFlag != -1) {\n+            // Force numeric context on both parameters and optimize\n+            // direct call case as Optimizer currently does not handle it\n+\n+            if (childNumberFlag != Node.RIGHT) {\n+                // Left already has number content\n+                generateExpression(child, node);\n+            } else if (left_dcp_register != -1) {\n+                dcpLoadAsNumber(left_dcp_register);\n+            } else {\n+                generateExpression(child, node);\n+                addObjectToDouble();\n+            }\n+\n+            if (childNumberFlag != Node.LEFT) {\n+                // Right already has number content\n+                generateExpression(rChild, node);\n+            } else if (right_dcp_register != -1) {\n+                dcpLoadAsNumber(right_dcp_register);\n+            } else {\n+                generateExpression(rChild, node);\n+                addObjectToDouble();\n+            }\n+\n+            genSimpleCompare(type, trueGOTO, falseGOTO);\n+\n+        } else {\n+            if (left_dcp_register != -1 && right_dcp_register != -1) {\n+                // Generate code to dynamically check for number content\n+                // if both operands are dcp\n+                short stack = cfw.getStackTop();\n+                int leftIsNotNumber = cfw.acquireLabel();\n+                cfw.addALoad(left_dcp_register);\n+                cfw.add(ByteCode.GETSTATIC,\n+                        \"java/lang/Void\",\n+                        \"TYPE\",\n+                        \"Ljava/lang/Class;\");\n+                cfw.add(ByteCode.IF_ACMPNE, leftIsNotNumber);\n+                cfw.addDLoad(left_dcp_register + 1);\n+                dcpLoadAsNumber(right_dcp_register);\n+                genSimpleCompare(type, trueGOTO, falseGOTO);\n+                if (stack != cfw.getStackTop()) throw Codegen.badTree();\n+\n+                cfw.markLabel(leftIsNotNumber);\n+                int rightIsNotNumber = cfw.acquireLabel();\n+                cfw.addALoad(right_dcp_register);\n+                cfw.add(ByteCode.GETSTATIC,\n+                        \"java/lang/Void\",\n+                        \"TYPE\",\n+                        \"Ljava/lang/Class;\");\n+                cfw.add(ByteCode.IF_ACMPNE, rightIsNotNumber);\n+                cfw.addALoad(left_dcp_register);\n+                addObjectToDouble();\n+                cfw.addDLoad(right_dcp_register + 1);\n+                genSimpleCompare(type, trueGOTO, falseGOTO);\n+                if (stack != cfw.getStackTop()) throw Codegen.badTree();\n+\n+                cfw.markLabel(rightIsNotNumber);\n+                // Load both register as objects to call generic cmp_*\n+                cfw.addALoad(left_dcp_register);\n+                cfw.addALoad(right_dcp_register);\n+\n+            } else {\n+                generateExpression(child, node);\n+                generateExpression(rChild, node);\n+            }\n+\n+            if (type == Token.GE || type == Token.GT) {\n+                cfw.add(ByteCode.SWAP);\n+            }\n+            String routine = ((type == Token.LT)\n+                      || (type == Token.GT)) ? \"cmp_LT\" : \"cmp_LE\";\n+            addScriptRuntimeInvoke(routine,\n+                                   \"(Ljava/lang/Object;\"\n+                                   +\"Ljava/lang/Object;\"\n+                                   +\")Z\");\n+            cfw.add(ByteCode.IFNE, trueGOTO);\n+            cfw.add(ByteCode.GOTO, falseGOTO);\n+        }\n+    }\n+\n+    private void visitIfJumpEqOp(Node node, Node child,\n+                                 int trueGOTO, int falseGOTO)\n+    {\n+        if (trueGOTO == -1 || falseGOTO == -1) throw Codegen.badTree();\n+\n+        short stackInitial = cfw.getStackTop();\n+        int type = node.getType();\n+        Node rChild = child.getNext();\n+\n+        // Optimize if one of operands is null\n+        if (child.getType() == Token.NULL || rChild.getType() == Token.NULL) {\n+            // eq is symmetric in this case\n+            if (child.getType() == Token.NULL) {\n+                child = rChild;\n+            }\n+            generateExpression(child, node);\n+            if (type == Token.SHEQ || type == Token.SHNE) {\n+                int testCode = (type == Token.SHEQ)\n+                                ? ByteCode.IFNULL : ByteCode.IFNONNULL;\n+                cfw.add(testCode, trueGOTO);\n+            } else {\n+                if (type != Token.EQ) {\n+                    // swap false/true targets for !=\n+                    if (type != Token.NE) throw Codegen.badTree();\n+                    int tmp = trueGOTO;\n+                    trueGOTO = falseGOTO;\n+                    falseGOTO = tmp;\n+                }\n+                cfw.add(ByteCode.DUP);\n+                int undefCheckLabel = cfw.acquireLabel();\n+                cfw.add(ByteCode.IFNONNULL, undefCheckLabel);\n+                short stack = cfw.getStackTop();\n+                cfw.add(ByteCode.POP);\n+                cfw.add(ByteCode.GOTO, trueGOTO);\n+                cfw.markLabel(undefCheckLabel, stack);\n+                Codegen.pushUndefined(cfw);\n+                cfw.add(ByteCode.IF_ACMPEQ, trueGOTO);\n+            }\n+            cfw.add(ByteCode.GOTO, falseGOTO);\n+        } else {\n+            int child_dcp_register = nodeIsDirectCallParameter(child);\n+            if (child_dcp_register != -1\n+                && rChild.getType() == Token.TO_OBJECT)\n+            {\n+                Node convertChild = rChild.getFirstChild();\n+                if (convertChild.getType() == Token.NUMBER) {\n+                    cfw.addALoad(child_dcp_register);\n+                    cfw.add(ByteCode.GETSTATIC,\n+                            \"java/lang/Void\",\n+                            \"TYPE\",\n+                            \"Ljava/lang/Class;\");\n+                    int notNumbersLabel = cfw.acquireLabel();\n+                    cfw.add(ByteCode.IF_ACMPNE, notNumbersLabel);\n+                    cfw.addDLoad(child_dcp_register + 1);\n+                    cfw.addPush(convertChild.getDouble());\n+                    cfw.add(ByteCode.DCMPL);\n+                    if (type == Token.EQ)\n+                        cfw.add(ByteCode.IFEQ, trueGOTO);\n+                    else\n+                        cfw.add(ByteCode.IFNE, trueGOTO);\n+                    cfw.add(ByteCode.GOTO, falseGOTO);\n+                    cfw.markLabel(notNumbersLabel);\n+                    // fall thru into generic handling\n+                }\n+            }\n+\n+            generateExpression(child, node);\n+            generateExpression(rChild, node);\n+\n+            String name;\n+            int testCode;\n+            switch (type) {\n+              case Token.EQ:\n+                name = \"eq\";\n+                testCode = ByteCode.IFNE;\n+                break;\n+              case Token.NE:\n+                name = \"eq\";\n+                testCode = ByteCode.IFEQ;\n+                break;\n+              case Token.SHEQ:\n+                name = \"shallowEq\";\n+                testCode = ByteCode.IFNE;\n+                break;\n+              case Token.SHNE:\n+                name = \"shallowEq\";\n+                testCode = ByteCode.IFEQ;\n+                break;\n+              default:\n+                throw Codegen.badTree();\n+            }\n+            addScriptRuntimeInvoke(name,\n+                                   \"(Ljava/lang/Object;\"\n+                                   +\"Ljava/lang/Object;\"\n+                                   +\")Z\");\n+            cfw.add(testCode, trueGOTO);\n+            cfw.add(ByteCode.GOTO, falseGOTO);\n+        }\n+        if (stackInitial != cfw.getStackTop()) throw Codegen.badTree();\n+    }\n+\n+    private void visitSetName(Node node, Node child)\n+    {\n+        String name = node.getFirstChild().getString();\n+        while (child != null) {\n+            generateExpression(child, node);\n+            child = child.getNext();\n+        }\n+        cfw.addALoad(contextLocal);\n+        cfw.addALoad(variableObjectLocal);\n+        cfw.addPush(name);\n+        addScriptRuntimeInvoke(\n+            \"setName\",\n+            \"(Lorg/mozilla/javascript/Scriptable;\"\n+            +\"Ljava/lang/Object;\"\n+            +\"Lorg/mozilla/javascript/Context;\"\n+            +\"Lorg/mozilla/javascript/Scriptable;\"\n+            +\"Ljava/lang/String;\"\n+            +\")Ljava/lang/Object;\");\n+    }\n+\n+    private void visitStrictSetName(Node node, Node child)\n+    {\n+        String name = node.getFirstChild().getString();\n+        while (child != null) {\n+            generateExpression(child, node);\n+            child = child.getNext();\n+        }\n+        cfw.addALoad(contextLocal);\n+        cfw.addALoad(variableObjectLocal);\n+        cfw.addPush(name);\n+        addScriptRuntimeInvoke(\n+            \"strictSetName\",\n+            \"(Lorg/mozilla/javascript/Scriptable;\"\n+            +\"Ljava/lang/Object;\"\n+            +\"Lorg/mozilla/javascript/Context;\"\n+            +\"Lorg/mozilla/javascript/Scriptable;\"\n+            +\"Ljava/lang/String;\"\n+            +\")Ljava/lang/Object;\");\n+    }\n+\n+    private void visitSetConst(Node node, Node child)\n+    {\n+        String name = node.getFirstChild().getString();\n+        while (child != null) {\n+            generateExpression(child, node);\n+            child = child.getNext();\n+        }\n+        cfw.addALoad(contextLocal);\n+        cfw.addPush(name);\n+        addScriptRuntimeInvoke(\n+            \"setConst\",\n+            \"(Lorg/mozilla/javascript/Scriptable;\"\n+            +\"Ljava/lang/Object;\"\n+            +\"Lorg/mozilla/javascript/Context;\"\n+            +\"Ljava/lang/String;\"\n+            +\")Ljava/lang/Object;\");\n+    }\n+\n+    private void visitGetVar(Node node)\n+    {\n+        if (!hasVarsInRegs) Kit.codeBug();\n+        int varIndex = fnCurrent.getVarIndex(node);\n+        short reg = varRegisters[varIndex];\n+        if (varIsDirectCallParameter(varIndex)) {\n+            // Remember that here the isNumber flag means that we\n+            // want to use the incoming parameter in a Number\n+            // context, so test the object type and convert the\n+            //  value as necessary.\n+            if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {\n+                dcpLoadAsNumber(reg);\n+            } else {\n+                dcpLoadAsObject(reg);\n+            }\n+        } else if (fnCurrent.isNumberVar(varIndex)) {\n+            cfw.addDLoad(reg);\n+        } else {\n+            cfw.addALoad(reg);\n+        }\n+    }\n+\n+    private void visitSetVar(Node node, Node child, boolean needValue)\n+    {\n+        if (!hasVarsInRegs) Kit.codeBug();\n+        int varIndex = fnCurrent.getVarIndex(node);\n+        generateExpression(child.getNext(), node);\n+        boolean isNumber = (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1);\n+        short reg = varRegisters[varIndex];\n+        boolean [] constDeclarations = fnCurrent.fnode.getParamAndVarConst();\n+        if (constDeclarations[varIndex]) {\n+            if (!needValue) {\n+                if (isNumber)\n+                    cfw.add(ByteCode.POP2);\n+                else\n+                    cfw.add(ByteCode.POP);\n+            }\n+        }\n+        else if (varIsDirectCallParameter(varIndex)) {\n+            if (isNumber) {\n+                if (needValue) cfw.add(ByteCode.DUP2);\n+                cfw.addALoad(reg);\n+                cfw.add(ByteCode.GETSTATIC,\n+                        \"java/lang/Void\",\n+                        \"TYPE\",\n+                        \"Ljava/lang/Class;\");\n+                int isNumberLabel = cfw.acquireLabel();\n+                int beyond = cfw.acquireLabel();\n+                cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);\n+                short stack = cfw.getStackTop();\n+                addDoubleWrap();\n+                cfw.addAStore(reg);\n+                cfw.add(ByteCode.GOTO, beyond);\n+                cfw.markLabel(isNumberLabel, stack);\n+                cfw.addDStore(reg + 1);\n+                cfw.markLabel(beyond);\n+            }\n+            else {\n+                if (needValue) cfw.add(ByteCode.DUP);\n+                cfw.addAStore(reg);\n+            }\n+        } else {\n+            boolean isNumberVar = fnCurrent.isNumberVar(varIndex);\n+            if (isNumber) {\n+                if (isNumberVar) {\n+                    cfw.addDStore(reg);\n+                    if (needValue) cfw.addDLoad(reg);\n+                } else {\n+                    if (needValue) cfw.add(ByteCode.DUP2);\n+                    // Cannot save number in variable since !isNumberVar,\n+                    // so convert to object\n+                    addDoubleWrap();\n+                    cfw.addAStore(reg);\n+                }\n+            } else {\n+                if (isNumberVar) Kit.codeBug();\n+                cfw.addAStore(reg);\n+                if (needValue) cfw.addALoad(reg);\n+            }\n+        }\n+    }\n+\n+    private void visitSetConstVar(Node node, Node child, boolean needValue)\n+    {\n+        if (!hasVarsInRegs) Kit.codeBug();\n+        int varIndex = fnCurrent.getVarIndex(node);\n+        generateExpression(child.getNext(), node);\n+        boolean isNumber = (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1);\n+        short reg = varRegisters[varIndex];\n+        int beyond = cfw.acquireLabel();\n+        int noAssign = cfw.acquireLabel();\n+        if (isNumber) {\n+            cfw.addILoad(reg + 2);\n+            cfw.add(ByteCode.IFNE, noAssign);\n+            short stack = cfw.getStackTop();\n+            cfw.addPush(1);\n+            cfw.addIStore(reg + 2);\n+            cfw.addDStore(reg);\n+            if (needValue) {\n+                cfw.addDLoad(reg);\n+                cfw.markLabel(noAssign, stack);\n+            } else {\n+                cfw.add(ByteCode.GOTO, beyond);\n+                cfw.markLabel(noAssign, stack);\n+                cfw.add(ByteCode.POP2);\n+            }\n+        }\n+        else {\n+            cfw.addILoad(reg + 1);\n+            cfw.add(ByteCode.IFNE, noAssign);\n+            short stack = cfw.getStackTop();\n+            cfw.addPush(1);\n+            cfw.addIStore(reg + 1);\n+            cfw.addAStore(reg);\n+            if (needValue) {\n+                cfw.addALoad(reg);\n+                cfw.markLabel(noAssign, stack);\n+            } else {\n+                cfw.add(ByteCode.GOTO, beyond);\n+                cfw.markLabel(noAssign, stack);\n+                cfw.add(ByteCode.POP);\n+            }\n+        }\n+        cfw.markLabel(beyond);\n+    }\n+\n+    private void visitGetProp(Node node, Node child)\n+    {\n+        generateExpression(child, node); // object\n+        Node nameChild = child.getNext();\n+        generateExpression(nameChild, node);  // the name\n+        if (node.getType() == Token.GETPROPNOWARN) {\n+            cfw.addALoad(contextLocal);\n+            addScriptRuntimeInvoke(\n+                \"getObjectPropNoWarn\",\n+                \"(Ljava/lang/Object;\"\n+                +\"Ljava/lang/String;\"\n+                +\"Lorg/mozilla/javascript/Context;\"\n+                +\")Ljava/lang/Object;\");\n+            return;\n+        }\n+        /*\n+            for 'this.foo' we call getObjectProp(Scriptable...) which can\n+            skip some casting overhead.\n+        */\n+        int childType = child.getType();\n+        if (childType == Token.THIS && nameChild.getType() == Token.STRING) {\n+            cfw.addALoad(contextLocal);\n+            addScriptRuntimeInvoke(\n+                \"getObjectProp\",\n+                \"(Lorg/mozilla/javascript/Scriptable;\"\n+                +\"Ljava/lang/String;\"\n+                +\"Lorg/mozilla/javascript/Context;\"\n+                +\")Ljava/lang/Object;\");\n+        } else {\n+            cfw.addALoad(contextLocal);\n+            cfw.addALoad(variableObjectLocal);\n+            addScriptRuntimeInvoke(\n+                \"getObjectProp\",\n+                \"(Ljava/lang/Object;\"\n+                +\"Ljava/lang/String;\"\n+                +\"Lorg/mozilla/javascript/Context;\"\n+                +\"Lorg/mozilla/javascript/Scriptable;\"\n+                +\")Ljava/lang/Object;\");\n+        }\n+    }\n+\n+    private void visitSetProp(int type, Node node, Node child)\n+    {\n+        Node objectChild = child;\n+        generateExpression(child, node);\n+        child = child.getNext();\n+        if (type == Token.SETPROP_OP) {\n+            cfw.add(ByteCode.DUP);\n+        }\n+        Node nameChild = child;\n+        generateExpression(child, node);\n+        child = child.getNext();\n+        if (type == Token.SETPROP_OP) {\n+            // stack: ... object object name -> ... object name object name\n+            cfw.add(ByteCode.DUP_X1);\n+            //for 'this.foo += ...' we call thisGet which can skip some\n+            //casting overhead.\n+            if (objectChild.getType() == Token.THIS\n+                && nameChild.getType() == Token.STRING)\n+            {\n+                cfw.addALoad(contextLocal);\n+                addScriptRuntimeInvoke(\n+                    \"getObjectProp\",\n+                    \"(Lorg/mozilla/javascript/Scriptable;\"\n+                    +\"Ljava/lang/String;\"\n+                    +\"Lorg/mozilla/javascript/Context;\"\n+                    +\")Ljava/lang/Object;\");\n+            } else {\n+                cfw.addALoad(contextLocal);\n+                addScriptRuntimeInvoke(\n+                    \"getObjectProp\",\n+                    \"(Ljava/lang/Object;\"\n+                    +\"Ljava/lang/String;\"\n+                    +\"Lorg/mozilla/javascript/Context;\"\n+                    +\")Ljava/lang/Object;\");\n+            }\n+        }\n+        generateExpression(child, node);\n+        cfw.addALoad(contextLocal);\n+        addScriptRuntimeInvoke(\n+            \"setObjectProp\",\n+            \"(Ljava/lang/Object;\"\n+            +\"Ljava/lang/String;\"\n+            +\"Ljava/lang/Object;\"\n+            +\"Lorg/mozilla/javascript/Context;\"\n+            +\")Ljava/lang/Object;\");\n+    }\n+\n+    private void visitSetElem(int type, Node node, Node child)\n+    {\n+        generateExpression(child, node);\n+        child = child.getNext();\n+        if (type == Token.SETELEM_OP) {\n+            cfw.add(ByteCode.DUP);\n+        }\n+        generateExpression(child, node);\n+        child = child.getNext();\n+        boolean indexIsNumber = (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1);\n+        if (type == Token.SETELEM_OP) {\n+            if (indexIsNumber) {\n+                // stack: ... object object number\n+                //        -> ... object number object number\n+                cfw.add(ByteCode.DUP2_X1);\n+                cfw.addALoad(contextLocal);\n+                addOptRuntimeInvoke(\n+                    \"getObjectIndex\",\n+                    \"(Ljava/lang/Object;D\"\n+                    +\"Lorg/mozilla/javascript/Context;\"\n+                    +\")Ljava/lang/Object;\");\n+            } else {\n+                // stack: ... object object indexObject\n+                //        -> ... object indexObject object indexObject\n+                cfw.add(ByteCode.DUP_X1);\n+                cfw.addALoad(contextLocal);\n+                addScriptRuntimeInvoke(\n+                    \"getObjectElem\",\n+                    \"(Ljava/lang/Object;\"\n+                    +\"Ljava/lang/Object;\"\n+                    +\"Lorg/mozilla/javascript/Context;\"\n+                    +\")Ljava/lang/Object;\");\n+            }\n+        }\n+        generateExpression(child, node);\n+        cfw.addALoad(contextLocal);\n+        if (indexIsNumber) {\n+            addScriptRuntimeInvoke(\n+                \"setObjectIndex\",\n+                \"(Ljava/lang/Object;\"\n+                +\"D\"\n+                +\"Ljava/lang/Object;\"\n+                +\"Lorg/mozilla/javascript/Context;\"\n+                +\")Ljava/lang/Object;\");\n+        } else {\n+            addScriptRuntimeInvoke(\n+                \"setObjectElem\",\n+                \"(Ljava/lang/Object;\"\n+                +\"Ljava/lang/Object;\"\n+                +\"Ljava/lang/Object;\"\n+                +\"Lorg/mozilla/javascript/Context;\"\n+                +\")Ljava/lang/Object;\");\n+        }\n+    }\n+\n+    private void visitDotQuery(Node node, Node child)\n+    {\n+        updateLineNumber(node);\n+        generateExpression(child, node);\n+        cfw.addALoad(variableObjectLocal);\n+        addScriptRuntimeInvoke(\"enterDotQuery\",\n+                               \"(Ljava/lang/Object;\"\n+                               +\"Lorg/mozilla/javascript/Scriptable;\"\n+                               +\")Lorg/mozilla/javascript/Scriptable;\");\n+        cfw.addAStore(variableObjectLocal);\n+\n+        // add push null/pop with label in between to simplify code for loop\n+        // continue when it is necessary to pop the null result from\n+        // updateDotQuery\n+        cfw.add(ByteCode.ACONST_NULL);\n+        int queryLoopStart = cfw.acquireLabel();\n+        cfw.markLabel(queryLoopStart); // loop continue jumps here\n+        cfw.add(ByteCode.POP);\n+\n+        generateExpression(child.getNext(), node);\n+        addScriptRuntimeInvoke(\"toBoolean\", \"(Ljava/lang/Object;)Z\");\n+        cfw.addALoad(variableObjectLocal);\n+        addScriptRuntimeInvoke(\"updateDotQuery\",\n+                               \"(Z\"\n+                               +\"Lorg/mozilla/javascript/Scriptable;\"\n+                               +\")Ljava/lang/Object;\");\n+        cfw.add(ByteCode.DUP);\n+        cfw.add(ByteCode.IFNULL, queryLoopStart);\n+        // stack: ... non_null_result_of_updateDotQuery\n+        cfw.addALoad(variableObjectLocal);\n+        addScriptRuntimeInvoke(\"leaveDotQuery\",\n+                               \"(Lorg/mozilla/javascript/Scriptable;\"\n+                               +\")Lorg/mozilla/javascript/Scriptable;\");\n+        cfw.addAStore(variableObjectLocal);\n+    }\n+\n+    private int getLocalBlockRegister(Node node)\n+    {\n+        Node localBlock = (Node)node.getProp(Node.LOCAL_BLOCK_PROP);\n+        int localSlot = localBlock.getExistingIntProp(Node.LOCAL_PROP);\n+        return localSlot;\n+    }\n+\n+    private void dcpLoadAsNumber(int dcp_register)\n+    {\n+        cfw.addALoad(dcp_register);\n+        cfw.add(ByteCode.GETSTATIC,\n+                \"java/lang/Void\",\n+                \"TYPE\",\n+                \"Ljava/lang/Class;\");\n+        int isNumberLabel = cfw.acquireLabel();\n+        cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);\n+        short stack = cfw.getStackTop();\n+        cfw.addALoad(dcp_register);\n+        addObjectToDouble();\n+        int beyond = cfw.acquireLabel();\n+        cfw.add(ByteCode.GOTO, beyond);\n+        cfw.markLabel(isNumberLabel, stack);\n+        cfw.addDLoad(dcp_register + 1);\n+        cfw.markLabel(beyond);\n+    }\n+\n+    private void dcpLoadAsObject(int dcp_register)\n+    {\n+        cfw.addALoad(dcp_register);\n+        cfw.add(ByteCode.GETSTATIC,\n+                \"java/lang/Void\",\n+                \"TYPE\",\n+                \"Ljava/lang/Class;\");\n+        int isNumberLabel = cfw.acquireLabel();\n+        cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);\n+        short stack = cfw.getStackTop();\n+        cfw.addALoad(dcp_register);\n+        int beyond = cfw.acquireLabel();\n+        cfw.add(ByteCode.GOTO, beyond);\n+        cfw.markLabel(isNumberLabel, stack);\n+        cfw.addDLoad(dcp_register + 1);\n+        addDoubleWrap();\n+        cfw.markLabel(beyond);\n+    }\n+\n+    private void addGoto(Node target, int jumpcode)\n+    {\n+        int targetLabel = getTargetLabel(target);\n+        cfw.add(jumpcode, targetLabel);\n+    }\n+\n+    private void addObjectToDouble()\n+    {\n+        addScriptRuntimeInvoke(\"toNumber\", \"(Ljava/lang/Object;)D\");\n+    }\n+\n+    private void addNewObjectArray(int size)\n+    {\n+        if (size == 0) {\n+            if (itsZeroArgArray >= 0) {\n+                cfw.addALoad(itsZeroArgArray);\n+            } else {\n+                cfw.add(ByteCode.GETSTATIC,\n+                        \"org/mozilla/javascript/ScriptRuntime\",\n+                        \"emptyArgs\", \"[Ljava/lang/Object;\");\n+            }\n+        } else {\n+            cfw.addPush(size);\n+            cfw.add(ByteCode.ANEWARRAY, \"java/lang/Object\");\n+        }\n+    }\n+\n+    private void addScriptRuntimeInvoke(String methodName,\n+                                        String methodSignature)\n+    {\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      \"org.mozilla.javascript.ScriptRuntime\",\n+                      methodName,\n+                      methodSignature);\n+    }\n+\n+    private void addOptRuntimeInvoke(String methodName,\n+                                     String methodSignature)\n+    {\n+        cfw.addInvoke(ByteCode.INVOKESTATIC,\n+                      \"org/mozilla/javascript/optimizer/OptRuntime\",\n+                      methodName,\n+                      methodSignature);\n+    }\n+\n+    private void addJumpedBooleanWrap(int trueLabel, int falseLabel)\n+    {\n+        cfw.markLabel(falseLabel);\n+        int skip = cfw.acquireLabel();\n+        cfw.add(ByteCode.GETSTATIC, \"java/lang/Boolean\",\n+                                \"FALSE\", \"Ljava/lang/Boolean;\");\n+        cfw.add(ByteCode.GOTO, skip);\n+        cfw.markLabel(trueLabel);\n+        cfw.add(ByteCode.GETSTATIC, \"java/lang/Boolean\",\n+                                \"TRUE\", \"Ljava/lang/Boolean;\");\n+        cfw.markLabel(skip);\n+        cfw.adjustStackTop(-1);   // only have 1 of true/false\n+    }\n+\n+    private void addDoubleWrap()\n+    {\n+        addOptRuntimeInvoke(\"wrapDouble\", \"(D)Ljava/lang/Double;\");\n+    }\n+\n+    /**\n+     * Const locals use an extra slot to hold the has-been-assigned-once flag at\n+     * runtime.\n+     * @param isConst true iff the variable is const\n+     * @return the register for the word pair (double/long)\n+     */\n+    private short getNewWordPairLocal(boolean isConst)\n+    {\n+        short result = getConsecutiveSlots(2, isConst);\n+        if (result < (MAX_LOCALS - 1)) {\n+            locals[result] = 1;\n+            locals[result + 1] = 1;\n+            if (isConst)\n+                locals[result + 2] = 1;\n+            if (result == firstFreeLocal) {\n+                for (int i = firstFreeLocal + 2; i < MAX_LOCALS; i++) {\n+                    if (locals[i] == 0) {\n+                        firstFreeLocal = (short) i;\n+                        if (localsMax < firstFreeLocal)\n+                            localsMax = firstFreeLocal;\n+                        return result;\n+                    }\n+                }\n+            }\n+            else {\n+                return result;\n+            }\n+        }\n+        throw Context.reportRuntimeError(\"Program too complex \" +\n+                                         \"(out of locals)\");\n+    }\n+\n+    private short getNewWordLocal(boolean isConst)\n+    {\n+        short result = getConsecutiveSlots(1, isConst);\n+        if (result < (MAX_LOCALS - 1)) {\n+            locals[result] = 1;\n+            if (isConst)\n+                locals[result + 1] = 1;\n+            if (result == firstFreeLocal) {\n+                for (int i = firstFreeLocal + 2; i < MAX_LOCALS; i++) {\n+                    if (locals[i] == 0) {\n+                        firstFreeLocal = (short) i;\n+                        if (localsMax < firstFreeLocal)\n+                            localsMax = firstFreeLocal;\n+                        return result;\n+                    }\n+                }\n+            }\n+            else {\n+                return result;\n+            }\n+        }\n+        throw Context.reportRuntimeError(\"Program too complex \" +\n+                                         \"(out of locals)\");\n+    }\n+\n+    private short getNewWordLocal()\n+    {\n+        short result = firstFreeLocal;\n+        locals[result] = 1;\n+        for (int i = firstFreeLocal + 1; i < MAX_LOCALS; i++) {\n+            if (locals[i] == 0) {\n+                firstFreeLocal = (short) i;\n+                if (localsMax < firstFreeLocal)\n+                    localsMax = firstFreeLocal;\n+                return result;\n+            }\n+        }\n+        throw Context.reportRuntimeError(\"Program too complex \" +\n+                                         \"(out of locals)\");\n+    }\n+\n+    private short getConsecutiveSlots(int count, boolean isConst) {\n+        if (isConst)\n+            count++;\n+        short result = firstFreeLocal;\n+        while (true) {\n+            if (result >= (MAX_LOCALS - 1))\n+                break;\n+            int i;\n+            for (i = 0; i < count; i++)\n+                if (locals[result + i] != 0)\n+                    break;\n+            if (i >= count)\n+                break;\n+            result++;\n+        }\n+        return result;\n+    }\n+\n+    // This is a valid call only for a local that is allocated by default.\n+    private void incReferenceWordLocal(short local)\n+    {\n+        locals[local]++;\n+    }\n+\n+    // This is a valid call only for a local that is allocated by default.\n+    private void decReferenceWordLocal(short local)\n+    {\n+        locals[local]--;\n+    }\n+\n+    private void releaseWordLocal(short local)\n+    {\n+        if (local < firstFreeLocal)\n+            firstFreeLocal = local;\n+        locals[local] = 0;\n+    }\n+\n+\n+    static final int GENERATOR_TERMINATE = -1;\n+    static final int GENERATOR_START = 0;\n+    static final int GENERATOR_YIELD_START = 1;\n+\n+    ClassFileWriter cfw;\n+    Codegen codegen;\n+    CompilerEnvirons compilerEnv;\n+    ScriptNode scriptOrFn;\n+    public int scriptOrFnIndex;\n+    private int savedCodeOffset;\n+\n+    private OptFunctionNode fnCurrent;\n+    private boolean isTopLevel;\n+\n+    private static final int MAX_LOCALS = 256;\n+    private int[] locals;\n+    private short firstFreeLocal;\n+    private short localsMax;\n+\n+    private int itsLineNumber;\n+\n+    private boolean hasVarsInRegs;\n+    private short[] varRegisters;\n+    private boolean inDirectCallFunction;\n+    private boolean itsForcedObjectParameters;\n+    private int enterAreaStartLabel;\n+    private int epilogueLabel;\n+\n+    // special known locals. If you add a new local here, be sure\n+    // to initialize it to -1 in initBodyGeneration\n+    private short variableObjectLocal;\n+    private short popvLocal;\n+    private short contextLocal;\n+    private short argsLocal;\n+    private short operationLocal;\n+    private short thisObjLocal;\n+    private short funObjLocal;\n+    private short itsZeroArgArray;\n+    private short itsOneArgArray;\n+    private short scriptRegexpLocal;\n+    private short generatorStateLocal;\n+\n+    private boolean isGenerator;\n+    private int generatorSwitch;\n+    private int maxLocals = 0;\n+    private int maxStack = 0;\n+\n+    private Map<Node,FinallyReturnPoint> finallys;\n+\n+    static class FinallyReturnPoint {\n+        public List<Integer> jsrPoints  = new ArrayList<Integer>();\n+        public int tableLabel = 0;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/optimizer/DataFlowBitSet.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+\n+\n+package org.mozilla.javascript.optimizer;\n+\n+class DataFlowBitSet {\n+\n+    private int itsBits[];\n+    private int itsSize;\n+\n+    DataFlowBitSet(int size)\n+    {\n+        itsSize = size;\n+        itsBits = new int[(size + 31) >> 5];\n+    }\n+\n+    void set(int n)\n+    {\n+        if (!(0 <= n && n < itsSize)) badIndex(n);\n+        itsBits[n >> 5] |= 1 << (n & 31);\n+    }\n+\n+    boolean test(int n)\n+    {\n+        if (!(0 <= n && n < itsSize)) badIndex(n);\n+        return ((itsBits[n >> 5] & (1 << (n & 31))) != 0);\n+    }\n+\n+    void not()\n+    {\n+        int bitsLength = itsBits.length;\n+        for (int i = 0; i < bitsLength; i++)\n+            itsBits[i] = ~itsBits[i];\n+    }\n+\n+    void clear(int n)\n+    {\n+        if (!(0 <= n && n < itsSize)) badIndex(n);\n+        itsBits[n >> 5] &= ~(1 << (n & 31));\n+    }\n+\n+    void clear()\n+    {\n+        int bitsLength = itsBits.length;\n+        for (int i = 0; i < bitsLength; i++)\n+            itsBits[i] = 0;\n+    }\n+\n+    void or(DataFlowBitSet b)\n+    {\n+        int bitsLength = itsBits.length;\n+        for (int i = 0; i < bitsLength; i++)\n+            itsBits[i] |= b.itsBits[i];\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        sb.append(\"DataFlowBitSet, size = \");\n+        sb.append(itsSize);\n+        sb.append('\\n');\n+        int bitsLength = itsBits.length;\n+        for (int i = 0; i < bitsLength; i++) {\n+            sb.append(Integer.toHexString(itsBits[i]));\n+            sb.append(' ');\n+        }\n+        return sb.toString();\n+    }\n+\n+    boolean df(DataFlowBitSet in, DataFlowBitSet gen, DataFlowBitSet notKill)\n+    {\n+        int bitsLength = itsBits.length;\n+        boolean changed = false;\n+        for (int i = 0; i < bitsLength; i++) {\n+            int oldBits = itsBits[i];\n+            itsBits[i] = (in.itsBits[i] | gen.itsBits[i]) & notKill.itsBits[i];\n+            changed |= (oldBits != itsBits[i]);\n+        }\n+        return changed;\n+    }\n+\n+    boolean df2(DataFlowBitSet in, DataFlowBitSet gen, DataFlowBitSet notKill)\n+    {\n+        int bitsLength = itsBits.length;\n+        boolean changed = false;\n+        for (int i = 0; i < bitsLength; i++) {\n+            int oldBits = itsBits[i];\n+            itsBits[i] = (in.itsBits[i] & notKill.itsBits[i]) | gen.itsBits[i];\n+            changed |= (oldBits != itsBits[i]);\n+        }\n+        return changed;\n+    }\n+\n+    private void badIndex(int n)\n+    {\n+        throw new RuntimeException(\"DataFlowBitSet bad index \" + n);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/optimizer/OptFunctionNode.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Bob Jervis\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+\n+package org.mozilla.javascript.optimizer;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.ast.FunctionNode;\n+import org.mozilla.javascript.ast.ScriptNode;\n+\n+final class OptFunctionNode\n+{\n+    OptFunctionNode(FunctionNode fnode)\n+    {\n+        this.fnode = fnode;\n+        fnode.setCompilerData(this);\n+    }\n+\n+    static OptFunctionNode get(ScriptNode scriptOrFn, int i)\n+    {\n+        FunctionNode fnode = scriptOrFn.getFunctionNode(i);\n+        return (OptFunctionNode)fnode.getCompilerData();\n+    }\n+\n+    static OptFunctionNode get(ScriptNode scriptOrFn)\n+    {\n+        return (OptFunctionNode)scriptOrFn.getCompilerData();\n+    }\n+\n+    boolean isTargetOfDirectCall()\n+    {\n+        return directTargetIndex >= 0;\n+    }\n+\n+    int getDirectTargetIndex()\n+    {\n+        return directTargetIndex;\n+    }\n+\n+    void setDirectTargetIndex(int directTargetIndex)\n+    {\n+        // One time action\n+        if (directTargetIndex < 0 || this.directTargetIndex >= 0)\n+            Kit.codeBug();\n+        this.directTargetIndex = directTargetIndex;\n+    }\n+\n+    void setParameterNumberContext(boolean b)\n+    {\n+        itsParameterNumberContext = b;\n+    }\n+\n+    boolean getParameterNumberContext()\n+    {\n+        return itsParameterNumberContext;\n+    }\n+\n+    int getVarCount()\n+    {\n+        return fnode.getParamAndVarCount();\n+    }\n+\n+    boolean isParameter(int varIndex)\n+    {\n+        return varIndex < fnode.getParamCount();\n+    }\n+\n+    boolean isNumberVar(int varIndex)\n+    {\n+        varIndex -= fnode.getParamCount();\n+        if (varIndex >= 0 && numberVarFlags != null) {\n+            return numberVarFlags[varIndex];\n+        }\n+        return false;\n+    }\n+\n+    void setIsNumberVar(int varIndex)\n+    {\n+        varIndex -= fnode.getParamCount();\n+        // Can only be used with non-parameters\n+        if (varIndex < 0) Kit.codeBug();\n+        if (numberVarFlags == null) {\n+            int size = fnode.getParamAndVarCount() - fnode.getParamCount();\n+            numberVarFlags = new boolean[size];\n+        }\n+        numberVarFlags[varIndex] = true;\n+    }\n+\n+    int getVarIndex(Node n)\n+    {\n+        int index = n.getIntProp(Node.VARIABLE_PROP, -1);\n+        if (index == -1) {\n+            Node node;\n+            int type = n.getType();\n+            if (type == Token.GETVAR) {\n+                node = n;\n+            } else if (type == Token.SETVAR ||\n+                       type == Token.SETCONSTVAR) {\n+                node = n.getFirstChild();\n+            } else {\n+                throw Kit.codeBug();\n+            }\n+            index = fnode.getIndexForNameNode(node);\n+            if (index < 0) throw Kit.codeBug();\n+            n.putIntProp(Node.VARIABLE_PROP, index);\n+        }\n+        return index;\n+    }\n+\n+    FunctionNode fnode;\n+    private boolean[] numberVarFlags;\n+    private int directTargetIndex = -1;\n+    private boolean itsParameterNumberContext;\n+    boolean itsContainsCalls0;\n+    boolean itsContainsCalls1;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/optimizer/OptRuntime.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Roger Lawrence\n+ *   Hannes Wallnoefer\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+\n+package org.mozilla.javascript.optimizer;\n+\n+import org.mozilla.javascript.*;\n+\n+public final class OptRuntime extends ScriptRuntime\n+{\n+\n+    public static final Double zeroObj = new Double(0.0);\n+    public static final Double oneObj = new Double(1.0);\n+    public static final Double minusOneObj = new Double(-1.0);\n+\n+    /**\n+     * Implement ....() call shrinking optimizer code.\n+     */\n+    public static Object call0(Callable fun, Scriptable thisObj,\n+                               Context cx, Scriptable scope)\n+    {\n+        return fun.call(cx, scope, thisObj, ScriptRuntime.emptyArgs);\n+    }\n+\n+    /**\n+     * Implement ....(arg) call shrinking optimizer code.\n+     */\n+    public static Object call1(Callable fun, Scriptable thisObj, Object arg0,\n+                               Context cx, Scriptable scope)\n+    {\n+        return fun.call(cx, scope, thisObj, new Object[] { arg0 } );\n+    }\n+\n+    /**\n+     * Implement ....(arg0, arg1) call shrinking optimizer code.\n+     */\n+    public static Object call2(Callable fun, Scriptable thisObj,\n+                               Object arg0, Object arg1,\n+                               Context cx, Scriptable scope)\n+    {\n+        return fun.call(cx, scope, thisObj, new Object[] { arg0, arg1 });\n+    }\n+\n+    /**\n+     * Implement ....(arg0, arg1, ...) call shrinking optimizer code.\n+     */\n+    public static Object callN(Callable fun, Scriptable thisObj,\n+                               Object[] args,\n+                               Context cx, Scriptable scope)\n+    {\n+        return fun.call(cx, scope, thisObj, args);\n+    }\n+\n+    /**\n+     * Implement name(args) call shrinking optimizer code.\n+     */\n+    public static Object callName(Object[] args, String name,\n+                                  Context cx, Scriptable scope)\n+    {\n+        Callable f = getNameFunctionAndThis(name, cx, scope);\n+        Scriptable thisObj = lastStoredScriptable(cx);\n+        return f.call(cx, scope, thisObj, args);\n+    }\n+\n+    /**\n+     * Implement name() call shrinking optimizer code.\n+     */\n+    public static Object callName0(String name,\n+                                   Context cx, Scriptable scope)\n+    {\n+        Callable f = getNameFunctionAndThis(name, cx, scope);\n+        Scriptable thisObj = lastStoredScriptable(cx);\n+        return f.call(cx, scope, thisObj, ScriptRuntime.emptyArgs);\n+    }\n+\n+    /**\n+     * Implement x.property() call shrinking optimizer code.\n+     */\n+    public static Object callProp0(Object value, String property,\n+                                   Context cx, Scriptable scope)\n+    {\n+        Callable f = getPropFunctionAndThis(value, property, cx, scope);\n+        Scriptable thisObj = lastStoredScriptable(cx);\n+        return f.call(cx, scope, thisObj, ScriptRuntime.emptyArgs);\n+    }\n+\n+    public static Object add(Object val1, double val2)\n+    {\n+        if (val1 instanceof Scriptable)\n+            val1 = ((Scriptable) val1).getDefaultValue(null);\n+        if (!(val1 instanceof String))\n+            return wrapDouble(toNumber(val1) + val2);\n+        return ((String)val1).concat(toString(val2));\n+    }\n+\n+    public static Object add(double val1, Object val2)\n+    {\n+        if (val2 instanceof Scriptable)\n+            val2 = ((Scriptable) val2).getDefaultValue(null);\n+        if (!(val2 instanceof String))\n+            return wrapDouble(toNumber(val2) + val1);\n+        return toString(val1).concat((String)val2);\n+    }\n+\n+    public static Object elemIncrDecr(Object obj, double index,\n+                                      Context cx, int incrDecrMask)\n+    {\n+        return ScriptRuntime.elemIncrDecr(obj, new Double(index), cx,\n+                                          incrDecrMask);\n+    }\n+\n+    public static Object[] padStart(Object[] currentArgs, int count) {\n+        Object[] result = new Object[currentArgs.length + count];\n+        System.arraycopy(currentArgs, 0, result, count, currentArgs.length);\n+        return result;\n+    }\n+\n+    public static void initFunction(NativeFunction fn, int functionType,\n+                                    Scriptable scope, Context cx)\n+    {\n+        ScriptRuntime.initFunction(cx, scope, fn, functionType, false);\n+    }\n+\n+    public static Object callSpecial(Context cx, Callable fun,\n+                                     Scriptable thisObj, Object[] args,\n+                                     Scriptable scope,\n+                                     Scriptable callerThis, int callType,\n+                                     String fileName, int lineNumber)\n+    {\n+        return ScriptRuntime.callSpecial(cx, fun, thisObj, args, scope,\n+                                         callerThis, callType,\n+                                         fileName, lineNumber);\n+    }\n+\n+    public static Object newObjectSpecial(Context cx, Object fun,\n+                                          Object[] args, Scriptable scope,\n+                                          Scriptable callerThis, int callType)\n+    {\n+        return ScriptRuntime.newSpecial(cx, fun, args, scope, callType);\n+    }\n+\n+    public static Double wrapDouble(double num)\n+    {\n+        if (num == 0.0) {\n+            if (1 / num > 0) {\n+                // +0.0\n+                return zeroObj;\n+            }\n+        } else if (num == 1.0) {\n+            return oneObj;\n+        } else if (num == -1.0) {\n+            return minusOneObj;\n+        } else if (num != num) {\n+            return NaNobj;\n+        }\n+        return new Double(num);\n+    }\n+\n+    static String encodeIntArray(int[] array)\n+    {\n+        // XXX: this extremely inefficient for small integers\n+        if (array == null) { return null; }\n+        int n = array.length;\n+        char[] buffer = new char[1 + n * 2];\n+        buffer[0] = 1;\n+        for (int i = 0; i != n; ++i) {\n+            int value = array[i];\n+            int shift = 1 + i * 2;\n+            buffer[shift] = (char)(value >>> 16);\n+            buffer[shift + 1] = (char)value;\n+        }\n+        return new String(buffer);\n+    }\n+\n+    private static int[] decodeIntArray(String str, int arraySize)\n+    {\n+        // XXX: this extremely inefficient for small integers\n+        if (arraySize == 0) {\n+            if (str != null) throw new IllegalArgumentException();\n+            return null;\n+        }\n+        if (str.length() != 1 + arraySize * 2 && str.charAt(0) != 1) {\n+            throw new IllegalArgumentException();\n+        }\n+        int[] array = new int[arraySize];\n+        for (int i = 0; i != arraySize; ++i) {\n+            int shift = 1 + i * 2;\n+            array[i] = (str.charAt(shift) << 16) | str.charAt(shift + 1);\n+        }\n+        return array;\n+    }\n+\n+    public static Scriptable newArrayLiteral(Object[] objects,\n+                                             String encodedInts,\n+                                             int skipCount,\n+                                             Context cx,\n+                                             Scriptable scope)\n+    {\n+        int[] skipIndexces = decodeIntArray(encodedInts, skipCount);\n+        return newArrayLiteral(objects, skipIndexces, cx, scope);\n+    }\n+\n+    public static void main(final Script script, final String[] args)\n+    {\n+        ContextFactory.getGlobal().call(new ContextAction() {\n+            public Object run(Context cx)\n+            {\n+                ScriptableObject global = getGlobal(cx);\n+\n+                // get the command line arguments and define \"arguments\"\n+                // array in the top-level object\n+                Object[] argsCopy = new Object[args.length];\n+                System.arraycopy(args, 0, argsCopy, 0, args.length);\n+                Scriptable argsObj = cx.newArray(global, argsCopy);\n+                global.defineProperty(\"arguments\", argsObj,\n+                                      ScriptableObject.DONTENUM);\n+                script.exec(cx, global);\n+                return null;\n+            }\n+        });\n+    }\n+\n+    public static void throwStopIteration(Object obj) {\n+        throw new JavaScriptException(\n+            NativeIterator.getStopIterationObject((Scriptable)obj), \"\", 0);\n+    }\n+\n+    public static Scriptable createNativeGenerator(NativeFunction funObj,\n+                                                   Scriptable scope,\n+                                                   Scriptable thisObj,\n+                                                   int maxLocals,\n+                                                   int maxStack)\n+    {\n+        return new NativeGenerator(scope, funObj,\n+                new GeneratorState(thisObj, maxLocals, maxStack));\n+    }\n+\n+    public static Object[] getGeneratorStackState(Object obj) {\n+        GeneratorState rgs = (GeneratorState) obj;\n+        if (rgs.stackState == null)\n+            rgs.stackState = new Object[rgs.maxStack];\n+        return rgs.stackState;\n+    }\n+\n+    public static Object[] getGeneratorLocalsState(Object obj) {\n+        GeneratorState rgs = (GeneratorState) obj;\n+        if (rgs.localsState == null)\n+            rgs.localsState = new Object[rgs.maxLocals];\n+        return rgs.localsState;\n+    }\n+\n+    public static class GeneratorState {\n+        static final String CLASS_NAME =\n+            \"org/mozilla/javascript/optimizer/OptRuntime$GeneratorState\";\n+\n+        public int resumptionPoint;\n+        static final String resumptionPoint_NAME = \"resumptionPoint\";\n+        static final String resumptionPoint_TYPE = \"I\";\n+        \n+        public Scriptable thisObj;\n+        static final String thisObj_NAME = \"thisObj\";\n+        static final String thisObj_TYPE =\n+            \"Lorg/mozilla/javascript/Scriptable;\";\n+\n+        Object[] stackState;\n+        Object[] localsState;\n+        int maxLocals;\n+        int maxStack;\n+\n+        GeneratorState(Scriptable thisObj, int maxLocals, int maxStack) {\n+            this.thisObj = thisObj;\n+            this.maxLocals = maxLocals;\n+            this.maxStack = maxStack;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/optimizer/OptTransformer.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+\n+package org.mozilla.javascript.optimizer;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.ast.ScriptNode;\n+import java.util.Map;\n+\n+/**\n+ * This class performs node transforms to prepare for optimization.\n+ *\n+ * @see NodeTransformer\n+ */\n+\n+class OptTransformer extends NodeTransformer {\n+\n+    OptTransformer(Map<String,OptFunctionNode> possibleDirectCalls, ObjArray directCallTargets)\n+    {\n+        this.possibleDirectCalls = possibleDirectCalls;\n+        this.directCallTargets = directCallTargets;\n+    }\n+\n+    @Override\n+    protected void visitNew(Node node, ScriptNode tree) {\n+        detectDirectCall(node, tree);\n+        super.visitNew(node, tree);\n+    }\n+\n+    @Override\n+    protected void visitCall(Node node, ScriptNode tree) {\n+        detectDirectCall(node, tree);\n+        super.visitCall(node, tree);\n+    }\n+\n+    private void detectDirectCall(Node node, ScriptNode tree)\n+    {\n+        if (tree.getType() == Token.FUNCTION) {\n+            Node left = node.getFirstChild();\n+\n+            // count the arguments\n+            int argCount = 0;\n+            Node arg = left.getNext();\n+            while (arg != null) {\n+                arg = arg.getNext();\n+                argCount++;\n+            }\n+\n+            if (argCount == 0) {\n+                OptFunctionNode.get(tree).itsContainsCalls0 = true;\n+            }\n+\n+            /*\n+             * Optimize a call site by converting call(\"a\", b, c) into :\n+             *\n+             *  FunctionObjectFor\"a\" <-- instance variable init'd by constructor\n+             *\n+             *  // this is a DIRECTCALL node\n+             *  fn = GetProp(tmp = GetBase(\"a\"), \"a\");\n+             *  if (fn == FunctionObjectFor\"a\")\n+             *      fn.call(tmp, b, c)\n+             *  else\n+             *      ScriptRuntime.Call(fn, tmp, b, c)\n+             */\n+            if (possibleDirectCalls != null) {\n+                String targetName = null;\n+                if (left.getType() == Token.NAME) {\n+                    targetName = left.getString();\n+                } else if (left.getType() == Token.GETPROP) {\n+                    targetName = left.getFirstChild().getNext().getString();\n+                } else if (left.getType() == Token.GETPROPNOWARN) {\n+                    throw Kit.codeBug();\n+                }\n+                if (targetName != null) {\n+                    OptFunctionNode ofn;\n+                    ofn = possibleDirectCalls.get(targetName);\n+                    if (ofn != null\n+                        && argCount == ofn.fnode.getParamCount()\n+                        && !ofn.fnode.requiresActivation())\n+                    {\n+                        // Refuse to directCall any function with more\n+                        // than 32 parameters - prevent code explosion\n+                        // for wacky test cases\n+                        if (argCount <= 32) {\n+                            node.putProp(Node.DIRECTCALL_PROP, ofn);\n+                            if (!ofn.isTargetOfDirectCall()) {\n+                                int index = directCallTargets.size();\n+                                directCallTargets.add(ofn);\n+                                ofn.setDirectTargetIndex(index);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private Map<String,OptFunctionNode> possibleDirectCalls;\n+    private ObjArray directCallTargets;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/optimizer/Optimizer.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+\n+\n+package org.mozilla.javascript.optimizer;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.ast.ScriptNode;\n+\n+class Optimizer\n+{\n+\n+    static final int NoType = 0;\n+    static final int NumberType = 1;\n+    static final int AnyType = 3;\n+\n+    // It is assumed that (NumberType | AnyType) == AnyType\n+\n+    void optimize(ScriptNode scriptOrFn)\n+    {\n+        //  run on one function at a time for now\n+        int functionCount = scriptOrFn.getFunctionCount();\n+        for (int i = 0; i != functionCount; ++i) {\n+            OptFunctionNode f = OptFunctionNode.get(scriptOrFn, i);\n+            optimizeFunction(f);\n+        }\n+    }\n+\n+    private void optimizeFunction(OptFunctionNode theFunction)\n+    {\n+        if (theFunction.fnode.requiresActivation()) return;\n+\n+        inDirectCallFunction = theFunction.isTargetOfDirectCall();\n+        this.theFunction = theFunction;\n+\n+        ObjArray statementsArray = new ObjArray();\n+        buildStatementList_r(theFunction.fnode, statementsArray);\n+        Node[] theStatementNodes = new Node[statementsArray.size()];\n+        statementsArray.toArray(theStatementNodes);\n+\n+        Block.runFlowAnalyzes(theFunction, theStatementNodes);\n+\n+        if (!theFunction.fnode.requiresActivation()) {\n+            /*\n+             * Now that we know which local vars are in fact always\n+             * Numbers, we re-write the tree to take advantage of\n+             * that. Any arithmetic or assignment op involving just\n+             * Number typed vars is marked so that the codegen will\n+             * generate non-object code.\n+             */\n+            parameterUsedInNumberContext = false;\n+            for (int i = 0; i < theStatementNodes.length; i++) {\n+                rewriteForNumberVariables(theStatementNodes[i], NumberType);\n+            }\n+            theFunction.setParameterNumberContext(parameterUsedInNumberContext);\n+        }\n+\n+    }\n+\n+\n+/*\n+        Each directCall parameter is passed as a pair of values - an object\n+        and a double. The value passed depends on the type of value available at\n+        the call site. If a double is available, the object in java/lang/Void.TYPE\n+        is passed as the object value, and if an object value is available, then\n+        0.0 is passed as the double value.\n+\n+        The receiving routine always tests the object value before proceeding.\n+        If the parameter is being accessed in a 'Number Context' then the code\n+        sequence is :\n+        if (\"parameter_objectValue\" == java/lang/Void.TYPE)\n+            ...fine..., use the parameter_doubleValue\n+        else\n+            toNumber(parameter_objectValue)\n+\n+        and if the parameter is being referenced in an Object context, the code is\n+        if (\"parameter_objectValue\" == java/lang/Void.TYPE)\n+            new Double(parameter_doubleValue)\n+        else\n+            ...fine..., use the parameter_objectValue\n+\n+        If the receiving code never uses the doubleValue, it is converted on\n+        entry to a Double instead.\n+*/\n+\n+\n+/*\n+        We're referencing a node in a Number context (i.e. we'd prefer it\n+        was a double value). If the node is a parameter in a directCall\n+        function, mark it as being referenced in this context.\n+*/\n+    private void markDCPNumberContext(Node n)\n+    {\n+        if (inDirectCallFunction && n.getType() == Token.GETVAR) {\n+            int varIndex = theFunction.getVarIndex(n);\n+            if (theFunction.isParameter(varIndex)) {\n+                parameterUsedInNumberContext = true;\n+            }\n+        }\n+    }\n+\n+    private boolean convertParameter(Node n)\n+    {\n+        if (inDirectCallFunction && n.getType() == Token.GETVAR) {\n+            int varIndex = theFunction.getVarIndex(n);\n+            if (theFunction.isParameter(varIndex)) {\n+                n.removeProp(Node.ISNUMBER_PROP);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private int rewriteForNumberVariables(Node n, int desired)\n+    {\n+        switch (n.getType()) {\n+            case Token.EXPR_VOID : {\n+                    Node child = n.getFirstChild();\n+                    int type = rewriteForNumberVariables(child, NumberType);\n+                    if (type == NumberType)\n+                        n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                     return NoType;\n+                }\n+            case Token.NUMBER :\n+                n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                return NumberType;\n+\n+            case Token.GETVAR :\n+                {\n+                    int varIndex = theFunction.getVarIndex(n);\n+                    if (inDirectCallFunction\n+                        && theFunction.isParameter(varIndex)\n+                        && desired == NumberType)\n+                    {\n+                        n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                        return NumberType;\n+                    }\n+                    else if (theFunction.isNumberVar(varIndex)) {\n+                        n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                        return NumberType;\n+                    }\n+                    return NoType;\n+                }\n+\n+            case Token.INC :\n+            case Token.DEC : {\n+                    Node child = n.getFirstChild();\n+                    // \"child\" will be GETVAR or GETPROP or GETELEM\n+                    if (child.getType() == Token.GETVAR) {\n+                        ;\n+                        if (rewriteForNumberVariables(child, NumberType) == NumberType &&\n+                            !convertParameter(child))\n+                        {\n+                            n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                            markDCPNumberContext(child);\n+                            return NumberType;\n+                        }\n+                      return NoType;                       \n+                    }\n+                    else if (child.getType() == Token.GETELEM) {\n+                        return rewriteForNumberVariables(child, NumberType);\n+                    }\n+                    return NoType;\n+                }\n+            case Token.SETVAR : {\n+                    Node lChild = n.getFirstChild();\n+                    Node rChild = lChild.getNext();\n+                    int rType = rewriteForNumberVariables(rChild, NumberType);\n+                    int varIndex = theFunction.getVarIndex(n);\n+                    if (inDirectCallFunction\n+                        && theFunction.isParameter(varIndex))\n+                    {\n+                        if (rType == NumberType) {\n+                            if (!convertParameter(rChild)) {\n+                                n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                                return NumberType;\n+                            }\n+                            markDCPNumberContext(rChild);\n+                            return NoType;\n+                        }\n+                        else\n+                            return rType;\n+                    }\n+                    else if (theFunction.isNumberVar(varIndex)) {\n+                        if (rType != NumberType) {\n+                            n.removeChild(rChild);\n+                            n.addChildToBack(\n+                                new Node(Token.TO_DOUBLE, rChild));\n+                        }\n+                        n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                        markDCPNumberContext(rChild);\n+                        return NumberType;\n+                    }\n+                    else {\n+                        if (rType == NumberType) {\n+                            if (!convertParameter(rChild)) {\n+                                n.removeChild(rChild);\n+                                n.addChildToBack(\n+                                    new Node(Token.TO_OBJECT, rChild));\n+                            }\n+                        }\n+                        return NoType;\n+                    }\n+                }\n+            case Token.LE :\n+            case Token.LT :\n+            case Token.GE :\n+            case Token.GT : {\n+                    Node lChild = n.getFirstChild();\n+                    Node rChild = lChild.getNext();\n+                    int lType = rewriteForNumberVariables(lChild, NumberType);\n+                    int rType = rewriteForNumberVariables(rChild, NumberType);\n+                    markDCPNumberContext(lChild);\n+                    markDCPNumberContext(rChild);\n+\n+                    if (convertParameter(lChild)) {\n+                        if (convertParameter(rChild)) {\n+                            return NoType;\n+                        } else if (rType == NumberType) {\n+                            n.putIntProp(Node.ISNUMBER_PROP, Node.RIGHT);\n+                        }\n+                    }\n+                    else if (convertParameter(rChild)) {\n+                        if (lType == NumberType) {\n+                            n.putIntProp(Node.ISNUMBER_PROP, Node.LEFT);\n+                        }\n+                    }\n+                    else {\n+                        if (lType == NumberType) {\n+                            if (rType == NumberType) {\n+                                n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                            }\n+                            else {\n+                                n.putIntProp(Node.ISNUMBER_PROP, Node.LEFT);\n+                            }\n+                        }\n+                        else {\n+                            if (rType == NumberType) {\n+                                n.putIntProp(Node.ISNUMBER_PROP, Node.RIGHT);\n+                            }\n+                        }\n+                    }\n+                    // we actually build a boolean value\n+                    return NoType;\n+                }\n+\n+            case Token.ADD : {\n+                    Node lChild = n.getFirstChild();\n+                    Node rChild = lChild.getNext();\n+                    int lType = rewriteForNumberVariables(lChild, NumberType);\n+                    int rType = rewriteForNumberVariables(rChild, NumberType);\n+\n+\n+                    if (convertParameter(lChild)) {\n+                        if (convertParameter(rChild)) {\n+                            return NoType;\n+                        }\n+                        else {\n+                            if (rType == NumberType) {\n+                                n.putIntProp(Node.ISNUMBER_PROP, Node.RIGHT);\n+                            }\n+                        }\n+                    }\n+                    else {\n+                        if (convertParameter(rChild)) {\n+                            if (lType == NumberType) {\n+                                n.putIntProp(Node.ISNUMBER_PROP, Node.LEFT);\n+                            }\n+                        }\n+                        else {\n+                            if (lType == NumberType) {\n+                                if (rType == NumberType) {\n+                                    n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                                    return NumberType;\n+                                }\n+                                else {\n+                                    n.putIntProp(Node.ISNUMBER_PROP, Node.LEFT);\n+                                }\n+                            }\n+                            else {\n+                                if (rType == NumberType) {\n+                                    n.putIntProp(Node.ISNUMBER_PROP,\n+                                                 Node.RIGHT);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    return NoType;\n+                }\n+\n+            case Token.BITXOR :\n+            case Token.BITOR :\n+            case Token.BITAND :\n+            case Token.RSH :\n+            case Token.LSH :\n+            case Token.SUB :\n+            case Token.MUL :\n+            case Token.DIV :\n+            case Token.MOD : {\n+                    Node lChild = n.getFirstChild();\n+                    Node rChild = lChild.getNext();\n+                    int lType = rewriteForNumberVariables(lChild, NumberType);\n+                    int rType = rewriteForNumberVariables(rChild, NumberType);\n+                    markDCPNumberContext(lChild);\n+                    markDCPNumberContext(rChild);\n+                    if (lType == NumberType) {\n+                        if (rType == NumberType) {\n+                            n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                            return NumberType;\n+                        }\n+                        else {\n+                            if (!convertParameter(rChild)) {\n+                                n.removeChild(rChild);\n+                                n.addChildToBack(\n+                                    new Node(Token.TO_DOUBLE, rChild));\n+                                n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                            }\n+                            return NumberType;\n+                        }\n+                    }\n+                    else {\n+                        if (rType == NumberType) {\n+                            if (!convertParameter(lChild)) {\n+                                n.removeChild(lChild);\n+                                n.addChildToFront(\n+                                    new Node(Token.TO_DOUBLE, lChild));\n+                                n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                            }\n+                            return NumberType;\n+                        }\n+                        else {\n+                            if (!convertParameter(lChild)) {\n+                                n.removeChild(lChild);\n+                                n.addChildToFront(\n+                                    new Node(Token.TO_DOUBLE, lChild));\n+                            }\n+                            if (!convertParameter(rChild)) {\n+                                n.removeChild(rChild);\n+                                n.addChildToBack(\n+                                    new Node(Token.TO_DOUBLE, rChild));\n+                            }\n+                            n.putIntProp(Node.ISNUMBER_PROP, Node.BOTH);\n+                            return NumberType;\n+                        }\n+                    }\n+                }\n+            case Token.SETELEM :\n+            case Token.SETELEM_OP : {\n+                    Node arrayBase = n.getFirstChild();\n+                    Node arrayIndex = arrayBase.getNext();\n+                    Node rValue = arrayIndex.getNext();\n+                    int baseType = rewriteForNumberVariables(arrayBase, NumberType);\n+                    if (baseType == NumberType) {// can never happen ???\n+                        if (!convertParameter(arrayBase)) {\n+                            n.removeChild(arrayBase);\n+                            n.addChildToFront(\n+                                new Node(Token.TO_OBJECT, arrayBase));\n+                        }\n+                    }\n+                    int indexType = rewriteForNumberVariables(arrayIndex, NumberType);\n+                    if (indexType == NumberType) {\n+                        if (!convertParameter(arrayIndex)) {\n+                            // setting the ISNUMBER_PROP signals the codegen\n+                            // to use the OptRuntime.setObjectIndex that takes\n+                            // a double index\n+                            n.putIntProp(Node.ISNUMBER_PROP, Node.LEFT);\n+                        }\n+                    }\n+                    int rValueType = rewriteForNumberVariables(rValue, NumberType);\n+                    if (rValueType == NumberType) {\n+                        if (!convertParameter(rValue)) {\n+                            n.removeChild(rValue);\n+                            n.addChildToBack(\n+                                new Node(Token.TO_OBJECT, rValue));\n+                        }\n+                    }\n+                    return NoType;\n+                }\n+            case Token.GETELEM : {\n+                    Node arrayBase = n.getFirstChild();\n+                    Node arrayIndex = arrayBase.getNext();\n+                    int baseType = rewriteForNumberVariables(arrayBase, NumberType);\n+                    if (baseType == NumberType) {// can never happen ???\n+                        if (!convertParameter(arrayBase)) {\n+                            n.removeChild(arrayBase);\n+                            n.addChildToFront(\n+                                new Node(Token.TO_OBJECT, arrayBase));\n+                        }\n+                    }\n+                    int indexType = rewriteForNumberVariables(arrayIndex, NumberType);\n+                    if (indexType == NumberType) {\n+                        if (!convertParameter(arrayIndex)) {\n+                            // setting the ISNUMBER_PROP signals the codegen\n+                            // to use the OptRuntime.getObjectIndex that takes\n+                            // a double index\n+                            n.putIntProp(Node.ISNUMBER_PROP, Node.RIGHT);\n+                        }\n+                    }\n+                    return NoType;\n+                }\n+            case Token.CALL :\n+                {\n+                    Node child = n.getFirstChild(); // the function node\n+                    // must be an object\n+                    rewriteAsObjectChildren(child, child.getFirstChild());\n+                    child = child.getNext(); // the first arg\n+\n+                    OptFunctionNode target\n+                            = (OptFunctionNode)n.getProp(Node.DIRECTCALL_PROP);\n+                    if (target != null) {\n+/*\n+    we leave each child as a Number if it can be. The codegen will\n+    handle moving the pairs of parameters.\n+*/\n+                        while (child != null) {\n+                            int type = rewriteForNumberVariables(child, NumberType);\n+                            if (type == NumberType) {\n+                                markDCPNumberContext(child);\n+                            }\n+                            child = child.getNext();\n+                        }\n+                    } else {\n+                        rewriteAsObjectChildren(n, child);\n+                    }\n+                    return NoType;\n+                }\n+            default : {\n+                    rewriteAsObjectChildren(n, n.getFirstChild());\n+                    return NoType;\n+                }\n+        }\n+    }\n+\n+    private void rewriteAsObjectChildren(Node n, Node child)\n+    {\n+        // Force optimized children to be objects\n+        while (child != null) {\n+            Node nextChild = child.getNext();\n+            int type = rewriteForNumberVariables(child, NoType);\n+            if (type == NumberType) {\n+                if (!convertParameter(child)) {\n+                    n.removeChild(child);\n+                    Node nuChild = new Node(Token.TO_OBJECT, child);\n+                    if (nextChild == null)\n+                        n.addChildToBack(nuChild);\n+                    else\n+                        n.addChildBefore(nuChild, nextChild);\n+                }\n+            }\n+            child = nextChild;\n+        }\n+    }\n+\n+    private static void buildStatementList_r(Node node, ObjArray statements)\n+    {\n+        int type = node.getType();\n+        if (type == Token.BLOCK\n+            || type == Token.LOCAL_BLOCK\n+            || type == Token.LOOP\n+            || type == Token.FUNCTION)\n+        {\n+            Node child = node.getFirstChild();\n+            while (child != null) {\n+                buildStatementList_r(child, statements);\n+                child = child.getNext();\n+            }\n+        } else {\n+            statements.add(node);\n+        }\n+    }\n+\n+    private boolean inDirectCallFunction;\n+    OptFunctionNode theFunction;\n+    private boolean parameterUsedInNumberContext;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/regexp/NativeRegExp.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Brendan Eich\n+ *   Matthias Radestock\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.regexp;\n+\n+import java.io.Serializable;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.Function;\n+import org.mozilla.javascript.IdFunctionObject;\n+import org.mozilla.javascript.IdScriptableObject;\n+import org.mozilla.javascript.Kit;\n+import org.mozilla.javascript.ScriptRuntime;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.ScriptableObject;\n+import org.mozilla.javascript.Undefined;\n+\n+/**\n+ * This class implements the RegExp native object.\n+ *\n+ * Revision History:\n+ * Implementation in C by Brendan Eich\n+ * Initial port to Java by Norris Boyd from jsregexp.c version 1.36\n+ * Merged up to version 1.38, which included Unicode support.\n+ * Merged bug fixes in version 1.39.\n+ * Merged JSFUN13_BRANCH changes up to 1.32.2.13\n+ *\n+ */\n+\n+\n+\n+public class NativeRegExp extends IdScriptableObject implements Function\n+{\n+    static final long serialVersionUID = 4965263491464903264L;\n+\n+    private static final Object REGEXP_TAG = new Object();\n+\n+    public static final int JSREG_GLOB = 0x1;       // 'g' flag: global\n+    public static final int JSREG_FOLD = 0x2;       // 'i' flag: fold\n+    public static final int JSREG_MULTILINE = 0x4;  // 'm' flag: multiline\n+\n+    //type of match to perform\n+    public static final int TEST = 0;\n+    public static final int MATCH = 1;\n+    public static final int PREFIX = 2;\n+\n+    private static final boolean debug = false;\n+\n+    private static final byte REOP_EMPTY         = 0;  /* match rest of input against rest of r.e. */\n+    private static final byte REOP_ALT           = 1;  /* alternative subexpressions in kid and next */\n+    private static final byte REOP_BOL           = 2;  /* beginning of input (or line if multiline) */\n+    private static final byte REOP_EOL           = 3;  /* end of input (or line if multiline) */\n+    private static final byte REOP_WBDRY         = 4;  /* match \"\" at word boundary */\n+    private static final byte REOP_WNONBDRY      = 5;  /* match \"\" at word non-boundary */\n+    private static final byte REOP_QUANT         = 6;  /* quantified atom: atom{1,2} */\n+    private static final byte REOP_STAR          = 7;  /* zero or more occurrences of kid */\n+    private static final byte REOP_PLUS          = 8;  /* one or more occurrences of kid */\n+    private static final byte REOP_OPT           = 9;  /* optional subexpression in kid */\n+    private static final byte REOP_LPAREN        = 10; /* left paren bytecode: kid is u.num'th sub-regexp */\n+    private static final byte REOP_RPAREN        = 11; /* right paren bytecode */\n+    private static final byte REOP_DOT           = 12; /* stands for any character */\n+//    private static final byte REOP_CCLASS        = 13; /* character class: [a-f] */\n+    private static final byte REOP_DIGIT         = 14; /* match a digit char: [0-9] */\n+    private static final byte REOP_NONDIGIT      = 15; /* match a non-digit char: [^0-9] */\n+    private static final byte REOP_ALNUM         = 16; /* match an alphanumeric char: [0-9a-z_A-Z] */\n+    private static final byte REOP_NONALNUM      = 17; /* match a non-alphanumeric char: [^0-9a-z_A-Z] */\n+    private static final byte REOP_SPACE         = 18; /* match a whitespace char */\n+    private static final byte REOP_NONSPACE      = 19; /* match a non-whitespace char */\n+    private static final byte REOP_BACKREF       = 20; /* back-reference (e.g., \\1) to a parenthetical */\n+    private static final byte REOP_FLAT          = 21; /* match a flat string */\n+    private static final byte REOP_FLAT1         = 22; /* match a single char */\n+    private static final byte REOP_JUMP          = 23; /* for deoptimized closure loops */\n+//    private static final byte REOP_DOTSTAR       = 24; /* optimize .* to use a single opcode */\n+//    private static final byte REOP_ANCHOR        = 25; /* like .* but skips left context to unanchored r.e. */\n+//    private static final byte REOP_EOLONLY       = 26; /* $ not preceded by any pattern */\n+//    private static final byte REOP_UCFLAT        = 27; /* flat Unicode string; len immediate counts chars */\n+    private static final byte REOP_UCFLAT1       = 28; /* single Unicode char */\n+//    private static final byte REOP_UCCLASS       = 29; /* Unicode character class, vector of chars to match */\n+//    private static final byte REOP_NUCCLASS      = 30; /* negated Unicode character class */\n+//    private static final byte REOP_BACKREFi      = 31; /* case-independent REOP_BACKREF */\n+    private static final byte REOP_FLATi         = 32; /* case-independent REOP_FLAT */\n+    private static final byte REOP_FLAT1i        = 33; /* case-independent REOP_FLAT1 */\n+//    private static final byte REOP_UCFLATi       = 34; /* case-independent REOP_UCFLAT */\n+    private static final byte REOP_UCFLAT1i      = 35; /* case-independent REOP_UCFLAT1 */\n+//    private static final byte REOP_ANCHOR1       = 36; /* first-char discriminating REOP_ANCHOR */\n+//    private static final byte REOP_NCCLASS       = 37; /* negated 8-bit character class */\n+//    private static final byte REOP_DOTSTARMIN    = 38; /* ungreedy version of REOP_DOTSTAR */\n+//    private static final byte REOP_LPARENNON     = 39; /* non-capturing version of REOP_LPAREN */\n+//    private static final byte REOP_RPARENNON     = 40; /* non-capturing version of REOP_RPAREN */\n+    private static final byte REOP_ASSERT        = 41; /* zero width positive lookahead assertion */\n+    private static final byte REOP_ASSERT_NOT    = 42; /* zero width negative lookahead assertion */\n+    private static final byte REOP_ASSERTTEST    = 43; /* sentinel at end of assertion child */\n+    private static final byte REOP_ASSERTNOTTEST = 44; /* sentinel at end of !assertion child */\n+    private static final byte REOP_MINIMALSTAR   = 45; /* non-greedy version of * */\n+    private static final byte REOP_MINIMALPLUS   = 46; /* non-greedy version of + */\n+    private static final byte REOP_MINIMALOPT    = 47; /* non-greedy version of ? */\n+    private static final byte REOP_MINIMALQUANT  = 48; /* non-greedy version of {} */\n+    private static final byte REOP_ENDCHILD      = 49; /* sentinel at end of quantifier child */\n+    private static final byte REOP_CLASS         = 50; /* character class with index */\n+    private static final byte REOP_REPEAT        = 51; /* directs execution of greedy quantifier */\n+    private static final byte REOP_MINIMALREPEAT = 52; /* directs execution of non-greedy quantifier */\n+    private static final byte REOP_END           = 53;\n+\n+\n+\n+    public static void init(Context cx, Scriptable scope, boolean sealed)\n+    {\n+\n+        NativeRegExp proto = new NativeRegExp();\n+        proto.re = (RECompiled)compileRE(cx, \"\", null, false);\n+        proto.activatePrototypeMap(MAX_PROTOTYPE_ID);\n+        proto.setParentScope(scope);\n+        proto.setPrototype(getObjectPrototype(scope));\n+\n+        NativeRegExpCtor ctor = new NativeRegExpCtor();\n+        // Bug #324006: ECMA-262 15.10.6.1 says \"The initial value of\n+        // RegExp.prototype.constructor is the builtin RegExp constructor.\"\n+        proto.defineProperty(\"constructor\", ctor, ScriptableObject.DONTENUM);\n+\n+        ScriptRuntime.setFunctionProtoAndParent(ctor, scope);\n+\n+        ctor.setImmunePrototypeProperty(proto);\n+\n+        if (sealed) {\n+            proto.sealObject();\n+            ctor.sealObject();\n+        }\n+\n+        defineProperty(scope, \"RegExp\", ctor, ScriptableObject.DONTENUM);\n+    }\n+\n+    NativeRegExp(Scriptable scope, Object regexpCompiled)\n+    {\n+        this.re = (RECompiled)regexpCompiled;\n+        this.lastIndex = 0;\n+        ScriptRuntime.setObjectProtoAndParent(this, scope);\n+    }\n+\n+    @Override\n+    public String getClassName()\n+    {\n+        return \"RegExp\";\n+    }\n+\n+    /**\n+     * Gets the value to be returned by the typeof operator called on this object.\n+     * @see org.mozilla.javascript.ScriptableObject#getTypeOf()\n+     * @return \"object\"\n+     */\n+    @Override\n+    public String getTypeOf()\n+    {\n+    \treturn \"object\";\n+    }\n+\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        return execSub(cx, scope, args, MATCH);\n+    }\n+\n+    public Scriptable construct(Context cx, Scriptable scope, Object[] args)\n+    {\n+        return (Scriptable)execSub(cx, scope, args, MATCH);\n+    }\n+\n+    Scriptable compile(Context cx, Scriptable scope, Object[] args)\n+    {\n+        if (args.length > 0 && args[0] instanceof NativeRegExp) {\n+            if (args.length > 1 && args[1] != Undefined.instance) {\n+                // report error\n+                throw ScriptRuntime.typeError0(\"msg.bad.regexp.compile\");\n+            }\n+            NativeRegExp thatObj = (NativeRegExp) args[0];\n+            this.re = thatObj.re;\n+            this.lastIndex = thatObj.lastIndex;\n+            return this;\n+        }\n+        String s = args.length == 0 ? \"\" : ScriptRuntime.toString(args[0]);\n+        String global = args.length > 1 && args[1] != Undefined.instance\n+            ? ScriptRuntime.toString(args[1])\n+            : null;\n+        this.re = (RECompiled)compileRE(cx, s, global, false);\n+        this.lastIndex = 0;\n+        return this;\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append('/');\n+        if (re.source.length != 0) {\n+            buf.append(re.source);\n+        } else {\n+            // See bugzilla 226045\n+            buf.append(\"(?:)\");\n+        }\n+        buf.append('/');\n+        if ((re.flags & JSREG_GLOB) != 0)\n+            buf.append('g');\n+        if ((re.flags & JSREG_FOLD) != 0)\n+            buf.append('i');\n+        if ((re.flags & JSREG_MULTILINE) != 0)\n+            buf.append('m');\n+        return buf.toString();\n+    }\n+\n+    NativeRegExp() {  }\n+\n+    private static RegExpImpl getImpl(Context cx)\n+    {\n+        return (RegExpImpl) ScriptRuntime.getRegExpProxy(cx);\n+    }\n+\n+    private Object execSub(Context cx, Scriptable scopeObj,\n+                           Object[] args, int matchType)\n+    {\n+        RegExpImpl reImpl = getImpl(cx);\n+        String str;\n+        if (args.length == 0) {\n+            str = reImpl.input;\n+            if (str == null) {\n+                reportError(\"msg.no.re.input.for\", toString());\n+            }\n+        } else {\n+            str = ScriptRuntime.toString(args[0]);\n+        }\n+        double d = ((re.flags & JSREG_GLOB) != 0) ? lastIndex : 0;\n+\n+        Object rval;\n+        if (d < 0 || str.length() < d) {\n+            lastIndex = 0;\n+            rval = null;\n+        }\n+        else {\n+            int indexp[] = { (int)d };\n+            rval = executeRegExp(cx, scopeObj, reImpl, str, indexp, matchType);\n+            if ((re.flags & JSREG_GLOB) != 0) {\n+                lastIndex = (rval == null || rval == Undefined.instance)\n+                            ? 0 : indexp[0];\n+            }\n+        }\n+        return rval;\n+    }\n+\n+    static Object compileRE(Context cx, String str, String global, boolean flat)\n+    {\n+        RECompiled regexp = new RECompiled();\n+        regexp.source = str.toCharArray();\n+        int length = str.length();\n+\n+        int flags = 0;\n+        if (global != null) {\n+            for (int i = 0; i < global.length(); i++) {\n+                char c = global.charAt(i);\n+                if (c == 'g') {\n+                    flags |= JSREG_GLOB;\n+                } else if (c == 'i') {\n+                    flags |= JSREG_FOLD;\n+                } else if (c == 'm') {\n+                    flags |= JSREG_MULTILINE;\n+                } else {\n+                    reportError(\"msg.invalid.re.flag\", String.valueOf(c));\n+                }\n+            }\n+        }\n+        regexp.flags = flags;\n+\n+        CompilerState state = new CompilerState(cx, regexp.source, length, flags);\n+        if (flat && length > 0) {\n+if (debug) {\n+System.out.println(\"flat = \\\"\" + str + \"\\\"\");\n+}\n+            state.result = new RENode(REOP_FLAT);\n+            state.result.chr = state.cpbegin[0];\n+            state.result.length = length;\n+            state.result.flatIndex = 0;\n+            state.progLength += 5;\n+        }\n+        else\n+            if (!parseDisjunction(state))\n+                return null;\n+\n+        regexp.program = new byte[state.progLength + 1];\n+        if (state.classCount != 0) {\n+            regexp.classList = new RECharSet[state.classCount];\n+            regexp.classCount = state.classCount;\n+        }\n+        int endPC = emitREBytecode(state, regexp, 0, state.result);\n+        regexp.program[endPC++] = REOP_END;\n+\n+if (debug) {\n+System.out.println(\"Prog. length = \" + endPC);\n+for (int i = 0; i < endPC; i++) {\n+    System.out.print(regexp.program[i]);\n+    if (i < (endPC - 1)) System.out.print(\", \");\n+}\n+System.out.println();\n+}\n+        regexp.parenCount = state.parenCount;\n+\n+        // If re starts with literal, init anchorCh accordingly\n+        switch (regexp.program[0]) {\n+        case REOP_UCFLAT1:\n+        case REOP_UCFLAT1i:\n+            regexp.anchorCh = (char)getIndex(regexp.program, 1);\n+            break;\n+        case REOP_FLAT1:\n+        case REOP_FLAT1i:\n+            regexp.anchorCh = (char)(regexp.program[1] & 0xFF);\n+            break;\n+        case REOP_FLAT:\n+        case REOP_FLATi:\n+            int k = getIndex(regexp.program, 1);\n+            regexp.anchorCh = regexp.source[k];\n+            break;\n+        }\n+\n+if (debug) {\n+if (regexp.anchorCh >= 0) {\n+    System.out.println(\"Anchor ch = '\" + (char)regexp.anchorCh + \"'\");\n+}\n+}\n+        return regexp;\n+    }\n+\n+    static boolean isDigit(char c)\n+    {\n+        return '0' <= c && c <= '9';\n+    }\n+\n+    private static boolean isWord(char c)\n+    {\n+        return Character.isLetter(c) || isDigit(c) || c == '_';\n+    }\n+\n+    private static boolean isLineTerm(char c)\n+    {\n+        return ScriptRuntime.isJSLineTerminator(c);\n+    }\n+\n+    private static boolean isREWhiteSpace(int c)\n+    {\n+        return ScriptRuntime.isJSWhitespaceOrLineTerminator(c);\n+    }\n+\n+    /*\n+     *\n+     * 1. If IgnoreCase is false, return ch.\n+     * 2. Let u be ch converted to upper case as if by calling\n+     *    String.prototype.toUpperCase on the one-character string ch.\n+     * 3. If u does not consist of a single character, return ch.\n+     * 4. Let cu be u's character.\n+     * 5. If ch's code point value is greater than or equal to decimal 128 and cu's\n+     *    code point value is less than decimal 128, then return ch.\n+     * 6. Return cu.\n+     */\n+    private static char upcase(char ch)\n+    {\n+        if (ch < 128) {\n+            if ('a' <= ch && ch <= 'z') {\n+                return (char)(ch + ('A' - 'a'));\n+            }\n+            return ch;\n+        }\n+        char cu = Character.toUpperCase(ch);\n+        if ((ch >= 128) && (cu < 128)) return ch;\n+        return cu;\n+    }\n+\n+    private static char downcase(char ch)\n+    {\n+        if (ch < 128) {\n+            if ('A' <= ch && ch <= 'Z') {\n+                return (char)(ch + ('a' - 'A'));\n+            }\n+            return ch;\n+        }\n+        char cl = Character.toLowerCase(ch);\n+        if ((ch >= 128) && (cl < 128)) return ch;\n+        return cl;\n+    }\n+\n+/*\n+ * Validates and converts hex ascii value.\n+ */\n+    private static int toASCIIHexDigit(int c)\n+    {\n+        if (c < '0')\n+            return -1;\n+        if (c <= '9') {\n+            return c - '0';\n+        }\n+        c |= 0x20;\n+        if ('a' <= c && c <= 'f') {\n+            return c - 'a' + 10;\n+        }\n+        return -1;\n+    }\n+\n+/*\n+ * Top-down regular expression grammar, based closely on Perl4.\n+ *\n+ *  regexp:     altern                  A regular expression is one or more\n+ *              altern '|' regexp       alternatives separated by vertical bar.\n+ */\n+    private static boolean parseDisjunction(CompilerState state)\n+    {\n+        if (!parseAlternative(state))\n+            return false;\n+        char[] source = state.cpbegin;\n+        int index = state.cp;\n+        if (index != source.length && source[index] == '|') {\n+            RENode altResult;\n+            ++state.cp;\n+            altResult = new RENode(REOP_ALT);\n+            altResult.kid = state.result;\n+            if (!parseDisjunction(state))\n+                return false;\n+            altResult.kid2 = state.result;\n+            state.result = altResult;\n+            /* ALT, <next>, ..., JUMP, <end> ... JUMP <end> */\n+            state.progLength += 9;\n+        }\n+        return true;\n+    }\n+\n+/*\n+ *  altern:     item                    An alternative is one or more items,\n+ *              item altern             concatenated together.\n+ */\n+    private static boolean parseAlternative(CompilerState state)\n+    {\n+        RENode headTerm = null;\n+        RENode tailTerm = null;\n+        char[] source = state.cpbegin;\n+        while (true) {\n+            if (state.cp == state.cpend || source[state.cp] == '|'\n+                || (state.parenNesting != 0 && source[state.cp] == ')'))\n+            {\n+                if (headTerm == null) {\n+                    state.result = new RENode(REOP_EMPTY);\n+                }\n+                else\n+                    state.result = headTerm;\n+                return true;\n+            }\n+            if (!parseTerm(state))\n+                return false;\n+            if (headTerm == null)\n+                headTerm = state.result;\n+            else {\n+                if (tailTerm == null) {\n+                    headTerm.next = state.result;\n+                    tailTerm = state.result;\n+                    while (tailTerm.next != null) tailTerm = tailTerm.next;\n+                }\n+                else {\n+                    tailTerm.next = state.result;\n+                    tailTerm = tailTerm.next;\n+                    while (tailTerm.next != null) tailTerm = tailTerm.next;\n+                }\n+            }\n+        }\n+    }\n+\n+    /* calculate the total size of the bitmap required for a class expression */\n+    private static boolean\n+    calculateBitmapSize(CompilerState state, RENode target, char[] src,\n+                        int index, int end)\n+    {\n+        char rangeStart = 0;\n+        char c;\n+        int n;\n+        int nDigits;\n+        int i;\n+        int max = 0;\n+        boolean inRange = false;\n+\n+        target.bmsize = 0;\n+\n+        if (index == end)\n+            return true;\n+\n+        if (src[index] == '^')\n+            ++index;\n+\n+        while (index != end) {\n+            int localMax = 0;\n+            nDigits = 2;\n+            switch (src[index]) {\n+            case '\\\\':\n+                ++index;\n+                c = src[index++];\n+                switch (c) {\n+                case 'b':\n+                    localMax = 0x8;\n+                    break;\n+                case 'f':\n+                    localMax = 0xC;\n+                    break;\n+                case 'n':\n+                    localMax = 0xA;\n+                    break;\n+                case 'r':\n+                    localMax = 0xD;\n+                    break;\n+                case 't':\n+                    localMax = 0x9;\n+                    break;\n+                case 'v':\n+                    localMax = 0xB;\n+                    break;\n+                case 'c':\n+                    if (((index + 1) < end) && Character.isLetter(src[index + 1]))\n+                        localMax = (char)(src[index++] & 0x1F);\n+                    else\n+                        localMax = '\\\\';\n+                    break;\n+                case 'u':\n+                    nDigits += 2;\n+                    // fall thru...\n+                case 'x':\n+                    n = 0;\n+                    for (i = 0; (i < nDigits) && (index < end); i++) {\n+                        c = src[index++];\n+                        n = Kit.xDigitToInt(c, n);\n+                        if (n < 0) {\n+                            // Back off to accepting the original\n+                            // '\\' as a literal\n+                            index -= (i + 1);\n+                            n = '\\\\';\n+                            break;\n+                        }\n+                    }\n+                    localMax = n;\n+                    break;\n+                case 'd':\n+                    if (inRange) {\n+                        reportError(\"msg.bad.range\", \"\");\n+                        return false;\n+                    }\n+                    localMax = '9';\n+                    break;\n+                case 'D':\n+                case 's':\n+                case 'S':\n+                case 'w':\n+                case 'W':\n+                    if (inRange) {\n+                        reportError(\"msg.bad.range\", \"\");\n+                        return false;\n+                    }\n+                    target.bmsize = 65535;\n+                    return true;\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                    /*\n+                     *  This is a non-ECMA extension - decimal escapes (in this\n+                     *  case, octal!) are supposed to be an error inside class\n+                     *  ranges, but supported here for backwards compatibility.\n+                     *\n+                     */\n+                    n = (c - '0');\n+                    c = src[index];\n+                    if ('0' <= c && c <= '7') {\n+                        index++;\n+                        n = 8 * n + (c - '0');\n+                        c = src[index];\n+                        if ('0' <= c && c <= '7') {\n+                            index++;\n+                            i = 8 * n + (c - '0');\n+                            if (i <= 0377)\n+                                n = i;\n+                            else\n+                                index--;\n+                        }\n+                    }\n+                    localMax = n;\n+                    break;\n+\n+                default:\n+                    localMax = c;\n+                    break;\n+                }\n+                break;\n+            default:\n+                localMax = src[index++];\n+                break;\n+            }\n+            if (inRange) {\n+                if (rangeStart > localMax) {\n+                    reportError(\"msg.bad.range\", \"\");\n+                    return false;\n+                }\n+                inRange = false;\n+            }\n+            else {\n+                if (index < (end - 1)) {\n+                    if (src[index] == '-') {\n+                        ++index;\n+                        inRange = true;\n+                        rangeStart = (char)localMax;\n+                        continue;\n+                    }\n+                }\n+            }\n+            if ((state.flags & JSREG_FOLD) != 0){\n+                char cu = upcase((char)localMax);\n+                char cd = downcase((char)localMax);\n+                localMax = (cu >= cd) ? cu : cd;\n+            }\n+            if (localMax > max)\n+                max = localMax;\n+        }\n+        target.bmsize = max;\n+        return true;\n+    }\n+\n+    /*\n+     *  item:       assertion               An item is either an assertion or\n+     *              quantatom               a quantified atom.\n+     *\n+     *  assertion:  '^'                     Assertions match beginning of string\n+     *                                      (or line if the class static property\n+     *                                      RegExp.multiline is true).\n+     *              '$'                     End of string (or line if the class\n+     *                                      static property RegExp.multiline is\n+     *                                      true).\n+     *              '\\b'                    Word boundary (between \\w and \\W).\n+     *              '\\B'                    Word non-boundary.\n+     *\n+     *  quantatom:  atom                    An unquantified atom.\n+     *              quantatom '{' n ',' m '}'\n+     *                                      Atom must occur between n and m times.\n+     *              quantatom '{' n ',' '}' Atom must occur at least n times.\n+     *              quantatom '{' n '}'     Atom must occur exactly n times.\n+     *              quantatom '*'           Zero or more times (same as {0,}).\n+     *              quantatom '+'           One or more times (same as {1,}).\n+     *              quantatom '?'           Zero or one time (same as {0,1}).\n+     *\n+     *              any of which can be optionally followed by '?' for ungreedy\n+     *\n+     *  atom:       '(' regexp ')'          A parenthesized regexp (what matched\n+     *                                      can be addressed using a backreference,\n+     *                                      see '\\' n below).\n+     *              '.'                     Matches any char except '\\n'.\n+     *              '[' classlist ']'       A character class.\n+     *              '[' '^' classlist ']'   A negated character class.\n+     *              '\\f'                    Form Feed.\n+     *              '\\n'                    Newline (Line Feed).\n+     *              '\\r'                    Carriage Return.\n+     *              '\\t'                    Horizontal Tab.\n+     *              '\\v'                    Vertical Tab.\n+     *              '\\d'                    A digit (same as [0-9]).\n+     *              '\\D'                    A non-digit.\n+     *              '\\w'                    A word character, [0-9a-z_A-Z].\n+     *              '\\W'                    A non-word character.\n+     *              '\\s'                    A whitespace character, [ \\b\\f\\n\\r\\t\\v].\n+     *              '\\S'                    A non-whitespace character.\n+     *              '\\' n                   A backreference to the nth (n decimal\n+     *                                      and positive) parenthesized expression.\n+     *              '\\' octal               An octal escape sequence (octal must be\n+     *                                      two or three digits long, unless it is\n+     *                                      0 for the null character).\n+     *              '\\x' hex                A hex escape (hex must be two digits).\n+     *              '\\c' ctrl               A control character, ctrl is a letter.\n+     *              '\\' literalatomchar     Any character except one of the above\n+     *                                      that follow '\\' in an atom.\n+     *              otheratomchar           Any character not first among the other\n+     *                                      atom right-hand sides.\n+     */\n+\n+    private static void doFlat(CompilerState state, char c)\n+    {\n+        state.result = new RENode(REOP_FLAT);\n+        state.result.chr = c;\n+        state.result.length = 1;\n+        state.result.flatIndex = -1;\n+        state.progLength += 3;\n+    }\n+\n+    private static int\n+    getDecimalValue(char c, CompilerState state, int maxValue,\n+                    String overflowMessageId)\n+    {\n+        boolean overflow = false;\n+        int start = state.cp;\n+        char[] src = state.cpbegin;\n+        int value = c - '0';\n+        for (; state.cp != state.cpend; ++state.cp) {\n+            c = src[state.cp];\n+            if (!isDigit(c)) {\n+                break;\n+            }\n+            if (!overflow) {\n+                int digit = c - '0';\n+                if (value < (maxValue - digit) / 10) {\n+                    value = value * 10 + digit;\n+                } else {\n+                    overflow = true;\n+                    value = maxValue;\n+                }\n+            }\n+        }\n+        if (overflow) {\n+            reportError(overflowMessageId,\n+                        String.valueOf(src, start, state.cp - start));\n+        }\n+        return value;\n+    }\n+\n+    private static boolean\n+    parseTerm(CompilerState state)\n+    {\n+        char[] src = state.cpbegin;\n+        char c = src[state.cp++];\n+        int nDigits = 2;\n+        int parenBaseCount = state.parenCount;\n+        int num, tmp;\n+        RENode term;\n+        int termStart;\n+\n+        switch (c) {\n+        /* assertions and atoms */\n+        case '^':\n+            state.result = new RENode(REOP_BOL);\n+            state.progLength++;\n+            return true;\n+        case '$':\n+            state.result = new RENode(REOP_EOL);\n+            state.progLength++;\n+            return true;\n+        case '\\\\':\n+            if (state.cp < state.cpend) {\n+                c = src[state.cp++];\n+                switch (c) {\n+                /* assertion escapes */\n+                case 'b' :\n+                    state.result = new RENode(REOP_WBDRY);\n+                    state.progLength++;\n+                    return true;\n+                case 'B':\n+                    state.result = new RENode(REOP_WNONBDRY);\n+                    state.progLength++;\n+                    return true;\n+                /* Decimal escape */\n+                case '0':\n+/*\n+ * Under 'strict' ECMA 3, we interpret \\0 as NUL and don't accept octal.\n+ * However, (XXX and since Rhino doesn't have a 'strict' mode) we'll just\n+ * behave the old way for compatibility reasons.\n+ * (see http://bugzilla.mozilla.org/show_bug.cgi?id=141078)\n+ *\n+ */\n+                    reportWarning(state.cx, \"msg.bad.backref\", \"\");\n+                    /* octal escape */\n+                    num = 0;\n+                    while (state.cp < state.cpend) {\n+                        c = src[state.cp];\n+                        if ((c >= '0') && (c <= '7')) {\n+                            state.cp++;\n+                            tmp = 8 * num + (c - '0');\n+                            if (tmp > 0377)\n+                                break;\n+                            num = tmp;\n+                        }\n+                        else\n+                            break;\n+                    }\n+                    c = (char)(num);\n+                    doFlat(state, c);\n+                    break;\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    termStart = state.cp - 1;\n+                    num = getDecimalValue(c, state, 0xFFFF,\n+                                          \"msg.overlarge.backref\");\n+                    if (num > state.parenCount)\n+                        reportWarning(state.cx, \"msg.bad.backref\", \"\");\n+                    /*\n+                     * n > 9 or > count of parentheses,\n+                     * then treat as octal instead.\n+                     */\n+                    if ((num > 9) && (num > state.parenCount)) {\n+                        state.cp = termStart;\n+                        num = 0;\n+                        while (state.cp < state.cpend) {\n+                            c = src[state.cp];\n+                            if ((c >= '0') && (c <= '7')) {\n+                                state.cp++;\n+                                tmp = 8 * num + (c - '0');\n+                                if (tmp > 0377)\n+                                    break;\n+                                num = tmp;\n+                            }\n+                            else\n+                                break;\n+                        }\n+                        c = (char)(num);\n+                        doFlat(state, c);\n+                        break;\n+                    }\n+                    /* otherwise, it's a back-reference */\n+                    state.result = new RENode(REOP_BACKREF);\n+                    state.result.parenIndex = num - 1;\n+                    state.progLength += 3;\n+                    break;\n+                /* Control escape */\n+                case 'f':\n+                    c = 0xC;\n+                    doFlat(state, c);\n+                    break;\n+                case 'n':\n+                    c = 0xA;\n+                    doFlat(state, c);\n+                    break;\n+                case 'r':\n+                    c = 0xD;\n+                    doFlat(state, c);\n+                    break;\n+                case 't':\n+                    c = 0x9;\n+                    doFlat(state, c);\n+                    break;\n+                case 'v':\n+                    c = 0xB;\n+                    doFlat(state, c);\n+                    break;\n+                /* Control letter */\n+                case 'c':\n+                    if (((state.cp + 1) < state.cpend) &&\n+                                        Character.isLetter(src[state.cp + 1]))\n+                        c = (char)(src[state.cp++] & 0x1F);\n+                    else {\n+                        /* back off to accepting the original '\\' as a literal */\n+                        --state.cp;\n+                        c = '\\\\';\n+                    }\n+                    doFlat(state, c);\n+                    break;\n+                /* UnicodeEscapeSequence */\n+                case 'u':\n+                    nDigits += 2;\n+                    // fall thru...\n+                /* HexEscapeSequence */\n+                case 'x':\n+                    {\n+                        int n = 0;\n+                        int i;\n+                        for (i = 0; (i < nDigits)\n+                                && (state.cp < state.cpend); i++) {\n+                            c = src[state.cp++];\n+                            n = Kit.xDigitToInt(c, n);\n+                            if (n < 0) {\n+                                // Back off to accepting the original\n+                                // 'u' or 'x' as a literal\n+                                state.cp -= (i + 2);\n+                                n = src[state.cp++];\n+                                break;\n+                            }\n+                        }\n+                        c = (char)(n);\n+                    }\n+                    doFlat(state, c);\n+                    break;\n+                /* Character class escapes */\n+                case 'd':\n+                    state.result = new RENode(REOP_DIGIT);\n+                    state.progLength++;\n+                    break;\n+                case 'D':\n+                    state.result = new RENode(REOP_NONDIGIT);\n+                    state.progLength++;\n+                    break;\n+                case 's':\n+                    state.result = new RENode(REOP_SPACE);\n+                    state.progLength++;\n+                    break;\n+                case 'S':\n+                    state.result = new RENode(REOP_NONSPACE);\n+                    state.progLength++;\n+                    break;\n+                case 'w':\n+                    state.result = new RENode(REOP_ALNUM);\n+                    state.progLength++;\n+                    break;\n+                case 'W':\n+                    state.result = new RENode(REOP_NONALNUM);\n+                    state.progLength++;\n+                    break;\n+                /* IdentityEscape */\n+                default:\n+                    state.result = new RENode(REOP_FLAT);\n+                    state.result.chr = c;\n+                    state.result.length = 1;\n+                    state.result.flatIndex = state.cp - 1;\n+                    state.progLength += 3;\n+                    break;\n+                }\n+                break;\n+            }\n+            else {\n+                /* a trailing '\\' is an error */\n+                reportError(\"msg.trail.backslash\", \"\");\n+                return false;\n+            }\n+        case '(': {\n+            RENode result = null;\n+            termStart = state.cp;\n+            if (state.cp + 1 < state.cpend && src[state.cp] == '?'\n+                && ((c = src[state.cp + 1]) == '=' || c == '!' || c == ':'))\n+            {\n+                state.cp += 2;\n+                if (c == '=') {\n+                    result = new RENode(REOP_ASSERT);\n+                    /* ASSERT, <next>, ... ASSERTTEST */\n+                    state.progLength += 4;\n+                } else if (c == '!') {\n+                    result = new RENode(REOP_ASSERT_NOT);\n+                    /* ASSERTNOT, <next>, ... ASSERTNOTTEST */\n+                    state.progLength += 4;\n+                }\n+            } else {\n+                result = new RENode(REOP_LPAREN);\n+                /* LPAREN, <index>, ... RPAREN, <index> */\n+                state.progLength += 6;\n+                result.parenIndex = state.parenCount++;\n+            }\n+            ++state.parenNesting;\n+            if (!parseDisjunction(state))\n+                return false;\n+            if (state.cp == state.cpend || src[state.cp] != ')') {\n+                reportError(\"msg.unterm.paren\", \"\");\n+                return false;\n+            }\n+            ++state.cp;\n+            --state.parenNesting;\n+            if (result != null) {\n+                result.kid = state.result;\n+                state.result = result;\n+            }\n+            break;\n+        }\n+        case ')':\n+          reportError(\"msg.re.unmatched.right.paren\", \"\");\n+          return false;\n+        case '[':\n+            state.result = new RENode(REOP_CLASS);\n+            termStart = state.cp;\n+            state.result.startIndex = termStart;\n+            while (true) {\n+                if (state.cp == state.cpend) {\n+                    reportError(\"msg.unterm.class\", \"\");\n+                    return false;\n+                }\n+                if (src[state.cp] == '\\\\')\n+                    state.cp++;\n+                else {\n+                    if (src[state.cp] == ']') {\n+                        state.result.kidlen = state.cp - termStart;\n+                        break;\n+                    }\n+                }\n+                state.cp++;\n+            }\n+            state.result.index = state.classCount++;\n+            /*\n+             * Call calculateBitmapSize now as we want any errors it finds\n+             * to be reported during the parse phase, not at execution.\n+             */\n+            if (!calculateBitmapSize(state, state.result, src, termStart, state.cp++))\n+                return false;\n+            state.progLength += 3; /* CLASS, <index> */\n+            break;\n+\n+        case '.':\n+            state.result = new RENode(REOP_DOT);\n+            state.progLength++;\n+            break;\n+        case '*':\n+        case '+':\n+        case '?':\n+            reportError(\"msg.bad.quant\", String.valueOf(src[state.cp - 1]));\n+            return false;\n+        default:\n+            state.result = new RENode(REOP_FLAT);\n+            state.result.chr = c;\n+            state.result.length = 1;\n+            state.result.flatIndex = state.cp - 1;\n+            state.progLength += 3;\n+            break;\n+        }\n+\n+        term = state.result;\n+        if (state.cp == state.cpend) {\n+            return true;\n+        }\n+        boolean hasQ = false;\n+        switch (src[state.cp]) {\n+            case '+':\n+                state.result = new RENode(REOP_QUANT);\n+                state.result.min = 1;\n+                state.result.max = -1;\n+                /* <PLUS>, <parencount>, <parenindex>, <next> ... <ENDCHILD> */\n+                state.progLength += 8;\n+                hasQ = true;\n+                break;\n+            case '*':\n+                state.result = new RENode(REOP_QUANT);\n+                state.result.min = 0;\n+                state.result.max = -1;\n+                /* <STAR>, <parencount>, <parenindex>, <next> ... <ENDCHILD> */\n+                state.progLength += 8;\n+                hasQ = true;\n+                break;\n+            case '?':\n+                state.result = new RENode(REOP_QUANT);\n+                state.result.min = 0;\n+                state.result.max = 1;\n+                /* <OPT>, <parencount>, <parenindex>, <next> ... <ENDCHILD> */\n+                state.progLength += 8;\n+                hasQ = true;\n+                break;\n+            case '{':  /* balance '}' */\n+            {\n+                int min = 0;\n+                int max = -1;\n+                int leftCurl = state.cp;\n+\n+               /* For Perl etc. compatibility, if quntifier does not match\n+                * \\{\\d+(,\\d*)?\\} exactly back off from it\n+                * being a quantifier, and chew it up as a literal\n+                * atom next time instead.\n+                */\n+\n+                c = src[++state.cp];\n+                if (isDigit(c)) {\n+                    ++state.cp;\n+                    min = getDecimalValue(c, state, 0xFFFF,\n+                                          \"msg.overlarge.min\");\n+                    c = src[state.cp];\n+                    if (c == ',') {\n+                        c = src[++state.cp];\n+                        if (isDigit(c)) {\n+                            ++state.cp;\n+                            max = getDecimalValue(c, state, 0xFFFF,\n+                                                  \"msg.overlarge.max\");\n+                            c = src[state.cp];\n+                            if (min > max) {\n+                                reportError(\"msg.max.lt.min\",\n+                                            String.valueOf(src[state.cp]));\n+                                return false;\n+                            }\n+                        }\n+                    } else {\n+                        max = min;\n+                    }\n+                    /* balance '{' */\n+                    if (c == '}') {\n+                        state.result = new RENode(REOP_QUANT);\n+                        state.result.min = min;\n+                        state.result.max = max;\n+                        // QUANT, <min>, <max>, <parencount>,\n+                        // <parenindex>, <next> ... <ENDCHILD>\n+                        state.progLength += 12;\n+                        hasQ = true;\n+                    }\n+                }\n+                if (!hasQ) {\n+                    state.cp = leftCurl;\n+                }\n+                break;\n+            }\n+        }\n+        if (!hasQ)\n+            return true;\n+\n+        ++state.cp;\n+        state.result.kid = term;\n+        state.result.parenIndex = parenBaseCount;\n+        state.result.parenCount = state.parenCount - parenBaseCount;\n+        if ((state.cp < state.cpend) && (src[state.cp] == '?')) {\n+            ++state.cp;\n+            state.result.greedy = false;\n+        }\n+        else\n+            state.result.greedy = true;\n+        return true;\n+    }\n+\n+    private static void resolveForwardJump(byte[] array, int from, int pc)\n+    {\n+        if (from > pc) throw Kit.codeBug();\n+        addIndex(array, from, pc - from);\n+    }\n+\n+    private static int getOffset(byte[] array, int pc)\n+    {\n+        return getIndex(array, pc);\n+    }\n+\n+    private static int addIndex(byte[] array, int pc, int index)\n+    {\n+        if (index < 0) throw Kit.codeBug();\n+        if (index > 0xFFFF)\n+            throw Context.reportRuntimeError(\"Too complex regexp\");\n+        array[pc] = (byte)(index >> 8);\n+        array[pc + 1] = (byte)(index);\n+        return pc + 2;\n+    }\n+\n+    private static int getIndex(byte[] array, int pc)\n+    {\n+        return ((array[pc] & 0xFF) << 8) | (array[pc + 1] & 0xFF);\n+    }\n+\n+    private static final int OFFSET_LEN = 2;\n+    private static final int INDEX_LEN  = 2;\n+\n+    private static int\n+    emitREBytecode(CompilerState state, RECompiled re, int pc, RENode t)\n+    {\n+        RENode nextAlt;\n+        int nextAltFixup, nextTermFixup;\n+        byte[] program = re.program;\n+\n+        while (t != null) {\n+            program[pc++] = t.op;\n+            switch (t.op) {\n+            case REOP_EMPTY:\n+                --pc;\n+                break;\n+            case REOP_ALT:\n+                nextAlt = t.kid2;\n+                nextAltFixup = pc;    /* address of next alternate */\n+                pc += OFFSET_LEN;\n+                pc = emitREBytecode(state, re, pc, t.kid);\n+                program[pc++] = REOP_JUMP;\n+                nextTermFixup = pc;    /* address of following term */\n+                pc += OFFSET_LEN;\n+                resolveForwardJump(program, nextAltFixup, pc);\n+                pc = emitREBytecode(state, re, pc, nextAlt);\n+\n+                program[pc++] = REOP_JUMP;\n+                nextAltFixup = pc;\n+                pc += OFFSET_LEN;\n+\n+                resolveForwardJump(program, nextTermFixup, pc);\n+                resolveForwardJump(program, nextAltFixup, pc);\n+                break;\n+            case REOP_FLAT:\n+                /*\n+                 * Consecutize FLAT's if possible.\n+                 */\n+                if (t.flatIndex != -1) {\n+                    while ((t.next != null) && (t.next.op == REOP_FLAT)\n+                            && ((t.flatIndex + t.length)\n+                                            == t.next.flatIndex)) {\n+                        t.length += t.next.length;\n+                        t.next = t.next.next;\n+                    }\n+                }\n+                if ((t.flatIndex != -1) && (t.length > 1)) {\n+                    if ((state.flags & JSREG_FOLD) != 0)\n+                        program[pc - 1] = REOP_FLATi;\n+                    else\n+                        program[pc - 1] = REOP_FLAT;\n+                    pc = addIndex(program, pc, t.flatIndex);\n+                    pc = addIndex(program, pc, t.length);\n+                }\n+                else {\n+                    if (t.chr < 256) {\n+                        if ((state.flags & JSREG_FOLD) != 0)\n+                            program[pc - 1] = REOP_FLAT1i;\n+                        else\n+                            program[pc - 1] = REOP_FLAT1;\n+                        program[pc++] = (byte)(t.chr);\n+                    }\n+                    else {\n+                        if ((state.flags & JSREG_FOLD) != 0)\n+                            program[pc - 1] = REOP_UCFLAT1i;\n+                        else\n+                            program[pc - 1] = REOP_UCFLAT1;\n+                        pc = addIndex(program, pc, t.chr);\n+                    }\n+                }\n+                break;\n+            case REOP_LPAREN:\n+                pc = addIndex(program, pc, t.parenIndex);\n+                pc = emitREBytecode(state, re, pc, t.kid);\n+                program[pc++] = REOP_RPAREN;\n+                pc = addIndex(program, pc, t.parenIndex);\n+                break;\n+            case REOP_BACKREF:\n+                pc = addIndex(program, pc, t.parenIndex);\n+                break;\n+            case REOP_ASSERT:\n+                nextTermFixup = pc;\n+                pc += OFFSET_LEN;\n+                pc = emitREBytecode(state, re, pc, t.kid);\n+                program[pc++] = REOP_ASSERTTEST;\n+                resolveForwardJump(program, nextTermFixup, pc);\n+                break;\n+            case REOP_ASSERT_NOT:\n+                nextTermFixup = pc;\n+                pc += OFFSET_LEN;\n+                pc = emitREBytecode(state, re, pc, t.kid);\n+                program[pc++] = REOP_ASSERTNOTTEST;\n+                resolveForwardJump(program, nextTermFixup, pc);\n+                break;\n+            case REOP_QUANT:\n+                if ((t.min == 0) && (t.max == -1))\n+                    program[pc - 1] = (t.greedy) ? REOP_STAR : REOP_MINIMALSTAR;\n+                else\n+                if ((t.min == 0) && (t.max == 1))\n+                    program[pc - 1] = (t.greedy) ? REOP_OPT : REOP_MINIMALOPT;\n+                else\n+                if ((t.min == 1) && (t.max == -1))\n+                    program[pc - 1] = (t.greedy) ? REOP_PLUS : REOP_MINIMALPLUS;\n+                else {\n+                    if (!t.greedy) program[pc - 1] = REOP_MINIMALQUANT;\n+                    pc = addIndex(program, pc, t.min);\n+                    // max can be -1 which addIndex does not accept\n+                    pc = addIndex(program, pc, t.max + 1);\n+                }\n+                pc = addIndex(program, pc, t.parenCount);\n+                pc = addIndex(program, pc, t.parenIndex);\n+                nextTermFixup = pc;\n+                pc += OFFSET_LEN;\n+                pc = emitREBytecode(state, re, pc, t.kid);\n+                program[pc++] = REOP_ENDCHILD;\n+                resolveForwardJump(program, nextTermFixup, pc);\n+                break;\n+            case REOP_CLASS:\n+                pc = addIndex(program, pc, t.index);\n+                re.classList[t.index] = new RECharSet(t.bmsize, t.startIndex,\n+                                                      t.kidlen);\n+                break;\n+            default:\n+                break;\n+            }\n+            t = t.next;\n+        }\n+        return pc;\n+    }\n+\n+    private static void\n+    pushProgState(REGlobalData gData, int min, int max,\n+                  REBackTrackData backTrackLastToSave,\n+                  int continuation_pc, int continuation_op)\n+    {\n+        gData.stateStackTop = new REProgState(gData.stateStackTop, min, max,\n+                                              gData.cp, backTrackLastToSave,\n+                                              continuation_pc,\n+                                              continuation_op);\n+    }\n+\n+    private static REProgState\n+    popProgState(REGlobalData gData)\n+    {\n+        REProgState state = gData.stateStackTop;\n+        gData.stateStackTop = state.previous;\n+        return state;\n+    }\n+\n+    private static void\n+    pushBackTrackState(REGlobalData gData, byte op, int target)\n+    {\n+        gData.backTrackStackTop = new REBackTrackData(gData, op, target);\n+    }\n+\n+    /*\n+     *   Consecutive literal characters.\n+     */\n+    private static boolean\n+    flatNMatcher(REGlobalData gData, int matchChars,\n+                 int length, char[] chars, int end)\n+    {\n+        if ((gData.cp + length) > end)\n+            return false;\n+        for (int i = 0; i < length; i++) {\n+            if (gData.regexp.source[matchChars + i] != chars[gData.cp + i]) {\n+                return false;\n+            }\n+        }\n+        gData.cp += length;\n+        return true;\n+    }\n+\n+    private static boolean\n+    flatNIMatcher(REGlobalData gData, int matchChars,\n+                  int length, char[] chars, int end)\n+    {\n+        if ((gData.cp + length) > end)\n+            return false;\n+        for (int i = 0; i < length; i++) {\n+            if (upcase(gData.regexp.source[matchChars + i])\n+                != upcase(chars[gData.cp + i]))\n+            {\n+                return false;\n+            }\n+        }\n+        gData.cp += length;\n+        return true;\n+    }\n+\n+    /*\n+    1. Evaluate DecimalEscape to obtain an EscapeValue E.\n+    2. If E is not a character then go to step 6.\n+    3. Let ch be E's character.\n+    4. Let A be a one-element RECharSet containing the character ch.\n+    5. Call CharacterSetMatcher(A, false) and return its Matcher result.\n+    6. E must be an integer. Let n be that integer.\n+    7. If n=0 or n>NCapturingParens then throw a SyntaxError exception.\n+    8. Return an internal Matcher closure that takes two arguments, a State x\n+       and a Continuation c, and performs the following:\n+        1. Let cap be x's captures internal array.\n+        2. Let s be cap[n].\n+        3. If s is undefined, then call c(x) and return its result.\n+        4. Let e be x's endIndex.\n+        5. Let len be s's length.\n+        6. Let f be e+len.\n+        7. If f>InputLength, return failure.\n+        8. If there exists an integer i between 0 (inclusive) and len (exclusive)\n+           such that Canonicalize(s[i]) is not the same character as\n+           Canonicalize(Input [e+i]), then return failure.\n+        9. Let y be the State (f, cap).\n+        10. Call c(y) and return its result.\n+    */\n+    private static boolean\n+    backrefMatcher(REGlobalData gData, int parenIndex,\n+                   char[] chars, int end)\n+    {\n+        int len;\n+        int i;\n+        int parenContent = gData.parens_index(parenIndex);\n+        if (parenContent == -1)\n+            return true;\n+\n+        len = gData.parens_length(parenIndex);\n+        if ((gData.cp + len) > end)\n+            return false;\n+\n+        if ((gData.regexp.flags & JSREG_FOLD) != 0) {\n+            for (i = 0; i < len; i++) {\n+                if (upcase(chars[parenContent + i]) != upcase(chars[gData.cp + i]))\n+                    return false;\n+            }\n+        }\n+        else {\n+            for (i = 0; i < len; i++) {\n+                if (chars[parenContent + i] != chars[gData.cp + i])\n+                    return false;\n+            }\n+        }\n+        gData.cp += len;\n+        return true;\n+    }\n+\n+\n+    /* Add a single character to the RECharSet */\n+    private static void\n+    addCharacterToCharSet(RECharSet cs, char c)\n+    {\n+        int byteIndex = (c / 8);\n+        if (c > cs.length)\n+            throw new RuntimeException();\n+        cs.bits[byteIndex] |= 1 << (c & 0x7);\n+    }\n+\n+\n+    /* Add a character range, c1 to c2 (inclusive) to the RECharSet */\n+    private static void\n+    addCharacterRangeToCharSet(RECharSet cs, char c1, char c2)\n+    {\n+        int i;\n+\n+        int byteIndex1 = (c1 / 8);\n+        int byteIndex2 = (c2 / 8);\n+\n+        if ((c2 > cs.length) || (c1 > c2))\n+            throw new RuntimeException();\n+\n+        c1 &= 0x7;\n+        c2 &= 0x7;\n+\n+        if (byteIndex1 == byteIndex2) {\n+            cs.bits[byteIndex1] |= ((0xFF) >> (7 - (c2 - c1))) << c1;\n+        }\n+        else {\n+            cs.bits[byteIndex1] |= 0xFF << c1;\n+            for (i = byteIndex1 + 1; i < byteIndex2; i++)\n+                cs.bits[i] = (byte)0xFF;\n+            cs.bits[byteIndex2] |= (0xFF) >> (7 - c2);\n+        }\n+    }\n+\n+    /* Compile the source of the class into a RECharSet */\n+    private static void\n+    processCharSet(REGlobalData gData, RECharSet charSet)\n+    {\n+        synchronized (charSet) {\n+            if (!charSet.converted) {\n+                processCharSetImpl(gData, charSet);\n+                charSet.converted = true;\n+            }\n+        }\n+    }\n+\n+\n+    private static void\n+    processCharSetImpl(REGlobalData gData, RECharSet charSet)\n+    {\n+        int src = charSet.startIndex;\n+        int end = src + charSet.strlength;\n+\n+        char rangeStart = 0, thisCh;\n+        int byteLength;\n+        char c;\n+        int n;\n+        int nDigits;\n+        int i;\n+        boolean inRange = false;\n+\n+        charSet.sense = true;\n+        byteLength = (charSet.length / 8) + 1;\n+        charSet.bits = new byte[byteLength];\n+\n+        if (src == end)\n+            return;\n+\n+        if (gData.regexp.source[src] == '^') {\n+            charSet.sense = false;\n+            ++src;\n+        }\n+\n+        while (src != end) {\n+            nDigits = 2;\n+            switch (gData.regexp.source[src]) {\n+            case '\\\\':\n+                ++src;\n+                c = gData.regexp.source[src++];\n+                switch (c) {\n+                case 'b':\n+                    thisCh = 0x8;\n+                    break;\n+                case 'f':\n+                    thisCh = 0xC;\n+                    break;\n+                case 'n':\n+                    thisCh = 0xA;\n+                    break;\n+                case 'r':\n+                    thisCh = 0xD;\n+                    break;\n+                case 't':\n+                    thisCh = 0x9;\n+                    break;\n+                case 'v':\n+                    thisCh = 0xB;\n+                    break;\n+                case 'c':\n+                    if (((src + 1) < end) && isWord(gData.regexp.source[src + 1]))\n+                        thisCh = (char)(gData.regexp.source[src++] & 0x1F);\n+                    else {\n+                        --src;\n+                        thisCh = '\\\\';\n+                    }\n+                    break;\n+                case 'u':\n+                    nDigits += 2;\n+                    // fall thru\n+                case 'x':\n+                    n = 0;\n+                    for (i = 0; (i < nDigits) && (src < end); i++) {\n+                        c = gData.regexp.source[src++];\n+                        int digit = toASCIIHexDigit(c);\n+                        if (digit < 0) {\n+                            /* back off to accepting the original '\\'\n+                             * as a literal\n+                             */\n+                            src -= (i + 1);\n+                            n = '\\\\';\n+                            break;\n+                        }\n+                        n = (n << 4) | digit;\n+                    }\n+                    thisCh = (char)(n);\n+                    break;\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                    /*\n+                     *  This is a non-ECMA extension - decimal escapes (in this\n+                     *  case, octal!) are supposed to be an error inside class\n+                     *  ranges, but supported here for backwards compatibility.\n+                     *\n+                     */\n+                    n = (c - '0');\n+                    c = gData.regexp.source[src];\n+                    if ('0' <= c && c <= '7') {\n+                        src++;\n+                        n = 8 * n + (c - '0');\n+                        c = gData.regexp.source[src];\n+                        if ('0' <= c && c <= '7') {\n+                            src++;\n+                            i = 8 * n + (c - '0');\n+                            if (i <= 0377)\n+                                n = i;\n+                            else\n+                                src--;\n+                        }\n+                    }\n+                    thisCh = (char)(n);\n+                    break;\n+\n+                case 'd':\n+                    addCharacterRangeToCharSet(charSet, '0', '9');\n+                    continue;   /* don't need range processing */\n+                case 'D':\n+                    addCharacterRangeToCharSet(charSet, (char)0, (char)('0' - 1));\n+                    addCharacterRangeToCharSet(charSet, (char)('9' + 1),\n+                                                (char)(charSet.length));\n+                    continue;\n+                case 's':\n+                    for (i = charSet.length; i >= 0; i--)\n+                        if (isREWhiteSpace(i))\n+                            addCharacterToCharSet(charSet, (char)(i));\n+                    continue;\n+                case 'S':\n+                    for (i = charSet.length; i >= 0; i--)\n+                        if (!isREWhiteSpace(i))\n+                            addCharacterToCharSet(charSet, (char)(i));\n+                    continue;\n+                case 'w':\n+                    for (i = charSet.length; i >= 0; i--)\n+                        if (isWord((char)i))\n+                            addCharacterToCharSet(charSet, (char)(i));\n+                    continue;\n+                case 'W':\n+                    for (i = charSet.length; i >= 0; i--)\n+                        if (!isWord((char)i))\n+                            addCharacterToCharSet(charSet, (char)(i));\n+                    continue;\n+                default:\n+                    thisCh = c;\n+                    break;\n+\n+                }\n+                break;\n+\n+            default:\n+                thisCh = gData.regexp.source[src++];\n+                break;\n+\n+            }\n+            if (inRange) {\n+                if ((gData.regexp.flags & JSREG_FOLD) != 0) {\n+                    addCharacterRangeToCharSet(charSet,\n+                                               upcase(rangeStart),\n+                                               upcase(thisCh));\n+                    addCharacterRangeToCharSet(charSet,\n+                                               downcase(rangeStart),\n+                                               downcase(thisCh));\n+                } else {\n+                    addCharacterRangeToCharSet(charSet, rangeStart, thisCh);\n+                }\n+                inRange = false;\n+            }\n+            else {\n+                if ((gData.regexp.flags & JSREG_FOLD) != 0) {\n+                    addCharacterToCharSet(charSet, upcase(thisCh));\n+                    addCharacterToCharSet(charSet, downcase(thisCh));\n+                } else {\n+                    addCharacterToCharSet(charSet, thisCh);\n+                }\n+                if (src < (end - 1)) {\n+                    if (gData.regexp.source[src] == '-') {\n+                        ++src;\n+                        inRange = true;\n+                        rangeStart = thisCh;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    /*\n+     *   Initialize the character set if it this is the first call.\n+     *   Test the bit - if the ^ flag was specified, non-inclusion is a success\n+     */\n+    private static boolean\n+    classMatcher(REGlobalData gData, RECharSet charSet, char ch)\n+    {\n+        if (!charSet.converted) {\n+            processCharSet(gData, charSet);\n+        }\n+\n+        int byteIndex = ch / 8;\n+        if (charSet.sense) {\n+            if ((charSet.length == 0) ||\n+                 ( (ch > charSet.length)\n+                    || ((charSet.bits[byteIndex] & (1 << (ch & 0x7))) == 0) ))\n+                return false;\n+        } else {\n+            if (! ((charSet.length == 0) ||\n+                     ( (ch > charSet.length)\n+                        || ((charSet.bits[byteIndex] & (1 << (ch & 0x7))) == 0) )))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    private static boolean\n+    executeREBytecode(REGlobalData gData, char[] chars, int end)\n+    {\n+        int pc = 0;\n+        byte program[] = gData.regexp.program;\n+        int currentContinuation_op;\n+        int currentContinuation_pc;\n+        boolean result = false;\n+\n+        currentContinuation_pc = 0;\n+        currentContinuation_op = REOP_END;\n+if (debug) {\n+System.out.println(\"Input = \\\"\" + new String(chars) + \"\\\", start at \" + gData.cp);\n+}\n+        int op = program[pc++];\n+        for (;;) {\n+if (debug) {\n+System.out.println(\"Testing at \" + gData.cp + \", op = \" + op);\n+}\n+            switch (op) {\n+            case REOP_EMPTY:\n+                result = true;\n+                break;\n+            case REOP_BOL:\n+                if (gData.cp != 0) {\n+                    if (gData.multiline ||\n+                            ((gData.regexp.flags & JSREG_MULTILINE) != 0)) {\n+                        if (!isLineTerm(chars[gData.cp - 1])) {\n+                            result = false;\n+                            break;\n+                        }\n+                    }\n+                    else {\n+                        result = false;\n+                        break;\n+                    }\n+                }\n+                result = true;\n+                break;\n+            case REOP_EOL:\n+                if (gData.cp != end) {\n+                    if (gData.multiline ||\n+                            ((gData.regexp.flags & JSREG_MULTILINE) != 0)) {\n+                        if (!isLineTerm(chars[gData.cp])) {\n+                            result = false;\n+                            break;\n+                        }\n+                    }\n+                    else {\n+                        result = false;\n+                        break;\n+                    }\n+                }\n+                result = true;\n+                break;\n+            case REOP_WBDRY:\n+                result = ((gData.cp == 0 || !isWord(chars[gData.cp - 1]))\n+                          ^ !((gData.cp < end) && isWord(chars[gData.cp])));\n+                break;\n+            case REOP_WNONBDRY:\n+                result = ((gData.cp == 0 || !isWord(chars[gData.cp - 1]))\n+                          ^ ((gData.cp < end) && isWord(chars[gData.cp])));\n+                break;\n+            case REOP_DOT:\n+                result = (gData.cp != end && !isLineTerm(chars[gData.cp]));\n+                if (result) {\n+                    gData.cp++;\n+                }\n+                break;\n+            case REOP_DIGIT:\n+                result = (gData.cp != end && isDigit(chars[gData.cp]));\n+                if (result) {\n+                    gData.cp++;\n+                }\n+                break;\n+            case REOP_NONDIGIT:\n+                result = (gData.cp != end && !isDigit(chars[gData.cp]));\n+                if (result) {\n+                    gData.cp++;\n+                }\n+                break;\n+            case REOP_SPACE:\n+                result = (gData.cp != end && isREWhiteSpace(chars[gData.cp]));\n+                if (result) {\n+                    gData.cp++;\n+                }\n+                break;\n+            case REOP_NONSPACE:\n+                result = (gData.cp != end && !isREWhiteSpace(chars[gData.cp]));\n+                if (result) {\n+                    gData.cp++;\n+                }\n+                break;\n+            case REOP_ALNUM:\n+                result = (gData.cp != end && isWord(chars[gData.cp]));\n+                if (result) {\n+                    gData.cp++;\n+                }\n+                break;\n+            case REOP_NONALNUM:\n+                result = (gData.cp != end && !isWord(chars[gData.cp]));\n+                if (result) {\n+                    gData.cp++;\n+                }\n+                break;\n+            case REOP_FLAT:\n+                {\n+                    int offset = getIndex(program, pc);\n+                    pc += INDEX_LEN;\n+                    int length = getIndex(program, pc);\n+                    pc += INDEX_LEN;\n+                    result = flatNMatcher(gData, offset, length, chars, end);\n+                }\n+                break;\n+            case REOP_FLATi:\n+                {\n+                    int offset = getIndex(program, pc);\n+                    pc += INDEX_LEN;\n+                    int length = getIndex(program, pc);\n+                    pc += INDEX_LEN;\n+                    result = flatNIMatcher(gData, offset, length, chars, end);\n+                }\n+                break;\n+            case REOP_FLAT1:\n+                {\n+                    char matchCh = (char)(program[pc++] & 0xFF);\n+                    result = (gData.cp != end && chars[gData.cp] == matchCh);\n+                    if (result) {\n+                        gData.cp++;\n+                    }\n+                }\n+                break;\n+            case REOP_FLAT1i:\n+                {\n+                    char matchCh = (char)(program[pc++] & 0xFF);\n+                    result = (gData.cp != end\n+                              && upcase(chars[gData.cp]) == upcase(matchCh));\n+                    if (result) {\n+                        gData.cp++;\n+                    }\n+                }\n+                break;\n+            case REOP_UCFLAT1:\n+                {\n+                    char matchCh = (char)getIndex(program, pc);\n+                    pc += INDEX_LEN;\n+                    result = (gData.cp != end && chars[gData.cp] == matchCh);\n+                    if (result) {\n+                        gData.cp++;\n+                    }\n+                }\n+                break;\n+            case REOP_UCFLAT1i:\n+                {\n+                    char matchCh = (char)getIndex(program, pc);\n+                    pc += INDEX_LEN;\n+                    result = (gData.cp != end\n+                              && upcase(chars[gData.cp]) == upcase(matchCh));\n+                    if (result) {\n+                        gData.cp++;\n+                    }\n+                }\n+                break;\n+            case REOP_ALT:\n+                {\n+                    int nextpc;\n+                    byte nextop;\n+                    pushProgState(gData, 0, 0, null,\n+                                  currentContinuation_pc,\n+                                  currentContinuation_op);\n+                    nextpc = pc + getOffset(program, pc);\n+                    nextop = program[nextpc++];\n+                    pushBackTrackState(gData, nextop, nextpc);\n+                    pc += INDEX_LEN;\n+                    op = program[pc++];\n+                }\n+                continue;\n+\n+            case REOP_JUMP:\n+                {\n+                    int offset;\n+                    REProgState state = popProgState(gData);\n+                    currentContinuation_pc = state.continuation_pc;\n+                    currentContinuation_op = state.continuation_op;\n+                    offset = getOffset(program, pc);\n+                    pc += offset;\n+                    op = program[pc++];\n+                }\n+                continue;\n+\n+\n+            case REOP_LPAREN:\n+                {\n+                    int parenIndex = getIndex(program, pc);\n+                    pc += INDEX_LEN;\n+                    gData.set_parens(parenIndex, gData.cp, 0);\n+                    op = program[pc++];\n+                }\n+                continue;\n+            case REOP_RPAREN:\n+                {\n+                    int cap_index;\n+                    int parenIndex = getIndex(program, pc);\n+                    pc += INDEX_LEN;\n+                    cap_index = gData.parens_index(parenIndex);\n+                    gData.set_parens(parenIndex, cap_index,\n+                                     gData.cp - cap_index);\n+                    if (parenIndex > gData.lastParen)\n+                        gData.lastParen = parenIndex;\n+                    op = program[pc++];\n+                }\n+                continue;\n+            case REOP_BACKREF:\n+                {\n+                    int parenIndex = getIndex(program, pc);\n+                    pc += INDEX_LEN;\n+                    result = backrefMatcher(gData, parenIndex, chars, end);\n+                }\n+                break;\n+\n+            case REOP_CLASS:\n+                {\n+                    int index = getIndex(program, pc);\n+                    pc += INDEX_LEN;\n+                    if (gData.cp != end) {\n+                        if (classMatcher(gData, gData.regexp.classList[index],\n+                                         chars[gData.cp]))\n+                        {\n+                            gData.cp++;\n+                            result = true;\n+                            break;\n+                        }\n+                    }\n+                    result = false;\n+                }\n+                break;\n+\n+            case REOP_ASSERT:\n+            case REOP_ASSERT_NOT:\n+                {\n+                    byte testOp;\n+                    pushProgState(gData, 0, 0, gData.backTrackStackTop,\n+                                  currentContinuation_pc,\n+                                  currentContinuation_op);\n+                    if (op == REOP_ASSERT) {\n+                        testOp = REOP_ASSERTTEST;\n+                    } else {\n+                        testOp = REOP_ASSERTNOTTEST;\n+                    }\n+                    pushBackTrackState(gData, testOp,\n+                                       pc + getOffset(program, pc));\n+                    pc += INDEX_LEN;\n+                    op = program[pc++];\n+                }\n+                continue;\n+\n+            case REOP_ASSERTTEST:\n+            case REOP_ASSERTNOTTEST:\n+                {\n+                    REProgState state = popProgState(gData);\n+                    gData.cp = state.index;\n+                    gData.backTrackStackTop = state.backTrack;\n+                    currentContinuation_pc = state.continuation_pc;\n+                    currentContinuation_op = state.continuation_op;\n+                    if (result) {\n+                        if (op == REOP_ASSERTTEST) {\n+                            result = true;\n+                        } else {\n+                            result = false;\n+                        }\n+                    } else {\n+                        if (op == REOP_ASSERTTEST) {\n+                            // Do nothing\n+                        } else {\n+                            result = true;\n+                        }\n+                    }\n+                }\n+                break;\n+\n+            case REOP_STAR:\n+            case REOP_PLUS:\n+            case REOP_OPT:\n+            case REOP_QUANT:\n+            case REOP_MINIMALSTAR:\n+            case REOP_MINIMALPLUS:\n+            case REOP_MINIMALOPT:\n+            case REOP_MINIMALQUANT:\n+                {\n+                    int min, max;\n+                    boolean greedy = false;\n+                    switch (op) {\n+                      case REOP_STAR:\n+                        greedy = true;\n+                        // fallthrough\n+                      case REOP_MINIMALSTAR:\n+                        min = 0;\n+                        max = -1;\n+                        break;\n+                      case REOP_PLUS:\n+                        greedy = true;\n+                        // fallthrough\n+                      case REOP_MINIMALPLUS:\n+                        min = 1;\n+                        max = -1;\n+                        break;\n+                      case REOP_OPT:\n+                        greedy = true;\n+                        // fallthrough\n+                      case REOP_MINIMALOPT:\n+                        min = 0;\n+                        max = 1;\n+                        break;\n+                      case REOP_QUANT:\n+                        greedy = true;\n+                        // fallthrough\n+                      case REOP_MINIMALQUANT:\n+                        min = getOffset(program, pc);\n+                        pc += INDEX_LEN;\n+                        // See comments in emitREBytecode for \" - 1\" reason\n+                        max = getOffset(program, pc) - 1;\n+                        pc += INDEX_LEN;\n+                        break;\n+                      default:\n+                        throw Kit.codeBug();\n+                    }\n+                    pushProgState(gData, min, max, null,\n+                                  currentContinuation_pc,\n+                                  currentContinuation_op);\n+                    if (greedy) {\n+                        currentContinuation_op = REOP_REPEAT;\n+                        currentContinuation_pc = pc;\n+                        pushBackTrackState(gData, REOP_REPEAT, pc);\n+                        /* Step over <parencount>, <parenindex> & <next> */\n+                        pc += 3 * INDEX_LEN;\n+                        op = program[pc++];\n+                    } else {\n+                        if (min != 0) {\n+                            currentContinuation_op = REOP_MINIMALREPEAT;\n+                            currentContinuation_pc = pc;\n+                            /* <parencount> <parenindex> & <next> */\n+                            pc += 3 * INDEX_LEN;\n+                            op = program[pc++];\n+                        } else {\n+                            pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);\n+                            popProgState(gData);\n+                            pc += 2 * INDEX_LEN;  // <parencount> & <parenindex>\n+                            pc = pc + getOffset(program, pc);\n+                            op = program[pc++];\n+                        }\n+                    }\n+                }\n+                continue;\n+\n+            case REOP_ENDCHILD:\n+                // Use the current continuation.\n+                pc = currentContinuation_pc;\n+                op = currentContinuation_op;\n+                continue;\n+\n+            case REOP_REPEAT:\n+                {\n+                    REProgState state = popProgState(gData);\n+                    if (!result) {\n+                        //\n+                        // There's been a failure, see if we have enough\n+                        // children.\n+                        //\n+                        if (state.min == 0)\n+                            result = true;\n+                        currentContinuation_pc = state.continuation_pc;\n+                        currentContinuation_op = state.continuation_op;\n+                        pc += 2 * INDEX_LEN;  /* <parencount> & <parenindex> */\n+                        pc = pc + getOffset(program, pc);\n+                        break;\n+                    }\n+                    else {\n+                        if (state.min == 0 && gData.cp == state.index) {\n+                            // matched an empty string, that'll get us nowhere\n+                            result = false;\n+                            currentContinuation_pc = state.continuation_pc;\n+                            currentContinuation_op = state.continuation_op;\n+                            pc += 2 * INDEX_LEN;\n+                            pc = pc + getOffset(program, pc);\n+                            break;\n+                        }\n+                        int new_min = state.min, new_max = state.max;\n+                        if (new_min != 0) new_min--;\n+                        if (new_max != -1) new_max--;\n+                        if (new_max == 0) {\n+                            result = true;\n+                            currentContinuation_pc = state.continuation_pc;\n+                            currentContinuation_op = state.continuation_op;\n+                            pc += 2 * INDEX_LEN;\n+                            pc = pc + getOffset(program, pc);\n+                            break;\n+                        }\n+                        pushProgState(gData, new_min, new_max, null,\n+                                      state.continuation_pc,\n+                                      state.continuation_op);\n+                        currentContinuation_op = REOP_REPEAT;\n+                        currentContinuation_pc = pc;\n+                        pushBackTrackState(gData, REOP_REPEAT, pc);\n+                        int parenCount = getIndex(program, pc);\n+                        pc += INDEX_LEN;\n+                        int parenIndex = getIndex(program, pc);\n+                        pc += 2 * INDEX_LEN;\n+                        op = program[pc++];\n+                        for (int k = 0; k < parenCount; k++) {\n+                            gData.set_parens(parenIndex + k, -1, 0);\n+                        }\n+                    }\n+                }\n+                continue;\n+\n+            case REOP_MINIMALREPEAT:\n+                {\n+                    REProgState state = popProgState(gData);\n+                    if (!result) {\n+                        //\n+                        // Non-greedy failure - try to consume another child.\n+                        //\n+                        if (state.max == -1 || state.max > 0) {\n+                            pushProgState(gData, state.min, state.max, null,\n+                                          state.continuation_pc,\n+                                          state.continuation_op);\n+                            currentContinuation_op = REOP_MINIMALREPEAT;\n+                            currentContinuation_pc = pc;\n+                            int parenCount = getIndex(program, pc);\n+                            pc += INDEX_LEN;\n+                            int parenIndex = getIndex(program, pc);\n+                            pc += 2 * INDEX_LEN;\n+                            for (int k = 0; k < parenCount; k++) {\n+                                gData.set_parens(parenIndex + k, -1, 0);\n+                            }\n+                            op = program[pc++];\n+                            continue;\n+                        } else {\n+                            // Don't need to adjust pc since we're going to pop.\n+                            currentContinuation_pc = state.continuation_pc;\n+                            currentContinuation_op = state.continuation_op;\n+                            break;\n+                        }\n+                    } else {\n+                        if (state.min == 0 && gData.cp == state.index) {\n+                            // Matched an empty string, that'll get us nowhere.\n+                            result = false;\n+                            currentContinuation_pc = state.continuation_pc;\n+                            currentContinuation_op = state.continuation_op;\n+                            break;\n+                        }\n+                        int new_min = state.min, new_max = state.max;\n+                        if (new_min != 0) new_min--;\n+                        if (new_max != -1) new_max--;\n+                        pushProgState(gData, new_min, new_max, null,\n+                                      state.continuation_pc,\n+                                      state.continuation_op);\n+                        if (new_min != 0) {\n+                            currentContinuation_op = REOP_MINIMALREPEAT;\n+                            currentContinuation_pc = pc;\n+                            int parenCount = getIndex(program, pc);\n+                            pc += INDEX_LEN;\n+                            int parenIndex = getIndex(program, pc);\n+                            pc += 2 * INDEX_LEN;\n+                            for (int k = 0; k < parenCount; k++) {\n+                                gData.set_parens(parenIndex + k, -1, 0);\n+                            }\n+                            op = program[pc++];\n+                        } else {\n+                            currentContinuation_pc = state.continuation_pc;\n+                            currentContinuation_op = state.continuation_op;\n+                            pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);\n+                            popProgState(gData);\n+                            pc += 2 * INDEX_LEN;\n+                            pc = pc + getOffset(program, pc);\n+                            op = program[pc++];\n+                        }\n+                        continue;\n+                    }\n+                }\n+\n+            case REOP_END:\n+                return true;\n+\n+            default:\n+                throw Kit.codeBug();\n+\n+            }\n+            /*\n+             *  If the match failed and there's a backtrack option, take it.\n+             *  Otherwise this is a complete and utter failure.\n+             */\n+            if (!result) {\n+                REBackTrackData backTrackData = gData.backTrackStackTop;\n+                if (backTrackData != null) {\n+                    gData.backTrackStackTop = backTrackData.previous;\n+\n+                    gData.lastParen = backTrackData.lastParen;\n+\n+                    // XXX: If backTrackData will no longer be used, then\n+                    // there is no need to clone backTrackData.parens\n+                    if (backTrackData.parens != null) {\n+                        gData.parens = backTrackData.parens.clone();\n+                    }\n+\n+                    gData.cp = backTrackData.cp;\n+\n+                    gData.stateStackTop = backTrackData.stateStackTop;\n+\n+                    currentContinuation_op\n+                        = gData.stateStackTop.continuation_op;\n+                    currentContinuation_pc\n+                        = gData.stateStackTop.continuation_pc;\n+                    pc = backTrackData.continuation_pc;\n+                    op = backTrackData.continuation_op;\n+                    continue;\n+                }\n+                else\n+                    return false;\n+            }\n+\n+            op = program[pc++];\n+        }\n+\n+    }\n+\n+    private static boolean\n+    matchRegExp(REGlobalData gData, RECompiled re,\n+                char[] chars, int start, int end, boolean multiline)\n+    {\n+        if (re.parenCount != 0) {\n+            gData.parens = new long[re.parenCount];\n+        } else {\n+            gData.parens = null;\n+        }\n+\n+        gData.backTrackStackTop = null;\n+\n+        gData.stateStackTop = null;\n+\n+        gData.multiline = multiline;\n+        gData.regexp = re;\n+        gData.lastParen = 0;\n+\n+        int anchorCh = gData.regexp.anchorCh;\n+        //\n+        // have to include the position beyond the last character\n+        //  in order to detect end-of-input/line condition\n+        //\n+        for (int i = start; i <= end; ++i) {\n+            //\n+            // If the first node is a literal match, step the index into\n+            // the string until that match is made, or fail if it can't be\n+            // found at all.\n+            //\n+            if (anchorCh >= 0) {\n+                for (;;) {\n+                    if (i == end) {\n+                        return false;\n+                    }\n+                    char matchCh = chars[i];\n+                    if (matchCh == anchorCh ||\n+                            ((gData.regexp.flags & JSREG_FOLD) != 0\n+                             && upcase(matchCh) == upcase((char)anchorCh)))\n+                    {\n+                        break;\n+                    }\n+                    ++i;\n+                }\n+            }\n+            gData.cp = i;\n+            for (int j = 0; j < re.parenCount; j++) {\n+                gData.set_parens(j, -1, 0);\n+            }\n+            boolean result = executeREBytecode(gData, chars, end);\n+\n+            gData.backTrackStackTop = null;\n+            gData.stateStackTop = null;\n+            if (result) {\n+                gData.skipped = i - start;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /*\n+     * indexp is assumed to be an array of length 1\n+     */\n+    Object executeRegExp(Context cx, Scriptable scopeObj, RegExpImpl res,\n+                         String str, int indexp[], int matchType)\n+    {\n+        REGlobalData gData = new REGlobalData();\n+\n+        int start = indexp[0];\n+        char[] charArray = str.toCharArray();\n+        int end = charArray.length;\n+        if (start > end)\n+            start = end;\n+        //\n+        // Call the recursive matcher to do the real work.\n+        //\n+        boolean matches = matchRegExp(gData, re, charArray, start, end,\n+                                      res.multiline);\n+        if (!matches) {\n+            if (matchType != PREFIX) return null;\n+            return Undefined.instance;\n+        }\n+        int index = gData.cp;\n+        int i = index;\n+        indexp[0] = i;\n+        int matchlen = i - (start + gData.skipped);\n+        int ep = index;\n+        index -= matchlen;\n+        Object result;\n+        Scriptable obj;\n+\n+        if (matchType == TEST) {\n+            /*\n+             * Testing for a match and updating cx.regExpImpl: don't allocate\n+             * an array object, do return true.\n+             */\n+            result = Boolean.TRUE;\n+            obj = null;\n+        }\n+        else {\n+            /*\n+             * The array returned on match has element 0 bound to the matched\n+             * string, elements 1 through re.parenCount bound to the paren\n+             * matches, an index property telling the length of the left context,\n+             * and an input property referring to the input string.\n+             */\n+            Scriptable scope = getTopLevelScope(scopeObj);\n+            result = ScriptRuntime.newObject(cx, scope, \"Array\", null);\n+            obj = (Scriptable) result;\n+\n+            String matchstr = new String(charArray, index, matchlen);\n+            obj.put(0, obj, matchstr);\n+        }\n+\n+        if (re.parenCount == 0) {\n+            res.parens = null;\n+            res.lastParen = SubString.emptySubString;\n+        } else {\n+            SubString parsub = null;\n+            int num;\n+            res.parens = new SubString[re.parenCount];\n+            for (num = 0; num < re.parenCount; num++) {\n+                int cap_index = gData.parens_index(num);\n+                String parstr;\n+                if (cap_index != -1) {\n+                    int cap_length = gData.parens_length(num);\n+                    parsub = new SubString(charArray, cap_index, cap_length);\n+                    res.parens[num] = parsub;\n+                    if (matchType == TEST) continue;\n+                    parstr = parsub.toString();\n+                    obj.put(num+1, obj, parstr);\n+                }\n+                else {\n+                    if (matchType != TEST)\n+                        obj.put(num+1, obj, Undefined.instance);\n+                }\n+            }\n+            res.lastParen = parsub;\n+        }\n+\n+        if (! (matchType == TEST)) {\n+            /*\n+             * Define the index and input properties last for better for/in loop\n+             * order (so they come after the elements).\n+             */\n+            obj.put(\"index\", obj, Integer.valueOf(start + gData.skipped));\n+            obj.put(\"input\", obj, str);\n+        }\n+\n+        if (res.lastMatch == null) {\n+            res.lastMatch = new SubString();\n+            res.leftContext = new SubString();\n+            res.rightContext = new SubString();\n+        }\n+        res.lastMatch.charArray = charArray;\n+        res.lastMatch.index = index;\n+        res.lastMatch.length = matchlen;\n+\n+        res.leftContext.charArray = charArray;\n+        if (cx.getLanguageVersion() == Context.VERSION_1_2) {\n+            /*\n+             * JS1.2 emulated Perl4.0.1.8 (patch level 36) for global regexps used\n+             * in scalar contexts, and unintentionally for the string.match \"list\"\n+             * psuedo-context.  On \"hi there bye\", the following would result:\n+             *\n+             * Language     while(/ /g){print(\"$`\");}   s/ /$`/g\n+             * perl4.036    \"hi\", \"there\"               \"hihitherehi therebye\"\n+             * perl5        \"hi\", \"hi there\"            \"hihitherehi therebye\"\n+             * js1.2        \"hi\", \"there\"               \"hihitheretherebye\"\n+             *\n+             * Insofar as JS1.2 always defined $` as \"left context from the last\n+             * match\" for global regexps, it was more consistent than perl4.\n+             */\n+            res.leftContext.index = start;\n+            res.leftContext.length = gData.skipped;\n+        } else {\n+            /*\n+             * For JS1.3 and ECMAv2, emulate Perl5 exactly:\n+             *\n+             * js1.3        \"hi\", \"hi there\"            \"hihitherehi therebye\"\n+             */\n+            res.leftContext.index = 0;\n+            res.leftContext.length = start + gData.skipped;\n+        }\n+\n+        res.rightContext.charArray = charArray;\n+        res.rightContext.index = ep;\n+        res.rightContext.length = end - ep;\n+\n+        return result;\n+    }\n+\n+    int getFlags()\n+    {\n+        return re.flags;\n+    }\n+\n+    private static void reportWarning(Context cx, String messageId, String arg)\n+    {\n+        if (cx.hasFeature(Context.FEATURE_STRICT_MODE)) {\n+            String msg = ScriptRuntime.getMessage1(messageId, arg);\n+            Context.reportWarning(msg);\n+        }\n+    }\n+\n+    private static void reportError(String messageId, String arg)\n+    {\n+        String msg = ScriptRuntime.getMessage1(messageId, arg);\n+        throw ScriptRuntime.constructError(\"SyntaxError\", msg);\n+    }\n+\n+// #string_id_map#\n+\n+    private static final int\n+        Id_lastIndex    = 1,\n+        Id_source       = 2,\n+        Id_global       = 3,\n+        Id_ignoreCase   = 4,\n+        Id_multiline    = 5,\n+\n+        MAX_INSTANCE_ID = 5;\n+\n+    @Override\n+    protected int getMaxInstanceId()\n+    {\n+        return MAX_INSTANCE_ID;\n+    }\n+\n+    @Override\n+    protected int findInstanceIdInfo(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-05-09 08:16:24 EDT\n+        L0: { id = 0; String X = null; int c;\n+            int s_length = s.length();\n+            if (s_length==6) {\n+                c=s.charAt(0);\n+                if (c=='g') { X=\"global\";id=Id_global; }\n+                else if (c=='s') { X=\"source\";id=Id_source; }\n+            }\n+            else if (s_length==9) {\n+                c=s.charAt(0);\n+                if (c=='l') { X=\"lastIndex\";id=Id_lastIndex; }\n+                else if (c=='m') { X=\"multiline\";id=Id_multiline; }\n+            }\n+            else if (s_length==10) { X=\"ignoreCase\";id=Id_ignoreCase; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+// #/string_id_map#\n+\n+        if (id == 0) return super.findInstanceIdInfo(s);\n+\n+        int attr;\n+        switch (id) {\n+          case Id_lastIndex:\n+            attr = PERMANENT | DONTENUM;\n+            break;\n+          case Id_source:\n+          case Id_global:\n+          case Id_ignoreCase:\n+          case Id_multiline:\n+            attr = PERMANENT | READONLY | DONTENUM;\n+            break;\n+          default:\n+            throw new IllegalStateException();\n+        }\n+        return instanceIdInfo(attr, id);\n+    }\n+\n+    @Override\n+    protected String getInstanceIdName(int id)\n+    {\n+        switch (id) {\n+            case Id_lastIndex:  return \"lastIndex\";\n+            case Id_source:     return \"source\";\n+            case Id_global:     return \"global\";\n+            case Id_ignoreCase: return \"ignoreCase\";\n+            case Id_multiline:  return \"multiline\";\n+        }\n+        return super.getInstanceIdName(id);\n+    }\n+\n+    @Override\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        switch (id) {\n+          case Id_lastIndex:\n+            return ScriptRuntime.wrapNumber(lastIndex);\n+          case Id_source:\n+            return new String(re.source);\n+          case Id_global:\n+            return ScriptRuntime.wrapBoolean((re.flags & JSREG_GLOB) != 0);\n+          case Id_ignoreCase:\n+            return ScriptRuntime.wrapBoolean((re.flags & JSREG_FOLD) != 0);\n+          case Id_multiline:\n+            return ScriptRuntime.wrapBoolean((re.flags & JSREG_MULTILINE) != 0);\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+    @Override\n+    protected void setInstanceIdValue(int id, Object value)\n+    {\n+        if (id == Id_lastIndex) {\n+            lastIndex = ScriptRuntime.toNumber(value);\n+            return;\n+        }\n+        super.setInstanceIdValue(id, value);\n+    }\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_compile:  arity=1; s=\"compile\";  break;\n+          case Id_toString: arity=0; s=\"toString\"; break;\n+          case Id_toSource: arity=0; s=\"toSource\"; break;\n+          case Id_exec:     arity=1; s=\"exec\";     break;\n+          case Id_test:     arity=1; s=\"test\";     break;\n+          case Id_prefix:   arity=1; s=\"prefix\";   break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(REGEXP_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(REGEXP_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_compile:\n+            return realThis(thisObj, f).compile(cx, scope, args);\n+\n+          case Id_toString:\n+          case Id_toSource:\n+            return realThis(thisObj, f).toString();\n+\n+          case Id_exec:\n+            return realThis(thisObj, f).execSub(cx, scope, args, MATCH);\n+\n+          case Id_test: {\n+            Object x = realThis(thisObj, f).execSub(cx, scope, args, TEST);\n+            return Boolean.TRUE.equals(x) ? Boolean.TRUE : Boolean.FALSE;\n+          }\n+\n+          case Id_prefix:\n+            return realThis(thisObj, f).execSub(cx, scope, args, PREFIX);\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private static NativeRegExp realThis(Scriptable thisObj, IdFunctionObject f)\n+    {\n+        if (!(thisObj instanceof NativeRegExp))\n+            throw incompatibleCallError(f);\n+        return (NativeRegExp)thisObj;\n+    }\n+\n+// #string_id_map#\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-05-09 08:16:24 EDT\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 4: c=s.charAt(0);\n+                if (c=='e') { X=\"exec\";id=Id_exec; }\n+                else if (c=='t') { X=\"test\";id=Id_test; }\n+                break L;\n+            case 6: X=\"prefix\";id=Id_prefix; break L;\n+            case 7: X=\"compile\";id=Id_compile; break L;\n+            case 8: c=s.charAt(3);\n+                if (c=='o') { X=\"toSource\";id=Id_toSource; }\n+                else if (c=='t') { X=\"toString\";id=Id_toString; }\n+                break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+\n+    private static final int\n+        Id_compile       = 1,\n+        Id_toString      = 2,\n+        Id_toSource      = 3,\n+        Id_exec          = 4,\n+        Id_test          = 5,\n+        Id_prefix        = 6,\n+\n+        MAX_PROTOTYPE_ID = 6;\n+\n+// #/string_id_map#\n+\n+    private RECompiled re;\n+    double lastIndex;          /* index after last match, for //g iterator */\n+\n+}       // class NativeRegExp\n+\n+class RECompiled implements Serializable\n+{\n+    static final long serialVersionUID = -6144956577595844213L;\n+\n+    char []source;          /* locked source string, sans // */\n+    int parenCount;         /* number of parenthesized submatches */\n+    int flags;              /* flags  */\n+    byte[] program;         /* regular expression bytecode */\n+    int classCount;         /* count [...] bitmaps */\n+    RECharSet[] classList;  /* list of [...] bitmaps */\n+    int anchorCh = -1;      /* if >= 0, then re starts with this literal char */\n+}\n+\n+class RENode {\n+\n+    RENode(byte op)\n+    {\n+        this.op = op;\n+    }\n+\n+    byte            op;         /* r.e. op bytecode */\n+    RENode          next;       /* next in concatenation order */\n+    RENode          kid;        /* first operand */\n+\n+    RENode          kid2;       /* second operand */\n+    int             num;        /* could be a number */\n+    int             parenIndex; /* or a parenthesis index */\n+\n+                                /* or a range */\n+    int             min;\n+    int             max;\n+    int             parenCount;\n+    boolean         greedy;\n+\n+                                /* or a character class */\n+    int             startIndex;\n+    int             kidlen;     /* length of string at kid, in chars */\n+    int             bmsize;     /* bitmap size, based on max char code */\n+    int             index;      /* index into class list */\n+\n+                                /* or a literal sequence */\n+    char            chr;        /* of one character */\n+    int             length;     /* or many (via the index) */\n+    int             flatIndex;  /* which is -1 if not sourced */\n+\n+}\n+\n+class CompilerState {\n+\n+    CompilerState(Context cx, char[] source, int length, int flags)\n+    {\n+        this.cx = cx;\n+        this.cpbegin = source;\n+        this.cp = 0;\n+        this.cpend = length;\n+        this.flags = flags;\n+        this.parenCount = 0;\n+        this.classCount = 0;\n+        this.progLength = 0;\n+    }\n+\n+    Context     cx;\n+    char        cpbegin[];\n+    int         cpend;\n+    int         cp;\n+    int         flags;\n+    int         parenCount;\n+    int         parenNesting;\n+    int         classCount;   /* number of [] encountered */\n+    int         progLength;   /* estimated bytecode length */\n+    RENode      result;\n+}\n+\n+class REProgState\n+{\n+    REProgState(REProgState previous, int min, int max, int index,\n+                REBackTrackData backTrack,\n+                int continuation_pc, int continuation_op)\n+    {\n+        this.previous = previous;\n+        this.min = min;\n+        this.max = max;\n+        this.index = index;\n+        this.continuation_op = continuation_op;\n+        this.continuation_pc = continuation_pc;\n+        this.backTrack = backTrack;\n+    }\n+\n+    REProgState previous; // previous state in stack\n+\n+    int min;                      /* current quantifier min */\n+    int max;                      /* current quantifier max */\n+    int index;                    /* progress in text */\n+    int continuation_op;\n+    int continuation_pc;\n+    REBackTrackData backTrack; // used by ASSERT_  to recover state\n+}\n+\n+class REBackTrackData {\n+\n+    REBackTrackData(REGlobalData gData, int op, int pc)\n+    {\n+        previous = gData.backTrackStackTop;\n+        continuation_op = op;\n+        continuation_pc = pc;\n+        lastParen = gData.lastParen;\n+        if (gData.parens != null) {\n+            parens = gData.parens.clone();\n+        }\n+        cp = gData.cp;\n+        stateStackTop = gData.stateStackTop;\n+    }\n+\n+    REBackTrackData previous;\n+\n+    int continuation_op;                /* where to backtrack to */\n+    int continuation_pc;\n+    int lastParen;\n+    long[] parens;                      /* parenthesis captures */\n+    int cp;                             /* char buffer index */\n+    REProgState stateStackTop;          /* state of op that backtracked */\n+}\n+\n+class REGlobalData {\n+    boolean multiline;\n+    RECompiled regexp;              /* the RE in execution */\n+    int lastParen;                  /* highest paren set so far */\n+    int skipped;                    /* chars skipped anchoring this r.e. */\n+\n+    int cp;                         /* char buffer index */\n+    long[] parens;                  /* parens captures */\n+\n+    REProgState stateStackTop;       /* stack of state of current ancestors */\n+\n+    REBackTrackData backTrackStackTop;  /* last matched-so-far position */\n+\n+\n+    /**\n+     * Get start of parenthesis capture contents, -1 for empty.\n+     */\n+    int parens_index(int i)\n+    {\n+        return (int)(parens[i]);\n+    }\n+\n+    /**\n+     * Get length of parenthesis capture contents.\n+     */\n+    int parens_length(int i)\n+    {\n+        return (int)(parens[i] >>> 32);\n+    }\n+\n+    void set_parens(int i, int index, int length)\n+    {\n+        parens[i] = (index & 0xffffffffL) | ((long)length << 32);\n+    }\n+\n+}\n+\n+/*\n+ * This struct holds a bitmap representation of a class from a regexp.\n+ * There's a list of these referenced by the classList field in the NativeRegExp\n+ * struct below. The initial state has startIndex set to the offset in the\n+ * original regexp source of the beginning of the class contents. The first\n+ * use of the class converts the source representation into a bitmap.\n+ *\n+ */\n+final class RECharSet implements Serializable\n+{\n+    static final long serialVersionUID = 7931787979395898394L;\n+\n+    RECharSet(int length, int startIndex, int strlength)\n+    {\n+        this.length = length;\n+        this.startIndex = startIndex;\n+        this.strlength = strlength;\n+    }\n+\n+    int length;\n+    int startIndex;\n+    int strlength;\n+\n+    volatile transient boolean converted;\n+    volatile transient boolean sense;\n+    volatile transient byte[] bits;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/regexp/NativeRegExpCtor.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Brendan Eich\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.regexp;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * This class implements the RegExp constructor native object.\n+ *\n+ * Revision History:\n+ * Implementation in C by Brendan Eich\n+ * Initial port to Java by Norris Boyd from jsregexp.c version 1.36\n+ * Merged up to version 1.38, which included Unicode support.\n+ * Merged bug fixes in version 1.39.\n+ * Merged JSFUN13_BRANCH changes up to 1.32.2.11\n+ *\n+ */\n+class NativeRegExpCtor extends BaseFunction\n+{\n+    static final long serialVersionUID = -5733330028285400526L;\n+\n+    NativeRegExpCtor()\n+    {\n+    }\n+\n+    @Override\n+    public String getFunctionName()\n+    {\n+        return \"RegExp\";\n+    }\n+\n+    @Override\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+                       Object[] args)\n+    {\n+        if (args.length > 0 && args[0] instanceof NativeRegExp &&\n+            (args.length == 1 || args[1] == Undefined.instance))\n+        {\n+            return args[0];\n+        }\n+        return construct(cx, scope, args);\n+    }\n+\n+    @Override\n+    public Scriptable construct(Context cx, Scriptable scope, Object[] args)\n+    {\n+        NativeRegExp re = new NativeRegExp();\n+        re.compile(cx, scope, args);\n+        ScriptRuntime.setObjectProtoAndParent(re, scope);\n+        return re;\n+    }\n+\n+    private static RegExpImpl getImpl()\n+    {\n+        Context cx = Context.getCurrentContext();\n+        return (RegExpImpl) ScriptRuntime.getRegExpProxy(cx);\n+    }\n+\n+// #string_id_map#\n+\n+    private static final int\n+        Id_multiline     = 1,\n+        Id_STAR          = 2,  // #string=$*#\n+\n+        Id_input         = 3,\n+        Id_UNDERSCORE    = 4,  // #string=$_#\n+\n+        Id_lastMatch     = 5,\n+        Id_AMPERSAND     = 6,  // #string=$&#\n+\n+        Id_lastParen     = 7,\n+        Id_PLUS          = 8,  // #string=$+#\n+\n+        Id_leftContext   = 9,\n+        Id_BACK_QUOTE    = 10, // #string=$`#\n+\n+        Id_rightContext  = 11,\n+        Id_QUOTE         = 12, // #string=$'#\n+\n+        DOLLAR_ID_BASE   = 12;\n+\n+    private static final int\n+        Id_DOLLAR_1 = DOLLAR_ID_BASE + 1, // #string=$1#\n+        Id_DOLLAR_2 = DOLLAR_ID_BASE + 2, // #string=$2#\n+        Id_DOLLAR_3 = DOLLAR_ID_BASE + 3, // #string=$3#\n+        Id_DOLLAR_4 = DOLLAR_ID_BASE + 4, // #string=$4#\n+        Id_DOLLAR_5 = DOLLAR_ID_BASE + 5, // #string=$5#\n+        Id_DOLLAR_6 = DOLLAR_ID_BASE + 6, // #string=$6#\n+        Id_DOLLAR_7 = DOLLAR_ID_BASE + 7, // #string=$7#\n+        Id_DOLLAR_8 = DOLLAR_ID_BASE + 8, // #string=$8#\n+        Id_DOLLAR_9 = DOLLAR_ID_BASE + 9, // #string=$9#\n+\n+        MAX_INSTANCE_ID = DOLLAR_ID_BASE + 9;\n+\n+    @Override\n+    protected int getMaxInstanceId()\n+    {\n+        return super.getMaxInstanceId() + MAX_INSTANCE_ID;\n+    }\n+\n+    @Override\n+    protected int findInstanceIdInfo(String s) {\n+        int id;\n+// #generated# Last update: 2001-05-24 16:09:31 GMT+02:00\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 2: switch (s.charAt(1)) {\n+                case '&': if (s.charAt(0)=='$') {id=Id_AMPERSAND; break L0;} break L;\n+                case '\\'': if (s.charAt(0)=='$') {id=Id_QUOTE; break L0;} break L;\n+                case '*': if (s.charAt(0)=='$') {id=Id_STAR; break L0;} break L;\n+                case '+': if (s.charAt(0)=='$') {id=Id_PLUS; break L0;} break L;\n+                case '1': if (s.charAt(0)=='$') {id=Id_DOLLAR_1; break L0;} break L;\n+                case '2': if (s.charAt(0)=='$') {id=Id_DOLLAR_2; break L0;} break L;\n+                case '3': if (s.charAt(0)=='$') {id=Id_DOLLAR_3; break L0;} break L;\n+                case '4': if (s.charAt(0)=='$') {id=Id_DOLLAR_4; break L0;} break L;\n+                case '5': if (s.charAt(0)=='$') {id=Id_DOLLAR_5; break L0;} break L;\n+                case '6': if (s.charAt(0)=='$') {id=Id_DOLLAR_6; break L0;} break L;\n+                case '7': if (s.charAt(0)=='$') {id=Id_DOLLAR_7; break L0;} break L;\n+                case '8': if (s.charAt(0)=='$') {id=Id_DOLLAR_8; break L0;} break L;\n+                case '9': if (s.charAt(0)=='$') {id=Id_DOLLAR_9; break L0;} break L;\n+                case '_': if (s.charAt(0)=='$') {id=Id_UNDERSCORE; break L0;} break L;\n+                case '`': if (s.charAt(0)=='$') {id=Id_BACK_QUOTE; break L0;} break L;\n+                } break L;\n+            case 5: X=\"input\";id=Id_input; break L;\n+            case 9: c=s.charAt(4);\n+                if (c=='M') { X=\"lastMatch\";id=Id_lastMatch; }\n+                else if (c=='P') { X=\"lastParen\";id=Id_lastParen; }\n+                else if (c=='i') { X=\"multiline\";id=Id_multiline; }\n+                break L;\n+            case 11: X=\"leftContext\";id=Id_leftContext; break L;\n+            case 12: X=\"rightContext\";id=Id_rightContext; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+        }\n+// #/generated#\n+\n+        if (id == 0) return super.findInstanceIdInfo(s);\n+\n+        int attr;\n+        switch (id) {\n+          case Id_multiline:\n+          case Id_STAR:\n+          case Id_input:\n+          case Id_UNDERSCORE:\n+            attr = PERMANENT;\n+            break;\n+          default:\n+            attr = PERMANENT | READONLY;\n+            break;\n+        }\n+\n+        return instanceIdInfo(attr, super.getMaxInstanceId() + id);\n+    }\n+\n+// #/string_id_map#\n+\n+    @Override\n+    protected String getInstanceIdName(int id)\n+    {\n+        int shifted = id - super.getMaxInstanceId();\n+        if (1 <= shifted && shifted <= MAX_INSTANCE_ID) {\n+            switch (shifted) {\n+                case Id_multiline:    return \"multiline\";\n+                case Id_STAR:         return \"$*\";\n+\n+                case Id_input:        return \"input\";\n+                case Id_UNDERSCORE:   return \"$_\";\n+\n+                case Id_lastMatch:    return \"lastMatch\";\n+                case Id_AMPERSAND:    return \"$&\";\n+\n+                case Id_lastParen:    return \"lastParen\";\n+                case Id_PLUS:         return \"$+\";\n+\n+                case Id_leftContext:  return \"leftContext\";\n+                case Id_BACK_QUOTE:   return \"$`\";\n+\n+                case Id_rightContext: return \"rightContext\";\n+                case Id_QUOTE:        return \"$'\";\n+            }\n+            // Must be one of $1..$9, convert to 0..8\n+            int substring_number = shifted - DOLLAR_ID_BASE - 1;\n+            char[] buf = { '$', (char)('1' + substring_number) };\n+            return new String(buf);\n+        }\n+        return super.getInstanceIdName(id);\n+    }\n+\n+    @Override\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        int shifted = id - super.getMaxInstanceId();\n+        if (1 <= shifted && shifted <= MAX_INSTANCE_ID) {\n+            RegExpImpl impl = getImpl();\n+            Object stringResult;\n+            switch (shifted) {\n+              case Id_multiline:\n+              case Id_STAR:\n+                return ScriptRuntime.wrapBoolean(impl.multiline);\n+\n+              case Id_input:\n+              case Id_UNDERSCORE:\n+                stringResult = impl.input;\n+                break;\n+\n+              case Id_lastMatch:\n+              case Id_AMPERSAND:\n+                stringResult = impl.lastMatch;\n+                break;\n+\n+              case Id_lastParen:\n+              case Id_PLUS:\n+                stringResult = impl.lastParen;\n+                break;\n+\n+              case Id_leftContext:\n+              case Id_BACK_QUOTE:\n+                stringResult = impl.leftContext;\n+                break;\n+\n+              case Id_rightContext:\n+              case Id_QUOTE:\n+                stringResult = impl.rightContext;\n+                break;\n+\n+              default:\n+                {\n+                    // Must be one of $1..$9, convert to 0..8\n+                    int substring_number = shifted - DOLLAR_ID_BASE - 1;\n+                    stringResult = impl.getParenSubString(substring_number);\n+                    break;\n+                }\n+            }\n+            return (stringResult == null) ? \"\" : stringResult.toString();\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+    @Override\n+    protected void setInstanceIdValue(int id, Object value)\n+    {\n+        int shifted = id - super.getMaxInstanceId();\n+        switch (shifted) {\n+            case Id_multiline:\n+            case Id_STAR:\n+                getImpl().multiline = ScriptRuntime.toBoolean(value);\n+                return;\n+\n+            case Id_input:\n+            case Id_UNDERSCORE:\n+                getImpl().input = ScriptRuntime.toString(value);\n+                return;\n+        }\n+        super.setInstanceIdValue(id, value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/regexp/RegExpImpl.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.regexp;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ *\n+ */\n+public class RegExpImpl implements RegExpProxy {\n+\n+    public boolean isRegExp(Scriptable obj) {\n+        return obj instanceof NativeRegExp;\n+    }\n+\n+    public Object compileRegExp(Context cx, String source, String flags)\n+    {\n+        return NativeRegExp.compileRE(cx, source, flags, false);\n+    }\n+\n+    public Scriptable wrapRegExp(Context cx, Scriptable scope,\n+                                 Object compiled)\n+    {\n+        return new NativeRegExp(scope, compiled);\n+    }\n+\n+    public Object action(Context cx, Scriptable scope,\n+                         Scriptable thisObj, Object[] args,\n+                         int actionType)\n+    {\n+        GlobData data = new GlobData();\n+        data.mode = actionType;\n+\n+        switch (actionType) {\n+          case RA_MATCH:\n+            {\n+                Object rval;\n+                data.optarg = 1;\n+                rval = matchOrReplace(cx, scope, thisObj, args,\n+                                      this, data, false);\n+                return data.arrayobj == null ? rval : data.arrayobj;\n+            }\n+\n+          case RA_SEARCH:\n+            data.optarg = 1;\n+            return matchOrReplace(cx, scope, thisObj, args,\n+                                  this, data, false);\n+\n+          case RA_REPLACE:\n+            {\n+                Object arg1 = args.length < 2 ? Undefined.instance : args[1];\n+                String repstr = null;\n+                Function lambda = null;\n+                if (arg1 instanceof Function) {\n+                    lambda = (Function) arg1;\n+                } else {\n+                    repstr = ScriptRuntime.toString(arg1);\n+                }\n+\n+                data.optarg = 2;\n+                data.lambda = lambda;\n+                data.repstr = repstr;\n+                data.dollar = repstr == null ? -1 : repstr.indexOf('$');\n+                data.charBuf = null;\n+                data.leftIndex = 0;\n+                Object val = matchOrReplace(cx, scope, thisObj, args,\n+                                            this, data, true);\n+                SubString rc = this.rightContext;\n+\n+                if (data.charBuf == null) {\n+                    if (data.global || val == null\n+                        || !val.equals(Boolean.TRUE))\n+                    {\n+                        /* Didn't match even once. */\n+                        return data.str;\n+                    }\n+                    SubString lc = this.leftContext;\n+                    replace_glob(data, cx, scope, this, lc.index, lc.length);\n+                }\n+                data.charBuf.append(rc.charArray, rc.index, rc.length);\n+                return data.charBuf.toString();\n+            }\n+\n+          default:\n+            throw Kit.codeBug();\n+        }\n+    }\n+\n+    /**\n+     * Analog of C match_or_replace.\n+     */\n+    private static Object matchOrReplace(Context cx, Scriptable scope,\n+                                         Scriptable thisObj, Object[] args,\n+                                         RegExpImpl reImpl,\n+                                         GlobData data, boolean forceFlat)\n+    {\n+        NativeRegExp re;\n+\n+        String str = ScriptRuntime.toString(thisObj);\n+        data.str = str;\n+        Scriptable topScope = ScriptableObject.getTopLevelScope(scope);\n+\n+        if (args.length == 0) {\n+            Object compiled = NativeRegExp.compileRE(cx, \"\", \"\", false);\n+            re = new NativeRegExp(topScope, compiled);\n+        } else if (args[0] instanceof NativeRegExp) {\n+            re = (NativeRegExp) args[0];\n+        } else {\n+            String src = ScriptRuntime.toString(args[0]);\n+            String opt;\n+            if (data.optarg < args.length) {\n+                args[0] = src;\n+                opt = ScriptRuntime.toString(args[data.optarg]);\n+            } else {\n+                opt = null;\n+            }\n+            Object compiled = NativeRegExp.compileRE(cx, src, opt, forceFlat);\n+            re = new NativeRegExp(topScope, compiled);\n+        }\n+        data.regexp = re;\n+\n+        data.global = (re.getFlags() & NativeRegExp.JSREG_GLOB) != 0;\n+        int[] indexp = { 0 };\n+        Object result = null;\n+        if (data.mode == RA_SEARCH) {\n+            result = re.executeRegExp(cx, scope, reImpl,\n+                                      str, indexp, NativeRegExp.TEST);\n+            if (result != null && result.equals(Boolean.TRUE))\n+                result = Integer.valueOf(reImpl.leftContext.length);\n+            else\n+                result = Integer.valueOf(-1);\n+        } else if (data.global) {\n+            re.lastIndex = 0;\n+            for (int count = 0; indexp[0] <= str.length(); count++) {\n+                result = re.executeRegExp(cx, scope, reImpl,\n+                                          str, indexp, NativeRegExp.TEST);\n+                if (result == null || !result.equals(Boolean.TRUE))\n+                    break;\n+                if (data.mode == RA_MATCH) {\n+                    match_glob(data, cx, scope, count, reImpl);\n+                } else {\n+                    if (data.mode != RA_REPLACE) Kit.codeBug();\n+                    SubString lastMatch = reImpl.lastMatch;\n+                    int leftIndex = data.leftIndex;\n+                    int leftlen = lastMatch.index - leftIndex;\n+                    data.leftIndex = lastMatch.index + lastMatch.length;\n+                    replace_glob(data, cx, scope, reImpl, leftIndex, leftlen);\n+                }\n+                if (reImpl.lastMatch.length == 0) {\n+                    if (indexp[0] == str.length())\n+                        break;\n+                    indexp[0]++;\n+                }\n+            }\n+        } else {\n+            result = re.executeRegExp(cx, scope, reImpl, str, indexp,\n+                                      ((data.mode == RA_REPLACE)\n+                                       ? NativeRegExp.TEST\n+                                       : NativeRegExp.MATCH));\n+        }\n+\n+        return result;\n+    }\n+\n+\n+\n+    public int find_split(Context cx, Scriptable scope, String target,\n+                          String separator, Scriptable reObj,\n+                          int[] ip, int[] matchlen,\n+                          boolean[] matched, String[][] parensp)\n+    {\n+        int i = ip[0];\n+        int length = target.length();\n+        int result;\n+\n+        int version = cx.getLanguageVersion();\n+        NativeRegExp re = (NativeRegExp) reObj;\n+        again:\n+        while (true) {  // imitating C label\n+            /* JS1.2 deviated from Perl by never matching at end of string. */\n+            int ipsave = ip[0]; // reuse ip to save object creation\n+            ip[0] = i;\n+            Object ret = re.executeRegExp(cx, scope, this, target, ip,\n+                                          NativeRegExp.TEST);\n+            if (ret != Boolean.TRUE) {\n+                // Mismatch: ensure our caller advances i past end of string.\n+                ip[0] = ipsave;\n+                matchlen[0] = 1;\n+                matched[0] = false;\n+                return length;\n+            }\n+            i = ip[0];\n+            ip[0] = ipsave;\n+            matched[0] = true;\n+\n+            SubString sep = this.lastMatch;\n+            matchlen[0] = sep.length;\n+            if (matchlen[0] == 0) {\n+                /*\n+                 * Empty string match: never split on an empty\n+                 * match at the start of a find_split cycle.  Same\n+                 * rule as for an empty global match in\n+                 * match_or_replace.\n+                 */\n+                if (i == ip[0]) {\n+                    /*\n+                     * \"Bump-along\" to avoid sticking at an empty\n+                     * match, but don't bump past end of string --\n+                     * our caller must do that by adding\n+                     * sep->length to our return value.\n+                     */\n+                    if (i == length) {\n+                        if (version == Context.VERSION_1_2) {\n+                            matchlen[0] = 1;\n+                            result = i;\n+                        }\n+                        else\n+                            result = -1;\n+                        break;\n+                    }\n+                    i++;\n+                    continue again; // imitating C goto\n+                }\n+            }\n+            // PR_ASSERT((size_t)i >= sep->length);\n+            result = i - matchlen[0];\n+            break;\n+        }\n+        int size = (parens == null) ? 0 : parens.length;\n+        parensp[0] = new String[size];\n+        for (int num = 0; num < size; num++) {\n+            SubString parsub = getParenSubString(num);\n+            parensp[0][num] = parsub.toString();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Analog of REGEXP_PAREN_SUBSTRING in C jsregexp.h.\n+     * Assumes zero-based; i.e., for $3, i==2\n+     */\n+    SubString getParenSubString(int i)\n+    {\n+        if (parens != null && i < parens.length) {\n+            SubString parsub = parens[i];\n+            if (parsub != null) {\n+                return parsub;\n+            }\n+        }\n+        return SubString.emptySubString;\n+    }\n+\n+    /*\n+     * Analog of match_glob() in jsstr.c\n+     */\n+    private static void match_glob(GlobData mdata, Context cx,\n+                                   Scriptable scope, int count,\n+                                   RegExpImpl reImpl)\n+    {\n+        if (mdata.arrayobj == null) {\n+            Scriptable s = ScriptableObject.getTopLevelScope(scope);\n+            mdata.arrayobj = ScriptRuntime.newObject(cx, s, \"Array\", null);\n+        }\n+        SubString matchsub = reImpl.lastMatch;\n+        String matchstr = matchsub.toString();\n+        mdata.arrayobj.put(count, mdata.arrayobj, matchstr);\n+    }\n+\n+    /*\n+     * Analog of replace_glob() in jsstr.c\n+     */\n+    private static void replace_glob(GlobData rdata, Context cx,\n+                                     Scriptable scope, RegExpImpl reImpl,\n+                                     int leftIndex, int leftlen)\n+    {\n+        int replen;\n+        String lambdaStr;\n+        if (rdata.lambda != null) {\n+            // invoke lambda function with args lastMatch, $1, $2, ... $n,\n+            // leftContext.length, whole string.\n+            SubString[] parens = reImpl.parens;\n+            int parenCount = (parens == null) ? 0 : parens.length;\n+            Object[] args = new Object[parenCount + 3];\n+            args[0] = reImpl.lastMatch.toString();\n+            for (int i=0; i < parenCount; i++) {\n+                SubString sub = parens[i];\n+                if (sub != null) {\n+                    args[i+1] = sub.toString();\n+                } else {\n+                    args[i+1] = Undefined.instance;\n+                }\n+            }\n+            args[parenCount+1] = new Integer(reImpl.leftContext.length);\n+            args[parenCount+2] = rdata.str;\n+            // This is a hack to prevent expose of reImpl data to\n+            // JS function which can run new regexps modifing\n+            // regexp that are used later by the engine.\n+            // TODO: redesign is necessary\n+            if (reImpl != ScriptRuntime.getRegExpProxy(cx)) Kit.codeBug();\n+            RegExpImpl re2 = new RegExpImpl();\n+            re2.multiline = reImpl.multiline;\n+            re2.input = reImpl.input;\n+            ScriptRuntime.setRegExpProxy(cx, re2);\n+            try {\n+                Scriptable parent = ScriptableObject.getTopLevelScope(scope);\n+                Object result = rdata.lambda.call(cx, parent, parent, args);\n+                lambdaStr = ScriptRuntime.toString(result);\n+            } finally {\n+                ScriptRuntime.setRegExpProxy(cx, reImpl);\n+            }\n+            replen = lambdaStr.length();\n+        } else {\n+            lambdaStr = null;\n+            replen = rdata.repstr.length();\n+            if (rdata.dollar >= 0) {\n+                int[] skip = new int[1];\n+                int dp = rdata.dollar;\n+                do {\n+                    SubString sub = interpretDollar(cx, reImpl, rdata.repstr,\n+                                                    dp, skip);\n+                    if (sub != null) {\n+                        replen += sub.length - skip[0];\n+                        dp += skip[0];\n+                    } else {\n+                        ++dp;\n+                    }\n+                    dp = rdata.repstr.indexOf('$', dp);\n+                } while (dp >= 0);\n+            }\n+        }\n+\n+        int growth = leftlen + replen + reImpl.rightContext.length;\n+        StringBuffer charBuf = rdata.charBuf;\n+        if (charBuf == null) {\n+            charBuf = new StringBuffer(growth);\n+            rdata.charBuf = charBuf;\n+        } else {\n+            charBuf.ensureCapacity(rdata.charBuf.length() + growth);\n+        }\n+\n+        charBuf.append(reImpl.leftContext.charArray, leftIndex, leftlen);\n+        if (rdata.lambda != null) {\n+            charBuf.append(lambdaStr);\n+        } else {\n+            do_replace(rdata, cx, reImpl);\n+        }\n+    }\n+\n+    private static SubString interpretDollar(Context cx, RegExpImpl res,\n+                                             String da, int dp, int[] skip)\n+    {\n+        char dc;\n+        int num, tmp;\n+\n+        if (da.charAt(dp) != '$') Kit.codeBug();\n+\n+        /* Allow a real backslash (literal \"\\\\\") to escape \"$1\" etc. */\n+        int version = cx.getLanguageVersion();\n+        if (version != Context.VERSION_DEFAULT\n+            && version <= Context.VERSION_1_4)\n+        {\n+            if (dp > 0 && da.charAt(dp - 1) == '\\\\')\n+                return null;\n+        }\n+        int daL = da.length();\n+        if (dp + 1 >= daL)\n+            return null;\n+        /* Interpret all Perl match-induced dollar variables. */\n+        dc = da.charAt(dp + 1);\n+        if (NativeRegExp.isDigit(dc)) {\n+            int cp;\n+            if (version != Context.VERSION_DEFAULT\n+                && version <= Context.VERSION_1_4)\n+            {\n+                if (dc == '0')\n+                    return null;\n+                /* Check for overflow to avoid gobbling arbitrary decimal digits. */\n+                num = 0;\n+                cp = dp;\n+                while (++cp < daL && NativeRegExp.isDigit(dc = da.charAt(cp)))\n+                {\n+                    tmp = 10 * num + (dc - '0');\n+                    if (tmp < num)\n+                        break;\n+                    num = tmp;\n+                }\n+            }\n+            else {  /* ECMA 3, 1-9 or 01-99 */\n+                int parenCount = (res.parens == null) ? 0 : res.parens.length;\n+                num = dc - '0';\n+                if (num > parenCount)\n+                    return null;\n+                cp = dp + 2;\n+                if ((dp + 2) < daL) {\n+                    dc = da.charAt(dp + 2);\n+                    if (NativeRegExp.isDigit(dc)) {\n+                        tmp = 10 * num + (dc - '0');\n+                        if (tmp <= parenCount) {\n+                            cp++;\n+                            num = tmp;\n+                        }\n+                    }\n+                }\n+                if (num == 0) return null;  /* $0 or $00 is not valid */\n+            }\n+            /* Adjust num from 1 $n-origin to 0 array-index-origin. */\n+            num--;\n+            skip[0] = cp - dp;\n+            return res.getParenSubString(num);\n+        }\n+\n+        skip[0] = 2;\n+        switch (dc) {\n+          case '$':\n+            return new SubString(\"$\");\n+          case '&':\n+            return res.lastMatch;\n+          case '+':\n+            return res.lastParen;\n+          case '`':\n+            if (version == Context.VERSION_1_2) {\n+                /*\n+                 * JS1.2 imitated the Perl4 bug where left context at each step\n+                 * in an iterative use of a global regexp started from last match,\n+                 * not from the start of the target string.  But Perl4 does start\n+                 * $` at the beginning of the target string when it is used in a\n+                 * substitution, so we emulate that special case here.\n+                 */\n+                res.leftContext.index = 0;\n+                res.leftContext.length = res.lastMatch.index;\n+            }\n+            return res.leftContext;\n+          case '\\'':\n+            return res.rightContext;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Analog of do_replace in jsstr.c\n+     */\n+    private static void do_replace(GlobData rdata, Context cx,\n+                                   RegExpImpl regExpImpl)\n+    {\n+        StringBuffer charBuf = rdata.charBuf;\n+        int cp = 0;\n+        String da = rdata.repstr;\n+        int dp = rdata.dollar;\n+        if (dp != -1) {\n+            int[] skip = new int[1];\n+            do {\n+                int len = dp - cp;\n+                charBuf.append(da.substring(cp, dp));\n+                cp = dp;\n+                SubString sub = interpretDollar(cx, regExpImpl, da,\n+                                                dp, skip);\n+                if (sub != null) {\n+                    len = sub.length;\n+                    if (len > 0) {\n+                        charBuf.append(sub.charArray, sub.index, len);\n+                    }\n+                    cp += skip[0];\n+                    dp += skip[0];\n+                } else {\n+                    ++dp;\n+                }\n+                dp = da.indexOf('$', dp);\n+            } while (dp >= 0);\n+        }\n+        int daL = da.length();\n+        if (daL > cp) {\n+            charBuf.append(da.substring(cp, daL));\n+        }\n+    }\n+\n+    /*\n+     * See ECMA 15.5.4.8.  Modified to match JS 1.2 - optionally takes\n+     * a limit argument and accepts a regular expression as the split\n+     * argument.\n+     */\n+    public Object js_split(Context cx, Scriptable scope,\n+                                   String target, Object[] args)\n+    {\n+        // create an empty Array to return;\n+        Scriptable top = ScriptableObject.getTopLevelScope(scope);\n+        Scriptable result = ScriptRuntime.newObject(cx, top, \"Array\", null);\n+\n+        // return an array consisting of the target if no separator given\n+        // don't check against undefined, because we want\n+        // 'fooundefinedbar'.split(void 0) to split to ['foo', 'bar']\n+        if (args.length < 1) {\n+            result.put(0, result, target);\n+            return result;\n+        }\n+\n+        // Use the second argument as the split limit, if given.\n+        boolean limited = (args.length > 1) && (args[1] != Undefined.instance);\n+        long limit = 0;  // Initialize to avoid warning.\n+        if (limited) {\n+            /* Clamp limit between 0 and 1 + string length. */\n+            limit = ScriptRuntime.toUint32(args[1]);\n+            if (limit > target.length())\n+                limit = 1 + target.length();\n+        }\n+\n+        String separator = null;\n+        int[] matchlen = new int[1];\n+        Scriptable re = null;\n+        RegExpProxy reProxy = null;\n+        if (args[0] instanceof Scriptable) {\n+            reProxy = ScriptRuntime.getRegExpProxy(cx);\n+            if (reProxy != null) {\n+                Scriptable test = (Scriptable)args[0];\n+                if (reProxy.isRegExp(test)) {\n+                    re = test;\n+                }\n+            }\n+        }\n+        if (re == null) {\n+            separator = ScriptRuntime.toString(args[0]);\n+            matchlen[0] = separator.length();\n+        }\n+\n+        // split target with separator or re\n+        int[] ip = { 0 };\n+        int match;\n+        int len = 0;\n+        boolean[] matched = { false };\n+        String[][] parens = { null };\n+        int version = cx.getLanguageVersion();\n+        while ((match = find_split(cx, scope, target, separator, version,\n+                                   reProxy, re, ip, matchlen, matched, parens))\n+               >= 0)\n+        {\n+            if ((limited && len >= limit) || (match > target.length()))\n+                break;\n+\n+            String substr;\n+            if (target.length() == 0)\n+                substr = target;\n+            else\n+                substr = target.substring(ip[0], match);\n+\n+            result.put(len, result, substr);\n+            len++;\n+        /*\n+         * Imitate perl's feature of including parenthesized substrings\n+         * that matched part of the delimiter in the new array, after the\n+         * split substring that was delimited.\n+         */\n+            if (re != null && matched[0] == true) {\n+                int size = parens[0].length;\n+                for (int num = 0; num < size; num++) {\n+                    if (limited && len >= limit)\n+                        break;\n+                    result.put(len, result, parens[0][num]);\n+                    len++;\n+                }\n+                matched[0] = false;\n+            }\n+            ip[0] = match + matchlen[0];\n+\n+            if (version < Context.VERSION_1_3\n+                && version != Context.VERSION_DEFAULT)\n+            {\n+        /*\n+         * Deviate from ECMA to imitate Perl, which omits a final\n+         * split unless a limit argument is given and big enough.\n+         */\n+                if (!limited && ip[0] == target.length())\n+                    break;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /*\n+     * Used by js_split to find the next split point in target,\n+     * starting at offset ip and looking either for the given\n+     * separator substring, or for the next re match.  ip and\n+     * matchlen must be reference variables (assumed to be arrays of\n+     * length 1) so they can be updated in the leading whitespace or\n+     * re case.\n+     *\n+     * Return -1 on end of string, >= 0 for a valid index of the next\n+     * separator occurrence if found, or the string length if no\n+     * separator is found.\n+     */\n+    private static int find_split(Context cx, Scriptable scope, String target,\n+                                  String separator, int version,\n+                                  RegExpProxy reProxy, Scriptable re,\n+                                  int[] ip, int[] matchlen, boolean[] matched,\n+                                  String[][] parensp)\n+    {\n+        int i = ip[0];\n+        int length = target.length();\n+\n+        /*\n+         * Perl4 special case for str.split(' '), only if the user has selected\n+         * JavaScript1.2 explicitly.  Split on whitespace, and skip leading w/s.\n+         * Strange but true, apparently modeled after awk.\n+         */\n+        if (version == Context.VERSION_1_2 &&\n+            re == null && separator.length() == 1 && separator.charAt(0) == ' ')\n+        {\n+            /* Skip leading whitespace if at front of str. */\n+            if (i == 0) {\n+                while (i < length && Character.isWhitespace(target.charAt(i)))\n+                    i++;\n+                ip[0] = i;\n+            }\n+\n+            /* Don't delimit whitespace at end of string. */\n+            if (i == length)\n+                return -1;\n+\n+            /* Skip over the non-whitespace chars. */\n+            while (i < length\n+                   && !Character.isWhitespace(target.charAt(i)))\n+                i++;\n+\n+            /* Now skip the next run of whitespace. */\n+            int j = i;\n+            while (j < length && Character.isWhitespace(target.charAt(j)))\n+                j++;\n+\n+            /* Update matchlen to count delimiter chars. */\n+            matchlen[0] = j - i;\n+            return i;\n+        }\n+\n+        /*\n+         * Stop if past end of string.  If at end of string, we will\n+         * return target length, so that\n+         *\n+         *  \"ab,\".split(',') => new Array(\"ab\", \"\")\n+         *\n+         * and the resulting array converts back to the string \"ab,\"\n+         * for symmetry.  NB: This differs from perl, which drops the\n+         * trailing empty substring if the LIMIT argument is omitted.\n+         */\n+        if (i > length)\n+            return -1;\n+\n+        /*\n+         * Match a regular expression against the separator at or\n+         * above index i.  Return -1 at end of string instead of\n+         * trying for a match, so we don't get stuck in a loop.\n+         */\n+        if (re != null) {\n+            return reProxy.find_split(cx, scope, target, separator, re,\n+                                      ip, matchlen, matched, parensp);\n+        }\n+\n+        /*\n+         * Deviate from ECMA by never splitting an empty string by any separator\n+         * string into a non-empty array (an array of length 1 that contains the\n+         * empty string).\n+         */\n+        if (version != Context.VERSION_DEFAULT && version < Context.VERSION_1_3\n+            && length == 0)\n+            return -1;\n+\n+        /*\n+         * Special case: if sep is the empty string, split str into\n+         * one character substrings.  Let our caller worry about\n+         * whether to split once at end of string into an empty\n+         * substring.\n+         *\n+         * For 1.2 compatibility, at the end of the string, we return the length as\n+         * the result, and set the separator length to 1 -- this allows the caller\n+         * to include an additional null string at the end of the substring list.\n+         */\n+        if (separator.length() == 0) {\n+            if (version == Context.VERSION_1_2) {\n+                if (i == length) {\n+                    matchlen[0] = 1;\n+                    return i;\n+                }\n+                return i + 1;\n+            }\n+            return (i == length) ? -1 : i + 1;\n+        }\n+\n+        /* Punt to j.l.s.indexOf; return target length if separator is\n+         * not found.\n+         */\n+        if (ip[0] >= length)\n+            return length;\n+\n+        i = target.indexOf(separator, ip[0]);\n+\n+        return (i != -1) ? i : length;\n+    }\n+\n+    String          input;         /* input string to match (perl $_, GC root) */\n+    boolean         multiline;     /* whether input contains newlines (perl $*) */\n+    SubString[]     parens;        /* Vector of SubString; last set of parens\n+                                      matched (perl $1, $2) */\n+    SubString       lastMatch;     /* last string matched (perl $&) */\n+    SubString       lastParen;     /* last paren matched (perl $+) */\n+    SubString       leftContext;   /* input to left of last match (perl $`) */\n+    SubString       rightContext;  /* input to right of last match (perl $') */\n+}\n+\n+\n+final class GlobData\n+{\n+    int      mode;      /* input: return index, match object, or void */\n+    int      optarg;    /* input: index of optional flags argument */\n+    boolean  global;    /* output: whether regexp was global */\n+    String   str;       /* output: 'this' parameter object as string */\n+    NativeRegExp regexp;/* output: regexp parameter object private data */\n+\n+    // match-specific data\n+\n+    Scriptable arrayobj;\n+\n+    // replace-specific data\n+\n+    Function      lambda;        /* replacement function object or null */\n+    String        repstr;        /* replacement string */\n+    int           dollar = -1;   /* -1 or index of first $ in repstr */\n+    StringBuffer  charBuf;       /* result characters, null initially */\n+    int           leftIndex;     /* leftContext index, always 0 for JS1.2 */\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/regexp/SubString.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.regexp;\n+\n+class SubString {\n+\n+    public SubString()\n+    {\n+    }\n+\n+    public SubString(String str)\n+    {\n+        index = 0;\n+        charArray = str.toCharArray();\n+        length = str.length();\n+    }\n+\n+    public SubString(char[] source, int start, int len)\n+    {\n+    // there must be a better way of doing this??\n+        index = 0;\n+        length = len;\n+        charArray = new char[len];\n+        for (int j = 0; j < len; j++)\n+            charArray[j] = source[start + j];\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return charArray == null\n+               ? \"\"\n+               : new String(charArray, index, length);\n+    }\n+\n+    static final SubString emptySubString = new SubString();\n+\n+    char[] charArray;\n+    int    index;\n+    int    length;\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/serialize/ScriptableInputStream.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino serialization code, released\n+ * Sept. 25, 2001.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Norris Boyd.\n+ * Portions created by the Initial Developer are Copyright (C) 2001\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Attila Szegedi\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+// API class\n+\n+package org.mozilla.javascript.serialize;\n+\n+import java.io.*;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * Class ScriptableInputStream is used to read in a JavaScript\n+ * object or function previously serialized with a ScriptableOutputStream.\n+ * References to names in the exclusion list\n+ * replaced with references to the top-level scope specified during\n+ * creation of the ScriptableInputStream.\n+ *\n+ */\n+\n+public class ScriptableInputStream extends ObjectInputStream {\n+\n+    /**\n+     * Create a ScriptableInputStream.\n+     * @param in the InputStream to read from.\n+     * @param scope the top-level scope to create the object in.\n+     */\n+    public ScriptableInputStream(InputStream in, Scriptable scope)\n+        throws IOException\n+    {\n+        super(in);\n+        this.scope = scope;\n+        enableResolveObject(true);\n+        Context cx = Context.getCurrentContext();\n+        if (cx != null) {\n+            this.classLoader = cx.getApplicationClassLoader();\n+        }\n+    }\n+\n+    @Override\n+    protected Class<?> resolveClass(ObjectStreamClass desc)\n+        throws IOException, ClassNotFoundException\n+    {\n+        String name = desc.getName();\n+        if (classLoader != null) {\n+            try {\n+                return classLoader.loadClass(name);\n+            } catch (ClassNotFoundException ex) {\n+                // fall through to default loading\n+            }\n+        }\n+        return super.resolveClass(desc);\n+    }\n+\n+    @Override\n+    protected Object resolveObject(Object obj)\n+        throws IOException\n+    {\n+        if (obj instanceof ScriptableOutputStream.PendingLookup) {\n+            String name = ((ScriptableOutputStream.PendingLookup)obj).getName();\n+            obj = ScriptableOutputStream.lookupQualifiedName(scope, name);\n+            if (obj == Scriptable.NOT_FOUND) {\n+                throw new IOException(\"Object \" + name + \" not found upon \" +\n+                                      \"deserialization.\");\n+            }\n+        }else if (obj instanceof UniqueTag) {\n+            obj = ((UniqueTag)obj).readResolve();\n+        }else if (obj instanceof Undefined) {\n+            obj = ((Undefined)obj).readResolve();\n+        }\n+        return obj;\n+    }\n+\n+    private Scriptable scope;\n+    private ClassLoader classLoader;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/serialize/ScriptableOutputStream.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino serialization code, released\n+ * Sept. 25, 2001.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Norris Boyd.\n+ * Portions created by the Initial Developer are Copyright (C) 2001\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Attila Szegedi\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.serialize;\n+\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.StringTokenizer;\n+import java.io.*;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * Class ScriptableOutputStream is an ObjectOutputStream used\n+ * to serialize JavaScript objects and functions. Note that\n+ * compiled functions currently cannot be serialized, only\n+ * interpreted functions. The top-level scope containing the\n+ * object is not written out, but is instead replaced with\n+ * another top-level object when the ScriptableInputStream\n+ * reads in this object. Also, object corresponding to names\n+ * added to the exclude list are not written out but instead\n+ * are looked up during deserialization. This approach avoids\n+ * the creation of duplicate copies of standard objects\n+ * during deserialization.\n+ *\n+ */\n+\n+// API class\n+\n+public class ScriptableOutputStream extends ObjectOutputStream {\n+\n+    /**\n+     * ScriptableOutputStream constructor.\n+     * Creates a ScriptableOutputStream for use in serializing\n+     * JavaScript objects. Calls excludeStandardObjectNames.\n+     *\n+     * @param out the OutputStream to write to.\n+     * @param scope the scope containing the object.\n+     */\n+    public ScriptableOutputStream(OutputStream out, Scriptable scope)\n+        throws IOException\n+    {\n+        super(out);\n+        this.scope = scope;\n+        table = new HashMap<Object,String>();\n+        table.put(scope, \"\");\n+        enableReplaceObject(true);\n+        excludeStandardObjectNames(); // XXX\n+    }\n+\n+    public void excludeAllIds(Object[] ids) {\n+        for (Object id: ids) {\n+            if (id instanceof String &&\n+                (scope.get((String) id, scope) instanceof Scriptable))\n+            {\n+                this.addExcludedName((String)id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds a qualified name to the list of object to be excluded from\n+     * serialization. Names excluded from serialization are looked up\n+     * in the new scope and replaced upon deserialization.\n+     * @param name a fully qualified name (of the form \"a.b.c\", where\n+     *             \"a\" must be a property of the top-level object). The object\n+     *             need not exist, in which case the name is ignored.\n+     * @throws IllegalArgumentException if the object is not a\n+     *         {@link Scriptable}.\n+     */\n+    public void addOptionalExcludedName(String name) {\n+        Object obj = lookupQualifiedName(scope, name);\n+        if(obj != null && obj != UniqueTag.NOT_FOUND) {\n+            if (!(obj instanceof Scriptable)) {\n+                throw new IllegalArgumentException(\n+                        \"Object for excluded name \" + name +\n+                        \" is not a Scriptable, it is \" +\n+                        obj.getClass().getName());\n+            }\n+            table.put(obj, name);\n+        }\n+    }\n+\n+    /**\n+     * Adds a qualified name to the list of objects to be excluded from\n+     * serialization. Names excluded from serialization are looked up\n+     * in the new scope and replaced upon deserialization.\n+     * @param name a fully qualified name (of the form \"a.b.c\", where\n+     *             \"a\" must be a property of the top-level object)\n+     * @throws IllegalArgumentException if the object is not found or is not\n+     *         a {@link Scriptable}.\n+     */\n+    public void addExcludedName(String name) {\n+        Object obj = lookupQualifiedName(scope, name);\n+        if (!(obj instanceof Scriptable)) {\n+            throw new IllegalArgumentException(\"Object for excluded name \" +\n+                                               name + \" not found.\");\n+        }\n+        table.put(obj, name);\n+    }\n+\n+    /**\n+     * Returns true if the name is excluded from serialization.\n+     */\n+    public boolean hasExcludedName(String name) {\n+        return table.get(name) != null;\n+    }\n+\n+    /**\n+     * Removes a name from the list of names to exclude.\n+     */\n+    public void removeExcludedName(String name) {\n+        table.remove(name);\n+    }\n+\n+    /**\n+     * Adds the names of the standard objects and their\n+     * prototypes to the list of excluded names.\n+     */\n+    public void excludeStandardObjectNames() {\n+        String[] names = { \"Object\", \"Object.prototype\",\n+                           \"Function\", \"Function.prototype\",\n+                           \"String\", \"String.prototype\",\n+                           \"Math\",  // no Math.prototype\n+                           \"Array\", \"Array.prototype\",\n+                           \"Error\", \"Error.prototype\",\n+                           \"Number\", \"Number.prototype\",\n+                           \"Date\", \"Date.prototype\",\n+                           \"RegExp\", \"RegExp.prototype\",\n+                           \"Script\", \"Script.prototype\",\n+                           \"Continuation\", \"Continuation.prototype\",\n+                         };\n+        for (int i=0; i < names.length; i++) {\n+            addExcludedName(names[i]);\n+        }\n+\n+        String[] optionalNames = {\n+                \"XML\", \"XML.prototype\",\n+                \"XMLList\", \"XMLList.prototype\",\n+        };\n+        for (int i=0; i < optionalNames.length; i++) {\n+            addOptionalExcludedName(optionalNames[i]);\n+        }\n+    }\n+\n+    static Object lookupQualifiedName(Scriptable scope,\n+                                      String qualifiedName)\n+    {\n+        StringTokenizer st = new StringTokenizer(qualifiedName, \".\");\n+        Object result = scope;\n+        while (st.hasMoreTokens()) {\n+            String s = st.nextToken();\n+            result = ScriptableObject.getProperty((Scriptable)result, s);\n+            if (result == null || !(result instanceof Scriptable))\n+                break;\n+        }\n+        return result;\n+    }\n+\n+    static class PendingLookup implements Serializable\n+    {\n+        static final long serialVersionUID = -2692990309789917727L;\n+\n+        PendingLookup(String name) { this.name = name; }\n+\n+        String getName() { return name; }\n+\n+        private String name;\n+    }\n+\n+    @Override\n+    protected Object replaceObject(Object obj) throws IOException\n+    {\n+        if (false) throw new IOException(); // suppress warning\n+        String name = table.get(obj);\n+        if (name == null)\n+            return obj;\n+        return new PendingLookup(name);\n+    }\n+\n+    private Scriptable scope;\n+    private Map<Object,String> table;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/xml/XMLLib.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml;\n+\n+import org.mozilla.javascript.*;\n+\n+public abstract class XMLLib\n+{\n+    private static final Object XML_LIB_KEY = new Object();\n+\t\n+\t/**\n+\t\tAn object which specifies an XMLLib implementation to be used at runtime.\n+\t \n+\t\tThis interface should be considered experimental.  It may be better\n+\t\t(and certainly more flexible) to write an interface that returns an\n+\t\tXMLLib object rather than a class name, for example.  But that would\n+\t\tcause many more ripple effects in the code, all the way back to\n+\t\t{@link ScriptRuntime}.\n+\t */\n+\tpublic static abstract class Factory {\n+\t\tpublic static Factory create(final String className) {\n+\t\t\treturn new Factory() {\n+\t\t\t    @Override\n+\t\t\t\tpublic String getImplementationClassName() {\n+\t\t\t\t\treturn className;\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t\t\n+\t\tpublic abstract String getImplementationClassName();\n+\t}\n+\n+    public static XMLLib extractFromScopeOrNull(Scriptable scope)\n+    {\n+        ScriptableObject so = ScriptRuntime.getLibraryScopeOrNull(scope);\n+        if (so == null) {\n+            // If library is not yet initialized, return null\n+            return null;\n+        }\n+\n+        // Ensure lazily initialization of real XML library instance\n+        // which is done on first access to XML property\n+        ScriptableObject.getProperty(so, \"XML\");\n+\n+        return (XMLLib)so.getAssociatedValue(XML_LIB_KEY);\n+    }\n+\n+    public static XMLLib extractFromScope(Scriptable scope)\n+    {\n+        XMLLib lib = extractFromScopeOrNull(scope);\n+        if (lib != null) {\n+            return lib;\n+        }\n+        String msg = ScriptRuntime.getMessage0(\"msg.XML.not.available\");\n+        throw Context.reportRuntimeError(msg);\n+    }\n+\n+    protected final XMLLib bindToScope(Scriptable scope)\n+    {\n+        ScriptableObject so = ScriptRuntime.getLibraryScopeOrNull(scope);\n+        if (so == null) {\n+            // standard library should be initialized at this point\n+            throw new IllegalStateException();\n+        }\n+        return (XMLLib)so.associateValue(XML_LIB_KEY, this);\n+    }\n+\n+    public abstract boolean isXMLName(Context cx, Object name);\n+\n+    public abstract Ref nameRef(Context cx, Object name,\n+                                Scriptable scope, int memberTypeFlags);\n+\n+    public abstract Ref nameRef(Context cx, Object namespace, Object name,\n+                                Scriptable scope, int memberTypeFlags);\n+\n+    /**\n+     * Escapes the reserved characters in a value of an attribute.\n+     *\n+     * @param value Unescaped text\n+     * @return The escaped text\n+     */\n+    public abstract String escapeAttributeValue(Object value);\n+\n+    /**\n+     * Escapes the reserved characters in a value of a text node.\n+     *\n+     * @param value Unescaped text\n+     * @return The escaped text\n+     */\n+    public abstract String escapeTextValue(Object value);\n+\n+\n+    /**\n+     * Construct namespace for default xml statement.\n+     */\n+    public abstract Object toDefaultXmlNamespace(Context cx, Object uriValue);\n+    \n+    public void setIgnoreComments(boolean b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void setIgnoreWhitespace(boolean b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void setIgnoreProcessingInstructions(boolean b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void setPrettyPrinting(boolean b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void setPrettyIndent(int i) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean isIgnoreComments() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean isIgnoreProcessingInstructions() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean isIgnoreWhitespace() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean isPrettyPrinting() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public int getPrettyIndent() {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/src/org/mozilla/javascript/xml/XMLObject.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xml;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ *  This Interface describes what all XML objects (XML, XMLList) should have in common.\n+ *\n+ */\n+public abstract class XMLObject extends IdScriptableObject\n+{\n+    public XMLObject()\n+    {\n+    }\n+\n+    public XMLObject(Scriptable scope, Scriptable prototype)\n+    {\n+        super(scope, prototype);\n+    }\n+\n+    /**\n+     * Implementation of ECMAScript [[Has]].\n+     */\n+    public abstract boolean ecmaHas(Context cx, Object id);\n+\n+    /**\n+     * Implementation of ECMAScript [[Get]].\n+     */\n+    public abstract Object ecmaGet(Context cx, Object id);\n+\n+    /**\n+     * Implementation of ECMAScript [[Put]].\n+     */\n+    public abstract void ecmaPut(Context cx, Object id, Object value);\n+\n+    /**\n+     * Implementation of ECMAScript [[Delete]].\n+     */\n+    public abstract boolean ecmaDelete(Context cx, Object id);\n+\n+    /**\n+     * Return an additional object to look for methods that runtime should\n+     * consider during method search. Return null if no such object available.\n+     */\n+    public abstract Scriptable getExtraMethodSource(Context cx);\n+\n+    /**\n+     * Generic reference to implement x.@y, x..y etc.\n+     */\n+    public abstract Ref memberRef(Context cx, Object elem,\n+                                  int memberTypeFlags);\n+\n+    /**\n+     * Generic reference to implement x::ns, x.@ns::y, x..@ns::y etc.\n+     */\n+    public abstract Ref memberRef(Context cx, Object namespace, Object elem,\n+                                  int memberTypeFlags);\n+\n+    /**\n+     * Wrap this object into NativeWith to implement the with statement.\n+     */\n+    public abstract NativeWith enterWith(Scriptable scope);\n+\n+    /**\n+     * Wrap this object into NativeWith to implement the .() query.\n+     */\n+    public abstract NativeWith enterDotQuery(Scriptable scope);\n+\n+    /**\n+     * Custom <tt>+</tt> operator.\n+     * Should return {@link Scriptable#NOT_FOUND} if this object does not have\n+     * custom addition operator for the given value,\n+     * or the result of the addition operation.\n+     * <p>\n+     * The default implementation returns {@link Scriptable#NOT_FOUND}\n+     * to indicate no custom addition operation.\n+     *\n+     * @param cx the Context object associated with the current thread.\n+     * @param thisIsLeft if true, the object should calculate this + value\n+     *                   if false, the object should calculate value + this.\n+     * @param value the second argument for addition operation.\n+     */\n+    public Object addValues(Context cx, boolean thisIsLeft, Object value)\n+    {\n+        return Scriptable.NOT_FOUND;\n+    }\n+\n+    /**\n+     * Gets the value returned by calling the typeof operator on this object. \n+     * @see org.mozilla.javascript.ScriptableObject#getTypeOf()\n+     * @return \"xml\" or \"undefined\" if {@link #avoidObjectDetection()} returns <code>true</code>\n+     */\n+    @Override\n+    public String getTypeOf()\n+    {\n+    \treturn avoidObjectDetection() ? \"undefined\" : \"xml\";\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/drivers/JsDriver.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is the Java port of jsDriver.pl.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * David P. Caldwell.\n+ * Portions created by David P. Caldwell are Copyright (C)\n+ * 2007 David P. Caldwell. All Rights Reserved.\n+ *\n+ *\n+ * Contributor(s):\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *   Norris Boyd <norrisboyd@gmail.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.drivers;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import org.w3c.dom.*;\n+\n+import org.mozilla.javascript.tools.shell.*;\n+\n+/**\n+ * @version $Id: JsDriver.java,v 1.10 2009/05/15 12:30:45 nboyd%atg.com Exp $\n+ */\n+public class JsDriver {\n+    private JsDriver() {\n+    }\n+\n+    private static String join(String[] list) {\n+        String rv = \"\";\n+        for (int i=0; i<list.length; i++) {\n+            rv += list[i];\n+            if (i+1 != list.length) {\n+                rv += \",\";\n+            }\n+        }\n+        return rv;\n+    }\n+\n+    private static class Tests {\n+        private File testDirectory;\n+        private String[] list;\n+        private String[] skip;\n+\n+        Tests(File testDirectory, String[] list, String[] skip) throws IOException {\n+            this.testDirectory = testDirectory;\n+            this.list = getTestList(list);\n+            this.skip = getTestList(skip);\n+        }\n+        \n+        private String[] getTestList(String[] tests) throws IOException {\n+          ArrayList<String> list = new ArrayList<String>();\n+          for (int i=0; i < tests.length; i++) {\n+            if (tests[i].startsWith(\"@\"))\n+              TestUtils.addTestsFromFile(tests[i].substring(1), list);\n+            else\n+              list.add(tests[i]);\n+          }\n+          return list.toArray(new String[0]);\n+        }\n+\n+        private boolean matches(String path) {\n+            if (list.length == 0) return true;\n+            return TestUtils.matches(list, path);\n+        }\n+\n+        private boolean excluded(String path) {\n+            if (skip.length == 0) return false;\n+            return TestUtils.matches(skip, path);\n+        }\n+\n+        private void addFiles(List<Script> rv, String prefix, File directory) {\n+            File[] files = directory.listFiles();\n+            if (files == null) throw new RuntimeException(\"files null for \" + directory);\n+            for (int i=0; i<files.length; i++) {\n+                String path = prefix + files[i].getName();\n+                if (ShellTest.DIRECTORY_FILTER.accept(files[i])) {\n+                    addFiles(rv, path + \"/\", files[i]);\n+                } else {\n+                    boolean isTopLevel = prefix.length() == 0;\n+                    if (ShellTest.TEST_FILTER.accept(files[i]) && matches(path) && !excluded(path) && !isTopLevel) {\n+                        rv.add(new Script(path, files[i]));\n+                    }\n+                }\n+            }\n+        }\n+\n+        static class Script {\n+            private String path;\n+            private File file;\n+\n+            Script(String path, File file) {\n+                this.path = path;\n+                this.file = file;\n+            }\n+\n+            String getPath() {\n+                return path;\n+            }\n+\n+            File getFile() {\n+                return file;\n+            }\n+        }\n+\n+        Script[] getFiles() {\n+            ArrayList<Script> rv = new ArrayList<Script>();\n+            addFiles(rv, \"\", testDirectory);\n+            return rv.toArray(new Script[0]);\n+        }\n+    }\n+\n+    private static class ConsoleStatus extends ShellTest.Status {\n+        private File jsFile;\n+\n+        private Arguments.Console console;\n+        private boolean trace;\n+\n+        private boolean failed;\n+\n+        ConsoleStatus(Arguments.Console console, boolean trace) {\n+            this.console = console;\n+            this.trace = trace;\n+        }\n+\n+        @Override\n+        public void running(File jsFile) {\n+            try {\n+                console.println(\"Running: \" + jsFile.getCanonicalPath());\n+                this.jsFile = jsFile;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void failed(String s) {\n+            console.println(\"Failed: \" + jsFile + \": \" + s);\n+            failed = true;\n+        }\n+\n+        @Override\n+        public void threw(Throwable t) {\n+            console.println(\"Failed: \" + jsFile + \" with exception.\");\n+            console.println(ShellTest.getStackTrace(t));\n+            failed = true;\n+        }\n+\n+        @Override\n+        public void timedOut() {\n+            console.println(\"Failed: \" + jsFile + \": timed out.\");\n+            failed = true;\n+        }\n+\n+        @Override\n+        public void exitCodesWere(int expected, int actual) {\n+            if (expected != actual) {\n+                console.println(\"Failed: \" + jsFile + \" expected \" + expected + \" actual \" + actual);\n+                failed = true;\n+            }\n+        }\n+\n+        @Override\n+        public void outputWas(String s) {\n+            if (!failed) {\n+                console.println(\"Passed: \" + jsFile);\n+                if (trace) {\n+                    console.println(s);\n+                }\n+            }\n+        }\n+    }\n+\n+    //    returns true if node was found, false otherwise\n+    private static boolean setContent(Element node, String id, String content) {\n+        if (node.getAttribute(\"id\").equals(id)) {\n+            node.setTextContent(node.getTextContent() + \"\\n\" + content);\n+            return true;\n+        } else {\n+            NodeList children = node.getChildNodes();\n+            for (int i=0; i<children.getLength(); i++) {\n+                if (children.item(i) instanceof Element) {\n+                    Element e = (Element)children.item(i);\n+                    boolean rv = setContent( e, id, content );\n+                    if (rv) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static Element getElementById(Element node, String id) {\n+        if (node.getAttribute(\"id\").equals(id)) {\n+            return node;\n+        } else {\n+            NodeList children = node.getChildNodes();\n+            for (int i=0; i<children.getLength(); i++) {\n+                if (children.item(i) instanceof Element) {\n+                    Element rv = getElementById( (Element)children.item(i), id );\n+                    if (rv != null) {\n+                        return rv;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+\tprivate static String newlineLineEndings(String s) {\n+\t\tStringBuffer rv = new StringBuffer();\n+\t\tfor (int i=0; i<s.length(); i++) {\n+\t\t\tif (s.charAt(i) == '\\r') {\n+\t\t\t\tif (i+1<s.length() && s.charAt(i+1) == '\\n') {\n+\t\t\t\t\t//    just skip \\r\n+\t\t\t\t} else {\n+\t\t\t\t\t//    Macintosh, substitute \\n\n+\t\t\t\t\trv.append('\\n');\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\trv.append(s.charAt(i));\n+\t\t\t}\n+\t\t}\n+\t\treturn rv.toString();\n+\t}\n+\n+    private static class HtmlStatus extends ShellTest.Status {\n+        private String testPath;\n+        private String bugUrl;\n+        private String lxrUrl;\n+        private Document html;\n+        private Element failureHtml;\n+        private boolean failed;\n+\n+        private String output;\n+\n+        HtmlStatus(String lxrUrl, String bugUrl, String testPath, Document html, Element failureHtml) {\n+            this.testPath = testPath;\n+            this.bugUrl = bugUrl;\n+            this.lxrUrl = lxrUrl;\n+            this.html = html;\n+            this.failureHtml = failureHtml;\n+        }\n+\n+        @Override\n+        public void running(File file) {\n+        }\n+\n+        @Override\n+        public void failed(String s) {\n+            failed = true;\n+            setContent(failureHtml, \"failureDetails.reason\", \"Failure reason: \\n\" + s);\n+        }\n+\n+        @Override\n+        public void exitCodesWere(int expected, int actual) {\n+            if (expected != actual) {\n+                failed = true;\n+                setContent(failureHtml, \"failureDetails.reason\", \"expected exit code \" + expected + \" but got \" + actual);\n+            }\n+        }\n+\n+        @Override\n+        public void threw(Throwable e) {\n+            failed = true;\n+            setContent(failureHtml, \"failureDetails.reason\", \"Threw Java exception:\\n\" + newlineLineEndings(ShellTest.getStackTrace(e)));\n+        }\n+\n+        @Override\n+        public void timedOut() {\n+            failed = true;\n+            setContent(failureHtml, \"failureDetails.reason\", \"Timed out.\");\n+        }\n+\n+        @Override\n+        public void outputWas(String s) {\n+            this.output = s;\n+        }\n+\n+        private String getLinesStartingWith(String prefix) {\n+            BufferedReader r = new BufferedReader(new StringReader(output));\n+            String line = null;\n+            String rv = \"\";\n+            try {\n+                while( (line = r.readLine()) != null ) {\n+                    if (line.startsWith(prefix)) {\n+                        if (rv.length() > 0) {\n+                            rv += \"\\n\";\n+                        }\n+                        rv += line;\n+                    }\n+                }\n+                return rv;\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Can't happen.\");\n+            }\n+        }\n+\n+        boolean failed() {\n+            return failed;\n+        }\n+\n+        void finish() {\n+            if (failed) {\n+                getElementById(failureHtml, \"failureDetails.status\").setTextContent(getLinesStartingWith(\"STATUS:\"));\n+\n+                String bn = getLinesStartingWith(\"BUGNUMBER:\");\n+                Element bnlink = getElementById(failureHtml, \"failureDetails.bug.href\");\n+                if (bn.length() > 0) {\n+                    String number = bn.substring(\"BUGNUMBER: \".length());\n+                    if (!number.equals(\"none\")) {\n+                        bnlink.setAttribute(\"href\", bugUrl + number);\n+                        getElementById(bnlink, \"failureDetails.bug.number\").setTextContent(number);\n+                    } else {\n+                        bnlink.getParentNode().removeChild(bnlink);\n+                    }\n+                } else {\n+                    bnlink.getParentNode().removeChild(bnlink);\n+                }\n+\n+                getElementById(failureHtml, \"failureDetails.lxr\").setAttribute(\"href\", lxrUrl + testPath);\n+                getElementById(failureHtml, \"failureDetails.lxr.text\").setTextContent(testPath);\n+\n+                getElementById(html.getDocumentElement(), \"retestList.text\").setTextContent(\n+                    getElementById(html.getDocumentElement(), \"retestList.text\").getTextContent()\n+                    + testPath\n+                    + \"\\n\"\n+                );\n+\n+                getElementById(html.getDocumentElement(), \"failureDetails\").appendChild(failureHtml);\n+            }\n+        }\n+    }\n+\t\n+\tprivate static class XmlStatus extends ShellTest.Status {\n+\t\tprivate Element target;\n+\t\tprivate Date start;\n+\t\t\n+\t\tXmlStatus(String path, Element root) {\n+\t\t\tthis.target = root.getOwnerDocument().createElement(\"test\");\n+\t\t\tthis.target.setAttribute(\"path\", path);\n+\t\t\troot.appendChild(target);\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic void running(File file) {\n+\t\t\tthis.start = new Date();\n+\t\t}\n+\t\t\n+\t\tprivate Element createElement(Element parent, String name) {\n+\t\t\tElement rv = parent.getOwnerDocument().createElement(name);\n+\t\t\tparent.appendChild(rv);\n+\t\t\treturn rv;\n+\t\t}\n+\t\t\n+\t\tprivate void finish() {\n+\t\t\tDate end = new Date();\n+\t\t\tlong elapsed = end.getTime() - start.getTime();\n+\t\t\tthis.target.setAttribute(\"elapsed\", String.valueOf(elapsed));\n+\t\t}\n+\t\t\n+\t\tprivate void setTextContent(Element e, String content) {\n+\t\t\te.setTextContent( newlineLineEndings(content) );\n+\t\t}\n+\t\t\n+        @Override\n+        public void exitCodesWere(int expected, int actual) {\n+\t\t\tfinish();\n+\t\t\tElement exit = createElement(target, \"exit\");\n+\t\t\texit.setAttribute(\"expected\", String.valueOf(expected));\n+\t\t\texit.setAttribute(\"actual\", String.valueOf(actual));\n+\t\t}\n+\t\t\n+        @Override\n+        public void timedOut() {\n+\t\t\tfinish();\n+\t\t\tcreateElement(target, \"timedOut\");\n+\t\t}\n+\t\t\n+        @Override\n+        public void failed(String s) {\n+\t\t\tfinish();\n+\t\t\tElement failed = createElement(target, \"failed\");\n+\t\t\tsetTextContent(failed, s);\n+\t\t}\n+\t\t\n+        @Override\n+        public void outputWas(String message) {\n+\t\t\tfinish();\n+\t\t\tElement output = createElement(target, \"output\");\n+\t\t\tsetTextContent(output, message);\n+\t\t}\n+\t\t\n+        @Override\n+        public void threw(Throwable t) {\n+\t\t\tfinish();\n+\t\t\tElement threw = createElement(target, \"threw\");\n+\t\t\tsetTextContent(threw, ShellTest.getStackTrace(t));\n+\t\t}\n+\t}\n+\n+    private static class Results {\n+        private ShellContextFactory factory;\n+        private Arguments arguments;\n+        private File output;\n+        private boolean trace;\n+\n+        private Document html;\n+        private Element failureHtml;\n+\t\t\n+\t\tprivate Document xml;\n+\n+\t\tprivate Date start;\n+        private int tests;\n+        private int failures;\n+\n+        Results(ShellContextFactory factory, Arguments arguments, boolean trace) {\n+            this.factory = factory;\n+            this.arguments = arguments;\n+\t\t\t\n+\t\t\tFile output = arguments.getOutputFile();\n+\t\t\tif (output == null) {\n+\t\t\t\toutput = new File(\"rhino-test-results.\" + new java.text.SimpleDateFormat(\"yyyy.MM.dd.HH.mm.ss\").format(new Date()) + \".html\");\n+\t\t\t}\n+\t\t\tthis.output = output;\n+\n+            this.trace = trace;\n+        }\n+\n+        private Document parse(InputStream in) {\n+            try {\n+                javax.xml.parsers.DocumentBuilderFactory factory = javax.xml.parsers.DocumentBuilderFactory.newInstance();\n+                factory.setValidating(false);\n+                javax.xml.parsers.DocumentBuilder dom = factory.newDocumentBuilder();\n+                return dom.parse(in);\n+            } catch (Throwable t) {\n+                throw new RuntimeException(\"Parser failure\", t);\n+            }\n+        }\n+\n+        private Document getTemplate() {\n+            return parse(getClass().getResourceAsStream(\"results.html\"));\n+        }\n+\n+        private void write(Document template, boolean xml) {\n+            try {\n+\t\t\t\tFile output = this.output;\n+\t\t\t\tjavax.xml.transform.TransformerFactory factory = javax.xml.transform.TransformerFactory.newInstance();\n+\t\t\t\tjavax.xml.transform.Transformer xform = factory.newTransformer();\n+\t\t\t\tif (xml) {\n+\t\t\t\t\txform.setOutputProperty(javax.xml.transform.OutputKeys.METHOD, \"xml\");\n+\t\t\t\t\txform.setOutputProperty(javax.xml.transform.OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n+\t\t\t\t\toutput = new File(output.getCanonicalPath() + \".xml\");\n+\t\t\t\t}\n+                xform.transform(\n+                    new javax.xml.transform.dom.DOMSource(template),\n+                    new javax.xml.transform.stream.StreamResult( new FileOutputStream(output) )\n+                );\n+            } catch (IOException e) {\n+                arguments.getConsole().println(\"Could not write results file to \" + output + \": \");\n+                e.printStackTrace(System.err);\n+            } catch (javax.xml.transform.TransformerConfigurationException e) {\n+                throw new RuntimeException(\"Parser failure\", e);\n+            } catch (javax.xml.transform.TransformerException e) {\n+                throw new RuntimeException(\"Parser failure\", e);\n+            }\n+        }\n+\t\t\n+\t\tvoid start() {\n+            this.html = getTemplate();\n+            this.failureHtml = getElementById(html.getDocumentElement(), \"failureDetails.prototype\");\n+            if (this.failureHtml == null) {\n+                try {\n+                    javax.xml.transform.TransformerFactory.newInstance().newTransformer().transform(\n+                        new javax.xml.transform.dom.DOMSource(html),\n+                        new javax.xml.transform.stream.StreamResult(System.err)\n+                    );\n+                } catch (Throwable t) {\n+                    throw new RuntimeException(t);\n+                }\n+                throw new RuntimeException(\"No\");\n+            }\n+            this.failureHtml.getParentNode().removeChild(this.failureHtml);\n+\t\t\t\n+\t\t\ttry {\n+\t\t\t\tthis.xml = javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder()\n+\t\t\t\t\t.getDOMImplementation().createDocument(null, \"results\", null)\n+\t\t\t\t;\n+\t\t\t\txml.getDocumentElement().setAttribute(\"timestamp\", String.valueOf(new Date().getTime()));\n+\t\t\t\txml.getDocumentElement().setAttribute(\"optimization\", String.valueOf(arguments.getOptimizationLevel()));\n+                xml.getDocumentElement().setAttribute(\"strict\", String.valueOf(arguments.isStrict()));\n+                xml.getDocumentElement().setAttribute(\"timeout\", String.valueOf(arguments.getTimeout()));\n+\t\t\t} catch (javax.xml.parsers.ParserConfigurationException e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t\t\n+\t\t\tthis.start = new Date();\n+\t\t}\n+\n+        void run(Tests.Script script, ShellTest.Parameters parameters) {\n+\t\t\tString path = script.getPath();\n+\t\t\tFile test = script.getFile();\n+            ConsoleStatus cStatus = new ConsoleStatus(arguments.getConsole(), trace);\n+            HtmlStatus hStatus = new HtmlStatus(arguments.getLxrUrl(), arguments.getBugUrl(), path, html, (Element)failureHtml.cloneNode(true));\n+\t\t\tXmlStatus xStatus = new XmlStatus(path, this.xml.getDocumentElement());\n+            ShellTest.Status status = ShellTest.Status.compose(new ShellTest.Status[] { cStatus, hStatus, xStatus });\n+            try {\n+                ShellTest.run(factory, test, parameters, status);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+            tests++;\n+            if (hStatus.failed()) {\n+                failures++;\n+            }\n+            hStatus.finish();\n+        }\n+\t\t\n+        private void set(Document document, String id, String value) {\n+            getElementById(document.getDocumentElement(), id).setTextContent(value);\n+        }\n+\n+        void finish() {\n+\t\t\tDate end = new Date();\n+            long elapsedMs = end.getTime() - start.getTime();\n+            set(html, \"results.testlist\", join(arguments.getTestList()));\n+            set(html, \"results.skiplist\", join(arguments.getSkipList()));\n+            String pct = new java.text.DecimalFormat(\"##0.00\").format( (double)failures / (double)tests * 100.0 );\n+            set(html, \"results.results\", \"Tests attempted: \" + tests + \" Failures: \" + failures + \" (\" + pct + \"%)\");\n+            set(html, \"results.platform\", \"java.home=\" + System.getProperty(\"java.home\")\n+                + \"\\n\" + \"java.version=\" + System.getProperty(\"java.version\")\n+                + \"\\n\" + \"os.name=\" + System.getProperty(\"os.name\")\n+            );\n+            set(html, \"results.classpath\", System.getProperty(\"java.class.path\").replace(File.pathSeparatorChar, ' '));\n+            int elapsedSeconds = (int)(elapsedMs / 1000);\n+            int elapsedMinutes = elapsedSeconds / 60;\n+            elapsedSeconds = elapsedSeconds % 60;\n+            String elapsed = \"\" + elapsedMinutes + \" minutes, \" + elapsedSeconds + \" seconds\";\n+            set(html, \"results.elapsed\", elapsed);\n+            set(html, \"results.time\", new java.text.SimpleDateFormat(\"MMMM d yyyy h:mm:ss aa\").format(new java.util.Date()));\n+            write(html, false);\n+\t\t\twrite(xml, true);\n+        }\n+    }\n+\n+    private static class ShellTestParameters extends ShellTest.Parameters {\n+        private int timeout;\n+\n+        ShellTestParameters(int timeout) {\n+            this.timeout = timeout;\n+        }\n+\n+        @Override\n+        public int getTimeoutMilliseconds() {\n+            return timeout;\n+        }\n+    }\n+\n+    void run(Arguments arguments) throws Throwable {\n+        if (arguments.help()) {\n+            System.out.println(\"See mozilla/js/tests/README-jsDriver.html; note that some options are not supported.\");\n+            System.out.println(\"Consult the Java source code at testsrc/org/mozilla/javascript/JsDriver.java for details.\");\n+            System.exit(0);\n+        }\n+\n+        ShellContextFactory factory = new ShellContextFactory();\n+        factory.setOptimizationLevel(arguments.getOptimizationLevel());\n+        factory.setStrictMode(arguments.isStrict());\n+\n+        File path = arguments.getTestsPath();\n+        if (path == null) {\n+            path = new File(\"../tests\");\n+        }\n+        if (!path.exists()) {\n+            throw new RuntimeException(\"JavaScript tests not found at \" + path.getCanonicalPath());\n+        }\n+        Tests tests = new Tests(path, arguments.getTestList(), arguments.getSkipList());\n+        Tests.Script[] all = tests.getFiles();\n+        arguments.getConsole().println(\"Running \" + all.length + \" tests.\");\n+\n+        Results results = new Results(factory, arguments, arguments.trace());\n+\t\t\n+\t\tresults.start();\n+        for (int i=0; i<all.length; i++) {\n+            results.run(all[i], new ShellTestParameters(arguments.getTimeout()));\n+        }\n+\t\tresults.finish();\n+    }\n+\n+    public static void main(Arguments arguments) throws Throwable {\n+        JsDriver driver = new JsDriver();\n+        driver.run(arguments);\n+    }\n+\n+    private static class Arguments {\n+        private ArrayList<Option> options = new ArrayList<Option>();\n+\n+        private Option bugUrl = new Option(\"b\", \"bugurl\", false, false, \"http://bugzilla.mozilla.org/show_bug.cgi?id=\");\n+        private Option optimizationLevel = new Option(\"o\", \"optimization\", false, false, \"-1\");\n+        private Option strict = new Option(null, \"strict\", false, true, null);        \n+        private Option outputFile = new Option(\"f\", \"file\", false, false, null);\n+        private Option help = new Option(\"h\", \"help\", false, true, null);\n+        private Option logFailuresToConsole = new Option(\"k\", \"confail\", false, true, null);\n+        private Option testList = new Option(\"l\", \"list\", true, false, null);\n+        private Option skipList = new Option(\"L\", \"neglist\", true, false, null);\n+        private Option testsPath = new Option(\"p\", \"testpath\", false, false, null);\n+        private Option trace = new Option(\"t\", \"trace\", false, true, null);\n+        private Option lxrUrl = new Option(\"u\", \"lxrurl\", false, false, \"http://lxr.mozilla.org/mozilla/source/js/tests/\");\n+        private Option timeout = new Option(null, \"timeout\", false, false, \"60000\");\n+       \n+        public static class Console {\n+          public void print(String message) {\n+            System.out.print(message);\n+          }\n+          public void println(String message) {\n+            System.out.println(message);\n+          }\n+        }\n+        private Console console = new Console();\n+\n+        private class Option {\n+            private String letterOption;\n+            private String wordOption;\n+            private boolean array;\n+            private boolean flag;\n+            private boolean ignored;\n+\n+            private ArrayList<String> values = new ArrayList<String>();\n+\n+            //    array: can this option have multiple values?\n+            //    flag: is this option a simple true/false switch?\n+            Option(String letterOption, String wordOption, boolean array,\n+                   boolean flag, String unspecified)\n+            {\n+                this.letterOption = letterOption;\n+                this.wordOption = wordOption;\n+                this.flag = flag;\n+                this.array = array;\n+                if (!flag && !array) {\n+                    this.values.add(unspecified);\n+                }\n+                options.add(this);\n+            }\n+\n+            Option ignored() {\n+                this.ignored = true;\n+                return this;\n+            }\n+\n+            int getInt() {\n+                return Integer.parseInt( getValue() );\n+            }\n+\n+            String getValue() {\n+                return values.get(0);\n+            }\n+\n+            boolean getSwitch() {\n+                return values.size() > 0;\n+            }\n+\n+            File getFile() {\n+                if (getValue() == null) return null;\n+                return new File(getValue());\n+            }\n+\n+            String[] getValues() {\n+                return values.toArray(new String[0]);\n+            }\n+\n+            void process(List<String> arguments) {\n+                String option = arguments.get(0);\n+                String dashLetter = (letterOption == null) ? (String)null : \"-\" + letterOption;\n+                if (option.equals(dashLetter) || option.equals(\"--\" + wordOption)) {\n+                    arguments.remove(0);\n+                    if (flag) {\n+                        values.add(0, (String)null );\n+                    } else if (array) {\n+                        while (arguments.size() > 0 &&\n+                               !arguments.get(0).startsWith(\"-\"))\n+                        {\n+                            values.add(arguments.remove(0));\n+                        }\n+                    } else {\n+                        values.set(0, arguments.remove(0));\n+                    }\n+                    if (ignored) {\n+                        System.err.println(\"WARNING: \" + option + \" is ignored in the Java version of the test driver.\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        //    -b URL, --bugurl=URL\n+        public String getBugUrl() {\n+            return bugUrl.getValue();\n+        }       \n+        \n+        //    -c PATH, --classpath=PATH\n+        //    Does not apply; we will use the VM's classpath\n+\n+        //    -e TYPE ..., --engine=TYPE ...\n+        //    Does not apply; was used to select between SpiderMonkey and Rhino\n+\n+        //    Not in jsDriver.pl\n+        public int getOptimizationLevel() {\n+            return optimizationLevel.getInt();\n+        }\n+        \n+        //    --strict\n+        public boolean isStrict() {\n+          return strict.getSwitch();\n+        }\n+\n+        //    -f FILE, --file=FILE\n+        public File getOutputFile() {\n+            return outputFile.getFile();\n+        }\n+        \n+        //    -h, --help\n+        public boolean help() {\n+            return help.getSwitch();\n+        }\n+\n+        //    -j PATH, --javapath=PATH\n+        //    Does not apply; we will use this JVM\n+\n+        //    -k, --confail\n+        //    TODO    Currently this is ignored; not clear precisely what it means (perhaps we should not be logging ordinary\n+        //            pass/fail to the console currently?)\n+        public boolean logFailuresToConsole() {\n+            return logFailuresToConsole.getSwitch();\n+        }\n+\n+        //    -l FILE,... or --list=FILE,...\n+        public String[] getTestList() {\n+            return testList.getValues();\n+        }\n+\n+        //    -L FILE,... or --neglist=FILE,...\n+        public String[] getSkipList() {\n+            return skipList.getValues();\n+        }\n+\n+        //    -p PATH, --testpath=PATH\n+        public File getTestsPath() {\n+            return testsPath.getFile();\n+        }\n+\n+        //    -s PATH, --shellpath=PATH\n+        //    Does not apply; we will use the Rhino shell with any classes given on the classpath\n+\n+        //    -t, --trace\n+        public boolean trace() {\n+            return trace.getSwitch();\n+        }\n+\n+        //    -u URL, --lxrurl=URL\n+        public String getLxrUrl() {\n+            return lxrUrl.getValue();\n+        }\n+\n+        //\n+        //    New arguments\n+        //\n+\n+        //    --timeout\n+        //    Milliseconds to wait for each test\n+        public int getTimeout() {\n+            return timeout.getInt();\n+        }\n+\n+        public Console getConsole() {\n+            return console;\n+        }\n+        \n+        void process(List<String> arguments) {\n+            while(arguments.size() > 0) {\n+                String option = arguments.get(0);\n+                if (option.startsWith(\"--\")) {\n+                    //    preprocess --name=value options into --name value\n+                    if (option.indexOf(\"=\") != -1) {\n+                        arguments.set(0, option.substring(option.indexOf(\"=\")));\n+                        arguments.add(1, option.substring(option.indexOf(\"=\") + 1));\n+                    }\n+                } else if (option.startsWith(\"-\")) {\n+                    //    could be multiple single-letter options, e.g. -kht, so preprocess them into -k -h -t\n+                    if (option.length() > 2) {\n+                        for (int i=2; i<option.length(); i++) {\n+                            arguments.add(1, \"-\" + option.substring(i,i+1));\n+                        }\n+                        arguments.set(0, option.substring(0,2));\n+                    }\n+                }\n+                int lengthBefore = arguments.size();\n+                for (int i=0; i<options.size(); i++) {\n+                    if (arguments.size() > 0) {\n+                        options.get(i).process(arguments);\n+                    }\n+                }\n+                \n+                if (arguments.size() == lengthBefore) {\n+\t\t\t\t\tSystem.err.println(\"WARNING: ignoring unrecognized option \" + arguments.remove(0));\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        ArrayList<String> arguments = new ArrayList<String>();\n+        arguments.addAll(Arrays.asList(args));\n+        Arguments clArguments = new Arguments();\n+        clArguments.process(arguments);\n+        main(clArguments);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/drivers/JsTestsBase.java\n+package org.mozilla.javascript.drivers;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.Scriptable;\n+\n+public class JsTestsBase extends TestCase {\n+    private int optimizationLevel;\n+    \n+    public void setOptimizationLevel(int level) {\n+        this.optimizationLevel = level;\n+    }\n+  \n+    public void runJsTest(Context cx, Scriptable shared, String name, String source) {\n+        // create a lightweight top-level scope\n+        Scriptable scope = cx.newObject(shared);\n+        scope.setPrototype(shared);\n+        System.out.print(name + \": \");\n+        Object result;\n+        try {\n+            result = cx.evaluateString(scope, source, \"jstest input\", 1, null);\n+        } catch (RuntimeException e) {\n+            System.out.println(\"FAILED\");\n+            throw e;\n+        }\n+        assertTrue(result != null);\n+        assertTrue(\"success\".equals(result));\n+        System.out.println(\"passed\");\n+    }\n+    \n+    public void runJsTests(File[] tests) throws IOException {\n+        ContextFactory factory = ContextFactory.getGlobal();\n+        Context cx = factory.enterContext();\n+        try {\n+            cx.setOptimizationLevel(this.optimizationLevel);\n+            Scriptable shared = cx.initStandardObjects();\n+            for (File f : tests) {\n+                int length = (int) f.length(); // don't worry about very long\n+                                               // files\n+                char[] buf = new char[length];\n+                new FileReader(f).read(buf, 0, length);\n+                String session = new String(buf);\n+                runJsTest(cx, shared, f.getName(), session);\n+            }\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/drivers/ShellTest.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is the Java port of jsDriver.pl.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * David P. Caldwell.\n+ * Portions created by David P. Caldwell are Copyright (C)\n+ * 2007 David P. Caldwell. All Rights Reserved.\n+ *\n+ *\n+ * Contributor(s):\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.drivers;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.tools.shell.Global;\n+import org.mozilla.javascript.tools.shell.Main;\n+import org.mozilla.javascript.tools.shell.ShellContextFactory;\n+\n+/**\n+ * @version $Id: ShellTest.java,v 1.12 2009/05/15 12:30:45 nboyd%atg.com Exp $\n+ */\n+public class ShellTest {\n+    public static final FileFilter DIRECTORY_FILTER = new FileFilter() {\n+        public boolean accept(File pathname)\n+        {\n+            return pathname.isDirectory() && !pathname.getName().equals(\"CVS\");\n+        }\n+    };\n+\n+    public static final FileFilter TEST_FILTER = new FileFilter() {\n+        public boolean accept(File pathname)\n+        {\n+            return pathname.getName().endsWith(\".js\") && !pathname.getName().equals(\"shell.js\") && !pathname.getName().equals(\"browser.js\") && !pathname.getName().equals(\"template.js\");\n+        }\n+    };\n+\n+    public static String getStackTrace(Throwable t) {\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+        t.printStackTrace(new PrintStream(bytes));\n+        return new String(bytes.toByteArray());\n+    }\n+\n+    private static void runFileIfExists(Context cx, Scriptable global, File f)\n+    {\n+        if(f.isFile())\n+        {\n+            Main.processFile(cx, global, f.getPath());\n+        }\n+    }\n+\n+    private static class TestState\n+    {\n+        boolean finished;\n+        ErrorReporterWrapper errors;\n+        int exitCode = 0;\n+    }\n+\n+    public static abstract class Status {\n+        private boolean negative;\n+\n+        public final void setNegative() {\n+            this.negative = true;\n+        }\n+\n+        public final boolean isNegative() {\n+            return this.negative;\n+        }\n+\n+        public final void hadErrors(JsError[] errors) {\n+            if (!negative && errors.length > 0) {\n+                failed(\"JavaScript errors:\\n\" + JsError.toString(errors));\n+            } else if (negative && errors.length == 0) {\n+                failed(\"Should have produced runtime error.\");\n+            }\n+        }\n+\n+        public abstract void running(File jsFile);\n+\n+        public abstract void failed(String s);\n+        public abstract void threw(Throwable t);\n+        public abstract void timedOut();\n+        public abstract void exitCodesWere(int expected, int actual);\n+        public abstract void outputWas(String s);\n+\n+        static Status compose(final Status[] array) {\n+            return new Status() {\n+                @Override\n+                public void running(File file) {\n+\t\t\t\t\tfor (int i=0; i<array.length; i++) {\n+\t\t\t\t\t\tarray[i].running(file);\n+\t\t\t\t\t}\n+                }\n+                @Override\n+                public void threw(Throwable t) {\n+\t\t\t\t\tfor (int i=0; i<array.length; i++) {\n+\t\t\t\t\t\tarray[i].threw(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+                @Override\n+                public void failed(String s) {\n+\t\t\t\t\tfor (int i=0; i<array.length; i++) {\n+\t\t\t\t\t\tarray[i].failed(s);\n+\t\t\t\t\t}\n+                }\n+                @Override\n+                public void exitCodesWere(int expected, int actual) {\n+\t\t\t\t\tfor (int i=0; i<array.length; i++) {\n+\t\t\t\t\t\tarray[i].exitCodesWere(expected, actual);\n+\t\t\t\t\t}\n+                }\n+                @Override\n+                public void outputWas(String s) {\n+\t\t\t\t\tfor (int i=0; i<array.length; i++) {\n+\t\t\t\t\t\tarray[i].outputWas(s);\n+\t\t\t\t\t}\n+                }\n+                @Override\n+                public void timedOut() {\n+\t\t\t\t\tfor (int i=0; i<array.length; i++) {\n+\t\t\t\t\t\tarray[i].timedOut();\n+\t\t\t\t\t}\n+                }\n+            };\n+        }\n+\n+        static class JsError {\n+            static String toString(JsError[] e) {\n+                String rv = \"\";\n+                for (int i=0; i<e.length; i++) {\n+                    rv += e[i].toString();\n+                    if (i+1 != e.length) {\n+                        rv += \"\\n\";\n+                    }\n+                }\n+                return rv;\n+            }\n+\n+            private String message;\n+            private String sourceName;\n+            private int line;\n+            private String lineSource;\n+            private int lineOffset;\n+\n+            JsError(String message, String sourceName, int line, String lineSource, int lineOffset) {\n+                this.message = message;\n+                this.sourceName = sourceName;\n+                this.line = line;\n+                this.lineSource = lineSource;\n+                this.lineOffset = lineOffset;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                String locationLine = \"\";\n+                if (sourceName != null)\n+                    locationLine += sourceName + \":\";\n+                if (line != 0)\n+                    locationLine += line + \": \";\n+                locationLine += message;\n+                String sourceLine = this.lineSource;\n+                String errCaret = null;\n+                if (lineSource != null) {\n+                    errCaret = \"\";\n+                    for (int i=0; i<lineSource.length(); i++) {\n+                        char c = lineSource.charAt(i);\n+                        if (i < lineOffset-1) {\n+                            if (c == '\\t') {\n+                                errCaret += \"\\t\";\n+                            } else {\n+                                errCaret += \" \";\n+                            }\n+                        } else if (i == lineOffset-1) {\n+                            errCaret += \"^\";\n+                        }\n+                    }\n+                }\n+                String rv = locationLine;\n+                if (sourceLine != null) {\n+                    rv += \"\\n\" + sourceLine;\n+                }\n+                if (errCaret != null) {\n+                    rv += \"\\n\" + errCaret;\n+                }\n+                return rv;\n+            }\n+\n+            String getMessage() {\n+                return message;\n+            }\n+\n+            String getSourceName() {\n+                return sourceName;\n+            }\n+\n+            int getLine() {\n+                return line;\n+            }\n+\n+            String getLineSource() {\n+                return lineSource;\n+            }\n+\n+            int getLineOffset() {\n+                return lineOffset;\n+            }\n+        }\n+    }\n+\n+    private static class ErrorReporterWrapper implements ErrorReporter {\n+        private ErrorReporter original;\n+        private ArrayList<Status.JsError> errors = new ArrayList<Status.JsError>();\n+\n+        ErrorReporterWrapper(ErrorReporter original) {\n+            this.original = original;\n+        }\n+\n+        private void addError(String string, String string0, int i, String string1, int i0) {\n+            errors.add( new Status.JsError(string, string0, i, string1, i0) );\n+        }\n+\n+        public void warning(String string, String string0, int i, String string1, int i0) {\n+            original.warning(string, string0, i, string1, i0);\n+        }\n+\n+        public EvaluatorException runtimeError(String string, String string0, int i, String string1, int i0) {\n+            return original.runtimeError(string, string0, i, string1, i0);\n+        }\n+\n+        public void error(String string, String string0, int i, String string1, int i0) {\n+            addError(string, string0, i, string1, i0);\n+        }\n+    }\n+\n+    public static abstract class Parameters {\n+        public abstract int getTimeoutMilliseconds();\n+    }\n+    \n+    @SuppressWarnings(value={\"deprecation\"})\n+    private static void callStop(Thread t) {\n+        t.stop();\n+    }\n+\n+    public static void run(final ShellContextFactory shellContextFactory,\n+            final File jsFile, final Parameters parameters,\n+            final Status status) throws Exception {\n+        final Global global = new Global();\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream p = new PrintStream(out);\n+        global.setOut(p);\n+        global.setErr(p);\n+        global.defineFunctionProperties(\n+                new String[] { \"options\" }, ShellTest.class,\n+                ScriptableObject.DONTENUM | ScriptableObject.PERMANENT |\n+                  ScriptableObject.READONLY);\n+        final TestState testState = new TestState();\n+        if (jsFile.getName().endsWith(\"-n.js\")) {\n+            status.setNegative();\n+        }\n+        final Throwable thrown[] = {null};\n+        \n+        Thread t = new Thread(new Runnable()\n+        {\n+            public void run()\n+            {\n+                try\n+                {\n+                    shellContextFactory.call(new ContextAction()\n+                    {\n+                        public Object run(Context cx)\n+                        {\n+                            status.running(jsFile);\n+                            testState.errors = new ErrorReporterWrapper(cx.getErrorReporter());\n+                            cx.setErrorReporter( testState.errors );\n+                            global.init(cx);\n+                            try {\n+                                runFileIfExists(cx, global, new File(jsFile.getParentFile().getParentFile().getParentFile(), \"shell.js\"));\n+                                runFileIfExists(cx, global, new File(jsFile.getParentFile().getParentFile(), \"shell.js\"));\n+                                runFileIfExists(cx, global, new File(jsFile.getParentFile(), \"shell.js\"));\n+                                runFileIfExists(cx, global, jsFile);\n+                                status.hadErrors(testState.errors.errors.toArray(new Status.JsError[0]));\n+                            } catch (ThreadDeath e) {\n+                            } catch (Throwable t) {\n+                                status.threw(t);\n+                            }\n+                            return null;\n+                        }\n+                    });\n+                }\n+                catch (Error t)\n+                {\n+                    thrown[0] = t;\n+                }\n+                catch (RuntimeException t)\n+                {\n+                    thrown[0] = t;\n+                }\n+                finally {\n+                    synchronized(testState)\n+                    {\n+                        testState.finished = true;\n+                    }\n+                }\n+            }\n+        }, jsFile.getPath());\n+        t.setDaemon(true);\n+        t.start();\n+        t.join(parameters.getTimeoutMilliseconds());\n+        synchronized(testState)\n+        {\n+            if(!testState.finished)\n+            {\n+                callStop(t);\n+                status.timedOut();\n+            }\n+        }\n+        int expectedExitCode = 0;\n+        p.flush();\n+        status.outputWas(new String(out.toByteArray()));\n+        BufferedReader r = new BufferedReader(new InputStreamReader(\n+                new ByteArrayInputStream(out.toByteArray())));\n+        String failures = \"\";\n+        for(;;)\n+        {\n+            String s = r.readLine();\n+            if(s == null)\n+            {\n+                break;\n+            }\n+            if(s.indexOf(\"FAILED!\") != -1)\n+            {\n+                failures += s + '\\n';\n+            }\n+            int expex = s.indexOf(\"EXPECT EXIT CODE \");\n+            if(expex != -1)\n+            {\n+                expectedExitCode = s.charAt(expex + \"EXPECT EXIT CODE \".length()) - '0';\n+            }\n+        }\n+        if (thrown[0] != null)\n+        {\n+        \tstatus.threw(thrown[0]);\n+        }\n+        status.exitCodesWere(expectedExitCode, testState.exitCode);\n+        if(failures != \"\")\n+        {\n+            status.failed(failures);\n+        }\n+    }\n+\n+    // Global function to mimic options() function in spidermonkey.\n+    // It looks like this toggles jit compiler mode in spidermonkey\n+    // when called with \"jit\" as argument. Our version is a no-op\n+    // and returns an empty string.\n+    public static String options() {\n+        return \"\";\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/drivers/StandardTests.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Attila Szegedi\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.drivers;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.net.URL;\n+import java.util.Arrays;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.mozilla.javascript.tools.shell.ShellContextFactory;\n+\n+/**\n+ * Executes the tests in the js/tests directory, much like jsDriver.pl does.\n+ * Excludes tests found in the js/tests/rhino-n.tests file.\n+ * @version $Id: StandardTests.java,v 1.15 2009/07/21 17:39:05 nboyd%atg.com Exp $\n+ */\n+public class StandardTests extends TestSuite\n+{\n+    // Disable this suite in favor of\n+    // org.mozilla.javascript.tests.MozillaSuiteTest\n+    private static final boolean DISABLE = true;\n+\n+\tpublic static TestSuite suite() throws Exception\n+    {\n+        TestSuite suite = new TestSuite(\"Standard JavaScript tests\");\n+        if (!DISABLE) {\n+            File testDir = null;\n+            if (System.getProperty(\"mozilla.js.tests\") != null) {\n+                testDir = new File(System.getProperty(\"mozilla.js.tests\"));\n+            } else {\n+                URL url = StandardTests.class.getResource(\".\");\n+                String path = url.getFile();\n+                int jsIndex = path.lastIndexOf(\"/js\");\n+                if(jsIndex == -1)\n+                {\n+                    throw new IllegalStateException(\"You aren't running the tests from within the standard mozilla/js directory structure\");\n+                }\n+                path = path.substring(0, jsIndex + 3).replace('/', File.separatorChar);\n+                path = path.replace(\"%20\", \" \");\n+                testDir = new File(path, \"tests\");\n+            }\n+            if(!testDir.isDirectory())\n+            {\n+                throw new FileNotFoundException(testDir + \" is not a directory\");\n+            }\n+            String[] excludes = TestUtils.loadTestsFromResource(\"/base.skip\", null);\n+            String[] opt1Excludes = TestUtils.loadTestsFromResource(\"/opt1.skip\", excludes);\n+            for(int i = -1; i < 2; ++i)\n+            {\n+                TestSuite optimizationLevelSuite = new TestSuite(\"Optimization level \" + i);\n+                addSuites(optimizationLevelSuite, testDir, i == -1 ? excludes : opt1Excludes, i);\n+                suite.addTest(optimizationLevelSuite);\n+            }\n+        }\n+        return suite;\n+    }\n+\n+    private static void addSuites(TestSuite topLevel, File testDir, String[] excludes, int optimizationLevel)\n+    {\n+        File[] subdirs = testDir.listFiles(ShellTest.DIRECTORY_FILTER);\n+        Arrays.sort(subdirs);\n+        for (int i = 0; i < subdirs.length; i++)\n+        {\n+            File subdir = subdirs[i];\n+            String name = subdir.getName();\n+            if (TestUtils.matches(excludes, name)) {\n+                continue;\n+            }\n+            TestSuite testSuite = new TestSuite(name);\n+            addCategories(testSuite, subdir, name + \"/\", excludes, optimizationLevel);\n+            topLevel.addTest(testSuite);\n+        }\n+    }\n+\n+    private static void addCategories(TestSuite suite, File suiteDir, String prefix, String[] excludes, int optimizationLevel)\n+    {\n+        File[] subdirs = suiteDir.listFiles(ShellTest.DIRECTORY_FILTER);\n+        Arrays.sort(subdirs);\n+        for (int i = 0; i < subdirs.length; i++)\n+        {\n+            File subdir = subdirs[i];\n+            String name = subdir.getName();\n+            TestSuite testCategory = new TestSuite(name);\n+            addTests(testCategory, subdir, prefix + name + \"/\", excludes, optimizationLevel);\n+            suite.addTest(testCategory);\n+        }\n+    }\n+\n+    private static void addTests(TestSuite suite, File suiteDir, String prefix, String[] excludes, int optimizationLevel)\n+    {\n+        File[] jsFiles = suiteDir.listFiles(ShellTest.TEST_FILTER);\n+        Arrays.sort(jsFiles);\n+        for (int i = 0; i < jsFiles.length; i++)\n+        {\n+            File jsFile = jsFiles[i];\n+            String name = jsFile.getName();\n+            if (!TestUtils.matches(excludes, prefix + name)) {\n+                suite.addTest(new JsTestCase(jsFile, optimizationLevel));\n+            }\n+        }\n+    }\n+\n+    public static class JunitStatus extends ShellTest.Status {\n+        @Override\n+        public final void running(File jsFile) {\n+            //    do nothing\n+        }\n+\n+        @Override\n+        public final void failed(String s) {\n+            Assert.fail(s);\n+        }\n+\n+        @Override\n+        public final void exitCodesWere(int expected, int actual) {\n+            Assert.assertEquals(\"Unexpected exit code\", expected, actual);\n+        }\n+\n+        @Override\n+        public final void outputWas(String s) {\n+            // Do nothing; we don't want to see the output when running JUnit\n+            // tests.\n+        }\n+\n+        @Override\n+        public final void threw(Throwable t) {\n+            Assert.fail(ShellTest.getStackTrace(t));\n+        }\n+\n+        @Override\n+        public final void timedOut() {\n+            failed(\"Timed out.\");\n+        }\n+    }\n+\n+    public static final class JsTestCase extends TestCase\n+    {\n+        private final File jsFile;\n+        private final int optimizationLevel;\n+\n+        JsTestCase(File jsFile, int optimizationLevel)\n+        {\n+            super(jsFile.getName() + (optimizationLevel == 1 ? \"-compiled\" : \"-interpreted\"));\n+            this.jsFile = jsFile;\n+            this.optimizationLevel = optimizationLevel;\n+        }\n+\n+        @Override\n+        public int countTestCases()\n+        {\n+            return 1;\n+        }\n+\n+        public static class ShellTestParameters extends ShellTest.Parameters {\n+            @Override\n+            public int getTimeoutMilliseconds() {\n+                if (System.getProperty(\"mozilla.js.tests.timeout\") != null) {\n+                    return Integer.parseInt(System.getProperty(\"mozilla.js.tests.timeout\"));\n+                }\n+                return 60000;\n+            }\n+        }\n+\n+        @Override\n+        public void runBare() throws Exception\n+        {\n+            final ShellContextFactory shellContextFactory = new ShellContextFactory();\n+            shellContextFactory.setOptimizationLevel(optimizationLevel);\n+            ShellTestParameters params = new ShellTestParameters();\n+            ShellTest.run(shellContextFactory, jsFile, params, new JunitStatus());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/drivers/TestUtils.java\n+package org.mozilla.javascript.drivers;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Arrays;\n+\n+import org.mozilla.javascript.ContextFactory;\n+\n+public class TestUtils {\n+    private static ContextFactory.GlobalSetter globalSetter;\n+\n+    public static void GrabContextFactoryGlobalSetter() {\n+        if (globalSetter == null) {\n+            globalSetter = ContextFactory.getGlobalSetter();\n+        }\n+    }\n+\n+    public static void setGlobalContextFactory(ContextFactory factory) {\n+        GrabContextFactoryGlobalSetter();\n+        globalSetter.setContextFactoryGlobal(factory);\n+    }\n+\n+    public static File[] recursiveListFiles(File dir, FileFilter filter) {\n+        if (!dir.isDirectory())\n+            throw new IllegalArgumentException(dir + \" is not a directory\");\n+        List<File> fileList = new ArrayList<File>();\n+        recursiveListFilesHelper(dir, filter, fileList);\n+        return fileList.toArray(new File[fileList.size()]);\n+    }\n+\n+    public static void recursiveListFilesHelper(File dir, FileFilter filter,\n+                                                List<File> fileList)\n+    {\n+        for (File f: dir.listFiles()) {\n+            if (f.isDirectory()) {\n+                recursiveListFilesHelper(f, filter, fileList);\n+            } else {\n+                if (filter.accept(f))\n+                    fileList.add(f);\n+            }\n+        }\n+    }\n+\n+    public static void addTestsFromFile(String filename, List<String> list)\n+            throws IOException {\n+        addTestsFromStream(new FileInputStream(new File(filename)), list);\n+    }\n+\n+    public static void addTestsFromStream(InputStream in, List<String> list)\n+            throws IOException {\n+        Properties props = new Properties();\n+        props.load(in);\n+        for (Object obj: props.keySet()) {\n+            list.add(obj.toString());\n+        }\n+    }\n+\n+    public static String[] loadTestsFromResource(String resource, String[] inherited)\n+            throws IOException {\n+        List<String> list = inherited == null ?\n+                new ArrayList<String>() :\n+                new ArrayList<String>(Arrays.asList(inherited));\n+        InputStream in = StandardTests.class.getResourceAsStream(resource);\n+        if (in != null)\n+            addTestsFromStream(in, list);\n+        return list.toArray(new String[0]);\n+    }\n+\n+    public static boolean matches(String[] patterns, String path) {\n+        for (int i=0; i<patterns.length; i++) {\n+            if (path.startsWith(patterns[i])) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/testing/TestErrorReporter.java\n+package org.mozilla.javascript.testing;\n+\n+import org.mozilla.javascript.ErrorReporter;\n+import org.mozilla.javascript.EvaluatorException;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ * <p>An error reporter for testing that verifies that messages reported to the\n+ * reporter are expected.</p>\n+ *\n+ * <p>Sample use</p>\n+ * <pre>\n+ * TestErrorReporter e =\n+ *   new TestErrorReporter(null, new String[] { \"first warning\" });\n+ * ...\n+ * assertTrue(e.hasEncounteredAllWarnings());\n+ * </pre>\n+ *\n+ */\n+public class TestErrorReporter extends Assert implements ErrorReporter {\n+    private final String[] errors;\n+    private final String[] warnings;\n+    private int errorsIndex = 0;\n+    private int warningsIndex = 0;\n+\n+    public TestErrorReporter(String[] errors, String[] warnings) {\n+        this.errors = errors;\n+        this.warnings = warnings;\n+    }\n+\n+    public void error(String message, String sourceName, int line,\n+                      String lineSource, int lineOffset) {\n+        if (errors != null && errorsIndex < errors.length) {\n+            assertEquals(errors[errorsIndex++], message);\n+        } else {\n+            fail(\"extra error: \" + message);\n+        }\n+    }\n+\n+    public void warning(String message, String sourceName, int line,\n+                        String lineSource, int lineOffset) {\n+        if (warnings != null && warningsIndex < warnings.length) {\n+            assertEquals(warnings[warningsIndex++], message);\n+        } else {\n+            fail(\"extra warning: \" + message);\n+        }\n+    }\n+\n+    public EvaluatorException runtimeError(\n+        String message, String sourceName, int line, String lineSource,\n+        int lineOffset) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+   /**\n+    * Returns whether all warnings were reported to this reporter.\n+    */\n+    public boolean hasEncounteredAllWarnings() {\n+        return (warnings == null) ?\n+            warningsIndex == 0 :\n+            warnings.length == warningsIndex;\n+    }\n+\n+   /**\n+    * Returns whether all errors were reported to this reporter.\n+    */\n+    public boolean hasEncounteredAllErrors() {\n+        return (errors == null) ?\n+            errorsIndex == 0 :\n+            errors.length == errorsIndex;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/ApplyOnPrimitiveNumberTest.java\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.ScriptRuntime;\n+import org.mozilla.javascript.ScriptableObject;\n+\n+/**\n+ * Primitive numbers are not wrapped before calling apply.\n+ * Test for bug <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=466661\">466661</a>.\n+ */\n+public class ApplyOnPrimitiveNumberTest extends TestCase\n+{\n+\tpublic void testIt()\n+\t{\n+\t\tfinal String script = \"var fn = function() { return this; }\\n\"\n+\t\t\t+ \"fn.apply(1)\";\n+\n+\t\tfinal ContextAction action = new ContextAction()\n+\t\t{\n+\t\t\tpublic Object run(final Context _cx)\n+\t\t\t{\n+\t\t\t\tfinal ScriptableObject scope = _cx.initStandardObjects();\n+\t\t\t\tfinal Object result = _cx.evaluateString(scope, script, \"test script\", 0, null);\n+\t\t\t\tassertEquals(\"object\", ScriptRuntime.typeof(result));\n+\t\t\t\tassertEquals(\"1\", Context.toString(result));\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t};\n+\t\tUtils.runWithAllOptimizationLevels(action);\n+\t}\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/ArrayConcatTest.java\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.ScriptableObject;\n+\n+/**\n+ * Test for overloaded array concat with non-dense arg.\n+ * See https://bugzilla.mozilla.org/show_bug.cgi?id=477604\n+ */\n+public class ArrayConcatTest extends TestCase {\n+\n+    public void testArrayConcat() {\n+\t\tfinal String script = \"var a = ['a0', 'a1'];\\n\"\n+\t\t\t+ \"a[3] = 'a3';\\n\"\n+\t\t\t+ \"var b = ['b1', 'b2'];\\n\"\n+\t\t\t+ \"b.concat(a)\";\n+\n+\t\tfinal ContextAction action = new ContextAction()\n+\t\t{\n+\t\t\tpublic Object run(final Context _cx)\n+\t\t\t{\n+\t\t\t\tfinal ScriptableObject scope = _cx.initStandardObjects();\n+\t\t\t\tfinal Object result = _cx.evaluateString(scope, script, \"test script\", 0, null);\n+\t\t\t\tassertEquals(\"b1,b2,a0,a1,,a3\", Context.toString(result));\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t};\n+\n+\t\tUtils.runWithAllOptimizationLevels(action);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Bug409702Test.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * See https://bugzilla.mozilla.org/show_bug.cgi?id=409702\n+ */\n+public class Bug409702Test extends TestCase {\n+\n+    public static abstract class Foo {\n+        public Foo() {\n+        }\n+\n+        public abstract void a();\n+\n+        public abstract int b();\n+\n+        public static abstract class Subclass extends Foo {\n+\n+            @Override\n+            public final void a() {\n+            }\n+        }\n+    }\n+\n+  public void testAdapter() {\n+      final int value = 12;\n+      String source =\n+          \"var instance = \" +\n+          \"  new JavaAdapter(\" + Foo.Subclass.class.getName() + \",\" +\n+          \"{ b: function () { return \" + value + \"; } });\" +\n+          \"instance.b();\";\n+\n+      Context cx = ContextFactory.getGlobal().enterContext();\n+      try {\n+          Scriptable scope = cx.initStandardObjects();\n+          Object result = cx.evaluateString(scope, source, \"source\", 1, null);\n+          assertEquals(new Integer(value), result);\n+      } finally {\n+          Context.exit();\n+      }\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Bug412433Test.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * See https://bugzilla.mozilla.org/show_bug.cgi?id=412433\n+ */\n+public class Bug412433Test extends TestCase {\n+    public void testMalformedJavascript2()\n+    {\n+        Context context = Context.enter();\n+        try {\n+\t        ScriptableObject scope = context.initStandardObjects();\n+\t        context.evaluateString(scope, \"\\\"\\\".split(/[/?,/&]/)\", \"\", 0, null);\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Bug419940Test.java\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * See https://bugzilla.mozilla.org/show_bug.cgi?id=419940\n+ */\n+public class Bug419940Test extends TestCase {\n+    final static int value = 12;\n+\n+    public static abstract class BaseFoo {\n+        public abstract int doSomething();\n+    }\n+    public static class Foo extends BaseFoo {\n+        @Override\n+        public int doSomething() {\n+           return value;\n+        }\n+    }\n+\n+  public void testAdapter() {\n+      String source =\n+          \"(new JavaAdapter(\" + Foo.class.getName() + \", {})).doSomething();\";\n+\n+      Context cx = ContextFactory.getGlobal().enterContext();\n+      try {\n+          Scriptable scope = cx.initStandardObjects();\n+          Object result = cx.evaluateString(scope, source, \"source\", 1, null);\n+          assertEquals(new Integer(value), result);\n+      } finally {\n+          Context.exit();\n+      }\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Bug421071Test.java\n+/*\n+ * @(#)Bug421071Test.java\n+ *\n+ */\n+\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.ImporterTopLevel;\n+import org.mozilla.javascript.Script;\n+import org.mozilla.javascript.Scriptable;\n+\n+public class Bug421071Test extends TestCase {\n+    private ContextFactory factory;\n+    private TopLevelScope globalScope;\n+    private Script testScript;\n+\n+    public void testProblemReplicator() throws Exception {\n+        // before debugging please put the breakpoint in the\n+        // NativeJavaPackage.getPkgProperty()\n+        // and observe names passed in there\n+        testScript = compileScript();\n+        runTestScript(); // this one does not get to the\n+                            // NativeJavaPackage.getPkgProperty() on my\n+                            // variables\n+        runTestScript(); // however this one does\n+    }\n+\n+    private Script compileScript() {\n+        String scriptSource = \"importPackage(java.util);\\n\"\n+                + \"var searchmon = 3;\\n\"\n+                + \"var searchday = 10;\\n\"\n+                + \"var searchyear = 2008;\\n\"\n+                + \"var searchwkday = 0;\\n\"\n+                + \"\\n\"\n+                + \"var myDate = Calendar.getInstance();\\n // this is a java.util.Calendar\"\n+                + \"myDate.set(Calendar.MONTH, searchmon);\\n\"\n+                + \"myDate.set(Calendar.DATE, searchday);\\n\"\n+                + \"myDate.set(Calendar.YEAR, searchyear);\\n\"\n+                + \"searchwkday.value = myDate.get(Calendar.DAY_OF_WEEK);\";\n+        Script script;\n+        Context context = factory.enterContext();\n+        try {\n+            script = context.compileString(scriptSource, \"testScript\", 1, null);\n+            return script;\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+    private void runTestScript() throws InterruptedException {\n+        // will start new thread to get as close as possible to original\n+        // environment, however the same behavior is exposed using new\n+        // ScriptRunner(script).run();\n+        Thread thread = new Thread(new ScriptRunner(testScript));\n+        thread.start();\n+        thread.join();\n+    }\n+\n+    static class DynamicScopeContextFactory extends ContextFactory {\n+        @Override\n+        public boolean hasFeature(Context cx, int featureIndex) {\n+            if (featureIndex == Context.FEATURE_DYNAMIC_SCOPE)\n+                return true;\n+            return super.hasFeature(cx, featureIndex);\n+        }\n+    }\n+\n+    private TopLevelScope createGlobalScope() {\n+        factory = new DynamicScopeContextFactory();\n+        Context context = factory.enterContext();\n+        // noinspection deprecation\n+        TopLevelScope globalScope = new TopLevelScope(context);\n+        Context.exit();\n+        return globalScope;\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        globalScope = createGlobalScope();\n+    }\n+\n+    private class TopLevelScope extends ImporterTopLevel {\n+        private static final long serialVersionUID = 7831526694313927899L;\n+\n+        public TopLevelScope(Context context) {\n+            super(context);\n+        }\n+    }\n+\n+    private class ScriptRunner implements Runnable {\n+        private Script script;\n+\n+        public ScriptRunner(Script script) {\n+            this.script = script;\n+        }\n+\n+        public void run() {\n+            Context context = factory.enterContext();\n+            try {\n+                // Run each script in its own scope, to keep global variables\n+                // defined in each script separate\n+                Scriptable threadScope = context.newObject(globalScope);\n+                threadScope.setPrototype(globalScope);\n+                threadScope.setParentScope(null);\n+                script.exec(context, threadScope);\n+            } catch (Exception ee) {\n+                ee.printStackTrace();\n+            } finally {\n+                Context.exit();\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Bug448816Test.java\n+package org.mozilla.javascript.tests;\n+\n+import org.mozilla.javascript.ScriptableObject;\n+import org.mozilla.javascript.Context;\n+import junit.framework.TestCase;\n+\n+import java.util.*;\n+\n+\n+/**\n+ * See https://bugzilla.mozilla.org/show_bug.cgi?id=448816\n+ */\n+public class Bug448816Test extends TestCase {\n+\n+    Map<Object, Object> map, reference;\n+\n+    protected void setUp() {\n+        // set up a reference map\n+        reference = new LinkedHashMap<Object, Object>();\n+        reference.put(\"a\", \"a\");\n+        reference.put(\"b\", Boolean.TRUE);\n+        reference.put(\"c\", new HashMap());\n+        reference.put(new Integer(1), new Integer(42));\n+        // get a js object as map\n+        Context context = Context.enter();\n+        ScriptableObject scope = context.initStandardObjects();\n+        map = (Map<Object, Object>) context.evaluateString(scope,\n+                \"({ a: 'a', b: true, c: new java.util.HashMap(), 1: 42});\",\n+                \"testsrc\", 1, null);\n+        Context.exit();\n+    }\n+\n+    public void testEqual() {\n+        // FIXME we do not override equals() and hashCode() in ScriptableObject\n+        // so calling this with swapped argument fails. This breaks symmetry\n+        // of equals(), but overriding these methods might be risky.\n+        assertEquals(reference, map);\n+    }\n+\n+    public void testBasicAccess() {\n+        assertTrue(map.size() == 4);\n+        assertEquals(map.get(\"a\"), reference.get(\"a\"));\n+        assertEquals(map.get(\"b\"), reference.get(\"b\"));\n+        assertEquals(map.get(\"c\"), reference.get(\"c\"));\n+        assertEquals(map.get(new Integer(1)), reference.get(new Integer(1)));\n+        assertEquals(map.get(\"notfound\"), reference.get(\"notfound\"));\n+        assertTrue(map.containsKey(\"b\"));\n+        assertTrue(map.containsValue(Boolean.TRUE));\n+        assertFalse(map.containsKey(\"x\"));\n+        assertFalse(map.containsValue(Boolean.FALSE));\n+        assertFalse(map.containsValue(null));\n+    }\n+\n+    public void testCollections() {\n+        assertEquals(map.keySet(), reference.keySet());\n+        assertEquals(map.entrySet(), reference.entrySet());\n+        // java.util.Collection does not imply overriding equals(), so:\n+        assertTrue(map.values().containsAll(reference.values()));\n+        assertTrue(reference.values().containsAll(map.values()));\n+    }\n+\n+    public void testRemoval() {\n+        // the only update we implement is removal\n+        assertTrue(map.size() == 4);\n+        assertEquals(map.remove(\"b\"), Boolean.TRUE);\n+        reference.remove(\"b\");\n+        assertTrue(map.size() == 3);\n+        assertEquals(reference, map);\n+        testCollections();\n+    }\n+\n+    public void testKeyIterator() {\n+        compareIterators(map.keySet().iterator(), reference.keySet().iterator());\n+    }\n+\n+    public void testEntryIterator() {\n+        compareIterators(map.entrySet().iterator(), reference.entrySet().iterator());\n+    }\n+\n+    public void testValueIterator() {\n+        compareIterators(map.values().iterator(), reference.values().iterator());\n+    }\n+\n+    private void compareIterators(Iterator it1, Iterator it2) {\n+        assertTrue(map.size() == 4);\n+        while (it1.hasNext()) {\n+            assertEquals(it1.next(), it2.next());\n+            it1.remove();\n+            it2.remove();\n+        }\n+        assertTrue(map.isEmpty());\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Bug467396Test.java\n+package org.mozilla.javascript.tests;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.Wrapper;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test for overloaded varargs/non-varargs methods.\n+ * See https://bugzilla.mozilla.org/show_bug.cgi?id=467396\n+ */\n+public class Bug467396Test extends TestCase {\n+\n+    public void testOverloadedVarargs() {\n+        Context cx = ContextFactory.getGlobal().enterContext();\n+        try {\n+            Scriptable scope = cx.initStandardObjects();\n+            Object result = unwrap(cx.evaluateString(scope,\n+                    \"java.lang.reflect.Array.newInstance(java.lang.Object, 1)\",\n+                    \"source\", 1, null));\n+            assertTrue(result instanceof Object[]);\n+            assertEquals(1, ((Object[]) result).length);\n+            result = unwrap(cx.evaluateString(scope,\n+                    \"java.lang.reflect.Array.newInstance(java.lang.Object, [1])\",\n+                    \"source\", 1, null));\n+            assertTrue(result instanceof Object[]);\n+            assertEquals(1, ((Object[]) result).length);\n+            result = unwrap(cx.evaluateString(scope,\n+                    \"java.lang.reflect.Array.newInstance(java.lang.Object, [1, 1])\",\n+                    \"source\", 1, null));\n+            assertTrue(result instanceof Object[][]);\n+            assertEquals(1, ((Object[][]) result).length);\n+            assertEquals(1, ((Object[][]) result)[0].length);\n+            result = unwrap(cx.evaluateString(scope,\n+                    \"java.lang.reflect.Array.newInstance(java.lang.Object, 1, 1)\",\n+                    \"source\", 1, null));\n+            assertTrue(result instanceof Object[][]);\n+            assertEquals(1, ((Object[][]) result).length);\n+            assertEquals(1, ((Object[][]) result)[0].length);\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+\n+    private Object unwrap(Object obj) {\n+        return obj instanceof Wrapper ? ((Wrapper) obj).unwrap() : obj;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Bug482203.java\n+package org.mozilla.javascript.tests;\n+\n+import java.io.InputStreamReader;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Callable;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.Script;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.ScriptableObject;\n+\n+public class Bug482203 extends TestCase {\n+    public void testJsApi() throws Exception {\n+        Context cx = Context.enter();\n+        cx.setOptimizationLevel(-1);\n+        Script script = cx.compileReader(new InputStreamReader(\n+                Bug482203.class.getResourceAsStream(\"conttest.js\")), \n+                \"\", 1, null);\n+        Scriptable scope = cx.initStandardObjects();\n+        script.exec(cx, scope);\n+        for(;;)\n+        {\n+            Object cont = ScriptableObject.getProperty(scope, \"c\");\n+            if(cont == null)\n+            {\n+                break;\n+            }\n+            ((Callable)cont).call(cx, scope, scope, new Object[] { null });\n+        }\n+    }\n+    public void testJavaApi() throws Exception {\n+        Context cx = Context.enter();\n+        try {\n+\t        cx.setOptimizationLevel(-1);\n+\t        Script script = cx.compileReader(new InputStreamReader(\n+\t                Bug482203.class.getResourceAsStream(\"conttest.js\")), \n+\t                \"\", 1, null);\n+\t        Scriptable scope = cx.initStandardObjects();\n+\t        cx.executeScriptWithContinuations(script, scope);\n+\t        for(;;)\n+\t        {\n+\t            Object cont = ScriptableObject.getProperty(scope, \"c\");\n+\t            if(cont == null)\n+\t            {\n+\t                break;\n+\t            }\n+\t            cx.resumeContinuation(cont, scope, null);\n+\t        }\n+        } finally {\n+        \tContext.exit();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Bug492525Test.java\n+package org.mozilla.javascript.tests;\n+\n+import org.junit.Test;\n+import static org.junit.Assert.assertArrayEquals;\n+import org.mozilla.javascript.NativeArray;\n+\n+public class Bug492525Test {\n+  @Test\n+  public void getAllIdsShouldIncludeArrayIndices() {\n+    NativeArray array = new NativeArray(new String[]{\"a\", \"b\"});\n+    Object[] expectedIds = new Object[] {0, 1, \"length\"};\n+    Object[] actualIds = array.getAllIds();\n+    assertArrayEquals(expectedIds, actualIds);\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Bug496585.java\n+package org.mozilla.javascript.tests;\n+\n+import org.mozilla.javascript.Function;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.Context;\n+import org.junit.Test;\n+\n+public class Bug496585 {\n+    public void method(String one, Function function) {\n+        System.out.println(\"string+function\");\n+    }\n+\n+    public void method(String... strings) {\n+        System.out.println(\"string[]\");\n+    }\n+\n+    @Test\n+    public void callOverloadedFunction() {\n+        new ContextFactory().call(new ContextAction() {\n+            public Object run(Context cx) {\n+                cx.evaluateString(\n+                    cx.initStandardObjects(),\n+                    \"new org.mozilla.javascript.tests.Bug496585().method('one', 'two', 'three')\",\n+                    \"<test>\", 1, null);\n+                cx.evaluateString(\n+                    cx.initStandardObjects(),\n+                    \"new org.mozilla.javascript.tests.Bug496585().method('one', function() {})\",\n+                    \"<test>\", 1, null);\n+                return null;\n+            }\n+        });\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/ClassShutterExceptionTest.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.ClassShutter;\n+import org.mozilla.javascript.RhinoException;\n+import org.mozilla.javascript.EvaluatorException;\n+\n+/**\n+ */\n+public class ClassShutterExceptionTest extends TestCase {\n+    private static Context.ClassShutterSetter classShutterSetter;\n+\n+    /**\n+     * Define a ClassShutter that prevents access to all Java classes.\n+     */\n+    static class OpaqueShutter implements ClassShutter {\n+        public boolean visibleToScripts(String name) {\n+            return false;\n+        }\n+    }\n+\n+    public void helper(String source) {\n+        Context cx = Context.enter();\n+        Context.ClassShutterSetter setter = cx.getClassShutterSetter();\n+        try {\n+            Scriptable globalScope = cx.initStandardObjects();\n+            if (setter == null) {\n+                setter = classShutterSetter;\n+            } else {\n+                classShutterSetter = setter;\n+            }\n+            setter.setClassShutter(new OpaqueShutter());\n+            cx.evaluateString(globalScope, source, \"test source\", 1, null);\n+        } finally {\n+            setter.setClassShutter(null);\n+            Context.exit();\n+        }\n+    }\n+\n+    public void testClassShutterException() {\n+        try {\n+            helper(\"java.lang.System.out.println('hi');\");\n+            fail();\n+        } catch (RhinoException e) {\n+            // OpaqueShutter should prevent access to java.lang...\n+            return;\n+        }\n+    }\n+\n+    public void testThrowingException() {\n+        // JavaScript exceptions with no reference to Java\n+        // should not be affected by the ClassShutter\n+        helper(\"try { throw 3; } catch (e) { }\");\n+    }\n+\n+    public void testThrowingEcmaError() {\n+        try {\n+            // JavaScript exceptions with no reference to Java\n+            // should not be affected by the ClassShutter\n+            helper(\"friggin' syntax error!\");\n+            fail(\"Should have thrown an exception\");\n+        } catch (EvaluatorException e) {\n+            // should have thrown an exception for syntax error\n+        }\n+    }\n+\n+    public void testThrowingEvaluatorException() {\n+            // JavaScript exceptions with no reference to Java\n+            // should not be affected by the ClassShutter\n+            helper(\"try { eval('for;if;else'); } catch (e) { }\");\n+    }\n+ }\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/ContextFactoryTest.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.RhinoException;\n+\n+/**\n+ */\n+public class ContextFactoryTest extends TestCase {\n+    static class MyFactory extends ContextFactory {\n+        @Override\n+        public boolean hasFeature(Context cx, int featureIndex)\n+        {\n+            switch (featureIndex) {\n+                case Context.FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME:\n+                    return true;\n+            }\n+            return super.hasFeature(cx, featureIndex);\n+        }\n+    }\n+\n+    public void testCustomContextFactory() {\n+        ContextFactory factory = new MyFactory();\n+        Context cx = factory.enterContext();\n+        try {\n+            Scriptable globalScope = cx.initStandardObjects();\n+            // Test that FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME is enabled\n+            /* TODO(stevey): fix this functionality in parser\n+            Object result = cx.evaluateString(globalScope,\n+                    \"var obj = {};\" +\n+                    \"function obj.foo() { return 'bar'; }\" +\n+                    \"obj.foo();\",\n+                    \"test source\", 1, null);\n+            assertEquals(\"bar\", result);\n+            */\n+        } catch (RhinoException e) {\n+            fail(e.toString());\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+ }\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/ContinuationsApiTest.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *    Norris Boyd\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tests;\n+\n+import java.io.*;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.Script;\n+import org.mozilla.javascript.Function;\n+import org.mozilla.javascript.ContinuationPending;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.WrappedException;\n+import org.mozilla.javascript.serialize.ScriptableInputStream;\n+import org.mozilla.javascript.serialize.ScriptableOutputStream;\n+\n+/**\n+ * Test of new API functions for running and resuming scripts containing\n+ * continuations, and for suspending a continuation from a Java method\n+ * called from JavaScript.\n+ *\n+ */\n+public class ContinuationsApiTest extends TestCase {\n+  Scriptable globalScope;\n+\n+  public static class MyClass implements Serializable {\n+\n+    private static final long serialVersionUID = 4189002778806232070L;\n+\n+    public int f(int a) {\n+        Context cx = Context.enter();\n+        try {\n+            ContinuationPending pending = cx.captureContinuation();\n+            pending.setApplicationState(a);\n+            throw pending;\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+    public int g(int a) {\n+        Context cx = Context.enter();\n+        try {\n+            ContinuationPending pending = cx.captureContinuation();\n+            pending.setApplicationState(2*a);\n+            throw pending;\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+  }\n+\n+  @Override\n+  public void setUp() {\n+      Context cx = Context.enter();\n+      try {\n+          globalScope = cx.initStandardObjects();\n+          cx.setOptimizationLevel(-1); // must use interpreter mode\n+          globalScope.put(\"myObject\", globalScope,\n+                  Context.javaToJS(new MyClass(), globalScope));\n+      } finally {\n+          Context.exit();\n+      }\n+  }\n+\n+  public void testScriptWithContinuations() {\n+      Context cx = Context.enter();\n+      try {\n+          cx.setOptimizationLevel(-1); // must use interpreter mode\n+          Script script = cx.compileString(\"myObject.f(3) + 1;\",\n+                  \"test source\", 1, null);\n+          cx.executeScriptWithContinuations(script, globalScope);\n+          fail(\"Should throw ContinuationPending\");\n+      } catch (ContinuationPending pending) {\n+\n+          Object applicationState = pending.getApplicationState();\n+          assertEquals(new Integer(3), applicationState);\n+          int saved = (Integer) applicationState;\n+          Object result = cx.resumeContinuation(pending.getContinuation(), globalScope, saved + 1);\n+          assertEquals(5, ((Number)result).intValue());\n+\n+      } finally {\n+          Context.exit();\n+      }\n+  }\n+\n+  public void testScriptWithMultipleContinuations() {\n+      Context cx = Context.enter();\n+      try {\n+          cx.setOptimizationLevel(-1); // must use interpreter mode\n+          Script script = cx.compileString(\n+              \"myObject.f(3) + myObject.g(3) + 2;\",\n+              \"test source\", 1, null);\n+          cx.executeScriptWithContinuations(script, globalScope);\n+          fail(\"Should throw ContinuationPending\");\n+      } catch (ContinuationPending pending) {\n+          try {\n+              Object applicationState = pending.getApplicationState();\n+              assertEquals(new Integer(3), applicationState);\n+              int saved = (Integer) applicationState;\n+              cx.resumeContinuation(pending.getContinuation(), globalScope, saved + 1);\n+              fail(\"Should throw another ContinuationPending\");\n+          } catch (ContinuationPending pending2) {\n+              Object applicationState2 = pending2.getApplicationState();\n+              assertEquals(new Integer(6), applicationState2);\n+              int saved2 = (Integer) applicationState2;\n+              Object result2 = cx.resumeContinuation(pending2.getContinuation(), globalScope, saved2 + 1);\n+              assertEquals(13, ((Number)result2).intValue());\n+          }\n+      } finally {\n+          Context.exit();\n+      }\n+  }\n+\n+  public void testScriptWithNestedContinuations() {\n+      Context cx = Context.enter();\n+      try {\n+          cx.setOptimizationLevel(-1); // must use interpreter mode\n+          Script script = cx.compileString(\"myObject.g( myObject.f(1) ) + 2;\",\n+                  \"test source\", 1, null);\n+          cx.executeScriptWithContinuations(script, globalScope);\n+          fail(\"Should throw ContinuationPending\");\n+      } catch (ContinuationPending pending) {\n+          try {\n+              Object applicationState = pending.getApplicationState();\n+              assertEquals(new Integer(1), applicationState);\n+              int saved = (Integer) applicationState;\n+              cx.resumeContinuation(pending.getContinuation(), globalScope, saved + 1);\n+              fail(\"Should throw another ContinuationPending\");\n+          } catch (ContinuationPending pending2) {\n+              Object applicationState2 = pending2.getApplicationState();\n+              assertEquals(new Integer(4), applicationState2);\n+              int saved2 = (Integer) applicationState2;\n+              Object result2 = cx.resumeContinuation(pending2.getContinuation(), globalScope, saved2 + 2);\n+              assertEquals(8, ((Number)result2).intValue());\n+          }\n+      } finally {\n+          Context.exit();\n+      }\n+  }\n+\n+\n+  public void testFunctionWithContinuations() {\n+      Context cx = Context.enter();\n+      try {\n+          cx.setOptimizationLevel(-1); // must use interpreter mode\n+          cx.evaluateString(globalScope,\n+                  \"function f(a) { return myObject.f(a); }\",\n+                  \"function test source\", 1, null);\n+          Function f = (Function) globalScope.get(\"f\", globalScope);\n+          Object[] args = { 7 };\n+          cx.callFunctionWithContinuations(f, globalScope, args);\n+          fail(\"Should throw ContinuationPending\");\n+      } catch (ContinuationPending pending) {\n+          Object applicationState = pending.getApplicationState();\n+          assertEquals(7, ((Number)applicationState).intValue());\n+          int saved = (Integer) applicationState;\n+          Object result = cx.resumeContinuation(pending.getContinuation(), globalScope, saved + 1);\n+          assertEquals(8, ((Number)result).intValue());\n+      } finally {\n+          Context.exit();\n+      }\n+  }\n+\n+  /**\n+   * Since a continuation can only capture JavaScript frames and not Java\n+   * frames, ensure that Rhino throws an exception when the JavaScript frames\n+   * don't reach all the way to the code called by\n+   * executeScriptWithContinuations or callFunctionWithContinuations.\n+   */\n+  public void testErrorOnEvalCall() {\n+      Context cx = Context.enter();\n+      try {\n+          cx.setOptimizationLevel(-1); // must use interpreter mode\n+          Script script = cx.compileString(\"eval('myObject.f(3);');\",\n+                  \"test source\", 1, null);\n+          cx.executeScriptWithContinuations(script, globalScope);\n+          fail(\"Should throw IllegalStateException\");\n+      } catch (WrappedException we) {\n+          Throwable t = we.getWrappedException();\n+          assertTrue(t instanceof IllegalStateException);\n+          assertTrue(t.getMessage().startsWith(\"Cannot capture continuation\"));\n+      } finally {\n+          Context.exit();\n+      }\n+  }\n+\n+  public void testSerializationWithContinuations()\n+      throws IOException, ClassNotFoundException\n+  {\n+      Context cx = Context.enter();\n+      try {\n+          cx.setOptimizationLevel(-1); // must use interpreter mode\n+          cx.evaluateString(globalScope,\n+                  \"function f(a) { var k = myObject.f(a); var t = []; return k; }\",\n+                  \"function test source\", 1, null);\n+          Function f = (Function) globalScope.get(\"f\", globalScope);\n+          Object[] args = { 7 };\n+          cx.callFunctionWithContinuations(f, globalScope, args);\n+          fail(\"Should throw ContinuationPending\");\n+      } catch (ContinuationPending pending) {\n+          // serialize\n+          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+          ScriptableOutputStream sos = new ScriptableOutputStream(baos, globalScope);\n+          sos.writeObject(globalScope);\n+          sos.writeObject(pending.getContinuation());\n+          sos.close();\n+          baos.close();\n+          byte[] serializedData = baos.toByteArray();\n+\n+          // deserialize\n+          ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);\n+          ScriptableInputStream sis = new ScriptableInputStream(bais, globalScope);\n+          globalScope = (Scriptable) sis.readObject();\n+          Object continuation = sis.readObject();\n+          sis.close();\n+          bais.close();\n+\n+          Object result = cx.resumeContinuation(continuation, globalScope, 8);\n+          assertEquals(8, ((Number)result).intValue());\n+      } finally {\n+          Context.exit();\n+      }\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/CustomSetterAcceptNullScriptableTest.java\n+package org.mozilla.javascript.tests;\n+\n+import java.lang.reflect.Method;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.ScriptableObject;\n+\n+/**\n+ * Takes care that it's possible to set <code>null</code> value\n+ * when using custom setter for a {@link Scriptable} object.\n+ * See https://bugzilla.mozilla.org/show_bug.cgi?id=461138\n+ */\n+public class CustomSetterAcceptNullScriptableTest extends TestCase\n+{\n+\tpublic static class Foo extends ScriptableObject {\n+        private static final long serialVersionUID = -8771045033217033529L;\n+\n+        @Override\n+\t\tpublic String getClassName()\n+\t\t{\n+\t\t\treturn \"Foo\";\n+\t\t}\n+\n+\t\tpublic void setMyProp(final Foo2 s) { }\n+\t}\n+\n+\tpublic static class Foo2 extends ScriptableObject {\n+        private static final long serialVersionUID = -8880603824656138628L;\n+\n+        @Override\n+\t\tpublic String getClassName()\n+\t\t{\n+\t\t\treturn \"Foo2\";\n+\t\t}\n+\t}\n+\n+\tpublic void testSetNullForScriptableSetter() throws Exception {\n+\n+\t\tfinal String scriptCode = \"foo.myProp = new Foo2();\\n\"\n+\t\t\t+ \"foo.myProp = null;\";\n+\n+\t\tfinal ContextFactory factory = new ContextFactory();\n+\t\tfinal Context cx = factory.enterContext();\n+\n+\t\ttry {\n+\t        final ScriptableObject topScope = cx.initStandardObjects();\n+\t        final Foo foo = new Foo();\n+\n+\t        // define custom setter method\n+\t        final Method setMyPropMethod = Foo.class.getMethod(\"setMyProp\", Foo2.class);\n+\t        foo.defineProperty(\"myProp\", null, null, setMyPropMethod, ScriptableObject.EMPTY);\n+\n+\t        topScope.put(\"foo\", topScope, foo);\n+\n+\t        ScriptableObject.defineClass(topScope, Foo2.class);\n+\n+\t        cx.evaluateString(topScope, scriptCode, \"myScript\", 1, null);\n+\t\t}\n+\t\tfinally {\n+\t\t\tContext.exit();\n+\t\t}\n+\t}\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/DefineClassTest.java\n+package org.mozilla.javascript.tests;\n+\n+import org.junit.Test;\n+import org.junit.Before;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.annotations.*;\n+\n+public class DefineClassTest {\n+\n+    Scriptable scope;\n+\n+    @Test\n+    public void testAnnotatedHostObject() {\n+        Context cx = Context.enter();\n+        try {\n+            Object result = evaluate(cx, \"a = new AnnotatedHostObject(); a.initialized;\");\n+            assertEquals(result, Boolean.TRUE);\n+            assertEquals(evaluate(cx, \"a.instanceFunction();\"), \"instanceFunction\");\n+            assertEquals(evaluate(cx, \"a.namedFunction();\"), \"namedFunction\");\n+            assertEquals(evaluate(cx, \"AnnotatedHostObject.staticFunction();\"), \"staticFunction\");\n+            assertEquals(evaluate(cx, \"AnnotatedHostObject.namedStaticFunction();\"), \"namedStaticFunction\");\n+            assertNull(evaluate(cx, \"a.foo;\"));\n+            assertEquals(evaluate(cx, \"a.foo = 'foo'; a.foo;\"), \"FOO\");\n+            assertEquals(evaluate(cx, \"a.bar;\"), \"bar\");\n+            try {\n+                evaluate(cx, \"a.bar = 'bar'; a.bar;\");\n+                fail(\"setting property with no setter should throw error\");\n+            } catch (EcmaError e) {\n+                // expected, as AnnotatedHostObject.bar only has a getter\n+            }\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+    @Test\n+    public void testTraditionalHostObject() {\n+        Context cx = Context.enter();\n+        try {\n+            Object result = evaluate(cx, \"t = new TraditionalHostObject(); t.initialized;\");\n+            assertEquals(result, Boolean.TRUE);\n+            assertEquals(evaluate(cx, \"t.instanceFunction();\"), \"instanceFunction\");\n+            assertEquals(evaluate(cx, \"TraditionalHostObject.staticFunction();\"), \"staticFunction\");\n+            assertNull(evaluate(cx, \"t.foo;\"));\n+            assertEquals(evaluate(cx, \"t.foo = 'foo'; t.foo;\"), \"FOO\");\n+            assertEquals(evaluate(cx, \"t.bar;\"), \"bar\");\n+            try {\n+                evaluate(cx, \"t.bar = 'bar'; t.bar;\");\n+                fail(\"setting property with no setter should throw error\");\n+            } catch (EcmaError e) {\n+                // expected, as TraditionalHostObject.bar only has a getter\n+            }\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+    private Object evaluate(Context cx, String str) {\n+        return cx.evaluateString(scope, str, \"<testsrc>\", 0, null);\n+    }\n+\n+\n+    @Before\n+    public void init() throws Exception {\n+        Context cx = Context.enter();\n+        try {\n+            scope = cx.initStandardObjects();\n+            ScriptableObject.defineClass(scope, AnnotatedHostObject.class);\n+            ScriptableObject.defineClass(scope, TraditionalHostObject.class);\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+    public static class AnnotatedHostObject extends ScriptableObject {\n+\n+        String foo, bar = \"bar\";\n+\n+        public AnnotatedHostObject() {}\n+\n+        public String getClassName() {\n+            return \"AnnotatedHostObject\";\n+        }\n+\n+        @JSConstructor\n+        public void jsConstructorMethod() {\n+            put(\"initialized\", this, Boolean.TRUE);\n+        }\n+\n+        @JSFunction\n+        public Object instanceFunction() {\n+            return \"instanceFunction\";\n+        }\n+\n+        @JSFunction(\"namedFunction\")\n+        public Object someFunctionName() {\n+            return \"namedFunction\";\n+        }\n+\n+        @JSStaticFunction\n+        public static Object staticFunction() {\n+            return \"staticFunction\";\n+        }\n+\n+        @JSStaticFunction(\"namedStaticFunction\")\n+        public static Object someStaticFunctionName() {\n+            return \"namedStaticFunction\";\n+        }\n+\n+        @JSGetter\n+        public String getFoo() {\n+            return foo;\n+        }\n+\n+        @JSSetter\n+        public void setFoo(String foo) {\n+            this.foo = foo.toUpperCase();\n+        }\n+\n+        @JSGetter(\"bar\")\n+        public String getMyBar() {\n+            return bar;\n+        }\n+\n+        public void setBar(String bar) {\n+            this.bar = bar.toUpperCase();\n+        }\n+    }\n+\n+    public static class TraditionalHostObject extends ScriptableObject {\n+\n+        String foo, bar = \"bar\";\n+\n+        public TraditionalHostObject() {}\n+\n+        public String getClassName() {\n+            return \"TraditionalHostObject\";\n+        }\n+\n+        public void jsConstructor() {\n+            put(\"initialized\", this, Boolean.TRUE);\n+        }\n+\n+        public Object jsFunction_instanceFunction() {\n+            return \"instanceFunction\";\n+        }\n+\n+        public static Object jsStaticFunction_staticFunction() {\n+            return \"staticFunction\";\n+        }\n+\n+        public String jsGet_foo() {\n+            return foo;\n+        }\n+\n+        public void jsSet_foo(String foo) {\n+            this.foo = foo.toUpperCase();\n+        }\n+\n+        public String jsGet_bar() {\n+            return bar;\n+        }\n+\n+        // not a JS setter\n+        public void setBar(String bar) {\n+            this.bar = bar.toUpperCase();\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/DefineFunctionPropertiesTest.java\n+package org.mozilla.javascript.tests;\n+\n+import org.mozilla.javascript.*;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Example of defining global functions.\n+ *\n+ */\n+public class DefineFunctionPropertiesTest extends TestCase {\n+    ScriptableObject global;\n+    static Object key = \"DefineFunctionPropertiesTest\";\n+\n+    /**\n+     * Demonstrates how to create global functions in JavaScript\n+     * from static methods defined in Java.\n+     */\n+    @Override\n+    public void setUp() {\n+        Context cx = Context.enter();\n+        try {\n+            global = cx.initStandardObjects();\n+            String[] names = { \"f\", \"g\" };\n+            global.defineFunctionProperties(names,\n+                    DefineFunctionPropertiesTest.class,\n+                    ScriptableObject.DONTENUM);\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+    /**\n+     * Simple global function that doubles its input.\n+     */\n+    public static int f(int a) {\n+        return a * 2;\n+    }\n+\n+    /**\n+     * Simple test: call 'f' defined above\n+     */\n+    public void testSimpleFunction() {\n+        Context cx = Context.enter();\n+        try {\n+            Object result = cx.evaluateString(global, \"f(7) + 1\",\n+                    \"test source\", 1, null);\n+            assertEquals(15.0, result);\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+    /**\n+     * More complicated example: this form of call allows variable\n+     * argument lists, and allows access to the 'this' object. For\n+     * a global function, the 'this' object is the global object.\n+     * In this case we look up a value that we associated with the global\n+     * object using {@link ScriptableObject#getAssociatedValue(Object)}.\n+     */\n+    public static Object g(Context cx, Scriptable thisObj, Object[] args,\n+            Function funObj)\n+    {\n+        Object arg = args.length > 0 ? args[0] : Undefined.instance;\n+        Object privateValue = Undefined.instance;\n+        if (thisObj instanceof ScriptableObject) {\n+            privateValue =\n+                ((ScriptableObject) thisObj).getAssociatedValue(key);\n+        }\n+        return arg.toString() + privateValue;\n+    }\n+\n+    /**\n+     * Associate a value with the global scope and call function 'g'\n+     * defined above.\n+     */\n+    public void testPrivateData() {\n+        Context cx = Context.enter();\n+        try {\n+            global.associateValue(key, \"bar\");\n+            Object result = cx.evaluateString(global, \"g('foo');\",\n+                    \"test source\", 1, null);\n+            assertEquals(\"foobar\", result);\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/DeletePropertyTest.java\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+\n+import org.junit.Test;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.ScriptableObject;\n+\n+/**\n+ * Test for delete that should apply for properties defined in prototype chain. \n+ * See https://bugzilla.mozilla.org/show_bug.cgi?id=510504\n+ */\n+public class DeletePropertyTest extends TestCase {\n+\t/**\n+\t * delete should not delete anything in the prototype chain.\n+\t */\n+\t@Test\n+\tpublic void testDeletePropInPrototype() throws Exception {\n+\t\tfinal String script = \"Array.prototype.foo = function() {};\\n\"\n+\t\t\t+ \"Array.prototype[1] = function() {};\\n\"\n+\t\t\t+ \"var t = [];\\n\"\n+\t\t\t+ \"[].foo();\\n\"\n+\t\t\t+ \"for (var i in t) delete t[i];\\n\"\n+\t\t\t+ \"[].foo();\\n\"\n+\t\t\t+ \"[][1]();\\n\";\n+\t\t\n+\t\tfinal ContextAction action = new ContextAction()\n+\t\t{\n+\t\t\tpublic Object run(final Context _cx)\n+\t\t\t{\n+\t\t\t\tfinal ScriptableObject scope = _cx.initStandardObjects();\n+\t\t\t\tfinal Object result = _cx.evaluateString(scope, script, \"test script\", 0, null);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t};\n+\n+\t\tUtils.runWithAllOptimizationLevels(action);\n+\t}\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/DoctestsTest.java\n+package org.mozilla.javascript.tests;\n+\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.*;\n+\n+import org.junit.*;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.drivers.TestUtils;\n+import org.mozilla.javascript.tools.shell.Global;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Run doctests in folder testsrc/doctests.\n+ *\n+ * A doctest is a test in the form of an interactive shell session; Rhino\n+ * collects and runs the inputs to the shell prompt and compares them to the\n+ * expected outputs.\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class DoctestsTest {\n+    static final String baseDirectory = \"testsrc\" + File.separator + \"doctests\";\n+    static final String doctestsExtension = \".doctest\";\n+    String name;\n+    String source;\n+    int optimizationLevel;\n+\n+    public DoctestsTest(String name, String source, int optimizationLevel) {\n+        this.name = name;\n+        this.source = source;\n+        this.optimizationLevel = optimizationLevel;\n+    }\n+\n+    public static File[] getDoctestFiles() {\n+        return TestUtils.recursiveListFiles(new File(baseDirectory),\n+                new FileFilter() {\n+                    public boolean accept(File f) {\n+                        return f.getName().endsWith(doctestsExtension);\n+                    }\n+            });\n+    }\n+\n+    public static String loadFile(File f) throws IOException {\n+        int length = (int) f.length(); // don't worry about very long files\n+        char[] buf = new char[length];\n+        new FileReader(f).read(buf, 0, length);\n+        return new String(buf);\n+    }\n+\n+    @Parameters\n+    public static Collection<Object[]> doctestValues() throws IOException {\n+        File[] doctests = getDoctestFiles();\n+        List<Object[]> result = new ArrayList<Object[]>();\n+        for (File f : doctests) {\n+            String contents = loadFile(f);\n+            result.add(new Object[] { f.getName(), contents, -1 });\n+            result.add(new Object[] { f.getName(), contents, 0 });\n+            result.add(new Object[] { f.getName(), contents, 9 });\n+        }\n+        return result;\n+    }\n+\n+    // move \"@Parameters\" to this method to test a single doctest\n+    public static Collection<Object[]> singleDoctest() throws IOException {\n+        List<Object[]> result = new ArrayList<Object[]>();\n+        File f = new File(baseDirectory, \"Counter.doctest\");\n+        String contents = loadFile(f);\n+        result.add(new Object[] { f.getName(), contents, -1 });\n+        return result;\n+    }\n+\n+    @Test\n+    public void runDoctest() throws Exception {\n+        ContextFactory factory = ContextFactory.getGlobal();\n+        Context cx = factory.enterContext();\n+        try {\n+            cx.setOptimizationLevel(optimizationLevel);\n+            Global global = new Global(cx);\n+            // global.runDoctest throws an exception on any failure\n+            int testsPassed = global.runDoctest(cx, global, source, name, 1);\n+            System.out.println(name + \"(\" + optimizationLevel + \"): \" +\n+                    testsPassed + \" passed.\");\n+            assertTrue(testsPassed > 0);\n+        } catch (Exception ex) {\n+          System.out.println(name + \"(\" + optimizationLevel + \"): FAILED due to \"+ex);\n+          throw ex;\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Evaluator.java\n+package org.mozilla.javascript.tests;\n+import org.mozilla.javascript.*;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+public class Evaluator {\n+\n+  public static Object eval(String source) {\n+    return eval(source, Collections.EMPTY_MAP);\n+  }\n+\n+  public static Object eval(String source, String id, Scriptable object) {\n+    return eval(source, Collections.singletonMap(id, object));\n+  }\n+\n+  public static Object eval(String source, Map<String, Scriptable> bindings) {\n+    Context cx = ContextFactory.getGlobal().enterContext();\n+    try {\n+      Scriptable scope = cx.initStandardObjects();\n+      for (String id : bindings.keySet()) {\n+        Scriptable object = bindings.get(id);\n+        object.setParentScope(scope);\n+        scope.put(id, scope, object);\n+      }\n+      return cx.evaluateString(scope, source, \"source\", 1, null);\n+    } finally {\n+      Context.exit();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/GeneratedClassNameTest.java\n+package org.mozilla.javascript.tests;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.Script;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Takes care that the class name of the generated class \"looks like\"\n+ * the provided script name.\n+ * See https://bugzilla.mozilla.org/show_bug.cgi?id=460283\n+ */\n+public class GeneratedClassNameTest extends TestCase\n+{\n+\tpublic void testGeneratedClassName() throws Exception {\n+\t\tdoTest(\"myScript_js\", \"myScript.js\");\n+\t\tdoTest(\"foo\", \"foo\");\n+\t\tdoTest(\"c\", \"\");\n+\t\tdoTest(\"_1\", \"1\");\n+\t\tdoTest(\"_\", \"_\");\n+\t\tdoTest(\"unnamed_script\", null);\n+\t\tdoTest(\"some_dir_some_foo_js\", \"some/dir/some/foo.js\");\n+\t\tdoTest(\"some_dir_some_foo_js\", \"some\\\\dir\\\\some\\\\foo.js\");\n+\t\tdoTest(\"_12_foo_34_js\", \"12 foo 34.js\");\n+\t}\n+\n+\tprivate void doTest(final String expectedName, final String scriptName)\n+\t    throws Exception\n+\t{\n+\t    final Script script = (Script) ContextFactory.getGlobal().call(\n+\t      new ContextAction() {\n+\t        public Object run(final Context context) {\n+\t          return context.compileString(\"var f = 1\", scriptName, 1, null);\n+\t        }\n+\t      });\n+\n+\t    // remove serial number\n+\t    String name = script.getClass().getSimpleName();\n+\t    assertEquals(expectedName, name.substring(0, name.lastIndexOf('_')));\n+\t}\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/GeneratedMethodNameTest.java\n+package org.mozilla.javascript.tests;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.Script;\n+import org.mozilla.javascript.Scriptable;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Takes care that the name of the method generated for a function \"looks like\" the original function name.\n+ * See https://bugzilla.mozilla.org/show_bug.cgi?id=460726\n+ */\n+public class GeneratedMethodNameTest extends TestCase\n+{\n+\tpublic void testStandardFunction() throws Exception {\n+\t\tfinal String scriptCode = \"function myFunc() {\\n\"\n+\t\t\t+ \" var m = javaNameGetter.readCurrentFunctionJavaName();\\n\"\n+\t\t\t+ \"  if (m != 'myFunc') throw 'got '  + m;\"\n+\t\t\t+ \"}\\n\"\n+\t\t\t+ \"myFunc();\";\n+\t\tdoTest(scriptCode);\n+\t}\n+\n+\tpublic void testFunctionDollar() throws Exception {\n+\t\tfinal String scriptCode = \"function $() {\\n\"\n+\t\t\t+ \" var m = javaNameGetter.readCurrentFunctionJavaName();\\n\"\n+\t\t\t+ \"  if (m != '$') throw 'got '  + m;\"\n+\t\t\t+ \"}\\n\"\n+\t\t\t+ \"$();\";\n+\t\tdoTest(scriptCode);\n+\t}\n+\n+\tpublic void testScriptName() throws Exception {\n+\t\tfinal String scriptCode =\n+\t\t  \"var m = javaNameGetter.readCurrentFunctionJavaName();\\n\"\n+\t\t\t+ \"if (m != 'script') throw 'got '  + m;\";\n+\t\tdoTest(scriptCode);\n+\t}\n+\n+\tpublic void testConstructor() throws Exception {\n+\t\tfinal String scriptCode = \"function myFunc() {\\n\"\n+\t\t\t+ \" var m = javaNameGetter.readCurrentFunctionJavaName();\\n\"\n+\t\t\t+ \"  if (m != 'myFunc') throw 'got '  + m;\"\n+\t\t\t+ \"}\\n\"\n+\t\t\t+ \"new myFunc();\";\n+\t\tdoTest(scriptCode);\n+\t}\n+\n+\tpublic void testAnonymousFunction() throws Exception {\n+\t\tfinal String scriptCode = \"var myFunc = function() {\\n\"\n+\t\t\t+ \" var m = javaNameGetter.readCurrentFunctionJavaName();\\n\"\n+\t\t\t+ \"  if (m != 'anonymous') throw 'got '  + m;\"\n+\t\t\t+ \"}\\n\"\n+\t\t\t+ \"myFunc();\";\n+\t\tdoTest(scriptCode);\n+\t}\n+\n+\tpublic class JavaNameGetter {\n+\t    public String readCurrentFunctionJavaName() {\n+            final Throwable t = new RuntimeException();\n+            // remove prefix and suffix of method name\n+            return t.getStackTrace()[8].getMethodName().\n+                replaceFirst(\"_[^_]*_(.*)_[^_]*\", \"$1\");\n+\t    }\n+\t}\n+\n+\tpublic void doTest(final String scriptCode) throws Exception {\n+\t\tfinal Context cx = ContextFactory.getGlobal().enterContext();\n+\t\ttry {\n+            Scriptable topScope = cx.initStandardObjects();\n+    \t\ttopScope.put(\"javaNameGetter\", topScope, new JavaNameGetter());\n+    \t\tScript script = cx.compileString(scriptCode, \"myScript\", 1, null);\n+    \t\tscript.exec(cx, topScope);\n+\t\t} finally {\n+\t\t    Context.exit();\n+\t\t}\n+\t}\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/GlobalParseXTest.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.Scriptable;\n+\n+/**\n+ * Tests for global functions parseFloat and parseInt.\n+ */\n+public class GlobalParseXTest extends TestCase {\n+\n+\t/**\n+\t * Test for bug #501972\n+\t * https://bugzilla.mozilla.org/show_bug.cgi?id=501972\n+\t * Leading whitespaces should be ignored with following white space chars\n+\t * (see ECMA spec 15.1.2.3)\n+\t * <TAB>, <SP>, <NBSP>, <FF>, <VT>, <CR>, <LF>, <LS>, <PS>, <USP>\n+\t */\n+    public void testParseFloatAndIntWhiteSpaces() {\n+    \ttestParseFloatWhiteSpaces(\"\\\\u00A0 \"); // <NBSP>\n+\n+    \ttestParseFloatWhiteSpaces(\"\\\\t \");\n+    \ttestParseFloatWhiteSpaces(\"\\\\u00A0 \"); // <NBSP>\n+    \ttestParseFloatWhiteSpaces(\"\\\\u000C \"); // <FF>\n+    \ttestParseFloatWhiteSpaces(\"\\\\u000B \"); // <VT>\n+    \ttestParseFloatWhiteSpaces(\"\\\\u000D \"); // <CR>\n+    \ttestParseFloatWhiteSpaces(\"\\\\u000A \"); // <LF>\n+    \ttestParseFloatWhiteSpaces(\"\\\\u2028 \"); // <LS>\n+    \ttestParseFloatWhiteSpaces(\"\\\\u2029 \"); // <PS>\n+    }\n+\n+    private void testParseFloatWhiteSpaces(final String prefix) {\n+        assertEvaluates(\"789\", \"String(parseInt('\" + prefix + \"789 '))\");\n+        assertEvaluates(\"7.89\", \"String(parseFloat('\" + prefix + \"7.89 '))\");\n+    }\n+\n+    private void assertEvaluates(final Object expected, final String source) {\n+        final ContextAction action = new ContextAction() {\n+            public Object run(Context cx) {\n+                final Scriptable scope = cx.initStandardObjects();\n+                final Object rep = cx.evaluateString(scope, source, \"test.js\",\n+                        0, null);\n+                assertEquals(expected, rep);\n+                return null;\n+            }\n+        };\n+        Utils.runWithAllOptimizationLevels(action);\n+    }\n+ }\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/JavaAcessibilityTest.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.NativeJavaObject;\n+import org.mozilla.javascript.Script;\n+import org.mozilla.javascript.drivers.TestUtils;\n+import org.mozilla.javascript.tools.shell.Global;\n+import org.mozilla.javascript.tools.shell.ShellContextFactory;\n+\n+/**\n+ */\n+public class JavaAcessibilityTest extends TestCase {\n+\n+  protected final Global global = new Global();\n+  String importClass = \"importClass(Packages.org.mozilla.javascript.tests.PrivateAccessClass)\\n\";\n+\n+  public JavaAcessibilityTest() {\n+    global.init(contextFactory);\n+  }\n+\n+  @Override\n+  protected void setUp() {\n+    TestUtils.setGlobalContextFactory(contextFactory);\n+  }\n+\n+  @Override\n+  protected void tearDown() {\n+    TestUtils.setGlobalContextFactory(null);\n+  }\n+\n+  private ContextFactory contextFactory = new ShellContextFactory() {\n+    @Override\n+    protected boolean hasFeature(Context cx, int featureIndex) {\n+      if (featureIndex == Context.FEATURE_ENHANCED_JAVA_ACCESS)\n+            return true;\n+      return super.hasFeature(cx, featureIndex);\n+    }\n+  };\n+\n+  public void testAccessingFields() {\n+    Object result = runScript(importClass + \"PrivateAccessClass.staticPackagePrivateInt\");\n+    assertEquals(new Integer(0), result);\n+\n+    result = runScript(importClass + \"PrivateAccessClass.staticPrivateInt\");\n+    assertEquals(new Integer(1), result);\n+\n+    result = runScript(importClass + \"PrivateAccessClass.staticProtectedInt\");\n+    assertEquals(new Integer(2), result);\n+\n+    result = runScript(importClass + \"new PrivateAccessClass().packagePrivateString\");\n+    assertEquals(\"package private\", ((NativeJavaObject) result).unwrap());\n+\n+    result = runScript(importClass + \"new PrivateAccessClass().privateString\");\n+    assertEquals(\"private\", ((NativeJavaObject) result).unwrap());\n+\n+    result = runScript(importClass + \"new PrivateAccessClass().protectedString\");\n+    assertEquals(\"protected\", ((NativeJavaObject) result).unwrap());\n+\n+    result = runScript(importClass + \"new PrivateAccessClass.PrivateNestedClass().packagePrivateInt\");\n+    assertEquals(new Integer(0), result);\n+\n+    result = runScript(importClass + \"new PrivateAccessClass.PrivateNestedClass().privateInt\");\n+    assertEquals(new Integer(1), result);\n+\n+    result = runScript(importClass + \"new PrivateAccessClass.PrivateNestedClass().protectedInt\");\n+    assertEquals(new Integer(2), result);\n+  }\n+\n+  public void testAccessingMethods() {\n+    Object result = runScript(importClass + \"PrivateAccessClass.staticPackagePrivateMethod()\");\n+    assertEquals(new Integer(0), result);\n+\n+    result = runScript(importClass + \"PrivateAccessClass.staticPrivateMethod()\");\n+    assertEquals(new Integer(1), result);\n+\n+    result = runScript(importClass + \"PrivateAccessClass.staticProtectedMethod()\");\n+    assertEquals(new Integer(2), result);\n+\n+    result = runScript(importClass + \"new PrivateAccessClass().packagePrivateMethod()\");\n+    assertEquals(new Integer(3), result);\n+\n+    result = runScript(importClass + \"new PrivateAccessClass().privateMethod()\");\n+    assertEquals(new Integer(4), result);\n+\n+    result = runScript(importClass + \"new PrivateAccessClass().protectedMethod()\");\n+    assertEquals(new Integer(5), result);\n+  }\n+\n+  public void testAccessingConstructors() {\n+    runScript(importClass + \"new PrivateAccessClass(\\\"foo\\\")\");\n+    runScript(importClass + \"new PrivateAccessClass(5)\");\n+    runScript(importClass + \"new PrivateAccessClass(5, \\\"foo\\\")\");\n+  }\n+\n+  public void testAccessingJavaBeanProperty() {\n+      Object result = runScript(importClass +\n+          \"var x = new PrivateAccessClass(); x.javaBeanProperty + ' ' + x.getterCalled;\");\n+      assertEquals(\"6 true\", result);\n+\n+      result = runScript(importClass +\n+      \"var x = new PrivateAccessClass(); x.javaBeanProperty = 4; x.javaBeanProperty + ' ' + x.setterCalled;\");\n+      assertEquals(\"4 true\", result);\n+  }\n+\n+  public void testOverloadFunctionRegression() {\n+      Object result = runScript(\n+        \"(new java.util.GregorianCalendar()).set(3,4);'success';\");\n+      assertEquals(\"success\", result);\n+  }\n+\n+\n+  private Object runScript(final String scriptSourceText) {\n+    return contextFactory.call(new ContextAction() {\n+      public Object run(Context context) {\n+        Script script = context.compileString(scriptSourceText, \"\", 1, null);\n+        return script.exec(context, global);\n+      }\n+    });\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/JsTestsTest.java\n+package org.mozilla.javascript.tests;\n+\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+\n+import org.mozilla.javascript.drivers.TestUtils;\n+import org.mozilla.javascript.drivers.JsTestsBase;\n+\n+public class JsTestsTest extends JsTestsBase {\n+    static final String baseDirectory = \"testsrc\" + File.separator + \"jstests\";\n+\n+    static final String jstestsExtension = \".jstest\";\n+\n+    public void runJsTests() throws IOException {\n+        File[] tests = TestUtils.recursiveListFiles(new File(baseDirectory),\n+                new FileFilter() {\n+                  public boolean accept(File f) {\n+                      return f.getName().endsWith(jstestsExtension);\n+                  }\n+                });\n+        runJsTests(tests);\n+    }\n+    \n+    public void testJsTestsInterpreted() throws IOException {\n+        setOptimizationLevel(-1);\n+        runJsTests();\n+    }\n+    \n+    public void testJsTestsCompiled() throws IOException {\n+        setOptimizationLevel(0);\n+        runJsTests();\n+    }\n+    \n+    public void testJsTestsOptimized() throws IOException {\n+        setOptimizationLevel(9);\n+        runJsTests();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/MozillaSuiteTest.java\n+package org.mozilla.javascript.tests;\n+\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import junit.framework.Assert;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.mozilla.javascript.drivers.ShellTest;\n+import org.mozilla.javascript.drivers.StandardTests;\n+import org.mozilla.javascript.drivers.TestUtils;\n+import org.mozilla.javascript.tools.shell.ShellContextFactory;\n+\n+/**\n+ * This JUnit suite runs the Mozilla test suite (in mozilla.org CVS\n+ * at /mozilla/js/tests).\n+ *\n+ * Not all tests in the suite are run. Since the mozilla.org tests are\n+ * designed and maintained for the SpiderMonkey engine, tests in the\n+ * suite may not pass due to feature set differences and known bugs.\n+ * To make sure that this unit test is stable in the midst of changes\n+ * to the mozilla.org suite, we maintain a list of passing tests in\n+ * files opt-1.tests, opt0.tests, and opt9.tests. This class also\n+ * implements the ability to run skipped tests, see if any pass, and\n+ * print out a script to modify the *.tests files.\n+ * (This approach doesn't handle breaking changes to existing passing\n+ * tests, but in practice that has been very rare.)\n+ */\n+@RunWith(Parameterized.class)\n+public class MozillaSuiteTest {\n+    private final File jsFile;\n+    private final int optimizationLevel;\n+\n+    static final int[] OPT_LEVELS = { -1, 0, 9 };\n+\n+    public MozillaSuiteTest(File jsFile, int optimizationLevel) {\n+        this.jsFile = jsFile;\n+        this.optimizationLevel = optimizationLevel;\n+    }\n+\n+    public static File getTestDir() throws IOException {\n+        File testDir = null;\n+        if (System.getProperty(\"mozilla.js.tests\") != null) {\n+            testDir = new File(System.getProperty(\"mozilla.js.tests\"));\n+        } else {\n+            URL url = StandardTests.class.getResource(\".\");\n+            String path = url.getFile();\n+            int jsIndex = path.lastIndexOf(\"/js\");\n+            if (jsIndex == -1) {\n+                throw new IllegalStateException(\"You aren't running the tests \"+\n+                    \"from within the standard mozilla/js directory structure\");\n+            }\n+            path = path.substring(0, jsIndex + 3).replace('/', File.separatorChar);\n+            path = path.replace(\"%20\", \" \");\n+            testDir = new File(path, \"tests\");\n+        }\n+        if (!testDir.isDirectory()) {\n+            throw new FileNotFoundException(testDir + \" is not a directory\");\n+        }\n+        return testDir;\n+    }\n+\n+    public static String getTestFilename(int optimizationLevel) {\n+        return \"opt\" + optimizationLevel + \".tests\";\n+    }\n+\n+    public static File[] getTestFiles(int optimizationLevel) throws IOException {\n+        File testDir = getTestDir();\n+        String[] tests = TestUtils.loadTestsFromResource(\n+            \"/\" + getTestFilename(optimizationLevel), null);\n+        Arrays.sort(tests);\n+        File[] files = new File[tests.length];\n+        for (int i=0; i < files.length; i++) {\n+            files[i] = new File(testDir, tests[i]);\n+        }\n+        return files;\n+    }\n+\n+    public static String loadFile(File f) throws IOException {\n+        int length = (int) f.length(); // don't worry about very long files\n+        char[] buf = new char[length];\n+        new FileReader(f).read(buf, 0, length);\n+        return new String(buf);\n+    }\n+\n+    @Parameters\n+    public static Collection<Object[]> mozillaSuiteValues() throws IOException {\n+        List<Object[]> result = new ArrayList<Object[]>();\n+        int[] optLevels = OPT_LEVELS;\n+        for (int i=0; i < optLevels.length; i++) {\n+            File[] tests = getTestFiles(optLevels[i]);\n+            for (File f : tests) {\n+                result.add(new Object[] { f, optLevels[i] });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    // move \"@Parameters\" to this method to test a single Mozilla test\n+    public static Collection<Object[]> singleDoctest() throws IOException {\n+        final String SINGLE_TEST_FILE = \"e4x/Expressions/11.1.1.js\";\n+        final int SINGLE_TEST_OPTIMIZATION_LEVEL = -1;\n+        List<Object[]> result = new ArrayList<Object[]>();\n+        File f = new File(getTestDir(), SINGLE_TEST_FILE);\n+        result.add(new Object[] { f, SINGLE_TEST_OPTIMIZATION_LEVEL });\n+        return result;\n+    }\n+\n+    private static class ShellTestParameters extends ShellTest.Parameters {\n+        @Override\n+        public int getTimeoutMilliseconds() {\n+            if (System.getProperty(\"mozilla.js.tests.timeout\") != null) {\n+                return Integer.parseInt(System.getProperty(\n+                    \"mozilla.js.tests.timeout\"));\n+            }\n+            return 10000;\n+        }\n+    }\n+\n+    private static class JunitStatus extends ShellTest.Status {\n+        @Override\n+        public final void running(File jsFile) {\n+            //    do nothing\n+        }\n+\n+        @Override\n+        public final void failed(String s) {\n+            System.out.println(\"Failed: \" + s);\n+            Assert.fail(s);\n+        }\n+\n+        @Override\n+        public final void exitCodesWere(int expected, int actual) {\n+            Assert.assertEquals(\"Unexpected exit code\", expected, actual);\n+        }\n+\n+        @Override\n+        public final void outputWas(String s) {\n+            // Do nothing; we don't want to see the output when running JUnit\n+            // tests.\n+        }\n+\n+        @Override\n+        public final void threw(Throwable t) {\n+            Assert.fail(ShellTest.getStackTrace(t));\n+        }\n+\n+        @Override\n+        public final void timedOut() {\n+            failed(\"Timed out.\");\n+        }\n+    }\n+\n+    @Test\n+    public void runMozillaTest() throws Exception {\n+        //System.out.println(\"Test \\\"\" + jsFile + \"\\\" running under optimization level \" + optimizationLevel);\n+        final ShellContextFactory shellContextFactory =\n+            new ShellContextFactory();\n+        shellContextFactory.setOptimizationLevel(optimizationLevel);\n+        ShellTestParameters params = new ShellTestParameters();\n+        JunitStatus status = new JunitStatus();\n+        ShellTest.run(shellContextFactory, jsFile, params, status);\n+    }\n+\n+\n+    /**\n+     * The main class will run all the test files that are *not* covered in\n+     * the *.tests files, and print out a list of all the tests that pass.\n+     */\n+    public static void main(String[] args) throws IOException {\n+        PrintStream out = new PrintStream(\"fix-tests-files.sh\");\n+        try {\n+            for (int i=0; i < OPT_LEVELS.length; i++) {\n+                int optLevel = OPT_LEVELS[i];\n+                File testDir = getTestDir();\n+                File[] allTests =\n+                    TestUtils.recursiveListFiles(testDir,\n+                        new FileFilter() {\n+                            public boolean accept(File pathname)\n+                            {\n+                                return ShellTest.DIRECTORY_FILTER.accept(pathname) ||\n+                                       ShellTest.TEST_FILTER.accept(pathname);\n+                            }\n+                    });\n+                HashSet<File> diff = new HashSet<File>(Arrays.asList(allTests));\n+                File testFiles[] = getTestFiles(optLevel);\n+                diff.removeAll(Arrays.asList(testFiles));\n+                ArrayList<String> skippedPassed = new ArrayList<String>();\n+                int absolutePathLength = testDir.getAbsolutePath().length() + 1;\n+                for (File testFile: diff) {\n+                    try {\n+                        (new MozillaSuiteTest(testFile, optLevel)).runMozillaTest();\n+                        // strip off testDir\n+                        String canonicalized =\n+                            testFile.getAbsolutePath().substring(absolutePathLength);\n+                        canonicalized = canonicalized.replace('\\\\', '/');\n+                        skippedPassed.add(canonicalized);\n+                    } catch (Throwable t) {\n+                        // failed, so skip\n+                    }\n+                }\n+                // \"skippedPassed\" now contains all the tests that are currently\n+                // skipped but now pass. Print out shell commands to update the\n+                // appropriate *.tests file.\n+                if (skippedPassed.size() > 0) {\n+                    out.println(\"cat >> \" + getTestFilename(optLevel) + \" <<EOF\");\n+                    String[] sorted = skippedPassed.toArray(new String[0]);\n+                    Arrays.sort(sorted);\n+                    for (int j=0; j < sorted.length; j++) {\n+                        out.println(sorted[j]);\n+                    }\n+                    out.println(\"EOF\");\n+                }\n+            }\n+            System.out.println(\"Done.\");\n+        } finally {\n+            out.close();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/NativeArrayTest.java\n+package org.mozilla.javascript.tests;\n+\n+import org.junit.Test;\n+import org.junit.Before;\n+\n+import static org.junit.Assert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+import org.mozilla.javascript.NativeArray;\n+\n+public class NativeArrayTest {\n+  private NativeArray array;\n+\n+  @Before\n+  public void init() {\n+    array = new NativeArray(1);\n+  }\n+\n+  @Test\n+  public void getIdsShouldIncludeBothIndexAndNormalProperties() {\n+    array.put(0, array, \"index\");\n+    array.put(\"a\", array, \"normal\");\n+\n+    assertThat(array.getIds(), is(new Object[]{0, \"a\"}));\n+  }\n+\n+  @Test\n+  public void deleteShouldRemoveIndexProperties() {\n+    array.put(0, array, \"a\");\n+    array.delete(0);\n+    assertThat(array.has(0, array), is(false));\n+  }\n+\n+  @Test\n+  public void deleteShouldRemoveNormalProperties() {\n+    array.put(\"p\", array, \"a\");\n+    array.delete(\"p\");\n+    assertThat(array.has(\"p\", array), is(false));\n+  }\n+\n+  @Test\n+  public void putShouldAddIndexProperties() {\n+    array.put(0, array, \"a\");\n+    assertThat(array.has(0, array), is(true));\n+  }\n+\n+  @Test\n+  public void putShouldAddNormalProperties() {\n+    array.put(\"p\", array, \"a\");\n+    assertThat(array.has(\"p\", array), is(true));\n+  }\n+\n+  @Test\n+  public void getShouldReturnIndexProperties() {\n+    array.put(0, array, \"a\");\n+    array.put(\"p\", array, \"b\");\n+    assertThat((String) array.get(0, array), is(\"a\"));\n+  }\n+\n+  @Test\n+  public void getShouldReturnNormalProperties() {\n+    array.put(\"p\", array, \"a\");\n+    assertThat((String) array.get(\"p\", array), is(\"a\"));\n+  }\n+\n+  @Test\n+  public void hasShouldBeFalseForANewArray() {\n+    assertThat(new NativeArray(0).has(0, array), is(false));\n+  }\n+\n+  @Test\n+  public void getIndexIdsShouldBeEmptyForEmptyArray() {\n+    assertThat(new NativeArray(0).getIndexIds(), is(new Integer[]{}));\n+  }\n+\n+  @Test\n+  public void getIndexIdsShouldBeAZeroForSimpleSingletonArray() {\n+    array.put(0, array, \"a\");\n+    assertThat(array.getIndexIds(), is(new Integer[]{ 0 }));\n+  }\n+\n+  @Test\n+  public void getIndexIdsShouldWorkWhenIndicesSetAsString() {\n+    array.put(\"0\", array, \"a\");\n+    assertThat(array.getIndexIds(), is(new Integer[]{ 0 }));\n+  }\n+\n+  @Test\n+  public void getIndexIdsShouldNotIncludeNegativeIds() {\n+    array.put(-1, array, \"a\");\n+    assertThat(array.getIndexIds(), is(new Integer[]{}));\n+  }\n+\n+  @Test\n+  public void getIndexIdsShouldIncludeIdsLessThan2ToThe32() {\n+    int maxIndex = (int) (1L << 31) - 1;\n+    array.put(maxIndex, array, \"a\");\n+    assertThat(array.getIndexIds(), is(new Integer[]{ maxIndex }));\n+  }\n+\n+  @Test\n+  public void getIndexIdsShouldNotIncludeIdsGreaterThanOrEqualTo2ToThe32() {\n+    array.put((1L<<31)+\"\", array, \"a\");\n+    assertThat(array.getIndexIds(), is(new Integer[]{}));\n+  }\n+\n+  @Test\n+  public void getIndexIdsShouldNotReturnNonNumericIds() {\n+    array.put(\"x\", array, \"a\");\n+    assertThat(array.getIndexIds(), is(new Integer[]{}));\n+  }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/NativeStringTest.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.Scriptable;\n+\n+/**\n+ */\n+public class NativeStringTest extends TestCase {\n+\n+\t/**\n+\t * Test for bug #492359\n+\t * https://bugzilla.mozilla.org/show_bug.cgi?id=492359\n+\t * Calling generic String or Array functions without arguments was causing ArrayIndexOutOfBoundsException\n+\t * in 1.7R2\n+\t */\n+    public void testtoLowerCaseApply() {\n+        assertEvaluates(\"hello\", \"var x = String.toLowerCase; x.apply('HELLO')\");\n+        assertEvaluates(\"hello\", \"String.toLowerCase('HELLO')\"); // first patch proposed to #492359 was breaking this\n+    }\n+\n+    private void assertEvaluates(final Object expected, final String source) {\n+        final ContextAction action = new ContextAction() {\n+            public Object run(Context cx) {\n+                final Scriptable scope = cx.initStandardObjects();\n+                final Object rep = cx.evaluateString(scope, source, \"test.js\",\n+                        0, null);\n+                assertEquals(expected, rep);\n+                return null;\n+            }\n+        };\n+        Utils.runWithAllOptimizationLevels(action);\n+    }\n+ }\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/ObserveInstructionCountTest.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.Callable;\n+import org.mozilla.javascript.drivers.TestUtils;\n+\n+/**\n+ */\n+public class ObserveInstructionCountTest extends TestCase {\n+    // Custom Context to store execution time.\n+    static class MyContext extends Context {\n+        MyContext(ContextFactory factory) {\n+            super(factory);\n+        }\n+        int quota;\n+    }\n+\n+    static class QuotaExceeded extends RuntimeException {\n+        private static final long serialVersionUID = -8018441873635071899L;\n+    }\n+\n+    @Override\n+    protected void setUp() {\n+        TestUtils.setGlobalContextFactory(new MyFactory());\n+    }\n+\n+    @Override\n+    protected void tearDown() {\n+        TestUtils.setGlobalContextFactory(null);\n+    }\n+\n+    static class MyFactory extends ContextFactory {\n+\n+        @Override\n+        protected Context makeContext()\n+        {\n+            MyContext cx = new MyContext(this);\n+            // Make Rhino runtime call observeInstructionCount\n+            // each 500 bytecode instructions (if we're really enforcing\n+            // a quota of 2000, we could set this closer to 2000)\n+            cx.setInstructionObserverThreshold(500);\n+            return cx;\n+        }\n+\n+        @Override\n+        protected void observeInstructionCount(Context cx, int instructionCount)\n+        {\n+            MyContext mcx = (MyContext)cx;\n+            mcx.quota -= instructionCount;\n+            if (mcx.quota <= 0) {\n+                throw new QuotaExceeded();\n+            }\n+        }\n+\n+        @Override\n+        protected Object doTopCall(Callable callable,\n+                                   Context cx, Scriptable scope,\n+                                   Scriptable thisObj, Object[] args)\n+        {\n+            MyContext mcx = (MyContext)cx;\n+            mcx.quota = 2000;\n+            return super.doTopCall(callable, cx, scope, thisObj, args);\n+        }\n+    }\n+\n+    private void baseCase(int optimizationLevel, String source) {\n+        ContextFactory factory = new MyFactory();\n+        Context cx = factory.enterContext();\n+        cx.setOptimizationLevel(optimizationLevel);\n+        assertTrue(cx instanceof MyContext);\n+        try {\n+            Scriptable globalScope = cx.initStandardObjects();\n+            cx.evaluateString(globalScope,\n+                    source,\n+                    \"test source\", 1, null);\n+            fail();\n+        } catch (QuotaExceeded e) {\n+            // expected\n+        } catch (RuntimeException e) {\n+            fail(e.toString());\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+\n+    public void testWhileTrueInGlobal() {\n+        String source = \"var i=0; while (true) i++;\";\n+        baseCase(-1, source); // interpreted mode\n+        baseCase(1, source); // compiled mode\n+    }\n+\n+    public void testWhileTrueNoCounterInGlobal() {\n+        String source = \"while (true);\";\n+        baseCase(-1, source); // interpreted mode\n+        baseCase(1, source); // compiled mode\n+    }\n+\n+    public void testWhileTrueInFunction() {\n+        String source = \"var i=0; function f() { while (true) i++; } f();\";\n+        baseCase(-1, source); // interpreted mode\n+        baseCase(1, source); // compiled mode\n+    }\n+\n+    public void testForever() {\n+        String source = \"for(;;);\";\n+        baseCase(-1, source); // interpreted mode\n+        baseCase(1, source); // compiled mode\n+    }\n+\n+ }\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/ParserTest.java\n+package org.mozilla.javascript.tests;\n+\n+import org.mozilla.javascript.ast.*;\n+\n+import org.mozilla.javascript.CompilerEnvirons;\n+import org.mozilla.javascript.EvaluatorException;\n+import org.mozilla.javascript.Parser;\n+import org.mozilla.javascript.Token;\n+import org.mozilla.javascript.testing.TestErrorReporter;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.List;\n+\n+public class ParserTest extends TestCase {\n+    boolean allowKeywordsAsObjectLiteralsKeys = false;\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+      super.setUp();\n+      allowKeywordsAsObjectLiteralsKeys = false;\n+    }\n+\n+    public void testAutoSemiColonBetweenNames() {\n+        AstRoot root = parse(\"\\nx\\ny\\nz\\n\");\n+        AstNode first = ((ExpressionStatement)\n+            root.getFirstChild()).getExpression();\n+        assertEquals(\"x\", first.getString());\n+        AstNode second = ((ExpressionStatement)\n+            root.getFirstChild().getNext()).getExpression();\n+        assertEquals(\"y\", second.getString());\n+        AstNode third = ((ExpressionStatement)\n+            root.getFirstChild().getNext().getNext()).getExpression();\n+        assertEquals(\"z\", third.getString());\n+    }\n+\n+    public void testAutoSemiBeforeComment1() {\n+       parse(\"var a = 1\\n/** a */ var b = 2\");\n+    }\n+\n+    public void testAutoSemiBeforeComment2() {\n+       parse(\"var a = 1\\n/** a */\\n var b = 2\");\n+    }\n+\n+    public void testAutoSemiBeforeComment3() {\n+       parse(\"var a = 1\\n/** a */\\n /** b */ var b = 2\");\n+    }\n+\n+    public void testLinenoAssign() {\n+        AstRoot root = parse(\"\\n\\na = b\");\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        AstNode n = st.getExpression();\n+\n+        assertTrue(n instanceof Assignment);\n+        assertEquals(Token.ASSIGN, n.getType());\n+        assertEquals(2, n.getLineno());\n+    }\n+\n+    public void testLinenoCall() {\n+        AstRoot root = parse(\"\\nfoo(123);\");\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        AstNode n = st.getExpression();\n+\n+        assertTrue(n instanceof FunctionCall);\n+        assertEquals(Token.CALL, n.getType());\n+        assertEquals(1, n.getLineno());\n+    }\n+\n+    public void testLinenoGetProp() {\n+        AstRoot root = parse(\"\\nfoo.bar\");\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        AstNode n = st.getExpression();\n+\n+        assertTrue(n instanceof PropertyGet);\n+        assertEquals(Token.GETPROP, n.getType());\n+        assertEquals(1, n.getLineno());\n+\n+        PropertyGet getprop = (PropertyGet) n;\n+        AstNode m = getprop.getRight();\n+\n+        assertTrue(m instanceof Name);\n+        assertEquals(Token.NAME, m.getType()); // used to be Token.STRING!\n+        assertEquals(1, m.getLineno());\n+    }\n+\n+    public void testLinenoGetElem() {\n+        AstRoot root = parse(\"\\nfoo[123]\");\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        AstNode n = st.getExpression();\n+\n+        assertTrue(n instanceof ElementGet);\n+        assertEquals(Token.GETELEM, n.getType());\n+        assertEquals(1, n.getLineno());\n+    }\n+\n+    public void testLinenoComment() {\n+        AstRoot root = parse(\"\\n/** a */\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(1, root.getComments().first().getLineno());\n+    }\n+\n+    public void testLinenoComment2() {\n+        AstRoot root = parse(\"\\n/**\\n\\n a */\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(1, root.getComments().first().getLineno());\n+    }\n+\n+    public void testLinenoComment3() {\n+        AstRoot root = parse(\"\\n  \\n\\n/**\\n\\n a */\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(3, root.getComments().first().getLineno());\n+    }\n+\n+    public void testLinenoComment4() {\n+        AstRoot root = parse(\"\\n  \\n\\n  /**\\n\\n a */\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(3, root.getComments().first().getLineno());\n+    }\n+\n+    public void testLineComment5() {\n+        AstRoot root = parse(\"  /**\\n* a.\\n* b.\\n* c.*/\\n\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(0, root.getComments().first().getLineno());\n+    }\n+\n+    public void testLineComment6() {\n+        AstRoot root = parse(\"  \\n/**\\n* a.\\n* b.\\n* c.*/\\n\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(1, root.getComments().first().getLineno());\n+    }\n+\n+    public void testLinenoComment7() {\n+        AstRoot root = parse(\"var x;\\n/**\\n\\n a */\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(1, root.getComments().first().getLineno());\n+    }\n+\n+    public void testLinenoComment8() {\n+        AstRoot root = parse(\"\\nvar x;/**\\n\\n a */\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(1, root.getComments().first().getLineno());\n+    }\n+\n+    public void testLinenoLiteral() {\n+        AstRoot root = parse(\n+            \"\\nvar d =\\n\" +\n+            \"    \\\"foo\\\";\\n\" +\n+            \"var e =\\n\" +\n+            \"    1;\\n\" +\n+            \"var f = \\n\" +\n+            \"    1.2;\\n\" +\n+            \"var g = \\n\" +\n+            \"    2e5;\\n\" +\n+            \"var h = \\n\" +\n+            \"    'bar';\\n\");\n+\n+        VariableDeclaration stmt1 = (VariableDeclaration) root.getFirstChild();\n+        List<VariableInitializer> vars1 = stmt1.getVariables();\n+        VariableInitializer firstVar = vars1.get(0);\n+        Name firstVarName = (Name) firstVar.getTarget();\n+        AstNode firstVarLiteral = firstVar.getInitializer();\n+\n+        VariableDeclaration stmt2 = (VariableDeclaration) stmt1.getNext();\n+        List<VariableInitializer> vars2 = stmt2.getVariables();\n+        VariableInitializer secondVar = vars2.get(0);\n+        Name secondVarName = (Name) secondVar.getTarget();\n+        AstNode secondVarLiteral = secondVar.getInitializer();\n+\n+        VariableDeclaration stmt3 = (VariableDeclaration) stmt2.getNext();\n+       List<VariableInitializer> vars3 = stmt3.getVariables();\n+        VariableInitializer thirdVar = vars3.get(0);\n+        Name thirdVarName = (Name) thirdVar.getTarget();\n+        AstNode thirdVarLiteral = thirdVar.getInitializer();\n+\n+        VariableDeclaration stmt4 = (VariableDeclaration) stmt3.getNext();\n+        List<VariableInitializer> vars4 = stmt4.getVariables();\n+        VariableInitializer fourthVar = vars4.get(0);\n+        Name fourthVarName = (Name) fourthVar.getTarget();\n+        AstNode fourthVarLiteral = fourthVar.getInitializer();\n+\n+        VariableDeclaration stmt5 = (VariableDeclaration) stmt4.getNext();\n+        List<VariableInitializer> vars5 = stmt5.getVariables();\n+        VariableInitializer fifthVar = vars5.get(0);\n+        Name fifthVarName = (Name) fifthVar.getTarget();\n+        AstNode fifthVarLiteral = fifthVar.getInitializer();\n+\n+        assertEquals(2, firstVarLiteral.getLineno());\n+        assertEquals(4, secondVarLiteral.getLineno());\n+        assertEquals(6, thirdVarLiteral.getLineno());\n+        assertEquals(8, fourthVarLiteral.getLineno());\n+        assertEquals(10, fifthVarLiteral.getLineno());\n+    }\n+\n+    public void testLinenoSwitch() {\n+        AstRoot root = parse(\n+            \"\\nswitch (a) {\\n\" +\n+            \"   case\\n\" +\n+            \"     1:\\n\" +\n+            \"     b++;\\n\" +\n+            \"   case 2:\\n\" +\n+            \"   default:\\n\" +\n+            \"     b--;\\n\" +\n+            \"  }\\n\");\n+\n+        SwitchStatement switchStmt = (SwitchStatement) root.getFirstChild();\n+        AstNode switchVar = switchStmt.getExpression();\n+        List<SwitchCase> cases = switchStmt.getCases();\n+        SwitchCase firstCase = cases.get(0);\n+        AstNode caseArg = firstCase.getExpression();\n+        List<AstNode> caseBody = firstCase.getStatements();\n+        ExpressionStatement exprStmt = (ExpressionStatement) caseBody.get(0);\n+        UnaryExpression incrExpr = (UnaryExpression) exprStmt.getExpression();\n+        AstNode incrVar = incrExpr.getOperand();\n+\n+        SwitchCase secondCase = cases.get(1);\n+        AstNode defaultCase = cases.get(2);\n+        AstNode returnStmt = (AstNode) switchStmt.getNext();\n+\n+        assertEquals(1, switchStmt.getLineno());\n+        assertEquals(1, switchVar.getLineno());\n+        assertEquals(2, firstCase.getLineno());\n+        assertEquals(3, caseArg.getLineno());\n+        assertEquals(4, exprStmt.getLineno());\n+        assertEquals(4, incrExpr.getLineno());\n+        assertEquals(4, incrVar.getLineno());\n+        assertEquals(5, secondCase.getLineno());\n+        assertEquals(6, defaultCase.getLineno());\n+    }\n+\n+\n+    public void testLinenoFunctionParams() {\n+        AstRoot root = parse(\n+            \"\\nfunction\\n\" +\n+            \"    foo(\\n\" +\n+            \"    a,\\n\" +\n+            \"    b,\\n\" +\n+            \"    c) {\\n\" +\n+            \"}\\n\");\n+        FunctionNode function = (FunctionNode) root.getFirstChild();\n+        Name functionName = function.getFunctionName();\n+\n+        AstNode body = function.getBody();\n+        List<AstNode> params = function.getParams();\n+        AstNode param1 = params.get(0);\n+        AstNode param2 = params.get(1);\n+        AstNode param3 = params.get(2);\n+\n+        assertEquals(1, function.getLineno());\n+        assertEquals(2, functionName.getLineno());\n+        assertEquals(3, param1.getLineno());\n+        assertEquals(4, param2.getLineno());\n+        assertEquals(5, param3.getLineno());\n+        assertEquals(5, body.getLineno());\n+    }\n+\n+    public void testLinenoVarDecl() {\n+      AstRoot root = parse(\n+          \"\\nvar\\n\" +\n+          \"    a =\\n\" +\n+          \"    3\\n\");\n+\n+      VariableDeclaration decl = (VariableDeclaration) root.getFirstChild();\n+      List<VariableInitializer> vars = decl.getVariables();\n+      VariableInitializer init = vars.get(0);\n+      AstNode declName = init.getTarget();\n+      AstNode expr = init.getInitializer();\n+\n+      assertEquals(1, decl.getLineno());\n+      assertEquals(2, init.getLineno());\n+      assertEquals(2, declName.getLineno());\n+      assertEquals(3, expr.getLineno());\n+    }\n+\n+    public void testLinenoReturn() {\n+      AstRoot root = parse(\n+          \"\\nfunction\\n\" +\n+          \"    foo(\\n\" +\n+          \"    a,\\n\" +\n+          \"    b,\\n\" +\n+          \"    c) {\\n\" +\n+          \"    return\\n\" +\n+          \"    4;\\n\" +\n+          \"}\\n\");\n+      FunctionNode function = (FunctionNode) root.getFirstChild();\n+      Name functionName = function.getFunctionName();\n+\n+      AstNode body = function.getBody();\n+      ReturnStatement returnStmt = (ReturnStatement) body.getFirstChild();\n+      ExpressionStatement exprStmt = (ExpressionStatement) returnStmt.getNext();\n+      AstNode returnVal = exprStmt.getExpression();\n+\n+      assertEquals(6, returnStmt.getLineno());\n+      assertEquals(7, exprStmt.getLineno());\n+      assertEquals(7, returnVal.getLineno());\n+    }\n+\n+    public void testLinenoFor() {\n+        AstRoot root = parse(\n+            \"\\nfor(\\n\" +\n+            \";\\n\" +\n+            \";\\n\" +\n+            \") {\\n\" +\n+            \"}\\n\");\n+\n+        ForLoop forLoop = (ForLoop) root.getFirstChild();\n+        AstNode initClause = forLoop.getInitializer();\n+        AstNode condClause = forLoop.getCondition();\n+        AstNode incrClause = forLoop.getIncrement();\n+\n+      assertEquals(1, forLoop.getLineno());\n+      assertEquals(2, initClause.getLineno());\n+      assertEquals(3, condClause.getLineno());\n+      assertEquals(4, incrClause.getLineno());\n+    }\n+\n+    public void testLinenoInfix() {\n+        AstRoot root = parse(\n+            \"\\nvar d = a\\n\" +\n+            \"    + \\n\" +\n+            \"    b;\\n\" +\n+            \"var\\n\" +\n+            \"    e =\\n\" +\n+            \"    a +\\n\" +\n+            \"    c;\\n\" +\n+            \"var f = b\\n\" +\n+            \"    / c;\\n\");\n+\n+        VariableDeclaration stmt1 = (VariableDeclaration) root.getFirstChild();\n+        List<VariableInitializer> vars1 = stmt1.getVariables();\n+        VariableInitializer var1 = vars1.get(0);\n+        Name firstVarName = (Name) var1.getTarget();\n+        InfixExpression var1Add = (InfixExpression) var1.getInitializer();\n+\n+        VariableDeclaration stmt2 = (VariableDeclaration) stmt1.getNext();\n+        List<VariableInitializer> vars2 = stmt2.getVariables();\n+        VariableInitializer var2 = vars2.get(0);\n+        Name secondVarName = (Name) var2.getTarget();\n+        InfixExpression var2Add = (InfixExpression) var2.getInitializer();\n+\n+        VariableDeclaration stmt3 = (VariableDeclaration) stmt2.getNext();\n+        List<VariableInitializer> vars3 = stmt3.getVariables();\n+        VariableInitializer var3 = vars3.get(0);\n+        Name thirdVarName = (Name) var3.getTarget();\n+        InfixExpression thirdVarDiv = (InfixExpression) var3.getInitializer();\n+\n+        ReturnStatement returnStmt = (ReturnStatement) stmt3.getNext();\n+\n+        assertEquals(1, var1.getLineno());\n+        assertEquals(1, firstVarName.getLineno());\n+        assertEquals(2, var1Add.getLineno());\n+        assertEquals(1, var1Add.getLeft().getLineno());\n+        assertEquals(3, var1Add.getRight().getLineno());\n+\n+        // var directive with name on next line wrong --\n+        // should be 6.\n+        assertEquals(5, var2.getLineno());\n+        assertEquals(5, secondVarName.getLineno());\n+        assertEquals(6, var2Add.getLineno());\n+        assertEquals(6, var2Add.getLeft().getLineno());\n+        assertEquals(7, var2Add.getRight().getLineno());\n+\n+        assertEquals(8, var3.getLineno());\n+        assertEquals(8, thirdVarName.getLineno());\n+        assertEquals(9, thirdVarDiv.getLineno());\n+        assertEquals(8, thirdVarDiv.getLeft().getLineno());\n+        assertEquals(9, thirdVarDiv.getRight().getLineno());\n+    }\n+\n+    public void testLinenoPrefix() {\n+        AstRoot root = parse(\n+            \"\\na++;\\n\" +\n+            \"   --\\n\" +\n+            \"   b;\\n\");\n+\n+        ExpressionStatement first = (ExpressionStatement) root.getFirstChild();\n+        ExpressionStatement secondStmt = (ExpressionStatement) first.getNext();\n+        UnaryExpression firstOp = (UnaryExpression) first.getExpression();\n+        UnaryExpression secondOp = (UnaryExpression) secondStmt.getExpression();\n+        AstNode firstVarRef = firstOp.getOperand();\n+        AstNode secondVarRef = secondOp.getOperand();\n+\n+        assertEquals(1, firstOp.getLineno());\n+        assertEquals(2, secondOp.getLineno());\n+        assertEquals(1, firstVarRef.getLineno());\n+        assertEquals(3, secondVarRef.getLineno());\n+      }\n+\n+    public void testLinenoIf() {\n+        AstRoot root = parse(\n+            \"\\nif\\n\" +\n+            \"   (a == 3)\\n\" +\n+            \"   {\\n\" +\n+            \"     b = 0;\\n\" +\n+            \"   }\\n\" +\n+            \"     else\\n\" +\n+            \"   {\\n\" +\n+            \"     c = 1;\\n\" +\n+            \"   }\\n\");\n+\n+        IfStatement ifStmt = (IfStatement) root.getFirstChild();\n+        AstNode condClause = ifStmt.getCondition();\n+        AstNode thenClause = ifStmt.getThenPart();\n+        AstNode elseClause = ifStmt.getElsePart();\n+\n+        assertEquals(1, ifStmt.getLineno());\n+        assertEquals(2, condClause.getLineno());\n+        assertEquals(3, thenClause.getLineno());\n+        assertEquals(7, elseClause.getLineno());\n+    }\n+\n+    public void testLinenoTry() {\n+        AstRoot root = parse(\n+            \"\\ntry {\\n\" +\n+            \"    var x = 1;\\n\" +\n+            \"} catch\\n\" +\n+            \"    (err)\\n\" +\n+            \"{\\n\" +\n+            \"} finally {\\n\" +\n+            \"    var y = 2;\\n\" +\n+            \"}\\n\");\n+\n+        TryStatement tryStmt = (TryStatement) root.getFirstChild();\n+        AstNode tryBlock = tryStmt.getTryBlock();\n+        List<CatchClause> catchBlocks = tryStmt.getCatchClauses();\n+        CatchClause catchClause= catchBlocks.get(0);\n+        Block catchVarBlock = catchClause.getBody();\n+        Name catchVar = catchClause.getVarName();\n+        AstNode finallyBlock = tryStmt.getFinallyBlock();\n+        AstNode finallyStmt = (AstNode) finallyBlock.getFirstChild();\n+\n+        assertEquals(1, tryStmt.getLineno());\n+        assertEquals(1, tryBlock.getLineno());\n+        assertEquals(5, catchVarBlock.getLineno());\n+        assertEquals(4, catchVar.getLineno());\n+        assertEquals(3, catchClause.getLineno());\n+        assertEquals(6, finallyBlock.getLineno());\n+        assertEquals(7, finallyStmt.getLineno());\n+      }\n+\n+    public void testLinenoConditional() {\n+         AstRoot root = parse(\n+            \"\\na\\n\" +\n+            \"    ?\\n\" +\n+            \"    b\\n\" +\n+            \"    :\\n\" +\n+            \"    c\\n\" +\n+            \"    ;\\n\");\n+\n+        ExpressionStatement ex = (ExpressionStatement) root.getFirstChild();\n+        ConditionalExpression hook = (ConditionalExpression) ex.getExpression();\n+        AstNode condExpr = hook.getTestExpression();\n+        AstNode thenExpr = hook.getTrueExpression();\n+        AstNode elseExpr = hook.getFalseExpression();\n+\n+        assertEquals(2, hook.getLineno());\n+        assertEquals(1, condExpr.getLineno());\n+        assertEquals(3, thenExpr.getLineno());\n+        assertEquals(5, elseExpr.getLineno());\n+    }\n+\n+    public void testLinenoLabel() {\n+        AstRoot root = parse(\n+            \"\\nfoo:\\n\" +\n+            \"a = 1;\\n\" +\n+            \"bar:\\n\" +\n+            \"b = 2;\\n\");\n+\n+        LabeledStatement firstStmt = (LabeledStatement) root.getFirstChild();\n+        LabeledStatement secondStmt = (LabeledStatement) firstStmt.getNext();\n+\n+        assertEquals(1, firstStmt.getLineno());\n+        assertEquals(3, secondStmt.getLineno());\n+    }\n+\n+    public void testLinenoCompare() {\n+        AstRoot root = parse(\n+            \"\\na\\n\" +\n+            \"<\\n\" +\n+            \"b\\n\");\n+\n+        ExpressionStatement expr = (ExpressionStatement) root.getFirstChild();\n+        InfixExpression compare = (InfixExpression) expr.getExpression();\n+        AstNode lhs = compare.getLeft();\n+        AstNode rhs = compare.getRight();\n+\n+        assertEquals(1, lhs.getLineno());\n+        assertEquals(2, compare.getLineno());\n+        assertEquals(3, rhs.getLineno());\n+    }\n+\n+    public void testLinenoEq() {\n+        AstRoot root = parse(\n+            \"\\na\\n\" +\n+            \"==\\n\" +\n+            \"b\\n\");\n+        ExpressionStatement expr = (ExpressionStatement) root.getFirstChild();\n+        InfixExpression compare = (InfixExpression) expr.getExpression();\n+        AstNode lhs = compare.getLeft();\n+        AstNode rhs = compare.getRight();\n+\n+        assertEquals(1, lhs.getLineno());\n+        assertEquals(2, compare.getLineno());\n+        assertEquals(3, rhs.getLineno());\n+    }\n+\n+    public void testLinenoPlusEq() {\n+        AstRoot root = parse(\n+            \"\\na\\n\" +\n+            \"+=\\n\" +\n+            \"b\\n\");\n+        ExpressionStatement expr = (ExpressionStatement) root.getFirstChild();\n+        Assignment assign = (Assignment) expr.getExpression();\n+        AstNode lhs = assign.getLeft();\n+        AstNode rhs = assign.getRight();\n+\n+        assertEquals(1, lhs.getLineno());\n+        assertEquals(2, assign.getLineno());\n+        assertEquals(3, rhs.getLineno());\n+    }\n+\n+    public void testLinenoComma() {\n+        AstRoot root = parse(\n+            \"\\na,\\n\" +\n+            \"    b,\\n\" +\n+            \"    c;\\n\");\n+\n+        ExpressionStatement stmt = (ExpressionStatement) root.getFirstChild();\n+        InfixExpression comma1 = (InfixExpression) stmt.getExpression();\n+        InfixExpression comma2 = (InfixExpression) comma1.getLeft();\n+        AstNode cRef = comma1.getRight();\n+        AstNode aRef = comma2.getLeft();\n+        AstNode bRef = comma2.getRight();\n+\n+        assertEquals(2, comma1.getLineno());\n+        assertEquals(1, comma2.getLineno());\n+        assertEquals(1, aRef.getLineno());\n+        assertEquals(2, bRef.getLineno());\n+        assertEquals(3, cRef.getLineno());\n+    }\n+\n+    public void testRegexpLocation() {\n+      AstNode root = parse(\n+          \"\\nvar path =\\n\" +\n+          \"      replace(\\n\" +\n+          \"/a/g,\" +\n+          \"'/');\\n\");\n+\n+      VariableDeclaration firstVarDecl =\n+          (VariableDeclaration) root.getFirstChild();\n+      List<VariableInitializer> vars1 = firstVarDecl.getVariables();\n+      VariableInitializer firstInitializer = vars1.get(0);\n+      Name firstVarName = (Name) firstInitializer.getTarget();\n+      FunctionCall callNode =(FunctionCall) firstInitializer.getInitializer();\n+      AstNode fnName = callNode.getTarget();\n+      List<AstNode> args = callNode.getArguments();\n+      RegExpLiteral regexObject = (RegExpLiteral) args.get(0);\n+      AstNode aString = args.get(1);\n+\n+      assertEquals(1, firstVarDecl.getLineno());\n+      assertEquals(1, firstVarName.getLineno());\n+      assertEquals(2, callNode.getLineno());\n+      assertEquals(2, fnName.getLineno());\n+      assertEquals(3, regexObject.getLineno());\n+      assertEquals(3, aString.getLineno());\n+    }\n+\n+    public void testNestedOr() {\n+      AstNode root = parse(\n+          \"\\nif (a && \\n\" +\n+          \"    b() || \\n\" +\n+          \"    /* comment */\\n\" +\n+          \"    c) {\\n\" +\n+          \"}\\n\"\n+                           );\n+\n+      IfStatement ifStmt = (IfStatement) root.getFirstChild();\n+      InfixExpression orClause = (InfixExpression) ifStmt.getCondition();\n+      InfixExpression andClause = (InfixExpression) orClause.getLeft();\n+      AstNode cName = orClause.getRight();\n+\n+      assertEquals(1, ifStmt.getLineno());\n+      assertEquals(2, orClause.getLineno());\n+      assertEquals(1, andClause.getLineno());\n+      assertEquals(4, cName.getLineno());\n+\n+    }\n+\n+    public void testObjectLitLocation() {\n+      AstNode root = parse(\n+          \"\\nvar foo =\\n\" +\n+          \"{ \\n\" +\n+          \"'A' : 'A', \\n\" +\n+          \"'B' : 'B', \\n\" +\n+          \"'C' : \\n\" +\n+          \"      'C' \\n\" +\n+          \"};\\n\");\n+\n+      VariableDeclaration firstVarDecl =\n+          (VariableDeclaration) root.getFirstChild();\n+      List<VariableInitializer> vars1 = firstVarDecl.getVariables();\n+      VariableInitializer firstInitializer = vars1.get(0);\n+      Name firstVarName = (Name) firstInitializer.getTarget();\n+\n+      ObjectLiteral objectLiteral =\n+          (ObjectLiteral) firstInitializer.getInitializer();\n+      List<ObjectProperty> props = objectLiteral.getElements();\n+      ObjectProperty firstObjectLit = props.get(0);\n+      ObjectProperty secondObjectLit = props.get(1);\n+      ObjectProperty thirdObjectLit = props.get(2);\n+\n+      AstNode firstKey = firstObjectLit.getLeft();\n+      AstNode firstValue = firstObjectLit.getRight();\n+      AstNode secondKey = secondObjectLit.getLeft();\n+      AstNode secondValue = secondObjectLit.getRight();\n+      AstNode thirdKey = thirdObjectLit.getLeft();\n+      AstNode thirdValue = thirdObjectLit.getRight();\n+\n+      assertEquals(1, firstVarName.getLineno());\n+      assertEquals(2, firstObjectLit.getLineno());\n+      assertEquals(3, firstKey.getLineno());\n+      assertEquals(3, firstValue.getLineno());\n+\n+      assertEquals(4, secondKey.getLineno());\n+      assertEquals(4, secondValue.getLineno());\n+\n+      assertEquals(5, thirdKey.getLineno());\n+      assertEquals(6, thirdValue.getLineno());\n+    }\n+\n+    public void testTryWithoutCatchLocation() {\n+      AstNode root = parse(\n+          \"\\ntry {\\n\" +\n+          \"  var x = 1;\\n\" +\n+          \"} finally {\\n\" +\n+          \"  var y = 2;\\n\" +\n+          \"}\\n\");\n+\n+      TryStatement tryStmt = (TryStatement) root.getFirstChild();\n+      AstNode tryBlock = tryStmt.getTryBlock();\n+      List<CatchClause> catchBlocks = tryStmt.getCatchClauses();\n+      Scope finallyBlock = (Scope) tryStmt.getFinallyBlock();\n+      AstNode finallyStmt = (AstNode) finallyBlock.getFirstChild();\n+\n+      assertEquals(1, tryStmt.getLineno());\n+      assertEquals(1, tryBlock.getLineno());\n+      assertEquals(3, finallyBlock.getLineno());\n+      assertEquals(4, finallyStmt.getLineno());\n+    }\n+\n+    public void testTryWithoutFinallyLocation() {\n+      AstNode root = parse(\n+          \"\\ntry {\\n\" +\n+          \"  var x = 1;\\n\" +\n+          \"} catch (ex) {\\n\" +\n+          \"  var y = 2;\\n\" +\n+          \"}\\n\");\n+\n+      TryStatement tryStmt = (TryStatement) root.getFirstChild();\n+      Scope tryBlock = (Scope) tryStmt.getTryBlock();\n+      List<CatchClause> catchBlocks = tryStmt.getCatchClauses();\n+      CatchClause catchClause = catchBlocks.get(0);\n+      AstNode catchStmt = catchClause.getBody();\n+      AstNode exceptionVar = catchClause.getVarName();\n+      AstNode varDecl = (AstNode) catchStmt.getFirstChild();\n+\n+      assertEquals(1, tryStmt.getLineno());\n+      assertEquals(1, tryBlock.getLineno());\n+      assertEquals(3, catchClause.getLineno());\n+      assertEquals(3, catchStmt.getLineno());\n+      assertEquals(3, exceptionVar.getLineno());\n+      assertEquals(4, varDecl.getLineno());\n+    }\n+\n+    public void testLinenoMultilineEq() {\n+      AstRoot root = parse(\n+          \"\\nif\\n\" +\n+          \"    (((a == \\n\" +\n+          \"  3) && \\n\" +\n+          \"  (b == 2)) || \\n\" +\n+          \" (c == 1)) {\\n\" +\n+          \"}\\n\");\n+      IfStatement ifStmt = (IfStatement) root.getFirstChild();\n+      InfixExpression orTest = (InfixExpression) ifStmt.getCondition();\n+      ParenthesizedExpression cTestParen =\n+          (ParenthesizedExpression) orTest.getRight();\n+      InfixExpression cTest = (InfixExpression) cTestParen.getExpression();\n+      ParenthesizedExpression andTestParen =\n+          (ParenthesizedExpression) orTest.getLeft();\n+      InfixExpression andTest = (InfixExpression) andTestParen.getExpression();\n+      AstNode aTest = andTest.getLeft();\n+      AstNode bTest = andTest.getRight();\n+\n+      assertEquals(1, ifStmt.getLineno());\n+      assertEquals(4, orTest.getLineno());\n+      assertEquals(3, andTest.getLineno());\n+      assertEquals(2, aTest.getLineno());\n+      assertEquals(4, bTest.getLineno());\n+      assertEquals(5, cTest.getLineno());\n+      assertEquals(5, cTestParen.getLineno());\n+      assertEquals(2, andTestParen.getLineno());\n+    }\n+\n+    public void testLinenoMultilineBitTest() {\n+      AstRoot root = parse(\n+          \"\\nif (\\n\" +\n+          \"      ((a \\n\" +\n+          \"        | 3 \\n\" +\n+          \"       ) == \\n\" +\n+          \"       (b \\n\" +\n+          \"        & 2)) && \\n\" +\n+          \"      ((a \\n\" +\n+          \"         ^ 0xffff) \\n\" +\n+          \"       != \\n\" +\n+          \"       (c \\n\" +\n+          \"        << 1))) {\\n\" +\n+          \"}\\n\");\n+\n+      IfStatement ifStmt = (IfStatement) root.getFirstChild();\n+      InfixExpression andTest = (InfixExpression) ifStmt.getCondition();\n+      ParenthesizedExpression bigLHSExpr =\n+          (ParenthesizedExpression) andTest.getLeft();\n+      ParenthesizedExpression bigRHSExpr =\n+          (ParenthesizedExpression) andTest.getRight();\n+\n+      InfixExpression eqTest = (InfixExpression) bigLHSExpr.getExpression();\n+      InfixExpression notEqTest = (InfixExpression) bigRHSExpr.getExpression();\n+\n+      ParenthesizedExpression test1Expr =\n+          (ParenthesizedExpression) eqTest.getLeft();\n+      ParenthesizedExpression test2Expr =\n+          (ParenthesizedExpression) eqTest.getRight();\n+\n+      ParenthesizedExpression test3Expr =\n+          (ParenthesizedExpression) notEqTest.getLeft();\n+      ParenthesizedExpression test4Expr =\n+          (ParenthesizedExpression) notEqTest.getRight();\n+\n+      InfixExpression bitOrTest = (InfixExpression) test1Expr.getExpression();\n+      InfixExpression bitAndTest = (InfixExpression) test2Expr.getExpression();\n+      InfixExpression bitXorTest = (InfixExpression) test3Expr.getExpression();\n+      InfixExpression bitShiftTest = (InfixExpression) test4Expr.getExpression();\n+\n+      assertEquals(1, ifStmt.getLineno());\n+\n+      assertEquals(2, bigLHSExpr.getLineno());\n+      assertEquals(7, bigRHSExpr.getLineno());\n+      assertEquals(4, eqTest.getLineno());\n+      assertEquals(9, notEqTest.getLineno());\n+\n+      assertEquals(2, test1Expr.getLineno());\n+      assertEquals(5, test2Expr.getLineno());\n+      assertEquals(7, test3Expr.getLineno());\n+      assertEquals(10, test4Expr.getLineno());\n+\n+      assertEquals(3, bitOrTest.getLineno());\n+      assertEquals(6, bitAndTest.getLineno());\n+      assertEquals(8, bitXorTest.getLineno());\n+      assertEquals(11, bitShiftTest.getLineno());\n+    }\n+\n+    public void testLinenoFunctionCall() {\n+      AstNode root = parse(\n+          \"\\nfoo.\\n\" +\n+          \"bar.\\n\" +\n+          \"baz(1);\");\n+\n+      ExpressionStatement stmt = (ExpressionStatement) root.getFirstChild();\n+      FunctionCall fc = (FunctionCall) stmt.getExpression();\n+      // Line number should get closest to the actual paren.\n+      assertEquals(3, fc.getLineno());\n+    }\n+\n+    public void testLinenoName() {\n+      AstNode root = parse(\n+          \"\\na;\\n\" +\n+          \"b.\\n\" +\n+          \"c;\\n\");\n+\n+      ExpressionStatement exprStmt = (ExpressionStatement) root.getFirstChild();\n+      AstNode aRef = exprStmt.getExpression();\n+      ExpressionStatement bExprStmt = (ExpressionStatement) exprStmt.getNext();\n+      AstNode bRef = bExprStmt.getExpression();\n+\n+      assertEquals(1, aRef.getLineno());\n+      assertEquals(2, bRef.getLineno());\n+    }\n+\n+    public void testLinenoDeclaration() {\n+      AstNode root = parse(\n+          \"\\na.\\n\" +\n+          \"b=\\n\" +\n+          \"function() {};\\n\");\n+\n+      ExpressionStatement exprStmt = (ExpressionStatement) root.getFirstChild();\n+      Assignment fnAssignment = (Assignment) exprStmt.getExpression();\n+      PropertyGet aDotbName = (PropertyGet) fnAssignment.getLeft();\n+      AstNode aName = aDotbName.getLeft();\n+      AstNode bName = aDotbName.getRight();\n+      FunctionNode fnNode = (FunctionNode) fnAssignment.getRight();\n+\n+      assertEquals(2, fnAssignment.getLineno());\n+      assertEquals(1, aDotbName.getLineno());\n+      assertEquals(1, aName.getLineno());\n+      assertEquals(2, bName.getLineno());\n+      assertEquals(3, fnNode.getLineno());\n+    }\n+\n+    public void testInOperatorInForLoop1() {\n+        parse(\"var a={};function b_(p){ return p;};\" +\n+              \"for(var i=b_(\\\"length\\\" in a);i<0;) {}\");\n+    }\n+\n+    public void testInOperatorInForLoop2() {\n+        parse(\"var a={}; for (;(\\\"length\\\" in a);) {}\");\n+    }\n+\n+    public void testInOperatorInForLoop3() {\n+        parse(\"for (x in y) {}\");\n+    }\n+\n+    public void testJSDocAttachment1() {\n+        AstRoot root = parse(\"/** @type number */var a;\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(\"/** @type number */\",\n+                     root.getComments().first().getValue());\n+        assertNotNull(root.getFirstChild().getJsDoc());\n+    }\n+\n+    public void testJSDocAttachment2() {\n+        AstRoot root = parse(\"/** @type number */a.b;\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(\"/** @type number */\",\n+                     root.getComments().first().getValue());\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        assertNotNull(st.getExpression().getJsDoc());\n+    }\n+\n+    public void testJSDocAttachment3() {\n+        AstRoot root = parse(\"var a = /** @type number */(x);\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(\"/** @type number */\",\n+                     root.getComments().first().getValue());\n+        VariableDeclaration vd = (VariableDeclaration) root.getFirstChild();\n+        VariableInitializer vi = vd.getVariables().get(0);\n+        assertNotNull(vi.getInitializer().getJsDoc());\n+    }\n+\n+    public void testJSDocAttachment4() {\n+        AstRoot root = parse(\"(function() {/** should not be attached */})()\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        FunctionCall fc = (FunctionCall) st.getExpression();\n+        ParenthesizedExpression pe = (ParenthesizedExpression) fc.getTarget();\n+        assertNull(pe.getJsDoc());\n+    }\n+\n+    public void testJSDocAttachment5() {\n+        AstRoot root = parse(\"({/** attach me */ 1: 2});\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        ParenthesizedExpression pt = (ParenthesizedExpression) st.getExpression();\n+        ObjectLiteral lit = (ObjectLiteral) pt.getExpression();\n+        NumberLiteral number =\n+            (NumberLiteral) lit.getElements().get(0).getLeft();\n+        assertNotNull(number.getJsDoc());\n+    }\n+\n+    public void testJSDocAttachment6() {\n+        AstRoot root = parse(\"({1: /** don't attach me */ 2, 3: 4});\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        ParenthesizedExpression pt = (ParenthesizedExpression) st.getExpression();\n+        ObjectLiteral lit = (ObjectLiteral) pt.getExpression();\n+        for (ObjectProperty el : lit.getElements()) {\n+          assertNull(el.getLeft().getJsDoc());\n+          assertNull(el.getRight().getJsDoc());\n+        }\n+    }\n+\n+    public void testJSDocAttachment7() {\n+        AstRoot root = parse(\"({/** attach me */ '1': 2});\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        ParenthesizedExpression pt = (ParenthesizedExpression) st.getExpression();\n+        ObjectLiteral lit = (ObjectLiteral) pt.getExpression();\n+        StringLiteral stringLit =\n+            (StringLiteral) lit.getElements().get(0).getLeft();\n+        assertNotNull(stringLit.getJsDoc());\n+    }\n+\n+    public void testJSDocAttachment8() {\n+        AstRoot root = parse(\"({'1': /** attach me */ (foo())});\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        ParenthesizedExpression pt = (ParenthesizedExpression) st.getExpression();\n+        ObjectLiteral lit = (ObjectLiteral) pt.getExpression();\n+        ParenthesizedExpression parens =\n+            (ParenthesizedExpression) lit.getElements().get(0).getRight();\n+        assertNotNull(parens.getJsDoc());\n+    }\n+\n+    public void testJSDocAttachment9() {\n+        AstRoot root = parse(\"({/** attach me */ foo: 2});\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        ParenthesizedExpression pt = (ParenthesizedExpression) st.getExpression();\n+        ObjectLiteral lit = (ObjectLiteral) pt.getExpression();\n+        Name objLitKey =\n+            (Name) lit.getElements().get(0).getLeft();\n+        assertNotNull(objLitKey.getJsDoc());\n+    }\n+\n+    public void testJSDocAttachment10() {\n+        AstRoot root = parse(\"({foo: /** attach me */ (bar)});\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        ParenthesizedExpression pt = (ParenthesizedExpression) st.getExpression();\n+        ObjectLiteral lit = (ObjectLiteral) pt.getExpression();\n+        ParenthesizedExpression parens =\n+            (ParenthesizedExpression) lit.getElements().get(0).getRight();\n+        assertNotNull(parens.getJsDoc());\n+    }\n+\n+    public void testJSDocAttachment11() {\n+      AstRoot root = parse(\"({/** attach me */ get foo() {}});\");\n+      assertNotNull(root.getComments());\n+      assertEquals(1, root.getComments().size());\n+      ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+      ParenthesizedExpression pt = (ParenthesizedExpression) st.getExpression();\n+      ObjectLiteral lit = (ObjectLiteral) pt.getExpression();\n+      Name objLitKey =\n+          (Name) lit.getElements().get(0).getLeft();\n+      assertNotNull(objLitKey.getJsDoc());\n+  }\n+\n+    public void testJSDocAttachment12() {\n+      AstRoot root = parse(\"({/** attach me */ get 1() {}});\");\n+      assertNotNull(root.getComments());\n+      assertEquals(1, root.getComments().size());\n+      ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+      ParenthesizedExpression pt = (ParenthesizedExpression) st.getExpression();\n+      ObjectLiteral lit = (ObjectLiteral) pt.getExpression();\n+      NumberLiteral number =\n+          (NumberLiteral) lit.getElements().get(0).getLeft();\n+      assertNotNull(number.getJsDoc());\n+  }\n+\n+  public void testJSDocAttachment13() {\n+      AstRoot root = parse(\"({/** attach me */ get 'foo'() {}});\");\n+      assertNotNull(root.getComments());\n+      assertEquals(1, root.getComments().size());\n+      ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+      ParenthesizedExpression pt = (ParenthesizedExpression) st.getExpression();\n+      ObjectLiteral lit = (ObjectLiteral) pt.getExpression();\n+      StringLiteral stringLit =\n+          (StringLiteral) lit.getElements().get(0).getLeft();\n+      assertNotNull(stringLit.getJsDoc());\n+  }\n+\n+    public void testJSDocAttachment14() {\n+        AstRoot root = parse(\"var a = (/** @type {!Foo} */ {});\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(\"/** @type {!Foo} */\",\n+                     root.getComments().first().getValue());\n+        VariableDeclaration vd = (VariableDeclaration) root.getFirstChild();\n+        VariableInitializer vi = vd.getVariables().get(0);\n+        assertNotNull(((ParenthesizedExpression)vi.getInitializer())\n+                       .getExpression().getJsDoc());\n+    }\n+\n+    public void testJSDocAttachment15() {\n+        AstRoot root = parse(\"/** @private */ x(); function f() {}\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        assertNotNull(st.getExpression().getJsDoc());\n+    }\n+\n+    public void testJSDocAttachment16() {\n+        AstRoot root = parse(\n+        \"/** @suppress {with} */ with (context) {\\n\" +\n+        \"  eval('[' + expr + ']');\\n\" +\n+        \"}\\n\");\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+\n+        WithStatement st = (WithStatement) root.getFirstChild();\n+        assertNotNull(st.getJsDoc());\n+    }\n+\n+    public void testParsingWithoutJSDoc() {\n+        AstRoot root = parse(\"var a = /** @type number */(x);\", false);\n+        assertNotNull(root.getComments());\n+        assertEquals(1, root.getComments().size());\n+        assertEquals(\"/** @type number */\",\n+                     root.getComments().first().getValue());\n+        VariableDeclaration vd = (VariableDeclaration) root.getFirstChild();\n+        VariableInitializer vi = vd.getVariables().get(0);\n+        assertTrue(vi.getInitializer() instanceof ParenthesizedExpression);\n+    }\n+\n+    public void testParseCommentsAsReader() throws IOException {\n+        AstRoot root = parseAsReader(\n+            \"/** a */var a;\\n /** b */var b; /** c */var c;\");\n+        assertNotNull(root.getComments());\n+        assertEquals(3, root.getComments().size());\n+        Comment[] comments = new Comment[3];\n+        comments = root.getComments().toArray(comments);\n+        assertEquals(\"/** a */\", comments[0].getValue());\n+        assertEquals(\"/** b */\", comments[1].getValue());\n+        assertEquals(\"/** c */\", comments[2].getValue());\n+    }\n+\n+    public void testParseCommentsAsReader2() throws IOException {\n+        String js = \"\";\n+        for (int i = 0; i < 100; i++) {\n+            String stri = Integer.toString(i);\n+            js += \"/** Some comment for a\" + stri + \" */\" +\n+                  \"var a\" + stri + \" = \" + stri + \";\\n\";\n+        }\n+        AstRoot root = parseAsReader(js);\n+    }\n+\n+    public void testLinenoCommentsWithJSDoc() throws IOException {\n+        AstRoot root = parseAsReader(\n+            \"/* foo \\n\" +\n+            \" bar \\n\" +\n+            \"*/\\n\" +\n+            \"/** @param {string} x */\\n\" +\n+            \"function a(x) {};\\n\");\n+        assertNotNull(root.getComments());\n+        assertEquals(2, root.getComments().size());\n+        Comment[] comments = new Comment[2];\n+        comments = root.getComments().toArray(comments);\n+        assertEquals(0, comments[0].getLineno());\n+        assertEquals(3, comments[1].getLineno());\n+    }\n+\n+    public void testParseUnicodeFormatStringLiteral() {\n+        AstRoot root = parse(\"'A\\u200DB'\");\n+        ExpressionStatement st = (ExpressionStatement) root.getFirstChild();\n+        StringLiteral stringLit = (StringLiteral) st.getExpression();\n+        assertEquals(\"A\\u200DB\", stringLit.getValue());\n+    }\n+\n+    public void testParseUnicodeFormatName() {\n+        AstRoot root = parse(\"A\\u200DB\");\n+        AstNode first = ((ExpressionStatement)\n+            root.getFirstChild()).getExpression();\n+        assertEquals(\"AB\", first.getString());\n+    }\n+\n+    public void testParseUnicodeReservedKeywords1() {\n+        AstRoot root = parse(\"\\\\u0069\\\\u0066\");\n+        AstNode first = ((ExpressionStatement)\n+            root.getFirstChild()).getExpression();\n+        assertEquals(\"i\\\\u0066\", first.getString());\n+    }\n+\n+    public void testParseUnicodeReservedKeywords2() {\n+        AstRoot root = parse(\"v\\\\u0061\\\\u0072\");\n+        AstNode first = ((ExpressionStatement)\n+            root.getFirstChild()).getExpression();\n+        assertEquals(\"va\\\\u0072\", first.getString());\n+    }\n+\n+    public void testParseUnicodeReservedKeywords3() {\n+        // All are keyword \"while\"\n+        AstRoot root = parse(\"w\\\\u0068\\\\u0069\\\\u006C\\\\u0065;\" +\n+\t    \"\\\\u0077\\\\u0068il\\\\u0065; \\\\u0077h\\\\u0069le;\");\n+        AstNode first = ((ExpressionStatement)\n+            root.getFirstChild()).getExpression();\n+        AstNode second = ((ExpressionStatement)\n+\t    root.getFirstChild().getNext()).getExpression();\n+        AstNode third = ((ExpressionStatement)\n+            root.getFirstChild().getNext().getNext()).getExpression();\n+        assertEquals(\"whil\\\\u0065\", first.getString());\n+        assertEquals(\"whil\\\\u0065\", second.getString());\n+        assertEquals(\"whil\\\\u0065\", third.getString());\n+    }\n+\n+    public void testParseObjectLiteral1() {\n+      allowKeywordsAsObjectLiteralsKeys = true;\n+\n+      parse(\"({a:1});\");\n+      parse(\"({'a':1});\");\n+      parse(\"({0:1});\");\n+\n+      // property getter and setter definitions accept string and number\n+      parse(\"({get a() {return 1}});\");\n+      parse(\"({get 'a'() {return 1}});\");\n+      parse(\"({get 0() {return 1}});\");\n+\n+      parse(\"({set a(a) {return 1}});\");\n+      parse(\"({set 'a'(a) {return 1}});\");\n+      parse(\"({set 0(a) {return 1}});\");\n+\n+      // keywords ok\n+      parse(\"({function:1});\");\n+      // reserved words ok\n+      parse(\"({float:1});\");\n+    }\n+\n+    public void testParseObjectLiteral2() {\n+      // keywords, fail\n+      expectParseErrors(\"({function:1});\",\n+          new String[] { \"invalid property id\" });\n+\n+      allowKeywordsAsObjectLiteralsKeys = true;\n+\n+      // keywords ok\n+      parse(\"({function:1});\");\n+    }\n+\n+    public void testParseKeywordPropertyAccess() {\n+      allowKeywordsAsObjectLiteralsKeys = true;\n+\n+      // keywords ok\n+      parse(\"({function:1}).function;\");\n+\n+      // reserved words ok.\n+      parse(\"({import:1}).import;\");\n+    }\n+\n+    private void expectParseErrors(String string, String [] errors) {\n+      parse(string, errors, null, false);\n+    }\n+\n+    private AstRoot parse(String string) {\n+        return parse(string, true);\n+    }\n+\n+    private AstRoot parse(String string, boolean jsdoc) {\n+       return parse(string, null, null, jsdoc);\n+    }\n+\n+    private AstRoot parse(\n+        String string, final String [] errors, final String [] warnings,\n+        boolean jsdoc) {\n+        CompilerEnvirons environment = new CompilerEnvirons();\n+        environment.setAllowKeywordAsObjectPropertyName(\n+            allowKeywordsAsObjectLiteralsKeys);\n+\n+        TestErrorReporter testErrorReporter =\n+            new TestErrorReporter(errors, warnings) {\n+          @Override\n+          public EvaluatorException runtimeError(\n+               String message, String sourceName, int line, String lineSource,\n+               int lineOffset) {\n+             if (errors == null) {\n+               throw new UnsupportedOperationException();\n+             }\n+             return new EvaluatorException(\n+               message, sourceName, line, lineSource, lineOffset);\n+           }\n+        };\n+        environment.setErrorReporter(testErrorReporter);\n+\n+        environment.setRecordingComments(true);\n+        environment.setRecordingLocalJsDocComments(jsdoc);\n+\n+        Parser p = new Parser(environment, testErrorReporter);\n+        AstRoot script = null;\n+        try {\n+          script = p.parse(string, null, 0);\n+        } catch (EvaluatorException e) {\n+          if (errors == null) {\n+            // EvaluationExceptions should not occur when we aren't expecting\n+            // errors.\n+            throw e;\n+          }\n+        }\n+\n+        assertTrue(testErrorReporter.hasEncounteredAllErrors());\n+        assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n+\n+        return script;\n+    }\n+\n+    private AstRoot parseAsReader(String string) throws IOException {\n+        CompilerEnvirons environment = new CompilerEnvirons();\n+\n+        TestErrorReporter testErrorReporter = new TestErrorReporter(null, null);\n+        environment.setErrorReporter(testErrorReporter);\n+\n+        environment.setRecordingComments(true);\n+        environment.setRecordingLocalJsDocComments(true);\n+\n+        Parser p = new Parser(environment, testErrorReporter);\n+        AstRoot script = p.parse(new StringReader(string), null, 0);\n+\n+        assertTrue(testErrorReporter.hasEncounteredAllErrors());\n+        assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n+\n+        return script;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/PrimitiveTypeScopeResolutionTest.java\n+package org.mozilla.javascript.tests;\n+\n+import org.junit.Test;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.ScriptableObject;\n+\n+/**\n+ * Unit tests for <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=374918\">Bug 374918 -\n+ * String primitive prototype wrongly resolved when used with many top scopes</a>\n+ */\n+public class PrimitiveTypeScopeResolutionTest\n+{\n+    /**\n+     */\n+    @Test\n+    public void functionCall() {\n+        String str2 = \"function f() {\\n\"\n+            + \"String.prototype.foo = function() { return 'from 2' }; \\n\"\n+            + \"var s2 = 's2';\\n\"\n+            + \"var s2Foo = s2.foo();\\n\"\n+            + \"if (s2Foo != 'from 2') throw 's2 got: ' + s2Foo;\\n\" // fails\n+            + \"}\";\n+\n+        String str1 = \"String.prototype.foo = function() { return 'from 1'};\"\n+            + \"scope2.f()\";\n+    \ttestWithTwoScopes(str1, str2);\n+    }\n+\n+    /**\n+     */\n+    @Test\n+    public void propertyAccess() {\n+        String str2 = \"function f() { String.prototype.foo = 'from 2'; \\n\"\n+            + \"var s2 = 's2';\\n\"\n+            + \"var s2Foo = s2.foo;\\n\"\n+            + \"if (s2Foo != 'from 2') throw 's2 got: ' + s2Foo;\\n\" // fails\n+            + \"}\";\n+\n+        String str1 = \"String.prototype.foo = 'from 1'; scope2.f()\";\n+    \ttestWithTwoScopes(str1, str2);\n+    }\n+\n+    /**\n+     */\n+    @Test\n+    public void elementAccess() {\n+        String str2 = \"function f() { String.prototype.foo = 'from 2'; \\n\"\n+            + \"var s2 = 's2';\\n\"\n+            + \"var s2Foo = s2['foo'];\\n\"\n+            + \"if (s2Foo != 'from 2') throw 's2 got: ' + s2Foo;\\n\" // fails\n+            + \"}\";\n+\n+        String str1 = \"String.prototype.foo = 'from 1'; scope2.f()\";\n+    \ttestWithTwoScopes(str1, str2);\n+    }\n+\n+    private void testWithTwoScopes(final String scriptScope1,\n+                                   final String scriptScope2)\n+    {\n+    \tfinal ContextAction action = new ContextAction()\n+    \t{\n+    \t\tpublic Object run(final Context cx)\n+    \t\t{\n+    \t        final Scriptable scope1 = cx.initStandardObjects(\n+    \t            new MySimpleScriptableObject(\"scope1\"));\n+    \t        final Scriptable scope2 = cx.initStandardObjects(\n+    \t            new MySimpleScriptableObject(\"scope2\"));\n+    \t        cx.evaluateString(scope2, scriptScope2, \"source2\", 1, null);\n+\n+    \t        scope1.put(\"scope2\", scope1, scope2);\n+\n+    \t        return cx.evaluateString(scope1, scriptScope1, \"source1\", 1,\n+    \t                                 null);\n+    \t\t}\n+    \t};\n+    \tUtils.runWithAllOptimizationLevels(action);\n+    }\n+\n+\t/**\n+\t * Simple utility allowing to better see the concerned scope while debugging\n+\t */\n+\tstatic class MySimpleScriptableObject extends ScriptableObject\n+\t{\n+        private static final long serialVersionUID = 1L;\n+        private String label_;\n+\t\tMySimpleScriptableObject(String label)\n+\t\t{\n+\t\t\tlabel_ = label;\n+\t\t}\n+\t\t@Override\n+\t\tpublic String getClassName()\n+\t\t{\n+\t\t\treturn \"MySimpleScriptableObject\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString()\n+\t\t{\n+\t\t\treturn label_;\n+\t\t}\n+\t}\n+\n+    public static class MyObject extends ScriptableObject {\n+        private static final long serialVersionUID = 1L;\n+\n+    @Override\n+      public String getClassName()\n+      {\n+          return \"MyObject\";\n+      }\n+\n+      public Object readPropFoo(final Scriptable s) {\n+          return ScriptableObject.getProperty(s, \"foo\");\n+      }\n+  }\n+\n+  /**\n+   * Test that FunctionObject use the right top scope to convert a primitive\n+   * to an object\n+   */\n+  @Test\n+  public void functionObjectPrimitiveToObject() throws Exception {\n+      final String scriptScope2 = \"function f() {\\n\"\n+          + \"String.prototype.foo = 'from 2'; \\n\"\n+          + \"var s2 = 's2';\\n\"\n+          + \"var s2Foo = s2.foo;\\n\"\n+          + \"var s2FooReadByFunction = myObject.readPropFoo(s2);\\n\"\n+          + \"if (s2Foo != s2FooReadByFunction)\\n\"\n+          + \"throw 's2 got: ' + s2FooReadByFunction;\\n\"\n+          + \"}\";\n+\n+      // define object with custom method\n+      final MyObject myObject = new MyObject();\n+      final String[] functionNames = { \"readPropFoo\" };\n+      myObject.defineFunctionProperties(functionNames, MyObject.class,\n+          ScriptableObject.EMPTY);\n+\n+      final String scriptScope1 = \"String.prototype.foo = 'from 1'; scope2.f()\";\n+\n+      final ContextAction action = new ContextAction()\n+      {\n+          public Object run(final Context cx)\n+          {\n+              final Scriptable scope1 = cx.initStandardObjects(\n+                  new MySimpleScriptableObject(\"scope1\"));\n+              final Scriptable scope2 = cx.initStandardObjects(\n+                  new MySimpleScriptableObject(\"scope2\"));\n+\n+              scope2.put(\"myObject\", scope2, myObject);\n+              cx.evaluateString(scope2, scriptScope2, \"source2\", 1, null);\n+\n+              scope1.put(\"scope2\", scope1, scope2);\n+\n+              return cx.evaluateString(scope1, scriptScope1, \"source1\", 1, null);\n+          }\n+      };\n+      Utils.runWithAllOptimizationLevels(action);\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/PrivateAccessClass.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Attila Szegedi\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tests;\n+\n+/**\n+ * A class with private/protected/package private members, to test the Rhino\n+ * feature Context.FEATURE_ENHANCED_JAVA_ACCESS, that allows bypassing Java\n+ * member access restrictions.\n+ */\n+\n+public class PrivateAccessClass\n+{\n+  private PrivateAccessClass() { }\n+  PrivateAccessClass(String s) { }\n+  private PrivateAccessClass(int x) { }\n+  protected PrivateAccessClass(int x, String s) { }\n+\n+  private static class PrivateNestedClass\n+  {\n+    private PrivateNestedClass() { }\n+\n+    int packagePrivateInt = 0;\n+    private int privateInt = 1;\n+    protected int protectedInt = 2;\n+  }\n+\n+  static int staticPackagePrivateInt = 0;\n+  private static int staticPrivateInt = 1;\n+  protected static int staticProtectedInt = 2;\n+\n+  String packagePrivateString = \"package private\";\n+  private String privateString = \"private\";\n+  protected String protectedString = \"protected\";\n+\n+  static int staticPackagePrivateMethod() { return 0; }\n+  static private int staticPrivateMethod() { return 1; }\n+  static protected int staticProtectedMethod() { return 2; }\n+\n+  int packagePrivateMethod() { return 3; }\n+  private int privateMethod() { return 4; }\n+  protected int protectedMethod() { return 5; }\n+\n+  private int javaBeanProperty = 6;\n+  public boolean getterCalled = false;\n+  public boolean setterCalled = false;\n+  public int getJavaBeanProperty() {\n+      getterCalled = true;\n+      return javaBeanProperty;\n+  }\n+  public void setJavaBeanProperty(int i) {\n+      setterCalled = true;\n+      javaBeanProperty = i;\n+  }\n+\n+  /*\n+   * Suppress warnings about unused private members.\n+   */\n+  public int referenceToPrivateMembers() {\n+    PrivateAccessClass pac = new PrivateAccessClass();\n+    PrivateAccessClass pac2 = new PrivateAccessClass(2);\n+    PrivateNestedClass pnc = new PrivateNestedClass();\n+    System.out.println(privateString);\n+    pac2.privateMethod(); // to silence warning\n+    return pnc.privateInt + staticPrivateInt + staticPrivateMethod() +\n+           pac.privateMethod() + javaBeanProperty;\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/StackTraceTest.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.JavaScriptException;\n+import org.mozilla.javascript.Scriptable;\n+\n+/**\n+ */\n+public class StackTraceTest extends TestCase {\n+\n+\t/**\n+\t * As of CVS head on May, 11. 2009, stacktrace information is lost when a call to some\n+\t * native function has been made.\n+\t */\n+    public void testFailureStackTrace() {\n+        final String source1 = \"function f2() { throw 'hello'; }; f2();\";\n+        final String source2 = \"function f2() { 'H'.toLowerCase(); throw 'hello'; }; f2();\";\n+\n+        runWithExpectedStackTrace(source1, \"\tat test.js (f2)\\n\\tat test.js\\n\"); // works\n+        runWithExpectedStackTrace(source2, \"\tat test.js (f2)\\n\\tat test.js\\n\"); // fails\n+    }\n+\n+\tprivate void runWithExpectedStackTrace(final String _source, final String _expectedStackTrace)\n+\t{\n+        final ContextAction action = new ContextAction() {\n+        \tpublic Object run(Context cx) {\n+        \t\tfinal Scriptable scope = cx.initStandardObjects();\n+        \t\ttry {\n+        \t\t\tcx.evaluateString(scope, _source, \"test.js\", 0, null);\n+        \t\t}\n+        \t\tcatch (final JavaScriptException e)\n+        \t\t{\n+        \t\t\tassertEquals(_expectedStackTrace, e.getScriptStackTrace());\n+        \t\t\treturn null;\n+        \t\t}\n+        \t\tthrow new RuntimeException(\"Exception expected!\");\n+        \t}\n+        };\n+        Utils.runWithOptimizationLevel(action, -1);\n+\t}\n+ }\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/StrictModeApiTest.java\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.ScriptableObject;\n+import org.mozilla.javascript.EvaluatorException;\n+\n+/**\n+ * Test of strict mode APIs.\n+ *\n+ */\n+public class StrictModeApiTest extends TestCase {\n+\n+  private ScriptableObject global;\n+  private ContextFactory contextFactory;\n+\n+  static class MyContextFactory extends ContextFactory {\n+    @Override\n+    protected boolean hasFeature(Context cx, int featureIndex) {\n+        switch (featureIndex) {\n+            case Context.FEATURE_STRICT_MODE:\n+            case Context.FEATURE_STRICT_VARS:\n+            case Context.FEATURE_STRICT_EVAL:\n+            case Context.FEATURE_WARNING_AS_ERROR:\n+                return true;\n+        }\n+        return super.hasFeature(cx, featureIndex);\n+    }\n+  }\n+\n+  public void testStrictModeError() {\n+    contextFactory = new MyContextFactory();\n+    Context cx = contextFactory.enterContext();\n+    try {\n+        global = cx.initStandardObjects();\n+        try {\n+            runScript(\"({}.nonexistent);\");\n+            fail();\n+        } catch (EvaluatorException e) {\n+            assertTrue(e.getMessage().startsWith(\"Reference to undefined property\"));\n+        }\n+    } finally {\n+        Context.exit();\n+    }\n+  }\n+\n+  private Object runScript(final String scriptSourceText) {\n+    return this.contextFactory.call(new ContextAction() {\n+      public Object run(Context context) {\n+          return context.evaluateString(global, scriptSourceText,\n+                  \"test source\", 1, null);\n+      }\n+    });\n+  }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/TypeOfTest.java\n+package org.mozilla.javascript.tests;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.BaseFunction;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.Function;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.ScriptableObject;\n+\n+/**\n+ * Takes care that it's possible to customize the result of the typeof operator.\n+ * See https://bugzilla.mozilla.org/show_bug.cgi?id=463996\n+ * Includes fix and test for https://bugzilla.mozilla.org/show_bug.cgi?id=453360\n+ */\n+public class TypeOfTest extends TestCase\n+{\n+\tpublic static class Foo extends ScriptableObject {\n+        private static final long serialVersionUID = -8771045033217033529L;\n+        private final String typeOfValue_;\n+\n+        public Foo(final String _typeOfValue)\n+\t\t{\n+        \ttypeOfValue_ = _typeOfValue;\n+\t\t}\n+        \n+        @Override\n+        public String getTypeOf()\n+        {\n+        \treturn typeOfValue_;\n+        }\n+\n+\t\t@Override\n+\t\tpublic String getClassName()\n+\t\t{\n+\t\t\treturn \"Foo\";\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * ECMA 11.4.3 says that typeof on host object is Implementation-dependent\n+\t */\n+\tpublic void testCustomizeTypeOf() throws Exception\n+\t{\n+\t\ttestCustomizeTypeOf(\"object\", new Foo(\"object\"));\n+\t\ttestCustomizeTypeOf(\"blabla\", new Foo(\"blabla\"));\n+\t}\n+\n+\t/**\n+\t * ECMA 11.4.3 says that typeof on host object is Implementation-dependent\n+\t */\n+\tpublic void test0() throws Exception\n+\t{\n+        final Function f = new BaseFunction()\n+        {\n+        \t@Override\n+        \tpublic Object call(Context _cx, Scriptable _scope, Scriptable _thisObj,\n+        \t\t\tObject[] _args)\n+        \t{\n+        \t\treturn _args[0].getClass().getName();\n+        \t}\n+        };\n+\t\tfinal ContextAction action = new ContextAction()\n+\t\t{\n+\t\t\tpublic Object run(final Context context)\n+\t\t\t{\n+\t\t\t\tfinal Scriptable scope = context.initStandardObjects();\n+\t\t\t\tscope.put(\"myObj\", scope, f);\n+\t\t\t\treturn context.evaluateString(scope, \"typeof myObj\", \"test script\", 1, null);\n+\t\t\t}\n+\t\t};\n+\t\tdoTest(\"function\", action);\n+\t}\n+\n+\tprivate void testCustomizeTypeOf(final String expected, final Scriptable obj)\n+\t{\n+\t\tfinal ContextAction action = new ContextAction()\n+\t\t{\n+\t\t\tpublic Object run(final Context context)\n+\t\t\t{\n+\t\t\t\tfinal Scriptable scope = context.initStandardObjects();\n+\t\t\t\tscope.put(\"myObj\", scope, obj);\n+\t\t\t\treturn context.evaluateString(scope, \"typeof myObj\", \"test script\", 1, null);\n+\t\t\t}\n+\t\t};\n+\t\tdoTest(expected, action);\n+\t}\n+\n+\t/**\n+\t * See https://bugzilla.mozilla.org/show_bug.cgi?id=453360\n+\t */\n+\tpublic void testBug453360() throws Exception\n+\t{\n+\t\tdoTest(\"object\", \"typeof new RegExp();\");\n+\t\tdoTest(\"object\", \"typeof /foo/;\");\n+\t}\n+\n+\tprivate void doTest(String expected, final String script)\n+\t{\n+\t\tfinal ContextAction action = new ContextAction()\n+\t\t{\n+\t\t\tpublic Object run(final Context context)\n+\t\t\t{\n+\t\t\t\tfinal Scriptable scope = context.initStandardObjects();\n+\t\t\t\treturn context.evaluateString(scope, script, \"test script\", 1, null);\n+\t\t\t}\n+\t\t};\n+\t\tdoTest(expected, action);\n+\t}\n+\n+\tprivate void doTest(final String expected, final ContextAction action)\n+\t{\n+\t\tdoTest(-1, expected, action);\n+\t\tdoTest(0, expected, action);\n+\t\tdoTest(1, expected, action);\n+\t}\n+\n+\tprivate void doTest(final int optimizationLevel, final String expected, final ContextAction action)\n+\t{\n+\t\tObject o = new ContextFactory().call(new ContextAction()\n+\t\t\t{\n+\t\t\t\tpublic Object run(final Context context)\n+\t\t\t\t{\n+\t\t\t\t\tcontext.setOptimizationLevel(optimizationLevel);\n+\t\t\t\t\treturn Context.toString(action.run(context));\n+\t\t\t\t}\n+\t\t\t});\n+\t\tassertEquals(expected, o);\n+\t}\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Utils.java\n+package org.mozilla.javascript.tests;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.ContextFactory;\n+\n+/**\n+ * Misc utilities to make test code easier.\n+ */\n+public class Utils\n+{\n+\t/**\n+\t * Runs the action successively with all available optimization levels\n+\t */\n+\tpublic static void runWithAllOptimizationLevels(final ContextAction action)\n+\t{\n+\t\trunWithOptimizationLevel(action, -1);\n+\t\trunWithOptimizationLevel(action, 0);\n+\t\trunWithOptimizationLevel(action, 1);\n+\t}\n+\n+\t/**\n+\t * Runs the provided action at the given optimization level\n+\t */\n+\tpublic static void runWithOptimizationLevel(final ContextAction action, final int optimizationLevel)\n+\t{\n+    \tfinal Context cx = new ContextFactory().enterContext();\n+    \ttry\n+    \t{\n+    \t\tcx.setOptimizationLevel(optimizationLevel);\n+    \t\taction.run(cx);\n+    \t}\n+    \tfinally\n+    \t{\n+    \t\tContext.exit();\n+    \t}\n+\t}\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java\n+/*\n+ * Tests for the Object.getOwnPropertyDescriptor(obj, prop) method\n+ */\n+package org.mozilla.javascript.tests.es5;\n+import org.mozilla.javascript.*;\n+import static org.mozilla.javascript.tests.Evaluator.eval;\n+import static org.junit.Assert.assertEquals;\n+import org.junit.Test;\n+\n+public class ObjectGetOwnPropertyDescriptorTest {\n+\n+  @Test\n+  public void testContentsOfPropertyDescriptorShouldReflectAttributesOfProperty() {\n+    NativeObject descriptor;\n+    NativeObject object = new NativeObject();\n+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n+    object.defineProperty(\"b\", \"2\", ScriptableObject.DONTENUM | ScriptableObject.READONLY | ScriptableObject.PERMANENT);\n+\n+    descriptor = (NativeObject) eval(\"Object.getOwnPropertyDescriptor(obj, 'a')\", \"obj\", object);\n+    assertEquals(\"1\",  descriptor.get(\"value\"));\n+    assertEquals(true, descriptor.get(\"enumerable\"));\n+    assertEquals(true, descriptor.get(\"writable\"));\n+    assertEquals(true, descriptor.get(\"configurable\"));\n+\n+    descriptor = (NativeObject) eval(\"Object.getOwnPropertyDescriptor(obj, 'b')\", \"obj\", object);\n+    assertEquals(\"2\",  descriptor.get(\"value\"));\n+    assertEquals(false, descriptor.get(\"enumerable\"));\n+    assertEquals(false, descriptor.get(\"writable\"));\n+    assertEquals(false, descriptor.get(\"configurable\"));\n+  }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java\n+/*\n+ * Tests for the Object.getOwnPropertyNames(obj) method\n+ */\n+package org.mozilla.javascript.tests.es5;\n+import org.mozilla.javascript.*;\n+import static org.mozilla.javascript.tests.Evaluator.eval;\n+import static org.junit.Assert.assertEquals;\n+import org.junit.Test;\n+\n+public class ObjectGetOwnPropertyNamesTest {\n+\n+  @Test\n+  public void testShouldReturnAllPropertiesOfArg() {\n+    NativeObject object = new NativeObject();\n+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n+    object.defineProperty(\"b\", \"2\", ScriptableObject.DONTENUM);\n+\n+    Object result = eval(\"Object.getOwnPropertyNames(obj)\", \"obj\", object);\n+\n+    NativeArray names = (NativeArray) result;\n+\n+    assertEquals(2, names.getLength());\n+    assertEquals(\"a\", names.get(0, names));\n+    assertEquals(\"b\", names.get(1, names));\n+  }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java\n+/*\n+ * Tests for the Object.keys(obj) method\n+ */\n+package org.mozilla.javascript.tests.es5;\n+import org.mozilla.javascript.*;\n+import static org.mozilla.javascript.tests.Evaluator.eval;\n+import static org.junit.Assert.assertEquals;\n+import org.junit.Test;\n+\n+public class ObjectKeysTest {\n+\n+  @Test\n+  public void shouldReturnOnlyEnumerablePropertiesOfArg() {\n+    NativeObject object = new NativeObject();\n+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n+    object.defineProperty(\"b\", \"2\", ScriptableObject.EMPTY);\n+    object.defineProperty(\"c\", \"3\", ScriptableObject.DONTENUM);\n+\n+    Object result = eval(\"Object.keys(obj)\", \"obj\", object);\n+\n+    NativeArray keys = (NativeArray) result;\n+\n+    assertEquals(2, keys.getLength());\n+    assertEquals(\"a\", keys.get(0, keys));\n+    assertEquals(\"b\", keys.get(1, keys));\n+  }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/json/JsonLexerTest.java\n+package org.mozilla.javascript.tests.json;\n+\n+import static org.mozilla.javascript.json.JsonLexer.Token.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.mozilla.javascript.json.JsonLexer;\n+import org.mozilla.javascript.json.JsonLexer.Token;\n+\n+import org.junit.Test;\n+\n+public class JsonLexerTest {\n+\n+\t@Test\n+\tpublic void shouldLexSingleTokens() throws Exception {\n+\t\tassertLexesSingleToken(\"null\", NULL);\n+\t\tassertLexesSingleToken(\"false\", BOOLEAN);\n+\t\tassertLexesSingleToken(\"true\", BOOLEAN);\n+\t\tassertLexesSingleToken(\"-1.0e-4\", NUMBER);\n+\t\tassertLexesSingleToken(\"\\\"\\\"\", STRING);\n+\t\tassertLexesSingleToken(\"[\", OPEN_BRACKET);\n+\t\tassertLexesSingleToken(\"{\", OPEN_BRACE);\n+\t\tassertLexesSingleToken(\"\\\"a\\\"\", STRING);\n+\t}\n+\t\n+\t@Test\n+\tpublic void shouldLexSequenceOfTokens() throws Exception {\n+\t\tassertLexesMultipleTokens(\"[1]\", OPEN_BRACKET, NUMBER, CLOSE_BRACKET);\n+\t\tassertLexesMultipleTokens(\"[1,false]\", OPEN_BRACKET, NUMBER, COMMA, BOOLEAN, CLOSE_BRACKET);\n+\t\tassertLexesMultipleTokens(\"{\\\"a\\\":1}\", OPEN_BRACE, STRING, COLON, NUMBER, CLOSE_BRACE);\n+\t\tassertLexesMultipleTokens(\"{\\\"a\\\":1,\\\"b\\\":false}\", OPEN_BRACE, STRING, COLON, NUMBER, COMMA, STRING, COLON, BOOLEAN, CLOSE_BRACE);\n+\t}\n+\t\n+\t@Test\n+\tpublic void shouldIgnoreWhitespace() throws Exception {\n+\t\tassertLexesSingleToken(\"  1\\t\\n \\t\", NUMBER);\n+\t\tassertLexesMultipleTokens(\" [ 1 , null\\t\\n ]\\t\", OPEN_BRACKET, NUMBER, COMMA, NULL, CLOSE_BRACKET);\n+\t}\n+\n+\tprivate void assertLexesMultipleTokens(String json, Token... tokens) {\n+\t\tJsonLexer lexer = new JsonLexer(json);\n+\t\tfor (Token token : tokens) {\n+\t\t\tassertTrue(\"Expected \"+token, lexer.moveNext());\n+\t\t\tassertEquals(token, lexer.getToken());\n+\t\t}\n+\t\tassertFalse(lexer.moveNext());\n+\t}\n+\t\n+\tprivate void assertLexesSingleToken(String lexeme, Token token) {\n+\t\tJsonLexer lexer = new JsonLexer(lexeme);\n+\t\tassertTrue(lexer.moveNext());\n+\t\tassertEquals(token, lexer.getToken());\n+\t\tassertFalse(lexer.moveNext());\n+\t}\n+\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/json/JsonParserTest.java\n+package org.mozilla.javascript.tests.json;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.NativeArray;\n+import org.mozilla.javascript.NativeObject;\n+\n+import org.mozilla.javascript.json.JsonParser;\n+import org.mozilla.javascript.json.JsonParser.ParseException;\n+\n+import org.junit.Before;\n+import org.junit.After;\n+import org.junit.Test;\n+\n+public class JsonParserTest {\n+    private JsonParser parser;\n+    private Context cx;\n+\n+    @Before\n+    public void setUp() {\n+        cx = Context.enter();\n+        parser = new JsonParser(cx, cx.initStandardObjects());\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Context.exit();\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseIllegalWhitespaceChars() throws Exception {\n+        parser.parseValue(\" \\u000b 1\");\n+    }\n+\n+\n+    @Test\n+    public void shouldParseJsonNull() throws Exception {\n+        assertEquals(null, parser.parseValue(\"null\"));\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseJavaNull() throws Exception {\n+        parser.parseValue(null);\n+    }\n+\n+    @Test\n+    public void shouldParseJsonBoolean() throws Exception {\n+        assertEquals(true, parser.parseValue(\"true\"));\n+        assertEquals(false, parser.parseValue(\"false\"));\n+    }\n+\n+    @Test\n+    public void shouldParseJsonNumbers() throws Exception {\n+        assertEquals(1, parser.parseValue(\"1\"));\n+        assertEquals(-1, parser.parseValue(\"-1\"));\n+        assertEquals(1.5, parser.parseValue(\"1.5\"));\n+        assertEquals(1.5e13, parser.parseValue(\"1.5e13\"));\n+        assertEquals(1.0e16, parser.parseValue(\"9999999999999999\"));\n+        assertEquals(Double.POSITIVE_INFINITY, parser.parseValue(\"1.5e99999999\"));\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseDoubleNegativeNumbers() throws Exception {\n+        parser.parseValue(\"--5\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseNumbersWithDecimalExponent() throws Exception {\n+        parser.parseValue(\"5e5.5\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseNumbersBeginningWithZero() throws Exception {\n+        parser.parseValue(\"05\");\n+    }\n+\n+    @Test\n+    public void shouldParseJsonString() throws Exception {\n+        assertEquals(\"hello\", parser.parseValue(\"\\\"hello\\\"\"));\n+        assertEquals(\"Sch\\u00f6ne Gr\\u00fc\\u00dfe\",\n+                parser.parseValue(\"\\\"Sch\\\\u00f6ne Gr\\\\u00fc\\\\u00dfe\\\"\"));\n+        assertEquals(\"\", parser.parseValue(str('\"', '\"')));\n+        assertEquals(\" \", parser.parseValue(str('\"', ' ', '\"')));\n+        assertEquals(\"\\r\", parser.parseValue(str('\"', '\\\\', 'r', '\"')));\n+        assertEquals(\"\\n\", parser.parseValue(str('\"', '\\\\', 'n', '\"')));\n+        assertEquals(\"\\t\", parser.parseValue(str('\"', '\\\\', 't', '\"')));\n+        assertEquals(\"\\\\\", parser.parseValue(str('\"', '\\\\', '\\\\', '\"')));\n+        assertEquals(\"/\", parser.parseValue(str('\"', '/', '\"')));\n+        assertEquals(\"/\", parser.parseValue(str('\"', '\\\\', '/', '\"')));\n+        assertEquals(\"\\\"\", parser.parseValue(str('\"', '\\\\', '\"', '\"')));\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseEmptyJavaString() throws Exception {\n+        parser.parseValue(\"\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseSingleDoubleQuote() throws Exception {\n+        parser.parseValue(str('\"'));\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseStringContainingSingleBackslash() throws Exception {\n+        parser.parseValue(str('\"', '\\\\', '\"'));\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseStringIllegalStringChars() throws Exception {\n+        parser.parseValue(str('\"', '\\n', '\"'));\n+    }\n+\n+    @Test\n+    public void shouldParseEmptyJsonArray() throws Exception {\n+        assertEquals(0, ((NativeArray) parser.parseValue(\"[]\")).getLength() );\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void shouldParseHeterogeneousJsonArray() throws Exception {\n+        NativeArray actual = (NativeArray) parser\n+                .parseValue(\"[ \\\"hello\\\" , 3, null, [false] ]\");\n+        assertEquals(\"hello\", actual.get(0, actual));\n+        assertEquals(3, actual.get(1, actual));\n+        assertEquals(null, actual.get(2, actual));\n+\n+        NativeArray innerArr = (NativeArray) actual.get(3, actual);\n+        assertEquals(false, innerArr.get(0, innerArr));\n+\n+        assertEquals(4, actual.getLength());\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseArrayWithInvalidElements() throws Exception {\n+        parser.parseValue(\"[wtf]\");\n+    }\n+\n+    @Test\n+    @SuppressWarnings({ \"serial\", \"unchecked\" })\n+    public void shouldParseJsonObject() throws Exception {\n+        String json = \"{\" +\n+                \"\\\"bool\\\" : false, \" +\n+                \"\\\"str\\\"  : \\\"xyz\\\", \" +\n+                \"\\\"obj\\\"  : {\\\"a\\\":1} \" +\n+                \"}\";\n+    NativeObject actual = (NativeObject) parser.parseValue(json);\n+    assertEquals(false, actual.get(\"bool\", actual));\n+    assertEquals(\"xyz\", actual.get(\"str\", actual));\n+\n+    NativeObject innerObj = (NativeObject) actual.get(\"obj\", actual);\n+    assertEquals(1, innerObj.get(\"a\", innerObj));\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseJsonObjectsWithInvalidFormat() throws Exception {\n+        parser.parseValue(\"{\\\"only\\\", \\\"keys\\\"}\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseMoreThanOneToplevelValue() throws Exception {\n+        parser.parseValue(\"1 2\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseStringTruncatedUnicode() throws Exception {\n+            parser.parseValue(\"\\\"\\\\u00f\\\"\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseStringControlChars1() throws Exception {\n+            parser.parseValue(\"\\\"\\u0000\\\"\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void shouldFailToParseStringControlChars2() throws Exception {\n+            parser.parseValue(\"\\\"\\u001f\\\"\");\n+    }\n+\n+    private String str(char... chars) {\n+        return new String(chars);\n+    }\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/SourceReader.java\n+package org.mozilla.javascript.tools;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+\n+import org.mozilla.javascript.Kit;\n+import org.mozilla.javascript.tools.shell.ParsedContentType;\n+\n+/**\n+ * @version $Id: SourceReader.java,v 1.1 2008/10/18 18:57:26 szegedia%freemail.hu Exp $\n+ */\n+public class SourceReader\n+{\n+    public static Object readFileOrUrl(String path, boolean convertToString,\n+            String defaultEncoding) throws IOException\n+    {\n+        URL url = null;\n+        // Assume path is URL if it contains dot and there are at least\n+        // 2 characters in the protocol part. The later allows under Windows\n+        // to interpret paths with driver letter as file, not URL.\n+        if (path.indexOf(':') >= 2) {\n+            try {\n+                url = new URL(path);\n+            } catch (MalformedURLException ex) {\n+            }\n+        }\n+\n+        InputStream is = null;\n+        int capacityHint = 0;\n+        String encoding;\n+        final String contentType;\n+        byte[] data;\n+        try {\n+            if (url == null) {\n+                File file = new File(path);\n+                contentType = encoding = null;\n+                capacityHint = (int)file.length();\n+                is = new FileInputStream(file);\n+            } else {\n+                URLConnection uc = url.openConnection();\n+                is = uc.getInputStream();\n+                if(convertToString) {\n+                    ParsedContentType pct = new ParsedContentType(uc.getContentType());\n+                    contentType = pct.getContentType();\n+                    encoding = pct.getEncoding();\n+                }\n+                else {\n+                    contentType = encoding = null;\n+                }\n+                capacityHint = uc.getContentLength();\n+                // Ignore insane values for Content-Length\n+                if (capacityHint > (1 << 20)) {\n+                    capacityHint = -1;\n+                }\n+            }\n+            if (capacityHint <= 0) {\n+                capacityHint = 4096;\n+            }\n+\n+            data = Kit.readStream(is, capacityHint);\n+        } finally {\n+            if(is != null) {\n+                is.close();\n+            }\n+        }\n+\n+        Object result;\n+        if (!convertToString) {\n+            result = data;\n+        } else {\n+            if(encoding == null) {\n+                // None explicitly specified in Content-type header. Use RFC-4329\n+                // 4.2.2 section to autodetect\n+                if(data.length > 3 && data[0] == -1 && data[1] == -2 && data[2] == 0 && data[3] == 0) {\n+                    encoding = \"UTF-32LE\";\n+                }\n+                else if(data.length > 3 && data[0] == 0 && data[1] == 0 && data[2] == -2 && data[3] == -1) {\n+                    encoding = \"UTF-32BE\";\n+                }\n+                else if(data.length > 2 && data[0] == -17 && data[1] == -69 && data[2] == -65) {\n+                    encoding = \"UTF-8\";\n+                }\n+                else if(data.length > 1 && data[0] == -1 && data[1] == -2) {\n+                    encoding = \"UTF-16LE\";\n+                }\n+                else if(data.length > 1 && data[0] == -2 && data[1] == -1) {\n+                    encoding = \"UTF-16BE\";\n+                }\n+                else {\n+                    // No autodetect. See if we have explicit value on command line\n+                    encoding = defaultEncoding;\n+                    if(encoding == null) {\n+                        // No explicit encoding specification\n+                        if(url == null) {\n+                            // Local files default to system encoding\n+                            encoding = System.getProperty(\"file.encoding\");\n+                        }\n+                        else if(contentType != null && contentType.startsWith(\"application/\")) {\n+                            // application/* types default to UTF-8\n+                            encoding = \"UTF-8\";\n+                        }\n+                        else {\n+                            // text/* MIME types default to US-ASCII\n+                            encoding = \"US-ASCII\";\n+                        }\n+                    }\n+                }\n+            }\n+            String strResult = new String(data, encoding);\n+            // Skip BOM\n+            if(strResult.length() > 0 && strResult.charAt(0) == '\\uFEFF')\n+            {\n+                strResult = strResult.substring(1);\n+            }\n+            result = strResult;\n+        }\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/ToolErrorReporter.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Kurt Westerfeld\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tools;\n+\n+import org.mozilla.javascript.*;\n+\n+import java.text.MessageFormat;\n+import java.io.*;\n+import java.util.*;\n+\n+/**\n+ * Error reporter for tools.\n+ *\n+ * Currently used by both the shell and the compiler.\n+ */\n+public class ToolErrorReporter implements ErrorReporter {\n+\n+    public ToolErrorReporter(boolean reportWarnings) {\n+        this(reportWarnings, System.err);\n+    }\n+\n+    public ToolErrorReporter(boolean reportWarnings, PrintStream err) {\n+        this.reportWarnings = reportWarnings;\n+        this.err = err;\n+    }\n+\n+    /**\n+     * Look up the message corresponding to messageId in the\n+     * org.mozilla.javascript.tools.shell.resources.Messages property file.\n+     * For internationalization support.\n+     */\n+    public static String getMessage(String messageId) {\n+        return getMessage(messageId, (Object []) null);\n+    }\n+\n+    public static String getMessage(String messageId, String argument) {\n+        Object[] args = { argument };\n+        return getMessage(messageId, args);\n+    }\n+\n+    public static String getMessage(String messageId, Object arg1, Object arg2)\n+    {\n+        Object[] args = { arg1, arg2 };\n+        return getMessage(messageId, args);\n+    }\n+\n+    public static String getMessage(String messageId, Object[] args) {\n+        Context cx = Context.getCurrentContext();\n+        Locale locale = cx == null ? Locale.getDefault() : cx.getLocale();\n+\n+        // ResourceBundle does caching.\n+        ResourceBundle rb = ResourceBundle.getBundle\n+            (\"org.mozilla.javascript.tools.resources.Messages\", locale);\n+\n+        String formatString;\n+        try {\n+            formatString = rb.getString(messageId);\n+        } catch (java.util.MissingResourceException mre) {\n+            throw new RuntimeException(\"no message resource found for message property \"\n+                                       + messageId);\n+        }\n+\n+        if (args == null) {\n+            return formatString;\n+        } else {\n+            MessageFormat formatter = new MessageFormat(formatString);\n+            return formatter.format(args);\n+        }\n+    }\n+\n+    private static String getExceptionMessage(RhinoException ex)\n+    {\n+        String msg;\n+        if (ex instanceof JavaScriptException) {\n+            msg = getMessage(\"msg.uncaughtJSException\", ex.details());\n+        } else if (ex instanceof EcmaError) {\n+            msg = getMessage(\"msg.uncaughtEcmaError\", ex.details());\n+        } else if (ex instanceof EvaluatorException) {\n+            msg = ex.details();\n+        } else {\n+            msg = ex.toString();\n+        }\n+        return msg;\n+    }\n+\n+    public void warning(String message, String sourceName, int line,\n+                        String lineSource, int lineOffset)\n+    {\n+        if (!reportWarnings)\n+            return;\n+        reportErrorMessage(message, sourceName, line, lineSource, lineOffset,\n+                           true);\n+    }\n+\n+    public void error(String message, String sourceName, int line,\n+                      String lineSource, int lineOffset)\n+    {\n+        hasReportedErrorFlag = true;\n+        reportErrorMessage(message, sourceName, line, lineSource, lineOffset,\n+                           false);\n+    }\n+\n+    public EvaluatorException runtimeError(String message, String sourceName,\n+                                           int line, String lineSource,\n+                                           int lineOffset)\n+    {\n+        return new EvaluatorException(message, sourceName, line,\n+                                      lineSource, lineOffset);\n+    }\n+\n+    public boolean hasReportedError() {\n+        return hasReportedErrorFlag;\n+    }\n+\n+    public boolean isReportingWarnings() {\n+        return this.reportWarnings;\n+    }\n+\n+    public void setIsReportingWarnings(boolean reportWarnings) {\n+        this.reportWarnings = reportWarnings;\n+    }\n+\n+    public static void reportException(ErrorReporter er, RhinoException ex)\n+    {\n+        if (er instanceof ToolErrorReporter) {\n+            ((ToolErrorReporter)er).reportException(ex);\n+        } else {\n+            String msg = getExceptionMessage(ex);\n+            er.error(msg, ex.sourceName(), ex.lineNumber(),\n+                     ex.lineSource(), ex.columnNumber());\n+        }\n+    }\n+\n+    public void reportException(RhinoException ex)\n+    {\n+        if (ex instanceof WrappedException) {\n+            WrappedException we = (WrappedException)ex;\n+            we.printStackTrace(err);\n+        } else {\n+            String lineSeparator =\n+                SecurityUtilities.getSystemProperty(\"line.separator\");\n+            String msg = getExceptionMessage(ex) + lineSeparator +\n+                ex.getScriptStackTrace();\n+            reportErrorMessage(msg, ex.sourceName(), ex.lineNumber(),\n+                               ex.lineSource(), ex.columnNumber(), false);\n+        }\n+    }\n+\n+    private void reportErrorMessage(String message, String sourceName, int line,\n+                                    String lineSource, int lineOffset,\n+                                    boolean justWarning)\n+    {\n+        if (line > 0) {\n+            String lineStr = String.valueOf(line);\n+            if (sourceName != null) {\n+                Object[] args = { sourceName, lineStr, message };\n+                message = getMessage(\"msg.format3\", args);\n+            } else {\n+                Object[] args = { lineStr, message };\n+                message = getMessage(\"msg.format2\", args);\n+            }\n+        } else {\n+            Object[] args = { message };\n+            message = getMessage(\"msg.format1\", args);\n+        }\n+        if (justWarning) {\n+            message = getMessage(\"msg.warning\", message);\n+        }\n+        err.println(messagePrefix + message);\n+        if (null != lineSource) {\n+            err.println(messagePrefix + lineSource);\n+            err.println(messagePrefix + buildIndicator(lineOffset));\n+        }\n+    }\n+\n+    private String buildIndicator(int offset){\n+        StringBuffer sb = new StringBuffer();\n+        for (int i = 0; i < offset-1; i++)\n+            sb.append(\".\");\n+        sb.append(\"^\");\n+        return sb.toString();\n+    }\n+\n+    private final String messagePrefix = \"js: \";\n+    private boolean hasReportedErrorFlag;\n+    private boolean reportWarnings;\n+    private PrintStream err;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/debugger/Dim.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino JavaScript Debugger code, released\n+ * November 21, 2000.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * SeeBeyond Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Matt Gould\n+ *   Christopher Oliver\n+ *   Cameron McCormack\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+package org.mozilla.javascript.tools.debugger;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.debug.*;\n+import java.util.*;\n+import java.io.*;\n+import java.net.URL;\n+\n+/**\n+ * Dim or Debugger Implementation for Rhino.\n+ */\n+public class Dim {\n+\n+    // Constants for instructing the debugger what action to perform\n+    // to end interruption.  Used by 'returnValue'.\n+    public static final int STEP_OVER = 0;\n+    public static final int STEP_INTO = 1;\n+    public static final int STEP_OUT = 2;\n+    public static final int GO = 3;\n+    public static final int BREAK = 4;\n+    public static final int EXIT = 5;\n+\n+    // Constants for the DimIProxy interface implementation class.\n+    private static final int IPROXY_DEBUG = 0;\n+    private static final int IPROXY_LISTEN = 1;\n+    private static final int IPROXY_COMPILE_SCRIPT = 2;\n+    private static final int IPROXY_EVAL_SCRIPT = 3;\n+    private static final int IPROXY_STRING_IS_COMPILABLE = 4;\n+    private static final int IPROXY_OBJECT_TO_STRING = 5;\n+    private static final int IPROXY_OBJECT_PROPERTY = 6;\n+    private static final int IPROXY_OBJECT_IDS = 7;\n+\n+    /**\n+     * Interface to the debugger GUI.\n+     */\n+    private GuiCallback callback;\n+\n+    /**\n+     * Whether the debugger should break.\n+     */\n+    private boolean breakFlag;\n+\n+    /**\n+     * The ScopeProvider object that provides the scope in which to\n+     * evaluate script.\n+     */\n+    private ScopeProvider scopeProvider;\n+\n+    /**\n+     * The index of the current stack frame.\n+     */\n+    private int frameIndex = -1;\n+\n+    /**\n+     * Information about the current stack at the point of interruption.\n+     */\n+    private volatile ContextData interruptedContextData;\n+\n+    /**\n+     * The ContextFactory to listen to for debugging information.\n+     */\n+    private ContextFactory contextFactory;\n+\n+    /**\n+     * Synchronization object used to allow script evaluations to\n+     * happen when a thread is resumed.\n+     */\n+    private Object monitor = new Object();\n+\n+    /**\n+     * Synchronization object used to wait for valid\n+     * {@link #interruptedContextData}.\n+     */\n+    private Object eventThreadMonitor = new Object();\n+\n+    /**\n+     * The action to perform to end the interruption loop.\n+     */\n+    private volatile int returnValue = -1;\n+\n+    /**\n+     * Whether the debugger is inside the interruption loop.\n+     */\n+    private boolean insideInterruptLoop;\n+\n+    /**\n+     * The requested script string to be evaluated when the thread\n+     * has been resumed.\n+     */\n+    private String evalRequest;\n+\n+    /**\n+     * The stack frame in which to evaluate {@link #evalRequest}.\n+     */\n+    private StackFrame evalFrame;\n+\n+    /**\n+     * The result of evaluating {@link #evalRequest}.\n+     */\n+    private String evalResult;\n+\n+    /**\n+     * Whether the debugger should break when a script exception is thrown.\n+     */\n+    private boolean breakOnExceptions;\n+\n+    /**\n+     * Whether the debugger should break when a script function is entered.\n+     */\n+    private boolean breakOnEnter;\n+\n+    /**\n+     * Whether the debugger should break when a script function is returned\n+     * from.\n+     */\n+    private boolean breakOnReturn;\n+\n+    /**\n+     * Table mapping URLs to information about the script source.\n+     */\n+    private final Map<String,SourceInfo> urlToSourceInfo = \n+        Collections.synchronizedMap(new HashMap<String,SourceInfo>());\n+\n+    /**\n+     * Table mapping function names to information about the function.\n+     */\n+    private final Map<String,FunctionSource> functionNames =\n+        Collections.synchronizedMap(new HashMap<String,FunctionSource>());\n+\n+    /**\n+     * Table mapping functions to information about the function.\n+     */\n+    private final Map<DebuggableScript,FunctionSource> functionToSource =\n+        Collections.synchronizedMap(new HashMap<DebuggableScript,FunctionSource>());\n+\n+    /**\n+     * ContextFactory.Listener instance attached to {@link #contextFactory}.\n+     */\n+    private DimIProxy listener;\n+\n+    /**\n+     * Sets the GuiCallback object to use.\n+     */\n+    public void setGuiCallback(GuiCallback callback) {\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * Tells the debugger to break at the next opportunity.\n+     */\n+    public void setBreak() {\n+        this.breakFlag = true;\n+    }\n+\n+    /**\n+     * Sets the ScopeProvider to be used.\n+     */\n+    public void setScopeProvider(ScopeProvider scopeProvider) {\n+        this.scopeProvider = scopeProvider;\n+    }\n+\n+    /**\n+     * Switches context to the stack frame with the given index.\n+     */\n+    public void contextSwitch(int frameIndex) {\n+        this.frameIndex = frameIndex;\n+    }\n+\n+    /**\n+     * Sets whether the debugger should break on exceptions.\n+     */\n+    public void setBreakOnExceptions(boolean breakOnExceptions) {\n+        this.breakOnExceptions = breakOnExceptions;\n+    }\n+\n+    /**\n+     * Sets whether the debugger should break on function entering.\n+     */\n+    public void setBreakOnEnter(boolean breakOnEnter) {\n+        this.breakOnEnter = breakOnEnter;\n+    }\n+\n+    /**\n+     * Sets whether the debugger should break on function return.\n+     */\n+    public void setBreakOnReturn(boolean breakOnReturn) {\n+        this.breakOnReturn = breakOnReturn;\n+    }\n+\n+    /**\n+     * Attaches the debugger to the given ContextFactory.\n+     */\n+    public void attachTo(ContextFactory factory) {\n+        detach();\n+        this.contextFactory = factory;\n+        this.listener = new DimIProxy(this, IPROXY_LISTEN);\n+        factory.addListener(this.listener);\n+    }\n+\n+    /**\n+     * Detaches the debugger from the current ContextFactory.\n+     */\n+    public void detach() {\n+        if (listener != null) {\n+            contextFactory.removeListener(listener);\n+            contextFactory = null;\n+            listener = null;\n+        }\n+    }\n+\n+    /**\n+     * Releases resources associated with this debugger.\n+     */\n+    public void dispose() {\n+        detach();\n+    }\n+\n+    /**\n+     * Returns the FunctionSource object for the given script or function.\n+     */\n+    private FunctionSource getFunctionSource(DebuggableScript fnOrScript) {\n+        FunctionSource fsource = functionSource(fnOrScript);\n+        if (fsource == null) {\n+            String url = getNormalizedUrl(fnOrScript);\n+            SourceInfo si = sourceInfo(url);\n+            if (si == null) {\n+                if (!fnOrScript.isGeneratedScript()) {\n+                    // Not eval or Function, try to load it from URL\n+                    String source = loadSource(url);\n+                    if (source != null) {\n+                        DebuggableScript top = fnOrScript;\n+                        for (;;) {\n+                            DebuggableScript parent = top.getParent();\n+                            if (parent == null) {\n+                                break;\n+                            }\n+                            top = parent;\n+                        }\n+                        registerTopScript(top, source);\n+                        fsource = functionSource(fnOrScript);\n+                    }\n+                }\n+            }\n+        }\n+        return fsource;\n+    }\n+\n+    /**\n+     * Loads the script at the given URL.\n+     */\n+    private String loadSource(String sourceUrl) {\n+        String source = null;\n+        int hash = sourceUrl.indexOf('#');\n+        if (hash >= 0) {\n+            sourceUrl = sourceUrl.substring(0, hash);\n+        }\n+        try {\n+            InputStream is;\n+          openStream:\n+            {\n+                if (sourceUrl.indexOf(':') < 0) {\n+                    // Can be a file name\n+                    try {\n+                        if (sourceUrl.startsWith(\"~/\")) {\n+                            String home = SecurityUtilities.getSystemProperty(\"user.home\");\n+                            if (home != null) {\n+                                String pathFromHome = sourceUrl.substring(2);\n+                                File f = new File(new File(home), pathFromHome);\n+                                if (f.exists()) {\n+                                    is = new FileInputStream(f);\n+                                    break openStream;\n+                                }\n+                            }\n+                        }\n+                        File f = new File(sourceUrl);\n+                        if (f.exists()) {\n+                            is = new FileInputStream(f);\n+                            break openStream;\n+                        }\n+                    } catch (SecurityException ex) { }\n+                    // No existing file, assume missed http://\n+                    if (sourceUrl.startsWith(\"//\")) {\n+                        sourceUrl = \"http:\" + sourceUrl;\n+                    } else if (sourceUrl.startsWith(\"/\")) {\n+                        sourceUrl = \"http://127.0.0.1\" + sourceUrl;\n+                    } else {\n+                        sourceUrl = \"http://\" + sourceUrl;\n+                    }\n+                }\n+\n+                is = (new URL(sourceUrl)).openStream();\n+            }\n+\n+            try {\n+                source = Kit.readReader(new InputStreamReader(is));\n+            } finally {\n+                is.close();\n+            }\n+        } catch (IOException ex) {\n+            System.err.println\n+                (\"Failed to load source from \"+sourceUrl+\": \"+ ex);\n+        }\n+        return source;\n+    }\n+\n+    /**\n+     * Registers the given script as a top-level script in the debugger.\n+     */\n+    private void registerTopScript(DebuggableScript topScript, String source) {\n+        if (!topScript.isTopLevel()) {\n+            throw new IllegalArgumentException();\n+        }\n+        String url = getNormalizedUrl(topScript);\n+        DebuggableScript[] functions = getAllFunctions(topScript);\n+        final SourceInfo sourceInfo = new SourceInfo(source, functions, url);\n+\n+        synchronized (urlToSourceInfo) {\n+            SourceInfo old = urlToSourceInfo.get(url);\n+            if (old != null) {\n+                sourceInfo.copyBreakpointsFrom(old);\n+            }\n+            urlToSourceInfo.put(url, sourceInfo);\n+            for (int i = 0; i != sourceInfo.functionSourcesTop(); ++i) {\n+                FunctionSource fsource = sourceInfo.functionSource(i);\n+                String name = fsource.name();\n+                if (name.length() != 0) {\n+                    functionNames.put(name, fsource);\n+                }\n+            }\n+        }\n+\n+        synchronized (functionToSource) {\n+            for (int i = 0; i != functions.length; ++i) {\n+                FunctionSource fsource = sourceInfo.functionSource(i);\n+                functionToSource.put(functions[i], fsource);\n+            }\n+        }\n+\n+        callback.updateSourceText(sourceInfo);\n+    }\n+\n+    /**\n+     * Returns the FunctionSource object for the given function or script.\n+     */\n+    private FunctionSource functionSource(DebuggableScript fnOrScript) {\n+        return functionToSource.get(fnOrScript);\n+    }\n+\n+    /**\n+     * Returns an array of all function names.\n+     */\n+    public String[] functionNames() {\n+        synchronized (urlToSourceInfo) {\n+            return functionNames.keySet().toArray(new String[functionNames.size()]);\n+        }\n+    }\n+\n+    /**\n+     * Returns the FunctionSource object for the function with the given name.\n+     */\n+    public FunctionSource functionSourceByName(String functionName) {\n+        return functionNames.get(functionName);\n+    }\n+\n+    /**\n+     * Returns the SourceInfo object for the given URL.\n+     */\n+    public SourceInfo sourceInfo(String url) {\n+        return urlToSourceInfo.get(url);\n+    }\n+\n+    /**\n+     * Returns the source URL for the given script or function.\n+     */\n+    private String getNormalizedUrl(DebuggableScript fnOrScript) {\n+        String url = fnOrScript.getSourceName();\n+        if (url == null) { url = \"<stdin>\"; }\n+        else {\n+            // Not to produce window for eval from different lines,\n+            // strip line numbers, i.e. replace all #[0-9]+\\(eval\\) by\n+            // (eval)\n+            // Option: similar teatment for Function?\n+            char evalSeparator = '#';\n+            StringBuffer sb = null;\n+            int urlLength = url.length();\n+            int cursor = 0;\n+            for (;;) {\n+                int searchStart = url.indexOf(evalSeparator, cursor);\n+                if (searchStart < 0) {\n+                    break;\n+                }\n+                String replace = null;\n+                int i = searchStart + 1;\n+                while (i != urlLength) {\n+                    int c = url.charAt(i);\n+                    if (!('0' <= c && c <= '9')) {\n+                        break;\n+                    }\n+                    ++i;\n+                }\n+                if (i != searchStart + 1) {\n+                    // i points after #[0-9]+\n+                    if (\"(eval)\".regionMatches(0, url, i, 6)) {\n+                        cursor = i + 6;\n+                        replace = \"(eval)\";\n+                    }\n+                }\n+                if (replace == null) {\n+                    break;\n+                }\n+                if (sb == null) {\n+                    sb = new StringBuffer();\n+                    sb.append(url.substring(0, searchStart));\n+                }\n+                sb.append(replace);\n+            }\n+            if (sb != null) {\n+                if (cursor != urlLength) {\n+                    sb.append(url.substring(cursor));\n+                }\n+                url = sb.toString();\n+            }\n+        }\n+        return url;\n+    }\n+\n+    /**\n+     * Returns an array of all functions in the given script.\n+     */\n+    private static DebuggableScript[] getAllFunctions\n+            (DebuggableScript function) {\n+        ObjArray functions = new ObjArray();\n+        collectFunctions_r(function, functions);\n+        DebuggableScript[] result = new DebuggableScript[functions.size()];\n+        functions.toArray(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Helper function for {@link #getAllFunctions(DebuggableScript)}.\n+     */\n+    private static void collectFunctions_r(DebuggableScript function,\n+                                             ObjArray array) {\n+        array.add(function);\n+        for (int i = 0; i != function.getFunctionCount(); ++i) {\n+            collectFunctions_r(function.getFunction(i), array);\n+        }\n+    }\n+\n+    /**\n+     * Clears all breakpoints.\n+     */\n+    public void clearAllBreakpoints() {\n+        for (SourceInfo si: urlToSourceInfo.values()) {\n+            si.removeAllBreakpoints();\n+        }\n+    }\n+\n+    /**\n+     * Called when a breakpoint has been hit.\n+     */\n+    private void handleBreakpointHit(StackFrame frame, Context cx) {\n+        breakFlag = false;\n+        interrupted(cx, frame, null);\n+    }\n+\n+    /**\n+     * Called when a script exception has been thrown.\n+     */\n+    private void handleExceptionThrown(Context cx, Throwable ex,\n+                                         StackFrame frame) {\n+        if (breakOnExceptions) {\n+            ContextData cd = frame.contextData();\n+            if (cd.lastProcessedException != ex) {\n+                interrupted(cx, frame, ex);\n+                cd.lastProcessedException = ex;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the current ContextData object.\n+     */\n+    public ContextData currentContextData() {\n+        return interruptedContextData;\n+    }\n+\n+    /**\n+     * Sets the action to perform to end interruption.\n+     */\n+    public void setReturnValue(int returnValue) {\n+        synchronized (monitor) {\n+            this.returnValue = returnValue;\n+            monitor.notify();\n+        }\n+    }\n+\n+    /**\n+     * Resumes execution of script.\n+     */\n+    public void go() {\n+        synchronized (monitor) {\n+            this.returnValue = GO;\n+            monitor.notifyAll();\n+        }\n+    }\n+\n+    /**\n+     * Evaluates the given script.\n+     */\n+    public String eval(String expr) {\n+        String result = \"undefined\";\n+        if (expr == null) {\n+            return result;\n+        }\n+        ContextData contextData = currentContextData();\n+        if (contextData == null || frameIndex >= contextData.frameCount()) {\n+            return result;\n+        }\n+        StackFrame frame = contextData.getFrame(frameIndex);\n+        if (contextData.eventThreadFlag) {\n+            Context cx = Context.getCurrentContext();\n+            result = do_eval(cx, frame, expr);\n+        } else {\n+            synchronized (monitor) {\n+                if (insideInterruptLoop) {\n+                    evalRequest = expr;\n+                    evalFrame = frame;\n+                    monitor.notify();\n+                    do {\n+                        try {\n+                            monitor.wait();\n+                        } catch (InterruptedException exc) {\n+                            Thread.currentThread().interrupt();\n+                            break;\n+                        }\n+                    } while (evalRequest != null);\n+                    result = evalResult;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Compiles the given script.\n+     */\n+    public void compileScript(String url, String text) {\n+        DimIProxy action = new DimIProxy(this, IPROXY_COMPILE_SCRIPT);\n+        action.url = url;\n+        action.text = text;\n+        action.withContext();\n+    }\n+\n+    /**\n+     * Evaluates the given script.\n+     */\n+    public void evalScript(final String url, final String text) {\n+        DimIProxy action = new DimIProxy(this, IPROXY_EVAL_SCRIPT);\n+        action.url = url;\n+        action.text = text;\n+        action.withContext();\n+    }\n+\n+    /**\n+     * Converts the given script object to a string.\n+     */\n+    public String objectToString(Object object) {\n+        DimIProxy action = new DimIProxy(this, IPROXY_OBJECT_TO_STRING);\n+        action.object = object;\n+        action.withContext();\n+        return action.stringResult;\n+    }\n+\n+    /**\n+     * Returns whether the given string is syntactically valid script.\n+     */\n+    public boolean stringIsCompilableUnit(String str) {\n+        DimIProxy action = new DimIProxy(this, IPROXY_STRING_IS_COMPILABLE);\n+        action.text = str;\n+        action.withContext();\n+        return action.booleanResult;\n+    }\n+\n+    /**\n+     * Returns the value of a property on the given script object.\n+     */\n+    public Object getObjectProperty(Object object, Object id) {\n+        DimIProxy action = new DimIProxy(this, IPROXY_OBJECT_PROPERTY);\n+        action.object = object;\n+        action.id = id;\n+        action.withContext();\n+        return action.objectResult;\n+    }\n+\n+    /**\n+     * Returns an array of the property names on the given script object.\n+     */\n+    public Object[] getObjectIds(Object object) {\n+        DimIProxy action = new DimIProxy(this, IPROXY_OBJECT_IDS);\n+        action.object = object;\n+        action.withContext();\n+        return action.objectArrayResult;\n+    }\n+\n+    /**\n+     * Returns the value of a property on the given script object.\n+     */\n+    private Object getObjectPropertyImpl(Context cx, Object object,\n+                                           Object id) {\n+        Scriptable scriptable = (Scriptable)object;\n+        Object result;\n+        if (id instanceof String) {\n+            String name = (String)id;\n+            if (name.equals(\"this\")) {\n+                result = scriptable;\n+            } else if (name.equals(\"__proto__\")) {\n+                result = scriptable.getPrototype();\n+            } else if (name.equals(\"__parent__\")) {\n+                result = scriptable.getParentScope();\n+            } else {\n+                result = ScriptableObject.getProperty(scriptable, name);\n+                if (result == ScriptableObject.NOT_FOUND) {\n+                    result = Undefined.instance;\n+                }\n+            }\n+        } else {\n+            int index = ((Integer)id).intValue();\n+            result = ScriptableObject.getProperty(scriptable, index);\n+            if (result == ScriptableObject.NOT_FOUND) {\n+                result = Undefined.instance;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns an array of the property names on the given script object.\n+     */\n+    private Object[] getObjectIdsImpl(Context cx, Object object) {\n+        if (!(object instanceof Scriptable) || object == Undefined.instance) {\n+            return Context.emptyArgs;\n+        }\n+\n+        Object[] ids;\n+        Scriptable scriptable = (Scriptable)object;\n+        if (scriptable instanceof DebuggableObject) {\n+            ids = ((DebuggableObject)scriptable).getAllIds();\n+        } else {\n+            ids = scriptable.getIds();\n+        }\n+\n+        Scriptable proto = scriptable.getPrototype();\n+        Scriptable parent = scriptable.getParentScope();\n+        int extra = 0;\n+        if (proto != null) {\n+            ++extra;\n+        }\n+        if (parent != null) {\n+            ++extra;\n+        }\n+        if (extra != 0) {\n+            Object[] tmp = new Object[extra + ids.length];\n+            System.arraycopy(ids, 0, tmp, extra, ids.length);\n+            ids = tmp;\n+            extra = 0;\n+            if (proto != null) {\n+                ids[extra++] = \"__proto__\";\n+            }\n+            if (parent != null) {\n+                ids[extra++] = \"__parent__\";\n+            }\n+        }\n+\n+        return ids;\n+    }\n+\n+    /**\n+     * Interrupts script execution.\n+     */\n+    private void interrupted(Context cx, final StackFrame frame,\n+                               Throwable scriptException) {\n+        ContextData contextData = frame.contextData();\n+        boolean eventThreadFlag = callback.isGuiEventThread();\n+        contextData.eventThreadFlag = eventThreadFlag;\n+\n+        boolean recursiveEventThreadCall = false;\n+\n+interruptedCheck:\n+        synchronized (eventThreadMonitor) {\n+            if (eventThreadFlag) {\n+                if (interruptedContextData != null) {\n+                    recursiveEventThreadCall = true;\n+                    break interruptedCheck;\n+                }\n+            } else {\n+                while (interruptedContextData != null) {\n+                    try {\n+                        eventThreadMonitor.wait();\n+                    } catch (InterruptedException exc) {\n+                        return;\n+                    }\n+                }\n+            }\n+            interruptedContextData = contextData;\n+        }\n+\n+        if (recursiveEventThreadCall) {\n+            // XXX: For now the following is commented out as on Linux\n+            // too deep recursion of dispatchNextGuiEvent causes GUI lockout.\n+            // Note: it can make GUI unresponsive if long-running script\n+            // will be called on GUI thread while processing another interrupt\n+            if (false) {\n+               // Run event dispatch until gui sets a flag to exit the initial\n+               // call to interrupted.\n+                while (this.returnValue == -1) {\n+                    try {\n+                        callback.dispatchNextGuiEvent();\n+                    } catch (InterruptedException exc) {\n+                    }\n+                }\n+            }\n+            return;\n+        }\n+\n+        if (interruptedContextData == null) Kit.codeBug();\n+\n+        try {\n+            do {\n+                int frameCount = contextData.frameCount();\n+                this.frameIndex = frameCount -1;\n+\n+                final String threadTitle = Thread.currentThread().toString();\n+                final String alertMessage;\n+                if (scriptException == null) {\n+                    alertMessage = null;\n+                } else {\n+                    alertMessage = scriptException.toString();\n+                }\n+\n+                int returnValue = -1;\n+                if (!eventThreadFlag) {\n+                    synchronized (monitor) {\n+                        if (insideInterruptLoop) Kit.codeBug();\n+                        this.insideInterruptLoop = true;\n+                        this.evalRequest = null;\n+                        this.returnValue = -1;\n+                        callback.enterInterrupt(frame, threadTitle,\n+                                                alertMessage);\n+                        try {\n+                            for (;;) {\n+                                try {\n+                                    monitor.wait();\n+                                } catch (InterruptedException exc) {\n+                                    Thread.currentThread().interrupt();\n+                                    break;\n+                                }\n+                                if (evalRequest != null) {\n+                                    this.evalResult = null;\n+                                    try {\n+                                        evalResult = do_eval(cx, evalFrame,\n+                                                             evalRequest);\n+                                    } finally {\n+                                        evalRequest = null;\n+                                        evalFrame = null;\n+                                        monitor.notify();\n+                                    }\n+                                    continue;\n+                                }\n+                                if (this.returnValue != -1) {\n+                                    returnValue = this.returnValue;\n+                                    break;\n+                                }\n+                            }\n+                        } finally {\n+                            insideInterruptLoop = false;\n+                        }\n+                    }\n+                } else {\n+                    this.returnValue = -1;\n+                    callback.enterInterrupt(frame, threadTitle, alertMessage);\n+                    while (this.returnValue == -1) {\n+                        try {\n+                            callback.dispatchNextGuiEvent();\n+                        } catch (InterruptedException exc) {\n+                        }\n+                    }\n+                    returnValue = this.returnValue;\n+                }\n+                switch (returnValue) {\n+                case STEP_OVER:\n+                    contextData.breakNextLine = true;\n+                    contextData.stopAtFrameDepth = contextData.frameCount();\n+                    break;\n+                case STEP_INTO:\n+                    contextData.breakNextLine = true;\n+                    contextData.stopAtFrameDepth = -1;\n+                    break;\n+                case STEP_OUT:\n+                    if (contextData.frameCount() > 1) {\n+                        contextData.breakNextLine = true;\n+                        contextData.stopAtFrameDepth\n+                            = contextData.frameCount() -1;\n+                    }\n+                    break;\n+                }\n+            } while (false);\n+        } finally {\n+            synchronized (eventThreadMonitor) {\n+                interruptedContextData = null;\n+                eventThreadMonitor.notifyAll();\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluates script in the given stack frame.\n+     */\n+    private static String do_eval(Context cx, StackFrame frame, String expr) {\n+        String resultString;\n+        Debugger saved_debugger = cx.getDebugger();\n+        Object saved_data = cx.getDebuggerContextData();\n+        int saved_level = cx.getOptimizationLevel();\n+\n+        cx.setDebugger(null, null);\n+        cx.setOptimizationLevel(-1);\n+        cx.setGeneratingDebug(false);\n+        try {\n+            Callable script = (Callable)cx.compileString(expr, \"\", 0, null);\n+            Object result = script.call(cx, frame.scope, frame.thisObj,\n+                                        ScriptRuntime.emptyArgs);\n+            if (result == Undefined.instance) {\n+                resultString = \"\";\n+            } else {\n+                resultString = ScriptRuntime.toString(result);\n+            }\n+        } catch (Exception exc) {\n+            resultString = exc.getMessage();\n+        } finally {\n+            cx.setGeneratingDebug(true);\n+            cx.setOptimizationLevel(saved_level);\n+            cx.setDebugger(saved_debugger, saved_data);\n+        }\n+        if (resultString == null) {\n+            resultString = \"null\";\n+        }\n+        return resultString;\n+    }\n+\n+    /**\n+     * Proxy class to implement debug interfaces without bloat of class\n+     * files.\n+     */\n+    private static class DimIProxy\n+        implements ContextAction, ContextFactory.Listener, Debugger {\n+\n+        /**\n+         * The debugger.\n+         */\n+        private Dim dim;\n+\n+        /**\n+         * The interface implementation type.  One of the IPROXY_* constants\n+         * defined in {@link Dim}.\n+         */\n+        private int type;\n+\n+        /**\n+         * The URL origin of the script to compile or evaluate.\n+         */\n+        private String url;\n+\n+        /**\n+         * The text of the script to compile, evaluate or test for compilation.\n+         */\n+        private String text;\n+\n+        /**\n+         * The object to convert, get a property from or enumerate.\n+         */\n+        private Object object;\n+\n+        /**\n+         * The property to look up in {@link #object}.\n+         */\n+        private Object id;\n+\n+        /**\n+         * The boolean result of the action.\n+         */\n+        private boolean booleanResult;\n+\n+        /**\n+         * The String result of the action.\n+         */\n+        private String stringResult;\n+\n+        /**\n+         * The Object result of the action.\n+         */\n+        private Object objectResult;\n+\n+        /**\n+         * The Object[] result of the action.\n+         */\n+        private Object[] objectArrayResult;\n+\n+        /**\n+         * Creates a new DimIProxy.\n+         */\n+        private DimIProxy(Dim dim, int type) {\n+            this.dim = dim;\n+            this.type = type;\n+        }\n+\n+        // ContextAction\n+\n+        /**\n+         * Performs the action given by {@link #type}.\n+         */\n+        public Object run(Context cx) {\n+            switch (type) {\n+              case IPROXY_COMPILE_SCRIPT:\n+                cx.compileString(text, url, 1, null);\n+                break;\n+\n+              case IPROXY_EVAL_SCRIPT:\n+                {\n+                    Scriptable scope = null;\n+                    if (dim.scopeProvider != null) {\n+                        scope = dim.scopeProvider.getScope();\n+                    }\n+                    if (scope == null) {\n+                        scope = new ImporterTopLevel(cx);\n+                    }\n+                    cx.evaluateString(scope, text, url, 1, null);\n+                }\n+                break;\n+\n+              case IPROXY_STRING_IS_COMPILABLE:\n+                booleanResult = cx.stringIsCompilableUnit(text);\n+                break;\n+\n+              case IPROXY_OBJECT_TO_STRING:\n+                if (object == Undefined.instance) {\n+                    stringResult = \"undefined\";\n+                } else if (object == null) {\n+                    stringResult = \"null\";\n+                } else if (object instanceof NativeCall) {\n+                    stringResult = \"[object Call]\";\n+                } else {\n+                    stringResult = Context.toString(object);\n+                }\n+                break;\n+\n+              case IPROXY_OBJECT_PROPERTY:\n+                objectResult = dim.getObjectPropertyImpl(cx, object, id);\n+                break;\n+\n+              case IPROXY_OBJECT_IDS:\n+                objectArrayResult = dim.getObjectIdsImpl(cx, object);\n+                break;\n+\n+              default:\n+                throw Kit.codeBug();\n+            }\n+            return null;\n+        }\n+\n+        /**\n+         * Performs the action given by {@link #type} with the attached\n+         * {@link ContextFactory}.\n+         */\n+        private void withContext() {\n+            dim.contextFactory.call(this);\n+        }\n+\n+        // ContextFactory.Listener\n+\n+        /**\n+         * Called when a Context is created.\n+         */\n+        public void contextCreated(Context cx) {\n+            if (type != IPROXY_LISTEN) Kit.codeBug();\n+            ContextData contextData = new ContextData();\n+            Debugger debugger = new DimIProxy(dim, IPROXY_DEBUG);\n+            cx.setDebugger(debugger, contextData);\n+            cx.setGeneratingDebug(true);\n+            cx.setOptimizationLevel(-1);\n+        }\n+\n+        /**\n+         * Called when a Context is destroyed.\n+         */\n+        public void contextReleased(Context cx) {\n+            if (type != IPROXY_LISTEN) Kit.codeBug();\n+        }\n+\n+        // Debugger\n+\n+        /**\n+         * Returns a StackFrame for the given function or script.\n+         */\n+        public DebugFrame getFrame(Context cx, DebuggableScript fnOrScript) {\n+            if (type != IPROXY_DEBUG) Kit.codeBug();\n+\n+            FunctionSource item = dim.getFunctionSource(fnOrScript);\n+            if (item == null) {\n+                // Can not debug if source is not available\n+                return null;\n+            }\n+            return new StackFrame(cx, dim, item);\n+        }\n+\n+        /**\n+         * Called when compilation is finished.\n+         */\n+        public void handleCompilationDone(Context cx,\n+                                          DebuggableScript fnOrScript,\n+                                          String source) {\n+            if (type != IPROXY_DEBUG) Kit.codeBug();\n+\n+            if (!fnOrScript.isTopLevel()) {\n+                return;\n+            }\n+            dim.registerTopScript(fnOrScript, source);\n+        }\n+    }\n+\n+    /**\n+     * Class to store information about a stack.\n+     */\n+    public static class ContextData {\n+\n+        /**\n+         * The stack frames.\n+         */\n+        private ObjArray frameStack = new ObjArray();\n+\n+        /**\n+         * Whether the debugger should break at the next line in this context.\n+         */\n+        private boolean breakNextLine;\n+\n+        /**\n+         * The frame depth the debugger should stop at.  Used to implement\n+         * \"step over\" and \"step out\".\n+         */\n+        private int stopAtFrameDepth = -1;\n+\n+        /**\n+         * Whether this context is in the event thread.\n+         */\n+        private boolean eventThreadFlag;\n+\n+        /**\n+         * The last exception that was processed.\n+         */\n+        private Throwable lastProcessedException;\n+\n+        /**\n+         * Returns the ContextData for the given Context.\n+         */\n+        public static ContextData get(Context cx) {\n+            return (ContextData) cx.getDebuggerContextData();\n+        }\n+\n+        /**\n+         * Returns the number of stack frames.\n+         */\n+        public int frameCount() {\n+            return frameStack.size();\n+        }\n+\n+        /**\n+         * Returns the stack frame with the given index.\n+         */\n+        public StackFrame getFrame(int frameNumber) {\n+            int num = frameStack.size() - frameNumber - 1;\n+            return (StackFrame) frameStack.get(num);\n+        }\n+\n+        /**\n+         * Pushes a stack frame on to the stack.\n+         */\n+        private void pushFrame(StackFrame frame) {\n+            frameStack.push(frame);\n+        }\n+\n+        /**\n+         * Pops a stack frame from the stack.\n+         */\n+        private void popFrame() {\n+            frameStack.pop();\n+        }\n+    }\n+\n+    /**\n+     * Object to represent one stack frame.\n+     */\n+    public static class StackFrame implements DebugFrame {\n+\n+        /**\n+         * The debugger.\n+         */\n+        private Dim dim;\n+\n+        /**\n+         * The ContextData for the Context being debugged.\n+         */\n+        private ContextData contextData;\n+\n+        /**\n+         * The scope.\n+         */\n+        private Scriptable scope;\n+\n+        /**\n+         * The 'this' object.\n+         */\n+        private Scriptable thisObj;\n+\n+        /**\n+         * Information about the function.\n+         */\n+        private FunctionSource fsource;\n+\n+        /**\n+         * Array of breakpoint state for each source line.\n+         */\n+        private boolean[] breakpoints;\n+\n+        /**\n+         * Current line number.\n+         */\n+        private int lineNumber;\n+\n+        /**\n+         * Creates a new StackFrame.\n+         */\n+        private StackFrame(Context cx, Dim dim, FunctionSource fsource) {\n+            this.dim = dim;\n+            this.contextData = ContextData.get(cx);\n+            this.fsource = fsource;\n+            this.breakpoints = fsource.sourceInfo().breakpoints;\n+            this.lineNumber = fsource.firstLine();\n+        }\n+\n+        /**\n+         * Called when the stack frame is entered.\n+         */\n+        public void onEnter(Context cx, Scriptable scope,\n+                            Scriptable thisObj, Object[] args) {\n+            contextData.pushFrame(this);\n+            this.scope = scope;\n+            this.thisObj = thisObj;\n+            if (dim.breakOnEnter) {\n+                dim.handleBreakpointHit(this, cx);\n+            }\n+        }\n+\n+        /**\n+         * Called when the current position has changed.\n+         */\n+        public void onLineChange(Context cx, int lineno) {\n+            this.lineNumber = lineno;\n+\n+            if (!breakpoints[lineno] && !dim.breakFlag) {\n+                boolean lineBreak = contextData.breakNextLine;\n+                if (lineBreak && contextData.stopAtFrameDepth >= 0) {\n+                    lineBreak = (contextData.frameCount()\n+                                 <= contextData.stopAtFrameDepth);\n+                }\n+                if (!lineBreak) {\n+                    return;\n+                }\n+                contextData.stopAtFrameDepth = -1;\n+                contextData.breakNextLine = false;\n+            }\n+\n+            dim.handleBreakpointHit(this, cx);\n+        }\n+\n+        /**\n+         * Called when an exception has been thrown.\n+         */\n+        public void onExceptionThrown(Context cx, Throwable exception) {\n+            dim.handleExceptionThrown(cx, exception, this);\n+        }\n+\n+        /**\n+         * Called when the stack frame has been left.\n+         */\n+        public void onExit(Context cx, boolean byThrow,\n+                           Object resultOrException) {\n+            if (dim.breakOnReturn && !byThrow) {\n+                dim.handleBreakpointHit(this, cx);\n+            }\n+            contextData.popFrame();\n+        }\n+\n+        /**\n+         * Called when a 'debugger' statement is executed.\n+         */\n+        public void onDebuggerStatement(Context cx) {\n+            dim.handleBreakpointHit(this, cx);\n+        }\n+\n+        /**\n+         * Returns the SourceInfo object for the function.\n+         */\n+        public SourceInfo sourceInfo() {\n+            return fsource.sourceInfo();\n+        }\n+\n+        /**\n+         * Returns the ContextData object for the Context.\n+         */\n+        public ContextData contextData() {\n+            return contextData;\n+        }\n+\n+        /**\n+         * Returns the scope object for this frame.\n+         */\n+        public Object scope() {\n+            return scope;\n+        }\n+\n+        /**\n+         * Returns the 'this' object for this frame.\n+         */\n+        public Object thisObj() {\n+            return thisObj;\n+        }\n+\n+        /**\n+         * Returns the source URL.\n+         */\n+        public String getUrl() {\n+            return fsource.sourceInfo().url();\n+        }\n+\n+        /**\n+         * Returns the current line number.\n+         */\n+        public int getLineNumber() {\n+            return lineNumber;\n+        }\n+    }\n+\n+    /**\n+     * Class to store information about a function.\n+     */\n+    public static class FunctionSource {\n+\n+        /**\n+         * Information about the source of the function.\n+         */\n+        private SourceInfo sourceInfo;\n+\n+        /**\n+         * Line number of the first line of the function.\n+         */\n+        private int firstLine;\n+\n+        /**\n+         * The function name.\n+         */\n+        private String name;\n+\n+        /**\n+         * Creates a new FunctionSource.\n+         */\n+        private FunctionSource(SourceInfo sourceInfo, int firstLine,\n+                                 String name) {\n+            if (name == null) throw new IllegalArgumentException();\n+            this.sourceInfo = sourceInfo;\n+            this.firstLine = firstLine;\n+            this.name = name;\n+        }\n+\n+        /**\n+         * Returns the SourceInfo object that describes the source of the\n+         * function.\n+         */\n+        public SourceInfo sourceInfo() {\n+            return sourceInfo;\n+        }\n+\n+        /**\n+         * Returns the line number of the first line of the function.\n+         */\n+        public int firstLine() {\n+            return firstLine;\n+        }\n+\n+        /**\n+         * Returns the name of the function.\n+         */\n+        public String name() {\n+            return name;\n+        }\n+    }\n+\n+    /**\n+     * Class to store information about a script source.\n+     */\n+    public static class SourceInfo {\n+\n+        /**\n+         * An empty array of booleans.\n+         */\n+        private static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n+\n+        /**\n+         * The script.\n+         */\n+        private String source;\n+\n+        /**\n+         * The URL of the script.\n+         */\n+        private String url;\n+\n+        /**\n+         * Array indicating which lines can have breakpoints set.\n+         */\n+        private boolean[] breakableLines;\n+        \n+        /**\n+         * Array indicating whether a breakpoint is set on the line.\n+         */\n+        private boolean[] breakpoints;\n+\n+        /**\n+         * Array of FunctionSource objects for the functions in the script.\n+         */\n+        private FunctionSource[] functionSources;\n+\n+        /**\n+         * Creates a new SourceInfo object.\n+         */\n+        private SourceInfo(String source, DebuggableScript[] functions,\n+                             String normilizedUrl) {\n+            this.source = source;\n+            this.url = normilizedUrl;\n+\n+            int N = functions.length;\n+            int[][] lineArrays = new int[N][];\n+            for (int i = 0; i != N; ++i) {\n+                lineArrays[i] = functions[i].getLineNumbers();\n+            }\n+\n+            int minAll = 0, maxAll = -1;\n+            int[] firstLines = new int[N];\n+            for (int i = 0; i != N; ++i) {\n+                int[] lines = lineArrays[i];\n+                if (lines == null || lines.length == 0) {\n+                    firstLines[i] = -1;\n+                } else {\n+                    int min, max;\n+                    min = max = lines[0];\n+                    for (int j = 1; j != lines.length; ++j) {\n+                        int line = lines[j];\n+                        if (line < min) {\n+                            min = line;\n+                        } else if (line > max) {\n+                            max = line;\n+                        }\n+                    }\n+                    firstLines[i] = min;\n+                    if (minAll > maxAll) {\n+                        minAll = min;\n+                        maxAll = max;\n+                    } else {\n+                        if (min < minAll) {\n+                            minAll = min;\n+                        }\n+                        if (max > maxAll) {\n+                            maxAll = max;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (minAll > maxAll) {\n+                // No line information\n+                this.breakableLines = EMPTY_BOOLEAN_ARRAY;\n+                this.breakpoints = EMPTY_BOOLEAN_ARRAY;\n+            } else {\n+                if (minAll < 0) {\n+                    // Line numbers can not be negative\n+                    throw new IllegalStateException(String.valueOf(minAll));\n+                }\n+                int linesTop = maxAll + 1;\n+                this.breakableLines = new boolean[linesTop];\n+                this.breakpoints = new boolean[linesTop];\n+                for (int i = 0; i != N; ++i) {\n+                    int[] lines = lineArrays[i];\n+                    if (lines != null && lines.length != 0) {\n+                        for (int j = 0; j != lines.length; ++j) {\n+                            int line = lines[j];\n+                            this.breakableLines[line] = true;\n+                        }\n+                    }\n+                }\n+            }\n+            this.functionSources = new FunctionSource[N];\n+            for (int i = 0; i != N; ++i) {\n+                String name = functions[i].getFunctionName();\n+                if (name == null) {\n+                    name = \"\";\n+                }\n+                this.functionSources[i]\n+                    = new FunctionSource(this, firstLines[i], name);\n+            }\n+        }\n+\n+        /**\n+         * Returns the source text.\n+         */\n+        public String source() {\n+            return this.source;\n+        }\n+\n+        /**\n+         * Returns the script's origin URL.\n+         */\n+        public String url() {\n+            return this.url;\n+        }\n+\n+        /**\n+         * Returns the number of FunctionSource objects stored in this object.\n+         */\n+        public int functionSourcesTop() {\n+            return functionSources.length;\n+        }\n+\n+        /**\n+         * Returns the FunctionSource object with the given index.\n+         */\n+        public FunctionSource functionSource(int i) {\n+            return functionSources[i];\n+        }\n+\n+        /**\n+         * Copies the breakpoints from the given SourceInfo object into this\n+         * one.\n+         */\n+        private void copyBreakpointsFrom(SourceInfo old) {\n+            int end = old.breakpoints.length;\n+            if (end > this.breakpoints.length) {\n+                end = this.breakpoints.length;\n+            }\n+            for (int line = 0; line != end; ++line) {\n+                if (old.breakpoints[line]) {\n+                    this.breakpoints[line] = true;\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Returns whether the given line number can have a breakpoint set on\n+         * it.\n+         */\n+        public boolean breakableLine(int line) {\n+            return (line < this.breakableLines.length)\n+                   && this.breakableLines[line];\n+        }\n+\n+        /**\n+         * Returns whether there is a breakpoint set on the given line.\n+         */\n+        public boolean breakpoint(int line) {\n+            if (!breakableLine(line)) {\n+                throw new IllegalArgumentException(String.valueOf(line));\n+            }\n+            return line < this.breakpoints.length && this.breakpoints[line];\n+        }\n+\n+        /**\n+         * Sets or clears the breakpoint flag for the given line.\n+         */\n+        public boolean breakpoint(int line, boolean value) {\n+            if (!breakableLine(line)) {\n+                throw new IllegalArgumentException(String.valueOf(line));\n+            }\n+            boolean changed;\n+            synchronized (breakpoints) {\n+                if (breakpoints[line] != value) {\n+                    breakpoints[line] = value;\n+                    changed = true;\n+                } else {\n+                    changed = false;\n+                }\n+            }\n+            return changed;\n+        }\n+\n+        /**\n+         * Removes all breakpoints from the script.\n+         */\n+        public void removeAllBreakpoints() {\n+            synchronized (breakpoints) {\n+                for (int line = 0; line != breakpoints.length; ++line) {\n+                    breakpoints[line] = false;\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/debugger/GuiCallback.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov, igor@fastmail.fm\n+ *   Cameron McCormack\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+package org.mozilla.javascript.tools.debugger;\n+\n+/**\n+ * Interface for communication between the debugger and its GUI.  This\n+ * should be implemented by the GUI.\n+ */\n+public interface GuiCallback {\n+\n+    /**\n+     * Called when the source text of some script has been changed.\n+     */\n+    void updateSourceText(Dim.SourceInfo sourceInfo);\n+\n+    /**\n+     * Called when the interrupt loop has been entered.\n+     */\n+    void enterInterrupt(Dim.StackFrame lastFrame,\n+                        String threadTitle,\n+                        String alertMessage);\n+\n+    /**\n+     * Returns whether the current thread is the GUI's event thread.\n+     * This information is required to avoid blocking the event thread\n+     * from the debugger.\n+     */\n+    boolean isGuiEventThread();\n+\n+    /**\n+     * Processes the next GUI event.  This manual pumping of GUI events\n+     * is necessary when the GUI event thread itself has been stopped.\n+     */\n+    void dispatchNextGuiEvent() throws InterruptedException;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/debugger/Main.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino JavaScript Debugger code, released\n+ * November 21, 2000.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * SeeBeyond Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Matt Gould\n+ *   Christopher Oliver\n+ *   Cameron McCormack\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tools.debugger;\n+\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+\n+import javax.swing.JFrame;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.tools.shell.Global;\n+\n+/**\n+ * Rhino script debugger main class.  This class links together a\n+ * debugger object ({@link Dim}) and a debugger GUI object ({@link SwingGui}).\n+ */\n+public class Main {\n+\n+    /**\n+     * The debugger.\n+     */\n+    private Dim dim;\n+\n+    /**\n+     * The debugger frame.\n+     */\n+    private SwingGui debugGui;\n+\n+    /**\n+     * Creates a new Main.\n+     */\n+    public Main(String title) {\n+        dim = new Dim();\n+        debugGui = new SwingGui(dim, title);\n+    }\n+\n+    /**\n+     * Returns the debugger window {@link JFrame}.\n+     */\n+    public JFrame getDebugFrame() {\n+        return debugGui;\n+    }\n+\n+    /**\n+     * Breaks execution of the script.\n+     */\n+    public void doBreak() {\n+        dim.setBreak();\n+    }\n+\n+    /**\n+     * Sets whether execution should break when a script exception is thrown.\n+     */\n+    public void setBreakOnExceptions(boolean value) {\n+        dim.setBreakOnExceptions(value);\n+        debugGui.getMenubar().getBreakOnExceptions().setSelected(value);\n+    }\n+\n+    /**\n+     * Sets whether execution should break when a function is entered.\n+     */\n+    public void setBreakOnEnter(boolean value) {\n+        dim.setBreakOnEnter(value);\n+        debugGui.getMenubar().getBreakOnEnter().setSelected(value);\n+    }\n+\n+    /**\n+     * Sets whether execution should break when a function is left.\n+     */\n+    public void setBreakOnReturn(boolean value) {\n+        dim.setBreakOnReturn(value);\n+        debugGui.getMenubar().getBreakOnReturn().setSelected(value);\n+    }\n+\n+    /**\n+     * Removes all breakpoints.\n+     */\n+    public void clearAllBreakpoints() {\n+        dim.clearAllBreakpoints();\n+    }\n+\n+    /**\n+     * Resumes execution of the script.\n+     */\n+    public void go() {\n+        dim.go();\n+    }\n+\n+    /**\n+     * Sets the scope to be used for script evaluation.\n+     */\n+    public void setScope(Scriptable scope) {\n+        setScopeProvider(IProxy.newScopeProvider(scope));\n+    }\n+\n+    /**\n+     * Sets the {@link ScopeProvider} that provides a scope to be used\n+     * for script evaluation.\n+     */\n+    public void setScopeProvider(ScopeProvider p) {\n+        dim.setScopeProvider(p);\n+    }\n+\n+    /**\n+     * Assign a Runnable object that will be invoked when the user\n+     * selects \"Exit...\" or closes the Debugger main window.\n+     */\n+    public void setExitAction(Runnable r) {\n+        debugGui.setExitAction(r);\n+    }\n+\n+    /**\n+     * Returns an {@link InputStream} for stdin from the debugger's internal\n+     * Console window.\n+     */\n+    public InputStream getIn() {\n+        return debugGui.getConsole().getIn();\n+    }\n+\n+    /**\n+     * Returns a {@link PrintStream} for stdout to the debugger's internal\n+     * Console window.\n+     */\n+    public PrintStream getOut() {\n+        return debugGui.getConsole().getOut();\n+    }\n+\n+    /**\n+     * Returns a {@link PrintStream} for stderr in the Debugger's internal\n+     * Console window.\n+     */\n+    public PrintStream getErr() {\n+        return debugGui.getConsole().getErr();\n+    }\n+\n+    /**\n+     * Packs the debugger GUI frame.\n+     */\n+    public void pack() {\n+        debugGui.pack();\n+    }\n+\n+    /**\n+     * Sets the debugger GUI frame dimensions.\n+     */\n+    public void setSize(int w, int h) {\n+        debugGui.setSize(w, h);\n+    }\n+\n+    /**\n+     * Sets the visibility of the debugger GUI frame.\n+     */\n+    public void setVisible(boolean flag) {\n+        debugGui.setVisible(flag);\n+    }\n+\n+    /**\n+     * Returns whether the debugger GUI frame is visible.\n+     */\n+    public boolean isVisible() {\n+        return debugGui.isVisible();\n+    }\n+\n+    /**\n+     * Frees any resources held by the debugger.\n+     */\n+    public void dispose() {\n+        clearAllBreakpoints();\n+        dim.go();\n+        debugGui.dispose();\n+        dim = null;\n+    }\n+\n+    /**\n+     * Attaches the debugger to the given {@link ContextFactory}.\n+     */\n+    public void attachTo(ContextFactory factory) {\n+        dim.attachTo(factory);\n+    }\n+\n+    /**\n+     * Detaches from the current {@link ContextFactory}.\n+     */\n+    public void detach() {\n+        dim.detach();\n+    }\n+\n+    /**\n+     * Main entry point.  Creates a debugger attached to a Rhino\n+     * {@link org.mozilla.javascript.tools.shell.Main} shell session.\n+     */\n+    public static void main(String[] args) {\n+        Main main = new Main(\"Rhino JavaScript Debugger\");\n+        main.doBreak();\n+        main.setExitAction(new IProxy(IProxy.EXIT_ACTION));\n+\n+        System.setIn(main.getIn());\n+        System.setOut(main.getOut());\n+        System.setErr(main.getErr());\n+\n+        Global global = org.mozilla.javascript.tools.shell.Main.getGlobal();\n+        global.setIn(main.getIn());\n+        global.setOut(main.getOut());\n+        global.setErr(main.getErr());\n+\n+        main.attachTo(\n+            org.mozilla.javascript.tools.shell.Main.shellContextFactory);\n+\n+        main.setScope(global);\n+\n+        main.pack();\n+        main.setSize(600, 460);\n+        main.setVisible(true);\n+\n+        org.mozilla.javascript.tools.shell.Main.exec(args);\n+    }\n+\n+    /**\n+     * Entry point for embedded applications.  This method attaches\n+     * to the global {@link ContextFactory} with a scope of a newly\n+     * created {@link Global} object.  No I/O redirection is performed\n+     * as with {@link #main(String[])}.\n+     */\n+    public static void mainEmbedded(String title) {\n+        ContextFactory factory = ContextFactory.getGlobal();\n+        Global global = new Global();\n+        global.init(factory);\n+        mainEmbedded(factory, global, title);\n+    }\n+\n+    /**\n+     * Entry point for embedded applications.  This method attaches\n+     * to the given {@link ContextFactory} with the given scope.  No\n+     * I/O redirection is performed as with {@link #main(String[])}.\n+     */\n+    public static void mainEmbedded(ContextFactory factory,\n+                                    Scriptable scope,\n+                                    String title) {\n+        mainEmbeddedImpl(factory, scope, title);\n+    }\n+\n+    /**\n+     * Entry point for embedded applications.  This method attaches\n+     * to the given {@link ContextFactory} with the given scope.  No\n+     * I/O redirection is performed as with {@link #main(String[])}.\n+     */\n+    public static void mainEmbedded(ContextFactory factory,\n+                                    ScopeProvider scopeProvider,\n+                                    String title) {\n+        mainEmbeddedImpl(factory, scopeProvider, title);\n+    }\n+\n+    /**\n+     * Helper method for {@link #mainEmbedded(String)}, etc.\n+     */\n+    private static void mainEmbeddedImpl(ContextFactory factory,\n+                                         Object scopeProvider,\n+                                         String title) {\n+        if (title == null) {\n+            title = \"Rhino JavaScript Debugger (embedded usage)\";\n+        }\n+        Main main = new Main(title);\n+        main.doBreak();\n+        main.setExitAction(new IProxy(IProxy.EXIT_ACTION));\n+\n+        main.attachTo(factory);\n+        if (scopeProvider instanceof ScopeProvider) {\n+            main.setScopeProvider((ScopeProvider)scopeProvider);\n+        } else {\n+            Scriptable scope = (Scriptable)scopeProvider;\n+            if (scope instanceof Global) {\n+                Global global = (Global)scope;\n+                global.setIn(main.getIn());\n+                global.setOut(main.getOut());\n+                global.setErr(main.getErr());\n+            }\n+            main.setScope(scope);\n+        }\n+\n+        main.pack();\n+        main.setSize(600, 460);\n+        main.setVisible(true);\n+    }\n+\n+    // Deprecated methods\n+\n+    /**\n+     * @deprecated Use {@link #setSize(int, int)} instead.\n+     */\n+    public void setSize(java.awt.Dimension dimension) {\n+        debugGui.setSize(dimension.width, dimension.height);\n+    }\n+\n+    /**\n+     * @deprecated\n+     * The method does nothing and is only present for compatibility.\n+     */\n+    public void setOptimizationLevel(int level) {\n+    }\n+\n+    /**\n+     * @deprecated\n+     * The method is only present for compatibility and should not be called.\n+     */\n+    public void contextEntered(Context cx) {\n+        throw new IllegalStateException();\n+    }\n+\n+    /**\n+     * @deprecated\n+     * The method is only present for compatibility and should not be called.\n+     */\n+    public void contextExited(Context cx) {\n+        throw new IllegalStateException();\n+    }\n+\n+    /**\n+     * @deprecated\n+     * The method is only present for compatibility and should not be called.\n+     */\n+    public void contextCreated(Context cx) {\n+        throw new IllegalStateException();\n+    }\n+\n+    /**\n+     * @deprecated\n+     * The method is only present for compatibility and should not be called.\n+     */\n+    public void contextReleased(Context cx)\n+    {\n+        throw new IllegalStateException();\n+    }\n+\n+    /**\n+     * Class to consolidate all internal implementations of interfaces\n+     * to avoid class generation bloat.\n+     */\n+    private static class IProxy implements Runnable, ScopeProvider {\n+\n+        // Constants for 'type'.\n+        public static final int EXIT_ACTION = 1;\n+        public static final int SCOPE_PROVIDER = 2;\n+\n+        /**\n+         * The type of interface.\n+         */\n+        private final int type;\n+\n+        /**\n+         * The scope object to expose when {@link #type} =\n+         * {@link #SCOPE_PROVIDER}.\n+         */\n+        private Scriptable scope;\n+\n+        /**\n+         * Creates a new IProxy.\n+         */\n+        public IProxy(int type) {\n+            this.type = type;\n+        }\n+\n+        /**\n+         * Creates a new IProxy that acts as a {@link ScopeProvider}.\n+         */\n+        public static ScopeProvider newScopeProvider(Scriptable scope) {\n+            IProxy scopeProvider = new IProxy(SCOPE_PROVIDER);\n+            scopeProvider.scope = scope;\n+            return scopeProvider;\n+        }\n+\n+        // ContextAction\n+\n+        /**\n+         * Exit action.\n+         */\n+        public void run() {\n+            if (type != EXIT_ACTION) Kit.codeBug();\n+            System.exit(0);\n+        }\n+\n+        // ScopeProvider\n+\n+        /**\n+         * Returns the scope for script evaluations.\n+         */\n+        public Scriptable getScope() {\n+            if (type != SCOPE_PROVIDER) Kit.codeBug();\n+            if (scope == null) Kit.codeBug();\n+            return scope;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/debugger/ScopeProvider.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino JavaScript Debugger code, released\n+ * November 21, 2000.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * See Beyond Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Christopher Oliver\n+ *   Cameron McCormack\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+package org.mozilla.javascript.tools.debugger;\n+\n+import org.mozilla.javascript.Scriptable;\n+\n+/**\n+ * Interface to provide a scope object for script evaluation to the debugger.\n+ */\n+public interface ScopeProvider {\n+\n+    /**\n+     * Returns the scope object to be used for script evaluation.\n+     */\n+    Scriptable getScope();\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/debugger/SwingGui.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino JavaScript Debugger code, released\n+ * November 21, 2000.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * SeeBeyond Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Matt Gould\n+ *   Cameron McCormack\n+ *   Christopher Oliver\n+ *   Hannes Wallnoefer\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+package org.mozilla.javascript.tools.debugger;\n+\n+import javax.swing.*;\n+import javax.swing.text.*;\n+import javax.swing.event.*;\n+import javax.swing.table.*;\n+import java.awt.EventQueue;\n+import java.awt.ActiveEvent;\n+import java.awt.AWTEvent;\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Event;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.GridLayout;\n+import java.awt.MenuComponent;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.event.*;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.EventListener;\n+import java.util.EventObject;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import java.io.*;\n+import javax.swing.tree.DefaultTreeCellRenderer;\n+import javax.swing.tree.TreePath;\n+import java.lang.reflect.Method;\n+\n+import org.mozilla.javascript.Kit;\n+import org.mozilla.javascript.SecurityUtilities;\n+\n+import org.mozilla.javascript.tools.shell.ConsoleTextArea;\n+\n+import org.mozilla.javascript.tools.debugger.treetable.JTreeTable;\n+import org.mozilla.javascript.tools.debugger.treetable.TreeTableModel;\n+import org.mozilla.javascript.tools.debugger.treetable.TreeTableModelAdapter;\n+\n+/**\n+ * GUI for the Rhino debugger.\n+ */\n+public class SwingGui extends JFrame implements GuiCallback {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = -8217029773456711621L;\n+\n+    /**\n+     * The debugger.\n+     */\n+    Dim dim;\n+\n+    /**\n+     * The action to run when the 'Exit' menu item is chosen or the\n+     * frame is closed.\n+     */\n+    private Runnable exitAction;\n+\n+    /**\n+     * The {@link JDesktopPane} that holds the script windows.\n+     */\n+    private JDesktopPane desk;\n+\n+    /**\n+     * The {@link JPanel} that shows information about the context.\n+     */\n+    private ContextWindow context;\n+\n+    /**\n+     * The menu bar.\n+     */\n+    private Menubar menubar;\n+\n+    /**\n+     * The tool bar.\n+     */\n+    private JToolBar toolBar;\n+\n+    /**\n+     * The console that displays I/O from the script.\n+     */\n+    private JSInternalConsole console;\n+\n+    /**\n+     * The {@link JSplitPane} that separates {@link #desk} from\n+     * {@link org.mozilla.javascript.Context}.\n+     */\n+    private JSplitPane split1;\n+\n+    /**\n+     * The status bar.\n+     */\n+    private JLabel statusBar;\n+\n+    /**\n+     * Hash table of internal frame names to the internal frames themselves.\n+     */\n+    private final Map<String,JFrame> toplevels = \n+        Collections.synchronizedMap(new HashMap<String,JFrame>());\n+\n+    /**\n+     * Hash table of script URLs to their internal frames.\n+     */\n+    private final Map<String,FileWindow> fileWindows = \n+        Collections.synchronizedMap(new HashMap<String,FileWindow>());\n+\n+\n+    /**\n+     * The {@link FileWindow} that last had the focus.\n+     */\n+    private FileWindow currentWindow;\n+\n+    /**\n+     * File choose dialog for loading a script.\n+     */\n+    JFileChooser dlg;\n+\n+    /**\n+     * The AWT EventQueue.  Used for manually pumping AWT events from\n+     * {@link #dispatchNextGuiEvent()}.\n+     */\n+    private EventQueue awtEventQueue;\n+\n+    /**\n+     * Creates a new SwingGui.\n+     */\n+    public SwingGui(Dim dim, String title) {\n+        super(title);\n+        this.dim = dim;\n+        init();\n+        dim.setGuiCallback(this);\n+    }\n+\n+    /**\n+     * Returns the Menubar of this debugger frame.\n+     */\n+    public Menubar getMenubar() {\n+        return menubar;\n+    }\n+\n+    /**\n+     * Sets the {@link Runnable} that will be run when the \"Exit\" menu\n+     * item is chosen.\n+     */\n+    public void setExitAction(Runnable r) {\n+        exitAction = r;\n+    }\n+\n+    /**\n+     * Returns the debugger console component.\n+     */\n+    public JSInternalConsole getConsole() {\n+        return console;\n+    }\n+\n+    /**\n+     * Sets the visibility of the debugger GUI.\n+     */\n+    @Override\n+    public void setVisible(boolean b) {\n+        super.setVisible(b);\n+        if (b) {\n+            // this needs to be done after the window is visible\n+            console.consoleTextArea.requestFocus();\n+            context.split.setDividerLocation(0.5);\n+            try {\n+                console.setMaximum(true);\n+                console.setSelected(true);\n+                console.show();\n+                console.consoleTextArea.requestFocus();\n+            } catch (Exception exc) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Records a new internal frame.\n+     */\n+    void addTopLevel(String key, JFrame frame) {\n+        if (frame != this) {\n+            toplevels.put(key, frame);\n+        }\n+    }\n+\n+    /**\n+     * Constructs the debugger GUI.\n+     */\n+    private void init() {\n+        menubar = new Menubar(this);\n+        setJMenuBar(menubar);\n+        toolBar = new JToolBar();\n+        JButton button;\n+        JButton breakButton, goButton, stepIntoButton,\n+            stepOverButton, stepOutButton;\n+        String [] toolTips = {\"Break (Pause)\",\n+                              \"Go (F5)\",\n+                              \"Step Into (F11)\",\n+                              \"Step Over (F7)\",\n+                              \"Step Out (F8)\"};\n+        int count = 0;\n+        button = breakButton = new JButton(\"Break\");\n+        button.setToolTipText(\"Break\");\n+        button.setActionCommand(\"Break\");\n+        button.addActionListener(menubar);\n+        button.setEnabled(true);\n+        button.setToolTipText(toolTips[count++]);\n+\n+        button = goButton = new JButton(\"Go\");\n+        button.setToolTipText(\"Go\");\n+        button.setActionCommand(\"Go\");\n+        button.addActionListener(menubar);\n+        button.setEnabled(false);\n+        button.setToolTipText(toolTips[count++]);\n+\n+        button = stepIntoButton = new JButton(\"Step Into\");\n+        button.setToolTipText(\"Step Into\");\n+        button.setActionCommand(\"Step Into\");\n+        button.addActionListener(menubar);\n+        button.setEnabled(false);\n+        button.setToolTipText(toolTips[count++]);\n+\n+        button = stepOverButton = new JButton(\"Step Over\");\n+        button.setToolTipText(\"Step Over\");\n+        button.setActionCommand(\"Step Over\");\n+        button.setEnabled(false);\n+        button.addActionListener(menubar);\n+        button.setToolTipText(toolTips[count++]);\n+\n+        button = stepOutButton = new JButton(\"Step Out\");\n+        button.setToolTipText(\"Step Out\");\n+        button.setActionCommand(\"Step Out\");\n+        button.setEnabled(false);\n+        button.addActionListener(menubar);\n+        button.setToolTipText(toolTips[count++]);\n+\n+        Dimension dim = stepOverButton.getPreferredSize();\n+        breakButton.setPreferredSize(dim);\n+        breakButton.setMinimumSize(dim);\n+        breakButton.setMaximumSize(dim);\n+        breakButton.setSize(dim);\n+        goButton.setPreferredSize(dim);\n+        goButton.setMinimumSize(dim);\n+        goButton.setMaximumSize(dim);\n+        stepIntoButton.setPreferredSize(dim);\n+        stepIntoButton.setMinimumSize(dim);\n+        stepIntoButton.setMaximumSize(dim);\n+        stepOverButton.setPreferredSize(dim);\n+        stepOverButton.setMinimumSize(dim);\n+        stepOverButton.setMaximumSize(dim);\n+        stepOutButton.setPreferredSize(dim);\n+        stepOutButton.setMinimumSize(dim);\n+        stepOutButton.setMaximumSize(dim);\n+        toolBar.add(breakButton);\n+        toolBar.add(goButton);\n+        toolBar.add(stepIntoButton);\n+        toolBar.add(stepOverButton);\n+        toolBar.add(stepOutButton);\n+\n+        JPanel contentPane = new JPanel();\n+        contentPane.setLayout(new BorderLayout());\n+        getContentPane().add(toolBar, BorderLayout.NORTH);\n+        getContentPane().add(contentPane, BorderLayout.CENTER);\n+        desk = new JDesktopPane();\n+        desk.setPreferredSize(new Dimension(600, 300));\n+        desk.setMinimumSize(new Dimension(150, 50));\n+        desk.add(console = new JSInternalConsole(\"JavaScript Console\"));\n+        context = new ContextWindow(this);\n+        context.setPreferredSize(new Dimension(600, 120));\n+        context.setMinimumSize(new Dimension(50, 50));\n+\n+        split1 = new JSplitPane(JSplitPane.VERTICAL_SPLIT, desk,\n+                                          context);\n+        split1.setOneTouchExpandable(true);\n+        SwingGui.setResizeWeight(split1, 0.66);\n+        contentPane.add(split1, BorderLayout.CENTER);\n+        statusBar = new JLabel();\n+        statusBar.setText(\"Thread: \");\n+        contentPane.add(statusBar, BorderLayout.SOUTH);\n+        dlg = new JFileChooser();\n+\n+        javax.swing.filechooser.FileFilter filter =\n+            new javax.swing.filechooser.FileFilter() {\n+                    @Override\n+                    public boolean accept(File f) {\n+                        if (f.isDirectory()) {\n+                            return true;\n+                        }\n+                        String n = f.getName();\n+                        int i = n.lastIndexOf('.');\n+                        if (i > 0 && i < n.length() -1) {\n+                            String ext = n.substring(i + 1).toLowerCase();\n+                            if (ext.equals(\"js\")) {\n+                                return true;\n+                            }\n+                        }\n+                        return false;\n+                    }\n+\n+                    @Override\n+                    public String getDescription() {\n+                        return \"JavaScript Files (*.js)\";\n+                    }\n+                };\n+        dlg.addChoosableFileFilter(filter);\n+        addWindowListener(new WindowAdapter() {\n+                @Override\n+                public void windowClosing(WindowEvent e) {\n+                    exit();\n+                }\n+            });\n+    }\n+\n+    /**\n+     * Runs the {@link #exitAction}.\n+     */\n+    private void exit() {\n+        if (exitAction != null) {\n+            SwingUtilities.invokeLater(exitAction);\n+        }\n+        dim.setReturnValue(Dim.EXIT);\n+    }\n+\n+    /**\n+     * Returns the {@link FileWindow} for the given URL.\n+     */\n+    FileWindow getFileWindow(String url) {\n+        if (url == null || url.equals(\"<stdin>\")) {\n+            return null;\n+        }\n+        return fileWindows.get(url);\n+    }\n+\n+    /**\n+     * Returns a short version of the given URL.\n+     */\n+    static String getShortName(String url) {\n+        int lastSlash = url.lastIndexOf('/');\n+        if (lastSlash < 0) {\n+            lastSlash = url.lastIndexOf('\\\\');\n+        }\n+        String shortName = url;\n+        if (lastSlash >= 0 && lastSlash + 1 < url.length()) {\n+            shortName = url.substring(lastSlash + 1);\n+        }\n+        return shortName;\n+    }\n+\n+    /**\n+     * Closes the given {@link FileWindow}.\n+     */\n+    void removeWindow(FileWindow w) {\n+        fileWindows.remove(w.getUrl());\n+        JMenu windowMenu = getWindowMenu();\n+        int count = windowMenu.getItemCount();\n+        JMenuItem lastItem = windowMenu.getItem(count -1);\n+        String name = getShortName(w.getUrl());\n+        for (int i = 5; i < count; i++) {\n+            JMenuItem item = windowMenu.getItem(i);\n+            if (item == null) continue; // separator\n+            String text = item.getText();\n+            //1 D:\\foo.js\n+            //2 D:\\bar.js\n+            int pos = text.indexOf(' ');\n+            if (text.substring(pos + 1).equals(name)) {\n+                windowMenu.remove(item);\n+                // Cascade    [0]\n+                // Tile       [1]\n+                // -------    [2]\n+                // Console    [3]\n+                // -------    [4]\n+                if (count == 6) {\n+                    // remove the final separator\n+                    windowMenu.remove(4);\n+                } else {\n+                    int j = i - 4;\n+                    for (;i < count -1; i++) {\n+                        JMenuItem thisItem = windowMenu.getItem(i);\n+                        if (thisItem != null) {\n+                            //1 D:\\foo.js\n+                            //2 D:\\bar.js\n+                            text = thisItem.getText();\n+                            if (text.equals(\"More Windows...\")) {\n+                                break;\n+                            } else {\n+                                pos = text.indexOf(' ');\n+                                thisItem.setText((char)('0' + j) + \" \" +\n+                                                 text.substring(pos + 1));\n+                                thisItem.setMnemonic('0' + j);\n+                                j++;\n+                            }\n+                        }\n+                    }\n+                    if (count - 6 == 0 && lastItem != item) {\n+                        if (lastItem.getText().equals(\"More Windows...\")) {\n+                            windowMenu.remove(lastItem);\n+                        }\n+                    }\n+                }\n+                break;\n+            }\n+        }\n+        windowMenu.revalidate();\n+    }\n+\n+    /**\n+     * Shows the line at which execution in the given stack frame just stopped.\n+     */\n+    void showStopLine(Dim.StackFrame frame) {\n+        String sourceName = frame.getUrl();\n+        if (sourceName == null || sourceName.equals(\"<stdin>\")) {\n+            if (console.isVisible()) {\n+                console.show();\n+            }\n+        } else {\n+            showFileWindow(sourceName, -1);\n+            int lineNumber = frame.getLineNumber();\n+            FileWindow w = getFileWindow(sourceName);\n+            if (w != null) {\n+                setFilePosition(w, lineNumber);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Shows a {@link FileWindow} for the given source, creating it\n+     * if it doesn't exist yet. if <code>lineNumber</code> is greater\n+     * than -1, it indicates the line number to select and display.\n+     * @param sourceUrl the source URL\n+     * @param lineNumber the line number to select, or -1\n+     */\n+    protected void showFileWindow(String sourceUrl, int lineNumber) {\n+        FileWindow w = getFileWindow(sourceUrl);\n+        if (w == null) {\n+            Dim.SourceInfo si = dim.sourceInfo(sourceUrl);\n+            createFileWindow(si, -1);\n+            w = getFileWindow(sourceUrl);\n+        }\n+        if (lineNumber > -1) {\n+            int start = w.getPosition(lineNumber-1);\n+            int end = w.getPosition(lineNumber)-1;\n+            w.textArea.select(start);\n+            w.textArea.setCaretPosition(start);\n+            w.textArea.moveCaretPosition(end);\n+        }\n+        try {\n+            if (w.isIcon()) {\n+                w.setIcon(false);\n+            }\n+            w.setVisible(true);\n+            w.moveToFront();\n+            w.setSelected(true);\n+            requestFocus();\n+            w.requestFocus();\n+            w.textArea.requestFocus();\n+        } catch (Exception exc) {\n+        }\n+    }\n+\n+    /**\n+     * Creates and shows a new {@link FileWindow} for the given source.\n+     */\n+    protected void createFileWindow(Dim.SourceInfo sourceInfo, int line) {\n+        boolean activate = true;\n+\n+        String url = sourceInfo.url();\n+        FileWindow w = new FileWindow(this, sourceInfo);\n+        fileWindows.put(url, w);\n+        if (line != -1) {\n+            if (currentWindow != null) {\n+                currentWindow.setPosition(-1);\n+            }\n+            try {\n+                w.setPosition(w.textArea.getLineStartOffset(line-1));\n+            } catch (BadLocationException exc) {\n+                try {\n+                    w.setPosition(w.textArea.getLineStartOffset(0));\n+                } catch (BadLocationException ee) {\n+                    w.setPosition(-1);\n+                }\n+            }\n+        }\n+        desk.add(w);\n+        if (line != -1) {\n+            currentWindow = w;\n+        }\n+        menubar.addFile(url);\n+        w.setVisible(true);\n+\n+        if (activate) {\n+            try {\n+                w.setMaximum(true);\n+                w.setSelected(true);\n+                w.moveToFront();\n+            } catch (Exception exc) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the source text for <code>sourceInfo</code>. This returns true\n+     * if a {@link FileWindow} for the given source exists and could be updated.\n+     * Otherwise, this does nothing and returns false.\n+     * @param sourceInfo the source info\n+     * @return true if a {@link FileWindow} for the given source exists\n+     *              and could be updated, false otherwise.\n+     */\n+    protected boolean updateFileWindow(Dim.SourceInfo sourceInfo) {\n+        String fileName = sourceInfo.url();\n+        FileWindow w = getFileWindow(fileName);\n+        if (w != null) {\n+            w.updateText(sourceInfo);\n+            w.show();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Moves the current position in the given {@link FileWindow} to the\n+     * given line.\n+     */\n+    private void setFilePosition(FileWindow w, int line) {\n+        boolean activate = true;\n+        JTextArea ta = w.textArea;\n+        try {\n+            if (line == -1) {\n+                w.setPosition(-1);\n+                if (currentWindow == w) {\n+                    currentWindow = null;\n+                }\n+            } else {\n+                int loc = ta.getLineStartOffset(line-1);\n+                if (currentWindow != null && currentWindow != w) {\n+                    currentWindow.setPosition(-1);\n+                }\n+                w.setPosition(loc);\n+                currentWindow = w;\n+            }\n+        } catch (BadLocationException exc) {\n+            // fix me\n+        }\n+        if (activate) {\n+            if (w.isIcon()) {\n+                desk.getDesktopManager().deiconifyFrame(w);\n+            }\n+            desk.getDesktopManager().activateFrame(w);\n+            try {\n+                w.show();\n+                w.toFront();  // required for correct frame layering (JDK 1.4.1)\n+                w.setSelected(true);\n+            } catch (Exception exc) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handles script interruption.\n+     */\n+    void enterInterruptImpl(Dim.StackFrame lastFrame,\n+                            String threadTitle, String alertMessage) {\n+        statusBar.setText(\"Thread: \" + threadTitle);\n+\n+        showStopLine(lastFrame);\n+\n+        if (alertMessage != null) {\n+            MessageDialogWrapper.showMessageDialog(this,\n+                                                   alertMessage,\n+                                                   \"Exception in Script\",\n+                                                   JOptionPane.ERROR_MESSAGE);\n+        }\n+\n+        updateEnabled(true);\n+\n+        Dim.ContextData contextData = lastFrame.contextData();\n+\n+        JComboBox ctx = context.context;\n+        List<String> toolTips = context.toolTips;\n+        context.disableUpdate();\n+        int frameCount = contextData.frameCount();\n+        ctx.removeAllItems();\n+        // workaround for JDK 1.4 bug that caches selected value even after\n+        // removeAllItems() is called\n+        ctx.setSelectedItem(null);\n+        toolTips.clear();\n+        for (int i = 0; i < frameCount; i++) {\n+            Dim.StackFrame frame = contextData.getFrame(i);\n+            String url = frame.getUrl();\n+            int lineNumber = frame.getLineNumber();\n+            String shortName = url;\n+            if (url.length() > 20) {\n+                shortName = \"...\" + url.substring(url.length() - 17);\n+            }\n+            String location = \"\\\"\" + shortName + \"\\\", line \" + lineNumber;\n+            ctx.insertItemAt(location, i);\n+            location = \"\\\"\" + url + \"\\\", line \" + lineNumber;\n+            toolTips.add(location);\n+        }\n+        context.enableUpdate();\n+        ctx.setSelectedIndex(0);\n+        ctx.setMinimumSize(new Dimension(50, ctx.getMinimumSize().height));\n+    }\n+\n+    /**\n+     * Returns the 'Window' menu.\n+     */\n+    private JMenu getWindowMenu() {\n+        return menubar.getMenu(3);\n+    }\n+\n+    /**\n+     * Displays a {@link JFileChooser} and returns the selected filename.\n+     */\n+    private String chooseFile(String title) {\n+        dlg.setDialogTitle(title);\n+        File CWD = null;\n+        String dir = SecurityUtilities.getSystemProperty(\"user.dir\");\n+        if (dir != null) {\n+            CWD = new File(dir);\n+        }\n+        if (CWD != null) {\n+            dlg.setCurrentDirectory(CWD);\n+        }\n+        int returnVal = dlg.showOpenDialog(this);\n+        if (returnVal == JFileChooser.APPROVE_OPTION) {\n+            try {\n+                String result = dlg.getSelectedFile().getCanonicalPath();\n+                CWD = dlg.getSelectedFile().getParentFile();\n+                Properties props = System.getProperties();\n+                props.put(\"user.dir\", CWD.getPath());\n+                System.setProperties(props);\n+                return result;\n+            } catch (IOException ignored) {\n+            } catch (SecurityException ignored) {\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the current selected internal frame.\n+     */\n+    private JInternalFrame getSelectedFrame() {\n+       JInternalFrame[] frames = desk.getAllFrames();\n+       for (int i = 0; i < frames.length; i++) {\n+           if (frames[i].isShowing()) {\n+               return frames[i];\n+           }\n+       }\n+       return frames[frames.length - 1];\n+    }\n+\n+    /**\n+     * Enables or disables the menu and tool bars with respect to the\n+     * state of script execution.\n+     */\n+    private void updateEnabled(boolean interrupted) {\n+        ((Menubar)getJMenuBar()).updateEnabled(interrupted);\n+        for (int ci = 0, cc = toolBar.getComponentCount(); ci < cc; ci++) {\n+            boolean enableButton;\n+            if (ci == 0) {\n+                // Break\n+                enableButton = !interrupted;\n+            } else {\n+                enableButton = interrupted;\n+            }\n+            toolBar.getComponent(ci).setEnabled(enableButton);\n+        }\n+        if (interrupted) {\n+            toolBar.setEnabled(true);\n+            // raise the debugger window\n+            int state = getExtendedState();\n+            if (state == Frame.ICONIFIED) {\n+                setExtendedState(Frame.NORMAL);\n+            }\n+            toFront();\n+            context.enable();\n+        } else {\n+            if (currentWindow != null) currentWindow.setPosition(-1);\n+            context.disable();\n+        }\n+    }\n+\n+    /**\n+     * Calls {@link JSplitPane#setResizeWeight} via reflection.\n+     * For compatibility, since JDK &lt; 1.3 does not have this method.\n+     */\n+    static void setResizeWeight(JSplitPane pane, double weight) {\n+        try {\n+            Method m = JSplitPane.class.getMethod(\"setResizeWeight\",\n+                                                  new Class[]{double.class});\n+            m.invoke(pane, new Object[]{new Double(weight)});\n+        } catch (NoSuchMethodException exc) {\n+        } catch (IllegalAccessException exc) {\n+        } catch (java.lang.reflect.InvocationTargetException exc) {\n+        }\n+    }\n+\n+    /**\n+     * Reads the file with the given name and returns its contents as a String.\n+     */\n+    private String readFile(String fileName) {\n+        String text;\n+        try {\n+            Reader r = new FileReader(fileName);\n+            try {\n+                text = Kit.readReader(r);\n+            } finally {\n+                r.close();\n+            }\n+        } catch (IOException ex) {\n+            MessageDialogWrapper.showMessageDialog(this,\n+                                                   ex.getMessage(),\n+                                                   \"Error reading \"+fileName,\n+                                                   JOptionPane.ERROR_MESSAGE);\n+            text = null;\n+        }\n+        return text;\n+    }\n+\n+    // GuiCallback\n+\n+    /**\n+     * Called when the source text for a script has been updated.\n+     */\n+    public void updateSourceText(Dim.SourceInfo sourceInfo) {\n+        RunProxy proxy = new RunProxy(this, RunProxy.UPDATE_SOURCE_TEXT);\n+        proxy.sourceInfo = sourceInfo;\n+        SwingUtilities.invokeLater(proxy);\n+    }\n+\n+    /**\n+     * Called when the interrupt loop has been entered.\n+     */\n+    public void enterInterrupt(Dim.StackFrame lastFrame,\n+                               String threadTitle,\n+                               String alertMessage) {\n+        if (SwingUtilities.isEventDispatchThread()) {\n+            enterInterruptImpl(lastFrame, threadTitle, alertMessage);\n+        } else {\n+            RunProxy proxy = new RunProxy(this, RunProxy.ENTER_INTERRUPT);\n+            proxy.lastFrame = lastFrame;\n+            proxy.threadTitle = threadTitle;\n+            proxy.alertMessage = alertMessage;\n+            SwingUtilities.invokeLater(proxy);\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the current thread is the GUI event thread.\n+     */\n+    public boolean isGuiEventThread() {\n+        return SwingUtilities.isEventDispatchThread();\n+    }\n+\n+    /**\n+     * Processes the next GUI event.\n+     */\n+    public void dispatchNextGuiEvent() throws InterruptedException {\n+        EventQueue queue = awtEventQueue;\n+        if (queue == null) {\n+            queue = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+            awtEventQueue = queue;\n+        }\n+        AWTEvent event = queue.getNextEvent();\n+        if (event instanceof ActiveEvent) {\n+            ((ActiveEvent)event).dispatch();\n+        } else {\n+            Object source = event.getSource();\n+            if (source instanceof Component) {\n+                Component comp = (Component)source;\n+                comp.dispatchEvent(event);\n+            } else if (source instanceof MenuComponent) {\n+                ((MenuComponent)source).dispatchEvent(event);\n+            }\n+        }\n+    }\n+\n+    // ActionListener\n+\n+    /**\n+     * Performs an action from the menu or toolbar.\n+     */\n+    public void actionPerformed(ActionEvent e) {\n+        String cmd = e.getActionCommand();\n+        int returnValue = -1;\n+        if (cmd.equals(\"Cut\") || cmd.equals(\"Copy\") || cmd.equals(\"Paste\")) {\n+            JInternalFrame f = getSelectedFrame();\n+            if (f != null && f instanceof ActionListener) {\n+                ((ActionListener)f).actionPerformed(e);\n+            }\n+        } else if (cmd.equals(\"Step Over\")) {\n+            returnValue = Dim.STEP_OVER;\n+        } else if (cmd.equals(\"Step Into\")) {\n+            returnValue = Dim.STEP_INTO;\n+        } else if (cmd.equals(\"Step Out\")) {\n+            returnValue = Dim.STEP_OUT;\n+        } else if (cmd.equals(\"Go\")) {\n+            returnValue = Dim.GO;\n+        } else if (cmd.equals(\"Break\")) {\n+            dim.setBreak();\n+        } else if (cmd.equals(\"Exit\")) {\n+            exit();\n+        } else if (cmd.equals(\"Open\")) {\n+            String fileName = chooseFile(\"Select a file to compile\");\n+            if (fileName != null) {\n+                String text = readFile(fileName);\n+                if (text != null) {\n+                    RunProxy proxy = new RunProxy(this, RunProxy.OPEN_FILE);\n+                    proxy.fileName = fileName;\n+                    proxy.text = text;\n+                    new Thread(proxy).start();\n+                }\n+            }\n+        } else if (cmd.equals(\"Load\")) {\n+            String fileName = chooseFile(\"Select a file to execute\");\n+            if (fileName != null) {\n+                String text = readFile(fileName);\n+                if (text != null) {\n+                    RunProxy proxy = new RunProxy(this, RunProxy.LOAD_FILE);\n+                    proxy.fileName = fileName;\n+                    proxy.text = text;\n+                    new Thread(proxy).start();\n+                }\n+            }\n+        } else if (cmd.equals(\"More Windows...\")) {\n+            MoreWindows dlg = new MoreWindows(this, fileWindows,\n+                                              \"Window\", \"Files\");\n+            dlg.showDialog(this);\n+        } else if (cmd.equals(\"Console\")) {\n+            if (console.isIcon()) {\n+                desk.getDesktopManager().deiconifyFrame(console);\n+            }\n+            console.show();\n+            desk.getDesktopManager().activateFrame(console);\n+            console.consoleTextArea.requestFocus();\n+        } else if (cmd.equals(\"Cut\")) {\n+        } else if (cmd.equals(\"Copy\")) {\n+        } else if (cmd.equals(\"Paste\")) {\n+        } else if (cmd.equals(\"Go to function...\")) {\n+            FindFunction dlg = new FindFunction(this, \"Go to function\",\n+                                                \"Function\");\n+            dlg.showDialog(this);\n+        } else if (cmd.equals(\"Tile\")) {\n+            JInternalFrame[] frames = desk.getAllFrames();\n+            int count = frames.length;\n+            int rows, cols;\n+            rows = cols = (int)Math.sqrt(count);\n+            if (rows*cols < count) {\n+                cols++;\n+                if (rows * cols < count) {\n+                    rows++;\n+                }\n+            }\n+            Dimension size = desk.getSize();\n+            int w = size.width/cols;\n+            int h = size.height/rows;\n+            int x = 0;\n+            int y = 0;\n+            for (int i = 0; i < rows; i++) {\n+                for (int j = 0; j < cols; j++) {\n+                    int index = (i*cols) + j;\n+                    if (index >= frames.length) {\n+                        break;\n+                    }\n+                    JInternalFrame f = frames[index];\n+                    try {\n+                        f.setIcon(false);\n+                        f.setMaximum(false);\n+                    } catch (Exception exc) {\n+                    }\n+                    desk.getDesktopManager().setBoundsForFrame(f, x, y,\n+                                                               w, h);\n+                    x += w;\n+                }\n+                y += h;\n+                x = 0;\n+            }\n+        } else if (cmd.equals(\"Cascade\")) {\n+            JInternalFrame[] frames = desk.getAllFrames();\n+            int count = frames.length;\n+            int x, y, w, h;\n+            x = y = 0;\n+            h = desk.getHeight();\n+            int d = h / count;\n+            if (d > 30) d = 30;\n+            for (int i = count -1; i >= 0; i--, x += d, y += d) {\n+                JInternalFrame f = frames[i];\n+                try {\n+                    f.setIcon(false);\n+                    f.setMaximum(false);\n+                } catch (Exception exc) {\n+                }\n+                Dimension dimen = f.getPreferredSize();\n+                w = dimen.width;\n+                h = dimen.height;\n+                desk.getDesktopManager().setBoundsForFrame(f, x, y, w, h);\n+            }\n+        } else {\n+            Object obj = getFileWindow(cmd);\n+            if (obj != null) {\n+                FileWindow w = (FileWindow)obj;\n+                try {\n+                    if (w.isIcon()) {\n+                        w.setIcon(false);\n+                    }\n+                    w.setVisible(true);\n+                    w.moveToFront();\n+                    w.setSelected(true);\n+                } catch (Exception exc) {\n+                }\n+            }\n+        }\n+        if (returnValue != -1) {\n+            updateEnabled(false);\n+            dim.setReturnValue(returnValue);\n+        }\n+    }\n+}\n+\n+/**\n+ * Helper class for showing a message dialog.\n+ */\n+class MessageDialogWrapper {\n+\n+    /**\n+     * Shows a message dialog, wrapping the <code>msg</code> at 60\n+     * columns.\n+     */\n+    public static void showMessageDialog(Component parent, String msg,\n+                                         String title, int flags) {\n+        if (msg.length() > 60) {\n+            StringBuffer buf = new StringBuffer();\n+            int len = msg.length();\n+            int j = 0;\n+            int i;\n+            for (i = 0; i < len; i++, j++) {\n+                char c = msg.charAt(i);\n+                buf.append(c);\n+                if (Character.isWhitespace(c)) {\n+                    int k;\n+                    for (k = i + 1; k < len; k++) {\n+                        if (Character.isWhitespace(msg.charAt(k))) {\n+                            break;\n+                        }\n+                    }\n+                    if (k < len) {\n+                        int nextWordLen = k - i;\n+                        if (j + nextWordLen > 60) {\n+                            buf.append('\\n');\n+                            j = 0;\n+                        }\n+                    }\n+                }\n+            }\n+            msg = buf.toString();\n+        }\n+        JOptionPane.showMessageDialog(parent, msg, title, flags);\n+    }\n+}\n+\n+/**\n+ * Extension of JTextArea for script evaluation input.\n+ */\n+class EvalTextArea\n+    extends JTextArea\n+    implements KeyListener, DocumentListener {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = -3918033649601064194L;\n+\n+    /**\n+     * The debugger GUI.\n+     */\n+    private SwingGui debugGui;\n+\n+    /**\n+     * History of expressions that have been evaluated\n+     */\n+    private List<String> history;\n+\n+    /**\n+     * Index of the selected history item.\n+     */\n+    private int historyIndex = -1;\n+\n+    /**\n+     * Position in the display where output should go.\n+     */\n+    private int outputMark;\n+\n+    /**\n+     * Creates a new EvalTextArea.\n+     */\n+    public EvalTextArea(SwingGui debugGui) {\n+        this.debugGui = debugGui;\n+        history = Collections.synchronizedList(new ArrayList<String>());\n+        Document doc = getDocument();\n+        doc.addDocumentListener(this);\n+        addKeyListener(this);\n+        setLineWrap(true);\n+        setFont(new Font(\"Monospaced\", 0, 12));\n+        append(\"% \");\n+        outputMark = doc.getLength();\n+    }\n+\n+    /**\n+     * Selects a subrange of the text.\n+     */\n+    @Override\n+    public void select(int start, int end) {\n+        //requestFocus();\n+        super.select(start, end);\n+    }\n+\n+    /**\n+     * Called when Enter is pressed.\n+     */\n+    private synchronized void returnPressed() {\n+        Document doc = getDocument();\n+        int len = doc.getLength();\n+        Segment segment = new Segment();\n+        try {\n+            doc.getText(outputMark, len - outputMark, segment);\n+        } catch (javax.swing.text.BadLocationException ignored) {\n+            ignored.printStackTrace();\n+        }\n+        String text = segment.toString();\n+        if (debugGui.dim.stringIsCompilableUnit(text)) {\n+            if (text.trim().length() > 0) {\n+               history.add(text);\n+               historyIndex = history.size();\n+            }\n+            append(\"\\n\");\n+            String result = debugGui.dim.eval(text);\n+            if (result.length() > 0) {\n+                append(result);\n+                append(\"\\n\");\n+            }\n+            append(\"% \");\n+            outputMark = doc.getLength();\n+        } else {\n+            append(\"\\n\");\n+        }\n+    }\n+\n+    /**\n+     * Writes output into the text area.\n+     */\n+    public synchronized void write(String str) {\n+        insert(str, outputMark);\n+        int len = str.length();\n+        outputMark += len;\n+        select(outputMark, outputMark);\n+    }\n+\n+    // KeyListener\n+\n+    /**\n+     * Called when a key is pressed.\n+     */\n+    public void keyPressed(KeyEvent e) {\n+        int code = e.getKeyCode();\n+        if (code == KeyEvent.VK_BACK_SPACE || code == KeyEvent.VK_LEFT) {\n+            if (outputMark == getCaretPosition()) {\n+                e.consume();\n+            }\n+        } else if (code == KeyEvent.VK_HOME) {\n+           int caretPos = getCaretPosition();\n+           if (caretPos == outputMark) {\n+               e.consume();\n+           } else if (caretPos > outputMark) {\n+               if (!e.isControlDown()) {\n+                   if (e.isShiftDown()) {\n+                       moveCaretPosition(outputMark);\n+                   } else {\n+                       setCaretPosition(outputMark);\n+                   }\n+                   e.consume();\n+               }\n+           }\n+        } else if (code == KeyEvent.VK_ENTER) {\n+            returnPressed();\n+            e.consume();\n+        } else if (code == KeyEvent.VK_UP) {\n+            historyIndex--;\n+            if (historyIndex >= 0) {\n+                if (historyIndex >= history.size()) {\n+                    historyIndex = history.size() -1;\n+                }\n+                if (historyIndex >= 0) {\n+                    String str = history.get(historyIndex);\n+                    int len = getDocument().getLength();\n+                    replaceRange(str, outputMark, len);\n+                    int caretPos = outputMark + str.length();\n+                    select(caretPos, caretPos);\n+                } else {\n+                    historyIndex++;\n+                }\n+            } else {\n+                historyIndex++;\n+            }\n+            e.consume();\n+        } else if (code == KeyEvent.VK_DOWN) {\n+            int caretPos = outputMark;\n+            if (history.size() > 0) {\n+                historyIndex++;\n+                if (historyIndex < 0) {historyIndex = 0;}\n+                int len = getDocument().getLength();\n+                if (historyIndex < history.size()) {\n+                    String str = history.get(historyIndex);\n+                    replaceRange(str, outputMark, len);\n+                    caretPos = outputMark + str.length();\n+                } else {\n+                    historyIndex = history.size();\n+                    replaceRange(\"\", outputMark, len);\n+                }\n+            }\n+            select(caretPos, caretPos);\n+            e.consume();\n+        }\n+    }\n+\n+    /**\n+     * Called when a key is typed.\n+     */\n+    public void keyTyped(KeyEvent e) {\n+        int keyChar = e.getKeyChar();\n+        if (keyChar == 0x8 /* KeyEvent.VK_BACK_SPACE */) {\n+            if (outputMark == getCaretPosition()) {\n+                e.consume();\n+            }\n+        } else if (getCaretPosition() < outputMark) {\n+            setCaretPosition(outputMark);\n+        }\n+    }\n+\n+    /**\n+     * Called when a key is released.\n+     */\n+    public synchronized void keyReleased(KeyEvent e) {\n+    }\n+\n+    // DocumentListener\n+\n+    /**\n+     * Called when text was inserted into the text area.\n+     */\n+    public synchronized void insertUpdate(DocumentEvent e) {\n+        int len = e.getLength();\n+        int off = e.getOffset();\n+        if (outputMark > off) {\n+            outputMark += len;\n+        }\n+    }\n+\n+    /**\n+     * Called when text was removed from the text area.\n+     */\n+    public synchronized void removeUpdate(DocumentEvent e) {\n+        int len = e.getLength();\n+        int off = e.getOffset();\n+        if (outputMark > off) {\n+            if (outputMark >= off + len) {\n+                outputMark -= len;\n+            } else {\n+                outputMark = off;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Attempts to clean up the damage done by {@link #updateUI()}.\n+     */\n+    public synchronized void postUpdateUI() {\n+        //requestFocus();\n+        setCaret(getCaret());\n+        select(outputMark, outputMark);\n+    }\n+\n+    /**\n+     * Called when text has changed in the text area.\n+     */\n+    public synchronized void changedUpdate(DocumentEvent e) {\n+    }\n+}\n+\n+/**\n+ * An internal frame for evaluating script.\n+ */\n+class EvalWindow extends JInternalFrame implements ActionListener {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = -2860585845212160176L;\n+\n+    /**\n+     * The text area into which expressions can be typed.\n+     */\n+    private EvalTextArea evalTextArea;\n+\n+    /**\n+     * Creates a new EvalWindow.\n+     */\n+    public EvalWindow(String name, SwingGui debugGui) {\n+        super(name, true, false, true, true);\n+        evalTextArea = new EvalTextArea(debugGui);\n+        evalTextArea.setRows(24);\n+        evalTextArea.setColumns(80);\n+        JScrollPane scroller = new JScrollPane(evalTextArea);\n+        setContentPane(scroller);\n+        //scroller.setPreferredSize(new Dimension(600, 400));\n+        pack();\n+        setVisible(true);\n+    }\n+\n+    /**\n+     * Sets whether the text area is enabled.\n+     */\n+    @Override\n+    public void setEnabled(boolean b) {\n+        super.setEnabled(b);\n+        evalTextArea.setEnabled(b);\n+    }\n+\n+    // ActionListener\n+\n+    /**\n+     * Performs an action on the text area.\n+     */\n+    public void actionPerformed(ActionEvent e) {\n+        String cmd = e.getActionCommand();\n+        if (cmd.equals(\"Cut\")) {\n+            evalTextArea.cut();\n+        } else if (cmd.equals(\"Copy\")) {\n+            evalTextArea.copy();\n+        } else if (cmd.equals(\"Paste\")) {\n+            evalTextArea.paste();\n+        }\n+    }\n+}\n+\n+/**\n+ * Internal frame for the console.\n+ */\n+class JSInternalConsole extends JInternalFrame implements ActionListener {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = -5523468828771087292L;\n+\n+    /**\n+     * Creates a new JSInternalConsole.\n+     */\n+    public JSInternalConsole(String name) {\n+        super(name, true, false, true, true);\n+        consoleTextArea = new ConsoleTextArea(null);\n+        consoleTextArea.setRows(24);\n+        consoleTextArea.setColumns(80);\n+        JScrollPane scroller = new JScrollPane(consoleTextArea);\n+        setContentPane(scroller);\n+        pack();\n+        addInternalFrameListener(new InternalFrameAdapter() {\n+                @Override\n+                public void internalFrameActivated(InternalFrameEvent e) {\n+                    // hack\n+                    if (consoleTextArea.hasFocus()) {\n+                        consoleTextArea.getCaret().setVisible(false);\n+                        consoleTextArea.getCaret().setVisible(true);\n+                    }\n+                }\n+            });\n+    }\n+\n+    /**\n+     * The console text area.\n+     */\n+    ConsoleTextArea consoleTextArea;\n+\n+    /**\n+     * Returns the input stream of the console text area.\n+     */\n+    public InputStream getIn() {\n+        return consoleTextArea.getIn();\n+    }\n+\n+    /**\n+     * Returns the output stream of the console text area.\n+     */\n+    public PrintStream getOut() {\n+        return consoleTextArea.getOut();\n+    }\n+\n+    /**\n+     * Returns the error stream of the console text area.\n+     */\n+    public PrintStream getErr() {\n+        return consoleTextArea.getErr();\n+    }\n+\n+    // ActionListener\n+\n+    /**\n+     * Performs an action on the text area.\n+     */\n+    public void actionPerformed(ActionEvent e) {\n+        String cmd = e.getActionCommand();\n+        if (cmd.equals(\"Cut\")) {\n+            consoleTextArea.cut();\n+        } else if (cmd.equals(\"Copy\")) {\n+            consoleTextArea.copy();\n+        } else if (cmd.equals(\"Paste\")) {\n+            consoleTextArea.paste();\n+        }\n+    }\n+}\n+\n+/**\n+ * Popup menu class for right-clicking on {@link FileTextArea}s.\n+ */\n+class FilePopupMenu extends JPopupMenu {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = 3589525009546013565L;\n+\n+    /**\n+     * The popup x position.\n+     */\n+    int x;\n+    \n+    /**\n+     * The popup y position.\n+     */\n+    int y;\n+\n+    /**\n+     * Creates a new FilePopupMenu.\n+     */\n+    public FilePopupMenu(FileTextArea w) {\n+        JMenuItem item;\n+        add(item = new JMenuItem(\"Set Breakpoint\"));\n+        item.addActionListener(w);\n+        add(item = new JMenuItem(\"Clear Breakpoint\"));\n+        item.addActionListener(w);\n+        add(item = new JMenuItem(\"Run\"));\n+        item.addActionListener(w);\n+    }\n+\n+    /**\n+     * Displays the menu at the given coordinates.\n+     */\n+    public void show(JComponent comp, int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+        super.show(comp, x, y);\n+    }\n+}\n+\n+/**\n+ * Text area to display script source.\n+ */\n+class FileTextArea\n+    extends JTextArea\n+    implements ActionListener, PopupMenuListener, KeyListener, MouseListener {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = -25032065448563720L;\n+\n+    /**\n+     * The owning {@link FileWindow}.\n+     */\n+    private FileWindow w;\n+\n+    /**\n+     * The popup menu.\n+     */\n+    private FilePopupMenu popup;\n+\n+    /**\n+     * Creates a new FileTextArea.\n+     */\n+    public FileTextArea(FileWindow w) {\n+        this.w = w;\n+        popup = new FilePopupMenu(this);\n+        popup.addPopupMenuListener(this);\n+        addMouseListener(this);\n+        addKeyListener(this);\n+        setFont(new Font(\"Monospaced\", 0, 12));\n+    }\n+\n+    /**\n+     * Moves the selection to the given offset.\n+     */\n+    public void select(int pos) {\n+        if (pos >= 0) {\n+            try {\n+                int line = getLineOfOffset(pos);\n+                Rectangle rect = modelToView(pos);\n+                if (rect == null) {\n+                    select(pos, pos);\n+                } else {\n+                    try {\n+                        Rectangle nrect =\n+                            modelToView(getLineStartOffset(line + 1));\n+                        if (nrect != null) {\n+                            rect = nrect;\n+                        }\n+                    } catch (Exception exc) {\n+                    }\n+                    JViewport vp = (JViewport)getParent();\n+                    Rectangle viewRect = vp.getViewRect();\n+                    if (viewRect.y + viewRect.height > rect.y) {\n+                        // need to scroll up\n+                        select(pos, pos);\n+                    } else {\n+                        // need to scroll down\n+                        rect.y += (viewRect.height - rect.height)/2;\n+                        scrollRectToVisible(rect);\n+                        select(pos, pos);\n+                    }\n+                }\n+            } catch (BadLocationException exc) {\n+                select(pos, pos);\n+                //exc.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks if the popup menu should be shown.\n+     */\n+    private void checkPopup(MouseEvent e) {\n+        if (e.isPopupTrigger()) {\n+            popup.show(this, e.getX(), e.getY());\n+        }\n+    }\n+\n+    // MouseListener\n+\n+    /**\n+     * Called when a mouse button is pressed.\n+     */\n+    public void mousePressed(MouseEvent e) {\n+        checkPopup(e);\n+    }\n+\n+    /**\n+     * Called when the mouse is clicked.\n+     */\n+    public void mouseClicked(MouseEvent e) {\n+        checkPopup(e);\n+        requestFocus();\n+        getCaret().setVisible(true);\n+    }\n+\n+    /**\n+     * Called when the mouse enters the component.\n+     */\n+    public void mouseEntered(MouseEvent e) {\n+    }\n+\n+    /**\n+     * Called when the mouse exits the component.\n+     */\n+    public void mouseExited(MouseEvent e) {\n+    }\n+\n+    /**\n+     * Called when a mouse button is released.\n+     */\n+    public void mouseReleased(MouseEvent e) {\n+        checkPopup(e);\n+    }\n+\n+    // PopupMenuListener\n+\n+    /**\n+     * Called before the popup menu will become visible.\n+     */\n+    public void popupMenuWillBecomeVisible(PopupMenuEvent e) {\n+    }\n+\n+    /**\n+     * Called before the popup menu will become invisible.\n+     */\n+    public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {\n+    }\n+\n+    /**\n+     * Called when the popup menu is cancelled.\n+     */\n+    public void popupMenuCanceled(PopupMenuEvent e) {\n+    }\n+\n+    // ActionListener\n+\n+    /**\n+     * Performs an action.\n+     */\n+    public void actionPerformed(ActionEvent e) {\n+        int pos = viewToModel(new Point(popup.x, popup.y));\n+        popup.setVisible(false);\n+        String cmd = e.getActionCommand();\n+        int line = -1;\n+        try {\n+            line = getLineOfOffset(pos);\n+        } catch (Exception exc) {\n+        }\n+        if (cmd.equals(\"Set Breakpoint\")) {\n+            w.setBreakPoint(line + 1);\n+        } else if (cmd.equals(\"Clear Breakpoint\")) {\n+            w.clearBreakPoint(line + 1);\n+        } else if (cmd.equals(\"Run\")) {\n+            w.load();\n+        }\n+    }\n+\n+    // KeyListener\n+\n+    /**\n+     * Called when a key is pressed.\n+     */\n+    public void keyPressed(KeyEvent e) {\n+        switch (e.getKeyCode()) {\n+        case KeyEvent.VK_BACK_SPACE:\n+        case KeyEvent.VK_ENTER:\n+        case KeyEvent.VK_DELETE:\n+        case KeyEvent.VK_TAB:\n+            e.consume();\n+            break;\n+        }\n+    }\n+\n+    /**\n+     * Called when a key is typed.\n+     */\n+    public void keyTyped(KeyEvent e) {\n+        e.consume();\n+    }\n+\n+    /**\n+     * Called when a key is released.\n+     */\n+    public void keyReleased(KeyEvent e) {\n+        e.consume();\n+    }\n+}\n+\n+/**\n+ * Dialog to list the available windows.\n+ */\n+class MoreWindows extends JDialog implements ActionListener {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = 5177066296457377546L;\n+\n+    /**\n+     * Last selected value.\n+     */\n+    private String value;\n+\n+    /**\n+     * The list component.\n+     */\n+    private JList list;\n+\n+    /**\n+     * Our parent frame.\n+     */\n+    private SwingGui swingGui;\n+\n+    /**\n+     * The \"Select\" button.\n+     */\n+    private JButton setButton;\n+\n+    /**\n+     * The \"Cancel\" button.\n+     */\n+    private JButton cancelButton;\n+\n+    /**\n+     * Creates a new MoreWindows.\n+     */\n+    MoreWindows(SwingGui frame, Map<String,FileWindow> fileWindows, String title,\n+                String labelText) {\n+        super(frame, title, true);\n+        this.swingGui = frame;\n+        //buttons\n+        cancelButton = new JButton(\"Cancel\");\n+        setButton = new JButton(\"Select\");\n+        cancelButton.addActionListener(this);\n+        setButton.addActionListener(this);\n+        getRootPane().setDefaultButton(setButton);\n+\n+        //dim part of the dialog\n+        list = new JList(new DefaultListModel());\n+        DefaultListModel model = (DefaultListModel)list.getModel();\n+        model.clear();\n+        //model.fireIntervalRemoved(model, 0, size);\n+        for (String data: fileWindows.keySet()) {\n+            model.addElement(data);\n+        }\n+        list.setSelectedIndex(0);\n+        //model.fireIntervalAdded(model, 0, data.length);\n+        setButton.setEnabled(true);\n+        list.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);\n+        list.addMouseListener(new MouseHandler());\n+        JScrollPane listScroller = new JScrollPane(list);\n+        listScroller.setPreferredSize(new Dimension(320, 240));\n+        //XXX: Must do the following, too, or else the scroller thinks\n+        //XXX: it's taller than it is:\n+        listScroller.setMinimumSize(new Dimension(250, 80));\n+        listScroller.setAlignmentX(LEFT_ALIGNMENT);\n+\n+        //Create a container so that we can add a title around\n+        //the scroll pane.  Can't add a title directly to the\n+        //scroll pane because its background would be white.\n+        //Lay out the label and scroll pane from top to button.\n+        JPanel listPane = new JPanel();\n+        listPane.setLayout(new BoxLayout(listPane, BoxLayout.Y_AXIS));\n+        JLabel label = new JLabel(labelText);\n+        label.setLabelFor (list);\n+        listPane.add(label);\n+        listPane.add(Box.createRigidArea(new Dimension(0,5)));\n+        listPane.add(listScroller);\n+        listPane.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));\n+\n+        //Lay out the buttons from left to right.\n+        JPanel buttonPane = new JPanel();\n+        buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.X_AXIS));\n+        buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));\n+        buttonPane.add(Box.createHorizontalGlue());\n+        buttonPane.add(cancelButton);\n+        buttonPane.add(Box.createRigidArea(new Dimension(10, 0)));\n+        buttonPane.add(setButton);\n+\n+        //Put everything together, using the content pane's BorderLayout.\n+        Container contentPane = getContentPane();\n+        contentPane.add(listPane, BorderLayout.CENTER);\n+        contentPane.add(buttonPane, BorderLayout.SOUTH);\n+        pack();\n+        addKeyListener(new KeyAdapter() {\n+                @Override\n+                public void keyPressed(KeyEvent ke) {\n+                    int code = ke.getKeyCode();\n+                    if (code == KeyEvent.VK_ESCAPE) {\n+                        ke.consume();\n+                        value = null;\n+                        setVisible(false);\n+                    }\n+                }\n+            });\n+    }\n+\n+    /**\n+     * Shows the dialog.\n+     */\n+    public String showDialog(Component comp) {\n+        value = null;\n+        setLocationRelativeTo(comp);\n+        setVisible(true);\n+        return value;\n+    }\n+\n+    // ActionListener\n+\n+    /**\n+     * Performs an action.\n+     */\n+    public void actionPerformed(ActionEvent e) {\n+        String cmd = e.getActionCommand();\n+        if (cmd.equals(\"Cancel\")) {\n+            setVisible(false);\n+            value = null;\n+        } else if (cmd.equals(\"Select\")) {\n+            value = (String)list.getSelectedValue();\n+            setVisible(false);\n+            swingGui.showFileWindow(value, -1);\n+        }\n+    }\n+\n+    /**\n+     * MouseListener implementation for {@link #list}.\n+     */\n+    private class MouseHandler extends MouseAdapter {\n+        @Override\n+        public void mouseClicked(MouseEvent e) {\n+            if (e.getClickCount() == 2) {\n+                setButton.doClick();\n+            }\n+        }\n+    }\n+}\n+\n+/**\n+ * Find function dialog.\n+ */\n+class FindFunction extends JDialog implements ActionListener {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = 559491015232880916L;\n+\n+    /**\n+     * Last selected function.\n+     */\n+    private String value;\n+\n+    /**\n+     * List of functions.\n+     */\n+    private JList list;\n+\n+    /**\n+     * The debug GUI frame.\n+     */\n+    private SwingGui debugGui;\n+\n+    /**\n+     * The \"Select\" button.\n+     */\n+    private JButton setButton;\n+\n+    /**\n+     * The \"Cancel\" button.\n+     */\n+    private JButton cancelButton;\n+\n+    /**\n+     * Creates a new FindFunction.\n+     */\n+    public FindFunction(SwingGui debugGui, String title, String labelText) {\n+        super(debugGui, title, true);\n+        this.debugGui = debugGui;\n+\n+        cancelButton = new JButton(\"Cancel\");\n+        setButton = new JButton(\"Select\");\n+        cancelButton.addActionListener(this);\n+        setButton.addActionListener(this);\n+        getRootPane().setDefaultButton(setButton);\n+\n+        list = new JList(new DefaultListModel());\n+        DefaultListModel model = (DefaultListModel)list.getModel();\n+        model.clear();\n+\n+        String[] a = debugGui.dim.functionNames();\n+        java.util.Arrays.sort(a);\n+        for (int i = 0; i < a.length; i++) {\n+            model.addElement(a[i]);\n+        }\n+        list.setSelectedIndex(0);\n+\n+        setButton.setEnabled(a.length > 0);\n+        list.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);\n+        list.addMouseListener(new MouseHandler());\n+        JScrollPane listScroller = new JScrollPane(list);\n+        listScroller.setPreferredSize(new Dimension(320, 240));\n+        listScroller.setMinimumSize(new Dimension(250, 80));\n+        listScroller.setAlignmentX(LEFT_ALIGNMENT);\n+\n+        //Create a container so that we can add a title around\n+        //the scroll pane.  Can't add a title directly to the\n+        //scroll pane because its background would be white.\n+        //Lay out the label and scroll pane from top to button.\n+        JPanel listPane = new JPanel();\n+        listPane.setLayout(new BoxLayout(listPane, BoxLayout.Y_AXIS));\n+        JLabel label = new JLabel(labelText);\n+        label.setLabelFor (list);\n+        listPane.add(label);\n+        listPane.add(Box.createRigidArea(new Dimension(0,5)));\n+        listPane.add(listScroller);\n+        listPane.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));\n+\n+        //Lay out the buttons from left to right.\n+        JPanel buttonPane = new JPanel();\n+        buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.X_AXIS));\n+        buttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));\n+        buttonPane.add(Box.createHorizontalGlue());\n+        buttonPane.add(cancelButton);\n+        buttonPane.add(Box.createRigidArea(new Dimension(10, 0)));\n+        buttonPane.add(setButton);\n+\n+        //Put everything together, using the content pane's BorderLayout.\n+        Container contentPane = getContentPane();\n+        contentPane.add(listPane, BorderLayout.CENTER);\n+        contentPane.add(buttonPane, BorderLayout.SOUTH);\n+        pack();\n+        addKeyListener(new KeyAdapter() {\n+                @Override\n+                public void keyPressed(KeyEvent ke) {\n+                    int code = ke.getKeyCode();\n+                    if (code == KeyEvent.VK_ESCAPE) {\n+                        ke.consume();\n+                        value = null;\n+                        setVisible(false);\n+                    }\n+                }\n+            });\n+    }\n+\n+    /**\n+     * Shows the dialog.\n+     */\n+    public String showDialog(Component comp) {\n+        value = null;\n+        setLocationRelativeTo(comp);\n+        setVisible(true);\n+        return value;\n+    }\n+\n+    // ActionListener\n+\n+    /**\n+     * Performs an action.\n+     */\n+    public void actionPerformed(ActionEvent e) {\n+        String cmd = e.getActionCommand();\n+        if (cmd.equals(\"Cancel\")) {\n+            setVisible(false);\n+            value = null;\n+        } else if (cmd.equals(\"Select\")) {\n+            if (list.getSelectedIndex() < 0) {\n+                return;\n+            }\n+            try {\n+                value = (String)list.getSelectedValue();\n+            } catch (ArrayIndexOutOfBoundsException exc) {\n+                return;\n+            }\n+            setVisible(false);\n+            Dim.FunctionSource item = debugGui.dim.functionSourceByName(value);\n+            if (item != null) {\n+                Dim.SourceInfo si = item.sourceInfo();\n+                String url = si.url();\n+                int lineNumber = item.firstLine();\n+                debugGui.showFileWindow(url, lineNumber);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * MouseListener implementation for {@link #list}.\n+     */\n+    class MouseHandler extends MouseAdapter {\n+        @Override\n+        public void mouseClicked(MouseEvent e) {\n+            if (e.getClickCount() == 2) {\n+                setButton.doClick();\n+            }\n+        }\n+    }\n+}\n+\n+/**\n+ * Gutter for FileWindows.\n+ */\n+class FileHeader extends JPanel implements MouseListener {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = -2858905404778259127L;\n+\n+    /**\n+     * The line that the mouse was pressed on.\n+     */\n+    private int pressLine = -1;\n+\n+    /**\n+     * The owning FileWindow.\n+     */\n+    private FileWindow fileWindow;\n+\n+    /**\n+     * Creates a new FileHeader.\n+     */\n+    public FileHeader(FileWindow fileWindow) {\n+        this.fileWindow = fileWindow;\n+        addMouseListener(this);\n+        update();\n+    }\n+\n+    /**\n+     * Updates the gutter.\n+     */\n+    public void update() {\n+        FileTextArea textArea = fileWindow.textArea;\n+        Font font = textArea.getFont();\n+        setFont(font);\n+        FontMetrics metrics = getFontMetrics(font);\n+        int h = metrics.getHeight();\n+        int lineCount = textArea.getLineCount() + 1;\n+        String dummy = Integer.toString(lineCount);\n+        if (dummy.length() < 2) {\n+            dummy = \"99\";\n+        }\n+        Dimension d = new Dimension();\n+        d.width = metrics.stringWidth(dummy) + 16;\n+        d.height = lineCount * h + 100;\n+        setPreferredSize(d);\n+        setSize(d);\n+    }\n+\n+    /**\n+     * Paints the component.\n+     */\n+    @Override\n+    public void paint(Graphics g) {\n+        super.paint(g);\n+        FileTextArea textArea = fileWindow.textArea;\n+        Font font = textArea.getFont();\n+        g.setFont(font);\n+        FontMetrics metrics = getFontMetrics(font);\n+        Rectangle clip = g.getClipBounds();\n+        g.setColor(getBackground());\n+        g.fillRect(clip.x, clip.y, clip.width, clip.height);\n+        int ascent = metrics.getMaxAscent();\n+        int h = metrics.getHeight();\n+        int lineCount = textArea.getLineCount() + 1;\n+        String dummy = Integer.toString(lineCount);\n+        if (dummy.length() < 2) {\n+            dummy = \"99\";\n+        }\n+        int startLine = clip.y / h;\n+        int endLine = (clip.y + clip.height) / h + 1;\n+        int width = getWidth();\n+        if (endLine > lineCount) endLine = lineCount;\n+        for (int i = startLine; i < endLine; i++) {\n+            String text;\n+            int pos = -2;\n+            try {\n+                pos = textArea.getLineStartOffset(i);\n+            } catch (BadLocationException ignored) {\n+            }\n+            boolean isBreakPoint = fileWindow.isBreakPoint(i + 1);\n+            text = Integer.toString(i + 1) + \" \";\n+            int y = i * h;\n+            g.setColor(Color.blue);\n+            g.drawString(text, 0, y + ascent);\n+            int x = width - ascent;\n+            if (isBreakPoint) {\n+                g.setColor(new Color(0x80, 0x00, 0x00));\n+                int dy = y + ascent - 9;\n+                g.fillOval(x, dy, 9, 9);\n+                g.drawOval(x, dy, 8, 8);\n+                g.drawOval(x, dy, 9, 9);\n+            }\n+            if (pos == fileWindow.currentPos) {\n+                Polygon arrow = new Polygon();\n+                int dx = x;\n+                y += ascent - 10;\n+                int dy = y;\n+                arrow.addPoint(dx, dy + 3);\n+                arrow.addPoint(dx + 5, dy + 3);\n+                for (x = dx + 5; x <= dx + 10; x++, y++) {\n+                    arrow.addPoint(x, y);\n+                }\n+                for (x = dx + 9; x >= dx + 5; x--, y++) {\n+                    arrow.addPoint(x, y);\n+                }\n+                arrow.addPoint(dx + 5, dy + 7);\n+                arrow.addPoint(dx, dy + 7);\n+                g.setColor(Color.yellow);\n+                g.fillPolygon(arrow);\n+                g.setColor(Color.black);\n+                g.drawPolygon(arrow);\n+            }\n+        }\n+    }\n+\n+    // MouseListener\n+\n+    /**\n+     * Called when the mouse enters the component.\n+     */\n+    public void mouseEntered(MouseEvent e) {\n+    }\n+    \n+    /**\n+     * Called when a mouse button is pressed.\n+     */\n+    public void mousePressed(MouseEvent e) {\n+        Font font = fileWindow.textArea.getFont();\n+        FontMetrics metrics = getFontMetrics(font);\n+        int h = metrics.getHeight();\n+        pressLine = e.getY() / h;\n+    }\n+\n+    /**\n+     * Called when the mouse is clicked.\n+     */\n+    public void mouseClicked(MouseEvent e) {\n+    }\n+\n+    /**\n+     * Called when the mouse exits the component.\n+     */\n+    public void mouseExited(MouseEvent e) {\n+    }\n+\n+    /**\n+     * Called when a mouse button is released.\n+     */\n+    public void mouseReleased(MouseEvent e) {\n+        if (e.getComponent() == this\n+                && (e.getModifiers() & MouseEvent.BUTTON1_MASK) != 0) {\n+            int y = e.getY();\n+            Font font = fileWindow.textArea.getFont();\n+            FontMetrics metrics = getFontMetrics(font);\n+            int h = metrics.getHeight();\n+            int line = y/h;\n+            if (line == pressLine) {\n+                fileWindow.toggleBreakPoint(line + 1);\n+            } else {\n+                pressLine = -1;\n+            }\n+        }\n+    }\n+}\n+\n+/**\n+ * An internal frame for script files.\n+ */\n+class FileWindow extends JInternalFrame implements ActionListener {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = -6212382604952082370L;\n+\n+    /**\n+     * The debugger GUI.\n+     */\n+    private SwingGui debugGui;\n+\n+    /**\n+     * The SourceInfo object that describes the file.\n+     */\n+    private Dim.SourceInfo sourceInfo;\n+\n+    /**\n+     * The FileTextArea that displays the file.\n+     */\n+    FileTextArea textArea;\n+\n+    /**\n+     * The FileHeader that is the gutter for {@link #textArea}.\n+     */\n+    private FileHeader fileHeader;\n+    \n+    /**\n+     * Scroll pane for containing {@link #textArea}.\n+     */\n+    private JScrollPane p;\n+\n+    /**\n+     * The current offset position.\n+     */\n+    int currentPos;\n+\n+    /**\n+     * Loads the file.\n+     */\n+    void load() {\n+        String url = getUrl();\n+        if (url != null) {\n+            RunProxy proxy = new RunProxy(debugGui, RunProxy.LOAD_FILE);\n+            proxy.fileName = url;\n+            proxy.text = sourceInfo.source();\n+            new Thread(proxy).start();\n+        }\n+    }\n+\n+    /**\n+     * Returns the offset position for the given line.\n+     */\n+    public int getPosition(int line) {\n+        int result = -1;\n+        try {\n+            result = textArea.getLineStartOffset(line);\n+        } catch (javax.swing.text.BadLocationException exc) {\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns whether the given line has a breakpoint.\n+     */\n+    public boolean isBreakPoint(int line) {\n+        return sourceInfo.breakableLine(line) && sourceInfo.breakpoint(line);\n+    }\n+\n+    /**\n+     * Toggles the breakpoint on the given line.\n+     */\n+    public void toggleBreakPoint(int line) {\n+        if (!isBreakPoint(line)) {\n+            setBreakPoint(line);\n+        } else {\n+            clearBreakPoint(line);\n+        }\n+    }\n+\n+    /**\n+     * Sets a breakpoint on the given line.\n+     */\n+    public void setBreakPoint(int line) {\n+        if (sourceInfo.breakableLine(line)) {\n+            boolean changed = sourceInfo.breakpoint(line, true);\n+            if (changed) {\n+                fileHeader.repaint();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clears a breakpoint from the given line.\n+     */\n+    public void clearBreakPoint(int line) {\n+        if (sourceInfo.breakableLine(line)) {\n+            boolean changed = sourceInfo.breakpoint(line, false);\n+            if (changed) {\n+                fileHeader.repaint();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new FileWindow.\n+     */\n+    public FileWindow(SwingGui debugGui, Dim.SourceInfo sourceInfo) {\n+        super(SwingGui.getShortName(sourceInfo.url()),\n+              true, true, true, true);\n+        this.debugGui = debugGui;\n+        this.sourceInfo = sourceInfo;\n+        updateToolTip();\n+        currentPos = -1;\n+        textArea = new FileTextArea(this);\n+        textArea.setRows(24);\n+        textArea.setColumns(80);\n+        p = new JScrollPane();\n+        fileHeader = new FileHeader(this);\n+        p.setViewportView(textArea);\n+        p.setRowHeaderView(fileHeader);\n+        setContentPane(p);\n+        pack();\n+        updateText(sourceInfo);\n+        textArea.select(0);\n+    }\n+\n+    /**\n+     * Updates the tool tip contents.\n+     */\n+    private void updateToolTip() {\n+        // Try to set tool tip on frame. On Mac OS X 10.5,\n+        // the number of components is different, so try to be safe.\n+        int n = getComponentCount() - 1;\n+        if (n > 1) {\n+            n = 1;\n+        } else if (n < 0) {\n+            return;\n+        }\n+        Component c = getComponent(n);\n+        // this will work at least for Metal L&F\n+        if (c != null && c instanceof JComponent) {\n+            ((JComponent)c).setToolTipText(getUrl());\n+        }\n+    }\n+\n+    /**\n+     * Returns the URL of the source.\n+     */\n+    public String getUrl() {\n+        return sourceInfo.url();\n+    }\n+\n+    /**\n+     * Called when the text of the script has changed.\n+     */\n+    public void updateText(Dim.SourceInfo sourceInfo) {\n+        this.sourceInfo = sourceInfo;\n+        String newText = sourceInfo.source();\n+        if (!textArea.getText().equals(newText)) {\n+            textArea.setText(newText);\n+            int pos = 0;\n+            if (currentPos != -1) {\n+                pos = currentPos;\n+            }\n+            textArea.select(pos);\n+        }\n+        fileHeader.update();\n+        fileHeader.repaint();\n+    }\n+\n+    /**\n+     * Sets the cursor position.\n+     */\n+    public void setPosition(int pos) {\n+        textArea.select(pos);\n+        currentPos = pos;\n+        fileHeader.repaint();\n+    }\n+\n+    /**\n+     * Selects a range of characters.\n+     */\n+    public void select(int start, int end) {\n+        int docEnd = textArea.getDocument().getLength();\n+        textArea.select(docEnd, docEnd);\n+        textArea.select(start, end);\n+    }\n+\n+    /**\n+     * Disposes this FileWindow.\n+     */\n+    @Override\n+    public void dispose() {\n+        debugGui.removeWindow(this);\n+        super.dispose();\n+    }\n+\n+    // ActionListener\n+\n+    /**\n+     * Performs an action.\n+     */\n+    public void actionPerformed(ActionEvent e) {\n+        String cmd = e.getActionCommand();\n+        if (cmd.equals(\"Cut\")) {\n+            // textArea.cut();\n+        } else if (cmd.equals(\"Copy\")) {\n+            textArea.copy();\n+        } else if (cmd.equals(\"Paste\")) {\n+            // textArea.paste();\n+        }\n+    }\n+}\n+\n+/**\n+ * Table model class for watched expressions.\n+ */\n+class MyTableModel extends AbstractTableModel {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = 2971618907207577000L;\n+\n+    /**\n+     * The debugger GUI.\n+     */\n+    private SwingGui debugGui;\n+\n+    /**\n+     * List of watched expressions.\n+     */\n+    private List<String> expressions;\n+\n+    /**\n+     * List of values from evaluated from {@link #expressions}.\n+     */\n+    private List<String> values;\n+\n+    /**\n+     * Creates a new MyTableModel.\n+     */\n+    public MyTableModel(SwingGui debugGui) {\n+        this.debugGui = debugGui;\n+        expressions = Collections.synchronizedList(new ArrayList<String>());\n+        values = Collections.synchronizedList(new ArrayList<String>());\n+        expressions.add(\"\");\n+        values.add(\"\");\n+    }\n+\n+    /**\n+     * Returns the number of columns in the table (2).\n+     */\n+    public int getColumnCount() {\n+        return 2;\n+    }\n+\n+    /**\n+     * Returns the number of rows in the table.\n+     */\n+    public int getRowCount() {\n+        return expressions.size();\n+    }\n+\n+    /**\n+     * Returns the name of the given column.\n+     */\n+    @Override\n+    public String getColumnName(int column) {\n+        switch (column) {\n+        case 0:\n+            return \"Expression\";\n+        case 1:\n+            return \"Value\";\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns whether the given cell is editable.\n+     */\n+    @Override\n+    public boolean isCellEditable(int row, int column) {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the value in the given cell.\n+     */\n+    public Object getValueAt(int row, int column) {\n+        switch (column) {\n+        case 0:\n+            return expressions.get(row);\n+        case 1:\n+            return values.get(row);\n+        }\n+        return \"\";\n+    }\n+\n+    /**\n+     * Sets the value in the given cell.\n+     */\n+    @Override\n+    public void setValueAt(Object value, int row, int column) {\n+        switch (column) {\n+        case 0:\n+            String expr = value.toString();\n+            expressions.set(row, expr);\n+            String result = \"\";\n+            if (expr.length() > 0) {\n+                result = debugGui.dim.eval(expr);\n+                if (result == null) result = \"\";\n+            }\n+            values.set(row, result);\n+            updateModel();\n+            if (row + 1 == expressions.size()) {\n+                expressions.add(\"\");\n+                values.add(\"\");\n+                fireTableRowsInserted(row + 1, row + 1);\n+            }\n+            break;\n+        case 1:\n+            // just reset column 2; ignore edits\n+            fireTableDataChanged();\n+        }\n+    }\n+\n+    /**\n+     * Re-evaluates the expressions in the table.\n+     */\n+    void updateModel() {\n+        for (int i = 0; i < expressions.size(); ++i) {\n+            String expr = expressions.get(i);\n+            String result = \"\";\n+            if (expr.length() > 0) {\n+                result = debugGui.dim.eval(expr);\n+                if (result == null) result = \"\";\n+            } else {\n+                result = \"\";\n+            }\n+            result = result.replace('\\n', ' ');\n+            values.set(i, result);\n+        }\n+        fireTableDataChanged();\n+    }\n+}\n+\n+/**\n+ * A table for evaluated expressions.\n+ */\n+class Evaluator extends JTable {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = 8133672432982594256L;\n+\n+    /**\n+     * The {@link TableModel} for this table.\n+     */\n+    MyTableModel tableModel;\n+\n+    /**\n+     * Creates a new Evaluator.\n+     */\n+    public Evaluator(SwingGui debugGui) {\n+        super(new MyTableModel(debugGui));\n+        tableModel = (MyTableModel)getModel();\n+    }\n+}\n+\n+/**\n+ * Tree model for script object inspection.\n+ */\n+class VariableModel implements TreeTableModel {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final String[] cNames = { \" Name\", \" Value\" };\n+\n+    /**\n+     * Tree column types.\n+     */\n+    private static final Class<?>[] cTypes =\n+        { TreeTableModel.class, String.class };\n+\n+    /**\n+     * Empty {@link VariableNode} array.\n+     */\n+    private static final VariableNode[] CHILDLESS = new VariableNode[0];\n+\n+    /**\n+     * The debugger.\n+     */\n+    private Dim debugger;\n+\n+    /**\n+     * The root node.\n+     */\n+    private VariableNode root;\n+\n+    /**\n+     * Creates a new VariableModel.\n+     */\n+    public VariableModel() {\n+    }\n+\n+    /**\n+     * Creates a new VariableModel.\n+     */\n+    public VariableModel(Dim debugger, Object scope) {\n+        this.debugger = debugger;\n+        this.root = new VariableNode(scope, \"this\");\n+    }\n+\n+    // TreeTableModel\n+\n+    /**\n+     * Returns the root node of the tree.\n+     */\n+    public Object getRoot() {\n+        if (debugger == null) {\n+            return null;\n+        }\n+        return root;\n+    }\n+\n+    /**\n+     * Returns the number of children of the given node.\n+     */\n+    public int getChildCount(Object nodeObj) {\n+        if (debugger == null) {\n+            return 0;\n+        }\n+        VariableNode node = (VariableNode) nodeObj;\n+        return children(node).length;\n+    }\n+\n+    /**\n+     * Returns a child of the given node.\n+     */\n+    public Object getChild(Object nodeObj, int i) {\n+        if (debugger == null) {\n+            return null;\n+        }\n+        VariableNode node = (VariableNode) nodeObj;\n+        return children(node)[i];\n+    }\n+\n+    /**\n+     * Returns whether the given node is a leaf node.\n+     */\n+    public boolean isLeaf(Object nodeObj) {\n+        if (debugger == null) {\n+            return true;\n+        }\n+        VariableNode node = (VariableNode) nodeObj;\n+        return children(node).length == 0;\n+    }\n+\n+    /**\n+     * Returns the index of a node under its parent.\n+     */\n+    public int getIndexOfChild(Object parentObj, Object childObj) {\n+        if (debugger == null) {\n+            return -1;\n+        }\n+        VariableNode parent = (VariableNode) parentObj;\n+        VariableNode child = (VariableNode) childObj;\n+        VariableNode[] children = children(parent);\n+        for (int i = 0; i != children.length; i++) {\n+            if (children[i] == child) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns whether the given cell is editable.\n+     */\n+    public boolean isCellEditable(Object node, int column) {\n+        return column == 0;\n+    }\n+\n+    /**\n+     * Sets the value at the given cell.\n+     */\n+    public void setValueAt(Object value, Object node, int column) { }\n+\n+    /**\n+     * Adds a TreeModelListener to this tree.\n+     */\n+    public void addTreeModelListener(TreeModelListener l) { }\n+\n+    /**\n+     * Removes a TreeModelListener from this tree.\n+     */\n+    public void removeTreeModelListener(TreeModelListener l) { }\n+\n+    public void valueForPathChanged(TreePath path, Object newValue) { }\n+\n+    // TreeTableNode\n+\n+    /**\n+     * Returns the number of columns.\n+     */\n+    public int getColumnCount() {\n+        return cNames.length;\n+    }\n+\n+    /**\n+     * Returns the name of the given column.\n+     */\n+    public String getColumnName(int column) {\n+        return cNames[column];\n+    }\n+\n+    /**\n+     * Returns the type of value stored in the given column.\n+     */\n+    public Class<?> getColumnClass(int column) {\n+        return cTypes[column];\n+    }\n+\n+    /**\n+     * Returns the value at the given cell.\n+     */\n+    public Object getValueAt(Object nodeObj, int column) {\n+        if (debugger == null) { return null; }\n+        VariableNode node = (VariableNode)nodeObj;\n+        switch (column) {\n+        case 0: // Name\n+            return node.toString();\n+        case 1: // Value\n+            String result;\n+            try {\n+                result = debugger.objectToString(getValue(node));\n+            } catch (RuntimeException exc) {\n+                result = exc.getMessage();\n+            }\n+            StringBuffer buf = new StringBuffer();\n+            int len = result.length();\n+            for (int i = 0; i < len; i++) {\n+                char ch = result.charAt(i);\n+                if (Character.isISOControl(ch)) {\n+                    ch = ' ';\n+                }\n+                buf.append(ch);\n+            }\n+            return buf.toString();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns an array of the children of the given node.\n+     */\n+    private VariableNode[] children(VariableNode node) {\n+        if (node.children != null) {\n+            return node.children;\n+        }\n+\n+        VariableNode[] children;\n+\n+        Object value = getValue(node);\n+        Object[] ids = debugger.getObjectIds(value);\n+        if (ids == null || ids.length == 0) {\n+            children = CHILDLESS;\n+        } else {\n+            Arrays.sort(ids, new Comparator<Object>() {\n+                    public int compare(Object l, Object r)\n+                    {\n+                        if (l instanceof String) {\n+                            if (r instanceof Integer) {\n+                                return -1;\n+                            }\n+                            return ((String)l).compareToIgnoreCase((String)r);\n+                        } else {\n+                            if (r instanceof String) {\n+                                return 1;\n+                            }\n+                            int lint = ((Integer)l).intValue();\n+                            int rint = ((Integer)r).intValue();\n+                            return lint - rint;\n+                        }\n+                    }\n+            });\n+            children = new VariableNode[ids.length];\n+            for (int i = 0; i != ids.length; ++i) {\n+                children[i] = new VariableNode(value, ids[i]);\n+            }\n+        }\n+        node.children = children;\n+        return children;\n+    }\n+\n+    /**\n+     * Returns the value of the given node.\n+     */\n+    public Object getValue(VariableNode node) {\n+        try {\n+            return debugger.getObjectProperty(node.object, node.id);\n+        } catch (Exception exc) {\n+            return \"undefined\";\n+        }\n+    }\n+\n+    /**\n+     * A variable node in the tree.\n+     */\n+    private static class VariableNode {\n+\n+        /**\n+         * The script object.\n+         */\n+        private Object object;\n+\n+        /**\n+         * The object name.  Either a String or an Integer.\n+         */\n+        private Object id;\n+\n+        /**\n+         * Array of child nodes.  This is filled with the properties of\n+         * the object.\n+         */\n+        private VariableNode[] children;\n+\n+        /**\n+         * Creates a new VariableNode.\n+         */\n+        public VariableNode(Object object, Object id) {\n+            this.object = object;\n+            this.id = id;\n+        }\n+\n+        /**\n+         * Returns a string representation of this node.\n+         */\n+        @Override\n+        public String toString() {\n+            return id instanceof String\n+                ? (String) id : \"[\" + ((Integer) id).intValue() + \"]\";\n+        }\n+    }\n+}\n+\n+/**\n+ * A tree table for browsing script objects.\n+ */\n+class MyTreeTable extends JTreeTable {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = 3457265548184453049L;\n+\n+    /**\n+     * Creates a new MyTreeTable.\n+     */\n+    public MyTreeTable(VariableModel model) {\n+        super(model);\n+    }\n+\n+    /**\n+     * Initializes a tree for this tree table.\n+     */\n+    public JTree resetTree(TreeTableModel treeTableModel) {\n+        tree = new TreeTableCellRenderer(treeTableModel);\n+\n+        // Install a tableModel representing the visible rows in the tree.\n+        super.setModel(new TreeTableModelAdapter(treeTableModel, tree));\n+\n+        // Force the JTable and JTree to share their row selection models.\n+        ListToTreeSelectionModelWrapper selectionWrapper = new\n+            ListToTreeSelectionModelWrapper();\n+        tree.setSelectionModel(selectionWrapper);\n+        setSelectionModel(selectionWrapper.getListSelectionModel());\n+\n+        // Make the tree and table row heights the same.\n+        if (tree.getRowHeight() < 1) {\n+            // Metal looks better like this.\n+            setRowHeight(18);\n+        }\n+\n+        // Install the tree editor renderer and editor.\n+        setDefaultRenderer(TreeTableModel.class, tree);\n+        setDefaultEditor(TreeTableModel.class, new TreeTableCellEditor());\n+        setShowGrid(true);\n+        setIntercellSpacing(new Dimension(1,1));\n+        tree.setRootVisible(false);\n+        tree.setShowsRootHandles(true);\n+        DefaultTreeCellRenderer r = (DefaultTreeCellRenderer)tree.getCellRenderer();\n+        r.setOpenIcon(null);\n+        r.setClosedIcon(null);\n+        r.setLeafIcon(null);\n+        return tree;\n+    }\n+\n+    /**\n+     * Returns whether the cell under the coordinates of the mouse\n+     * in the {@link EventObject} is editable.\n+     */\n+    public boolean isCellEditable(EventObject e) {\n+        if (e instanceof MouseEvent) {\n+            MouseEvent me = (MouseEvent)e;\n+            // If the modifiers are not 0 (or the left mouse button),\n+            // tree may try and toggle the selection, and table\n+            // will then try and toggle, resulting in the\n+            // selection remaining the same. To avoid this, we\n+            // only dispatch when the modifiers are 0 (or the left mouse\n+            // button).\n+            if (me.getModifiers() == 0 ||\n+                ((me.getModifiers() & (InputEvent.BUTTON1_MASK|1024)) != 0 &&\n+                 (me.getModifiers() &\n+                  (InputEvent.SHIFT_MASK |\n+                   InputEvent.CTRL_MASK |\n+                   InputEvent.ALT_MASK |\n+                   InputEvent.BUTTON2_MASK |\n+                   InputEvent.BUTTON3_MASK |\n+                   64   | //SHIFT_DOWN_MASK\n+                   128  | //CTRL_DOWN_MASK\n+                   512  | // ALT_DOWN_MASK\n+                   2048 | //BUTTON2_DOWN_MASK\n+                   4096   //BUTTON3_DOWN_MASK\n+                   )) == 0)) {\n+                int row = rowAtPoint(me.getPoint());\n+                for (int counter = getColumnCount() - 1; counter >= 0;\n+                     counter--) {\n+                    if (TreeTableModel.class == getColumnClass(counter)) {\n+                        MouseEvent newME = new MouseEvent\n+                            (MyTreeTable.this.tree, me.getID(),\n+                             me.getWhen(), me.getModifiers(),\n+                             me.getX() - getCellRect(row, counter, true).x,\n+                             me.getY(), me.getClickCount(),\n+                             me.isPopupTrigger());\n+                        MyTreeTable.this.tree.dispatchEvent(newME);\n+                        break;\n+                    }\n+                }\n+            }\n+            if (me.getClickCount() >= 3) {\n+                return true;\n+            }\n+            return false;\n+        }\n+        if (e == null) {\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n+\n+/**\n+ * Panel that shows information about the context.\n+ */\n+class ContextWindow extends JPanel implements ActionListener {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = 2306040975490228051L;\n+\n+    /**\n+     * The debugger GUI.\n+     */\n+    private SwingGui debugGui;\n+\n+    /**\n+     * The combo box that holds the stack frames.\n+     */\n+    JComboBox context;\n+\n+    /**\n+     * Tool tips for the stack frames.\n+     */\n+    List<String> toolTips;\n+\n+    /**\n+     * Tabbed pane for \"this\" and \"locals\".\n+     */\n+    private JTabbedPane tabs;\n+\n+    /**\n+     * Tabbed pane for \"watch\" and \"evaluate\".\n+     */\n+    private JTabbedPane tabs2;\n+\n+    /**\n+     * The table showing the \"this\" object.\n+     */\n+    private MyTreeTable thisTable;\n+\n+    /**\n+     * The table showing the stack local variables.\n+     */\n+    private MyTreeTable localsTable;\n+\n+    /**\n+     * The {@link #evaluator}'s table model.\n+     */\n+    private MyTableModel tableModel;\n+\n+    /**\n+     * The script evaluator table.\n+     */\n+    private Evaluator evaluator;\n+\n+    /**\n+     * The script evaluation text area.\n+     */\n+    private EvalTextArea cmdLine;\n+\n+    /**\n+     * The split pane.\n+     */\n+    JSplitPane split;\n+\n+    /**\n+     * Whether the ContextWindow is enabled.\n+     */\n+    private boolean enabled;\n+\n+    /**\n+     * Creates a new ContextWindow.\n+     */\n+    public ContextWindow(final SwingGui debugGui) {\n+        this.debugGui = debugGui;\n+        enabled = false;\n+        JPanel left = new JPanel();\n+        JToolBar t1 = new JToolBar();\n+        t1.setName(\"Variables\");\n+        t1.setLayout(new GridLayout());\n+        t1.add(left);\n+        JPanel p1 = new JPanel();\n+        p1.setLayout(new GridLayout());\n+        JPanel p2 = new JPanel();\n+        p2.setLayout(new GridLayout());\n+        p1.add(t1);\n+        JLabel label = new JLabel(\"Context:\");\n+        context = new JComboBox();\n+        context.setLightWeightPopupEnabled(false);\n+        toolTips = Collections.synchronizedList(new java.util.ArrayList<String>());\n+        label.setBorder(context.getBorder());\n+        context.addActionListener(this);\n+        context.setActionCommand(\"ContextSwitch\");\n+        GridBagLayout layout = new GridBagLayout();\n+        left.setLayout(layout);\n+        GridBagConstraints lc = new GridBagConstraints();\n+        lc.insets.left = 5;\n+        lc.anchor = GridBagConstraints.WEST;\n+        lc.ipadx = 5;\n+        layout.setConstraints(label, lc);\n+        left.add(label);\n+        GridBagConstraints c = new GridBagConstraints();\n+        c.gridwidth = GridBagConstraints.REMAINDER;\n+        c.fill = GridBagConstraints.HORIZONTAL;\n+        c.anchor = GridBagConstraints.WEST;\n+        layout.setConstraints(context, c);\n+        left.add(context);\n+        tabs = new JTabbedPane(SwingConstants.BOTTOM);\n+        tabs.setPreferredSize(new Dimension(500,300));\n+        thisTable = new MyTreeTable(new VariableModel());\n+        JScrollPane jsp = new JScrollPane(thisTable);\n+        jsp.getViewport().setViewSize(new Dimension(5,2));\n+        tabs.add(\"this\", jsp);\n+        localsTable = new MyTreeTable(new VariableModel());\n+        localsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);\n+        localsTable.setPreferredSize(null);\n+        jsp = new JScrollPane(localsTable);\n+        tabs.add(\"Locals\", jsp);\n+        c.weightx  = c.weighty = 1;\n+        c.gridheight = GridBagConstraints.REMAINDER;\n+        c.fill = GridBagConstraints.BOTH;\n+        c.anchor = GridBagConstraints.WEST;\n+        layout.setConstraints(tabs, c);\n+        left.add(tabs);\n+        evaluator = new Evaluator(debugGui);\n+        cmdLine = new EvalTextArea(debugGui);\n+        //cmdLine.requestFocus();\n+        tableModel = evaluator.tableModel;\n+        jsp = new JScrollPane(evaluator);\n+        JToolBar t2 = new JToolBar();\n+        t2.setName(\"Evaluate\");\n+        tabs2 = new JTabbedPane(SwingConstants.BOTTOM);\n+        tabs2.add(\"Watch\", jsp);\n+        tabs2.add(\"Evaluate\", new JScrollPane(cmdLine));\n+        tabs2.setPreferredSize(new Dimension(500,300));\n+        t2.setLayout(new GridLayout());\n+        t2.add(tabs2);\n+        p2.add(t2);\n+        evaluator.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);\n+        split = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n+                               p1, p2);\n+        split.setOneTouchExpandable(true);\n+        SwingGui.setResizeWeight(split, 0.5);\n+        setLayout(new BorderLayout());\n+        add(split, BorderLayout.CENTER);\n+\n+        final JToolBar finalT1 = t1;\n+        final JToolBar finalT2 = t2;\n+        final JPanel finalP1 = p1;\n+        final JPanel finalP2 = p2;\n+        final JSplitPane finalSplit = split;\n+        final JPanel finalThis = this;\n+\n+        ComponentListener clistener = new ComponentListener() {\n+                boolean t2Docked = true;\n+                void check(Component comp) {\n+                    Component thisParent = finalThis.getParent();\n+                    if (thisParent == null) {\n+                        return;\n+                    }\n+                    Component parent = finalT1.getParent();\n+                    boolean leftDocked = true;\n+                    boolean rightDocked = true;\n+                    boolean adjustVerticalSplit = false;\n+                    if (parent != null) {\n+                        if (parent != finalP1) {\n+                            while (!(parent instanceof JFrame)) {\n+                                parent = parent.getParent();\n+                            }\n+                            JFrame frame = (JFrame)parent;\n+                            debugGui.addTopLevel(\"Variables\", frame);\n+\n+                            // We need the following hacks because:\n+                            // - We want an undocked toolbar to be\n+                            //   resizable.\n+                            // - We are using JToolbar as a container of a\n+                            //   JComboBox. Without this JComboBox's popup\n+                            //   can get left floating when the toolbar is\n+                            //   re-docked.\n+                            //\n+                            // We make the frame resizable and then\n+                            // remove JToolbar's window listener\n+                            // and insert one of our own that first ensures\n+                            // the JComboBox's popup window is closed\n+                            // and then calls JToolbar's window listener.\n+                            if (!frame.isResizable()) {\n+                                frame.setResizable(true);\n+                                frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);\n+                                final EventListener[] l =\n+                                    frame.getListeners(WindowListener.class);\n+                                frame.removeWindowListener((WindowListener)l[0]);\n+                                frame.addWindowListener(new WindowAdapter() {\n+                                        @Override\n+                                        public void windowClosing(WindowEvent e) {\n+                                            context.hidePopup();\n+                                            ((WindowListener)l[0]).windowClosing(e);\n+                                        }\n+                                    });\n+                                //adjustVerticalSplit = true;\n+                            }\n+                            leftDocked = false;\n+                        } else {\n+                            leftDocked = true;\n+                        }\n+                    }\n+                    parent = finalT2.getParent();\n+                    if (parent != null) {\n+                        if (parent != finalP2) {\n+                            while (!(parent instanceof JFrame)) {\n+                                parent = parent.getParent();\n+                            }\n+                            JFrame frame = (JFrame)parent;\n+                            debugGui.addTopLevel(\"Evaluate\", frame);\n+                            frame.setResizable(true);\n+                            rightDocked = false;\n+                        } else {\n+                            rightDocked = true;\n+                        }\n+                    }\n+                    if (leftDocked && t2Docked && rightDocked && t2Docked) {\n+                        // no change\n+                        return;\n+                    }\n+                    t2Docked = rightDocked;\n+                    JSplitPane split = (JSplitPane)thisParent;\n+                    if (leftDocked) {\n+                        if (rightDocked) {\n+                            finalSplit.setDividerLocation(0.5);\n+                        } else {\n+                            finalSplit.setDividerLocation(1.0);\n+                        }\n+                        if (adjustVerticalSplit) {\n+                            split.setDividerLocation(0.66);\n+                        }\n+\n+                    } else if (rightDocked) {\n+                            finalSplit.setDividerLocation(0.0);\n+                            split.setDividerLocation(0.66);\n+                    } else {\n+                        // both undocked\n+                        split.setDividerLocation(1.0);\n+                    }\n+                }\n+                public void componentHidden(ComponentEvent e) {\n+                    check(e.getComponent());\n+                }\n+                public void componentMoved(ComponentEvent e) {\n+                    check(e.getComponent());\n+                }\n+                public void componentResized(ComponentEvent e) {\n+                    check(e.getComponent());\n+                }\n+                public void componentShown(ComponentEvent e) {\n+                    check(e.getComponent());\n+                }\n+            };\n+        p1.addContainerListener(new ContainerListener() {\n+            public void componentAdded(ContainerEvent e) {\n+                Component thisParent = finalThis.getParent();\n+                JSplitPane split = (JSplitPane)thisParent;\n+                if (e.getChild() == finalT1) {\n+                    if (finalT2.getParent() == finalP2) {\n+                        // both docked\n+                        finalSplit.setDividerLocation(0.5);\n+                    } else {\n+                        // left docked only\n+                        finalSplit.setDividerLocation(1.0);\n+                    }\n+                    split.setDividerLocation(0.66);\n+                }\n+            }\n+            public void componentRemoved(ContainerEvent e) {\n+                Component thisParent = finalThis.getParent();\n+                JSplitPane split = (JSplitPane)thisParent;\n+                if (e.getChild() == finalT1) {\n+                    if (finalT2.getParent() == finalP2) {\n+                        // right docked only\n+                        finalSplit.setDividerLocation(0.0);\n+                        split.setDividerLocation(0.66);\n+                    } else {\n+                        // both undocked\n+                        split.setDividerLocation(1.0);\n+                    }\n+                }\n+            }\n+            });\n+        t1.addComponentListener(clistener);\n+        t2.addComponentListener(clistener);\n+        disable();\n+    }\n+\n+    /**\n+     * Disables the component.\n+     */\n+    @Override\n+    public void disable() {\n+        context.setEnabled(false);\n+        thisTable.setEnabled(false);\n+        localsTable.setEnabled(false);\n+        evaluator.setEnabled(false);\n+        cmdLine.setEnabled(false);\n+    }\n+\n+    /**\n+     * Enables the component.\n+     */\n+    @Override\n+    public void enable() {\n+        context.setEnabled(true);\n+        thisTable.setEnabled(true);\n+        localsTable.setEnabled(true);\n+        evaluator.setEnabled(true);\n+        cmdLine.setEnabled(true);\n+    }\n+\n+    /**\n+     * Disables updating of the component.\n+     */\n+    public void disableUpdate() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Enables updating of the component.\n+     */\n+    public void enableUpdate() {\n+        enabled = true;\n+    }\n+\n+    // ActionListener\n+\n+    /**\n+     * Performs an action.\n+     */\n+    public void actionPerformed(ActionEvent e) {\n+        if (!enabled) return;\n+        if (e.getActionCommand().equals(\"ContextSwitch\")) {\n+            Dim.ContextData contextData = debugGui.dim.currentContextData();\n+            if (contextData == null) { return; }\n+            int frameIndex = context.getSelectedIndex();\n+            context.setToolTipText(toolTips.get(frameIndex));\n+            int frameCount = contextData.frameCount();\n+            if (frameIndex >= frameCount) {\n+                return;\n+            }\n+            Dim.StackFrame frame = contextData.getFrame(frameIndex);\n+            Object scope = frame.scope();\n+            Object thisObj = frame.thisObj();\n+            thisTable.resetTree(new VariableModel(debugGui.dim, thisObj));\n+            VariableModel scopeModel;\n+            if (scope != thisObj) {\n+                scopeModel = new VariableModel(debugGui.dim, scope);\n+            } else {\n+                scopeModel = new VariableModel();\n+            }\n+            localsTable.resetTree(scopeModel);\n+            debugGui.dim.contextSwitch(frameIndex);\n+            debugGui.showStopLine(frame);\n+            tableModel.updateModel();\n+        }\n+    }\n+}\n+\n+/**\n+ * The debugger frame menu bar.\n+ */\n+class Menubar extends JMenuBar implements ActionListener {\n+\n+    /**\n+     * Serializable magic number.\n+     */\n+    private static final long serialVersionUID = 3217170497245911461L;\n+\n+    /**\n+     * Items that are enabled only when interrupted.\n+     */\n+    private List<JMenuItem> interruptOnlyItems = \n+        Collections.synchronizedList(new ArrayList<JMenuItem>());\n+\n+    /**\n+     * Items that are enabled only when running.\n+     */\n+    private List<JMenuItem> runOnlyItems = \n+        Collections.synchronizedList(new ArrayList<JMenuItem>());\n+\n+    /**\n+     * The debugger GUI.\n+     */\n+    private SwingGui debugGui;\n+\n+    /**\n+     * The menu listing the internal frames.\n+     */\n+    private JMenu windowMenu;\n+\n+    /**\n+     * The \"Break on exceptions\" menu item.\n+     */\n+    private JCheckBoxMenuItem breakOnExceptions;\n+\n+    /**\n+     * The \"Break on enter\" menu item.\n+     */\n+    private JCheckBoxMenuItem breakOnEnter;\n+\n+    /**\n+     * The \"Break on return\" menu item.\n+     */\n+    private JCheckBoxMenuItem breakOnReturn;\n+\n+    /**\n+     * Creates a new Menubar.\n+     */\n+    Menubar(SwingGui debugGui) {\n+        super();\n+        this.debugGui = debugGui;\n+        String[] fileItems  = {\"Open...\", \"Run...\", \"\", \"Exit\"};\n+        String[] fileCmds  = {\"Open\", \"Load\", \"\", \"Exit\"};\n+        char[] fileShortCuts = {'0', 'N', 0, 'X'};\n+        int[] fileAccelerators = {KeyEvent.VK_O,\n+                                  KeyEvent.VK_N,\n+                                  0,\n+                                  KeyEvent.VK_Q};\n+        String[] editItems = {\"Cut\", \"Copy\", \"Paste\", \"Go to function...\"};\n+        char[] editShortCuts = {'T', 'C', 'P', 'F'};\n+        String[] debugItems = {\"Break\", \"Go\", \"Step Into\", \"Step Over\", \"Step Out\"};\n+        char[] debugShortCuts = {'B', 'G', 'I', 'O', 'T'};\n+        String[] plafItems = {\"Metal\", \"Windows\", \"Motif\"};\n+        char [] plafShortCuts = {'M', 'W', 'F'};\n+        int[] debugAccelerators = {KeyEvent.VK_PAUSE,\n+                                   KeyEvent.VK_F5,\n+                                   KeyEvent.VK_F11,\n+                                   KeyEvent.VK_F7,\n+                                   KeyEvent.VK_F8,\n+                                   0, 0};\n+\n+        JMenu fileMenu = new JMenu(\"File\");\n+        fileMenu.setMnemonic('F');\n+        JMenu editMenu = new JMenu(\"Edit\");\n+        editMenu.setMnemonic('E');\n+        JMenu plafMenu = new JMenu(\"Platform\");\n+        plafMenu.setMnemonic('P');\n+        JMenu debugMenu = new JMenu(\"Debug\");\n+        debugMenu.setMnemonic('D');\n+        windowMenu = new JMenu(\"Window\");\n+        windowMenu.setMnemonic('W');\n+        for (int i = 0; i < fileItems.length; ++i) {\n+            if (fileItems[i].length() == 0) {\n+                fileMenu.addSeparator();\n+            } else {\n+                JMenuItem item = new JMenuItem(fileItems[i],\n+                                               fileShortCuts[i]);\n+                item.setActionCommand(fileCmds[i]);\n+                item.addActionListener(this);\n+                fileMenu.add(item);\n+                if (fileAccelerators[i] != 0) {\n+                    KeyStroke k = KeyStroke.getKeyStroke(fileAccelerators[i], Event.CTRL_MASK);\n+                    item.setAccelerator(k);\n+                }\n+            }\n+        }\n+        for (int i = 0; i < editItems.length; ++i) {\n+            JMenuItem item = new JMenuItem(editItems[i],\n+                                           editShortCuts[i]);\n+            item.addActionListener(this);\n+            editMenu.add(item);\n+        }\n+        for (int i = 0; i < plafItems.length; ++i) {\n+            JMenuItem item = new JMenuItem(plafItems[i],\n+                                           plafShortCuts[i]);\n+            item.addActionListener(this);\n+            plafMenu.add(item);\n+        }\n+        for (int i = 0; i < debugItems.length; ++i) {\n+            JMenuItem item = new JMenuItem(debugItems[i],\n+                                           debugShortCuts[i]);\n+            item.addActionListener(this);\n+            if (debugAccelerators[i] != 0) {\n+                KeyStroke k = KeyStroke.getKeyStroke(debugAccelerators[i], 0);\n+                item.setAccelerator(k);\n+            }\n+            if (i != 0) {\n+                interruptOnlyItems.add(item);\n+            } else {\n+                runOnlyItems.add(item);\n+            }\n+            debugMenu.add(item);\n+        }\n+        breakOnExceptions = new JCheckBoxMenuItem(\"Break on Exceptions\");\n+        breakOnExceptions.setMnemonic('X');\n+        breakOnExceptions.addActionListener(this);\n+        breakOnExceptions.setSelected(false);\n+        debugMenu.add(breakOnExceptions);\n+\n+        breakOnEnter = new JCheckBoxMenuItem(\"Break on Function Enter\");\n+        breakOnEnter.setMnemonic('E');\n+        breakOnEnter.addActionListener(this);\n+        breakOnEnter.setSelected(false);\n+        debugMenu.add(breakOnEnter);\n+\n+        breakOnReturn = new JCheckBoxMenuItem(\"Break on Function Return\");\n+        breakOnReturn.setMnemonic('R');\n+        breakOnReturn.addActionListener(this);\n+        breakOnReturn.setSelected(false);\n+        debugMenu.add(breakOnReturn);\n+\n+        add(fileMenu);\n+        add(editMenu);\n+        //add(plafMenu);\n+        add(debugMenu);\n+        JMenuItem item;\n+        windowMenu.add(item = new JMenuItem(\"Cascade\", 'A'));\n+        item.addActionListener(this);\n+        windowMenu.add(item = new JMenuItem(\"Tile\", 'T'));\n+        item.addActionListener(this);\n+        windowMenu.addSeparator();\n+        windowMenu.add(item = new JMenuItem(\"Console\", 'C'));\n+        item.addActionListener(this);\n+        add(windowMenu);\n+\n+        updateEnabled(false);\n+    }\n+\n+    /**\n+     * Returns the \"Break on exceptions\" menu item.\n+     */\n+    public JCheckBoxMenuItem getBreakOnExceptions() {\n+        return breakOnExceptions;\n+    }\n+\n+    /**\n+     * Returns the \"Break on enter\" menu item.\n+     */\n+    public JCheckBoxMenuItem getBreakOnEnter() {\n+        return breakOnEnter;\n+    }\n+\n+    /**\n+     * Returns the \"Break on return\" menu item.\n+     */\n+    public JCheckBoxMenuItem getBreakOnReturn() {\n+        return breakOnReturn;\n+    }\n+\n+    /**\n+     * Returns the \"Debug\" menu.\n+     */\n+    public JMenu getDebugMenu() {\n+        return getMenu(2);\n+    }\n+\n+    // ActionListener\n+\n+    /**\n+     * Performs an action.\n+     */\n+    public void actionPerformed(ActionEvent e) {\n+        String cmd = e.getActionCommand();\n+        String plaf_name = null;\n+        if (cmd.equals(\"Metal\")) {\n+            plaf_name = \"javax.swing.plaf.metal.MetalLookAndFeel\";\n+        } else if (cmd.equals(\"Windows\")) {\n+            plaf_name = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\n+        } else if (cmd.equals(\"Motif\")) {\n+            plaf_name = \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\";\n+        } else {\n+            Object source = e.getSource();\n+            if (source == breakOnExceptions) {\n+                debugGui.dim.setBreakOnExceptions(breakOnExceptions.isSelected());\n+            } else if (source == breakOnEnter) {\n+                debugGui.dim.setBreakOnEnter(breakOnEnter.isSelected());\n+            } else if (source == breakOnReturn) {\n+                debugGui.dim.setBreakOnReturn(breakOnReturn.isSelected());\n+            } else {\n+                debugGui.actionPerformed(e);\n+            }\n+            return;\n+        }\n+        try {\n+            UIManager.setLookAndFeel(plaf_name);\n+            SwingUtilities.updateComponentTreeUI(debugGui);\n+            SwingUtilities.updateComponentTreeUI(debugGui.dlg);\n+        } catch (Exception ignored) {\n+            //ignored.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the window menu.\n+     */\n+    public void addFile(String url) {\n+        int count = windowMenu.getItemCount();\n+        JMenuItem item;\n+        if (count == 4) {\n+            windowMenu.addSeparator();\n+            count++;\n+        }\n+        JMenuItem lastItem = windowMenu.getItem(count -1);\n+        boolean hasMoreWin = false;\n+        int maxWin = 5;\n+        if (lastItem != null &&\n+           lastItem.getText().equals(\"More Windows...\")) {\n+            hasMoreWin = true;\n+            maxWin++;\n+        }\n+        if (!hasMoreWin && count - 4 == 5) {\n+            windowMenu.add(item = new JMenuItem(\"More Windows...\", 'M'));\n+            item.setActionCommand(\"More Windows...\");\n+            item.addActionListener(this);\n+            return;\n+        } else if (count - 4 <= maxWin) {\n+            if (hasMoreWin) {\n+                count--;\n+                windowMenu.remove(lastItem);\n+            }\n+            String shortName = SwingGui.getShortName(url);\n+\n+            windowMenu.add(item = new JMenuItem((char)('0' + (count-4)) + \" \" + shortName, '0' + (count - 4)));\n+            if (hasMoreWin) {\n+                windowMenu.add(lastItem);\n+            }\n+        } else {\n+            return;\n+        }\n+        item.setActionCommand(url);\n+        item.addActionListener(this);\n+    }\n+\n+    /**\n+     * Updates the enabledness of menu items.\n+     */\n+    public void updateEnabled(boolean interrupted) {\n+        for (int i = 0; i != interruptOnlyItems.size(); ++i) {\n+            JMenuItem item = interruptOnlyItems.get(i);\n+            item.setEnabled(interrupted);\n+        }\n+\n+        for (int i = 0; i != runOnlyItems.size(); ++i) {\n+            JMenuItem item = runOnlyItems.get(i);\n+            item.setEnabled(!interrupted);\n+        }\n+    }\n+}\n+\n+/**\n+ * Class to consolidate all cases that require to implement Runnable\n+ * to avoid class generation bloat.\n+ */\n+class RunProxy implements Runnable {\n+\n+    // Constants for 'type'.\n+    static final int OPEN_FILE = 1;\n+    static final int LOAD_FILE = 2;\n+    static final int UPDATE_SOURCE_TEXT = 3;\n+    static final int ENTER_INTERRUPT = 4;\n+\n+    /**\n+     * The debugger GUI.\n+     */\n+    private SwingGui debugGui;\n+\n+    /**\n+     * The type of Runnable this object is.  Takes one of the constants\n+     * defined in this class.\n+     */\n+    private int type;\n+\n+    /**\n+     * The name of the file to open or load.\n+     */\n+    String fileName;\n+\n+    /**\n+     * The source text to update.\n+     */\n+    String text;\n+\n+    /**\n+     * The source for which to update the text.\n+     */\n+    Dim.SourceInfo sourceInfo;\n+\n+    /**\n+     * The frame to interrupt in.\n+     */\n+    Dim.StackFrame lastFrame;\n+\n+    /**\n+     * The name of the interrupted thread.\n+     */\n+    String threadTitle;\n+\n+    /**\n+     * The message of the exception thrown that caused the thread\n+     * interruption, if any.\n+     */\n+    String alertMessage;\n+\n+    /**\n+     * Creates a new RunProxy.\n+     */\n+    public RunProxy(SwingGui debugGui, int type) {\n+        this.debugGui = debugGui;\n+        this.type = type;\n+    }\n+\n+    /**\n+     * Runs this Runnable.\n+     */\n+    public void run() {\n+        switch (type) {\n+          case OPEN_FILE:\n+            try {\n+                debugGui.dim.compileScript(fileName, text);\n+            } catch (RuntimeException ex) {\n+                MessageDialogWrapper.showMessageDialog(\n+                    debugGui, ex.getMessage(), \"Error Compiling \"+fileName,\n+                    JOptionPane.ERROR_MESSAGE);\n+            }\n+            break;\n+\n+          case LOAD_FILE:\n+            try {\n+                debugGui.dim.evalScript(fileName, text);\n+            } catch (RuntimeException ex) {\n+                MessageDialogWrapper.showMessageDialog(\n+                    debugGui, ex.getMessage(), \"Run error for \"+fileName,\n+                    JOptionPane.ERROR_MESSAGE);\n+            }\n+            break;\n+\n+          case UPDATE_SOURCE_TEXT:\n+            {\n+                String fileName = sourceInfo.url();\n+                if (!debugGui.updateFileWindow(sourceInfo) &&\n+                        !fileName.equals(\"<stdin>\")) {\n+                    debugGui.createFileWindow(sourceInfo, -1);\n+                }\n+            }\n+            break;\n+\n+          case ENTER_INTERRUPT:\n+            debugGui.enterInterruptImpl(lastFrame, threadTitle, alertMessage);\n+            break;\n+\n+          default:\n+            throw new IllegalArgumentException(String.valueOf(type));\n+\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/debugger/treetable/AbstractCellEditor.java\n+/*\n+ * Copyright 1998 Sun Microsystems, Inc.  All Rights Reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Sun Microsystems nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package org.mozilla.javascript.tools.debugger.treetable;\n+\n+import javax.swing.*;\n+import javax.swing.event.*;\n+import java.util.EventObject;\n+\n+public class AbstractCellEditor implements CellEditor {\n+\n+    protected EventListenerList listenerList = new EventListenerList();\n+\n+    public Object getCellEditorValue() { return null; }\n+    public boolean isCellEditable(EventObject e) { return true; }\n+    public boolean shouldSelectCell(EventObject anEvent) { return false; }\n+    public boolean stopCellEditing() { return true; }\n+    public void cancelCellEditing() {}\n+\n+    public void addCellEditorListener(CellEditorListener l) {\n+        listenerList.add(CellEditorListener.class, l);\n+    }\n+\n+    public void removeCellEditorListener(CellEditorListener l) {\n+        listenerList.remove(CellEditorListener.class, l);\n+    }\n+\n+    /*\n+     * Notify all listeners that have registered interest for\n+     * notification on this event type.  \n+     * @see EventListenerList\n+     */\n+    protected void fireEditingStopped() {\n+        // Guaranteed to return a non-null array\n+        Object[] listeners = listenerList.getListenerList();\n+        // Process the listeners last to first, notifying\n+        // those that are interested in this event\n+        for (int i = listeners.length-2; i>=0; i-=2) {\n+            if (listeners[i]==CellEditorListener.class) {\n+                ((CellEditorListener)listeners[i+1]).editingStopped(new ChangeEvent(this));\n+            }          \n+        }\n+    }\n+\n+    /*\n+     * Notify all listeners that have registered interest for\n+     * notification on this event type.  \n+     * @see EventListenerList\n+     */\n+    protected void fireEditingCanceled() {\n+        // Guaranteed to return a non-null array\n+        Object[] listeners = listenerList.getListenerList();\n+        // Process the listeners last to first, notifying\n+        // those that are interested in this event\n+        for (int i = listeners.length-2; i>=0; i-=2) {\n+            if (listeners[i]==CellEditorListener.class) {\n+                ((CellEditorListener)listeners[i+1]).editingCanceled(new ChangeEvent(this));\n+            }          \n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/debugger/treetable/JTreeTable.java\n+/*\n+ * @(#)JTreeTable.java  1.2 98/10/27\n+ *\n+ * Copyright 1997, 1998 Sun Microsystems, Inc.  All Rights Reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Sun Microsystems nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package org.mozilla.javascript.tools.debugger.treetable;\n+\n+import javax.swing.*;\n+import javax.swing.event.*;\n+import javax.swing.tree.*;\n+import javax.swing.table.*;\n+\n+import java.awt.Dimension;\n+import java.awt.Component;\n+import java.awt.Graphics;\n+\n+import java.awt.event.MouseEvent;\n+\n+import java.util.EventObject;\n+\n+/**\n+ * This example shows how to create a simple JTreeTable component,\n+ * by using a JTree as a renderer (and editor) for the cells in a\n+ * particular column in the JTable.\n+ *\n+ * @version 1.2 10/27/98\n+ *\n+ */\n+public class JTreeTable extends JTable {\n+    /**\n+     *\n+     */\n+    private static final long serialVersionUID = -2103973006456695515L;\n+    /** A subclass of JTree. */\n+    protected TreeTableCellRenderer tree;\n+\n+    public JTreeTable(TreeTableModel treeTableModel) {\n+        super();\n+\n+        // Create the tree. It will be used as a renderer and editor.\n+        tree = new TreeTableCellRenderer(treeTableModel);\n+\n+        // Install a tableModel representing the visible rows in the tree.\n+        super.setModel(new TreeTableModelAdapter(treeTableModel, tree));\n+\n+        // Force the JTable and JTree to share their row selection models.\n+        ListToTreeSelectionModelWrapper selectionWrapper = new\n+                                ListToTreeSelectionModelWrapper();\n+        tree.setSelectionModel(selectionWrapper);\n+        setSelectionModel(selectionWrapper.getListSelectionModel());\n+\n+        // Install the tree editor renderer and editor.\n+        setDefaultRenderer(TreeTableModel.class, tree);\n+        setDefaultEditor(TreeTableModel.class, new TreeTableCellEditor());\n+\n+        // No grid.\n+        setShowGrid(false);\n+\n+        // No intercell spacing\n+        setIntercellSpacing(new Dimension(0, 0));\n+\n+        // And update the height of the trees row to match that of\n+        // the table.\n+        if (tree.getRowHeight() < 1) {\n+            // Metal looks better like this.\n+            setRowHeight(18);\n+        }\n+    }\n+\n+    /**\n+     * Overridden to message super and forward the method to the tree.\n+     * Since the tree is not actually in the component hierarchy it will\n+     * never receive this unless we forward it in this manner.\n+     */\n+    @Override\n+    public void updateUI() {\n+        super.updateUI();\n+        if(tree != null) {\n+            tree.updateUI();\n+        }\n+        // Use the tree's default foreground and background colors in the\n+        // table.\n+        LookAndFeel.installColorsAndFont(this, \"Tree.background\",\n+                                         \"Tree.foreground\", \"Tree.font\");\n+    }\n+\n+    /* Workaround for BasicTableUI anomaly. Make sure the UI never tries to\n+     * paint the editor. The UI currently uses different techniques to\n+     * paint the renderers and editors and overriding setBounds() below\n+     * is not the right thing to do for an editor. Returning -1 for the\n+     * editing row in this case, ensures the editor is never painted.\n+     */\n+    @Override\n+    public int getEditingRow() {\n+        return (getColumnClass(editingColumn) == TreeTableModel.class) ? -1 :\n+                editingRow;\n+    }\n+\n+    /**\n+     * Overridden to pass the new rowHeight to the tree.\n+     */\n+    @Override\n+    public void setRowHeight(int rowHeight) {\n+        super.setRowHeight(rowHeight);\n+        if (tree != null && tree.getRowHeight() != rowHeight) {\n+            tree.setRowHeight(getRowHeight());\n+        }\n+    }\n+\n+    /**\n+     * Returns the tree that is being shared between the model.\n+     */\n+    public JTree getTree() {\n+        return tree;\n+    }\n+\n+    /**\n+     * A TreeCellRenderer that displays a JTree.\n+     */\n+    public class TreeTableCellRenderer extends JTree implements TableCellRenderer {\n+        private static final long serialVersionUID = -193867880014600717L;\n+        /** Last table/tree row asked to renderer. */\n+        protected int visibleRow;\n+\n+        public TreeTableCellRenderer(TreeModel model) {\n+            super(model);\n+        }\n+\n+        /**\n+         * updateUI is overridden to set the colors of the Tree's renderer\n+         * to match that of the table.\n+         */\n+        @Override\n+        public void updateUI() {\n+            super.updateUI();\n+            // Make the tree's cell renderer use the table's cell selection\n+            // colors.\n+            TreeCellRenderer tcr = getCellRenderer();\n+            if (tcr instanceof DefaultTreeCellRenderer) {\n+                DefaultTreeCellRenderer dtcr = ((DefaultTreeCellRenderer)tcr);\n+                // For 1.1 uncomment this, 1.2 has a bug that will cause an\n+                // exception to be thrown if the border selection color is\n+                // null.\n+                // dtcr.setBorderSelectionColor(null);\n+                dtcr.setTextSelectionColor(UIManager.getColor\n+                                           (\"Table.selectionForeground\"));\n+                dtcr.setBackgroundSelectionColor(UIManager.getColor\n+                                                (\"Table.selectionBackground\"));\n+            }\n+        }\n+\n+        /**\n+         * Sets the row height of the tree, and forwards the row height to\n+         * the table.\n+         */\n+        @Override\n+        public void setRowHeight(int rowHeight) {\n+            if (rowHeight > 0) {\n+                super.setRowHeight(rowHeight);\n+                if (JTreeTable.this != null &&\n+                    JTreeTable.this.getRowHeight() != rowHeight) {\n+                    JTreeTable.this.setRowHeight(getRowHeight());\n+                }\n+            }\n+        }\n+\n+        /**\n+         * This is overridden to set the height to match that of the JTable.\n+         */\n+        @Override\n+        public void setBounds(int x, int y, int w, int h) {\n+            super.setBounds(x, 0, w, JTreeTable.this.getHeight());\n+        }\n+\n+        /**\n+         * Sublcassed to translate the graphics such that the last visible\n+         * row will be drawn at 0,0.\n+         */\n+        @Override\n+        public void paint(Graphics g) {\n+            g.translate(0, -visibleRow * getRowHeight());\n+            super.paint(g);\n+        }\n+\n+        /**\n+         * TreeCellRenderer method. Overridden to update the visible row.\n+         */\n+        public Component getTableCellRendererComponent(JTable table,\n+                                                       Object value,\n+                                                       boolean isSelected,\n+                                                       boolean hasFocus,\n+                                                       int row, int column) {\n+            if(isSelected)\n+                setBackground(table.getSelectionBackground());\n+            else\n+                setBackground(table.getBackground());\n+\n+            visibleRow = row;\n+            return this;\n+        }\n+    }\n+\n+\n+    /**\n+     * TreeTableCellEditor implementation. Component returned is the\n+     * JTree.\n+     */\n+    public class TreeTableCellEditor extends AbstractCellEditor implements\n+                 TableCellEditor {\n+        public Component getTableCellEditorComponent(JTable table,\n+                                                     Object value,\n+                                                     boolean isSelected,\n+                                                     int r, int c) {\n+            return tree;\n+        }\n+\n+        /**\n+         * Overridden to return false, and if the event is a mouse event\n+         * it is forwarded to the tree.<p>\n+         * The behavior for this is debatable, and should really be offered\n+         * as a property. By returning false, all keyboard actions are\n+         * implemented in terms of the table. By returning true, the\n+         * tree would get a chance to do something with the keyboard\n+         * events. For the most part this is ok. But for certain keys,\n+         * such as left/right, the tree will expand/collapse where as\n+         * the table focus should really move to a different column. Page\n+         * up/down should also be implemented in terms of the table.\n+         * By returning false this also has the added benefit that clicking\n+         * outside of the bounds of the tree node, but still in the tree\n+         * column will select the row, whereas if this returned true\n+         * that wouldn't be the case.\n+         * <p>By returning false we are also enforcing the policy that\n+         * the tree will never be editable (at least by a key sequence).\n+         */\n+        @Override\n+        public boolean isCellEditable(EventObject e) {\n+            if (e instanceof MouseEvent) {\n+                for (int counter = getColumnCount() - 1; counter >= 0;\n+                     counter--) {\n+                    if (getColumnClass(counter) == TreeTableModel.class) {\n+                        MouseEvent me = (MouseEvent)e;\n+                        MouseEvent newME = new MouseEvent(tree, me.getID(),\n+                                   me.getWhen(), me.getModifiers(),\n+                                   me.getX() - getCellRect(0, counter, true).x,\n+                                   me.getY(), me.getClickCount(),\n+                                   me.isPopupTrigger());\n+                        tree.dispatchEvent(newME);\n+                        break;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+\n+    /**\n+     * ListToTreeSelectionModelWrapper extends DefaultTreeSelectionModel\n+     * to listen for changes in the ListSelectionModel it maintains. Once\n+     * a change in the ListSelectionModel happens, the paths are updated\n+     * in the DefaultTreeSelectionModel.\n+     */\n+    public class ListToTreeSelectionModelWrapper\n+        extends DefaultTreeSelectionModel\n+    {\n+        private static final long serialVersionUID = 8168140829623071131L;\n+\n+        /** Set to true when we are updating the ListSelectionModel. */\n+        protected boolean         updatingListSelectionModel;\n+\n+        public ListToTreeSelectionModelWrapper() {\n+            super();\n+            getListSelectionModel().addListSelectionListener\n+                                    (createListSelectionListener());\n+        }\n+\n+        /**\n+         * Returns the list selection model. ListToTreeSelectionModelWrapper\n+         * listens for changes to this model and updates the selected paths\n+         * accordingly.\n+         */\n+        public ListSelectionModel getListSelectionModel() {\n+            return listSelectionModel;\n+        }\n+\n+        /**\n+         * This is overridden to set <code>updatingListSelectionModel</code>\n+         * and message super. This is the only place DefaultTreeSelectionModel\n+         * alters the ListSelectionModel.\n+         */\n+        @Override\n+        public void resetRowSelection() {\n+            if(!updatingListSelectionModel) {\n+                updatingListSelectionModel = true;\n+                try {\n+                    super.resetRowSelection();\n+                }\n+                finally {\n+                    updatingListSelectionModel = false;\n+                }\n+            }\n+            // Notice how we don't message super if\n+            // updatingListSelectionModel is true. If\n+            // updatingListSelectionModel is true, it implies the\n+            // ListSelectionModel has already been updated and the\n+            // paths are the only thing that needs to be updated.\n+        }\n+\n+        /**\n+         * Creates and returns an instance of ListSelectionHandler.\n+         */\n+        protected ListSelectionListener createListSelectionListener() {\n+            return new ListSelectionHandler();\n+        }\n+\n+        /**\n+         * If <code>updatingListSelectionModel</code> is false, this will\n+         * reset the selected paths from the selected rows in the list\n+         * selection model.\n+         */\n+        protected void updateSelectedPathsFromSelectedRows() {\n+            if(!updatingListSelectionModel) {\n+                updatingListSelectionModel = true;\n+                try {\n+                    // This is way expensive, ListSelectionModel needs an\n+                    // enumerator for iterating.\n+                    int        min = listSelectionModel.getMinSelectionIndex();\n+                    int        max = listSelectionModel.getMaxSelectionIndex();\n+\n+                    clearSelection();\n+                    if(min != -1 && max != -1) {\n+                        for(int counter = min; counter <= max; counter++) {\n+                            if(listSelectionModel.isSelectedIndex(counter)) {\n+                                TreePath     selPath = tree.getPathForRow\n+                                                            (counter);\n+\n+                                if(selPath != null) {\n+                                    addSelectionPath(selPath);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                finally {\n+                    updatingListSelectionModel = false;\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Class responsible for calling updateSelectedPathsFromSelectedRows\n+         * when the selection of the list changse.\n+         */\n+        class ListSelectionHandler implements ListSelectionListener {\n+            public void valueChanged(ListSelectionEvent e) {\n+                updateSelectedPathsFromSelectedRows();\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/debugger/treetable/TreeTableModel.java\n+/*\n+ * TreeTableModel.java\n+ *\n+ * Copyright 1998 Sun Microsystems, Inc.  All Rights Reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Sun Microsystems nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package org.mozilla.javascript.tools.debugger.treetable;\n+\n+import javax.swing.tree.TreeModel;\n+\n+/**\n+ * TreeTableModel is the model used by a JTreeTable. It extends TreeModel\n+ * to add methods for getting inforamtion about the set of columns each\n+ * node in the TreeTableModel may have. Each column, like a column in\n+ * a TableModel, has a name and a type associated with it. Each node in\n+ * the TreeTableModel can return a value for each of the columns and\n+ * set that value if isCellEditable() returns true.\n+ *\n+ */\n+public interface TreeTableModel extends TreeModel\n+{\n+    /**\n+     * Returns the number ofs availible column.\n+     */\n+    public int getColumnCount();\n+\n+    /**\n+     * Returns the name for column number <code>column</code>.\n+     */\n+    public String getColumnName(int column);\n+\n+    /**\n+     * Returns the type for column number <code>column</code>.\n+     */\n+    public Class<?> getColumnClass(int column);\n+\n+    /**\n+     * Returns the value to be displayed for node <code>node</code>,\n+     * at column number <code>column</code>.\n+     */\n+    public Object getValueAt(Object node, int column);\n+\n+    /**\n+     * Indicates whether the the value for node <code>node</code>,\n+     * at column number <code>column</code> is editable.\n+     */\n+    public boolean isCellEditable(Object node, int column);\n+\n+    /**\n+     * Sets the value for node <code>node</code>,\n+     * at column number <code>column</code>.\n+     */\n+    public void setValueAt(Object aValue, Object node, int column);\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/debugger/treetable/TreeTableModelAdapter.java\n+/*\n+ * @(#)TreeTableModelAdapter.java       1.2 98/10/27\n+ *\n+ * Copyright 1997, 1998 Sun Microsystems, Inc.  All Rights Reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Sun Microsystems nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package org.mozilla.javascript.tools.debugger.treetable;\n+\n+import javax.swing.JTree;\n+import javax.swing.SwingUtilities;\n+import javax.swing.table.AbstractTableModel;\n+import javax.swing.tree.TreePath;\n+import javax.swing.event.TreeExpansionEvent;\n+import javax.swing.event.TreeExpansionListener;\n+import javax.swing.event.TreeModelEvent;\n+import javax.swing.event.TreeModelListener;\n+\n+/**\n+ * This is a wrapper class takes a TreeTableModel and implements\n+ * the table model interface. The implementation is trivial, with\n+ * all of the event dispatching support provided by the superclass:\n+ * the AbstractTableModel.\n+ *\n+ * @version 1.2 10/27/98\n+ *\n+ */\n+public class TreeTableModelAdapter extends AbstractTableModel {\n+    private static final long serialVersionUID = 48741114609209052L;\n+    JTree tree;\n+    TreeTableModel treeTableModel;\n+\n+    public TreeTableModelAdapter(TreeTableModel treeTableModel, JTree tree) {\n+        this.tree = tree;\n+        this.treeTableModel = treeTableModel;\n+\n+        tree.addTreeExpansionListener(new TreeExpansionListener() {\n+            // Don't use fireTableRowsInserted() here; the selection model\n+            // would get updated twice.\n+            public void treeExpanded(TreeExpansionEvent event) {\n+              fireTableDataChanged();\n+            }\n+            public void treeCollapsed(TreeExpansionEvent event) {\n+              fireTableDataChanged();\n+            }\n+        });\n+\n+        // Install a TreeModelListener that can update the table when\n+        // tree changes. We use delayedFireTableDataChanged as we can\n+        // not be guaranteed the tree will have finished processing\n+        // the event before us.\n+        treeTableModel.addTreeModelListener(new TreeModelListener() {\n+            public void treeNodesChanged(TreeModelEvent e) {\n+                delayedFireTableDataChanged();\n+            }\n+\n+            public void treeNodesInserted(TreeModelEvent e) {\n+                delayedFireTableDataChanged();\n+            }\n+\n+            public void treeNodesRemoved(TreeModelEvent e) {\n+                delayedFireTableDataChanged();\n+            }\n+\n+            public void treeStructureChanged(TreeModelEvent e) {\n+                delayedFireTableDataChanged();\n+            }\n+        });\n+    }\n+\n+    // Wrappers, implementing TableModel interface.\n+\n+    public int getColumnCount() {\n+        return treeTableModel.getColumnCount();\n+    }\n+\n+    @Override\n+    public String getColumnName(int column) {\n+        return treeTableModel.getColumnName(column);\n+    }\n+\n+    @Override\n+    public Class<?> getColumnClass(int column) {\n+        return treeTableModel.getColumnClass(column);\n+    }\n+\n+    public int getRowCount() {\n+        return tree.getRowCount();\n+    }\n+\n+    protected Object nodeForRow(int row) {\n+        TreePath treePath = tree.getPathForRow(row);\n+        return treePath.getLastPathComponent();\n+    }\n+\n+    public Object getValueAt(int row, int column) {\n+        return treeTableModel.getValueAt(nodeForRow(row), column);\n+    }\n+\n+    @Override\n+    public boolean isCellEditable(int row, int column) {\n+         return treeTableModel.isCellEditable(nodeForRow(row), column);\n+    }\n+\n+    @Override\n+    public void setValueAt(Object value, int row, int column) {\n+        treeTableModel.setValueAt(value, nodeForRow(row), column);\n+    }\n+\n+    /**\n+     * Invokes fireTableDataChanged after all the pending events have been\n+     * processed. SwingUtilities.invokeLater is used to handle this.\n+     */\n+    protected void delayedFireTableDataChanged() {\n+        SwingUtilities.invokeLater(new Runnable() {\n+            public void run() {\n+                fireTableDataChanged();\n+            }\n+        });\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/idswitch/CodePrinter.java\n+/* -*- Mode: java; tab-width: 4; indent-tabs-mode: 1; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+package org.mozilla.javascript.tools.idswitch;\n+\n+class CodePrinter {\n+\n+// length of u-type escape like \\u12AB\n+    private static final int LITERAL_CHAR_MAX_SIZE = 6;\n+\n+    private String lineTerminator = \"\\n\";\n+\n+    private int indentStep = 4;\n+    private int indentTabSize = 8;\n+\n+    private char[] buffer = new char[1 << 12]; // 4K\n+    private int offset;\n+\n+    public String getLineTerminator() { return lineTerminator; }\n+    public void setLineTerminator(String value) { lineTerminator = value; }\n+\n+    public int getIndentStep() { return indentStep; }\n+    public void setIndentStep(int char_count) { indentStep = char_count; }\n+\n+    public int getIndentTabSize() {    return indentTabSize; }\n+    public void setIndentTabSize(int tab_size) { indentTabSize = tab_size; }\n+\n+    public void clear() {\n+        offset = 0;\n+    }\n+\n+    private int ensure_area(int area_size) {\n+        int begin = offset;\n+        int end = begin + area_size;\n+        if (end > buffer.length) {\n+            int new_capacity = buffer.length * 2;\n+            if (end > new_capacity) { new_capacity = end; }\n+            char[] tmp = new char[new_capacity];\n+            System.arraycopy(buffer, 0, tmp, 0, begin);\n+            buffer = tmp;\n+        }\n+        return begin;\n+    }\n+\n+    private int add_area(int area_size) {\n+        int pos = ensure_area(area_size);\n+        offset = pos + area_size;\n+        return pos;\n+    }\n+\n+    public int getOffset() {\n+        return offset;\n+    }\n+\n+    public int getLastChar() {\n+        return offset == 0 ? -1 : buffer[offset - 1];\n+    }\n+\n+    public void p(char c) {\n+        int pos = add_area(1);\n+        buffer[pos] = c;\n+    }\n+\n+    public void p(String s) {\n+        int l = s.length();\n+        int pos = add_area(l);\n+        s.getChars(0, l, buffer, pos);\n+    }\n+\n+    public final void p(char[] array) {\n+        p(array, 0, array.length);\n+    }\n+\n+    public void p(char[] array, int begin, int end) {\n+        int l = end - begin;\n+        int pos = add_area(l);\n+        System.arraycopy(array, begin, buffer, pos, l);\n+    }\n+\n+    public void p(int i) {\n+        p(Integer.toString(i));\n+    }\n+\n+    public void qchar(int c) {\n+        int pos = ensure_area(2 + LITERAL_CHAR_MAX_SIZE);\n+        buffer[pos] = '\\'';\n+        pos = put_string_literal_char(pos + 1, c, false);\n+        buffer[pos] = '\\'';\n+        offset = pos + 1;\n+    }\n+\n+    public void qstring(String s) {\n+        int l = s.length();\n+        int pos = ensure_area(2 + LITERAL_CHAR_MAX_SIZE * l);\n+        buffer[pos] = '\"';\n+        ++pos;\n+        for (int i = 0; i != l; ++i) {\n+            pos = put_string_literal_char(pos, s.charAt(i), true);\n+        }\n+        buffer[pos] = '\"';\n+        offset = pos + 1;\n+    }\n+\n+    private int put_string_literal_char(int pos, int c, boolean in_string) {\n+        boolean backslash_symbol = true;\n+        switch (c) {\n+            case '\\b': c = 'b'; break;\n+            case '\\t': c = 't'; break;\n+            case '\\n': c = 'n'; break;\n+            case '\\f': c = 'f'; break;\n+            case '\\r': c = 'r'; break;\n+            case '\\'': backslash_symbol = !in_string; break;\n+            case '\"': backslash_symbol = in_string; break;\n+            default: backslash_symbol = false;\n+        }\n+\n+        if (backslash_symbol) {\n+            buffer[pos] = '\\\\';\n+            buffer[pos + 1] = (char)c;\n+            pos += 2;\n+        }\n+        else if (' ' <= c && c <= 126) {\n+            buffer[pos] = (char)c;\n+            ++pos;\n+        }\n+        else {\n+            buffer[pos] = '\\\\';\n+            buffer[pos + 1] = 'u';\n+            buffer[pos + 2] = digit_to_hex_letter(0xF & (c >> 12));\n+            buffer[pos + 3] = digit_to_hex_letter(0xF & (c >> 8));\n+            buffer[pos + 4] = digit_to_hex_letter(0xF & (c >> 4));\n+            buffer[pos + 5] = digit_to_hex_letter(0xF & c);\n+            pos += 6;\n+        }\n+        return pos;\n+    }\n+\n+    private static char digit_to_hex_letter(int d) {\n+        return (char)((d < 10) ? '0' + d : 'A' - 10 + d);\n+    }\n+\n+    public void indent(int level) {\n+        int visible_size = indentStep * level;\n+        int indent_size, tab_count;\n+        if (indentTabSize <= 0) {\n+            tab_count = 0; indent_size = visible_size;\n+        }\n+        else {\n+            tab_count = visible_size / indentTabSize;\n+            indent_size = tab_count + visible_size % indentTabSize;\n+        }\n+        int pos = add_area(indent_size);\n+        int tab_end = pos + tab_count;\n+        int indent_end = pos + indent_size;\n+        for (; pos != tab_end; ++pos) {    buffer[pos] = '\\t'; }\n+        for (; pos != indent_end; ++pos) {    buffer[pos] = ' '; }\n+    }\n+\n+    public void nl() {\n+        p('\\n');\n+    }\n+\n+    public void line(int indent_level, String s) {\n+        indent(indent_level); p(s); nl();\n+    }\n+\n+    public void erase(int begin, int end) {\n+        System.arraycopy(buffer, end, buffer, begin, offset - end);\n+        offset -= end - begin;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new String(buffer, 0, offset);\n+    }\n+\n+\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/idswitch/FileBody.java\n+/* -*- Mode: java; tab-width: 4; indent-tabs-mode: 1; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+package org.mozilla.javascript.tools.idswitch;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+\n+public class FileBody {\n+\n+    private static class ReplaceItem {\n+        ReplaceItem next;\n+        int begin;\n+        int end;\n+        String replacement;\n+\n+        ReplaceItem(int begin, int end, String text) {\n+            this.begin = begin;\n+            this.end = end;\n+            this.replacement = text;\n+        }\n+    }\n+\n+    private char[] buffer = new char[1 << 14]; // 16K\n+    private int bufferEnd;\n+    private int lineBegin;\n+    private int lineEnd;\n+    private int nextLineStart;\n+\n+    private int lineNumber;\n+\n+    ReplaceItem firstReplace;\n+    ReplaceItem lastReplace;\n+\n+\n+    public char[] getBuffer() { return buffer; }\n+\n+    public void readData(Reader r) throws IOException {\n+        int capacity = buffer.length;\n+        int offset = 0;\n+        for (;;) {\n+            int n_read = r.read(buffer, offset, capacity - offset);\n+            if (n_read < 0) { break; }\n+            offset += n_read;\n+            if (capacity == offset) {\n+                capacity *= 2;\n+                char[] tmp = new char[capacity];\n+                System.arraycopy(buffer, 0, tmp, 0, offset);\n+                buffer = tmp;\n+            }\n+        }\n+        bufferEnd = offset;\n+    }\n+\n+    public void writeInitialData(Writer w) throws IOException {\n+        w.write(buffer, 0, bufferEnd);\n+    }\n+\n+    public void writeData(Writer w) throws IOException {\n+        int offset = 0;\n+        for (ReplaceItem x = firstReplace; x != null; x = x.next) {\n+            int before_replace = x.begin - offset;\n+            if (before_replace > 0) {\n+                w.write(buffer, offset, before_replace);\n+            }\n+            w.write(x.replacement);\n+            offset = x.end;\n+        }\n+        int tail = bufferEnd - offset;\n+        if (tail != 0) {\n+            w.write(buffer, offset, tail);\n+        }\n+    }\n+\n+    public boolean wasModified() { return firstReplace != null; }\n+\n+    public boolean setReplacement(int begin, int end, String text) {\n+        if (equals(text, buffer, begin, end)) { return false; }\n+\n+        ReplaceItem item = new ReplaceItem(begin, end, text);\n+        if (firstReplace == null) {\n+            firstReplace = lastReplace = item;\n+        }\n+        else if (begin < firstReplace.begin) {\n+            item.next = firstReplace;\n+            firstReplace = item;\n+        }\n+        else {\n+            ReplaceItem cursor = firstReplace;\n+            ReplaceItem next = cursor.next;\n+            while (next != null) {\n+                if (begin < next.begin) {\n+                    item.next = next;\n+                    cursor.next = item;\n+                    break;\n+                }\n+                cursor = next;\n+                next = next.next;\n+            }\n+            if (next == null) {\n+                lastReplace.next = item;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public int getLineNumber() { return lineNumber; }\n+\n+    public int getLineBegin() { return lineBegin; }\n+\n+    public int getLineEnd() { return lineEnd; }\n+\n+    public void startLineLoop() {\n+        lineNumber = 0;\n+        lineBegin = lineEnd = nextLineStart = 0;\n+    }\n+\n+    public boolean nextLine() {\n+        if (nextLineStart == bufferEnd) {\n+            lineNumber = 0; return false;\n+        }\n+        int i; int c = 0;\n+        for (i = nextLineStart; i != bufferEnd; ++i) {\n+            c = buffer[i];\n+            if (c == '\\n' || c == '\\r') { break; }\n+        }\n+        lineBegin = nextLineStart;\n+        lineEnd = i;\n+        if (i == bufferEnd) {\n+            nextLineStart = i;\n+        }\n+        else if (c == '\\r' && i + 1 != bufferEnd && buffer[i + 1] == '\\n') {\n+            nextLineStart = i + 2;\n+        }\n+        else {\n+            nextLineStart = i + 1;\n+        }\n+        ++lineNumber;\n+        return true;\n+    }\n+\n+    private static boolean equals(String str, char[] array, int begin, int end)\n+    {\n+        if (str.length() == end - begin) {\n+            for (int i = begin, j = 0; i != end; ++i, ++j) {\n+                if (array[i] != str.charAt(j)) { return false; }\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+}\n+\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/idswitch/IdValuePair.java\n+/* -*- Mode: java; tab-width: 4; indent-tabs-mode: 1; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+package org.mozilla.javascript.tools.idswitch;\n+\n+public class IdValuePair\n+{\n+    public final int idLength;\n+    public final String id;\n+    public final String value;\n+\n+    private int lineNumber;\n+\n+    public IdValuePair(String id, String value) {\n+        this.idLength = id.length();\n+        this.id = id;\n+        this.value = value;\n+    }\n+\n+    public int getLineNumber() { return lineNumber; }\n+\n+    public void setLineNumber(int value) { lineNumber = value; }\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/idswitch/Main.java\n+/* -*- Mode: java; tab-width: 4; indent-tabs-mode: 1; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+package org.mozilla.javascript.tools.idswitch;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.text.SimpleDateFormat;\n+\n+import org.mozilla.javascript.EvaluatorException;\n+import org.mozilla.javascript.tools.ToolErrorReporter;\n+\n+public class Main {\n+\n+    private static final String SWITCH_TAG_STR = \"string_id_map\";\n+    private static final String GENERATED_TAG_STR = \"generated\";\n+    private static final String STRING_TAG_STR = \"string\";\n+\n+    private static final int\n+        NORMAL_LINE        = 0,\n+        SWITCH_TAG         = 1,\n+        GENERATED_TAG      = 2,\n+        STRING_TAG         = 3;\n+\n+    private final List<IdValuePair> all_pairs = new ArrayList<IdValuePair>();\n+\n+    private ToolErrorReporter R;\n+    private CodePrinter P;\n+    private FileBody body;\n+    private String source_file;\n+\n+    private int tag_definition_end;\n+\n+    private int tag_value_start;\n+    private int tag_value_end;\n+\n+    private static boolean is_value_type(int id) {\n+        if (id == STRING_TAG) { return true; }\n+        return false;\n+    }\n+\n+    private static String tag_name(int id) {\n+        switch (id) {\n+            case SWITCH_TAG: return SWITCH_TAG_STR;\n+            case -SWITCH_TAG: return \"/\" + SWITCH_TAG_STR;\n+            case GENERATED_TAG: return GENERATED_TAG_STR;\n+            case -GENERATED_TAG: return \"/\" + GENERATED_TAG_STR;\n+        }\n+        return \"\";\n+    }\n+\n+    void process_file(String file_path) throws IOException {\n+        source_file = file_path;\n+\n+        body = new FileBody();\n+\n+        InputStream is;\n+        if (file_path.equals(\"-\")) {\n+            is = System.in;\n+        }\n+        else {\n+            is = new FileInputStream(file_path);\n+        }\n+        try {\n+            Reader r = new InputStreamReader(is, \"ASCII\");\n+            body.readData(r);\n+        }\n+        finally { is.close(); }\n+\n+        process_file();\n+\n+        if (body.wasModified()) {\n+            OutputStream os;\n+            if (file_path.equals(\"-\")) {\n+                os = System.out;\n+            }\n+            else {\n+                os = new FileOutputStream(file_path);\n+            }\n+\n+            try {\n+                Writer w = new OutputStreamWriter(os);\n+                body.writeData(w);\n+                w.flush();\n+            }\n+            finally { os.close(); }\n+        }\n+    }\n+\n+    private void process_file() {\n+        int cur_state = 0;\n+        char[] buffer = body.getBuffer();\n+\n+        int generated_begin = -1, generated_end = -1;\n+        int time_stamp_begin = -1, time_stamp_end = -1;\n+\n+        body.startLineLoop();\n+        while (body.nextLine()) {\n+            int begin = body.getLineBegin();\n+            int end = body.getLineEnd();\n+\n+            int tag_id = extract_line_tag_id(buffer, begin, end);\n+            boolean bad_tag = false;\n+            switch (cur_state) {\n+                case NORMAL_LINE:\n+                    if (tag_id == SWITCH_TAG) {\n+                        cur_state = SWITCH_TAG;\n+                        all_pairs.clear();\n+                        generated_begin = -1;\n+                    }\n+                    else if (tag_id == -SWITCH_TAG) {\n+                        bad_tag = true;\n+                    }\n+                    break;\n+                case SWITCH_TAG:\n+                    if (tag_id == 0) {\n+                        look_for_id_definitions(buffer, begin, end, false);\n+                    }\n+                    else if (tag_id == STRING_TAG) {\n+                        look_for_id_definitions(buffer, begin, end, true);\n+                    }\n+                    else if (tag_id == GENERATED_TAG) {\n+                        if (generated_begin >= 0) { bad_tag = true; }\n+                        else {\n+                            cur_state = GENERATED_TAG;\n+                            time_stamp_begin = tag_definition_end;\n+                            time_stamp_end = end;\n+                        }\n+                    }\n+                    else if (tag_id == -SWITCH_TAG) {\n+                        cur_state = 0;\n+                        if (generated_begin >= 0 && !all_pairs.isEmpty()) {\n+                            generate_java_code();\n+                            String code = P.toString();\n+                            boolean different = body.setReplacement\n+                                (generated_begin, generated_end, code);\n+                            if (different) {\n+                                String stamp = get_time_stamp();\n+                                body.setReplacement\n+                                    (time_stamp_begin, time_stamp_end, stamp);\n+                            }\n+                        }\n+\n+                        break;\n+                    }\n+                    else {\n+                        bad_tag = true;\n+                    }\n+                    break;\n+                case GENERATED_TAG:\n+                    if (tag_id == 0) {\n+                        if (generated_begin < 0) { generated_begin = begin; }\n+                    }\n+                    else if (tag_id == -GENERATED_TAG) {\n+                        if (generated_begin < 0) { generated_begin = begin; }\n+                        cur_state = SWITCH_TAG;\n+                        generated_end = begin;\n+                    }\n+                    else {\n+                        bad_tag = true;\n+                    }\n+                    break;\n+            }\n+            if (bad_tag) {\n+                String text = ToolErrorReporter.getMessage(\n+                    \"msg.idswitch.bad_tag_order\", tag_name(tag_id));\n+                throw R.runtimeError\n+                    (text, source_file, body.getLineNumber(), null, 0);\n+            }\n+        }\n+\n+        if (cur_state != 0) {\n+            String text = ToolErrorReporter.getMessage(\n+                \"msg.idswitch.file_end_in_switch\", tag_name(cur_state));\n+            throw R.runtimeError\n+                (text, source_file, body.getLineNumber(), null, 0);\n+        }\n+    }\n+\n+    private String get_time_stamp() {\n+        SimpleDateFormat f = new SimpleDateFormat\n+            (\" 'Last update:' yyyy-MM-dd HH:mm:ss z\");\n+        return f.format(new Date());\n+    }\n+\n+    private void generate_java_code() {\n+\n+        P.clear();\n+\n+        IdValuePair[] pairs = new IdValuePair[all_pairs.size()];\n+        all_pairs.toArray(pairs);\n+\n+        SwitchGenerator g = new SwitchGenerator();\n+        g.char_tail_test_threshold = 2;\n+        g.setReporter(R);\n+        g.setCodePrinter(P);\n+\n+        g.generateSwitch(pairs, \"0\");\n+    }\n+\n+    private int extract_line_tag_id(char[] array, int cursor, int end) {\n+        int id = 0;\n+        cursor = skip_white_space(array, cursor, end);\n+        int after_leading_white_space = cursor;\n+        cursor = look_for_slash_slash(array, cursor, end);\n+        if (cursor != end) {\n+            boolean at_line_start = (after_leading_white_space + 2 == cursor);\n+            cursor = skip_white_space(array, cursor, end);\n+            if (cursor != end && array[cursor] == '#') {\n+                ++cursor;\n+\n+                boolean end_tag = false;\n+                if (cursor != end && array[cursor] == '/') {\n+                    ++cursor; end_tag = true;\n+                }\n+\n+                int tag_start = cursor;\n+\n+                for (; cursor != end; ++cursor) {\n+                    int c = array[cursor];\n+                    if (c == '#' || c == '=' ||is_white_space(c)) { break; }\n+                }\n+\n+                if (cursor != end) {\n+                    int tag_end = cursor;\n+                    cursor = skip_white_space(array, cursor, end);\n+                    if (cursor != end) {\n+                        int c = array[cursor];\n+                        if (c == '=' || c == '#') {\n+                            id = get_tag_id\n+                                (array, tag_start, tag_end, at_line_start);\n+                            if (id != 0) {\n+                                String bad = null;\n+                                if (c == '#') {\n+                                    if (end_tag) {\n+                                        id = -id;\n+                                        if (is_value_type(id)) {\n+                                            bad = \"msg.idswitch.no_end_usage\";\n+                                        }\n+                                    }\n+                                    tag_definition_end = cursor + 1;\n+                                }\n+                                else  {\n+                                    if (end_tag) {\n+                                        bad = \"msg.idswitch.no_end_with_value\";\n+                                    }\n+                                    else if (!is_value_type(id)) {\n+                                        bad = \"msg.idswitch.no_value_allowed\";\n+                                    }\n+                                    id = extract_tag_value\n+                                        (array, cursor + 1, end, id);\n+                                }\n+                                if (bad != null) {\n+                                    String s = ToolErrorReporter.getMessage(\n+                                        bad, tag_name(id));\n+                                    throw R.runtimeError\n+                                        (s, source_file, body.getLineNumber(),\n+                                         null, 0);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return id;\n+    }\n+\n+// Return position after first of // or end if not found\n+    private int look_for_slash_slash(char[] array, int cursor, int end) {\n+        while (cursor + 2 <= end) {\n+            int c = array[cursor++];\n+            if (c == '/') {\n+                c = array[cursor++];\n+                if (c == '/') {\n+                    return cursor;\n+                }\n+            }\n+        }\n+        return end;\n+    }\n+\n+    private int extract_tag_value(char[] array, int cursor, int end, int id) {\n+        // cursor points after #[^#=]+=\n+        // ALERT: implement support for quoted strings\n+        boolean found = false;\n+        cursor = skip_white_space(array, cursor, end);\n+        if (cursor != end) {\n+            int value_start = cursor;\n+            int value_end = cursor;\n+            while (cursor != end) {\n+                int c = array[cursor];\n+                if (is_white_space(c)) {\n+                    int after_space = skip_white_space(array, cursor + 1, end);\n+                    if (after_space != end && array[after_space] == '#') {\n+                        value_end = cursor;\n+                        cursor = after_space;\n+                        break;\n+                    }\n+                    cursor = after_space + 1;\n+                }\n+                else if (c == '#') {\n+                    value_end = cursor;\n+                    break;\n+                }\n+                else {\n+                    ++cursor;\n+                }\n+            }\n+            if (cursor != end) {\n+                // array[cursor] is '#' here\n+                found = true;\n+                tag_value_start = value_start;\n+                tag_value_end = value_end;\n+                tag_definition_end = cursor + 1;\n+            }\n+        }\n+        return (found) ? id : 0;\n+    }\n+\n+    private int get_tag_id\n+        (char[] array, int begin, int end, boolean at_line_start)\n+    {\n+        if (at_line_start) {\n+            if (equals(SWITCH_TAG_STR, array, begin, end)) {\n+                return SWITCH_TAG;\n+            }\n+            if (equals(GENERATED_TAG_STR, array, begin, end)) {\n+                return GENERATED_TAG;\n+            }\n+        }\n+        if (equals(STRING_TAG_STR, array, begin, end)) {\n+            return STRING_TAG;\n+        }\n+        return 0;\n+    }\n+\n+    private void look_for_id_definitions\n+        (char[] array, int begin, int end, boolean use_tag_value_as_string)\n+    {\n+    // Look for the pattern\n+    // '^[ \\t]+Id_([a-zA-Z0-9_]+)[ \\t]*=.*$'\n+    // where \\1 gives field or method name\n+        int cursor = begin;\n+        // Skip tab and spaces at the beginning\n+        cursor = skip_white_space(array, cursor, end);\n+        int id_start = cursor;\n+        int name_start = skip_matched_prefix(\"Id_\", array, cursor, end);\n+        if (name_start >= 0) {\n+            // Found Id_ prefix\n+            cursor = name_start;\n+            cursor = skip_name_char(array, cursor, end);\n+            int name_end = cursor;\n+            if (name_start != name_end) {\n+                cursor = skip_white_space(array, cursor, end);\n+                if (cursor != end) {\n+                    if (array[cursor] == '=') {\n+                        int id_end = name_end;\n+                        if (use_tag_value_as_string) {\n+                            name_start = tag_value_start;\n+                            name_end = tag_value_end;\n+                        }\n+                        // Got the match\n+                        add_id(array, id_start, id_end, name_start, name_end);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void add_id\n+        (char[] array, int id_start, int id_end, int name_start, int name_end)\n+    {\n+        String name = new String(array, name_start, name_end - name_start);\n+        String value = new String(array, id_start, id_end - id_start);\n+\n+        IdValuePair pair = new IdValuePair(name, value);\n+\n+        pair.setLineNumber(body.getLineNumber());\n+\n+        all_pairs.add(pair);\n+    }\n+\n+    private static boolean is_white_space(int c) {\n+        return c == ' ' || c == '\\t';\n+    }\n+\n+    private static int skip_white_space(char[] array, int begin, int end) {\n+        int cursor = begin;\n+        for (; cursor != end; ++cursor) {\n+            int c = array[cursor];\n+            if (!is_white_space(c)) { break; }\n+        }\n+        return cursor;\n+    }\n+\n+    private static int skip_matched_prefix\n+        (String prefix, char[] array, int begin, int end)\n+    {\n+        int cursor = -1;\n+        int prefix_length = prefix.length();\n+        if (prefix_length <= end - begin) {\n+            cursor = begin;\n+            for (int i = 0; i != prefix_length; ++i, ++cursor) {\n+                if (prefix.charAt(i) != array[cursor]) {\n+                    cursor = -1; break;\n+                }\n+            }\n+        }\n+        return cursor;\n+    }\n+\n+    private static boolean equals(String str, char[] array, int begin, int end)\n+    {\n+        if (str.length() == end - begin) {\n+            for (int i = begin, j = 0; i != end; ++i, ++j) {\n+                if (array[i] != str.charAt(j)) { return false; }\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static int skip_name_char(char[] array, int begin, int end) {\n+        int cursor = begin;\n+        for (; cursor != end; ++cursor) {\n+            int c = array[cursor];\n+            if (!('a' <= c && c <= 'z') && !('A' <= c && c <= 'Z')) {\n+                if (!('0' <= c && c <= '9')) {\n+                    if (c != '_') {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        return cursor;\n+    }\n+\n+    public static void main(String[] args) {\n+        Main self = new Main();\n+        int status = self.exec(args);\n+        System.exit(status);\n+    }\n+\n+    private int exec(String[] args) {\n+        R = new ToolErrorReporter(true, System.err);\n+\n+        int arg_count = process_options(args);\n+\n+        if (arg_count == 0) {\n+            option_error(ToolErrorReporter.getMessage(\n+                             \"msg.idswitch.no_file_argument\"));\n+            return -1;\n+        }\n+        if (arg_count > 1) {\n+            option_error(ToolErrorReporter.getMessage(\n+                             \"msg.idswitch.too_many_arguments\"));\n+            return -1;\n+        }\n+\n+        P = new CodePrinter();\n+        P.setIndentStep(4);\n+        P.setIndentTabSize(0);\n+\n+        try {\n+            process_file(args[0]);\n+        }\n+        catch (IOException ex) {\n+            print_error(ToolErrorReporter.getMessage(\n+                            \"msg.idswitch.io_error\", ex.toString()));\n+            return -1;\n+        }\n+        catch (EvaluatorException ex) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+    private int process_options(String[] args) {\n+\n+        int status = 1;\n+\n+        boolean show_usage = false;\n+        boolean show_version = false;\n+\n+        int N = args.length;\n+        L: for (int i = 0; i != N; ++i) {\n+            String arg = args[i];\n+            int arg_length = arg.length();\n+            if (arg_length >= 2) {\n+                if (arg.charAt(0) == '-') {\n+                    if (arg.charAt(1) == '-') {\n+                        if (arg_length == 2) {\n+                            args[i] = null; break;\n+                        }\n+                        if (arg.equals(\"--help\")) {\n+                            show_usage = true;\n+                        }\n+                        else if (arg.equals(\"--version\")) {\n+                            show_version = true;\n+                        }\n+                        else {\n+                            option_error(ToolErrorReporter.getMessage(\n+                                             \"msg.idswitch.bad_option\", arg));\n+                            status = -1; break L;\n+                        }\n+                    }\n+                    else {\n+                        for (int j = 1; j != arg_length; ++j) {\n+                            char c = arg.charAt(j);\n+                            switch (c) {\n+                                case 'h': show_usage = true; break;\n+                                default:\n+                                    option_error(\n+                                        ToolErrorReporter.getMessage(\n+                                            \"msg.idswitch.bad_option_char\",\n+                                            String.valueOf(c)));\n+                                    status = -1;\n+                                    break L;\n+                            }\n+\n+                        }\n+                    }\n+                    args[i] = null;\n+                }\n+            }\n+        }\n+\n+        if (status == 1) {\n+            if (show_usage) { show_usage(); status = 0; }\n+            if (show_version) { show_version(); status = 0; }\n+        }\n+\n+        if (status != 1) { System.exit(status); }\n+\n+        return remove_nulls(args);\n+    }\n+\n+    private void show_usage() {\n+        System.out.println(\n+            ToolErrorReporter.getMessage(\"msg.idswitch.usage\"));\n+        System.out.println();\n+    }\n+\n+    private void show_version() {\n+        System.out.println(\n+            ToolErrorReporter.getMessage(\"msg.idswitch.version\"));\n+    }\n+\n+    private void option_error(String str) {\n+        print_error(\n+            ToolErrorReporter.getMessage(\"msg.idswitch.bad_invocation\", str));\n+    }\n+\n+    private void print_error(String text) {\n+        System.err.println(text);\n+    }\n+\n+    private int remove_nulls(String[] array) {\n+        int N = array.length;\n+        int cursor = 0;\n+        for (; cursor != N; ++cursor) {\n+            if (array[cursor] == null) { break; }\n+        }\n+        int destination = cursor;\n+        if (cursor != N) {\n+            ++cursor;\n+            for (; cursor != N; ++cursor) {\n+                String elem = array[cursor];\n+                if (elem != null) {\n+                    array[destination] = elem; ++destination;\n+                }\n+            }\n+        }\n+        return destination;\n+    }\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/idswitch/SwitchGenerator.java\n+/* -*- Mode: java; tab-width: 4; indent-tabs-mode: 1; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+package org.mozilla.javascript.tools.idswitch;\n+\n+import org.mozilla.javascript.EvaluatorException;\n+import org.mozilla.javascript.tools.ToolErrorReporter;\n+\n+public class SwitchGenerator {\n+\n+    String v_switch_label = \"L0\";\n+    String v_label = \"L\";\n+    String v_s = \"s\";\n+    String v_c = \"c\";\n+    String v_guess = \"X\";\n+    String v_id = \"id\";\n+    String v_length_suffix = \"_length\";\n+\n+    int use_if_threshold = 3;\n+    int char_tail_test_threshold = 2;\n+\n+    private IdValuePair[] pairs;\n+    private String default_value;\n+    private int[] columns;\n+    private boolean c_was_defined;\n+\n+    private CodePrinter P;\n+    private ToolErrorReporter R;\n+    private String source_file;\n+\n+    public CodePrinter getCodePrinter() { return P; }\n+    public void setCodePrinter(CodePrinter value) { P = value; }\n+\n+    public ToolErrorReporter getReporter() { return R; }\n+    public void setReporter(ToolErrorReporter value) { R = value; }\n+\n+    public String getSourceFileName() { return source_file; }\n+    public void setSourceFileName(String value) { source_file = value; }\n+\n+    public void generateSwitch(String[] pairs, String default_value) {\n+        int N = pairs.length / 2;\n+        IdValuePair[] id_pairs = new IdValuePair[N];\n+        for (int i = 0; i != N; ++i) {\n+            id_pairs[i] = new IdValuePair(pairs[2 * i], pairs[2 * i + 1]);\n+        }\n+        generateSwitch(id_pairs, default_value);\n+\n+    }\n+\n+    public void generateSwitch(IdValuePair[] pairs, String default_value) {\n+        int begin = 0;\n+        int end = pairs.length;\n+        if (begin == end) { return; }\n+        this.pairs = pairs;\n+        this.default_value = default_value;\n+\n+        generate_body(begin, end, 2);\n+    }\n+\n+    private void generate_body(int begin, int end, int indent_level) {\n+        P.indent(indent_level);\n+        P.p(v_switch_label); P.p(\": { \");\n+        P.p(v_id); P.p(\" = \"); P.p(default_value);\n+        P.p(\"; String \"); P.p(v_guess); P.p(\" = null;\");\n+\n+        c_was_defined = false;\n+        int c_def_begin = P.getOffset();\n+        P.p(\" int \"); P.p(v_c); P.p(';');\n+        int c_def_end = P.getOffset();\n+        P.nl();\n+\n+        generate_length_switch(begin, end, indent_level + 1);\n+\n+        if (!c_was_defined) {\n+            P.erase(c_def_begin, c_def_end);\n+        }\n+\n+        P.indent(indent_level + 1);\n+        P.p(\"if (\"); P.p(v_guess); P.p(\"!=null && \");\n+        P.p(v_guess); P.p(\"!=\"); P.p(v_s);\n+        P.p(\" && !\"); P.p(v_guess); P.p(\".equals(\"); P.p(v_s); P.p(\")) \");\n+        P.p(v_id); P.p(\" = \"); P.p(default_value); P.p(\";\"); P.nl();\n+        \n+        // Add break at end of block to suppress warning for unused label\n+        P.indent(indent_level + 1);\n+        P.p(\"break \"); P.p(v_switch_label); P.p(\";\"); P.nl();\n+        \n+        P.line(indent_level, \"}\");\n+    }\n+\n+    private void generate_length_switch(int begin, int end, int indent_level) {\n+\n+        sort_pairs(begin, end, -1);\n+\n+        check_all_is_different(begin, end);\n+\n+        int lengths_count = count_different_lengths(begin, end);\n+\n+        columns = new int[pairs[end  - 1].idLength];\n+\n+        boolean use_if;\n+        if (lengths_count <= use_if_threshold) {\n+            use_if = true;\n+            if (lengths_count != 1) {\n+                P.indent(indent_level);\n+                P.p(\"int \"); P.p(v_s); P.p(v_length_suffix);\n+                P.p(\" = \"); P.p(v_s); P.p(\".length();\");\n+                P.nl();\n+            }\n+        }\n+        else {\n+            use_if = false;\n+            P.indent(indent_level);\n+            P.p(v_label); P.p(\": switch (\");\n+            P.p(v_s); P.p(\".length()) {\");\n+            P.nl();\n+        }\n+\n+        int same_length_begin = begin;\n+        int cur_l = pairs[begin].idLength, l = 0;\n+        for (int i = begin;;) {\n+            ++i;\n+            if (i == end || (l = pairs[i].idLength) != cur_l) {\n+                int next_indent;\n+                if (use_if) {\n+                    P.indent(indent_level);\n+                    if (same_length_begin != begin) { P.p(\"else \"); }\n+                    P.p(\"if (\");\n+                    if (lengths_count == 1) {\n+                        P.p(v_s); P.p(\".length()==\");\n+                    }\n+                    else {\n+                        P.p(v_s); P.p(v_length_suffix); P.p(\"==\");\n+                    }\n+                    P.p(cur_l);\n+                    P.p(\") {\");\n+                    next_indent = indent_level + 1;\n+                }\n+                else {\n+                    P.indent(indent_level);\n+                    P.p(\"case \"); P.p(cur_l); P.p(\":\");\n+                    next_indent = indent_level + 1;\n+                }\n+                generate_letter_switch\n+                    (same_length_begin, i, next_indent, !use_if, use_if);\n+                if (use_if) {\n+                    P.p(\"}\"); P.nl();\n+                }\n+                else {\n+                    P.p(\"break \"); P.p(v_label); P.p(\";\"); P.nl();\n+                }\n+\n+                if (i == end) { break; }\n+                same_length_begin = i;\n+                cur_l = l;\n+            }\n+        }\n+\n+        if (!use_if) {\n+            P.indent(indent_level); P.p(\"}\"); P.nl();\n+        }\n+\n+    }\n+\n+    private void generate_letter_switch\n+        (int begin, int end,\n+         int indent_level, boolean label_was_defined, boolean inside_if)\n+    {\n+        int L = pairs[begin].idLength;\n+\n+        for (int i = 0; i != L; ++i) {\n+            columns[i] = i;\n+        }\n+\n+        generate_letter_switch_r\n+            (begin, end, L, indent_level, label_was_defined, inside_if);\n+    }\n+\n+\n+    private boolean generate_letter_switch_r\n+        (int begin, int end, int L,\n+         int indent_level, boolean label_was_defined, boolean inside_if)\n+    {\n+        boolean next_is_unreachable = false;\n+        if (begin + 1 == end) {\n+            P.p(' ');\n+            IdValuePair pair = pairs[begin];\n+            if (L > char_tail_test_threshold) {\n+                P.p(v_guess); P.p(\"=\"); P.qstring(pair.id); P.p(\";\");\n+                P.p(v_id); P.p(\"=\"); P.p(pair.value); P.p(\";\");\n+            }\n+            else {\n+                if (L == 0) {\n+                    next_is_unreachable = true;\n+                    P.p(v_id); P.p(\"=\"); P.p(pair.value);\n+                    P.p(\"; break \"); P.p(v_switch_label); P.p(\";\");\n+                }\n+                else {\n+                    P.p(\"if (\");\n+                    int column = columns[0];\n+                    P.p(v_s); P.p(\".charAt(\"); P.p(column); P.p(\")==\");\n+                    P.qchar(pair.id.charAt(column));\n+                    for (int i = 1; i != L; ++i) {\n+                        P.p(\" && \");\n+                        column = columns[i];\n+                        P.p(v_s); P.p(\".charAt(\"); P.p(column); P.p(\")==\");\n+                        P.qchar(pair.id.charAt(column));\n+                    }\n+                    P.p(\") {\");\n+                    P.p(v_id); P.p(\"=\"); P.p(pair.value);\n+                    P.p(\"; break \"); P.p(v_switch_label); P.p(\";}\");\n+                }\n+            }\n+            P.p(' ');\n+            return next_is_unreachable;\n+        }\n+\n+        int max_column_index = find_max_different_column(begin, end, L);\n+        int max_column = columns[max_column_index];\n+        int count = count_different_chars(begin, end, max_column);\n+\n+        columns[max_column_index] = columns[L - 1];\n+\n+        if (inside_if) { P.nl(); P.indent(indent_level); }\n+        else { P.p(' '); }\n+\n+        boolean use_if;\n+        if (count <= use_if_threshold) {\n+            use_if = true;\n+            c_was_defined = true;\n+            P.p(v_c); P.p(\"=\"); P.p(v_s);\n+            P.p(\".charAt(\"); P.p(max_column); P.p(\");\");\n+        }\n+        else {\n+            use_if = false;\n+            if (!label_was_defined) {\n+                label_was_defined = true;\n+                P.p(v_label); P.p(\": \");\n+            }\n+            P.p(\"switch (\"); P.p(v_s);\n+            P.p(\".charAt(\"); P.p(max_column); P.p(\")) {\");\n+        }\n+\n+        int same_char_begin = begin;\n+        int cur_ch = pairs[begin].id.charAt(max_column), ch = 0;\n+        for (int i = begin;;) {\n+            ++i;\n+            if (i == end || (ch = pairs[i].id.charAt(max_column)) != cur_ch) {\n+                int next_indent;\n+                if (use_if) {\n+                    P.nl(); P.indent(indent_level);\n+                    if (same_char_begin != begin) { P.p(\"else \"); }\n+                    P.p(\"if (\"); P.p(v_c); P.p(\"==\");\n+                    P.qchar(cur_ch); P.p(\") {\");\n+                    next_indent = indent_level + 1;\n+                }\n+                else {\n+                    P.nl(); P.indent(indent_level);\n+                    P.p(\"case \"); P.qchar(cur_ch); P.p(\":\");\n+                    next_indent = indent_level + 1;\n+                }\n+                boolean after_unreachable = generate_letter_switch_r\n+                    (same_char_begin, i, L - 1,\n+                     next_indent, label_was_defined, use_if);\n+                if (use_if) {\n+                    P.p(\"}\");\n+                }\n+                else {\n+                    if (!after_unreachable) {\n+                        P.p(\"break \"); P.p(v_label); P.p(\";\");\n+                    }\n+                }\n+                if (i == end) { break; }\n+                same_char_begin = i;\n+                cur_ch = ch;\n+            }\n+        }\n+\n+        if (use_if) {\n+            P.nl();\n+            if (inside_if) { P.indent(indent_level - 1); }\n+            else { P.indent(indent_level); }\n+        }\n+        else {\n+            P.nl(); P.indent(indent_level); P.p(\"}\");\n+            if (inside_if) { P.nl(); P.indent(indent_level - 1);}\n+            else { P.p(' '); }\n+        }\n+\n+        columns[max_column_index] = max_column;\n+\n+        return next_is_unreachable;\n+    }\n+\n+\n+    private int count_different_lengths(int begin, int end) {\n+        int lengths_count = 0;\n+        int cur_l = -1;\n+        for (; begin != end; ++begin) {\n+            int l = pairs[begin].idLength;\n+            if (cur_l != l) {\n+                ++lengths_count; cur_l = l;\n+            }\n+        }\n+        return lengths_count;\n+    }\n+\n+    private int find_max_different_column(int begin, int end, int L) {\n+        int max_count = 0;\n+        int max_index = 0;\n+\n+        for (int i = 0; i != L; ++i) {\n+            int column = columns[i];\n+            sort_pairs(begin, end, column);\n+            int count = count_different_chars(begin, end, column);\n+            if (count == end - begin) { return i; }\n+            if (max_count < count) {\n+                max_count = count;\n+                max_index = i;\n+            }\n+        }\n+\n+        if (max_index != L - 1) {\n+            sort_pairs(begin, end, columns[max_index]);\n+        }\n+\n+        return max_index;\n+    }\n+\n+    private int count_different_chars(int begin, int end, int column) {\n+        int chars_count = 0;\n+        int cur_ch = -1;\n+        for (; begin != end; ++begin) {\n+            int ch = pairs[begin].id.charAt(column);\n+            if (ch != cur_ch) {\n+                ++chars_count; cur_ch = ch;\n+            }\n+        }\n+        return chars_count;\n+    }\n+\n+    private void check_all_is_different(int begin, int end) {\n+        if (begin != end) {\n+            IdValuePair prev = pairs[begin];\n+            while (++begin != end) {\n+                IdValuePair current = pairs[begin];\n+                if (prev.id.equals(current.id)) {\n+                    throw on_same_pair_fail(prev, current);\n+                }\n+                prev = current;\n+            }\n+        }\n+    }\n+\n+    private EvaluatorException on_same_pair_fail(IdValuePair a, IdValuePair b) {\n+        int line1 = a.getLineNumber(), line2 = b.getLineNumber();\n+        if (line2 > line1) { int tmp = line1; line1 = line2; line2 = tmp; }\n+        String error_text = ToolErrorReporter.getMessage(\n+            \"msg.idswitch.same_string\", a.id, new Integer(line2));\n+        return R.runtimeError(error_text, source_file, line1, null, 0);\n+    }\n+\n+    private void sort_pairs(int begin, int end, int comparator) {\n+        heap4Sort(pairs, begin, end - begin, comparator);\n+    }\n+\n+    private static boolean bigger\n+        (IdValuePair a, IdValuePair b, int comparator)\n+    {\n+        if (comparator < 0) {\n+        // For length selection switch it is enough to compare just length,\n+        // but to detect same strings full comparison is essential\n+            //return a.idLength > b.idLength;\n+            int diff = a.idLength - b.idLength;\n+            if (diff != 0) { return diff > 0; }\n+            return a.id.compareTo(b.id) > 0;\n+        }\n+        else {\n+            return a.id.charAt(comparator) > b.id.charAt(comparator);\n+        }\n+    }\n+\n+    private static void heap4Sort\n+        (IdValuePair[] array, int offset, int size, int comparator)\n+    {\n+        if (size <= 1) { return; }\n+        makeHeap4(array, offset, size, comparator);\n+        while (size > 1) {\n+            --size;\n+            IdValuePair v1 = array[offset + size];\n+            IdValuePair v2 = array[offset + 0];\n+            array[offset + size] = v2;\n+            array[offset + 0] = v1;\n+            heapify4(array, offset, size, 0, comparator);\n+        }\n+    }\n+\n+    private static void makeHeap4\n+        (IdValuePair[] array, int offset, int size, int comparator)\n+    {\n+        for (int i = ((size + 2) >> 2); i != 0;) {\n+            --i;\n+            heapify4(array, offset, size, i, comparator);\n+        }\n+    }\n+\n+    private static void heapify4\n+        (IdValuePair[] array, int offset, int size, int i, int comparator)\n+    {\n+        int new_i1, new_i2, new_i3;\n+        IdValuePair i_val = array[offset + i];\n+        for (;;) {\n+            int base = (i << 2);\n+            new_i1 = base | 1;\n+            new_i2 = base | 2;\n+            new_i3 = base | 3;\n+            int new_i4 = base + 4;\n+            if (new_i4 >= size) { break; }\n+            IdValuePair val1 = array[offset + new_i1];\n+            IdValuePair val2 = array[offset + new_i2];\n+            IdValuePair val3 = array[offset + new_i3];\n+            IdValuePair val4 = array[offset + new_i4];\n+            if (bigger(val2, val1, comparator)) {\n+                val1 = val2; new_i1 = new_i2;\n+            }\n+            if (bigger(val4, val3, comparator)) {\n+                val3 = val4; new_i3 = new_i4;\n+            }\n+            if (bigger(val3, val1, comparator)) {\n+                val1 = val3; new_i1 = new_i3;\n+            }\n+            if (bigger(i_val, val1, comparator)) { return; }\n+            array[offset + i] = val1;\n+            array[offset + new_i1] = i_val;\n+            i = new_i1;\n+        }\n+        if (new_i1 < size) {\n+            IdValuePair val1 = array[offset + new_i1];\n+            if (new_i2 != size) {\n+                IdValuePair val2 = array[offset + new_i2];\n+                if (bigger(val2, val1, comparator)) {\n+                    val1 = val2; new_i1 = new_i2;\n+                }\n+                if (new_i3 != size) {\n+                    IdValuePair val3 = array[offset + new_i3];\n+                    if (bigger(val3, val1, comparator)) {\n+                        val1 = val3; new_i1 = new_i3;\n+                    }\n+                }\n+            }\n+            if (bigger(val1, i_val, comparator)) {\n+                array[offset + i] = val1;\n+                array[offset + new_i1] = i_val;\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/jsc/Main.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Mozilla Communicator client code, released\n+ * March 31, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1998-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Christine Begle\n+ *   Norris Boyd\n+ *   Roger Lawrence\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tools.jsc;\n+\n+import java.io.*;\n+import java.util.*;\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.optimizer.ClassCompiler;\n+import org.mozilla.javascript.tools.SourceReader;\n+import org.mozilla.javascript.tools.ToolErrorReporter;\n+\n+/**\n+ */\n+public class Main {\n+\n+    /**\n+     * Main entry point.\n+     *\n+     * Process arguments as would a normal Java program.\n+     * Then set up the execution environment and begin to\n+     * compile scripts.\n+     */\n+    public static void main(String args[])\n+    {\n+        Main main = new Main();\n+        args = main.processOptions(args);\n+        if (args == null) {\n+            if (main.printHelp) {\n+                System.out.println(ToolErrorReporter.getMessage(\n+                    \"msg.jsc.usage\", Main.class.getName()));\n+                System.exit(0);\n+            }\n+            System.exit(1);\n+        }\n+        if (!main.reporter.hasReportedError()) {\n+            main.processSource(args);\n+        }\n+    }\n+\n+    public Main()\n+    {\n+        reporter = new ToolErrorReporter(true);\n+        compilerEnv = new CompilerEnvirons();\n+        compilerEnv.setErrorReporter(reporter);\n+        compiler = new ClassCompiler(compilerEnv);\n+    }\n+\n+    /**\n+     * Parse arguments.\n+     *\n+     */\n+    public String[] processOptions(String args[])\n+    {\n+        targetPackage = \"\";        // default to no package\n+        compilerEnv.setGenerateDebugInfo(false);   // default to no symbols\n+        for (int i=0; i < args.length; i++) {\n+            String arg = args[i];\n+            if (!arg.startsWith(\"-\")) {\n+                int tail = args.length - i;\n+                if (targetName != null && tail > 1) {\n+                    addError(\"msg.multiple.js.to.file\", targetName);\n+                    return null;\n+                }\n+                String[] result = new String[tail];\n+                for (int j = 0; j != tail; ++j) {\n+                    result[j] = args[i + j];\n+                }\n+                return result;\n+            }\n+            if (arg.equals(\"-help\") || arg.equals(\"-h\")\n+                || arg.equals(\"--help\"))\n+            {\n+                printHelp = true;\n+                return null;\n+            }\n+\n+            try {\n+                if (arg.equals(\"-version\") && ++i < args.length) {\n+                    int version = Integer.parseInt(args[i]);\n+                    compilerEnv.setLanguageVersion(version);\n+                    continue;\n+                }\n+                if ((arg.equals(\"-opt\") || arg.equals(\"-O\"))  &&\n+                    ++i < args.length)\n+                {\n+                    int optLevel = Integer.parseInt(args[i]);\n+                    compilerEnv.setOptimizationLevel(optLevel);\n+                    continue;\n+                }\n+            }\n+            catch (NumberFormatException e) {\n+                badUsage(args[i]);\n+                return null;\n+            }\n+            if (arg.equals(\"-nosource\")) {\n+                compilerEnv.setGeneratingSource(false);\n+                continue;\n+            }\n+            if (arg.equals(\"-debug\") || arg.equals(\"-g\")) {\n+                compilerEnv.setGenerateDebugInfo(true);\n+                continue;\n+            }\n+            if (arg.equals(\"-main-method-class\") && ++i < args.length) {\n+                compiler.setMainMethodClass(args[i]);\n+                continue;\n+            }\n+            if (arg.equals(\"-encoding\") && ++i < args.length) {\n+                characterEncoding = args[i];\n+                continue;\n+            }\n+            if (arg.equals(\"-o\") && ++i < args.length) {\n+                String name = args[i];\n+                int end = name.length();\n+                if (end == 0\n+                    || !Character.isJavaIdentifierStart(name.charAt(0)))\n+                {\n+                    addError(\"msg.invalid.classfile.name\", name);\n+                    continue;\n+                }\n+                for (int j = 1; j < end; j++) {\n+                    char c = name.charAt(j);\n+                    if (!Character.isJavaIdentifierPart(c)) {\n+                        if (c == '.') {\n+                            // check if it is the dot in .class\n+                            if (j == end - 6 && name.endsWith(\".class\")) {\n+                                name = name.substring(0, j);\n+                                break;\n+                            }\n+                        }\n+                        addError(\"msg.invalid.classfile.name\", name);\n+                        break;\n+                    }\n+                }\n+                targetName = name;\n+                continue;\n+            }\n+            if (arg.equals(\"-observe-instruction-count\")) {\n+                compilerEnv.setGenerateObserverCount(true);\n+            }\n+            if (arg.equals(\"-package\") && ++i < args.length) {\n+                String pkg = args[i];\n+                int end = pkg.length();\n+                for (int j = 0; j != end; ++j) {\n+                    char c = pkg.charAt(j);\n+                    if (Character.isJavaIdentifierStart(c)) {\n+                        for (++j; j != end; ++j) {\n+                            c = pkg.charAt(j);\n+                            if (!Character.isJavaIdentifierPart(c)) {\n+                                break;\n+                            }\n+                        }\n+                        if (j == end) {\n+                            break;\n+                        }\n+                        if (c == '.' && j != end - 1) {\n+                            continue;\n+                        }\n+                    }\n+                    addError(\"msg.package.name\", targetPackage);\n+                    return null;\n+                }\n+                targetPackage = pkg;\n+                continue;\n+            }\n+            if (arg.equals(\"-extends\") && ++i < args.length) {\n+                String targetExtends = args[i];\n+                Class<?> superClass;\n+                try {\n+                    superClass = Class.forName(targetExtends);\n+                } catch (ClassNotFoundException e) {\n+                    throw new Error(e.toString()); // TODO: better error\n+                }\n+                compiler.setTargetExtends(superClass);\n+                continue;\n+            }\n+            if (arg.equals(\"-implements\") && ++i < args.length) {\n+                // TODO: allow for multiple comma-separated interfaces.\n+                String targetImplements = args[i];\n+                StringTokenizer st = new StringTokenizer(targetImplements,\n+                                                         \",\");\n+                List<Class<?>> list = new ArrayList<Class<?>>();\n+                while (st.hasMoreTokens()) {\n+                    String className = st.nextToken();\n+                    try {\n+                        list.add(Class.forName(className));\n+                    } catch (ClassNotFoundException e) {\n+                        throw new Error(e.toString()); // TODO: better error\n+                    }\n+                }\n+                Class<?>[] implementsClasses = list.toArray(new Class<?>[list.size()]);\n+                compiler.setTargetImplements(implementsClasses);\n+                continue;\n+            }\n+            if (arg.equals(\"-d\") && ++i < args.length) {\n+                destinationDir = args[i];\n+                continue;\n+            }\n+            badUsage(arg);\n+            return null;\n+        }\n+        // no file name\n+        p(ToolErrorReporter.getMessage(\"msg.no.file\"));\n+        return null;\n+    }\n+    /**\n+     * Print a usage message.\n+     */\n+    private static void badUsage(String s) {\n+        System.err.println(ToolErrorReporter.getMessage(\n+            \"msg.jsc.bad.usage\", Main.class.getName(), s));\n+    }\n+\n+    /**\n+     * Compile JavaScript source.\n+     *\n+     */\n+    public void processSource(String[] filenames)\n+    {\n+        for (int i = 0; i != filenames.length; ++i) {\n+            String filename = filenames[i];\n+            if (!filename.endsWith(\".js\")) {\n+                addError(\"msg.extension.not.js\", filename);\n+                return;\n+            }\n+            File f = new File(filename);\n+            String source = readSource(f);\n+            if (source == null) return;\n+\n+            String mainClassName = targetName;\n+            if (mainClassName == null) {\n+                String name = f.getName();\n+                String nojs = name.substring(0, name.length() - 3);\n+                mainClassName = getClassName(nojs);\n+            }\n+            if (targetPackage.length() != 0) {\n+                mainClassName = targetPackage+\".\"+mainClassName;\n+            }\n+\n+            Object[] compiled\n+                = compiler.compileToClassFiles(source, filename, 1,\n+                                               mainClassName);\n+            if (compiled == null || compiled.length == 0) {\n+                return;\n+            }\n+\n+            File targetTopDir = null;\n+            if (destinationDir != null) {\n+                targetTopDir = new File(destinationDir);\n+            } else {\n+                String parent = f.getParent();\n+                if (parent != null) {\n+                    targetTopDir = new File(parent);\n+                }\n+            }\n+            for (int j = 0; j != compiled.length; j += 2) {\n+                String className = (String)compiled[j];\n+                byte[] bytes = (byte[])compiled[j + 1];\n+                File outfile = getOutputFile(targetTopDir, className);\n+                try {\n+                    FileOutputStream os = new FileOutputStream(outfile);\n+                    try {\n+                        os.write(bytes);\n+                    } finally {\n+                        os.close();\n+                    }\n+                } catch (IOException ioe) {\n+                    addFormatedError(ioe.toString());\n+                }\n+            }\n+        }\n+    }\n+\n+    private String readSource(File f)\n+    {\n+        String absPath = f.getAbsolutePath();\n+        if (!f.isFile()) {\n+            addError(\"msg.jsfile.not.found\", absPath);\n+            return null;\n+        }\n+        try {\n+            return (String)SourceReader.readFileOrUrl(absPath, true,\n+                    characterEncoding);\n+        } catch (FileNotFoundException ex) {\n+            addError(\"msg.couldnt.open\", absPath);\n+        } catch (IOException ioe) {\n+            addFormatedError(ioe.toString());\n+        }\n+        return null;\n+    }\n+\n+    private File getOutputFile(File parentDir, String className)\n+    {\n+        String path = className.replace('.', File.separatorChar);\n+        path = path.concat(\".class\");\n+        File f = new File(parentDir, path);\n+        String dirPath = f.getParent();\n+        if (dirPath != null) {\n+            File dir = new File(dirPath);\n+            if (!dir.exists()) {\n+                dir.mkdirs();\n+            }\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * Verify that class file names are legal Java identifiers.  Substitute\n+     * illegal characters with underscores, and prepend the name with an\n+     * underscore if the file name does not begin with a JavaLetter.\n+     */\n+\n+    String getClassName(String name) {\n+        char[] s = new char[name.length()+1];\n+        char c;\n+        int j = 0;\n+\n+        if (!Character.isJavaIdentifierStart(name.charAt(0))) {\n+            s[j++] = '_';\n+        }\n+        for (int i=0; i < name.length(); i++, j++) {\n+            c = name.charAt(i);\n+            if ( Character.isJavaIdentifierPart(c) ) {\n+                s[j] = c;\n+            } else {\n+                s[j] = '_';\n+            }\n+        }\n+        return (new String(s)).trim();\n+     }\n+\n+    private static void p(String s) {\n+        System.out.println(s);\n+    }\n+\n+    private void addError(String messageId, String arg)\n+    {\n+        String msg;\n+        if (arg == null) {\n+            msg = ToolErrorReporter.getMessage(messageId);\n+        } else {\n+            msg = ToolErrorReporter.getMessage(messageId, arg);\n+        }\n+        addFormatedError(msg);\n+    }\n+\n+    private void addFormatedError(String message)\n+    {\n+        reporter.error(message, null, -1, null, -1);\n+    }\n+\n+    private boolean printHelp;\n+    private ToolErrorReporter reporter;\n+    private CompilerEnvirons compilerEnv;\n+    private ClassCompiler compiler;\n+    private String targetName;\n+    private String targetPackage;\n+    private String destinationDir;\n+    private String characterEncoding;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/ConsoleTextArea.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino JavaScript Debugger code, released\n+ * November 21, 2000.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * See Beyond Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Christopher Oliver\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+package org.mozilla.javascript.tools.shell;\n+import java.io.*;\n+import java.awt.*;\n+import java.awt.event.*;\n+import javax.swing.*;\n+import javax.swing.event.*;\n+import javax.swing.text.Document;\n+import javax.swing.text.Segment;\n+\n+class ConsoleWrite implements Runnable {\n+    private ConsoleTextArea textArea;\n+    private String str;\n+\n+    public ConsoleWrite(ConsoleTextArea textArea, String str) {\n+        this.textArea = textArea;\n+        this.str = str;\n+    }\n+\n+    public void run() {\n+        textArea.write(str);\n+    }\n+}\n+\n+class ConsoleWriter extends java.io.OutputStream {\n+\n+    private ConsoleTextArea textArea;\n+    private StringBuffer buffer;\n+\n+    public ConsoleWriter(ConsoleTextArea textArea) {\n+        this.textArea = textArea;\n+        buffer = new StringBuffer();\n+    }\n+\n+    @Override\n+    public synchronized void write(int ch) {\n+        buffer.append((char)ch);\n+        if(ch == '\\n') {\n+            flushBuffer();\n+        }\n+    }\n+\n+    public synchronized void write (char[] data, int off, int len) {\n+        for(int i = off; i < len; i++) {\n+            buffer.append(data[i]);\n+            if(data[i] == '\\n') {\n+                flushBuffer();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void flush() {\n+        if (buffer.length() > 0) {\n+            flushBuffer();\n+        }\n+    }\n+\n+    @Override\n+    public void close () {\n+        flush();\n+    }\n+\n+    private void flushBuffer() {\n+        String str = buffer.toString();\n+        buffer.setLength(0);\n+        SwingUtilities.invokeLater(new ConsoleWrite(textArea, str));\n+    }\n+}\n+\n+public class ConsoleTextArea\n+    extends JTextArea implements KeyListener, DocumentListener\n+{\n+    static final long serialVersionUID = 8557083244830872961L;\n+\n+    private ConsoleWriter console1;\n+    private ConsoleWriter console2;\n+    private PrintStream out;\n+    private PrintStream err;\n+    private PrintWriter inPipe;\n+    private PipedInputStream in;\n+    private java.util.List<String> history;\n+    private int historyIndex = -1;\n+    private int outputMark = 0;\n+\n+    @Override\n+    public void select(int start, int end) {\n+        requestFocus();\n+        super.select(start, end);\n+    }\n+\n+    public ConsoleTextArea(String[] argv) {\n+        super();\n+        history = new java.util.ArrayList<String>();\n+        console1 = new ConsoleWriter(this);\n+        console2 = new ConsoleWriter(this);\n+        out = new PrintStream(console1, true);\n+        err = new PrintStream(console2, true);\n+        PipedOutputStream outPipe = new PipedOutputStream();\n+        inPipe = new PrintWriter(outPipe);\n+        in = new PipedInputStream();\n+        try {\n+            outPipe.connect(in);\n+        } catch(IOException exc) {\n+            exc.printStackTrace();\n+        }\n+        getDocument().addDocumentListener(this);\n+        addKeyListener(this);\n+        setLineWrap(true);\n+        setFont(new Font(\"Monospaced\", 0, 12));\n+    }\n+\n+\n+    synchronized void returnPressed() {\n+        Document doc = getDocument();\n+        int len = doc.getLength();\n+        Segment segment = new Segment();\n+        try {\n+            doc.getText(outputMark, len - outputMark, segment);\n+        } catch(javax.swing.text.BadLocationException ignored) {\n+            ignored.printStackTrace();\n+        }\n+        if(segment.count > 0) {\n+            history.add(segment.toString());\n+        }\n+        historyIndex = history.size();\n+        inPipe.write(segment.array, segment.offset, segment.count);\n+        append(\"\\n\");\n+        outputMark = doc.getLength();\n+        inPipe.write(\"\\n\");\n+        inPipe.flush();\n+        console1.flush();\n+    }\n+\n+    public void eval(String str) {\n+        inPipe.write(str);\n+        inPipe.write(\"\\n\");\n+        inPipe.flush();\n+        console1.flush();\n+    }\n+\n+    public void keyPressed(KeyEvent e) {\n+        int code = e.getKeyCode();\n+        if(code == KeyEvent.VK_BACK_SPACE || code == KeyEvent.VK_LEFT) {\n+            if(outputMark == getCaretPosition()) {\n+                e.consume();\n+            }\n+        } else if(code == KeyEvent.VK_HOME) {\n+           int caretPos = getCaretPosition();\n+           if(caretPos == outputMark) {\n+               e.consume();\n+           } else if(caretPos > outputMark) {\n+               if(!e.isControlDown()) {\n+                   if(e.isShiftDown()) {\n+                       moveCaretPosition(outputMark);\n+                   } else {\n+                       setCaretPosition(outputMark);\n+                   }\n+                   e.consume();\n+               }\n+           }\n+        } else if(code == KeyEvent.VK_ENTER) {\n+            returnPressed();\n+            e.consume();\n+        } else if(code == KeyEvent.VK_UP) {\n+            historyIndex--;\n+            if(historyIndex >= 0) {\n+                if(historyIndex >= history.size()) {\n+                    historyIndex = history.size() -1;\n+                }\n+                if(historyIndex >= 0) {\n+                    String str = history.get(historyIndex);\n+                    int len = getDocument().getLength();\n+                    replaceRange(str, outputMark, len);\n+                    int caretPos = outputMark + str.length();\n+                    select(caretPos, caretPos);\n+                } else {\n+                    historyIndex++;\n+                }\n+            } else {\n+                historyIndex++;\n+            }\n+            e.consume();\n+        } else if(code == KeyEvent.VK_DOWN) {\n+            int caretPos = outputMark;\n+            if(history.size() > 0) {\n+                historyIndex++;\n+                if(historyIndex < 0) {historyIndex = 0;}\n+                int len = getDocument().getLength();\n+                if (historyIndex < history.size()) {\n+                    String str = history.get(historyIndex);\n+                    replaceRange(str, outputMark, len);\n+                    caretPos = outputMark + str.length();\n+                } else {\n+                    historyIndex = history.size();\n+                    replaceRange(\"\", outputMark, len);\n+                }\n+            }\n+            select(caretPos, caretPos);\n+            e.consume();\n+        }\n+    }\n+\n+    public void keyTyped(KeyEvent e) {\n+        int keyChar = e.getKeyChar();\n+        if(keyChar == 0x8 /* KeyEvent.VK_BACK_SPACE */) {\n+            if(outputMark == getCaretPosition()) {\n+                e.consume();\n+            }\n+        } else if(getCaretPosition() < outputMark) {\n+            setCaretPosition(outputMark);\n+        }\n+    }\n+\n+    public synchronized void keyReleased(KeyEvent e) {\n+    }\n+\n+    public synchronized void write(String str) {\n+        insert(str, outputMark);\n+        int len = str.length();\n+        outputMark += len;\n+        select(outputMark, outputMark);\n+    }\n+\n+    public synchronized void insertUpdate(DocumentEvent e) {\n+        int len = e.getLength();\n+        int off = e.getOffset();\n+        if(outputMark > off) {\n+            outputMark += len;\n+        }\n+    }\n+\n+    public synchronized void removeUpdate(DocumentEvent e) {\n+        int len = e.getLength();\n+        int off = e.getOffset();\n+        if(outputMark > off) {\n+            if(outputMark >= off + len) {\n+                outputMark -= len;\n+            } else {\n+                outputMark = off;\n+            }\n+        }\n+    }\n+\n+    public synchronized void postUpdateUI() {\n+        // this attempts to cleanup the damage done by updateComponentTreeUI\n+        requestFocus();\n+        setCaret(getCaret());\n+        select(outputMark, outputMark);\n+    }\n+\n+    public synchronized void changedUpdate(DocumentEvent e) {\n+    }\n+\n+\n+    public InputStream getIn() {\n+        return in;\n+    }\n+\n+    public PrintStream getOut() {\n+        return out;\n+    }\n+\n+    public PrintStream getErr() {\n+        return err;\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/Environment.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+/*\n+        Environment.java\n+\n+        Wraps java.lang.System properties.\n+\n+        by Patrick C. Beard <beard@netscape.com>\n+ */\n+\n+package org.mozilla.javascript.tools.shell;\n+\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.ScriptRuntime;\n+import org.mozilla.javascript.ScriptableObject;\n+\n+import java.util.Map;\n+\n+/**\n+ * Environment, intended to be instantiated at global scope, provides\n+ * a natural way to access System properties from JavaScript.\n+ *\n+ */\n+public class Environment extends ScriptableObject\n+{\n+    static final long serialVersionUID = -430727378460177065L;\n+\n+    private Environment thePrototypeInstance = null;\n+\n+    public static void defineClass(ScriptableObject scope) {\n+        try {\n+            ScriptableObject.defineClass(scope, Environment.class);\n+        } catch (Exception e) {\n+            throw new Error(e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return \"Environment\";\n+    }\n+\n+    public Environment() {\n+        if (thePrototypeInstance == null)\n+            thePrototypeInstance = this;\n+    }\n+\n+    public Environment(ScriptableObject scope) {\n+        setParentScope(scope);\n+        Object ctor = ScriptRuntime.getTopLevelProp(scope, \"Environment\");\n+        if (ctor != null && ctor instanceof Scriptable) {\n+            Scriptable s = (Scriptable) ctor;\n+            setPrototype((Scriptable) s.get(\"prototype\", s));\n+        }\n+    }\n+\n+    @Override\n+    public boolean has(String name, Scriptable start) {\n+        if (this == thePrototypeInstance)\n+            return super.has(name, start);\n+\n+        return (System.getProperty(name) != null);\n+    }\n+\n+    @Override\n+    public Object get(String name, Scriptable start) {\n+        if (this == thePrototypeInstance)\n+            return super.get(name, start);\n+\n+        String result = System.getProperty(name);\n+        if (result != null)\n+            return ScriptRuntime.toObject(getParentScope(), result);\n+        else\n+            return Scriptable.NOT_FOUND;\n+    }\n+\n+    @Override\n+    public void put(String name, Scriptable start, Object value) {\n+        if (this == thePrototypeInstance)\n+            super.put(name, start, value);\n+        else\n+            System.getProperties().put(name, ScriptRuntime.toString(value));\n+    }\n+\n+    private Object[] collectIds() {\n+        Map<Object,Object> props = System.getProperties();\n+        return props.keySet().toArray();\n+    }\n+\n+    @Override\n+    public Object[] getIds() {\n+        if (this == thePrototypeInstance)\n+            return super.getIds();\n+        return collectIds();\n+    }\n+\n+    @Override\n+    public Object[] getAllIds() {\n+        if (this == thePrototypeInstance)\n+            return super.getAllIds();\n+        return collectIds();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/Global.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Patrick Beard\n+ *   Igor Bukanov\n+ *   Norris Boyd\n+ *   Rob Ginda\n+ *   Kurt Westerfeld\n+ *   Matthias Radestock\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tools.shell;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.lang.reflect.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.tools.ToolErrorReporter;\n+import org.mozilla.javascript.serialize.*;\n+\n+/**\n+ * This class provides for sharing functions across multiple threads.\n+ * This is of particular interest to server applications.\n+ *\n+ */\n+public class Global extends ImporterTopLevel\n+{\n+    static final long serialVersionUID = 4029130780977538005L;\n+\n+    NativeArray history;\n+    boolean attemptedJLineLoad;\n+    private InputStream inStream;\n+    private PrintStream outStream;\n+    private PrintStream errStream;\n+    private boolean sealedStdLib = false;\n+    boolean initialized;\n+    private QuitAction quitAction;\n+    private String[] prompts = { \"js> \", \"  > \" };\n+    private HashMap<String,String> doctestCanonicalizations;\n+\n+    public Global()\n+    {\n+    }\n+\n+    public Global(Context cx)\n+    {\n+        init(cx);\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set the action to call from quit().\n+     */\n+    public void initQuitAction(QuitAction quitAction)\n+    {\n+        if (quitAction == null)\n+            throw new IllegalArgumentException(\"quitAction is null\");\n+        if (this.quitAction != null)\n+            throw new IllegalArgumentException(\"The method is once-call.\");\n+\n+        this.quitAction = quitAction;\n+    }\n+\n+    public void init(ContextFactory factory)\n+    {\n+        factory.call(new ContextAction() {\n+                public Object run(Context cx)\n+                {\n+                    init(cx);\n+                    return null;\n+                }\n+            });\n+    }\n+\n+    public void init(Context cx)\n+    {\n+        // Define some global functions particular to the shell. Note\n+        // that these functions are not part of ECMA.\n+        initStandardObjects(cx, sealedStdLib);\n+        String[] names = {\n+            \"defineClass\",\n+            \"deserialize\",\n+            \"doctest\",\n+            \"gc\",\n+            \"help\",\n+            \"load\",\n+            \"loadClass\",\n+            \"print\",\n+            \"quit\",\n+            \"readFile\",\n+            \"readUrl\",\n+            \"runCommand\",\n+            \"seal\",\n+            \"serialize\",\n+            \"spawn\",\n+            \"sync\",\n+            \"toint32\",\n+            \"version\",\n+        };\n+        defineFunctionProperties(names, Global.class,\n+                                 ScriptableObject.DONTENUM);\n+\n+        // Set up \"environment\" in the global scope to provide access to the\n+        // System environment variables.\n+        Environment.defineClass(this);\n+        Environment environment = new Environment(this);\n+        defineProperty(\"environment\", environment,\n+                       ScriptableObject.DONTENUM);\n+\n+        history = (NativeArray) cx.newArray(this, 0);\n+        defineProperty(\"history\", history, ScriptableObject.DONTENUM);\n+\n+        initialized = true;\n+    }\n+\n+    /**\n+     * Print a help message.\n+     *\n+     * This method is defined as a JavaScript function.\n+     */\n+    public static void help(Context cx, Scriptable thisObj,\n+                            Object[] args, Function funObj)\n+    {\n+        PrintStream out = getInstance(funObj).getOut();\n+        out.println(ToolErrorReporter.getMessage(\"msg.help\"));\n+    }\n+\n+    public static void gc(Context cx, Scriptable thisObj,\n+            Object[] args, Function funObj)\n+    {\n+        System.gc();\n+    }\n+\n+\n+    /**\n+     * Print the string values of its arguments.\n+     *\n+     * This method is defined as a JavaScript function.\n+     * Note that its arguments are of the \"varargs\" form, which\n+     * allows it to handle an arbitrary number of arguments\n+     * supplied to the JavaScript function.\n+     *\n+     */\n+    public static Object print(Context cx, Scriptable thisObj,\n+                               Object[] args, Function funObj)\n+    {\n+        PrintStream out = getInstance(funObj).getOut();\n+        for (int i=0; i < args.length; i++) {\n+            if (i > 0)\n+                out.print(\" \");\n+\n+            // Convert the arbitrary JavaScript value into a string form.\n+            String s = Context.toString(args[i]);\n+\n+            out.print(s);\n+        }\n+        out.println();\n+        return Context.getUndefinedValue();\n+    }\n+\n+    /**\n+     * Call embedding-specific quit action passing its argument as\n+     * int32 exit code.\n+     *\n+     * This method is defined as a JavaScript function.\n+     */\n+    public static void quit(Context cx, Scriptable thisObj,\n+                            Object[] args, Function funObj)\n+    {\n+        Global global = getInstance(funObj);\n+        if (global.quitAction != null) {\n+            int exitCode = (args.length == 0 ? 0\n+                            : ScriptRuntime.toInt32(args[0]));\n+            global.quitAction.quit(cx, exitCode);\n+        }\n+    }\n+\n+    /**\n+     * Get and set the language version.\n+     *\n+     * This method is defined as a JavaScript function.\n+     */\n+    public static double version(Context cx, Scriptable thisObj,\n+                                 Object[] args, Function funObj)\n+    {\n+        double result = cx.getLanguageVersion();\n+        if (args.length > 0) {\n+            double d = Context.toNumber(args[0]);\n+            cx.setLanguageVersion((int) d);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Load and execute a set of JavaScript source files.\n+     *\n+     * This method is defined as a JavaScript function.\n+     *\n+     */\n+    public static void load(Context cx, Scriptable thisObj,\n+                            Object[] args, Function funObj)\n+    {\n+        for (int i = 0; i < args.length; i++) {\n+            Main.processFile(cx, thisObj, Context.toString(args[i]));\n+        }\n+    }\n+\n+    /**\n+     * Load a Java class that defines a JavaScript object using the\n+     * conventions outlined in ScriptableObject.defineClass.\n+     * <p>\n+     * This method is defined as a JavaScript function.\n+     * @exception IllegalAccessException if access is not available\n+     *            to a reflected class member\n+     * @exception InstantiationException if unable to instantiate\n+     *            the named class\n+     * @exception InvocationTargetException if an exception is thrown\n+     *            during execution of methods of the named class\n+     * @see org.mozilla.javascript.ScriptableObject#defineClass(Scriptable,Class)\n+     */\n+    @SuppressWarnings({\"unchecked\"})\n+    public static void defineClass(Context cx, Scriptable thisObj,\n+                                   Object[] args, Function funObj)\n+        throws IllegalAccessException, InstantiationException,\n+               InvocationTargetException\n+    {\n+        Class<?> clazz = getClass(args);\n+        if (!Scriptable.class.isAssignableFrom(clazz)) {\n+            throw reportRuntimeError(\"msg.must.implement.Scriptable\");\n+        }\n+        ScriptableObject.defineClass(thisObj, (Class<? extends Scriptable>)clazz);\n+    }\n+\n+    /**\n+     * Load and execute a script compiled to a class file.\n+     * <p>\n+     * This method is defined as a JavaScript function.\n+     * When called as a JavaScript function, a single argument is\n+     * expected. This argument should be the name of a class that\n+     * implements the Script interface, as will any script\n+     * compiled by jsc.\n+     *\n+     * @exception IllegalAccessException if access is not available\n+     *            to the class\n+     * @exception InstantiationException if unable to instantiate\n+     *            the named class\n+     */\n+    public static void loadClass(Context cx, Scriptable thisObj,\n+                                 Object[] args, Function funObj)\n+        throws IllegalAccessException, InstantiationException\n+    {\n+        Class<?> clazz = getClass(args);\n+        if (!Script.class.isAssignableFrom(clazz)) {\n+            throw reportRuntimeError(\"msg.must.implement.Script\");\n+        }\n+        Script script = (Script) clazz.newInstance();\n+        script.exec(cx, thisObj);\n+    }\n+\n+    private static Class<?> getClass(Object[] args) {\n+        if (args.length == 0) {\n+            throw reportRuntimeError(\"msg.expected.string.arg\");\n+        }\n+        Object arg0 = args[0];\n+        if (arg0 instanceof Wrapper) {\n+            Object wrapped = ((Wrapper)arg0).unwrap();\n+            if (wrapped instanceof Class)\n+                return (Class<?>)wrapped;\n+        }\n+        String className = Context.toString(args[0]);\n+        try {\n+            return Class.forName(className);\n+        }\n+        catch (ClassNotFoundException cnfe) {\n+            throw reportRuntimeError(\"msg.class.not.found\", className);\n+        }\n+    }\n+\n+    public static void serialize(Context cx, Scriptable thisObj,\n+                                 Object[] args, Function funObj)\n+        throws IOException\n+    {\n+        if (args.length < 2) {\n+            throw Context.reportRuntimeError(\n+                \"Expected an object to serialize and a filename to write \" +\n+                \"the serialization to\");\n+        }\n+        Object obj = args[0];\n+        String filename = Context.toString(args[1]);\n+        FileOutputStream fos = new FileOutputStream(filename);\n+        Scriptable scope = ScriptableObject.getTopLevelScope(thisObj);\n+        ScriptableOutputStream out = new ScriptableOutputStream(fos, scope);\n+        out.writeObject(obj);\n+        out.close();\n+    }\n+\n+    public static Object deserialize(Context cx, Scriptable thisObj,\n+                                     Object[] args, Function funObj)\n+        throws IOException, ClassNotFoundException\n+    {\n+        if (args.length < 1) {\n+            throw Context.reportRuntimeError(\n+                \"Expected a filename to read the serialization from\");\n+        }\n+        String filename = Context.toString(args[0]);\n+        FileInputStream fis = new FileInputStream(filename);\n+        Scriptable scope = ScriptableObject.getTopLevelScope(thisObj);\n+        ObjectInputStream in = new ScriptableInputStream(fis, scope);\n+        Object deserialized = in.readObject();\n+        in.close();\n+        return Context.toObject(deserialized, scope);\n+    }\n+\n+    public String[] getPrompts(Context cx) {\n+        if (ScriptableObject.hasProperty(this, \"prompts\")) {\n+            Object promptsJS = ScriptableObject.getProperty(this,\n+                                                            \"prompts\");\n+            if (promptsJS instanceof Scriptable) {\n+                Scriptable s = (Scriptable) promptsJS;\n+                if (ScriptableObject.hasProperty(s, 0) &&\n+                    ScriptableObject.hasProperty(s, 1))\n+                {\n+                    Object elem0 = ScriptableObject.getProperty(s, 0);\n+                    if (elem0 instanceof Function) {\n+                        elem0 = ((Function) elem0).call(cx, this, s,\n+                                new Object[0]);\n+                    }\n+                    prompts[0] = Context.toString(elem0);\n+                    Object elem1 = ScriptableObject.getProperty(s, 1);\n+                    if (elem1 instanceof Function) {\n+                        elem1 = ((Function) elem1).call(cx, this, s,\n+                                new Object[0]);\n+                    }\n+                    prompts[1] = Context.toString(elem1);\n+                }\n+            }\n+        }\n+        return prompts;\n+    }\n+\n+    /**\n+     * Example: doctest(\"js> function f() {\\n  >   return 3;\\n  > }\\njs> f();\\n3\\n\"); returns 2\n+     * (since 2 tests were executed).\n+     */\n+    public static Object doctest(Context cx, Scriptable thisObj,\n+                                 Object[] args, Function funObj)\n+    {\n+    \tif (args.length == 0) {\n+    \t\treturn Boolean.FALSE;\n+    \t}\n+    \tString session = Context.toString(args[0]);\n+        Global global = getInstance(funObj);\n+        return new Integer(global.runDoctest(cx, global, session, null, 0));\n+    }\n+\n+    public int runDoctest(Context cx, Scriptable scope, String session,\n+                          String sourceName, int lineNumber)\n+    {\n+        doctestCanonicalizations = new HashMap<String,String>();\n+        String[] lines = session.split(\"[\\n\\r]+\");\n+        String prompt0 = this.prompts[0].trim();\n+        String prompt1 = this.prompts[1].trim();\n+        int testCount = 0;\n+        int i = 0;\n+        while (i < lines.length && !lines[i].trim().startsWith(prompt0)) {\n+            i++; // skip lines that don't look like shell sessions\n+        }\n+    \twhile (i < lines.length) {\n+    \t\tString inputString = lines[i].trim().substring(prompt0.length());\n+            inputString += \"\\n\";\n+    \t\ti++;\n+    \t\twhile (i < lines.length && lines[i].trim().startsWith(prompt1)) {\n+    \t\t\tinputString += lines[i].trim().substring(prompt1.length());\n+    \t\t\tinputString += \"\\n\";\n+    \t\t\ti++;\n+    \t\t}\n+            String expectedString = \"\";\n+            while (i < lines.length &&\n+                   !lines[i].trim().startsWith(prompt0))\n+            {\n+                expectedString += lines[i] + \"\\n\";\n+                i++;\n+            }\n+    \t\tPrintStream savedOut = this.getOut();\n+    \t\tPrintStream savedErr = this.getErr();\n+    \t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+    \t\tByteArrayOutputStream err = new ByteArrayOutputStream();\n+    \t\tthis.setOut(new PrintStream(out));\n+    \t\tthis.setErr(new PrintStream(err));\n+    \t\tString resultString = \"\";\n+    \t\tErrorReporter savedErrorReporter = cx.getErrorReporter();\n+    \t\tcx.setErrorReporter(new ToolErrorReporter(false, this.getErr()));\n+    \t\ttry {\n+    \t\t    testCount++;\n+\t    \t\tObject result = cx.evaluateString(scope, inputString,\n+\t    \t\t\t\t            \"doctest input\", 1, null);\n+\t            if (result != Context.getUndefinedValue() &&\n+\t                    !(result instanceof Function &&\n+\t                      inputString.trim().startsWith(\"function\")))\n+\t            {\n+\t            \tresultString = Context.toString(result);\n+\t            }\n+    \t\t} catch (RhinoException e) {\n+                ToolErrorReporter.reportException(cx.getErrorReporter(), e);\n+    \t\t} finally {\n+    \t\t    this.setOut(savedOut);\n+    \t\t    this.setErr(savedErr);\n+        \t\tcx.setErrorReporter(savedErrorReporter);\n+    \t\t\tresultString += err.toString() + out.toString();\n+    \t\t}\n+    \t\tif (!doctestOutputMatches(expectedString, resultString)) {\n+    \t\t    String message = \"doctest failure running:\\n\" +\n+                    inputString +\n+                    \"expected: \" + expectedString +\n+                    \"actual: \" + resultString + \"\\n\";\n+    \t\t    if (sourceName != null)\n+                    throw Context.reportRuntimeError(message, sourceName,\n+                            lineNumber+i-1, null, 0);\n+    \t\t    else\n+                    throw Context.reportRuntimeError(message);\n+    \t\t}\n+    \t}\n+    \treturn testCount;\n+    }\n+\n+    /**\n+     * Compare actual result of doctest to expected, modulo some\n+     * acceptable differences. Currently just trims the strings\n+     * before comparing, but should ignore differences in line numbers\n+     * for error messages for example.\n+     *\n+     * @param expected the expected string\n+     * @param actual the actual string\n+     * @return true iff actual matches expected modulo some acceptable\n+     *      differences\n+     */\n+    private boolean doctestOutputMatches(String expected, String actual) {\n+        expected = expected.trim();\n+        actual = actual.trim().replace(\"\\r\\n\", \"\\n\");\n+        if (expected.equals(actual))\n+            return true;\n+        for (Map.Entry<String,String> entry: doctestCanonicalizations.entrySet()) {\n+            expected = expected.replace(entry.getKey(), entry.getValue());\n+        }\n+        if (expected.equals(actual))\n+            return true;\n+        // java.lang.Object.toString() prints out a unique hex number associated\n+        // with each object. This number changes from run to run, so we want to\n+        // ignore differences between these numbers in the output. We search for a\n+        // regexp that matches the hex number preceded by '@', then enter mappings into\n+        // \"doctestCanonicalizations\" so that we ensure that the mappings are\n+        // consistent within a session.\n+        Pattern p = Pattern.compile(\"@[0-9a-fA-F]+\");\n+        Matcher expectedMatcher = p.matcher(expected);\n+        Matcher actualMatcher = p.matcher(actual);\n+        for (;;) {\n+            if (!expectedMatcher.find())\n+                return false;\n+            if (!actualMatcher.find())\n+                return false;\n+            if (actualMatcher.start() != expectedMatcher.start())\n+                return false;\n+            int start = expectedMatcher.start();\n+            if (!expected.substring(0, start).equals(actual.substring(0, start)))\n+                return false;\n+            String expectedGroup = expectedMatcher.group();\n+            String actualGroup = actualMatcher.group();\n+            String mapping = doctestCanonicalizations.get(expectedGroup);\n+            if (mapping == null) {\n+                doctestCanonicalizations.put(expectedGroup, actualGroup);\n+                expected = expected.replace(expectedGroup, actualGroup);\n+            } else if (!actualGroup.equals(mapping)) {\n+                return false; // wrong object!\n+            }\n+            if (expected.equals(actual))\n+                return true;\n+        }\n+    }\n+\n+    /**\n+     * The spawn function runs a given function or script in a different\n+     * thread.\n+     *\n+     * js> function g() { a = 7; }\n+     * js> a = 3;\n+     * 3\n+     * js> spawn(g)\n+     * Thread[Thread-1,5,main]\n+     * js> a\n+     * 3\n+     */\n+    public static Object spawn(Context cx, Scriptable thisObj, Object[] args,\n+                               Function funObj)\n+    {\n+        Scriptable scope = funObj.getParentScope();\n+        Runner runner;\n+        if (args.length != 0 && args[0] instanceof Function) {\n+            Object[] newArgs = null;\n+            if (args.length > 1 && args[1] instanceof Scriptable) {\n+                newArgs = cx.getElements((Scriptable) args[1]);\n+            }\n+            if (newArgs == null) { newArgs = ScriptRuntime.emptyArgs; }\n+            runner = new Runner(scope, (Function) args[0], newArgs);\n+        } else if (args.length != 0 && args[0] instanceof Script) {\n+            runner = new Runner(scope, (Script) args[0]);\n+        } else {\n+            throw reportRuntimeError(\"msg.spawn.args\");\n+        }\n+        runner.factory = cx.getFactory();\n+        Thread thread = new Thread(runner);\n+        thread.start();\n+        return thread;\n+    }\n+\n+    /**\n+     * The sync function creates a synchronized function (in the sense\n+     * of a Java synchronized method) from an existing function. The\n+     * new function synchronizes on the <code>this</code> object of\n+     * its invocation.\n+     * js> var o = { f : sync(function(x) {\n+     *       print(\"entry\");\n+     *       Packages.java.lang.Thread.sleep(x*1000);\n+     *       print(\"exit\");\n+     *     })};\n+     * js> spawn(function() {o.f(5);});\n+     * Thread[Thread-0,5,main]\n+     * entry\n+     * js> spawn(function() {o.f(5);});\n+     * Thread[Thread-1,5,main]\n+     * js>\n+     * exit\n+     * entry\n+     * exit\n+     */\n+    public static Object sync(Context cx, Scriptable thisObj, Object[] args,\n+                              Function funObj)\n+    {\n+        if (args.length == 1 && args[0] instanceof Function) {\n+            return new Synchronizer((Function)args[0]);\n+        }\n+        else {\n+            throw reportRuntimeError(\"msg.sync.args\");\n+        }\n+    }\n+\n+    /**\n+     * Execute the specified command with the given argument and options\n+     * as a separate process and return the exit status of the process.\n+     * <p>\n+     * Usage:\n+     * <pre>\n+     * runCommand(command)\n+     * runCommand(command, arg1, ..., argN)\n+     * runCommand(command, arg1, ..., argN, options)\n+     * </pre>\n+     * All except the last arguments to runCommand are converted to strings\n+     * and denote command name and its arguments. If the last argument is a\n+     * JavaScript object, it is an option object. Otherwise it is converted to\n+     * string denoting the last argument and options objects assumed to be\n+     * empty.\n+     * The following properties of the option object are processed:\n+     * <ul>\n+     * <li><tt>args</tt> - provides an array of additional command arguments\n+     * <li><tt>env</tt> - explicit environment object. All its enumerable\n+     *   properties define the corresponding environment variable names.\n+     * <li><tt>input</tt> - the process input. If it is not\n+     *   java.io.InputStream, it is converted to string and sent to the process\n+     *   as its input. If not specified, no input is provided to the process.\n+     * <li><tt>output</tt> - the process output instead of\n+     *   java.lang.System.out. If it is not instance of java.io.OutputStream,\n+     *   the process output is read, converted to a string, appended to the\n+     *   output property value converted to string and put as the new value of\n+     *   the output property.\n+     * <li><tt>err</tt> - the process error output instead of\n+     *   java.lang.System.err. If it is not instance of java.io.OutputStream,\n+     *   the process error output is read, converted to a string, appended to\n+     *   the err property value converted to string and put as the new\n+     *   value of the err property.\n+     * </ul>\n+     */\n+    public static Object runCommand(Context cx, Scriptable thisObj,\n+                                    Object[] args, Function funObj)\n+        throws IOException\n+    {\n+        int L = args.length;\n+        if (L == 0 || (L == 1 && args[0] instanceof Scriptable)) {\n+            throw reportRuntimeError(\"msg.runCommand.bad.args\");\n+        }\n+\n+        InputStream in = null;\n+        OutputStream out = null, err = null;\n+        ByteArrayOutputStream outBytes = null, errBytes = null;\n+        Object outObj = null, errObj = null;\n+        String[] environment = null;\n+        Scriptable params = null;\n+        Object[] addArgs = null;\n+        if (args[L - 1] instanceof Scriptable) {\n+            params = (Scriptable)args[L - 1];\n+            --L;\n+            Object envObj = ScriptableObject.getProperty(params, \"env\");\n+            if (envObj != Scriptable.NOT_FOUND) {\n+                if (envObj == null) {\n+                    environment = new String[0];\n+                } else {\n+                    if (!(envObj instanceof Scriptable)) {\n+                        throw reportRuntimeError(\"msg.runCommand.bad.env\");\n+                    }\n+                    Scriptable envHash = (Scriptable)envObj;\n+                    Object[] ids = ScriptableObject.getPropertyIds(envHash);\n+                    environment = new String[ids.length];\n+                    for (int i = 0; i != ids.length; ++i) {\n+                        Object keyObj = ids[i], val;\n+                        String key;\n+                        if (keyObj instanceof String) {\n+                            key = (String)keyObj;\n+                            val = ScriptableObject.getProperty(envHash, key);\n+                        } else {\n+                            int ikey = ((Number)keyObj).intValue();\n+                            key = Integer.toString(ikey);\n+                            val = ScriptableObject.getProperty(envHash, ikey);\n+                        }\n+                        if (val == ScriptableObject.NOT_FOUND) {\n+                            val = Undefined.instance;\n+                        }\n+                        environment[i] = key+'='+ScriptRuntime.toString(val);\n+                    }\n+                }\n+            }\n+            Object inObj = ScriptableObject.getProperty(params, \"input\");\n+            if (inObj != Scriptable.NOT_FOUND) {\n+                in = toInputStream(inObj);\n+            }\n+            outObj = ScriptableObject.getProperty(params, \"output\");\n+            if (outObj != Scriptable.NOT_FOUND) {\n+                out = toOutputStream(outObj);\n+                if (out == null) {\n+                    outBytes = new ByteArrayOutputStream();\n+                    out = outBytes;\n+                }\n+            }\n+            errObj = ScriptableObject.getProperty(params, \"err\");\n+            if (errObj != Scriptable.NOT_FOUND) {\n+                err = toOutputStream(errObj);\n+                if (err == null) {\n+                    errBytes = new ByteArrayOutputStream();\n+                    err = errBytes;\n+                }\n+            }\n+            Object addArgsObj = ScriptableObject.getProperty(params, \"args\");\n+            if (addArgsObj != Scriptable.NOT_FOUND) {\n+                Scriptable s = Context.toObject(addArgsObj,\n+                                                getTopLevelScope(thisObj));\n+                addArgs = cx.getElements(s);\n+            }\n+        }\n+        Global global = getInstance(funObj);\n+        if (out == null) {\n+            out = (global != null) ? global.getOut() : System.out;\n+        }\n+        if (err == null) {\n+            err = (global != null) ? global.getErr() : System.err;\n+        }\n+        // If no explicit input stream, do not send any input to process,\n+        // in particular, do not use System.in to avoid deadlocks\n+        // when waiting for user input to send to process which is already\n+        // terminated as it is not always possible to interrupt read method.\n+\n+        String[] cmd = new String[(addArgs == null) ? L : L + addArgs.length];\n+        for (int i = 0; i != L; ++i) {\n+            cmd[i] = ScriptRuntime.toString(args[i]);\n+        }\n+        if (addArgs != null) {\n+            for (int i = 0; i != addArgs.length; ++i) {\n+                cmd[L + i] = ScriptRuntime.toString(addArgs[i]);\n+            }\n+        }\n+\n+        int exitCode = runProcess(cmd, environment, in, out, err);\n+        if (outBytes != null) {\n+            String s = ScriptRuntime.toString(outObj) + outBytes.toString();\n+            ScriptableObject.putProperty(params, \"output\", s);\n+        }\n+        if (errBytes != null) {\n+            String s = ScriptRuntime.toString(errObj) + errBytes.toString();\n+            ScriptableObject.putProperty(params, \"err\", s);\n+        }\n+\n+        return new Integer(exitCode);\n+    }\n+\n+    /**\n+     * The seal function seals all supplied arguments.\n+     */\n+    public static void seal(Context cx, Scriptable thisObj, Object[] args,\n+                            Function funObj)\n+    {\n+        for (int i = 0; i != args.length; ++i) {\n+            Object arg = args[i];\n+            if (!(arg instanceof ScriptableObject) || arg == Undefined.instance)\n+            {\n+                if (!(arg instanceof Scriptable) || arg == Undefined.instance)\n+                {\n+                    throw reportRuntimeError(\"msg.shell.seal.not.object\");\n+                } else {\n+                    throw reportRuntimeError(\"msg.shell.seal.not.scriptable\");\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i != args.length; ++i) {\n+            Object arg = args[i];\n+            ((ScriptableObject)arg).sealObject();\n+        }\n+    }\n+\n+    /**\n+     * The readFile reads the given file content and convert it to a string\n+     * using the specified character coding or default character coding if\n+     * explicit coding argument is not given.\n+     * <p>\n+     * Usage:\n+     * <pre>\n+     * readFile(filePath)\n+     * readFile(filePath, charCoding)\n+     * </pre>\n+     * The first form converts file's context to string using the default\n+     * character coding.\n+     */\n+    public static Object readFile(Context cx, Scriptable thisObj, Object[] args,\n+                                  Function funObj)\n+        throws IOException\n+    {\n+        if (args.length == 0) {\n+            throw reportRuntimeError(\"msg.shell.readFile.bad.args\");\n+        }\n+        String path = ScriptRuntime.toString(args[0]);\n+        String charCoding = null;\n+        if (args.length >= 2) {\n+            charCoding = ScriptRuntime.toString(args[1]);\n+        }\n+\n+        return readUrl(path, charCoding, true);\n+    }\n+\n+    /**\n+     * The readUrl opens connection to the given URL, read all its data\n+     * and converts them to a string\n+     * using the specified character coding or default character coding if\n+     * explicit coding argument is not given.\n+     * <p>\n+     * Usage:\n+     * <pre>\n+     * readUrl(url)\n+     * readUrl(url, charCoding)\n+     * </pre>\n+     * The first form converts file's context to string using the default\n+     * charCoding.\n+     */\n+    public static Object readUrl(Context cx, Scriptable thisObj, Object[] args,\n+                                 Function funObj)\n+        throws IOException\n+    {\n+        if (args.length == 0) {\n+            throw reportRuntimeError(\"msg.shell.readUrl.bad.args\");\n+        }\n+        String url = ScriptRuntime.toString(args[0]);\n+        String charCoding = null;\n+        if (args.length >= 2) {\n+            charCoding = ScriptRuntime.toString(args[1]);\n+        }\n+\n+        return readUrl(url, charCoding, false);\n+    }\n+\n+    /**\n+     * Convert the argument to int32 number.\n+     */\n+    public static Object toint32(Context cx, Scriptable thisObj, Object[] args,\n+                                 Function funObj)\n+    {\n+        Object arg = (args.length != 0 ? args[0] : Undefined.instance);\n+        if (arg instanceof Integer)\n+            return arg;\n+        return ScriptRuntime.wrapInt(ScriptRuntime.toInt32(arg));\n+    }\n+\n+    public InputStream getIn() {\n+        if (inStream == null && !attemptedJLineLoad) {\n+            // Check if we can use JLine for better command line handling\n+            InputStream jlineStream = ShellLine.getStream(this);\n+            if (jlineStream != null)\n+                inStream = jlineStream;\n+            attemptedJLineLoad = true;\n+        }\n+        return inStream == null ? System.in : inStream;\n+    }\n+\n+    public void setIn(InputStream in) {\n+        inStream = in;\n+    }\n+\n+    public PrintStream getOut() {\n+        return outStream == null ? System.out : outStream;\n+    }\n+\n+    public void setOut(PrintStream out) {\n+        outStream = out;\n+    }\n+\n+    public PrintStream getErr() {\n+        return errStream == null ? System.err : errStream;\n+    }\n+\n+    public void setErr(PrintStream err) {\n+        errStream = err;\n+    }\n+\n+    public void setSealedStdLib(boolean value)\n+    {\n+        sealedStdLib = value;\n+    }\n+\n+    private static Global getInstance(Function function)\n+    {\n+        Scriptable scope = function.getParentScope();\n+        if (!(scope instanceof Global))\n+            throw reportRuntimeError(\"msg.bad.shell.function.scope\",\n+                                     String.valueOf(scope));\n+        return (Global)scope;\n+    }\n+\n+    /**\n+     * Runs the given process using Runtime.exec().\n+     * If any of in, out, err is null, the corresponding process stream will\n+     * be closed immediately, otherwise it will be closed as soon as\n+     * all data will be read from/written to process\n+     *\n+     * @return Exit value of process.\n+     * @throws IOException If there was an error executing the process.\n+     */\n+    private static int runProcess(String[] cmd, String[] environment,\n+                                  InputStream in, OutputStream out,\n+                                  OutputStream err)\n+        throws IOException\n+    {\n+        Process p;\n+        if (environment == null) {\n+            p = Runtime.getRuntime().exec(cmd);\n+        } else {\n+            p = Runtime.getRuntime().exec(cmd, environment);\n+        }\n+\n+        try {\n+            PipeThread inThread = null;\n+            if (in != null) {\n+                inThread = new PipeThread(false, in, p.getOutputStream());\n+                inThread.start();\n+            } else {\n+                p.getOutputStream().close();\n+            }\n+\n+            PipeThread outThread = null;\n+            if (out != null) {\n+                outThread = new PipeThread(true, p.getInputStream(), out);\n+                outThread.start();\n+            } else {\n+                p.getInputStream().close();\n+            }\n+\n+            PipeThread errThread = null;\n+            if (err != null) {\n+                errThread = new PipeThread(true, p.getErrorStream(), err);\n+                errThread.start();\n+            } else {\n+                p.getErrorStream().close();\n+            }\n+\n+            // wait for process completion\n+            for (;;) {\n+                try {\n+                    p.waitFor();\n+                    if (outThread != null) {\n+                        outThread.join();\n+                    }\n+                    if (inThread != null) {\n+                        inThread.join();\n+                    }\n+                    if (errThread != null) {\n+                        errThread.join();\n+                    }\n+                    break;\n+                } catch (InterruptedException ignore) {\n+                }\n+            }\n+\n+            return p.exitValue();\n+        } finally {\n+            p.destroy();\n+        }\n+    }\n+\n+    static void pipe(boolean fromProcess, InputStream from, OutputStream to)\n+        throws IOException\n+    {\n+        try {\n+            final int SIZE = 4096;\n+            byte[] buffer = new byte[SIZE];\n+            for (;;) {\n+                int n;\n+                if (!fromProcess) {\n+                    n = from.read(buffer, 0, SIZE);\n+                } else {\n+                    try {\n+                        n = from.read(buffer, 0, SIZE);\n+                    } catch (IOException ex) {\n+                        // Ignore exception as it can be cause by closed pipe\n+                        break;\n+                    }\n+                }\n+                if (n < 0) { break; }\n+                if (fromProcess) {\n+                    to.write(buffer, 0, n);\n+                    to.flush();\n+                } else {\n+                    try {\n+                        to.write(buffer, 0, n);\n+                        to.flush();\n+                    } catch (IOException ex) {\n+                        // Ignore exception as it can be cause by closed pipe\n+                        break;\n+                    }\n+                }\n+            }\n+        } finally {\n+            try {\n+                if (fromProcess) {\n+                    from.close();\n+                } else {\n+                    to.close();\n+                }\n+            } catch (IOException ex) {\n+                // Ignore errors on close. On Windows JVM may throw invalid\n+                // refrence exception if process terminates too fast.\n+            }\n+        }\n+    }\n+\n+    private static InputStream toInputStream(Object value)\n+        throws IOException\n+    {\n+        InputStream is = null;\n+        String s = null;\n+        if (value instanceof Wrapper) {\n+            Object unwrapped = ((Wrapper)value).unwrap();\n+            if (unwrapped instanceof InputStream) {\n+                is = (InputStream)unwrapped;\n+            } else if (unwrapped instanceof byte[]) {\n+                is = new ByteArrayInputStream((byte[])unwrapped);\n+            } else if (unwrapped instanceof Reader) {\n+                s = readReader((Reader)unwrapped);\n+            } else if (unwrapped instanceof char[]) {\n+                s = new String((char[])unwrapped);\n+            }\n+        }\n+        if (is == null) {\n+            if (s == null) { s = ScriptRuntime.toString(value); }\n+            is = new ByteArrayInputStream(s.getBytes());\n+        }\n+        return is;\n+    }\n+\n+    private static OutputStream toOutputStream(Object value) {\n+        OutputStream os = null;\n+        if (value instanceof Wrapper) {\n+            Object unwrapped = ((Wrapper)value).unwrap();\n+            if (unwrapped instanceof OutputStream) {\n+                os = (OutputStream)unwrapped;\n+            }\n+        }\n+        return os;\n+    }\n+\n+    private static String readUrl(String filePath, String charCoding,\n+                                  boolean urlIsFile)\n+        throws IOException\n+    {\n+        int chunkLength;\n+        InputStream is = null;\n+        try {\n+            if (!urlIsFile) {\n+                URL urlObj = new URL(filePath);\n+                URLConnection uc = urlObj.openConnection();\n+                is = uc.getInputStream();\n+                chunkLength = uc.getContentLength();\n+                if (chunkLength <= 0)\n+                    chunkLength = 1024;\n+                if (charCoding == null) {\n+                    String type = uc.getContentType();\n+                    if (type != null) {\n+                        charCoding = getCharCodingFromType(type);\n+                    }\n+                }\n+            } else {\n+                File f = new File(filePath);\n+                if (!f.exists()) {\n+                    throw new FileNotFoundException(\"File not found: \" + filePath);\n+                } else if (!f.canRead()) {\n+                    throw new IOException(\"Cannot read file: \" + filePath);\n+                }\n+                long length = f.length();\n+                chunkLength = (int)length;\n+                if (chunkLength != length)\n+                    throw new IOException(\"Too big file size: \"+length);\n+\n+                if (chunkLength == 0) { return \"\"; }\n+\n+                is = new FileInputStream(f);\n+            }\n+\n+            Reader r;\n+            if (charCoding == null) {\n+                r = new InputStreamReader(is);\n+            } else {\n+                r = new InputStreamReader(is, charCoding);\n+            }\n+            return readReader(r, chunkLength);\n+\n+        } finally {\n+            if (is != null)\n+                is.close();\n+        }\n+    }\n+\n+    private static String getCharCodingFromType(String type)\n+    {\n+        int i = type.indexOf(';');\n+        if (i >= 0) {\n+            int end = type.length();\n+            ++i;\n+            while (i != end && type.charAt(i) <= ' ') {\n+                ++i;\n+            }\n+            String charset = \"charset\";\n+            if (charset.regionMatches(true, 0, type, i, charset.length()))\n+            {\n+                i += charset.length();\n+                while (i != end && type.charAt(i) <= ' ') {\n+                    ++i;\n+                }\n+                if (i != end && type.charAt(i) == '=') {\n+                    ++i;\n+                    while (i != end && type.charAt(i) <= ' ') {\n+                        ++i;\n+                    }\n+                    if (i != end) {\n+                        // i is at the start of non-empty\n+                        // charCoding spec\n+                        while (type.charAt(end -1) <= ' ') {\n+                            --end;\n+                        }\n+                        return type.substring(i, end);\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static String readReader(Reader reader)\n+        throws IOException\n+    {\n+        return readReader(reader, 4096);\n+    }\n+\n+    private static String readReader(Reader reader, int initialBufferSize)\n+        throws IOException\n+    {\n+        char[] buffer = new char[initialBufferSize];\n+        int offset = 0;\n+        for (;;) {\n+            int n = reader.read(buffer, offset, buffer.length - offset);\n+            if (n < 0) { break;    }\n+            offset += n;\n+            if (offset == buffer.length) {\n+                char[] tmp = new char[buffer.length * 2];\n+                System.arraycopy(buffer, 0, tmp, 0, offset);\n+                buffer = tmp;\n+            }\n+        }\n+        return new String(buffer, 0, offset);\n+    }\n+\n+    static RuntimeException reportRuntimeError(String msgId) {\n+        String message = ToolErrorReporter.getMessage(msgId);\n+        return Context.reportRuntimeError(message);\n+    }\n+\n+    static RuntimeException reportRuntimeError(String msgId, String msgArg)\n+    {\n+        String message = ToolErrorReporter.getMessage(msgId, msgArg);\n+        return Context.reportRuntimeError(message);\n+    }\n+}\n+\n+\n+class Runner implements Runnable, ContextAction {\n+\n+    Runner(Scriptable scope, Function func, Object[] args) {\n+        this.scope = scope;\n+        f = func;\n+        this.args = args;\n+    }\n+\n+    Runner(Scriptable scope, Script script) {\n+        this.scope = scope;\n+        s = script;\n+    }\n+\n+    public void run()\n+    {\n+        factory.call(this);\n+    }\n+\n+    public Object run(Context cx)\n+    {\n+        if (f != null)\n+            return f.call(cx, scope, scope, args);\n+        else\n+            return s.exec(cx, scope);\n+    }\n+\n+    ContextFactory factory;\n+    private Scriptable scope;\n+    private Function f;\n+    private Script s;\n+    private Object[] args;\n+}\n+\n+class PipeThread extends Thread {\n+\n+    PipeThread(boolean fromProcess, InputStream from, OutputStream to) {\n+        setDaemon(true);\n+        this.fromProcess = fromProcess;\n+        this.from = from;\n+        this.to = to;\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            Global.pipe(fromProcess, from, to);\n+        } catch (IOException ex) {\n+            throw Context.throwAsScriptRuntimeEx(ex);\n+        }\n+    }\n+\n+    private boolean fromProcess;\n+    private InputStream from;\n+    private OutputStream to;\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/JSConsole.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino JavaScript Debugger code, released\n+ * November 21, 2000.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * See Beyond Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Christopher Oliver\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+package org.mozilla.javascript.tools.shell;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.io.File;\n+\n+import javax.swing.ButtonGroup;\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JOptionPane;\n+import javax.swing.JRadioButtonMenuItem;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+import org.mozilla.javascript.SecurityUtilities;\n+\n+public class JSConsole extends JFrame implements ActionListener\n+{\n+    static final long serialVersionUID = 2551225560631876300L;\n+\n+    private File CWD;\n+    private JFileChooser dlg;\n+    private ConsoleTextArea consoleTextArea;\n+\n+    public String chooseFile() {\n+        if(CWD == null) {\n+            String dir = SecurityUtilities.getSystemProperty(\"user.dir\");\n+            if(dir != null) {\n+                CWD = new File(dir);\n+            }\n+        }\n+        if(CWD != null) {\n+            dlg.setCurrentDirectory(CWD);\n+        }\n+        dlg.setDialogTitle(\"Select a file to load\");\n+        int returnVal = dlg.showOpenDialog(this);\n+        if(returnVal == JFileChooser.APPROVE_OPTION) {\n+            String result = dlg.getSelectedFile().getPath();\n+            CWD = new File(dlg.getSelectedFile().getParent());\n+            return result;\n+        }\n+        return null;\n+    }\n+\n+    public static void main(String args[]) {\n+        new JSConsole(args);\n+    }\n+\n+    public void createFileChooser() {\n+        dlg = new JFileChooser();\n+        javax.swing.filechooser.FileFilter filter =\n+            new javax.swing.filechooser.FileFilter() {\n+                   @Override\n+                    public boolean accept(File f) {\n+                        if(f.isDirectory()) {\n+                            return true;\n+                        }\n+                        String name = f.getName();\n+                        int i = name.lastIndexOf('.');\n+                        if(i > 0 && i < name.length() -1) {\n+                            String ext = name.substring(i + 1).toLowerCase();\n+                            if(ext.equals(\"js\")) {\n+                                return true;\n+                            }\n+                        }\n+                        return false;\n+                    }\n+\n+                   @Override\n+                    public String getDescription() {\n+                        return \"JavaScript Files (*.js)\";\n+                    }\n+                };\n+        dlg.addChoosableFileFilter(filter);\n+\n+    }\n+\n+    public JSConsole(String[] args) {\n+        super(\"Rhino JavaScript Console\");\n+        JMenuBar menubar = new JMenuBar();\n+        createFileChooser();\n+        String[] fileItems  = {\"Load...\", \"Exit\"};\n+        String[] fileCmds  = {\"Load\", \"Exit\"};\n+        char[] fileShortCuts = {'L', 'X'};\n+        String[] editItems = {\"Cut\", \"Copy\", \"Paste\"};\n+        char[] editShortCuts = {'T', 'C', 'P'};\n+        String[] plafItems = {\"Metal\", \"Windows\", \"Motif\"};\n+        boolean [] plafState = {true, false, false};\n+        JMenu fileMenu = new JMenu(\"File\");\n+        fileMenu.setMnemonic('F');\n+        JMenu editMenu = new JMenu(\"Edit\");\n+        editMenu.setMnemonic('E');\n+        JMenu plafMenu = new JMenu(\"Platform\");\n+        plafMenu.setMnemonic('P');\n+        for(int i = 0; i < fileItems.length; ++i) {\n+            JMenuItem item = new JMenuItem(fileItems[i],\n+                                           fileShortCuts[i]);\n+            item.setActionCommand(fileCmds[i]);\n+            item.addActionListener(this);\n+            fileMenu.add(item);\n+        }\n+        for(int i = 0; i < editItems.length; ++i) {\n+            JMenuItem item = new JMenuItem(editItems[i],\n+                                           editShortCuts[i]);\n+            item.addActionListener(this);\n+            editMenu.add(item);\n+        }\n+        ButtonGroup group = new ButtonGroup();\n+        for(int i = 0; i < plafItems.length; ++i) {\n+            JRadioButtonMenuItem item = new JRadioButtonMenuItem(plafItems[i],\n+                                                                 plafState[i]);\n+            group.add(item);\n+            item.addActionListener(this);\n+            plafMenu.add(item);\n+        }\n+        menubar.add(fileMenu);\n+        menubar.add(editMenu);\n+        menubar.add(plafMenu);\n+        setJMenuBar(menubar);\n+        consoleTextArea = new ConsoleTextArea(args);\n+        JScrollPane scroller = new JScrollPane(consoleTextArea);\n+        setContentPane(scroller);\n+        consoleTextArea.setRows(24);\n+        consoleTextArea.setColumns(80);\n+        addWindowListener(new WindowAdapter() {\n+                @Override\n+                public void windowClosing(WindowEvent e) {\n+                    System.exit(0);\n+                }\n+            });\n+        pack();\n+        setVisible(true);\n+        // System.setIn(consoleTextArea.getIn());\n+        // System.setOut(consoleTextArea.getOut());\n+        // System.setErr(consoleTextArea.getErr());\n+        Main.setIn(consoleTextArea.getIn());\n+        Main.setOut(consoleTextArea.getOut());\n+        Main.setErr(consoleTextArea.getErr());\n+        Main.main(args);\n+    }\n+\n+    public void actionPerformed(ActionEvent e) {\n+        String cmd = e.getActionCommand();\n+        String plaf_name = null;\n+        if(cmd.equals(\"Load\")) {\n+            String f = chooseFile();\n+            if(f != null) {\n+                f = f.replace('\\\\', '/');\n+                consoleTextArea.eval(\"load(\\\"\" + f + \"\\\");\");\n+            }\n+        } else if(cmd.equals(\"Exit\")) {\n+            System.exit(0);\n+        } else if(cmd.equals(\"Cut\")) {\n+            consoleTextArea.cut();\n+        } else if(cmd.equals(\"Copy\")) {\n+            consoleTextArea.copy();\n+        } else if(cmd.equals(\"Paste\")) {\n+            consoleTextArea.paste();\n+        } else {\n+            if(cmd.equals(\"Metal\")) {\n+                plaf_name = \"javax.swing.plaf.metal.MetalLookAndFeel\";\n+            } else if(cmd.equals(\"Windows\")) {\n+                plaf_name = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\n+            } else if(cmd.equals(\"Motif\")) {\n+                plaf_name = \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\";\n+            }\n+            if(plaf_name != null) {\n+                try {\n+                    UIManager.setLookAndFeel(plaf_name);\n+                    SwingUtilities.updateComponentTreeUI(this);\n+                    consoleTextArea.postUpdateUI();\n+                    // updateComponentTreeUI seems to mess up the file\n+                    // chooser dialog, so just create a new one\n+                    createFileChooser();\n+                } catch(Exception exc) {\n+                    JOptionPane.showMessageDialog(this,\n+                                                  exc.getMessage(),\n+                                                  \"Platform\",\n+                                                  JOptionPane.ERROR_MESSAGE);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/JavaPolicySecurity.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tools.shell;\n+\n+import java.security.*;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Enumeration;\n+\n+import org.mozilla.javascript.*;\n+\n+public class JavaPolicySecurity extends SecurityProxy\n+{\n+\n+    @Override\n+    public Class<?> getStaticSecurityDomainClassInternal() {\n+        return ProtectionDomain.class;\n+    }\n+\n+    private static class Loader extends ClassLoader\n+        implements GeneratedClassLoader\n+    {\n+        private ProtectionDomain domain;\n+\n+        Loader(ClassLoader parent, ProtectionDomain domain) {\n+            super(parent != null ? parent : getSystemClassLoader());\n+            this.domain = domain;\n+        }\n+\n+        public Class<?> defineClass(String name, byte[] data) {\n+            return super.defineClass(name, data, 0, data.length, domain);\n+        }\n+\n+        public void linkClass(Class<?> cl) {\n+            resolveClass(cl);\n+        }\n+    }\n+\n+    private static class ContextPermissions extends PermissionCollection\n+    {\n+        static final long serialVersionUID = -1721494496320750721L;\n+\n+// Construct PermissionCollection that permits an action only\n+// if it is permitted by staticDomain and by security context of Java stack on\n+// the moment of constructor invocation\n+        ContextPermissions(ProtectionDomain staticDomain) {\n+            _context = AccessController.getContext();\n+            if (staticDomain != null) {\n+                _statisPermissions = staticDomain.getPermissions();\n+            }\n+            setReadOnly();\n+        }\n+\n+        @Override\n+        public void add(Permission permission) {\n+            throw new RuntimeException(\"NOT IMPLEMENTED\");\n+        }\n+\n+        @Override\n+        public boolean implies(Permission permission) {\n+            if (_statisPermissions != null) {\n+                if (!_statisPermissions.implies(permission)) {\n+                    return false;\n+                }\n+            }\n+            try {\n+                _context.checkPermission(permission);\n+                return true;\n+            }catch (AccessControlException ex) {\n+                return false;\n+            }\n+        }\n+\n+        @Override\n+        public Enumeration<Permission> elements()\n+        {\n+            return new Enumeration<Permission>() {\n+                public boolean hasMoreElements() { return false; }\n+                public Permission nextElement() { return null; }\n+            };\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuffer sb = new StringBuffer();\n+            sb.append(getClass().getName());\n+            sb.append('@');\n+            sb.append(Integer.toHexString(System.identityHashCode(this)));\n+            sb.append(\" (context=\");\n+            sb.append(_context);\n+            sb.append(\", static_permitions=\");\n+            sb.append(_statisPermissions);\n+            sb.append(')');\n+            return sb.toString();\n+        }\n+\n+        AccessControlContext _context;\n+        PermissionCollection _statisPermissions;\n+    }\n+\n+    public JavaPolicySecurity()\n+    {\n+        // To trigger error on jdk-1.1 with lazy load\n+        new CodeSource(null,  (java.security.cert.Certificate[])null);\n+    }\n+\n+    @Override\n+    protected void callProcessFileSecure(final Context cx,\n+                                         final Scriptable scope,\n+                                         final String filename)\n+    {\n+        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n+            public Object run() {\n+                URL url = getUrlObj(filename);\n+                ProtectionDomain staticDomain = getUrlDomain(url);\n+                Main.processFileSecure(cx, scope, url.toExternalForm(),\n+                                       staticDomain);\n+                return null;\n+            }\n+        });\n+    }\n+\n+    private URL getUrlObj(String url)\n+    {\n+        URL urlObj;\n+        try {\n+            urlObj = new URL(url);\n+        } catch (MalformedURLException ex) {\n+            // Assume as Main.processFileSecure it is file, need to build its\n+            // URL\n+            String curDir = System.getProperty(\"user.dir\");\n+            curDir = curDir.replace('\\\\', '/');\n+            if (!curDir.endsWith(\"/\")) {\n+                curDir = curDir+'/';\n+            }\n+            try {\n+                URL curDirURL = new URL(\"file:\"+curDir);\n+                urlObj = new URL(curDirURL, url);\n+            } catch (MalformedURLException ex2) {\n+                throw new RuntimeException\n+                    (\"Can not construct file URL for '\"+url+\"':\"\n+                     +ex2.getMessage());\n+            }\n+        }\n+        return urlObj;\n+    }\n+\n+    private ProtectionDomain getUrlDomain(URL url)\n+    {\n+        CodeSource cs;\n+        cs = new CodeSource(url, (java.security.cert.Certificate[])null);\n+        PermissionCollection pc = Policy.getPolicy().getPermissions(cs);\n+        return new ProtectionDomain(cs, pc);\n+    }\n+\n+    @Override\n+    public GeneratedClassLoader\n+    createClassLoader(ClassLoader parentLoader, Object securityDomain)\n+    {\n+        ProtectionDomain domain = (ProtectionDomain)securityDomain;\n+        return new Loader(parentLoader, domain);\n+    }\n+\n+    @Override\n+    public Object getDynamicSecurityDomain(Object securityDomain)\n+    {\n+        ProtectionDomain staticDomain = (ProtectionDomain)securityDomain;\n+        return getDynamicDomain(staticDomain);\n+    }\n+\n+    private ProtectionDomain getDynamicDomain(ProtectionDomain staticDomain) {\n+        ContextPermissions p = new ContextPermissions(staticDomain);\n+        ProtectionDomain contextDomain = new ProtectionDomain(null, p);\n+        return contextDomain;\n+    }\n+\n+    @Override\n+    public Object callWithDomain(Object securityDomain,\n+                                 final Context cx,\n+                                 final Callable callable,\n+                                 final Scriptable scope,\n+                                 final Scriptable thisObj,\n+                                 final Object[] args)\n+    {\n+        ProtectionDomain staticDomain = (ProtectionDomain)securityDomain;\n+        // There is no direct way in Java to intersect permissions according\n+        // stack context with additional domain.\n+        // The following implementation first constructs ProtectionDomain\n+        // that allows actions only allowed by both staticDomain and current\n+        // stack context, and then constructs AccessController for this dynamic\n+        // domain.\n+        // If this is too slow, alternative solution would be to generate\n+        // class per domain with a proxy method to call to infect\n+        // java stack.\n+        // Another optimization in case of scripts coming from \"world\" domain,\n+        // that is having minimal default privileges is to construct\n+        // one AccessControlContext based on ProtectionDomain\n+        // with least possible privileges and simply call\n+        // AccessController.doPrivileged with this untrusted context\n+\n+        ProtectionDomain dynamicDomain = getDynamicDomain(staticDomain);\n+        ProtectionDomain[] tmp = { dynamicDomain };\n+        AccessControlContext restricted = new AccessControlContext(tmp);\n+\n+        PrivilegedAction<Object> action = new PrivilegedAction<Object>() {\n+            public Object run() {\n+                return callable.call(cx, scope, thisObj, args);\n+            }\n+        };\n+\n+        return AccessController.doPrivileged(action, restricted);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/Main.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Patrick Beard\n+ *   Norris Boyd\n+ *   Igor Bukanov\n+ *   Rob Ginda\n+ *   Kurt Westerfeld\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tools.shell;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.EvaluatorException;\n+import org.mozilla.javascript.Function;\n+import org.mozilla.javascript.GeneratedClassLoader;\n+import org.mozilla.javascript.Kit;\n+import org.mozilla.javascript.NativeArray;\n+import org.mozilla.javascript.RhinoException;\n+import org.mozilla.javascript.Script;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.ScriptableObject;\n+import org.mozilla.javascript.SecurityController;\n+import org.mozilla.javascript.tools.SourceReader;\n+import org.mozilla.javascript.tools.ToolErrorReporter;\n+\n+/**\n+ * The shell program.\n+ *\n+ * Can execute scripts interactively or in batch mode at the command line.\n+ * An example of controlling the JavaScript engine.\n+ *\n+ */\n+public class Main\n+{\n+    public static ShellContextFactory\n+        shellContextFactory = new ShellContextFactory();\n+\n+    public static Global global = new Global();\n+    static protected ToolErrorReporter errorReporter;\n+    static protected int exitCode = 0;\n+    static private final int EXITCODE_RUNTIME_ERROR = 3;\n+    static private final int EXITCODE_FILE_NOT_FOUND = 4;\n+    static boolean processStdin = true;\n+    static List<String> fileList = new ArrayList<String>();\n+    private static SecurityProxy securityImpl;\n+\n+    static {\n+        global.initQuitAction(new IProxy(IProxy.SYSTEM_EXIT));\n+    }\n+\n+    /**\n+     * Proxy class to avoid proliferation of anonymous classes.\n+     */\n+    private static class IProxy implements ContextAction, QuitAction\n+    {\n+        private static final int PROCESS_FILES = 1;\n+        private static final int EVAL_INLINE_SCRIPT = 2;\n+        private static final int SYSTEM_EXIT = 3;\n+\n+        private int type;\n+        String[] args;\n+        String scriptText;\n+\n+        IProxy(int type)\n+        {\n+            this.type = type;\n+        }\n+\n+        public Object run(Context cx)\n+        {\n+            if (type == PROCESS_FILES) {\n+                processFiles(cx, args);\n+            } else if (type == EVAL_INLINE_SCRIPT) {\n+                Script script = loadScriptFromSource(cx, scriptText,\n+                                                     \"<command>\", 1, null);\n+                if (script != null) {\n+                    evaluateScript(script, cx, getGlobal());\n+                }\n+            } else {\n+                throw Kit.codeBug();\n+            }\n+            return null;\n+        }\n+\n+        public void quit(Context cx, int exitCode)\n+        {\n+            if (type == SYSTEM_EXIT) {\n+                System.exit(exitCode);\n+                return;\n+            }\n+            throw Kit.codeBug();\n+        }\n+    }\n+\n+    /**\n+     * Main entry point.\n+     *\n+     * Process arguments as would a normal Java program. Also\n+     * create a new Context and associate it with the current thread.\n+     * Then set up the execution environment and begin to\n+     * execute scripts.\n+     */\n+    public static void main(String args[]) {\n+        try {\n+            if (Boolean.getBoolean(\"rhino.use_java_policy_security\")) {\n+                initJavaPolicySecuritySupport();\n+            }\n+        } catch (SecurityException ex) {\n+            ex.printStackTrace(System.err);\n+        }\n+\n+        int result = exec(args);\n+        if (result != 0) {\n+            System.exit(result);\n+        }\n+    }\n+\n+    /**\n+     *  Execute the given arguments, but don't System.exit at the end.\n+     */\n+    public static int exec(String origArgs[])\n+    {\n+        errorReporter = new ToolErrorReporter(false, global.getErr());\n+        shellContextFactory.setErrorReporter(errorReporter);\n+        String[] args = processOptions(origArgs);\n+        if (processStdin)\n+            fileList.add(null);\n+\n+        if (!global.initialized) {\n+            global.init(shellContextFactory);\n+        }\n+        IProxy iproxy = new IProxy(IProxy.PROCESS_FILES);\n+        iproxy.args = args;\n+        shellContextFactory.call(iproxy);\n+\n+        return exitCode;\n+    }\n+\n+    static void processFiles(Context cx, String[] args)\n+    {\n+        // define \"arguments\" array in the top-level object:\n+        // need to allocate new array since newArray requires instances\n+        // of exactly Object[], not ObjectSubclass[]\n+        Object[] array = new Object[args.length];\n+        System.arraycopy(args, 0, array, 0, args.length);\n+        Scriptable argsObj = cx.newArray(global, array);\n+        global.defineProperty(\"arguments\", argsObj,\n+                              ScriptableObject.DONTENUM);\n+\n+        for (String file: fileList) {\n+            processSource(cx, file);\n+        }\n+    }\n+\n+    public static Global getGlobal()\n+    {\n+        return global;\n+    }\n+\n+    /**\n+     * Parse arguments.\n+     */\n+    public static String[] processOptions(String args[])\n+    {\n+        String usageError;\n+        goodUsage: for (int i = 0; ; ++i) {\n+            if (i == args.length) {\n+                return new String[0];\n+            }\n+            String arg = args[i];\n+            if (!arg.startsWith(\"-\")) {\n+                processStdin = false;\n+                fileList.add(arg);\n+                String[] result = new String[args.length - i - 1];\n+                System.arraycopy(args, i+1, result, 0, args.length - i - 1);\n+                return result;\n+            }\n+            if (arg.equals(\"-version\")) {\n+                if (++i == args.length) {\n+                    usageError = arg;\n+                    break goodUsage;\n+                }\n+                int version;\n+                try {\n+                    version = Integer.parseInt(args[i]);\n+                } catch (NumberFormatException ex) {\n+                    usageError = args[i];\n+                    break goodUsage;\n+                }\n+                if (!Context.isValidLanguageVersion(version)) {\n+                    usageError = args[i];\n+                    break goodUsage;\n+                }\n+                shellContextFactory.setLanguageVersion(version);\n+                continue;\n+            }\n+            if (arg.equals(\"-opt\") || arg.equals(\"-O\")) {\n+                if (++i == args.length) {\n+                    usageError = arg;\n+                    break goodUsage;\n+                }\n+                int opt;\n+                try {\n+                    opt = Integer.parseInt(args[i]);\n+                } catch (NumberFormatException ex) {\n+                    usageError = args[i];\n+                    break goodUsage;\n+                }\n+                if (opt == -2) {\n+                    // Compatibility with Cocoon Rhino fork\n+                    opt = -1;\n+                } else if (!Context.isValidOptimizationLevel(opt)) {\n+                    usageError = args[i];\n+                    break goodUsage;\n+                }\n+                shellContextFactory.setOptimizationLevel(opt);\n+                continue;\n+            }\n+            if (arg.equals(\"-encoding\")) {\n+                if (++i == args.length) {\n+                    usageError = arg;\n+                    break goodUsage;\n+                }\n+                String enc = args[i];\n+                shellContextFactory.setCharacterEncoding(enc);\n+                continue;\n+            }\n+            if (arg.equals(\"-strict\")) {\n+                shellContextFactory.setStrictMode(true);\n+                errorReporter.setIsReportingWarnings(true);\n+                continue;\n+            }\n+            if (arg.equals(\"-fatal-warnings\")) {\n+                shellContextFactory.setWarningAsError(true);\n+                continue;\n+            }\n+            if (arg.equals(\"-e\")) {\n+                processStdin = false;\n+                if (++i == args.length) {\n+                    usageError = arg;\n+                    break goodUsage;\n+                }\n+                if (!global.initialized) {\n+                    global.init(shellContextFactory);\n+                }\n+                IProxy iproxy = new IProxy(IProxy.EVAL_INLINE_SCRIPT);\n+                iproxy.scriptText = args[i];\n+                shellContextFactory.call(iproxy);\n+                continue;\n+            }\n+            if (arg.equals(\"-w\")) {\n+                errorReporter.setIsReportingWarnings(true);\n+                continue;\n+            }\n+            if (arg.equals(\"-f\")) {\n+                processStdin = false;\n+                if (++i == args.length) {\n+                    usageError = arg;\n+                    break goodUsage;\n+                }\n+                fileList.add(args[i].equals(\"-\") ? null : args[i]);\n+                continue;\n+            }\n+            if (arg.equals(\"-sealedlib\")) {\n+                global.setSealedStdLib(true);\n+                continue;\n+            }\n+            if (arg.equals(\"-debug\")) {\n+                shellContextFactory.setGeneratingDebug(true);\n+                continue;\n+            }\n+            if (arg.equals(\"-?\") ||\n+                arg.equals(\"-help\")) {\n+                // print usage message\n+                global.getOut().println(\n+                    ToolErrorReporter.getMessage(\"msg.shell.usage\", Main.class.getName()));\n+                System.exit(1);\n+            }\n+            usageError = arg;\n+            break goodUsage;\n+        }\n+        // print error and usage message\n+        global.getOut().println(\n+            ToolErrorReporter.getMessage(\"msg.shell.invalid\", usageError));\n+        global.getOut().println(\n+            ToolErrorReporter.getMessage(\"msg.shell.usage\", Main.class.getName()));\n+        System.exit(1);\n+        return null;\n+    }\n+\n+    private static void initJavaPolicySecuritySupport()\n+    {\n+        Throwable exObj;\n+        try {\n+            Class<?> cl = Class.forName\n+                (\"org.mozilla.javascript.tools.shell.JavaPolicySecurity\");\n+            securityImpl = (SecurityProxy)cl.newInstance();\n+            SecurityController.initGlobal(securityImpl);\n+            return;\n+        } catch (ClassNotFoundException ex) {\n+            exObj = ex;\n+        } catch (IllegalAccessException ex) {\n+            exObj = ex;\n+        } catch (InstantiationException ex) {\n+            exObj = ex;\n+        } catch (LinkageError ex) {\n+            exObj = ex;\n+        }\n+        throw Kit.initCause(new IllegalStateException(\n+            \"Can not load security support: \"+exObj), exObj);\n+    }\n+\n+    /**\n+     * Evaluate JavaScript source.\n+     *\n+     * @param cx the current context\n+     * @param filename the name of the file to compile, or null\n+     *                 for interactive mode.\n+     */\n+    public static void processSource(Context cx, String filename)\n+    {\n+        if (filename == null || filename.equals(\"-\")) {\n+            PrintStream ps = global.getErr();\n+            if (filename == null) {\n+                // print implementation version\n+                ps.println(cx.getImplementationVersion());\n+            }\n+\n+            // Use the interpreter for interactive input\n+            cx.setOptimizationLevel(-1);\n+\n+            String charEnc = shellContextFactory.getCharacterEncoding();\n+            if(charEnc == null)\n+            {\n+                charEnc = System.getProperty(\"file.encoding\");\n+            }\n+            BufferedReader in;\n+            try\n+            {\n+                in = new BufferedReader(new InputStreamReader(global.getIn(),\n+                        charEnc));\n+            }\n+            catch(UnsupportedEncodingException e)\n+            {\n+                throw new UndeclaredThrowableException(e);\n+            }\n+            int lineno = 1;\n+            boolean hitEOF = false;\n+            while (!hitEOF) {\n+            \tString[] prompts = global.getPrompts(cx);\n+                if (filename == null)\n+                    ps.print(prompts[0]);\n+                ps.flush();\n+                String source = \"\";\n+\n+                // Collect lines of source to compile.\n+                while (true) {\n+                    String newline;\n+                    try {\n+                        newline = in.readLine();\n+                    }\n+                    catch (IOException ioe) {\n+                        ps.println(ioe.toString());\n+                        break;\n+                    }\n+                    if (newline == null) {\n+                        hitEOF = true;\n+                        break;\n+                    }\n+                    source = source + newline + \"\\n\";\n+                    lineno++;\n+                    if (cx.stringIsCompilableUnit(source))\n+                        break;\n+                    ps.print(prompts[1]);\n+                }\n+                Script script = loadScriptFromSource(cx, source, \"<stdin>\",\n+                                                     lineno, null);\n+                if (script != null) {\n+                    Object result = evaluateScript(script, cx, global);\n+                    // Avoid printing out undefined or function definitions.\n+                    if (result != Context.getUndefinedValue() &&\n+                        !(result instanceof Function &&\n+                          source.trim().startsWith(\"function\")))\n+                    {\n+                        try {\n+                            ps.println(Context.toString(result));\n+                        } catch (RhinoException rex) {\n+                            ToolErrorReporter.reportException(\n+                                cx.getErrorReporter(), rex);\n+                        }\n+                    }\n+                    NativeArray h = global.history;\n+                    h.put((int)h.getLength(), h, source);\n+                }\n+            }\n+            ps.println();\n+        } else {\n+            processFile(cx, global, filename);\n+        }\n+    }\n+\n+    public static void processFile(Context cx, Scriptable scope,\n+                                   String filename)\n+    {\n+        if (securityImpl == null) {\n+            processFileSecure(cx, scope, filename, null);\n+        } else {\n+            securityImpl.callProcessFileSecure(cx, scope, filename);\n+        }\n+    }\n+\n+    static void processFileSecure(Context cx, Scriptable scope,\n+                                  String path, Object securityDomain)\n+    {\n+        Script script;\n+        if (path.endsWith(\".class\")) {\n+            script = loadCompiledScript(cx, path, securityDomain);\n+        } else {\n+            String source = (String)readFileOrUrl(path, true);\n+            if (source == null) {\n+                exitCode = EXITCODE_FILE_NOT_FOUND;\n+                return;\n+            }\n+\n+            // Support the executable script #! syntax:  If\n+            // the first line begins with a '#', treat the whole\n+            // line as a comment.\n+            if (source.length() > 0 && source.charAt(0) == '#') {\n+                for (int i = 1; i != source.length(); ++i) {\n+                    int c = source.charAt(i);\n+                    if (c == '\\n' || c == '\\r') {\n+                        source = source.substring(i);\n+                        break;\n+                    }\n+                }\n+            }\n+            script = loadScriptFromSource(cx, source, path, 1, securityDomain);\n+        }\n+        if (script != null) {\n+            evaluateScript(script, cx, scope);\n+        }\n+    }\n+\n+    public static Script loadScriptFromSource(Context cx, String scriptSource,\n+                                              String path, int lineno,\n+                                              Object securityDomain)\n+    {\n+        try {\n+            return cx.compileString(scriptSource, path, lineno,\n+                                    securityDomain);\n+        } catch (EvaluatorException ee) {\n+            // Already printed message.\n+            exitCode = EXITCODE_RUNTIME_ERROR;\n+        } catch (RhinoException rex) {\n+            ToolErrorReporter.reportException(\n+                cx.getErrorReporter(), rex);\n+            exitCode = EXITCODE_RUNTIME_ERROR;\n+        } catch (VirtualMachineError ex) {\n+            // Treat StackOverflow and OutOfMemory as runtime errors\n+            ex.printStackTrace();\n+            String msg = ToolErrorReporter.getMessage(\n+                \"msg.uncaughtJSException\", ex.toString());\n+            exitCode = EXITCODE_RUNTIME_ERROR;\n+            Context.reportError(msg);\n+        }\n+        return null;\n+    }\n+\n+    private static Script loadCompiledScript(Context cx, String path,\n+                                             Object securityDomain)\n+    {\n+        byte[] data = (byte[])readFileOrUrl(path, false);\n+        if (data == null) {\n+            exitCode = EXITCODE_FILE_NOT_FOUND;\n+            return null;\n+        }\n+        // XXX: For now extract class name of compiled Script from path\n+        // instead of parsing class bytes\n+        int nameStart = path.lastIndexOf('/');\n+        if (nameStart < 0) {\n+            nameStart = 0;\n+        } else {\n+            ++nameStart;\n+        }\n+        int nameEnd = path.lastIndexOf('.');\n+        if (nameEnd < nameStart) {\n+            // '.' does not exist in path (nameEnd < 0)\n+            // or it comes before nameStart\n+            nameEnd = path.length();\n+        }\n+        String name = path.substring(nameStart, nameEnd);\n+        try {\n+            GeneratedClassLoader loader = SecurityController.createLoader(cx.getApplicationClassLoader(), securityDomain);\n+            Class<?> clazz = loader.defineClass(name, data);\n+            loader.linkClass(clazz);\n+            if (!Script.class.isAssignableFrom(clazz)) {\n+                throw Context.reportRuntimeError(\"msg.must.implement.Script\");\n+            }\n+            return (Script) clazz.newInstance();\n+         } catch (RhinoException rex) {\n+            ToolErrorReporter.reportException(\n+                cx.getErrorReporter(), rex);\n+            exitCode = EXITCODE_RUNTIME_ERROR;\n+        } catch (IllegalAccessException iaex) {\n+            exitCode = EXITCODE_RUNTIME_ERROR;\n+            Context.reportError(iaex.toString());\n+        } catch (InstantiationException inex) {\n+            exitCode = EXITCODE_RUNTIME_ERROR;\n+            Context.reportError(inex.toString());\n+        }\n+        return null;\n+    }\n+\n+    public static Object evaluateScript(Script script, Context cx,\n+                                        Scriptable scope)\n+    {\n+        try {\n+            return script.exec(cx, scope);\n+        } catch (RhinoException rex) {\n+            ToolErrorReporter.reportException(\n+                cx.getErrorReporter(), rex);\n+            exitCode = EXITCODE_RUNTIME_ERROR;\n+        } catch (VirtualMachineError ex) {\n+            // Treat StackOverflow and OutOfMemory as runtime errors\n+            ex.printStackTrace();\n+            String msg = ToolErrorReporter.getMessage(\n+                \"msg.uncaughtJSException\", ex.toString());\n+            exitCode = EXITCODE_RUNTIME_ERROR;\n+            Context.reportError(msg);\n+        }\n+        return Context.getUndefinedValue();\n+    }\n+\n+    public static InputStream getIn() {\n+        return getGlobal().getIn();\n+    }\n+\n+    public static void setIn(InputStream in) {\n+        getGlobal().setIn(in);\n+    }\n+\n+    public static PrintStream getOut() {\n+        return getGlobal().getOut();\n+    }\n+\n+    public static void setOut(PrintStream out) {\n+        getGlobal().setOut(out);\n+    }\n+\n+    public static PrintStream getErr() {\n+        return getGlobal().getErr();\n+    }\n+\n+    public static void setErr(PrintStream err) {\n+        getGlobal().setErr(err);\n+    }\n+\n+    /**\n+     * Read file or url specified by <tt>path</tt>.\n+     * @return file or url content as <tt>byte[]</tt> or as <tt>String</tt> if\n+     * <tt>convertToString</tt> is true.\n+     */\n+    private static Object readFileOrUrl(String path, boolean convertToString)\n+    {\n+        try {\n+            return SourceReader.readFileOrUrl(path, convertToString,\n+                    shellContextFactory.getCharacterEncoding());\n+        } catch (IOException ex) {\n+            Context.reportError(ToolErrorReporter.getMessage(\n+                    \"msg.couldnt.read.source\", path, ex.getMessage()));\n+            return null;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/ParsedContentType.java\n+package org.mozilla.javascript.tools.shell;\n+\n+import java.util.StringTokenizer;\n+\n+/**\n+ * Breaks a \"contentType; charset=encoding\" MIME type into content type and\n+ * encoding parts.\n+ * @version $Id: ParsedContentType.java,v 1.1 2008/10/18 09:17:10 szegedia%freemail.hu Exp $\n+ */\n+public final class ParsedContentType\n+{\n+    private final String contentType;\n+    private final String encoding;\n+    \n+    public ParsedContentType(String mimeType)\n+    {\n+        String contentType = null;\n+        String encoding = null;\n+        if(mimeType != null)\n+        {\n+            StringTokenizer tok = new StringTokenizer(mimeType, \";\");\n+            if(tok.hasMoreTokens())\n+            {\n+                contentType = tok.nextToken().trim();\n+                while(tok.hasMoreTokens())\n+                {\n+                    String param = tok.nextToken().trim();\n+                    if(param.startsWith(\"charset=\"))\n+                    {\n+                        encoding = param.substring(8).trim();\n+                        int l = encoding.length();\n+                        if(l > 0)\n+                        {\n+                            if(encoding.charAt(0) == '\"')\n+                            {\n+                                encoding = encoding.substring(1);\n+                            }\n+                            if(encoding.charAt(l - 1) == '\"')\n+                            {\n+                                encoding = encoding.substring(0, l - 1);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        this.contentType = contentType;\n+        this.encoding = encoding;\n+    }\n+    \n+    public String getContentType()\n+    {\n+        return contentType;\n+    }\n+    \n+    public String getEncoding()\n+    {\n+        return encoding;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/QuitAction.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tools.shell;\n+\n+import org.mozilla.javascript.Context;\n+\n+/**\n+ * Defines action to perform in response to quit command.\n+ */\n+public interface QuitAction\n+{\n+    public void quit(Context cx, int exitCode);\n+}\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/SecurityProxy.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tools.shell;\n+\n+import org.mozilla.javascript.*;\n+\n+public abstract class SecurityProxy extends SecurityController\n+{\n+    protected abstract void callProcessFileSecure(Context cx, Scriptable scope,\n+                                                  String filename);\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/ShellContextFactory.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Bob Jervis\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tools.shell;\n+\n+import org.mozilla.javascript.*;\n+\n+public class ShellContextFactory extends ContextFactory\n+{\n+    private boolean strictMode;\n+    private boolean warningAsError;\n+    private int languageVersion;\n+    private int optimizationLevel;\n+    private boolean generatingDebug;\n+    private ErrorReporter errorReporter;\n+    private String characterEncoding;\n+    \n+    @Override\n+    protected boolean hasFeature(Context cx, int featureIndex)\n+    {\n+        switch (featureIndex) {\n+          case Context.FEATURE_STRICT_VARS:\n+          case Context.FEATURE_STRICT_EVAL:\n+          case Context.FEATURE_STRICT_MODE:\n+            return strictMode;\n+\n+          case Context.FEATURE_WARNING_AS_ERROR:\n+            return warningAsError;\n+        }\n+        return super.hasFeature(cx, featureIndex);\n+    }\n+\n+    @Override\n+    protected void onContextCreated(Context cx)\n+    {\n+        cx.setLanguageVersion(languageVersion);\n+        cx.setOptimizationLevel(optimizationLevel);\n+        if (errorReporter != null) {\n+            cx.setErrorReporter(errorReporter);\n+        }\n+        cx.setGeneratingDebug(generatingDebug);\n+        super.onContextCreated(cx);\n+    }\n+\n+    public void setStrictMode(boolean flag)\n+    {\n+        checkNotSealed();\n+        this.strictMode = flag;\n+    }\n+\n+    public void setWarningAsError(boolean flag)\n+    {\n+        checkNotSealed();\n+        this.warningAsError = flag;\n+    }\n+\n+    public void setLanguageVersion(int version)\n+    {\n+        Context.checkLanguageVersion(version);\n+        checkNotSealed();\n+        this.languageVersion = version;\n+    }\n+\n+    public void setOptimizationLevel(int optimizationLevel)\n+    {\n+        Context.checkOptimizationLevel(optimizationLevel);\n+        checkNotSealed();\n+        this.optimizationLevel = optimizationLevel;\n+    }\n+\n+    public void setErrorReporter(ErrorReporter errorReporter)\n+    {\n+        if (errorReporter == null) throw new IllegalArgumentException();\n+        this.errorReporter = errorReporter;\n+    }\n+\n+    public void setGeneratingDebug(boolean generatingDebug)\n+    {\n+        this.generatingDebug = generatingDebug;\n+    }\n+    \n+    public String getCharacterEncoding()\n+    {\n+        return characterEncoding;\n+    }\n+    \n+    public void setCharacterEncoding(String characterEncoding)\n+    {\n+        this.characterEncoding = characterEncoding;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/toolsrc/org/mozilla/javascript/tools/shell/ShellLine.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1998.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Matthieu Riou\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.tools.shell;\n+\n+import java.io.InputStream;\n+import java.util.List;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import org.mozilla.javascript.Kit;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.ScriptableObject;\n+import org.mozilla.javascript.Function;\n+\n+/**\n+ * Provides a specialized input stream for consoles to handle line\n+ * editing, history and completion. Relies on the JLine library (see\n+ * <http://jline.sourceforge.net>).\n+ */\n+public class ShellLine {\n+\n+    public static InputStream getStream(Scriptable scope) {\n+        // We don't want a compile-time dependency on the JLine jar, so use\n+        // reflection to load and reference the JLine classes.\n+        ClassLoader classLoader = ShellLine.class.getClassLoader();\n+        if (classLoader == null) {\n+            // If the attempt to get a class specific class loader above failed\n+            // then fallback to the system class loader.\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        if (classLoader == null) {\n+            // If for some reason we still don't have a handle to a class\n+            // loader then give up (avoid a NullPointerException).\n+            return null;\n+        }\n+        Class<?> readerClass = Kit.classOrNull(classLoader, \"jline.ConsoleReader\");\n+        if (readerClass == null)\n+            return null;\n+        try {\n+            // ConsoleReader reader = new ConsoleReader();\n+            Constructor<?> c = readerClass.getConstructor();\n+            Object reader = c.newInstance();\n+        \n+            // reader.setBellEnabled(false);\n+            Method m = readerClass.getMethod(\"setBellEnabled\", Boolean.TYPE);\n+            m.invoke(reader, Boolean.FALSE);\n+\n+            // reader.addCompletor(new FlexibleCompletor(prefixes));\n+            Class<?> completorClass = Kit.classOrNull(classLoader,\n+                \"jline.Completor\");\n+            m = readerClass.getMethod(\"addCompletor\", completorClass);\n+            Object completor = Proxy.newProxyInstance(classLoader,\n+                    new Class[] { completorClass },\n+                    new FlexibleCompletor(completorClass, scope));\n+            m.invoke(reader, completor);\n+            \n+            // return new ConsoleReaderInputStream(reader);\n+            Class<?> inputStreamClass = Kit.classOrNull(classLoader,\n+                \"jline.ConsoleReaderInputStream\");\n+            c = inputStreamClass.getConstructor(readerClass);\n+            return (InputStream) c.newInstance(reader);\n+        } catch (NoSuchMethodException e) {\n+        } catch (InstantiationException e) {\n+        } catch (IllegalAccessException e) {\n+        } catch (InvocationTargetException e) {\n+        }\n+        return null;\n+    }\n+}\n+\n+/**\n+ * The completors provided with JLine are pretty uptight, they only\n+ * complete on a line that it can fully recognize (only composed of\n+ * completed strings). This one completes whatever came before.\n+ */\n+class FlexibleCompletor implements java.lang.reflect.InvocationHandler {\n+    private Method completeMethod;\n+    private Scriptable global;\n+\n+    FlexibleCompletor(Class<?> completorClass, Scriptable global)\n+        throws NoSuchMethodException\n+    {\n+        this.global = global;\n+        this.completeMethod = completorClass.getMethod(\"complete\", String.class,\n+                Integer.TYPE, List.class);\n+    }\n+    \n+    @SuppressWarnings({\"unchecked\"})\n+    public Object invoke(Object proxy, Method method, Object[] args) {\n+        if (method.equals(this.completeMethod)) {\n+            int result = complete((String)args[0], ((Integer) args[1]).intValue(),\n+                    (List<String>) args[2]);\n+            return Integer.valueOf(result);\n+        }\n+        throw new NoSuchMethodError(method.toString());\n+    }\n+\n+    public int complete(String buffer, int cursor, List<String> candidates) {\n+        // Starting from \"cursor\" at the end of the buffer, look backward\n+        // and collect a list of identifiers separated by (possibly zero)\n+        // dots. Then look up each identifier in turn until getting to the\n+        // last, presumably incomplete fragment. Then enumerate all the\n+        // properties of the last object and find any that have the\n+        // fragment as a prefix and return those for autocompletion.\n+        int m = cursor - 1;\n+        while (m >= 0) {\n+            char c = buffer.charAt(m);\n+            if (!Character.isJavaIdentifierPart(c) && c != '.')\n+                break;\n+            m--;\n+        }\n+        String namesAndDots = buffer.substring(m+1, cursor);\n+        String[] names = namesAndDots.split(\"\\\\.\", -1);\n+        Scriptable obj = this.global;\n+        for (int i=0; i < names.length - 1; i++) {\n+            Object val = obj.get(names[i], global);\n+            if (val instanceof Scriptable)\n+                obj = (Scriptable) val;\n+            else {\n+                return buffer.length(); // no matches\n+            }\n+        }\n+        Object[] ids = (obj instanceof ScriptableObject) \n+                       ? ((ScriptableObject)obj).getAllIds()\n+                       : obj.getIds();\n+        String lastPart = names[names.length-1];\n+        for (int i=0; i < ids.length; i++) {\n+            if (!(ids[i] instanceof String))\n+                continue;\n+            String id = (String)ids[i];\n+            if (id.startsWith(lastPart)) {\n+                if (obj.get(id, obj) instanceof Function)\n+                    id += \"(\";\n+                candidates.add(id);\n+            }\n+        }\n+        return buffer.length() - lastPart.length();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/Namespace.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xmlimpl;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * Class Namespace\n+ *\n+ */\n+class Namespace extends IdScriptableObject\n+{\n+    static final long serialVersionUID = -5765755238131301744L;\n+\n+    private static final Object NAMESPACE_TAG = \"Namespace\";\n+\n+    private Namespace prototype;\n+    private XmlNode.Namespace ns;\n+\n+    private Namespace() {\n+    }\n+\n+    static Namespace create(Scriptable scope, Namespace prototype, XmlNode.Namespace namespace) {\n+        Namespace rv = new Namespace();\n+        rv.setParentScope(scope);\n+        rv.prototype = prototype;\n+        rv.setPrototype(prototype);\n+        rv.ns = namespace;\n+        return rv;\n+    }\n+\n+    final XmlNode.Namespace getDelegate() {\n+        return ns;\n+    }\n+\n+    public void exportAsJSClass(boolean sealed) {\n+        exportAsJSClass(MAX_PROTOTYPE_ID, this.getParentScope(), sealed);\n+    }\n+\n+    public String uri() {\n+        return ns.getUri();\n+    }\n+\n+    public String prefix() {\n+        return ns.getPrefix();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return uri();\n+    }\n+\n+    public String toLocaleString() {\n+        return toString();\n+    }\n+\n+    private boolean equals(Namespace n) {\n+        return uri().equals(n.uri());\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Namespace)) return false;\n+        return equals((Namespace)obj);\n+    }\n+    \n+    @Override\n+    public int hashCode() {\n+        return uri().hashCode();\n+    }\n+\n+    @Override\n+    protected Object equivalentValues(Object value) {\n+        if (!(value instanceof Namespace)) return Scriptable.NOT_FOUND;\n+        boolean result = equals((Namespace)value);\n+        return result ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return \"Namespace\";\n+    }\n+\n+    @Override\n+    public Object getDefaultValue(Class<?> hint) {\n+        return uri();\n+    }\n+\n+// #string_id_map#\n+    private static final int\n+        Id_prefix               = 1,\n+        Id_uri                  = 2,\n+        MAX_INSTANCE_ID         = 2;\n+\n+    @Override\n+    protected int getMaxInstanceId()\n+    {\n+        return super.getMaxInstanceId() + MAX_INSTANCE_ID;\n+    }\n+\n+    @Override\n+    protected int findInstanceIdInfo(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-08-20 08:23:22 EDT\n+        L0: { id = 0; String X = null;\n+            int s_length = s.length();\n+            if (s_length==3) { X=\"uri\";id=Id_uri; }\n+            else if (s_length==6) { X=\"prefix\";id=Id_prefix; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+\n+        if (id == 0) return super.findInstanceIdInfo(s);\n+\n+        int attr;\n+        switch (id) {\n+          case Id_prefix:\n+          case Id_uri:\n+            attr = PERMANENT | READONLY;\n+            break;\n+          default: throw new IllegalStateException();\n+        }\n+        return instanceIdInfo(attr, super.getMaxInstanceId() + id);\n+    }\n+// #/string_id_map#\n+\n+    @Override\n+    protected String getInstanceIdName(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_prefix: return \"prefix\";\n+          case Id_uri: return \"uri\";\n+        }\n+        return super.getInstanceIdName(id);\n+    }\n+\n+    @Override\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_prefix:\n+            if (ns.getPrefix() == null) return Undefined.instance;\n+            return ns.getPrefix();\n+          case Id_uri:\n+            return ns.getUri();\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+\n+// #string_id_map#\n+    private static final int\n+        Id_constructor          = 1,\n+        Id_toString             = 2,\n+        Id_toSource             = 3,\n+        MAX_PROTOTYPE_ID        = 3;\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-08-20 08:23:22 EDT\n+        L0: { id = 0; String X = null; int c;\n+            int s_length = s.length();\n+            if (s_length==8) {\n+                c=s.charAt(3);\n+                if (c=='o') { X=\"toSource\";id=Id_toSource; }\n+                else if (c=='t') { X=\"toString\";id=Id_toString; }\n+            }\n+            else if (s_length==11) { X=\"constructor\";id=Id_constructor; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+// #/string_id_map#\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor: arity=2; s=\"constructor\"; break;\n+          case Id_toString:    arity=0; s=\"toString\";    break;\n+          case Id_toSource:    arity=0; s=\"toSource\";    break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(NAMESPACE_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f,\n+                             Context cx,\n+                             Scriptable scope,\n+                             Scriptable thisObj,\n+                             Object[] args)\n+    {\n+        if (!f.hasTag(NAMESPACE_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_constructor:\n+            return jsConstructor(cx, (thisObj == null), args);\n+          case Id_toString:\n+            return realThis(thisObj, f).toString();\n+          case Id_toSource:\n+            return realThis(thisObj, f).js_toSource();\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private Namespace realThis(Scriptable thisObj, IdFunctionObject f) {\n+        if(!(thisObj instanceof Namespace))\n+            throw incompatibleCallError(f);\n+        return (Namespace)thisObj;\n+    }\n+\n+    Namespace newNamespace(String uri) {\n+        Namespace prototype = (this.prototype == null) ? this : this.prototype;\n+        return create( this.getParentScope(), prototype, XmlNode.Namespace.create(uri) );\n+    }\n+\n+    Namespace newNamespace(String prefix, String uri) {\n+        if (prefix == null) return newNamespace(uri);\n+        Namespace prototype = (this.prototype == null) ? this : this.prototype;\n+        return create( this.getParentScope(), prototype, XmlNode.Namespace.create(prefix, uri) );\n+    }\n+\n+    Namespace constructNamespace(Object uriValue) {\n+        String prefix;\n+        String uri;\n+\n+        if (uriValue instanceof Namespace) {\n+            Namespace ns = (Namespace)uriValue;\n+            prefix = ns.prefix();\n+            uri = ns.uri();\n+        } else if (uriValue instanceof QName) {\n+            QName qname = (QName)uriValue;\n+            uri = qname.uri();\n+            if (uri != null) {\n+                //    TODO    Is there a way to push this back into QName so that we can make prefix() private?\n+                prefix = qname.prefix();\n+            } else {\n+                uri = qname.toString();\n+                prefix = null;\n+            }\n+        } else {\n+            uri = ScriptRuntime.toString(uriValue);\n+            prefix = (uri.length() == 0) ? \"\" : null;\n+        }\n+\n+        return newNamespace(prefix, uri);\n+    }\n+\n+    Namespace castToNamespace(Object namespaceObj) {\n+        if (namespaceObj instanceof Namespace) {\n+            return (Namespace)namespaceObj;\n+        }\n+        return constructNamespace(namespaceObj);\n+    }\n+\n+    private Namespace constructNamespace(Object prefixValue, Object uriValue) {\n+        String prefix;\n+        String uri;\n+\n+        if (uriValue instanceof QName) {\n+            QName qname = (QName)uriValue;\n+            uri = qname.uri();\n+            if (uri == null) {\n+                uri = qname.toString();\n+            }\n+        } else {\n+            uri = ScriptRuntime.toString(uriValue);\n+        }\n+\n+        if (uri.length() == 0) {\n+            if (prefixValue == Undefined.instance) {\n+                prefix = \"\";\n+            } else {\n+                prefix = ScriptRuntime.toString(prefixValue);\n+                if (prefix.length() != 0) {\n+                    throw ScriptRuntime.typeError(\n+                        \"Illegal prefix '\"+prefix+\"' for 'no namespace'.\");\n+                }\n+            }\n+        } else if (prefixValue == Undefined.instance) {\n+            prefix = \"\";\n+        } else if (!XMLName.accept(prefixValue)) {\n+            prefix = \"\";\n+        } else {\n+            prefix = ScriptRuntime.toString(prefixValue);\n+        }\n+\n+        return newNamespace(prefix, uri);\n+    }\n+\n+    private Namespace constructNamespace() {\n+        return newNamespace(\"\", \"\");\n+    }\n+\n+    private Object jsConstructor(Context cx, boolean inNewExpr, Object[] args)\n+    {\n+        if (!inNewExpr && args.length == 1) {\n+            return castToNamespace(args[0]);\n+        }\n+\n+        if (args.length == 0) {\n+            return constructNamespace();\n+        } else if (args.length == 1) {\n+            return constructNamespace(args[0]);\n+        } else {\n+            return constructNamespace(args[0], args[1]);\n+        }\n+    }\n+\n+    private String js_toSource()\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        toSourceImpl(ns.getPrefix(), ns.getUri(), sb);\n+        sb.append(')');\n+        return sb.toString();\n+    }\n+\n+    static void toSourceImpl(String prefix, String uri, StringBuffer sb)\n+    {\n+        sb.append(\"new Namespace(\");\n+        if (uri.length() == 0) {\n+            if (!\"\".equals(prefix)) throw new IllegalArgumentException(prefix);\n+        } else {\n+            sb.append('\\'');\n+            if (prefix != null) {\n+                sb.append(ScriptRuntime.escapeString(prefix, '\\''));\n+                sb.append(\"', '\");\n+            }\n+            sb.append(ScriptRuntime.escapeString(uri, '\\''));\n+            sb.append('\\'');\n+        }\n+        sb.append(')');\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/QName.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xmlimpl;\n+\n+import org.mozilla.javascript.*;\n+\n+/**\n+ * Class QName\n+ *\n+ */\n+final class QName extends IdScriptableObject\n+{\n+    static final long serialVersionUID = 416745167693026750L;\n+\n+    private static final Object QNAME_TAG = \"QName\";\n+\n+    private XMLLibImpl lib;\n+\n+    private QName prototype;\n+\n+    private XmlNode.QName delegate;\n+\n+    private QName() {\n+    }\n+\n+    static QName create(XMLLibImpl lib, Scriptable scope, QName prototype, XmlNode.QName delegate) {\n+        QName rv = new QName();\n+        rv.lib = lib;\n+        rv.setParentScope(scope);\n+        rv.prototype = prototype;\n+        rv.setPrototype(prototype);\n+        rv.delegate = delegate;\n+        return rv;\n+    }\n+\n+//    /** @deprecated */\n+//    static QName create(XMLLibImpl lib, XmlNode.QName nodeQname) {\n+//        return create(lib, lib.globalScope(), lib.qnamePrototype(), nodeQname);\n+//    }\n+\n+    void exportAsJSClass(boolean sealed) {\n+        exportAsJSClass(MAX_PROTOTYPE_ID, getParentScope(), sealed);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        //    ECMA357 13.3.4.2\n+        if (delegate.getNamespace() == null) {\n+            return \"*::\" + localName();\n+        } else if (delegate.getNamespace().isGlobal()) {\n+            //    leave as empty\n+            return localName();\n+        } else {\n+            return uri() + \"::\" + localName();\n+        }\n+    }\n+\n+    public String localName() {\n+        if (delegate.getLocalName() == null) return \"*\";\n+        return delegate.getLocalName();\n+    }\n+\n+    /*\n+     * TODO This property is supposed to be invisible and I think we can\n+     *  make it private at some point, though Namespace might need it\n+     */\n+    String prefix() {\n+        if (delegate.getNamespace() == null) return null;\n+        return delegate.getNamespace().getPrefix();\n+    }\n+\n+    String uri() {\n+        if (delegate.getNamespace() == null) return null;\n+        return delegate.getNamespace().getUri();\n+    }\n+\n+    /** @deprecated */\n+    final XmlNode.QName toNodeQname() {\n+        return delegate;\n+    }\n+\n+    final XmlNode.QName getDelegate() {\n+        return delegate;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if(!(obj instanceof QName)) return false;\n+        return equals((QName)obj);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return delegate.hashCode();\n+    }\n+\n+    @Override\n+    protected Object equivalentValues(Object value)\n+    {\n+        if(!(value instanceof QName)) return Scriptable.NOT_FOUND;\n+        boolean result = equals((QName)value);\n+        return result ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    private boolean equals(QName q) {\n+        return this.delegate.equals(q.delegate);\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return \"QName\";\n+    }\n+\n+    @Override\n+    public Object getDefaultValue(Class<?> hint) {\n+        return toString();\n+    }\n+\n+// #string_id_map#\n+    private static final int\n+        Id_localName            = 1,\n+        Id_uri                  = 2,\n+        MAX_INSTANCE_ID         = 2;\n+\n+    @Override\n+    protected int getMaxInstanceId()\n+    {\n+        return super.getMaxInstanceId() + MAX_INSTANCE_ID;\n+    }\n+\n+    @Override\n+    protected int findInstanceIdInfo(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-08-20 08:21:41 EDT\n+        L0: { id = 0; String X = null;\n+            int s_length = s.length();\n+            if (s_length==3) { X=\"uri\";id=Id_uri; }\n+            else if (s_length==9) { X=\"localName\";id=Id_localName; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+\n+        if (id == 0) return super.findInstanceIdInfo(s);\n+\n+        int attr;\n+        switch (id) {\n+          case Id_localName:\n+          case Id_uri:\n+            attr = PERMANENT | READONLY;\n+            break;\n+          default: throw new IllegalStateException();\n+        }\n+        return instanceIdInfo(attr, super.getMaxInstanceId() + id);\n+    }\n+// #/string_id_map#\n+\n+    @Override\n+    protected String getInstanceIdName(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_localName: return \"localName\";\n+          case Id_uri: return \"uri\";\n+        }\n+        return super.getInstanceIdName(id);\n+    }\n+\n+    @Override\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_localName: return localName();\n+          case Id_uri: return uri();\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+// #string_id_map#\n+    private static final int\n+        Id_constructor          = 1,\n+        Id_toString             = 2,\n+        Id_toSource             = 3,\n+        MAX_PROTOTYPE_ID        = 3;\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-08-20 08:21:41 EDT\n+        L0: { id = 0; String X = null; int c;\n+            int s_length = s.length();\n+            if (s_length==8) {\n+                c=s.charAt(3);\n+                if (c=='o') { X=\"toSource\";id=Id_toSource; }\n+                else if (c=='t') { X=\"toString\";id=Id_toString; }\n+            }\n+            else if (s_length==11) { X=\"constructor\";id=Id_constructor; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+// #/string_id_map#\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_constructor: arity=2; s=\"constructor\"; break;\n+          case Id_toString:    arity=0; s=\"toString\";    break;\n+          case Id_toSource:    arity=0; s=\"toSource\";    break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(QNAME_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f,\n+                             Context cx,\n+                             Scriptable scope,\n+                             Scriptable thisObj,\n+                             Object[] args)\n+    {\n+        if (!f.hasTag(QNAME_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_constructor:\n+            return jsConstructor(cx, (thisObj == null), args);\n+          case Id_toString:\n+            return realThis(thisObj, f).toString();\n+          case Id_toSource:\n+            return realThis(thisObj, f).js_toSource();\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private QName realThis(Scriptable thisObj, IdFunctionObject f)\n+    {\n+        if(!(thisObj instanceof QName))\n+            throw incompatibleCallError(f);\n+        return (QName)thisObj;\n+    }\n+\n+    QName newQName(XMLLibImpl lib, String q_uri, String q_localName, String q_prefix) {\n+        QName prototype = this.prototype;\n+        if (prototype == null) {\n+            prototype = this;\n+        }\n+        XmlNode.Namespace ns = null;\n+        if (q_prefix != null) {\n+            ns = XmlNode.Namespace.create(q_uri, q_prefix);\n+        } else if (q_uri != null) {\n+            ns = XmlNode.Namespace.create(q_uri);\n+        } else {\n+            ns = null;\n+        }\n+        if (q_localName != null && q_localName.equals(\"*\")) q_localName = null;\n+        return create(lib, this.getParentScope(), prototype, XmlNode.QName.create(ns, q_localName));\n+    }\n+\n+    //    See ECMA357 13.3.2\n+    QName constructQName(XMLLibImpl lib, Context cx, Object namespace, Object name) {\n+        String nameString = null;\n+        if (name instanceof QName) {\n+            if (namespace == Undefined.instance) {\n+                return (QName)name;\n+            } else {\n+                nameString = ((QName)name).localName();\n+            }\n+        }\n+        if (name == Undefined.instance) {\n+            nameString = \"\";\n+        } else {\n+            nameString = ScriptRuntime.toString(name);\n+        }\n+\n+        if (namespace == Undefined.instance) {\n+            if (\"*\".equals(nameString)) {\n+                namespace = null;\n+            } else {\n+                namespace = lib.getDefaultNamespace(cx);\n+            }\n+        }\n+        Namespace namespaceNamespace = null;\n+        if (namespace == null) {\n+            //    leave as null\n+        } else if (namespace instanceof Namespace) {\n+            namespaceNamespace = (Namespace)namespace;\n+        } else {\n+            namespaceNamespace = lib.newNamespace(ScriptRuntime.toString(namespace));\n+        }\n+        String q_localName = nameString;\n+        String q_uri;\n+        String q_prefix;\n+        if (namespace == null) {\n+            q_uri = null;\n+            q_prefix = null;    //    corresponds to undefined; see QName class\n+        } else {\n+            q_uri = namespaceNamespace.uri();\n+            q_prefix = namespaceNamespace.prefix();\n+        }\n+        return newQName(lib, q_uri, q_localName, q_prefix);\n+    }\n+\n+    QName constructQName(XMLLibImpl lib, Context cx, Object nameValue) {\n+        return constructQName(lib, cx, Undefined.instance, nameValue);\n+    }\n+\n+    QName castToQName(XMLLibImpl lib, Context cx, Object qnameValue) {\n+        if (qnameValue instanceof QName) {\n+            return (QName)qnameValue;\n+        }\n+        return constructQName(lib, cx, qnameValue);\n+    }\n+\n+    private Object jsConstructor(Context cx, boolean inNewExpr, Object[] args) {\n+        //    See ECMA357 13.3.2\n+        if (!inNewExpr && args.length == 1) {\n+            return castToQName(lib, cx, args[0]);\n+        }\n+        if (args.length == 0) {\n+            return constructQName(lib, cx, Undefined.instance);\n+        } else if (args.length == 1) {\n+            return constructQName(lib, cx, args[0]);\n+        } else {\n+            return constructQName(lib, cx, args[0], args[1]);\n+        }\n+    }\n+\n+    private String js_toSource() {\n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        toSourceImpl(uri(), localName(), prefix(), sb);\n+        sb.append(')');\n+        return sb.toString();\n+    }\n+\n+    private static void toSourceImpl(String uri, String localName, String prefix, StringBuffer sb) {\n+        sb.append(\"new QName(\");\n+        if (uri == null && prefix == null) {\n+            if (!\"*\".equals(localName)) {\n+                sb.append(\"null, \");\n+            }\n+        } else {\n+            Namespace.toSourceImpl(prefix, uri, sb);\n+            sb.append(\", \");\n+        }\n+        sb.append('\\'');\n+        sb.append(ScriptRuntime.escapeString(localName, '\\''));\n+        sb.append(\"')\");\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XML.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xmlimpl;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.xml.XMLObject;\n+\n+class XML extends XMLObjectImpl {\n+    static final long serialVersionUID = -630969919086449092L;\n+\n+    private XmlNode node;\n+\n+    XML(XMLLibImpl lib, Scriptable scope, XMLObject prototype, XmlNode node) {\n+      super(lib, scope, prototype);\n+      initialize(node);\n+    }\n+\n+    void initialize(XmlNode node) {\n+        this.node = node;\n+        this.node.setXml(this);\n+    }\n+\n+    @Override\n+    final XML getXML() {\n+        return this;\n+    }\n+\n+    void replaceWith(XML value) {\n+        //    We use the underlying document structure if the node is not\n+        //    \"standalone,\" but we need to just replace the XmlNode instance\n+        //    otherwise\n+        if (this.node.parent() != null || false) {\n+            this.node.replaceWith(value.node);\n+        } else {\n+            this.initialize(value.node);\n+        }\n+    }\n+\n+    /* TODO: needs encapsulation. */\n+    XML makeXmlFromString(XMLName name, String value) {\n+        try {\n+            return newTextElementXML(this.node, name.toQname(), value);\n+        } catch(Exception e) {\n+            throw ScriptRuntime.typeError(e.getMessage());\n+        }\n+    }\n+\n+    /* TODO: Rename this, at the very least.  But it's not clear it's even necessary */\n+    XmlNode getAnnotation() {\n+        return node;\n+    }\n+\n+    //\n+    //  Methods from ScriptableObject\n+    //\n+\n+    //    TODO Either cross-reference this next comment with the specification or delete it and change the behavior\n+    //    The comment: XML[0] should return this, all other indexes are Undefined\n+    @Override\n+    public Object get(int index, Scriptable start) {\n+        if (index == 0) {\n+            return this;\n+        } else {\n+            return Scriptable.NOT_FOUND;\n+        }\n+    }\n+\n+    @Override\n+    public boolean has(int index, Scriptable start) {\n+        return (index == 0);\n+    }\n+\n+    @Override\n+    public void put(int index, Scriptable start, Object value) {\n+        //    TODO    Clarify the following comment and add a reference to the spec\n+        //    The comment: Spec says assignment to indexed XML object should return type error\n+        throw ScriptRuntime.typeError(\"Assignment to indexed XML is not allowed\");\n+    }\n+\n+    @Override\n+    public Object[] getIds() {\n+        if (isPrototype()) {\n+            return new Object[0];\n+        } else {\n+            return new Object[] { Integer.valueOf(0) };\n+        }\n+    }\n+\n+    //    TODO    This is how I found it but I am not sure it makes sense\n+    @Override\n+    public void delete(int index) {\n+        if (index == 0) {\n+            this.remove();\n+        }\n+    }\n+\n+    //\n+    //    Methods from XMLObjectImpl\n+    //\n+\n+    @Override\n+    boolean hasXMLProperty(XMLName xmlName) {\n+        if (isPrototype()) {\n+            return getMethod(xmlName.localName()) != NOT_FOUND;\n+        } else {\n+            return (getPropertyList(xmlName).length() > 0) || (getMethod(xmlName.localName()) != NOT_FOUND);\n+        }\n+    }\n+\n+    @Override\n+    Object getXMLProperty(XMLName xmlName) {\n+        if (isPrototype()) {\n+            return getMethod(xmlName.localName());\n+        } else {\n+            return getPropertyList(xmlName);\n+        }\n+    }\n+\n+    //\n+    //\n+    //    Methods that merit further review\n+    //\n+    //\n+\n+    XmlNode.QName getNodeQname() {\n+        return this.node.getQname();\n+    }\n+\n+    XML[] getChildren() {\n+        if (!isElement()) return null;\n+        XmlNode[] children = this.node.getMatchingChildren(XmlNode.Filter.TRUE);\n+        XML[] rv = new XML[children.length];\n+        for (int i=0; i<rv.length; i++) {\n+            rv[i] = toXML(children[i]);\n+        }\n+        return rv;\n+    }\n+\n+    XML[] getAttributes() {\n+        XmlNode[] attributes = this.node.getAttributes();\n+        XML[] rv = new XML[attributes.length];\n+        for (int i=0; i<rv.length; i++) {\n+            rv[i] = toXML(attributes[i]);\n+        }\n+        return rv;\n+    }\n+\n+    //    Used only by XML, XMLList\n+    XMLList getPropertyList(XMLName name) {\n+        return name.getMyValueOn(this);\n+    }\n+\n+    @Override\n+    void deleteXMLProperty(XMLName name) {\n+        XMLList list = getPropertyList(name);\n+        for (int i=0; i<list.length(); i++) {\n+            list.item(i).node.deleteMe();\n+        }\n+    }\n+\n+    @Override\n+    void putXMLProperty(XMLName xmlName, Object value) {\n+        if (isPrototype()) {\n+            //    TODO    Is this really a no-op?  Check the spec to be sure\n+        } else {\n+            xmlName.setMyValueOn(this, value);\n+        }\n+    }\n+\n+    @Override\n+    boolean hasOwnProperty(XMLName xmlName) {\n+        boolean hasProperty = false;\n+\n+        if (isPrototype()) {\n+            String property = xmlName.localName();\n+            hasProperty = (0 != findPrototypeId(property));\n+        } else {\n+            hasProperty = (getPropertyList(xmlName).length() > 0);\n+        }\n+\n+        return hasProperty;\n+    }\n+\n+    @Override\n+    protected Object jsConstructor(Context cx, boolean inNewExpr, Object[] args) {\n+        if (args.length == 0 || args[0] == null || args[0] == Undefined.instance) {\n+            args = new Object[] { \"\" };\n+        }\n+        //    ECMA 13.4.2 does not appear to specify what to do if multiple arguments are sent.\n+        XML toXml = ecmaToXml(args[0]);\n+        if (inNewExpr) {\n+            return toXml.copy();\n+        } else {\n+            return toXml;\n+        }\n+    }\n+\n+    //    See ECMA 357, 11_2_2_1, Semantics, 3_f.\n+    @Override\n+    public Scriptable getExtraMethodSource(Context cx) {\n+        if (hasSimpleContent()) {\n+            String src = toString();\n+            return ScriptRuntime.toObjectOrNull(cx, src);\n+        }\n+        return null;\n+    }\n+\n+    //\n+    //    TODO    Miscellaneous methods not yet grouped\n+    //\n+\n+    void removeChild(int index) {\n+        this.node.removeChild(index);\n+    }\n+\n+    @Override\n+    void normalize() {\n+        this.node.normalize();\n+    }\n+\n+    private XML toXML(XmlNode node) {\n+        if (node.getXml() == null) {\n+            node.setXml(newXML(node));\n+        }\n+        return node.getXml();\n+    }\n+\n+    void setAttribute(XMLName xmlName, Object value) {\n+        if (!isElement()) throw new IllegalStateException(\"Can only set attributes on elements.\");\n+        //    TODO    Is this legal, but just not \"supported\"?  If so, support it.\n+        if (xmlName.uri() == null && xmlName.localName().equals(\"*\")) {\n+            throw ScriptRuntime.typeError(\"@* assignment not supported.\");\n+        }\n+        this.node.setAttribute(xmlName.toQname(), ScriptRuntime.toString(value));\n+    }\n+\n+    void remove() {\n+        this.node.deleteMe();\n+    }\n+\n+    @Override\n+    void addMatches(XMLList rv, XMLName name) {\n+        name.addMatches(rv, this);\n+    }\n+\n+    @Override\n+    XMLList elements(XMLName name) {\n+        XMLList rv = newXMLList();\n+        rv.setTargets(this, name.toQname());\n+        //    TODO    Should have an XMLNode.Filter implementation based on XMLName\n+        XmlNode[] elements = this.node.getMatchingChildren(XmlNode.Filter.ELEMENT);\n+        for (int i=0; i<elements.length; i++) {\n+            if (name.matches( toXML(elements[i]) )) {\n+                rv.addToList( toXML(elements[i]) );\n+            }\n+        }\n+        return rv;\n+    }\n+\n+    @Override\n+    XMLList child(XMLName xmlName) {\n+        //    TODO    Right now I think this method would allow child( \"@xxx\" ) to return the xxx attribute, which is wrong\n+\n+        XMLList rv = newXMLList();\n+\n+        //    TODO    Should this also match processing instructions?  If so, we have to change the filter and also the XMLName\n+        //            class to add an acceptsProcessingInstruction() method\n+\n+        XmlNode[] elements = this.node.getMatchingChildren(XmlNode.Filter.ELEMENT);\n+        for (int i=0; i<elements.length; i++) {\n+            if (xmlName.matchesElement(elements[i].getQname())) {\n+                rv.addToList( toXML(elements[i]) );\n+            }\n+        }\n+        rv.setTargets(this, xmlName.toQname());\n+        return rv;\n+    }\n+\n+    XML replace(XMLName xmlName, Object xml) {\n+        putXMLProperty(xmlName, xml);\n+        return this;\n+    }\n+\n+    @Override\n+    XMLList children() {\n+        XMLList rv = newXMLList();\n+        XMLName all = XMLName.formStar();\n+        rv.setTargets(this, all.toQname());\n+        XmlNode[] children = this.node.getMatchingChildren(XmlNode.Filter.TRUE);\n+        for (int i=0; i<children.length; i++) {\n+            rv.addToList( toXML(children[i]) );\n+        }\n+        return rv;\n+    }\n+\n+    @Override\n+    XMLList child(int index) {\n+        //    ECMA357 13.4.4.6 (numeric case)\n+        XMLList result = newXMLList();\n+        result.setTargets(this, null);\n+        if (index >= 0 && index < this.node.getChildCount()) {\n+            result.addToList(getXmlChild(index));\n+        }\n+        return result;\n+    }\n+\n+    XML getXmlChild(int index) {\n+        XmlNode child = this.node.getChild(index);\n+        if (child.getXml() == null) {\n+            child.setXml(newXML(child));\n+        }\n+        return child.getXml();\n+    }\n+\n+    int childIndex() {\n+        return this.node.getChildIndex();\n+    }\n+\n+    @Override\n+    boolean contains(Object xml) {\n+        if (xml instanceof XML) {\n+            return equivalentXml(xml);\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    //    Method overriding XMLObjectImpl\n+    @Override\n+    boolean equivalentXml(Object target) {\n+        boolean result = false;\n+\n+        if (target instanceof XML) {\n+            //    TODO    This is a horrifyingly inefficient way to do this so we should make it better.  It may also not work.\n+            return this.node.toXmlString(getProcessor()).equals( ((XML)target).node.toXmlString(getProcessor()) );\n+        } else if (target instanceof XMLList) {\n+            //    TODO    Is this right?  Check the spec ...\n+            XMLList otherList = (XMLList) target;\n+\n+            if (otherList.length() == 1) {\n+                result = equivalentXml(otherList.getXML());\n+            }\n+        } else if (hasSimpleContent()) {\n+            String otherStr = ScriptRuntime.toString(target);\n+\n+            result = toString().equals(otherStr);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    XMLObjectImpl copy() {\n+        return newXML( this.node.copy() );\n+    }\n+\n+    @Override\n+    boolean hasSimpleContent() {\n+        if (isComment() || isProcessingInstruction()) return false;\n+        if (isText() || this.node.isAttributeType()) return true;\n+        return !this.node.hasChildElement();\n+    }\n+\n+    @Override\n+    boolean hasComplexContent() {\n+        return !hasSimpleContent();\n+    }\n+\n+    //    TODO Cross-reference comment below with spec\n+    //    Comment is: Length of an XML object is always 1, it's a list of XML objects of size 1.\n+    @Override\n+    int length() {\n+        return 1;\n+    }\n+\n+    //    TODO    it is not clear what this method was for ...\n+    boolean is(XML other) {\n+        return this.node.isSameNode(other.node);\n+    }\n+\n+    Object nodeKind() {\n+        return ecmaClass();\n+    }\n+\n+    @Override\n+    Object parent() {\n+        XmlNode parent = this.node.parent();\n+        if (parent == null) return null;\n+        return newXML(this.node.parent());\n+    }\n+\n+    @Override\n+    boolean propertyIsEnumerable(Object name)\n+    {\n+        boolean result;\n+        if (name instanceof Integer) {\n+            result = (((Integer)name).intValue() == 0);\n+        } else if (name instanceof Number) {\n+            double x = ((Number)name).doubleValue();\n+            // Check that number is positive 0\n+            result = (x == 0.0 && 1.0 / x > 0);\n+        } else {\n+            result = ScriptRuntime.toString(name).equals(\"0\");\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    Object valueOf() {\n+        return this;\n+    }\n+\n+    //\n+    //    Selection of children\n+    //\n+\n+    @Override\n+    XMLList comments() {\n+        XMLList rv = newXMLList();\n+        this.node.addMatchingChildren(rv, XmlNode.Filter.COMMENT);\n+        return rv;\n+    }\n+\n+    @Override\n+    XMLList text() {\n+        XMLList rv = newXMLList();\n+        this.node.addMatchingChildren(rv, XmlNode.Filter.TEXT);\n+        return rv;\n+    }\n+\n+    @Override\n+    XMLList processingInstructions(XMLName xmlName) {\n+        XMLList rv = newXMLList();\n+        this.node.addMatchingChildren(rv, XmlNode.Filter.PROCESSING_INSTRUCTION(xmlName));\n+        return rv;\n+    }\n+\n+    //\n+    //    Methods relating to modification of child nodes\n+    //\n+\n+    //    We create all the nodes we are inserting before doing the insert to\n+    //    avoid nasty cycles caused by mutability of these objects.  For example,\n+    //    what if the toString() method of value modifies the XML object we were\n+    //    going to insert into?  insertAfter might get confused about where to\n+    //    insert.  This actually came up with SpiderMonkey, leading to a (very)\n+    //    long discussion.  See bug #354145.\n+    private XmlNode[] getNodesForInsert(Object value) {\n+        if (value instanceof XML) {\n+            return new XmlNode[] { ((XML)value).node };\n+        } else if (value instanceof XMLList) {\n+            XMLList list = (XMLList)value;\n+            XmlNode[] rv = new XmlNode[list.length()];\n+            for (int i=0; i<list.length(); i++) {\n+                rv[i] = list.item(i).node;\n+            }\n+            return rv;\n+        } else {\n+            return new XmlNode[] {\n+                XmlNode.createText(getProcessor(), ScriptRuntime.toString(value))\n+            };\n+        }\n+    }\n+\n+    XML replace(int index, Object xml) {\n+        XMLList xlChildToReplace = child(index);\n+        if (xlChildToReplace.length() > 0) {\n+            // One exists an that index\n+            XML childToReplace = xlChildToReplace.item(0);\n+            insertChildAfter(childToReplace, xml);\n+            removeChild(index);\n+        }\n+        return this;\n+    }\n+\n+    XML prependChild(Object xml) {\n+        if (this.node.isParentType()) {\n+            this.node.insertChildrenAt(0, getNodesForInsert(xml));\n+        }\n+        return this;\n+    }\n+\n+    XML appendChild(Object xml) {\n+        if (this.node.isParentType()) {\n+            XmlNode[] nodes = getNodesForInsert(xml);\n+            this.node.insertChildrenAt(this.node.getChildCount(), nodes);\n+        }\n+        return this;\n+    }\n+\n+    private int getChildIndexOf(XML child) {\n+        for (int i=0; i<this.node.getChildCount(); i++) {\n+            if (this.node.getChild(i).isSameNode(child.node)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    XML insertChildBefore(XML child, Object xml) {\n+        if (child == null) {\n+            // Spec says inserting before nothing is the same as appending\n+            appendChild(xml);\n+        } else {\n+            XmlNode[] toInsert = getNodesForInsert(xml);\n+            int index = getChildIndexOf(child);\n+            if (index != -1) {\n+                this.node.insertChildrenAt(index, toInsert);\n+            }\n+        }\n+\n+        return this;\n+    }\n+\n+    XML insertChildAfter(XML child, Object xml) {\n+        if (child == null) {\n+            // Spec says inserting after nothing is the same as prepending\n+            prependChild(xml);\n+        } else {\n+            XmlNode[] toInsert = getNodesForInsert(xml);\n+            int index = getChildIndexOf(child);\n+            if (index != -1) {\n+                this.node.insertChildrenAt(index+1, toInsert);\n+            }\n+        }\n+\n+        return this;\n+    }\n+\n+    XML setChildren(Object xml) {\n+        //    TODO    Have not carefully considered the spec but it seems to call for this\n+        if (!isElement()) return this;\n+\n+        while(this.node.getChildCount() > 0) {\n+            this.node.removeChild(0);\n+        }\n+        XmlNode[] toInsert = getNodesForInsert(xml);\n+        // append new children\n+        this.node.insertChildrenAt(0, toInsert);\n+\n+        return this;\n+    }\n+\n+    //\n+    //    Name and namespace-related methods\n+    //\n+\n+    private void addInScopeNamespace(Namespace ns) {\n+        if (!isElement()) {\n+            return;\n+        }\n+        //    See ECMA357 9.1.1.13\n+        //    in this implementation null prefix means ECMA undefined\n+        if (ns.prefix() != null) {\n+            if (ns.prefix().length() == 0 && ns.uri().length() == 0) {\n+                return;\n+            }\n+            if (node.getQname().getNamespace().getPrefix().equals(ns.prefix())) {\n+                node.invalidateNamespacePrefix();\n+            }\n+            node.declareNamespace(ns.prefix(), ns.uri());\n+        } else {\n+            return;\n+        }\n+    }\n+\n+    Namespace[] inScopeNamespaces() {\n+        XmlNode.Namespace[] inScope = this.node.getInScopeNamespaces();\n+        return createNamespaces(inScope);\n+    }\n+\n+    private XmlNode.Namespace adapt(Namespace ns) {\n+        if (ns.prefix() == null) {\n+            return XmlNode.Namespace.create(ns.uri());\n+        } else {\n+            return XmlNode.Namespace.create(ns.prefix(), ns.uri());\n+        }\n+    }\n+\n+    XML removeNamespace(Namespace ns) {\n+        if (!isElement()) return this;\n+        this.node.removeNamespace(adapt(ns));\n+        return this;\n+    }\n+\n+    XML addNamespace(Namespace ns) {\n+        addInScopeNamespace(ns);\n+        return this;\n+    }\n+\n+    QName name() {\n+        if (isText() || isComment()) return null;\n+        if (isProcessingInstruction()) return newQName(\"\", this.node.getQname().getLocalName(), null);\n+        return newQName(node.getQname());\n+    }\n+\n+    Namespace[] namespaceDeclarations() {\n+        XmlNode.Namespace[] declarations = node.getNamespaceDeclarations();\n+        return createNamespaces(declarations);\n+    }\n+\n+    Namespace namespace(String prefix) {\n+        if (prefix == null) {\n+            return createNamespace( this.node.getNamespaceDeclaration() );\n+        } else {\n+            return createNamespace( this.node.getNamespaceDeclaration(prefix) );\n+        }\n+    }\n+\n+    String localName() {\n+        if (name() == null) return null;\n+        return name().localName();\n+    }\n+\n+    void setLocalName(String localName) {\n+        //    ECMA357 13.4.4.34\n+        if (isText() || isComment()) return;\n+        this.node.setLocalName(localName);\n+    }\n+\n+    void setName(QName name) {\n+        //    See ECMA357 13.4.4.35\n+        if (isText() || isComment()) return;\n+        if (isProcessingInstruction()) {\n+            //    Spec says set the name URI to empty string and then set the [[Name]] property, but I understand this to do the same\n+            //    thing, unless we allow colons in processing instruction targets, which I think we do not.\n+            this.node.setLocalName(name.localName());\n+            return;\n+        }\n+        node.renameNode(name.getDelegate());\n+    }\n+\n+    void setNamespace(Namespace ns) {\n+        //    See ECMA357 13.4.4.36\n+        if (isText() || isComment() || isProcessingInstruction()) return;\n+        setName(newQName(ns.uri(), localName(), ns.prefix()));\n+    }\n+\n+    final String ecmaClass() {\n+        //    See ECMA357 9.1\n+\n+        //    TODO    See ECMA357 9.1.1 last paragraph for what defaults should be\n+\n+        if (node.isTextType()) {\n+            return \"text\";\n+        } else if (node.isAttributeType()) {\n+            return \"attribute\";\n+        } else if (node.isCommentType()) {\n+            return \"comment\";\n+        } else if (node.isProcessingInstructionType()) {\n+            return \"processing-instruction\";\n+        } else if (node.isElementType()) {\n+            return \"element\";\n+        } else {\n+            throw new RuntimeException(\"Unrecognized type: \" + node);\n+        }\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        //    TODO:    This appears to confuse the interpreter if we use the \"real\" class property from ECMA.  Otherwise this code\n+        //    would be:\n+        //    return ecmaClass();\n+        return \"XML\";\n+    }\n+\n+    private String ecmaValue() {\n+        return node.ecmaValue();\n+    }\n+\n+    private String ecmaToString() {\n+        //    See ECMA357 10.1.1\n+        if (isAttribute() || isText()) {\n+            return ecmaValue();\n+        }\n+        if (this.hasSimpleContent()) {\n+            StringBuffer rv = new StringBuffer();\n+            for (int i=0; i < this.node.getChildCount(); i++) {\n+                XmlNode child = this.node.getChild(i);\n+                if (!child.isProcessingInstructionType() &&\n+                    !child.isCommentType())\n+                {\n+                    // TODO: Probably inefficient; taking clean non-optimized\n+                    // solution for now\n+                    XML x = new XML(getLib(), getParentScope(),\n+                                    (XMLObject)getPrototype(), child);\n+                    rv.append(x.toString());\n+                }\n+            }\n+            return rv.toString();\n+        }\n+        return toXMLString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return ecmaToString();\n+    }\n+\n+    @Override\n+    String toSource(int indent) {\n+        return toXMLString();\n+    }\n+\n+    @Override\n+    String toXMLString() {\n+        return this.node.ecmaToXMLString(getProcessor());\n+    }\n+\n+    final boolean isAttribute() {\n+        return node.isAttributeType();\n+    }\n+\n+    final boolean isComment() {\n+        return node.isCommentType();\n+    }\n+\n+    final boolean isText() {\n+        return node.isTextType();\n+    }\n+\n+    final boolean isElement() {\n+        return node.isElementType();\n+    }\n+\n+    final boolean isProcessingInstruction() {\n+        return node.isProcessingInstructionType();\n+    }\n+\n+    //    Support experimental Java interface\n+    org.w3c.dom.Node toDomNode() {\n+        return node.toDomNode();\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLCtor.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xmlimpl;\n+\n+import org.mozilla.javascript.*;\n+\n+class XMLCtor extends IdFunctionObject\n+{\n+    static final long serialVersionUID = -8708195078359817341L;\n+\n+    private static final Object XMLCTOR_TAG = \"XMLCtor\";\n+\n+    private XmlProcessor options;\n+//    private XMLLibImpl lib;\n+\n+    XMLCtor(XML xml, Object tag, int id, int arity)\n+    {\n+        super(xml, tag, id, arity);\n+//        this.lib = xml.lib;\n+        this.options = xml.getProcessor();\n+        activatePrototypeMap(MAX_FUNCTION_ID);\n+    }\n+\n+    private void writeSetting(Scriptable target)\n+    {\n+        for (int i = 1; i <= MAX_INSTANCE_ID; ++i) {\n+            int id = super.getMaxInstanceId() + i;\n+            String name = getInstanceIdName(id);\n+            Object value = getInstanceIdValue(id);\n+            ScriptableObject.putProperty(target, name, value);\n+        }\n+    }\n+\n+    private void readSettings(Scriptable source)\n+    {\n+        for (int i = 1; i <= MAX_INSTANCE_ID; ++i) {\n+            int id = super.getMaxInstanceId() + i;\n+            String name = getInstanceIdName(id);\n+            Object value = ScriptableObject.getProperty(source, name);\n+            if (value == Scriptable.NOT_FOUND) {\n+                continue;\n+            }\n+            switch (i) {\n+              case Id_ignoreComments:\n+              case Id_ignoreProcessingInstructions:\n+              case Id_ignoreWhitespace:\n+              case Id_prettyPrinting:\n+                if (!(value instanceof Boolean)) {\n+                    continue;\n+                }\n+                break;\n+              case Id_prettyIndent:\n+                if (!(value instanceof Number)) {\n+                    continue;\n+                }\n+                break;\n+              default:\n+                throw new IllegalStateException();\n+            }\n+            setInstanceIdValue(id, value);\n+        }\n+    }\n+\n+// #string_id_map#\n+\n+    private static final int\n+        Id_ignoreComments               = 1,\n+        Id_ignoreProcessingInstructions = 2,\n+        Id_ignoreWhitespace             = 3,\n+        Id_prettyIndent                 = 4,\n+        Id_prettyPrinting               = 5,\n+\n+        MAX_INSTANCE_ID                 = 5;\n+\n+    @Override\n+    protected int getMaxInstanceId()\n+    {\n+        return super.getMaxInstanceId() + MAX_INSTANCE_ID;\n+    }\n+\n+    @Override\n+    protected int findInstanceIdInfo(String s) {\n+        int id;\n+// #generated# Last update: 2007-08-20 09:01:10 EDT\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 12: X=\"prettyIndent\";id=Id_prettyIndent; break L;\n+            case 14: c=s.charAt(0);\n+                if (c=='i') { X=\"ignoreComments\";id=Id_ignoreComments; }\n+                else if (c=='p') { X=\"prettyPrinting\";id=Id_prettyPrinting; }\n+                break L;\n+            case 16: X=\"ignoreWhitespace\";id=Id_ignoreWhitespace; break L;\n+            case 28: X=\"ignoreProcessingInstructions\";id=Id_ignoreProcessingInstructions; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+\n+        if (id == 0) return super.findInstanceIdInfo(s);\n+\n+        int attr;\n+        switch (id) {\n+          case Id_ignoreComments:\n+          case Id_ignoreProcessingInstructions:\n+          case Id_ignoreWhitespace:\n+          case Id_prettyIndent:\n+          case Id_prettyPrinting:\n+            attr = PERMANENT | DONTENUM;\n+            break;\n+          default: throw new IllegalStateException();\n+        }\n+        return instanceIdInfo(attr, super.getMaxInstanceId() + id);\n+    }\n+\n+// #/string_id_map#\n+\n+    @Override\n+    protected String getInstanceIdName(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_ignoreComments:               return \"ignoreComments\";\n+          case Id_ignoreProcessingInstructions: return \"ignoreProcessingInstructions\";\n+          case Id_ignoreWhitespace:             return \"ignoreWhitespace\";\n+          case Id_prettyIndent:                 return \"prettyIndent\";\n+          case Id_prettyPrinting:               return \"prettyPrinting\";\n+        }\n+        return super.getInstanceIdName(id);\n+    }\n+\n+    @Override\n+    protected Object getInstanceIdValue(int id)\n+    {\n+        switch (id - super.getMaxInstanceId()) {\n+          case Id_ignoreComments:\n+            return ScriptRuntime.wrapBoolean(options.isIgnoreComments());\n+          case Id_ignoreProcessingInstructions:\n+            return ScriptRuntime.wrapBoolean(options.isIgnoreProcessingInstructions());\n+          case Id_ignoreWhitespace:\n+            return ScriptRuntime.wrapBoolean(options.isIgnoreWhitespace());\n+          case Id_prettyIndent:\n+            return ScriptRuntime.wrapInt(options.getPrettyIndent());\n+          case Id_prettyPrinting:\n+            return ScriptRuntime.wrapBoolean(options.isPrettyPrinting());\n+        }\n+        return super.getInstanceIdValue(id);\n+    }\n+\n+    @Override\n+    protected void setInstanceIdValue(int id, Object value) {\n+        switch (id - super.getMaxInstanceId()) {\n+            case Id_ignoreComments:\n+                options.setIgnoreComments(ScriptRuntime.toBoolean(value));\n+                return;\n+            case Id_ignoreProcessingInstructions:\n+                options.setIgnoreProcessingInstructions(ScriptRuntime.toBoolean(value));\n+                return;\n+            case Id_ignoreWhitespace:\n+                options.setIgnoreWhitespace(ScriptRuntime.toBoolean(value));\n+                return;\n+            case Id_prettyIndent:\n+                options.setPrettyIndent(ScriptRuntime.toInt32(value));\n+                return;\n+            case Id_prettyPrinting:\n+                options.setPrettyPrinting(ScriptRuntime.toBoolean(value));\n+                return;\n+        }\n+        super.setInstanceIdValue(id, value);\n+    }\n+\n+// #string_id_map#\n+    private static final int\n+        Id_defaultSettings              = 1,\n+        Id_settings                     = 2,\n+        Id_setSettings                  = 3,\n+        MAX_FUNCTION_ID                 = 3;\n+\n+    @Override\n+    protected int findPrototypeId(String s)\n+    {\n+        int id;\n+// #generated# Last update: 2007-08-20 09:01:10 EDT\n+        L0: { id = 0; String X = null;\n+            int s_length = s.length();\n+            if (s_length==8) { X=\"settings\";id=Id_settings; }\n+            else if (s_length==11) { X=\"setSettings\";id=Id_setSettings; }\n+            else if (s_length==15) { X=\"defaultSettings\";id=Id_defaultSettings; }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+// #/string_id_map#\n+\n+    @Override\n+    protected void initPrototypeId(int id)\n+    {\n+        String s;\n+        int arity;\n+        switch (id) {\n+          case Id_defaultSettings:  arity=0; s=\"defaultSettings\";  break;\n+          case Id_settings:         arity=0; s=\"settings\";         break;\n+          case Id_setSettings:      arity=1; s=\"setSettings\";      break;\n+          default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(XMLCTOR_TAG, id, s, arity);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(XMLCTOR_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        switch (id) {\n+          case Id_defaultSettings: {\n+            options.setDefault();\n+            Scriptable obj = cx.newObject(scope);\n+            writeSetting(obj);\n+            return obj;\n+          }\n+          case Id_settings: {\n+            Scriptable obj = cx.newObject(scope);\n+            writeSetting(obj);\n+            return obj;\n+          }\n+          case Id_setSettings: {\n+            if (args.length == 0\n+                || args[0] == null\n+                || args[0] == Undefined.instance)\n+            {\n+                options.setDefault();\n+            } else if (args[0] instanceof Scriptable) {\n+                readSettings((Scriptable)args[0]);\n+            }\n+            return Undefined.instance;\n+          }\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    /**\n+        hasInstance for XML objects works differently than other objects; see ECMA357 13.4.3.10.\n+     */\n+    @Override\n+    public boolean hasInstance(Scriptable instance) {\n+        return (instance instanceof XML || instance instanceof XMLList);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLLibImpl.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xmlimpl;\n+\n+import java.io.Serializable;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.xml.*;\n+\n+public final class XMLLibImpl extends XMLLib implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    //\n+    //    EXPERIMENTAL Java interface\n+    //\n+\n+    /**\n+        This experimental interface is undocumented.\n+     */\n+    public static org.w3c.dom.Node toDomNode(Object xmlObject) {\n+        //    Could return DocumentFragment for XMLList\n+        //    Probably a single node for XMLList with one element\n+        if (xmlObject instanceof XML) {\n+            return ((XML)xmlObject).toDomNode();\n+        } else {\n+            throw new IllegalArgumentException(\n+                    \"xmlObject is not an XML object in JavaScript.\");\n+        }\n+    }\n+\n+    public static void init(Context cx, Scriptable scope, boolean sealed) {\n+        XMLLibImpl lib = new XMLLibImpl(scope);\n+        XMLLib bound = lib.bindToScope(scope);\n+        if (bound == lib) {\n+            lib.exportToScope(sealed);\n+        }\n+    }\n+    \n+    public void setIgnoreComments(boolean b) {\n+        options.setIgnoreComments(b);\n+    }\n+\n+    public void setIgnoreWhitespace(boolean b) {\n+        options.setIgnoreWhitespace(b);\n+    }\n+\n+    public void setIgnoreProcessingInstructions(boolean b) {\n+        options.setIgnoreProcessingInstructions(b);\n+    }\n+\n+    public void setPrettyPrinting(boolean b) {\n+        options.setPrettyPrinting(b);\n+    }\n+\n+    public void setPrettyIndent(int i) {\n+        options.setPrettyIndent(i);\n+    }\n+\n+    public boolean isIgnoreComments() {\n+        return options.isIgnoreComments();\n+    }\n+\n+    public boolean isIgnoreProcessingInstructions() {\n+        return options.isIgnoreProcessingInstructions();\n+    }\n+\n+    public boolean isIgnoreWhitespace() {\n+        return options.isIgnoreWhitespace();\n+    }\n+\n+    public  boolean isPrettyPrinting() {\n+        return options.isPrettyPrinting();\n+    }\n+\n+    public int getPrettyIndent() {\n+        return options.getPrettyIndent();\n+    }\n+\n+\n+    private Scriptable globalScope;\n+\n+    private XML xmlPrototype;\n+    private XMLList xmlListPrototype;\n+    private Namespace namespacePrototype;\n+    private QName qnamePrototype;\n+\n+    private XmlProcessor options = new XmlProcessor();\n+\n+    private XMLLibImpl(Scriptable globalScope) {\n+        this.globalScope = globalScope;\n+    }\n+\n+    /** @deprecated */\n+    QName qnamePrototype() {\n+        return qnamePrototype;\n+    }\n+\n+    /** @deprecated */\n+    Scriptable globalScope() {\n+        return globalScope;\n+    }\n+\n+    XmlProcessor getProcessor() {\n+        return options;\n+    }\n+\n+    private void exportToScope(boolean sealed) {\n+        xmlPrototype = newXML(XmlNode.createText(options, \"\"));\n+        xmlListPrototype = newXMLList();\n+        namespacePrototype = Namespace.create(this.globalScope, null, XmlNode.Namespace.GLOBAL);\n+        qnamePrototype = QName.create(this, this.globalScope, null, XmlNode.QName.create(XmlNode.Namespace.create(\"\"), \"\"));\n+\n+        xmlPrototype.exportAsJSClass(sealed);\n+        xmlListPrototype.exportAsJSClass(sealed);\n+        namespacePrototype.exportAsJSClass(sealed);\n+        qnamePrototype.exportAsJSClass(sealed);\n+    }\n+\n+    /** @deprecated */\n+    XMLName toAttributeName(Context cx, Object nameValue) {\n+        if (nameValue instanceof XMLName) {\n+            //    TODO    Will this always be an XMLName of type attribute name?\n+            return (XMLName)nameValue;\n+        } else if (nameValue instanceof QName) {\n+            return XMLName.create( ((QName)nameValue).getDelegate(), true, false );\n+        } else if (nameValue instanceof Boolean\n+            || nameValue instanceof Number\n+            || nameValue == Undefined.instance\n+            || nameValue == null) {\n+            throw badXMLName(nameValue);\n+        } else {\n+            //    TODO    Not 100% sure that putting these in global namespace is the right thing to do\n+            String localName = null;\n+            if (nameValue instanceof String) {\n+                localName = (String)nameValue;\n+            } else {\n+                localName = ScriptRuntime.toString(nameValue);\n+            }\n+            if (localName != null && localName.equals(\"*\")) localName = null;\n+            return XMLName.create(XmlNode.QName.create(XmlNode.Namespace.create(\"\"), localName), true, false);\n+        }\n+    }\n+\n+    private static RuntimeException badXMLName(Object value)\n+    {\n+        String msg;\n+        if (value instanceof Number) {\n+            msg = \"Can not construct XML name from number: \";\n+        } else if (value instanceof Boolean) {\n+            msg = \"Can not construct XML name from boolean: \";\n+        } else if (value == Undefined.instance || value == null) {\n+            msg = \"Can not construct XML name from \";\n+        } else {\n+            throw new IllegalArgumentException(value.toString());\n+        }\n+        return ScriptRuntime.typeError(msg+ScriptRuntime.toString(value));\n+    }\n+\n+    XMLName toXMLNameFromString(Context cx, String name) {\n+        return XMLName.create(getDefaultNamespaceURI(cx), name);\n+    }\n+\n+    /* TODO: Marked deprecated by original author */\n+    XMLName toXMLName(Context cx, Object nameValue) {\n+        XMLName result;\n+\n+        if (nameValue instanceof XMLName) {\n+            result = (XMLName)nameValue;\n+        } else if (nameValue instanceof QName) {\n+            QName qname = (QName)nameValue;\n+            result = XMLName.formProperty(qname.uri(), qname.localName());\n+        } else if (nameValue instanceof String) {\n+            result = toXMLNameFromString(cx, (String)nameValue);\n+        } else if (nameValue instanceof Boolean\n+            || nameValue instanceof Number\n+            || nameValue == Undefined.instance\n+            || nameValue == null) {\n+            throw badXMLName(nameValue);\n+        } else {\n+            String name = ScriptRuntime.toString(nameValue);\n+            result = toXMLNameFromString(cx, name);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * If value represents Uint32 index, make it available through\n+     * ScriptRuntime.lastUint32Result(cx) and return null.\n+     * Otherwise return the same value as toXMLName(cx, value).\n+     */\n+    XMLName toXMLNameOrIndex(Context cx, Object value)\n+    {\n+        XMLName result;\n+\n+        if (value instanceof XMLName) {\n+            result = (XMLName)value;\n+        } else if (value instanceof String) {\n+            String str = (String)value;\n+            long test = ScriptRuntime.testUint32String(str);\n+            if (test >= 0) {\n+                ScriptRuntime.storeUint32Result(cx, test);\n+                result = null;\n+            } else {\n+                result = toXMLNameFromString(cx, str);\n+            }\n+        } else if (value instanceof Number) {\n+            double d = ((Number)value).doubleValue();\n+            long l = (long)d;\n+            if (l == d && 0 <= l && l <= 0xFFFFFFFFL) {\n+                ScriptRuntime.storeUint32Result(cx, l);\n+                result = null;\n+            } else {\n+                throw badXMLName(value);\n+            }\n+        } else if (value instanceof QName) {\n+            QName qname = (QName)value;\n+            String uri = qname.uri();\n+            boolean number = false;\n+            result = null;\n+            if (uri != null && uri.length() == 0) {\n+                // Only in this case qname.toString() can resemble uint32\n+                long test = ScriptRuntime.testUint32String(uri);\n+                if (test >= 0) {\n+                    ScriptRuntime.storeUint32Result(cx, test);\n+                    number = true;\n+                }\n+            }\n+            if (!number) {\n+                result = XMLName.formProperty(uri, qname.localName());\n+            }\n+        } else if (value instanceof Boolean\n+                   || value == Undefined.instance\n+                   || value == null)\n+        {\n+            throw badXMLName(value);\n+        } else {\n+            String str = ScriptRuntime.toString(value);\n+            long test = ScriptRuntime.testUint32String(str);\n+            if (test >= 0) {\n+                ScriptRuntime.storeUint32Result(cx, test);\n+                result = null;\n+            } else {\n+                result = toXMLNameFromString(cx, str);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    Object addXMLObjects(Context cx, XMLObject obj1, XMLObject obj2)\n+    {\n+        XMLList listToAdd = newXMLList();\n+\n+        if (obj1 instanceof XMLList) {\n+            XMLList list1 = (XMLList)obj1;\n+            if (list1.length() == 1) {\n+                listToAdd.addToList(list1.item(0));\n+            } else {\n+                // Might be xmlFragment + xmlFragment + xmlFragment + ...;\n+                // then the result will be an XMLList which we want to be an\n+                // rValue and allow it to be assigned to an lvalue.\n+                listToAdd = newXMLListFrom(obj1);\n+            }\n+        } else {\n+            listToAdd.addToList(obj1);\n+        }\n+\n+        if (obj2 instanceof XMLList) {\n+            XMLList list2 = (XMLList)obj2;\n+            for (int i = 0; i < list2.length(); i++) {\n+                listToAdd.addToList(list2.item(i));\n+            }\n+        } else if (obj2 instanceof XML) {\n+            listToAdd.addToList(obj2);\n+        }\n+\n+        return listToAdd;\n+    }\n+\n+    private Ref xmlPrimaryReference(Context cx, XMLName xmlName, Scriptable scope) {\n+        XMLObjectImpl xmlObj;\n+        XMLObjectImpl firstXml = null;\n+        for (;;) {\n+            // XML object can only present on scope chain as a wrapper\n+            // of XMLWithScope\n+            if (scope instanceof XMLWithScope) {\n+                xmlObj = (XMLObjectImpl)scope.getPrototype();\n+                if (xmlObj.hasXMLProperty(xmlName)) {\n+                    break;\n+                }\n+                if (firstXml == null) {\n+                    firstXml = xmlObj;\n+                }\n+            }\n+            scope = scope.getParentScope();\n+            if (scope == null) {\n+                xmlObj = firstXml;\n+                break;\n+            }\n+        }\n+\n+        // xmlObj == null corresponds to undefined as the target of\n+        // the reference\n+        if (xmlObj != null) {\n+            xmlName.initXMLObject(xmlObj);\n+        }\n+        return xmlName;\n+    }\n+\n+    Namespace castToNamespace(Context cx, Object namespaceObj) {\n+        return this.namespacePrototype.castToNamespace(namespaceObj);\n+    }\n+\n+    private String getDefaultNamespaceURI(Context cx) {\n+        return getDefaultNamespace(cx).uri();\n+    }\n+\n+    Namespace newNamespace(String uri) {\n+        return this.namespacePrototype.newNamespace(uri);\n+    }\n+\n+    Namespace getDefaultNamespace(Context cx) {\n+        if (cx == null) {\n+            cx = Context.getCurrentContext();\n+            if (cx == null) {\n+                return namespacePrototype;\n+            }\n+        }\n+\n+        Object ns = ScriptRuntime.searchDefaultNamespace(cx);\n+        if (ns == null) {\n+            return namespacePrototype;\n+        } else {\n+            if (ns instanceof Namespace) {\n+                return (Namespace)ns;\n+            } else {\n+                //    TODO    Clarify or remove the following comment\n+                // Should not happen but for now it could\n+                // due to bad searchDefaultNamespace implementation.\n+                return namespacePrototype;\n+            }\n+        }\n+    }\n+\n+    Namespace[] createNamespaces(XmlNode.Namespace[] declarations) {\n+        Namespace[] rv = new Namespace[declarations.length];\n+        for (int i=0; i<declarations.length; i++) {\n+            rv[i] = this.namespacePrototype.newNamespace(declarations[i].getPrefix(), declarations[i].getUri());\n+        }\n+        return rv;\n+    }\n+\n+    //    See ECMA357 13.3.2\n+    QName constructQName(Context cx, Object namespace, Object name) {\n+        return this.qnamePrototype.constructQName(this, cx, namespace, name);\n+    }\n+\n+    QName newQName(String uri, String localName, String prefix) {\n+        return this.qnamePrototype.newQName(this, uri, localName, prefix);\n+    }\n+\n+    QName constructQName(Context cx, Object nameValue) {\n+//        return constructQName(cx, Undefined.instance, nameValue);\n+        return this.qnamePrototype.constructQName(this, cx, nameValue);\n+    }\n+\n+    QName castToQName(Context cx, Object qnameValue) {\n+        return this.qnamePrototype.castToQName(this, cx, qnameValue);\n+    }\n+\n+    QName newQName(XmlNode.QName qname) {\n+        return QName.create(this, this.globalScope, this.qnamePrototype, qname);\n+    }\n+\n+    XML newXML(XmlNode node) {\n+        return new XML(this, this.globalScope, this.xmlPrototype, node);\n+    }\n+\n+    /* TODO: Can this can be replaced by ecmaToXml below?\n+     */\n+    final XML newXMLFromJs(Object inputObject) {\n+        String frag;\n+\n+        if (inputObject == null || inputObject == Undefined.instance) {\n+            frag = \"\";\n+        } else if (inputObject instanceof XMLObjectImpl) {\n+            // todo: faster way for XMLObjects?\n+            frag = ((XMLObjectImpl) inputObject).toXMLString();\n+        } else {\n+            frag = ScriptRuntime.toString(inputObject);\n+        }\n+\n+        if (frag.trim().startsWith(\"<>\")) {\n+            throw ScriptRuntime.typeError(\"Invalid use of XML object anonymous tags <></>.\");\n+        }\n+\n+        if (frag.indexOf(\"<\") == -1) {\n+            //    Solo text node\n+            return newXML(XmlNode.createText(options, frag));\n+        }\n+        return parse(frag);\n+    }\n+\n+    private XML parse(String frag) {\n+        try {\n+            return newXML(XmlNode.createElement(options, getDefaultNamespaceURI(Context.getCurrentContext()), frag));\n+        } catch (org.xml.sax.SAXException e) {\n+            throw ScriptRuntime.typeError(\"Cannot parse XML: \" + e.getMessage());\n+        }\n+    }\n+\n+    final XML ecmaToXml(Object object) {\n+        //    See ECMA357 10.3\n+        if (object == null || object == Undefined.instance) throw ScriptRuntime.typeError(\"Cannot convert \" + object + \" to XML\");\n+        if (object instanceof XML) return (XML)object;\n+        if (object instanceof XMLList) {\n+            XMLList list = (XMLList)object;\n+            if (list.getXML() != null) {\n+                return list.getXML();\n+            } else {\n+                throw ScriptRuntime.typeError(\"Cannot convert list of >1 element to XML\");\n+            }\n+        }\n+        //    TODO    Technically we should fail on anything except a String, Number or Boolean\n+        //            See ECMA357 10.3\n+        // Extension: if object is a DOM node, use that to construct the XML\n+        // object.\n+        if (object instanceof Wrapper) {\n+            object = ((Wrapper) object).unwrap();\n+        }\n+        if (object instanceof org.w3c.dom.Node) {\n+            org.w3c.dom.Node node = (org.w3c.dom.Node) object;\n+            return newXML(XmlNode.createElementFromNode(node));\n+        }\n+        //    Instead we just blindly cast to a String and let them convert anything.\n+        String s = ScriptRuntime.toString(object);\n+        //    TODO    Could this get any uglier?\n+        if (s.length() > 0 && s.charAt(0) == '<') {\n+            return parse(s);\n+        } else {\n+            return newXML(XmlNode.createText(options, s));\n+        }\n+    }\n+\n+    final XML newTextElementXML(XmlNode reference, XmlNode.QName qname, String value) {\n+        return newXML(XmlNode.newElementWithText(options, reference, qname, value));\n+    }\n+\n+    XMLList newXMLList() {\n+        return new XMLList(this, this.globalScope, this.xmlListPrototype);\n+    }\n+\n+    final XMLList newXMLListFrom(Object inputObject) {\n+        XMLList rv = newXMLList();\n+\n+        if (inputObject == null || inputObject instanceof Undefined) {\n+            return rv;\n+        } else if (inputObject instanceof XML) {\n+            XML xml = (XML) inputObject;\n+            rv.getNodeList().add(xml);\n+            return rv;\n+        } else if (inputObject instanceof XMLList) {\n+            XMLList xmll = (XMLList) inputObject;\n+            rv.getNodeList().add(xmll.getNodeList());\n+            return rv;\n+        } else {\n+            String frag = ScriptRuntime.toString(inputObject).trim();\n+\n+            if (!frag.startsWith(\"<>\")) {\n+                frag = \"<>\" + frag + \"</>\";\n+            }\n+\n+            frag = \"<fragment>\" + frag.substring(2);\n+            if (!frag.endsWith(\"</>\")) {\n+                throw ScriptRuntime.typeError(\"XML with anonymous tag missing end anonymous tag\");\n+            }\n+\n+            frag = frag.substring(0, frag.length() - 3) + \"</fragment>\";\n+\n+            XML orgXML = newXMLFromJs(frag);\n+\n+            // Now orphan the children and add them to our XMLList.\n+            XMLList children = orgXML.children();\n+\n+            for (int i = 0; i < children.getNodeList().length(); i++) {\n+                // Copy here is so that they'll be orphaned (parent() will be undefined)\n+                rv.getNodeList().add(((XML) children.item(i).copy()));\n+            }\n+            return rv;\n+        }\n+    }\n+\n+    XmlNode.QName toNodeQName(Context cx, Object namespaceValue, Object nameValue) {\n+        // This is duplication of constructQName(cx, namespaceValue, nameValue)\n+        // but for XMLName\n+\n+        String localName;\n+\n+        if (nameValue instanceof QName) {\n+            QName qname = (QName)nameValue;\n+            localName = qname.localName();\n+        } else {\n+            localName = ScriptRuntime.toString(nameValue);\n+        }\n+\n+        XmlNode.Namespace ns;\n+        if (namespaceValue == Undefined.instance) {\n+            if (\"*\".equals(localName)) {\n+                ns = null;\n+            } else {\n+                ns = getDefaultNamespace(cx).getDelegate();\n+            }\n+        } else if (namespaceValue == null) {\n+            ns = null;\n+        } else if (namespaceValue instanceof Namespace) {\n+            ns = ((Namespace)namespaceValue).getDelegate();\n+        } else {\n+            ns = this.namespacePrototype.constructNamespace(namespaceValue).getDelegate();\n+        }\n+\n+        if (localName != null && localName.equals(\"*\")) localName = null;\n+        return XmlNode.QName.create(ns, localName);\n+    }\n+\n+    XmlNode.QName toNodeQName(Context cx, String name, boolean attribute) {\n+        XmlNode.Namespace defaultNamespace = getDefaultNamespace(cx).getDelegate();\n+        if (name != null && name.equals(\"*\")) {\n+            return XmlNode.QName.create(null, null);\n+        } else {\n+            if (attribute) {\n+                return XmlNode.QName.create(XmlNode.Namespace.GLOBAL, name);\n+            } else {\n+                return XmlNode.QName.create(defaultNamespace, name);\n+            }\n+        }\n+    }\n+\n+    /*\n+        TODO: Too general; this should be split into overloaded methods.\n+        Is that possible?\n+     */\n+    XmlNode.QName toNodeQName(Context cx, Object nameValue, boolean attribute) {\n+        if (nameValue instanceof XMLName) {\n+            return ((XMLName)nameValue).toQname();\n+        } else if (nameValue instanceof QName) {\n+            QName qname = (QName)nameValue;\n+            return qname.getDelegate();\n+        } else if (\n+            nameValue instanceof Boolean\n+            || nameValue instanceof Number\n+            || nameValue == Undefined.instance\n+            || nameValue == null\n+        ) {\n+            throw badXMLName(nameValue);\n+        } else {\n+            String local = null;\n+            if (nameValue instanceof String) {\n+                local = (String)nameValue;\n+            } else {\n+                local = ScriptRuntime.toString(nameValue);\n+            }\n+            return toNodeQName(cx, local, attribute);\n+        }\n+    }\n+\n+    //\n+    //    Override methods from XMLLib\n+    //\n+\n+    @Override\n+    public boolean isXMLName(Context _cx, Object nameObj) {\n+        return XMLName.accept(nameObj);\n+    }\n+\n+    @Override\n+    public Object toDefaultXmlNamespace(Context cx, Object uriValue) {\n+        return this.namespacePrototype.constructNamespace(uriValue);\n+    }\n+\n+    @Override\n+    public String escapeTextValue(Object o) {\n+        return options.escapeTextValue(o);\n+    }\n+\n+    @Override\n+    public String escapeAttributeValue(Object o) {\n+        return options.escapeAttributeValue(o);\n+    }\n+\n+    @Override\n+    public Ref nameRef(Context cx, Object name, Scriptable scope, int memberTypeFlags) {\n+        if ((memberTypeFlags & Node.ATTRIBUTE_FLAG) == 0) {\n+            // should only be called for cases like @name or @[expr]\n+            throw Kit.codeBug();\n+        }\n+        XMLName xmlName = toAttributeName(cx, name);\n+        return xmlPrimaryReference(cx, xmlName, scope);\n+    }\n+\n+    @Override\n+    public Ref nameRef(Context cx, Object namespace, Object name, Scriptable scope, int memberTypeFlags) {\n+        XMLName xmlName = XMLName.create(toNodeQName(cx, namespace, name), false, false);\n+\n+        //    No idea what is coming in from the parser in this case; is it detecting the \"@\"?\n+        if ((memberTypeFlags & Node.ATTRIBUTE_FLAG) != 0) {\n+            if (!xmlName.isAttributeName()) {\n+                xmlName.setAttributeName();\n+            }\n+        }\n+\n+        return xmlPrimaryReference(cx, xmlName, scope);\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLList.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xmlimpl;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.xml.*;\n+import java.util.ArrayList;\n+\n+class XMLList extends XMLObjectImpl implements Function {\n+    static final long serialVersionUID = -4543618751670781135L;\n+\n+    private XmlNode.InternalList _annos;\n+    private XMLObjectImpl targetObject = null;\n+    private XmlNode.QName targetProperty = null;\n+\n+    XMLList(XMLLibImpl lib, Scriptable scope, XMLObject prototype) {\n+        super(lib, scope, prototype);\n+        _annos = new XmlNode.InternalList();\n+    }\n+\n+    /* TODO Will probably end up unnecessary as we move things around */\n+    XmlNode.InternalList getNodeList() {\n+        return _annos;\n+    }\n+\n+    //    TODO    Should be XMLObjectImpl, XMLName?\n+    void setTargets(XMLObjectImpl object, XmlNode.QName property) {\n+        targetObject = object;\n+        targetProperty = property;\n+    }\n+\n+    /* TODO: original author marked this as deprecated */\n+    private XML getXmlFromAnnotation(int index) {\n+        return getXML(_annos, index);\n+    }\n+\n+    @Override\n+    XML getXML() {\n+        if (length() == 1) return getXmlFromAnnotation(0);\n+        return null;\n+    }\n+\n+    private void internalRemoveFromList(int index) {\n+        _annos.remove(index);\n+    }\n+\n+    void replace(int index, XML xml) {\n+        if (index < length()) {\n+            XmlNode.InternalList newAnnoList = new XmlNode.InternalList();\n+            newAnnoList.add(_annos, 0, index);\n+            newAnnoList.add(xml);\n+            newAnnoList.add(_annos, index+1, length());\n+            _annos = newAnnoList;\n+        }\n+    }\n+\n+    private void insert(int index, XML xml) {\n+        if (index < length()) {\n+            XmlNode.InternalList newAnnoList = new XmlNode.InternalList();\n+            newAnnoList.add(_annos, 0, index);\n+            newAnnoList.add(xml);\n+            newAnnoList.add(_annos, index, length());\n+            _annos = newAnnoList;\n+        }\n+    }\n+\n+    //\n+    //\n+    //  methods overriding ScriptableObject\n+    //\n+    //\n+\n+    @Override\n+    public String getClassName() {\n+        return \"XMLList\";\n+    }\n+\n+    //\n+    //\n+    //  methods overriding IdScriptableObject\n+    //\n+    //\n+\n+    @Override\n+    public Object get(int index, Scriptable start) {\n+        //Log(\"get index: \" + index);\n+\n+        if (index >= 0 && index < length()) {\n+            return getXmlFromAnnotation(index);\n+        } else {\n+            return Scriptable.NOT_FOUND;\n+        }\n+    }\n+\n+    @Override\n+    boolean hasXMLProperty(XMLName xmlName) {\n+        boolean result = false;\n+\n+        // Has now should return true if the property would have results > 0 or\n+        // if it's a method name\n+        String name = xmlName.localName();\n+        if ((getPropertyList(xmlName).length() > 0) ||\n+            (getMethod(name) != NOT_FOUND)) {\n+            result = true;\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean has(int index, Scriptable start) {\n+        return 0 <= index && index < length();\n+    }\n+\n+    @Override\n+    void putXMLProperty(XMLName xmlName, Object value) {\n+        //Log(\"put property: \" + name);\n+\n+        // Special-case checks for undefined and null\n+        if (value == null) {\n+            value = \"null\";\n+        } else if (value instanceof Undefined) {\n+            value = \"undefined\";\n+        }\n+\n+        if (length() > 1) {\n+            throw ScriptRuntime.typeError(\n+               \"Assignment to lists with more than one item is not supported\");\n+        } else if (length() == 0) {\n+            // Secret sauce for super-expandos.\n+            // We set an element here, and then add ourselves to our target.\n+            if (targetObject != null && targetProperty != null &&\n+                targetProperty.getLocalName() != null)\n+            {\n+                // Add an empty element with our targetProperty name and \n+                // then set it.\n+                XML xmlValue = newTextElementXML(null, targetProperty, null);\n+                addToList(xmlValue);\n+\n+                if(xmlName.isAttributeName()) {\n+                    setAttribute(xmlName, value);\n+                } else {\n+                    XML xml = item(0);\n+                    xml.putXMLProperty(xmlName, value);\n+\n+                    // Update the list with the new item at location 0.\n+                    replace(0, item(0));\n+                }\n+\n+                // Now add us to our parent\n+                XMLName name2 = XMLName.formProperty(\n+                        targetProperty.getNamespace().getUri(),\n+                        targetProperty.getLocalName());\n+                targetObject.putXMLProperty(name2, this);\n+            } else {\n+                throw ScriptRuntime.typeError(\n+                  \"Assignment to empty XMLList without targets not supported\");\n+            }\n+        } else if(xmlName.isAttributeName()) {\n+            setAttribute(xmlName, value);\n+        } else {\n+            XML xml = item(0);\n+            xml.putXMLProperty(xmlName, value);\n+\n+            // Update the list with the new item at location 0.\n+            replace(0, item(0));\n+            \n+            if (targetObject != null && targetProperty != null &&\n+                targetProperty.getLocalName() != null)\n+            {\n+                // Now add us to our parent\n+                XMLName name2 = XMLName.formProperty(\n+                        targetProperty.getNamespace().getUri(),\n+                        targetProperty.getLocalName());\n+                targetObject.putXMLProperty(name2, this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    Object getXMLProperty(XMLName name) {\n+        return getPropertyList(name);\n+    }\n+\n+    private void replaceNode(XML xml, XML with) {\n+        xml.replaceWith(with);\n+    }\n+\n+    @Override\n+    public void put(int index, Scriptable start, Object value) {\n+        Object parent = Undefined.instance;\n+        // Convert text into XML if needed.\n+        XMLObject xmlValue;\n+\n+        // Special-case checks for undefined and null\n+        if (value == null) {\n+            value = \"null\";\n+        } else if (value instanceof Undefined) {\n+            value = \"undefined\";\n+        }\n+\n+        if (value instanceof XMLObject) {\n+            xmlValue = (XMLObject) value;\n+        } else {\n+            if (targetProperty == null) {\n+                xmlValue = newXMLFromJs(value.toString());\n+            } else {\n+                //    Note that later in the code, we will use this as an argument to replace(int,value)\n+                //    So we will be \"replacing\" this element with itself\n+                //    There may well be a better way to do this\n+                //    TODO    Find a way to refactor this whole method and simplify it\n+                xmlValue = item(index);\n+                ((XML)xmlValue).setChildren(value);\n+            }\n+        }\n+\n+        // Find the parent\n+        if (index < length()) {\n+            parent = item(index).parent();\n+        } else {\n+            // Appending\n+            parent = parent();\n+        }\n+\n+        if (parent instanceof XML) {\n+            // found parent, alter doc\n+            XML xmlParent = (XML) parent;\n+\n+            if (index < length()) {\n+                // We're replacing the the node.\n+                XML xmlNode = getXmlFromAnnotation(index);\n+\n+                if (xmlValue instanceof XML) {\n+                    replaceNode(xmlNode, (XML) xmlValue);\n+                    replace(index, xmlNode);\n+                } else if (xmlValue instanceof XMLList) {\n+                    // Replace the first one, and add the rest on the list.\n+                    XMLList list = (XMLList) xmlValue;\n+\n+                    if (list.length() > 0) {\n+                        int lastIndexAdded = xmlNode.childIndex();\n+                        replaceNode(xmlNode, list.item(0));\n+                        replace(index, list.item(0));\n+\n+                        for (int i = 1; i < list.length(); i++) {\n+                            xmlParent.insertChildAfter(xmlParent.getXmlChild(lastIndexAdded), list.item(i));\n+                            lastIndexAdded++;\n+                            insert(index + i, list.item(i));\n+                        }\n+                    }\n+                }\n+            } else {\n+                // Appending\n+                xmlParent.appendChild(xmlValue);\n+                addToList(xmlParent.getXmlChild(index));\n+            }\n+        } else {\n+            // Don't all have same parent, no underlying doc to alter\n+            if (index < length()) {\n+                XML xmlNode = getXML(_annos, index);\n+\n+                if (xmlValue instanceof XML) {\n+                    replaceNode(xmlNode, (XML) xmlValue);\n+                    replace(index, xmlNode);\n+                } else if (xmlValue instanceof XMLList) {\n+                    // Replace the first one, and add the rest on the list.\n+                    XMLList list = (XMLList) xmlValue;\n+\n+                    if (list.length() > 0) {\n+                        replaceNode(xmlNode, list.item(0));\n+                        replace(index, list.item(0));\n+\n+                        for (int i = 1; i < list.length(); i++) {\n+                            insert(index + i, list.item(i));\n+                        }\n+                    }\n+                }\n+            } else {\n+                addToList(xmlValue);\n+            }\n+        }\n+    }\n+\n+    private XML getXML(XmlNode.InternalList _annos, int index) {\n+        if (index >= 0 && index < length()) {\n+            return xmlFromNode(_annos.item(index));\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    void deleteXMLProperty(XMLName name) {\n+        for (int i = 0; i < length(); i++) {\n+            XML xml = getXmlFromAnnotation(i);\n+\n+            if (xml.isElement()) {\n+                xml.deleteXMLProperty(name);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void delete(int index) {\n+        if (index >= 0 && index < length()) {\n+            XML xml = getXmlFromAnnotation(index);\n+\n+            xml.remove();\n+\n+            internalRemoveFromList(index);\n+        }\n+    }\n+\n+    @Override\n+    public Object[] getIds() {\n+        Object enumObjs[];\n+\n+        if (isPrototype()) {\n+            enumObjs = new Object[0];\n+        } else {\n+            enumObjs = new Object[length()];\n+\n+            for (int i = 0; i < enumObjs.length; i++) {\n+                enumObjs[i] = Integer.valueOf(i);\n+            }\n+        }\n+\n+        return enumObjs;\n+    }\n+\n+    public Object[] getIdsForDebug() {\n+        return getIds();\n+    }\n+\n+\n+    // XMLList will remove will delete all items in the list (a set delete) this differs from the XMLList delete operator.\n+    void remove() {\n+        int nLen = length();\n+        for (int i = nLen - 1; i >= 0; i--) {\n+            XML xml = getXmlFromAnnotation(i);\n+            if (xml != null) {\n+                xml.remove();\n+                internalRemoveFromList(i);\n+            }\n+        }\n+    }\n+\n+    XML item(int index) {\n+        return _annos != null\n+            ? getXmlFromAnnotation(index) : createEmptyXML();\n+    }\n+\n+    private void setAttribute(XMLName xmlName, Object value) {\n+        for (int i = 0; i < length(); i++) {\n+            XML xml = getXmlFromAnnotation(i);\n+            xml.setAttribute(xmlName, value);\n+        }\n+    }\n+\n+    void addToList(Object toAdd) {\n+        _annos.addToList(toAdd);\n+    }\n+\n+    //\n+    //\n+    // Methods from section 12.4.4 in the spec\n+    //\n+    //\n+\n+    @Override\n+    XMLList child(int index) {\n+        XMLList result = newXMLList();\n+\n+        for (int i = 0; i < length(); i++) {\n+            result.addToList(getXmlFromAnnotation(i).child(index));\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    XMLList child(XMLName xmlName) {\n+        XMLList result = newXMLList();\n+\n+        for (int i = 0; i < length(); i++) {\n+            result.addToList(getXmlFromAnnotation(i).child(xmlName));\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    void addMatches(XMLList rv, XMLName name) {\n+        for (int i=0; i<length(); i++) {\n+            getXmlFromAnnotation(i).addMatches(rv, name);\n+        }\n+    }\n+\n+    @Override\n+    XMLList children() {\n+        ArrayList<XML> list = new ArrayList<XML>();\n+\n+        for (int i = 0; i < length(); i++) {\n+            XML xml = getXmlFromAnnotation(i);\n+\n+            if (xml != null) {\n+                XMLList childList = xml.children();\n+\n+                int cChildren = childList.length();\n+                for (int j = 0; j < cChildren; j++) {\n+                    list.add(childList.item(j));\n+                }\n+            }\n+        }\n+\n+        XMLList allChildren = newXMLList();\n+        int sz = list.size();\n+\n+        for (int i = 0; i < sz; i++) {\n+            allChildren.addToList(list.get(i));\n+        }\n+\n+        return allChildren;\n+    }\n+\n+    @Override\n+    XMLList comments() {\n+        XMLList result = newXMLList();\n+\n+        for (int i = 0; i < length(); i++) {\n+            XML xml = getXmlFromAnnotation(i);\n+            result.addToList(xml.comments());\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    XMLList elements(XMLName name) {\n+        XMLList rv = newXMLList();\n+        for (int i=0; i<length(); i++) {\n+            XML xml = getXmlFromAnnotation(i);\n+            rv.addToList(xml.elements(name));\n+        }\n+        return rv;\n+    }\n+\n+    @Override\n+    boolean contains(Object xml) {\n+        boolean result = false;\n+\n+        for (int i = 0; i < length(); i++) {\n+            XML member = getXmlFromAnnotation(i);\n+\n+            if (member.equivalentXml(xml)) {\n+                result = true;\n+                break;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    XMLObjectImpl copy() {\n+        XMLList result = newXMLList();\n+\n+        for (int i = 0; i < length(); i++) {\n+            XML xml = getXmlFromAnnotation(i);\n+            result.addToList(xml.copy());\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    boolean hasOwnProperty(XMLName xmlName) {\n+        if (isPrototype()) {\n+            String property = xmlName.localName();\n+            return (findPrototypeId(property) != 0);\n+        } else {\n+            return (getPropertyList(xmlName).length() > 0);\n+        }\n+    }\n+\n+    @Override\n+    boolean hasComplexContent() {\n+        boolean complexContent;\n+        int length = length();\n+\n+        if (length == 0) {\n+            complexContent = false;\n+        } else if (length == 1) {\n+            complexContent = getXmlFromAnnotation(0).hasComplexContent();\n+        } else {\n+            complexContent = false;\n+\n+            for (int i = 0; i < length; i++) {\n+                XML nextElement = getXmlFromAnnotation(i);\n+                if (nextElement.isElement()) {\n+                    complexContent = true;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return complexContent;\n+    }\n+\n+    @Override\n+    boolean hasSimpleContent() {\n+        if (length() == 0) {\n+            return true;\n+        } else if (length() == 1) {\n+            return getXmlFromAnnotation(0).hasSimpleContent();\n+        } else {\n+            for (int i=0; i<length(); i++) {\n+                XML nextElement = getXmlFromAnnotation(i);\n+                if (nextElement.isElement()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    int length() {\n+        int result = 0;\n+\n+        if (_annos != null) {\n+            result = _annos.length();\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    void normalize() {\n+        for (int i = 0; i < length(); i++) {\n+            getXmlFromAnnotation(i).normalize();\n+        }\n+    }\n+\n+    /**\n+     * If list is empty, return undefined, if elements have different parents return undefined,\n+     * If they all have the same parent, return that parent\n+     */\n+    @Override\n+    Object parent() {\n+        if (length() == 0) return Undefined.instance;\n+\n+        XML candidateParent = null;\n+\n+        for (int i = 0; i < length(); i++) {\n+            Object currParent = getXmlFromAnnotation(i).parent();\n+            if (!(currParent instanceof XML)) return Undefined.instance;\n+            XML xml = (XML)currParent;\n+            if (i == 0) {\n+                // Set the first for the rest to compare to.\n+                candidateParent = xml;\n+            } else {\n+                if (candidateParent.is(xml)) {\n+                    //    keep looking\n+                } else {\n+                    return Undefined.instance;\n+                }\n+            }\n+        }\n+        return candidateParent;\n+    }\n+\n+    @Override\n+    XMLList processingInstructions(XMLName xmlName) {\n+        XMLList result = newXMLList();\n+\n+        for (int i = 0; i < length(); i++) {\n+            XML xml = getXmlFromAnnotation(i);\n+\n+            result.addToList(xml.processingInstructions(xmlName));\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    boolean propertyIsEnumerable(Object name) {\n+        long index;\n+        if (name instanceof Integer) {\n+            index = ((Integer)name).intValue();\n+        } else if (name instanceof Number) {\n+            double x = ((Number)name).doubleValue();\n+            index = (long)x;\n+            if (index != x) {\n+                return false;\n+            }\n+            if (index == 0 && 1.0 / x < 0) {\n+                // Negative 0\n+                return false;\n+            }\n+        } else {\n+            String s = ScriptRuntime.toString(name);\n+            index = ScriptRuntime.testUint32String(s);\n+        }\n+        return (0 <= index && index < length());\n+    }\n+\n+    @Override\n+    XMLList text() {\n+        XMLList result = newXMLList();\n+\n+        for (int i = 0; i < length(); i++) {\n+            result.addToList(getXmlFromAnnotation(i).text());\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        //    ECMA357 10.1.2\n+        if (hasSimpleContent()) {\n+            StringBuffer sb = new StringBuffer();\n+\n+            for(int i = 0; i < length(); i++) {\n+                XML next = getXmlFromAnnotation(i);\n+                if (next.isComment() || next.isProcessingInstruction()) {\n+                    //    do nothing\n+                } else {\n+                    sb.append(next.toString());\n+                }\n+            }\n+\n+            return sb.toString();\n+        } else {\n+            return toXMLString();\n+        }\n+    }\n+\n+    @Override\n+    String toSource(int indent) {\n+        return toXMLString();\n+    }\n+\n+    @Override\n+    String toXMLString() {\n+        //    See ECMA 10.2.1\n+        StringBuffer sb = new StringBuffer();\n+\n+        for (int i=0; i<length(); i++) {\n+            if (getProcessor().isPrettyPrinting() && i != 0) {\n+                sb.append('\\n');\n+            }\n+            sb.append(getXmlFromAnnotation(i).toXMLString());\n+        }\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    Object valueOf() {\n+        return this;\n+    }\n+\n+    //\n+    // Other public Functions from XMLObject\n+    //\n+\n+    @Override\n+    boolean equivalentXml(Object target) {\n+        boolean result = false;\n+\n+        // Zero length list should equate to undefined\n+        if (target instanceof Undefined && length() == 0) {\n+            result = true;\n+        } else if (length() == 1) {\n+            result = getXmlFromAnnotation(0).equivalentXml(target);\n+        } else if (target instanceof XMLList) {\n+            XMLList otherList = (XMLList) target;\n+\n+            if (otherList.length() == length()) {\n+                result = true;\n+\n+                for (int i = 0; i < length(); i++) {\n+                    if (!getXmlFromAnnotation(i).equivalentXml(otherList.getXmlFromAnnotation(i))) {\n+                        result = false;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private XMLList getPropertyList(XMLName name) {\n+        XMLList propertyList = newXMLList();\n+        XmlNode.QName qname = null;\n+\n+        if (!name.isDescendants() && !name.isAttributeName()) {\n+            // Only set the targetProperty if this is a regular child get\n+            // and not a descendant or attribute get\n+            qname = name.toQname();\n+        }\n+\n+        propertyList.setTargets(this, qname);\n+\n+        for (int i = 0; i < length(); i++) {\n+            propertyList.addToList(\n+                getXmlFromAnnotation(i).getPropertyList(name));\n+        }\n+\n+        return propertyList;\n+    }\n+\n+    private Object applyOrCall(boolean isApply,\n+        Context cx, Scriptable scope,\n+        Scriptable thisObj, Object[] args) {\n+        String methodName = isApply ? \"apply\" : \"call\";\n+        if(!(thisObj instanceof XMLList) ||\n+            ((XMLList)thisObj).targetProperty == null)\n+            throw ScriptRuntime.typeError1(\"msg.isnt.function\",\n+                methodName);\n+\n+        return ScriptRuntime.applyOrCall(isApply, cx, scope, thisObj, args);\n+    }\n+\n+    @Override\n+    protected Object jsConstructor(Context cx, boolean inNewExpr,\n+                                   Object[] args)\n+    {\n+        if (args.length == 0) {\n+            return newXMLList();\n+        } else {\n+            Object arg0 = args[0];\n+            if (!inNewExpr && arg0 instanceof XMLList) {\n+                // XMLList(XMLList) returns the same object.\n+                return arg0;\n+            }\n+            return newXMLListFrom(arg0);\n+        }\n+    }\n+\n+    /**\n+     * See ECMA 357, 11_2_2_1, Semantics, 3_e.\n+     */\n+    @Override\n+    public Scriptable getExtraMethodSource(Context cx) {\n+        if (length() == 1) {\n+            return getXmlFromAnnotation(0);\n+        }\n+        return null;\n+    }\n+\n+    public Object call(Context cx, Scriptable scope, Scriptable thisObj,\n+        Object[] args) {\n+        // This XMLList is being called as a Function.\n+        // Let's find the real Function object.\n+        if(targetProperty == null)\n+            throw ScriptRuntime.notFunctionError(this);\n+\n+        String methodName = targetProperty.getLocalName();\n+\n+        boolean isApply = methodName.equals(\"apply\");\n+        if(isApply || methodName.equals(\"call\"))\n+            return applyOrCall(isApply, cx, scope, thisObj, args);\n+\n+        Callable method = ScriptRuntime.getElemFunctionAndThis(\n+            this, methodName, cx);\n+        // Call lastStoredScriptable to clear stored thisObj\n+        // but ignore the result as the method should use the supplied\n+        // thisObj, not one from redirected call\n+        ScriptRuntime.lastStoredScriptable(cx);\n+        return method.call(cx, scope, thisObj, args);\n+    }\n+\n+    public Scriptable construct(Context cx, Scriptable scope, Object[] args) {\n+        throw ScriptRuntime.typeError1(\"msg.not.ctor\", \"XMLList\");\n+    }\n+}\n+\n+\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLName.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Milen Nankov\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xmlimpl;\n+\n+import org.mozilla.javascript.*;\n+\n+class XMLName extends Ref {\n+    static final long serialVersionUID = 3832176310755686977L;\n+\n+    private static boolean isNCNameStartChar(int c) {\n+        if ((c & ~0x7F) == 0) {\n+            // Optimize for ASCII and use A..Z < _ < a..z\n+            if (c >= 'a') {\n+                return c <= 'z';\n+            } else if (c >= 'A') {\n+                if (c <= 'Z') {\n+                    return true;\n+                }\n+                return c == '_';\n+            }\n+        } else if ((c & ~0x1FFF) == 0) {\n+            return (0xC0 <= c && c <= 0xD6)\n+            || (0xD8 <= c && c <= 0xF6)\n+            || (0xF8 <= c && c <= 0x2FF)\n+            || (0x370 <= c && c <= 0x37D)\n+            || 0x37F <= c;\n+        }\n+        return (0x200C <= c && c <= 0x200D)\n+        || (0x2070 <= c && c <= 0x218F)\n+        || (0x2C00 <= c && c <= 0x2FEF)\n+        || (0x3001 <= c && c <= 0xD7FF)\n+        || (0xF900 <= c && c <= 0xFDCF)\n+        || (0xFDF0 <= c && c <= 0xFFFD)\n+        || (0x10000 <= c && c <= 0xEFFFF);\n+    }\n+\n+    private static boolean isNCNameChar(int c) {\n+        if ((c & ~0x7F) == 0) {\n+            // Optimize for ASCII and use - < . < 0..9 < A..Z < _ < a..z\n+            if (c >= 'a') {\n+                return c <= 'z';\n+            } else if (c >= 'A') {\n+                if (c <= 'Z') {\n+                    return true;\n+                }\n+                return c == '_';\n+            } else if (c >= '0') {\n+                return c <= '9';\n+            } else {\n+                return c == '-' || c == '.';\n+            }\n+        } else if ((c & ~0x1FFF) == 0) {\n+            return isNCNameStartChar(c) || c == 0xB7\n+                || (0x300 <= c && c <= 0x36F);\n+        }\n+        return isNCNameStartChar(c) || (0x203F <= c && c <= 0x2040);\n+    }\n+\n+    //    This means \"accept\" in the parsing sense\n+    //    See ECMA357 13.1.2.1\n+    static boolean accept(Object nameObj) {\n+        String name;\n+        try {\n+            name = ScriptRuntime.toString(nameObj);\n+        } catch (EcmaError ee) {\n+            if (\"TypeError\".equals(ee.getName())) {\n+                return false;\n+            }\n+            throw ee;\n+        }\n+\n+        // See http://w3.org/TR/xml-names11/#NT-NCName\n+        int length = name.length();\n+        if (length != 0) {\n+            if (isNCNameStartChar(name.charAt(0))) {\n+                for (int i = 1; i != length; ++i) {\n+                    if (!isNCNameChar(name.charAt(i))) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private XmlNode.QName qname;\n+    private boolean isAttributeName;\n+    private boolean isDescendants;\n+    private XMLObjectImpl xmlObject;\n+\n+    private XMLName() {\n+    }\n+\n+    static XMLName formStar() {\n+        XMLName rv = new XMLName();\n+        rv.qname = XmlNode.QName.create(null, null);\n+        return rv;\n+    }\n+\n+    /** @deprecated */\n+    static XMLName formProperty(XmlNode.Namespace namespace, String localName) {\n+        if (localName != null && localName.equals(\"*\")) localName = null;\n+        XMLName rv = new XMLName();\n+        rv.qname = XmlNode.QName.create(namespace, localName);\n+        return rv;\n+    }\n+\n+    /** TODO: marked deprecated by original author */\n+    static XMLName formProperty(String uri, String localName) {\n+        return formProperty(XmlNode.Namespace.create(uri), localName);\n+    }\n+\n+    /** TODO: marked deprecated by original implementor */\n+    static XMLName create(String defaultNamespaceUri, String name) {\n+        if (name == null)\n+            throw new IllegalArgumentException();\n+\n+        int l = name.length();\n+        if (l != 0) {\n+            char firstChar = name.charAt(0);\n+            if (firstChar == '*') {\n+                if (l == 1) {\n+                    return XMLName.formStar();\n+                }\n+            } else if (firstChar == '@') {\n+                XMLName xmlName = XMLName.formProperty(\"\", name.substring(1));\n+                xmlName.setAttributeName();\n+                return xmlName;\n+            }\n+        }\n+\n+        return XMLName.formProperty(defaultNamespaceUri, name);\n+    }\n+\n+    static XMLName create(XmlNode.QName qname, boolean attribute, boolean descendants) {\n+        XMLName rv = new XMLName();\n+        rv.qname = qname;\n+        rv.isAttributeName = attribute;\n+        rv.isDescendants = descendants;\n+        return rv;\n+    }\n+\n+    /** @deprecated */\n+    static XMLName create(XmlNode.QName qname) {\n+        return create(qname, false, false);\n+    }\n+\n+    void initXMLObject(XMLObjectImpl xmlObject) {\n+        if (xmlObject == null) throw new IllegalArgumentException();\n+        if (this.xmlObject != null) throw new IllegalStateException();\n+        this.xmlObject = xmlObject;\n+    }\n+\n+    String uri() {\n+        if (qname.getNamespace() == null) return null;\n+        return qname.getNamespace().getUri();\n+    }\n+\n+    String localName() {\n+        if (qname.getLocalName() == null) return \"*\";\n+        return qname.getLocalName();\n+    }\n+\n+    private void addDescendantChildren(XMLList list, XML target) {\n+        XMLName xmlName = this;\n+        if (target.isElement()) {\n+            XML[] children = target.getChildren();\n+            for (int i=0; i<children.length; i++) {\n+                if (xmlName.matches( children[i] )) {\n+                    list.addToList( children[i] );\n+                }\n+                addDescendantChildren(list, children[i]);\n+            }\n+        }\n+    }\n+\n+    void addMatchingAttributes(XMLList list, XML target) {\n+        XMLName name = this;\n+        if (target.isElement()) {\n+            XML[] attributes = target.getAttributes();\n+            for (int i=0; i<attributes.length; i++) {\n+                if (name.matches( attributes[i]) ) {\n+                    list.addToList( attributes[i] );\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addDescendantAttributes(XMLList list, XML target) {\n+        if (target.isElement()) {\n+            addMatchingAttributes(list, target);\n+            XML[] children = target.getChildren();\n+            for (int i=0; i<children.length; i++) {\n+                addDescendantAttributes(list, children[i]);\n+            }\n+        }\n+    }\n+\n+    XMLList matchDescendantAttributes(XMLList rv, XML target) {\n+        rv.setTargets(target, null);\n+        addDescendantAttributes(rv, target);\n+        return rv;\n+    }\n+\n+    XMLList matchDescendantChildren(XMLList rv, XML target) {\n+        rv.setTargets(target, null);\n+        addDescendantChildren(rv, target);\n+        return rv;\n+    }\n+\n+    void addDescendants(XMLList rv, XML target) {\n+        XMLName xmlName = this;\n+        if (xmlName.isAttributeName()) {\n+            matchDescendantAttributes(rv, target);\n+        } else {\n+            matchDescendantChildren(rv, target);\n+        }\n+    }\n+\n+    private void addAttributes(XMLList rv, XML target) {\n+        addMatchingAttributes(rv, target);\n+    }\n+\n+    void addMatches(XMLList rv, XML target) {\n+        if (isDescendants()) {\n+            addDescendants(rv, target);\n+        } else if (isAttributeName()) {\n+            addAttributes(rv, target);\n+        } else {\n+            XML[] children = target.getChildren();\n+            if (children != null) {\n+                for (int i=0; i<children.length; i++) {\n+                    if (this.matches(children[i])) {\n+                        rv.addToList( children[i] );\n+                    }\n+                }\n+            }\n+            rv.setTargets(target, this.toQname());\n+        }\n+    }\n+\n+    XMLList getMyValueOn(XML target) {\n+        XMLList rv = target.newXMLList();\n+        addMatches(rv, target);\n+        return rv;\n+    }\n+\n+    void setMyValueOn(XML target, Object value) {\n+        // Special-case checks for undefined and null\n+        if (value == null) {\n+            value = \"null\";\n+        } else if (value instanceof Undefined) {\n+            value = \"undefined\";\n+        }\n+\n+        XMLName xmlName = this;\n+        // Get the named property\n+        if (xmlName.isAttributeName()) {\n+            target.setAttribute(xmlName, value);\n+        } else if (xmlName.uri() == null && xmlName.localName().equals(\"*\")) {\n+            target.setChildren(value);\n+        } else {\n+            // Convert text into XML if needed.\n+            XMLObjectImpl xmlValue = null;\n+\n+            if (value instanceof XMLObjectImpl) {\n+                xmlValue = (XMLObjectImpl)value;\n+\n+                // Check for attribute type and convert to textNode\n+                if (xmlValue instanceof XML) {\n+                    if (((XML)xmlValue).isAttribute()) {\n+                        xmlValue = target.makeXmlFromString(xmlName,\n+                                xmlValue.toString());\n+                    }\n+                }\n+\n+                if (xmlValue instanceof XMLList) {\n+                    for (int i = 0; i < xmlValue.length(); i++) {\n+                        XML xml = ((XMLList) xmlValue).item(i);\n+\n+                        if (xml.isAttribute()) {\n+                            ((XMLList)xmlValue).replace(i, target.makeXmlFromString(xmlName, xml.toString()));\n+                        }\n+                    }\n+                }\n+            } else {\n+                xmlValue = target.makeXmlFromString(xmlName, ScriptRuntime.toString(value));\n+            }\n+\n+            XMLList matches = target.getPropertyList(xmlName);\n+\n+            if (matches.length() == 0) {\n+                target.appendChild(xmlValue);\n+            } else {\n+                // Remove all other matches\n+                for (int i = 1; i < matches.length(); i++) {\n+                    target.removeChild(matches.item(i).childIndex());\n+                }\n+\n+                // Replace first match with new value.\n+                XML firstMatch = matches.item(0);\n+                target.replace(firstMatch.childIndex(), xmlValue);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean has(Context cx) {\n+        if (xmlObject == null) {\n+            return false;\n+        }\n+        return xmlObject.hasXMLProperty(this);\n+    }\n+\n+    @Override\n+    public Object get(Context cx) {\n+        if (xmlObject == null) {\n+            throw ScriptRuntime.undefReadError(Undefined.instance,\n+                toString());\n+        }\n+        return xmlObject.getXMLProperty(this);\n+    }\n+\n+    @Override\n+    public Object set(Context cx, Object value) {\n+        if (xmlObject == null) {\n+            throw ScriptRuntime.undefWriteError(Undefined.instance,\n+                toString(),\n+                value);\n+        }\n+        // Assignment to descendants causes parse error on bad reference\n+        // and this should not be called\n+        if (isDescendants) throw Kit.codeBug();\n+        xmlObject.putXMLProperty(this, value);\n+        return value;\n+    }\n+\n+    @Override\n+    public boolean delete(Context cx) {\n+        if (xmlObject == null) {\n+            return true;\n+        }\n+        xmlObject.deleteXMLProperty(this);\n+        return !xmlObject.hasXMLProperty(this);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        //return qname.localName();\n+        StringBuffer buff = new StringBuffer();\n+        if (isDescendants) buff.append(\"..\");\n+        if (isAttributeName) buff.append('@');\n+        if (uri() == null) {\n+            buff.append('*');\n+            if(localName().equals(\"*\")) {\n+                return buff.toString();\n+            }\n+        } else {\n+            buff.append('\"').append(uri()).append('\"');\n+        }\n+        buff.append(':').append(localName());\n+        return buff.toString();\n+    }\n+\n+    final XmlNode.QName toQname() {\n+        return this.qname;\n+    }\n+\n+    final boolean matchesLocalName(String localName) {\n+        return localName().equals(\"*\") || localName().equals(localName);\n+    }\n+\n+    final boolean matchesElement(XmlNode.QName qname) {\n+        if (this.uri() == null || this.uri().equals(qname.getNamespace().getUri())) {\n+            if (this.localName().equals(\"*\") || this.localName().equals(qname.getLocalName())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    final boolean matches(XML node) {\n+        XmlNode.QName qname = node.getNodeQname();\n+        String nodeUri = null;\n+        if (qname.getNamespace() != null) {\n+            nodeUri = qname.getNamespace().getUri();\n+        }\n+        if (isAttributeName) {\n+            if (node.isAttribute()) {\n+                if (this.uri() == null || this.uri().equals(nodeUri)) {\n+                    if (this.localName().equals(\"*\") || this.localName().equals(qname.getLocalName())) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            } else {\n+                //    TODO    Could throw exception maybe, should not call this method on attribute name with arbitrary node type\n+                //            unless we traverse all attributes and children habitually\n+                return false;\n+            }\n+        } else {\n+            if ( this.uri() == null || ((node.isElement()) && this.uri().equals(nodeUri)) ) {\n+                if (localName().equals(\"*\")) return true;\n+                if (node.isElement()) {\n+                    if (localName().equals(qname.getLocalName())) return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /* TODO: marked deprecated by original author */\n+    boolean isAttributeName() {\n+        return isAttributeName;\n+    }\n+\n+    // TODO Fix whether this is an attribute XMLName at construction?\n+    // Marked deprecated by original author\n+    void setAttributeName() {\n+//        if (isAttributeName) throw new IllegalStateException();\n+        isAttributeName = true;\n+    }\n+\n+    /* TODO: was marked deprecated by original author */\n+    boolean isDescendants() {\n+        return isDescendants;\n+    }\n+\n+    //    TODO    Fix whether this is an descendant XMLName at construction?\n+    /** @deprecated */\n+    void setIsDescendants() {\n+//        if (isDescendants) throw new IllegalStateException();\n+        isDescendants = true;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLObjectImpl.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-2000\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Igor Bukanov\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xmlimpl;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.xml.*;\n+\n+/**\n+ *  This abstract class describes what all XML objects (XML, XMLList) should\n+ *  have in common.\n+ *\n+ * @see XML\n+ */\n+abstract class XMLObjectImpl extends XMLObject {\n+    private static final Object XMLOBJECT_TAG = \"XMLObject\";\n+    private XMLLibImpl lib;\n+    private boolean prototypeFlag;\n+\n+    protected XMLObjectImpl(XMLLibImpl lib, Scriptable scope,\n+                            XMLObject prototype)\n+    {\n+        initialize(lib, scope, prototype);\n+    }\n+\n+    final void initialize(XMLLibImpl lib, Scriptable scope,\n+                          XMLObject prototype)\n+    {\n+        setParentScope(scope);\n+        setPrototype(prototype);\n+        prototypeFlag = (prototype == null);\n+        this.lib = lib;\n+    }\n+\n+    final boolean isPrototype() {\n+        return prototypeFlag;\n+    }\n+\n+    XMLLibImpl getLib() {\n+        return lib;\n+    }\n+\n+    final XML newXML(XmlNode node) {\n+        return lib.newXML(node);\n+    }\n+\n+    XML xmlFromNode(XmlNode node) {\n+        if (node.getXml() == null) {\n+            node.setXml( newXML(node) );\n+        }\n+        return node.getXml();\n+    }\n+\n+    final XMLList newXMLList() {\n+        return lib.newXMLList();\n+    }\n+\n+    final XMLList newXMLListFrom(Object o) {\n+        return lib.newXMLListFrom(o);\n+    }\n+\n+    final XmlProcessor getProcessor() {\n+        return lib.getProcessor();\n+    }\n+\n+    final QName newQName(String uri, String localName, String prefix) {\n+        return lib.newQName(uri, localName, prefix);\n+    }\n+\n+    final QName newQName(XmlNode.QName name) {\n+        return lib.newQName(name);\n+    }\n+\n+    final Namespace createNamespace(XmlNode.Namespace declaration) {\n+        if (declaration == null) return null;\n+        return lib.createNamespaces( new XmlNode.Namespace[] { declaration } )[0];\n+    }\n+\n+    final Namespace[] createNamespaces(XmlNode.Namespace[] declarations) {\n+        return lib.createNamespaces(declarations);\n+    }\n+\n+    //\n+    //    Scriptable\n+    //\n+\n+    @Override\n+    public final Object get(String name, Scriptable start) {\n+        return super.get(name, start);\n+    }\n+\n+    @Override\n+    public final boolean has(String name, Scriptable start) {\n+        return super.has(name, start);\n+    }\n+\n+    @Override\n+    public final void put(String name, Scriptable start, Object value) {\n+        super.put(name, start, value);\n+    }\n+\n+    @Override\n+    public final void delete(String name) {\n+        //    TODO    I am not sure about this, but this is how I found it.  DPC\n+        throw new IllegalArgumentException(\"String: [\" + name + \"]\");\n+    }\n+\n+    @Override\n+    public final Scriptable getPrototype() {\n+        return super.getPrototype();\n+    }\n+\n+    @Override\n+    public final void setPrototype(Scriptable prototype) {\n+        super.setPrototype(prototype);\n+    }\n+\n+    @Override\n+    public final Scriptable getParentScope() {\n+        return super.getParentScope();\n+    }\n+\n+    @Override\n+    public final void setParentScope(Scriptable parent) {\n+        super.setParentScope(parent);\n+    }\n+\n+    @Override\n+    public final Object getDefaultValue(Class<?> hint) {\n+        return this.toString();\n+    }\n+\n+    @Override\n+    public final boolean hasInstance(Scriptable scriptable) {\n+        return super.hasInstance(scriptable);\n+    }\n+\n+    /**\n+     * ecmaHas(cx, id) calls this after resolving when id to XMLName\n+     * and checking it is not Uint32 index.\n+     */\n+    abstract boolean hasXMLProperty(XMLName name);\n+\n+    /**\n+     * ecmaGet(cx, id) calls this after resolving when id to XMLName\n+     * and checking it is not Uint32 index.\n+     */\n+    abstract Object getXMLProperty(XMLName name);\n+\n+    /**\n+     * ecmaPut(cx, id, value) calls this after resolving when id to XMLName\n+     * and checking it is not Uint32 index.\n+     */\n+    abstract void putXMLProperty(XMLName name, Object value);\n+\n+    /**\n+     * ecmaDelete(cx, id) calls this after resolving when id to XMLName\n+     * and checking it is not Uint32 index.\n+     */\n+    abstract void deleteXMLProperty(XMLName name);\n+\n+    /**\n+     * Test XML equality with target the target.\n+     */\n+    abstract boolean equivalentXml(Object target);\n+\n+    abstract void addMatches(XMLList rv, XMLName name);\n+\n+    private XMLList getMatches(XMLName name) {\n+        XMLList rv = newXMLList();\n+        addMatches(rv, name);\n+        return rv;\n+    }\n+\n+    abstract XML getXML();\n+\n+    // Methods from section 12.4.4 in the spec\n+    abstract XMLList child(int index);\n+    abstract XMLList child(XMLName xmlName);\n+    abstract XMLList children();\n+    abstract XMLList comments();\n+    abstract boolean contains(Object xml);\n+    abstract XMLObjectImpl copy();\n+    abstract XMLList elements(XMLName xmlName);\n+    abstract boolean hasOwnProperty(XMLName xmlName);\n+    abstract boolean hasComplexContent();\n+    abstract boolean hasSimpleContent();\n+    abstract int length();\n+    abstract void normalize();\n+    abstract Object parent();\n+    abstract XMLList processingInstructions(XMLName xmlName);\n+    abstract boolean propertyIsEnumerable(Object member);\n+    abstract XMLList text();\n+    @Override\n+    public abstract String toString();\n+    abstract String toSource(int indent);\n+    abstract String toXMLString();\n+    abstract Object valueOf();\n+\n+    protected abstract Object jsConstructor(Context cx, boolean inNewExpr, Object[] args);\n+\n+    final Object getMethod(String id) {\n+        return super.get(id, this);\n+    }\n+\n+    //\n+    //\n+    // Methods overriding ScriptableObject\n+    //\n+    //\n+\n+    /**\n+     * XMLObject always compare with any value and equivalentValues\n+     * never returns {@link Scriptable#NOT_FOUND} for them but rather\n+     * calls equivalentXml(value) and wrap the result as Boolean.\n+     */\n+    @Override\n+    protected final Object equivalentValues(Object value) {\n+        boolean result = equivalentXml(value);\n+        return result ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    //\n+    //\n+    // Methods overriding XMLObject\n+    //\n+    //\n+\n+    /**\n+     * Implementation of ECMAScript [[Has]]\n+     */\n+    @Override\n+    public final boolean ecmaHas(Context cx, Object id) {\n+        if (cx == null) cx = Context.getCurrentContext();\n+        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);\n+        if (xmlName == null) {\n+            long index = ScriptRuntime.lastUint32Result(cx);\n+            // XXX Fix this cast\n+            return has((int)index, this);\n+        }\n+        return hasXMLProperty(xmlName);\n+    }\n+\n+    /**\n+     * Implementation of ECMAScript [[Get]]\n+     */\n+    @Override\n+    public final Object ecmaGet(Context cx, Object id) {\n+        if (cx == null) cx = Context.getCurrentContext();\n+        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);\n+        if (xmlName == null) {\n+            long index = ScriptRuntime.lastUint32Result(cx);\n+            // XXX Fix this cast\n+            Object result = get((int)index, this);\n+            if (result == Scriptable.NOT_FOUND) {\n+                result = Undefined.instance;\n+            }\n+            return result;\n+        }\n+        return getXMLProperty(xmlName);\n+    }\n+\n+    /**\n+     * Implementation of ECMAScript [[Put]]\n+     */\n+    @Override\n+    public final void ecmaPut(Context cx, Object id, Object value) {\n+        if (cx == null) cx = Context.getCurrentContext();\n+        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);\n+        if (xmlName == null) {\n+            long index = ScriptRuntime.lastUint32Result(cx);\n+            // XXX Fix this cast\n+            put((int)index, this, value);\n+            return;\n+        }\n+        putXMLProperty(xmlName, value);\n+    }\n+\n+    /**\n+     * Implementation of ECMAScript [[Delete]].\n+     */\n+    @Override\n+    public final boolean ecmaDelete(Context cx, Object id) {\n+        if (cx == null) cx = Context.getCurrentContext();\n+        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);\n+        if (xmlName == null) {\n+            long index = ScriptRuntime.lastUint32Result(cx);\n+            // XXX Fix this\n+            delete((int)index);\n+            return true;\n+        }\n+        deleteXMLProperty(xmlName);\n+        return true;\n+    }\n+\n+    //    TODO    Can this be made more strongly typed?\n+    @Override\n+    public Ref memberRef(Context cx, Object elem, int memberTypeFlags) {\n+        boolean attribute = (memberTypeFlags & Node.ATTRIBUTE_FLAG) != 0;\n+        boolean descendants = (memberTypeFlags & Node.DESCENDANTS_FLAG) != 0;\n+        if (!attribute && !descendants) {\n+            // Code generation would use ecma(Get|Has|Delete|Set) for\n+            // normal name identifiers so one ATTRIBUTE_FLAG\n+            // or DESCENDANTS_FLAG has to be set\n+            throw Kit.codeBug();\n+        }\n+        XmlNode.QName qname = lib.toNodeQName(cx, elem, attribute);\n+        XMLName rv = XMLName.create(qname, attribute, descendants);\n+        rv.initXMLObject(this);\n+        return rv;\n+    }\n+\n+    /**\n+     * Generic reference to implement x::ns, x.@ns::y, x..@ns::y etc.\n+     */\n+    @Override\n+    public Ref memberRef(Context cx, Object namespace, Object elem,\n+            int memberTypeFlags)\n+    {\n+        boolean attribute = (memberTypeFlags & Node.ATTRIBUTE_FLAG) != 0;\n+        boolean descendants = (memberTypeFlags & Node.DESCENDANTS_FLAG) != 0;\n+        XMLName rv = XMLName.create(lib.toNodeQName(cx, namespace, elem),\n+                attribute, descendants);\n+        rv.initXMLObject(this);\n+        return rv;\n+    }\n+\n+    @Override\n+    public NativeWith enterWith(Scriptable scope) {\n+        return new XMLWithScope(lib, scope, this);\n+    }\n+\n+    @Override\n+    public NativeWith enterDotQuery(Scriptable scope) {\n+        XMLWithScope xws = new XMLWithScope(lib, scope, this);\n+        xws.initAsDotQuery();\n+        return xws;\n+    }\n+\n+    @Override\n+    public final Object addValues(Context cx, boolean thisIsLeft,\n+        Object value) {\n+        if (value instanceof XMLObject) {\n+            XMLObject v1, v2;\n+            if (thisIsLeft) {\n+                v1 = this;\n+                v2 = (XMLObject)value;\n+            } else {\n+                v1 = (XMLObject)value;\n+                v2 = this;\n+            }\n+            return lib.addXMLObjects(cx, v1, v2);\n+        }\n+        if (value == Undefined.instance) {\n+            // both \"xml + undefined\" and \"undefined + xml\" gives String(xml)\n+            return ScriptRuntime.toString(this);\n+        }\n+\n+        return super.addValues(cx, thisIsLeft, value);\n+    }\n+\n+    //\n+    //\n+    // IdScriptableObject machinery\n+    //\n+    //\n+\n+    final void exportAsJSClass(boolean sealed) {\n+        prototypeFlag = true;\n+        exportAsJSClass(MAX_PROTOTYPE_ID, getParentScope(), sealed);\n+    }\n+\n+// #string_id_map#\n+    private final static int\n+        Id_constructor             = 1,\n+\n+        Id_addNamespace            = 2,\n+        Id_appendChild             = 3,\n+        Id_attribute               = 4,\n+        Id_attributes              = 5,\n+        Id_child                   = 6,\n+        Id_childIndex              = 7,\n+        Id_children                = 8,\n+        Id_comments                = 9,\n+        Id_contains                = 10,\n+        Id_copy                    = 11,\n+        Id_descendants             = 12,\n+        Id_elements                = 13,\n+        Id_inScopeNamespaces       = 14,\n+        Id_insertChildAfter        = 15,\n+        Id_insertChildBefore       = 16,\n+        Id_hasOwnProperty          = 17,\n+        Id_hasComplexContent       = 18,\n+        Id_hasSimpleContent        = 19,\n+        Id_length                  = 20,\n+        Id_localName               = 21,\n+        Id_name                    = 22,\n+        Id_namespace               = 23,\n+        Id_namespaceDeclarations   = 24,\n+        Id_nodeKind                = 25,\n+        Id_normalize               = 26,\n+        Id_parent                  = 27,\n+        Id_prependChild            = 28,\n+        Id_processingInstructions  = 29,\n+        Id_propertyIsEnumerable    = 30,\n+        Id_removeNamespace         = 31,\n+        Id_replace                 = 32,\n+        Id_setChildren             = 33,\n+        Id_setLocalName            = 34,\n+        Id_setName                 = 35,\n+        Id_setNamespace            = 36,\n+        Id_text                    = 37,\n+        Id_toString                = 38,\n+        Id_toSource                = 39,\n+        Id_toXMLString             = 40,\n+        Id_valueOf                 = 41,\n+\n+        MAX_PROTOTYPE_ID           = 41;\n+\n+    @Override\n+    protected int findPrototypeId(String s) {\n+        int id;\n+// #generated# Last update: 2008-10-21 12:32:31 MESZ\n+        L0: { id = 0; String X = null; int c;\n+            L: switch (s.length()) {\n+            case 4: c=s.charAt(0);\n+                if (c=='c') { X=\"copy\";id=Id_copy; }\n+                else if (c=='n') { X=\"name\";id=Id_name; }\n+                else if (c=='t') { X=\"text\";id=Id_text; }\n+                break L;\n+            case 5: X=\"child\";id=Id_child; break L;\n+            case 6: c=s.charAt(0);\n+                if (c=='l') { X=\"length\";id=Id_length; }\n+                else if (c=='p') { X=\"parent\";id=Id_parent; }\n+                break L;\n+            case 7: c=s.charAt(0);\n+                if (c=='r') { X=\"replace\";id=Id_replace; }\n+                else if (c=='s') { X=\"setName\";id=Id_setName; }\n+                else if (c=='v') { X=\"valueOf\";id=Id_valueOf; }\n+                break L;\n+            case 8: switch (s.charAt(2)) {\n+                case 'S': c=s.charAt(7);\n+                    if (c=='e') { X=\"toSource\";id=Id_toSource; }\n+                    else if (c=='g') { X=\"toString\";id=Id_toString; }\n+                    break L;\n+                case 'd': X=\"nodeKind\";id=Id_nodeKind; break L;\n+                case 'e': X=\"elements\";id=Id_elements; break L;\n+                case 'i': X=\"children\";id=Id_children; break L;\n+                case 'm': X=\"comments\";id=Id_comments; break L;\n+                case 'n': X=\"contains\";id=Id_contains; break L;\n+                } break L;\n+            case 9: switch (s.charAt(2)) {\n+                case 'c': X=\"localName\";id=Id_localName; break L;\n+                case 'm': X=\"namespace\";id=Id_namespace; break L;\n+                case 'r': X=\"normalize\";id=Id_normalize; break L;\n+                case 't': X=\"attribute\";id=Id_attribute; break L;\n+                } break L;\n+            case 10: c=s.charAt(0);\n+                if (c=='a') { X=\"attributes\";id=Id_attributes; }\n+                else if (c=='c') { X=\"childIndex\";id=Id_childIndex; }\n+                break L;\n+            case 11: switch (s.charAt(0)) {\n+                case 'a': X=\"appendChild\";id=Id_appendChild; break L;\n+                case 'c': X=\"constructor\";id=Id_constructor; break L;\n+                case 'd': X=\"descendants\";id=Id_descendants; break L;\n+                case 's': X=\"setChildren\";id=Id_setChildren; break L;\n+                case 't': X=\"toXMLString\";id=Id_toXMLString; break L;\n+                } break L;\n+            case 12: c=s.charAt(0);\n+                if (c=='a') { X=\"addNamespace\";id=Id_addNamespace; }\n+                else if (c=='p') { X=\"prependChild\";id=Id_prependChild; }\n+                else if (c=='s') {\n+                    c=s.charAt(3);\n+                    if (c=='L') { X=\"setLocalName\";id=Id_setLocalName; }\n+                    else if (c=='N') { X=\"setNamespace\";id=Id_setNamespace; }\n+                }\n+                break L;\n+            case 14: X=\"hasOwnProperty\";id=Id_hasOwnProperty; break L;\n+            case 15: X=\"removeNamespace\";id=Id_removeNamespace; break L;\n+            case 16: c=s.charAt(0);\n+                if (c=='h') { X=\"hasSimpleContent\";id=Id_hasSimpleContent; }\n+                else if (c=='i') { X=\"insertChildAfter\";id=Id_insertChildAfter; }\n+                break L;\n+            case 17: c=s.charAt(3);\n+                if (c=='C') { X=\"hasComplexContent\";id=Id_hasComplexContent; }\n+                else if (c=='c') { X=\"inScopeNamespaces\";id=Id_inScopeNamespaces; }\n+                else if (c=='e') { X=\"insertChildBefore\";id=Id_insertChildBefore; }\n+                break L;\n+            case 20: X=\"propertyIsEnumerable\";id=Id_propertyIsEnumerable; break L;\n+            case 21: X=\"namespaceDeclarations\";id=Id_namespaceDeclarations; break L;\n+            case 22: X=\"processingInstructions\";id=Id_processingInstructions; break L;\n+            }\n+            if (X!=null && X!=s && !X.equals(s)) id = 0;\n+            break L0;\n+        }\n+// #/generated#\n+        return id;\n+    }\n+// #/string_id_map#\n+\n+    @Override\n+    protected void initPrototypeId(int id) {\n+        String s;\n+        int arity;\n+        switch (id) {\n+            case Id_constructor: {\n+                IdFunctionObject ctor;\n+                if (this instanceof XML) {\n+                    ctor = new XMLCtor((XML)this, XMLOBJECT_TAG, id, 1);\n+                } else {\n+                    ctor = new IdFunctionObject(this, XMLOBJECT_TAG, id, 1);\n+                }\n+                initPrototypeConstructor(ctor);\n+                return;\n+            }\n+\n+            case Id_addNamespace:      arity=1; s=\"addNamespace\";      break;\n+            case Id_appendChild:       arity=1; s=\"appendChild\";       break;\n+            case Id_attribute:         arity=1; s=\"attribute\";         break;\n+            case Id_attributes:        arity=0; s=\"attributes\";        break;\n+            case Id_child:             arity=1; s=\"child\";             break;\n+            case Id_childIndex:        arity=0; s=\"childIndex\";        break;\n+            case Id_children:          arity=0; s=\"children\";          break;\n+            case Id_comments:          arity=0; s=\"comments\";          break;\n+            case Id_contains:          arity=1; s=\"contains\";          break;\n+            case Id_copy:              arity=0; s=\"copy\";              break;\n+            case Id_descendants:       arity=1; s=\"descendants\";       break;\n+            case Id_elements:          arity=1; s=\"elements\";          break;\n+            case Id_hasComplexContent: arity=0; s=\"hasComplexContent\"; break;\n+            case Id_hasOwnProperty:    arity=1; s=\"hasOwnProperty\";    break;\n+            case Id_hasSimpleContent:  arity=0; s=\"hasSimpleContent\";  break;\n+            case Id_inScopeNamespaces: arity=0; s=\"inScopeNamespaces\"; break;\n+            case Id_insertChildAfter:  arity=2; s=\"insertChildAfter\";  break;\n+            case Id_insertChildBefore: arity=2; s=\"insertChildBefore\"; break;\n+            case Id_length:            arity=0; s=\"length\";            break;\n+            case Id_localName:         arity=0; s=\"localName\";         break;\n+            case Id_name:              arity=0; s=\"name\";              break;\n+            case Id_namespace:         arity=1; s=\"namespace\";         break;\n+            case Id_namespaceDeclarations:\n+                arity=0; s=\"namespaceDeclarations\"; break;\n+            case Id_nodeKind:          arity=0; s=\"nodeKind\";          break;\n+            case Id_normalize:         arity=0; s=\"normalize\";         break;\n+            case Id_parent:            arity=0; s=\"parent\";            break;\n+            case Id_prependChild:      arity=1; s=\"prependChild\";      break;\n+            case Id_processingInstructions:\n+                arity=1; s=\"processingInstructions\"; break;\n+            case Id_propertyIsEnumerable:\n+                arity=1; s=\"propertyIsEnumerable\"; break;\n+            case Id_removeNamespace:   arity=1; s=\"removeNamespace\";   break;\n+            case Id_replace:           arity=2; s=\"replace\";           break;\n+            case Id_setChildren:       arity=1; s=\"setChildren\";       break;\n+            case Id_setLocalName:      arity=1; s=\"setLocalName\";      break;\n+            case Id_setName:           arity=1; s=\"setName\";           break;\n+            case Id_setNamespace:      arity=1; s=\"setNamespace\";      break;\n+            case Id_text:              arity=0; s=\"text\";              break;\n+            case Id_toString:          arity=0; s=\"toString\";          break;\n+            case Id_toSource:          arity=1; s=\"toSource\";          break;\n+            case Id_toXMLString:       arity=1; s=\"toXMLString\";       break;\n+            case Id_valueOf:           arity=0; s=\"valueOf\";           break;\n+\n+            default: throw new IllegalArgumentException(String.valueOf(id));\n+        }\n+        initPrototypeMethod(XMLOBJECT_TAG, id, s, arity);\n+    }\n+\n+    private Object[] toObjectArray(Object[] typed) {\n+        Object[] rv = new Object[typed.length];\n+        for (int i=0; i<rv.length; i++) {\n+            rv[i] = typed[i];\n+        }\n+        return rv;\n+    }\n+\n+    private void xmlMethodNotFound(Object object, String name) {\n+        throw ScriptRuntime.notFunctionError(object, name);\n+    }\n+\n+    @Override\n+    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,\n+                             Scriptable thisObj, Object[] args)\n+    {\n+        if (!f.hasTag(XMLOBJECT_TAG)) {\n+            return super.execIdCall(f, cx, scope, thisObj, args);\n+        }\n+        int id = f.methodId();\n+        if (id == Id_constructor) {\n+            return jsConstructor(cx, thisObj == null, args);\n+        }\n+\n+        // All (XML|XMLList).prototype methods require thisObj to be XML\n+        if (!(thisObj instanceof XMLObjectImpl))\n+            throw incompatibleCallError(f);\n+        XMLObjectImpl realThis = (XMLObjectImpl)thisObj;\n+\n+        XML xml = realThis.getXML();\n+        switch (id) {\n+            case Id_appendChild: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"appendChild\");\n+                return xml.appendChild(arg(args, 0));\n+            }\n+            case Id_addNamespace: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"addNamespace\");\n+                Namespace ns = lib.castToNamespace(cx, arg(args, 0));\n+                return xml.addNamespace(ns);\n+            }\n+            case Id_childIndex: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"childIndex\");\n+                return ScriptRuntime.wrapInt(xml.childIndex());\n+            }\n+            case Id_inScopeNamespaces: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"inScopeNamespaces\");\n+                return cx.newArray(scope, toObjectArray(xml.inScopeNamespaces()));\n+            }\n+            case Id_insertChildAfter: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"insertChildAfter\");\n+                Object arg0 = arg(args, 0);\n+                if (arg0 == null || arg0 instanceof XML) {\n+                    return xml.insertChildAfter((XML)arg0, arg(args, 1));\n+                }\n+                return Undefined.instance;\n+            }\n+            case Id_insertChildBefore: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"insertChildBefore\");\n+                Object arg0 = arg(args, 0);\n+                if (arg0 == null || arg0 instanceof XML) {\n+                    return xml.insertChildBefore((XML)arg0, arg(args, 1));\n+                }\n+                return Undefined.instance;\n+            }\n+            case Id_localName: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"localName\");\n+                return xml.localName();\n+            }\n+            case Id_name: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"name\");\n+                return xml.name();\n+            }\n+            case Id_namespace: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"namespace\");\n+                String prefix = (args.length > 0) ? ScriptRuntime.toString(args[0]) : null;\n+                Namespace rv = xml.namespace(prefix);\n+                if (rv == null) {\n+                    return Undefined.instance;\n+                } else {\n+                    return rv;\n+                }\n+            }\n+            case Id_namespaceDeclarations: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"namespaceDeclarations\");\n+                Namespace[] array = xml.namespaceDeclarations();\n+                return cx.newArray(scope, toObjectArray(array));\n+            }\n+            case Id_nodeKind: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"nodeKind\");\n+                return xml.nodeKind();\n+            }\n+            case Id_prependChild: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"prependChild\");\n+                return xml.prependChild(arg(args, 0));\n+            }\n+            case Id_removeNamespace: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"removeNamespace\");\n+                Namespace ns = lib.castToNamespace(cx, arg(args, 0));\n+                return xml.removeNamespace(ns);\n+            }\n+            case Id_replace: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"replace\");\n+                XMLName xmlName = lib.toXMLNameOrIndex(cx, arg(args, 0));\n+                Object arg1 = arg(args, 1);\n+                if (xmlName == null) {\n+                    //    I refuse to believe that this number will exceed 2^31\n+                    int index = (int)ScriptRuntime.lastUint32Result(cx);\n+                    return xml.replace(index, arg1);\n+                } else {\n+                    return xml.replace(xmlName, arg1);\n+                }\n+            }\n+            case Id_setChildren: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"setChildren\");\n+                return xml.setChildren(arg(args, 0));\n+            }\n+            case Id_setLocalName: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"setLocalName\");\n+                String localName;\n+                Object arg = arg(args, 0);\n+                if (arg instanceof QName) {\n+                    localName = ((QName)arg).localName();\n+                } else {\n+                    localName = ScriptRuntime.toString(arg);\n+                }\n+                xml.setLocalName(localName);\n+                return Undefined.instance;\n+            }\n+            case Id_setName: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"setName\");\n+                Object arg = (args.length != 0) ? args[0] : Undefined.instance;\n+                QName qname = lib.constructQName(cx, arg);\n+                xml.setName(qname);\n+                return Undefined.instance;\n+            }\n+            case Id_setNamespace: {\n+                if (xml == null) xmlMethodNotFound(realThis, \"setNamespace\");\n+                Namespace ns = lib.castToNamespace(cx, arg(args, 0));\n+                xml.setNamespace(ns);\n+                return Undefined.instance;\n+            }\n+\n+            case Id_attribute: {\n+                XMLName xmlName = XMLName.create( lib.toNodeQName(cx, arg(args, 0), true), true, false );\n+                return realThis.getMatches(xmlName);\n+            }\n+            case Id_attributes:\n+                return realThis.getMatches(XMLName.create(XmlNode.QName.create(null, null), true, false));\n+            case Id_child: {\n+                XMLName xmlName = lib.toXMLNameOrIndex(cx, arg(args, 0));\n+                if (xmlName == null) {\n+                    //    Two billion or so is a fine upper limit, so we cast to int\n+                    int index = (int)ScriptRuntime.lastUint32Result(cx);\n+                    return realThis.child(index);\n+                } else {\n+                    return realThis.child(xmlName);\n+                }\n+            }\n+            case Id_children:\n+                return realThis.children();\n+            case Id_comments:\n+                return realThis.comments();\n+            case Id_contains:\n+                return ScriptRuntime.wrapBoolean(\n+                    realThis.contains(arg(args, 0)));\n+            case Id_copy:\n+                return realThis.copy();\n+            case Id_descendants: {\n+                XmlNode.QName qname = (args.length == 0) ? XmlNode.QName.create(null, null) : lib.toNodeQName(cx, args[0], false);\n+                return realThis.getMatches( XMLName.create(qname, false, true) );\n+            }\n+            case Id_elements: {\n+                XMLName xmlName = (args.length == 0)\n+                ? XMLName.formStar()\n+                : lib.toXMLName(cx, args[0]);\n+                return realThis.elements(xmlName);\n+            }\n+            case Id_hasOwnProperty: {\n+                XMLName xmlName = lib.toXMLName(cx, arg(args, 0));\n+                return ScriptRuntime.wrapBoolean(\n+                    realThis.hasOwnProperty(xmlName));\n+            }\n+            case Id_hasComplexContent:\n+                return ScriptRuntime.wrapBoolean(realThis.hasComplexContent());\n+            case Id_hasSimpleContent:\n+                return ScriptRuntime.wrapBoolean(realThis.hasSimpleContent());\n+            case Id_length:\n+                return ScriptRuntime.wrapInt(realThis.length());\n+            case Id_normalize:\n+                realThis.normalize();\n+                return Undefined.instance;\n+            case Id_parent:\n+                return realThis.parent();\n+            case Id_processingInstructions: {\n+                XMLName xmlName = (args.length > 0)\n+                ? lib.toXMLName(cx, args[0])\n+                : XMLName.formStar();\n+                return realThis.processingInstructions(xmlName);\n+            }\n+            case Id_propertyIsEnumerable: {\n+                return ScriptRuntime.wrapBoolean(\n+                    realThis.propertyIsEnumerable(arg(args, 0)));\n+            }\n+            case Id_text:\n+                return realThis.text();\n+            case Id_toString:\n+                return realThis.toString();\n+            case Id_toSource:\n+                int indent = ScriptRuntime.toInt32(args, 0);\n+                return realThis.toSource(indent);\n+            case Id_toXMLString: {\n+                return realThis.toXMLString();\n+            }\n+            case Id_valueOf:\n+                return realThis.valueOf();\n+        }\n+        throw new IllegalArgumentException(String.valueOf(id));\n+    }\n+\n+    private static Object arg(Object[] args, int i) {\n+        return (i < args.length) ? args[i] : Undefined.instance;\n+    }\n+\n+    final XML newTextElementXML(XmlNode reference, XmlNode.QName qname, String value) {\n+        return lib.newTextElementXML(reference, qname, value);\n+    }\n+\n+    /* TODO: Hopefully this can be replaced with ecmaToXml below. */\n+    final XML newXMLFromJs(Object inputObject) {\n+        return lib.newXMLFromJs(inputObject);\n+    }\n+\n+    final XML ecmaToXml(Object object) {\n+        return lib.ecmaToXml(object);\n+    }\n+\n+    final String ecmaEscapeAttributeValue(String s) {\n+        //    TODO    Check this\n+        String quoted = lib.escapeAttributeValue(s);\n+        return quoted.substring(1, quoted.length() - 1);\n+    }\n+\n+    final XML createEmptyXML() {\n+        return newXML(XmlNode.createEmpty(getProcessor()));\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLWithScope.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Norris Boyd\n+ *   Ethan Hugg\n+ *   Terry Lucas\n+ *   Milen Nankov\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xmlimpl;\n+\n+import org.mozilla.javascript.*;\n+import org.mozilla.javascript.xml.*;\n+\n+final class XMLWithScope extends NativeWith\n+{\n+    private static final long serialVersionUID = -696429282095170887L;\n+\n+    private XMLLibImpl lib;\n+    private int         _currIndex;\n+    private XMLList     _xmlList;\n+    private XMLObject   _dqPrototype;\n+\n+    XMLWithScope(XMLLibImpl lib, Scriptable parent, XMLObject prototype)\n+    {\n+        super(parent, prototype);\n+        this.lib = lib;\n+    }\n+\n+    void initAsDotQuery()\n+    {\n+        XMLObject prototype = (XMLObject)getPrototype();\n+        // XMLWithScope also handles the .(xxx) DotQuery for XML\n+        // basically DotQuery is a for/in/with statement and in\n+        // the following 3 statements we setup to signal it's\n+        // DotQuery,\n+        // the index and the object being looped over.  The\n+        // xws.setPrototype is the scope of the object which is\n+        // is a element of the lhs (XMLList).\n+        _currIndex = 0;\n+        _dqPrototype = prototype;\n+        if (prototype instanceof XMLList) {\n+            XMLList xl = (XMLList)prototype;\n+            if (xl.length() > 0) {\n+                setPrototype((Scriptable)(xl.get(0, null)));\n+            }\n+        }\n+        // Always return the outer-most type of XML lValue of\n+        // XML to left of dotQuery.\n+        _xmlList = lib.newXMLList();\n+    }\n+\n+    @Override\n+    protected Object updateDotQuery(boolean value)\n+    {\n+        // Return null to continue looping\n+\n+        XMLObject seed = _dqPrototype;\n+        XMLList xmlL = _xmlList;\n+\n+        if (seed instanceof XMLList) {\n+            // We're a list so keep testing each element of the list if the\n+            // result on the top of stack is true then that element is added\n+            // to our result list.  If false, we try the next element.\n+            XMLList orgXmlL = (XMLList)seed;\n+\n+            int idx = _currIndex;\n+\n+            if (value) {\n+                xmlL.addToList(orgXmlL.get(idx, null));\n+            }\n+\n+            // More elements to test?\n+            if (++idx < orgXmlL.length()) {\n+                // Yes, set our new index, get the next element and\n+                // reset the expression to run with this object as\n+                // the WITH selector.\n+                _currIndex = idx;\n+                setPrototype((Scriptable)(orgXmlL.get(idx, null)));\n+\n+                // continue looping\n+                return null;\n+            }\n+        } else {\n+            // If we're not a XMLList then there's no looping\n+            // just return DQPrototype if the result is true.\n+            if (value) {\n+              xmlL.addToList(seed);\n+            }\n+        }\n+\n+        return xmlL;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlNode.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino DOM-only E4X implementation.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * David P. Caldwell.\n+ * Portions created by David P. Caldwell are Copyright (C)\n+ * 2007 David P. Caldwell. All Rights Reserved.\n+ *\n+ *\n+ * Contributor(s):\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xmlimpl;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.mozilla.javascript.Undefined;\n+import org.w3c.dom.Attr;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.w3c.dom.ProcessingInstruction;\n+import org.w3c.dom.UserDataHandler;\n+\n+class XmlNode implements Serializable {\n+    private static final String XML_NAMESPACES_NAMESPACE_URI = \"http://www.w3.org/2000/xmlns/\";\n+\n+    private static final String USER_DATA_XMLNODE_KEY = XmlNode.class.getName();\n+\n+    private static final boolean DOM_LEVEL_3 = true;\n+\n+    private static XmlNode getUserData(Node node) {\n+        if (DOM_LEVEL_3) {\n+            return (XmlNode)node.getUserData(USER_DATA_XMLNODE_KEY);\n+        }\n+        return null;\n+    }\n+\n+    private static void setUserData(Node node, XmlNode wrap) {\n+        if (DOM_LEVEL_3) {\n+            node.setUserData(USER_DATA_XMLNODE_KEY, wrap, wrap.events);\n+        }\n+    }\n+\n+    private static XmlNode createImpl(Node node) {\n+        if (node instanceof Document) throw new IllegalArgumentException();\n+        XmlNode rv = null;\n+        if (getUserData(node) == null) {\n+            rv = new XmlNode();\n+            rv.dom = node;\n+            setUserData(node, rv);\n+        } else {\n+            rv = getUserData(node);\n+        }\n+        return rv;\n+    }\n+\n+    static XmlNode newElementWithText(XmlProcessor processor, XmlNode reference, XmlNode.QName qname, String value) {\n+        if (reference instanceof org.w3c.dom.Document) throw new IllegalArgumentException(\"Cannot use Document node as reference\");\n+        Document document = null;\n+        if (reference != null) {\n+            document = reference.dom.getOwnerDocument();\n+        } else {\n+            document = processor.newDocument();\n+        }\n+        Node referenceDom = (reference != null) ? reference.dom : null;\n+        Namespace ns = qname.getNamespace();\n+        Element e = (ns == null || ns.getUri().length() == 0)\n+            ? document.createElementNS(null, qname.getLocalName())\n+            : document.createElementNS(ns.getUri(),\n+                                       qname.qualify(referenceDom));\n+        if (value != null) {\n+            e.appendChild(document.createTextNode(value));\n+        }\n+        return XmlNode.createImpl(e);\n+    }\n+\n+    static XmlNode createText(XmlProcessor processor, String value) {\n+        return createImpl( processor.newDocument().createTextNode(value) );\n+    }\n+\n+    static XmlNode createElementFromNode(Node node) {\n+        if (node instanceof Document)\n+            node = ((Document) node).getDocumentElement();\n+        return createImpl(node);\n+    }\n+\n+    static XmlNode createElement(XmlProcessor processor, String namespaceUri, String xml) throws org.xml.sax.SAXException {\n+        return createImpl( processor.toXml(namespaceUri, xml) );\n+    }\n+\n+    static XmlNode createEmpty(XmlProcessor processor) {\n+        return createText(processor, \"\");\n+    }\n+\n+    private static XmlNode copy(XmlNode other) {\n+        return createImpl( other.dom.cloneNode(true) );\n+    }\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private UserDataHandler events = new XmlNodeUserDataHandler();\n+\n+    private Node dom;\n+\n+    private XML xml;\n+\n+    private XmlNode() {\n+    }\n+\n+    String debug() {\n+        XmlProcessor raw = new XmlProcessor();\n+        raw.setIgnoreComments(false);\n+        raw.setIgnoreProcessingInstructions(false);\n+        raw.setIgnoreWhitespace(false);\n+        raw.setPrettyPrinting(false);\n+        return raw.ecmaToXmlString(this.dom);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"XmlNode: type=\" + dom.getNodeType() + \" dom=\" + dom.toString();\n+    }\n+\n+    XML getXml() {\n+        return xml;\n+    }\n+\n+    void setXml(XML xml) {\n+        this.xml = xml;\n+    }\n+\n+    int getChildCount() {\n+        return this.dom.getChildNodes().getLength();\n+    }\n+\n+    XmlNode parent() {\n+        Node domParent = dom.getParentNode();\n+        if (domParent instanceof Document) return null;\n+        if (domParent == null) return null;\n+        return createImpl(domParent);\n+    }\n+\n+    int getChildIndex() {\n+        if (this.isAttributeType()) return -1;\n+        if (parent() == null) return -1;\n+        org.w3c.dom.NodeList siblings = this.dom.getParentNode().getChildNodes();\n+        for (int i=0; i<siblings.getLength(); i++) {\n+            if (siblings.item(i) == dom) {\n+                return i;\n+            }\n+        }\n+        //    Either the parent is -1 or one of the this node's parent's children is this node.\n+        throw new RuntimeException(\"Unreachable.\");\n+    }\n+\n+    void removeChild(int index) {\n+        this.dom.removeChild( this.dom.getChildNodes().item(index) );\n+    }\n+\n+    String toXmlString(XmlProcessor processor) {\n+        return processor.ecmaToXmlString(this.dom);\n+    }\n+\n+    String ecmaValue() {\n+        //    TODO    See ECMA 357 Section 9.1\n+        if (isTextType()) {\n+            return ((org.w3c.dom.Text)dom).getData();\n+        } else if (isAttributeType()) {\n+            return ((org.w3c.dom.Attr)dom).getValue();\n+        } else if (isProcessingInstructionType()) {\n+            return ((org.w3c.dom.ProcessingInstruction)dom).getData();\n+        } else if (isCommentType()) {\n+            return ((org.w3c.dom.Comment)dom).getNodeValue();\n+        } else if (isElementType()) {\n+            throw new RuntimeException(\"Unimplemented ecmaValue() for elements.\");\n+        } else {\n+            throw new RuntimeException(\"Unimplemented for node \" + dom);\n+        }\n+    }\n+\n+    void deleteMe() {\n+        if (dom instanceof Attr) {\n+            Attr attr = (Attr)this.dom;\n+            attr.getOwnerElement().getAttributes().removeNamedItemNS(attr.getNamespaceURI(), attr.getLocalName());\n+        } else {\n+            if (this.dom.getParentNode() != null) {\n+                this.dom.getParentNode().removeChild(this.dom);\n+            } else {\n+                //    This case can be exercised at least when executing the regression\n+                //    tests under https://bugzilla.mozilla.org/show_bug.cgi?id=354145\n+            }\n+        }\n+    }\n+\n+    void normalize() {\n+        this.dom.normalize();\n+    }\n+\n+    void insertChildAt(int index, XmlNode node) {\n+        Node parent = this.dom;\n+        Node child = parent.getOwnerDocument().importNode( node.dom, true );\n+        if (parent.getChildNodes().getLength() < index) {\n+            //    TODO    Check ECMA for what happens here\n+            throw new IllegalArgumentException(\"index=\" + index + \" length=\" + parent.getChildNodes().getLength());\n+        }\n+        if (parent.getChildNodes().getLength() == index) {\n+            parent.appendChild(child);\n+        } else {\n+            parent.insertBefore(child, parent.getChildNodes().item(index));\n+        }\n+    }\n+\n+    void insertChildrenAt(int index, XmlNode[] nodes) {\n+        for (int i=0; i<nodes.length; i++) {\n+            insertChildAt(index+i, nodes[i]);\n+        }\n+    }\n+\n+    XmlNode getChild(int index) {\n+        Node child = dom.getChildNodes().item(index);\n+        return createImpl(child);\n+    }\n+\n+    //    Helper method for XML.hasSimpleContent()\n+    boolean hasChildElement() {\n+        org.w3c.dom.NodeList nodes = this.dom.getChildNodes();\n+        for (int i=0; i<nodes.getLength(); i++) {\n+            if (nodes.item(i).getNodeType() == org.w3c.dom.Node.ELEMENT_NODE) return true;\n+        }\n+        return false;\n+    }\n+\n+    boolean isSameNode(XmlNode other) {\n+        //    TODO    May need to be changed if we allow XmlNode to refer to several Node objects\n+        return this.dom == other.dom;\n+    }\n+\n+    private String toUri(String ns) {\n+        return (ns == null) ? \"\" : ns;\n+    }\n+\n+    private void addNamespaces(Namespaces rv, Element element) {\n+        if (element == null) throw new RuntimeException(\"element must not be null\");\n+        String myDefaultNamespace = toUri(element.lookupNamespaceURI(null));\n+        String parentDefaultNamespace = \"\";\n+        if (element.getParentNode() != null) {\n+            parentDefaultNamespace = toUri(element.getParentNode().lookupNamespaceURI(null));\n+        }\n+        if (!myDefaultNamespace.equals(parentDefaultNamespace) || !(element.getParentNode() instanceof Element) ) {\n+            rv.declare(Namespace.create(\"\", myDefaultNamespace));\n+        }\n+        NamedNodeMap attributes = element.getAttributes();\n+        for (int i=0; i<attributes.getLength(); i++) {\n+            Attr attr = (Attr)attributes.item(i);\n+            if (attr.getPrefix() != null && attr.getPrefix().equals(\"xmlns\")) {\n+                rv.declare(Namespace.create(attr.getLocalName(), attr.getValue()));\n+            }\n+        }\n+    }\n+\n+    private Namespaces getAllNamespaces() {\n+        Namespaces rv = new Namespaces();\n+\n+        Node target = this.dom;\n+        if (target instanceof Attr) {\n+            target = ((Attr)target).getOwnerElement();\n+        }\n+        while(target != null) {\n+            if (target instanceof Element) {\n+                addNamespaces(rv, (Element)target);\n+            }\n+            target = target.getParentNode();\n+        }\n+        //    Fallback in case no namespace was declared\n+        rv.declare(Namespace.create(\"\", \"\"));\n+        return rv;\n+    }\n+\n+    Namespace[] getInScopeNamespaces() {\n+        Namespaces rv = getAllNamespaces();\n+        return rv.getNamespaces();\n+    }\n+\n+    Namespace[] getNamespaceDeclarations() {\n+        //    ECMA357 13.4.4.24\n+        if (this.dom instanceof Element) {\n+            Namespaces rv = new Namespaces();\n+            addNamespaces( rv, (Element)this.dom );\n+            return rv.getNamespaces();\n+        } else {\n+            return new Namespace[0];\n+        }\n+    }\n+\n+    Namespace getNamespaceDeclaration(String prefix) {\n+        if (prefix.equals(\"\") && dom instanceof Attr) {\n+            //    Default namespaces do not apply to attributes; see XML Namespaces section 5.2\n+            return Namespace.create(\"\", \"\");\n+        }\n+        Namespaces rv = getAllNamespaces();\n+        return rv.getNamespace(prefix);\n+    }\n+\n+    Namespace getNamespaceDeclaration() {\n+        if (dom.getPrefix() == null) return getNamespaceDeclaration(\"\");\n+        return getNamespaceDeclaration(dom.getPrefix());\n+    }\n+\n+    static class XmlNodeUserDataHandler implements UserDataHandler, Serializable {\n+        private static final long serialVersionUID = 4666895518900769588L;\n+\n+        public void handle(short operation, String key, Object data, Node src, Node dest) {\n+        }\n+    }\n+\n+    private static class Namespaces {\n+        private Map<String,String> map = new HashMap<String,String>();\n+        private Map<String,String> uriToPrefix = new HashMap<String,String>();\n+\n+        Namespaces() {\n+        }\n+\n+        void declare(Namespace n) {\n+            if (map.get(n.prefix) == null) {\n+                map.put(n.prefix, n.uri);\n+            }\n+            //    TODO    I think this is analogous to the other way, but have not really thought it through ... should local scope\n+            //            matter more than outer scope?\n+            if (uriToPrefix.get(n.uri) == null) {\n+                uriToPrefix.put(n.uri, n.prefix);\n+            }\n+        }\n+\n+        Namespace getNamespaceByUri(String uri) {\n+            if (uriToPrefix.get(uri) == null) return null;\n+            return Namespace.create(uri, uriToPrefix.get(uri));\n+        }\n+\n+        Namespace getNamespace(String prefix) {\n+            if (map.get(prefix) == null) return null;\n+            return Namespace.create(prefix, map.get(prefix));\n+        }\n+\n+        Namespace[] getNamespaces() {\n+            ArrayList<Namespace> rv = new ArrayList<Namespace>();\n+            for (String prefix: map.keySet()) {\n+                String uri = map.get(prefix);\n+                Namespace n = Namespace.create(prefix, uri);\n+                if (!n.isEmpty()) {\n+                    rv.add(n);\n+                }\n+            }\n+            return rv.toArray(new Namespace[rv.size()]);\n+        }\n+    }\n+\n+    final XmlNode copy() {\n+        return copy( this );\n+    }\n+\n+    //    Returns whether this node is capable of being a parent\n+    final boolean isParentType() {\n+        return isElementType();\n+    }\n+\n+    final boolean isTextType() {\n+        return dom.getNodeType() == Node.TEXT_NODE || dom.getNodeType() == Node.CDATA_SECTION_NODE;\n+    }\n+\n+    final boolean isAttributeType() {\n+        return dom.getNodeType() == Node.ATTRIBUTE_NODE;\n+    }\n+\n+    final boolean isProcessingInstructionType() {\n+        return dom.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE;\n+    }\n+\n+    final boolean isCommentType() {\n+        return dom.getNodeType() == Node.COMMENT_NODE;\n+    }\n+\n+    final boolean isElementType() {\n+        return dom.getNodeType() == Node.ELEMENT_NODE;\n+    }\n+\n+    final void renameNode(QName qname) {\n+        this.dom = dom.getOwnerDocument().renameNode(dom, qname.getNamespace().getUri(), qname.qualify(dom));\n+    }\n+\n+    void invalidateNamespacePrefix() {\n+        if (!(dom instanceof Element)) throw new IllegalStateException();\n+        String prefix = this.dom.getPrefix();\n+        QName after = QName.create(this.dom.getNamespaceURI(), this.dom.getLocalName(), null);\n+        renameNode(after);\n+        NamedNodeMap attrs = this.dom.getAttributes();\n+        for (int i=0; i<attrs.getLength(); i++) {\n+            if (attrs.item(i).getPrefix().equals(prefix)) {\n+                createImpl( attrs.item(i) ).renameNode( QName.create(attrs.item(i).getNamespaceURI(), attrs.item(i).getLocalName(), null) );\n+            }\n+        }\n+    }\n+\n+    private void declareNamespace(Element e, String prefix, String uri) {\n+        if (prefix.length() > 0) {\n+            e.setAttributeNS(XML_NAMESPACES_NAMESPACE_URI, \"xmlns:\" + prefix, uri);\n+        } else {\n+            e.setAttribute(\"xmlns\", uri);\n+        }\n+    }\n+\n+    void declareNamespace(String prefix, String uri) {\n+        if (!(dom instanceof Element)) throw new IllegalStateException();\n+        if (dom.lookupNamespaceURI(uri) != null && dom.lookupNamespaceURI(uri).equals(prefix)) {\n+            //    do nothing\n+        } else {\n+            Element e = (Element)dom;\n+            declareNamespace(e, prefix, uri);\n+        }\n+    }\n+\n+    private Namespace getDefaultNamespace() {\n+        String prefix = \"\";\n+        String uri = (dom.lookupNamespaceURI(null) == null) ? \"\" : dom.lookupNamespaceURI(null);\n+        return Namespace.create(prefix, uri);\n+    }\n+\n+    private String getExistingPrefixFor(Namespace namespace) {\n+        if (getDefaultNamespace().getUri().equals(namespace.getUri())) {\n+            return \"\";\n+        }\n+        return dom.lookupPrefix(namespace.getUri());\n+    }\n+\n+    private Namespace getNodeNamespace() {\n+        String uri = dom.getNamespaceURI();\n+        String prefix = dom.getPrefix();\n+        if (uri == null) uri = \"\";\n+        if (prefix == null) prefix = \"\";\n+        return Namespace.create(prefix, uri);\n+    }\n+\n+    Namespace getNamespace() {\n+        return getNodeNamespace();\n+    }\n+\n+    void removeNamespace(Namespace namespace) {\n+        Namespace current = getNodeNamespace();\n+\n+        //    Do not remove in-use namespace\n+        if (namespace.is(current)) return;\n+        NamedNodeMap attrs = this.dom.getAttributes();\n+        for (int i=0; i<attrs.getLength(); i++) {\n+            XmlNode attr = XmlNode.createImpl(attrs.item(i));\n+            if (namespace.is(attr.getNodeNamespace())) return;\n+        }\n+\n+        //    TODO    I must confess I am not sure I understand the spec fully.  See ECMA357 13.4.4.31\n+        String existingPrefix = getExistingPrefixFor(namespace);\n+        if (existingPrefix != null) {\n+            if (namespace.isUnspecifiedPrefix()) {\n+                //    we should remove any namespace with this URI from scope; we do this by declaring a namespace with the same\n+                //    prefix as the existing prefix and setting its URI to the default namespace\n+                declareNamespace(existingPrefix, getDefaultNamespace().getUri());\n+            } else {\n+                if (existingPrefix.equals(namespace.getPrefix())) {\n+                    declareNamespace(existingPrefix, getDefaultNamespace().getUri());\n+                }\n+            }\n+        } else {\n+            //    the argument namespace is not declared in this scope, so do nothing.\n+        }\n+    }\n+\n+    private void setProcessingInstructionName(String localName) {\n+        org.w3c.dom.ProcessingInstruction pi = (ProcessingInstruction)this.dom;\n+        //    We cannot set the node name; Document.renameNode() only supports elements and attributes.  So we replace it\n+        pi.getParentNode().replaceChild(\n+            pi,\n+            pi.getOwnerDocument().createProcessingInstruction(localName, pi.getData())\n+        );\n+    }\n+\n+    final void setLocalName(String localName) {\n+        if (dom instanceof ProcessingInstruction) {\n+            setProcessingInstructionName(localName);\n+        } else {\n+            String prefix = dom.getPrefix();\n+            if (prefix == null) prefix = \"\";\n+            this.dom = dom.getOwnerDocument().renameNode(dom, dom.getNamespaceURI(), QName.qualify(prefix, localName));\n+        }\n+    }\n+\n+    final QName getQname() {\n+        String uri = (dom.getNamespaceURI()) == null ? \"\" : dom.getNamespaceURI();\n+        String prefix = (dom.getPrefix() == null) ? \"\" : dom.getPrefix();\n+        return QName.create( uri, dom.getLocalName(), prefix );\n+    }\n+\n+    void addMatchingChildren(XMLList result, XmlNode.Filter filter) {\n+        Node node = this.dom;\n+        NodeList children = node.getChildNodes();\n+        for(int i=0; i<children.getLength(); i++) {\n+            Node childnode = children.item(i);\n+            XmlNode child = XmlNode.createImpl(childnode);\n+            if (filter.accept(childnode)) {\n+                result.addToList(child);\n+            }\n+        }\n+    }\n+\n+    XmlNode[] getMatchingChildren(Filter filter) {\n+        ArrayList<XmlNode> rv = new ArrayList<XmlNode>();\n+        NodeList nodes = this.dom.getChildNodes();\n+        for (int i=0; i<nodes.getLength(); i++) {\n+            Node node = nodes.item(i);\n+            if (filter.accept(node)) {\n+                rv.add(createImpl(node));\n+            }\n+        }\n+        return rv.toArray(new XmlNode[rv.size()]);\n+    }\n+\n+    XmlNode[] getAttributes() {\n+        NamedNodeMap attrs = this.dom.getAttributes();\n+        //    TODO    Or could make callers handle null?\n+        if (attrs == null) throw new IllegalStateException(\"Must be element.\");\n+        XmlNode[] rv = new XmlNode[attrs.getLength()];\n+        for (int i=0; i<attrs.getLength(); i++) {\n+            rv[i] = createImpl( attrs.item(i) );\n+        }\n+        return rv;\n+    }\n+\n+    String getAttributeValue() {\n+        return ((Attr)dom).getValue();\n+    }\n+\n+    void setAttribute(QName name, String value) {\n+        if (!(dom instanceof Element)) throw new IllegalStateException(\"Can only set attribute on elements.\");\n+        name.setAttribute( (Element)dom, value );\n+    }\n+\n+    void replaceWith(XmlNode other) {\n+        Node replacement = other.dom;\n+        if (replacement.getOwnerDocument() != this.dom.getOwnerDocument()) {\n+            replacement = this.dom.getOwnerDocument().importNode(replacement, true);\n+        }\n+        this.dom.getParentNode().replaceChild(replacement, this.dom);\n+    }\n+\n+    String ecmaToXMLString(XmlProcessor processor) {\n+        if (this.isElementType()) {\n+            Element copy = (Element)this.dom.cloneNode(true);\n+            Namespace[] inScope = this.getInScopeNamespaces();\n+            for (int i=0; i<inScope.length; i++) {\n+                declareNamespace(copy, inScope[i].getPrefix(), inScope[i].getUri());\n+            }\n+            return processor.ecmaToXmlString(copy);\n+        } else {\n+            return processor.ecmaToXmlString(dom);\n+        }\n+    }\n+\n+    static class Namespace implements Serializable {\n+\n+        /**\n+         * Serial version id for Namespace with fields prefix and uri\n+         */\n+        private static final long serialVersionUID = 4073904386884677090L;\n+\n+        static Namespace create(String prefix, String uri) {\n+            if (prefix == null) throw new IllegalArgumentException(\"Empty string represents default namespace prefix\");\n+            if (uri == null) throw new IllegalArgumentException(\"Namespace may not lack a URI\");\n+            Namespace rv = new Namespace();\n+            rv.prefix = prefix;\n+            rv.uri = uri;\n+            return rv;\n+        }\n+\n+        static Namespace create(String uri) {\n+            Namespace rv = new Namespace();\n+            rv.uri = uri;\n+            return rv;\n+        }\n+\n+        static final Namespace GLOBAL = create(\"\", \"\");\n+\n+        private String prefix;\n+        private String uri;\n+\n+        private Namespace() {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (prefix == null) return \"XmlNode.Namespace [\" + uri + \"]\";\n+            return \"XmlNode.Namespace [\" + prefix + \"{\" + uri + \"}]\";\n+        }\n+\n+        boolean isUnspecifiedPrefix() {\n+            return prefix == null;\n+        }\n+\n+        boolean is(Namespace other) {\n+            return this.prefix != null && other.prefix != null && this.prefix.equals(other.prefix) && this.uri.equals(other.uri);\n+        }\n+\n+        boolean isEmpty() {\n+            return prefix != null && prefix.equals(\"\") && uri.equals(\"\");\n+        }\n+\n+        boolean isDefault() {\n+            return prefix != null && prefix.equals(\"\");\n+        }\n+\n+        boolean isGlobal() {\n+            return uri != null && uri.equals(\"\");\n+        }\n+\n+        //    Called by QName\n+        //    TODO    Move functionality from QName lookupPrefix to here\n+        private void setPrefix(String prefix) {\n+            if (prefix == null) throw new IllegalArgumentException();\n+            this.prefix = prefix;\n+        }\n+\n+        String getPrefix() {\n+            return prefix;\n+        }\n+\n+        String getUri() {\n+            return uri;\n+        }\n+    }\n+\n+    //    TODO    Where is this class used?  No longer using it in QName implementation\n+    static class QName implements Serializable {\n+        private static final long serialVersionUID = -6587069811691451077L;\n+\n+        static QName create(Namespace namespace, String localName) {\n+            //    A null namespace indicates a wild-card match for any namespace\n+            //    A null localName indicates \"*\" from the point of view of ECMA357\n+            if (localName != null && localName.equals(\"*\")) throw new RuntimeException(\"* is not valid localName\");\n+            QName rv = new QName();\n+            rv.namespace = namespace;\n+            rv.localName = localName;\n+            return rv;\n+        }\n+\n+        /** @deprecated */\n+        static QName create(String uri, String localName, String prefix) {\n+            return create(Namespace.create(prefix, uri), localName);\n+        }\n+\n+        static String qualify(String prefix, String localName) {\n+            if (prefix == null) throw new IllegalArgumentException(\"prefix must not be null\");\n+            if (prefix.length() > 0) return prefix + \":\" + localName;\n+            return localName;\n+        }\n+\n+        private Namespace namespace;\n+        private String localName;\n+\n+        private QName() {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"XmlNode.QName [\" + localName + \",\" + namespace + \"]\";\n+        }\n+\n+        private boolean equals(String one, String two) {\n+            if (one == null && two == null) return true;\n+            if (one == null || two == null) return false;\n+            return one.equals(two);\n+        }\n+\n+        private boolean namespacesEqual(Namespace one, Namespace two) {\n+            if (one == null && two == null) return true;\n+            if (one == null || two == null) return false;\n+            return equals(one.getUri(), two.getUri());\n+        }\n+\n+        final boolean equals(QName other) {\n+            if (!namespacesEqual(this.namespace, other.namespace)) return false;\n+            if (!equals(this.localName, other.localName)) return false;\n+            return true;\n+        }\n+        \n+        @Override\n+        public boolean equals(Object obj) {\n+            if(!(obj instanceof QName)) {\n+                return false;\n+            }\n+            return equals((QName)obj);\n+        }\n+        \n+        @Override\n+        public int hashCode() {\n+            return localName == null ? 0 : localName.hashCode();\n+        }\n+\n+        void lookupPrefix(org.w3c.dom.Node node) {\n+            if (node == null) throw new IllegalArgumentException(\"node must not be null\");\n+            String prefix = node.lookupPrefix(namespace.getUri());\n+            if (prefix == null) {\n+                //    check to see if we match the default namespace\n+                String defaultNamespace = node.lookupNamespaceURI(null);\n+                if (defaultNamespace == null) defaultNamespace = \"\";\n+                String nodeNamespace = namespace.getUri();\n+                if (nodeNamespace.equals(defaultNamespace)) {\n+                    prefix = \"\";\n+                }\n+            }\n+            int i = 0;\n+            while(prefix == null) {\n+                String generatedPrefix = \"e4x_\" + i++;\n+                String generatedUri = node.lookupNamespaceURI(generatedPrefix);\n+                if (generatedUri == null) {\n+                    prefix = generatedPrefix;\n+                    org.w3c.dom.Node top = node;\n+                    while(top.getParentNode() != null && top.getParentNode() instanceof org.w3c.dom.Element) {\n+                        top = top.getParentNode();\n+                    }\n+                    ((org.w3c.dom.Element)top).setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:\" + prefix, namespace.getUri());\n+                }\n+            }\n+            namespace.setPrefix(prefix);\n+        }\n+\n+        String qualify(org.w3c.dom.Node node) {\n+            if (namespace.getPrefix() == null) {\n+                if (node != null) {\n+                    lookupPrefix(node);\n+                } else {\n+                    if (namespace.getUri().equals(\"\")) {\n+                        namespace.setPrefix(\"\");\n+                    } else {\n+                        //    TODO    I am not sure this is right, but if we are creating a standalone node, I think we can set the\n+                        //            default namespace on the node itself and not worry about setting a prefix for that namespace.\n+                        namespace.setPrefix(\"\");\n+                    }\n+                }\n+            }\n+            return qualify(namespace.getPrefix(), localName);\n+        }\n+\n+        void setAttribute(org.w3c.dom.Element element, String value) {\n+            if (namespace.getPrefix() == null) lookupPrefix(element);\n+            element.setAttributeNS(namespace.getUri(), qualify(namespace.getPrefix(), localName), value);\n+        }\n+\n+        Namespace getNamespace() {\n+            return namespace;\n+        }\n+\n+        String getLocalName() {\n+            return localName;\n+        }\n+    }\n+\n+    static class InternalList implements Serializable {\n+        private static final long serialVersionUID = -3633151157292048978L;\n+        private List<XmlNode> list;\n+\n+        InternalList() {\n+            list = new ArrayList<XmlNode>();\n+        }\n+\n+        private void _add(XmlNode n) {\n+            list.add(n);\n+        }\n+\n+        XmlNode item(int index) {\n+            return list.get(index);\n+        }\n+\n+        void remove(int index) {\n+            list.remove(index);\n+        }\n+\n+        void add(InternalList other) {\n+            for (int i=0; i<other.length(); i++) {\n+                _add(other.item(i));\n+            }\n+        }\n+\n+        void add(InternalList from, int startInclusive, int endExclusive) {\n+            for (int i=startInclusive; i<endExclusive; i++) {\n+                _add(from.item(i));\n+            }\n+        }\n+\n+        void add(XmlNode node) {\n+            _add(node);\n+        }\n+\n+        /* TODO: was marked deprecated by original author */\n+        void add(XML xml) {\n+            _add(xml.getAnnotation());\n+        }\n+\n+        /* TODO: was marked deprecated by original author */\n+        void addToList(Object toAdd) {\n+            if (toAdd instanceof Undefined) {\n+                // Missing argument do nothing...\n+                return;\n+            }\n+\n+            if (toAdd instanceof XMLList) {\n+                XMLList xmlSrc = (XMLList)toAdd;\n+                for (int i = 0; i < xmlSrc.length(); i++) {\n+                    this._add((xmlSrc.item(i)).getAnnotation());\n+                }\n+            } else if (toAdd instanceof XML) {\n+                this._add(((XML)(toAdd)).getAnnotation());\n+            } else if (toAdd instanceof XmlNode) {\n+                this._add((XmlNode)toAdd);\n+            }\n+        }\n+\n+        int length() {\n+            return list.size();\n+        }\n+    }\n+\n+    static abstract class Filter {\n+        static final Filter COMMENT = new Filter() {\n+            @Override\n+            boolean accept(Node node) {\n+                return node.getNodeType() == Node.COMMENT_NODE;\n+            }\n+        };\n+        static final Filter TEXT = new Filter() {\n+            @Override\n+            boolean accept(Node node) {\n+                return node.getNodeType() == Node.TEXT_NODE;\n+            }\n+        };\n+        static Filter PROCESSING_INSTRUCTION(final XMLName name) {\n+            return new Filter() {\n+                @Override\n+                boolean accept(Node node) {\n+                    if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n+                        ProcessingInstruction pi = (ProcessingInstruction)node;\n+                        return name.matchesLocalName(pi.getTarget());\n+                    }\n+                    return false;\n+                }\n+            };\n+        }\n+        static Filter ELEMENT = new Filter() {\n+            @Override\n+            boolean accept(Node node) {\n+                return node.getNodeType() == Node.ELEMENT_NODE;\n+            }\n+        };\n+        static Filter TRUE = new Filter() {\n+            @Override\n+            boolean accept(Node node) {\n+                return true;\n+            }\n+        };\n+        abstract boolean accept(Node node);\n+    }\n+\n+    //    Support experimental Java interface\n+    org.w3c.dom.Node toDomNode() {\n+        return this.dom;\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlProcessor.java\n+/* ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino DOM-only E4X implementation.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * David P. Caldwell.\n+ * Portions created by David P. Caldwell are Copyright (C)\n+ * 2007 David P. Caldwell. All Rights Reserved.\n+ *\n+ *\n+ * Contributor(s):\n+ *   David P. Caldwell <inonit@inonit.com>\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.xmlimpl;\n+\n+import org.w3c.dom.*;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import org.mozilla.javascript.*;\n+\n+//    Disambiguate from org.mozilla.javascript.Node\n+import org.w3c.dom.Node;\n+import org.xml.sax.ErrorHandler;\n+import org.xml.sax.SAXParseException;\n+\n+class XmlProcessor implements Serializable {\n+    \n+    private static final long serialVersionUID = 6903514433204808713L;\n+    \n+    private boolean ignoreComments;\n+    private boolean ignoreProcessingInstructions;\n+    private boolean ignoreWhitespace;\n+    private boolean prettyPrint;\n+    private int prettyIndent;\n+\n+    private transient javax.xml.parsers.DocumentBuilderFactory dom;\n+    private transient javax.xml.transform.TransformerFactory xform;\n+    private transient DocumentBuilder documentBuilder;\n+    private RhinoSAXErrorHandler errorHandler = new RhinoSAXErrorHandler();\n+\n+    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        this.dom = javax.xml.parsers.DocumentBuilderFactory.newInstance();\n+        this.dom.setNamespaceAware(true);\n+        this.dom.setIgnoringComments(false);\n+        this.xform = javax.xml.transform.TransformerFactory.newInstance();\n+    }\n+    \n+    private static class RhinoSAXErrorHandler implements ErrorHandler, Serializable {\n+\n+        private static final long serialVersionUID = 6918417235413084055L;\n+\n+        private void throwError(SAXParseException e) {\n+            throw ScriptRuntime.constructError(\"TypeError\", e.getMessage(),\n+                e.getLineNumber() - 1);\n+        }\n+\n+        public void error(SAXParseException e) {\n+            throwError(e);\n+        }\n+\n+        public void fatalError(SAXParseException e) {\n+            throwError(e);\n+        }\n+\n+        public void warning(SAXParseException e) {\n+            Context.reportWarning(e.getMessage());\n+        }\n+    }\n+\n+    XmlProcessor() {\n+        setDefault();\n+        this.dom = javax.xml.parsers.DocumentBuilderFactory.newInstance();\n+        this.dom.setNamespaceAware(true);\n+        this.dom.setIgnoringComments(false);\n+        this.xform = javax.xml.transform.TransformerFactory.newInstance();\n+    }\n+\n+    final void setDefault() {\n+        this.setIgnoreComments(true);\n+        this.setIgnoreProcessingInstructions(true);\n+        this.setIgnoreWhitespace(true);\n+        this.setPrettyPrinting(true);\n+        this.setPrettyIndent(2);\n+    }\n+\n+    final void setIgnoreComments(boolean b) {\n+        this.ignoreComments = b;\n+    }\n+\n+    final void setIgnoreWhitespace(boolean b) {\n+        this.ignoreWhitespace = b;\n+    }\n+\n+    final void setIgnoreProcessingInstructions(boolean b) {\n+        this.ignoreProcessingInstructions = b;\n+    }\n+\n+    final void setPrettyPrinting(boolean b) {\n+        this.prettyPrint = b;\n+    }\n+\n+    final void setPrettyIndent(int i) {\n+        this.prettyIndent = i;\n+    }\n+\n+    final boolean isIgnoreComments() {\n+        return ignoreComments;\n+    }\n+\n+    final boolean isIgnoreProcessingInstructions() {\n+        return ignoreProcessingInstructions;\n+    }\n+\n+    final boolean isIgnoreWhitespace() {\n+        return ignoreWhitespace;\n+    }\n+\n+    final boolean isPrettyPrinting() {\n+        return prettyPrint;\n+    }\n+\n+    final int getPrettyIndent() {\n+        return prettyIndent;\n+    }\n+\n+    private String toXmlNewlines(String rv) {\n+        StringBuffer nl = new StringBuffer();\n+        for (int i=0; i<rv.length(); i++) {\n+            if (rv.charAt(i) == '\\r') {\n+                if (rv.charAt(i+1) == '\\n') {\n+                    //    DOS, do nothing and skip the \\r\n+                } else {\n+                    //    Macintosh, substitute \\n\n+                    nl.append('\\n');\n+                }\n+            } else {\n+                nl.append(rv.charAt(i));\n+            }\n+        }\n+        return nl.toString();\n+    }\n+\n+    private javax.xml.parsers.DocumentBuilderFactory getDomFactory() {\n+        return dom;\n+    }\n+    \n+    private synchronized DocumentBuilder getDocumentBuilderFromPool()\n+        throws javax.xml.parsers.ParserConfigurationException\n+    {\n+        DocumentBuilder result;\n+        if (documentBuilder == null) {\n+            javax.xml.parsers.DocumentBuilderFactory factory = getDomFactory();\n+            result = factory.newDocumentBuilder();\n+        } else {\n+            result = documentBuilder;\n+            documentBuilder = null;\n+        }\n+        result.setErrorHandler(errorHandler);\n+        return result;\n+    }\n+        \n+    private synchronized void returnDocumentBuilderToPool(DocumentBuilder db) {\n+        if (documentBuilder == null) {\n+            try {\n+                db.reset();\n+                documentBuilder = db;\n+            } catch (UnsupportedOperationException e) {\n+                // document builders that don't support reset() can't\n+                // be pooled\n+            }\n+        }\n+    }\n+\n+    private void addProcessingInstructionsTo(List<Node> list, Node node) {\n+        if (node instanceof ProcessingInstruction) {\n+            list.add(node);\n+        }\n+        if (node.getChildNodes() != null) {\n+            for (int i=0; i<node.getChildNodes().getLength(); i++) {\n+                addProcessingInstructionsTo(list, node.getChildNodes().item(i));\n+            }\n+        }\n+    }\n+\n+    private void addCommentsTo(List<Node> list, Node node) {\n+        if (node instanceof Comment) {\n+            list.add(node);\n+        }\n+        if (node.getChildNodes() != null) {\n+            for (int i=0; i<node.getChildNodes().getLength(); i++) {\n+                addProcessingInstructionsTo(list, node.getChildNodes().item(i));\n+            }\n+        }\n+    }\n+\n+    private void addTextNodesToRemoveAndTrim(List<Node> toRemove, Node node) {\n+        if (node instanceof Text) {\n+            Text text = (Text)node;\n+            boolean BUG_369394_IS_VALID = false;\n+            if (!BUG_369394_IS_VALID) {\n+                text.setData(text.getData().trim());\n+            } else {\n+                if (text.getData().trim().length() == 0) {\n+                    text.setData(\"\");\n+                }\n+            }\n+            if (text.getData().length() == 0) {\n+                toRemove.add(node);\n+            }\n+        }\n+        if (node.getChildNodes() != null) {\n+            for (int i=0; i<node.getChildNodes().getLength(); i++) {\n+                addTextNodesToRemoveAndTrim(toRemove, node.getChildNodes().item(i));\n+            }\n+        }\n+    }\n+\n+    final Node toXml(String defaultNamespaceUri, String xml) throws org.xml.sax.SAXException {\n+        //    See ECMA357 10.3.1\n+        DocumentBuilder builder = null;\n+        try {\n+            String syntheticXml = \"<parent xmlns=\\\"\" + defaultNamespaceUri +\n+                \"\\\">\" + xml + \"</parent>\";\n+            builder = getDocumentBuilderFromPool(); \n+            Document document = builder.parse( new org.xml.sax.InputSource(new java.io.StringReader(syntheticXml)) );\n+            if (ignoreProcessingInstructions) {\n+                List<Node> list = new java.util.ArrayList<Node>();\n+                addProcessingInstructionsTo(list, document);\n+                for (Node node: list) {\n+                    node.getParentNode().removeChild(node);\n+                }\n+            }\n+            if (ignoreComments) {\n+                List<Node> list = new java.util.ArrayList<Node>();\n+                addCommentsTo(list, document);\n+                for (Node node: list) {\n+                    node.getParentNode().removeChild(node);\n+                }\n+            }\n+            if (ignoreWhitespace) {\n+                //    Apparently JAXP setIgnoringElementContentWhitespace() has a different meaning, it appears from the Javadoc\n+                //    Refers to element-only content models, which means we would need to have a validating parser and DTD or schema\n+                //    so that it would know which whitespace to ignore.\n+\n+                //    Instead we will try to delete it ourselves.\n+                List<Node> list = new java.util.ArrayList<Node>();\n+                addTextNodesToRemoveAndTrim(list, document);\n+                for (Node node: list) {\n+                    node.getParentNode().removeChild(node);\n+                }\n+            }\n+            NodeList rv = document.getDocumentElement().getChildNodes();\n+            if (rv.getLength() > 1) {\n+                throw ScriptRuntime.constructError(\"SyntaxError\", \"XML objects may contain at most one node.\");\n+            } else if (rv.getLength() == 0) {\n+                Node node = document.createTextNode(\"\");\n+                return node;\n+            } else {\n+                Node node = rv.item(0);\n+                document.getDocumentElement().removeChild(node);\n+                return node;\n+            }\n+        } catch (java.io.IOException e) {\n+            throw new RuntimeException(\"Unreachable.\");\n+        } catch (javax.xml.parsers.ParserConfigurationException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            if (builder != null)\n+                returnDocumentBuilderToPool(builder);\n+        }\n+    }\n+\n+    Document newDocument() {\n+        DocumentBuilder builder = null;\n+        try {\n+            //    TODO    Should this use XML settings?\n+            builder = getDocumentBuilderFromPool();\n+            return builder.newDocument();\n+        } catch (javax.xml.parsers.ParserConfigurationException ex) {\n+            //    TODO    How to handle these runtime errors?\n+            throw new RuntimeException(ex);\n+        } finally {\n+            if (builder != null)\n+                returnDocumentBuilderToPool(builder);\n+        }\n+    }\n+\n+    //    TODO    Cannot remember what this is for, so whether it should use settings or not\n+    private String toString(Node node) {\n+        javax.xml.transform.dom.DOMSource source = new javax.xml.transform.dom.DOMSource(node);\n+        java.io.StringWriter writer = new java.io.StringWriter();\n+        javax.xml.transform.stream.StreamResult result = new javax.xml.transform.stream.StreamResult(writer);\n+        try {\n+            javax.xml.transform.Transformer transformer = xform.newTransformer();\n+            transformer.setOutputProperty(javax.xml.transform.OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n+            transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, \"no\");\n+            transformer.setOutputProperty(javax.xml.transform.OutputKeys.METHOD, \"xml\");\n+            transformer.transform(source, result);\n+        } catch (javax.xml.transform.TransformerConfigurationException ex) {\n+            //    TODO    How to handle these runtime errors?\n+            throw new RuntimeException(ex);\n+        } catch (javax.xml.transform.TransformerException ex) {\n+            //    TODO    How to handle these runtime errors?\n+            throw new RuntimeException(ex);\n+        }\n+        return toXmlNewlines(writer.toString());\n+    }\n+\n+    String escapeAttributeValue(Object value) {\n+        String text = ScriptRuntime.toString(value);\n+\n+        if (text.length() == 0) return \"\";\n+\n+        Document dom = newDocument();\n+        Element e = dom.createElement(\"a\");\n+        e.setAttribute(\"b\", text);\n+        String elementText = toString(e);\n+        int begin = elementText.indexOf('\"');\n+        int end = elementText.lastIndexOf('\"');\n+        return elementText.substring(begin+1,end);\n+    }\n+\n+    String escapeTextValue(Object value) {\n+        if (value instanceof XMLObjectImpl) {\n+            return ((XMLObjectImpl)value).toXMLString();\n+        }\n+\n+        String text = ScriptRuntime.toString(value);\n+\n+        if (text.length() == 0) return text;\n+\n+        Document dom = newDocument();\n+        Element e = dom.createElement(\"a\");\n+        e.setTextContent(text);\n+        String elementText = toString(e);\n+\n+        int begin = elementText.indexOf('>') + 1;\n+        int end = elementText.lastIndexOf('<');\n+        return (begin < end) ? elementText.substring(begin, end) : \"\";\n+    }\n+\n+    private String escapeElementValue(String s) {\n+        //    TODO    Check this\n+        return escapeTextValue(s);\n+    }\n+\n+    private String elementToXmlString(Element element) {\n+        //    TODO    My goodness ECMA is complicated (see 10.2.1).  We'll try this first.\n+        Element copy = (Element)element.cloneNode(true);\n+        if (prettyPrint) {\n+            beautifyElement(copy, 0);\n+        }\n+        return toString(copy);\n+    }\n+\n+    final String ecmaToXmlString(Node node) {\n+        //    See ECMA 357 Section 10.2.1\n+        StringBuffer s = new StringBuffer();\n+        int indentLevel = 0;\n+        if (prettyPrint) {\n+            for (int i=0; i<indentLevel; i++) {\n+                s.append(' ');\n+            }\n+        }\n+        if (node instanceof Text) {\n+            String data = ((Text)node).getData();\n+            //    TODO Does Java trim() work same as XMLWhitespace?\n+            String v = (prettyPrint) ? data.trim() : data;\n+            s.append(escapeElementValue(v));\n+            return s.toString();\n+        }\n+        if (node instanceof Attr) {\n+            String value = ((Attr)node).getValue();\n+            s.append(escapeAttributeValue(value));\n+            return s.toString();\n+        }\n+        if (node instanceof Comment) {\n+            s.append(\"<!--\" + ((Comment)node).getNodeValue() + \"-->\");\n+            return s.toString();\n+        }\n+        if (node instanceof ProcessingInstruction) {\n+            ProcessingInstruction pi = (ProcessingInstruction)node;\n+            s.append(\"<?\" + pi.getTarget() + \" \" + pi.getData() + \"?>\");\n+            return s.toString();\n+        }\n+        s.append(elementToXmlString((Element)node));\n+        return s.toString();\n+    }\n+\n+    private void beautifyElement(Element e, int indent) {\n+        StringBuffer s = new StringBuffer();\n+        s.append('\\n');\n+        for (int i=0; i<indent; i++) {\n+            s.append(' ');\n+        }\n+        String afterContent = s.toString();\n+        for (int i=0; i<prettyIndent; i++) {\n+            s.append(' ');\n+        }\n+        String beforeContent = s.toString();\n+\n+        //    We \"mark\" all the nodes first; if we tried to do this loop otherwise, it would behave unexpectedly (the inserted nodes\n+        //    would contribute to the length and it might never terminate).\n+        ArrayList<Node> toIndent = new ArrayList<Node>();\n+        boolean indentChildren = false;\n+        for (int i=0; i<e.getChildNodes().getLength(); i++) {\n+            if (i == 1) indentChildren = true;\n+            if (e.getChildNodes().item(i) instanceof Text) {\n+                toIndent.add(e.getChildNodes().item(i));\n+            } else {\n+                indentChildren = true;\n+                toIndent.add(e.getChildNodes().item(i));\n+            }\n+        }\n+        if (indentChildren) {\n+            for (int i=0; i<toIndent.size(); i++) {\n+                e.insertBefore(e.getOwnerDocument().createTextNode(beforeContent),\n+                        toIndent.get(i));\n+            }\n+        }\n+        NodeList nodes = e.getChildNodes();\n+        ArrayList<Element> list = new ArrayList<Element>();\n+        for (int i=0; i < nodes.getLength(); i++) {\n+            if (nodes.item(i) instanceof Element) {\n+                list.add((Element)nodes.item(i));\n+            }\n+        }\n+        for (Element elem: list) {\n+            beautifyElement(elem, indent + prettyIndent);\n+        }\n+        if (indentChildren) {\n+            e.appendChild(e.getOwnerDocument().createTextNode(afterContent));\n+        }\n+    }\n+}", "timestamp": 1309201780, "metainfo": ""}