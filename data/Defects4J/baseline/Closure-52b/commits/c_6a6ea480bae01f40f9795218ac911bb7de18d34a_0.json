{"sha": "6a6ea480bae01f40f9795218ac911bb7de18d34a", "log": "Don't warn about duplicate variable declarations unless warning_level is set to VERBOSE.  Implementation of libary function goog.base.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n     return compiler;\n   }\n \n+  final protected void setRunOptions(B options) throws IOException {\n+    if (FLAG_js_output_file.get().length() > 0) {\n+      options.jsOutputFile = FLAG_js_output_file.get();\n+    }\n+\n+    if (FLAG_create_source_map.get().length() > 0) {\n+      options.sourceMapOutputPath = FLAG_create_source_map.get();\n+    }\n+\n+    if (!FLAG_variable_map_input_file.get().equals(\"\")) {\n+      options.inputVariableMapSerialized =\n+          VariableMap.load(FLAG_variable_map_input_file.get()).toBytes();\n+    }\n+\n+    if (!FLAG_property_map_input_file.get().equals(\"\")) {\n+      options.inputPropertyMapSerialized =\n+          VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n+    }\n+\n+    if (FLAG_third_party.get()) {\n+      options.setCodingConvention(new DefaultCodingConvention());\n+    }\n+  }\n+\n   /**\n    * Runs the Compiler and calls System.exit() with the exit status of the\n    * compiler.\n     JSModule[] modules = null;\n     Result result;\n \n-    if (FLAG_js_output_file.get().length() > 0) {\n-      options.jsOutputFile = FLAG_js_output_file.get();\n-    }\n-\n-    if (FLAG_create_source_map.get().length() > 0) {\n-      options.sourceMapOutputPath = FLAG_create_source_map.get();\n-    }\n-\n-    if (!FLAG_variable_map_input_file.get().equals(\"\")) {\n-      options.inputVariableMapSerialized =\n-          VariableMap.load(FLAG_variable_map_input_file.get()).toBytes();\n-    }\n-\n-    if (!FLAG_property_map_input_file.get().equals(\"\")) {\n-      options.inputPropertyMapSerialized =\n-          VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n-    }\n+    setRunOptions(options);\n \n     if (!options.jsOutputFile.equals(\"\")) {\n       out = new PrintStream(options.jsOutputFile);\n-    }\n-\n-    if (FLAG_third_party.get()) {\n-\n-      // Enable the generic coding conventions.\n-      compiler.setCodingConvention(new DefaultCodingConvention());\n     }\n \n     ((PrintStreamErrorManager) compiler.getErrorManager())\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n     return \"goog.global\";\n   }\n \n-  @Override\n-  public boolean allowsVariableRedeclaration(\n-      Scope scope, String name, Node parent) {\n-    return !scope.isGlobal();\n-  }\n-\n   private final Set<String> propertyTestFunctions = ImmutableSet.of(\n       \"goog.isDef\", \"goog.isNull\", \"goog.isDefAndNotNull\",\n       \"goog.isString\", \"goog.isNumber\", \"goog.isBoolean\",\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n    * Gets the name of the global object.\n    */\n   public String getGlobalObject();\n-\n-  public boolean allowsVariableRedeclaration(Scope scope, String name,\n-      Node parent);\n \n   /**\n    * Whether this CALL function is testing for the existence of a property.\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   private final StringBuilder debugLog_ = new StringBuilder();\n \n   /** Detects Google-specific coding conventions. */\n-  private CodingConvention codingConvention = new GoogleCodingConvention();\n+  CodingConvention defaultCodingConvention = new GoogleCodingConvention();\n \n   private JSTypeRegistry typeRegistry;\n \n \n   @Override\n   public CodingConvention getCodingConvention() {\n-    return codingConvention;\n-  }\n-\n-  public void setCodingConvention(CodingConvention convention) {\n-    Preconditions.checkState(convention != null);\n-    codingConvention = convention;\n+    CodingConvention convention = options_.getCodingConvention();\n+    convention = convention != null ? convention : defaultCodingConvention;\n+    return convention;\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   // Special-purpose alterations\n   //--------------------------------\n \n+  /** A CodingConvention to use during the compile. */\n+  private CodingConvention codingConvention;\n+\n   /** Instrument code for the purpose of collecting coverage data. */\n   public boolean instrumentForCoverage;\n \n \n   /** Rewrite new Date(goog.now()) to new Date().  */\n   boolean rewriteNewDateGoogNow;\n+\n+  /** Remove goog.abstractMethod assignments. */\n+  boolean removeAbstractMethods;\n \n   /** Gather CSS names (requires closurePass) */\n   public boolean gatherCssNames;\n     removeTryCatchFinally = false;\n     closurePass = false;\n     rewriteNewDateGoogNow = true;\n+    removeAbstractMethods = true;\n     stripTypes = Collections.emptySet();\n     stripNameSuffixes = Collections.emptySet();\n     stripNamePrefixes = Collections.emptySet();\n     this.rewriteNewDateGoogNow = rewrite;\n   }\n \n+  public void setRemoveAbstractMethods(boolean remove) {\n+    this.removeAbstractMethods = remove;\n+  }\n+\n   /**\n    * If true, name anonymous functions only. All other passes will be skipped.\n    */\n    */\n   public void setChainCalls(boolean value) {\n     this.chainCalls = value;\n+  }\n+\n+  public void setCodingConvention(CodingConvention codingConvention) {\n+    this.codingConvention = codingConvention;\n+  }\n+\n+  public CodingConvention getCodingConvention() {\n+    return codingConvention;\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n   }\n \n   @Override\n-  public boolean allowsVariableRedeclaration(\n-      Scope scope, String name, Node parent) {\n-    return true;\n-  }\n-\n-  @Override\n   public boolean isPropertyTestFunction(Node call) {\n     return false;\n   }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n-    if (!options.checkSymbols) {\n-      options.setWarningLevel(DiagnosticGroups.UNDEFINED_VARIABLES,\n+    WarningsGuard warningsGuard = options.getWarningsGuard();\n+    if (!options.checkSymbols &&\n+        (warningsGuard == null || !warningsGuard.disables(\n+            DiagnosticGroups.CHECK_VARIABLES))) {\n+      options.setWarningLevel(DiagnosticGroups.CHECK_VARIABLES,\n           CheckLevel.OFF);\n     }\n \n \n     // Abstract method removal works best on minimally modified code, and also\n     // only needs to run once.\n-    if (options.closurePass) {\n+    if (options.closurePass && options.removeAbstractMethods) {\n       passes.add(removeAbstractMethods);\n     }\n \n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n       DiagnosticGroups.registerGroup(\"undefinedVars\",\n           new DiagnosticGroup(VarCheck.UNDEFINED_VAR_ERROR));\n \n+  public static DiagnosticGroup CHECK_VARIABLES =\n+      DiagnosticGroups.registerGroup(\"checkVars\",\n+          new DiagnosticGroup(\n+              VarCheck.UNDEFINED_VAR_ERROR,\n+              SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR));\n+\n   /**\n    * Adds warning levels by name.\n    */\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n+import com.google.common.collect.HashMultiset;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multiset;\n-import com.google.common.collect.Multisets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import java.util.ArrayDeque;\n import java.util.Deque;\n import java.util.Map;\n-\n \n /**\n  *  Find all Functions, VARs, and Exception names and make them\n \n     ContextualRenamer() {\n       this.global = true;\n-      nameUsage = Multisets.newHashMultiset();\n+      nameUsage = HashMultiset.create();\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CheckLevel;\n-import com.google.javascript.jscomp.NodeTraversal.AbstractNodeTypePruningCallback;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n *\n *\n  */\n-class ProcessClosurePrimitives extends AbstractNodeTypePruningCallback\n+class ProcessClosurePrimitives extends AbstractPostOrderCallback\n     implements CompilerPass {\n \n   static final DiagnosticType NULL_ARGUMENT_ERROR = DiagnosticType.error(\n       DiagnosticType.error(\n           \"JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR\",\n       \"goog.setCssNameMapping only takes an object literal with string values\");\n+\n+  static final DiagnosticType BASE_CLASS_ERROR = DiagnosticType.error(\n+      \"JSC_BASE_CLASS_ERROR\",\n+      \"incorrect use of goog.base: {0}\");\n \n   /** The root Closure namespace */\n   static final String GOOG = \"goog\";\n   private final CheckLevel requiresLevel;\n   private final boolean rewriteNewDateGoogNow;\n \n-  private static final Set<Integer> TRAVERSAL_NODE_TYPES = ImmutableSet.of(\n-    Token.SCRIPT,\n-    Token.BLOCK,\n-    Token.EXPR_RESULT,\n-    Token.CALL,\n-    Token.ASSIGN,\n-    Token.IF,\n-    Token.VAR,\n-    Token.NAME,\n-    Token.NEW,\n-    Token.FUNCTION);\n-\n   ProcessClosurePrimitives(AbstractCompiler compiler,\n                            CheckLevel requiresLevel,\n                            boolean rewriteNewDateGoogNow) {\n-    super(TRAVERSAL_NODE_TYPES);\n-\n     this.compiler = compiler;\n     this.unrecognizedRequires = new ArrayList<UnrecognizedRequire>();\n     this.providedNodes = new HashMap<String, ProvidedNode>();\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     switch (n.getType()) {\n       case Token.CALL:\n-        if (parent.getType() == Token.EXPR_RESULT) {\n-          Node left = n.getFirstChild();\n-          if (left.getType() == Token.GETPROP) {\n-            Node name = left.getFirstChild();\n-            if (name.getType() == Token.NAME &&\n-                GOOG.equals(name.getString())) {\n-              // For the sake of simplicity, we report code changes\n-              // when we see a provides/requires, and don't worry about\n-              // reporting the change when we actually do the replacement.\n-              String methodName = name.getNext().getString();\n-              if (\"require\".equals(methodName)) {\n-                Node arg = left.getNext();\n-                if (verifyArgument(t, left, arg)) {\n-                  String ns = arg.getString();\n-                  ProvidedNode provided = providedNodes.get(ns);\n-                  if (provided == null) {\n-                    unrecognizedRequires.add(\n-                        new UnrecognizedRequire(n, ns, t.getSourceName()));\n-                  } else {\n-                    JSModule module = t.getModule();\n-                    if (module != provided.module /* covers null case */ &&\n-                        !compiler.getModuleGraph().dependsOn(module,\n-                            provided.module)) {\n-                      compiler.report(\n-                          JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns,\n-                              provided.module.getName(),\n-                              module.getName()));\n-                    }\n-                  }\n-\n-                  // Requires should be removed before runtime.  The one\n-                  // exception is if the type has not been provided yet and\n-                  // errors for broken requires are turned off, in which case,\n-                  // we will be doing a later pass that may error, so we can\n-                  // leave this here this time and let it error next time if it\n-                  // is still not provided.\n-                  if (provided != null || requiresLevel.isOn()) {\n-                    parent.getParent().removeChild(parent);\n-                    compiler.reportCodeChange();\n+        boolean isExpr = parent.getType() == Token.EXPR_RESULT;\n+        Node left = n.getFirstChild();\n+        if (left.getType() == Token.GETPROP) {\n+          Node name = left.getFirstChild();\n+          if (name.getType() == Token.NAME &&\n+              GOOG.equals(name.getString())) {\n+            // For the sake of simplicity, we report code changes\n+            // when we see a provides/requires, and don't worry about\n+            // reporting the change when we actually do the replacement.\n+            String methodName = name.getNext().getString();\n+            if (\"base\".equals(methodName)) {\n+              processBaseClassCall(t, n);\n+            } else if (!isExpr) {\n+              // All other methods must be called in an EXPR.\n+              break;\n+            } else if (\"require\".equals(methodName)) {\n+              Node arg = left.getNext();\n+              if (verifyArgument(t, left, arg)) {\n+                String ns = arg.getString();\n+                ProvidedNode provided = providedNodes.get(ns);\n+                if (provided == null) {\n+                  unrecognizedRequires.add(\n+                      new UnrecognizedRequire(n, ns, t.getSourceName()));\n+                } else {\n+                  JSModule module = t.getModule();\n+                  if (module != provided.module /* covers null case */ &&\n+                      !compiler.getModuleGraph().dependsOn(module,\n+                          provided.module)) {\n+                    compiler.report(\n+                        JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns,\n+                            provided.module.getName(),\n+                            module.getName()));\n                   }\n                 }\n-              } else if (\"provide\".equals(methodName)) {\n-                Node arg = left.getNext();\n-                if (verifyProvide(t, left, arg)) {\n-                  String ns = arg.getString();\n-                  if (providedNodes.get(ns) != null) {\n-                    compiler.report(\n-                        JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n-                  } else if (!providedNodes.containsKey(ns)) {\n-                    replaceProvide(t, parent, parent.getParent(), ns);\n-                  } else {\n-                    // Namespace was already inserted for a sub-namespace.\n-                    parent.getParent().removeChild(parent);\n-                    providedNodes.put(ns,\n-                        new ProvidedNode(null, null, t.getModule()));\n-                  }\n+\n+                // Requires should be removed before runtime.  The one\n+                // exception is if the type has not been provided yet and\n+                // errors for broken requires are turned off, in which case,\n+                // we will be doing a later pass that may error, so we can\n+                // leave this here this time and let it error next time if it\n+                // is still not provided.\n+                if (provided != null || requiresLevel.isOn()) {\n+                  parent.getParent().removeChild(parent);\n                   compiler.reportCodeChange();\n                 }\n-              } else if (\"exportSymbol\".equals(methodName)) {\n-                Node arg = left.getNext();\n-                if (arg.getType() == Token.STRING) {\n-                  int dot = arg.getString().indexOf('.');\n-                  if (dot == -1) {\n-                    exportedVariables.add(arg.getString());\n-                  } else {\n-                    exportedVariables.add(arg.getString().substring(0, dot));\n-                  }\n+              }\n+            } else if (\"provide\".equals(methodName)) {\n+              Node arg = left.getNext();\n+              if (verifyProvide(t, left, arg)) {\n+                String ns = arg.getString();\n+                if (providedNodes.get(ns) != null) {\n+                  compiler.report(\n+                      JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n+                } else if (!providedNodes.containsKey(ns)) {\n+                  replaceProvide(t, parent, parent.getParent(), ns);\n+                } else {\n+                  // Namespace was already inserted for a sub-namespace.\n+                  parent.getParent().removeChild(parent);\n+                  providedNodes.put(ns,\n+                      new ProvidedNode(null, null, t.getModule()));\n                 }\n-              } else if (\"addDependency\".equals(methodName)) {\n-                CodingConvention convention = compiler.getCodingConvention();\n-                List<String> typeDecls =\n-                    convention.identifyTypeDeclarationCall(n);\n-                if (typeDecls != null) {\n-                  for (String typeDecl : typeDecls) {\n-                    compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n-                  }\n+                compiler.reportCodeChange();\n+              }\n+            } else if (\"exportSymbol\".equals(methodName)) {\n+              Node arg = left.getNext();\n+              if (arg.getType() == Token.STRING) {\n+                int dot = arg.getString().indexOf('.');\n+                if (dot == -1) {\n+                  exportedVariables.add(arg.getString());\n+                } else {\n+                  exportedVariables.add(arg.getString().substring(0, dot));\n                 }\n-\n-                // We can't modify parent, so just create a node that will\n-                // get compiled out.\n-                parent.replaceChild(n, Node.newNumber(0));\n-                compiler.reportCodeChange();\n-              } else if (\"setCssNameMapping\".equals(methodName)) {\n-                processSetCssNameMapping(t, n, parent);\n               }\n+            } else if (\"addDependency\".equals(methodName)) {\n+              CodingConvention convention = compiler.getCodingConvention();\n+              List<String> typeDecls =\n+                  convention.identifyTypeDeclarationCall(n);\n+              if (typeDecls != null) {\n+                for (String typeDecl : typeDecls) {\n+                  compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n+                }\n+              }\n+\n+              // We can't modify parent, so just create a node that will\n+              // get compiled out.\n+              parent.replaceChild(n, Node.newNumber(0));\n+              compiler.reportCodeChange();\n+            } else if (\"setCssNameMapping\".equals(methodName)) {\n+              processSetCssNameMapping(t, n, parent);\n             }\n           }\n         }\n       case Token.NEW:\n         trySimplifyNewDate(t, n, parent);\n         break;\n-    }\n+\n+      case Token.GETPROP:\n+        if (n.getFirstChild().getType() == Token.NAME &&\n+            parent.getType() != Token.CALL &&\n+            parent.getType() != Token.ASSIGN &&\n+            \"goog.base\".equals(n.getQualifiedName())) {\n+          reportBadBaseClassUse(t, n, \"May only be called directly.\");\n+        }\n+        break;\n+    }\n+  }\n+\n+  /**\n+   * Processes the base class call.\n+   */\n+  private void processBaseClassCall(NodeTraversal t, Node n) {\n+    // Two things must hold for every goog.base call:\n+    // 1) We must be calling it on \"this\".\n+    // 2) We must be calling it on a prototype method of the same name as\n+    //    the one we're in, OR we must be calling it from a constructor.\n+    // If both of those things are true, then we can rewrite:\n+    // <pre>\n+    // function Foo() {\n+    //   goog.base(this);\n+    // }\n+    // goog.inherits(Foo, BaseFoo);\n+    // Foo.prototype.bar = function() {\n+    //   goog.base(this, 'bar', 1);\n+    // };\n+    // </pre>\n+    // as the easy-to-optimize:\n+    // <pre>\n+    // function Foo() {\n+    //   BaseFoo.call(this);\n+    // }\n+    // goog.inherits(Foo, BaseFoo);\n+    // Foo.prototype.bar = function() {\n+    //   Foo.superClass_.bar.call(this, 1);\n+    // };\n+    //\n+    // Most of the logic here is just to make sure the AST's\n+    // structure is what we expect it to be.\n+\n+    Node callee = n.getFirstChild();\n+    Node thisArg = callee.getNext();\n+    if (thisArg == null || thisArg.getType() != Token.THIS) {\n+      reportBadBaseClassUse(t, n, \"First argument must be 'this'.\");\n+      return;\n+    }\n+\n+    Node enclosingFnNameNode = getEnclosingDeclNameNode(t);\n+    if (enclosingFnNameNode == null) {\n+      reportBadBaseClassUse(t, n, \"Could not find enclosing method.\");\n+      return;\n+    }\n+\n+    String enclosingQname = enclosingFnNameNode.getQualifiedName();\n+    if (enclosingQname.indexOf(\".prototype.\") == -1) {\n+      // Handle constructors.\n+      Node enclosingParent = enclosingFnNameNode.getParent();\n+      Node maybeInheritsExpr = (enclosingParent.getType() == Token.ASSIGN ?\n+          enclosingParent.getParent() : enclosingParent).getNext();\n+      Node baseClassNode = null;\n+      if (maybeInheritsExpr != null &&\n+          maybeInheritsExpr.getType() == Token.EXPR_RESULT &&\n+          maybeInheritsExpr.getFirstChild().getType() == Token.CALL) {\n+        Node callNode = maybeInheritsExpr.getFirstChild();\n+        if (\"goog.inherits\".equals(\n+                callNode.getFirstChild().getQualifiedName()) &&\n+            callNode.getLastChild().isQualifiedName()) {\n+          baseClassNode = callNode.getLastChild();\n+        }\n+      }\n+\n+      if (baseClassNode == null) {\n+        reportBadBaseClassUse(\n+            t, n, \"Could not find goog.inherits for base class\");\n+        return;\n+      }\n+\n+      // We're good to go.\n+      n.replaceChild(\n+          callee,\n+          NodeUtil.newQualifiedNameNode(\n+            String.format(\"%s.call\", baseClassNode.getQualifiedName()),\n+            callee, \"goog.base\"));\n+      compiler.reportCodeChange();\n+    } else {\n+      // Handle methods.\n+      Node methodNameNode = thisArg.getNext();\n+      if (methodNameNode == null || methodNameNode.getType() != Token.STRING) {\n+        reportBadBaseClassUse(t, n, \"Second argument must name a method.\");\n+        return;\n+      }\n+\n+      String methodName = methodNameNode.getString();\n+      String ending = \".prototype.\" + methodName;\n+      if (enclosingQname == null ||\n+          !enclosingQname.endsWith(ending)) {\n+        reportBadBaseClassUse(\n+            t, n, \"Enclosing method does not match \" + methodName);\n+        return;\n+      }\n+\n+      // We're good to go.\n+      Node className =\n+          enclosingFnNameNode.getFirstChild().getFirstChild();\n+      n.replaceChild(\n+          callee,\n+          NodeUtil.newQualifiedNameNode(\n+            String.format(\"%s.superClass_.%s.call\",\n+                className.getQualifiedName(), methodName),\n+            callee, \"goog.base\"));\n+      n.removeChild(methodNameNode);\n+      compiler.reportCodeChange();\n+    }\n+  }\n+\n+  /**\n+   * Returns the qualified name node of the function whose scope we're in,\n+   * or null if it cannot be found.\n+   */\n+  private Node getEnclosingDeclNameNode(NodeTraversal t) {\n+    Node scopeRoot = t.getScopeRoot();\n+    if (NodeUtil.isFunctionDeclaration(scopeRoot)) {\n+      // function x() {...}\n+      return scopeRoot.getFirstChild();\n+    } else {\n+      Node parent = scopeRoot.getParent();\n+      if (parent != null) {\n+        if (parent.getType() == Token.ASSIGN ||\n+            parent.getLastChild() == scopeRoot &&\n+            parent.getFirstChild().isQualifiedName()) {\n+          // x.y.z = function() {...};\n+          return parent.getFirstChild();\n+        } else if (parent.getType() == Token.NAME) {\n+          // var x = function() {...};\n+          return parent;\n+        }\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  /** Reports an incorrect use of super-method calling. */\n+  private void reportBadBaseClassUse(\n+      NodeTraversal t, Node n, String extraMessage) {\n+    compiler.report(JSError.make(t, n, BASE_CLASS_ERROR, extraMessage));\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n         Scope s, String name,\n         Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n       // Don't allow multiple variables to be declared at the top level scope\n-      if (!compiler.getCodingConvention().allowsVariableRedeclaration(\n-          scope, name, parent)) {\n-\n+      if (scope.isGlobal()) {\n         Scope.Var origVar = scope.getVar(name);\n         Node origParent = origVar.getParentNode();\n         if (origParent.getType() == Token.CATCH &&\n--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n import com.google.javascript.rhino.Node;\n \n import junit.framework.TestCase;\n+\n+import java.io.IOException;\n \n /**\n  * Tests for {@link CompilerRunner}.\n \n   public void testCheckSymbolsOffForDefault() {\n     CompilerRunner.FLAG_warning_level.setForTest(WarningLevel.DEFAULT);\n-    testSame(\"x = 3;\");\n+    testSame(\"x = 3; var y; var y;\");\n   }\n \n   public void testCheckSymbolsOnForVerbose() {\n     CompilerRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n     test(\"x = 3;\", VarCheck.UNDEFINED_VAR_ERROR);\n+    test(\"var y; var y;\", SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n   }\n \n   public void testCheckSymbolsOverrideForVerbose() {\n     test(\"function (a, a) {}\", RhinoErrorReporter.DUPLICATE_PARAM);\n     assertTrue(lastCompiler.hasHaltingErrors());\n   }\n+\n+  /* Helper functions */\n \n   private void testSame(String original) {\n     testSame(new String[] { original });\n     for (int i = 0; i < original.length; i++) {\n       inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n     }\n+    CompilerOptions options = runner.createOptions();\n+    try {\n+      runner.setRunOptions(options);\n+    } catch (IOException e) {\n+      assert(false);\n+    }\n     compiler.compile(\n-        externs, CompilerTestCase.createModuleChain(original),\n-        runner.createOptions());\n+        externs, CompilerTestCase.createModuleChain(original), options);\n     return compiler;\n   }\n \n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n     CompilerOptions options = new CompilerOptions();\n     options.setWarningLevel(\n         DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n+    options.setCodingConvention(getCodingConvention());\n     return options;\n+  }\n+\n+  protected CodingConvention getCodingConvention() {\n+    return new GoogleCodingConvention();\n   }\n \n   /**\n \n   private Compiler createCompiler() {\n     Compiler compiler = new Compiler();\n-    compiler.setCodingConvention(getCodingConvention());\n     return compiler;\n   }\n-\n-  protected CodingConvention getCodingConvention() {\n-    return new GoogleCodingConvention();\n-  }\n }\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n \n import com.google.javascript.rhino.Node;\n import com.google.javascript.jscomp.CheckLevel;\n+import static com.google.javascript.jscomp.ProcessClosurePrimitives.BASE_CLASS_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.DUPLICATE_NAMESPACE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.FUNCTION_NAMESPACE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_ARGUMENT_ERROR;\n   public void testInvalidProvide() {\n     test(\"goog.provide('a.class');\", null, INVALID_PROVIDE_ERROR);\n   }\n+\n+  private static final String METHOD_FORMAT =\n+      \"function Foo() {} Foo.prototype.method = function() { %s };\";\n+\n+  private static final String FOO_INHERITS =\n+      \"goog.inherits(Foo, BaseFoo);\";\n+\n+  public void testInvalidBase1() {\n+    test(\"goog.base(this, 'method');\", null, BASE_CLASS_ERROR);\n+  }\n+\n+  public void testInvalidBase2() {\n+    test(\"function Foo() {}\" +\n+         \"Foo.method = function() {\" +\n+         \"  goog.base(this, 'method');\" +\n+         \"};\", null, BASE_CLASS_ERROR);\n+  }\n+\n+  public void testInvalidBase3() {\n+    test(String.format(METHOD_FORMAT, \"goog.base();\"),\n+         null, BASE_CLASS_ERROR);\n+  }\n+\n+  public void testInvalidBase4() {\n+    test(String.format(METHOD_FORMAT, \"goog.base(this, 'bar');\"),\n+         null, BASE_CLASS_ERROR);\n+  }\n+\n+  public void testInvalidBase5() {\n+    test(String.format(METHOD_FORMAT, \"goog.base('foo', 'method');\"),\n+         null, BASE_CLASS_ERROR);\n+  }\n+\n+  public void testInvalidBase6() {\n+    test(String.format(METHOD_FORMAT, \"goog.base.call(null, this, 'method');\"),\n+         null, BASE_CLASS_ERROR);\n+  }\n+\n+  public void testInvalidBase7() {\n+    test(\"function Foo() { goog.base(this); }\",\n+         null, BASE_CLASS_ERROR);\n+  }\n+\n+  public void testInvalidBase8() {\n+    test(\"var Foo = function() { goog.base(this); }\",\n+         null, BASE_CLASS_ERROR);\n+  }\n+\n+  public void testInvalidBase9() {\n+    test(\"var goog = {}; goog.Foo = function() { goog.base(this); }\",\n+         null, BASE_CLASS_ERROR);\n+  }\n+\n+  public void testValidBase1() {\n+    test(String.format(METHOD_FORMAT, \"goog.base(this, 'method');\"),\n+         String.format(METHOD_FORMAT, \"Foo.superClass_.method.call(this)\"));\n+  }\n+\n+  public void testValidBase2() {\n+    test(String.format(METHOD_FORMAT, \"goog.base(this, 'method', 1, 2);\"),\n+         String.format(METHOD_FORMAT,\n+             \"Foo.superClass_.method.call(this, 1, 2)\"));\n+  }\n+\n+  public void testValidBase3() {\n+    test(String.format(METHOD_FORMAT, \"return goog.base(this, 'method');\"),\n+         String.format(METHOD_FORMAT,\n+             \"return Foo.superClass_.method.call(this)\"));\n+  }\n+\n+  public void testValidBase4() {\n+    test(\"function Foo() { goog.base(this, 1, 2); }\" + FOO_INHERITS,\n+         \"function Foo() { BaseFoo.call(this, 1, 2); } \" + FOO_INHERITS);\n+  }\n+\n+  public void testValidBase5() {\n+    test(\"var Foo = function() { goog.base(this, 1); };\" + FOO_INHERITS,\n+         \"var Foo = function() { BaseFoo.call(this, 1); }; \" + FOO_INHERITS);\n+  }\n+\n+  public void testValidBase6() {\n+    test(\"var goog = {}; goog.Foo = function() { goog.base(this); }; \" +\n+         \"goog.inherits(goog.Foo, goog.BaseFoo);\",\n+         \"var goog = {}; goog.Foo = function() { goog.BaseFoo.call(this); }; \" +\n+         \"goog.inherits(goog.Foo, goog.BaseFoo);\");\n+  }\n }", "timestamp": 1258665784, "metainfo": ""}