{"sha": "bd7f6b05affb62305cbd6a405d08e084376907d0", "log": "Fix alternation corner-cases in regex optimizer.  /a{1,2}/  /a{3,}/  /\\d{2,}/  |         |       | v         v       v  /aa?/     /aaa+/   /\\d\\d+/  R=acleung DELTA=160  (133 added, 11 deleted, 16 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2006   ", "commit": "\n--- a/src/com/google/javascript/jscomp/regex/RegExpTree.java\n+++ b/src/com/google/javascript/jscomp/regex/RegExpTree.java\n       this.text = text;\n     }\n \n-    static void escapeRegularCharOnto(char ch, StringBuilder sb) {\n+    /**\n+     * @param ch The code-unit to escape.\n+     * @param next The next code-unit or -1 if indeterminable.\n+     */\n+    private static void escapeRegularCharOnto(\n+        char ch, int next, StringBuilder sb) {\n       switch (ch) {\n         case '$':\n         case '^':\n         case '(':\n         case ')':\n         case '+':\n-        case '{':\n         case '[':\n         case '|':\n         case '.':\n         case '?':\n           sb.append('\\\\').append(ch);\n           break;\n+        case '{':\n+          // If possibly part of a repetition, then escape.\n+          // Concatenation is handled by the digitsMightBleed check.\n+          if ('0' <= next && next <= '9') {\n+            sb.append('\\\\');\n+          }\n+          sb.append(ch);\n+          break;\n         default:\n           escapeCharOnto(ch, sb);\n       }\n     @Override\n     protected void appendSourceCode(StringBuilder sb) {\n       for (int i = 0, n = text.length(); i < n; ++i) {\n-        escapeRegularCharOnto(text.charAt(i), sb);\n+        escapeRegularCharOnto(text.charAt(i), i + 1 < n ? text.charAt(i + 1) : -1, sb);\n       }\n     }\n \n       return ImmutableList.of(body);\n     }\n \n-    @Override\n-    protected void appendSourceCode(StringBuilder sb) {\n+    private void appendBodySourceCode(StringBuilder sb) {\n       if (body instanceof Alternation || body instanceof Concatenation\n           || body instanceof Repetition\n           || (body instanceof Text && ((Text) body).text.length() > 1)) {\n       } else {\n         body.appendSourceCode(sb);\n       }\n+    }\n+\n+    private static int suffixLen(int min, int max) {\n+      // This mirrors the branches that renders a suffix in appendSourceCode below.\n+      if (max == Integer.MAX_VALUE) {\n+        switch (min) {\n+          case 0: return 1;  // *\n+          case 1: return 1;  // +\n+          default: return 3 + numDecimalDigits(min);  // {3,}\n+        }\n+      }\n+      if (min == 0 && max == 1) {\n+        return 1;  // ?\n+      }\n+      if (min == max) {\n+        if (min == 1) {\n+          return 0;  // No suffix needed for {1}.\n+        }\n+        return 2 + numDecimalDigits(min);  // {4}\n+      }\n+      return 3 + numDecimalDigits(min) + numDecimalDigits(max);  // {2,7}\n+    }\n+\n+    private static int numDecimalDigits(int n) {\n+      if (n < 0) {\n+        // Negative values should not be passed in.\n+        throw new AssertionError();\n+        // If changing this code to support negative values,\n+        // Integer.MIN_VALUE is a corner-case..\n+      }\n+      int nDigits = 1;\n+      while (n >= 10) {\n+        ++nDigits;\n+        n /= 10;\n+      }\n+      return nDigits;\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      int bodyStart = sb.length();\n+      appendBodySourceCode(sb);\n+      int bodyEnd = sb.length();\n+      int bodyLen = bodyEnd - bodyStart;\n+      int min = this.min;\n+      int max = this.max;\n+      if (min >= 2 && max == Integer.MAX_VALUE || max - min <= 1) {\n+        int expanded =\n+           // If min == max then we want to try expanding to the limit and\n+           // attach the empty suffix, which is equivalent to min = max = 1,\n+           // i.e. /a/ vs /a{1}/.\n+           min == max\n+           // Give aa+ preference over aaa*.\n+           || max == Integer.MAX_VALUE\n+           ? min - 1\n+           : min;\n+        int expandedMin = min - expanded;\n+        int expandedMax = max == Integer.MAX_VALUE ? max : max - expanded;\n+        int suffixLen = suffixLen(min, max);\n+        int expandedSuffixLen = suffixLen(expandedMin, expandedMax);\n+        if (bodyLen * expanded + expandedSuffixLen < suffixLen\n+            && !body.hasCapturingGroup()) {\n+          // a{2} -> aa\n+          // a{2,} -> aa+\n+          // a{2,3} -> aaa?\n+          while (--expanded >= 0) {\n+            sb.append(sb, bodyStart, bodyEnd);\n+          }\n+          min = expandedMin;\n+          max = expandedMax;\n+        }\n+      }\n+\n       if (max == Integer.MAX_VALUE) {\n         switch (min) {\n           case 0: sb.append('*'); break;\n       } else if (min == 0 && max == 1) {\n         sb.append('?');\n       } else if (min == max) {\n-        sb.append('{').append(min).append('}');\n+        if (min != 1) {\n+          sb.append('{').append(min).append('}');\n+        }\n       } else {\n         sb.append('{').append(min).append(',').append(max).append('}');\n       }\n \n     @Override\n     protected void appendSourceCode(StringBuilder sb) {\n+      // True if the last content written might consume\n+      // decimal digits written subsequently.\n       boolean digitsMightBleed = false;\n       for (RegExpTree element : elements) {\n         boolean parenthesize = false;\n         if (element instanceof Alternation\n             || element instanceof Concatenation) {\n           parenthesize = true;\n-        } else {\n-          digitsMightBleed = element instanceof Text;\n-          if (digitsMightBleed) {\n-            Text text = (Text) element;\n-            if (text.text.length() != 0) {\n-              char first = text.text.charAt(0);\n-              parenthesize = '0' <= first && first <= '9';\n-            }\n-          }\n         }\n         if (parenthesize) {\n           sb.append(\"(?:\");\n           element.appendSourceCode(sb);\n           sb.append(')');\n         } else {\n+          int start = sb.length();\n           element.appendSourceCode(sb);\n-        }\n-        digitsMightBleed = element instanceof BackReference\n-            && ((BackReference) element).groupIndex < 10;\n+          if (digitsMightBleed && sb.length() > start) {\n+            char firstChar = sb.charAt(start);\n+            if ('0' <= firstChar && firstChar <= '9') {\n+              // Bleeding happened.\n+              // If the last character would be ambiguous\n+              // with a repetition, escape it.\n+              if (sb.charAt(start - 1) == '{') {\n+                // Concatenation from optimization of\n+                // /{(?:0,}/ -> /\\{0,}/\n+                sb.insert(start - 1, '\\\\');\n+              } else {\n+                // Or parenthesize otherwise.\n+                // Concatenation from optimization of\n+                // /(.)\\1(?:0)/ -> /(.)\\1(?:0)/.\n+                sb.insert(start, \"(?:\").append(')');\n+              }\n+            }\n+          }\n+        }\n+        digitsMightBleed = (\n+            // \\1(?:0) bleeds if there are 10 or more\n+            // capturing groups preceding.\n+            (element instanceof BackReference\n+             && ((BackReference) element).groupIndex < 10)\n+            // foo{(?:10}) bleeds.\n+            || (element instanceof Text\n+                && ((Text) element).text.endsWith(\"{\")));\n       }\n     }\n \n--- a/test/com/google/javascript/jscomp/PeepholeSimplifyRegExpTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSimplifyRegExpTest.java\n     testSame(\"/a?/\");\n     testSame(\"/a{6}/\");\n     testSame(\"/a{4,}/\");\n+    test(\"/a{3,}/\",\n+         \"/aaa+/\");\n     testSame(\"/a{4,6}/\");\n     testSame(\"/a{4,6}?/\");\n     test(\"/(?:a?)?/\", \"/a?/\");\n     test(\"/a(?:a*)?/\", \"/a+/\");\n     test(\"/(?:a{2,3}){3,4}/\", \"/a{6,12}/\");\n     test(\"/a{2,3}a{3,4}/\", \"/a{5,7}/\");\n-    testSame(\"/a{2,3}b{3,4}/\");\n+    testSame(\"/a{5,7}b{5,6}/\");\n+    test(\"/a{2,3}b{3,4}/\",\n+         \"/aaa?bbbb?/\");\n+    test(\"/a{3}b{3,4}/\",\n+         \"/aaabbbb?/\");\n+    testSame(\"/[a-z]{1,2}/\");\n+    test(\"/\\\\d{1,2}/\",\n+         \"/\\\\d\\\\d?/\");\n     test(\"/a*a*/\", \"/a*/\");\n-    test(\"/a+a+/\", \"/a{2,}/\");\n+    test(\"/a+a+/\", \"/aa+/\");\n     test(\"/a+a*/\", \"/a+/\");\n-    // In partial repetitions the open curly is treated literally.\n-    test(\"/a{/\", \"/a\\\\{/\");\n-    test(\"/a{}/\", \"/a\\\\{}/\");\n-    test(\"/a{,3}/\", \"/a\\\\{,3}/\");\n-    test(\"/a{x}/\", \"/a\\\\{x}/\");\n-    test(\"/a{-1}/\", \"/a\\\\{-1}/\");\n-    test(\"/a{3,1}/\", \"/a\\\\{3,1}/\");\n+    // We don't conflate literal curly brackets with repetitions.\n+    testSame(\"/a\\\\{3,1}/\");\n+    test(\"/a(?:{3,1})/\", \"/a\\\\{3,1}/\");\n+    test(\"/a{3\\\\,1}/\", \"/a\\\\{3,1}/\");\n+    testSame(\"/a\\\\{3}/\");\n+    testSame(\"/a\\\\{3,}/\");\n+    testSame(\"/a\\\\{1,3}/\");\n+    // We don't over-escape curly brackets.\n+    testSame(\"/a{/\");\n+    testSame(\"/a{}/\");\n+    testSame(\"/a{x}/\");\n+    testSame(\"/a{-1}/\");\n+    testSame(\"/a{,3}/\");\n+    testSame(\"/{{[a-z]+}}/\");\n+    testSame(\"/{\\\\{0}}/\");\n+    testSame(\"/{\\\\{0?}}/\");\n   }\n \n   public final void testMoreCharsets() {", "timestamp": 1306284267, "metainfo": ""}