{"sha": "847b296c23a63aa0a0b38cc3e63883e1688288e3", "log": "Add support for other charset types.  Add support for ES5 directives.  Fork unit tests, so that they run more hermetically.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n package com.google.javascript.jscomp;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Charsets;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Maps;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.PrintStream;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n       \"the variable is marked true.\")\n   public static final Flag<List<String>> FLAG_define = Flag.stringCollector();\n \n+  @FlagSpec(help = \"Input charset for all files.\")\n+  static final Flag<String> FLAG_charset = Flag.value(\"\");\n+\n   private PrintStream out;\n   private final PrintStream err;\n   private A compiler;\n+\n+  private static Charset inputCharset;\n \n   public AbstractCompilerRunner(String[] args) {\n     this(args, System.out, System.err);\n     return compiler;\n   }\n \n-  final protected void setRunOptions(B options) throws IOException {\n+  final protected void setRunOptions(B options)\n+      throws IOException, FlagUsageException {\n     if (FLAG_js_output_file.get().length() > 0) {\n       options.jsOutputFile = FLAG_js_output_file.get();\n     }\n     if (FLAG_third_party.get()) {\n       options.setCodingConvention(new DefaultCodingConvention());\n     }\n+\n+    inputCharset = getInputCharset();\n   }\n \n   /**\n     boolean usingStdin = false;\n     for (String filename : files) {\n       if (!\"-\".equals(filename)) {\n-        inputs.add(JSSourceFile.fromFile(filename));\n+        JSSourceFile newFile = JSSourceFile.fromFile(filename, inputCharset);\n+        inputs.add(newFile);\n       } else {\n         if (!allowStdIn) {\n           throw new FlagUsageException(\"Can't specify stdin.\");\n \n     setRunOptions(options);\n \n-    if (!options.jsOutputFile.equals(\"\")) {\n-      out = new PrintStream(options.jsOutputFile);\n+    // Let the outputCharset be the same as the input charset... except if\n+    // we're reading in UTF-8 by default.  By tradition, we've always\n+    // output ASCII to avoid various hiccups with different browsers,\n+    // proxies and firewalls.\n+    if (inputCharset == Charsets.UTF_8) {\n+      options.outputCharset = Charsets.US_ASCII;\n+    } else {\n+      options.outputCharset = inputCharset;\n+    }\n+\n+    if (!options.jsOutputFile.isEmpty()) {\n+      out = new PrintStream(options.jsOutputFile, inputCharset.name());\n     }\n \n     ((PrintStreamErrorManager) compiler.getErrorManager())\n     return Math.min(result.errors.length, 0x7f);\n   }\n \n+  /**\n+   * Query the flag for the charset, and return a Charset object representing\n+   * the selection.  Keep this in a separate function\n+   * so it can be called both in static and normal methods.\n+   *\n+   * @return Charset to use when reading inputs\n+   * @throws FlagUsageException if flag is not a valid Charset name.\n+   */\n+  private static Charset getInputCharset() throws FlagUsageException {\n+    if (!FLAG_charset.get().isEmpty()) {\n+      if (!Charset.isSupported(FLAG_charset.get())) {\n+        throw new FlagUsageException(FLAG_charset.get() +\n+            \" is not a valid charset name.\");\n+      }\n+      return Charset.forName(FLAG_charset.get());\n+    }\n+    return Charsets.UTF_8;\n+  }\n+\n   protected List<JSSourceFile> createExterns() throws FlagUsageException,\n       IOException {\n     return createExternInputs(FLAG_externs.get());\n \n     String mapPath = null;\n \n-    if (sourceMapPath.contains(File.separator)) {\n+    if (sourceMapPath.contains(\"/\") || sourceMapPath.contains(\"\\\\\")) {\n       mapPath = sourceMapPath;\n     } else {\n       File outputFile = new File(path);\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Charsets;\n import com.google.common.base.Preconditions;\n import com.google.common.base.StringUtil;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.TokenStream;\n \n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n \n /**\n  * CodeGenerator generates codes from a parse tree, sending it to the specified\n \n   private final CodeConsumer cc;\n \n+  private final CharsetEncoder outputCharsetEncoder;\n+\n+  CodeGenerator(CodeConsumer consumer, Charset outputCharset) {\n+    cc = consumer;\n+    if (outputCharset == null || outputCharset == Charsets.US_ASCII) {\n+      // If we want our default (pretending to be UTF-8, but escaping anything\n+      // outside of straight ASCII), then don't use the encoder, but\n+      // just special-case the code.  This keeps the normal path through\n+      // the code identical to how it's been for years.\n+      this.outputCharsetEncoder = null;\n+    } else {\n+      this.outputCharsetEncoder = outputCharset.newEncoder();\n+    }\n+  }\n+\n   CodeGenerator(CodeConsumer consumer) {\n-    cc = consumer;\n+    this(consumer, null);\n   }\n \n   void add(String str) {\n           throw new Error(\"Expected children to be strings\");\n         }\n \n-        String regexp = regexpEscape(first.getString());\n+        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n \n         // I only use one .add because whitespace matters\n         if (childCount == 2) {\n \n       case Token.STRING:\n         Preconditions.checkState(childCount == 0);\n-        add(jsString(n.getString()));\n+        add(jsString(n.getString(), outputCharsetEncoder));\n         break;\n \n       case Token.DELPROP:\n   }\n \n   /** Outputs a js string, using the optimal (single/double) quote character */\n-  static String jsString(String s) {\n+  static String jsString(String s, CharsetEncoder outputCharsetEncoder) {\n     int singleq = 0, doubleq = 0;\n \n     // could count the quotes and pick the optimal quote character\n       singlequote = \"\\'\";\n     }\n \n-    return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\");\n+    return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\",\n+        outputCharsetEncoder);\n   }\n \n   /** Escapes regular expression */\n+  static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {\n+    return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder);\n+  }\n+\n+  /* If the user doesn't want to specify an output charset encoder, assume\n+     they want Latin/ASCII characters only.\n+   */\n   static String regexpEscape(String s) {\n-    return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\");\n+    return regexpEscape(s, null);\n   }\n \n   /** Helper to escape javascript string as well as regular expression */\n   static String strEscape(String s, char quote,\n                           String doublequoteEscape,\n                           String singlequoteEscape,\n-                          String backslashEscape) {\n+                          String backslashEscape,\n+                          CharsetEncoder outputCharsetEncoder) {\n     StringBuilder sb = new StringBuilder();\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n           }\n           break;\n         default:\n-          // Please keep in sync with the same code in identifierEscape().\n-          if (c > 0x1F && c < 0x7F) {\n-            // Non-control ASCII characters are safe to transmit\n-            sb.append(c);\n+          // If we're given an outputCharsetEncoder, then check if the\n+          //  character can be represented in this character set.\n+          if (outputCharsetEncoder != null) {\n+            if (outputCharsetEncoder.canEncode(c)) {\n+              sb.append(c);\n+            } else {\n+              // Unicode-escape the character.\n+              StringUtil.appendHexJavaScriptRepresentation(sb, c);\n+            }\n           } else {\n-            // Other characters can be misinterpreted by some js parsers,\n-            // or perhaps mangled by proxies along the way,\n-            // so we play it safe and unicode escape them.\n-            StringUtil.appendHexJavaScriptRepresentation(sb, c);\n+            // No charsetEncoder provided - pass straight latin characters\n+            // through, and escape the rest.  Doing the explicit character\n+            // check is measurably faster than using the CharsetEncoder.\n+            if (c > 0x1f && c <= 0x7f) {\n+              sb.append(c);\n+            } else {\n+              // Other characters can be misinterpreted by some js parsers,\n+              // or perhaps mangled by proxies along the way,\n+              // so we play it safe and unicode escape them.\n+              StringUtil.appendHexJavaScriptRepresentation(sb, c);\n+            }\n           }\n       }\n     }\n     StringBuilder sb = new StringBuilder();\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n-      // See comments for the same code in strEscape(). Please keep in sync.\n+      // Identifiers should always go to Latin1/ ASCII characters because\n+      // different browser's rules for valid identifier characters are\n+      // crazy.\n       if (c > 0x1F && c < 0x7F) {\n         sb.append(c);\n       } else {\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.Node;\n \n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Stack;\n     private boolean outputTypes = false;\n     private int lineLengthThreshold = DEFAULT_LINE_LENGTH_THRESHOLD;\n     private SourceMap sourceMap = null;\n+    // Specify a charset to use when outputting source code.  If null,\n+    // then just output ASCII.\n+    private Charset outputCharset = null;\n \n     /**\n      * Sets the root node from which to generate the source code.\n      */\n     Builder setSourceMap(SourceMap sourceMap) {\n       this.sourceMap = sourceMap;\n+      return this;\n+    }\n+\n+    Builder setOutputCharset(Charset outCharset) {\n+      this.outputCharset = outCharset;\n       return this;\n     }\n \n               : Format.COMPACT;\n \n       return toSource(root, outputFormat, lineBreak, lineLengthThreshold,\n-          sourceMap);\n+          sourceMap, outputCharset);\n     }\n   }\n \n    */\n   private static String toSource(Node root, Format outputFormat,\n                                  boolean lineBreak,  int lineLengthThreshold,\n-                                 SourceMap sourceMap) {\n+                                 SourceMap sourceMap,\n+                                 Charset outputCharset) {\n     boolean createSourceMap = (sourceMap != null);\n     CodeConsumer cp =\n         outputFormat == Format.COMPACT\n         : new PrettyCodePrinter(lineLengthThreshold, createSourceMap);\n     CodeGenerator cg =\n         outputFormat == Format.TYPED\n-        ? new TypedCodeGenerator(cp)\n-        : new CodeGenerator(cp);\n+        ? new TypedCodeGenerator(cp, outputCharset)\n+        : new CodeGenerator(cp, outputCharset);\n     cg.add(root);\n \n     String code = ((HasGetCode) cp).getCode();\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     if (options_.recordFunctionInformation) {\n       recordFunctionInformation();\n     }\n+\n+    if (options_.devMode == DevMode.START_AND_END) {\n+      runSanityCheck();\n+    }\n   }\n \n   public void parse() {\n     }\n   };\n \n-  private void maybeSanityCheck(String passName) {\n+  private void maybeSanityCheck() {\n     if (options_.devMode == DevMode.EVERY_PASS) {\n-      sanityCheck.create(this).process(null, jsRoot);\n-    }\n+      runSanityCheck();\n+    }\n+  }\n+\n+  private void runSanityCheck() {\n+    sanityCheck.create(this).process(null, jsRoot);\n   }\n \n   /**\n     currentPassName = null;\n     currentTracer = null;\n \n-    maybeSanityCheck(passToCheck);\n+    maybeSanityCheck();\n   }\n \n   /**\n         }\n \n         if (devMode) {\n-          sanityCheck.create(this).process(null, n);\n+          runSanityCheck();\n           if (hasErrors()) {\n             return null;\n           }\n     builder.setPrettyPrint(options_.prettyPrint);\n     builder.setLineBreak(options_.lineBreak);\n     builder.setSourceMap(sourceMap_);\n+    builder.setOutputCharset(options_.outputCharset);\n     return builder.build();\n   }\n \n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n import com.google.javascript.rhino.Token;\n \n import java.io.Serializable;\n+import java.nio.charset.Charset;\n import java.util.Collections;\n import java.util.Map;\n import java.util.Set;\n   /** The output path for the source map. */\n   public String sourceMapOutputPath;\n \n+  /**\n+   * Charset to use when generating code.  If null, then output ASCII.\n+   */\n+  public Charset outputCharset;\n \n   /**\n    * Initializes compiler options. All options are disabled by default.\n     START,\n \n     /**\n+     * At the start and at the end of all optimizations.\n+     */\n+    START_AND_END,\n+\n+    /**\n      * After every pass\n      */\n     EVERY_PASS\n--- a/src/com/google/javascript/jscomp/CompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/CompilerRunner.java\n       = Flag.value(WarningLevel.DEFAULT);\n \n   @FlagSpec(help = \"Specifies whether the default externs should be excluded.\")\n-  private static final Flag<Boolean> FLAG_use_only_custom_externs\n+  static final Flag<Boolean> FLAG_use_only_custom_externs\n       = Flag.value(false);\n \n   /**\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import java.util.List;\n import java.util.Map;\n import java.util.PriorityQueue;\n-\n \n /**\n  * This is a compiler pass that computes a control flow graph.\n    *   foo() -> bar()\n    *   bar() -> END\n    */\n-  private final Multimap<Node, Node> finallyMap = Multimaps.newHashMultimap();\n+  private final Multimap<Node, Node> finallyMap = HashMultimap.create();\n \n   /**\n    * Constructor.\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n package com.google.javascript.jscomp;\n \n import static com.google.common.base.Preconditions.checkState;\n+import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType;\n import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType;\n import com.google.javascript.jscomp.ConcreteType.ConcreteUniqueType;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.TypeValidator.TypeMismatch;\n+import com.google.javascript.jscomp.graph.StandardUnionFind;\n import com.google.javascript.jscomp.graph.UnionFind;\n-import com.google.javascript.jscomp.graph.StandardUnionFind;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n \n import java.util.Collection;\n import java.util.List;\n-import java.util.logging.Logger;\n import java.util.Map;\n import java.util.Set;\n import java.util.Stack;\n+import java.util.logging.Logger;\n \n /**\n  * DisambiguateProperties renames properties to disambiguate between unrelated\n \n   /** Returns a map from field name to types for which it will be renamed. */\n   Multimap<String, Collection<T>> getRenamedTypesForTesting() {\n-    Multimap<String, Collection<T>> ret = Multimaps.newHashMultimap();\n+    Multimap<String, Collection<T>> ret = HashMultimap.create();\n     for (Map.Entry<String, Property> entry: properties.entrySet()) {\n       Property prop = entry.getValue();\n       if (!prop.skipRenaming) {\n--- a/src/com/google/javascript/jscomp/FunctionRewriter.java\n+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n                                               new EmptyFunctionReducer(),\n                                               new IdentityReducer());\n \n-    Multimap<Reducer, Reduction> reductionMap = Multimaps.newHashMultimap();\n+    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n \n     // Accumulate possible reductions in the reduction multi map.  They\n     // will be applied in the loop below.\n--- a/src/com/google/javascript/jscomp/JSSourceFile.java\n+++ b/src/com/google/javascript/jscomp/JSSourceFile.java\n \n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Charsets;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.nio.charset.Charset;\n \n \n /**\n  */\n public class JSSourceFile extends SourceFile {\n \n+  public static JSSourceFile fromFile(String fileName, Charset charSet) {\n+    return new JSSourceFile(SourceFile.fromFile(fileName, charSet));\n+  }\n+\n   public static JSSourceFile fromFile(String fileName) {\n-    return new JSSourceFile(SourceFile.fromFile(fileName));\n+    return new JSSourceFile(SourceFile.fromFile(fileName, Charsets.UTF_8));\n+  }\n+\n+  public static JSSourceFile fromFile(File file, Charset charSet) {\n+    return new JSSourceFile(SourceFile.fromFile(file, charSet));\n   }\n \n   public static JSSourceFile fromFile(File file) {\n-    return new JSSourceFile(SourceFile.fromFile(file));\n+    return new JSSourceFile(SourceFile.fromFile(file, Charsets.UTF_8));\n   }\n \n   public static JSSourceFile fromCode(String fileName, String code) {\n--- a/src/com/google/javascript/jscomp/MethodCheck.java\n+++ b/src/com/google/javascript/jscomp/MethodCheck.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n import com.google.javascript.jscomp.FunctionCheck.FunctionInfo;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n \n import java.util.Collection;\n-\n \n /**\n  * Checks method arity. Looks for the following ways of defining methods:\n \n   /** Map from method names to possible signatures */\n   final Multimap<String,FunctionInfo> methodSignatures =\n-      Multimaps.newHashMultimap();\n+      HashMultimap.create();\n \n   final MethodCompilerPass.SignatureStore signatureCallback = new Store();\n \n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n   final Set<String> nonMethodProperties = Sets.newHashSet();\n \n   final Multimap<String, Node> methodDefinitions =\n-      Multimaps.newHashMultimap();\n+      HashMultimap.create();\n \n   final AbstractCompiler compiler;\n \n--- a/src/com/google/javascript/jscomp/NameReferenceGraph.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraph.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n import com.google.javascript.jscomp.DefinitionsRemover.AssignmentDefinition;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.jscomp.DefinitionsRemover.NamedFunctionDefinition;\n import com.google.javascript.jscomp.DefinitionsRemover.UnknownDefinition;\n+import com.google.javascript.jscomp.graph.GraphNode;\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n-import com.google.javascript.jscomp.graph.GraphNode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n   // will give us the Reference edges. For example a CALL node will map to a\n   // list of possible call edge.\n   private final Multimap<Node, DiGraphEdge<Name, Reference>>\n-      referenceMap = Multimaps.newHashMultimap();\n+      referenceMap = HashMultimap.create();\n \n   // Given a qualified name, provides the Name object.\n   private Map<String, Name> nameMap = Maps.newHashMap();\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n \n package com.google.javascript.jscomp;\n \n-import javax.annotation.Nullable;\n import com.google.common.base.Pair;\n import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n import com.google.javascript.jscomp.NameReferenceGraph.Name;\n import com.google.javascript.jscomp.NameReferenceGraph.Reference;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import java.util.ArrayList;\n import java.util.Collection;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * Constructs a name reference graph.\n  *\n   // The accuracy of the analysis will depend heavily on eliminating the need\n   // to resort to this map.\n   private final Multimap<String, Pair<Name, Reference>> unknownNameUse =\n-      Multimaps.newHashMultimap();\n+      HashMultimap.create();\n \n   // Should we continue even if we found a type checker bug.\n   private static final boolean CONSERVATIVE = false;\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.jscomp.DefinitionsRemover.ExternalNameOnlyDefinition;\n import com.google.javascript.jscomp.DefinitionsRemover.UnknownDefinition;\n   public SimpleDefinitionFinder(AbstractCompiler compiler) {\n     this.compiler = compiler;\n     this.definitionSiteMap = Maps.newHashMap();\n-    this.nameDefinitionMultimap = Multimaps.newHashMultimap();\n-    this.nameUseSiteMultimap = Multimaps.newHashMultimap();\n+    this.nameDefinitionMultimap = HashMultimap.create();\n+    this.nameUseSiteMultimap = HashMultimap.create();\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/SourceFile.java\n+++ b/src/com/google/javascript/jscomp/SourceFile.java\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.Reader;\n+import java.nio.charset.Charset;\n \n /**\n  * An abstract representation of a source file that provides access to\n     }\n   }\n \n+  public static SourceFile fromFile(String fileName, Charset c) {\n+    return fromFile(new File(fileName), c);\n+  }\n+\n   public static SourceFile fromFile(String fileName) {\n     return fromFile(new File(fileName));\n+  }\n+\n+  public static SourceFile fromFile(File file, Charset c) {\n+    return new OnDisk(file, c);\n   }\n \n   public static SourceFile fromFile(File file) {\n   static class OnDisk extends SourceFile {\n     private final File file;\n \n+    // This is stored as a String, but passed in and out as a Charset so that\n+    // we can serialize the class.\n+    // Default input file format for JSCompiler has always been UTF_8.\n+    protected String inputCharset = Charsets.UTF_8.name();\n+\n+    OnDisk(File file, Charset c) {\n+      this(file);\n+      if (c != null) {\n+        this.setCharset(c);\n+      }\n+    }\n+\n+    // No Charset provided?\n     OnDisk(File file) {\n       super(file.getPath());\n-      this.file = file;\n+      this.file = file;     \n     }\n \n     @Override\n       String cachedCode = super.getCode();\n \n       if (cachedCode == null) {\n-        cachedCode = Files.toString(file, Charsets.UTF_8);\n+        cachedCode = Files.toString(file, this.getCharset());\n         super.setCode(cachedCode);\n       }\n       return cachedCode;\n     public void clearCachedSource() {\n       super.setCode(null);\n     }\n+\n+    /**\n+     * Store the Charset specification as the string version of the name,\n+     * rather than the Charset itself.  This allows us to serialize the\n+     * SourceFile class.\n+     * @param c charset to use when reading the input.\n+     */\n+    public void setCharset(Charset c) {\n+      inputCharset = c.name();\n+    }\n+\n+    /**\n+     * Get the Charset specifying how we're supposed to read the file\n+     * in off disk and into UTF-16.  This is stored as a strong to allow\n+     * SourceFile to be serialized.\n+     * @return Charset object representing charset to use.\n+     */\n+    public Charset getCharset() {\n+      return Charset.forName(inputCharset);\n+    }    \n   }\n }\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n+import java.nio.charset.Charset;\n+\n \n /**\n  * A code generator that outputs type annotations for functions and\n *\n  */\n class TypedCodeGenerator extends CodeGenerator {\n-  TypedCodeGenerator(CodeConsumer consumer) {\n-    super(consumer);\n+  TypedCodeGenerator(CodeConsumer consumer, Charset outputCharset) {\n+    super(consumer, outputCharset);\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/WarningLevel.java\n+++ b/src/com/google/javascript/jscomp/WarningLevel.java\n     options.checkUndefinedProperties = CheckLevel.OFF;\n     options.checkUnusedPropertiesEarly = false;\n     options.checkUnreachableCode = CheckLevel.WARNING;\n+    options.checkControlStructures = true;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC;\n \n import com.google.common.base.Preconditions;\n-\n-import com.google.javascript.rhino.JSDocInfo;\n-import com.google.javascript.rhino.jstype.JSTypeRegistry;\n-import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.ScriptOrFnNode;\n-import com.google.javascript.rhino.Token;\n-\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.mozilla.rhino.ast.ArrayLiteral;\n import com.google.javascript.jscomp.mozilla.rhino.ast.Assignment;\n import com.google.javascript.jscomp.mozilla.rhino.ast.AstNode;\n import com.google.javascript.jscomp.mozilla.rhino.ast.VariableInitializer;\n import com.google.javascript.jscomp.mozilla.rhino.ast.WhileLoop;\n import com.google.javascript.jscomp.mozilla.rhino.ast.WithStatement;\n-\n-import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.ScriptOrFnNode;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+\n+import java.util.Set;\n \n /**\n  * IRFactory transforms the new AST to the old AST.\n   private final JSTypeRegistry registry;\n   private final ErrorReporter errorReporter;\n   private final TransformDispatcher transformDispatcher;\n+\n+  // non-static for thread safety\n+  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n \n   private IRFactory(String sourceString,\n                     String sourceName,\n       for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) {\n         node.addChildToBack(transform((AstNode)child));\n       }\n-      return node;\n+      parseDirectives(node);\n+      return node;\n+    }\n+\n+    /**\n+     * Parse the directives, encode them in the AST, and remove their nodes.\n+     *\n+     * For information on ES5 directives, see section 14.1 of\n+     * Ecma-262, Edition 5.\n+     *\n+     * It would be nice if Rhino would eventually take care of this for\n+     * us, but right now their directive-processing is a one-off.\n+     */\n+    private void parseDirectives(Node node) {\n+      // Remove all the directives, and encode them in the AST.\n+      Set<String> directives = null;\n+      while (isDirective(node.getFirstChild())) {\n+        String directive = node.removeFirstChild().getFirstChild().getString();\n+        if (directives == null) {\n+          directives = Sets.newHashSet(directive);\n+        } else {\n+          directives.add(directive);\n+        }\n+      }\n+\n+      if (directives != null) {\n+        node.setDirectives(directives);\n+      }\n+    }\n+\n+    private boolean isDirective(Node n) {\n+      if (n == null) return false;\n+\n+      int nType = n.getType();\n+      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n+          n.getFirstChild().getType() == Token.STRING &&\n+          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n     }\n \n     @Override\n         lp.addChildToBack(transform(param));\n       }\n       node.addChildToBack(lp);\n-      node.addChildToBack(transform(functionNode.getBody()));\n+\n+      Node bodyNode = transform(functionNode.getBody());\n+      parseDirectives(bodyNode);\n+      node.addChildToBack(bodyNode);\n      return node;\n     }\n \n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n \n package com.google.javascript.rhino;\n \n-import com.google.javascript.rhino.jstype.JSType;\n import com.google.common.base.Pair;\n import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.jstype.JSType;\n \n import java.io.IOException;\n import java.io.Serializable;\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n+import java.util.Set;\n \n /**\n  * This class implements the root of the intermediate representation.\n                                     // probably generated from Java code, and\n                                     // should be resolved to the proper\n                                     // overload if possible.\n-        LAST_PROP          = 47;\n+        DIRECTIVES         = 48,    // The ES5 directives on this node.\n+        LAST_PROP          = 48;\n \n     // values of ISNUMBER_PROP to specify\n     // which of the children are Number types\n     }\n \n     /**\n+     * Sets the ES5 directives on this node.\n+     */\n+    public void setDirectives(Set<String> val) {\n+        putProp(DIRECTIVES, val);\n+    }\n+\n+    /**\n+     * Returns the set of ES5 directives for this node.\n+     */\n+    public Set<String> getDirectives() {\n+        return (Set<String>) getProp(DIRECTIVES);\n+    }\n+\n+    /**\n      * Sets whether this is a synthetic block that should not be considered\n      * a real source block.\n      */\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n package com.google.javascript.rhino.jstype;\n \n import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.Node;\n \n   // A map from interface name to types that implement it.\n   private final Multimap<String, FunctionType> interfaceToImplementors =\n-      Multimaps.newHashMultimap();\n+      HashMultimap.create();\n \n   // All the unresolved named types.\n   private final Multimap<StaticScope<JSType>, NamedType> unresolvedNamedTypes =\n--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n   @Override\n   public void tearDown() {\n     Flags.resetAllFlagsForTest();\n+    // NOTE(nicksantos): ANT needs this for some weird reason.\n+    AbstractCompilerRunner.FLAG_define.resetForTest();\n     Flags.enableStateCheckingForTest();\n   }\n \n     test(\"/** @define {boolean} */ var FOO = false;\" +\n          \"/** @define {number} */ var BAR = 3;\",\n          \"var FOO = true, BAR = 5;\");\n+  }\n+\n+  public void testScriptStrictModeNoWarning() {\n+    test(\"'use strict';\", \"\");\n+    test(\"'no use strict';\", CheckSideEffects.USELESS_CODE_ERROR);\n+  }\n+\n+  public void testFunctionStrictModeNoWarning() {\n+    test(\"function f() {'use strict';}\", \"function f() {}\");\n+    test(\"function f() {'no use strict';}\",\n+         CheckSideEffects.USELESS_CODE_ERROR);\n   }\n \n   /* Helper functions */\n     CompilerOptions options = runner.createOptions();\n     try {\n       runner.setRunOptions(options);\n+    } catch (AbstractCompilerRunner.FlagUsageException e) {\n+      fail(\"Unexpected exception \" + e);\n     } catch (IOException e) {\n       assert(false);\n     }\n--- a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n     test(\"a.b.MyClass.prototype.memberName;\", \"\");\n   }\n \n+  public void testRemoveUselessStrings() {\n+    test(\"'a';\", \"\");\n+  }\n+\n+  public void testNoRemoveUseStrict() {\n+    test(\"'use strict';\", \"'use strict'\");\n+  }\n+\n   public void testNoRemoveUselessNameStatements() {\n     removeNoOpStatements = false;\n     testSame(\"a;\");\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n \n package com.google.javascript.jscomp.parsing;\n \n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.mozilla.rhino.CompilerEnvirons;\n import com.google.javascript.jscomp.mozilla.rhino.Parser;\n import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot;\n \n   public void testScript() throws Exception {\n     parse(\"\");\n+  }\n+\n+  public void testStrictScript() throws Exception {\n+    assertNull(newParse(\"\").getDirectives());\n+    assertEquals(\n+        Sets.newHashSet(\"use strict\"),\n+        newParse(\"'use strict'\").getDirectives());\n   }\n \n   public void testName() throws Exception {", "timestamp": 1260316211, "metainfo": ""}