{"sha": "de20cf30dfdf0f885c9b97dfb75f8425df0280b9", "log": "Add an inliner option to inline function without considering whether \"capture\" of variables. Traditionally, we have avoiding inlining function with closure into scope (because they might capture unintended values) or inline functions that require temporaries into scopes that contain closures (because the temps might leak into the closure scopes). This CL does not include a means of enabling the option.  R=acleung DELTA=332  (313 added, 0 deleted, 19 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3089   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       new PassFactory(\"inlineFunctions\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      boolean assumeMinimumCapture = false;\n       boolean enableBlockInlining = !isInliningForbidden();\n       return new InlineFunctions(\n           compiler,\n           options.inlineLocalFunctions,\n           enableBlockInlining,\n           options.isAssumeStrictThis()\n-              || options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT);\n+              || options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT,\n+          assumeMinimumCapture);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n   private final boolean allowDecomposition;\n   private Set<String> knownConstants = Sets.newHashSet();\n   private final boolean assumeStrictThis;\n+  private final boolean assumeMinimumCapture;\n \n   /**\n    * @param allowDecomposition Whether an effort should be made to break down\n       AbstractCompiler compiler,\n       Supplier<String> safeNameIdSupplier,\n       boolean allowDecomposition,\n-      boolean assumeStrictThis) {\n+      boolean assumeStrictThis,\n+      boolean assumeMinimumCapture) {\n     Preconditions.checkNotNull(compiler);\n     Preconditions.checkNotNull(safeNameIdSupplier);\n     this.compiler = compiler;\n     this.safeNameIdSupplier = safeNameIdSupplier;\n     this.allowDecomposition = allowDecomposition;\n     this.assumeStrictThis = assumeStrictThis;\n+    this.assumeMinimumCapture = assumeMinimumCapture;\n   }\n \n   /** The type of inlining to perform. */\n     // a memory leak.  This isn't a problem in the global scope as those values\n     // last until explicitly cleared.\n     if (containsFunctions) {\n-      if (!t.inGlobalScope()) {\n+      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n         // TODO(johnlenz): Allow inlining into any scope without local names or\n         // inner functions.\n         return CanInlineResult.NO;\n   private boolean callMeetsBlockInliningRequirements(\n       NodeTraversal t, Node callNode, final Node fnNode,\n       Set<String> namesToAlias) {\n+    final boolean assumeMinimumCapture = this.assumeMinimumCapture;\n+\n     // Note: functions that contain function definitions are filtered out\n     // in isCanidateFunction.\n \n           if (n.getType() == Token.NAME) {\n             return n.getString().equals(\"eval\");\n           }\n-          if (n.getType() == Token.FUNCTION) {\n+          if (!assumeMinimumCapture && n.getType() == Token.FUNCTION) {\n             return n != fnNode;\n           }\n           return false;\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n   private final boolean blockFunctionInliningEnabled;\n   private final boolean inlineGlobalFunctions;\n   private final boolean inlineLocalFunctions;\n+  private final boolean assumeMinimumCapture;\n \n   private SpecializeModule.SpecializationState specializationState;\n \n       boolean inlineGlobalFunctions,\n       boolean inlineLocalFunctions,\n       boolean blockFunctionInliningEnabled,\n-      boolean assumeStrictThis) {\n+      boolean assumeStrictThis,\n+      boolean assumeMinimumCapture) {\n     Preconditions.checkArgument(compiler != null);\n     Preconditions.checkArgument(safeNameIdSupplier != null);\n     this.compiler = compiler;\n     this.inlineGlobalFunctions = inlineGlobalFunctions;\n     this.inlineLocalFunctions = inlineLocalFunctions;\n     this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;\n+    this.assumeMinimumCapture = assumeMinimumCapture;\n \n     this.injector = new FunctionInjector(\n-        compiler, safeNameIdSupplier, true, assumeStrictThis);\n+        compiler, safeNameIdSupplier,\n+        true, assumeStrictThis, assumeMinimumCapture);\n   }\n \n   FunctionState getOrCreateFunctionState(String fnName) {\n             // TODO(johnlenz): this can be improved by looking at the possible\n             // values for locals.  If there are simple values, or constants\n             // we could still inline.\n-            if (hasLocalNames(fnNode)) {\n+            if (!assumeMinimumCapture && hasLocalNames(fnNode)) {\n               fs.setInline(false);\n             }\n           }\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n   static final InliningMode INLINE_DIRECT = InliningMode.DIRECT;\n   static final InliningMode INLINE_BLOCK = InliningMode.BLOCK;\n   private boolean assumeStrictThis = false;\n+  private boolean assumeMinimumCapture = false;\n \n   @Override\n   protected void setUp() throws Exception {\n   private FunctionInjector getInjector() {\n     Compiler compiler = new Compiler();\n     return new FunctionInjector(\n-        compiler, compiler.getUniqueNameIdSupplier(), true, assumeStrictThis);\n+        compiler, compiler.getUniqueNameIdSupplier(), true,\n+        assumeStrictThis, assumeMinimumCapture);\n   }\n \n   public void testIsSimpleFunction1() {\n     final Compiler compiler = new Compiler();\n     final FunctionInjector injector = new FunctionInjector(\n         compiler, compiler.getUniqueNameIdSupplier(), allowDecomposition,\n-        assumeStrictThis);\n+        assumeStrictThis,\n+        assumeMinimumCapture);\n     final Node tree = parse(compiler, code);\n \n     Node externsRoot = new Node(Token.EMPTY);\n     final Compiler compiler = new Compiler();\n     final FunctionInjector injector = new FunctionInjector(\n         compiler, compiler.getUniqueNameIdSupplier(), decompose,\n-        assumeStrictThis);\n+        assumeStrictThis,\n+        assumeMinimumCapture);\n \n     JSSourceFile[] externsInputs = new JSSourceFile[] {\n         JSSourceFile.fromCode(\"externs\", \"\")\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n   final boolean allowFunctionExpressionInlining = true;\n   final boolean allowLocalFunctionInlining = true;\n   boolean assumeStrictThis = false;\n+  boolean assumeMinimumCapture = false;\n \n   public InlineFunctionsTest() {\n     this.enableNormalize();\n     allowGlobalFunctionInlining = true;\n     allowBlockInlining = true;\n     assumeStrictThis = false;\n+    assumeMinimumCapture = false;\n   }\n \n   @Override\n         allowGlobalFunctionInlining,\n         allowLocalFunctionInlining,\n         allowBlockInlining,\n-        assumeStrictThis);\n+        assumeStrictThis,\n+        assumeMinimumCapture);\n   }\n \n   /**\n   }\n \n   public void testInlineFunctions15b() {\n-    // closure factories: don't inline closure with locals in global scope.\n+    assumeMinimumCapture = false;\n+\n+    // closure factories: don't inline closure with locals into global scope.\n     test(\"function foo(){var x;return function(a){return a+1}}\" +\n          \"var b=function(){return c};\" +\n          \"var d=b()+foo()\",\n \n          \"function foo(){var x;return function(a){return a+1}}\" +\n          \"var d=c+foo()\");\n+\n+    assumeMinimumCapture = true;\n+\n+    test(\"function foo(){var x;return function(a){return a+1}}\" +\n+         \"var b=function(){return c};\" +\n+         \"var d=b()+foo()\",\n+\n+         \"var JSCompiler_temp_const$$0 = c;\\n\" +\n+         \"{\\n\" +\n+         \"var JSCompiler_inline_result$$1;\\n\" +\n+         \"var x$$inline_3;\\n\" +\n+         \"JSCompiler_inline_result$$1 = \" +\n+         \"    function(a$$inline_4){ return a$$inline_4+1 };\\n\" +\n+         \"}\" +\n+         \"var d=JSCompiler_temp_const$$0 + JSCompiler_inline_result$$1\");\n   }\n \n   public void testInlineFunctions15c() {\n+    assumeMinimumCapture = false;\n+\n     // closure factories: don't inline into non-global scope.\n     test(\"function foo(){return function(a){return a+1}}\" +\n          \"var b=function(){return c};\" +\n \n          \"function foo(){return function(a){return a+1}}\" +\n          \"function _x(){ var d=c+foo() }\");\n+\n+    assumeMinimumCapture = true;\n+\n+    // closure factories: don't inline into non-global scope.\n+    test(\"function foo(){return function(a){return a+1}}\" +\n+         \"var b=function(){return c};\" +\n+         \"function _x(){ var d=b()+foo() }\",\n+\n+         \"function _x(){var d=c+function(a){return a+1}}\");\n+\n   }\n \n   public void testInlineFunctions15d() {\n+    assumeMinimumCapture = false;\n+\n     // closure factories: don't inline functions with vars.\n     test(\"function foo(){var x; return function(a){return a+1}}\" +\n          \"var b=function(){return c};\" +\n \n          \"function foo(){var x; return function(a){return a+1}}\" +\n          \"function _x(){ var d=c+foo() }\");\n+\n+    assumeMinimumCapture = true;\n+\n+    // closure factories: don't inline functions with vars.\n+    test(\"function foo(){var x; return function(a){return a+1}}\" +\n+         \"var b=function(){return c};\" +\n+         \"function _x(){ var d=b()+foo() }\",\n+\n+         \"function _x() { \\n\" +\n+         \"  var JSCompiler_temp_const$$0 = c;\\n\" +\n+         \"  {\\n\" +\n+         \"  var JSCompiler_inline_result$$1;\\n\" +\n+         \"  var x$$inline_3;\\n\" +\n+         \"  JSCompiler_inline_result$$1 = \" +\n+         \"      function(a$$inline_4) {return a$$inline_4+1};\\n\" +\n+         \"  }\\n\" +\n+         \"  var d = JSCompiler_temp_const$$0+JSCompiler_inline_result$$1\\n\" +\n+         \"}\");\n   }\n \n   public void testInlineFunctions16a() {\n+    assumeMinimumCapture = false;\n+\n     testSame(\"function foo(b){return window.bar(function(){c(b)})}\" +\n          \"var d=foo(e)\");\n+\n+    assumeMinimumCapture = true;\n+\n+    test(\n+        \"function foo(b){return window.bar(function(){c(b)})}\" +\n+        \"var d=foo(e)\",\n+        \"var d;{var b$$inline_1=e;\" +\n+        \"d=window.bar(function(){c(b$$inline_1)})}\");\n   }\n \n   public void testInlineFunctions16b() {\n   }\n \n   public void testShadowVariables7() {\n+    assumeMinimumCapture = false;\n     test(\"var a=3;\" +\n          \"function foo(){return a}\" +\n          \"(function(){var a=5;(function(){foo()})()})()\",\n          \"var a=3;\" +\n          \"{var a$$inline_1=5;{a}}\"\n+         );\n+\n+    assumeMinimumCapture = true;\n+    test(\"var a=3;\" +\n+         \"function foo(){return a}\" +\n+         \"(function(){var a=5;(function(){foo()})()})()\",\n+         \"var a=3;\" +\n+         \"{var a$$inline_2=5;{a}}\"\n          );\n   }\n \n   }\n \n   public void testShadowVariables16() {\n+    assumeMinimumCapture = false;\n     // Inline functions defined as a child of the CALL node.\n     test(\"var a=3;\" +\n          \"function foo(){return a}\" +\n          \"var a=3;\" +\n          \"{var a$$inline_1=5;{a}}\"\n          );\n+\n+    assumeMinimumCapture = true;\n+    // Inline functions defined as a child of the CALL node.\n+    test(\"var a=3;\" +\n+         \"function foo(){return a}\" +\n+         \"(function(){var a=5;(function(){foo()})()})()\",\n+         \"var a=3;\" +\n+         \"{var a$$inline_2=5;{a}}\"\n+         );\n+\n   }\n \n   public void testShadowVariables17() {\n   }\n \n   public void testComplexFunctionWithFunctionDefinition2() {\n+    assumeMinimumCapture = false;\n+\n     // Don't inline if local names might be captured.\n     testSame(\"function f(a){call(function(){return})}f()\");\n+\n+    assumeMinimumCapture = true;\n+\n+    test(\"(function(){\" +\n+         \"var f = function(a){call(function(){return a})};f()})()\",\n+         \"{{var a$$inline_1=void 0;call(function(){return a$$inline_1})}}\");\n   }\n \n   public void testComplexFunctionWithFunctionDefinition2a() {\n+    assumeMinimumCapture = false;\n+\n     // Don't inline if local names might be captured.\n     testSame(\"(function(){\" +\n-        \"var f = function(a){call(function(){return})};f()})()\");\n+        \"var f = function(a){call(function(){return a})};f()})()\");\n+\n+    assumeMinimumCapture = true;\n+\n+    test(\"(function(){\" +\n+         \"var f = function(a){call(function(){return a})};f()})()\",\n+         \"{{var a$$inline_1=void 0;call(function(){return a$$inline_1})}}\");\n   }\n \n   public void testComplexFunctionWithFunctionDefinition3() {\n+    assumeMinimumCapture = false;\n+\n     // Don't inline if local names might need to be captured.\n-    testSame(\"function f(){var a; call(function(){return})}f()\");\n+    testSame(\"function f(){var a; call(function(){return a})}f()\");\n+\n+    assumeMinimumCapture = true;\n+\n+    test(\"function f(){var a; call(function(){return a})}f()\",\n+         \"{var a$$inline_1;call(function(){return a$$inline_1})}\");\n+\n   }\n \n   public void testDecomposePlusEquals() {\n   }\n \n   public void testFunctionExpressionCallInlining11b() {\n+    assumeMinimumCapture = false;\n     // Can't inline functions that return inner functions and have local names.\n     testSame(\"((function(){var a; return function(){foo()}})())();\");\n+\n+    assumeMinimumCapture = true;\n+    test(\n+        \"((function(){var a; return function(){foo()}})())();\",\n+\n+        \"{var JSCompiler_inline_result$$0;\" +\n+        \"var a$$inline_2;\" +\n+        \"JSCompiler_inline_result$$0=function(){foo()};}\" +\n+        \"JSCompiler_inline_result$$0()\");\n+\n   }\n \n   public void testFunctionExpressionCallInlining11c() {\n     // TODO(johnlenz): Can inline, not temps needed.\n+    assumeMinimumCapture = false;\n     testSame(\"function _x() {\" +\n          \"  ((function(){return function(){foo()}})())();\" +\n          \"}\");\n+\n+    assumeMinimumCapture = true;\n+    test(\n+        \"function _x() {\" +\n+        \"  ((function(){return function(){foo()}})())();\" +\n+        \"}\",\n+        \"function _x() {\" +\n+        \"  {foo()}\" +\n+        \"}\");\n   }\n \n   public void testFunctionExpressionCallInlining11d() {\n     // TODO(johnlenz): Can inline into a function containing eval, if\n     // no names are introduced.\n+    assumeMinimumCapture = false;\n     testSame(\"function _x() {\" +\n          \"  eval();\" +\n          \"  ((function(){return function(){foo()}})())();\" +\n          \"}\");\n+\n+    assumeMinimumCapture = true;\n+    test(\n+        \"function _x() {\" +\n+        \"  eval();\" +\n+        \"  ((function(){return function(){foo()}})())();\" +\n+        \"}\",\n+        \"function _x() {\" +\n+        \"  eval();\" +\n+        \"  {foo()}\" +\n+        \"}\");\n+\n   }\n \n   public void testFunctionExpressionCallInlining11e() {\n     // No, don't inline into a function containing eval,\n-    // if no temps are introduced.\n+    // if temps are introduced.\n+    assumeMinimumCapture = false;\n     testSame(\"function _x() {\" +\n          \"  eval();\" +\n          \"  ((function(a){return function(){foo()}})())();\" +\n          \"}\");\n+\n+    assumeMinimumCapture = true;\n+    test(\"function _x() {\" +\n+        \"  eval();\" +\n+        \"  ((function(a){return function(){foo()}})())();\" +\n+        \"}\",\n+        \"function _x() {\" +\n+        \"  eval();\" +\n+        \"  {foo();}\" +\n+        \"}\");\n   }\n \n   public void testFunctionExpressionCallInlining12() {\n \n   // http://en.wikipedia.org/wiki/Fixed_point_combinator#Y_combinator\n   public void testFunctionExpressionYCombinator() {\n+    assumeMinimumCapture = false;\n     testSame(\n         \"var factorial = ((function(M) {\\n\" +\n         \"      return ((function(f) {\\n\" +\n         \"     }));\\n\" +\n         \"\\n\" +\n         \"factorial(5)\\n\");\n+\n+    assumeMinimumCapture = true;\n+    test(\n+        \"var factorial = ((function(M) {\\n\" +\n+        \"      return ((function(f) {\\n\" +\n+        \"                 return M(function(arg) {\\n\" +\n+        \"                            return (f(f))(arg);\\n\" +\n+        \"                            })\\n\" +\n+        \"               })\\n\" +\n+        \"              (function(f) {\\n\" +\n+        \"                 return M(function(arg) {\\n\" +\n+        \"                            return (f(f))(arg);\\n\" +\n+        \"                           })\\n\" +\n+        \"                 }));\\n\" +\n+        \"     })\\n\" +\n+        \"    (function(f) {\\n\" +\n+        \"       return function(n) {\\n\" +\n+        \"        if (n === 0)\\n\" +\n+        \"          return 1;\\n\" +\n+        \"        else\\n\" +\n+        \"          return n * f(n - 1);\\n\" +\n+        \"       };\\n\" +\n+        \"     }));\\n\" +\n+        \"\\n\" +\n+        \"factorial(5)\\n\",\n+        \"var factorial;\\n\" +\n+        \"{\\n\" +\n+        \"var M$$inline_6 = function(f$$2) {\\n\" +\n+        \"  return function(n){if(n===0)return 1;else return n*f$$2(n-1)}\\n\" +\n+        \"};\\n\" +\n+        \"{\\n\" +\n+        \"var f$$inline_1=function(f$$inline_9){\\n\" +\n+        \"  return M$$inline_6(\\n\" +\n+        \"    function(arg$$inline_10){\\n\" +\n+        \"      return f$$inline_9(f$$inline_9)(arg$$inline_10)\\n\" +\n+        \"     })\\n\" +\n+        \"};\\n\" +\n+        \"factorial=M$$inline_6(\\n\" +\n+        \"  function(arg$$inline_2){\\n\" +\n+        \"    return f$$inline_1(f$$inline_1)(arg$$inline_2)\\n\" +\n+        \"});\\n\" +\n+        \"}\\n\" +\n+        \"}\" +\n+        \"factorial(5)\");\n   }\n \n   public void testRenamePropertyFunction() {\n           compiler,\n           compiler.getUniqueNameIdSupplier(),\n           allowGlobalFunctionInlining,\n-          true, // allowLocalFunctionInlining\n-          true, // allowBlockInlining\n-          true); // assumeStrictThis\n+          true,  // allowLocalFunctionInlining\n+          true,  // allowBlockInlining\n+          true,  // assumeStrictThis\n+          true); // assumeMinimumCapture\n     }\n \n     public void testInlineObject() {\n   }\n \n   public void testIssue423() {\n+    assumeMinimumCapture = false;\n     test(\n         \"(function($) {\\n\" +\n         \"  $.fn.multicheck = function(options) {\\n\" +\n         \"    }\" +\n         \"  }\" +\n         \"})(jQuery)\");\n+\n+    assumeMinimumCapture = true;\n+    test(\n+        \"(function($) {\\n\" +\n+        \"  $.fn.multicheck = function(options) {\\n\" +\n+        \"    initialize.call(this, options);\\n\" +\n+        \"  };\\n\" +\n+        \"\\n\" +\n+        \"  function initialize(options) {\\n\" +\n+        \"    options.checkboxes = $(this).siblings(':checkbox');\\n\" +\n+        \"    preload_check_all.call(this);\\n\" +\n+        \"  }\\n\" +\n+        \"\\n\" +\n+        \"  function preload_check_all() {\\n\" +\n+        \"    $(this).data('checkboxes');\\n\" +\n+        \"  }\\n\" +\n+        \"})(jQuery)\",\n+        \"{var $$$inline_3=jQuery;\\n\" +\n+        \"$$$inline_3.fn.multicheck=function(options$$inline_7){\\n\" +\n+        \"  {options$$inline_7.checkboxes=\" +\n+            \"$$$inline_3(this).siblings(\\\":checkbox\\\");\\n\" +\n+        \"  {$$$inline_3(this).data(\\\"checkboxes\\\")}\" +\n+        \"  }\\n\" +\n+        \"}\\n\" +\n+        \"}\");\n   }\n \n   public void testAnonymous1() {\n+    assumeMinimumCapture = false;\n     test(\"(function(){var a=10;(function(){var b=a;a++;alert(b)})()})();\",\n          \"{var a$$inline_2=10;\" +\n          \"{var b$$inline_3=a$$inline_2;\" +\n          \"a$$inline_2++;alert(b$$inline_3)}}\");\n+\n+    assumeMinimumCapture = true;\n+    test(\"(function(){var a=10;(function(){var b=a;a++;alert(b)})()})();\",\n+        \"{var a$$inline_4=10;\" +\n+        \"{var b$$inline_1=a$$inline_4;\" +\n+        \"a$$inline_4++;alert(b$$inline_1)}}\");\n   }\n \n   public void testAnonymous2() {\n \n   public void testAnonymous3() {\n     // Introducing a new value into is tricky\n+    assumeMinimumCapture = false;\n     testSame(\"(function(){var a=10;(function(){arguments;})()})();\");\n+\n+    assumeMinimumCapture = true;\n+    test(\"(function(){var a=10;(function(){arguments;})()})();\",\n+         \"{var a$$inline_1=10;(function(){arguments;})();}\");\n+\n     test(\"(function(){(function(){arguments;})()})();\",\n         \"{(function(){arguments;})()}\");\n+  }\n+\n+\n+  public void testLoopWithFunctionWithFunction() {\n+    assumeMinimumCapture = true;\n+    test(\"function _testLocalVariableInLoop_() {\\n\" +\n+        \"  var result = 0;\\n\" +\n+        \"  function foo() {\\n\" +\n+        \"    var arr = [1, 2, 3, 4, 5];\\n\" +\n+        \"    for (var i = 0, l = arr.length; i < l; i++) {\\n\" +\n+        \"      var j = arr[i];\\n\" +\n+        // don't inline this function, because the correct behavior depends\n+        // captured values.\n+        \"      (function() {\\n\" +\n+        \"        var k = j;\\n\" +\n+        \"        setTimeout(function() { result += k; }, 5 * i);\\n\" +\n+        \"      })();\\n\" +\n+        \"    }\\n\" +\n+        \"  }\\n\" +\n+        \"  foo();\\n\" +\n+        \"}\",\n+        \"function _testLocalVariableInLoop_(){\\n\" +\n+        \"  var result=0;\\n\" +\n+        \"  {\" +\n+        \"  var arr$$inline_4=[1,2,3,4,5];\\n\" +\n+        \"  var i$$inline_5=0;\\n\" +\n+        \"  var l$$inline_6=arr$$inline_4.length;\\n\" +\n+        \"  for(;i$$inline_5<l$$inline_6;i$$inline_5++){\\n\" +\n+        \"    var j$$inline_7=arr$$inline_4[i$$inline_5];\\n\" +\n+        \"    (function(){\\n\" +\n+        \"       var k$$inline_8=j$$inline_7;\\n\" +\n+        \"       setTimeout(function(){result+=k$$inline_8},5*i$$inline_5)\\n\" +\n+        \"     })()\\n\" +\n+        \"  }\\n\" +\n+        \"  }\\n\" +\n+        \"}\");\n+  }\n+\n+  public void testMethodWithFunctionWithFunction() {\n+    assumeMinimumCapture = true;\n+    test(\"function _testLocalVariable_() {\\n\" +\n+        \"  var result = 0;\\n\" +\n+        \"  function foo() {\\n\" +\n+        \"      var j = [i];\\n\" +\n+        \"      (function(j) {\\n\" +\n+        \"        setTimeout(function() { result += j; }, 5 * i);\\n\" +\n+        \"      })(j);\\n\" +\n+        \"      j = null;\" +\n+        \"  }\\n\" +\n+        \"  foo();\\n\" +\n+        \"}\",\n+        \"function _testLocalVariable_(){\\n\" +\n+        \"  var result=0;\\n\" +\n+        \"  {\\n\" +\n+        \"  var j$$inline_4=[i];\\n\" +\n+        \"  {\\n\" +\n+        \"  var j$$inline_1=j$$inline_4;\\n\" +  // this temp is needed.\n+        \"  setTimeout(function(){result+=j$$inline_1},5*i);\\n\" +\n+        \"  }\\n\" +\n+        \"  j$$inline_4=null\\n\" + // because this value can be modified later.\n+        \"  }\\n\" +\n+        \"}\");\n   }\n \n   // Inline a single reference function into deeper modules\n--- a/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n+++ b/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new InlineFunctions(compiler,\n-          compiler.getUniqueNameIdSupplier(), true, false, true, true);\n+          compiler.getUniqueNameIdSupplier(), true, false, true, true, true);\n     }\n   };\n ", "timestamp": 1314059665, "metainfo": ""}