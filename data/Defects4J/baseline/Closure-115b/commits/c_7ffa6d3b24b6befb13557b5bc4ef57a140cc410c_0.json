{"sha": "7ffa6d3b24b6befb13557b5bc4ef57a140cc410c", "log": "Open-source CheckEventfulObjectDisposal pass. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=47121866", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CheckEventfulObjectDisposal.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.JSDocInfo.Visibility;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.UnionType;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Stack;\n+\n+/**\n+ * Check to ensure there exists a path to dispose of each eventful object\n+ * created.\n+ *\n+ * This compiler pass uses the inferred types and hence either type checking or\n+ * type inference needs to be enabled. The set of eventful objects is initialized\n+ * to {goog.events.Eventful} and, if the \"aggressive\" mode is set, expanded to a\n+ * larger class using the eventize relationship (see http://research.google.com/pubs/pub40738.html).\n+ *\n+ * This pass is heuristic based and should not be used for any check\n+ * of pass/fail testing.\n+ *\n+ * This check is performed interprocedurally but in a flow and path\n+ * insensitive manner.\n+ *\n+ *\n+ */\n+ // TODO(user) Pass needs to be updated for listenable interfaces.\n+public class CheckEventfulObjectDisposal implements CompilerPass {\n+\n+  // Error messages returned\n+  static final DiagnosticType EVENTFUL_OBJECT_NOT_DISPOSED = DiagnosticType.error(\n+      \"JSC_EVENTFUL_OBJECT_NOT_DISPOSED\",\n+      \"eventful object created should be\\n\" +\n+      \"  * registered as disposable, or\\n\" +\n+      \"  * explicitly disposed of\");\n+  static final DiagnosticType EVENTFUL_OBJECT_PURELY_LOCAL = DiagnosticType.error(\n+      \"JSC_EVENTFUL_OBJECT_PURELY_LOCAL\",\n+      \"a purely local eventful object cannot be disposed of later\");\n+  static final DiagnosticType OVERWRITE_PRIVATE_EVENTFUL_OBJECT = DiagnosticType.error(\n+      \"JSC_OVERWRITE_PRIVATE_EVENTFUL_OBJECT\",\n+      \"private eventful object overwritten in subclass cannot be properly disposed of\");\n+  static final DiagnosticType UNLISTEN_WITH_ANONBOUND = DiagnosticType.error(\n+      \"JSC_UNLISTEN_WITH_ANONBOUND\",\n+      \"an unlisten call with an anonymous or bound function does not result in \" +\n+      \"the event being unlisted to\");\n+\n+  /**\n+   * Policies to determine the disposal checking level.\n+   */\n+  public enum DisposalCheckingPolicy {\n+    /**\n+     * Don't check any disposal.\n+     */\n+    OFF,\n+\n+    /**\n+     * Default/conservative disposal checking.\n+     */\n+    ON,\n+\n+    /**\n+     * Aggressive disposal checking.\n+     */\n+    AGGRESSIVE,\n+  }\n+\n+  // Seed types\n+  static final String DISPOSABLE_TYPE_NAME = \"goog.Disposable\";\n+  static final String EVENT_HANDLER_TYPE_NAME = \"goog.events.EventHandler\";\n+  JSType googDisposableType;\n+  JSType googEventsEventHandlerType;\n+\n+  // Eventful types\n+  Set<JSType> eventfulTypes;\n+\n+  final AbstractCompiler compiler;\n+  final JSTypeRegistry typeRegistry;\n+\n+  // At the moment only ALLOCATED and POSSIBLY_DISPOSED are used\n+  private enum SeenType {\n+    ALLOCATED, ALLOCATED_LOCALLY, POSSIBLY_DISPOSED, DISPOSED\n+  }\n+\n+  // Combine the state and allocation site of eventful objects\n+  private class EventfulObjectState {\n+    public SeenType seen;\n+    public Node allocationSite;\n+  }\n+\n+  /*\n+   * The disposal checking policy used.\n+   */\n+  public DisposalCheckingPolicy checkingPolicy;\n+\n+  /*\n+   * Eventize DAG represented using adjacency lists.\n+   */\n+  public Map<String, Set<String>> eventizes;\n+\n+  /*\n+   * Maps from eventful object name to state.\n+   */\n+  static Map<String, EventfulObjectState> eventfulObjectMap;\n+\n+  public CheckEventfulObjectDisposal(AbstractCompiler compiler,\n+      DisposalCheckingPolicy checkingPolicy) {\n+    this.compiler = compiler;\n+    this.checkingPolicy = checkingPolicy;\n+    this.typeRegistry = compiler.getTypeRegistry();\n+  }\n+\n+  private static Node getBase(Node n) {\n+    Node base = n;\n+    while (base.isGetProp()) {\n+      base = base.getFirstChild();\n+    }\n+\n+    return base;\n+  }\n+\n+  /*\n+   * Get the type of the this in the current scope of traversal\n+   */\n+  private JSType getTypeOfThisForScope(NodeTraversal t) {\n+    JSType typeOfThis = t.getScopeRoot().getJSType();\n+    if (typeOfThis == null) {\n+      return null;\n+    }\n+    ObjectType objectType =\n+        ObjectType.cast(dereference(typeOfThis));\n+    return objectType.getTypeOfThis();\n+  }\n+\n+\n+  /*\n+   * Determines if thisType is possibly a subtype of thatType.\n+   *\n+   *  It differs from isSubtype only in that thisType gets expanded\n+   *  if it is a union.\n+   *\n+   *  Common case targeted is a function returning an eventful object\n+   *  that may also return a null.\n+   */\n+  private static boolean isPossiblySubtype(JSType thisType, JSType thatType) {\n+    if (thisType == null) {\n+      return false;\n+    }\n+\n+    JSType type = thisType;\n+\n+    if (type.isUnionType()) {\n+      for (JSType alternate : type.toMaybeUnionType().getAlternates()) {\n+        if (alternate.isSubtype(thatType)) {\n+          return true;\n+        }\n+      }\n+    } else {\n+      if (type.isSubtype(thatType)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static JSType dereference(JSType type) {\n+    return type == null ? null : type.dereference();\n+  }\n+\n+  /*\n+   * Create a unique identification string for Node n, or null if function\n+   * called with invalid argument.\n+   *\n+   * This function is basically used to distinguish between:\n+   *   A.B = function() {\n+   *     this.eh = new ...\n+   *   }\n+   * and\n+   *   C.D = function() {\n+   *     this.eh = new ...\n+   *   }\n+   *\n+   * As well as\n+   *   A.B = function() {\n+   *     var eh = new ...\n+   *   }\n+   * and\n+   *   C.D = function() {\n+   *     var eh = new ...\n+   *   }\n+   *\n+   * Warning: Inheritance is not currently handled.\n+   */\n+  private static String generateKey(NodeTraversal t, Node n, boolean noLocalVariables) {\n+    if (n == null) {\n+      return null;\n+    }\n+    String key;\n+\n+    Node scopeNode = t.getScopeRoot();\n+\n+    if (n.isName()) {\n+      if (noLocalVariables) {\n+        return null;\n+      }\n+      key = n.getQualifiedName();\n+\n+      if (scopeNode.isFunction()) {\n+        JSType parentScopeType = t.getScope().getParentScope().getTypeOfThis();\n+        /*\n+         * If the locally defined variable is defined within a function, use\n+         * the function name to create ID.\n+         */\n+        if (!parentScopeType.isGlobalThisType()) {\n+          key = parentScopeType.toString() + \"~\" + key;\n+        }\n+        key = NodeUtil.getFunctionName(scopeNode) + \"=\" + key;\n+      }\n+    } else {\n+      /*\n+       * Only handle cases such as a.b.c.X and not cases where the\n+       * eventful object is stored in an array or uses a function to\n+       * determine the index.\n+       *\n+       * Note: Inheritance changes the name that should be returned here\n+       */\n+      if (!n.isQualifiedName()) {\n+        return null;\n+      }\n+      key = n.getQualifiedName();\n+\n+      /*\n+       * If it is not a simple variable and doesn't use this, then we assume\n+       * global variable.\n+       */\n+      Node base = getBase(n);\n+      if (base != null && base.isThis()) {\n+        if (base.getJSType().isUnknownType()) {\n+          // Handle anonymous function created in constructor:\n+          //\n+          // /**\n+          // * @extends {goog.SubDisposable}\n+          // * @constructor */\n+          // speel.Person = function() {\n+          //  this.run = function() {\n+          //    this.eh = new goog.events.EventHandler();\n+          //  }\n+          //};\n+          key = t.getScope().getParentScope().getTypeOfThis().toString() + \"~\" + key;\n+        } else {\n+          if (n.getFirstChild() == null) {\n+            key = base.getJSType().toString() + \"=\" + key;\n+          } else {\n+            ObjectType objectType =\n+                ObjectType.cast(dereference(n.getFirstChild().getJSType()));\n+            if (objectType == null) {\n+              return null;\n+            }\n+\n+            ObjectType hObjT = objectType;\n+            String propertyName = n.getLastChild().getString();\n+\n+            while (objectType != null) {\n+              hObjT = objectType;\n+              objectType = objectType.getImplicitPrototype();\n+              if (objectType == null) {\n+                break;\n+              }\n+              if (objectType.getDisplayName().endsWith(\"prototype\")) {\n+                continue;\n+              }\n+              if (!objectType.getPropertyNames().contains(propertyName)) {\n+                break;\n+              }\n+            }\n+            key = hObjT.toString() + \"=\" + key;\n+          }\n+        }\n+      }\n+    }\n+\n+    return key;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    // This pass should not have gotten added in this case\n+    Preconditions.checkArgument(checkingPolicy != DisposalCheckingPolicy.OFF);\n+\n+    // Initialize types\n+    googDisposableType = compiler.getTypeRegistry().getType(DISPOSABLE_TYPE_NAME);\n+    googEventsEventHandlerType = compiler.getTypeRegistry().getType(EVENT_HANDLER_TYPE_NAME);\n+\n+    /*\n+     * Required types not found therefore the kind of pattern considered\n+     * will not be found.\n+     */\n+    if (googEventsEventHandlerType == null || googDisposableType == null) {\n+      return;\n+    }\n+\n+    // Seed list of disposable stype\n+    eventfulTypes = new HashSet<JSType>();\n+    eventfulTypes.add(googEventsEventHandlerType);\n+\n+    // Construct eventizer graph\n+    if (checkingPolicy == DisposalCheckingPolicy.AGGRESSIVE) {\n+      NodeTraversal.traverse(compiler, root, new ComputeEventizeTraversal());\n+      computeEventful();\n+    }\n+\n+    /*\n+     * eventfulObjectMap maps a eventful object's \"name\" to its corresponding\n+     * EventfulObjectState which tracks the state (allocated, disposed of)\n+     * as well as allocation site.\n+     */\n+    eventfulObjectMap = new HashMap<String, EventfulObjectState>();\n+\n+    // Traverse tree\n+    NodeTraversal.traverse(compiler, root, new Traversal());\n+\n+    /*\n+     * Scan eventfulObjectMap for allocated eventful objects that\n+     * had no free/dispose/eventlistener-removal call.\n+     */\n+    for (EventfulObjectState e : eventfulObjectMap.values()) {\n+      Node n = e.allocationSite;\n+      if (e.seen == SeenType.ALLOCATED) {\n+        compiler.report(JSError.make(n.getSourceFileName(), n, EVENTFUL_OBJECT_NOT_DISPOSED));\n+      } else if (e.seen == SeenType.ALLOCATED_LOCALLY) {\n+        compiler.report(JSError.make(n.getSourceFileName(), n, EVENTFUL_OBJECT_PURELY_LOCAL));\n+      }\n+    }\n+  }\n+\n+  private void computeEventful() {\n+    /*\n+     * Topological order of Eventize DAG\n+     */\n+    String[] order = new String[eventizes.size()];\n+\n+    /*\n+     * Perform topological sort\n+     */\n+    int white = 0, gray = 1, black = 2;\n+    int last = eventizes.size() - 1;\n+    Map<String, Integer> color = new HashMap<String, Integer>();\n+    Stack<String> dfsStack = new Stack<String>();\n+\n+    /*\n+     * Initialize color.\n+     * Some types are only on one or the other side of the\n+     * inference.\n+     */\n+    for (String r : eventizes.keySet()) {\n+      color.put(r, white);\n+      for (String s : eventizes.get(r)) {\n+        color.put(s, white);\n+      }\n+    }\n+\n+    int indx = 0;\n+    for (String s : eventizes.keySet()) {\n+      dfsStack.push(s);\n+      while (dfsStack.size() > 0) {\n+        String top = dfsStack.pop();\n+        if (!color.containsKey(top)) {\n+          continue;\n+        }\n+        if (color.get(top) == white) {\n+          color.put(top, gray);\n+          dfsStack.push(top);\n+          // for v in Adj[s]\n+          if (eventizes.containsKey(top)) {\n+            for (String v : eventizes.get(top)) {\n+              if (color.get(v) == white) {\n+                dfsStack.push(v);\n+              }\n+            }\n+          }\n+        } else if (color.get(top) == gray && eventizes.containsKey(top)) {\n+          order[last - indx] = top;\n+          ++indx;\n+          color.put(top, black);\n+        }\n+      }\n+    }\n+\n+    /*\n+     * Propagate eventfulness by iterating in topological order\n+     */\n+    for (String s : order) {\n+      if (eventfulTypes.contains(typeRegistry.getType(s))) {\n+        for (String v : eventizes.get(s)) {\n+          eventfulTypes.add(typeRegistry.getType(v));\n+        }\n+      }\n+    }\n+  }\n+\n+  private JSType maybeReturnDisposedType(Node n, boolean checkDispose) {\n+    /*\n+     * Checks for:\n+     *    - Y.registerDisposable(X)\n+     *      (Y has to be of type goog.Disposable)\n+     *    - X.dispose()\n+     *    - goog.dispose(X)\n+     *    - X.removeAll() (X is of type goog.events.EventHandler)\n+     *    - <array>.property(X) or Y.push(X)\n+     */\n+    Node first = n.getFirstChild();\n+\n+    if (first == null || !first.isQualifiedName()) {\n+      return null;\n+    }\n+    String property = first.getQualifiedName();\n+\n+    if (property.endsWith(\".registerDisposable\"))  {\n+      /*\n+       *  Ensure object is of type disposable\n+       */\n+      Node base = first.getFirstChild();\n+      JSType baseType = base.getJSType();\n+\n+      if (baseType == null || !isPossiblySubtype(baseType, googDisposableType)) {\n+        return null;\n+      }\n+\n+      return n.getLastChild().getJSType();\n+    }\n+\n+    if (checkDispose) {\n+      if (property.equals(\"goog.dispose\")) {\n+        return n.getLastChild().getJSType();\n+      }\n+      if (property.endsWith(\".dispose\")) {\n+        /*\n+         * n -> call\n+         *   n.firstChild -> \"dispose\"\n+         *   n.firstChild.firstChild -> object\n+         */\n+        return n.getFirstChild().getFirstChild().getJSType();\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  /*\n+   * Compute eventize relationship graph.\n+   */\n+  private class ComputeEventizeTraversal extends AbstractPostOrderCallback\n+      implements ScopedCallback {\n+\n+    /*\n+     * Keep track of whether in the constructor or disposal scope.\n+     */\n+    Stack<Boolean> isConstructorStack;\n+    Stack<Boolean> isDisposalStack;\n+\n+\n+    public ComputeEventizeTraversal() {\n+      isConstructorStack = new Stack<Boolean>();\n+      isDisposalStack = new Stack<Boolean>();\n+      eventizes = new HashMap<String, Set<String>>();\n+    }\n+\n+    private Boolean inConstructorScope() {\n+      Preconditions.checkNotNull(isConstructorStack);\n+      if (isDisposalStack.size() > 0) {\n+        return isConstructorStack.peek();\n+      }\n+      return null;\n+    }\n+\n+    private Boolean inDisposalScope() {\n+      Preconditions.checkNotNull(isDisposalStack);\n+      if (isDisposalStack.size() > 0) {\n+        return isDisposalStack.peek();\n+      }\n+      return null;\n+    }\n+\n+    /*\n+     * Filter types not interested in for eventize graph\n+     */\n+    private boolean collectorFilterType(JSType type) {\n+      if (type == null) {\n+        return true;\n+      }\n+\n+      if (type.isEmptyType() ||\n+          type.isUnknownType() ||\n+          !isPossiblySubtype(type, googDisposableType)) {\n+        return true;\n+      }\n+\n+      return false;\n+    }\n+\n+    /*\n+     * Log that thisType eventizes thatType.\n+     */\n+    private void addEventize(JSType thisType, JSType thatType) {\n+      if (collectorFilterType(thisType) ||\n+          collectorFilterType(thatType) ||\n+          thisType.isEquivalentTo(thatType)) {\n+        return;\n+      }\n+\n+      String className = thisType.getDisplayName();\n+      if (thatType.isUnionType()) {\n+        UnionType ut = thatType.toMaybeUnionType();\n+        for (JSType type : ut.getAlternates()) {\n+          if (type.isObject()) {\n+            addEventizeClass(className, type);\n+          }\n+        }\n+      } else {\n+        addEventizeClass(className, thatType);\n+      }\n+    }\n+\n+    private void addEventizeClass(String className, JSType thatType) {\n+      String propertyJsTypeName = thatType.getDisplayName();\n+\n+      Set<String> eventize = eventizes.get(propertyJsTypeName);\n+      if (eventize == null) {\n+        eventize = new HashSet<String>();\n+        eventizes.put(propertyJsTypeName, eventize);\n+      }\n+      eventize.add(className);\n+    }\n+\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      Node n = t.getScopeRoot();\n+      boolean isConstructor = false;\n+      boolean isInDisposal = false;\n+      String functionName = null;\n+\n+      /*\n+       * Scope entered is a function definition\n+       */\n+      if (n.isFunction()) {\n+        functionName = NodeUtil.getFunctionName(n);\n+\n+        /*\n+         *  Skip anonymous functions\n+         */\n+        if (functionName != null) {\n+\n+          JSDocInfo jsDocInfo = NodeUtil.getBestJSDocInfo(n);\n+          if (jsDocInfo != null) {\n+            /*\n+             *  Record constructor of a type\n+             */\n+            if (jsDocInfo.isConstructor()) {\n+              isConstructor = true;\n+\n+              /*\n+               * Initialize eventizes relationship\n+               */\n+              if (t.getScope() != null && t.getScope().getTypeOfThis() != null) {\n+                ObjectType objectType = ObjectType.cast(t.getScope().getTypeOfThis().dereference());\n+\n+                /*\n+                 * Eventize due to inheritance\n+                 */\n+\n+                while (objectType != null) {\n+                  objectType = objectType.getImplicitPrototype();\n+                  if (objectType == null) {\n+                    break;\n+                  }\n+\n+                  if (objectType.getDisplayName().endsWith(\"prototype\")) {\n+                    continue;\n+                  }\n+\n+                  addEventize(compiler.getTypeRegistry().getType(functionName), objectType);\n+\n+                  /*\n+                   * Don't add transitive eventize edges here, it will be\n+                   * taken care of in computeEventful\n+                   */\n+                  break;\n+                }\n+              }\n+            }\n+          }\n+\n+          /*\n+           *  Indicate within a disposeInternal member\n+           */\n+          if (functionName.endsWith(\".disposeInternal\")) {\n+            isInDisposal = true;\n+          }\n+        }\n+\n+        isConstructorStack.push(isConstructor);\n+        isDisposalStack.push(isInDisposal);\n+      } else {\n+        isConstructorStack.push(inConstructorScope());\n+        isDisposalStack.push(inDisposalScope());\n+      }\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {\n+      isConstructorStack.pop();\n+      isDisposalStack.pop();\n+    }\n+\n+    /*\n+     * Is the current node a call to goog.events.unlisten\n+     */\n+    private void isGoogEventsUnlisten(Node n) {\n+      Preconditions.checkArgument(n.getChildCount() > 3);\n+\n+      Node listener = n.getChildAtIndex(3);\n+\n+      Node objectWithListener = n.getChildAtIndex(1);\n+      if (!objectWithListener.isQualifiedName()) {\n+        return;\n+      }\n+\n+      if (listener.isFunction()) {\n+        /*\n+         * Anonymous function\n+         */\n+        compiler.report(JSError.make(n.getSourceFileName(), n, UNLISTEN_WITH_ANONBOUND));\n+      } else if (listener.isCall()) {\n+        if (!listener.getFirstChild().isQualifiedName()) {\n+          /*\n+           * Anonymous function\n+           */\n+          compiler.report(JSError.make(n.getSourceFileName(), n, UNLISTEN_WITH_ANONBOUND));\n+        } else if (listener.getFirstChild().getQualifiedName().equals(\"goog.bind\")) {\n+          /*\n+           * Using goog.bind to unlisten\n+           */\n+          compiler.report(JSError.make(n.getSourceFileName(), n, UNLISTEN_WITH_ANONBOUND));\n+        }\n+      }\n+    }\n+\n+\n+    private void isCalled(NodeTraversal t, Node n) {\n+      Node functionCalled = n.getFirstChild();\n+      if (functionCalled == null ||\n+          !functionCalled.isQualifiedName()) {\n+          return;\n+      }\n+      String functionCalledName = functionCalled.getQualifiedName();\n+      JSType typeOfThis = getTypeOfThisForScope(t);\n+      if (typeOfThis == null) {\n+        return;\n+      }\n+\n+      /*\n+       * Class considered eventful if there is an unlisten call in the\n+       * disposal.\n+       */\n+      if (functionCalledName.equals(\"goog.events.unlisten\")) {\n+\n+        if (inDisposalScope()) {\n+          eventfulTypes.add(typeOfThis);\n+        }\n+        isGoogEventsUnlisten(n);\n+      }\n+      if (inDisposalScope() &&\n+          functionCalledName.equals(\"goog.events.removeAll\")) {\n+        eventfulTypes.add(typeOfThis);\n+      }\n+\n+      /*\n+       * If member with qualified name gets disposed of when this class\n+       * gets disposed, consider the member type as an eventizer of this\n+       * class.\n+       */\n+      JSType disposedType = maybeReturnDisposedType(n, inDisposalScope());\n+      if (!collectorFilterType(disposedType)) {\n+        addEventize(getTypeOfThisForScope(t), disposedType);\n+      }\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      switch (n.getType()) {\n+        case Token.CALL:\n+          isCalled(t, n);\n+          break;\n+        default:\n+          break;\n+      }\n+    }\n+  }\n+\n+  private class Traversal extends AbstractPostOrderCallback  implements ScopedCallback {\n+    /*\n+     * Checks if the input node correspond to the creation of an eventful object\n+     */\n+    private boolean createsEventfulObject(Node n) {\n+      Node first = n.getFirstChild();\n+      JSType type = n.getJSType();\n+      if (first == null ||\n+          !first.isQualifiedName() ||\n+          type.isEmptyType() ||\n+          type.isUnknownType()) {\n+        return false;\n+      }\n+\n+      boolean isOfTypeNeedingDisposal = false;\n+      for (JSType disposableType : eventfulTypes) {\n+        if (type.isSubtype(disposableType)) {\n+          isOfTypeNeedingDisposal = true;\n+          break;\n+        }\n+      }\n+      return isOfTypeNeedingDisposal;\n+    }\n+\n+    /*\n+     * This function traverses the current scope to see if a locally\n+     * defined eventful object is assigned to a live-out variable.\n+     *\n+     * Note: This function could be called multiple times to traverse\n+     * the same scope if multiple local eventful objects are created in the\n+     * scope.\n+     */\n+    private Node localEventfulObjectAssign(\n+        NodeTraversal t, Node propertyNode) {\n+      Node parent;\n+      if (!t.getScope().isGlobal()) {\n+        /*\n+         * In function\n+         */\n+        parent = NodeUtil.getFunctionBody(t.getScopeRoot());\n+      } else {\n+        /*\n+         * In global scope\n+         */\n+        parent = t.getScopeRoot().getFirstChild();\n+      }\n+\n+      /*\n+       * Check to see if locally created EventHandler is assigned to field\n+       */\n+      for (Node sibling : parent.children()) {\n+        if (sibling.isExprResult()) {\n+          Node assign = sibling.getFirstChild();\n+          if (assign.isAssign()) {\n+            // assign.getLastChild().isEquivalentTo(propertyNode) did not work\n+            if (propertyNode.getQualifiedName().equals(assign.getLastChild().getQualifiedName())) {\n+              if (!assign.getFirstChild().isName()) {\n+                return assign.getFirstChild();\n+              }\n+            }\n+          }\n+        }\n+      }\n+\n+      /*\n+       * Eventful object created and assigned to a local variable which is not\n+       * assigned to another variable in a way to allow disposal.\n+       */\n+      String key = generateKey(t, propertyNode, false);\n+      if (key == null) {\n+        return null;\n+      }\n+\n+      EventfulObjectState e;\n+      if (eventfulObjectMap.containsKey(key)) {\n+        e = eventfulObjectMap.get(key);\n+\n+        if (e.seen == SeenType.ALLOCATED) {\n+          e.seen = SeenType.ALLOCATED_LOCALLY;\n+        }\n+      } else {\n+        e = new EventfulObjectState();\n+        e.seen = SeenType.ALLOCATED_LOCALLY;\n+\n+        eventfulObjectMap.put(key, e);\n+      }\n+      e.allocationSite = propertyNode;\n+\n+\n+      return null;\n+    }\n+\n+    /*\n+     * Record the creation of a new eventful object.\n+     */\n+    private void isNew(NodeTraversal t, Node n, Node parent) {\n+      if (!createsEventfulObject(n)) {\n+        return;\n+      }\n+\n+      /*\n+       * Insert allocation site and construct into eventfulObjectMap\n+       */\n+      String key;\n+      Node propertyNode;\n+\n+      /*\n+       * Handles (E is an eventful class):\n+       *  - object.something = new E();\n+       *  - local = new E();\n+       *  - var local = new E();\n+       */\n+      if (parent.isAssign()) {\n+        propertyNode = parent.getFirstChild();\n+      } else {\n+        propertyNode = parent;\n+      }\n+\n+      /*\n+       * Only perform checks for locally defined eventful objects in aggressive\n+       * mode to reduce false positives.\n+       */\n+      if (propertyNode.isName() &&\n+          checkingPolicy != DisposalCheckingPolicy.AGGRESSIVE) {\n+        return;\n+      }\n+\n+      key = generateKey(t, propertyNode, false);\n+      if (key == null) {\n+        return;\n+      }\n+\n+      EventfulObjectState e;\n+      if (eventfulObjectMap.containsKey(key)) {\n+        e = eventfulObjectMap.get(key);\n+      } else {\n+        e = new EventfulObjectState();\n+        e.seen = SeenType.ALLOCATED;\n+\n+        eventfulObjectMap.put(key, e);\n+      }\n+      e.allocationSite = propertyNode;\n+\n+      /*\n+       * Check if locally defined eventful object is assigned to global variable\n+       * and create an entry mapping to the previous site.\n+       */\n+      if (propertyNode.isName()) {\n+        Node globalVarNode = localEventfulObjectAssign(t, propertyNode);\n+        if (globalVarNode != null) {\n+          key = generateKey(t, globalVarNode, false);\n+          if (key == null) {\n+            /*\n+             * Local variable is assigned to an array or in a manner requiring\n+             * a function call.\n+             */\n+            e.seen = SeenType.POSSIBLY_DISPOSED;\n+            return;\n+          }\n+          eventfulObjectMap.put(key, e);\n+        }\n+      }\n+    }\n+\n+    private Node maybeGetValueNodeFromCall(Node n) {\n+      /*\n+       * Checks for:\n+       *    - Y.registerDisposable(X)\n+       *      (Y has to be of type goog.Disposable)\n+       *    - X.dispose()\n+       *    - goog.dispose(X)\n+       *    - X.removeAll() (X is of type goog.events.EventHandler)\n+       *    - <array>.property(X) or Y.push(X)\n+       */\n+      Node first = n.getFirstChild();\n+\n+      if (first == null || !first.isQualifiedName()) {\n+        return null;\n+      }\n+      String property = first.getQualifiedName();\n+\n+      if (property.endsWith(\".registerDisposable\"))  {\n+        /*\n+         *  Ensure object is of type disposable\n+         */\n+        Node base = first.getFirstChild();\n+        JSType baseType = base.getJSType();\n+\n+        if (baseType == null || !isPossiblySubtype(baseType, googDisposableType)) {\n+          return null;\n+        }\n+\n+        return  n.getLastChild();\n+      }\n+      if (property.equals(\"goog.dispose\")) {\n+        return n.getLastChild();\n+      }\n+\n+      /*\n+       * n -> call\n+       *   n.firstChild -> \"dispose\" | \"removeAll\"\n+       *   n.firstChild.firstChild -> object\n+       */\n+      Node calledOn = n.getFirstChild().getFirstChild();\n+      if (property.endsWith(\".dispose\")) {\n+        return calledOn;\n+      }\n+      if (property.endsWith(\".removeAll\")) {\n+        if (calledOn != null) {\n+          JSType calledOnType = calledOn.getJSType();\n+          if (calledOnType != null &&\n+              !calledOnType.isEmptyType() &&\n+              !calledOnType.isUnknownType() &&\n+              isPossiblySubtype(calledOnType, googEventsEventHandlerType)) {\n+            return calledOn;\n+          }\n+        }\n+      }\n+\n+      Node possiblyArray = first.getFirstChild();\n+      if (possiblyArray != null) {\n+        JSType possiblyArrayType = possiblyArray.getJSType();\n+        if (possiblyArrayType != null && possiblyArrayType.isArrayType()) {\n+          return  n.getLastChild();\n+        }\n+      }\n+      /*\n+       * Heuristic: a variable used in call to push/addChild gets stored\n+       * in object with method push/addChild/addChild_/addPane.\n+       */\n+      if (property.endsWith(\".push\") ||\n+          property.contains(\".add\")) {\n+        return  n.getLastChild();\n+      }\n+\n+      return null;\n+    }\n+\n+    /*\n+     * Look for calls to an eventful object's disposal functions.\n+     * (dispose or removeAll will remove all event listeners from\n+     * an EventHandler).\n+     */\n+    private void isCall(NodeTraversal t, Node n) {\n+      // Filter the calls to find a \"dispose\" call\n+      Node variableNode = maybeGetValueNodeFromCall(n);\n+      if (variableNode == null) {\n+        return;\n+      }\n+\n+      // Only consider removals on eventful object\n+      boolean isTrackedRemoval = false;\n+      JSType vnType = variableNode.getJSType();\n+      for (JSType type : eventfulTypes) {\n+        if (isPossiblySubtype(vnType, type)) {\n+          isTrackedRemoval = true;\n+        }\n+      }\n+      if (!isTrackedRemoval) {\n+        return;\n+      }\n+\n+      String key = generateKey(t, variableNode, false);\n+      if (key == null) {\n+        return;\n+      }\n+\n+      eventfulObjectDisposed(t, variableNode);\n+    }\n+\n+    /**\n+     * Dereference a type, autoboxing it and filtering out null.\n+     * From {@link CheckAccessControls}\n+     */\n+    private JSType dereference(JSType type) {\n+      return type == null ? null : type.dereference();\n+    }\n+\n+    /*\n+     * Track assignments to see if a private field is being\n+     * overwritten.\n+     *\n+     * Assigning to an array element is taken care of by the generateKey\n+     * returning null on array (\"complex\") variable names.\n+     */\n+    public void isAssign(NodeTraversal t, Node n) {\n+      Node assignedTo = n.getFirstChild();\n+      JSType assignedToType = assignedTo.getJSType();\n+      if (assignedToType == null || assignedToType.isEmptyType()) {\n+        return;\n+      }\n+\n+      if (n.getFirstChild().isGetProp()) {\n+        boolean isTrackedAssign = false;\n+        for (JSType disposalType : eventfulTypes) {\n+          if (assignedToType.isSubtype(disposalType)) {\n+            isTrackedAssign = true;\n+            break;\n+          }\n+        }\n+        if (!isTrackedAssign) {\n+          return;\n+        }\n+\n+        JSDocInfo di = n.getJSDocInfo();\n+        ObjectType objectType =\n+            ObjectType.cast(dereference(n.getFirstChild().getFirstChild().getJSType()));\n+        String propertyName = n.getFirstChild().getLastChild().getString();\n+\n+        boolean fieldIsPrivate = (\n+            (di != null) &&\n+            (di.getVisibility() == Visibility.PRIVATE));\n+\n+        /*\n+         * See if field is defined as private in superclass\n+         */\n+        while (objectType != null) {\n+          di = null;\n+          objectType = objectType.getImplicitPrototype();\n+          if (objectType == null) {\n+            break;\n+          }\n+\n+          /*\n+           * Skip prototype definitions:\n+           *   Don't flag a field declared private in assignment as well\n+           *   as in prototype declaration\n+           * Assumption: The inheritance hierarchy is similar to\n+           *   class\n+           *   class.prototype\n+           *   superclass\n+           *   superclass.prototype\n+           */\n+          if (objectType.getDisplayName().endsWith(\"prototype\")) {\n+            continue;\n+          }\n+\n+          di = objectType.getOwnPropertyJSDocInfo(propertyName);\n+          if (di != null) {\n+            if (fieldIsPrivate || di.getVisibility() == Visibility.PRIVATE) {\n+              compiler.report(\n+                  t.makeError(n, OVERWRITE_PRIVATE_EVENTFUL_OBJECT));\n+              break;\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    /*\n+     * Filter out any eventful objects returned.\n+     */\n+    private void isReturn(NodeTraversal t, Node n) {\n+      Node variableNode = n.getFirstChild();\n+      if (variableNode == null) {\n+        return;\n+      }\n+      JSType type = variableNode.getJSType();\n+      if (type == null || type.isEmptyType()) {\n+        return;\n+      }\n+\n+      boolean isTrackedReturn = false;\n+      for (JSType disposalType : eventfulTypes) {\n+        if (type.isSubtype(disposalType)) {\n+          isTrackedReturn = true;\n+          break;\n+        }\n+      }\n+      if (!isTrackedReturn) {\n+        return;\n+      }\n+\n+      eventfulObjectDisposed(t, variableNode);\n+    }\n+\n+    /*\n+     * Mark an eventful object as being disposed.\n+     */\n+    private void eventfulObjectDisposed(NodeTraversal t, Node variableNode) {\n+      String key = generateKey(t, variableNode, false);\n+      if (key == null) {\n+        return;\n+      }\n+\n+      EventfulObjectState e = eventfulObjectMap.get(key);\n+      if (e == null) {\n+        e = new EventfulObjectState();\n+        eventfulObjectMap.put(key, e);\n+      }\n+      e.seen = SeenType.POSSIBLY_DISPOSED;\n+    }\n+\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      /*\n+       * Local variables captured in scope are filtered at present.\n+       * LiveVariableAnalysis used to filter such variables.\n+       */\n+      ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n+      LiveVariablesAnalysis liveness =\n+          new LiveVariablesAnalysis(cfg, t.getScope(), compiler);\n+      liveness.analyze();\n+\n+      for (Var v : liveness.getEscapedLocals()) {\n+        eventfulObjectDisposed(t, v.getNode());\n+      }\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      switch (n.getType()) {\n+        case Token.ASSIGN:\n+          isAssign(t, n);\n+          break;\n+        case Token.CALL:\n+          isCall(t, n);\n+          break;\n+        case Token.NEW:\n+          isNew(t, n, parent);\n+          break;\n+        case Token.RETURN:\n+          isReturn(t, n);\n+          break;\n+        default:\n+          break;\n+      }\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * effect as specifying an empty set.\n    */\n   Set<String> extraAnnotationNames;\n+\n+  /**\n+   * Check for patterns that are known to cause memory leaks.\n+   */\n+  CheckEventfulObjectDisposal.DisposalCheckingPolicy checkEventfulObjectDisposalPolicy;\n+\n+  public void setCheckEventfulObjectDisposalPolicy(\n+      CheckEventfulObjectDisposal.DisposalCheckingPolicy policy) {\n+    this.checkEventfulObjectDisposalPolicy = policy;\n+\n+    // The CheckEventfulObjectDisposal pass requires types so enable inferring types if\n+    // this pass is enabled.\n+    if (policy != CheckEventfulObjectDisposal.DisposalCheckingPolicy.OFF) {\n+      this.inferTypes = true;\n+    }\n+  }\n+  public CheckEventfulObjectDisposal.DisposalCheckingPolicy getCheckEventfulObjectDisposalPolicy() {\n+    return checkEventfulObjectDisposalPolicy;\n+  }\n+\n \n   //--------------------------------\n   // Optimizations\n     computeFunctionSideEffects = false;\n     chainCalls = false;\n     extraAnnotationNames = null;\n+    checkEventfulObjectDisposalPolicy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.OFF;\n \n     // Optimizations\n     aggressiveRenaming = false;\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       checks.add(checkAccessControls);\n     }\n \n+    if (options.checkEventfulObjectDisposalPolicy !=\n+        CheckEventfulObjectDisposal.DisposalCheckingPolicy.OFF) {\n+      checks.add(checkEventfulObjectDisposal);\n+    }\n+\n     if (options.checkGlobalNamesLevel.isOn()) {\n       checks.add(checkGlobalNames);\n     }\n     @Override\n     protected CompilerPass create(AbstractCompiler compiler) {\n       return new ConstCheck(compiler);\n+    }\n+  };\n+\n+  /** Check memory bloat patterns */\n+  final PassFactory checkEventfulObjectDisposal =\n+      new PassFactory(\"checkEventfulObjectDisposal\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n+      return new CheckEventfulObjectDisposal(compiler,\n+          options.checkEventfulObjectDisposalPolicy);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/ReplaceMessagesForChrome.java\n+++ b/src/com/google/javascript/jscomp/ReplaceMessagesForChrome.java\n  * argument is an array of the values being used for the placeholders, in the\n  * order they appear in the source code.\n  *\n+ * @author tbreisacher@google.com (Tyler Breisacher)\n  */\n class ReplaceMessagesForChrome extends JsMessageVisitor {\n \n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/CheckEventfulObjectDisposalTest.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Tests for {@code CheckEventfulObjectDisposal.java}.\n+ *\n+ */\n+\n+public class CheckEventfulObjectDisposalTest extends CompilerTestCase {\n+\n+  private CheckEventfulObjectDisposal.DisposalCheckingPolicy policy =\n+      CheckEventfulObjectDisposal.DisposalCheckingPolicy.ON;\n+\n+  static final String CLOSURE_DEFS = \"var goog = {};\" + \"goog.inherits = function(x, y) {};\"\n+      + \"/** @type {!Function} */ goog.abstractMethod = function() {};\"\n+      + \"goog.isArray = function(x) {};\" + \"goog.isDef = function(x) {};\"\n+      + \"goog.isFunction = function(x) {};\" + \"goog.isNull = function(x) {};\"\n+      + \"goog.isString = function(x) {};\" + \"goog.isObject = function(x) {};\"\n+      + \"goog.isDefAndNotNull = function(x) {};\" + \"goog.asserts = {};\"\n+      + \"goog.dispose = function(x) {};\"\n+      + \"/** @return {*} */ goog.asserts.assert = function(x) { return x; };\"\n+      + \"/** @interface */\\n\"\n+      + \"goog.Disposable = goog.abstractMethod;\"\n+      + \"goog.Disposable.prototype.dispose = goog.abstractMethod;\"\n+      + \"/** @param {goog.Disposable} fn */\"\n+      + \"goog.Disposable.prototype.registerDisposable = goog.abstractMethod;\"\n+      + \"/** @implements {goog.Disposable}\\n * @constructor */\"\n+      + \"goog.SubDisposable = function() {};\"\n+      + \"/** @inheritDoc */ \"\n+      + \"goog.SubDisposable.prototype.dispose = function() {};\"\n+      + \"/** @inheritDoc */\"\n+      + \"goog.SubDisposable.prototype.registerDisposable = function() {};\"\n+      + \"goog.events = {};\"\n+      + \"/** @extends {goog.SubDisposable}\\n *  @constructor */\"\n+      + \"goog.events.EventHandler = function() {};\"\n+      + \"goog.events.EventHandler.prototype.removeAll = function() {};\";\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    enableTypeCheck(CheckLevel.WARNING);\n+    enableEcmaScript5(true);\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(Compiler compiler) {\n+    return new CheckEventfulObjectDisposal(compiler, policy);\n+  }\n+\n+  public void testNoEventHandler() {\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() {  };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  public void testNotFreed1() {\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { this.eh = new goog.events.EventHandler(); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_NOT_DISPOSED, true);\n+  }\n+\n+  public void testLocal() {\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { var eh = new goog.events.EventHandler();\\n\"\n+        + \"};\\n\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  public void testLocalAggressive() {\n+    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { var eh = new goog.events.EventHandler();\\n\"\n+        + \"};\\n\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_PURELY_LOCAL, true);\n+  }\n+\n+  public void testFreedLocal1() {\n+    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { var eh = new goog.events.EventHandler();\"\n+        + \"eh.dispose(); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  public void testFreedLocal2() {\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { var eh = new goog.events.EventHandler();\"\n+        + \"this.registerDisposable(eh); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  public void testFreedLocal2Aggressive() {\n+    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { var eh = new goog.events.EventHandler();\"\n+        + \"this.registerDisposable(eh); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_PURELY_LOCAL, true);\n+  }\n+\n+  public void testLocalLive1() {\n+    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { var eh = new goog.events.EventHandler();\"\n+        + \"this.eh = eh;\"\n+        + \"eh.dispose(); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  public void testLocalLive2() {\n+    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { var eh = new goog.events.EventHandler();\"\n+        + \"this.eh = eh;\"\n+        + \"this.eh.dispose(); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  /*\n+   * Local variable is never freed but as it is assigned to an array\n+   * this is left to the dynamic analyzer to discover it.\n+   */\n+  public void testLocalLive3() {\n+    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { var eh = new goog.events.EventHandler();\"\n+        + \"this.ehs = [];\"\n+        + \"this.ehs[0] = eh;\"\n+        + \"};\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  public void testFreedDispose() {\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { this.eh = new goog.events.EventHandler();\"\n+        + \"this.eh.dispose(); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  public void testFreedGoogDispose() {\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { this.eh = new goog.events.EventHandler();\"\n+        + \"goog.dispose(this.eh); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  public void testFreedRegisterDisposable() {\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { this.eh = new goog.events.EventHandler();\"\n+        + \"this.registerDisposable(this.eh); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  public void testFreedRemoveAll() {\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { this.eh = new goog.events.EventHandler();\"\n+        + \"this.eh.removeAll(); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  public void testPrivateInheritance() {\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"var test = function() { \"\n+        + \"/** @private */ this.eh = new goog.events.EventHandler();\"\n+        + \"this.eh.removeAll(); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"/** @extends {test}\\n * @constructor */\"\n+        + \"var subclass = function() {\"\n+        + \"/** @private */ this.eh = new goog.events.EventHandler();\"\n+        + \"this.eh.dispose();\"\n+        + \"};\"\n+        + \"var testObj = new test();\";\n+    testSame(js, CheckEventfulObjectDisposal.OVERWRITE_PRIVATE_EVENTFUL_OBJECT, true);\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/ReplaceMessagesForChromeTest.java\n+++ b/test/com/google/javascript/jscomp/ReplaceMessagesForChromeTest.java\n /**\n  * Test which checks that replacer works correctly.\n  *\n+ * @author tbreisacher@google.com (Tyler Breisacher)\n  */\n public class ReplaceMessagesForChromeTest extends CompilerTestCase {\n ", "timestamp": 1369807012, "metainfo": ""}