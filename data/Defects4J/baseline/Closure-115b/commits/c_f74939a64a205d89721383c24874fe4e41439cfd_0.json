{"sha": "f74939a64a205d89721383c24874fe4e41439cfd", "log": "Remove some non-determinism from the module graph  R=johnlenz DELTA=24  (4 added, 12 deleted, 8 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4113   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n       Appendable out, boolean isManifest) throws IOException {\n     Joiner commas = Joiner.on(\",\");\n     boolean requiresNewline = false;\n-    for (JSModule module : graph.getAllModulesInDependencyOrder()) {\n+    for (JSModule module : graph.getAllModules()) {\n       if (requiresNewline) {\n         out.append(\"\\n\");\n       }\n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.LinkedHashMultimap;\n import com.google.common.collect.LinkedListMultimap;\n \n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.Comparator;\n import java.util.Iterator;\n import java.util.List;\n  */\n public class JSModuleGraph {\n \n-  private Set<JSModule> modules;\n+  private List<JSModule> modules;\n \n   /**\n    * Lists of modules at each depth. <code>modulesByDepth.get(3)</code> is a\n    * Creates a module graph from a list of modules in dependency order.\n    */\n   public JSModuleGraph(JSModule[] modulesInDepOrder) {\n-    this(Lists.<JSModule>newArrayList(modulesInDepOrder));\n+    this(ImmutableList.copyOf(modulesInDepOrder));\n   }\n \n   /**\n    * Creates a module graph from a list of modules in dependency order.\n    */\n   public JSModuleGraph(List<JSModule> modulesInDepOrder) {\n-    modules = Sets.newHashSetWithExpectedSize(modulesInDepOrder.size());\n+    Preconditions.checkState(\n+        modulesInDepOrder.size() == Sets.newHashSet(modulesInDepOrder).size(),\n+        \"Found duplicate modules\");\n+    modules = ImmutableList.copyOf(modulesInDepOrder);\n     modulesByDepth = Lists.newArrayList();\n \n     for (JSModule module : modulesInDepOrder) {\n       }\n \n       module.setDepth(depth);\n-      modules.add(module);\n       if (depth == modulesByDepth.size()) {\n         modulesByDepth.add(new ArrayList<JSModule>());\n       }\n   }\n \n   /**\n-   * Gets an iterable over all modules.\n+   * Gets an iterable over all modules in dependency order.\n    */\n   Iterable<JSModule> getAllModules() {\n-    return modules;\n-  }\n-\n-  /**\n-   * Gets all the modules in dependency order. Modules with the same depth\n-   * will be ordered deterministically.\n-   */\n-  Iterable<JSModule> getAllModulesInDependencyOrder() {\n-    List<JSModule> modules = Lists.newArrayList(getAllModules());\n-    Collections.sort(modules, new DepthComparator());\n     return modules;\n   }\n \n \n     // Now, generate the sorted result.\n     List<CompilerInput> result = Lists.newArrayList();\n-    for (JSModule module : getAllModulesInDependencyOrder()) {\n+    for (JSModule module : getAllModules()) {\n       result.addAll(module.getInputs());\n     }\n \n   LinkedDirectedGraph<JSModule, String> toGraphvizGraph() {\n     LinkedDirectedGraph<JSModule, String> graphViz =\n         LinkedDirectedGraph.create();\n-    for (JSModule module : getAllModulesInDependencyOrder()) {\n+    for (JSModule module : getAllModules()) {\n       graphViz.createNode(module);\n       for (JSModule dep : module.getDependencies()) {\n         graphViz.createNode(dep);", "timestamp": 1327083696, "metainfo": ""}