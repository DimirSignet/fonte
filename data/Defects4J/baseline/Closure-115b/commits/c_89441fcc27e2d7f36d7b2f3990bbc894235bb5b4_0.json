{"sha": "89441fcc27e2d7f36d7b2f3990bbc894235bb5b4", "log": "Don't try to fold array literal accesses that are acting as a assignment target. Fixes issue 522.  R=acleung DELTA=116  (69 added, 45 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2859   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     return n;\n   }\n \n-\n-\n   /**\n    * Try to fold array-element. e.g [1, 2, 3][10];\n    */\n     }\n \n     if (left.getType() == Token.ARRAYLIT) {\n-      if (right.getType() != Token.NUMBER) {\n-        // Sometimes people like to use complex expressions to index into\n-        // arrays, or strings to index into array methods.\n-        return n;\n-      }\n-\n-      double index = right.getDouble();\n-      int intIndex = (int) index;\n-      if (intIndex != index) {\n-        error(INVALID_GETELEM_INDEX_ERROR, right);\n-        return n;\n-      }\n-\n-      if (intIndex < 0) {\n-        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n-        return n;\n-      }\n-\n-      Node elem = left.getFirstChild();\n-      for (int i = 0; elem != null && i < intIndex; i++) {\n-        elem = elem.getNext();\n-      }\n-\n-      if (elem == null) {\n-        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n-        return n;\n-      }\n-\n-      if (elem.getType() == Token.EMPTY) {\n-        elem = NodeUtil.newUndefinedNode(elem);\n-      } else {\n-        left.removeChild(elem);\n-      }\n-\n-      // Replace the entire GETELEM with the value\n-      n.getParent().replaceChild(n, elem);\n-      reportCodeChange();\n-      return elem;\n+      return tryFoldArrayAccess(n, left, right);\n     }\n     return n;\n   }\n     return n;\n   }\n \n-  private Node tryFoldObjectPropAccess(Node n, Node left, Node right) {\n-    Preconditions.checkArgument(NodeUtil.isGet(n));\n-\n-    if (left.getType() != Token.OBJECTLIT || right.getType() != Token.STRING) {\n-      return n;\n-    }\n-\n+  private boolean isAssignmentTarget(Node n) {\n     Node parent = n.getParent();\n     if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n         || parent.getType() == Token.INC\n         || parent.getType() == Token.DEC) {\n+      // If GETPROP/GETELEM is used as assignment target the object literal is\n+      // acting as a temporary we can't fold it here:\n+      //    \"{a:x}.a += 1\" is not \"x += 1\"\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n+    Node parent = n.getParent();\n+    // If GETPROP/GETELEM is used as assignment target the array literal is\n+    // acting as a temporary we can't fold it here:\n+    //    \"[][0] += 1\"\n+    if (isAssignmentTarget(n)) {\n+      return n;\n+    }\n+\n+    if (right.getType() != Token.NUMBER) {\n+      // Sometimes people like to use complex expressions to index into\n+      // arrays, or strings to index into array methods.\n+      return n;\n+    }\n+\n+    double index = right.getDouble();\n+    int intIndex = (int) index;\n+    if (intIndex != index) {\n+      error(INVALID_GETELEM_INDEX_ERROR, right);\n+      return n;\n+    }\n+\n+    if (intIndex < 0) {\n+      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n+      return n;\n+    }\n+\n+    Node elem = left.getFirstChild();\n+    for (int i = 0; elem != null && i < intIndex; i++) {\n+      elem = elem.getNext();\n+    }\n+\n+    if (elem == null) {\n+      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n+      return n;\n+    }\n+\n+    if (elem.getType() == Token.EMPTY) {\n+      elem = NodeUtil.newUndefinedNode(elem);\n+    } else {\n+      left.removeChild(elem);\n+    }\n+\n+    // Replace the entire GETELEM with the value\n+    n.getParent().replaceChild(n, elem);\n+    reportCodeChange();\n+    return elem;\n+  }\n+\n+  private Node tryFoldObjectPropAccess(Node n, Node left, Node right) {\n+    Preconditions.checkArgument(NodeUtil.isGet(n));\n+\n+    if (left.getType() != Token.OBJECTLIT || right.getType() != Token.STRING) {\n+      return n;\n+    }\n+\n+    if (isAssignmentTarget(n)) {\n       // If GETPROP/GETELEM is used as assignment target the object literal is\n       // acting as a temporary we can't fold it here:\n       //    \"{a:x}.a += 1\" is not \"x += 1\"\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n \n   public void testIEString() {\n     testSame(\"!+'\\\\v1'\");\n+  }\n+\n+  public void testIssue522() {\n+    testSame(\"[][1] = 1;\");\n   }\n \n   private static final List<String> LITERAL_OPERANDS =", "timestamp": 1312313699, "metainfo": ""}