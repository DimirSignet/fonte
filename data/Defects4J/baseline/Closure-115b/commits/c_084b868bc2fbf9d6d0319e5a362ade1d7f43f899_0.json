{"sha": "084b868bc2fbf9d6d0319e5a362ade1d7f43f899", "log": "Generate a parse error for unnamed function statements. Fixes issue 251.  R=nicksantos DELTA=384  (78 added, 0 deleted, 306 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=556   ", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n       return node;\n     }\n \n-   @Override\n-  Node processFunctionNode(FunctionNode functionNode) {\n+    @Override\n+    Node processFunctionNode(FunctionNode functionNode) {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n+        int functionType = functionNode.getFunctionType();\n+        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n+          errorReporter.error(\n+            \"unnamed function statement\",\n+            sourceName,\n+            functionNode.getLineno(), \"\", 0);\n+        }\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;\n--- a/test/com/google/javascript/jscomp/AliasStringsTest.java\n+++ b/test/com/google/javascript/jscomp/AliasStringsTest.java\n   public void testSeveral() {\n     strings = ImmutableSet.of(\"\", \"px\", \"none\", \"width\");\n \n-    test(\"function() {var styles=['width',100,'px','display','none'].join('')}\",\n+    test(\"function f() {\" +\n+         \"var styles=['width',100,'px','display','none'].join('')}\",\n          \"var $$S_width='width';\" +\n          \"var $$S_px='px';\" +\n          \"var $$S_none='none';\" +\n          \"var $$S_='';\" +\n-         \"function() {var styles=[$$S_width,100,$$S_px,'display',\" +\n+         \"function f() {var styles=[$$S_width,100,$$S_px,'display',\" +\n          \"$$S_none].join($$S_)}\");\n   }\n \n \n     // string as key\n     test(\"var foo={'px':435}\", \"var foo={px:435}\");\n-    test(\"bar=function(){return {'px':435}}\",\n-         \"bar=function(){return {px:435}}\");\n-\n-    test(\"function() {var foo={bar:'!@#$%^&*()'}}\",\n+    test(\"bar=function f(){return {'px':435}}\",\n+         \"bar=function f(){return {px:435}}\");\n+\n+    test(\"function f() {var foo={bar:'!@#$%^&*()'}}\",\n          \"var $$S_$21$40$23$24$25$5e$26$2a$28$29='!@#$%^&*()';\" +\n-         \"function() {var foo={bar:$$S_$21$40$23$24$25$5e$26$2a$28$29}}\");\n-\n-    test(\"function() {var foo={px:435,foo:'px',bar:'baz'}}\",\n+         \"function f() {var foo={bar:$$S_$21$40$23$24$25$5e$26$2a$28$29}}\");\n+\n+    test(\"function f() {var foo={px:435,foo:'px',bar:'baz'}}\",\n          \"var $$S_px='px';\" +\n-         \"function() {var foo={px:435,foo:$$S_px,bar:'baz'}}\");\n+         \"function f() {var foo={px:435,foo:$$S_px,bar:'baz'}}\");\n   }\n \n   public void testGetProp() {\n     strings = ImmutableSet.of(\"px\", \"width\");\n \n-    testSame(\"function(){element.style.px=1234}\");\n+    testSame(\"function f(){element.style.px=1234}\");\n \n     test(\"function f(){shape.width.units='px'}\",\n         \"var $$S_px='px';function f(){shape.width.units=$$S_px}\");\n   }\n \n   public void testBlackList() {\n-    test(\"function(){var f=\\'sec ret\\';g=\\\"TOPseCreT\\\"}\",\n+    test(\"(function (){var f=\\'sec ret\\';g=\\\"TOPseCreT\\\"})\",\n          \"var $$S_sec$20ret='sec ret';\" +\n-         \"function(){var f=$$S_sec$20ret;g=\\\"TOPseCreT\\\"}\");\n+         \"(function (){var f=$$S_sec$20ret;g=\\\"TOPseCreT\\\"})\");\n   }\n \n   public void testLongStableAlias() {\n--- a/test/com/google/javascript/jscomp/AstParallelizerTest.java\n+++ b/test/com/google/javascript/jscomp/AstParallelizerTest.java\n                    \"function foo(x) { foo(1) }\");\n   }\n \n-  public void testSplitAnonFuntion() {\n+  // TODO(johnlenz): This test is invalid it relies on allowing\n+  // nameless function statements, which does not parse.\n+  public void disable_testSplitAnonFuntion() {\n     splitFunctions(\"var foo = function(x) { foo(1) }; foo(1)\",\n                    \"var foo = function \" + HOLDER + \"() {}; foo(1)\",\n-                   \"function(x) { foo(1) }\");\n+                   \"(function(x) { foo(1) })\");\n   }\n \n-  public void testSplitInplaceCall() {\n+  // TODO(johnlenz): This test is invalid it relies on allowing\n+  // nameless function statements, which does not parse.\n+  public void disable_testSplitInplaceCall() {\n     splitFunctions(\"(function() { print('hi') })()\",\n                    \"(function \" + HOLDER + \"() {})()\",\n-                   \"function() { print('hi') }\");\n+                   \"(function() { print('hi') })\");\n   }\n \n-  public void testSplitMupltiFuntions() {\n+  // TODO(johnlenz): This test is invalid it relies on allowing\n+  // nameless function statements, which does not parse.\n+  public void disable_testSplitMupltiFuntions() {\n     splitFunctions(\"var foo = function(x) { foo(1) }; foo();\" +\n                    \"var bar = function(x,y) { bar(1,2) }; bar(1,2)\",\n                    // Output Root\n                    \"var foo = function \" + HOLDER + \"() {}; foo();\" +\n                    \"var bar = function \" + HOLDER + \"() {}; bar(1,2)\",\n                    // foo\n-                   \"function(x) { foo(1) }\",\n+                   \"(function(x) { foo(1) })\",\n                    // bar\n-                   \"function(x,y) { bar(1,2) }\");\n+                   \"(function(x,y) { bar(1,2) })\");\n   }\n \n-  public void testInnerFunctions() {\n+  // TODO(johnlenz): This test is invalid it relies on allowing\n+  // nameless function statements, which does not parse.\n+  public void disable_testInnerFunctions() {\n     splitFunctions(\"var foo = function() {var bar = function() {}}\",\n                    \"var foo = function \" + HOLDER + \"() {}\",\n                    \"function() {var bar = function() {}}\");\n--- a/test/com/google/javascript/jscomp/CheckGlobalThisTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalThisTest.java\n   }\n \n   public void testThisJSDoc4() throws Exception {\n-    testSame(\"/** @this whatever */function() { this.foo = 56; }\");\n+    testSame(\"/** @this whatever */function f() { this.foo = 56; }\");\n   }\n \n   public void testThisJSDoc5() throws Exception {\n-    testSame(\"function a() { /** @this x */function() { this.foo = 56; } }\");\n+    testSame(\"function a() { /** @this x */function f() { this.foo = 56; } }\");\n   }\n \n   public void testMethod1() {\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n \n   public void testDoLoopIECompatiblity() {\n     // Do loops within IFs cause syntax errors in IE6 and IE7.\n-    assertPrint(\"function(){if(e1){do foo();while(e2)}else foo()}\",\n-        \"function(){if(e1){do foo();while(e2)}else foo()}\");\n-\n-    assertPrint(\"function(){if(e1)do foo();while(e2)else foo()}\",\n-        \"function(){if(e1){do foo();while(e2)}else foo()}\");\n+    assertPrint(\"function f(){if(e1){do foo();while(e2)}else foo()}\",\n+        \"function f(){if(e1){do foo();while(e2)}else foo()}\");\n+\n+    assertPrint(\"function f(){if(e1)do foo();while(e2)else foo()}\",\n+        \"function f(){if(e1){do foo();while(e2)}else foo()}\");\n \n     assertPrint(\"if(x){do{foo()}while(y)}else bar()\",\n         \"if(x){do foo();while(y)}else bar()\");\n \n   public void testFunctionSafariCompatiblity() {\n     // Functions within IFs cause syntax errors on Safari.\n-    assertPrint(\"function(){if(e1){function goo(){return true}}else foo()}\",\n-        \"function(){if(e1){function goo(){return true}}else foo()}\");\n-\n-    assertPrint(\"function(){if(e1)function goo(){return true}else foo()}\",\n-        \"function(){if(e1){function goo(){return true}}else foo()}\");\n+    assertPrint(\"function f(){if(e1){function goo(){return true}}else foo()}\",\n+        \"function f(){if(e1){function goo(){return true}}else foo()}\");\n+\n+    assertPrint(\"function f(){if(e1)function goo(){return true}else foo()}\",\n+        \"function f(){if(e1){function goo(){return true}}else foo()}\");\n \n     assertPrint(\"if(e1){function goo(){return true}}\",\n         \"if(e1){function goo(){return true}}\");\n--- a/test/com/google/javascript/jscomp/CollapseVariableDeclarationsTest.java\n+++ b/test/com/google/javascript/jscomp/CollapseVariableDeclarationsTest.java\n \n     test(\"a = null; this.foo = null;\",\n          \"this.foo = a = null\");\n-    test(\"function(){ a = null; return null; }\",\n-         \"function(){return a = null}\");\n+    test(\"function f(){ a = null; return null; }\",\n+         \"function f(){return a = null}\");\n     test(\"a = true; if (a) { foo(); }\",\n          \"if (a = true) { foo() }\");\n     test(\"a = true; if (a && a) { foo(); }\",\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n   }\n \n   public void testDuplicateParams() {\n-    test(\"function (a, a) {}\", RhinoErrorReporter.DUPLICATE_PARAM);\n+    test(\"function f(a, a) {}\", RhinoErrorReporter.DUPLICATE_PARAM);\n     assertTrue(lastCompiler.hasHaltingErrors());\n   }\n \n         \"  node0 [label=\\\"BLOCK\\\"];\\n\" +\n         \"  node1 [label=\\\"SCRIPT\\\"];\\n\" +\n         \"  node0 -> node1 [weight=1];\\n\" +\n-        \"  node1 -> RETURN [label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n-        \"  node0 -> RETURN [label=\\\"SYN_BLOCK\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n-        \"  node0 -> node1 [label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n+        \"  node1 -> RETURN [label=\\\"UNCOND\\\", \" +\n+            \"fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n+        \"  node0 -> RETURN [label=\\\"SYN_BLOCK\\\", \" +\n+            \"fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n+        \"  node0 -> node1 [label=\\\"UNCOND\\\", \" +\n+            \"fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n         \"}\\n\\n\",\n         new String(outReader.toByteArray()));\n   }\n--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n   // TODO(johnlenz): Add tests to the IntegrationTest.\n \n   public void testFold1() {\n-    test(\"function() { if (x) return; y(); }\",\n-         \"function(){x||y()}\");\n+    test(\"function f() { if (x) return; y(); }\",\n+         \"function f(){x||y()}\");\n   }\n \n   public void testFoldWithMarkers1() {\n-    testSame(\"function(){startMarker();if(x)return;endMarker();y()}\");\n+    testSame(\"function f(){startMarker();if(x)return;endMarker();y()}\");\n   }\n \n   public void testFoldWithMarkers1a() {\n-    testSame(\"function(){startMarker();if(x)return;endMarker()}\");\n+    testSame(\"function f(){startMarker();if(x)return;endMarker()}\");\n   }\n \n   public void testFold2() {\n-    test(\"function() { if (x) return; y(); if (a) return; b(); }\",\n-         \"function(){if(!x){y();a||b()}}\");\n+    test(\"function f() { if (x) return; y(); if (a) return; b(); }\",\n+         \"function f(){if(!x){y();a||b()}}\");\n   }\n \n   public void testFoldWithMarkers2() {\n-    testSame(\"function(){startMarker(\\\"FOO\\\");startMarker(\\\"BAR\\\");\" +\n+    testSame(\"function f(){startMarker(\\\"FOO\\\");startMarker(\\\"BAR\\\");\" +\n              \"if(x)return;endMarker(\\\"BAR\\\");y();if(a)return;\" +\n              \"endMarker(\\\"FOO\\\");b()}\");\n   }\n--- a/test/com/google/javascript/jscomp/DenormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/DenormalizeTest.java\n          \"for(init(); a < 2 ; a++) foo();\");\n \n     // Other statements are left as is.\n-    test(\"function(){ var a; for(; a < 2 ; a++) foo() }\",\n-         \"function(){ for(var a; a < 2 ; a++) foo() }\");\n-    testSame(\"function(){ return; for(; a < 2 ; a++) foo() }\");\n+    test(\"function f(){ var a; for(; a < 2 ; a++) foo() }\",\n+         \"function f(){ for(var a; a < 2 ; a++) foo() }\");\n+    testSame(\"function f(){ return; for(; a < 2 ; a++) foo() }\");\n   }\n \n   public void testForIn() {\n     testSame(\"init(); for(a in b) foo()\");\n \n     // Other statements are left as is.\n-    testSame(\"function(){ return; for(a in b) foo() }\");\n+    testSame(\"function f(){ return; for(a in b) foo() }\");\n   }\n \n   public void testInOperatorNotInsideFor() {\n     // a for loop, even if it's protected by parentheses.\n \n     // Make sure the in operator doesn't get moved into the for loop.\n-    testSame(\"function(){ var a; var i=\\\"length\\\" in a;\" +\n+    testSame(\"function f(){ var a; var i=\\\"length\\\" in a;\" +\n         \"for(; a < 2 ; a++) foo() }\");\n     // Same, but with parens around the operator.\n-    testSame(\"function(){ var a; var i=(\\\"length\\\" in a);\" +\n+    testSame(\"function f(){ var a; var i=(\\\"length\\\" in a);\" +\n         \"for(; a < 2 ; a++) foo() }\");\n     // Make sure Normalize yanks the variable initializer out, and\n     // Denormalize doesn't put it back.\n-    test(\"function(){var b,a=0; for (var i=(\\\"length\\\" in b);a<2; a++) foo()}\",\n-         \"function(){var b; var a=0;var i=(\\\"length\\\" in b);\" +\n+    test(\"function f(){\" +\n+         \"var b,a=0; for (var i=(\\\"length\\\" in b);a<2; a++) foo()}\",\n+         \"function f(){var b; var a=0;var i=(\\\"length\\\" in b);\" +\n          \"for (;a<2;a++) foo()}\");\n   }\n \n--- a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n     helperCanExposeExpression(\n         DecompositionType.MOVABLE, \"switch(foo()){}\", \"foo\");\n     helperCanExposeExpression(\n-        DecompositionType.MOVABLE, \"function (){ return foo();}\", \"foo\");\n+        DecompositionType.MOVABLE, \"function f(){ return foo();}\", \"foo\");\n \n     helperCanExposeExpression(\n         DecompositionType.MOVABLE, \"x = foo() && 1\", \"foo\");\n         DecompositionType.DECOMPOSABLE, \"switch(x = goo() && foo()){}\", \"foo\");\n     helperCanExposeExpression(\n         DecompositionType.DECOMPOSABLE,\n-        \"function (){ return goo() && foo();}\", \"foo\");\n+        \"function f(){ return goo() && foo();}\", \"foo\");\n   }\n \n   public void testCanExposeExpression4() {\n \n   public void testMoveExpression7() {\n     helperMoveExpression(\n-        \"function (){ return foo();}\",\n-        \"foo\",\n-        \"function (){ var temp$$0 = foo(); return temp$$0;}\");\n+        \"function f(){ return foo();}\",\n+        \"foo\",\n+        \"function f(){ var temp$$0 = foo(); return temp$$0;}\");\n   }\n \n   public void testMoveExpression8() {\n \n   public void testExposeExpression10() {\n     helperExposeExpression(\n-        \"function (){ return goo() && foo();}\",\n-        \"foo\",\n-        \"function (){\" +\n+        \"function f(){ return goo() && foo();}\",\n+        \"foo\",\n+        \"function f(){\" +\n           \"var temp$$0; if (temp$$0 = goo()) temp$$0 = foo();\" +\n           \"return temp$$0;\" +\n          \"}\");\n--- a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n     testSame(\"function _func(x) { print(x) }\");\n     testSame(\"function _func(x,y) { if(y) { x = 1 }; print(x) }\");\n \n-    test(\"function(x, y) { x = 1; print(x) }\",\n-         \"function(x, y) { print(1) }\");\n-\n-    test(\"function(x, y) { if (y) { x = 1; print(x) }}\",\n-         \"function(x, y) { if (y) { print(1) }}\");\n+    test(\"function f(x, y) { x = 1; print(x) }\",\n+         \"function f(x, y) { print(1) }\");\n+\n+    test(\"function f(x, y) { if (y) { x = 1; print(x) }}\",\n+         \"function f(x, y) { if (y) { print(1) }}\");\n   }\n \n   private void noInline(String input) {\n--- a/test/com/google/javascript/jscomp/FunctionArgumentInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionArgumentInjectorTest.java\n   public void testFindModifiedParameters1() {\n     assertEquals(Sets.newHashSet(),\n         FunctionArgumentInjector.findModifiedParameters(\n-            parseFunction(\"function (a){ return a==0; }\")));\n+            parseFunction(\"function f(a){ return a==0; }\")));\n   }\n \n   public void testFindModifiedParameters2() {\n     assertEquals(Sets.newHashSet(),\n         FunctionArgumentInjector.findModifiedParameters(\n-            parseFunction(\"function (a){ b=a }\")));\n+            parseFunction(\"function f(a){ b=a }\")));\n   }\n \n   public void testFindModifiedParameters3() {\n     assertEquals(Sets.newHashSet(\"a\"),\n         FunctionArgumentInjector.findModifiedParameters(\n-            parseFunction(\"function (a){ a=0 }\")));\n+            parseFunction(\"function f(a){ a=0 }\")));\n   }\n \n   public void testFindModifiedParameters4() {\n     assertEquals(Sets.newHashSet(\"a\", \"b\"),\n         FunctionArgumentInjector.findModifiedParameters(\n-            parseFunction(\"function (a,b){ a=0;b=0 }\")));\n+            parseFunction(\"function f(a,b){ a=0;b=0 }\")));\n   }\n \n   public void testFindModifiedParameters5() {\n     assertEquals(Sets.newHashSet(\"b\"),\n         FunctionArgumentInjector.findModifiedParameters(\n-            parseFunction(\"function (a,b){ a; if (a) b=0 }\")));\n+            parseFunction(\"function f(a,b){ a; if (a) b=0 }\")));\n   }\n \n   public void testMaybeAddTempsForCallArguments1() {\n         \"function foo(a,b){goo();for(;;){a;b;}}; foo(x,y);\",\n         \"foo\",\n         Sets.newHashSet(\"a\", \"b\"));\n-  }  \n+  }\n \n   public void testMaybeAddTempsForCallArguments20() {\n     // A long string referenced more than once should have a temp.\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n \n   public void testIsSimpleFunction1() {\n     assertTrue(getInjector().isDirectCallNodeReplacementPossible(\n-        prep(\"function(){}\")));\n+        prep(\"function f(){}\")));\n   }\n \n   public void testIsSimpleFunction2() {\n     assertTrue(getInjector().isDirectCallNodeReplacementPossible(\n-        prep(\"function(){return 0;}\")));\n+        prep(\"function f(){return 0;}\")));\n   }\n \n   public void testIsSimpleFunction3() {\n     assertTrue(getInjector().isDirectCallNodeReplacementPossible(\n-        prep(\"function(){return x ? 0 : 1}\")));\n+        prep(\"function f(){return x ? 0 : 1}\")));\n   }\n \n   public void testIsSimpleFunction4() {\n     assertFalse(getInjector().isDirectCallNodeReplacementPossible(\n-        prep(\"function(){return;}\")));\n+        prep(\"function f(){return;}\")));\n   }\n \n   public void testIsSimpleFunction5() {\n     assertFalse(getInjector().isDirectCallNodeReplacementPossible(\n-        prep(\"function(){return 0; return 0;}\")));\n+        prep(\"function f(){return 0; return 0;}\")));\n   }\n \n   public void testIsSimpleFunction6() {\n     assertFalse(getInjector().isDirectCallNodeReplacementPossible(\n-        prep(\"function(){var x=true;return x ? 0 : 1}\")));\n+        prep(\"function f(){var x=true;return x ? 0 : 1}\")));\n   }\n \n   public void testIsSimpleFunction7() {\n     assertFalse(getInjector().isDirectCallNodeReplacementPossible(\n-        prep(\"function(){if (x) return 0; else return 1}\")));\n+        prep(\"function f(){if (x) return 0; else return 1}\")));\n   }\n \n   public void testCanInlineReferenceToFunction1() {\n--- a/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java\n+++ b/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java\n   private String wrapInFunction(String s) {\n     return \"function f(){\" + s + \"}\";\n   }\n-  \n+\n   public void testInFunction(String original, String expected) {\n     test(wrapInFunction(original), wrapInFunction(expected));\n   }\n-  \n+\n   public void testSameInFunction(String original) {\n     testSame(wrapInFunction(original));\n-  }  \n-  \n+  }\n+\n   public void testMakeLocalNamesUniqueWithContext1() {\n     // Set the test type\n     this.useDefaultRenamer = true;\n         \"function foo(){var arguments;function bar(){var arguments;}}\");\n \n     invert = true;\n-    \n+\n     // Don't introduce new references to arguments, it is special.\n     test(\n         \"function foo(){var arguments$$1;}\",\n     testSame(\"function f() { var $$; }\");\n     test(\"var CONST = 3; var b = CONST;\",\n          \"var CONST = 3; var b = CONST;\");\n-    test(\"function() {var CONST = 3; var ACONST$$1 = 2;}\",\n-         \"function() {var CONST = 3; var ACONST = 2;}\");\n+    test(\"function f() {var CONST = 3; var ACONST$$1 = 2;}\",\n+         \"function f() {var CONST = 3; var ACONST = 2;}\");\n   }\n \n   public void testOnlyInversion2() {\n     invert = true;\n-    test(\"function () {try { } catch(e) {e;}; try { } catch(e$$0) {e$$0;}}\",\n-        \"function () {try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}}\");\n+    test(\"function f() {try { } catch(e) {e;}; try { } catch(e$$0) {e$$0;}}\",\n+        \"function f() {try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}}\");\n   }\n \n   public void testOnlyInversion3() {\n \n   public void testConstRemovingRename1() {\n     removeConst = true;\n-    test(\"function() {var CONST = 3; var ACONST$$1 = 2;}\",\n-         \"function() {var CONST$$unique_0 = 3; var ACONST$$unique_1 = 2;}\");\n+    test(\"(function () {var CONST = 3; var ACONST$$1 = 2;})\",\n+         \"(function () {var CONST$$unique_0 = 3; var ACONST$$unique_1 = 2;})\");\n   }\n \n   public void testConstRemovingRename2() {\n--- a/test/com/google/javascript/jscomp/MinimizeExitPointsTest.java\n+++ b/test/com/google/javascript/jscomp/MinimizeExitPointsTest.java\n   }\n \n   public void testFunctionReturnOptimization() throws Exception {\n-    fold(\"function(){if(a()){b();if(c())return;}}\",\n-         \"function(){if(a()){b();if(c());}}\");\n-    fold(\"function(){if(x)return; x=3; return; }\",\n-         \"function(){if(x); else x=3}\");\n-    fold(\"function(){if(true){a();return;}else;b();}\",\n-         \"function(){if(true){a();}else{b();}}\");\n-    fold(\"function(){if(false){a();return;}else;b();return;}\",\n-         \"function(){if(false){a();}else{b();}}\");\n-    fold(\"function(){if(a()){b();return;}else;c();}\",\n-         \"function(){if(a()){b();}else{c();}}\");\n-    fold(\"function(){if(a()){b()}else{c();return;}}\",\n-         \"function(){if(a()){b()}else{c();}}\");\n-    fold(\"function(){if(a()){b();return;}else;}\",\n-         \"function(){if(a()){b();}else;}\");\n-    fold(\"function(){if(a()){return;}else{return;} return;}\",\n-         \"function(){if(a()){}else{}}\");\n-    fold(\"function(){if(a()){return;}else{return;} b();}\",\n-         \"function(){if(a()){}else{return;b()}}\");\n-\n-    fold(\"function(){while(a())return;}\",\n-         \"function(){while(a())return}\");\n-    foldSame(\"function(){for(x in a())return}\");\n-\n-    fold(\"function(){while(a())break;}\",\n-         \"function(){while(a())break}\");\n-    foldSame(\"function(){for(x in a())break}\");\n-\n-    fold(\"function(){try{return;}catch(e){return;}finally{return}}\",\n-         \"function(){try{}catch(e){}finally{}}\");\n-    fold(\"function(){try{return;}catch(e){return;}}\",\n-         \"function(){try{}catch(e){}}\");\n-    fold(\"function(){try{return;}finally{return;}}\",\n-         \"function(){try{}finally{}}\");\n-    fold(\"function(){try{if(a()){return;}else{return;} return;}catch(e){}}\",\n-         \"function(){try{if(a()){}else{}}catch(e){}}\");\n-\n-    fold(\"function(){g:return}\",\n-         \"function(){}\");\n-    fold(\"function(){g:if(a()){return;}else{return;} return;}\",\n-         \"function(){g:if(a()){}else{}}\");\n-    fold(\"function(){try{g:if(a()){} return;}finally{return}}\",\n-         \"function(){try{g:if(a()){}}finally{}}\");\n+    fold(\"function f(){if(a()){b();if(c())return;}}\",\n+         \"function f(){if(a()){b();if(c());}}\");\n+    fold(\"function f(){if(x)return; x=3; return; }\",\n+         \"function f(){if(x); else x=3}\");\n+    fold(\"function f(){if(true){a();return;}else;b();}\",\n+         \"function f(){if(true){a();}else{b();}}\");\n+    fold(\"function f(){if(false){a();return;}else;b();return;}\",\n+         \"function f(){if(false){a();}else{b();}}\");\n+    fold(\"function f(){if(a()){b();return;}else;c();}\",\n+         \"function f(){if(a()){b();}else{c();}}\");\n+    fold(\"function f(){if(a()){b()}else{c();return;}}\",\n+         \"function f(){if(a()){b()}else{c();}}\");\n+    fold(\"function f(){if(a()){b();return;}else;}\",\n+         \"function f(){if(a()){b();}else;}\");\n+    fold(\"function f(){if(a()){return;}else{return;} return;}\",\n+         \"function f(){if(a()){}else{}}\");\n+    fold(\"function f(){if(a()){return;}else{return;} b();}\",\n+         \"function f(){if(a()){}else{return;b()}}\");\n+\n+    fold(\"function f(){while(a())return;}\",\n+         \"function f(){while(a())return}\");\n+    foldSame(\"function f(){for(x in a())return}\");\n+\n+    fold(\"function f(){while(a())break;}\",\n+         \"function f(){while(a())break}\");\n+    foldSame(\"function f(){for(x in a())break}\");\n+\n+    fold(\"function f(){try{return;}catch(e){return;}finally{return}}\",\n+         \"function f(){try{}catch(e){}finally{}}\");\n+    fold(\"function f(){try{return;}catch(e){return;}}\",\n+         \"function f(){try{}catch(e){}}\");\n+    fold(\"function f(){try{return;}finally{return;}}\",\n+         \"function f(){try{}finally{}}\");\n+    fold(\"function f(){try{if(a()){return;}else{return;} return;}catch(e){}}\",\n+         \"function f(){try{if(a()){}else{}}catch(e){}}\");\n+\n+    fold(\"function f(){g:return}\",\n+         \"function f(){}\");\n+    fold(\"function f(){g:if(a()){return;}else{return;} return;}\",\n+         \"function f(){g:if(a()){}else{}}\");\n+    fold(\"function f(){try{g:if(a()){} return;}finally{return}}\",\n+         \"function f(){try{g:if(a()){}}finally{}}\");\n   }\n \n   public void testWhileContinueOptimization() throws Exception {\n--- a/test/com/google/javascript/jscomp/NameAnonymousFunctionsMappedTest.java\n+++ b/test/com/google/javascript/jscomp/NameAnonymousFunctionsMappedTest.java\n   }\n \n   public void testAssignmentToGetElem() {\n-    test(\"function() { win['x' + this.id] = function(a){}; }\",\n-         \"function() { win['x' + this.id] = function $(a){}; }\");\n+    test(\"function f() { win['x' + this.id] = function(a){}; }\",\n+         \"function f() { win['x' + this.id] = function $(a){}; }\");\n \n     // TODO - could probably do a better job encoding these\n     assertMapping(\"$\", \"win[\\\"x\\\"+this.id]\");\n--- a/test/com/google/javascript/jscomp/NameAnonymousFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/NameAnonymousFunctionsTest.java\n   }\n \n   public void testAssignmentToGetElem() {\n-    test(\"function() { win['x' + this.id] = function(a){}; }\",\n-         \"function() { win['x' + this.id] = function $win$x$this$id$(a){}; }\");\n+    test(\"function f() {win['x' + this.id] = function(a){};}\",\n+         \"function f() {win['x' + this.id] = function $win$x$this$id$(a){};}\");\n   }\n \n   public void testGetElemWithDashes() {\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n             parse(\"foo();\")));\n     assertNodeNames(Sets.<String>newHashSet(),\n         NodeUtil.getVarsDeclaredInBranch(\n-            parse(\"function(){var foo;}\")));\n+            parse(\"function f(){var foo;}\")));\n     assertNodeNames(Sets.newHashSet(\"goo\"),\n         NodeUtil.getVarsDeclaredInBranch(\n-            parse(\"var goo;function(){var foo;}\")));\n+            parse(\"var goo;function f(){var foo;}\")));\n   }\n \n   private void assertNodeNames(Set<String> nodeNames, Collection<Node> nodes) {\n--- a/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java\n+++ b/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java\n   }\n \n   public void testNoVarArgs() {\n-    testSame(\"function(a,b,c) { alert(a + b + c) }\");\n+    testSame(\"function f(a,b,c) { alert(a + b + c) }\");\n \n-    test(\"function(a,b,c) { alert(arguments[0]) }\",\n-         \"function(a,b,c) { alert(a) }\");\n+    test(\"function f(a,b,c) { alert(arguments[0]) }\",\n+         \"function f(a,b,c) { alert(a) }\");\n   }\n \n   public void testMissingVarArgs() {\n-    testSame(\"function() { alert(arguments[x]) }\");\n+    testSame(\"function f() { alert(arguments[x]) }\");\n   }\n \n   public void testArgumentRefOnNamedParameter() {\n-    test(\"function(a,b) { alert(arguments[0]) }\",\n-         \"function(a,b) { alert(a) }\");\n+    test(\"function f(a,b) { alert(arguments[0]) }\",\n+         \"function f(a,b) { alert(a) }\");\n   }\n \n   public void testTwoVarArgs() {\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n \n   /** Check that removing blocks with 1 child works */\n   public void testFoldOneChildBlocksIntegration() {\n-     fold(\"function(){switch(foo()){default:{break}}}\",\n-          \"function(){foo()}\");\n-\n-     fold(\"function(){switch(x){default:{break}}}\",\n-          \"function(){}\");\n-\n-     fold(\"function(){switch(x){default:x;case 1:return 2}}\",\n-          \"function(){switch(x){default:case 1:return 2}}\");\n+     fold(\"function f(){switch(foo()){default:{break}}}\",\n+          \"function f(){foo()}\");\n+\n+     fold(\"function f(){switch(x){default:{break}}}\",\n+          \"function f(){}\");\n+\n+     fold(\"function f(){switch(x){default:x;case 1:return 2}}\",\n+          \"function f(){switch(x){default:case 1:return 2}}\");\n \n      // ensure that block folding does not break hook ifs\n      fold(\"if(x){if(true){foo();foo()}else{bar();bar()}}\",\n   /** Try to minimize returns */\n   public void testFoldReturnsIntegration() {\n     // if-then-else duplicate statement removal handles this case:\n-    fold(\"function(){if(x)return;else return}\",\n-         \"function(){}\");\n+    fold(\"function f(){if(x)return;else return}\",\n+         \"function f(){}\");\n   }\n \n   public void testBug1059649() {\n--- a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n     fold(\"{'hi'}\", \"\");\n     fold(\"{x==3}\", \"\");\n     fold(\"{ (function(){x++}) }\", \"\");\n-    fold(\"function(){return;}\", \"function(){return;}\");\n-    fold(\"function(){return 3;}\", \"function(){return 3}\");\n-    fold(\"function(){if(x)return; x=3; return; }\",\n-         \"function(){if(x)return; x=3; return; }\");\n+    fold(\"function f(){return;}\", \"function f(){return;}\");\n+    fold(\"function f(){return 3;}\", \"function f(){return 3}\");\n+    fold(\"function f(){if(x)return; x=3; return; }\",\n+         \"function f(){if(x)return; x=3; return; }\");\n     fold(\"{x=3;;;y=2;;;}\", \"x=3;y=2\");\n \n     // Cases to test for empty block.\n   public void testNew2() {\n     test(\"1 + new Date;\", \"\");\n   }\n-  \n+\n   public void testFoldAssign() {\n     test(\"x=x\", \"\");\n     testSame(\"x=xy\");\n     test(\"var y=(x=x)\", \"var y=x\");\n     test(\"y=1 + (x=x)\", \"y=1 + x\");\n   }\n-  \n+\n   public void testTryCatchFinally() {\n     testSame(\"try {foo()} catch (e) {bar()}\");\n     testSame(\"try { try {foo()} catch (e) {bar()}} catch (x) {bar()}\");\n     testSame(\"try {var x = 1} finally {x()}\");\n     test(\"function f() { return; try{var x = 1}finally{} }\",\n         \"function f() { return; var x = 1; }\");\n-  }  \n+  }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n   // Needed for testFoldLiteralObjectConstructors(),\n   // testFoldLiteralArrayConstructors() and testFoldRegExp...()\n   private static final String FOLD_CONSTANTS_TEST_EXTERNS =\n-      \"var Object = function(){};\\n\" +\n-      \"var RegExp = function(a){};\\n\" +\n-      \"var Array = function(a){};\\n\";\n+      \"var Object = function f(){};\\n\" +\n+      \"var RegExp = function f(a){};\\n\" +\n+      \"var Array = function f(a){};\\n\";\n \n   // TODO(user): Remove this when we no longer need to do string comparison.\n   private PeepholeSubstituteAlternateSyntaxTest(boolean compareAsTree) {\n \n   /** Check that removing blocks with 1 child works */\n   public void testFoldOneChildBlocks() {\n-    fold(\"function(){if(x)a();x=3}\",\n-        \"function(){x&&a();x=3}\");\n-    fold(\"function(){if(x){a()}x=3}\",\n-        \"function(){x&&a();x=3}\");\n-    fold(\"function(){if(x){return 3}}\",\n-        \"function(){if(x)return 3}\");\n-    fold(\"function(){if(x){a()}}\",\n-        \"function(){x&&a()}\");\n-    fold(\"function(){if(x){throw 1}}\", \"function(){if(x)throw 1;}\");\n+    fold(\"function f(){if(x)a();x=3}\",\n+        \"function f(){x&&a();x=3}\");\n+    fold(\"function f(){if(x){a()}x=3}\",\n+        \"function f(){x&&a();x=3}\");\n+    fold(\"function f(){if(x){return 3}}\",\n+        \"function f(){if(x)return 3}\");\n+    fold(\"function f(){if(x){a()}}\",\n+        \"function f(){x&&a()}\");\n+    fold(\"function f(){if(x){throw 1}}\", \"function f(){if(x)throw 1;}\");\n \n     // Try it out with functions\n-    fold(\"function(){if(x){foo()}}\", \"function(){x&&foo()}\");\n-    fold(\"function(){if(x){foo()}else{bar()}}\",\n-         \"function(){x?foo():bar()}\");\n+    fold(\"function f(){if(x){foo()}}\", \"function f(){x&&foo()}\");\n+    fold(\"function f(){if(x){foo()}else{bar()}}\",\n+         \"function f(){x?foo():bar()}\");\n \n     // Try it out with properties and methods\n-    fold(\"function(){if(x){a.b=1}}\", \"function(){if(x)a.b=1}\");\n-    fold(\"function(){if(x){a.b*=1}}\", \"function(){x&&(a.b*=1)}\");\n-    fold(\"function(){if(x){a.b+=1}}\", \"function(){x&&(a.b+=1)}\");\n-    fold(\"function(){if(x){++a.b}}\", \"function(){x&&++a.b}\");\n-    fold(\"function(){if(x){a.foo()}}\", \"function(){x&&a.foo()}\");\n+    fold(\"function f(){if(x){a.b=1}}\", \"function f(){if(x)a.b=1}\");\n+    fold(\"function f(){if(x){a.b*=1}}\", \"function f(){x&&(a.b*=1)}\");\n+    fold(\"function f(){if(x){a.b+=1}}\", \"function f(){x&&(a.b+=1)}\");\n+    fold(\"function f(){if(x){++a.b}}\", \"function f(){x&&++a.b}\");\n+    fold(\"function f(){if(x){a.foo()}}\", \"function f(){x&&a.foo()}\");\n \n     // Try it out with throw/catch/finally [which should not change]\n-    fold(\"function(){try{foo()}catch(e){bar(e)}finally{baz()}}\",\n-         \"function(){try{foo()}catch(e){bar(e)}finally{baz()}}\");\n+    fold(\"function f(){try{foo()}catch(e){bar(e)}finally{baz()}}\",\n+         \"function f(){try{foo()}catch(e){bar(e)}finally{baz()}}\");\n \n     // Try it out with switch statements\n-    fold(\"function(){switch(x){case 1:break}}\",\n-         \"function(){switch(x){case 1:break}}\");\n+    fold(\"function f(){switch(x){case 1:break}}\",\n+         \"function f(){switch(x){case 1:break}}\");\n \n     // Do while loops stay in a block if that's where they started\n-    fold(\"function(){if(e1){do foo();while(e2)}else foo2()}\",\n-         \"function(){if(e1){do foo();while(e2)}else foo2()}\");\n+    fold(\"function f(){if(e1){do foo();while(e2)}else foo2()}\",\n+         \"function f(){if(e1){do foo();while(e2)}else foo2()}\");\n     // Test an obscure case with do and while\n     fold(\"if(x){do{foo()}while(y)}else bar()\",\n          \"if(x){do foo();while(y)}else bar()\");\n \n     // Play with nested IFs\n-    fold(\"function(){if(x){if(y)foo()}}\",\n-         \"function(){x&&y&&foo()}\");\n-    fold(\"function(){if(x){if(y)foo();else bar()}}\",\n-         \"function(){x&&(y?foo():bar())}\");\n-    fold(\"function(){if(x){if(y)foo()}else bar()}\",\n-         \"function(){if(x)y&&foo();else bar()}\");\n-    fold(\"function(){if(x){if(y)foo();else bar()}else{baz()}}\",\n-         \"function(){if(x)y?foo():bar();else baz()}\");\n+    fold(\"function f(){if(x){if(y)foo()}}\",\n+         \"function f(){x&&y&&foo()}\");\n+    fold(\"function f(){if(x){if(y)foo();else bar()}}\",\n+         \"function f(){x&&(y?foo():bar())}\");\n+    fold(\"function f(){if(x){if(y)foo()}else bar()}\",\n+         \"function f(){if(x)y&&foo();else bar()}\");\n+    fold(\"function f(){if(x){if(y)foo();else bar()}else{baz()}}\",\n+         \"function f(){if(x)y?foo():bar();else baz()}\");\n \n     fold(\"if(e1){while(e2){if(e3){foo()}}}else{bar()}\",\n          \"if(e1)while(e2)e3&&foo();else bar()\");\n     fold(\"if(a){if(b){f1();f2();}else if(c){f3();}}else {if(d){f4();}}\",\n          \"if(a)if(b){f1();f2()}else c&&f3();else d&&f4()\");\n \n-    fold(\"function(){foo()}\", \"function(){foo()}\");\n+    fold(\"function f(){foo()}\", \"function f(){foo()}\");\n     fold(\"switch(x){case y: foo()}\", \"switch(x){case y:foo()}\");\n     fold(\"try{foo()}catch(ex){bar()}finally{baz()}\",\n          \"try{foo()}catch(ex){bar()}finally{baz()}\");\n \n   /** Try to minimize returns */\n   public void testFoldReturns() {\n-    fold(\"function(){if(x)return 1;else return 2}\",\n-         \"function(){return x?1:2}\");\n-    fold(\"function(){if(x)return 1+x;else return 2-x}\",\n-         \"function(){return x?1+x:2-x}\");\n-    fold(\"function(){if(x)return y += 1;else return y += 2}\",\n-         \"function(){return x?(y+=1):(y+=2)}\");\n-\n-    fold(\"function(){if(x)return;else return 2-x}\",\n-         \"function(){if(x);else return 2-x}\");\n-    fold(\"function(){if(x)return x;else return}\",\n-         \"function(){if(x)return x;else;}\");\n-\n-    foldSame(\"function(){for(var x in y) { return x.y; } return k}\");\n+    fold(\"function f(){if(x)return 1;else return 2}\",\n+         \"function f(){return x?1:2}\");\n+    fold(\"function f(){if(x)return 1+x;else return 2-x}\",\n+         \"function f(){return x?1+x:2-x}\");\n+    fold(\"function f(){if(x)return y += 1;else return y += 2}\",\n+         \"function f(){return x?(y+=1):(y+=2)}\");\n+\n+    fold(\"function f(){if(x)return;else return 2-x}\",\n+         \"function f(){if(x);else return 2-x}\");\n+    fold(\"function f(){if(x)return x;else return}\",\n+         \"function f(){if(x)return x;else;}\");\n+\n+    foldSame(\"function f(){for(var x in y) { return x.y; } return k}\");\n   }\n \n   /** Try to minimize assignments */\n   public void testFoldAssignments() {\n-    fold(\"function(){if(x)y=3;else y=4;}\", \"function(){y=x?3:4}\");\n-    fold(\"function(){if(x)y=1+a;else y=2+a;}\", \"function(){y=x?1+a:2+a}\");\n+    fold(\"function f(){if(x)y=3;else y=4;}\", \"function f(){y=x?3:4}\");\n+    fold(\"function f(){if(x)y=1+a;else y=2+a;}\", \"function f(){y=x?1+a:2+a}\");\n \n     // and operation assignments\n-    fold(\"function(){if(x)y+=1;else y+=2;}\", \"function(){y+=x?1:2}\");\n-    fold(\"function(){if(x)y-=1;else y-=2;}\", \"function(){y-=x?1:2}\");\n-    fold(\"function(){if(x)y%=1;else y%=2;}\", \"function(){y%=x?1:2}\");\n-    fold(\"function(){if(x)y|=1;else y|=2;}\", \"function(){y|=x?1:2}\");\n+    fold(\"function f(){if(x)y+=1;else y+=2;}\", \"function f(){y+=x?1:2}\");\n+    fold(\"function f(){if(x)y-=1;else y-=2;}\", \"function f(){y-=x?1:2}\");\n+    fold(\"function f(){if(x)y%=1;else y%=2;}\", \"function f(){y%=x?1:2}\");\n+    fold(\"function f(){if(x)y|=1;else y|=2;}\", \"function f(){y|=x?1:2}\");\n \n     // sanity check, don't fold if the 2 ops don't match\n-    foldSame(\"function(){if(x)y-=1;else y+=2}\");\n+    foldSame(\"function f(){if(x)y-=1;else y+=2}\");\n \n     // sanity check, don't fold if the 2 LHS don't match\n-    foldSame(\"function(){if(x)y-=1;else z-=1}\");\n+    foldSame(\"function f(){if(x)y-=1;else z-=1}\");\n \n     // sanity check, don't fold if there are potential effects\n-    foldSame(\"function(){if(x)y().a=3;else y().a=4}\");\n+    foldSame(\"function f(){if(x)y().a=3;else y().a=4}\");\n   }\n \n   public void testRemoveDuplicateStatements() {\n   }\n \n   public void testNotCond() {\n-    fold(\"function(){if(!x)foo()}\", \"function(){x||foo()}\");\n-    fold(\"function(){if(!x)b=1}\", \"function(){x||(b=1)}\");\n+    fold(\"function f(){if(!x)foo()}\", \"function f(){x||foo()}\");\n+    fold(\"function f(){if(!x)b=1}\", \"function f(){x||(b=1)}\");\n     fold(\"if(!x)z=1;else if(y)z=2\", \"if(x){y&&(z=2)}else z=1\");\n-    foldSame(\"function(){if(!(x=1))a.b=1}\");\n+    foldSame(\"function f(){if(!(x=1))a.b=1}\");\n   }\n \n   public void testAndParenthesesCount() {\n-    fold(\"function(){if(x||y)a.foo()}\", \"function(){(x||y)&&a.foo()}\");\n-    foldSame(\"function(){if(x()||y()){x()||y()}}\");\n+    fold(\"function f(){if(x||y)a.foo()}\", \"function f(){(x||y)&&a.foo()}\");\n+    foldSame(\"function f(){if(x()||y()){x()||y()}}\");\n   }\n \n   public void testFoldLogicalOpStringCompare() {\n \n     // Cannot fold, the constructor being used is actually a local function\n     foldSame(\"x = \" +\n-         \"(function(){function Object(){this.x=4};return new Object();})();\");\n+         \"(function f(){function Object(){this.x=4};return new Object();})();\");\n   }\n \n   public void testFoldLiteralArrayConstructors() {\n     foldSame(\"function f(){return void foo();}\");\n     fold(\"function f(){return undefined;}\",\n          \"function f(){}\");\n-    fold(\"function(){if(a()){return undefined;}}\",\n-         \"function(){if(a()){}}\");\n+    fold(\"function f(){if(a()){return undefined;}}\",\n+         \"function f(){if(a()){}}\");\n   }\n \n   public void testFoldStandardConstructors() {\n \n   public void testUndefined() {\n     foldSame(\"var x = undefined\");\n-    foldSame(\"function (f) {var undefined=2;var x = undefined;}\");\n+    foldSame(\"function f(f) {var undefined=2;var x = undefined;}\");\n     this.enableNormalize();\n     fold(\"var x = undefined\", \"var x=void 0\");\n     foldSame(\n--- a/test/com/google/javascript/jscomp/RemoveTryCatchTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveTryCatchTest.java\n   }\n \n   public void testPreserveTryBlockContainingReturnStatement() {\n-    testSame(\"function(){var a;try{a=1;return}finally{a=2}}\");\n+    testSame(\"function f(){var a;try{a=1;return}finally{a=2}}\");\n   }\n \n   public void testPreserveAnnotatedTryBlock() {\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n          \"var a,b,c,d,e,f; \" +\n              \"(function(g) {}); try { } catch(h) {}; var i = a + a;\"\n          );\n-    test(\"function(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,\" +\n-         \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,$){};\" +\n+    test(\"(function(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,\" +\n+         \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,$){});\" +\n          \"var a4,a3,a2,a1,b4,b3,b2,b1,ab,ac,ad,fg;function foo(){};\",\n-         \"function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,\" +\n-         \"A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$){};\" +\n+         \"(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,\" +\n+         \"A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$){});\" +\n          \"var aa,ba,ca,da,ea,fa,ga,ha,ia,ja,ka,la;function ma(){};\");\n   }\n \n \n   public void testStableRenameWithPointlesslyAnonymousFunctions() {\n     VariableMap expectedVariableMap = makeVariableMap(\"L 0\", \"a\", \"L 1\", \"b\");\n-    testRenameMap(\"function (v1, v2) {}; function (v3, v4) {};\",\n-                  \"function (a, b) {}; function (a, b) {};\",\n+    testRenameMap(\"(function (v1, v2) {}); (function (v3, v4) {});\",\n+                  \"(function (a, b) {}); (function (a, b) {});\",\n                   expectedVariableMap);\n \n     expectedVariableMap = makeVariableMap(\"L 0\", \"a\", \"L 1\", \"b\", \"L 2\", \"c\");\n-    testRenameMapUsingOldMap(\"function (v0, v1, v2) {}; function (v3, v4) {};\",\n-                             \"function (a, b, c) {}; function (a, b) {};\",\n+    testRenameMapUsingOldMap(\"(function (v0, v1, v2) {});\" +\n+                             \"(function (v3, v4) {});\",\n+                             \"(function (a, b, c) {});\" +\n+                             \"(function (a, b) {});\",\n                              expectedVariableMap);\n   }\n \n \n     expectedVariableMap = makeVariableMap(\n         \"f1\", \"a\", \"L 0\", \"b\", \"L 1\", \"c\", \"L 2\", \"d\", \"L 3\", \"e\", \"L 4\", \"f\");\n-    testRenameMapUsingOldMap(\"function f1(v1, v2) { (function(v3, v4, v5) {}) }\",\n-                             \"function a(b, c) { (function(d, e, f) {}) }\",\n-                             expectedVariableMap);\n+    testRenameMapUsingOldMap(\n+        \"function f1(v1, v2) { (function(v3, v4, v5) {}) }\",\n+        \"function a(b, c) { (function(d, e, f) {}) }\",\n+        expectedVariableMap);\n   }\n \n   public void testStableRenameWithExterns1() {\n     generatePseudoNames = true;\n     test(\"var foo = function(a, b, c){}\",\n          \"var $foo$$ = function($a$$, $b$$, $c$$){}\");\n-    \n+\n     test(\"var a = function(a, b, c){}\",\n          \"var $a$$ = function($a$$, $b$$, $c$$){}\");\n   }\n--- a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n     test(\"(function() {}).prototype[f] = function(){};\", \"\");\n   }\n \n-  public void testUnlessUnconditionalReturn() {\n+  public void testUselessUnconditionalReturn() {\n     test(\"function foo() { return }\", \" function foo() { }\");\n     test(\"function foo() { return; return; x=1 }\", \"function foo() { }\");\n     test(\"function foo() { return; return; var x=1}\", \"function foo() {var x}\");\n          \"function foo() {         function bar() {} }\" );\n     testSame(\"function foo() { return 5 }\");\n \n-\n-    test(\"function() {switch (a) { case 'a': return}}\",\n-         \"function() {switch (a) { case 'a': }}\");\n-    testSame(\"function() {switch (a) { case 'a': case foo(): }}\");\n-    testSame(\"function() {switch (a) { default: return; case 'a': alert(1)}}\");\n-    testSame(\"function() {switch (a) { case 'a': return; default: alert(1)}}\");\n+    test(\"function f() {switch (a) { case 'a': return}}\",\n+         \"function f() {switch (a) { case 'a': }}\");\n+    testSame(\"function f() {switch (a) { case 'a': case foo(): }}\");\n+    testSame(\"function f() {switch (a) {\" +\n+             \" default: return; case 'a': alert(1)}}\");\n+    testSame(\"function f() {switch (a) {\" +\n+             \" case 'a': return; default: alert(1)}}\");\n   }\n \n   public void testUnlessUnconditionalContinue() {\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n \n   private CheckLevel externValidationErrorLevel;\n \n+  private CompilerPass testSetupPass;\n+\n   public VarCheckTest() {\n     super(EXTERNS);\n   }\n     strictModuleDepErrorLevel = CheckLevel.OFF;\n     externValidationErrorLevel = null;\n     sanityCheck = false;\n+    testSetupPass = null;\n   }\n \n   @Override\n     if (!sanityCheck) {\n       return new CompilerPass() {\n         @Override public void process(Node externs, Node root) {\n+          if (testSetupPass != null) {\n+            testSetupPass.process(externs, root);\n+          }\n           new VarCheck(compiler, false).process(externs, root);\n           if (!compiler.hasErrors()) {\n             new VarCheck(compiler, true).process(externs, root);\n   }\n \n   public void testInvalidFunctionDecl1() {\n-    test(\"function() {};\", null, VarCheck.INVALID_FUNCTION_DECL);\n-  }\n-\n-  public void testInvalidFunctionDecl2() {\n-    test(\"if (true) { function() {}; }\", null, VarCheck.INVALID_FUNCTION_DECL);\n+    final CompilerTestCase testcase = this;\n+\n+    // A compiler pass that create invalid function names.\n+    testSetupPass = new CompilerPass() {\n+\n+      void visit(Node n) {\n+        if (n.getType() == Token.NAME\n+            && !n.getString().isEmpty()\n+            && n.getParent().getType() == Token.FUNCTION) {\n+          n.setString(\"\");\n+          testcase.getLastCompiler().reportCodeChange();\n+        }\n+        for (Node c : n.children()) {\n+          visit(c);\n+        }\n+      }\n+\n+      @Override\n+      public void process(Node externs, Node root) {\n+        visit(root);\n+      }\n+    };\n+\n+    test(\"function f() {};\", null, VarCheck.INVALID_FUNCTION_DECL);\n+    test(\"if (true) { function f(){}; }\", null, VarCheck.INVALID_FUNCTION_DECL);\n   }\n \n   public void testValidFunctionExpr() {\n--- a/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n   public void testCorrectCode() {\n     assertNoWarning(\"function foo(d) { (function() { d.foo(); }); d.bar(); } \");\n     assertNoWarning(\"function foo() { bar(); } function bar() { foo(); } \");\n-    assertNoWarning(\"function(d) { d = 3; }\");\n+    assertNoWarning(\"function f(d) { d = 3; }\");\n     assertNoWarning(VARIABLE_RUN);\n-    assertNoWarning(\"function() { \" + VARIABLE_RUN + \"}\");\n+    assertNoWarning(\"function f() { \" + VARIABLE_RUN + \"}\");\n   }\n \n   public void testCorrectShadowing() {\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n   }\n \n   public void testFunction2() {\n-    parse(\"function() {}\");\n+    parse(\"(function() {})\");\n   }\n \n   public void testFunction3() {\n   }\n \n   public void testFunction4() {\n-    parse(\"function(a) {}\");\n+    parse(\"(function(a) {})\");\n   }\n \n   public void testFunction5() {\n   }\n \n   public void testFunction6() {\n-    parse(\"function(a, b) {}\");\n+    parse(\"(function(a, b) {})\");\n   }\n \n   public void testReturn() {\n-    parse(\"function() {return 1;}\");\n+    parse(\"(function() {return 1;})\");\n   }\n \n   public void testReturn2() {\n-    parse(\"function() {return;}\");\n+    parse(\"function f() {return;}\");\n   }\n \n   public void testReturn3() {\n-    parse(\"function(){return x?1:2}\");\n+    parse(\"function f(){return x?1:2}\");\n   }\n \n   public void testThrow() {\n   }\n \n   public void testSwitch3() {\n-    parse(\"function(){switch(x){default:case 1:return 2}}\");\n+    parse(\"function f(){switch(x){default:case 1:return 2}}\");\n   }\n \n   public void testDebugger() {\n   private void testNoParseError(String string) {\n     testParseError(string, (String)null);\n   }\n-  \n+\n   private void testParseError(String string, String error) {\n     testParseError(string, error == null ? null : new String[] { error });\n   }\n-  \n+\n   private void testParseError(String string, String[] errors) {\n     Node root = newParse(string, new TestErrorReporter(errors, null));\n     assertTrue(\"unexpected warnings reported\",\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n         var.getJSDocInfo().getBlockDescription());\n   }\n \n+  public void testUnnamedFunctionStatement() {\n+    // Statements\n+    parseError(\"function() {};\", \"unnamed function statement\");\n+    parseError(\"if (true) { function() {}; }\", \"unnamed function statement\");\n+    parse(\"function f() {};\");\n+    // Expressions\n+    parse(\"(function f() {});\");\n+    parse(\"(function () {});\");\n+  }\n+\n   private void parseError(String string, String... errors) {\n     TestErrorReporter testErrorReporter = new TestErrorReporter(errors, null);\n     Node script = null;\n     try {\n       script = ParserRunner.parse(\n-          \"input\", string, ParserRunner.createConfig(true, es5mode),\n+          \"input\", string, ParserRunner.createConfig(true, es5mode, false),\n           testErrorReporter, Logger.getAnonymousLogger());\n     } catch (IOException e) {\n       throw new RuntimeException(e);\n     Node script = null;\n     try {\n       script = ParserRunner.parse(\n-          \"input\", string, ParserRunner.createConfig(true, es5mode),\n+          \"input\", string, ParserRunner.createConfig(true, es5mode, false),\n           testErrorReporter, Logger.getAnonymousLogger());\n     } catch (IOException e) {\n       throw new RuntimeException(e);", "timestamp": 1297977642, "metainfo": ""}