{"sha": "66527dd399f7142edc491037b4488b158073ae55", "log": "Fix needed PeepholeRemoveDeadCode to fix the Calendar builde.  R=dcc DELTA=330  (161 added, 96 deleted, 73 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=103004   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n \n /**\n  * An abstract class whose implementations run peephole optimizations:\n   boolean mayHaveSideEffects(Node n) {\n     return NodeUtil.mayHaveSideEffects(n, currentTraversal.getCompiler());\n   }\n+\n+  /**\n+   * Check if the specified node is null or is still in the AST.\n+   */\n+  @VisibleForTesting\n+  static Node validateResult(Node n) {\n+    done: {\n+      if (n != null && n.getType() != Token.SCRIPT\n+          && (n.getType() != Token.BLOCK || !n.isSyntheticBlock())) {\n+        for (Node parent : n.getAncestors()) {\n+          if (parent.getType() == Token.SCRIPT) {\n+            break done;\n+          }\n+        }\n+        Preconditions.checkState(false);\n+      }\n+    }\n+    return n;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     if (NodeUtil.isExpressionNode(parent)) {\n       // If the value isn't used, then just throw\n       // away the operator\n-      parent.replaceChild(n, n.removeFirstChild());\n+      Node replacement = n.removeFirstChild();\n+      parent.replaceChild(n, replacement);\n       reportCodeChange();\n-      return null;\n+      return replacement;\n     }\n \n     TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n     Preconditions.checkArgument(n.getType() == Token.BITAND\n         || n.getType() == Token.BITOR);\n \n-    if (left.getType() == Token.NUMBER &&\n-        right.getType() == Token.NUMBER) {\n-      double resultDouble;\n-      double lval = left.getDouble();\n-      double rval = right.getDouble();\n-\n-      // For now, we are being extra conservative, and only folding ints in\n-      // the range MIN_VALUE-MAX_VALUE\n-      if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE ||\n-          rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) {\n-\n-        // Fall back through and let the javascript use the larger values\n-        return n;\n-      }\n-\n-      // Convert the numbers to ints\n-      int lvalInt = (int) lval;\n-      if (lvalInt != lval) {\n-        return n;\n-      }\n-\n-      int rvalInt = (int) rval;\n-      if (rvalInt != rval) {\n-        return n;\n-      }\n-\n-      switch (n.getType()) {\n-        case Token.BITAND:\n-          resultDouble = lvalInt & rvalInt;\n-          break;\n-        case Token.BITOR:\n-          resultDouble = lvalInt | rvalInt;\n-          break;\n-        default:\n-          throw new Error(\"Unknown bitwise operator\");\n-      }\n-\n-      Node newNumber = Node.newNumber(resultDouble);\n-      n.getParent().replaceChild(n, newNumber);\n-      reportCodeChange();\n-    }\n-\n-    return n;\n+    if (left.getType() != Token.NUMBER ||\n+        right.getType() != Token.NUMBER) {\n+      return n;\n+    }\n+\n+    double resultDouble;\n+    double lval = left.getDouble();\n+    double rval = right.getDouble();\n+\n+    // For now, we are being extra conservative, and only folding ints in\n+    // the range MIN_VALUE-MAX_VALUE\n+    if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE ||\n+        rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) {\n+\n+      // Fall back through and let the javascript use the larger values\n+      return n;\n+    }\n+\n+    // Convert the numbers to ints\n+    int lvalInt = (int) lval;\n+    if (lvalInt != lval) {\n+      return n;\n+    }\n+\n+    int rvalInt = (int) rval;\n+    if (rvalInt != rval) {\n+      return n;\n+    }\n+\n+    switch (n.getType()) {\n+      case Token.BITAND:\n+        resultDouble = lvalInt & rvalInt;\n+        break;\n+      case Token.BITOR:\n+        resultDouble = lvalInt | rvalInt;\n+        break;\n+      default:\n+        throw new Error(\"Unknown bitwise operator\");\n+    }\n+\n+    Node newNumber = Node.newNumber(resultDouble);\n+    n.getParent().replaceChild(n, newNumber);\n+    reportCodeChange();\n+    return newNumber;\n   }\n \n   /**\n \n     return n;\n   }\n-\n }\n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n /**\n  * A compiler pass to run various peephole optimizations (e.g. constant folding,\n  * some useless code removal, some minimizations).\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n-class PeepholeOptimizationsPass extends AbstractPostOrderCallback \n+class PeepholeOptimizationsPass extends AbstractPostOrderCallback\n     implements CompilerPass {\n   private AbstractCompiler compiler;\n-  \n+\n   private ImmutableSet<AbstractPeepholeOptimization> peepholeOptimizations;\n-                \n-  PeepholeOptimizationsPass(AbstractCompiler compiler, \n+\n+  PeepholeOptimizationsPass(AbstractCompiler compiler,\n       ImmutableSet<AbstractPeepholeOptimization> optimizations) {\n     this.compiler = compiler;\n     this.peepholeOptimizations = optimizations;\n   }\n-  \n+\n   /**\n    * Creates a peephole optimization pass that runs the given\n    * optimizations.\n    */\n-  PeepholeOptimizationsPass(AbstractCompiler compiler, \n+  PeepholeOptimizationsPass(AbstractCompiler compiler,\n       AbstractPeepholeOptimization... optimizations) {\n-    this(compiler, ImmutableSet.copyOf(optimizations));     \n+    this(compiler, ImmutableSet.copyOf(optimizations));\n   }\n-  \n+\n   public AbstractCompiler getCompiler() {\n     return compiler;\n   }\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal t = new NodeTraversal(compiler, this);\n-    \n+\n     beginTraversal(t);\n     t.traverse(root);\n     endTraversal(t);\n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     Node currentVersionOfNode = n;\n-    \n     boolean somethingChanged = false;\n-    \n+\n     do {\n       somethingChanged = false;\n       for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n-        Node newVersionOfNode = \n+        Node newVersionOfNode =\n             optimization.optimizeSubtree(currentVersionOfNode);\n-        \n+\n         if (newVersionOfNode != currentVersionOfNode) {\n           somethingChanged = true;\n-          \n+\n           currentVersionOfNode = newVersionOfNode;\n         }\n-        \n+\n         if (currentVersionOfNode == null) {\n           return;\n         }\n       }\n     } while(somethingChanged);\n   }\n-  \n+\n   /**\n    * Make sure that all the optimizations have the current traversal so they\n    * can report errors.\n-   */ \n+   */\n   private void beginTraversal(NodeTraversal t) {\n     for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n       optimization.beginTraversal(t);\n-    } \n+    }\n   }\n-    \n+\n   private void endTraversal(NodeTraversal t) {\n     for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n       optimization.endTraversal(t);\n-    } \n+    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n       case Token.SCRIPT:\n       case Token.BLOCK:\n         return tryOptimizeBlock(subtree);\n+      case Token.EXPR_RESULT:\n+        return tryFoldHookExpr(subtree);\n+      case Token.HOOK:\n+        return tryFoldHook(subtree);\n       case Token.IF:\n-      case Token.HOOK:\n-        return tryFoldHookIf(subtree);\n+        return tryFoldIf(subtree);\n       case Token.WHILE:\n         return tryFoldWhile(subtree);\n        case Token.FOR: {\n    * Try removing unneeded block nodes and their useless children\n    */\n   Node tryOptimizeBlock(Node n) {\n-    // TODO(dcc): Make sure this is also applied in the global scope\n-    // (i.e. with Token.SCRIPT) parents\n     // Remove any useless children\n     for (Node c = n.getFirstChild(); c != null; ) {\n       Node next = c.getNext();  // save c.next, since 'c' may be removed\n   }\n \n   /**\n-   * Try folding :? (hook) and IF nodes by removing dead branches.\n+   * Try folding IF nodes by removing dead branches.\n    * @return the replacement node, if changed, or the original if not\n    */\n-  private Node tryFoldHookIf(Node n) {\n+  private Node tryFoldIf(Node n) {\n+    Preconditions.checkState(n.getType() == Token.IF);\n     Node parent = n.getParent();\n+    Preconditions.checkNotNull(parent);\n     int type = n.getType();\n     Node cond = n.getFirstChild();\n     Node thenBody = cond.getNext();\n     Node elseBody = thenBody.getNext();\n \n-    boolean changes = false;\n-\n-    if (type == Token.IF) {\n-      // if (x) { .. } else { } --> if (x) { ... }\n-      if (elseBody != null && !mayHaveSideEffects(elseBody)) {\n-        n.removeChild(elseBody);\n-        elseBody = null;\n+    // if (x) { .. } else { } --> if (x) { ... }\n+    if (elseBody != null && !mayHaveSideEffects(elseBody)) {\n+      n.removeChild(elseBody);\n+      elseBody = null;\n+      reportCodeChange();\n+    }\n+\n+    // if (x) { } else { ... } --> if (!x) { ... }\n+    if (!mayHaveSideEffects(thenBody) && elseBody != null) {\n+      n.removeChild(elseBody);\n+      n.replaceChild(thenBody, elseBody);\n+      Node notCond = new Node(Token.NOT);\n+      n.replaceChild(cond, notCond);\n+      notCond.addChildToFront(cond);\n+      cond = notCond;\n+      thenBody = cond.getNext();\n+      elseBody = null;\n+      reportCodeChange();\n+    }\n+\n+    // if (x()) { }\n+    if (!mayHaveSideEffects(thenBody) && elseBody == null) {\n+      if (mayHaveSideEffects(cond)) {\n+        // x() has side effects, just leave the condition on its own.\n+        n.removeChild(cond);\n+        Node replacement = NodeUtil.newExpr(cond);\n+        parent.replaceChild(n, replacement);\n         reportCodeChange();\n-        changes = true;\n-      }\n-\n-      // if (x) { } else { ... } --> if (!x) { ... }\n-      if (!mayHaveSideEffects(thenBody) && elseBody != null) {\n-        n.removeChild(elseBody);\n-        n.replaceChild(thenBody, elseBody);\n-        Node notCond = new Node(Token.NOT);\n-        n.replaceChild(cond, notCond);\n-        notCond.addChildToFront(cond);\n-        cond = notCond;\n-        thenBody = cond.getNext();\n-        elseBody = null;\n+        return replacement;\n+      } else {\n+        // x() has no side effects, the whole tree is useless now.\n+        NodeUtil.removeChild(parent, n);\n         reportCodeChange();\n-        changes = true;\n-      }\n-\n-      // if (x()) { }\n-      if (!mayHaveSideEffects(thenBody) && elseBody == null) {\n-        if (mayHaveSideEffects(cond)) {\n-          // x() has side effects, just leave the condition on its own.\n-          n.removeChild(cond);\n-          Node replacement = NodeUtil.newExpr(cond);\n-          parent.replaceChild(n, replacement);\n-          reportCodeChange();\n-          return replacement;\n-        } else {\n-          // x() has no side effects, the whole tree is useless now.\n-          NodeUtil.removeChild(parent, n);\n-          reportCodeChange();\n-          return null;\n-        }\n-      }\n-    } else {\n-      Preconditions.checkState(type == Token.HOOK);\n-      if (NodeUtil.isExpressionNode(parent)) {\n-        // Try to remove useless nodes.\n-        if (!mayHaveSideEffects(thenBody)) {\n-          // x?void 0:y --> if(!x)y\n-          Node ifNode = new Node(Token.IF);\n-          if (cond.getType() == Token.NOT) {\n-            Node expr = cond.getFirstChild();\n-            cond.removeChild(expr);\n-            ifNode.addChildToBack(expr);\n-          } else {\n-            Node not = new Node(Token.NOT).copyInformationFrom(cond);\n-            n.removeChild(cond);\n-            not.addChildToBack(cond);\n-            ifNode.addChildToBack(not);\n-          }\n-\n-          n.removeChild(elseBody);\n-          ifNode.addChildToBack(\n-              new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))\n-                  .copyInformationFrom(elseBody));\n-\n-          //This modifies outside the subtree, which is not\n-          //desirable in a peephole optimization.\n-          parent.getParent().replaceChild(parent, ifNode);\n-          reportCodeChange();\n-          return ifNode;\n-        } else if (!mayHaveSideEffects(elseBody)) {\n-          // x?y:void 0 --> if(x)y\n-          Node ifNode = new Node(Token.IF);\n-          n.removeChild(cond);\n-          ifNode.addChildToBack(cond);\n-          n.removeChild(thenBody);\n-\n-          ifNode.addChildToBack(\n-              new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))\n-                  .copyInformationFrom(thenBody));\n-\n-          //This modifies outside the subtree, which is not\n-          //desirable in a peephole optimization.\n-          parent.getParent().replaceChild(parent, ifNode);\n-          reportCodeChange();\n-          return ifNode;\n-        }\n+        return null;\n       }\n     }\n \n       return n;  // We can't remove branches otherwise!\n     }\n \n-    // Transform \"if (a = 2) {x =2}\" into \"a=2;x=2\"\n     if (mayHaveSideEffects(cond)) {\n-      if (n.getType() == Token.HOOK) {\n-        // Transform HOOK to BLOCK with the condition\n-        Node replacement = new Node(Token.BLOCK).copyInformationFrom(n);\n-        n.detachChildren();\n-        replacement.addChildToFront(\n-            new Node(Token.EXPR_RESULT, cond).copyInformationFrom(cond));\n-        Node branchToKeep = condValue.toBoolean(true) ? thenBody : elseBody;\n-        replacement.addChildToBack(\n-            NodeUtil.newExpr(branchToKeep)\n-                .copyInformationFrom(branchToKeep));\n-        // This modifies outside the subtree, which is not\n-        // desirable in a peephole optimization.\n-        parent.getParent().replaceChild(parent, replacement);\n-        reportCodeChange();\n-        return replacement;\n-      }\n-\n-      Preconditions.checkState(n.getType() == Token.IF);\n+      // Transform \"if (a = 2) {x =2}\" into \"if (true) {a=2;x=2}\"\n       boolean newConditionValue = condValue == TernaryValue.TRUE;\n       // Add an elseBody if it is needed.\n       if (!newConditionValue && elseBody == null) {\n     } else {\n       // Replace \"if (true) { X } else { Y }\" with X, or\n       // replace \"if (false) { X } else { Y }\" with Y.\n-      Node firstBranch = n.getFirstChild().getNext();\n-      Node secondBranch = firstBranch.getNext();\n-      Node branch = condTrue ? firstBranch : secondBranch;\n-      Node notBranch = condTrue ? secondBranch : firstBranch;\n-      NodeUtil.redeclareVarsInsideBranch(notBranch);\n-      n.removeChild(branch);\n-      parent.replaceChild(n, branch);\n-      reportCodeChange();\n-      return branch;\n-    }\n+      Node trueBranch = n.getFirstChild().getNext();\n+      Node falseBranch = trueBranch.getNext();\n+      Node branchToKeep = condTrue ? trueBranch : falseBranch;\n+      Node branchToRemove = condTrue ? falseBranch : trueBranch;\n+      NodeUtil.redeclareVarsInsideBranch(branchToRemove);\n+      n.removeChild(branchToKeep);\n+      parent.replaceChild(n, branchToKeep);\n+      reportCodeChange();\n+      return branchToKeep;\n+    }\n+  }\n+\n+  /**\n+   * Transform HOOK (?:) to IF if this allows the removal of useless branches.\n+   * @return the replacement node, if changed, or the original if not\n+   */\n+  private Node tryFoldHookExpr(Node n) {\n+    Preconditions.checkState(NodeUtil.isExpressionNode(n));\n+    Node hook = n.getFirstChild();\n+    // Only looking at hooks here.\n+    if (hook.getType() != Token.HOOK) {\n+      return n;\n+    }\n+\n+    Node parent = n.getParent();\n+    Preconditions.checkNotNull(parent);\n+    Node cond = hook.getFirstChild();\n+    Node thenBody = cond.getNext();\n+    Node elseBody = thenBody.getNext();\n+\n+    // Try to remove useless conditions and branches.\n+    if (!mayHaveSideEffects(thenBody)) {\n+      // x?void 0:y --> if(!x)y\n+      Node ifNode = new Node(Token.IF);\n+      if (cond.getType() == Token.NOT) {\n+        Node expr = cond.getFirstChild();\n+        cond.removeChild(expr);\n+        ifNode.addChildToBack(expr);\n+      } else {\n+        Node not = new Node(Token.NOT).copyInformationFrom(cond);\n+        hook.removeChild(cond);\n+        not.addChildToBack(cond);\n+        ifNode.addChildToBack(not);\n+      }\n+\n+      hook.removeChild(elseBody);\n+      ifNode.addChildToBack(\n+          new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))\n+              .copyInformationFrom(elseBody));\n+\n+      parent.replaceChild(n, ifNode);\n+      reportCodeChange();\n+      return ifNode;\n+    } else if (!mayHaveSideEffects(elseBody)) {\n+      // x?y:void 0 --> if(x)y\n+      Node ifNode = new Node(Token.IF);\n+      hook.removeChild(cond);\n+      ifNode.addChildToBack(cond);\n+      hook.removeChild(thenBody);\n+\n+      ifNode.addChildToBack(\n+          new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))\n+              .copyInformationFrom(thenBody));\n+\n+      parent.replaceChild(n, ifNode);\n+      reportCodeChange();\n+      return ifNode;\n+    }\n+\n+    return n;\n+  }\n+\n+  /**\n+   * Try folding HOOK (?:) if the condition results of the condition is known.\n+   * @return the replacement node, if changed, or the original if not\n+   */\n+  private Node tryFoldHook(Node n) {\n+    Preconditions.checkState(n.getType() == Token.HOOK);\n+    Node parent = n.getParent();\n+    Preconditions.checkNotNull(parent);\n+    Node cond = n.getFirstChild();\n+    Node thenBody = cond.getNext();\n+    Node elseBody = thenBody.getNext();\n+\n+    TernaryValue condValue = NodeUtil.getExpressionBooleanValue(cond);\n+    if (condValue == TernaryValue.UNKNOWN) {\n+      return n;  // We can't remove branches otherwise!\n+    }\n+\n+    // Transform \"(a = 2) ? x =2 : y\" into \"a=2,x=2\"\n+    n.detachChildren();\n+    Node branchToKeep = condValue.toBoolean(true) ? thenBody : elseBody;\n+    Node replacement;\n+    if (mayHaveSideEffects(cond)) {\n+      replacement = new Node(Token.COMMA).copyInformationFrom(n);\n+      replacement.addChildToFront(cond);\n+      replacement.addChildToBack(branchToKeep);\n+    } else {\n+      replacement = branchToKeep;\n+    }\n+\n+    parent.replaceChild(n, replacement);\n+    reportCodeChange();\n+    return replacement;\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n          \"var x;var y;var z;function f(){var a;var b}\");\n   }\n \n-  public void testHookIf() {\n+  public void testIf() {\n     fold(\"if (1){ x=1; } else { x = 2;}\", \"x=1\");\n     fold(\"if (false){ x = 1; } else { x = 2; }\", \"x=2\");\n     fold(\"if (undefined){ x = 1; } else { x = 2; }\", \"x=2\");\n     fold(\"if (null){ x = 1; } else { x = 2; }\", \"x=2\");\n     fold(\"if (void 0){ x = 1; } else { x = 2; }\", \"x=2\");\n-    // foldSame(\"if (void foo()){ x = 1; } else { x = 2; }\");\n+    fold(\"if (void foo()){ x = 1; } else { x = 2; }\",\n+         \"void foo();x=2\");\n     fold(\"if (false){ x = 1; } else if (true) { x = 3; } else { x = 2; }\",\n          \"x=3\");\n+    fold(\"if (x){ x = 1; } else if (false) { x = 3; }\",\n+         \"if(x)x=1\");\n+  }\n+\n+  public void testHook() {\n+    fold(\"true ? a() : b()\", \"a()\");\n+    fold(\"false ? a() : b()\", \"b()\");\n+\n+    fold(\"a() ? b() : true\", \"if (a()) b()\");\n+    fold(\"a() ? true : b()\", \"if (!a()) b()\");\n+\n+    fold(\"(a = true) ? b() : c()\", \"a = true; b()\");\n+    fold(\"(a = false) ? b() : c()\", \"a = false; c()\");\n+    fold(\"do {f()} while((a = true) ? b() : c())\",\n+         \"do {f()} while((a = true) , b())\");\n+    fold(\"do {f()} while((a = false) ? b() : c())\",\n+         \"do {f()} while((a = false) , c())\");\n \n     fold(\"var x = (true) ? 1 : 0\", \"var x=1\");\n     fold(\"var y = (true) ? ((false) ? 12 : (cond ? 1 : 2)) : 13\",\n          \"var y=cond?1:2\");\n-    fold(\"if (x){ x = 1; } else if (false) { x = 3; }\", \"if(x)x=1\");\n \n     foldSame(\"var z=x?void 0:y()\");\n     foldSame(\"z=x?void 0:y()\");", "timestamp": 1281639898, "metainfo": ""}