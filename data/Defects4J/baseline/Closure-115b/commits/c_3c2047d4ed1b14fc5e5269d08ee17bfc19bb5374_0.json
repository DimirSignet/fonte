{"sha": "3c2047d4ed1b14fc5e5269d08ee17bfc19bb5374", "log": "Change on 2010/04/27 by john          A generic replacement for ReplaceDebugStrings.          R=anatol         DELTA=864  (860 added, 0 deleted, 4 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=fpmbak   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     PassConfig.State state = getPassConfig().getIntermediateState();\n     return new Result(getErrors(), getWarnings(), debugLog.toString(),\n         state.variableMap, state.propertyMap,\n-        state.anonymousFunctionNameMap, functionInformationMap,\n+        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n         sourceMap, externExports, state.cssNames);\n   }\n \n   public void optimize() {\n     // Ideally, this pass should be the first pass run, however:\n     // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n-    // is done first.    \n+    // is done first.\n     // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n     // unmodified local names.\n-    normalize();    \n-    \n+    normalize();\n+\n     PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n     if (options.devMode == DevMode.EVERY_PASS) {\n       phaseOptimizer.setSanityCheck(sanityCheck);\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import java.io.Serializable;\n import java.nio.charset.Charset;\n import java.util.Collections;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n \n   /** Id generators to replace. */\n   Set<String> idGenerators;\n+\n+  /** Configuration strings */\n+  List<String> replaceStringsFunctionDescriptions;\n+  String replaceStringsPlaceholderToken;\n \n   //--------------------------------\n   // Output options\n     cssRenamingMap = null;\n     processObjectPropertyString = false;\n     idGenerators = Collections.emptySet();\n+    replaceStringsFunctionDescriptions = Collections.emptyList();\n+    replaceStringsPlaceholderToken = \"\";\n \n     // Output\n     printInputDelimiter = false;\n     this.idGenerators = Sets.newHashSet(idGenerators);\n   }\n \n+  /**\n+   * Sets the id generators to replace.\n+   */\n+  public void setReplaceStringsConfiguration(\n+      String placeholderToken, List<String> functionDescriptors) {\n+    this.replaceStringsPlaceholderToken = placeholderToken;\n+    this.replaceStringsFunctionDescriptions =\n+        Lists.newArrayList(functionDescriptors);\n+  }\n+\n   public void setRewriteNewDateGoogNow(boolean rewrite) {\n     this.rewriteNewDateGoogNow = rewrite;\n   }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   /** Fully qualified function names and globally unique ids */\n   private FunctionNames functionNames = null;\n \n+  /** String replacement map */\n+  private VariableMap stringMap = null;\n+\n   public DefaultPassConfig(CompilerOptions options) {\n     super(options);\n   }\n         exportedNames == null ? null :\n             Collections.unmodifiableSet(exportedNames),\n         crossModuleIdGenerator, variableMap, propertyMap,\n-        anonymousFunctionNameMap, functionNames);\n+        anonymousFunctionNameMap, stringMap, functionNames);\n   }\n \n   @Override\n     this.variableMap = state.variableMap;\n     this.propertyMap = state.propertyMap;\n     this.anonymousFunctionNameMap = state.anonymousFunctionNameMap;\n+    this.stringMap = state.stringMap;\n     this.functionNames = state.functionNames;\n   }\n \n     }\n \n     passes.add(createEmptyPass(\"beforeStandardOptimizations\"));\n+\n+    if (!options.replaceStringsFunctionDescriptions.isEmpty()) {\n+      passes.add(replaceStrings);\n+    }\n \n     if (!options.idGenerators.isEmpty()) {\n       passes.add(replaceIdGenerators);\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new ReplaceIdGenerators(compiler, options.idGenerators);\n+    }\n+  };\n+\n+  /** Replace strings. */\n+  private final PassFactory replaceStrings =\n+      new PassFactory(\"replaceStrings\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      VariableMap map = null;\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          ReplaceStrings pass = new ReplaceStrings(\n+              compiler,\n+              options.replaceStringsPlaceholderToken,\n+              options.replaceStringsFunctionDescriptions);\n+          pass.process(externs, root);\n+          stringMap = pass.getStringMap();\n+        }\n+      };\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n     final VariableMap variableMap;\n     final VariableMap propertyMap;\n     final VariableMap anonymousFunctionNameMap;\n+    final VariableMap stringMap;\n     final FunctionNames functionNames;\n \n     State(Map<String, Integer> cssNames, Set<String> exportedNames,\n           CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator,\n           VariableMap variableMap, VariableMap propertyMap,\n-          VariableMap anonymousFunctionNameMap, FunctionNames functionNames) {\n+          VariableMap anonymousFunctionNameMap,\n+          VariableMap stringMap, FunctionNames functionNames) {\n       this.cssNames = cssNames;\n       this.exportedNames = exportedNames;\n       this.crossModuleIdGenerator = crossModuleIdGenerator;\n       this.variableMap = variableMap;\n       this.propertyMap = propertyMap;\n       this.anonymousFunctionNameMap = anonymousFunctionNameMap;\n+      this.stringMap = stringMap;\n       this.functionNames = functionNames;\n     }\n   }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ReplaceStrings.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Replaces JavaScript strings in the list of supplied methods with shortened\n+ * forms. Useful for replacing debug message such as: throw new\n+ * Error(\"Something bad happened\"); with generated codes like: throw new\n+ * Error(\"a\"); This makes the compiled JavaScript smaller and prevents us from\n+ * leaking details about the source code.\n+ *\n+ * Based in concept on the work by Jared Jacobs.\n+*\n+ */\n+public class ReplaceStrings extends AbstractPostOrderCallback\n+    implements CompilerPass {\n+  static final DiagnosticType BAD_REPLACEMENT_CONFIGURATION =\n+      DiagnosticType.warning(\n+          \"JSC_BAD_REPLACEMENT_CONFIGURATION\",\n+          \"Bad replacement configuration.\");\n+\n+  private final String DEFAULT_PLACEHOLDER_TOKEN = \"`\";\n+  private final String placeholderToken;\n+  private static final String REPLACE_ONE_MARKER = \"?\";\n+  private static final String REPLACE_ALL_MARKER = \"*\";\n+\n+  private final AbstractCompiler compiler;\n+  private final JSTypeRegistry registry;\n+\n+  //\n+  private final Map<String, Config> functions = Maps.newHashMap();\n+  private final Multimap<String, String> methods = HashMultimap.create();\n+  private final NameGenerator nameGenerator = createNameGenerator();\n+  private final Map<String, Result> results = Maps.newLinkedHashMap();\n+\n+  /**\n+   * Describes a function to look for a which parameters to replace.\n+   */\n+  private class Config {\n+    // TODO(johnlenz): Support name \"groups\" so that unrelated strings can\n+    // reuse strings.  For example, event-id can reuse the names used for logger\n+    // classes.\n+    final String name;\n+    final int parameter;\n+    static final int REPLACE_ALL_VALUE = 0;\n+\n+    Config(String name, int parameter) {\n+      this.name = name;\n+      this.parameter = parameter;\n+    }\n+  }\n+\n+  /**\n+   * Describes a replacement that occurred.\n+   */\n+  class Result {\n+    // The original message with non-static content replaced with\n+    // {@code placeholderToken}.\n+    public final String original;\n+    public final String replacement;\n+    public final List<Location> replacementLocations = Lists.newLinkedList();\n+\n+    Result(String original, String replacement) {\n+      this.original = original;\n+      this.replacement = replacement;\n+    }\n+\n+    void addLocation(Node n) {\n+      replacementLocations.add(new Location(\n+          (String)n.getProp(Node.SOURCEFILE_PROP),\n+          n.getLineno(), n.getCharno()));\n+    }\n+  }\n+\n+  /** Represent a source location where a replacement occurred. */\n+  class Location {\n+    public final String sourceFile;\n+    public final int line;\n+    public final int column;\n+    Location(String sourceFile, int line, int column) {\n+      this.sourceFile = sourceFile;\n+      this.line = line;\n+      this.column = column;\n+    }\n+  }\n+\n+  /**\n+   * @param placeholderToken Separator to use between string parts. Used to replace\n+   *     non-static string content.\n+   * @param functionsToInspect A list of function configurations in the form of\n+   *     function($,,,)\n+   *   or\n+   *     class.prototype.method($,,,)\n+   * where '$' is used to indicate which parameter should be replaced.\n+   */\n+  ReplaceStrings(\n+      AbstractCompiler compiler, String placeholderToken,\n+      List<String> functionsToInspect) {\n+    this.compiler = compiler;\n+    this.placeholderToken = placeholderToken.isEmpty()\n+        ? DEFAULT_PLACEHOLDER_TOKEN : placeholderToken;\n+    this.registry = compiler.getTypeRegistry();\n+\n+    // Intialize the map of functions to inspect for renaming canidates.\n+    parseConfiguration(functionsToInspect);\n+  }\n+\n+  // Get the list of all replacements performed.\n+  List<Result> getResult() {\n+    return ImmutableList.copyOf(results.values());\n+  }\n+\n+  // Get the list of replaces as a VariableMap\n+  VariableMap getStringMap() {\n+    Map<String, String> map = Maps.newHashMap();\n+    for (Result result : results.values()) {\n+      map.put(result.replacement, result.original);\n+    }\n+\n+    VariableMap stringMap = new VariableMap(map);\n+    return stringMap;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    // TODO(johnlenz): Determine if it is necessary to support \".call\" or\n+    // \".apply\".\n+    switch (n.getType()) {\n+      case Token.NEW: // e.g. new Error('msg');\n+      case Token.CALL: // e.g. Error('msg');\n+        Node calledFn = n.getFirstChild();\n+\n+        // Look for calls to static functions.\n+        String name = calledFn.getQualifiedName();\n+        if (name != null) {\n+          Config config = findMatching(name);\n+          if (config != null) {\n+            doSubstitutions(t, config, n);\n+            return;\n+          }\n+        }\n+\n+        // Look for calls to class methods.\n+        if (NodeUtil.isGet(calledFn)) {\n+          Node rhs = calledFn.getLastChild();\n+          if (rhs.getType() == Token.NAME || rhs.getType() == Token.STRING) {\n+            String methodName = rhs.getString();\n+            Collection<String> classes = methods.get(methodName);\n+            if (classes != null) {\n+              Node lhs = calledFn.getFirstChild();\n+              JSType type = lhs.getJSType().restrictByNotNullOrUndefined();\n+              Config config = findMatchingClass(type, classes);\n+              if (config != null) {\n+                doSubstitutions(t, config, n);\n+                return;\n+              }\n+            }\n+          }\n+        }\n+        break;\n+    }\n+  }\n+\n+  /**\n+   * @param name The function name to find.\n+   * @return The Config object for the name or null if no match was found.\n+   */\n+  private Config findMatching(String name) {\n+    Config config = functions.get(name);\n+    if (config == null) {\n+      name = name.replace('$', '.');\n+      config = functions.get(name);\n+    }\n+    return config;\n+  }\n+\n+  /**\n+   * @return The Config object for the class match the specified type or null\n+   * if no match was found.\n+   */\n+  private Config findMatchingClass(\n+      JSType callClassType, Collection<String> declarationNames) {\n+    if (!callClassType.isNoObjectType() && !callClassType.isUnknownType()) {\n+      for (String declarationName : declarationNames) {\n+        String className = getClassFromDeclarationName(declarationName);\n+        JSType methodClassType = registry.getType(className);\n+        if (methodClassType != null\n+            && callClassType.isSubtype(methodClassType)) {\n+          return functions.get(declarationName);\n+        }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Replace the parameters specified in the config, if possible.\n+   */\n+  private void doSubstitutions(NodeTraversal t, Config config, Node n) {\n+    Preconditions.checkState(\n+        n.getType() == Token.NEW || n.getType() == Token.CALL);\n+\n+    if (config.parameter != Config.REPLACE_ALL_VALUE) {\n+      // Note: the first child is the function, but the parameter id is 1 based.\n+      Node arg = n.getChildAtIndex(config.parameter);\n+      if (arg != null) {\n+        replaceExpression(t, arg, n);\n+      }\n+    } else {\n+      // Replace all parameters.\n+      Node firstParam = n.getFirstChild().getNext();\n+      for (Node arg = firstParam; arg != null; arg = arg.getNext()) {\n+        arg = replaceExpression(t, arg, n);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Replaces a string expression with a short encoded string expression.\n+   *\n+   * @param t The traversal\n+   * @param expr The expression node\n+   * @param parent The expression node's parent\n+   * @return The replacement node (or the original expression if no replacement\n+   *         is made)\n+   */\n+  private Node replaceExpression(NodeTraversal t, Node expr, Node parent) {\n+    Node replacement;\n+    String key = null;\n+    String replacementString;\n+    switch (expr.getType()) {\n+      case Token.STRING:\n+        key = expr.getString();\n+        replacementString = getReplacement(key);\n+        replacement = Node.newString(replacementString);\n+        break;\n+      case Token.ADD:\n+        StringBuilder keyBuilder = new StringBuilder();\n+        Node keyNode = Node.newString(\"\");\n+        replacement = buildReplacement(expr, keyNode, keyBuilder);\n+        key = keyBuilder.toString();\n+        replacementString = getReplacement(key);\n+        keyNode.setString(replacementString);\n+        break;\n+      case Token.NAME:\n+        // If the referenced variable is a constant, use its value.\n+        Scope.Var var = t.getScope().getVar(expr.getString());\n+        if (var != null && var.isConst()) {\n+          Node value = var.getInitialValue();\n+          if (value != null && value.getType() == Token.STRING) {\n+            key = value.getString();\n+            replacementString = getReplacement(key);\n+            replacement = Node.newString(replacementString);\n+            break;\n+          }\n+        }\n+        return expr;\n+      default:\n+        // This may be a function call or a variable reference. We don't\n+        // replace these.\n+        return expr;\n+    }\n+\n+    Preconditions.checkNotNull(key);\n+    Preconditions.checkNotNull(replacementString);\n+    recordReplacement(expr, key, replacementString);\n+\n+    parent.replaceChild(expr, replacement);\n+    compiler.reportCodeChange();\n+    return replacement;\n+  }\n+\n+  /**\n+   * Get a replacement string for the provide key text.\n+   */\n+  private String getReplacement(String key) {\n+    Result result = results.get(key);\n+    if (result != null) {\n+      return result.replacement;\n+    }\n+\n+    String replacement = nameGenerator.generateNextName();\n+    result = new Result(key, replacement);\n+    results.put(key, result);\n+    return replacement;\n+  }\n+\n+  /**\n+   * Record the location the replacement was made.\n+   */\n+  private void recordReplacement(Node n, String key, String replacement) {\n+    Result result = results.get(key);\n+    Preconditions.checkState(result != null);\n+\n+    result.addLocation(n);\n+  }\n+\n+  /**\n+   * Builds a replacement abstract syntax tree for the string expression {@code\n+   * expr}. Appends any string literal values that are encountered to\n+   * {@code keyBuilder}, to build the expression's replacement key.\n+   *\n+   * @param expr A JS expression that evaluates to a string value\n+   * @param prefix The JS expression to which {@code expr}'s replacement is\n+   *        logically being concatenated. It is a partial solution to the\n+   *        problem at hand and will either be this method's return value or a\n+   *        descendant of it.\n+   * @param keyBuilder A builder of the string expression's replacement key\n+   * @return The abstract syntax tree that should replace {@code expr}\n+   */\n+  private Node buildReplacement(\n+      Node expr, Node prefix, StringBuilder keyBuilder) {\n+    switch (expr.getType()) {\n+      case Token.ADD:\n+        Node left = expr.getFirstChild();\n+        Node right = left.getNext();\n+        prefix = buildReplacement(left, prefix, keyBuilder);\n+        return buildReplacement(right, prefix, keyBuilder);\n+      case Token.STRING:\n+        keyBuilder.append(expr.getString());\n+        return prefix;\n+      default:\n+        keyBuilder.append(placeholderToken);\n+        prefix = new Node(\n+            Token.ADD, prefix, Node.newString(placeholderToken));\n+        return new Node(Token.ADD, prefix, expr.cloneTree());\n+    }\n+  }\n+\n+  /**\n+   * From a provide name extract the method name.\n+   */\n+  private String getMethodFromDeclarationName(String fullDeclarationName) {\n+    String[] parts = fullDeclarationName.split(\"\\\\.prototype\\\\.\");\n+    Preconditions.checkState(parts.length == 1 || parts.length == 2);\n+    if (parts.length == 2) {\n+      return parts[1];\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * From a provide name extract the class name.\n+   */\n+  private String getClassFromDeclarationName(String fullDeclarationName) {\n+    String[] parts = fullDeclarationName.split(\"\\\\.prototype\\\\.\");\n+    Preconditions.checkState(parts.length == 1 || parts.length == 2);\n+    if (parts.length == 2) {\n+      return parts[0];\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Build the data structures need by this pass from the provided\n+   * list of functions and methods.\n+   */\n+  private void parseConfiguration(List<String> functionsToInspect) {\n+    for (String function : functionsToInspect) {\n+      Config config = parseConfiguration(function);\n+      functions.put(config.name, config);\n+\n+      String method = getMethodFromDeclarationName(config.name);\n+      if (method != null) {\n+        methods.put(method, config.name);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Convert the provide string into a Config.  The string can be a static function:\n+   *    foo(,,?)\n+   *    foo.bar(?)\n+   * or a class method:\n+   *    foo.prototype.bar(?)\n+   * And is allowed to either replace all parameters using \"*\" or one parameter \"?\".\n+   * \",\" is used as a placeholder for ignored parameters.\n+   */\n+  private Config parseConfiguration(String function) {\n+    // Looks like this function_name(,$,)\n+    int first = function.indexOf('(');\n+    int last = function.indexOf(')');\n+\n+    // TODO(johnlenz): Make parsing precondition checks JSErrors reports.\n+    Preconditions.checkState(first != -1 && last != -1);\n+\n+    String name = function.substring(0, first);\n+    String params = function.substring(first+1, last);\n+\n+    int paramCount = 0;\n+    int replacementParameter = -1;\n+    String[] parts = params.split(\",\");\n+    for (String param : parts) {\n+      paramCount++;\n+      if (param.equals(REPLACE_ALL_MARKER)) {\n+        Preconditions.checkState(paramCount == 1 && parts.length == 1);\n+        replacementParameter = Config.REPLACE_ALL_VALUE;\n+      } else if (param.equals(REPLACE_ONE_MARKER)) {\n+        // TODO(johnlenz): Support multiple.\n+        Preconditions.checkState(replacementParameter == -1);\n+        replacementParameter = paramCount;\n+      } else {\n+        Preconditions.checkState(param.isEmpty(), \"Unknown marker\");\n+      }\n+    }\n+\n+    Preconditions.checkState(replacementParameter != -1);\n+    return new Config(name, replacementParameter);\n+  }\n+\n+  /**\n+   * Use a name generate to create names so the names overlap with the names\n+   * used for variable and properties.\n+   */\n+  private static NameGenerator createNameGenerator() {\n+    final String namePrefix = \"\";\n+    final char[] reservedChars = new char[0];\n+    final Set<String> reservedNames = ImmutableSet.of();\n+    return new NameGenerator(reservedNames, namePrefix, reservedChars);\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/Result.java\n+++ b/src/com/google/javascript/jscomp/Result.java\n   public final VariableMap variableMap;\n   public final VariableMap propertyMap;\n   public final VariableMap namedAnonFunctionMap;\n+  public final VariableMap stringMap;\n   public final FunctionInformationMap functionInformationMap;\n   public final SourceMap sourceMap;\n   public final Map<String, Integer> cssNames;\n   Result(JSError[] errors, JSError[] warnings, String debugLog,\n          VariableMap variableMap, VariableMap propertyMap,\n          VariableMap namedAnonFunctionMap,\n+         VariableMap stringMap,\n          FunctionInformationMap functionInformationMap,\n          SourceMap sourceMap,  String externExport,\n          Map<String, Integer> cssNames) {\n     this.variableMap = variableMap;\n     this.propertyMap = propertyMap;\n     this.namedAnonFunctionMap = namedAnonFunctionMap;\n+    this.stringMap = stringMap;\n     this.functionInformationMap = functionInformationMap;\n     this.sourceMap = sourceMap;\n     this.externExport = externExport;\n                 FunctionInformationMap functionInformationMap,\n                 SourceMap sourceMap, String externExport) {\n     this(errors, warnings, debugLog, variableMap, propertyMap,\n-         namedAnonFunctionMap, functionInformationMap, sourceMap,\n+         namedAnonFunctionMap, null, functionInformationMap, sourceMap,\n          externExport, null);\n   }\n }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ReplaceStringsTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.ReplaceStrings.Result;\n+\n+import java.util.List;\n+\n+/**\n+ * Tests for {@link ReplaceStrings}.\n+ *\n+*\n+ */\n+public class ReplaceStringsTest extends CompilerTestCase {\n+  private ReplaceStrings pass;\n+\n+  private final static String EXTERNS =\n+    \"var goog = {};\\n\" +\n+    \"goog.debug = {};\\n\" +\n+    \"/** @constructor */\\n\" +\n+    \"goog.debug.Trace = function() {};\\n\" +\n+    \"goog.debug.Trace.startTracer = function (var_args) {};\\n\" +\n+    \"/** @constructor */\\n\" +\n+    \"goog.debug.Logger = function() {};\\n\" +\n+    \"goog.debug.Logger.prototype.info = function(msg, opt_ex) {};\\n\" +\n+    \"/**\\n\" +\n+    \" * @param {string} name\\n\" +\n+    \" * @return {!goog.debug.Logger}\\n\" +\n+    \" */\\n\" +\n+    \"goog.debug.Logger.getLogger = function(name){};\\n\";\n+\n+  public ReplaceStringsTest() {\n+    super(EXTERNS, true);\n+    enableNormalize();\n+  }\n+\n+  @Override\n+  protected CompilerOptions getOptions() {\n+    CompilerOptions options = super.getOptions();\n+    options.setWarningLevel(\n+        DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.OFF);\n+    return options;\n+  }\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    super.enableLineNumberCheck(false);\n+    super.enableTypeCheck(CheckLevel.OFF);\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(Compiler compiler) {\n+    List<String> names = Lists.newArrayList(\n+        \"Error(?)\",\n+        \"goog.debug.Trace.startTracer(*)\",\n+        \"goog.debug.Logger.getLogger(?)\",\n+        \"goog.debug.Logger.prototype.info(?)\"\n+        );\n+    pass = new ReplaceStrings(compiler, \"`\", names);\n+    return pass;\n+  }\n+\n+  @Override\n+  public int getNumRepetitions() {\n+    // This compiler pass is not idempotent and should only be run over a\n+    // parse tree once.\n+    return 1;\n+  }\n+\n+  public void testThrowError1() {\n+    testDebugStrings(\n+        \"throw Error('xyz');\",\n+        \"throw Error('a');\",\n+        (new String[] { \"a\", \"xyz\" }));\n+  }\n+\n+  public void testThrowError2() {\n+    testDebugStrings(\n+        \"throw Error('x' +\\n    'yz');\",\n+        \"throw Error('a');\",\n+        (new String[] { \"a\", \"xyz\" }));\n+  }\n+\n+  public void testThrowError3() {\n+    testDebugStrings(\n+        \"throw Error('Unhandled mail' + ' search type ' + type);\",\n+        \"throw Error('a' + '`' + type);\",\n+        (new String[] { \"a\", \"Unhandled mail search type `\" }));\n+  }\n+\n+  public void testThrowError4() {\n+    testDebugStrings(\n+        \"/** @constructor */\\n\" +\n+        \"var A = function() {};\\n\" +\n+        \"A.prototype.m = function(child) {\\n\" +\n+        \"  if (this.haveChild(child)) {\\n\" +\n+        \"    throw Error('Node: ' + this.getDataPath() +\\n\" +\n+        \"                ' already has a child named ' + child);\\n\" +\n+        \"  } else if (child.parentNode) {\\n\" +\n+        \"    throw Error('Node: ' + child.getDataPath() +\\n\" +\n+        \"                ' already has a parent');\\n\" +\n+        \"  }\\n\" +\n+        \"  child.parentNode = this;\\n\" +\n+        \"};\",\n+\n+        \"var A = function(){};\\n\" +\n+        \"A.prototype.m = function(child) {\\n\" +\n+        \"  if (this.haveChild(child)) {\\n\" +\n+        \"    throw Error('a' + '`' + this.getDataPath() + '`' + child);\\n\" +\n+        \"  } else if (child.parentNode) {\\n\" +\n+        \"    throw Error('b' + '`' + child.getDataPath());\\n\" +\n+        \"  }\\n\" +\n+        \"  child.parentNode = this;\\n\" +\n+        \"};\",\n+        (new String[] {\n+            \"a\",\n+            \"Node: ` already has a child named `\",\n+            \"b\",\n+            \"Node: ` already has a parent\",\n+            }));\n+  }\n+\n+  public void testThrowNonStringError() {\n+    // No replacement is done when an error is neither a string literal nor\n+    // a string concatenation expression.\n+    testDebugStrings(\n+        \"throw Error(x('abc'));\",\n+        \"throw Error(x('abc'));\",\n+        (new String[] { }));\n+  }\n+\n+  public void testThrowConstStringError() {\n+    testDebugStrings(\n+        \"var AA = 'uvw', AB = 'xyz'; throw Error(AB);\",\n+        \"var AA = 'uvw', AB = 'xyz'; throw Error('a');\",\n+        (new String [] { \"a\", \"xyz\" }));\n+  }\n+\n+  public void testThrowNewError1() {\n+    testDebugStrings(\n+        \"throw new Error('abc');\",\n+        \"throw new Error('a');\",\n+        (new String[] { \"a\", \"abc\" }));\n+  }\n+\n+  public void testThrowNewError2() {\n+    testDebugStrings(\n+        \"throw new Error();\",\n+        \"throw new Error();\",\n+        new String[] {});\n+  }\n+\n+  public void testStartTracer1() {\n+    testDebugStrings(\n+        \"goog.debug.Trace.startTracer('HistoryManager.updateHistory');\",\n+        \"goog.debug.Trace.startTracer('a');\",\n+        (new String[] { \"a\", \"HistoryManager.updateHistory\" }));\n+  }\n+\n+  public void testStartTracer2() {\n+    testDebugStrings(\n+        \"goog$debug$Trace.startTracer('HistoryManager', 'updateHistory');\",\n+        \"goog$debug$Trace.startTracer('a', 'b');\",\n+        (new String[] {\n+            \"a\", \"HistoryManager\",\n+            \"b\", \"updateHistory\" }));\n+  }\n+\n+  public void testStartTracer3() {\n+    testDebugStrings(\n+        \"goog$debug$Trace.startTracer('ThreadlistView',\\n\" +\n+        \"                             'Updating ' + array.length + ' rows');\",\n+        \"goog$debug$Trace.startTracer('a', 'b' + '`' + array.length);\",\n+        new String[] { \"a\", \"ThreadlistView\", \"b\", \"Updating ` rows\" });\n+  }\n+\n+  public void testStartTracer4() {\n+    testDebugStrings(\n+        \"goog.debug.Trace.startTracer(s, 'HistoryManager.updateHistory');\",\n+        \"goog.debug.Trace.startTracer(s, 'a');\",\n+        (new String[] { \"a\", \"HistoryManager.updateHistory\" }));\n+  }\n+\n+  public void testLoggerInitialization() {\n+    testDebugStrings(\n+        \"goog$debug$Logger$getLogger('my.app.Application');\",\n+        \"goog$debug$Logger$getLogger('a');\",\n+        (new String[] { \"a\", \"my.app.Application\" }));\n+  }\n+\n+  public void testLoggerOnObject1() {\n+    testDebugStrings(\n+        \"var x = {};\" +\n+        \"x.logger_ = goog.debug.Logger.getLogger('foo');\" +\n+        \"x.logger_.info('Some message');\",\n+        \"var x = {};\" +\n+        \"x.logger_ = goog.debug.Logger.getLogger('a');\" +\n+        \"x.logger_.info('b');\",\n+        new String[] {\n+            \"a\", \"foo\",\n+            \"b\", \"Some message\"});\n+  }\n+\n+  // Non-matching \"info\" property.\n+  public void testLoggerOnObject2() {\n+    testSame(\n+        \"var x = {};\" +\n+        \"x.info = function(a) {};\" +\n+        \"x.info('Some message');\");\n+  }\n+\n+  // Non-matching \"info\" prototype property.\n+  public void testLoggerOnObject3() {\n+    testSame(\n+        \"/** @constructor */\\n\" +\n+        \"var x = function() {};\\n\" +\n+        \"x.prototype.info = function(a) {};\" +\n+        \"(new x).info('Some message');\");\n+  }\n+\n+  // Non-matching \"info\" property on \"NoObject\" type.\n+  public void testLoggerOnObject4() {\n+    testSame(\"(new x).info('Some message');\");\n+  }\n+\n+  // Non-matching \"info\" property on \"UnknownObject\" type.\n+  public void testLoggerOnObject5() {\n+    testSame(\"my$Thing.logger_.info('Some message');\");\n+  }\n+\n+  public void testLoggerOnVar() {\n+    testDebugStrings(\n+        \"var logger = goog.debug.Logger.getLogger('foo');\" +\n+        \"logger.info('Some message');\",\n+        \"var logger = goog.debug.Logger.getLogger('a');\" +\n+        \"logger.info('b');\",\n+        new String[] {\n+            \"a\", \"foo\",\n+            \"b\", \"Some message\"});\n+  }\n+\n+  public void testLoggerOnThis() {\n+    testDebugStrings(\n+        \"this.logger_ = goog.debug.Logger.getLogger('foo');\" +\n+        \"this.logger_.info('Some message');\",\n+        \"this.logger_ = goog.debug.Logger.getLogger('a');\" +\n+        \"this.logger_.info('b');\",\n+        new String[] {\n+            \"a\", \"foo\",\n+            \"b\", \"Some message\"});\n+  }\n+\n+  public void testRepeatedErrorString1() {\n+    testDebugStrings(\n+        \"Error('abc');Error('def');Error('abc');\",\n+        \"Error('a');Error('b');Error('a');\",\n+        (new String[] { \"a\", \"abc\", \"b\", \"def\" }));\n+  }\n+\n+  public void testRepeatedErrorString2() {\n+    testDebugStrings(\n+        \"Error('a:' + u + ', b:' + v); Error('a:' + x + ', b:' + y);\",\n+        \"Error('a' + '`' + u + '`' + v); Error('a' + '`' + x + '`' + y);\",\n+        (new String[] { \"a\", \"a:`, b:`\" }));\n+  }\n+\n+  public void testRepeatedErrorString3() {\n+    testDebugStrings(\n+        \"var AB = 'b'; throw Error(AB); throw Error(AB);\",\n+        \"var AB = 'b'; throw Error('a'); throw Error('a');\",\n+        (new String[] { \"a\", \"b\" }));\n+  }\n+\n+  public void testRepeatedTracerString() {\n+    testDebugStrings(\n+        \"goog$debug$Trace.startTracer('A', 'B', 'A');\",\n+        \"goog$debug$Trace.startTracer('a', 'b', 'a');\",\n+        (new String[] { \"a\", \"A\", \"b\", \"B\" }));\n+  }\n+\n+  public void testRepeatedLoggerString() {\n+    testDebugStrings(\n+        \"goog$debug$Logger$getLogger('goog.net.XhrTransport');\" +\n+        \"goog$debug$Logger$getLogger('my.app.Application');\" +\n+        \"goog$debug$Logger$getLogger('my.app.Application');\",\n+        \"goog$debug$Logger$getLogger('a');\" +\n+        \"goog$debug$Logger$getLogger('b');\" +\n+        \"goog$debug$Logger$getLogger('b');\",\n+        new String[] {\n+            \"a\", \"goog.net.XhrTransport\",\"b\", \"my.app.Application\" });\n+  }\n+\n+  public void testRepeatedStringsWithDifferentMethods() {\n+    test(\n+        \"throw Error('A');\"\n+            + \"goog$debug$Trace.startTracer('B', 'A');\"\n+            + \"goog$debug$Logger$getLogger('C');\"\n+            + \"goog$debug$Logger$getLogger('B');\"\n+            + \"goog$debug$Logger$getLogger('A');\"\n+            + \"throw Error('D');\"\n+            + \"throw Error('C');\"\n+            + \"throw Error('B');\"\n+            + \"throw Error('A');\",\n+        \"throw Error('a');\"\n+            + \"goog$debug$Trace.startTracer('b', 'a');\"\n+            + \"goog$debug$Logger$getLogger('c');\"\n+            + \"goog$debug$Logger$getLogger('b');\"\n+            + \"goog$debug$Logger$getLogger('a');\"\n+            + \"throw Error('d');\"\n+            + \"throw Error('c');\"\n+            + \"throw Error('b');\"\n+            + \"throw Error('a');\");\n+  }\n+\n+  private void testDebugStrings(String js, String expected,\n+                                String[] substitutedStrings) {\n+    // Verify that the strings are substituted correctly in the js code.\n+    test(js, expected);\n+\n+    List<Result> results = pass.getResult();\n+    assertTrue(substitutedStrings.length % 2 == 0);\n+    assertEquals(substitutedStrings.length/2, results.size());\n+\n+    // Verify that substituted strings are decoded correctly.\n+    for (int i = 0; i < substitutedStrings.length; i += 2) {\n+      Result result = results.get(i/2);\n+      String original = substitutedStrings[i + 1];\n+      assertEquals(original, result.original);\n+\n+      String replacement = substitutedStrings[i];\n+      assertEquals(replacement, result.replacement);\n+    }\n+  }\n+}", "timestamp": 1272478389, "metainfo": ""}