{"sha": "66c8c695fd8130e3ede6f77c6e5cc1ec96a0e9b3", "log": "preserve whitespace at the beginning of license blocks makes the <code> in closure docs look a lot better fixes issue 701  R=jschorr DELTA=73  (52 added, 10 deleted, 11 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4482   ", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n \n     boolean ignoreStar = false;\n \n+    // Track the start of the line to count whitespace that\n+    // the tokenizer skipped. Because this case is rare, it's easier\n+    // to do this here than in the tokenizer.\n+    int lineStartChar = -1;\n+\n     do {\n       switch (token) {\n         case STAR:\n-          if (!ignoreStar) {\n+          if (ignoreStar) {\n+            // Mark the position after the star as the new start of the line.\n+            lineStartChar = stream.getCharno() + 1;\n+          } else {\n+            // The star is part of the comment.\n             if (builder.length() > 0) {\n               builder.append(' ');\n             }\n           }\n \n           ignoreStar = true;\n+          lineStartChar = 0;\n           token = next();\n           continue;\n \n-        case ANNOTATION:\n-        case EOC:\n-        case EOF:\n-          // When we're capturing a license block, annotations\n-          // in the block are ok.\n-          if (!(option == WhitespaceOption.PRESERVE &&\n-                token == JsDocToken.ANNOTATION)) {\n+        default:\n+          ignoreStar = false;\n+          state = State.SEARCHING_ANNOTATION;\n+\n+          boolean isEOC = token == JsDocToken.EOC;\n+          if (!isEOC) {\n+            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {\n+              int numSpaces = stream.getCharno() - lineStartChar;\n+              for (int i = 0; i < numSpaces; i++) {\n+                builder.append(' ');\n+              }\n+              lineStartChar = -1;\n+            } else if (builder.length() > 0) {\n+              // All tokens must be separated by a space.\n+              builder.append(' ');\n+            }\n+          }\n+\n+          if (token == JsDocToken.EOC ||\n+              token == JsDocToken.EOF ||\n+              // When we're capturing a license block, annotations\n+              // in the block are ok.\n+              (token == JsDocToken.ANNOTATION &&\n+               option != WhitespaceOption.PRESERVE)) {\n             String multilineText = builder.toString();\n \n             if (option != WhitespaceOption.PRESERVE) {\n             }\n \n             return new ExtractionInfo(multilineText, token);\n-          }\n-\n-          // FALL THROUGH\n-\n-        default:\n-          ignoreStar = false;\n-          state = State.SEARCHING_ANNOTATION;\n-\n-          if (builder.length() > 0) {\n-            builder.append(' ');\n           }\n \n           builder.append(toString(token));\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     testSame(options, code);\n   }\n \n+  public void testIssue701() {\n+    // Check ASCII art in license comments.\n+    String ascii = \"/**\\n\" +\n+        \" * @preserve\\n\" +\n+        \"   This\\n\" +\n+        \"     is\\n\" +\n+        \"       ASCII    ART\\n\" +\n+        \"*/\";\n+    String result = \"/*\\n\\n\" +\n+        \"   This\\n\" +\n+        \"     is\\n\" +\n+        \"       ASCII    ART\\n\" +\n+        \"*/\\n\";\n+    testSame(createCompilerOptions(), ascii);\n+    assertEquals(result, lastCompiler.toSource());\n+  }\n+\n   public void testCoaleseVariables() {\n     CompilerOptions options = createCompilerOptions();\n \n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n     this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n     String comment = \"@preserve Foo\\nBar\\n\\nBaz*/\";\n     parse(comment);\n-    assertEquals(\" Foo\\n Bar\\n\\n Baz\", node.getJSDocInfo().getLicense());\n+    assertEquals(\" Foo\\nBar\\n\\nBaz\", node.getJSDocInfo().getLicense());\n   }\n \n   public void testParseLicense() throws Exception {\n     this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n     String comment = \"@license Foo\\nBar\\n\\nBaz*/\";\n     parse(comment);\n-    assertEquals(\" Foo\\n Bar\\n\\n Baz\", node.getJSDocInfo().getLicense());\n+    assertEquals(\" Foo\\nBar\\n\\nBaz\", node.getJSDocInfo().getLicense());\n+  }\n+\n+  public void testParseLicenseAscii() throws Exception {\n+    Node node = new Node(1);\n+    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n+    String comment = \"@license Foo\\n *   Bar\\n\\n  Baz*/\";\n+    parse(comment);\n+    assertEquals(\" Foo\\n   Bar\\n\\n  Baz\", node.getJSDocInfo().getLicense());\n   }\n \n   public void testParseLicenseWithAnnotation() throws Exception {", "timestamp": 1333649413, "metainfo": ""}