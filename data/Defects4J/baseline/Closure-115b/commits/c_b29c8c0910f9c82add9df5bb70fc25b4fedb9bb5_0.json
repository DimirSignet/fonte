{"sha": "b29c8c0910f9c82add9df5bb70fc25b4fedb9bb5", "log": "Remove unneeded parts of rhino_ast  R=nicksantos DELTA=5085  (0 added, 5081 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3648   ", "commit": "\n--- a/src/com/google/javascript/rhino/Kit.java\n+++ b/src/com/google/javascript/rhino/Kit.java\n \n package com.google.javascript.rhino;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.Reader;\n-import java.lang.reflect.Method;\n-import java.util.Hashtable;\n-\n /**\n  * Collection of utilities\n  */\n-public class Kit\n-{\n-    /**\n-     * Reflection of Throwable.initCause(Throwable) from JDK 1.4\n-     * or nul if it is not available.\n-     */\n-    private static Method Throwable_initCause = null;\n-\n-    static {\n-        // Are we running on a JDK 1.4 or later system?\n-        try {\n-            Class<?> ThrowableClass = Kit.classOrNull(\"java.lang.Throwable\");\n-            Class<?>[] signature = { ThrowableClass };\n-            Throwable_initCause\n-                = ThrowableClass.getMethod(\"initCause\", signature);\n-        } catch (Exception ex) {\n-            // Assume any exceptions means the method does not exist.\n-        }\n-    }\n-\n-    public static Class<?> classOrNull(String className)\n-    {\n-        try {\n-            return Class.forName(className);\n-        } catch  (ClassNotFoundException ex) {\n-        } catch  (SecurityException ex) {\n-        } catch  (LinkageError ex) {\n-        } catch (IllegalArgumentException e) {\n-            // Can be thrown if name has characters that a class name\n-            // can not contain\n-        }\n-        return null;\n-    }\n-\n-    public static Class<?> classOrNull(ClassLoader loader, String className)\n-    {\n-        try {\n-            return loader.loadClass(className);\n-        } catch (ClassNotFoundException ex) {\n-        } catch (SecurityException ex) {\n-        } catch  (LinkageError ex) {\n-        } catch (IllegalArgumentException e) {\n-            // Can be thrown if name has characters that a class name\n-            // can not contain\n-        }\n-        return null;\n-    }\n-\n-    static <T> T newInstanceOrNull(Class<T> cl)\n-    {\n-        try {\n-            return cl.newInstance();\n-        } catch (SecurityException x) {\n-        } catch  (LinkageError ex) {\n-        } catch (InstantiationException x) {\n-        } catch (IllegalAccessException x) {\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * If initCause methods exists in Throwable, call\n-     * <tt>ex.initCause(cause)</tt> or otherwise do nothing.\n-     * @return The <tt>ex</tt> argument.\n-     */\n-    public static RuntimeException initCause(RuntimeException ex,\n-                                             Throwable cause)\n-    {\n-        if (Throwable_initCause != null) {\n-            Object[] args = { cause };\n-            try {\n-                Throwable_initCause.invoke(ex, args);\n-            } catch (Exception e) {\n-                // Ignore any exceptions\n-            }\n-        }\n-        return ex;\n-    }\n-\n-    /**\n-     * Split string into array of strings using semicolon as string terminator\n-     * (; after the last string is required).\n-     */\n-    public static String[] semicolonSplit(String s)\n-    {\n-        String[] array = null;\n-        for (;;) {\n-            // loop 2 times: first to count semicolons and then to fill array\n-            int count = 0;\n-            int cursor = 0;\n-            for (;;) {\n-                int next = s.indexOf(';', cursor);\n-                if (next < 0) {\n-                    break;\n-                }\n-                if (array != null) {\n-                    array[count] = s.substring(cursor, next);\n-                }\n-                ++count;\n-                cursor = next + 1;\n-            }\n-            // after the last semicolon\n-            if (array == null) {\n-                // array size counting state:\n-                // check for required terminating ';'\n-                if (cursor != s.length())\n-                    throw new IllegalArgumentException();\n-                array = new String[count];\n-            } else {\n-                // array filling state: stop the loop\n-                break;\n-            }\n-        }\n-        return array;\n-    }\n-\n+public class Kit {\n     /**\n      * If character <tt>c</tt> is a hexadecimal digit, return\n      * <tt>accumulator</tt> * 16 plus corresponding\n     }\n \n     /**\n-     * Add <i>listener</i> to <i>bag</i> of listeners.\n-     * The function does not modify <i>bag</i> and return a new collection\n-     * containing <i>listener</i> and all listeners from <i>bag</i>.\n-     * Bag without listeners always represented as the null value.\n-     * <p>\n-     * Usage example:\n-     * <pre>\n-     *     private volatile Object changeListeners;\n-     *\n-     *     public void addMyListener(PropertyChangeListener l)\n-     *     {\n-     *         synchronized (this) {\n-     *             changeListeners = Kit.addListener(changeListeners, l);\n-     *         }\n-     *     }\n-     *\n-     *     public void removeTextListener(PropertyChangeListener l)\n-     *     {\n-     *         synchronized (this) {\n-     *             changeListeners = Kit.removeListener(changeListeners, l);\n-     *         }\n-     *     }\n-     *\n-     *     public void fireChangeEvent(Object oldValue, Object newValue)\n-     *     {\n-     *     // Get immune local copy\n-     *         Object listeners = changeListeners;\n-     *         if (listeners != null) {\n-     *             PropertyChangeEvent e = new PropertyChangeEvent(\n-     *                 this, \"someProperty\" oldValue, newValue);\n-     *             for (int i = 0; ; ++i) {\n-     *                 Object l = Kit.getListener(listeners, i);\n-     *                 if (l == null)\n-     *                     break;\n-     *                 ((PropertyChangeListener)l).propertyChange(e);\n-     *             }\n-     *         }\n-     *     }\n-     * </pre>\n-     *\n-     * @param listener Listener to add to <i>bag</i>\n-     * @param bag Current collection of listeners.\n-     * @return A new bag containing all listeners from <i>bag</i> and\n-     *          <i>listener</i>.\n-     * @see #removeListener(Object bag, Object listener)\n-     * @see #getListener(Object bag, int index)\n-     */\n-    public static Object addListener(Object bag, Object listener)\n-    {\n-        if (listener == null) throw new IllegalArgumentException();\n-        if (listener instanceof Object[]) throw new IllegalArgumentException();\n-\n-        if (bag == null) {\n-            bag = listener;\n-        } else if (!(bag instanceof Object[])) {\n-            bag = new Object[] { bag, listener };\n-        } else {\n-            Object[] array = (Object[])bag;\n-            int L = array.length;\n-            // bag has at least 2 elements if it is array\n-            if (L < 2) throw new IllegalArgumentException();\n-            Object[] tmp = new Object[L + 1];\n-            System.arraycopy(array, 0, tmp, 0, L);\n-            tmp[L] = listener;\n-            bag = tmp;\n-        }\n-\n-        return bag;\n-    }\n-\n-    /**\n-     * Remove <i>listener</i> from <i>bag</i> of listeners.\n-     * The function does not modify <i>bag</i> and return a new collection\n-     * containing all listeners from <i>bag</i> except <i>listener</i>.\n-     * If <i>bag</i> does not contain <i>listener</i>, the function returns\n-     * <i>bag</i>.\n-     * <p>\n-     * For usage example, see {@link #addListener(Object bag, Object listener)}.\n-     *\n-     * @param listener Listener to remove from <i>bag</i>\n-     * @param bag Current collection of listeners.\n-     * @return A new bag containing all listeners from <i>bag</i> except\n-     *          <i>listener</i>.\n-     * @see #addListener(Object bag, Object listener)\n-     * @see #getListener(Object bag, int index)\n-     */\n-    public static Object removeListener(Object bag, Object listener)\n-    {\n-        if (listener == null) throw new IllegalArgumentException();\n-        if (listener instanceof Object[]) throw new IllegalArgumentException();\n-\n-        if (bag == listener) {\n-            bag = null;\n-        } else if (bag instanceof Object[]) {\n-            Object[] array = (Object[])bag;\n-            int L = array.length;\n-            // bag has at least 2 elements if it is array\n-            if (L < 2) throw new IllegalArgumentException();\n-            if (L == 2) {\n-                if (array[1] == listener) {\n-                    bag = array[0];\n-                } else if (array[0] == listener) {\n-                    bag = array[1];\n-                }\n-            } else {\n-                int i = L;\n-                do {\n-                    --i;\n-                    if (array[i] == listener) {\n-                        Object[] tmp = new Object[L - 1];\n-                        System.arraycopy(array, 0, tmp, 0, i);\n-                        System.arraycopy(array, i + 1, tmp, i, L - (i + 1));\n-                        bag = tmp;\n-                        break;\n-                    }\n-                } while (i != 0);\n-            }\n-        }\n-\n-        return bag;\n-    }\n-\n-    /**\n-     * Get listener at <i>index</i> position in <i>bag</i> or null if\n-     * <i>index</i> equals to number of listeners in <i>bag</i>.\n-     * <p>\n-     * For usage example, see {@link #addListener(Object bag, Object listener)}.\n-     *\n-     * @param bag Current collection of listeners.\n-     * @param index Index of the listener to access.\n-     * @return Listener at the given index or null.\n-     * @see #addListener(Object bag, Object listener)\n-     * @see #removeListener(Object bag, Object listener)\n-     */\n-    public static Object getListener(Object bag, int index)\n-    {\n-        if (index == 0) {\n-            if (bag == null)\n-                return null;\n-            if (!(bag instanceof Object[]))\n-                return bag;\n-            Object[] array = (Object[])bag;\n-            // bag has at least 2 elements if it is array\n-            if (array.length < 2) throw new IllegalArgumentException();\n-            return array[0];\n-        } else if (index == 1) {\n-            if (!(bag instanceof Object[])) {\n-                if (bag == null) throw new IllegalArgumentException();\n-                return null;\n-            }\n-            Object[] array = (Object[])bag;\n-            // the array access will check for index on its own\n-            return array[1];\n-        } else {\n-            // bag has to array\n-            Object[] array = (Object[])bag;\n-            int L = array.length;\n-            if (L < 2) throw new IllegalArgumentException();\n-            if (index == L)\n-                return null;\n-            return array[index];\n-        }\n-    }\n-\n-    static <K, V> V initHash(Hashtable<K, V> h, K key, V initialValue)\n-    {\n-        synchronized (h) {\n-            V current = h.get(key);\n-            if (current == null) {\n-                h.put(key, initialValue);\n-            } else {\n-                initialValue = current;\n-            }\n-        }\n-        return initialValue;\n-    }\n-\n-    private final static class ComplexKey\n-    {\n-        private Object key1;\n-        private Object key2;\n-        private int hash;\n-\n-        ComplexKey(Object key1, Object key2)\n-        {\n-            this.key1 = key1;\n-            this.key2 = key2;\n-        }\n-\n-        @Override public boolean equals(Object anotherObj)\n-        {\n-            if (!(anotherObj instanceof ComplexKey))\n-                return false;\n-            ComplexKey another = (ComplexKey)anotherObj;\n-            return key1.equals(another.key1) && key2.equals(another.key2);\n-        }\n-\n-        @Override public int hashCode()\n-        {\n-            if (hash == 0) {\n-                hash = key1.hashCode() ^ key2.hashCode();\n-            }\n-            return hash;\n-        }\n-    }\n-\n-    public static Object makeHashKeyFromPair(Object key1, Object key2)\n-    {\n-        if (key1 == null) throw new IllegalArgumentException();\n-        if (key2 == null) throw new IllegalArgumentException();\n-        return new ComplexKey(key1, key2);\n-    }\n-\n-    public static String readReader(Reader r)\n-        throws IOException\n-    {\n-        char[] buffer = new char[512];\n-        int cursor = 0;\n-        for (;;) {\n-            int n = r.read(buffer, cursor, buffer.length - cursor);\n-            if (n < 0) { break; }\n-            cursor += n;\n-            if (cursor == buffer.length) {\n-                char[] tmp = new char[buffer.length * 2];\n-                System.arraycopy(buffer, 0, tmp, 0, cursor);\n-                buffer = tmp;\n-            }\n-        }\n-        return new String(buffer, 0, cursor);\n-    }\n-\n-    public static byte[] readStream(InputStream is, int initialBufferCapacity)\n-        throws IOException\n-    {\n-        if (initialBufferCapacity <= 0) {\n-            throw new IllegalArgumentException(\n-                \"Bad initialBufferCapacity: \"+initialBufferCapacity);\n-        }\n-        byte[] buffer = new byte[initialBufferCapacity];\n-        int cursor = 0;\n-        for (;;) {\n-            int n = is.read(buffer, cursor, buffer.length - cursor);\n-            if (n < 0) { break; }\n-            cursor += n;\n-            if (cursor == buffer.length) {\n-                byte[] tmp = new byte[buffer.length * 2];\n-                System.arraycopy(buffer, 0, tmp, 0, cursor);\n-                buffer = tmp;\n-            }\n-        }\n-        if (cursor != buffer.length) {\n-            byte[] tmp = new byte[cursor];\n-            System.arraycopy(buffer, 0, tmp, 0, cursor);\n-            buffer = tmp;\n-        }\n-        return buffer;\n-    }\n-\n-    /**\n      * Throws RuntimeException to indicate failed assertion.\n      * The function never returns and its return type is RuntimeException\n      * only to be able to write <tt>throw Kit.codeBug()</tt> if plain\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n           sb.append(\"<invalid>\");\n         } else {\n           sb.append(first.getString());\n-        }\n-      } else if (this instanceof ScriptOrFnNode) {\n-        ScriptOrFnNode sof = (ScriptOrFnNode) this;\n-        if (this instanceof FunctionNode) {\n-          FunctionNode fn = (FunctionNode) this;\n-          sb.append(' ');\n-          sb.append(fn.getFunctionName());\n-        }\n-        if (printSource) {\n-          sb.append(\" [source name: \");\n-          sb.append(sof.getSourceName());\n-          sb.append(\"] [encoded source length: \");\n-          sb.append(sof.getEncodedSourceEnd() - sof.getEncodedSourceStart());\n-          sb.append(\"] [base line: \");\n-          sb.append(sof.getBaseLineno());\n-          sb.append(\"] [end line: \");\n-          sb.append(sof.getEndLineno());\n-          sb.append(']');\n         }\n       } else if (type == Token.NUMBER) {\n         sb.append(' ');\n             \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n       }\n       return null;\n-  }\n-\n-  /**\n-   * Helper function to ignore differences in Node subclasses that are no longer\n-   * used.\n-   */\n-  @SuppressWarnings(\"rawtypes\")\n-  static private Class getNodeClass(Node n) {\n-    Class c = n.getClass();\n-    if (c == FunctionNode.class || c == ScriptOrFnNode.class) {\n-      return Node.class;\n-    }\n-    return c;\n   }\n \n   /**\n   boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n     if (type != node.getType()\n         || getChildCount() != node.getChildCount()\n-        || getNodeClass(this) != getNodeClass(node)) {\n+        || this.getClass() != node.getClass()) {\n       return false;\n     }\n \n--- a/src/com/google/javascript/rhino/ScriptRuntime.java\n+++ b/src/com/google/javascript/rhino/ScriptRuntime.java\n     }\n \n     /**\n-     * Convert the value to a string.\n-     *\n-     * See ECMA 9.8.\n-     */\n-    public static String toString(Object val) {\n-        for (;;) {\n-            if (val == null) {\n-                return \"null\";\n-            }\n-            if (val instanceof String) {\n-                return (String)val;\n-            }\n-            if (val instanceof Number) {\n-                // XXX should we just teach NativeNumber.stringValue()\n-                // about Numbers?\n-                return numberToString(((Number)val).doubleValue(), 10);\n-            }\n-            return val.toString();\n-        }\n-    }\n-\n-    public static String numberToString(double d, int base) {\n-        if (d != d)\n-            return \"NaN\";\n-        if (d == Double.POSITIVE_INFINITY)\n-            return \"Infinity\";\n-        if (d == Double.NEGATIVE_INFINITY)\n-            return \"-Infinity\";\n-        if (d == 0.0)\n-            return \"0\";\n-\n-        if ((base < 2) || (base > 36)) {\n-            throw Context.reportRuntimeError1(\n-                \"msg.bad.radix\", Integer.toString(base));\n-        }\n-\n-        if (base != 10) {\n-            return DToA.JS_dtobasestr(base, d);\n-        } else {\n-            StringBuffer result = new StringBuffer();\n-            DToA.JS_dtostr(result, DToA.DTOSTR_STANDARD, 0, d);\n-            return result.toString();\n-        }\n-\n-    }\n-\n-    /**\n      * If str is a decimal presentation of Uint32 value, return it as long.\n      * Othewise return -1L;\n      */\n         final String defaultResource\n             = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n \n-        Context cx = Context.getCurrentContext();\n-        Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();\n+        Locale locale = Locale.getDefault();\n \n         // ResourceBundle does cacheing.\n         ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n         return formatter.format(arguments);\n     }\n \n-    public static EcmaError constructError(String error, String message)\n-    {\n-        int[] linep = new int[1];\n-        String filename = Context.getSourcePositionFromStack(linep);\n-        return constructError(error, message, filename, linep[0], null, 0);\n-    }\n-\n-    public static EcmaError constructError(String error,\n-                                           String message,\n-                                           String sourceName,\n-                                           int lineNumber,\n-                                           String lineSource,\n-                                           int columnNumber)\n-    {\n-        return new EcmaError(error, message, sourceName,\n-                             lineNumber, lineSource, columnNumber);\n-    }\n-\n-    public static EcmaError typeError(String message)\n-    {\n-        return constructError(\"TypeError\", message);\n-    }\n-\n-    public static EcmaError typeError0(String messageId)\n-    {\n-        String msg = getMessage0(messageId);\n-        return typeError(msg);\n-    }\n-\n-    public static EcmaError typeError1(String messageId, String arg1)\n-    {\n-        String msg = getMessage1(messageId, arg1);\n-        return typeError(msg);\n-    }\n-\n-    public static EcmaError typeError2(String messageId, String arg1,\n-                                       String arg2)\n-    {\n-        String msg = getMessage2(messageId, arg1, arg2);\n-        return typeError(msg);\n-    }\n-\n-    public static EcmaError typeError3(String messageId, String arg1,\n-                                       String arg2, String arg3)\n-    {\n-        String msg = getMessage3(messageId, arg1, arg2, arg3);\n-        return typeError(msg);\n-    }\n-\n-    public static RuntimeException undefReadError(Object object, Object id)\n-    {\n-        String idStr = (id == null) ? \"null\" : id.toString();\n-        return typeError2(\"msg.undef.prop.read\", toString(object), idStr);\n-    }\n-\n-    public static RuntimeException undefCallError(Object object, Object id)\n-    {\n-        String idStr = (id == null) ? \"null\" : id.toString();\n-        return typeError2(\"msg.undef.method.call\", toString(object), idStr);\n-    }\n-\n-    public static RuntimeException undefWriteError(Object object,\n-                                                   Object id,\n-                                                   Object value)\n-    {\n-        String idStr = (id == null) ? \"null\" : id.toString();\n-        String valueStr = toString(value);\n-        return typeError3(\"msg.undef.prop.write\", toString(object), idStr,\n-                          valueStr);\n-    }\n-\n-    public static RuntimeException notFunctionError(Object value)\n-    {\n-        return notFunctionError(value, value);\n-    }\n-\n-    public static RuntimeException notFunctionError(Object value,\n-                                                    Object messageHelper)\n-    {\n-        // XXX Use value for better error reporting\n-        String msg = (messageHelper == null)\n-                     ? \"null\" : messageHelper.toString();\n-        return typeError2(\"msg.isnt.function\", msg,\n-                value == null ? \"null\" : value.getClass().getName());\n-    }\n-\n-    static int lastIndexResult(Context cx)\n-    {\n-        return cx.scratchIndex;\n-    }\n-\n-    public static void storeUint32Result(Context cx, long value)\n-    {\n-        if ((value >>> 32) != 0)\n-            throw new IllegalArgumentException();\n-        cx.scratchUint32 = value;\n-    }\n-\n-    public static long lastUint32Result(Context cx)\n-    {\n-        long value = cx.scratchUint32;\n-        if ((value >>> 32) != 0)\n-            throw new IllegalStateException();\n-        return value;\n-    }\n-\n-    static String makeUrlForGeneratedScript\n-        (boolean isEval, String masterScriptUrl, int masterScriptLine)\n-    {\n-        if (isEval) {\n-            return masterScriptUrl+'#'+masterScriptLine+\"(eval)\";\n-        } else {\n-            return masterScriptUrl+'#'+masterScriptLine+\"(Function)\";\n-        }\n-    }\n-\n     static boolean isGeneratedScript(String sourceUrl) {\n         // ALERT: this may clash with a valid URL containing (eval) or\n         // (Function)", "timestamp": 1320707841, "metainfo": ""}