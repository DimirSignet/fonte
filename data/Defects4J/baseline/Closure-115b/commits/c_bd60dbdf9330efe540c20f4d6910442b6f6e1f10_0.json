{"sha": "bd60dbdf9330efe540c20f4d6910442b6f6e1f10", "log": "In preparation for resolving class type parameters, use TemplateTypes not Strings as keys in the TemplateTypeMap. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=43074510", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.TemplateType;\n \n import java.util.Iterator;\n import java.util.List;\n   private boolean makesDicts = false;\n   private boolean isInterface = false;\n   private Node parametersNode = null;\n-  private ImmutableList<String> templateTypeNames = ImmutableList.of();\n+  private ImmutableList<TemplateType> templateTypeNames = ImmutableList.of();\n   private ImmutableList<String> classTypeParameterNames = ImmutableList.of();;\n \n   static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning(\n   /**\n    * Infer the template type from the doc info.\n    */\n-  FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) {\n-    if (info != null) {\n-      templateTypeNames = info.getTemplateTypeNames();\n-      typeRegistry.setTemplateTypeNames(templateTypeNames);\n-    }\n+  FunctionTypeBuilder inferTemplateTypeName(\n+      @Nullable JSDocInfo info) {\n+    if (info != null &&  !info.getTemplateTypeNames().isEmpty()) {\n+      ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n+      for (String key : info.getTemplateTypeNames()) {\n+        builder.add(typeRegistry.createTemplateType(key));\n+      }\n+      templateTypeNames = builder.build();\n+    } else {\n+      templateTypeNames = ImmutableList.of();\n+    }\n+    typeRegistry.setTemplateTypeNames(templateTypeNames);\n     return this;\n   }\n \n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeRegistry.OBJECT_ELEMENT_TEMPLATE;\n-import static com.google.javascript.rhino.jstype.JSTypeRegistry.OBJECT_INDEX_TEMPLATE;\n-\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n               JSType iterKeyType = getNativeType(STRING_TYPE);\n               ObjectType objType = getJSType(obj).dereference();\n               JSType objIndexType = objType == null ?\n-                  null : objType.getTemplateTypeMap().getTemplateType(OBJECT_INDEX_TEMPLATE);\n+                  null : objType.getTemplateTypeMap().getTemplateType(\n+                      registry.getObjectIndexKey());\n               if (objIndexType != null && !objIndexType.isUnknownType()) {\n                 JSType narrowedKeyType =\n                     iterKeyType.getGreatestSubtype(objIndexType);\n         // template types amongst their templatized types.\n         TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n         TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (String key : paramTypeMap.getTemplateKeys()) {\n+        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n           maybeResolveTemplatedType(\n               paramTypeMap.getTemplateType(key),\n               argTypeMap.getTemplateType(key),\n     scope = traverseChildren(n, scope);\n     JSType type = getJSType(n.getFirstChild()).restrictByNotNullOrUndefined();\n     TemplateTypeMap typeMap = type.getTemplateTypeMap();\n-    if (typeMap.hasTemplateType(OBJECT_ELEMENT_TEMPLATE)) {\n-      n.setJSType(typeMap.getTemplateType(OBJECT_ELEMENT_TEMPLATE));\n+    if (typeMap.hasTemplateType(registry.getObjectElementKey())) {\n+      n.setJSType(typeMap.getTemplateType(registry.getObjectElementKey()));\n     }\n     return dereferencePointer(n.getFirstChild(), scope);\n   }\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeRegistry.OBJECT_INDEX_TEMPLATE;\n-\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n       ObjectType dereferenced = objType.dereference();\n       if (dereferenced != null && dereferenced\n           .getTemplateTypeMap()\n-          .hasTemplateKey(OBJECT_INDEX_TEMPLATE)) {\n+          .hasTemplateKey(typeRegistry.getObjectIndexKey())) {\n         expectCanAssignTo(t, indexNode, indexType, dereferenced\n-            .getTemplateTypeMap().getTemplateType(OBJECT_INDEX_TEMPLATE),\n+            .getTemplateTypeMap().getTemplateType(typeRegistry.getObjectIndexKey()),\n             \"restricted index type\");\n       } else if (dereferenced != null && dereferenced.isArrayType()) {\n         expectNumber(t, indexNode, indexType, \"array access\");\n--- a/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n   }\n \n   /** Set the template name. */\n-  public FunctionBuilder withTemplateKeys(ImmutableList<String> templateKeys) {\n+  public FunctionBuilder withTemplateKeys(\n+      ImmutableList<TemplateType> templateKeys) {\n     this.templateTypeMap = registry.createTemplateTypeMap(templateKeys, null);\n     return this;\n   }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n       return false;\n     }\n \n-    String templateKey = JSTypeRegistry.OBJECT_ELEMENT_TEMPLATE;\n+    TemplateType templateKey = type1.registry.getObjectElementKey();\n     JSType elemType1 = type1.getTemplateTypeMap().getTemplateType(templateKey);\n     JSType elemType2 = type2.getTemplateTypeMap().getTemplateType(templateKey);\n     return !elemType1.isSubtype(elemType2) && !elemType2.isSubtype(elemType1);\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n   private static final long serialVersionUID = 1L;\n \n   /**\n-   * The template variable corresponding to the property key type of the built-\n-   * in Javascript object.\n+   * The name associated with the template variable corresponding to the\n+   * property key type of the built-in Javascript object.\n    */\n   public static final String OBJECT_INDEX_TEMPLATE = \"Object#Key\";\n \n-  /**\n-   * The template variable corresponding to the property value type for\n-   * Javascript Objects and Arrays.\n+  private TemplateType objectIndexTemplateKey;\n+\n+  /**\n+   * The name associated with the template variable corresponding to the\n+   * property value type for Javascript Objects and Arrays.\n    */\n   public static final String OBJECT_ELEMENT_TEMPLATE = \"Object#Element\";\n+\n+  private TemplateType objectElementTemplateKey;\n \n   /**\n    * The UnionTypeBuilder caps the maximum number of alternate types it\n       ErrorReporter reporter, boolean tolerateUndefinedValues) {\n     this.reporter = reporter;\n     this.emptyTemplateTypeMap = new TemplateTypeMap(\n-        this, ImmutableList.<String>of(), ImmutableList.<JSType>of());\n+        this, ImmutableList.<TemplateType>of(), ImmutableList.<JSType>of());\n     nativeTypes = new JSType[JSTypeNative.values().length];\n     namesToTypes = new HashMap<String, JSType>();\n     resetForTypeCheck();\n     this.tolerateUndefinedValues = tolerateUndefinedValues;\n+  }\n+\n+  /**\n+   * @return The template variable corresponding to the property value type for\n+   * Javascript Objects and Arrays.\n+   */\n+  public TemplateType getObjectElementKey() {\n+    return this.objectElementTemplateKey;\n+  }\n+\n+  /**\n+   * @return The template variable corresponding to the\n+   * property key type of the built-in Javascript object.\n+   */\n+  public TemplateType getObjectIndexKey() {\n+    Preconditions.checkNotNull(objectIndexTemplateKey);\n+    return objectIndexTemplateKey;\n   }\n \n   /**\n   }\n \n   private void initializeBuiltInTypes() {\n+    objectIndexTemplateKey = new TemplateType(this, OBJECT_INDEX_TEMPLATE);\n+    objectElementTemplateKey = new TemplateType(this, OBJECT_ELEMENT_TEMPLATE);\n+\n     // These locals shouldn't be all caps.\n     BooleanType BOOLEAN_TYPE = new BooleanType(this);\n     registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n             createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n             null,\n             createTemplateTypeMap(ImmutableList.of(\n-                OBJECT_INDEX_TEMPLATE, OBJECT_ELEMENT_TEMPLATE), null),\n+                objectIndexTemplateKey, objectElementTemplateKey), null),\n             true, true);\n \n     OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE, null);\n           createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n           null,\n           createTemplateTypeMap(ImmutableList.of(\n-              OBJECT_ELEMENT_TEMPLATE), null),\n+              objectElementTemplateKey), null),\n           true, true);\n     ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n         ARRAY_FUNCTION_TYPE.getInstanceType();\n    *     to indicate that the parameter types are unknown.\n    * @param returnType the function's return type or {@code null} to indicate\n    *     that the return type is unknown.\n-   * @param templateKeys the templatized type keys for the class.\n+   * @param templateKeyNames the templatized type keys for the class.\n    */\n   public FunctionType createConstructorType(String name, Node source,\n-      Node parameters, JSType returnType, ImmutableList<String> templateKeys) {\n+      Node parameters, JSType returnType, ImmutableList<String> templateKeyNames) {\n+    return createConstructorTypeInternal(name, source, parameters, returnType,\n+        createTemplateMapKeys(templateKeyNames));\n+  }\n+\n+  private FunctionType createConstructorTypeInternal(String name, Node source,\n+      Node parameters, JSType returnType, ImmutableList<TemplateType> templateKeys) {\n     return new FunctionType(this, name, source,\n         createArrowType(parameters, returnType), null,\n         createTemplateTypeMap(templateKeys, null), true, false);\n+  }\n+\n+  ImmutableList<TemplateType> createTemplateMapKeys(ImmutableList<String> keys) {\n+    ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n+    if (keys != null) {\n+      for (String key : keys) {\n+        builder.add(new TemplateType(this, key));\n+      }\n+    }\n+    return builder.build();\n   }\n \n   /**\n     return FunctionType.forInterface(this, name, source);\n   }\n \n+  public TemplateType createTemplateType(String name) {\n+    return new TemplateType(this, name);\n+  }\n+\n   /**\n    * Creates a template type map from the specified list of template keys and\n    * template value types.\n    */\n   public TemplateTypeMap createTemplateTypeMap(\n-      ImmutableList<String> templateKeys,\n+      ImmutableList<TemplateType> templateKeys,\n       ImmutableList<JSType> templateValues) {\n     templateKeys = templateKeys == null ?\n-        ImmutableList.<String>of() : templateKeys;\n+        ImmutableList.<TemplateType>of() : templateKeys;\n     templateValues = templateValues == null ?\n         ImmutableList.<JSType>of() : templateValues;\n \n   /**\n    * Sets the template type name.\n    */\n-  public void setTemplateTypeNames(List<String> names) {\n-    Preconditions.checkNotNull(names);\n-    for (String name : names) {\n-      templateTypes.put(name, new TemplateType(this, name));\n+  public void setTemplateTypeNames(List<TemplateType> keys) {\n+    Preconditions.checkNotNull(keys);\n+    for (TemplateType key : keys) {\n+      templateTypes.put(key.getReferenceName(), key);\n     }\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\n+++ b/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\n  * @author izaakr@google.com (Izaak Rubin)\n  */\n public class TemplateTypeMap implements Serializable {\n-  private final ImmutableList<String> templateKeys;\n+  private final ImmutableList<TemplateType> templateKeys;\n   private final ImmutableList<JSType> templateValues;\n   final JSTypeRegistry registry;\n \n   TemplateTypeMap(JSTypeRegistry registry,\n-                  ImmutableList<String> templateKeys,\n+                  ImmutableList<TemplateType> templateKeys,\n                   ImmutableList<JSType> templateValues) {\n     Preconditions.checkNotNull(templateKeys);\n     Preconditions.checkNotNull(templateValues);\n   /**\n    * Returns a list of all template keys.\n    */\n-  public ImmutableList<String> getTemplateKeys() {\n+  public ImmutableList<TemplateType> getTemplateKeys() {\n     return templateKeys;\n   }\n \n    * Returns true if this map contains the specified template key, false\n    * otherwise.\n    */\n-  public boolean hasTemplateKey(String templateKey) {\n-    return templateKeys.contains(templateKey);\n+  public boolean hasTemplateKey(TemplateType templateKey) {\n+    // Note: match by identity, not equality\n+    for (TemplateType entry : templateKeys) {\n+      if (entry == templateKey) {\n+        return true;\n+      }\n+    }\n+    return false;\n   }\n \n   /**\n    * Returns a list of template keys in this map that do not have corresponding\n    * JSType values.\n    */\n-  ImmutableList<String> getUnfilledTemplateKeys() {\n+  ImmutableList<TemplateType> getUnfilledTemplateKeys() {\n     return templateKeys.subList(templateValues.size(), templateKeys.size());\n   }\n \n    * Returns true if there is a JSType value associated with the specified\n    * template key; false otherwise.\n    */\n-  public boolean hasTemplateType(String key) {\n+  public boolean hasTemplateType(TemplateType key) {\n     return getTemplateTypeInternal(key) != null;\n   }\n \n    * Returns the JSType value associated with the specified template key. If no\n    * JSType value is associated, returns UNKNOWN_TYPE.\n    */\n-  public JSType getTemplateType(String key) {\n+  public JSType getTemplateType(TemplateType key) {\n     JSType templateType = getTemplateTypeInternal(key);\n     return (templateType == null) ?\n         registry.getNativeType(JSTypeNative.UNKNOWN_TYPE) : templateType;\n   }\n \n+  public TemplateType getTemplateTypeKeyByName(String keyName) {\n+    for (TemplateType key : templateKeys) {\n+      if (key.getReferenceName().equals(keyName)) {\n+        return key;\n+      }\n+    }\n+    return null;\n+  }\n+\n   /**\n    * Returns the JSType value associated with the specified template key. If no\n    * JSType value is associated, returns null.\n    */\n-  private JSType getTemplateTypeInternal(String key) {\n-    int index = templateKeys.indexOf(key);\n+  private JSType getTemplateTypeInternal(TemplateType key) {\n+    int index = 0;\n+    for (TemplateType item : templateKeys) {\n+      // Note: match by identity.\n+      if (item == key) {\n+        break;\n+      }\n+      index++;\n+    }\n     if (index < 0 || index >= templateValues.size()) {\n       return null;\n     }\n    * Returns a new TemplateTypeMap whose keys have been extended with the\n    * specified list.\n    */\n-  TemplateTypeMap extendKeys(ImmutableList<String> newKeys) {\n+  TemplateTypeMap extendKeys(ImmutableList<TemplateType> newKeys) {\n     return registry.createTemplateTypeMap(\n         concatImmutableLists(templateKeys, newKeys), templateValues);\n   }\n--- a/src/com/google/javascript/rhino/jstype/TemplatizedType.java\n+++ b/src/com/google/javascript/rhino/jstype/TemplatizedType.java\n \n     // Cache which template keys were filled, and what JSTypes they were filled\n     // with.\n-    ImmutableList<String> filledTemplateKeys =\n+    ImmutableList<TemplateType> filledTemplateKeys =\n         objectType.getTemplateTypeMap().getUnfilledTemplateKeys();\n     ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n-    for (String filledTemplateKey : filledTemplateKeys) {\n+    for (TemplateType filledTemplateKey : filledTemplateKeys) {\n       builder.add(getTemplateTypeMap().getTemplateType(filledTemplateKey));\n     }\n     this.templateTypes = builder.build();\n     return templateTypes;\n   }\n \n-  //@Override\n+  @Override\n   public boolean isSubtype(JSType that) {\n     return isSubtypeHelper(this, that);\n   }\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n         findNameType(\"g\", lastLocalScope).toString());\n   }\n \n+  public void disable_testTemplateType13() {\n+    // TODO(johnlenz): allow template types in @type function expressions\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @type {function(T):T}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"var f;\" +\n+        \"/** @type {string} */\\n\" +\n+        \"var val = 'hi';\\n\" +\n+        \"var result = f(val);\");\n+    assertEquals(\"(string|undefined)\",\n+        findNameType(\"result\", globalScope).toString());\n+  }\n+\n   public void testClosureParameterTypesWithoutJSDoc() {\n     testSame(\n         \"/**\\n\" +\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n import com.google.javascript.rhino.head.ast.AstRoot;\n import com.google.javascript.rhino.head.ast.Comment;\n import com.google.javascript.rhino.jstype.JSType;\n-import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.SimpleSourceFile;\n import com.google.javascript.rhino.jstype.StaticSourceFile;\n+import com.google.javascript.rhino.jstype.TemplateType;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n import java.util.Collection;\n             OBJECT_TYPE, ImmutableList.of(UNKNOWN_TYPE, NUMBER_TYPE)),\n         info.getType());\n     assertTemplatizedTypeEquals(\n-        JSTypeRegistry.OBJECT_ELEMENT_TEMPLATE, NUMBER_TYPE, info.getType());\n+        registry.getObjectElementKey(), NUMBER_TYPE, info.getType());\n   }\n \n   public void testParseTemplatizedType12() throws Exception {\n             OBJECT_TYPE, ImmutableList.of(STRING_TYPE, NUMBER_TYPE)),\n         info.getType());\n     assertTemplatizedTypeEquals(\n-        JSTypeRegistry.OBJECT_ELEMENT_TEMPLATE, NUMBER_TYPE, info.getType());\n+        registry.getObjectElementKey(), NUMBER_TYPE, info.getType());\n     assertTemplatizedTypeEquals(\n-        JSTypeRegistry.OBJECT_INDEX_TEMPLATE, STRING_TYPE, info.getType());\n+        registry.getObjectIndexKey(), STRING_TYPE, info.getType());\n   }\n \n   public void testParseTemplatizedType13() throws Exception {\n     return new JsDocTokenStream(source, 0);\n   }\n \n-  private void assertTemplatizedTypeEquals(String key, JSType expected,\n+  private void assertTemplatizedTypeEquals(TemplateType key, JSType expected,\n                                            JSTypeExpression te) {\n     assertEquals(\n         expected, resolve(te).getTemplateTypeMap().getTemplateType(key));\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n   }\n \n   public void testTemplatedFunctionDerivedFunctions() {\n-    FunctionType fn = new FunctionBuilder(registry)\n-      .withTypeOfThis(new TemplateType(registry, \"T\"))\n-      .withTemplateKeys(ImmutableList.of(\"T\"))\n+    TemplateType template = registry.createTemplateType(\"T\");\n+    FunctionType fn = new FunctionBuilder(registry)\n+      .withTypeOfThis(template)\n+      .withTemplateKeys(ImmutableList.of(template))\n       .withReturnType(BOOLEAN_TYPE).build();\n \n     assertEquals(\"[T]\", fn.getPropertyType(\"call\").getTemplateTypeMap()\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n         templatizedCtor.getInstanceType(),\n         ImmutableList.of(NUMBER_TYPE, STRING_TYPE));\n \n+    TemplateTypeMap ctrTypeMap = templatizedCtor.getTemplateTypeMap();\n+    TemplateType keyA = ctrTypeMap.getTemplateTypeKeyByName(\"A\");\n+    assertNotNull(keyA);\n+    TemplateType keyB = ctrTypeMap.getTemplateTypeKeyByName(\"B\");\n+    assertNotNull(keyB);\n+    TemplateType keyC = ctrTypeMap.getTemplateTypeKeyByName(\"C\");\n+    assertNull(keyC);\n+    TemplateType unknownKey = registry.createTemplateType(\"C\");\n+\n     TemplateTypeMap templateTypeMap = templatizedInstance.getTemplateTypeMap();\n-    assertTrue(templateTypeMap.hasTemplateKey(\"A\"));\n-    assertTrue(templateTypeMap.hasTemplateKey(\"B\"));\n-    assertFalse(templateTypeMap.hasTemplateKey(\"C\"));\n-\n-    assertEquals(NUMBER_TYPE, templateTypeMap.getTemplateType(\"A\"));\n-    assertEquals(STRING_TYPE, templateTypeMap.getTemplateType(\"B\"));\n-    assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(\"C\"));\n+    assertTrue(templateTypeMap.hasTemplateKey(keyA));\n+    assertTrue(templateTypeMap.hasTemplateKey(keyB));\n+    assertFalse(templateTypeMap.hasTemplateKey(unknownKey));\n+\n+    assertEquals(NUMBER_TYPE, templateTypeMap.getTemplateType(keyA));\n+    assertEquals(STRING_TYPE, templateTypeMap.getTemplateType(keyB));\n+    assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(unknownKey));\n \n     assertEquals(\"TestingType.<number,string>\", templatizedInstance.toString());\n   }\n         templatizedCtor.getInstanceType(),\n         ImmutableList.of(NUMBER_TYPE));\n \n+    TemplateTypeMap ctrTypeMap = templatizedCtor.getTemplateTypeMap();\n+    TemplateType keyA = ctrTypeMap.getTemplateTypeKeyByName(\"A\");\n+    assertNotNull(keyA);\n+    TemplateType keyB = ctrTypeMap.getTemplateTypeKeyByName(\"B\");\n+    assertNotNull(keyB);\n+    TemplateType keyC = ctrTypeMap.getTemplateTypeKeyByName(\"C\");\n+    assertNull(keyC);\n+    TemplateType unknownKey = registry.createTemplateType(\"C\");\n+\n     TemplateTypeMap templateTypeMap = templatizedInstance.getTemplateTypeMap();\n-    assertTrue(templateTypeMap.hasTemplateKey(\"A\"));\n-    assertTrue(templateTypeMap.hasTemplateKey(\"B\"));\n-    assertFalse(templateTypeMap.hasTemplateKey(\"C\"));\n-\n-    assertEquals(NUMBER_TYPE, templateTypeMap.getTemplateType(\"A\"));\n-    assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(\"B\"));\n-    assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(\"C\"));\n+    assertTrue(templateTypeMap.hasTemplateKey(keyA));\n+    assertTrue(templateTypeMap.hasTemplateKey(keyB));\n+    assertFalse(templateTypeMap.hasTemplateKey(unknownKey));\n+\n+    assertEquals(NUMBER_TYPE, templateTypeMap.getTemplateType(keyA));\n+    assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(keyB));\n+    assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(unknownKey));\n \n     assertEquals(\"TestingType.<number,?>\", templatizedInstance.toString());\n   }", "timestamp": 1361926795, "metainfo": ""}