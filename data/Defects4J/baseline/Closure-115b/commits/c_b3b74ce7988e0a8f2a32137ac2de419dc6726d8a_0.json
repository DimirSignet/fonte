{"sha": "b3b74ce7988e0a8f2a32137ac2de419dc6726d8a", "log": "Better indexing for incomplete information  R=acleung DELTA=79  (67 added, 2 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3651   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n       SymbolScope myScope = createScopeFrom(\n           otherSymbolTable.getScope(otherSymbol));\n \n-      StaticReference<JSType> decl = otherSymbol.getDeclaration();\n-      Node declNode = decl == null ? null : decl.getNode();\n+      StaticReference<JSType> decl =\n+          findBestDeclToAdd(otherSymbolTable, otherSymbol);\n       Symbol mySymbol = null;\n-      if (declNode != null && declNode.getStaticSourceFile() != null) {\n+      if (decl != null) {\n+        Node declNode = decl.getNode();\n+\n         // If we have a declaration node, we can ensure the symbol is declared.\n         mySymbol = symbols.get(declNode, name);\n         if (mySymbol == null) {\n           // See SymbolTableTest#testDeclarationDisagreement.\n           mySymbol = myScope.ownSymbols.get(otherSymbol.getName());\n           if (mySymbol == null) {\n-            mySymbol = copySymbolTo(otherSymbol, myScope);\n+            mySymbol = copySymbolTo(otherSymbol, declNode, myScope);\n           }\n         }\n       } else {\n \n       if (mySymbol != null) {\n         for (R otherRef : otherSymbolTable.getReferences(otherSymbol)) {\n-          mySymbol.defineReferenceAt(otherRef.getNode());\n-        }\n-      }\n-    }\n+          if (isGoodRefToAdd(otherRef)) {\n+            mySymbol.defineReferenceAt(otherRef.getNode());\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  /** Helper for addSymbolsFrom, to determine the best declaration spot. */\n+  private <S extends StaticSlot<JSType>, R extends StaticReference<JSType>>\n+  StaticReference<JSType> findBestDeclToAdd(\n+      StaticSymbolTable<S, R> otherSymbolTable, S slot) {\n+    StaticReference<JSType> decl = slot.getDeclaration();\n+    if (isGoodRefToAdd(decl)) {\n+      return decl;\n+    }\n+\n+    for (R ref : otherSymbolTable.getReferences(slot)) {\n+      if (isGoodRefToAdd(ref)) {\n+        return ref;\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  /**\n+   * Helper for addSymbolsFrom, to determine whether a reference is\n+   * acceptable. A reference must be in the normal source tree.\n+   */\n+  private boolean isGoodRefToAdd(@Nullable StaticReference<JSType> ref) {\n+    return ref != null && ref.getNode() != null\n+        && ref.getNode().getStaticSourceFile() != null\n+        && !VarCheck.SYNTHETIC_VARS_DECLAR.equals(\n+            ref.getNode().getStaticSourceFile().getName());\n   }\n \n   private Symbol copySymbolTo(StaticSlot<JSType> sym, SymbolScope scope) {\n+    return copySymbolTo(sym, sym.getDeclaration().getNode(), scope);\n+  }\n+\n+  private Symbol copySymbolTo(\n+      StaticSlot<JSType> sym, Node declNode, SymbolScope scope) {\n+    // All symbols must have declaration nodes.\n+    Preconditions.checkNotNull(declNode);\n     return declareSymbol(\n-        sym.getName(), sym.getType(), sym.isTypeInferred(), scope,\n-        // All symbols must have declaration nodes.\n-        Preconditions.checkNotNull(sym.getDeclaration().getNode()),\n+        sym.getName(), sym.getType(), sym.isTypeInferred(), scope, declNode,\n         sym.getJSDocInfo());\n   }\n \n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.GETPROP) {\n         JSType owner = n.getFirstChild().getJSType();\n-        if (owner == null) {\n+        if (owner == null || owner.isUnknownType()) {\n+          // Try to find the symbol by its fully qualified name.\n+          String name = n.getQualifiedName();\n+          if (name != null) {\n+            Symbol lexicalSym = getEnclosingScope(n).getSlot(name);\n+            if (lexicalSym != null) {\n+              lexicalSym.defineReferenceAt(n);\n+            }\n+          }\n           return;\n         }\n \n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     Symbol googDomHelper = getGlobalVar(table, \"goog.dom.DomHelper\");\n     assertNotNull(googDomHelper);\n     assertEquals(1, Iterables.size(table.getReferences(googDomHelper)));\n+  }\n+\n+  public void testIncompleteNamespacedReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */\\n\" +\n+        \"goog.dom.DomHelper = function(){};\\n\" +\n+        \"var y = goog.dom.DomHelper;\\n\");\n+    Symbol goog = getGlobalVar(table, \"goog\");\n+    assertNotNull(goog);\n+    assertEquals(2, table.getReferenceList(goog).size());\n+\n+    // TODO(nicksantos): We should try to create a symbol for goog.dom,\n+    // even though we can't find a declaration for it.\n+    Symbol googDom = getGlobalVar(table, \"goog.dom\");\n+    assertNull(googDom);\n+\n+    Symbol googDomHelper = getGlobalVar(table, \"goog.dom.DomHelper\");\n+    assertNotNull(googDomHelper);\n+    assertEquals(2, Iterables.size(table.getReferences(googDomHelper)));\n   }\n \n   public void testRemovalOfNamespacedReferencesOfProperties()", "timestamp": 1320769909, "metainfo": ""}