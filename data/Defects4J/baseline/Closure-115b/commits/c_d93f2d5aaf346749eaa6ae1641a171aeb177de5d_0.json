{"sha": "d93f2d5aaf346749eaa6ae1641a171aeb177de5d", "log": "Seal struct instances.  R=nicksantos DELTA=189  (157 added, 15 deleted, 17 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5655   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n   static final DiagnosticType IN_USED_WITH_STRUCT =\n       DiagnosticType.warning(\"JSC_IN_USED_WITH_STRUCT\",\n                              \"Cannot use the IN operator with structs\");\n+\n+  static final DiagnosticType ILLEGAL_PROPERTY_CREATION =\n+      DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_CREATION\",\n+                             \"Cannot add a property to a struct instance \" +\n+                             \"after it is constructed.\");\n \n   static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup(\n       DETERMINISTIC_TEST,\n       INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n       EXPECTED_THIS_TYPE,\n       IN_USED_WITH_STRUCT,\n+      ILLEGAL_PROPERTY_CREATION,\n       RhinoErrorReporter.TYPE_PARSE_ERROR,\n       TypedScopeCreator.UNKNOWN_LENDS,\n       TypedScopeCreator.LENDS_ON_NON_OBJECT,\n       case Token.DEC:\n       case Token.INC:\n         left = n.getFirstChild();\n-        validator.expectNumber(\n-            t, left, getJSType(left), \"increment/decrement\");\n+        checkPropCreation(t, left);\n+        validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n         ensureTyped(t, n, NUMBER_TYPE);\n         break;\n \n       case Token.ASSIGN_SUB:\n       case Token.ASSIGN_ADD:\n       case Token.ASSIGN_MUL:\n+        checkPropCreation(t, n.getFirstChild());\n+        // fall through\n+\n       case Token.LSH:\n       case Token.RSH:\n       case Token.URSH:\n     if (lvalue.isGetProp()) {\n       Node object = lvalue.getFirstChild();\n       JSType objectJsType = getJSType(object);\n-      String property = lvalue.getLastChild().getString();\n+      Node property = lvalue.getLastChild();\n+      String pname = property.getString();\n \n       // the first name in this getprop refers to an interface\n       // we perform checks in addition to the ones below\n         JSType jsType = getJSType(object.getFirstChild());\n         if (jsType.isInterface() &&\n             object.getLastChild().getString().equals(\"prototype\")) {\n-          visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n+          visitInterfaceGetprop(t, assign, object, pname, lvalue, rvalue);\n         }\n       }\n \n       checkEnumAlias(t, info, rvalue);\n+      checkPropCreation(t, lvalue);\n \n       // Prototype assignments are special, because they actually affect\n       // the definition of a class. These are mostly validated\n       // during TypedScopeCreator, and we only look for the \"dumb\" cases here.\n       // object.prototype = ...;\n-      if (property.equals(\"prototype\")) {\n+      if (pname.equals(\"prototype\")) {\n         if (objectJsType != null && objectJsType.isFunctionType()) {\n           FunctionType functionType = objectJsType.toMaybeFunctionType();\n           if (functionType.isConstructor()) {\n       ObjectType type = ObjectType.cast(\n           objectJsType.restrictByNotNullOrUndefined());\n       if (type != null) {\n-        if (type.hasProperty(property) &&\n-            !type.isPropertyTypeInferred(property) &&\n-            !propertyIsImplicitCast(type, property)) {\n-          JSType expectedType = type.getPropertyType(property);\n+        if (type.hasProperty(pname) &&\n+            !type.isPropertyTypeInferred(pname) &&\n+            !propertyIsImplicitCast(type, pname)) {\n+          JSType expectedType = type.getPropertyType(pname);\n           if (!expectedType.isUnknownType()) {\n             validator.expectCanAssignToPropertyOf(\n                 t, assign, getJSType(rvalue),\n-                expectedType, object, property);\n+                expectedType, object, pname);\n             checkPropertyInheritanceOnGetpropAssign(\n-                t, assign, object, property, info, expectedType);\n+                t, assign, object, pname, info, expectedType);\n             return;\n           }\n         }\n       // If we couldn't get the property type with normal object property\n       // lookups, then check inheritance anyway with the unknown type.\n       checkPropertyInheritanceOnGetpropAssign(\n-          t, assign, object, property, info, getNativeType(UNKNOWN_TYPE));\n+          t, assign, object, pname, info, getNativeType(UNKNOWN_TYPE));\n     }\n \n     // Check qualified name sets to 'object' and 'object.property'.\n       ensureTyped(t, assign, rightType);\n     } else {\n       ensureTyped(t, assign);\n+    }\n+  }\n+\n+  /** Check that we don't create new properties on structs. */\n+  private void checkPropCreation(NodeTraversal t, Node lvalue) {\n+    if (lvalue.isGetProp()) {\n+      Node obj = lvalue.getFirstChild();\n+      Node prop = lvalue.getLastChild();\n+      JSType objType = getJSType(obj);\n+      String pname = prop.getString();\n+      if (objType.isStruct() && !objType.hasProperty(pname)) {\n+        if (!(obj.isThis() &&\n+              getJSType(t.getScope().getRootNode()).isConstructor())) {\n+          report(t, prop, ILLEGAL_PROPERTY_CREATION);\n+        }\n+      }\n     }\n   }\n \n       FunctionType baseConstructor = functionType.getSuperClassConstructor();\n       if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n           baseConstructor != null &&\n-          baseConstructor.isInterface() && functionType.isConstructor()) {\n+          baseConstructor.isInterface()) {\n         compiler.report(\n             t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                         \"constructor\", functionPrivateName));\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n         // 4) If this is a stub, define it.\n         // 5) Otherwise, do not define the type, but declare it in the registry\n         //    so that we can use it for missing property checks.\n-        if (objectType.hasProperty(propName) ||\n-            !objectType.isInstanceType()) {\n+        if (objectType.hasProperty(propName) || !objectType.isInstanceType()) {\n           if (\"prototype\".equals(propName)) {\n-            objectType.defineDeclaredProperty(\n-                propName, rightType, getprop);\n+            objectType.defineDeclaredProperty(propName, rightType, getprop);\n           } else {\n-            objectType.defineInferredProperty(\n-                propName, rightType, getprop);\n+            objectType.defineInferredProperty(propName, rightType, getprop);\n           }\n+        } else if (getprop.getFirstChild().isThis() &&\n+                   getJSType(syntacticScope.getRootNode()).isConstructor()) {\n+          objectType.defineInferredProperty(propName, rightType, getprop);\n         } else {\n-          if (getprop.getFirstChild().isThis() &&\n-              getJSType(syntacticScope.getRootNode()).isConstructor()) {\n-            objectType.defineInferredProperty(\n-                propName, rightType, getprop);\n-          } else {\n-            registry.registerPropertyOnType(propName, objectType);\n-          }\n+          registry.registerPropertyOnType(propName, objectType);\n         }\n       }\n     }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n     return displayName != null && !displayName.isEmpty();\n   }\n \n+  /** Checks whether the property pname is present on the object. */\n+  public boolean hasProperty(String pname) {\n+    return false;\n+  }\n+\n   public boolean isNoType() {\n     return false;\n   }\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n    *         returns {@code null}.\n    */\n   public abstract JSType getPropertyType(String propertyName);\n-\n-  /**\n-   * Checks whether the property whose name is given is present on the\n-   * object.\n-   */\n-  public abstract boolean hasProperty(String propertyName);\n \n   /**\n    * Checks whether the property whose name is given is present directly on\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n   private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n     for (JSType alternate : alternates) {\n       if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean hasProperty(String pname) {\n+    for (JSType alternate : alternates) {\n+      if (alternate.hasProperty(pname)) {\n         return true;\n       }\n     }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"No properties on this expression\\n\" +\n         \"found   : null\\n\" +\n         \"required: Object\");\n+  }\n+\n+  public void testSetprop1() throws Exception {\n+    // Create property on struct in the constructor\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() { this.x = 123; }\");\n+  }\n+\n+  public void testSetprop2() throws Exception {\n+    // Create property on struct outside the constructor\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() {}\\n\" +\n+              \"(new Foo()).x = 123;\",\n+              \"Cannot add a property to a struct instance \" +\n+              \"after it is constructed.\");\n+  }\n+\n+  public void testSetprop3() throws Exception {\n+    // Create property on struct outside the constructor\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() {}\\n\" +\n+              \"(function() { (new Foo()).x = 123; })();\",\n+              \"Cannot add a property to a struct instance \" +\n+              \"after it is constructed.\");\n+  }\n+\n+  public void testSetprop4() throws Exception {\n+    // Assign to existing property of struct outside the constructor\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() { this.x = 123; }\\n\" +\n+              \"(new Foo()).x = \\\"asdf\\\";\");\n+  }\n+\n+  public void testSetprop5() throws Exception {\n+    // Create a property on union that includes a struct\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() {}\\n\" +\n+              \"(true ? new Foo() : {}).x = 123;\",\n+              \"Cannot add a property to a struct instance \" +\n+              \"after it is constructed.\");\n+  }\n+\n+  public void testSetprop6() throws Exception {\n+    // Create property on struct in another constructor\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() {}\\n\" +\n+              \"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @param{Foo} f\\n\" +\n+              \" */\\n\" +\n+              \"function Bar(f) { f.x = 123; }\",\n+              \"Cannot add a property to a struct instance \" +\n+              \"after it is constructed.\");\n+  }\n+\n+  public void testSetprop7() throws Exception {\n+    //Bug b/c we require THIS when creating properties on structs for simplicity\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() {\\n\" +\n+              \"  var t = this;\\n\" +\n+              \"  t.x = 123;\\n\" +\n+              \"}\",\n+              \"Cannot add a property to a struct instance \" +\n+              \"after it is constructed.\");\n+  }\n+\n+  public void testSetprop8() throws Exception {\n+    // Create property on struct using DEC\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() {}\\n\" +\n+              \"(new Foo()).x--;\",\n+              new String[] {\n+                \"Property x never defined on Foo\",\n+                \"Cannot add a property to a struct instance \" +\n+                \"after it is constructed.\"\n+              });\n+  }\n+\n+  public void testSetprop9() throws Exception {\n+    // Create property on struct using ASSIGN_ADD\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() {}\\n\" +\n+              \"(new Foo()).x += 123;\",\n+              \"Cannot add a property to a struct instance \" +\n+              \"after it is constructed.\");\n   }\n \n   public void testGetpropDict1() throws Exception {", "timestamp": 1350425842, "metainfo": ""}