{"sha": "73e29a45d42249f9e30a0699bba8411ab14be6df", "log": "Fix a bug in ScopedAliases.", "commit": "\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n  *\n  * goog.dom.createElement(goog.dom.TagName.DIV);\n  *\n+ * The advantage of using goog.scope is that the compiler will *guarantee*\n+ * the anonymous function will be inlined, even if it can't prove\n+ * that it's semantically correct to do so. For example, consider this case:\n+ *\n+ * goog.scope(function() {\n+ *   goog.getBar = function () { return alias; };\n+ *   ...\n+ *   var alias = foo.bar;\n+ * })\n+ *\n+ * In theory, the compiler can't inline 'alias' unless it can prove that\n+ * goog.getBar is called only after 'alias' is defined.\n+ *\n+ * In practice, the compiler will inline 'alias' anyway, at the risk of\n+ * 'fixing' bad code.\n+ *\n  * @author robbyw@google.com (Robby Walker)\n  */\n class ScopedAliases implements HotSwapCompilerPass {\n   static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error(\n       \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\",\n       \"The alias {0} is assigned a value more than once.\");\n+\n+  static final DiagnosticType GOOG_SCOPE_ALIAS_CYCLE = DiagnosticType.error(\n+      \"JSC_GOOG_SCOPE_ALIAS_CYCLE\",\n+      \"The aliases {0} has a cycle.\");\n \n   static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error(\n       \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\",\n     if (!traversal.hasErrors()) {\n \n       // Apply the aliases.\n-      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n-        aliasUsage.applyAlias();\n+      List<AliasUsage> aliasWorkQueue =\n+          Lists.newArrayList(traversal.getAliasUsages());\n+      while (!aliasWorkQueue.isEmpty()) {\n+        List<AliasUsage> newQueue = Lists.newArrayList();\n+        for (AliasUsage aliasUsage : aliasWorkQueue) {\n+          if (aliasUsage.referencesOtherAlias()) {\n+            newQueue.add(aliasUsage);\n+          } else {\n+            aliasUsage.applyAlias();\n+          }\n+        }\n+\n+        // Prevent an infinite loop.\n+        if (newQueue.size() == aliasWorkQueue.size()) {\n+          Var cycleVar = newQueue.get(0).aliasVar;\n+          compiler.report(JSError.make(\n+              cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName()));\n+          break;\n+        } else {\n+          aliasWorkQueue = newQueue;\n+        }\n       }\n \n       // Remove the alias definitions.\n     }\n   }\n \n-  private interface AliasUsage {\n-    public void applyAlias();\n-  }\n-\n-  private class AliasedNode implements AliasUsage {\n-    private final Node aliasReference;\n-\n-    private final Node aliasDefinition;\n-\n-    AliasedNode(Node aliasReference, Node aliasDefinition) {\n+  private abstract class AliasUsage {\n+    final Var aliasVar;\n+    final Node aliasReference;\n+\n+    AliasUsage(Var aliasVar, Node aliasReference) {\n+      this.aliasVar = aliasVar;\n       this.aliasReference = aliasReference;\n-      this.aliasDefinition = aliasDefinition;\n+    }\n+\n+    /** Checks to see if this references another alias. */\n+    public boolean referencesOtherAlias() {\n+      Node aliasDefinition = aliasVar.getInitialValue();\n+      Node root = NodeUtil.getRootOfQualifiedName(aliasDefinition);\n+      Var otherAliasVar = aliasVar.getScope().getOwnSlot(root.getString());\n+      return otherAliasVar != null;\n+    }\n+\n+    public abstract void applyAlias();\n+  }\n+\n+  private class AliasedNode extends AliasUsage {\n+    AliasedNode(Var aliasVar, Node aliasReference) {\n+      super(aliasVar, aliasReference);\n     }\n \n     @Override\n     public void applyAlias() {\n+      Node aliasDefinition = aliasVar.getInitialValue();\n       aliasReference.getParent().replaceChild(\n           aliasReference, aliasDefinition.cloneTree());\n     }\n   }\n \n-  private class AliasedTypeNode implements AliasUsage {\n-    private final Node typeReference;\n-    private final Node aliasDefinition;\n-    private final String aliasName;\n-\n-    AliasedTypeNode(Node typeReference, Node aliasDefinition,\n-        String aliasName) {\n-      this.typeReference = typeReference;\n-      this.aliasDefinition = aliasDefinition;\n-      this.aliasName = aliasName;\n+  private class AliasedTypeNode extends AliasUsage {\n+    AliasedTypeNode(Var aliasVar, Node aliasReference) {\n+      super(aliasVar, aliasReference);\n     }\n \n     @Override\n     public void applyAlias() {\n-      String typeName = typeReference.getString();\n+      Node aliasDefinition = aliasVar.getInitialValue();\n+      String aliasName = aliasVar.getName();\n+      String typeName = aliasReference.getString();\n       String aliasExpanded =\n           Preconditions.checkNotNull(aliasDefinition.getQualifiedName());\n       Preconditions.checkState(typeName.startsWith(aliasName));\n-      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));\n+      aliasReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));\n     }\n   }\n \n           // The node in aliasedNode (which is \"g\") will be replaced in the\n           // changes pass above with \"goog\".  If we cloned here, we'd end up\n           // with <code>g.dom.createElement('DIV')</code>.\n-          Node aliasedNode = aliasVar.getInitialValue();\n-          aliasUsages.add(new AliasedNode(n, aliasedNode));\n+          aliasUsages.add(new AliasedNode(aliasVar, n));\n         }\n \n         JSDocInfo info = n.getJSDocInfo();\n         String baseName = name.substring(0, endIndex);\n         Var aliasVar = aliases.get(baseName);\n         if (aliasVar != null) {\n-          Node aliasedNode = aliasVar.getInitialValue();\n-          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));\n+          aliasUsages.add(new AliasedTypeNode(aliasVar, typeNode));\n         }\n       }\n \n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n   public void testAliasNonRedefinition() {\n     test(\"var y = {}; goog.scope(function() { goog.dom = y; });\",\n          \"var y = {}; goog.dom = y;\");\n+  }\n+\n+  public void testCtorAlias() {\n+    test(\"var x = {y: {}};\" +\n+         \"goog.scope(function() {\" +\n+         \"  var y = x.y;\" +\n+         \"  y.ClassA = function() { this.b = new ClassB(); };\" +\n+         \"  y.ClassB = function() {};\" +\n+         \"  var ClassB = y.ClassB;\" +\n+         \"});\",\n+         \"var x = {y: {}};\" +\n+         \"x.y.ClassA = function() { this.b = new x.y.ClassB(); };\" +\n+         \"x.y.ClassB = function() { };\");\n+  }\n+\n+  public void testAliasCycle() {\n+    test(\"var x = {y: {}};\" +\n+         \"goog.scope(function() {\" +\n+         \"  var y = z.x;\" +\n+         \"  var z = y.x;\" +\n+         \"  y.ClassA = function() {};\" +\n+         \"  z.ClassB = function() {};\" +\n+         \"});\", null,\n+         ScopedAliases.GOOG_SCOPE_ALIAS_CYCLE);\n   }\n \n   public void testScopedReturn() {", "timestamp": 1368678414, "metainfo": ""}