{"sha": "294c6d053601061318e16ce65a7f993c458149fc", "log": "Automated g4 rollback of changelist 51438644.  *** Reason for rollback ***  Leads to infinite looping.  *** Original change description ***  Also rotate commutative operators to eliminate parens. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=51542594", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n     if (!late) {\n       return n;\n     }\n-    // All commutative operators are also associative\n     Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));\n     Node rhs = n.getLastChild();\n     if (n.getType() == rhs.getType()) {\n-      // Transform a * (b * c) to a * b * c\n+      Node parent = n.getParent();\n       Node first = n.getFirstChild().detachFromParent();\n       Node second = rhs.getFirstChild().detachFromParent();\n       Node third = rhs.getLastChild().detachFromParent();\n           .copyInformationFrom(n);\n       Node newRoot = new Node(rhs.getType(), newLhs, third)\n           .copyInformationFrom(rhs);\n-      n.getParent().replaceChild(n, newRoot);\n+      parent.replaceChild(n, newRoot);\n       reportCodeChange();\n       return newRoot;\n-    } else if (NodeUtil.isCommutative(n.getType()) &&\n-               !NodeUtil.mayHaveSideEffects(n)) {\n-      // Transform a * (b / c) to b / c * a\n-      Node lhs = n.getFirstChild();\n-      int precedence = NodeUtil.precedence(n.getType());\n-      int lhsPrecedence = NodeUtil.precedence(lhs.getType());\n-      int rhsPrecedence = NodeUtil.precedence(rhs.getType());\n-      if (rhsPrecedence == precedence &&\n-          (lhs.getType() == n.getType() || lhsPrecedence != precedence)) {\n-        n.removeChild(rhs);\n-        n.addChildToFront(rhs);\n-        reportCodeChange();\n-        return n;\n-      }\n     }\n     return n;\n   }\n--- a/src/com/google/javascript/jscomp/ReorderConstantExpression.java\n+++ b/src/com/google/javascript/jscomp/ReorderConstantExpression.java\n     // if the operator is symmetric\n     if (NodeUtil.isSymmetricOperation(subtree)\n         || NodeUtil.isRelationalOperation(subtree)) {\n-      int type = subtree.getType();\n-      int leftType = subtree.getFirstChild().getType();\n-      if (type != leftType\n-          && NodeUtil.precedence(type) == NodeUtil.precedence(leftType)) {\n-        // then flipping would add parens\n-        return subtree;\n-      }\n       // right value is immutable and left is not\n       if (NodeUtil.isImmutableValue(subtree.getLastChild())\n           && !NodeUtil.isImmutableValue(subtree.getFirstChild())) {\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     testSame(\"var a = String({valueOf: function() { return 1; }});\");\n   }\n \n-  public void testRotateAssociativeOperators() {\n-    test(\"a || (b || c); a * (b * c); a | (b | c)\",\n-        \"(a || b) || c; (a * b) * c; (a | b) | c\");\n-    testSame(\"a % (b % c); a / (b / c); a - (b - c);\");\n-    test(\"a * (b % c);\", \"b % c * a\");\n-    test(\"(a * b) * (c / d)\", \"c / d * (a * b)\");\n-    test(\"c / d * (a * b)\", \"c / d * a * b\");\n-    test(\"(a + b) * (c % d)\", \"c % d * (a + b)\");\n-    testSame(\"(a / b) * (c % d)\");\n-    testSame(\"(c = 5) * (c % d)\");\n+  public void testAssocitivity() {\n+    test(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n+        \"var a,b,c; (a || b) || c; (a * b) * c; (a | b) | c\");\n+    testSame(\"var a,b,c; a % (b % c); a / (b / c); a - (b - c);\");\n   }\n \n   private static class StringCompareTestCase extends CompilerTestCase {", "timestamp": 1377731759, "metainfo": ""}