{"sha": "ff08ec69c436dc0e18539c3297ace1d16a7ac0a3", "log": "- Convert some additional public CompilerOption fields to setters. - Move the instrumentation options that do nothing in the open source release.  R=nicksantos DELTA=117  (59 added, 15 deleted, 43 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3926   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   /** Checks types on expressions */\n   public boolean checkTypes;\n \n+  boolean tightenTypes;\n+\n   /** Tightens types based on a global analysis. Experimental. */\n-  public boolean tightenTypes;\n+  public void setTightenTypes(boolean tighten) {\n+    this.tightenTypes = tighten;\n+  }\n \n   public CheckLevel reportMissingOverride;\n \n     this.reportMissingOverride = level;\n   }\n \n-  public CheckLevel reportUnknownTypes;\n+  CheckLevel reportUnknownTypes;\n \n   /** Flags a warning for every node whose type could not be determined. */\n   public void setReportUnknownTypes(CheckLevel level) {\n    */\n   public String checkMissingGetCssNameBlacklist;\n \n-  /** Checks that the synctactic restrictions of ES5 strict mode are met. */\n-  // TODO(johnlenz): remove this.\n-  public boolean checkEs5Strict;\n-\n   /** Checks that the synctactic restrictions of Caja are met. */\n-  public boolean checkCaja;\n+  boolean checkCaja;\n+\n+  public void setCheckCaja(boolean check) {\n+    checkCaja = check;\n+  }\n \n   /**\n    * A set of extra annotation names which are accepted and silently ignored\n   /** Enhanced function inlining */\n   public boolean inlineLocalFunctions;\n \n-  /** Assume closures capture only what they reference */\n-  public boolean assumeClosuresOnlyCaptureReferences;\n+  boolean assumeClosuresOnlyCaptureReferences;\n \n   /** Move code to a deeper module */\n   public boolean crossModuleCodeMotion;\n   public boolean inlineVariables;\n \n   /** Inlines variables */\n-  public boolean inlineLocalVariables;\n+  boolean inlineLocalVariables;\n \n   // TODO(user): This is temporary. Once flow sensitive inlining is stable\n   // Remove this.\n   /** Extracts common prototype member declarations */\n   public boolean extractPrototypeMemberDeclarations;\n \n-  /** Removes functions that have no body */\n+  // TODO(johnlenz): REMOVE THS\n   public boolean removeEmptyFunctions;\n \n   /** Removes unused member prototypes */\n   /** Adds variable aliases for externals to reduce code size */\n   public boolean aliasExternals;\n \n-  /**\n-   * If set to a non-empty string, then during an alias externals pass only\n-   * externals with these names will be considered for aliasing.\n-   */\n-  public String aliasableGlobals;\n-\n-  /**\n-   * Additional globals that can not be aliased since they may be undefined or\n-   * can cause errors.  Comma separated list of symbols.  e.g. \"foo,bar\"\n-   */\n-  public String unaliasableGlobals;\n+  String aliasableGlobals;\n+\n+  /**\n+   * A comma separated white-list of global names. When {@link #aliasExternals}\n+   * is enable, if set to a non-empty string, only externals with these names\n+   * will be considered for aliasing.\n+   */\n+  public void setAliasableGlobals(String names) {\n+    aliasableGlobals = names;\n+  }\n+\n+  String unaliasableGlobals;\n+\n+  /**\n+   * A comma separated white-list of global names. When {@link #aliasExternals}\n+   * is enable, these global names will not be aliased.\n+   */\n+  public void setUnaliasableGlobals(String names) {\n+    unaliasableGlobals = names;\n+  }\n \n   /** Collapses multiple variable declarations into one */\n   public boolean collapseVariableDeclarations;\n \n   /** Group multiple variable declarations into one */\n-  public boolean groupVariableDeclarations;\n+  boolean groupVariableDeclarations;\n+\n+  public void groupVariableDeclarations(boolean enabled) {\n+    groupVariableDeclarations = enabled;\n+  }\n \n   /**\n    * Collapses anonymous function declarations into named function\n   public boolean collapseProperties;\n \n   /** Split object literals into individual variables when possible. */\n-  public boolean collapseObjectLiterals;\n+  boolean collapseObjectLiterals;\n+\n+  public void setCollapseObjectLiterals(boolean enabled) {\n+    collapseObjectLiterals = true;\n+  }\n \n   /** Flattens multi-level property names on extern types (e.g. String$f = x) */\n   boolean collapsePropertiesOnExternTypes;\n   /**\n    * Where to save debug report for compute function side effects.\n    */\n-  public String debugFunctionSideEffectsPath;\n+  String debugFunctionSideEffectsPath;\n \n   /**\n    * Rename properties to disambiguate between unrelated fields based on\n   /** Whether to export test functions. */\n   public boolean exportTestFunctions;\n \n+  boolean specializeInitialModule;\n+\n   /** Specialize the initial module at the cost of later modules */\n-  public boolean specializeInitialModule;\n+  public void setSpecializeInitialModule(boolean enabled) {\n+    specializeInitialModule = enabled;\n+  }\n \n   //--------------------------------\n   // Special-purpose alterations\n   /** A CodingConvention to use during the compile. */\n   private CodingConvention codingConvention;\n \n-  /** Instrument code for the purpose of collecting coverage data. */\n-  public boolean instrumentForCoverage;\n-\n-  /**\n-   * Instrument code for the purpose of collecting coverage data - restrict to\n-   * coverage pass only, and skip all other passes.\n-   */\n-  public boolean instrumentForCoverageOnly;\n+  boolean ignoreCajaProperties;\n \n   /** Add code to skip properties that Caja adds to Object.prototype */\n-  public boolean ignoreCajaProperties;\n+  public void setIgnoreCajaProperties(boolean enabled) {\n+    ignoreCajaProperties = enabled;\n+  }\n \n   public String syntheticBlockStartMarker;\n \n   /** Move top level function declarations to the top */\n   public boolean moveFunctionDeclarations;\n \n-  /** Instrumentation template to use */\n+  /** Instrumentation template to use with #recordFunctionInformation */\n   public String instrumentationTemplate;\n \n+  String appNameStr;\n+\n   /**\n    * App identifier string for use by the instrumentation template's\n-   * app_name_setter\n-   */\n-  public String appNameStr;\n+   * app_name_setter. @see #instrumentationTemplate\n+   */\n+  public void setAppNameStr(String appNameStr) {\n+    this.appNameStr = appNameStr;\n+  }\n \n   /** Record function information */\n   public boolean recordFunctionInformation;\n   /** The string to use as the separator for printInputDelimiter */\n   public String inputDelimiter = \"// Input %num%\";\n \n+  String reportPath;\n+\n   /** Where to save a report of global name usage */\n-  public String reportPath;\n-\n-  public TracerMode tracer;\n+  public void setReportPath(String reportPath) {\n+    this.reportPath = reportPath;\n+  }\n+\n+  TracerMode tracer;\n+\n+  public void setTracerMode(TracerMode mode) {\n+    tracer = mode;\n+  }\n \n   private boolean colorizeErrorOutput;\n \n   /** The output path for the created externs file. */\n   String externExportsPath;\n \n+  String nameReferenceReportPath;\n+\n   /** Where to save a cross-reference report from the name reference graph */\n-  public String nameReferenceReportPath;\n+  public void setNameReferenceReportPath(String filePath) {\n+    nameReferenceReportPath = filePath;\n+  }\n+\n+  String nameReferenceGraphPath;\n \n   /** Where to save the name reference graph */\n-  public String nameReferenceGraphPath;\n+  public void setNameReferenceGraphPath(String filePath) {\n+    nameReferenceGraphPath = filePath;\n+  }\n \n   //--------------------------------\n   // Debugging Options\n     // Alterations\n     runtimeTypeCheck = false;\n     runtimeTypeCheckLogFunction = null;\n-    instrumentForCoverage = false;\n-    instrumentForCoverageOnly = false;\n     ignoreCajaProperties = false;\n     syntheticBlockStartMarker = null;\n     syntheticBlockEndMarker = null;\n   }\n \n   /**\n-   * If true, enables enables additional optimizations.\n+   * Whether to assume closures capture only what they reference. This allows\n+   * more aggressive function inlining.\n    */\n   public void setAssumeClosuresOnlyCaptureReferences(boolean enable) {\n     this.assumeClosuresOnlyCaptureReferences = enable;\n--- a/src/com/google/javascript/jscomp/jsonml/SecureCompiler.java\n+++ b/src/com/google/javascript/jscomp/jsonml/SecureCompiler.java\n import com.google.javascript.jscomp.JSSourceFile;\n import com.google.javascript.jscomp.Result;\n import com.google.javascript.jscomp.VariableRenamingPolicy;\n+import com.google.javascript.jscomp.CompilerOptions.Reach;\n \n import java.util.ArrayList;\n \n     CompilerOptions options = new CompilerOptions();\n \n     options.variableRenaming = VariableRenamingPolicy.OFF;\n-    options.inlineLocalVariables = true;\n+    options.setInlineVariables(Reach.LOCAL_ONLY);\n     options.inlineLocalFunctions = true;\n     options.checkGlobalThisLevel = CheckLevel.OFF;\n     options.coalesceVariableNames = true;", "timestamp": 1323289074, "metainfo": ""}