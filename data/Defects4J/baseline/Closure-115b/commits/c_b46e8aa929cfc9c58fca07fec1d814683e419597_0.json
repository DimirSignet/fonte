{"sha": "b46e8aa929cfc9c58fca07fec1d814683e419597", "log": "Add useful metadata to warnings whitelists  Tested: yes  R=johnlenz DELTA=320  (202 added, 49 deleted, 69 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5371   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n       return -1;\n     }\n \n-    return matchIndex;\n+    return matchIndex + separator.length();\n   }\n \n   /**\n    */\n   private String[] jsSplit(String stringValue, String separator, int limit) {\n     Preconditions.checkArgument(limit >= 0);\n-    Preconditions.checkArgument(stringValue != null);\n \n     // For limits of 0, return an empty array\n     if (limit == 0) {\n       return new String[0];\n     }\n \n-    // If a separator is not specified, return the entire string as\n-    // the only element of an array.\n+    /* If a separator is not specified, return the entire string as\n+     * the only element of an array.\n+     */\n     if (separator == null) {\n       return new String[] {stringValue};\n     }\n \n     List<String> splitStrings = Lists.newArrayList();\n \n-    // If an empty string is specified for the separator, split apart each\n-    // character of the string.\n+    /* If an empty string is specified for the separator, split apart each\n+     * character of the string.\n+     */\n     if (separator.length() == 0) {\n       for (int i = 0; i < stringValue.length() && i < limit; i++) {\n         splitStrings.add(stringValue.substring(i, i + 1));\n       }\n     } else {\n-      int startIndex = 0, matchIndex;    \n-      while ((matchIndex =\n+      int startIndex = 0, matchEndIndex;\n+      while ((matchEndIndex =\n           jsSplitMatch(stringValue, startIndex, separator)) >= 0 &&\n           splitStrings.size() < limit) {\n-        splitStrings.add(stringValue.substring(startIndex, matchIndex));\n-\n-        startIndex = matchIndex + separator.length();\n-      }\n-\n-      if (splitStrings.size() < limit) {\n-        if (startIndex < stringValue.length()) {\n-          splitStrings.add(stringValue.substring(startIndex));\n-        } else {\n-          splitStrings.add(\"\");\n-        }\n+        if (separator.length() == 0) {\n+          matchEndIndex++;\n+        }\n+        splitStrings.add(stringValue.substring(startIndex,\n+            matchEndIndex - separator.length()));\n+        startIndex = matchEndIndex;\n+      }\n+      if (startIndex < stringValue.length() && splitStrings.size() < limit) {\n+        splitStrings.add(stringValue.substring(startIndex));\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/WhitelistWarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/WhitelistWarningsGuard.java\n \n import com.google.common.base.Charsets;\n import com.google.common.base.Preconditions;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import com.google.common.collect.TreeMultimap;\n \n import java.io.File;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.PrintStream;\n-import java.util.HashSet;\n+import java.io.Reader;\n+import java.util.List;\n import java.util.Set;\n import java.util.regex.Pattern;\n \n  * @author bashir@google.com (Bashir Sadjad)\n  */\n public class WhitelistWarningsGuard extends WarningsGuard {\n+  private static final Splitter LINE_SPLITTER = Splitter.on(\"\\n\");\n+\n   /** The set of white-listed warnings, same format as {@code formatWarning}. */\n   private final Set<String> whitelist;\n \n    * This class depends on an input set that contains the white-list. The format\n    * of each white-list string is:\n    * <file-name>:<line-number>?  <warning-description>\n+   * # <optional-comment>\n    *\n    * @param whitelist The set of JS-warnings that are white-listed. This is\n    *     expected to have similar format as {@code formatWarning(JSError)}.\n     this.whitelist = normalizeWhitelist(whitelist);\n   }\n \n+  /**\n+   * Loads legacy warnings list from the set of strings. During development line\n+   * numbers are changed very often - we just cut them and compare without ones.\n+   *\n+   * @return known legacy warnings without line numbers.\n+   */\n   private static Set<String> normalizeWhitelist(Set<String> whitelist) {\n     Set<String> result = Sets.newHashSet();\n-    for (String match : whitelist) {\n-      result.add(LINE_NUMBER.matcher(match).replaceFirst(\":\"));\n+    for (String line : whitelist) {\n+      String trimmed = line.trim();\n+      if (trimmed.isEmpty() || trimmed.charAt(0) == '#') {\n+        // strip out empty lines and comments.\n+        continue;\n+      }\n+\n+      // Strip line number for matching.\n+      result.add(LINE_NUMBER.matcher(trimmed).replaceFirst(\":\"));\n     }\n     return ImmutableSet.copyOf(result);\n   }\n   }\n \n   /**\n-   * Loads legacy warnings list from the file. As during development line\n-   * numbers are changed very often - we just cut it and compare without ones.\n-   *\n-   * @return known legacy warnings without line numbers.\n+   * Loads legacy warnings list from the file.\n+   * @return The lines of the file.\n    */\n   public static Set<String> loadWhitelistedJsWarnings(File file) {\n     return loadWhitelistedJsWarnings(\n   }\n \n   /**\n-   * Loads legacy warnings list from the file. As during development line\n-   * numbers are changed very often - we just cut it and compare without ones.\n-   *\n-   * @return known legacy warnings without line numbers.\n+   * Loads legacy warnings list from the file.\n+   * @return The lines of the file.\n    */\n   protected static Set<String> loadWhitelistedJsWarnings(\n-      InputSupplier<InputStreamReader> supplier) {\n-    Preconditions.checkNotNull(supplier);\n-\n-    Set<String> result = new HashSet<String>();\n-\n+      InputSupplier<? extends Reader> supplier) {\n     try {\n-      for (String line : CharStreams.readLines(supplier)) {\n-        line = line.trim();\n-        if (line.isEmpty() || line.charAt(0) == '#') {\n-          continue;\n-        }\n-\n-        result.add(line);\n-      }\n+      return loadWhitelistedJsWarnings(supplier.getInput());\n     } catch (IOException e) {\n       throw new RuntimeException(e);\n     }\n+  }\n+\n+  /**\n+   * Loads legacy warnings list from the file.\n+   * @return The lines of the file.\n+   */\n+  // TODO(nicksantos): This is a weird API.\n+  static Set<String> loadWhitelistedJsWarnings(Reader reader)\n+      throws IOException {\n+    Preconditions.checkNotNull(reader);\n+    Set<String> result = Sets.newHashSet();\n+\n+    for (String line : CharStreams.readLines(reader)) {\n+      result.add(line);\n+    }\n \n     return result;\n   }\n     return formatWarning(error, false);\n   }\n \n-  public static String formatWarning(JSError error, boolean withLineNumber) {\n+  /**\n+   * @param withMetaData If true, include metadata that's useful to humans\n+   *     This metadata won't be used for matching the warning.\n+   */\n+  public static String formatWarning(JSError error, boolean withMetaData) {\n     StringBuilder sb = new StringBuilder();\n     sb.append(error.sourceName).append(\":\");\n-    if (withLineNumber) {\n+    if (withMetaData) {\n       sb.append(error.lineNumber);\n     }\n-    String descriptionFirstLine = getFirstLine(error.description);\n-    if (!withLineNumber) {\n-      descriptionFirstLine =\n-          LINE_NUMBER.matcher(descriptionFirstLine).replaceAll(\":\");\n-    }\n-    sb.append(\"  \").append(descriptionFirstLine);\n+    List<String> lines = ImmutableList.copyOf(\n+        LINE_SPLITTER.split(error.description));\n+    sb.append(\"  \").append(lines.get(0));\n+\n+    // Add the rest of the message as a comment.\n+    if (withMetaData) {\n+      for (int i = 1; i < lines.size(); i++) {\n+        sb.append(\"\\n# \").append(lines.get(i));\n+      }\n+      sb.append(\"\\n\");\n+    }\n \n     return sb.toString();\n   }\n     private final Set<JSError> warnings = Sets.newLinkedHashSet();\n     private String productName = null;\n     private String generatorTarget = null;\n-    private boolean withLineNumber = false;\n \n     /** Fill in your product name to get a fun message! */\n     public WhitelistBuilder setProductName(String name) {\n       return this;\n     }\n \n-    /**\n-     * Sets whether line number are recorded in the whitelist.\n-     *\n-     * The line numbers are not used by the compiler. The whitelist will still\n-     * match any line in the file. This ensures that unrelated changes in\n-     * the file don't make the build fail.\n-     *\n-     * The line numbers are only there to make it easier for humans to find\n-     * the problem.\n-     */\n+    /** We now always record the line number. */\n+    @Deprecated\n     public WhitelistBuilder setWithLineNumber(boolean line) {\n-      this.withLineNumber = line;\n       return this;\n     }\n \n       Multimap<DiagnosticType, String> warningsByType = TreeMultimap.create();\n       for (JSError warning : warnings) {\n         warningsByType.put(\n-            warning.getType(), formatWarning(warning, withLineNumber));\n+            warning.getType(),\n+            formatWarning(warning, true /* withLineNumber */));\n       }\n \n       for (DiagnosticType type : warningsByType.keySet()) {\n         out.append(\"\\n# Warning \")\n             .append(type.key)\n             .append(\": \")\n-            .println(getFirstLine(type.format.toPattern()));\n+            .println(Iterables.get(\n+                LINE_SPLITTER.split(type.format.toPattern()), 0));\n \n         for (String warning : warningsByType.get(type)) {\n           out.println(warning);\n         }\n       }\n+      out.flush();\n     }\n   }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n     fold(\"x = 'a b c d e'.split(' ', 1)\", \"x = ['a']\");\n     fold(\"x = 'a b c d e'.split(' ', 3)\", \"x = ['a','b','c']\");\n     fold(\"x = 'a b c d e'.split(null, 1)\", \"x = ['a b c d e']\");\n-    fold(\"x = 'aaaaa'.split('a')\", \"x = ['', '', '', '', '', '']\");\n-    fold(\"x = 'xyx'.split('x')\", \"x = ['', 'y', '']\");\n-    \n-    // Empty separator\n+    fold(\"x = 'aaaaa'.split('a')\", \"x = ['', '', '', '', '']\");\n     fold(\"x = 'abcde'.split('')\", \"x = ['a','b','c','d','e']\");\n     fold(\"x = 'abcde'.split('', 3)\", \"x = ['a','b','c']\");\n-    \n-    // Empty separator AND empty string\n-    fold(\"x = ''.split('')\", \"x = []\");\n-    \n-    // Separator equals string\n-    fold(\"x = 'aaa'.split('aaa')\", \"x = ['','']\");\n-    fold(\"x = ' '.split(' ')\", \"x = ['','']\");\n \n     foldSame(\"x = 'abcde'.split(/ /)\");\n     foldSame(\"x = 'abcde'.split(' ', -1)\");", "timestamp": 1344982955, "metainfo": ""}