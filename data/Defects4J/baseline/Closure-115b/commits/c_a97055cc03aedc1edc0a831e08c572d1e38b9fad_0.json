{"sha": "a97055cc03aedc1edc0a831e08c572d1e38b9fad", "log": "Pull external Rhino changes. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=48148994", "commit": "\n--- a/lib/rhino/src/org/mozilla/javascript/ClassCache.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ClassCache.java\n package org.mozilla.javascript;\n \n import java.util.Map;\n-import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.io.Serializable;\n \n /**\n     private static final long serialVersionUID = -8866246036237312215L;\n     private static final Object AKEY = \"ClassCache\";\n     private volatile boolean cachingIsEnabled = true;\n-    private transient HashMap<Class<?>,JavaMembers> classTable;\n-    private transient HashMap<JavaAdapter.JavaAdapterSignature,Class<?>> classAdapterCache;\n-    private transient HashMap<Class<?>,Object> interfaceAdapterCache;\n+    private transient Map<Class<?>,JavaMembers> classTable;\n+    private transient Map<JavaAdapter.JavaAdapterSignature,Class<?>> classAdapterCache;\n+    private transient Map<Class<?>,Object> interfaceAdapterCache;\n     private int generatedClassSerial;\n     private Scriptable associatedScope;\n \n      */\n     Map<Class<?>,JavaMembers> getClassCacheMap() {\n         if (classTable == null) {\n-            classTable = new HashMap<Class<?>,JavaMembers>();\n+            // Use 1 as concurrency level here and for other concurrent hash maps\n+            // as we don't expect high levels of sustained concurrent writes.\n+            classTable = new ConcurrentHashMap<Class<?>,JavaMembers>(16, 0.75f, 1);\n         }\n         return classTable;\n     }\n     Map<JavaAdapter.JavaAdapterSignature,Class<?>> getInterfaceAdapterCacheMap()\n     {\n         if (classAdapterCache == null) {\n-            classAdapterCache = new HashMap<JavaAdapter.JavaAdapterSignature,Class<?>>();\n+            classAdapterCache = new ConcurrentHashMap<JavaAdapter.JavaAdapterSignature,Class<?>>(16, 0.75f, 1);\n         }\n         return classAdapterCache;\n     }\n     {\n         if (cachingIsEnabled) {\n             if (interfaceAdapterCache == null) {\n-                interfaceAdapterCache = new HashMap<Class<?>,Object>();\n+                interfaceAdapterCache = new ConcurrentHashMap<Class<?>,Object>(16, 0.75f, 1);\n             }\n             interfaceAdapterCache.put(cl, iadapter);\n         }\n--- a/lib/rhino/src/org/mozilla/javascript/NativeJavaMethod.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeJavaMethod.java\n \n import java.lang.reflect.*;\n import java.util.Arrays;\n-import java.util.LinkedList;\n+import java.util.concurrent.CopyOnWriteArrayList;\n \n /**\n  * This class reflects Java methods into the JavaScript environment and\n                     }\n                 }\n             } else {\n-                overloadCache = new LinkedList<ResolvedOverload>();\n+                overloadCache = new CopyOnWriteArrayList<ResolvedOverload>();\n             }\n             int index = findFunction(cx, methods, args);\n             // As a sanity measure, don't let the lookup cache grow longer\n                 synchronized (overloadCache) {\n                     ResolvedOverload ovl = new ResolvedOverload(args, index);\n                     if (!overloadCache.contains(ovl)) {\n-                        overloadCache.addFirst(ovl);\n+                        overloadCache.add(0, ovl);\n                     }\n                 }\n             }\n \n     MemberBox[] methods;\n     private String functionName;\n-    private transient LinkedList<ResolvedOverload> overloadCache;\n+    private transient CopyOnWriteArrayList<ResolvedOverload> overloadCache;\n }\n \n class ResolvedOverload {", "timestamp": 1371603286, "metainfo": ""}