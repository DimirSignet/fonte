{"sha": "a1637bfdf32282f81ef6c71adec0b5bfed597119", "log": "Fixed some more linter warnings in the subdirectories. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44166744", "commit": "\n--- a/src/com/google/javascript/jscomp/graph/FixedPointGraphTraversal.java\n+++ b/src/com/google/javascript/jscomp/graph/FixedPointGraphTraversal.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.graph.DiGraph;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n \n         NON_HALTING_ERROR_MSG);\n   }\n \n+  /** Edge callback */\n   public static interface EdgeCallback<Node, Edge> {\n     /**\n      * Update the state of the destination node when the given edge\n--- a/src/com/google/javascript/jscomp/graph/GraphColoring.java\n+++ b/src/com/google/javascript/jscomp/graph/GraphColoring.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n-import com.google.javascript.jscomp.graph.Annotation;\n-import com.google.javascript.jscomp.graph.GraphNode;\n-import com.google.javascript.jscomp.graph.SubGraph;\n \n import java.util.Collections;\n import java.util.Comparator;\n     return graph;\n   }\n \n+  /** The color of a node */\n   public static class Color implements Annotation {\n     int value = 0;\n \n--- a/src/com/google/javascript/jscomp/graph/GraphPruner.java\n+++ b/src/com/google/javascript/jscomp/graph/GraphPruner.java\n  * in the pruned graph.\n  *\n  * We do not make any guarantees about what edges are in the pruned graph.\n+ *\n+ * @param <N> The type of data that the graph node holds.\n+ * @param <E> The type of data that the graph edge holds.\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n--- a/src/com/google/javascript/jscomp/graph/GraphReachability.java\n+++ b/src/com/google/javascript/jscomp/graph/GraphReachability.java\n  * Computes all the reachable nodes. Upon execution of {@link #compute(Object)},\n  * the graph nodes will be annotated with {@link #REACHABLE} if it is reachable\n  * from the specified entry node.\n+ *\n+ * @param <N> The type of data that the graph node holds.\n+ * @param <E> The type of data that the graph edge holds.\n  *\n  * @see GraphNode#getAnnotation()\n  */\n--- a/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n   public List<GraphNode<N, E>> getNeighborNodes(DiGraphNode<N, E> node) {\n     List<GraphNode<N, E>> result = Lists.newArrayList();\n     for (Iterator<GraphNode<N, E>> i =\n-      ((LinkedDirectedGraphNode<N, E>) node).neighborIterator();i.hasNext();) {\n+      ((LinkedDirectedGraphNode<N, E>) node).neighborIterator(); i.hasNext();) {\n       result.add(i.next());\n     }\n     return result;\n--- a/src/com/google/javascript/jscomp/graph/StandardUnionFind.java\n+++ b/src/com/google/javascript/jscomp/graph/StandardUnionFind.java\n  */\n package com.google.javascript.jscomp.graph;\n \n-import javax.annotation.Nullable;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.Iterators.filter;\n+\n import com.google.common.base.Objects;\n-import static com.google.common.base.Preconditions.checkArgument;\n import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n-\n-import static com.google.common.collect.Iterators.filter;\n import com.google.common.collect.Maps;\n \n import java.io.Serializable;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * A Union-Find implementation.\n--- a/src/com/google/javascript/jscomp/graph/UnionFind.java\n+++ b/src/com/google/javascript/jscomp/graph/UnionFind.java\n \n import java.util.Collection;\n import java.util.Set;\n-\n \n /**\n  * Union-Find is a classical algorithm used to find connected components in\n--- a/src/com/google/javascript/jscomp/parsing/Config.java\n+++ b/src/com/google/javascript/jscomp/parsing/Config.java\n  */\n public class Config {\n \n+  /** JavaScript mode */\n   public enum LanguageMode {\n     ECMASCRIPT3,\n     ECMASCRIPT5,\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n           break;\n         // Function declarations are valid\n         case com.google.javascript.rhino.head.Token.FUNCTION:\n-          FunctionNode fnNode = (FunctionNode)node;\n+          FunctionNode fnNode = (FunctionNode) node;\n           valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n           break;\n         // Object literal properties and catch declarations are valid.\n         case com.google.javascript.rhino.head.Token.ASSIGN:\n           if (node instanceof Assignment) {\n             valid = isExprStmt(node.getParent())\n-                && isPropAccess(((Assignment)node).getLeft());\n+                && isPropAccess(((Assignment) node).getLeft());\n           }\n           break;\n \n         com.google.javascript.rhino.head.Node n) {\n       Node node = newNode(transformTokenType(n.getType()));\n       for (com.google.javascript.rhino.head.Node child : n) {\n-        node.addChildToBack(transform((AstNode)child));\n+        node.addChildToBack(transform((AstNode) child));\n       }\n       return node;\n     }\n     private Node transformAsString(AstNode n) {\n       Node ret;\n       if (n instanceof Name) {\n-        ret = transformNameAsString((Name)n);\n+        ret = transformNameAsString((Name) n);\n       } else if (n instanceof NumberLiteral) {\n-        ret = transformNumberAsString((NumberLiteral)n);\n+        ret = transformNumberAsString((NumberLiteral) n);\n         ret.putBooleanProp(Node.QUOTED_PROP, true);\n       } else {\n         ret = transform(n);\n     Node processAstRoot(AstRoot rootNode) {\n       Node node = newNode(Token.SCRIPT);\n       for (com.google.javascript.rhino.head.Node child : rootNode) {\n-        node.addChildToBack(transform((AstNode)child));\n+        node.addChildToBack(transform((AstNode) child));\n       }\n       parseDirectives(node);\n       return node;\n     }\n \n     private boolean isDirective(Node n) {\n-      if (n == null) return false;\n-\n+      if (n == null) {\n+        return false;\n+      }\n       int nType = n.getType();\n       return nType == Token.EXPR_RESULT &&\n           n.getFirstChild().isString() &&\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n \n   private final Map<String, Annotation> annotationNames;\n   private final Set<String> suppressionNames;\n-  static private final Set<String> modifiesAnnotationKeywords =\n+  private static final Set<String> modifiesAnnotationKeywords =\n       ImmutableSet.<String>of(\"this\", \"arguments\");\n \n   private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;\n--- a/src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java\n    * to check.  (And checking EOF by exception is annoying.)\n    * Note distinction from EOF token type!\n    */\n-  private final static int\n-      EOF_CHAR = -1;\n+  private static final int EOF_CHAR = -1;\n \n   JsDocTokenStream(String sourceString) {\n     this(sourceString, 0);\n   final int getLineno() { return lineno; }\n \n   final int getCharno() {\n-    return lineno == initLineno? initCharno + charno : charno;\n+    return lineno == initLineno ? initCharno + charno : charno;\n   }\n \n   final String getString() { return string; }\n   }\n \n   private void addToString(int c) {\n-    int N = stringBufferTop;\n-    if (N == stringBuffer.length) {\n+    int n = stringBufferTop;\n+    if (n == stringBuffer.length) {\n         char[] tmp = new char[stringBuffer.length * 2];\n-        System.arraycopy(stringBuffer, 0, tmp, 0, N);\n+        System.arraycopy(stringBuffer, 0, tmp, 0, n);\n         stringBuffer = tmp;\n     }\n-    stringBuffer[N] = (char)c;\n-    stringBufferTop = N + 1;\n+    stringBuffer[n] = (char) c;\n+    stringBufferTop = n + 1;\n   }\n \n   void ungetChar(int c) {\n       return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;\n     } else {\n       return c == 0xA0\n-          || Character.getType((char)c) == Character.SPACE_SEPARATOR;\n+          || Character.getType((char) c) == Character.SPACE_SEPARATOR;\n     }\n   }\n \n   private static boolean isJSFormatChar(int c) {\n-    return c > 127 && Character.getType((char)c) == Character.FORMAT;\n+    return c > 127 && Character.getType((char) c) == Character.FORMAT;\n   }\n \n   /**\n       return ungetBuffer[ungetCursor];\n     }\n \n-    for(;;) {\n+    for (;;) {\n       int c;\n       if (sourceCursor == sourceEnd) {\n         hitEOF = true;\n       return ungetBuffer[ungetCursor];\n     }\n \n-    for(;;) {\n+    for (;;) {\n       int c;\n       if (sourceCursor == sourceEnd) {\n         hitEOF = true;\n--- a/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n+++ b/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n import java.util.Set;\n import java.util.logging.Logger;\n \n+/** parser runner */\n public class ParserRunner {\n \n-  private static final String configResource =\n+  private static final String CONFIG_RESOURCE =\n       \"com.google.javascript.jscomp.parsing.ParserConfig\";\n \n   private static Set<String> annotationNames = null;\n       return;\n     }\n \n-    ResourceBundle config = ResourceBundle.getBundle(configResource);\n+    ResourceBundle config = ResourceBundle.getBundle(CONFIG_RESOURCE);\n     annotationNames = extractList(config.getString(\"jsdoc.annotations\"));\n     suppressionNames = extractList(config.getString(\"jsdoc.suppressions\"));\n     reservedVars = extractList(config.getString(\"compiler.reserved.vars\"));\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n-import com.google.javascript.rhino.jstype.TemplatizedType;\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.jstype.TemplateType;\n+import com.google.javascript.rhino.jstype.TemplatizedType;\n import com.google.javascript.rhino.jstype.UnionType;\n import com.google.javascript.rhino.jstype.Visitor;\n \n--- a/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\n   /**\n    * Merging function for inequality comparisons between types.\n    */\n-  private final\n-      Function<TypePair, TypePair> INEQ =\n+  private final Function<TypePair, TypePair> ineq =\n     new Function<TypePair, TypePair>() {\n       @Override\n       public TypePair apply(TypePair p) {\n       case Token.GE:\n       case Token.GT:\n         if (outcome) {\n-          return caseEquality(condition, blindScope, INEQ);\n+          return caseEquality(condition, blindScope, ineq);\n         }\n         break;\n ", "timestamp": 1363798225, "metainfo": ""}