{"sha": "98d279bce83ddb2dca499be4bc365939f809a923", "log": "Change on 2010/07/12 15:42:05 by nicksantos  \tAdd a couple test cases that i was curious about.  \tR=robbyw \tDELTA=25  (25 added, 0 deleted, 0 changed)  Change on 2010/07/12 17:12:33 by nicksantos  \tAdd CONST annotations to synthesized vars.  \tR=johnlenz \tDELTA=11  (11 added, 0 deleted, 0 changed)  Change on 2010/07/12 17:55:03 by johnlenz  \tOpen source the name reference graph report and html report.  \tR=acleung \tDELTA=185  (93 added, 90 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=48009   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       DiagnosticType.error(\"JSC_INPUT_MAP_VAR_PARSE\",\n           \"Input variable map parse error: {0}\");\n \n+  private static final DiagnosticType NAME_REF_GRAPH_FILE_ERROR =\n+      DiagnosticType.error(\"JSC_NAME_REF_GRAPH_FILE_ERROR\",\n+          \"Error \\\"{1}\\\" writing name reference graph to \\\"{0}\\\".\");\n+\n+  private static final DiagnosticType NAME_REF_REPORT_FILE_ERROR =\n+      DiagnosticType.error(\"JSC_NAME_REF_REPORT_FILE_ERROR\",\n+          \"Error \\\"{1}\\\" writing name reference report to \\\"{0}\\\".\");\n+\n   /**\n    * A global namespace to share across checking passes.\n    * TODO(nicksantos): This is a hack until I can get the namespace into\n     if (options.instrumentationTemplate != null ||\n         options.recordFunctionInformation) {\n       checks.add(computeFunctionNames);\n+    }\n+\n+    if (options.nameReferenceGraphPath != null &&\n+        !options.nameReferenceGraphPath.isEmpty()) {\n+      checks.add(printNameReferenceGraph);\n+    }\n+\n+    if (options.nameReferenceReportPath != null &&\n+        !options.nameReferenceReportPath.isEmpty()) {\n+      checks.add(printNameReferenceReport);\n     }\n \n     assertAllOneTimePasses(checks);\n       }\n     }\n   }\n+\n+  private final PassFactory printNameReferenceGraph =\n+    new PassFactory(\"printNameReferenceGraph\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new CompilerPass() {\n+        @Override\n+        public void process(Node externs, Node jsRoot) {\n+          NameReferenceGraphConstruction gc =\n+              new NameReferenceGraphConstruction(compiler);\n+          gc.process(externs, jsRoot);\n+          String graphFileName = options.nameReferenceGraphPath;\n+          try {\n+            Files.write(DotFormatter.toDot(gc.getNameReferenceGraph()),\n+                new File(graphFileName),\n+                Charsets.UTF_8);\n+          } catch (IOException e) {\n+            compiler.report(\n+                JSError.make(\n+                    NAME_REF_GRAPH_FILE_ERROR, e.getMessage(), graphFileName));\n+          }\n+        }\n+      };\n+    }\n+  };\n+\n+  private final PassFactory printNameReferenceReport =\n+      new PassFactory(\"printNameReferenceReport\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new CompilerPass() {\n+        @Override\n+        public void process(Node externs, Node jsRoot) {\n+          NameReferenceGraphConstruction gc =\n+              new NameReferenceGraphConstruction(compiler);\n+          String reportFileName = options.nameReferenceReportPath;\n+          try {\n+            NameReferenceGraphReport report =\n+                new NameReferenceGraphReport(gc.getNameReferenceGraph());\n+            Files.write(report.getHtmlReport(),\n+                new File(reportFileName),\n+                Charsets.UTF_8);\n+          } catch (IOException e) {\n+            compiler.report(\n+                JSError.make(\n+                    NAME_REF_REPORT_FILE_ERROR, e.getMessage(), reportFileName));\n+          }\n+        }\n+      };\n+    }\n+  };\n }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphReport.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.NameReferenceGraph.Name;\n+import com.google.javascript.jscomp.NameReferenceGraph.Reference;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.JSType;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+/**\n+ * Generate a nice HTML file describing the name reference graph.\n+ * For each declaration, list the sites where the declaration's name\n+ * is referenced, and list all the names that the declaration references.\n+ * For each, name exactly where use occurs in the source code.\n+ *\n+ * <p>This report should be useful both for internal compiler\n+ * developers and for engineers trying to understand running behavior\n+ * of their code or who want to understand why the compiler won't\n+ * move their code into a new module.\n+ *\n+ * @author bowdidge@google.com (Robert Bowdidge)\n+ */\n+\n+final class NameReferenceGraphReport {\n+  private NameReferenceGraph graph = null;\n+\n+  /**\n+   * Create a NameReferenceGraphReport object.\n+   *\n+   * @param g  name reference graph to describe in report.\n+   */\n+  NameReferenceGraphReport(NameReferenceGraph g) {\n+    this.graph = g;\n+  }\n+\n+  /**\n+   * Generate a nice HTML file describing the name reference graph.\n+   * For each declaration, list the sites where the declaration's name\n+   * is referenced, and list all the names that the declaration references.\n+   * For each, name exactly where use occurs in the source code.\n+   *\n+   * <p>This report should be useful both for internal compiler\n+   * developers and for engineers trying to understand running\n+   * behavior of their code or who want to understand why\n+   * AbstractCompiler won't move their code into a new module.\n+   *\n+   * @return String containing the entire HTML for the report.\n+   */\n+  public String getHtmlReport() {\n+    StringBuilder builder = new StringBuilder();\n+    List<DiGraphNode<Name, Reference>> nodes = Lists.newArrayList(\n+        graph.getDirectedGraphNodes());\n+\n+    generateHtmlReportHeader(builder);\n+\n+    builder.append(\"<h1>Name Reference Graph Dump</h1>\\n\");\n+    builder.append(\"OVERALL STATS\\n\");\n+    builder.append(\"<ul>\\n\");\n+    builder.append(\"<li>Total names: \" + nodes.size());\n+    builder.append(\"</ul>\\n\");\n+\n+    builder.append(\"ALL NAMES\\n\");\n+    builder.append(\"<UL>\\n\");\n+\n+    // Sort declarations in alphabetical order.\n+    Collections.sort(nodes, new DiGraphNodeComparator());\n+\n+    for (DiGraphNode<Name, Reference> n : nodes) {\n+      // Generate the HTML describing the declaration itself.\n+      generateDeclarationReport(builder, n);\n+\n+      // Next, list the places where this name is used (REFERS TO), and the\n+      // names that this declaration refers to (REFERENCED BY).\n+      List<DiGraphEdge<Name, Reference>> outEdges =\n+          graph.getOutEdges(n.getValue());\n+      List<DiGraphEdge<Name, Reference>> inEdges =\n+          graph.getInEdges(n.getValue());\n+\n+      // Don't bother to create the dotted list if we don't have anything to\n+      // put in it.\n+      if (!outEdges.isEmpty() || !inEdges.isEmpty()) {\n+        builder.append(\"<ul>\");\n+\n+        if (outEdges.size() > 0) {\n+          builder.append(\"<li>REFERS TO:<br>\\n\");\n+          builder.append(\"<ul>\");\n+          for (DiGraphEdge<Name, Reference> edge : outEdges) {\n+            generateEdgeReport(builder, edge.getDestination().getValue(),\n+                edge);\n+          }\n+          builder.append(\"</ul>\\n\");\n+        }\n+\n+        if (inEdges.size() > 0) {\n+          builder.append(\"<li>REFERENCED BY:<br>\\n\");\n+          builder.append(\"<ul>\");\n+          for (DiGraphEdge<Name, Reference> edge : inEdges) {\n+            generateEdgeReport(builder, edge.getSource().getValue(), edge);\n+          }\n+          builder.append(\"</ul>\");\n+        }\n+        builder.append(\"</ul>\\n\");\n+      }\n+    }\n+    builder.append(\"</ul>\\n\");\n+    generateHtmlReportFooter(builder);\n+    return builder.toString();\n+  }\n+\n+  /**\n+   * Given a node, find the name of the containing source file.\n+   *\n+   * @param node Parse tree node whose filename is requested\n+   * @return String containing name of source file, or empty string if name\n+   *     cannot be identified.\n+   */\n+  private String getSourceFile(Node node) {\n+    String filename = (String) node.getProp(Node.SOURCEFILE_PROP);\n+    if (filename == null) {\n+      return \"\";\n+    }\n+    return filename;\n+  }\n+\n+  /**\n+   * Generate the HTML for describing a specific declaration.\n+   * @param builder  contents of report to be generated\n+   * @param declarationNode declaration to describe\n+   */\n+  private void generateDeclarationReport(StringBuilder builder,\n+      DiGraphNode<Name, Reference> declarationNode) {\n+    // Provide the name and location of declaration,\n+    // with an anchor to allow navigation to this declaration.\n+    String declName = declarationNode.getValue().getQualifiedName();\n+    JSType declType = declarationNode.getValue().getType();\n+\n+    builder.append(\"<LI> \");\n+    builder.append(\"<A NAME=\\\"\" + declName + \"\\\">\");\n+    builder.append(declName);\n+    builder.append(\"\\n\");\n+\n+    // Provide the type of the declaration.\n+    // This is helpful for debugging.\n+    generateType(builder, declType);\n+\n+    // List all the definitions of this name that were found in the code.\n+    // For each, list\n+    List<DefinitionsRemover.Definition> defs =\n+        declarationNode.getValue().getDeclarations();\n+\n+    if (defs.size() == 0) {\n+       builder.append(\"<br>No definitions found<br>\");\n+    } else {\n+      // Otherwise, provide a list of definitions in a dotted list.\n+      // For each definition, print the location where that definition is\n+      // found.\n+      builder.append(\"<ul>\");\n+      for (DefinitionsRemover.Definition def : defs) {\n+        Node fnDef = def.getRValue();\n+        String sourceFileName = getSourceFile(fnDef);\n+        builder.append(\"<li> Defined: \");\n+        generateSourceReferenceLink(builder,\n+            sourceFileName, fnDef.getLineno(), fnDef.getCharno());\n+      }\n+      builder.append(\"</ul>\");\n+    }\n+  }\n+\n+  /**\n+   *  Generate the HTML header for the report style.\n+   * Borrowed straight from NameAnalyzer's report style.\n+   *\n+   * @param builder contents of the report to be generated\n+   */\n+  private void generateHtmlReportHeader(StringBuilder builder) {\n+    builder.append(\"<!DOCTYPE html>\\n\" +\n+        \"<html>\" +\n+        \"<head>\" +\n+        \"<meta http-equiv=\\\"Content-Type\\\" \" +\n+        \"content=\\\"text/html;charset=utf-8\\\" >\" +\n+        \"<title>Name Reference Graph Dump</title>\" +\n+        \"<style type=\\\"text/css\\\">body, td, \");\n+    builder.append(\"p {font-family: Arial; font-size: 83%} \");\n+    builder.append(\"ul {margin-top:2px; margin-left:0px; padding-left:1em;}\");\n+    builder.append(\"li {margin-top:3px; margin-left:24px;\" +\n+        \"padding-left:0px;padding-bottom: 4px}\");\n+    builder.append(\"</style></head><body>\\n\");\n+  }\n+\n+  /**\n+   * Generate the HTML footer for the report style.\n+   */\n+  private void generateHtmlReportFooter(StringBuilder builder) {\n+    builder.append(\"</body></html>\");\n+  }\n+\n+  /**\n+   * Generate a description of a specific edge between two nodes.\n+   * For each edge, name the element being linked, the location of the\n+   * reference in the source file, and the type of the reference.\n+   *\n+   * @param builder contents of the report to be generated\n+   * @param referencedDecl name of the declaration being referenced\n+   * @param edge the graph edge being described\n+   */\n+  private void generateEdgeReport(StringBuilder builder,\n+      Name referencedDecl, DiGraphEdge<Name, Reference> edge) {\n+    String srcDeclName = referencedDecl.getQualifiedName();\n+    builder.append(\"<li><A HREF=\\\"#\" + srcDeclName + \"\\\">\");\n+    builder.append(srcDeclName);\n+    builder.append(\"</a> \");\n+\n+    Node def = edge.getValue().getSite();\n+    int lineNumber = def.getLineno();\n+    int columnNumber = def.getCharno();\n+    String sourceFile = getSourceFile(def);\n+\n+    generateSourceReferenceLink(builder, sourceFile, lineNumber, columnNumber);\n+\n+    JSType defType = edge.getValue().getSite().getJSType();\n+    generateType(builder, defType);\n+  }\n+\n+\n+  private void generateSourceReferenceLink(StringBuilder builder,\n+    String sourceFile, int lineNumber, int columnNumber) {\n+    assert(sourceFile != null);\n+\n+    builder.append(\"(\");\n+\n+\n+\n+    // Print out the text path so the user knows where things come from.\n+    builder.append(sourceFile + \":\" +\n+        lineNumber + \",\" + columnNumber);\n+\n+\n+\n+    builder.append(\")\");\n+  }\n+\n+  /**\n+   * Dump a type in a nice, readable way.\n+   *\n+   * @param builder contents of the report to be generated.\n+   * @param defType type to describe\n+   */\n+  private void generateType(StringBuilder builder, JSType defType) {\n+    if (defType == null) {\n+      builder.append(\" (type: null) \");\n+    } else if (defType.isUnknownType()) {\n+      builder.append(\" (type: unknown) \");\n+    } else {\n+      builder.append(\" (type: \" +\n+          defType.toString() + \") \");\n+    }\n+  }\n+\n+  /**\n+   * DiGraphNodeComparator gives us a way to generate sorted lists\n+   * of DiGraphNodes.  It provides a compare function used by the\n+   * String class's sort method.\n+   */\n+  class DiGraphNodeComparator implements\n+      Comparator<DiGraphNode<Name, Reference>> {\n+    public int compare(DiGraphNode<Name, Reference> node1,\n+        DiGraphNode<Name, Reference> node2) {\n+      Preconditions.checkNotNull(node1.getValue());\n+      Preconditions.checkNotNull(node2.getValue());\n+\n+      if ((node1.getValue().getQualifiedName() == null) &&\n+          (node2.getValue().getQualifiedName() == null)) {\n+        return 0;\n+      }\n+\n+      // Node 1, if null, comes before node 2.\n+      if (node1.getValue().getQualifiedName() == null) {\n+        return -1;\n+      }\n+\n+      // Node 2, if null, comes before node 1.\n+      if (node2.getValue().getQualifiedName() == null) {\n+        return 1;\n+      }\n+\n+      return node1.getValue().getQualifiedName().compareTo(\n+          node2.getValue().getQualifiedName());\n+    }\n+  }\n+\n+}\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n           // Create a new variable in a synthetic script. This will prevent\n           // subsequent compiler passes from crashing.\n           Node nameNode = Node.newString(Token.NAME, varName);\n+\n+          // Mark the variable as constant if it matches the coding convention\n+          // for constant vars.\n+          // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n+          // AFAIK, all people who use the CONST coding convention also\n+          // compile with undeclaredVars as errors. We have some test\n+          // cases for this configuration though, and it makes them happier.\n+          if (compiler.getCodingConvention().isConstant(varName)) {\n+            nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+          }\n+\n           getSynthesizedExternsRoot().addChildToBack(\n               new Node(Token.VAR, nameNode));\n           scope.getGlobalScope().declare(varName, nameNode,\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n         \"goog.scope(function() {g.method();});\",\n \n         \"goog.method();g.method();\");\n+  }\n+\n+  public void testTwoSymbolsInTwoScopes() {\n+    test(\n+        \"var goog = {};\" +\n+        \"goog.scope(function() { var g = goog; g.Foo = function() {}; });\" +\n+        \"goog.scope(function() { \" +\n+        \"  var Foo = goog.Foo; goog.bar = function() { return new Foo(); };\" +\n+        \"});\",\n+        \"var goog = {};\" +\n+        \"goog.Foo = function() {};\" +\n+        \"goog.bar = function() { return new goog.Foo(); };\");\n+  }\n+\n+  public void testAliasOfSymbolInGoogScope() {\n+    test(\n+        \"var goog = {};\" +\n+        \"goog.scope(function() {\" +\n+        \"  var g = goog;\" +\n+        \"  g.Foo = function() {};\" +\n+        \"  var Foo = g.Foo;\" +\n+        \"  Foo.prototype.bar = function() {};\" +\n+        \"});\",\n+        \"var goog = {}; goog.Foo = function() {};\" +\n+        \"goog.Foo.prototype.bar = function() {};\");\n   }\n \n   public void testScopedFunctionReturnThis() {", "timestamp": 1279043682, "metainfo": ""}