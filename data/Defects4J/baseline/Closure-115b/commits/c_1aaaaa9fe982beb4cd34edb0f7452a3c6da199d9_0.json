{"sha": "1aaaaa9fe982beb4cd34edb0f7452a3c6da199d9", "log": "Simplify how the prototype prop is stored  R=johnlenz DELTA=157  (87 added, 53 deleted, 17 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3082   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n    */\n   private FunctionPrototypeType prototype;\n \n+  private SimpleSlot prototypeSlot;\n+\n   /**\n    * Whether a function is a constructor, an interface, or just an ordinary\n    * function.\n     return call;\n   }\n \n+  @Override\n+  public StaticSlot<JSType> getSlot(String name) {\n+    if (\"prototype\".equals(name)) {\n+      // Lazy initialization of the prototype field.\n+      getPrototype();\n+      return prototypeSlot;\n+    } else {\n+      return super.getSlot(name);\n+    }\n+  }\n+\n+  /**\n+   * Includes the prototype iff someone has created it. We do not want\n+   * to expose the prototype for ordinary functions.\n+   */\n+  public Set<String> getOwnPropertyNames() {\n+    if (prototype == null) {\n+      return super.getOwnPropertyNames();\n+    } else {\n+      Set<String> names = Sets.newHashSet(\"prototype\");\n+      names.addAll(super.getOwnPropertyNames());\n+      return names;\n+    }\n+  }\n+\n   /**\n    * Gets the {@code prototype} property of this function type. This is\n    * equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}.\n \n     boolean replacedPrototype = prototype != null;\n     this.prototype = prototype;\n+    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n \n     if (isConstructor() || isInterface()) {\n       FunctionType superClass = getSuperClassConstructor();\n   }\n \n   @Override\n-  public boolean hasProperty(String name) {\n-    return super.hasProperty(name) || \"prototype\".equals(name);\n-  }\n-\n-  @Override\n-  public boolean hasOwnProperty(String name) {\n-    return super.hasOwnProperty(name) || \"prototype\".equals(name);\n-  }\n-\n-  @Override\n   public JSType getPropertyType(String name) {\n-    if (\"prototype\".equals(name)) {\n-      return getPrototype();\n-    } else {\n-      if (!hasOwnProperty(name)) {\n-        if (\"call\".equals(name)) {\n-          // Define the \"call\" function lazily.\n-          Node params = getParametersNode();\n-          if (params == null) {\n-            // If there's no params array, don't do any type-checking\n-            // in this CALL function.\n-            defineDeclaredProperty(name,\n-                new FunctionBuilder(registry)\n-                    .withReturnType(getReturnType())\n-                    .build(),\n-                source);\n-          } else {\n-            params = params.cloneTree();\n-            Node thisTypeNode = Node.newString(Token.NAME, \"thisType\");\n-            thisTypeNode.setJSType(\n-                registry.createOptionalNullableType(getTypeOfThis()));\n-            params.addChildToFront(thisTypeNode);\n-            thisTypeNode.setOptionalArg(true);\n-\n-            defineDeclaredProperty(name,\n-                new FunctionBuilder(registry)\n-                    .withParamsNode(params)\n-                    .withReturnType(getReturnType())\n-                    .build(),\n-                source);\n-          }\n-        } else if (\"apply\".equals(name)) {\n-          // Define the \"apply\" function lazily.\n-          FunctionParamBuilder builder = new FunctionParamBuilder(registry);\n-\n-          // Ecma-262 says that apply's second argument must be an Array\n-          // or an arguments object. We don't model the arguments object,\n-          // so let's just be forgiving for now.\n-          // TODO(nicksantos): Model the Arguments object.\n-          builder.addOptionalParams(\n-              registry.createNullableType(getTypeOfThis()),\n-              registry.createNullableType(\n-                  registry.getNativeType(JSTypeNative.OBJECT_TYPE)));\n-\n+    if (!hasOwnProperty(name)) {\n+      if (\"call\".equals(name)) {\n+        // Define the \"call\" function lazily.\n+        Node params = getParametersNode();\n+        if (params == null) {\n+          // If there's no params array, don't do any type-checking\n+          // in this CALL function.\n           defineDeclaredProperty(name,\n               new FunctionBuilder(registry)\n-                  .withParams(builder)\n-                  .withReturnType(getReturnType())\n-                  .build(),\n+              .withReturnType(getReturnType())\n+              .build(),\n+              source);\n+        } else {\n+          params = params.cloneTree();\n+          Node thisTypeNode = Node.newString(Token.NAME, \"thisType\");\n+          thisTypeNode.setJSType(\n+              registry.createOptionalNullableType(getTypeOfThis()));\n+          params.addChildToFront(thisTypeNode);\n+          thisTypeNode.setOptionalArg(true);\n+\n+          defineDeclaredProperty(name,\n+              new FunctionBuilder(registry)\n+              .withParamsNode(params)\n+              .withReturnType(getReturnType())\n+              .build(),\n               source);\n         }\n-      }\n-\n-      return super.getPropertyType(name);\n-    }\n+      } else if (\"apply\".equals(name)) {\n+        // Define the \"apply\" function lazily.\n+        FunctionParamBuilder builder = new FunctionParamBuilder(registry);\n+\n+        // Ecma-262 says that apply's second argument must be an Array\n+        // or an arguments object. We don't model the arguments object,\n+        // so let's just be forgiving for now.\n+        // TODO(nicksantos): Model the Arguments object.\n+        builder.addOptionalParams(\n+            registry.createNullableType(getTypeOfThis()),\n+            registry.createNullableType(\n+                registry.getNativeType(JSTypeNative.OBJECT_TYPE)));\n+\n+        defineDeclaredProperty(name,\n+            new FunctionBuilder(registry)\n+            .withParams(builder)\n+            .withReturnType(getReturnType())\n+            .build(),\n+            source);\n+      }\n+    }\n+\n+    return super.getPropertyType(name);\n   }\n \n   @Override\n       }\n     }\n     return super.defineProperty(name, type, inferred, propertyNode);\n-  }\n-\n-  @Override\n-  public boolean isPropertyTypeInferred(String property) {\n-    return \"prototype\".equals(property) ||\n-        super.isPropertyTypeInferred(property);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n+++ b/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n \n package com.google.javascript.rhino.jstype;\n \n+import java.io.Serializable;\n+\n /**\n  * The minimum implementation of StaticSlot<JSType>.\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n-public class SimpleSlot implements StaticSlot<JSType> {\n+public class SimpleSlot implements StaticSlot<JSType>, Serializable {\n   final String name;\n   final JSType type;\n   final boolean inferred;\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n-\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n-\n \n /**\n  * Tests for FunctionTypes.\n     assertTrue(objReturnBoolean.canAssignTo(ifaceReturnBoolean));\n   }\n \n+  public void testOrdinaryFunctionPrototype() {\n+    FunctionType oneNumber = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters(NUMBER_TYPE))\n+        .withReturnType(BOOLEAN_TYPE).build();\n+    assertEquals(ImmutableSet.<String>of(), oneNumber.getOwnPropertyNames());\n+  }\n+\n   public void testCtorWithPrototypeSet() {\n     FunctionType ctor = registry.createConstructorType(\n         \"Foo\", null, null, null);\n     assertFalse(ctor.getInstanceType().isUnknownType());\n-    ctor.defineDeclaredProperty(\"prototype\", UNKNOWN_TYPE, null);\n+\n+    Node node = new Node(Token.OBJECTLIT);\n+    ctor.defineDeclaredProperty(\"prototype\", UNKNOWN_TYPE, node);\n     assertTrue(ctor.getInstanceType().isUnknownType());\n+\n+    assertEquals(ImmutableSet.<String>of(\"prototype\"),\n+        ctor.getOwnPropertyNames());\n+    assertTrue(ctor.isPropertyTypeInferred(\"prototype\"));\n+    assertTrue(ctor.getPropertyType(\"prototype\").isUnknownType());\n+\n+    // The node is not recorded.\n+    assertNull(ctor.getPropertyNode(\"prototype\"));\n   }\n \n   public void testEmptyFunctionTypes() {", "timestamp": 1314038294, "metainfo": ""}