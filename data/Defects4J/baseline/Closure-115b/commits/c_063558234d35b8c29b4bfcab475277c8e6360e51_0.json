{"sha": "063558234d35b8c29b4bfcab475277c8e6360e51", "log": "Move source map code to agree upon package name.  R=jschorr DELTA=7651  (3816 added, 3813 deleted, 22 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=760   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/FilePosition.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+/**\n+ * Represents a position in a source file.\n+ *\n+ */\n+/**\n+ * Represents a position in a source file.\n+ */\n+public class FilePosition {\n+  private final int line;\n+  private final int column;\n+\n+  public FilePosition(int line, int column) {\n+    this.line = line;\n+    this.column = column;\n+  }\n+\n+  /**\n+   * Returns the line number of this postion.\n+   */\n+  public int getLine() {\n+    return line;\n+  }\n+\n+  /**\n+   * Returns the character index on the line\n+   * of this position.\n+   */\n+  public int getColumn() {\n+    return column;\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapGenerator.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Collects information mapping the generated (compiled) source back to\n+ * its original source for debugging purposes\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public interface SourceMapGenerator {\n+\n+  public enum Format {\n+     LEGACY {\n+       @Override\n+       public SourceMapGenerator getInstance() {\n+         return new SourceMapGeneratorV1();\n+       }\n+     },\n+     EXPERIMENTIAL {\n+       @Override\n+       public SourceMapGenerator getInstance() {\n+         return new SourceMapGeneratorV2();\n+       }\n+     };\n+     public abstract SourceMapGenerator getInstance();\n+  }\n+\n+  /**\n+   * Appends the source map to the given buffer.\n+   *\n+   * @param out The stream to which the map will be appended.\n+   * @param name The name of the generated source file that this source map\n+   *   represents.\n+   */\n+  void appendTo(Appendable out, String name) throws IOException;\n+\n+  /**\n+   * Resets the source map for reuse. A reset needs to be called between\n+   * each generated output file.\n+   */\n+  void reset();\n+\n+  /**\n+   * Adds a mapping for the given node.  Mappings must be added in order.\n+   * @param sourceName The file name to use in the generate source map\n+   *     to represent this source.\n+   * @param symbolName The symbol name associated with this position in the\n+   *     source map.\n+   * @param sourceStartPosition The starting position in the original source for\n+   *     represented range outputStartPosition to outputEndPosition in the\n+   *     generated file.\n+   * @param outputStartPosition The position on the starting line\n+   * @param outputEndPosition The position on the ending line.\n+   */\n+  void addMapping(String sourceName, @Nullable String symbolName,\n+           FilePosition sourceStartPosition,\n+           FilePosition outputStartPosition, FilePosition outputEndPosition);\n+\n+  /**\n+   * Sets the prefix used for wrapping the generated source file before\n+   * it is written. This ensures that the source map is adjusted for the\n+   * change in character offsets.\n+   *\n+   * @param prefix The prefix that is added before the generated source code.\n+   */\n+  void setWrapperPrefix(String prefix);\n+\n+  /**\n+   * Sets the source code that exists in the buffer for which the\n+   * generated code is being generated. This ensures that the source map\n+   * accurately reflects the fact that the source is being appended to\n+   * an existing buffer and as such, does not start at line 0, position 0\n+   * but rather some other line and position.\n+   *\n+   * @param offsetLine The index of the current line being printed.\n+   * @param offsetIndex The column index of the current character being printed.\n+   */\n+  void setStartingPosition(int offsetLine, int offsetIndex);\n+\n+  /**\n+   * Whether to perform additional validation on the source map.\n+   * @param validate\n+   */\n+  void validate(boolean validate);\n+\n+  /**\n+   * @param out\n+   * @param name\n+   * @param appSections\n+   * @throws IOException\n+   */\n+  void writeMetaMap(\n+      Appendable out, String name, List<SourceMapSection> appSections)\n+      throws IOException;\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV1.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.List;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Collects information mapping the generated (compiled) source back to\n+ * its original source for debugging purposes.\n+ *\n+ */\n+public class SourceMapGeneratorV1 implements SourceMapGenerator {\n+\n+  private final static int UNMAPPED = -1;\n+\n+\n+  /**\n+   * A mapping from a given position in an input source file to a given position\n+   * in the generated code.\n+   */\n+  static class Mapping {\n+    /**\n+     * A unique ID for this mapping for record keeping purposes.\n+     */\n+    int id = UNMAPPED;\n+\n+    /**\n+     * The input source file.\n+     */\n+    String sourceFile;\n+\n+    /**\n+     * The position of the code in the input source file. Both\n+     * the line number and the character index are indexed by\n+     * 1 for legacy reasons via the Rhino Node class.\n+     */\n+    FilePosition originalPosition;\n+\n+    /**\n+     * The starting position of the code in the generated source\n+     * file which this mapping represents. Indexed by 0.\n+     */\n+    FilePosition startPosition;\n+\n+    /**\n+     * The ending position of the code in the generated source\n+     * file which this mapping represents. Indexed by 0.\n+     */\n+    FilePosition endPosition;\n+\n+    /**\n+     * The original name of the token found at the position\n+     * represented by this mapping (if any).\n+     */\n+    String originalName;\n+\n+    /**\n+     * Whether the mapping is actually used by the source map.\n+     */\n+    boolean used = false;\n+  }\n+\n+  private class MappingWriter {\n+    /**\n+     * Cache of escaped source file name.\n+     */\n+    private String lastSourceFile = null;\n+    private String lastSourceFileEscaped = null;\n+    private int lastLine = 0;\n+    private String lastLineString = String.valueOf(0);\n+\n+    /**\n+     * Appends the mapping to the given buffer.\n+     */\n+    private void appendMappingTo(\n+        Mapping m, Appendable out) throws IOException {\n+      out.append(\"[\");\n+\n+      String sourceFile = m.sourceFile;\n+      // The source file rarely changes, so cache the escaped string.\n+      String escapedSourceFile;\n+      if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2)\n+        lastSourceFile = sourceFile;\n+        lastSourceFileEscaped = escapeString(sourceFile);\n+      }\n+      escapedSourceFile = lastSourceFileEscaped;\n+\n+      out.append(escapedSourceFile);\n+      out.append(\",\");\n+\n+      int line = m.originalPosition.getLine();\n+      if (line != lastLine) {\n+        lastLineString = String.valueOf(line);\n+      }\n+      String lineValue = lastLineString;\n+\n+      out.append(lineValue);\n+\n+      out.append(\",\");\n+      out.append(String.valueOf(\n+          m.originalPosition.getColumn()));\n+\n+      if (m.originalName != null) {\n+        out.append(\",\");\n+        out.append(escapeString(m.originalName));\n+      }\n+\n+      out.append(\"]\\n\");\n+    }\n+\n+    /**\n+     * Add used mappings to the supplied Appendable.\n+     */\n+    void appendMappings(Appendable out) throws IOException {\n+      for (Mapping m : mappings) {\n+        if (m.used) {\n+          appendMappingTo(m, out);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A pre-order traversal ordered list of mappings stored in this map.\n+   */\n+  private List<Mapping> mappings = Lists.newArrayList();\n+\n+  /**\n+   * For validation store the start of the last mapping added.\n+   */\n+  private Mapping lastMapping;\n+\n+  /**\n+   * The position that the current source map is offset in the\n+   * buffer being used to generated the compiled source file.\n+   */\n+  private FilePosition offsetPosition = new FilePosition(0, 0);\n+\n+  /**\n+   * The position that the current source map is offset in the\n+   * generated the compiled source file by the addition of a\n+   * an output wrapper prefix.\n+   */\n+  private FilePosition prefixPosition = new FilePosition(0, 0);\n+\n+  /**\n+   * Escapes the given string for JSON.\n+   */\n+  private static String escapeString(String value) {\n+    return Util.escapeString(value);\n+  }\n+\n+  /**\n+   * Adds a mapping for the given node.  Mappings must be added in order.\n+   * @param startPosition The position on the starting line\n+   * @param endPosition The position on the ending line.\n+   */\n+  public void addMapping(\n+      String sourceName, @Nullable String symbolName,\n+      FilePosition sourceStartPosition,\n+      FilePosition startPosition, FilePosition endPosition) {\n+\n+    // Don't bother if there is not sufficient information to be useful.\n+    if (sourceName == null || sourceStartPosition.getLine() < 0) {\n+      return;\n+    }\n+\n+    // Create the new mapping.\n+    Mapping mapping = new Mapping();\n+    mapping.sourceFile = sourceName;\n+    mapping.originalPosition = sourceStartPosition;\n+    mapping.originalName = symbolName; // may be null\n+\n+    // NOTE: When multiple outputs are concatenated together, the positions in\n+    // the mapping are relative to offsetPosition.\n+    if (offsetPosition.getLine() == 0\n+        && offsetPosition.getColumn() == 0) {\n+      mapping.startPosition = startPosition;\n+      mapping.endPosition = endPosition;\n+    } else {\n+      // If the mapping is found on the first line, we need to offset\n+      // its character position by the number of characters found on\n+      // the *last* line of the source file to which the code is\n+      // being generated.\n+      int offsetLine = offsetPosition.getLine();\n+      int startOffsetPosition = offsetPosition.getColumn();\n+      int endOffsetPosition = offsetPosition.getColumn();\n+\n+      if (startPosition.getLine() > 0) {\n+        startOffsetPosition = 0;\n+      }\n+\n+      if (endPosition.getLine() > 0) {\n+        endOffsetPosition = 0;\n+      }\n+\n+      mapping.startPosition =\n+          new FilePosition(startPosition.getLine() + offsetLine,\n+                       startPosition.getColumn() + startOffsetPosition);\n+\n+      mapping.endPosition =\n+          new FilePosition(endPosition.getLine() + offsetLine,\n+                       endPosition.getColumn() + endOffsetPosition);\n+    }\n+\n+    // Validate the mappings are in a proper order.\n+    if (lastMapping != null) {\n+      int lastLine = lastMapping.startPosition.getLine();\n+      int lastColumn = lastMapping.startPosition.getColumn();\n+      int nextLine = mapping.startPosition.getLine();\n+      int nextColumn = mapping.startPosition.getColumn();\n+      Preconditions.checkState(nextLine > lastLine\n+          || (nextLine == lastLine && nextColumn >= lastColumn),\n+          \"Incorrect source mappings order, previous : (%s,%s)\\n\"\n+          + \"new : (%s,%s)\\nnode : %s\",\n+          lastLine, lastColumn, nextLine, nextColumn);\n+    }\n+\n+    lastMapping = mapping;\n+    mappings.add(mapping);\n+  }\n+\n+  /**\n+   * Sets the prefix used for wrapping the generated source file before\n+   * it is output. This ensures that the source map is adjusted as\n+   * needed.\n+   *\n+   * @param prefix The prefix that is added before the generated source code.\n+   */\n+  public void setWrapperPrefix(String prefix) {\n+    // Determine the current line and character position.\n+    int prefixLine = 0;\n+    int prefixIndex = 0;\n+\n+    for (int i = 0; i < prefix.length(); ++i) {\n+      if (prefix.charAt(i) == '\\n') {\n+        prefixLine++;\n+        prefixIndex = 0;\n+      } else {\n+        prefixIndex++;\n+      }\n+    }\n+\n+    prefixPosition = new FilePosition(prefixLine, prefixIndex);\n+  }\n+\n+  /**\n+   * Sets the source code that exists in the buffer to which the\n+   * generated code is being generated. This ensures that the source map\n+   * accurately reflects the fact that the source is being appended to\n+   * an existing buffer and as such, does not start at line 0, position 0\n+   * but rather some other line and position.\n+   *\n+   * @param offsetLine The index of the current line being printed.\n+   * @param offsetIndex The column index of the current character being printed.\n+   */\n+  public void setStartingPosition(int offsetLine, int offsetIndex) {\n+    Preconditions.checkState(offsetLine >= 0);\n+    Preconditions.checkState(offsetIndex >= 0);\n+    offsetPosition = new FilePosition(offsetLine, offsetIndex);\n+  }\n+\n+  /**\n+   * Resets the source map for reuse for the generation of a new source file.\n+   */\n+  public void reset() {\n+    mappings = Lists.newArrayList();\n+    lastMapping = null;\n+    offsetPosition = new FilePosition(0, 0);\n+    prefixPosition = new FilePosition(0, 0);\n+  }\n+\n+  /**\n+   * Appends the source map in LavaBug format to the given buffer.\n+   *\n+   * @param out The stream to which the map will be appended.\n+   * @param name The name of the generated source file that this source map\n+   *   represents.\n+   */\n+  public void appendTo(Appendable out, String name) throws IOException {\n+    // Write the mappings out to the file. The format of the generated\n+    // source map is three sections, each deliminated by a magic comment.\n+    //\n+    // The first section contains an array for each line of the generated\n+    // code, where each element in the array is the ID of the mapping which\n+    // best represents the index-th character found on that line of the\n+    // generated source code.\n+    //\n+    // The second section contains an array per generated line. Unused.\n+    //\n+    // The third and final section contains an array per line, each of which\n+    // represents a mapping with a unique ID. The mappings are added in order.\n+    // The array itself contains a tuple representing\n+    // ['source file', line, col (, 'original name')]\n+    //\n+    // Example for 2 lines of generated code (with line numbers added for\n+    // readability):\n+    //\n+    // 1)  /** Begin line maps. **/{ \"count\": 2 }\n+    // 2)  [0,0,0,0,0,0,1,1,1,1,2]\n+    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]\n+    // 4)  /** Begin file information. **/\n+    // 5)  []\n+    // 6)  []\n+    // 7)  /** Begin mapping definitions. **/\n+    // 8)  [\"a.js\", 1, 34]\n+    // 9)  [\"a.js\", 5, 2]\n+    // 10) [\"b.js\", 1, 3, \"event\"]\n+    // 11) [\"c.js\", 1, 4]\n+    // 12) [\"d.js\", 3, 78, \"foo\"]\n+\n+    int maxLine = prepMappings();\n+\n+    // Add the line character maps.\n+    out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n+    out.append(escapeString(name));\n+    out.append(\", \\\"count\\\": \");\n+    out.append(String.valueOf(maxLine + 1));\n+    out.append(\" }\\n\");\n+    (new LineMapper(out)).appendLineMappings();\n+\n+    // Add the source file maps.\n+    out.append(\"/** Begin file information. **/\\n\");\n+\n+    // This section is unused but we need one entry per line to\n+    // prevent changing the format.\n+    for (int i = 0; i <= maxLine; ++i) {\n+      out.append(\"[]\\n\");\n+    }\n+\n+    // Add the mappings themselves.\n+    out.append(\"/** Begin mapping definitions. **/\\n\");\n+\n+    (new MappingWriter()).appendMappings(out);\n+  }\n+\n+  /**\n+   * Assigns sequential ids to used mappings, and returns the last line mapped.\n+   */\n+  private int prepMappings() throws IOException {\n+    // Mark any unused mappings.\n+    (new MappingTraversal()).traverse(new UsedMappingCheck());\n+\n+    // Renumber used mappings and keep track of the last line.\n+    int id = 0;\n+    int maxLine = 0;\n+    for (Mapping m : mappings) {\n+      if (m.used) {\n+        m.id = id++;\n+        int endPositionLine = m.endPosition.getLine();\n+        maxLine = Math.max(maxLine, endPositionLine);\n+      }\n+    }\n+\n+    // Adjust for the prefix.\n+    return maxLine + prefixPosition.getLine();\n+  }\n+\n+  private class LineMapper implements MappingVisitor {\n+    // The destination.\n+    private final Appendable out;\n+\n+    // Whether the current line has had a value written yet.\n+    private boolean firstChar = true;\n+\n+    private final static String UNMAPPED_STRING = \"-1\";\n+\n+    private int lastId = UNMAPPED;\n+    private String lastIdString = UNMAPPED_STRING;\n+\n+    LineMapper(Appendable out) {\n+      this.out = out;\n+    }\n+\n+    /**\n+     * As each segment is visited write out the appropriate line mapping.\n+     */\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+      throws IOException {\n+\n+      int id = (m != null) ? m.id : UNMAPPED;\n+      if (lastId != id) {\n+        // Prevent the creation of unnecessary temporary stings for often\n+        // repeated values.\n+        lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n+        lastId = id;\n+      }\n+      String idString = lastIdString;\n+\n+      for (int i = line; i <= nextLine; i++) {\n+        if (i == nextLine) {\n+          for (int j = col; j < nextCol; j++) {\n+            addCharEntry(idString);\n+          }\n+          break;\n+        }\n+\n+        closeLine();\n+        openLine();\n+\n+        // Set the starting location for the next line.\n+        col = 0;\n+      }\n+    }\n+\n+    // Append the line mapping entries.\n+    void appendLineMappings() throws IOException {\n+      // Start the first line.\n+      openLine();\n+\n+      (new MappingTraversal()).traverse(this);\n+\n+      // And close the final line.\n+      closeLine();\n+    }\n+\n+    /**\n+     * Begin the entry for a new line.\n+     */\n+    private void openLine() throws IOException {\n+      if (out != null) {\n+        out.append(\"[\");\n+        this.firstChar = true;\n+      }\n+    }\n+\n+    /**\n+     * End the entry for a line.\n+     */\n+    private void closeLine() throws IOException {\n+      if (out != null) {\n+        out.append(\"]\\n\");\n+      }\n+    }\n+\n+    /**\n+     * Add a new char position entry.\n+     * @param id The mapping id to record.\n+     */\n+    private void addCharEntry(String id) throws IOException {\n+      if (out != null) {\n+        if (firstChar) {\n+          firstChar = false;\n+        } else {\n+          out.append(\",\");\n+        }\n+        out.append(id);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Mark any visited mapping as \"used\".\n+   */\n+  private class UsedMappingCheck implements MappingVisitor {\n+    /**\n+     * @throws IOException\n+     */\n+    @Override\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+        throws IOException {\n+      if (m != null) {\n+        m.used = true;\n+      }\n+    }\n+  }\n+\n+  private interface MappingVisitor {\n+    /**\n+     * @param m The mapping for the current code segment. null if the segment\n+     *     is unmapped.\n+     * @param line The starting line for this code segment.\n+     * @param col The starting column for this code segment.\n+     * @param endLine The ending line\n+     * @param endCol The ending column\n+     * @throws IOException\n+     */\n+    void visit(Mapping m, int line, int col, int endLine, int endCol)\n+        throws IOException;\n+  }\n+\n+  /**\n+   * Walk the mappings and visit each segment of the mappings, unmapped\n+   * segments are visited with a null mapping, unused mapping are not visited.\n+   */\n+  private class MappingTraversal {\n+    // The last line and column written\n+    private int line;\n+    private int col;\n+\n+    MappingTraversal() {\n+    }\n+\n+    // Append the line mapping entries.\n+    void traverse(MappingVisitor v) throws IOException {\n+      // The mapping list is ordered as a pre-order traversal.  The mapping\n+      // positions give us enough information to rebuild the stack and this\n+      // allows the building of the source map in O(n) time.\n+      Deque<Mapping> stack = new ArrayDeque<Mapping>();\n+      for (Mapping m : mappings) {\n+        // Find the closest ancestor of the current mapping:\n+        // An overlapping mapping is an ancestor of the current mapping, any\n+        // non-overlapping mappings are siblings (or cousins) and must be\n+        // closed in the reverse order of when they encountered.\n+        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n+          Mapping previous = stack.pop();\n+          maybeVisit(v, previous);\n+        }\n+\n+        // Any gaps between the current line position and the start of the\n+        // current mapping belong to the parent.\n+        Mapping parent = stack.peek();\n+        maybeVisitParent(v, parent, m);\n+\n+        stack.push(m);\n+      }\n+\n+      // There are no more children to be had, simply close the remaining\n+      // mappings in the reverse order of when they encountered.\n+      while (!stack.isEmpty()) {\n+        Mapping m = stack.pop();\n+        maybeVisit(v, m);\n+      }\n+    }\n+\n+    /**\n+     * @return The line adjusted for the prefix position.\n+     */\n+    private int getAdjustedLine(FilePosition p) {\n+      return p.getLine() + prefixPosition.getLine();\n+    }\n+\n+    /**\n+     * @return The column adjusted for the prefix position.\n+     */\n+    private int getAdjustedCol(FilePosition p) {\n+      int rawLine = p.getLine();\n+      int rawCol = p.getColumn();\n+      // Only the first line needs the character position adjusted.\n+      return (rawLine != 0)\n+          ? rawCol : rawCol + prefixPosition.getColumn();\n+    }\n+\n+    /**\n+     * @return Whether m1 ends before m2 starts.\n+     */\n+    private boolean isOverlapped(Mapping m1, Mapping m2) {\n+      // No need to use adjusted values here, relative positions are sufficient.\n+      int l1 = m1.endPosition.getLine();\n+      int l2 = m2.startPosition.getLine();\n+      int c1 = m1.endPosition.getColumn();\n+      int c2 = m2.startPosition.getColumn();\n+\n+      return (l1 == l2 && c1 >= c2) || l1 > l2;\n+    }\n+\n+    /**\n+     * Write any needed entries from the current position to the end of the\n+     * provided mapping.\n+     */\n+    private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {\n+      int nextLine = getAdjustedLine(m.endPosition);\n+      int nextCol = getAdjustedCol(m.endPosition);\n+      // If this anything remaining in this mapping beyond the\n+      // current line and column position, write it out now.\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        visit(v, m, nextLine, nextCol);\n+      }\n+    }\n+\n+    /**\n+     * Write any needed entries to complete the provided mapping.\n+     */\n+    private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m)\n+        throws IOException {\n+      int nextLine = getAdjustedLine(m.startPosition);\n+      int nextCol = getAdjustedCol(m.startPosition);\n+      // If the previous value is null, no mapping exists.\n+      Preconditions.checkState(line < nextLine || col <= nextCol);\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        visit(v, parent, nextLine, nextCol);\n+      }\n+    }\n+\n+    /**\n+     * Write any entries needed between the current position the next position\n+     * and update the current position.\n+     */\n+    private void visit(MappingVisitor v, Mapping m,\n+        int nextLine, int nextCol)\n+        throws IOException {\n+      Preconditions.checkState(line <= nextLine);\n+      Preconditions.checkState(line < nextLine || col < nextCol);\n+\n+      if (line == nextLine && col == nextCol) {\n+        // Nothing to do.\n+        Preconditions.checkState(false);\n+        return;\n+      }\n+\n+      v.visit(m, line, col, nextLine, nextCol);\n+\n+      line = nextLine;\n+      col = nextCol;\n+    }\n+  }\n+\n+  @Override\n+  public void validate(boolean validate) {\n+    // No additional validation to do.\n+  }\n+\n+  @Override\n+  public void writeMetaMap(\n+      Appendable out, String name, List<SourceMapSection> appSections) {\n+    throw new UnsupportedOperationException();\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV2.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map.Entry;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Collects information mapping the generated (compiled) source back to\n+ * its original source for debugging purposes.\n+ *\n+ */\n+public class SourceMapGeneratorV2 implements SourceMapGenerator {\n+\n+  private boolean validate = false;\n+\n+  private final static int UNMAPPED = -1;\n+\n+  /**\n+   *  A map used to convert integer values in the range 0-63 to their base64\n+   *  values.\n+   */\n+  private static final String BASE64_MAP =\n+      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n+      \"abcdefghijklmnopqrstuvwzyz\" +\n+      \"0123456789+/\";\n+\n+  /**\n+   * A pre-order traversal ordered list of mappings stored in this map.\n+   */\n+  private List<Mapping> mappings = Lists.newArrayList();\n+\n+  /**\n+   * A map of source names to source name index\n+   */\n+  private LinkedHashMap<String, Integer> sourceFileMap =\n+      Maps.newLinkedHashMap();\n+\n+  /**\n+   * Cache of the last mappings source name.\n+   */\n+  private String lastSourceFile = null;\n+\n+  /**\n+   * Cache of the last mappings source name index.\n+   */\n+  private int lastSourceFileIndex = -1;\n+\n+  /**\n+   * For validation store the last mapping added.\n+   */\n+  private Mapping lastMapping;\n+\n+  /**\n+   * The position that the current source map is offset in the\n+   * buffer being used to generated the compiled source file.\n+   */\n+  private FilePosition offsetPosition = new FilePosition(0, 0);\n+\n+  /**\n+   * The position that the current source map is offset in the\n+   * generated the compiled source file by the addition of a\n+   * an output wrapper prefix.\n+   */\n+  private FilePosition prefixPosition = new FilePosition(0, 0);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  public void reset() {\n+    mappings.clear();\n+    lastMapping = null;\n+    sourceFileMap.clear();\n+    lastSourceFile = null;\n+    lastSourceFileIndex = -1;\n+    offsetPosition = new FilePosition(0, 0);\n+    prefixPosition = new FilePosition(0, 0);\n+  }\n+\n+  /**\n+   * @param validate Whether to perform (potentially costly) validation on the\n+   * generated source map.\n+   */\n+  @VisibleForTesting\n+  public void validate(boolean validate) {\n+    this.validate = validate;\n+  }\n+\n+  /**\n+   * Sets the prefix used for wrapping the generated source file before\n+   * it is written. This ensures that the source map is adjusted for the\n+   * change in character offsets.\n+   *\n+   * @param prefix The prefix that is added before the generated source code.\n+   */\n+  public void setWrapperPrefix(String prefix) {\n+    // Determine the current line and character position.\n+    int prefixLine = 0;\n+    int prefixIndex = 0;\n+\n+    for (int i = 0; i < prefix.length(); ++i) {\n+      if (prefix.charAt(i) == '\\n') {\n+        prefixLine++;\n+        prefixIndex = 0;\n+      } else {\n+        prefixIndex++;\n+      }\n+    }\n+\n+    prefixPosition = new FilePosition(prefixLine, prefixIndex);\n+  }\n+\n+  /**\n+   * Sets the source code that exists in the buffer for which the\n+   * generated code is being generated. This ensures that the source map\n+   * accurately reflects the fact that the source is being appended to\n+   * an existing buffer and as such, does not start at line 0, position 0\n+   * but rather some other line and position.\n+   *\n+   * @param offsetLine The index of the current line being printed.\n+   * @param offsetIndex The column index of the current character being printed.\n+   */\n+  public void setStartingPosition(int offsetLine, int offsetIndex) {\n+    Preconditions.checkState(offsetLine >= 0);\n+    Preconditions.checkState(offsetIndex >= 0);\n+    offsetPosition = new FilePosition(offsetLine, offsetIndex);\n+  }\n+\n+  /**\n+   * Adds a mapping for the given node.  Mappings must be added in order.\n+   * @param startPosition The position on the starting line\n+   * @param endPosition The position on the ending line.\n+   */\n+  public void addMapping(\n+      String sourceName, @Nullable String symbolName,\n+      FilePosition sourceStartPosition,\n+      FilePosition startPosition, FilePosition endPosition) {\n+\n+    // Don't bother if there is not sufficient information to be useful.\n+    if (sourceName == null || sourceStartPosition.getLine() < 0) {\n+      return;\n+    }\n+\n+    if (sourceName != lastSourceFile) {\n+      lastSourceFile = sourceName;\n+      Integer index = sourceFileMap.get(sourceName);\n+      if (index != null) {\n+        lastSourceFileIndex = index;\n+      } else {\n+        lastSourceFileIndex = sourceFileMap.size();\n+        sourceFileMap.put(sourceName, lastSourceFileIndex);\n+      }\n+    }\n+\n+    FilePosition adjustedStart = startPosition;\n+    FilePosition adjustedEnd = endPosition;\n+\n+    if (offsetPosition.getLine() != 0\n+        || offsetPosition.getColumn() != 0) {\n+      // If the mapping is found on the first line, we need to offset\n+      // its character position by the number of characters found on\n+      // the *last* line of the source file to which the code is\n+      // being generated.\n+      int offsetLine = offsetPosition.getLine();\n+      int startOffsetPosition = offsetPosition.getColumn();\n+      int endOffsetPosition = offsetPosition.getColumn();\n+\n+      if (startPosition.getLine() > 0) {\n+        startOffsetPosition = 0;\n+      }\n+\n+      if (endPosition.getLine() > 0) {\n+        endOffsetPosition = 0;\n+      }\n+\n+      adjustedStart = new FilePosition(\n+          startPosition.getLine() + offsetLine,\n+          startPosition.getColumn() + startOffsetPosition);\n+\n+      adjustedEnd = new FilePosition(\n+          endPosition.getLine() + offsetLine,\n+          endPosition.getColumn() + endOffsetPosition);\n+    }\n+\n+    // Create the new mapping.\n+    Mapping mapping = new Mapping();\n+    mapping.sourceFile = lastSourceFileIndex;\n+    mapping.originalPosition = sourceStartPosition;\n+    mapping.originalName = symbolName;\n+    mapping.startPosition = adjustedStart;\n+    mapping.endPosition = adjustedEnd;\n+\n+    // Validate the mappings are in a proper order.\n+    if (lastMapping != null) {\n+      int lastLine = lastMapping.startPosition.getLine();\n+      int lastColumn = lastMapping.startPosition.getColumn();\n+      int nextLine = mapping.startPosition.getLine();\n+      int nextColumn = mapping.startPosition.getColumn();\n+      Preconditions.checkState(nextLine > lastLine\n+          || (nextLine == lastLine && nextColumn >= lastColumn),\n+          \"Incorrect source mappings order, previous : (%s,%s)\\n\"\n+          + \"new : (%s,%s)\\nnode : %s\",\n+          lastLine, lastColumn, nextLine, nextColumn);\n+    }\n+\n+    lastMapping = mapping;\n+    mappings.add(mapping);\n+  }\n+\n+  /**\n+   * Writes out the source map in the following format (line numbers are for\n+   * reference only and are not part of the format):\n+   *\n+   * 1.  {\n+   * 2.    version: 2,\n+   * 3.    file: \u201cout.js\u201d\n+   * 4.    lineCount: 2\n+   * 5.    lineMaps: [\n+   * 6.        \"ABAAA\",\n+   * 7.        \"ABAA\"\n+   * 8.     ],\n+   * 9.    sourceRoot: \"\",\n+   * 10.   sources: [\"foo.js\", \"bar.js\"],\n+   * 11.   names: [\"src\", \"maps\", \"are\", \"fun\"],\n+   * 12.   mappings: [\n+   * 13.       [1, 1, 2, 4],\n+   * 14.       [2, 1, 2, \"yack\"],\n+   * 15.   ],\n+   * 16.  }\n+   *\n+   * Line 1: The entire file is a single JSON object\n+   * Line 2: File revision (always the first entry in the object)\n+   * Line 3: The name of the file that this source map is associated with.\n+   * Line 4: The number of lines represented in the sourcemap.\n+   * Line 5: \u201clineMaps\u201d field is a JSON array, where each entry represents a\n+   *     line in the generated text.\n+   * Line 6: A line entry, representing a series of line segments, where each\n+   *     segment encodes an mappings-id and repetition count.\n+   * Line 9: An optional source root, useful for relocating source files on a\n+   *     server or removing repeated prefix values in the \u201csources\u201d entry.\n+   * Line 10: A list of sources used by the \u201cmappings\u201d entry relative to the\n+   *     sourceRoot.\n+   * Line 11: A list of symbol names used by the \u201cmapping\u201d entry.  This list\n+   *     may be incomplete.\n+   * Line 12: The mappings field.\n+   * Line 13: Each entry represent a block of text in the original source, and\n+   *     consists four fields:\n+   *     The source file name\n+   *     The line in the source file the text begins\n+   *     The column in the line that the text begins\n+   *     An optional name (from the original source) that this entry represents.\n+   *     This can either be an string or index into the \u201cnames\u201d field.\n+   */\n+  public void appendTo(Appendable out, String name) throws IOException {\n+    int maxLine = prepMappings();\n+\n+    // Add the header fields.\n+    out.append(\"{\\n\");\n+    appendFirstField(out, \"version\", \"2\");\n+    appendField(out, \"file\", escapeString(name));\n+    appendField(out, \"lineCount\", String.valueOf(maxLine + 1));\n+\n+    // Add the line character maps.\n+    appendFieldStart(out, \"lineMaps\");\n+    out.append(\"[\");\n+    (new LineMapper(out)).appendLineMappings();\n+    out.append(\"]\");\n+    appendFieldEnd(out);\n+\n+    // Files names\n+    appendFieldStart(out, \"sources\");\n+    out.append(\"[\");\n+    addSourceNameMap(out);\n+    out.append(\"]\");\n+    appendFieldEnd(out);\n+\n+    // Add the mappings themselves.\n+    appendFieldStart(out, \"mappings\");\n+    out.append(\"[\");\n+    (new MappingWriter()).appendMappings(out);\n+    out.append(\"]\");\n+    appendFieldEnd(out);\n+\n+    out.append(\"\\n}\\n\");\n+  }\n+\n+  /**\n+   * Writes the source name map to 'out'.\n+   */\n+  private void addSourceNameMap(Appendable out) throws IOException {\n+    int i = 0;\n+    for (Entry<String, Integer> entry : sourceFileMap.entrySet()) {\n+      String key = entry.getKey();\n+      if (i != 0) {\n+        out.append(\",\");\n+      }\n+      out.append(\"\\\"\");\n+      out.append(key);\n+      out.append(\"\\\"\");\n+      i++;\n+    }\n+  }\n+\n+  /**\n+   * Escapes the given string for JSON.\n+   */\n+  private static String escapeString(String value) {\n+    return Util.escapeString(value);\n+  }\n+\n+  // Source map field helpers.\n+\n+  private static void appendFirstField(\n+      Appendable out, String name, String value)\n+      throws IOException {\n+    out.append(\"\\\"\");\n+    out.append(name);\n+    out.append(\"\\\"\");\n+    out.append(\":\");\n+    out.append(value);\n+  }\n+\n+  private static void appendField(Appendable out, String name, String value)\n+      throws IOException {\n+    out.append(\",\\n\");\n+    out.append(\"\\\"\");\n+    out.append(name);\n+    out.append(\"\\\"\");\n+    out.append(\":\");\n+    out.append(value);\n+  }\n+\n+  private static void appendFieldStart(Appendable out, String name)\n+      throws IOException {\n+    appendField(out, name, \"\");\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  private static void appendFieldEnd(Appendable out)\n+     throws IOException {\n+  }\n+\n+  /**\n+   * Assigns sequential ids to used mappings, and returns the last line mapped.\n+   */\n+  private int prepMappings() throws IOException {\n+    // Mark any unused mappings.\n+    (new MappingTraversal()).traverse(new UsedMappingCheck());\n+\n+    // Renumber used mappings and keep track of the last line.\n+    int id = 0;\n+    int maxLine = 0;\n+    for (Mapping m : mappings) {\n+      if (m.used) {\n+        m.id = id++;\n+        int endPositionLine = m.endPosition.getLine();\n+        maxLine = Math.max(maxLine, endPositionLine);\n+      }\n+    }\n+\n+    // Adjust for the prefix.\n+    return maxLine + prefixPosition.getLine();\n+  }\n+\n+  /**\n+   * A mapping from a given position in an input source file to a given position\n+   * in the generated code.\n+   */\n+  static class Mapping {\n+    /**\n+     * A unique ID for this mapping for record keeping purposes.\n+     */\n+    int id = UNMAPPED;\n+\n+    /**\n+     * The source file index.\n+     */\n+    int sourceFile;\n+\n+    /**\n+     * The position of the code in the input source file. Both\n+     * the line number and the character index are indexed by\n+     * 1 for legacy reasons via the Rhino Node class.\n+     */\n+    FilePosition originalPosition;\n+\n+    /**\n+     * The starting position of the code in the generated source\n+     * file which this mapping represents. Indexed by 0.\n+     */\n+    FilePosition startPosition;\n+\n+    /**\n+     * The ending position of the code in the generated source\n+     * file which this mapping represents. Indexed by 0.\n+     */\n+    FilePosition endPosition;\n+\n+    /**\n+     * The original name of the token found at the position\n+     * represented by this mapping (if any).\n+     */\n+    String originalName;\n+\n+    /**\n+     * Whether the mapping is actually used by the source map.\n+     */\n+    boolean used = false;\n+  }\n+\n+  private class MappingWriter {\n+    /**\n+     * Cache of escaped source file name.\n+     */\n+    private int lastLine = 0;\n+    private String lastLineString = String.valueOf(0);\n+\n+    /**\n+     * Appends the mapping to the given buffer.\n+     */\n+    private void appendMappingTo(\n+        Mapping m, Appendable out) throws IOException {\n+      out.append(\"[\");\n+\n+      out.append(String.valueOf(m.sourceFile));\n+      out.append(\",\");\n+\n+      int line = m.originalPosition.getLine();\n+      if (line != lastLine) {\n+        lastLineString = String.valueOf(line);\n+      }\n+      String lineValue = lastLineString;\n+\n+      out.append(lineValue);\n+\n+      out.append(\",\");\n+      out.append(String.valueOf(\n+          m.originalPosition.getColumn()));\n+\n+      if (m.originalName != null) {\n+        out.append(\",\");\n+        out.append(escapeString(m.originalName));\n+      }\n+\n+      out.append(\"],\\n\");\n+    }\n+\n+    /**\n+     * Add used mappings to the supplied Appendable.\n+     */\n+    void appendMappings(Appendable out) throws IOException {\n+      for (Mapping m : mappings) {\n+        if (m.used) {\n+          appendMappingTo(m, out);\n+        }\n+      }\n+    }\n+  }\n+\n+  private class LineMapper implements MappingVisitor {\n+    // The destination.\n+    private final Appendable out;\n+\n+    // Whether the current line has had a value written yet.\n+    private int lastId = UNMAPPED;\n+\n+    LineMapper(Appendable out) {\n+      this.out = out;\n+    }\n+\n+    /**\n+     * As each segment is visited write out the appropriate line mapping.\n+     */\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+      throws IOException {\n+\n+      int id = (m != null) ? m.id : UNMAPPED;\n+\n+      for (int i = line; i <= nextLine; i++) {\n+        if (i == nextLine) {\n+          closeEntry(id, nextCol-col);\n+          break;\n+        }\n+\n+        closeLine(false);\n+        openLine();\n+\n+        // Set the starting location for the next line.\n+        col = 0;\n+      }\n+    }\n+\n+    // Append the line mapping entries.\n+    void appendLineMappings() throws IOException {\n+      // Start the first line.\n+      openLine();\n+\n+      (new MappingTraversal()).traverse(this);\n+\n+      // And close the final line.\n+      closeLine(true);\n+    }\n+\n+    /**\n+     * Begin the entry for a new line.\n+     */\n+    private void openLine() throws IOException {\n+      out.append(\"\\\"\");\n+      // The first id of the line is not relative.\n+      this.lastId = 0;\n+    }\n+\n+    /**\n+     * End the entry for a line.\n+     */\n+    private void closeLine(boolean finalEntry) throws IOException {\n+      if (finalEntry) {\n+        out.append(\"\\\"\");\n+      } else {\n+        out.append(\"\\\",\\n\");\n+      }\n+    }\n+\n+    private void closeEntry(int id, int reps) throws IOException {\n+      if (reps == 0) {\n+        return;\n+      }\n+\n+      StringBuilder sb = new StringBuilder();\n+      LineMapEncoder.encodeEntry(sb, id, lastId, reps);\n+\n+      if (validate) {\n+        LineMapDecoder.LineEntry entry = LineMapDecoder.decodeLineEntry(\n+            sb.toString(), lastId);\n+        Preconditions.checkState(entry.id == id && entry.reps == reps,\n+            \"expected (%s,%s) but got (%s,%s)\",\n+            id, reps, entry.id, entry.reps);\n+      }\n+\n+      out.append(sb);\n+      lastId = id;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public static class LineMapEncoder {\n+    /**\n+     * The source map line map is consists of a series of entries each\n+     * representing a map entry and a repetition count of that entry.\n+     *\n+     * @param out The entry destination.\n+     * @param id  The id for the entry.\n+     * @param lastId The previous id written, used to generate a relative\n+     *     map id.\n+     * @param reps The number of times the id is repeated in the map.\n+     * @throws IOException\n+     */\n+    public static void encodeEntry(Appendable out, int id, int lastId, int reps)\n+        throws IOException {\n+      Preconditions.checkState(reps > 0);\n+      int relativeIdLength = getRelativeMappingIdLength(id, lastId);\n+      int relativeId = getRelativeMappingId(id, relativeIdLength, lastId);\n+\n+      String relativeIdString = valueToBase64(relativeId, relativeIdLength);\n+\n+      // If we can, we use a single base64 digit to encode both the id length\n+      // and the repetition count.  The current best division of the base64\n+      // digit (which has 6 bits) is 2 bits for the id length (1-4 digits) and\n+      // 4 bit for the repetition count (1-16 repetitions).  If either of these\n+      // two values are exceeded a \"!\" is written (a non-base64 character) to\n+      // signal the a full base64 character is used for repetition count and\n+      // the mapping id length.  As the repetition count can exceed 64, we\n+      // allow the \"escape\" (\"!\") to be repeated to signal additional\n+      // repetition count length characters.  It is extremely unlikely that\n+      // mapping id length will exceed 64 base64 characters in length so\n+      // additional \"!\" don't signal additional id length characters.\n+      if (reps > 16 || relativeIdLength > 4) {\n+        String repsString = valueToBase64(reps -1, 1);\n+        for (int i = 0; i < repsString.length(); i++) {\n+          // TODO(johnlenz): update this to whatever is agreed to.\n+          out.append('!');\n+        }\n+        String sizeId = valueToBase64(relativeIdString.length() -1, 1);\n+\n+        out.append(sizeId);\n+        out.append(repsString);\n+      } else {\n+        int prefix = ((reps -1) << 2) + (relativeIdString.length() -1);\n+        Preconditions.checkState(prefix < 64 && prefix >= 0,\n+            \"prefix (%s) reps(%s) map id size(%s)\",\n+            prefix, reps, relativeIdString.length());\n+        out.append(valueToBase64(prefix, 1));\n+      }\n+      out.append(relativeIdString);\n+    }\n+\n+    /**\n+     * @param idLength the length relative id, when encoded in as a base64\n+     *     value. @see #getRelativeMappingIdLength\n+     * @return A value relative to the the lastId.  Negative value are\n+     * represented as a two-complement value.\n+     */\n+    public static int getRelativeMappingId(int id, int idLength, int lastId) {\n+      int base = 1 << (idLength *6);\n+      int relativeId = id - lastId;\n+      return (relativeId < 0) ? relativeId + base : relativeId;\n+    }\n+\n+    /**\n+     * @return The length of the base64 number needed to include the id.\n+     */\n+    public static int getRelativeMappingIdLength(int rawId, int lastId) {\n+      Preconditions.checkState(rawId >= 0 || rawId == UNMAPPED);\n+      int relativeId = rawId - lastId;\n+      int id = (relativeId < 0 ? Math.abs(relativeId) -1 : relativeId) << 1;\n+      int digits = 1;\n+      int base = 64;\n+      while (id >= base) {\n+        digits++;\n+        base *= 64;\n+      }\n+      return digits;\n+    }\n+\n+    /**\n+     * @return return the base64 number encoding the provided value,\n+     *    padded if necessary to create a number with the given minimum length.\n+     */\n+    static String valueToBase64(int value, int minimumSize) {\n+      int size = 0;\n+      char chars[] = new char[4];\n+      do {\n+        int charValue = value & 63; // base64 chars\n+        value = value >>> 6; // get the next value;\n+        chars[size++] = BASE64_MAP.charAt(charValue);\n+      } while (value > 0);\n+\n+      StringBuilder sb = new StringBuilder(size);\n+\n+      while (minimumSize > size) {\n+        sb.append(BASE64_MAP.charAt(0));\n+        minimumSize--;\n+      }\n+      while (size > 0) {\n+        sb.append(chars[--size]);\n+      }\n+      return sb.toString();\n+    }\n+  }\n+\n+  /**\n+   * A line mapping decoder class used for testing and validation.\n+   */\n+  @VisibleForTesting\n+  public static class LineMapDecoder {\n+    private static LineEntry decodeLineEntry(String in, int lastId) {\n+      return decodeLineEntry(new StringParser(in), lastId);\n+    }\n+\n+    private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n+      int repDigits = 0;\n+\n+      // Determine the number of digits used for the repetition count.\n+      // Each \"!\" indicates another base64 digit.\n+      for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n+        repDigits++;\n+        reader.next(); // consume the \"!\"\n+      }\n+\n+      int idDigits = 0;\n+      int reps = 0;\n+      if (repDigits == 0) {\n+        // No repetition digit escapes, so the next character represents the\n+        // number of digits in the id (bottom 2 bits) and the number of\n+        // repetitions (top 4 digits).\n+        char digit = reader.next();\n+        int value = addBase64Digit(digit, 0);\n+        reps = (value >> 2);\n+        idDigits = (value & 3);\n+      } else {\n+        char digit = reader.next();\n+        idDigits = addBase64Digit(digit, 0);\n+\n+        int value = 0;\n+        for (int i = 0; i < repDigits; i++) {\n+          digit = reader.next();\n+          value = addBase64Digit(digit, value);\n+        }\n+        reps = value;\n+      }\n+\n+      // Adjust for 1 offset encoding.\n+      reps += 1;\n+      idDigits += 1;\n+\n+      // Decode the id token.\n+      int value = 0;\n+      for (int i = 0; i < idDigits; i++) {\n+        char digit = reader.next();\n+        value = addBase64Digit(digit, value);\n+      }\n+      int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n+      return new LineEntry(mappingId, reps);\n+    }\n+\n+    public static List<Integer> decodeLine(String lineSource) {\n+      return decodeLine(new StringParser(lineSource));\n+    }\n+\n+    static private List<Integer> decodeLine(StringParser reader) {\n+      List<Integer> result = Lists.newArrayListWithCapacity(512);\n+      int lastId = 0;\n+      while (reader.hasNext()) {\n+        LineEntry entry = decodeLineEntry(reader, lastId);\n+        lastId = entry.id;\n+\n+        for (int i=0; i < entry.reps; i++) {\n+          result.add(entry.id);\n+        }\n+      }\n+\n+      return result;\n+    }\n+\n+    /**\n+     * Build base64 number a digit at a time, most significant digit first.\n+     */\n+    private static int addBase64Digit(char digit, int previousValue) {\n+      return (previousValue * 64) + BASE64_MAP.indexOf(digit);\n+    }\n+\n+    /**\n+     * @return the id from the relative id.\n+     */\n+    public static int getIdFromRelativeId(int rawId, int digits, int lastId) {\n+      // The value range depends on the number of digits\n+      int base = 1 << (digits * 6);\n+      return ((rawId >= base/2) ? rawId - base : rawId) + lastId;\n+      // return (rawId - (base/2)) + lastId;\n+    }\n+\n+    static class LineEntry {\n+      final int id;\n+      final int reps;\n+      public LineEntry(int id, int reps) {\n+        this.id = id;\n+        this.reps = reps;\n+      }\n+    }\n+\n+    /**\n+     * A simple class for maintaining the current location\n+     * in the input.\n+     */\n+    static class StringParser {\n+      final String content;\n+      int current = 0;\n+\n+      StringParser(String content) {\n+        this.content = content;\n+      }\n+\n+      char next() {\n+        return content.charAt(current++);\n+      }\n+\n+      char peek() {\n+        return content.charAt(current);\n+      }\n+\n+      boolean hasNext() {\n+        return  current < content.length() -1;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Mark any visited mapping as \"used\".\n+   */\n+  private class UsedMappingCheck implements MappingVisitor {\n+    /**\n+     * @throws IOException\n+     */\n+    @Override\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+        throws IOException {\n+      if (m != null) {\n+        m.used = true;\n+      }\n+    }\n+  }\n+\n+  private interface MappingVisitor {\n+    /**\n+     * @param m The mapping for the current code segment. null if the segment\n+     *     is unmapped.\n+     * @param line The starting line for this code segment.\n+     * @param col The starting column for this code segment.\n+     * @param endLine The ending line\n+     * @param endCol The ending column\n+     * @throws IOException\n+     */\n+    void visit(Mapping m, int line, int col, int endLine, int endCol)\n+        throws IOException;\n+  }\n+\n+  /**\n+   * Walk the mappings and visit each segment of the mappings, unmapped\n+   * segments are visited with a null mapping, unused mapping are not visited.\n+   */\n+  private class MappingTraversal {\n+    // The last line and column written\n+    private int line;\n+    private int col;\n+\n+    MappingTraversal() {\n+    }\n+\n+    // Append the line mapping entries.\n+    void traverse(MappingVisitor v) throws IOException {\n+      // The mapping list is ordered as a pre-order traversal.  The mapping\n+      // positions give us enough information to rebuild the stack and this\n+      // allows the building of the source map in O(n) time.\n+      Deque<Mapping> stack = new ArrayDeque<Mapping>();\n+      for (Mapping m : mappings) {\n+        // Find the closest ancestor of the current mapping:\n+        // An overlapping mapping is an ancestor of the current mapping, any\n+        // non-overlapping mappings are siblings (or cousins) and must be\n+        // closed in the reverse order of when they encountered.\n+        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n+          Mapping previous = stack.pop();\n+          maybeVisit(v, previous);\n+        }\n+\n+        // Any gaps between the current line position and the start of the\n+        // current mapping belong to the parent.\n+        Mapping parent = stack.peek();\n+        maybeVisitParent(v, parent, m);\n+\n+        stack.push(m);\n+      }\n+\n+      // There are no more children to be had, simply close the remaining\n+      // mappings in the reverse order of when they encountered.\n+      while (!stack.isEmpty()) {\n+        Mapping m = stack.pop();\n+        maybeVisit(v, m);\n+      }\n+    }\n+\n+    /**\n+     * @return The line adjusted for the prefix position.\n+     */\n+    private int getAdjustedLine(FilePosition p) {\n+      return p.getLine() + prefixPosition.getLine();\n+    }\n+\n+    /**\n+     * @return The column adjusted for the prefix position.\n+     */\n+    private int getAdjustedCol(FilePosition p) {\n+      int rawLine = p.getLine();\n+      int rawCol = p.getColumn();\n+      // Only the first line needs the character position adjusted.\n+      return (rawLine != 0)\n+          ? rawCol : rawCol + prefixPosition.getColumn();\n+    }\n+\n+    /**\n+     * @return Whether m1 ends before m2 starts.\n+     */\n+    private boolean isOverlapped(Mapping m1, Mapping m2) {\n+      // No need to use adjusted values here, relative positions are sufficient.\n+      int l1 = m1.endPosition.getLine();\n+      int l2 = m2.startPosition.getLine();\n+      int c1 = m1.endPosition.getColumn();\n+      int c2 = m2.startPosition.getColumn();\n+\n+      return (l1 == l2 && c1 >= c2) || l1 > l2;\n+    }\n+\n+    /**\n+     * Write any needed entries from the current position to the end of the\n+     * provided mapping.\n+     */\n+    private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {\n+      int nextLine = getAdjustedLine(m.endPosition);\n+      int nextCol = getAdjustedCol(m.endPosition);\n+      // If this anything remaining in this mapping beyond the\n+      // current line and column position, write it out now.\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        visit(v, m, nextLine, nextCol);\n+      }\n+    }\n+\n+    /**\n+     * Write any needed entries to complete the provided mapping.\n+     */\n+    private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m)\n+        throws IOException {\n+      int nextLine = getAdjustedLine(m.startPosition);\n+      int nextCol = getAdjustedCol(m.startPosition);\n+      // If the previous value is null, no mapping exists.\n+      Preconditions.checkState(line < nextLine || col <= nextCol);\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        visit(v, parent, nextLine, nextCol);\n+      }\n+    }\n+\n+    /**\n+     * Write any entries needed between the current position the next position\n+     * and update the current position.\n+     */\n+    private void visit(MappingVisitor v, Mapping m,\n+        int nextLine, int nextCol)\n+        throws IOException {\n+      Preconditions.checkState(line <= nextLine);\n+      Preconditions.checkState(line < nextLine || col < nextCol);\n+\n+      if (line == nextLine && col == nextCol) {\n+        // Nothing to do.\n+        Preconditions.checkState(false);\n+        return;\n+      }\n+\n+      v.visit(m, line, col, nextLine, nextCol);\n+\n+      line = nextLine;\n+      col = nextCol;\n+    }\n+  }\n+\n+  /**\n+   * To facilitate incremental compiles, create a source map that is built\n+   * piecemeal from other source maps.\n+   * @throws IOException\n+   */\n+  @Override\n+  public void writeMetaMap(\n+      Appendable out, String name, List<SourceMapSection> appSections)\n+      throws IOException {\n+    // Add the header fields.\n+    out.append(\"{\\n\");\n+    appendFirstField(out, \"version\", \"2\");\n+    appendField(out, \"file\", escapeString(name));\n+\n+    // Add the line character maps.\n+    appendFieldStart(out, \"sections\");\n+    out.append(\"[\\n\");\n+    boolean first = true;\n+    Long offset = new Long(0);\n+    for (SourceMapSection section : appSections) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        out.append(\",\\n\");\n+      }\n+      out.append(\"{\\n\");\n+      appendFirstField(out, \"offset\", offset.toString());\n+      appendField(out, \"file\", escapeString(section.getSectionUrl()));\n+      out.append(\"\\n}\");\n+\n+      offset += section.getLength();\n+    }\n+\n+    out.append(\"\\n]\");\n+    appendFieldEnd(out);\n+\n+    out.append(\"\\n}\\n\");\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapSection.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+/**\n+ * A class representing a partial source map.\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class SourceMapSection {\n+\n+  /**\n+   * A url for a valid source map file that represents a section of a generate\n+   * source file such as when multiple files are concatenated together.\n+   */\n+  private final String sectionUrl;\n+  private final long representedLength;\n+\n+  /**\n+   * @param sectionUrl The url for the partial sourcemap\n+   * @param length The number of character represented by the source\n+   * map section.\n+   */\n+  public SourceMapSection(String sectionUrl, long length) {\n+    this.sectionUrl = sectionUrl;\n+    this.representedLength = length;\n+  }\n+\n+  /**\n+   * @return the name\n+   */\n+  public String getSectionUrl() {\n+    return sectionUrl;\n+  }\n+\n+  /**\n+   * @return the length\n+   */\n+  public long getLength() {\n+    return representedLength;\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/Util.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.debugging.sourcemap;\n+\n+import java.io.IOException;\n+import java.nio.charset.CharsetEncoder;\n+\n+/**\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+class Util {\n+\n+  private static final char[] HEX_CHARS\n+      = { '0', '1', '2', '3', '4', '5', '6', '7',\n+          '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n+\n+  /**\n+   * Escapes the given string to a double quoted (\") JavaScript/JSON string\n+   */\n+  static String escapeString(String s) {\n+    return escapeString(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);\n+  }\n+\n+  /** Helper to escape javascript string as well as regular expression */\n+  static String escapeString(String s, char quote,\n+                          String doublequoteEscape,\n+                          String singlequoteEscape,\n+                          String backslashEscape,\n+                          CharsetEncoder outputCharsetEncoder) {\n+    StringBuilder sb = new StringBuilder(s.length() + 2);\n+    sb.append(quote);\n+    for (int i = 0; i < s.length(); i++) {\n+      char c = s.charAt(i);\n+      switch (c) {\n+        case '\\n': sb.append(\"\\\\n\"); break;\n+        case '\\r': sb.append(\"\\\\r\"); break;\n+        case '\\t': sb.append(\"\\\\t\"); break;\n+        case '\\\\': sb.append(backslashEscape); break;\n+        case '\\\"': sb.append(doublequoteEscape); break;\n+        case '\\'': sb.append(singlequoteEscape); break;\n+        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n+          if (i >= 2 &&\n+              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n+               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n+            sb.append(\"\\\\>\");\n+          } else {\n+            sb.append(c);\n+          }\n+          break;\n+        case '<':\n+          // Break </script into <\\/script\n+          final String END_SCRIPT = \"/script\";\n+\n+          // Break <!-- into <\\!--\n+          final String START_COMMENT = \"!--\";\n+\n+          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n+                              END_SCRIPT.length())) {\n+            sb.append(\"<\\\\\");\n+          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n+                                     START_COMMENT.length())) {\n+            sb.append(\"<\\\\\");\n+          } else {\n+            sb.append(c);\n+          }\n+          break;\n+        default:\n+          // If we're given an outputCharsetEncoder, then check if the\n+          //  character can be represented in this character set.\n+          if (outputCharsetEncoder != null) {\n+            if (outputCharsetEncoder.canEncode(c)) {\n+              sb.append(c);\n+            } else {\n+              // Unicode-escape the character.\n+              appendCharAsHex(sb, c);\n+            }\n+          } else {\n+            // No charsetEncoder provided - pass straight latin characters\n+            // through, and escape the rest.  Doing the explicit character\n+            // check is measurably faster than using the CharsetEncoder.\n+            if (c > 0x1f && c <= 0x7f) {\n+              sb.append(c);\n+            } else {\n+              // Other characters can be misinterpreted by some js parsers,\n+              // or perhaps mangled by proxies along the way,\n+              // so we play it safe and unicode escape them.\n+              appendCharAsHex(sb, c);\n+            }\n+          }\n+      }\n+    }\n+    sb.append(quote);\n+    return sb.toString();\n+  }\n+\n+  /**\n+   * @see #appendHexJavaScriptRepresentation(Appendable, int)\n+   */\n+  @SuppressWarnings(\"cast\")\n+  private static void appendCharAsHex(\n+      StringBuilder sb, char c) {\n+    try {\n+      appendHexJavaScriptRepresentation(sb, (int)c);\n+    } catch (IOException ex) {\n+      // StringBuilder does not throw IOException.\n+      throw new RuntimeException(ex);\n+    }\n+  }\n+\n+  /**\n+   * Returns a javascript representation of the character in a hex escaped\n+   * format.\n+   * @param out The buffer to which the hex representation should be appended.\n+   * @param codePoint The codepoint to append.\n+   */\n+  private static void appendHexJavaScriptRepresentation(\n+      Appendable out, int codePoint)\n+      throws IOException {\n+    if (Character.isSupplementaryCodePoint(codePoint)) {\n+      // Handle supplementary unicode values which are not representable in\n+      // javascript.  We deal with these by escaping them as two 4B sequences\n+      // so that they will round-trip properly when sent from java to javascript\n+      // and back.\n+      char[] surrogates = Character.toChars(codePoint);\n+      appendHexJavaScriptRepresentation(out, surrogates[0]);\n+      appendHexJavaScriptRepresentation(out, surrogates[1]);\n+      return;\n+    }\n+    out.append(\"\\\\u\")\n+        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])\n+        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n+        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n+        .append(HEX_CHARS[codePoint & 0xf]);\n+  }\n+\n+}\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n-import com.google.javascript.jscomp.sourcemap.FilePosition;\n+import com.google.debugging.sourcemap.FilePosition;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Predicate;\n-import com.google.javascript.jscomp.sourcemap.SourceMapGenerator;\n-import com.google.javascript.jscomp.sourcemap.SourceMapGeneratorV1;\n-import com.google.javascript.jscomp.sourcemap.SourceMapGeneratorV2;\n-import com.google.javascript.jscomp.sourcemap.FilePosition;\n+import com.google.debugging.sourcemap.FilePosition;\n+import com.google.debugging.sourcemap.SourceMapGenerator;\n+import com.google.debugging.sourcemap.SourceMapGeneratorV1;\n+import com.google.debugging.sourcemap.SourceMapGeneratorV2;\n import com.google.javascript.rhino.Node;\n \n import java.io.IOException;\n--- /dev/null\n+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV1Test.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.LinkedListMultimap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.javascript.jscomp.Compiler;\n+import com.google.javascript.jscomp.CompilerOptions;\n+import com.google.javascript.jscomp.JSSourceFile;\n+import com.google.javascript.jscomp.Result;\n+import com.google.javascript.jscomp.SourceMap;\n+import com.google.javascript.jscomp.SourceMap.DetailLevel;\n+\n+import junit.framework.TestCase;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * Tests for {@link SourceMap}.\n+ *\n+ */\n+public class SourceMapGeneratorV1Test extends TestCase {\n+  private static final JSSourceFile[] EXTERNS = {\n+      JSSourceFile.fromCode(\"externs\", \"\")\n+  };\n+\n+  private DetailLevel detailLevel = SourceMap.DetailLevel.ALL;\n+\n+  @Override\n+  public void setUp() {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+  }\n+\n+  public void testBasicMapping() throws Exception {\n+    compileAndCheck(\"function __BASIC__() { }\");\n+  }\n+\n+  public void testLiteralMappings() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n+                    \"var __VAR__ = '__STR__'; }\");\n+  }\n+\n+  public void testMultilineMapping() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n+                    \"var __VAR__ = '__STR__';\\n\" +\n+                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n+                    \"}\");\n+  }\n+\n+  public void testMultiFunctionMapping() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n+                    \"var __VAR__ = '__STR__';\\n\" +\n+                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n+                    \"}\\n\\n\" +\n+\n+                    \"function __BASIC2__(__PARAM3__, __PARAM4__) {\\n\" +\n+                    \"var __VAR2__ = '__STR2__';\\n\" +\n+                    \"var __ANO2__ = \\\"__STR3__\\\";\\n\" +\n+                    \"}\\n\\n\");\n+  }\n+\n+  public void testGoldenOutput0() throws Exception {\n+    // Empty source map test\n+    checkSourceMap(\"\",\n+\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\",\" +\n+                   \" \\\"count\\\": 1 }\\n\" +\n+\n+                   \"[]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+\n+                   \"/** Begin mapping definitions. **/\\n\");\n+  }\n+\n+  public void testFunctionNameOutput1() throws Exception {\n+    checkSourceMap(\"function f() {}\",\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n+                   \"\\\"count\\\": 1 }\\n\" +\n+\n+                   \"[0,0,0,0,0,0,0,0,1,1,2,2,3,3]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,10]\\n\" +\n+                   \"[\\\"testcode\\\",1,13]\\n\");\n+  }\n+\n+  public void testFunctionNameOutput2() throws Exception {\n+    checkSourceMap(\"a.b.c = function () {};\",\n+\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n+                   \"\\\"count\\\": 1 }\\n\" +\n+\n+                   \"[3,2,2,1,1,0,4,4,4,4,4,4,4,4,5,5,6,6]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"testcode\\\",1,0]\\n\" +\n+                   \"[\\\"testcode\\\",1,0,\\\"c\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,0,\\\"b\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,0,\\\"a\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,17,\\\"a.b.c\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,17]\\n\" +\n+                   \"[\\\"testcode\\\",1,20]\\n\");\n+  }\n+\n+  public void testFunctionNameOutput3() throws Exception {\n+    checkSourceMap(\"var q = function () {};\",\n+\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n+                   \"\\\"count\\\": 1 }\\n\" +\n+\n+                   \"[0,0,0,0,1,1,2,2,2,2,2,2,2,2,3,3,4,4]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"testcode\\\",1,0]\\n\" +\n+                   \"[\\\"testcode\\\",1,4,\\\"q\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,17,\\\"q\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,17]\\n\" +\n+                   \"[\\\"testcode\\\",1,20]\\n\");\n+  }\n+\n+  public void testFunctionNameOutput4() throws Exception {\n+    checkSourceMap(\"({ 'q' : function () {} })\",\n+\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n+                   \"\\\"count\\\": 1 }\\n\" +\n+\n+                   \"[0,0,1,1,1,0,2,2,2,2,2,2,2,2,3,3,4,4,0,0]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"testcode\\\",1,1]\\n\" +\n+                   \"[\\\"testcode\\\",1,3]\\n\" +\n+                   \"[\\\"testcode\\\",1,18,\\\"q\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,18]\\n\" +\n+                   \"[\\\"testcode\\\",1,21]\\n\");\n+  }\n+\n+  public void testGoldenOutput1() throws Exception {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+\n+    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n+\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n+                   \"\\\"count\\\": 1 }\\n\" +\n+\n+                   \"[0,0,0,0,0,0,0,0,1,1,2,3,3,3,2,4,4,4,2,5,7,7,7,6,8,8,8,6,\" +\n+                   \"9,9,9,6,10,11,11,11,11,11,11,11,12,12,12,12,5]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,10]\\n\" +\n+                   \"[\\\"testcode\\\",1,11,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,16,\\\"bar\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,21]\\n\" +\n+                   \"[\\\"testcode\\\",1,23]\\n\" +\n+                   \"[\\\"testcode\\\",1,23,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,29,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,35,\\\"bar\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,41]\\n\" +\n+                   \"[\\\"testcode\\\",1,44]\\n\" +\n+                   \"[\\\"testcode\\\",1,51,\\\"foo\\\"]\\n\");\n+\n+\n+    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n+    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n+\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n+                   \"\\\"count\\\": 1 }\\n\" +\n+\n+                   \"[0,0,0,0,0,0,0,0,1,1,0,2,2,2,0,3,3,3,0,0,4,4,4,0,5,5,5,0,\" +\n+                   \"6,6,6,0,0,0,0,0,0,0,0,0,7,7,7,7,0]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,11,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,16,\\\"bar\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,23,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,29,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,35,\\\"bar\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,51,\\\"foo\\\"]\\n\");\n+  }\n+\n+  public void testGoldenOutput2() throws Exception {\n+    checkSourceMap(\"function f(foo, bar) {\\r\\n\\n\\n\\nfoo = foo + bar + foo;\" +\n+                   \"\\nreturn foo;\\n}\",\n+\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n+                   \"\\\"count\\\": 1 }\\n\" +\n+\n+                   \"[0,0,0,0,0,0,0,0,1,1,2,3,3,3,2,4,4,4,2,5,7,7,7,6,8,8,8,\" +\n+                   \"6,9,9,9,6,10,10,10,11,11,11,11,11,11,11,12,12,12,\" +\n+                   \"12,5]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,10]\\n\" +\n+                   \"[\\\"testcode\\\",1,11,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,16,\\\"bar\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",1,21]\\n\" +\n+                   \"[\\\"testcode\\\",5,0]\\n\" +\n+                   \"[\\\"testcode\\\",5,0,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",5,6,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",5,12,\\\"bar\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",5,18,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"testcode\\\",6,0]\\n\" +\n+                   \"[\\\"testcode\\\",6,7,\\\"foo\\\"]\\n\");\n+  }\n+\n+  public void testGoldenOutput3() throws Exception {\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"foo;\",\n+\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n+                   \"\\\"count\\\": 1 }\\n\" +\n+\n+                   \"[0,0,0]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,0,\\\"foo\\\"]\\n\");\n+  }\n+\n+  public void testGoldenOutput4() throws Exception {\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"foo;   boo;   goo;\",\n+\n+                   \"/** Begin line maps. **/\" +\n+                   \"{ \\\"file\\\" : \\\"testcode\\\", \\\"count\\\": 1 }\\n\" +\n+                   \"[0,0,0,1,1,1,1,2,2,2,2]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,0,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,7,\\\"boo\\\"]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,14,\\\"goo\\\"]\\n\");\n+  }\n+\n+  public void testGoldenOutput5() throws Exception {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"/** @preserve\\n\" +\n+                   \" * this is a test.\\n\" +\n+                   \" */\\n\" +\n+                   \"var foo=a + 'this is a really long line that will force the\"\n+                   + \" mapping to span multiple lines 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \"' + c + d + e;\",\n+\n+                   \"/** Begin line maps. **/\" +\n+                   \"{ \\\"file\\\" : \\\"testcode\\\", \\\"count\\\": 6 }\\n\" +\n+                   \"[]\\n\" +\n+                   \"[]\\n\" +\n+                   \"[]\\n\" +\n+                   \"[]\\n\" +\n+                   \"[0,0,0,0,1,1,1,1,2,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\" +\n+                   \"3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]\\n\" +\n+                   \"[4,1,5,1,6]\\n\" +\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+                   \"[]\\n\" +\n+                   \"[]\\n\" +\n+                   \"[]\\n\" +\n+                   \"[]\\n\" +\n+                   \"[]\\n\" +\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",4,0]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",4,4,\\\"foo\\\"]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",4,8,\\\"a\\\"]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",4,12]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",4,1314,\\\"c\\\"]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",4,1318,\\\"d\\\"]\\n\" +\n+                   \"[\\\"c:\\\\\\\\myfile.js\\\",4,1322,\\\"e\\\"]\\n\");\n+\n+    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n+\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+        \"/** @preserve\\n\" +\n+        \" * this is a test.\\n\" +\n+        \" */\\n\" +\n+        \"var foo=a + 'this is a really long line that will force the\"\n+        + \" mapping to span multiple lines 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \"' + c + d + e;\",\n+\n+        \"/** Begin line maps. **/\" +\n+        \"{ \\\"file\\\" : \\\"testcode\\\", \\\"count\\\": 6 }\\n\" +\n+        \"[]\\n\" +\n+        \"[]\\n\" +\n+        \"[]\\n\" +\n+        \"[]\\n\" +\n+        \"[-1,-1,-1,-1,0,0,0,0,1]\\n\" +\n+        \"[2,0,3,0,4]\\n\" +\n+        \"/** Begin file information. **/\\n\" +\n+        \"[]\\n\" +\n+        \"[]\\n\" +\n+        \"[]\\n\" +\n+        \"[]\\n\" +\n+        \"[]\\n\" +\n+        \"[]\\n\" +\n+        \"/** Begin mapping definitions. **/\\n\" +\n+        \"[\\\"c:\\\\\\\\myfile.js\\\",4,4,\\\"foo\\\"]\\n\" +\n+        \"[\\\"c:\\\\\\\\myfile.js\\\",4,8,\\\"a\\\"]\\n\" +\n+        \"[\\\"c:\\\\\\\\myfile.js\\\",4,1314,\\\"c\\\"]\\n\" +\n+        \"[\\\"c:\\\\\\\\myfile.js\\\",4,1318,\\\"d\\\"]\\n\" +\n+        \"[\\\"c:\\\\\\\\myfile.js\\\",4,1322,\\\"e\\\"]\\n\");\n+  }\n+\n+  public void testBasicDeterminism() throws Exception {\n+    RunResult result1 = compile(\"file1\", \"foo;\", \"file2\", \"bar;\");\n+    RunResult result2 = compile(\"file2\", \"foo;\", \"file1\", \"bar;\");\n+\n+    String map1 = getSourceMap(result1);\n+    String map2 = getSourceMap(result2);\n+\n+    // Assert that the files section of the maps are the same. The actual\n+    // entries will differ, so we cannot do a simple full comparison.\n+\n+    // Line 5 has the file information.\n+    String files1 = map1.split(\"\\n\")[4];\n+    String files2 = map2.split(\"\\n\")[4];\n+\n+    assertEquals(files1, files2);\n+  }\n+\n+  /**\n+   * Creates a source map for the given JS code and asserts it is\n+   * equal to the expected golden map.\n+   */\n+  private void checkSourceMap(String js, String expectedMap)\n+      throws IOException {\n+    checkSourceMap(\"testcode\", js, expectedMap);\n+  }\n+\n+  private String getSourceMap(RunResult result) throws IOException {\n+    StringBuilder sb = new StringBuilder();\n+    result.sourceMap.appendTo(sb, \"testcode\");\n+    return sb.toString();\n+  }\n+\n+  private void checkSourceMap(String fileName, String js, String expectedMap)\n+      throws IOException {\n+    RunResult result = compile(js, fileName);\n+    assertEquals(expectedMap, result.sourceMapFileContent);\n+    assertEquals(result.sourceMapFileContent, getSourceMap(result));\n+  }\n+\n+  private static class RunResult {\n+    String generatedSource;\n+    SourceMap sourceMap;\n+    public String sourceMapFileContent;\n+  }\n+\n+  private static class Token {\n+    String tokenName;\n+    FilePosition position;\n+  }\n+\n+  /**\n+   * Finds the all the __XX__ tokens in the given Javascript\n+   * string.\n+   */\n+  private Map<String, Token> findTokens(String js) {\n+    Map<String, Token> tokens = Maps.newLinkedHashMap();\n+\n+    int currentLine = 0;\n+    int positionOffset = 0;\n+\n+    for (int i = 0; i < js.length(); ++i) {\n+      char current = js.charAt(i);\n+\n+      if (current == '\\n') {\n+        positionOffset = i + 1;\n+        currentLine++;\n+        continue;\n+      }\n+\n+      if (current == '_' && (i < js.length() - 5)) {\n+        // Check for the _ token.\n+        if (js.charAt(i + 1) != '_') {\n+          continue;\n+        }\n+\n+        // Loop until we have another _ token.\n+        String tokenName = \"\";\n+\n+        int j = i + 2;\n+        for (; j < js.length(); ++j) {\n+          if (js.charAt(j) == '_') {\n+            break;\n+          }\n+\n+          tokenName += js.charAt(j);\n+        }\n+\n+        if (tokenName.length() > 0) {\n+          Token token = new Token();\n+          token.tokenName = tokenName;\n+          int currentPosition = i - positionOffset;\n+          token.position = new FilePosition(currentLine, currentPosition);\n+          tokens.put(tokenName, token);\n+        }\n+\n+        i = j;\n+      }\n+    }\n+\n+    return tokens;\n+  }\n+\n+  private void compileAndCheck(String js) {\n+    RunResult result = compile(js);\n+\n+    // Find all instances of the __XXX__ pattern in the original\n+    // source code.\n+    Map<String, Token> originalTokens = findTokens(js);\n+\n+    // Find all instances of the __XXX__ pattern in the generated\n+    // source code.\n+    Map<String, Token> resultTokens = findTokens(result.generatedSource);\n+\n+    // Ensure that the generated instances match via the source map\n+    // to the original source code.\n+\n+    // Ensure the token counts match.\n+    assertEquals(originalTokens.size(), resultTokens.size());\n+\n+    SourceMapReader reader = new SourceMapReader();\n+    try {\n+      reader.parse(result.sourceMapFileContent);\n+    } catch (SourceMapParseException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n+\n+    // Map the tokens from the generated source back to the\n+    // input source and ensure that the map is correct.\n+    for (Token token : resultTokens.values()) {\n+      OriginalMapping mapping = reader.getMappingForLine(\n+          token.position.getLine() + 1,\n+          token.position.getColumn() + 1);\n+\n+      assertNotNull(mapping);\n+\n+      // Find the associated token in the input source.\n+      Token inputToken = originalTokens.get(token.tokenName);\n+      assertNotNull(inputToken);\n+\n+      // Ensure that the map correctly points to the token (we add 1\n+      // to normalize versus the Rhino line number indexing scheme).\n+      assertEquals(mapping.position.getLine(),\n+                   inputToken.position.getLine() + 1);\n+\n+      // Ensure that if the token name does not being with an 'STR' (meaning a\n+      // string) it has an original name.\n+      if (!inputToken.tokenName.startsWith(\"STR\")) {\n+        assertTrue(!mapping.originalName.isEmpty());\n+      }\n+\n+      // Ensure that if the mapping has a name, it matches the token.\n+      if (!mapping.originalName.isEmpty()) {\n+        assertEquals(mapping.originalName, \"__\" + inputToken.tokenName + \"__\");\n+      }\n+    }\n+  }\n+\n+  private RunResult compile(String js) {\n+    return compile(js, \"testcode\");\n+  }\n+\n+  private RunResult compile(String js, String fileName) {\n+    return compile(js, fileName, null, null);\n+  }\n+\n+  private RunResult compile(String js1, String fileName1, String js2,\n+      String fileName2) {\n+    Compiler compiler = new Compiler();\n+    CompilerOptions options = new CompilerOptions();\n+    options.sourceMapOutputPath = \"testcode_source_map.out\";\n+    options.sourceMapDetailLevel = detailLevel;\n+\n+    // Turn on IDE mode to get rid of optimizations.\n+    options.ideMode = true;\n+\n+    JSSourceFile[] inputs = { JSSourceFile.fromCode(fileName1, js1) };\n+\n+    if (js2 != null && fileName2 != null) {\n+      JSSourceFile[] multiple =  { JSSourceFile.fromCode(fileName1, js1),\n+                                   JSSourceFile.fromCode(fileName2, js2) };\n+      inputs = multiple;\n+    }\n+\n+    Result result = compiler.compile(EXTERNS, inputs, options);\n+\n+    assertTrue(result.success);\n+    String source = compiler.toSource();\n+\n+    StringBuilder sb = new StringBuilder();\n+    try {\n+      result.sourceMap.appendTo(sb, \"testcode\");\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n+\n+    RunResult rr = new RunResult();\n+    rr.generatedSource = source;\n+    rr.sourceMap = result.sourceMap;\n+    rr.sourceMapFileContent = sb.toString();\n+    return rr;\n+  }\n+\n+  public static class SourceMapParseException extends IOException {\n+    private static final long serialVersionUID = 1L;\n+\n+    public SourceMapParseException(String message) {\n+      super(message);\n+    }\n+  }\n+\n+  public static class OriginalMapping {\n+    public final String srcfile;\n+    public final FilePosition position;\n+    public final String originalName;\n+\n+    OriginalMapping(String srcfile, int line, int column, String name) {\n+      this.srcfile = srcfile;\n+      this.position = new FilePosition(line, column);\n+      this.originalName = name;\n+    }\n+  }\n+\n+  /**\n+   * Class for parsing and representing a SourceMap\n+   * TODO(johnlenz): This would be best as a separate open-source component.\n+   *     Remove this when it is.\n+   */\n+  public class SourceMapReader {\n+    private static final String LINEMAP_HEADER = \"/** Begin line maps. **/\";\n+    private static final String FILEINFO_HEADER =\n+        \"/** Begin file information. **/\";\n+\n+    private static final String DEFINITION_HEADER =\n+        \"/** Begin mapping definitions. **/\";\n+\n+    /**\n+     * Internal class for parsing the SourceMap. Used to maintain parser\n+     * state in an easy to use instance.\n+     */\n+    private class ParseState {\n+      private Reader reader = null;\n+      private int currentPosition = 0;\n+\n+      public ParseState(String contents) {\n+        this.reader = new StringReader(contents);\n+      }\n+\n+      /**\n+       * Consumes a single character. If we have already reached the end\n+       * of the string, returns  -1.\n+       */\n+      private int consumeCharacter() {\n+        try {\n+          currentPosition++;\n+          return reader.read();\n+        } catch (IOException iox) {\n+          // Should never happen. Local reader.\n+          throw new IllegalStateException(\"IOException raised by reader\");\n+        }\n+      }\n+\n+      /**\n+       * Consumes the specified value found in the contents string. If the value\n+       * is not found, throws a parse exception.\n+       */\n+      public void consume(String value) throws SourceMapParseException {\n+         for (int i = 0; i < value.length(); ++i) {\n+          int ch = consumeCharacter();\n+\n+          if (ch == -1 || ch != value.charAt(i)) {\n+            fail(\"At character \" + currentPosition + \" expected: \" + value);\n+          }\n+        }\n+      }\n+\n+      /**\n+       * Consumes characters until the newline character is found or the string\n+       * has been entirely consumed. Returns the string consumed (without the\n+       * newline).\n+       */\n+      public String consumeUntilEOL() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        int ch = -1;\n+\n+        while ((ch = consumeCharacter()) != '\\n') {\n+          if (ch == -1) {\n+            return sb.toString();\n+          }\n+\n+          sb.append((char) ch);\n+        }\n+\n+        return sb.toString();\n+      }\n+\n+      /**\n+       * Indicates that parsing has failed by throwing a parse exception.\n+       */\n+      public void fail(String message) throws SourceMapParseException {\n+        throw new SourceMapParseException(message);\n+      }\n+    }\n+\n+    /**\n+     * Mapping from a line number (0-indexed), to a list of mapping IDs, one for\n+     * each character on the line. For example, if the array for line 2 is\n+     * [4,,,,5,6,,,7], then there will be the entry:\n+     *\n+     * 1 => {4, 4, 4, 4, 5, 6, 6, 6, 7}\n+     *\n+     */\n+    private Multimap<Integer, Integer> characterMap = null;\n+\n+    /**\n+     * Map of Mapping IDs to the actual mapping object.\n+     */\n+    private Map<Integer, OriginalMapping> mappings = null;\n+\n+    public SourceMapReader() {\n+    }\n+\n+    /**\n+     * Parses the given contents containing a source map.\n+     */\n+    public void parse(String contents) throws SourceMapParseException {\n+      ParseState parser = new ParseState(contents);\n+\n+      characterMap = LinkedListMultimap.create();\n+      mappings = Maps.newHashMap();\n+\n+      try {\n+        // /** Begin line maps. **/{ count: 2 }\n+        parser.consume(LINEMAP_HEADER);\n+        String countJSON = parser.consumeUntilEOL();\n+\n+        JSONObject countObject = new JSONObject(countJSON);\n+\n+        if (!countObject.has(\"count\")) {\n+          parser.fail(\"Missing 'count'\");\n+        }\n+\n+        int lineCount = countObject.getInt(\"count\");\n+\n+        if (lineCount <= 0) {\n+          parser.fail(\"Count must be >= 1\");\n+        }\n+\n+        // [0,,,,,,1,2]\n+        for (int i = 0; i < lineCount; ++i) {\n+          String currentLine = parser.consumeUntilEOL();\n+\n+          // Blank lines are allowed in the spec to indicate no mapping\n+          // information for the line.\n+          if (currentLine.isEmpty()) {\n+            continue;\n+          }\n+\n+          JSONArray charArray = new JSONArray(currentLine);\n+\n+          int lastID = -1;\n+\n+          for (int j = 0; j < charArray.length(); ++j) {\n+            int mappingID = lastID;\n+\n+            if (!charArray.isNull(j)) {\n+              mappingID = charArray.optInt(j);\n+            }\n+\n+            // Save the current character's mapping.\n+            characterMap.put(i, mappingID);\n+\n+            lastID = mappingID;\n+          }\n+        }\n+\n+        // /** Begin file information. **/\n+        parser.consume(FILEINFO_HEADER);\n+\n+        if (parser.consumeUntilEOL().length() > 0) {\n+          parser.fail(\"Unexpected token after file information header\");\n+        }\n+\n+        // File information. Not used, so we just consume it.\n+        for (int i = 0; i < lineCount; ++i) {\n+          parser.consumeUntilEOL();\n+        }\n+\n+        // /** Begin mapping definitions. **/\n+        parser.consume(DEFINITION_HEADER);\n+\n+        if (parser.consumeUntilEOL().length() > 0) {\n+          parser.fail(\"Unexpected token after definition header\");\n+        }\n+\n+        String currentLine = null;\n+\n+        // ['d.js', 3, 78, 'foo']\n+        for (int mappingID = 0;\n+             (currentLine = parser.consumeUntilEOL()).length() > 0;\n+             ++mappingID) {\n+\n+          JSONArray mapArray = new JSONArray(currentLine);\n+\n+          if (mapArray.length() < 3) {\n+            parser.fail(\"Invalid mapping array\");\n+          }\n+\n+          OriginalMapping mapping = new OriginalMapping(\n+              mapArray.getString(0), // srcfile\n+              mapArray.getInt(1),    // line\n+              mapArray.getInt(2),    // column\n+              mapArray.optString(3, \"\")); // identifier\n+\n+          mappings.put(mappingID, mapping);\n+        }\n+      } catch (JSONException ex) {\n+        parser.fail(\"JSON parse exception: \" + ex);\n+      }\n+    }\n+\n+    public OriginalMapping getMappingForLine(int lineNumber, int columnIndex) {\n+      Preconditions.checkNotNull(characterMap, \"parse() must be called first\");\n+\n+      if (!characterMap.containsKey(lineNumber - 1)) {\n+        return null;\n+      }\n+\n+      Collection<Integer> mapIds = characterMap.get(lineNumber - 1);\n+\n+      int columnPosition = columnIndex - 1;\n+      if (columnPosition >= mapIds.size() || columnPosition < 0) {\n+        return null;\n+      }\n+\n+      // TODO(user): Find a way to make this faster.\n+      Integer[] mapIdsAsArray = new Integer[mapIds.size()];\n+      mapIds.<Integer>toArray(mapIdsAsArray);\n+\n+      int mapId = mapIdsAsArray[columnPosition];\n+\n+      if (mapId < 0) {\n+        return null;\n+      }\n+\n+      return mappings.get(mapId);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV2Test.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.debugging.sourcemap.SourceMapGeneratorV2.LineMapDecoder;\n+import com.google.debugging.sourcemap.SourceMapGeneratorV2.LineMapEncoder;\n+import com.google.javascript.jscomp.Compiler;\n+import com.google.javascript.jscomp.CompilerOptions;\n+import com.google.javascript.jscomp.JSSourceFile;\n+import com.google.javascript.jscomp.Result;\n+import com.google.javascript.jscomp.SourceMap;\n+import com.google.javascript.jscomp.SourceMap.DetailLevel;\n+\n+import junit.framework.TestCase;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Tests for {@link SourceMap}.\n+ *\n+ */\n+public class SourceMapGeneratorV2Test extends TestCase {\n+  private static final JSSourceFile[] EXTERNS = {\n+      JSSourceFile.fromCode(\"externs\", \"\")\n+  };\n+\n+  private DetailLevel detailLevel = SourceMap.DetailLevel.ALL;\n+\n+  @Override\n+  public void setUp() {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+  }\n+\n+  public void testBasicMapping() throws Exception {\n+    compileAndCheck(\"function __BASIC__() { }\");\n+  }\n+\n+  public void testBasicMappingGoldenOutput() throws Exception {\n+    // Empty source map test\n+    checkSourceMap(\"function __BASIC__() { }\",\n+\n+                   //\"/** Source Map **/\\n\" +\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"cAkBEBEB\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,9,\\\"__BASIC__\\\"],\\n\" +\n+                   \"[0,1,9,\\\"__BASIC__\\\"],\\n\" +\n+                   \"[0,1,18],\\n\" +\n+                   \"[0,1,21],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testLiteralMappings() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n+                    \"var __VAR__ = '__STR__'; }\");\n+  }\n+\n+  public void testLiteralMappingsGoldenOutput() throws Exception {\n+    // Empty source map test\n+    checkSourceMap(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n+                   \"var __VAR__ = '__STR__'; }\",\n+\n+                   //\"/** Source Map **/\\n\" +\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"cAkBABkBA/kCA+ADMBcBgBA9\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,9,\\\"__BASIC__\\\"],\\n\" +\n+                   \"[0,1,9,\\\"__BASIC__\\\"],\\n\" +\n+                   \"[0,1,18],\\n\" +\n+                   \"[0,1,19,\\\"__PARAM1__\\\"],\\n\" +\n+                   \"[0,1,31,\\\"__PARAM2__\\\"],\\n\" +\n+                   \"[0,1,43],\\n\" +\n+                   \"[0,1,45],\\n\" +\n+                   \"[0,1,49,\\\"__VAR__\\\"],\\n\" +\n+                   \"[0,1,59],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testMultilineMapping() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n+                    \"var __VAR__ = '__STR__';\\n\" +\n+                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n+                    \"}\");\n+  }\n+\n+  public void testMultiFunctionMapping() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n+                    \"var __VAR__ = '__STR__';\\n\" +\n+                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n+                    \"}\\n\\n\" +\n+\n+                    \"function __BASIC2__(__PARAM3__, __PARAM4__) {\\n\" +\n+                    \"var __VAR2__ = '__STR2__';\\n\" +\n+                    \"var __ANO2__ = \\\"__STR3__\\\";\\n\" +\n+                    \"}\\n\\n\");\n+  }\n+\n+  public void testGoldenOutput0() throws Exception {\n+    // Empty source map test\n+    checkSourceMap(\"\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput1() throws Exception {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+\n+    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":\" +\n+                       \"[\\\"cAEBABIBA/ICA+ADICA/ICA+IDA9AEYBMBA5\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,9,\\\"f\\\"],\\n\" +\n+                   \"[0,1,9,\\\"f\\\"],\\n\" +\n+                   \"[0,1,10],\\n\" +\n+                   \"[0,1,11,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,16,\\\"bar\\\"],\\n\" +\n+                   \"[0,1,21],\\n\" +\n+                   \"[0,1,23],\\n\" +\n+                   \"[0,1,23,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,29,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,35,\\\"bar\\\"],\\n\" +\n+                   \"[0,1,41],\\n\" +\n+                   \"[0,1,44],\\n\" +\n+                   \"[0,1,51,\\\"foo\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+\n+    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n+\n+    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"cAEBA/ICA+IDE9IEA8IFA7IGg6MHA5\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,9,\\\"f\\\"],\\n\" +\n+                   \"[0,1,9,\\\"f\\\"],\\n\" +\n+                   \"[0,1,11,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,16,\\\"bar\\\"],\\n\" +\n+                   \"[0,1,23,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,29,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,35,\\\"bar\\\"],\\n\" +\n+                   \"[0,1,51,\\\"foo\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput2() throws Exception {\n+    checkSourceMap(\"function f(foo, bar) {\\r\\n\\n\\n\\nfoo = foo + bar + foo;\" +\n+                   \"\\nreturn foo;\\n}\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":\" +\n+                       \"[\\\"cAEBABIBA/ICA+ADICA/ICA+IDA9IEYBMBA5\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,9,\\\"f\\\"],\\n\" +\n+                   \"[0,1,9,\\\"f\\\"],\\n\" +\n+                   \"[0,1,10],\\n\" +\n+                   \"[0,1,11,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,16,\\\"bar\\\"],\\n\" +\n+                   \"[0,1,21],\\n\" +\n+                   \"[0,5,0],\\n\" +\n+                   \"[0,5,0,\\\"foo\\\"],\\n\" +\n+                   \"[0,5,6,\\\"foo\\\"],\\n\" +\n+                   \"[0,5,12,\\\"bar\\\"],\\n\" +\n+                   \"[0,5,18,\\\"foo\\\"],\\n\" +\n+                   \"[0,6,0],\\n\" +\n+                   \"[0,6,7,\\\"foo\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput3() throws Exception {\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"foo;\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"IA\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"c:\\\\myfile.js\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,0,\\\"foo\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput4() throws Exception {\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"foo;   boo;   goo;\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"IAMBMB\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"c:\\\\myfile.js\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,0,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,7,\\\"boo\\\"],\\n\" +\n+                   \"[0,1,14,\\\"goo\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput5() throws Exception {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"/** @preserve\\n\" +\n+                   \" * this is a test.\\n\" +\n+                   \" */\\n\" +\n+                   \"var foo=a + 'this is a really long line that will force the\"\n+                   + \" mapping to span multiple lines 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \"' + c + d + e;\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":6,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"\\\",\\n\" +\n+                   \"\\\"\\\",\\n\" +\n+                   \"\\\"\\\",\\n\" +\n+                   \"\\\"\\\",\\n\" +\n+                   \"\\\"MAMBABA/!!AUSC\\\",\\n\" +\n+                   \"\\\"AEA9AEA8AF\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"c:\\\\myfile.js\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,4,0],\\n\" +\n+                   \"[0,4,4,\\\"foo\\\"],\\n\" +\n+                   \"[0,4,8,\\\"a\\\"],\\n\" +\n+                   \"[0,4,12],\\n\" +\n+                   \"[0,4,1314,\\\"c\\\"],\\n\" +\n+                   \"[0,4,1318,\\\"d\\\"],\\n\" +\n+                   \"[0,4,1322,\\\"e\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+\n+    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n+\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+        \"/** @preserve\\n\" +\n+        \" * this is a test.\\n\" +\n+        \" */\\n\" +\n+        \"var foo=a + 'this is a really long line that will force the\"\n+        + \" mapping to span multiple lines 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \"' + c + d + e;\",\n+\n+        \"{\\n\" +\n+        \"\\\"version\\\":2,\\n\" +\n+        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+        \"\\\"lineCount\\\":6,\\n\" +\n+        \"\\\"lineMaps\\\":[\\\"\\\",\\n\" +\n+        \"\\\"\\\",\\n\" +\n+        \"\\\"\\\",\\n\" +\n+        \"\\\"\\\",\\n\" +\n+        \"\\\"M/MBAB\\\",\\n\" +\n+        \"\\\"ACA+ADA9AE\\\"],\\n\" +\n+        \"\\\"sources\\\":[\\\"c:\\\\myfile.js\\\"],\\n\" +\n+        \"\\\"mappings\\\":[[0,4,4,\\\"foo\\\"],\\n\" +\n+        \"[0,4,8,\\\"a\\\"],\\n\" +\n+        \"[0,4,1314,\\\"c\\\"],\\n\" +\n+        \"[0,4,1318,\\\"d\\\"],\\n\" +\n+        \"[0,4,1322,\\\"e\\\"],\\n\" +\n+        \"]\\n\" +\n+        \"}\\n\");\n+  }\n+\n+  public void testBasicDeterminism() throws Exception {\n+    RunResult result1 = compile(\"file1\", \"foo;\", \"file2\", \"bar;\");\n+    RunResult result2 = compile(\"file2\", \"foo;\", \"file1\", \"bar;\");\n+\n+    String map1 = getSourceMap(result1);\n+    String map2 = getSourceMap(result2);\n+\n+    // Assert that the files section of the maps are the same. The actual\n+    // entries will differ, so we cannot do a simple full comparison.\n+\n+    // Line 5 has the file information.\n+    String files1 = map1.split(\"\\n\")[4];\n+    String files2 = map2.split(\"\\n\")[4];\n+\n+    assertEquals(files1, files2);\n+  }\n+\n+  private int getRelativeId(int id, int lastId) {\n+    int length = LineMapEncoder.getRelativeMappingIdLength(id, lastId);\n+    int result = LineMapEncoder.getRelativeMappingId(id, length, lastId);\n+    int inverse = LineMapDecoder.getIdFromRelativeId(result, length, lastId);\n+    assertEquals(id, inverse);\n+    return result;\n+  }\n+\n+  public void testEncodingRelativeId() {\n+    assertEquals(0, getRelativeId(0, 0));\n+    assertEquals(64 + (-1), getRelativeId(-1, 0));\n+    assertEquals(64 + (-32), getRelativeId(0, 32));\n+    assertEquals(31, getRelativeId(31, 0));\n+    assertEquals(4096 + (-33), getRelativeId(0, 33));\n+    assertEquals(32, getRelativeId(32, 0));\n+  }\n+\n+  public void testEncodingIdLength() {\n+    assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(0, 0));\n+    assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(-1, 0));\n+    assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(0, 32));\n+    assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(31, 0));\n+    assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(0, 33));\n+    assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(32, 0));\n+\n+    assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(2047, 0));\n+    assertEquals(3, LineMapEncoder.getRelativeMappingIdLength(2048, 0));\n+    assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(0, 2048));\n+    assertEquals(3, LineMapEncoder.getRelativeMappingIdLength(0, 2049));\n+  }\n+\n+  private String getEntry(int id, int lastId, int reps) throws IOException {\n+    StringBuilder sb = new StringBuilder();\n+    LineMapEncoder.encodeEntry(sb, id, lastId, reps);\n+    return sb.toString();\n+  }\n+\n+  public void testEncoding() throws IOException {\n+    assertEquals(\"AA\", getEntry(0, 0, 1));\n+    assertEquals(\"EA\", getEntry(0, 0, 2));\n+    assertEquals(\"8A\", getEntry(0, 0, 16));\n+    assertEquals(\"!AQA\", getEntry(0, 0, 17));\n+    assertEquals(\"!ARA\", getEntry(0, 0, 18));\n+    assertEquals(\"!A+A\", getEntry(0, 0, 63));\n+    assertEquals(\"!A/A\", getEntry(0, 0, 64));\n+    assertEquals(\"!!ABAA\", getEntry(0, 0, 65));\n+    assertEquals(\"!!A//A\", getEntry(0, 0, 4096));\n+    assertEquals(\"!!!ABAAA\", getEntry(0, 0, 4097));\n+\n+    assertEquals(\"Af\", getEntry(31, 0, 1));\n+    assertEquals(\"BAg\", getEntry(32, 0, 1));\n+    assertEquals(\"AB\", getEntry(32, 31, 1));\n+\n+    assertEquals(\"!AQf\", getEntry(31, 0, 17));\n+    assertEquals(\"!BQAg\", getEntry(32, 0, 17));\n+    assertEquals(\"!AQB\", getEntry(32, 31, 17));\n+\n+    assertEquals(\"!A/B\", getEntry(32, 31, 64));\n+    assertEquals(\"!!ABAB\", getEntry(32, 31, 65));\n+  }\n+\n+  /**\n+   * Creates a source map for the given JS code and asserts it is\n+   * equal to the expected golden map.\n+   */\n+  private void checkSourceMap(String js, String expectedMap)\n+      throws IOException {\n+    checkSourceMap(\"testcode\", js, expectedMap);\n+  }\n+\n+  private String getSourceMap(RunResult result) throws IOException {\n+    StringBuilder sb = new StringBuilder();\n+    result.sourceMap.appendTo(sb, \"testcode\");\n+    return sb.toString();\n+  }\n+\n+  private void checkSourceMap(String fileName, String js, String expectedMap)\n+      throws IOException {\n+    RunResult result = compile(js, fileName);\n+    assertEquals(expectedMap, result.sourceMapFileContent);\n+    assertEquals(result.sourceMapFileContent, getSourceMap(result));\n+  }\n+\n+  private static class RunResult {\n+    String generatedSource;\n+    SourceMap sourceMap;\n+    public String sourceMapFileContent;\n+  }\n+\n+  private static class Token {\n+    String tokenName;\n+    FilePosition position;\n+  }\n+\n+  /**\n+   * Finds the all the __XX__ tokens in the given Javascript\n+   * string.\n+   */\n+  private Map<String, Token> findTokens(String js) {\n+    Map<String, Token> tokens = Maps.newLinkedHashMap();\n+\n+    int currentLine = 0;\n+    int positionOffset = 0;\n+\n+    for (int i = 0; i < js.length(); ++i) {\n+      char current = js.charAt(i);\n+\n+      if (current == '\\n') {\n+        positionOffset = i + 1;\n+        currentLine++;\n+        continue;\n+      }\n+\n+      if (current == '_' && (i < js.length() - 5)) {\n+        // Check for the _ token.\n+        if (js.charAt(i + 1) != '_') {\n+          continue;\n+        }\n+\n+        // Loop until we have another _ token.\n+        String tokenName = \"\";\n+\n+        int j = i + 2;\n+        for (; j < js.length(); ++j) {\n+          if (js.charAt(j) == '_') {\n+            break;\n+          }\n+\n+          tokenName += js.charAt(j);\n+        }\n+\n+        if (tokenName.length() > 0) {\n+          Token token = new Token();\n+          token.tokenName = tokenName;\n+          int currentPosition = i - positionOffset;\n+          token.position = new FilePosition(currentLine, currentPosition);\n+          tokens.put(tokenName, token);\n+        }\n+\n+        i = j;\n+      }\n+    }\n+\n+    return tokens;\n+  }\n+\n+  private void compileAndCheck(String js) {\n+    RunResult result = compile(js);\n+\n+    // Find all instances of the __XXX__ pattern in the original\n+    // source code.\n+    Map<String, Token> originalTokens = findTokens(js);\n+\n+    // Find all instances of the __XXX__ pattern in the generated\n+    // source code.\n+    Map<String, Token> resultTokens = findTokens(result.generatedSource);\n+\n+    // Ensure that the generated instances match via the source map\n+    // to the original source code.\n+\n+    // Ensure the token counts match.\n+    assertEquals(originalTokens.size(), resultTokens.size());\n+\n+    SourceMapReader reader = new SourceMapReader();\n+    try {\n+      reader.parse(result.sourceMapFileContent);\n+    } catch (SourceMapParseException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n+\n+    // Map the tokens from the generated source back to the\n+    // input source and ensure that the map is correct.\n+    for (Token token : resultTokens.values()) {\n+      OriginalMapping mapping = reader.getMappingForLine(\n+          token.position.getLine() + 1,\n+          token.position.getColumn() + 1);\n+\n+      assertNotNull(mapping);\n+\n+      // Find the associated token in the input source.\n+      Token inputToken = originalTokens.get(token.tokenName);\n+      assertNotNull(inputToken);\n+\n+      // Ensure that the map correctly points to the token (we add 1\n+      // to normalize versus the Rhino line number indexing scheme).\n+      assertEquals(mapping.position.getLine(),\n+                   inputToken.position.getLine() + 1);\n+\n+      // Ensure that if the token name does not being with an 'STR' (meaning a\n+      // string) it has an original name.\n+      if (!inputToken.tokenName.startsWith(\"STR\")) {\n+        assertTrue(!mapping.originalName.isEmpty());\n+      }\n+\n+      // Ensure that if the mapping has a name, it matches the token.\n+      if (!mapping.originalName.isEmpty()) {\n+        assertEquals(mapping.originalName, \"__\" + inputToken.tokenName + \"__\");\n+      }\n+    }\n+  }\n+\n+  private RunResult compile(String js) {\n+    return compile(js, \"testcode\");\n+  }\n+\n+  private RunResult compile(String js, String fileName) {\n+    return compile(js, fileName, null, null);\n+  }\n+\n+  private RunResult compile(String js1, String fileName1, String js2,\n+      String fileName2) {\n+    Compiler compiler = new Compiler();\n+    CompilerOptions options = new CompilerOptions();\n+    options.sourceMapOutputPath = \"testcode_source_map.out\";\n+    options.sourceMapFormat = SourceMap.Format.EXPERIMENTIAL;\n+    options.sourceMapDetailLevel = detailLevel;\n+\n+    // Turn on IDE mode to get rid of optimizations.\n+    options.ideMode = true;\n+\n+    JSSourceFile[] inputs = { JSSourceFile.fromCode(fileName1, js1) };\n+\n+    if (js2 != null && fileName2 != null) {\n+      JSSourceFile[] multiple =  { JSSourceFile.fromCode(fileName1, js1),\n+                                   JSSourceFile.fromCode(fileName2, js2) };\n+      inputs = multiple;\n+    }\n+\n+    Result result = compiler.compile(EXTERNS, inputs, options);\n+\n+    assertTrue(result.success);\n+    String source = compiler.toSource();\n+\n+    StringBuilder sb = new StringBuilder();\n+    try {\n+      result.sourceMap.validate(true);\n+      result.sourceMap.appendTo(sb, \"testcode\");\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n+\n+    RunResult rr = new RunResult();\n+    rr.generatedSource = source;\n+    rr.sourceMap = result.sourceMap;\n+    rr.sourceMapFileContent = sb.toString();\n+    return rr;\n+  }\n+\n+  public static class SourceMapParseException extends IOException {\n+    private static final long serialVersionUID = 1L;\n+\n+    public SourceMapParseException(String message) {\n+      super(message);\n+    }\n+\n+    public SourceMapParseException(String message, Exception ex) {\n+      super(message, ex);\n+    }\n+  }\n+\n+  public static class OriginalMapping {\n+    public final String srcfile;\n+    public final FilePosition position;\n+    public final String originalName;\n+\n+    OriginalMapping(String srcfile, int line, int column, String name) {\n+      this.srcfile = srcfile;\n+      this.position = new FilePosition(line, column);\n+      this.originalName = name;\n+    }\n+  }\n+\n+  /**\n+   * Class for parsing and representing a SourceMap\n+   * TODO(johnlenz): This would be best as a seperate open-source component.\n+   *     Remove this when it is.\n+   */\n+  public class SourceMapReader {\n+    private List<List<Integer>> characterMap = null;\n+\n+    /**\n+     * Map of Mapping IDs to the actual mapping object.\n+     */\n+    private List<OriginalMapping> mappings;\n+    private List<String> sources;\n+    private List<String> names;\n+\n+    public SourceMapReader() {\n+    }\n+\n+    /**\n+     * Parses the given contents containing a source map.\n+     * @throws IOException\n+     */\n+    public void parse(String contents) throws IOException {\n+      characterMap = null;\n+      mappings = null;\n+      sources = null;\n+      names = null;\n+\n+      try {\n+        JSONObject sourceMapRoot = new JSONObject(contents);\n+\n+        int version = sourceMapRoot.getInt(\"version\");\n+        if (version != 2) {\n+          throw new SourceMapParseException(\"unknown version\");\n+        }\n+\n+        String file = sourceMapRoot.getString(\"file\");\n+        if (file.isEmpty()) {\n+          throw new SourceMapParseException(\"file entry is missing or empty\");\n+        }\n+\n+        int lineCount = sourceMapRoot.getInt(\"lineCount\");\n+        JSONArray lineMaps = sourceMapRoot.getJSONArray(\"lineMaps\");\n+        if (lineCount != lineMaps.length()) {\n+          throw new SourceMapParseException(\n+              \"lineMaps lenght does not match lineCount\");\n+        }\n+\n+        characterMap = Lists.newArrayListWithCapacity(lineCount);\n+\n+        for (int i=0; i< lineMaps.length(); i++) {\n+          String lineEntry = lineMaps.getString(i);\n+          List<Integer> entries =\n+              SourceMapGeneratorV2.LineMapDecoder.decodeLine(lineEntry);\n+          String msg = \"line: \" + entries;\n+          System.err.println(msg);\n+          characterMap.add(entries);\n+        }\n+\n+        sources = jsonArrayToJavaArray(\n+            sourceMapRoot.getJSONArray(\"sources\"));\n+\n+        if (sourceMapRoot.has(\"names\")) {\n+          names = jsonArrayToJavaArray(\n+              sourceMapRoot.getJSONArray(\"names\"));\n+        } else {\n+          names = Collections.emptyList();\n+        }\n+\n+        JSONArray jsonMappings = sourceMapRoot.getJSONArray(\"mappings\");\n+        mappings = Lists.newArrayListWithCapacity(lineCount);\n+        for (int i = 0; i < jsonMappings.length(); i++) {\n+          JSONArray entry = jsonMappings.getJSONArray(i);\n+\n+          String name;\n+          try {\n+            int nameIndex = entry.getInt(3);\n+            name = names.get(nameIndex);\n+          } catch (JSONException e) {\n+            name = entry.optString(3, \"\");\n+          }\n+\n+          OriginalMapping mapping = new OriginalMapping(\n+            sources.get(entry.getInt(0)), // srcfile\n+            entry.getInt(1),    // line\n+            entry.getInt(2),    // column\n+            name); // identifier\n+          mappings.add(mapping);\n+        }\n+      } catch (JSONException ex) {\n+        throw new SourceMapParseException(\"JSON parse exception\", ex);\n+      }\n+    }\n+\n+    private List<String> jsonArrayToJavaArray(JSONArray jsonArray)\n+        throws JSONException {\n+      List<String> result = Lists.newArrayListWithCapacity(jsonArray.length());\n+      for (int i=0; i< jsonArray.length(); i++) {\n+        String source = jsonArray.getString(i);\n+        result.add(source);\n+      }\n+      return result;\n+    }\n+\n+    public OriginalMapping getMappingForLine(int lineNumber, int columnIndex) {\n+      Preconditions.checkNotNull(characterMap, \"parse() must be called first\");\n+\n+      List<Integer> mapIds = characterMap.get(lineNumber - 1);\n+      if (mapIds == null) {\n+        return null;\n+      }\n+\n+      int columnPosition = columnIndex - 1;\n+      if (columnPosition >= mapIds.size() || columnPosition < 0) {\n+        return null;\n+      }\n+\n+      int mapId = mapIds.get(columnPosition);\n+\n+      return mappings.get(mapId);\n+    }\n+  }\n+}", "timestamp": 1299199147, "metainfo": ""}