{"sha": "8ef31dd36e38599736e1c9b6ea1d1e546cba510a", "log": "Id Generator Annotations.  R=mgoodman,kai DELTA=298  (260 added, 4 deleted, 34 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2765   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n     passes.add(createEmptyPass(\"beforeStandardOptimizations\"));\n \n-    if (!options.idGenerators.isEmpty()) {\n-      passes.add(replaceIdGenerators);\n-    }\n+    passes.add(replaceIdGenerators);\n \n     // Optimizes references to the arguments variable.\n     if (options.optimizeArgumentsArray) {\n--- a/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n+++ b/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n           \"JSC_CONDITIONAL_ID_GENERATOR_CALL\",\n           \"Id generator call must be unconditional\");\n \n+  static final DiagnosticType CONFLICTING_GENERATOR_TYPE =\n+      DiagnosticType.error(\n+          \"JSC_CONFLICTING_ID_GENERATOR_TYPE\",\n+          \"Id generator can only be consistent or inconsistent\");\n+\n   private final AbstractCompiler compiler;\n   private final Map<String, NameGenerator> nameGenerators;\n+  private final Map<String, NameGenerator> consistNameGenerators;\n+  private final Map<String, Map<String, String>> consistNameMap;\n+\n   private final Map<String, List<Replacement>> idGeneratorMaps;\n \n-  public ReplaceIdGenerators(AbstractCompiler compiler,\n-                             Set<String> idGenerators) {\n+  public ReplaceIdGenerators(AbstractCompiler compiler, Set<String> idGens) {\n     this.compiler = compiler;\n-    nameGenerators = Maps.newHashMap();\n+    nameGenerators = Maps.newLinkedHashMap();\n+    consistNameGenerators = Maps.newLinkedHashMap();\n     idGeneratorMaps = Maps.newLinkedHashMap();\n-    for (String idGenerator : idGenerators) {\n-      nameGenerators.put(\n-          idGenerator,\n+    consistNameMap = Maps.newLinkedHashMap();\n+\n+    if (idGens != null) {\n+      for(String gen : idGens) {\n+        nameGenerators.put(gen,\n+            new NameGenerator(Collections.<String>emptySet(), \"\", null));\n+        idGeneratorMaps.put(gen, Lists.<Replacement>newLinkedList());\n+      }\n+    }\n+  }\n+\n+  private class GatherGenerators extends AbstractPostOrderCallback {\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      JSDocInfo doc = n.getJSDocInfo();\n+      if (doc == null) {\n+        return;\n+      }\n+\n+      if (!doc.isConsistentIdGenerator() &&\n+          !doc.isIdGenerator()) {\n+        return;\n+      }\n+\n+      if (doc.isConsistentIdGenerator() && doc.isIdGenerator()) {\n+        compiler.report(t.makeError(n, CONFLICTING_GENERATOR_TYPE));\n+      }\n+\n+      String name = null;\n+      if (NodeUtil.isAssign(n)) {\n+        name = n.getFirstChild().getQualifiedName();\n+      } else if (NodeUtil.isVar(n)) {\n+        name = n.getFirstChild().getString();\n+      } else if (NodeUtil.isFunction(n)){\n+        name = n.getFirstChild().getString();\n+        if (name.isEmpty()) {\n+          return;\n+        }\n+      }\n+\n+      // TODO(user): Error on function that has both. Or redeclartion\n+      // on the same function.\n+      if (doc.isConsistentIdGenerator()) {\n+        consistNameGenerators.put(name,\n+            new NameGenerator(Collections.<String>emptySet(), \"\", null));\n+        consistNameMap.put(name, Maps.<String, String>newLinkedHashMap());\n+      } else {\n+        nameGenerators.put(name,\n           new NameGenerator(Collections.<String>emptySet(), \"\", null));\n-      idGeneratorMaps.put(idGenerator, Lists.<Replacement>newArrayList());\n-    }\n-  }\n-\n+      }\n+      idGeneratorMaps.put(name, Lists.<Replacement>newArrayList());\n+    }\n+  }\n+\n+  @Override\n   public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new Callback());\n-  }\n-\n-  private class Callback extends AbstractPostOrderCallback {\n+    NodeTraversal.traverse(compiler, root, new GatherGenerators());\n+    NodeTraversal.traverse(compiler, root, new ReplaceGenerators());\n+  }\n+\n+  private class ReplaceGenerators extends AbstractPostOrderCallback {\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() != Token.CALL) {\n         return;\n       }\n \n       String callName = n.getFirstChild().getQualifiedName();\n+      boolean consistent = false;\n       NameGenerator nameGenerator = nameGenerators.get(callName);\n       if (nameGenerator == null) {\n-        return;\n-      }\n-      List<Replacement> idGeneratorMap = idGeneratorMaps.get(callName);\n+        nameGenerator = consistNameGenerators.get(callName);\n+        consistent = true;\n+      }\n+      if (nameGenerator == null) {\n+        return;\n+      }\n \n       if (!t.inGlobalScope()) {\n         // Warn about calls not in the global scope.\n         }\n       }\n \n-      String nextName = nameGenerator.generateNextName();\n-\n-      parent.replaceChild(n, Node.newString(nextName));\n+      Node id = n.getFirstChild().getNext();\n+\n+      // TODO(user): Error on id not a string literal.\n+      if (!NodeUtil.isString(id)) {\n+        return;\n+      }\n+\n+      List<Replacement> idGeneratorMap = idGeneratorMaps.get(callName);\n+      String rename = null;\n+\n+      if (consistent) {\n+        Map<String, String> entry = consistNameMap.get(callName);\n+        rename = entry.get(id.getString());\n+        if (rename == null) {\n+          rename = nameGenerator.generateNextName();\n+          entry.put(id.getString(), rename);\n+        }\n+      } else {\n+        rename = nameGenerator.generateNextName();\n+      }\n+\n+      parent.replaceChild(n, Node.newString(rename));\n       idGeneratorMap.add(\n-          new Replacement(nextName, t.getSourceName(), t.getLineNumber()));\n+          new Replacement(rename, t.getSourceName(), t.getLineNumber()));\n \n       compiler.reportCodeChange();\n     }\n--- a/src/com/google/javascript/jscomp/parsing/Annotation.java\n+++ b/src/com/google/javascript/jscomp/parsing/Annotation.java\n  */\n enum Annotation {\n   AUTHOR,\n+  CONSISTENTIDGENERATOR,\n   CONSTANT,\n   CONSTRUCTOR,\n   DEFINE,\n   EXPORT,\n   FILE_OVERVIEW,\n   HIDDEN,\n+  IDGENERATOR,\n   IMPLEMENTS,\n   IMPLICIT_CAST,\n   INHERIT_DOC,\n       new ImmutableMap.Builder<String, Annotation>().\n       put(\"argument\", Annotation.PARAM).\n       put(\"author\", Annotation.AUTHOR).\n+      put(\"consistentIdGenerator\", Annotation.CONSISTENTIDGENERATOR).\n       put(\"const\", Annotation.CONSTANT).\n       put(\"constant\", Annotation.CONSTANT).\n       put(\"constructor\", Annotation.CONSTRUCTOR).\n       put(\"fileoverview\", Annotation.FILE_OVERVIEW).\n       put(\"final\", Annotation.CONSTANT).\n       put(\"hidden\", Annotation.HIDDEN).\n+      put(\"idGenerator\", Annotation.IDGENERATOR).\n       put(\"implements\", Annotation.IMPLEMENTS).\n       put(\"implicitCast\", Annotation.IMPLICIT_CAST).\n       put(\"inheritDoc\", Annotation.INHERIT_DOC).\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n                   } else {\n                     token = eatTokensUntilEOL(token);\n                   }\n+                  continue retry;\n+\n+                case CONSISTENTIDGENERATOR:\n+                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n+                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n+                      stream.getLineno(), stream.getCharno());\n+                  }\n+                  token = eatTokensUntilEOL();\n                   continue retry;\n \n                 case CONSTANT:\n                   token = templateInfo.token;\n                   continue retry;\n \n+                case IDGENERATOR:\n+                  if (!jsdocBuilder.recordIdGenerator()) {\n+                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n+                      stream.getLineno(), stream.getCharno());\n+                  }\n+                  token = eatTokensUntilEOL();\n+                  continue retry;\n+\n                 case VERSION:\n                   ExtractionInfo versionInfo = extractSingleLineBlock();\n                   String version = versionInfo.string;\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n   private static final int MASK_EXTERNS       = 0x00008000; // @externs\n   private static final int MASK_JAVADISPATCH  = 0x00010000; // @javadispath\n   private static final int MASK_NOCOMPILE     = 0x00020000; // @nocompile\n+  // @consistentIdGenerator\n+  private static final int MASK_CONSISTIDGEN  = 0x00040000;\n+  // @idGenerator\n+  private static final int MASK_IDGEN         = 0x00080000;\n \n   // 3 bit type field stored in the top 3 bits of the most significant\n   // nibble.\n   // Visible for testing.\n   public JSDocInfo() {}\n \n+  void setConsistentIdGenerator(boolean value) {\n+    setFlag(value, MASK_CONSISTIDGEN);\n+  }\n+\n   void setConstant(boolean value) {\n     setFlag(value, MASK_CONSTANT);\n   }\n \n   void setNoShadow(boolean value) {\n     setFlag(value, MASK_NOSHADOW);\n+  }\n+\n+  void setIdGenerator(boolean value) {\n+    setFlag(value, MASK_IDGEN);\n   }\n \n   void setImplicitCast(boolean value) {\n   }\n \n   /**\n+   * @return whether the {@code @consistentIdGenerator} is present on\n+   * this {@link JSDocInfo}\n+   */\n+  public boolean isConsistentIdGenerator() {\n+    return getFlag(MASK_CONSISTIDGEN);\n+  }\n+\n+  /**\n    * Returns whether the {@code @const} annotation is present on this\n    * {@link JSDocInfo}.\n    */\n    */\n   public boolean isNoShadow() {\n     return getFlag(MASK_NOSHADOW);\n+  }\n+\n+  /**\n+   * @return whether the {@code @idGenerator} is present on\n+   * this {@link JSDocInfo}\n+   */\n+  public boolean isIdGenerator() {\n+    return getFlag(MASK_IDGEN);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n   }\n \n   /**\n+   * Records that the {@link JSDocInfo} being built should have its\n+   * {@link JSDocInfo#isConsistentIdGenerator()} flag set to\n+   * {@code true}.\n+   *\n+   * @return {@code true} if the consistentIdGenerator flag was recorded and\n+   *     {@code false} if it was already recorded\n+   */\n+  public boolean recordConsistentIdGenerator() {\n+    if (!currentInfo.isConsistentIdGenerator()) {\n+      currentInfo.setConsistentIdGenerator(true);\n+      populated = true;\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  /**\n    * Records the version.\n    */\n   public boolean recordVersion(String version) {\n       return true;\n     }\n     return false;\n+  }\n+\n+  /**\n+   * Records that the {@link JSDocInfo} being built should have its\n+   * {@link JSDocInfo#isIdGenerator()} flag set to\n+   * {@code true}.\n+   *\n+   * @return {@code true} if the idGenerator flag was recorded and {@code false}\n+   *     if it was already recorded\n+   */\n+  public boolean recordIdGenerator() {\n+    if (!currentInfo.isIdGenerator()) {\n+      currentInfo.setIdGenerator(true);\n+      populated = true;\n+      return true;\n+    } else {\n+      return false;\n+    }\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java\n+++ b/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java\n     return 1;\n   }\n \n-  public void testAssign() {\n+  public void testBackwardCompat() {\n     test(\"foo.bar = goog.events.getUniqueId('foo_bar')\",\n          \"foo.bar = 'a'\");\n   }\n \n-  public void testObjectLiteral() {\n-    test(\"foo = { bar : goog.events.getUniqueId('foo_bar')}\",\n-         \"foo = { bar : 'a' }\");\n+  public void testSimple() {\n+    test(\"/** @idGenerator */ foo.getUniqueId = function() {};\" +\n+         \"foo.bar = foo.getUniqueId('foo_bar')\",\n+\n+         \"foo.getUniqueId = function() {};\" +\n+         \"foo.bar = 'a'\");\n+\n+    test(\"/** @idGenerator */ goog.events.getUniqueId = function() {};\" +\n+        \"foo1 = goog.events.getUniqueId('foo1');\" +\n+        \"foo1 = goog.events.getUniqueId('foo1');\",\n+\n+        \"goog.events.getUniqueId = function() {};\" +\n+        \"foo1 = 'a';\" +\n+        \"foo1 = 'b';\");\n   }\n \n-  public void testTwoNamespaces() {\n-    test(\"foo.bar = goog.events.getUniqueId('foo_bar');\\n\"\n-         + \"baz.blah = goog.place.getUniqueId('baz_blah');\\n\",\n-         \"foo.bar = 'a';\\n\"\n-         + \"baz.blah = 'a'\\n\");\n+  public void testSimpleConsistent() {\n+    test(\"/** @consistentIdGenerator */ id = function() {};\" +\n+         \"foo.bar = id('foo_bar')\",\n+\n+         \"id = function() {};\" +\n+         \"foo.bar = 'a'\");\n+\n+    test(\"/** @consistentIdGenerator */ id = function() {};\" +\n+         \"f1 = id('f1');\" +\n+         \"f1 = id('f1')\",\n+\n+         \"id = function() {};\" +\n+         \"f1 = 'a';\" +\n+         \"f1 = 'a'\");\n+\n+    test(\"/** @consistentIdGenerator */ id = function() {};\" +\n+        \"f1 = id('f1');\" +\n+        \"f1 = id('f1');\" +\n+        \"f1 = id('f1')\",\n+\n+        \"id = function() {};\" +\n+        \"f1 = 'a';\" +\n+        \"f1 = 'a';\" +\n+        \"f1 = 'a'\");\n+  }\n+\n+  public void testVar() {\n+    test(\"/** @consistentIdGenerator */ var id = function() {};\" +\n+         \"foo.bar = id('foo_bar')\",\n+\n+         \"var id = function() {};\" +\n+         \"foo.bar = 'a'\");\n+  }\n+\n+  public void testObjLit() {\n+    test(\"/** @consistentIdGenerator */ get.id = function() {};\" +\n+         \"foo.bar = {a: get.id('foo_bar')}\",\n+\n+         \"get.id = function() {};\" +\n+         \"foo.bar = {a: 'a'}\");\n+  }\n+\n+  public void testTwoGenerators() {\n+    test(\"/** @idGenerator */ var id1 = function() {};\" +\n+         \"/** @idGenerator */ var id2 = function() {};\" +\n+         \"f1 = id1('1');\" +\n+         \"f2 = id1('1');\" +\n+         \"f3 = id2('1');\" +\n+         \"f4 = id2('1');\",\n+\n+         \"var id1 = function() {};\" +\n+         \"var id2 = function() {};\" +\n+         \"f1 = 'a';\" +\n+         \"f2 = 'b';\" +\n+         \"f3 = 'a';\" +\n+         \"f4 = 'b';\");\n+  }\n+\n+  public void testTwoMixedGenerators() {\n+    test(\"/** @idGenerator */ var id1 = function() {};\" +\n+         \"/** @consistentIdGenerator */ var id2 = function() {};\" +\n+         \"f1 = id1('1');\" +\n+         \"f2 = id1('1');\" +\n+         \"f3 = id2('1');\" +\n+         \"f4 = id2('1');\",\n+\n+         \"var id1 = function() {};\" +\n+         \"var id2 = function() {};\" +\n+         \"f1 = 'a';\" +\n+         \"f2 = 'b';\" +\n+         \"f3 = 'a';\" +\n+         \"f4 = 'a';\");\n   }\n \n   public void testLocalCall() {\n-    testSame(new String[] {\n-          \"function Foo() { goog.events.getUniqueId('foo'); }\"\n-        },\n+    testSame(new String[] {\"/** @idGenerator */ var id = function() {}; \" +\n+                           \"function Foo() { id('foo'); }\"},\n         ReplaceIdGenerators.NON_GLOBAL_ID_GENERATOR_CALL);\n   }\n \n   public void testConditionalCall() {\n-    testSame(new String[] {\"if (x) foo = goog.events.getUniqueId('foo')\"},\n-             ReplaceIdGenerators.CONDITIONAL_ID_GENERATOR_CALL);\n+    testSame(new String[] {\"/** @idGenerator */ var id = function() {}; \" +\n+                           \"if(x) id('foo');\"},\n+        ReplaceIdGenerators.CONDITIONAL_ID_GENERATOR_CALL);\n   }\n-}\n+\n+  public void testConflictingIdGenerator() {\n+    testSame(new String[] {\"/** @idGenerator \\n @consistentIdGenerator \\n*/\" +\n+                           \"var id = function() {}; \"},\n+        ReplaceIdGenerators.CONFLICTING_GENERATOR_TYPE);\n+  }\n+}", "timestamp": 1311814403, "metainfo": ""}