{"sha": "ecd0a7791a772cfa27a6f7dc071b2bd711517b80", "log": "Bugfix. When adding a prototype property on a @struct and the right side of the assignment isn't a function literal, don't warn. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=51069122", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     }\n   }\n \n-  /**\n-   * After a struct object is created, we can't add new properties to it, with\n-   * one exception. We allow creation of \"static\" properties like\n-   * Foo.prototype.bar = baz;\n-   * where Foo.prototype is a struct, if the assignment happens at the top level\n-   * and the constructor Foo is defined in the same file.\n-   */\n   private void checkPropCreation(NodeTraversal t, Node lvalue) {\n     if (lvalue.isGetProp()) {\n-      Node obj = lvalue.getFirstChild();\n+      JSType objType = getJSType(lvalue.getFirstChild());\n       Node prop = lvalue.getLastChild();\n-      JSType objType = getJSType(obj);\n-      String pname = prop.getString();\n-\n-      if (!objType.isStruct() || objType.hasProperty(pname)) {\n-        return;\n-      }\n-      Scope s = t.getScope();\n-      if (obj.isThis() && getJSType(s.getRootNode()).isConstructor()) {\n-        return;\n-      }\n-      // Prop created outside ctor, check that it's a static prop\n-      Node assgnExp = lvalue.getParent();\n-      Node assgnStm = assgnExp.getParent();\n-      if (objType instanceof ObjectType &&\n-          s.isGlobal() &&\n-          NodeUtil.isPrototypePropertyDeclaration(assgnStm)) {\n-        ObjectType instance =\n-            objType.toObjectType().getOwnerFunction().getInstanceType();\n-        String file = lvalue.getSourceFileName();\n-        Node ctor = instance.getConstructor().getSource();\n-        if (ctor != null && ctor.getSourceFileName().equals(file)) {\n-          JSType rvalueType = assgnExp.getLastChild().getJSType();\n-          instance.defineInferredProperty(pname, rvalueType, lvalue);\n-          return;\n-        }\n-      }\n-      report(t, prop, ILLEGAL_PROPERTY_CREATION);\n+      if (objType.isStruct() && !objType.hasProperty(prop.getString())) {\n+        report(t, prop, ILLEGAL_PROPERTY_CREATION);\n+      }\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     JSType nodeType = getJSType(obj);\n     ObjectType objectType = ObjectType.cast(\n         nodeType.restrictByNotNullOrUndefined());\n+    boolean propCreationInConstructor = obj.isThis() &&\n+        getJSType(syntacticScope.getRootNode()).isConstructor();\n+\n     if (objectType == null) {\n       registry.registerPropertyOnType(propName, nodeType);\n     } else {\n-      // Don't add the property to @struct objects outside a constructor\n       if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n-        if (!(obj.isThis() &&\n-              getJSType(syntacticScope.getRootNode()).isConstructor())) {\n-          return;\n+        // In general, we don't want to define a property on a struct object,\n+        // b/c TypeCheck will later check for improper property creation on\n+        // structs. There are two exceptions.\n+        // 1) If it's a property created inside the constructor, on the newly\n+        //    created instance, allow it.\n+        // 2) If it's a prototype property, allow it. For example:\n+        //    Foo.prototype.bar = baz;\n+        //    where Foo.prototype is a struct and the assignment happens at the\n+        //    top level and the constructor Foo is defined in the same file.\n+        boolean staticPropCreation = false;\n+        Node maybeAssignStm = getprop.getParent().getParent();\n+        if (syntacticScope.isGlobal() &&\n+            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n+          String propCreationFilename = maybeAssignStm.getSourceFileName();\n+          Node ctor = objectType.getOwnerFunction().getSource();\n+          if (ctor != null &&\n+              ctor.getSourceFileName().equals(propCreationFilename)) {\n+            staticPropCreation = true;\n+          }\n+        }\n+        if (!propCreationInConstructor && !staticPropCreation) {\n+          return; // Early return to avoid creating the property below.\n         }\n       }\n \n           } else {\n             objectType.defineInferredProperty(propName, rightType, getprop);\n           }\n-        } else if (obj.isThis() &&\n-                   getJSType(syntacticScope.getRootNode()).isConstructor()) {\n+        } else if (propCreationInConstructor) {\n           objectType.defineInferredProperty(propName, rightType, getprop);\n         } else {\n           registry.registerPropertyOnType(propName, objectType);\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n               \"function Bottom() {}\\n\" +\n               \"/** @override */\\n\" +\n               \"Bottom.prototype.foo = function() { return 3; };\");\n+  }\n+\n+  public void testSetprop15() throws Exception {\n+    // Create static property on struct\n+    testTypes(\n+        \"/** @interface */\\n\" +\n+        \"function Peelable() {};\\n\" +\n+        \"/** @return {undefined} */\\n\" +\n+        \"Peelable.prototype.peel;\\n\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @struct\\n\" +\n+        \" */\\n\" +\n+        \"function Fruit() {};\\n\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Fruit}\\n\" +\n+        \" * @implements {Peelable}\\n\" +\n+        \" */\\n\" +\n+        \"function Banana() { };\\n\" +\n+        \"function f() {};\\n\" +\n+        \"/** @override */\\n\" +\n+        \"Banana.prototype.peel = f;\");\n   }\n \n   public void testGetpropDict1() throws Exception {", "timestamp": 1377024956, "metainfo": ""}