{"sha": "2fe04268b0a5d84a8a989aa09823c451ac423a2e", "log": "Stop overly conservative if-statement preservation.  Also remove deeply-checking isLowerPrecedenceInExpression, which is a case that I don't think we ever need to check. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=45935325", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n \n         if (cond.isNot()) {\n           // if(!x)bar(); -> x||bar();\n-          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n-              isLowerPrecedenceInExpression(expr.getFirstChild(),\n+          if (isLowerPrecedence(cond.getFirstChild(), OR_PRECEDENCE) &&\n+              isLowerPrecedence(expr.getFirstChild(),\n                   OR_PRECEDENCE)) {\n             // It's not okay to add two sets of parentheses.\n             return n;\n         }\n \n         // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-            isLowerPrecedenceInExpression(expr.getFirstChild(),\n+        if (isLowerPrecedence(cond, AND_PRECEDENCE) &&\n+            isLowerPrecedence(expr.getFirstChild(),\n                 AND_PRECEDENCE)) {\n           // One additional set of parentheses is worth the change even if\n           // there is no immediate code size win. However, two extra pair of\n             Node innerElseBranch = innerThenBranch.getNext();\n \n             if (innerElseBranch == null &&\n-                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n+                 !(isLowerPrecedence(cond, AND_PRECEDENCE) &&\n+                   isLowerPrecedence(innerCond, AND_PRECEDENCE))) {\n               n.detachChildren();\n               n.addChildToBack(\n                   IR.and(\n           return false;\n       }\n     }\n-  }\n-\n-  /**\n-   * Does the expression contain an operator with lower precedence than\n-   * the argument?\n-   */\n-  private boolean isLowerPrecedenceInExpression(Node n,\n-      final int precedence) {\n-    Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() {\n-      @Override\n-      public boolean apply(Node input) {\n-        return NodeUtil.precedence(input.getType()) < precedence;\n-      }\n-    };\n-\n-    return NodeUtil.has(n, isLowerPrecedencePredicate,\n-        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     foldSame(\"if(x) var y = 1; else {y = 2; print(y)}\");\n   }\n \n+  public void testFoldIfWithLowerOperatorsInside() {\n+    fold(\"if (x + (y=5)) z && (w,z);\",\n+         \"x + (y=5) && z && (w,z)\");\n+    fold(\"if (!(x+(y=5))) z && (w,z);\",\n+         \"x + (y=5) || z && (w,z)\");\n+    fold(\"if (x + (y=5)) if (z && (w,z)) for(;;) foo();\",\n+         \"if (x + (y=5) && z && (w,z)) for(;;) foo();\");\n+  }\n+\n   public void testFoldReturnResult() {\n     fold(\"function f(){return false;}\", \"function f(){return !1}\");\n     foldSame(\"function f(){return null;}\");", "timestamp": 1367882249, "metainfo": ""}