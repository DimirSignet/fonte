{"sha": "6ef400d524e3f86cf914460b34b9c129ab74593c", "log": "A slightly more fancy name generator. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=45055678", "commit": "\n--- a/src/com/google/javascript/jscomp/NameGenerator.java\n+++ b/src/com/google/javascript/jscomp/NameGenerator.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.common.primitives.Chars;\n import com.google.javascript.rhino.TokenStream;\n \n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Set;\n \n import javax.annotation.Nullable;\n \n  *\n  */\n final class NameGenerator {\n+\n+  /**\n+   * Represents a char that can be used in renaming as well as how often\n+   * that char appears in the generated code.\n+   */\n+  private final class CharPriority implements Comparable<CharPriority>{\n+    final char name;\n+    int occurance;\n+\n+    // This is a tie-breaker when two chars occurrence count is the same.\n+    // When that happens, the 'natural' order prevails.\n+    final int order;\n+    CharPriority(char name, int order) {\n+      this.name = name;\n+      this.order = order;\n+      this.occurance = 0;\n+    }\n+\n+    @Override\n+    public int compareTo(CharPriority other) {\n+      // Start out by putting the element with more occurance first.\n+      int result = other.occurance - this.occurance;\n+      if (result != 0) {\n+        return result;\n+      }\n+      // If there is a tie, follow the order of FIRST_CHAR and NONFIRST_CHAR.\n+      result = this.order - other.order;\n+      return result;\n+    }\n+  }\n+\n+  // TODO(user): Maybe we don't need a HashMap to look up.\n+  // I started writing a skip-list like data-structure that would let us\n+  // have O(1) favors() and O(1) restartNaming() but the code gotten very messy.\n+  // Lets start with a logical implementation first until performance becomes\n+  // a problem.\n+  private final Map<Character, CharPriority> priorityLookupMap;\n+\n+  // It is important that the ordering of FIRST_CHAR is as close to NONFIRT_CHAR\n+  // as possible. Using the ASCII ordering is not a good idea. The reason\n+  // is that we cannot use numbers as FIRST_CHAR yet the ACSII value of numbers\n+  // is very small. If we picked numbers first in NONFIRST_CHAR, we would\n+  // end up balancing the huffman tree and result is bad compression.\n   /** Generate short name with this first character */\n   static final char[] FIRST_CHAR =\n     \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$\".toCharArray();\n   private final String prefix;\n   private int nameCount;\n \n-  private final char[] firstChars;\n-  private final char[] nonFirstChars;\n+  private final CharPriority[] firstChars;\n+  private final CharPriority[] nonFirstChars;\n \n   /**\n    * Creates a NameGenerator.\n     this.reservedNames = reservedNames;\n     this.prefix = prefix;\n \n+    this.priorityLookupMap = Maps.newHashMapWithExpectedSize(\n+        NONFIRST_CHAR.length);\n+\n+    int order = 0;\n+    for (char c : NONFIRST_CHAR) {\n+      priorityLookupMap.put(c, new CharPriority(c, order));\n+      order++;\n+    }\n+\n     // build the character arrays to use\n     this.firstChars = reserveCharacters(FIRST_CHAR, reservedCharacters);\n     this.nonFirstChars = reserveCharacters(NONFIRST_CHAR, reservedCharacters);\n \n     checkPrefix(prefix);\n+  }\n+\n+  /**\n+   * Restart the name generation. Re-calculate how characters are prioritized\n+   * based on how often the they appear in the final output.\n+   */\n+  public void restartNaming() {\n+    Arrays.sort(firstChars);\n+    Arrays.sort(nonFirstChars);\n+    nameCount = 0;\n+  }\n+\n+  /**\n+   * Increase the prioritization of all the chars in a String. This information\n+   * is not used until {@link #restartNaming()} is called. A compiler would be\n+   * able to generate names while changing the prioritization of the name\n+   * generator for the <b>next</b> pass.\n+   */\n+  public void favors(CharSequence sequence) {\n+    for (int i = 0; i < sequence.length(); i++) {\n+      priorityLookupMap.get(sequence.charAt(i)).occurance++;\n+    }\n   }\n \n   /**\n    * @return An array of characters to use. Will return the chars array if\n    *    reservedCharacters is null or empty, otherwise creates a new array.\n    */\n-  static char[] reserveCharacters(char[] chars, char[] reservedCharacters) {\n+  CharPriority[] reserveCharacters(char[] chars, char[] reservedCharacters) {\n     if (reservedCharacters == null || reservedCharacters.length == 0) {\n-      return chars;\n+      CharPriority[] result = new CharPriority[chars.length];\n+      for (int i = 0; i < chars.length; i++) {\n+        result[i] = priorityLookupMap.get(chars[i]);\n+      }\n+      return result;\n     }\n     Set<Character> charSet = Sets.newLinkedHashSet(Chars.asList(chars));\n     for (char reservedCharacter : reservedCharacters) {\n       charSet.remove(reservedCharacter);\n     }\n-    return Chars.toArray(charSet);\n+\n+    CharPriority[] result = new CharPriority[charSet.size()];\n+    int index = 0;\n+    for (char c : charSet) {\n+      result[index++] = priorityLookupMap.get(c);\n+    }\n+    return result;\n   }\n \n   /** Validates a name prefix. */\n     if (prefix.length() > 0) {\n       // Make sure that prefix starts with a legal character.\n       if (!contains(firstChars, prefix.charAt(0))) {\n+        char[] chars = new char[firstChars.length];\n+        for (int i = 0; i < chars.length; i++) {\n+          chars[i] = firstChars[i].name;\n+        }\n         throw new IllegalArgumentException(\"prefix must start with one of: \" +\n-                                           Arrays.toString(firstChars));\n+                                           Arrays.toString(chars));\n       }\n       for (int pos = 1; pos < prefix.length(); ++pos) {\n+        char[] chars = new char[nonFirstChars.length];\n+        for (int i = 0; i < chars.length; i++) {\n+          chars[i] = nonFirstChars[i].name;\n+        }\n         if (!contains(nonFirstChars, prefix.charAt(pos))) {\n           throw new IllegalArgumentException(\"prefix has invalid characters, \" +\n                                              \"must be one of: \" +\n-                                             Arrays.toString(nonFirstChars));\n+                                             Arrays.toString(chars));\n         }\n       }\n     }\n   }\n \n-  private boolean contains(char[] arr, char c) {\n+  private static boolean contains(CharPriority[] arr, char c) {\n     for (int i = 0; i < arr.length; i++) {\n-      if (arr[i] == c) {\n+      if (arr[i].name == c) {\n         return true;\n       }\n     }\n \n       if (name.isEmpty()) {\n         int pos = i % firstChars.length;\n-        name += firstChars[pos];\n+        name += firstChars[pos].name;\n         i /= firstChars.length;\n       }\n \n       while (i > 0) {\n         i--;\n         int pos = i % nonFirstChars.length;\n-        name += nonFirstChars[pos];\n+        name += nonFirstChars[pos].name;\n         i /= nonFirstChars.length;\n       }\n ", "timestamp": 1365550859, "metainfo": ""}