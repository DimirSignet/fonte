{"sha": "b2c046d1cda6af9818e0a3390eccd699792701c9", "log": "Clean up the equivalence relation to use less polymorphism magic. This is a big step towards addressing issue 791, but not quite there yet.  R=johnlenz DELTA=385  (198 added, 116 deleted, 71 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5632   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n           // private access is always allowed in the same file.\n           return;\n         } else if (visibility == Visibility.PRIVATE &&\n-            (currentClass == null || ownerType.differsFrom(currentClass))) {\n+            (currentClass == null || !ownerType.isEquivalentTo(currentClass))) {\n           if (docInfo.isConstructor() &&\n               isValidPrivateConstructorAccess(parent)) {\n             return;\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       }\n     }\n \n-    if (getJSType(callNode).differsFrom(narrowed)) {\n-      callNode.setJSType(narrowed);\n-    }\n+    callNode.setJSType(narrowed);\n     return scope;\n   }\n \n     Node objNode = n.getFirstChild();\n     Node property = n.getLastChild();\n     scope = traverseChildren(n, scope);\n+\n     n.setJSType(\n         getPropertyType(\n             objNode.getJSType(), property.getString(), n, scope));\n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n    * @return True if our parameter spec is equal to {@code that}'s parameter\n    *     spec.\n    */\n-  boolean hasEqualParameters(ArrowType that) {\n+  boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\n     Node thisParam = parameters.getFirstChild();\n     Node otherParam = that.parameters.getFirstChild();\n     while (thisParam != null && otherParam != null) {\n       if (thisParamType != null) {\n         // Both parameter lists give a type for this param, it should be equal\n         if (otherParamType != null &&\n-            !thisParamType.isEquivalentTo(otherParamType)) {\n+            !thisParamType.checkEquivalenceHelper(\n+                otherParamType, tolerateUnknowns)) {\n           return false;\n         }\n       } else {\n     return thisParam == otherParam;\n   }\n \n-  @Override\n-  public boolean isEquivalentTo(JSType object) {\n+  boolean checkArrowEquivalenceHelper(\n+      ArrowType that, boolean tolerateUnknowns) {\n     // Please keep this method in sync with the hashCode() method below.\n-    if (!(object instanceof ArrowType)) {\n+    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {\n       return false;\n     }\n-    ArrowType that = (ArrowType) object;\n-    if (!returnType.isEquivalentTo(that.returnType)) {\n-      return false;\n-    }\n-    return hasEqualParameters(that);\n+    return hasEqualParameters(that, tolerateUnknowns);\n   }\n \n   @Override\n \n   @Override\n   String toStringHelper(boolean forAnnotations) {\n-    return super.toString();\n+    return \"[ArrowType]\";\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n     return hasReferenceName();\n   }\n \n-  @Override\n-  public boolean isEquivalentTo(JSType that) {\n-    if (this == that) {\n-      return true;\n-    } else if (this.isNominalType()) {\n-      ObjectType thatObj = ObjectType.cast(that);\n-      if (thatObj != null && thatObj.isNominalType()) {\n-        return getReferenceName().equals(thatObj.getReferenceName());\n-      }\n-    }\n-    return false;\n-  }\n-\n   /**\n    * If this is equal to a NamedType object, its hashCode must be equal\n    * to the hashCode of the NamedType object.\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   private FunctionType tryMergeFunctionPiecewise(\n       FunctionType other, boolean leastSuper) {\n     Node newParamsNode = null;\n-    if (call.hasEqualParameters(other.call)) {\n+    if (call.hasEqualParameters(other.call, false)) {\n       newParamsNode = call.parameters;\n     } else {\n       // If the parameters are not equal, don't try to merge them.\n    * Two function types are equal if their signatures match. Since they don't\n    * have signatures, two interfaces are equal if their names match.\n    */\n-  @Override\n-  public boolean isEquivalentTo(JSType otherType) {\n-    FunctionType that =\n-        JSType.toMaybeFunctionType(otherType);\n-    if (that == null) {\n-      return false;\n-    }\n-    if (this.isConstructor()) {\n+  boolean checkFunctionEquivalenceHelper(\n+      FunctionType that, boolean tolerateUnknowns) {\n+    if (isConstructor()) {\n       if (that.isConstructor()) {\n         return this == that;\n       }\n       return false;\n     }\n-    if (this.isInterface()) {\n+    if (isInterface()) {\n       if (that.isInterface()) {\n-        return this.getReferenceName().equals(that.getReferenceName());\n+        return getReferenceName().equals(that.getReferenceName());\n       }\n       return false;\n     }\n     if (that.isInterface()) {\n       return false;\n     }\n-    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n-        this.call.isEquivalentTo(that.call);\n+\n+    return typeOfThis.checkEquivalenceHelper(\n+        that.typeOfThis, tolerateUnknowns) &&\n+        call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);\n   }\n \n   @Override\n   }\n \n   public boolean hasEqualCallType(FunctionType otherType) {\n-    return this.call.isEquivalentTo(otherType.call);\n+    return this.call.checkArrowEquivalenceHelper(otherType.call, false);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n     return hasReferenceName();\n   }\n \n-  @Override\n-  public boolean isEquivalentTo(JSType that) {\n-    if (this == that) {\n-      return true;\n-    } else if (this.isNominalType()) {\n-      ObjectType thatObj = ObjectType.cast(that);\n-      if (thatObj != null && thatObj.isNominalType()) {\n-        return getReferenceName().equals(thatObj.getReferenceName());\n-      }\n-    }\n-    return false;\n-  }\n-\n   /**\n    * If this is equal to a NamedType object, its hashCode must be equal\n    * to the hashCode of the NamedType object.\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n   /**\n    * Checks if two types are equivalent.\n    */\n-  public boolean isEquivalentTo(JSType jsType) {\n-    if (jsType instanceof ProxyObjectType) {\n-      return jsType.isEquivalentTo(this);\n-    }\n+  public final boolean isEquivalentTo(JSType jsType) {\n+    return checkEquivalenceHelper(jsType, false);\n+  }\n+\n+  /**\n+   * Whether this type is meaningfully different from {@code that} type.\n+   * This is a trickier check than pure equality, because it has to properly\n+   * handle unknown types.\n+   *\n+   * @see <a href=\"http://www.youtube.com/watch?v=_RpSv3HjpEw\">Unknown\n+   *     unknowns</a>\n+   */\n+  public final boolean differsFrom(JSType that) {\n+    return !checkEquivalenceHelper(that, true);\n+  }\n+\n+  /**\n+   * An equivalence visitor.\n+   */\n+  boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {\n+    if (this == that) {\n+      return true;\n+    }\n+\n+    boolean thisUnknown = isUnknownType();\n+    boolean thatUnknown = that.isUnknownType();\n+    if (isUnknownType() || that.isUnknownType()) {\n+      if (tolerateUnknowns) {\n+        // If we tolerate unknowns, then two types are the same if they're\n+        // both unknown.\n+        return thisUnknown && thatUnknown;\n+      } else if (thisUnknown && thatUnknown &&\n+          (isNominalType() ^ that.isNominalType())) {\n+        // If they're both unknown, but one is a nominal type and the other\n+        // is not, then we should fail out immediately. This ensures that\n+        // we won't unbox the unknowns further down.\n+        return false;\n+      }\n+    }\n+\n+    if (isUnionType() && that.isUnionType()) {\n+      return this.toMaybeUnionType().checkUnionEquivalenceHelper(\n+          that.toMaybeUnionType(), tolerateUnknowns);\n+    }\n+\n+    if (isFunctionType() && that.isFunctionType()) {\n+      return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(\n+          that.toMaybeFunctionType(), tolerateUnknowns);\n+    }\n+\n+    if (isRecordType() && that.isRecordType()) {\n+      return this.toMaybeRecordType().checkRecordEquivalenceHelper(\n+          that.toMaybeRecordType(), tolerateUnknowns);\n+    }\n+\n+    ParameterizedType thisParamType = toMaybeParameterizedType();\n+    ParameterizedType thatParamType = that.toMaybeParameterizedType();\n+    if (thisParamType != null || thatParamType != null) {\n+      // Check if one type is parameterized, but the other is not.\n+      boolean paramsMatch = false;\n+      if (thisParamType != null && thatParamType != null) {\n+        paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(\n+            thatParamType.getParameterType(), tolerateUnknowns);\n+      } else if (tolerateUnknowns) {\n+        paramsMatch = true;\n+      } else {\n+        paramsMatch = false;\n+      }\n+\n+      JSType thisRootType = thisParamType == null ?\n+          this : thisParamType.getReferencedTypeInternal();\n+      JSType thatRootType = thatParamType == null ?\n+          that : thatParamType.getReferencedTypeInternal();\n+      return paramsMatch &&\n+          thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);\n+    }\n+\n+    if (isNominalType() && that.isNominalType()) {\n+      return toObjectType().getReferenceName().equals(\n+          that.toObjectType().getReferenceName());\n+    }\n+\n+    // Unbox other proxies.\n+    if (this instanceof ProxyObjectType) {\n+      return ((ProxyObjectType) this)\n+          .getReferencedTypeInternal().checkEquivalenceHelper(\n+              that, tolerateUnknowns);\n+    }\n+\n+    if (that instanceof ProxyObjectType) {\n+      return checkEquivalenceHelper(\n+          ((ProxyObjectType) that).getReferencedTypeInternal(),\n+          tolerateUnknowns);\n+    }\n+\n     // Relies on the fact that for the base {@link JSType}, only one\n     // instance of each sub-type will ever be created in a given registry, so\n     // there is no need to verify members. If the object pointers are not\n     // identical, then the type member must be different.\n-    return this == jsType;\n+    return this == that;\n   }\n \n   public static boolean isEquivalent(JSType typeA, JSType typeB) {\n   }\n \n   /**\n-   * Whether this type is meaningfully different from {@code that} type.\n-   * This is a trickier check than pure equality, because it has to properly\n-   * handle unknown types.\n-   *\n-   * @see <a href=\"http://www.youtube.com/watch?v=_RpSv3HjpEw\">Unknown\n-   *     unknowns</a>\n-   */\n-  public boolean differsFrom(JSType that) {\n-    // if there are no unknowns, just use normal equality.\n-    if (!this.isUnknownType() && !that.isUnknownType()) {\n-      return !this.isEquivalentTo(that);\n-    }\n-    // otherwise, they're different iff one is unknown and the other is not.\n-    return this.isUnknownType() ^ that.isUnknownType();\n-  }\n-\n-  /**\n    * A generic implementation meant to be used as a helper for common subtyping\n    * cases.\n    */\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n   @Override\n   public boolean isNominalType() {\n     return true;\n-  }\n-\n-  /**\n-   * Two named types are equivalent if they are the same {@code\n-   * ObjectType} object.  This is complicated by the fact that isEquivalent\n-   * is sometimes called before we have a chance to resolve the type\n-   * names.\n-   *\n-   * @return {@code true} iff {@code that} == {@code this} or {@code that}\n-   *         is a {@link NamedType} whose reference is the same as ours,\n-   *         or {@code that} is the type we reference.\n-   */\n-  @Override\n-  public boolean isEquivalentTo(JSType that) {\n-    if (this == that) {\n-      return true;\n-    }\n-\n-    ObjectType objType = ObjectType.cast(that);\n-    if (objType != null) {\n-      return objType.isNominalType() &&\n-          reference.equals(objType.getReferenceName());\n-    }\n-    return false;\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n   }\n \n   @Override\n-  public boolean isEquivalentTo(JSType that) {\n-    return this == that;\n-  }\n-\n-  @Override\n   public int hashCode() {\n     return System.identityHashCode(this);\n   }\n--- a/src/com/google/javascript/rhino/jstype/ParameterizedType.java\n+++ b/src/com/google/javascript/rhino/jstype/ParameterizedType.java\n   }\n \n   @Override\n-  public boolean isEquivalentTo(JSType that) {\n-    return (super.isEquivalentTo(that)\n-        && JSType.isEquivalent(\n-            parameterType, that.toObjectType().getParameterType()));\n-  }\n-\n-  @Override\n   String toStringHelper(boolean forAnnotations) {\n     String result = super.toStringHelper(forAnnotations);\n     return result + \".<\" + parameterType.toStringHelper(forAnnotations) + \">\";\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n       // to avoid guessing.\n       return true;\n     }\n-    return this.isImplicitPrototype(thatObj);\n+    return thatObj != null && this.isImplicitPrototype(thatObj);\n   }\n \n   private boolean implicitPrototypeChainIsUnknown() {\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public boolean isEquivalentTo(JSType that) {\n-    if (this == that) {\n-      return true;\n-    }\n-    return referencedType.isEquivalentTo(that);\n-  }\n-\n-  @Override\n   public int hashCode() {\n     return referencedType.hashCode();\n   }\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n     return !declared;\n   }\n \n-  @Override\n-  public boolean isEquivalentTo(JSType other) {\n-    if (!other.isRecordType()) {\n-      return false;\n-    }\n-\n-    // Compare properties.\n-    RecordType otherRecord = other.toMaybeRecordType();\n-    if (otherRecord == this) {\n-      return true;\n-    }\n-\n+  boolean checkRecordEquivalenceHelper(\n+      RecordType otherRecord, boolean tolerateUnknowns) {\n     Set<String> keySet = properties.keySet();\n     Map<String, JSType> otherProps = otherRecord.properties;\n     if (!otherProps.keySet().equals(keySet)) {\n       return false;\n     }\n     for (String key : keySet) {\n-      if (!otherProps.get(key).isEquivalentTo(properties.get(key))) {\n+      if (!otherProps.get(key).checkEquivalenceHelper(\n+              properties.get(key), tolerateUnknowns)) {\n         return false;\n       }\n     }\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n    * Two union types are equal if they have the same number of alternates\n    * and all alternates are equal.\n    */\n-  @Override\n-  public boolean isEquivalentTo(JSType object) {\n-    if (object == null) {\n+  boolean checkUnionEquivalenceHelper(\n+      UnionType that, boolean tolerateUnknowns) {\n+    if (!tolerateUnknowns && alternates.size() != that.alternates.size()) {\n       return false;\n     }\n-    if (object.isUnionType()) {\n-      UnionType that = object.toMaybeUnionType();\n-      if (alternates.size() != that.alternates.size()) {\n+    for (JSType alternate : that.alternates) {\n+      if (!hasAlternate(alternate, tolerateUnknowns)) {\n         return false;\n       }\n-      for (JSType alternate : that.alternates) {\n-        if (!hasAlternate(alternate)) {\n-          return false;\n-        }\n-      }\n-      return true;\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  private boolean hasAlternate(JSType type) {\n+    }\n+    return true;\n+  }\n+\n+  private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n     for (JSType alternate : alternates) {\n-      if (alternate.isEquivalentTo(type)) {\n+      if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n         return true;\n       }\n     }\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.ParameterizedType;\n import com.google.javascript.rhino.jstype.RecordTypeBuilder;\n \n import junit.framework.TestCase;\n   protected final void assertTypeNotEquals(String msg, JSType a, JSType b) {\n     Asserts.assertTypeNotEquals(msg, a, b);\n   }\n+\n+  protected final ParameterizedType parameterize(ObjectType objType, JSType t) {\n+    return registry.createParameterizedType(objType, t);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"Property unknownProp never defined on Type\");\n   }\n \n+  public void testIssue791() throws Exception {\n+    // TODO(nicksantos): This warning is wrong, and should be fixed.\n+    testTypes(\n+        \"/** @param {{func: function()}} obj */\" +\n+        \"function test1(obj) {}\" +\n+        \"var fnStruc1 = {};\" +\n+        \"fnStruc1.func = function() {};\" +\n+        \"test1(fnStruc1);\",\n+        \"actual parameter 1 of test1 does not match formal parameter\\n\" +\n+        \"found   : {func: function (): undefined}\\n\" +\n+        \"required: {func: function (): ?}\");\n+  }\n+\n   public void testIssue810() throws Exception {\n     testTypes(\n         \"/** @constructor */\" +\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n     verifySubtypeOf(\"y\", OBJECT_TYPE);\n   }\n \n+  public void testFor5() {\n+    assuming(\"y\", parameterize(\n+        getNativeObjectType(ARRAY_TYPE), getNativeType(NUMBER_TYPE)));\n+    inFunction(\n+        \"var x = null; for (var i = 0; i < y.length; i++) { x = y[i]; }\");\n+    verify(\"x\", createNullableType(NUMBER_TYPE));\n+    verify(\"i\", NUMBER_TYPE);\n+  }\n+\n+  public void testFor6() {\n+    assuming(\"y\", getNativeObjectType(ARRAY_TYPE));\n+    inFunction(\n+        \"var x = null;\" +\n+        \"for (var i = 0; i < y.length; i++) { \" +\n+        \" if (y[i] == 'z') { x = y[i]; } \" +\n+        \"}\");\n+    verify(\"x\", getNativeType(UNKNOWN_TYPE));\n+    verify(\"i\", NUMBER_TYPE);\n+  }\n+\n   public void testSwitch1() {\n     assuming(\"x\", NUMBER_TYPE);\n     inFunction(\"var y = null; switch(x) {\\n\" +\n         \"out = x.prop;\");\n     verify(\"out\", CHECKED_UNKNOWN_TYPE);\n   }\n+\n+  private ObjectType getNativeObjectType(JSTypeNative t) {\n+    return registry.getNativeObjectType(t);\n+  }\n+\n+  private JSType getNativeType(JSTypeNative t) {\n+    return registry.getNativeType(t);\n+  }\n+\n+  private JSType parameterize(ObjectType objType, JSType t) {\n+    return registry.createParameterizedType(objType, t);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n \n   public void testParseParametrizedType1() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<number> */\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType());\n   }\n \n   public void testParseParametrizedType2() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<number>}*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType());\n   }\n \n   public void testParseParametrizedType3() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<(number,null)>*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),\n+        info.getType());\n   }\n \n   public void testParseParametrizedType4() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<(number|null)>}*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),\n+        info.getType());\n   }\n \n   public void testParseParametrizedType5() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<Array.<(number|null)>>}*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE,\n+            createUnionType(NULL_TYPE,\n+                parameterize(ARRAY_TYPE,\n+                    createUnionType(NUMBER_TYPE, NULL_TYPE)))),\n+        info.getType());\n   }\n \n   public void testParseParametrizedType6() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<!Array.<(number|null)>>}*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE,\n+            parameterize(ARRAY_TYPE,\n+                createUnionType(NUMBER_TYPE, NULL_TYPE))),\n+        info.getType());\n   }\n \n   public void testParseParametrizedType7() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<function():Date>}*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE,\n+            registry.createFunctionType(\n+                createUnionType(DATE_TYPE, NULL_TYPE))),\n+        info.getType());\n   }\n \n   public void testParseParametrizedType8() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<function():!Date>}*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE,\n+            registry.createFunctionType(DATE_TYPE)),\n+        info.getType());\n   }\n \n   public void testParseParametrizedType9() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<Date|number>}*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE,\n+            createUnionType(DATE_TYPE, NUMBER_TYPE, NULL_TYPE)),\n+        info.getType());\n   }\n \n   public void testParseParametrizedType10() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<Date|number|boolean>}*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n-  }\n-\n-  public void testParseParamterizedType11() throws Exception {\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE,\n+            createUnionType(DATE_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE)),\n+        info.getType());\n+  }\n+\n+  public void testParseParameterizedType11() throws Exception {\n     JSDocInfo info = parse(\"@type {!Object.<number>}*/\");\n-    assertTypeEquals(OBJECT_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(OBJECT_TYPE, NUMBER_TYPE),\n+        info.getType());\n     assertParameterTypeEquals(NUMBER_TYPE, info.getType());\n   }\n \n-  public void testParseParamterizedType12() throws Exception {\n+  public void testParseParameterizedType12() throws Exception {\n     JSDocInfo info = parse(\"@type {!Object.<string,number>}*/\");\n-    assertTypeEquals(OBJECT_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(OBJECT_TYPE, NUMBER_TYPE), info.getType());\n     assertParameterTypeEquals(NUMBER_TYPE, info.getType());\n     assertIndexTypeEquals(STRING_TYPE, info.getType());\n   }\n \n   public void testParseUnionType4() throws Exception {\n     JSDocInfo info = parse(\"@type {(Array.<boolean>,null)}*/\");\n-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+    assertTypeEquals(createUnionType(\n+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType5() throws Exception {\n     JSDocInfo info = parse(\"@type {(null, Array.<boolean>)}*/\");\n-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+    assertTypeEquals(createUnionType(\n+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType6() throws Exception {\n     JSDocInfo info = parse(\"@type {Array.<boolean>|null}*/\");\n-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+    assertTypeEquals(createUnionType(\n+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType7() throws Exception {\n     JSDocInfo info = parse(\"@type {null|Array.<boolean>}*/\");\n-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+    assertTypeEquals(createUnionType(\n+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType8() throws Exception {\n     JSDocInfo info = parse(\"@type {null||Array.<boolean>}*/\");\n-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+    assertTypeEquals(createUnionType(\n+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType9() throws Exception {\n     JSDocInfo info = parse(\"@type {Array.<boolean>||null}*/\");\n-    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+    assertTypeEquals(createUnionType(\n+        parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType10() throws Exception {\n \n   public void testParseNullableModifiers2() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<string?>}*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE, createUnionType(STRING_TYPE, NULL_TYPE)),\n+        info.getType());\n   }\n \n   public void testParseNullableModifiers3() throws Exception {\n     JSDocInfo info = parse(\"@type {Array.<boolean>?}*/\");\n-    assertTypeEquals(createNullableType(ARRAY_TYPE), info.getType());\n+    assertTypeEquals(\n+        createNullableType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE)),\n+        info.getType());\n   }\n \n   public void testParseNullableModifiers4() throws Exception {\n \n   public void testParseNewline2() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<\\n* number\\n* > */\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType());\n   }\n \n   public void testParseNewline3() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<(number,\\n* null)>*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),\n+        info.getType());\n   }\n \n   public void testParseNewline4() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<(number|\\n* null)>*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),\n+        info.getType());\n   }\n \n   public void testParseNewline5() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<function(\\n* )\\n* :\\n* Date>*/\");\n-    assertTypeEquals(ARRAY_TYPE, info.getType());\n+    assertTypeEquals(\n+        parameterize(ARRAY_TYPE,\n+            registry.createFunctionType(\n+                createUnionType(DATE_TYPE, NULL_TYPE))),\n+        info.getType());\n   }\n \n   public void testParseReturnType1() throws Exception {\n     JSDocInfo info =\n         parse(\"@return {null|string|Array.<boolean>}*/\");\n     assertTypeEquals(\n-        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE),\n+        createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE),\n+            NULL_TYPE, STRING_TYPE),\n         info.getReturnType());\n   }\n \n     JSDocInfo info =\n         parse(\"@returns {null|(string,Array.<boolean>)}*/\");\n     assertTypeEquals(\n-        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE),\n+        createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE),\n+            NULL_TYPE, STRING_TYPE),\n         info.getReturnType());\n   }\n \n     JSDocInfo info =\n         parse(\"@return {((null||Array.<boolean>,string),boolean)}*/\");\n     assertTypeEquals(\n-        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE, BOOLEAN_TYPE),\n+        createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE),\n+            NULL_TYPE, STRING_TYPE, BOOLEAN_TYPE),\n         info.getReturnType());\n   }\n \n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n \n   public void testIsEquivalentTo() {\n     FunctionType type = new FunctionBuilder(registry).build();\n-    assertFalse(type.isEquivalentTo(null));\n+    assertFalse(type.equals(null));\n     assertTrue(type.isEquivalentTo(type));\n   }\n \n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n         NULL_TYPE.getGreatestSubtype(\n             createUnionType(forwardDeclaredNamedType, NULL_TYPE)));\n     assertFalse(NULL_TYPE.isNominalConstructor());\n+\n+    assertTrue(NULL_TYPE.differsFrom(UNKNOWN_TYPE));\n   }\n \n   /**\n--- a/test/com/google/javascript/rhino/jstype/UnionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/UnionTypeTest.java\n \n   public void testIsEquivalentTo() {\n     UnionType type = (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE);\n-    assertFalse(type.isEquivalentTo(null));\n+    assertFalse(type.equals(null));\n     assertTrue(type.isEquivalentTo(type));\n   }\n ", "timestamp": 1349797286, "metainfo": ""}