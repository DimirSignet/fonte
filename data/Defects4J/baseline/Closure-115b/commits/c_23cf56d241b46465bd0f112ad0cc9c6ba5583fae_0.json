{"sha": "23cf56d241b46465bd0f112ad0cc9c6ba5583fae", "log": "Introduce InlineObjectLiterals Pass.  R=johnlenz DELTA=700  (700 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1774   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Supplier;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * Using the infrastructure provided by {@link ReferenceCollectingCallback},\n+ * identify variables that are only ever assigned to object literals\n+ * and that are never used in entirety, and expand the objects into\n+ * individual variables.\n+ *\n+ * Based on the InlineVariables pass\n+ *\n+ */\n+class InlineObjectLiterals implements CompilerPass {\n+\n+  public static final String VAR_PREFIX = \"JSCompiler_object_inline_\";\n+\n+  private final AbstractCompiler compiler;\n+\n+  private final Supplier<String> safeNameIdSupplier;\n+\n+  InlineObjectLiterals(\n+      AbstractCompiler compiler,\n+      Supplier<String> safeNameIdSupplier) {\n+    this.compiler = compiler;\n+    this.safeNameIdSupplier = safeNameIdSupplier;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n+        compiler, new InliningBehavior(), Predicates.<Var>alwaysTrue());\n+    callback.process(externs, root);\n+  }\n+\n+  /**\n+   * Builds up information about nodes in each scope. When exiting the\n+   * scope, inspects all variables in that scope, and inlines any\n+   * that we can.\n+   */\n+  private class InliningBehavior implements Behavior {\n+\n+    /**\n+     * A list of variables that should not be inlined, because their\n+     * reference information is out of sync with the state of the AST.\n+     */\n+    private final Set<Var> staleVars = Sets.newHashSet();\n+\n+    @Override\n+    public void afterExitScope(NodeTraversal t,\n+        Map<Var, ReferenceCollection> referenceMap) {\n+      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n+        Var v = it.next();\n+\n+        if (isVarInlineForbidden(v)) {\n+            continue;\n+        }\n+\n+        ReferenceCollection referenceInfo = referenceMap.get(v);\n+\n+        if (isInlinableObject(referenceInfo.references)) {\n+            // Blacklist the object itself, as well as any other values\n+            // that it refers to, since they will have been moved around.\n+            staleVars.add(v);\n+\n+            Reference declaration = referenceInfo.references.get(0);\n+            Reference init = referenceInfo.getInitializingReference();\n+\n+            // Split up the object into individual variables if the object\n+            // is never referenced directly in full.\n+            splitObject(v, declaration, init, referenceInfo);\n+        }\n+      }\n+    }\n+\n+    /**\n+     * If there are any variable references in the given node tree,\n+     * blacklist them to prevent the pass from trying to inline the\n+     * variable. Any code modifications will have potentially made the\n+     * ReferenceCollection invalid.\n+     */\n+    private void blacklistVarReferencesInTree(Node root, Scope scope) {\n+      for (Node c = root.getFirstChild(); c != null; c = c.getNext()) {\n+        blacklistVarReferencesInTree(c, scope);\n+      }\n+\n+      if (root.getType() == Token.NAME) {\n+        staleVars.add(scope.getVar(root.getString()));\n+      }\n+    }\n+\n+    /**\n+     * Whether the given variable is forbidden from being inlined.\n+     */\n+    private boolean isVarInlineForbidden(Var var) {\n+      // A variable may not be inlined if:\n+      // 1) The variable is exported,\n+      // 2) Don't inline the special RENAME_PROPERTY_FUNCTION_NAME\n+      // 3) A reference to the variable has been inlined. We're downstream\n+      //    of the mechanism that creates variable references, so we don't\n+      //    have a good way to update the reference. Just punt on it.\n+      return compiler.getCodingConvention().isExported(var.name)\n+          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)\n+          || staleVars.contains(var);\n+    }\n+\n+    /**\n+     * Counts the number of direct (full) references to an object.\n+     * Specifically we check for references of the following type:\n+     * <pre>\n+     *   x;\n+     *   x.fn();\n+     * </pre>\n+     */\n+    private boolean isInlinableObject(List<Reference> refs) {\n+      boolean ret = false;\n+      for (Reference ref : refs) {\n+        Node name = ref.getNameNode();\n+        Node parent = ref.getParent();\n+        Node gramps = ref.getGrandparent();\n+\n+        // Ignore indirect references, like x.y (except x.y(), since\n+        // the function referenced by y might reference 'this').\n+        //\n+        // TODO: If a function is called, figure out if it references\n+        // 'this', and if not, then inlining the object should be OK.\n+        if (parent.getType() == Token.GETPROP &&\n+            (gramps.getType() != Token.CALL ||\n+             gramps.getFirstChild() != parent) &&\n+            parent.getFirstChild().isEquivalentTo(name)) {\n+          continue;\n+        }\n+\n+        // Full references mean that we can't inline the object.\n+        if (!ref.isLvalue() && !ref.isInitializingDeclaration()) {\n+          if (parent.getType() != Token.VAR) {\n+            // This is a full reference to the object, we can't inline.\n+            return false;\n+          }\n+\n+          // var x; We can ignore safely.\n+          continue;\n+        }\n+\n+        Node val = ref.getAssignedValue();\n+        if (val == null) {\n+          // Var with no assignment. Keep going.\n+          continue;\n+        }\n+\n+        // We're looking for object literal assignments only.\n+        if (val.getType() != Token.OBJECTLIT) {\n+          return false;\n+        }\n+\n+        // Make sure that the value is not self-refential. IOW,\n+        // disallow things like x = {b: x.a}.\n+        //\n+        // TODO: Only exclude unorderable self-referential\n+        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n+        // but x = {a: 1, b: x.a} is.\n+        //\n+        // Also, ES5 getters/setters aren't handled by this pass.\n+        for (Node child = val.getFirstChild(); child != null;\n+             child = child.getNext()) {\n+          if (child.getType() == Token.GET ||\n+              child.getType() == Token.SET) {\n+            // ES5 get/set not supported.\n+            return false;\n+          }\n+          Node childVal = child.getFirstChild();\n+          // Check if childVal is the parent of any of the passed in\n+          // references, as that is how self-referential assignments\n+          // will happen.\n+          for (Reference t : refs) {\n+            Node refNode = t.getParent();\n+            while (!NodeUtil.isStatementBlock(refNode)) {\n+              if (refNode == childVal) {\n+                // There's a self-referential assignment\n+                return false;\n+              }\n+              refNode = refNode.getParent();\n+            }\n+          }\n+        }\n+\n+        // This is an assignment to an object literal. Make sure that\n+        // this isn't inside some giant GETPROP thing, e.g.\n+        // (x = {}).c = 5 (even though technically we could work out the\n+        // (x = {}).c case without the assignment, that's a sufficiently odd\n+        // case to not worry about it.\n+        Node p = parent;\n+        while ((p = p.getParent()) != null) {\n+          if (p.getType() == Token.GETPROP) {\n+            return false;\n+          }\n+        }\n+\n+        // We have found an acceptable object literal assignment. As\n+        // long as there are no other assignments that mess things up,\n+        // we can inline.\n+        ret = true;\n+      }\n+      return ret;\n+    }\n+\n+    /**\n+     * Computes a list of ever-referenced keys in the object being\n+     * inlined, and returns a mapping of key name -> generated\n+     * variable name.\n+     */\n+    private Map<String, String> computeVarList(\n+        Var v, ReferenceCollection referenceInfo) {\n+      Map<String, String> varmap = Maps.newHashMap();\n+\n+      for (Reference ref : referenceInfo.references) {\n+        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n+          Node val = ref.getAssignedValue();\n+          if (val != null) {\n+            for (Node child = val.getFirstChild(); child != null;\n+                 child = child.getNext()) {\n+              String varname = child.getString();\n+              if (varmap.containsKey(varname)) {\n+                continue;\n+              }\n+\n+              String var = VAR_PREFIX + varname + \"_\" +\n+                safeNameIdSupplier.get();\n+              varmap.put(varname, var);\n+            }\n+          }\n+        } else if (ref.getParent().getType() == Token.VAR) {\n+          // This is the var. There is no value.\n+        } else {\n+          Node getprop = ref.getParent();\n+          Preconditions.checkState(\n+            getprop.getType() == Token.GETPROP,\n+            \"Unexpected reference type: \" + Token.name(getprop.getType()));\n+          Preconditions.checkState(\n+            getprop.getFirstChild().getString().equals(v.getName()),\n+            \"Unexpected variable name: \" + getprop.getFirstChild().getString() +\n+            \", expecting: \" + v.getName());\n+\n+          // The key being looked up in the original map.\n+          String varname = getprop.getLastChild().getString();\n+          if (varmap.containsKey(varname)) {\n+            continue;\n+          }\n+\n+          String var = VAR_PREFIX + varname + \"_\" + safeNameIdSupplier.get();\n+          varmap.put(varname, var);\n+        }\n+      }\n+\n+      return varmap;\n+    }\n+\n+    /**\n+     * Populates a map of key names -> initial assigned values. The\n+     * object literal these are being pulled from is invalidated as\n+     * a result.\n+     */\n+    private void fillInitialValues(Reference init, Map<String, Node> initvals) {\n+      Node object = init.getAssignedValue();\n+      Preconditions.checkState(object.getType() == Token.OBJECTLIT);\n+      for (Node key = object.getFirstChild(); key != null;\n+           key = key.getNext()) {\n+        initvals.put(key.getString(), key.removeFirstChild());\n+      }\n+    }\n+\n+    /**\n+     * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n+     * Note that the resulting expression will always evaluate to\n+     * true, as would the x = {...} expression.\n+     */\n+    private void replaceAssignmentExpression(Var v, Reference ref,\n+                                             Map<String, String> varmap) {\n+      // Compute all of the assignments necessary\n+      List<Node> nodes = Lists.newArrayList();\n+      Node val = ref.getAssignedValue();\n+      blacklistVarReferencesInTree(val, v.scope);\n+      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n+      Set<String> all = Sets.newHashSet(varmap.keySet());\n+      for (Node key = val.getFirstChild(); key != null;\n+           key = key.getNext()) {\n+        String var = key.getString();\n+        Node value = key.removeFirstChild();\n+        // TODO(user): Copy type information.\n+        nodes.add(\n+          new Node(Token.ASSIGN,\n+                   Node.newString(Token.NAME, varmap.get(var)), value));\n+        all.remove(var);\n+      }\n+\n+      // TODO(user): Better source information.\n+      for (String var : all) {\n+        nodes.add(\n+          new Node(Token.ASSIGN,\n+                   Node.newString(Token.NAME, varmap.get(var)),\n+                   NodeUtil.newUndefinedNode(null)));\n+      }\n+\n+      // All assignments evaluate to true, so make sure that the\n+      // expr statement evaluates to true in case it matters.\n+      nodes.add(new Node(Token.TRUE));\n+\n+      // Join these using COMMA.  A COMMA node must have 2 children, so we\n+      // create a tree. In the tree the first child be the COMMA to match\n+      // the parser, otherwise tree equality tests fail.\n+      nodes = Lists.reverse(nodes);\n+      Node replacement = new Node(Token.COMMA);\n+      Node cur = replacement;\n+      int i;\n+      for (i = 0; i < nodes.size() - 2; i++) {\n+        cur.addChildToFront(nodes.get(i));\n+        Node t = new Node(Token.COMMA);\n+        cur.addChildToFront(t);\n+        cur = t;\n+      }\n+      cur.addChildToFront(nodes.get(i));\n+      cur.addChildToFront(nodes.get(i + 1));\n+\n+      Node replace = ref.getParent();\n+      replacement.copyInformationFromForTree(replace);\n+\n+      if (replace.getType() == Token.VAR) {\n+        replace.getParent().replaceChild(\n+            replace, NodeUtil.newExpr(replacement));\n+      } else {\n+        replace.getParent().replaceChild(replace, replacement);\n+      }\n+    }\n+\n+    /**\n+     * Splits up the object literal into individual variables, and\n+     * updates all uses.\n+     */\n+    private void splitObject(Var v, Reference declaration,\n+                             Reference init,\n+                             ReferenceCollection referenceInfo) {\n+      // First figure out the FULL set of possible keys, so that they\n+      // can all be properly set as necessary.\n+      Map<String, String> varmap = computeVarList(v, referenceInfo);\n+\n+      Map<String, Node> initvals = Maps.newHashMap();\n+      // Figure out the top-level of the var assign node. If it's a plain\n+      // ASSIGN, then there's an EXPR_STATEMENT above it, if it's a\n+      // VAR then it should be directly replaced.\n+      Node vnode;\n+      boolean defined = referenceInfo.isWellDefined() &&\n+          init.getParent().getType() == Token.VAR;\n+      if (defined) {\n+        vnode = init.getParent();\n+        fillInitialValues(init, initvals);\n+      } else {\n+        // TODO(user): More test / rewrite this part.\n+        // Find the beginning of the function / script.\n+        vnode = v.getScope().getRootNode().getLastChild().getFirstChild();\n+      }\n+\n+      for (Map.Entry<String, String> entry : varmap.entrySet()) {\n+        Node val = initvals.get(entry.getKey());\n+        Node varnode = NodeUtil.newVarNode(entry.getValue(), val);\n+        if (val == null) {\n+          // is this right?\n+          varnode.copyInformationFromForTree(vnode);\n+        }\n+        vnode.getParent().addChildBefore(varnode, vnode);\n+      }\n+\n+      if (defined) {\n+        vnode.getParent().removeChild(vnode);\n+      }\n+\n+      for (Reference ref : referenceInfo.references) {\n+        // The init/decl have already been converted.\n+        if (defined && ref == init) continue;\n+\n+        if (ref.isLvalue()) {\n+          // Assignments have to be handled specially, since they\n+          // expand out into multiple assignments.\n+          replaceAssignmentExpression(v, ref, varmap);\n+        } else if (ref.getParent().getType() == Token.VAR) {\n+          // The old variable declaration. It didn't have a\n+          // value. Remove it entirely as it should now be unused.\n+          ref.getGrandparent().removeChild(ref.getParent());\n+        } else {\n+          // Make sure that the reference is a GETPROP as we expect it to be.\n+          Node getprop = ref.getParent();\n+          Preconditions.checkState(\n+            getprop.getType() == Token.GETPROP,\n+            \"Unexpected reference type: \" + Token.name(getprop.getType()));\n+          Preconditions.checkState(\n+            getprop.getFirstChild().getString().equals(v.getName()),\n+            \"Unexpected variable name: \" + getprop.getFirstChild().getString() +\n+            \", expecting: \" + v.getName());\n+\n+          // The key being looked up in the original map.\n+          String var = getprop.getChildAtIndex(1).getString();\n+\n+          // If the variable hasn't already been declared, add an empty\n+          // declaration near all the other declarations.\n+          Preconditions.checkState(varmap.containsKey(var));\n+\n+          // Replace the GETPROP node with a NAME.\n+          Node replacement = Node.newString(Token.NAME, varmap.get(var));\n+          replacement.copyInformationFrom(getprop);\n+          ref.getGrandparent().replaceChild(ref.getParent(), replacement);\n+        }\n+      }\n+\n+      compiler.reportCodeChange();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/InlineObjectLiteralsTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Verifies that valid candidates for object literals are inlined as\n+ * expected, and invalid candidates are not touched.\n+ *\n+ */\n+public class InlineObjectLiteralsTest extends CompilerTestCase {\n+\n+  public InlineObjectLiteralsTest() {\n+    enableNormalize();\n+  }\n+\n+  @Override\n+  public void setUp() {\n+    super.enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(final Compiler compiler) {\n+    return new InlineObjectLiterals(\n+        compiler,\n+        compiler.getUniqueNameIdSupplier());\n+  }\n+\n+  // Test object literal -> variable inlining\n+  public void testObject1() {\n+    test(\"var a = {x:x, y:y}; f(a.x, a.y);\",\n+         \"var JSCompiler_object_inline_y_1=y;\" +\n+         \"var JSCompiler_object_inline_x_0=x;\" +\n+         \"f(JSCompiler_object_inline_x_0, JSCompiler_object_inline_y_1);\");\n+  }\n+\n+  public void testObject2() {\n+    test(\"var a = {y:y}; a.x = z; f(a.x, a.y);\",\n+         \"var JSCompiler_object_inline_y_0 = y;\" +\n+         \"var JSCompiler_object_inline_x_1;\" +\n+         \"JSCompiler_object_inline_x_1=z;\" +\n+         \"f(JSCompiler_object_inline_x_1, JSCompiler_object_inline_y_0);\");\n+  }\n+\n+  public void testObject3() {\n+    // Inlining the 'y' would cause the 'this' to be different in the\n+    // target function.\n+    testSame(\"var a = {y:y,x:x}; a.y(); f(a.x);\");\n+  }\n+\n+  public void testObject4() {\n+    // Object literal is escaped.\n+    testSame(\"var a = {y:y}; a.x = z; f(a.x, a.y); g(a);\");\n+  }\n+\n+  public void testObject5() {\n+    test(\"var a = {x:x, y:y}; var b = {a:a}; f(b.a.x, b.a.y);\",\n+         \"var a = {x:x, y:y};\" +\n+         \"var JSCompiler_object_inline_a_0=a;\" +\n+         \"f(JSCompiler_object_inline_a_0.x, JSCompiler_object_inline_a_0.y);\");\n+  }\n+\n+  public void testObject6() {\n+    test(\"for (var i = 0; i < 5; i++) { var a = {i:i,x:x}; f(a.i, a.x); }\",\n+         \"for (var i = 0; i < 5; i++) {\" +\n+         \"  var JSCompiler_object_inline_x_1=x;\" +\n+         \"  var JSCompiler_object_inline_i_0=i;\" +\n+         \"  f(JSCompiler_object_inline_i_0,JSCompiler_object_inline_x_1)\" +\n+         \"}\");\n+    test(\"if (c) { var a = {i:i,x:x}; f(a.i, a.x); }\",\n+         \"if (c) {\" +\n+         \"  var JSCompiler_object_inline_x_1=x;\" +\n+         \"  var JSCompiler_object_inline_i_0=i;\" +\n+         \"  f(JSCompiler_object_inline_i_0,JSCompiler_object_inline_x_1)\" +\n+         \"}\");\n+  }\n+\n+  public void testObject7() {\n+    test(\"var a = {x:x, y:f()}; g(a.x);\",\n+         \"var JSCompiler_object_inline_y_1=f();\" +\n+         \"var JSCompiler_object_inline_x_0=x;\" +\n+         \"g(JSCompiler_object_inline_x_0)\");\n+  }\n+\n+  public void testObject8() {\n+    testSame(\"var a = {x:x,y:y}; var b = {x:y}; f((c?a:b).x);\");\n+\n+    test(\"var a; if(c) { a={x:x, y:y}; } else { a={x:y}; } f(a.x);\",\n+         \"var JSCompiler_object_inline_y_1;\" +\n+         \"var JSCompiler_object_inline_x_0;\" +\n+         \"if(c) JSCompiler_object_inline_x_0=x,\" +\n+         \"      JSCompiler_object_inline_y_1=y,\" +\n+         \"      true;\" +\n+         \"else JSCompiler_object_inline_x_0=y,\" +\n+         \"     JSCompiler_object_inline_y_1=void 0,\" +\n+         \"     true;\" +\n+         \"f(JSCompiler_object_inline_x_0)\");\n+    test(\"var a = {x:x,y:y}; var b = {x:y}; c ? f(a.x) : f(b.x);\",\n+         \"var JSCompiler_object_inline_y_1 = y; \" +\n+         \"var JSCompiler_object_inline_x_0 = x; \" +\n+         \"var JSCompiler_object_inline_x_2 = y; \" +\n+         \"c ? f(JSCompiler_object_inline_x_0):f(JSCompiler_object_inline_x_2)\");\n+  }\n+\n+  public void testObject9() {\n+    // There is a call, so no inlining\n+    testSame(\"function f(a,b) {\" +\n+             \"  var x = {a:a,b:b}; x.a(); return x.b;\" +\n+             \"}\");\n+\n+    test(\"function f(a,b) {\" +\n+         \"  var x = {a:a,b:b}; g(x.a); x = {a:a,b:2}; return x.b;\" +\n+         \"}\",\n+         \"function f(a,b) {\" +\n+         \"  var JSCompiler_object_inline_b_1 = b;\" +\n+         \"  var JSCompiler_object_inline_a_0 = a;\" +\n+         \"  g(JSCompiler_object_inline_a_0);\" +\n+         \"  JSCompiler_object_inline_a_0 = a,\" +\n+         \"  JSCompiler_object_inline_b_1=2,\" +\n+         \"  true;\" +\n+         \"  return JSCompiler_object_inline_b_1\" +\n+         \"}\");\n+\n+    test(\"function f(a,b) { \" +\n+         \"  var x = {a:a,b:b}; g(x.a); x.b = x.c = 2; return x.b; \" +\n+         \"}\",\n+         \"function f(a,b) { \" +\n+         \"  var JSCompiler_object_inline_b_1=b; \" +\n+         \"  var JSCompiler_object_inline_c_2;\" +\n+         \"  var JSCompiler_object_inline_a_0=a;\" +\n+         \"  g(JSCompiler_object_inline_a_0);\" +\n+         \"  JSCompiler_object_inline_b_1=JSCompiler_object_inline_c_2=2;\" +\n+         \"  return JSCompiler_object_inline_b_1\" +\n+         \"}\");\n+  }\n+\n+  public void testObject10() {\n+    test(\"var x; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b);\",\n+         \"var JSCompiler_object_inline_b_1;\" +\n+         \"var JSCompiler_object_inline_a_0;\" +\n+         \"var b = f();\" +\n+         \"JSCompiler_object_inline_a_0=a,JSCompiler_object_inline_b_1=b,true;\" +\n+         \"if(JSCompiler_object_inline_a_0) g(JSCompiler_object_inline_b_1)\");\n+    test(\"var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c\",\n+         \"var JSCompiler_object_inline_b_1;\" +\n+         \"var JSCompiler_object_inline_c_2;\" +\n+         \"var JSCompiler_object_inline_a_0;\" +\n+         \"var b=f();\" +\n+         \"JSCompiler_object_inline_a_0=a,JSCompiler_object_inline_b_1=b,\" +\n+         \"  JSCompiler_object_inline_c_2=void 0,true;\" +\n+         \"if(JSCompiler_object_inline_a_0) \" +\n+         \"  g(JSCompiler_object_inline_b_1) + JSCompiler_object_inline_c_2\");\n+    test(\"var x; var b = f(); x = {a:a, b:b}; x.c = c; if(x.a) g(x.b) + x.c\",\n+         \"var JSCompiler_object_inline_b_1;\" +\n+         \"var JSCompiler_object_inline_c_2;\" +\n+         \"var JSCompiler_object_inline_a_0;\" +\n+         \"var b = f();\" +\n+         \"JSCompiler_object_inline_a_0 = a,JSCompiler_object_inline_b_1 = b, \" +\n+         \"  JSCompiler_object_inline_c_2=void 0,true;\" +\n+         \"JSCompiler_object_inline_c_2 = c;\" +\n+         \"if (JSCompiler_object_inline_a_0)\" +\n+         \"  g(JSCompiler_object_inline_b_1) + JSCompiler_object_inline_c_2;\");\n+    test(\"var x = {a:a}; if (b) x={b:b}; f(x.a||x.b);\",\n+         \"var JSCompiler_object_inline_b_1;\" +\n+         \"var JSCompiler_object_inline_a_0 = a;\" +\n+         \"if(b) JSCompiler_object_inline_b_1 = b,\" +\n+         \"      JSCompiler_object_inline_a_0 = void 0,\" +\n+         \"      true;\" +\n+         \"f(JSCompiler_object_inline_a_0 || JSCompiler_object_inline_b_1)\");\n+    test(\"var x; var y = 5; x = {a:a, b:b, c:c}; if (b) x={b:b}; f(x.a||x.b);\",\n+         \"var JSCompiler_object_inline_b_1;\" +\n+         \"var JSCompiler_object_inline_c_2;\" +\n+         \"var JSCompiler_object_inline_a_0;\" +\n+         \"var y=5;\" +\n+         \"JSCompiler_object_inline_a_0=a,\" +\n+         \"JSCompiler_object_inline_b_1=b,\" +\n+         \"JSCompiler_object_inline_c_2=c,\" +\n+         \"true;\" +\n+         \"if (b) JSCompiler_object_inline_b_1=b,\" +\n+         \"       JSCompiler_object_inline_c_2=void 0,\" +\n+         \"       JSCompiler_object_inline_a_0=void 0,\" +\n+         \"       true;\" +\n+         \"f(JSCompiler_object_inline_a_0||JSCompiler_object_inline_b_1)\");\n+  }\n+\n+  public void testObject11() {\n+    testSame(\"var x = {a:b}; (x = {a:a}).c = 5; f(x.a);\");\n+    testSame(\"var x = {a:a}; f(x[a]); g(x[a]);\");\n+  }\n+\n+  public void testObject12() {\n+    test(\"var a; a = {x:1, y:2}; f(a.x, a.y2);\",\n+         \"var JSCompiler_object_inline_y2_2;\" +\n+         \"var JSCompiler_object_inline_y_1;\" +\n+         \"var JSCompiler_object_inline_x_0;\" +\n+         \"JSCompiler_object_inline_x_0=1,\" +\n+         \"JSCompiler_object_inline_y_1=2,\" +\n+         \"JSCompiler_object_inline_y2_2=void 0,\" +\n+         \"true;\" +\n+         \"f(JSCompiler_object_inline_x_0, JSCompiler_object_inline_y2_2);\");\n+  }\n+\n+  public void testObject13() {\n+    testSame(\"var x = {a:1, b:2}; x = {a:3, b:x.a};\");\n+  }\n+\n+  public void testObject14() {\n+    testSame(\"var x = {a:1}; if ('a' in x) { f(); }\");\n+    testSame(\"var x = {a:1}; for (var y in x) { f(y); }\");\n+  }\n+\n+  public void testObject15() {\n+    testSame(\"x = x || {}; f(x.a);\");\n+  }\n+\n+  public void testObject16() {\n+    test(\"function f(e) { bar(); x = {a: foo()}; var x; print(x.a); }\",\n+         \"function f(e) { \" +\n+         \"  var JSCompiler_object_inline_a_0;\" +\n+         \"  bar();\" +\n+         \"  JSCompiler_object_inline_a_0 = foo(), true;\" +\n+         \"  print(JSCompiler_object_inline_a_0);\" +\n+         \"}\");\n+  }\n+\n+  public void testObject17() {\n+    // Note: Some day, with careful analysis, these two uses could be\n+    // disambiguated, and the second assignment could be inlined.\n+    testSame(\n+      \"var a = {a: function(){}};\" +\n+      \"a.a();\" +\n+      \"a = {a1: 100};\" +\n+      \"print(a.a1);\");\n+  }\n+}", "timestamp": 1304622938, "metainfo": ""}