{"sha": "afd09d58c5125df0865ef530750146f6a368b4e8", "log": "Extend the CheckEventfulObjectDisposal pass. * Moved logic to check for local undisposed eventful objects only in aggressive mode * Check for IDisposable interface instead of Disposable * Fixed filter for local objects returned * Abstracted disposal method checking logic ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=49893742", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckEventfulObjectDisposal.java\n+++ b/src/com/google/javascript/jscomp/CheckEventfulObjectDisposal.java\n  * Check to ensure there exists a path to dispose of each eventful object\n  * created.\n  *\n- * This compiler pass uses the inferred types and hence either type checking or\n- * type inference needs to be enabled. The set of eventful objects is initialized\n- * to {goog.events.Eventful} and, if the \"aggressive\" mode is set, expanded to a\n- * larger class using the eventize relationship (see http://research.google.com/pubs/pub40738.html).\n+ * An eventful class is any class that derives from goog.events.EventHandler\n+ * or (in aggressive mode) is disposable and disposes of an eventful class when\n+ * it is disposed (see http://research.google.com/pubs/pub40738.html).\n  *\n  * This pass is heuristic based and should not be used for any check\n- * of pass/fail testing.\n+ * of pass/fail testing. The pass traverses the AST and marks as errors\n+ * cases where an eventful object is allocated but a dispose call is not found.\n+ * It only tracks eventful objects that has a easily identifiable static name,\n+ * i.e., objects assigned to arrays, returned from functions or captured in\n+ * closures are not considered. It simply tries to see if there exists a call to\n+ * a dispose method in the AST for every object seen as eventful.\n  *\n- * This check is performed interprocedurally but in a flow and path\n- * insensitive manner.\n+ * This compiler pass uses the inferred types and hence either type checking or\n+ * type inference needs to be enabled.\n  *\n  *\n  */\n- // TODO(user) Pass needs to be updated for listenable interfaces.\n+ // TODO(user): Pass needs to be updated for listenable interfaces.\n public class CheckEventfulObjectDisposal implements CompilerPass {\n \n-  // Error messages returned\n-  static final DiagnosticType EVENTFUL_OBJECT_NOT_DISPOSED = DiagnosticType.error(\n-      \"JSC_EVENTFUL_OBJECT_NOT_DISPOSED\",\n-      \"eventful object created should be\\n\" +\n-      \"  * registered as disposable, or\\n\" +\n-      \"  * explicitly disposed of\");\n-  static final DiagnosticType EVENTFUL_OBJECT_PURELY_LOCAL = DiagnosticType.error(\n-      \"JSC_EVENTFUL_OBJECT_PURELY_LOCAL\",\n-      \"a purely local eventful object cannot be disposed of later\");\n-  static final DiagnosticType OVERWRITE_PRIVATE_EVENTFUL_OBJECT = DiagnosticType.error(\n-      \"JSC_OVERWRITE_PRIVATE_EVENTFUL_OBJECT\",\n-      \"private eventful object overwritten in subclass cannot be properly disposed of\");\n-  static final DiagnosticType UNLISTEN_WITH_ANONBOUND = DiagnosticType.error(\n-      \"JSC_UNLISTEN_WITH_ANONBOUND\",\n-      \"an unlisten call with an anonymous or bound function does not result in \" +\n-      \"the event being unlisted to\");\n+  static final DiagnosticType EVENTFUL_OBJECT_NOT_DISPOSED =\n+      DiagnosticType.error(\n+        \"JSC_EVENTFUL_OBJECT_NOT_DISPOSED\",\n+        \"eventful object created should be\\n\" +\n+        \"  * registered as disposable, or\\n\" +\n+        \"  * explicitly disposed of\");\n+  static final DiagnosticType EVENTFUL_OBJECT_PURELY_LOCAL =\n+      DiagnosticType.error(\n+        \"JSC_EVENTFUL_OBJECT_PURELY_LOCAL\",\n+        \"a purely local eventful object cannot be disposed of later\");\n+  static final DiagnosticType OVERWRITE_PRIVATE_EVENTFUL_OBJECT =\n+      DiagnosticType.error(\n+        \"JSC_OVERWRITE_PRIVATE_EVENTFUL_OBJECT\",\n+        \"private eventful object overwritten in subclass cannot be properly \"\n+        + \"disposed of\");\n+  static final DiagnosticType UNLISTEN_WITH_ANONBOUND =\n+      DiagnosticType.error(\n+        \"JSC_UNLISTEN_WITH_ANONBOUND\",\n+        \"an unlisten call with an anonymous or bound function does not result \"\n+        + \"in the event being unlisted to\");\n \n   /**\n    * Policies to determine the disposal checking level.\n   }\n \n   // Seed types\n-  private static final String DISPOSABLE_TYPE_NAME = \"goog.Disposable\";\n-  private static final String EVENT_HANDLER_TYPE_NAME = \"goog.events.EventHandler\";\n-  private JSType googDisposableType;\n+  private static final String DISPOSABLE_INTERFACE_TYPE_NAME =\n+      \"goog.disposable.IDisposable\";\n+  private static final String EVENT_HANDLER_TYPE_NAME =\n+      \"goog.events.EventHandler\";\n+  private JSType googDisposableInterfaceType;\n   private JSType googEventsEventHandlerType;\n \n   // Eventful types\n   private Set<JSType> eventfulTypes;\n \n   /*\n-   * Dispose methods is a map from regex to argument disposed/all arguments disposed.\n-   * Note: it is assumed that at most one regex match will occur per disposeMethod call.\n+   * Dispose methods is a map of types to maps from property/function name\n+   * to argument disposed/all arguments disposed. The key is used to filter\n+   * the dispose calls checked against. That is, the pass considers all dispose\n+   * calls of classes a class is derived from and not merely those in the map\n+   * of its given type.\n+   * Note: it is assumed that at most one string match will occur per\n+   * disposeMethod call.\n    */\n-  private Map<String, List<Integer>> disposeMethods;\n-  // Member used to signify all arguments should be disposed.\n+  private Map<JSType, Map<String, List<Integer>>> disposeCalls;\n+\n+  /**\n+   * Constant used to signify all arguments of method/function\n+   * should be marked as disposed.\n+   */\n   public static final int DISPOSE_ALL = -1;\n+\n+  /**\n+   *  Constant used to signify that object on which this method is called,\n+   *  will itself get disposed of.\n+   */\n+  public static final int DISPOSE_SELF = -2;\n \n   private final AbstractCompiler compiler;\n   private final JSTypeRegistry typeRegistry;\n   /*\n    * The disposal checking policy used.\n    */\n-  private DisposalCheckingPolicy checkingPolicy;\n+  private final DisposalCheckingPolicy checkingPolicy;\n \n   /*\n    * Eventize DAG represented using adjacency lists.\n \n   /**\n    * Add a new call that is used to dispose an JS object.\n-   * @param pattern A regular expression that matches the function used to dispose of/register\n-   *   an object as disposable\n-   * @param argumentsThatAreDisposed An array of integers (ideally sorted) that specifies\n-   *   the arguments of the function being disposed\n+   * @param functionOrMethodName The name or suffix of a function or method\n+   *  that disposes of/registers an object as disposable\n+   * @param argumentsThatAreDisposed An array of integers (ideally sorted) that\n+   *   specifies the arguments of the function being disposed\n    */\n-  private void addDisposeCall(String pattern, List<Integer> argumentsThatAreDisposed) {\n-    this.disposeMethods.put(pattern, argumentsThatAreDisposed);\n+  private void addDisposeCall(String functionOrMethodName,\n+      List<Integer> argumentsThatAreDisposed) {\n+    String potentiallyTypeName, propertyName;\n+    JSType objectType = null;\n+\n+    int lastPeriod = functionOrMethodName.lastIndexOf('.');\n+    // If function call has a period it is potentially a method function.\n+    if (lastPeriod >= 0) {\n+      potentiallyTypeName = functionOrMethodName.substring(0, lastPeriod);\n+      propertyName = functionOrMethodName.substring(lastPeriod);\n+      objectType = compiler.getTypeRegistry().getType(potentiallyTypeName);\n+    } else {\n+      propertyName = functionOrMethodName;\n+    }\n+\n+    // Find or create property map for object type\n+    Map<String, List<Integer>> map = this.disposeCalls.get(objectType);\n+    if (map == null) {\n+      map = Maps.newHashMap();\n+      this.disposeCalls.put(objectType, map);\n+    }\n+\n+    /*\n+     * If this is a static function call store the full function name,\n+     * else only the method of the object.\n+     */\n+    if (objectType == null) {\n+      map.put(functionOrMethodName, argumentsThatAreDisposed);\n+    } else {\n+      map.put(propertyName, argumentsThatAreDisposed);\n+    }\n   }\n \n \n    * Initialize disposeMethods map with calls to dispose calls.\n    */\n   private void initializeDisposeMethodsMap() {\n-    this.disposeMethods = Maps.newHashMap();\n-\n-    // Initialize disposeMethods hashmap\n-    this.addDisposeCall(\"goog.dispose\", new ArrayList<Integer>(Arrays.asList(0)));\n-    this.addDisposeCall(\"goog.disposeAll\", new ArrayList<Integer>(Arrays.asList(DISPOSE_ALL)));\n-    this.addDisposeCall(\".push\", new ArrayList<Integer>(Arrays.asList(0)));\n-    this.addDisposeCall(\".add\", new ArrayList<Integer>(Arrays.asList(DISPOSE_ALL)));\n+    this.disposeCalls = Maps.newHashMap();\n+\n+    /*\n+     * Initialize dispose calls map. Checks for:\n+     *    - Y.registerDisposable(X)\n+     *      (Y has to be of type goog.Disposable)\n+     *    - X.dispose()\n+     *    - goog.dispose(X)\n+     *    - goog.disposeAll(X...)\n+     *    - X.removeAll() (X is of type goog.events.EventHandler)\n+     *    - Y.add(X...) or Y.push(X)\n+     */\n+    this.addDisposeCall(\"goog.dispose\",\n+        new ArrayList<Integer>(Arrays.asList(0)));\n+    this.addDisposeCall(\"goog.Disposable.registerDisposable\",\n+        new ArrayList<Integer>(Arrays.asList(0)));\n+    this.addDisposeCall(\"goog.disposeAll\",\n+        new ArrayList<Integer>(Arrays.asList(DISPOSE_ALL)));\n+    this.addDisposeCall(\"goog.events.EventHandler.removeAll\",\n+        new ArrayList<Integer>(Arrays.asList(DISPOSE_SELF)));\n+    this.addDisposeCall(\".dispose\",\n+        new ArrayList<Integer>(Arrays.asList(DISPOSE_SELF)));\n+    this.addDisposeCall(\".push\",\n+        new ArrayList<Integer>(Arrays.asList(0)));\n+    this.addDisposeCall(\".add\",\n+        new ArrayList<Integer>(Arrays.asList(DISPOSE_ALL)));\n   }\n \n \n   }\n \n \n-  /*\n+  /**\n    * Determines if thisType is possibly a subtype of thatType.\n    *\n    *  It differs from isSubtype only in that thisType gets expanded\n    *\n    *  Common case targeted is a function returning an eventful object\n    *  that may also return a null.\n+   *\n+   *  @param thisType the JSType being tested\n+   *  @param thatType the JSType that is possibly a base of thisType\n+   *  @return whether thisType is possibly subtype of thatType\n    */\n   private static boolean isPossiblySubtype(JSType thisType, JSType thatType) {\n     if (thisType == null) {\n    *\n    * Warning: Inheritance is not currently handled.\n    */\n-  private static String generateKey(NodeTraversal t, Node n, boolean noLocalVariables) {\n+  private static String generateKey(NodeTraversal t, Node n,\n+      boolean noLocalVariables) {\n     if (n == null) {\n       return null;\n     }\n           //    this.eh = new goog.events.EventHandler();\n           //  }\n           //};\n-          key = t.getScope().getParentScope().getTypeOfThis().toString() + \"~\" + key;\n+          key = t.getScope().getParentScope().getTypeOfThis().toString() + \"~\"\n+              + key;\n         } else {\n           if (n.getFirstChild() == null) {\n             key = base.getJSType().toString() + \"=\" + key;\n     Preconditions.checkArgument(checkingPolicy != DisposalCheckingPolicy.OFF);\n \n     // Initialize types\n-    googDisposableType = compiler.getTypeRegistry().getType(DISPOSABLE_TYPE_NAME);\n-    googEventsEventHandlerType = compiler.getTypeRegistry().getType(EVENT_HANDLER_TYPE_NAME);\n+    googDisposableInterfaceType =\n+        compiler.getTypeRegistry().getType(DISPOSABLE_INTERFACE_TYPE_NAME);\n+    googEventsEventHandlerType = compiler.getTypeRegistry()\n+        .getType(EVENT_HANDLER_TYPE_NAME);\n \n     /*\n      * Required types not found therefore the kind of pattern considered\n      * will not be found.\n      */\n-    if (googEventsEventHandlerType == null || googDisposableType == null) {\n+    if (googEventsEventHandlerType == null ||\n+        googDisposableInterfaceType == null) {\n       return;\n     }\n \n \n     /*\n      * Scan eventfulObjectMap for allocated eventful objects that\n-     * had no free/dispose/eventlistener-removal call.\n+     * had no dispose calls.\n      */\n     for (EventfulObjectState e : eventfulObjectMap.values()) {\n       Node n = e.allocationSite;\n       if (e.seen == SeenType.ALLOCATED) {\n-        compiler.report(JSError.make(n.getSourceFileName(), n, EVENTFUL_OBJECT_NOT_DISPOSED));\n-      } else if (e.seen == SeenType.ALLOCATED_LOCALLY) {\n-        compiler.report(JSError.make(n.getSourceFileName(), n, EVENTFUL_OBJECT_PURELY_LOCAL));\n+        compiler.report(JSError.make(n.getSourceFileName(), n,\n+            EVENTFUL_OBJECT_NOT_DISPOSED));\n+      } else if (e.seen == SeenType.ALLOCATED_LOCALLY &&\n+          checkingPolicy == DisposalCheckingPolicy.AGGRESSIVE) {\n+        compiler.report(JSError.make(n.getSourceFileName(), n,\n+            EVENTFUL_OBJECT_PURELY_LOCAL));\n       }\n     }\n   }\n       Node base = first.getFirstChild();\n       JSType baseType = base.getJSType();\n \n-      if (baseType == null || !isPossiblySubtype(baseType, googDisposableType)) {\n+      if (baseType == null ||\n+          !isPossiblySubtype(baseType, googDisposableInterfaceType)) {\n         return null;\n       }\n \n \n       if (type.isEmptyType() ||\n           type.isUnknownType() ||\n-          !isPossiblySubtype(type, googDisposableType)) {\n+          !isPossiblySubtype(type, googDisposableInterfaceType)) {\n         return true;\n       }\n \n               /*\n                * Initialize eventizes relationship\n                */\n-              if (t.getScope() != null && t.getScope().getTypeOfThis() != null) {\n-                ObjectType objectType = ObjectType.cast(t.getScope().getTypeOfThis().dereference());\n+              if (t.getScope() != null &&\n+                  t.getScope().getTypeOfThis() != null) {\n+                ObjectType objectType = ObjectType.cast(t.getScope()\n+                    .getTypeOfThis().dereference());\n \n                 /*\n                  * Eventize due to inheritance\n                     continue;\n                   }\n \n-                  addEventize(compiler.getTypeRegistry().getType(functionName), objectType);\n+                  addEventize(compiler.getTypeRegistry().getType(functionName),\n+                      objectType);\n \n                   /*\n                    * Don't add transitive eventize edges here, it will be\n         /*\n          * Anonymous function\n          */\n-        compiler.report(JSError.make(n.getSourceFileName(), n, UNLISTEN_WITH_ANONBOUND));\n+        compiler.report(JSError.make(n.getSourceFileName(), n,\n+            UNLISTEN_WITH_ANONBOUND));\n       } else if (listener.isCall()) {\n         if (!listener.getFirstChild().isQualifiedName()) {\n           /*\n            * Anonymous function\n            */\n-          compiler.report(JSError.make(n.getSourceFileName(), n, UNLISTEN_WITH_ANONBOUND));\n-        } else if (listener.getFirstChild().getQualifiedName().equals(\"goog.bind\")) {\n+          compiler.report(JSError.make(n.getSourceFileName(), n,\n+              UNLISTEN_WITH_ANONBOUND));\n+        } else if (listener.getFirstChild().getQualifiedName()\n+            .equals(\"goog.bind\")) {\n           /*\n            * Using goog.bind to unlisten\n            */\n-          compiler.report(JSError.make(n.getSourceFileName(), n, UNLISTEN_WITH_ANONBOUND));\n-        }\n-      }\n-    }\n-\n-\n-    private void isCalled(NodeTraversal t, Node n) {\n+          compiler.report(JSError.make(n.getSourceFileName(), n,\n+              UNLISTEN_WITH_ANONBOUND));\n+        }\n+      }\n+    }\n+\n+\n+    private void visitCall(NodeTraversal t, Node n) {\n       Node functionCalled = n.getFirstChild();\n       if (functionCalled == null ||\n           !functionCalled.isQualifiedName()) {\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.CALL:\n-          isCalled(t, n);\n+          visitCall(t, n);\n           break;\n         default:\n           break;\n     }\n   }\n \n-  private class Traversal extends AbstractPostOrderCallback  implements ScopedCallback {\n+  private class Traversal extends AbstractPostOrderCallback\n+      implements ScopedCallback {\n     /*\n      * Checks if the input node correspond to the creation of an eventful object\n      */\n           Node assign = sibling.getFirstChild();\n           if (assign.isAssign()) {\n             // assign.getLastChild().isEquivalentTo(propertyNode) did not work\n-            if (propertyNode.getQualifiedName().equals(assign.getLastChild().getQualifiedName())) {\n+            if (propertyNode.getQualifiedName().equals(assign.getLastChild()\n+                .getQualifiedName())) {\n               if (!assign.getFirstChild().isName()) {\n                 return assign.getFirstChild();\n               }\n     /*\n      * Record the creation of a new eventful object.\n      */\n-    private void isNew(NodeTraversal t, Node n, Node parent) {\n+    private void visitNew(NodeTraversal t, Node n, Node parent) {\n       if (!createsEventfulObject(n)) {\n         return;\n       }\n         propertyNode = parent.getFirstChild();\n       } else {\n         propertyNode = parent;\n-      }\n-\n-      /*\n-       * Only perform checks for locally defined eventful objects in aggressive\n-       * mode to reduce false positives.\n-       */\n-      if (propertyNode.isName() &&\n-          checkingPolicy != DisposalCheckingPolicy.AGGRESSIVE) {\n-        return;\n       }\n \n       key = generateKey(t, propertyNode, false);\n       }\n     }\n \n+    private void addDisposeArgumentsMatched(Map<String, List<Integer>> map,\n+        Node n, String property, List<Node> foundDisposeCalls) {\n+      for (String disposeMethod : map.keySet()) {\n+        if (property.endsWith(disposeMethod)) {\n+          List<Integer> disposeArguments = map.get(disposeMethod);\n+\n+          // Dispose specific arguments only\n+          Node t = n.getNext();\n+          int tsArgument = 0;\n+          for (Integer disposeArgument : disposeArguments) {\n+            switch (disposeArgument) {\n+              // Dispose all arguments\n+              case DISPOSE_ALL:\n+                for (Node tt = n.getNext(); tt != null; tt = tt.getNext()) {\n+                  foundDisposeCalls.add(tt);\n+                }\n+                break;\n+              // Dispose objects called on\n+              case DISPOSE_SELF:\n+                Node calledOn = n.getFirstChild();\n+\n+                foundDisposeCalls.add(calledOn);\n+                break;\n+              default:\n+                // The current item pointed to by t is beyond that requested in\n+                // current array element.\n+                if (tsArgument > disposeArgument) {\n+                  t = n.getNext();\n+                  tsArgument = 0;\n+                }\n+                for (; tsArgument < disposeArgument && t != null;\n+                        ++tsArgument) {\n+                  t = t.getNext();\n+                }\n+                if (tsArgument == disposeArgument && t != null) {\n+                  foundDisposeCalls.add(t);\n+                }\n+                break;\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n     private List<Node> maybeGetValueNodesFromCall(Node n) {\n-      /*\n-       * Checks for:\n-       *    - Y.registerDisposable(X)\n-       *      (Y has to be of type goog.Disposable)\n-       *    - X.dispose()\n-       *    - goog.dispose(X)\n-       *    - goog.disposeAll(X...)\n-       *    - X.removeAll() (X is of type goog.events.EventHandler)\n-       *    - <array>.add*(X...) or Y.push(X)\n-       */\n       List<Node> ret = Lists.newArrayList();\n       Node first = n.getFirstChild();\n \n       }\n       String property = first.getQualifiedName();\n \n-      if (property.endsWith(\".registerDisposable\"))  {\n-        /*\n-         *  Ensure object is of type disposable\n-         */\n-        Node base = first.getFirstChild();\n-        JSType baseType = base.getJSType();\n-\n-        if (baseType != null && isPossiblySubtype(baseType, googDisposableType)) {\n-          ret.add(n.getLastChild());\n-        }\n-      }\n-\n-      // Call to function known to dispose arguments\n-      for (String disposeMethod : disposeMethods.keySet()) {\n-        if (property.matches(disposeMethod)) {\n-          List<Integer> disposeArguments = disposeMethods.get(disposeMethod);\n-\n-          // Dispose specific arguments only\n-          Node t = first.getNext();\n-          int tsArgument = 0;\n-          for (Integer disposeArgument : disposeArguments) {\n-            // Dispose all arguments?\n-            if (disposeArgument == DISPOSE_ALL) {\n-              for (Node tt = first.getNext(); tt != null; tt = tt.getNext()) {\n-                ret.add(tt);\n-              }\n-              break;\n-            }\n-\n-            // The current item pointed to by t is beyond that requested in\n-            // current array element.\n-            if (tsArgument > disposeArgument) {\n-              t = first.getNext();\n-              tsArgument = 0;\n-            }\n-            for (; tsArgument < disposeArgument && t != null; ++tsArgument) {\n-              t = t.getNext();\n-            }\n-            if (tsArgument == disposeArgument && t != null) {\n-              ret.add(t);\n-            }\n-          }\n-\n-          return ret;\n-        }\n-      }\n-\n-      /*\n-       * n -> call\n-       *   n.firstChild -> \"dispose\" | \"removeAll\"\n-       *   n.firstChild.firstChild -> object\n-       */\n-      Node calledOn = n.getFirstChild().getFirstChild();\n-      if (property.endsWith(\".dispose\")) {\n-        ret.add(calledOn);\n-      }\n-      if (property.endsWith(\".removeAll\")) {\n-        if (calledOn != null) {\n-          JSType calledOnType = calledOn.getJSType();\n-          if (calledOnType != null &&\n-              !calledOnType.isEmptyType() &&\n-              !calledOnType.isUnknownType() &&\n-              isPossiblySubtype(calledOnType, googEventsEventHandlerType)) {\n-            ret.add(calledOn);\n-          }\n-        }\n-      }\n-\n-      Node possiblyArray = first.getFirstChild();\n-      if (possiblyArray != null) {\n-        JSType possiblyArrayType = possiblyArray.getJSType();\n-        if (possiblyArrayType != null && possiblyArrayType.isArrayType()) {\n-          ret.add(n.getLastChild());\n+      Node base = first.getFirstChild();\n+      JSType baseType = null;\n+      if (base != null) {\n+        baseType = base.getJSType();\n+      }\n+\n+      for (JSType key : disposeCalls.keySet()) {\n+        if (key == null ||\n+            (baseType != null && isPossiblySubtype(baseType, key))) {\n+          addDisposeArgumentsMatched(disposeCalls.get(key), first, property,\n+              ret);\n         }\n       }\n \n      * (dispose or removeAll will remove all event listeners from\n      * an EventHandler).\n      */\n-    private void isCall(NodeTraversal t, Node n) {\n+    private void visitCall(NodeTraversal t, Node n) {\n       // Filter the calls to find a \"dispose\" call\n       List<Node> variableNodes = maybeGetValueNodesFromCall(n);\n \n     /*\n      * Check function definitions to add custom dispose methods.\n      */\n-    public void isFunction(NodeTraversal t, Node n) {\n+    public void visitFunction(NodeTraversal t, Node n) {\n       Preconditions.checkArgument(n.isFunction());\n       JSDocInfo jsDocInfo = NodeUtil.getFunctionJSDocInfo(n);\n \n         if (jsDocInfo.disposesOf(\"*\")) {\n           positionalDisposedParameters.add(DISPOSE_ALL);\n         } else {\n-          // Param types\n+          // Parameter types\n           int index = 0;\n           for (Node p : funType.getParameters()) {\n               // Bail out if the paramNode is not there.\n               index++;\n           }\n         }\n-        addDisposeCall(NodeUtil.getFunctionName(n), positionalDisposedParameters);\n+        addDisposeCall(NodeUtil.getFunctionName(n),\n+            positionalDisposedParameters);\n       }\n     }\n \n      * Assigning to an array element is taken care of by the generateKey\n      * returning null on array (\"complex\") variable names.\n      */\n-    public void isAssign(NodeTraversal t, Node n) {\n+    public void visitAssign(NodeTraversal t, Node n) {\n       Node assignedTo = n.getFirstChild();\n       JSType assignedToType = assignedTo.getJSType();\n       if (assignedToType == null || assignedToType.isEmptyType()) {\n \n         JSDocInfo di = n.getJSDocInfo();\n         ObjectType objectType =\n-            ObjectType.cast(dereference(n.getFirstChild().getFirstChild().getJSType()));\n+            ObjectType.cast(dereference(n.getFirstChild().getFirstChild()\n+                .getJSType()));\n         String propertyName = n.getFirstChild().getLastChild().getString();\n \n         boolean fieldIsPrivate = (\n     /*\n      * Filter out any eventful objects returned.\n      */\n-    private void isReturn(NodeTraversal t, Node n) {\n+    private void visitReturn(NodeTraversal t, Node n) {\n       Node variableNode = n.getFirstChild();\n       if (variableNode == null) {\n         return;\n       }\n-      JSType type = variableNode.getJSType();\n-      if (type == null || type.isEmptyType()) {\n-        return;\n-      }\n-\n-      boolean isTrackedReturn = false;\n-      for (JSType disposalType : eventfulTypes) {\n-        if (type.isSubtype(disposalType)) {\n-          isTrackedReturn = true;\n-          break;\n-        }\n-      }\n-      if (!isTrackedReturn) {\n-        return;\n-      }\n-\n-      eventfulObjectDisposed(t, variableNode);\n+\n+      if (!variableNode.isArrayLit()) {\n+        eventfulObjectDisposed(t, variableNode);\n+      } else {\n+        for (Node child : variableNode.children()) {\n+          eventfulObjectDisposed(t, child);\n+        }\n+      }\n     }\n \n     /*\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.ASSIGN:\n-          isAssign(t, n);\n+          visitAssign(t, n);\n           break;\n         case Token.CALL:\n-          isCall(t, n);\n+          visitCall(t, n);\n           break;\n         case Token.FUNCTION:\n-          isFunction(t, n);\n+          visitFunction(t, n);\n           break;\n         case Token.NEW:\n-          isNew(t, n, parent);\n+          visitNew(t, n, parent);\n           break;\n         case Token.RETURN:\n-          isReturn(t, n);\n+          visitReturn(t, n);\n           break;\n         default:\n           break;\n--- a/test/com/google/javascript/jscomp/CheckEventfulObjectDisposalTest.java\n+++ b/test/com/google/javascript/jscomp/CheckEventfulObjectDisposalTest.java\n   private CheckEventfulObjectDisposal.DisposalCheckingPolicy policy =\n       CheckEventfulObjectDisposal.DisposalCheckingPolicy.ON;\n \n-  static final String CLOSURE_DEFS = \"var goog = {};\" + \"goog.inherits = function(x, y) {};\"\n+  static final String CLOSURE_DEFS = \"var goog = {};\"\n+      + \"goog.inherits = function(x, y) {};\"\n       + \"/** @type {!Function} */ goog.abstractMethod = function() {};\"\n       + \"goog.isArray = function(x) {};\" + \"goog.isDef = function(x) {};\"\n       + \"goog.isFunction = function(x) {};\" + \"goog.isNull = function(x) {};\"\n       + \"goog.dispose = function(x) {};\"\n       + \"goog.disposeAll = function(var_args) {};\"\n       + \"/** @return {*} */ goog.asserts.assert = function(x) { return x; };\"\n+      + \"goog.disposable = {};\"\n       + \"/** @interface */\\n\"\n+      + \"goog.disposable.IDisposable = function() {};\"\n+      + \"goog.disposable.IDisposable.prototype.dispose;\"\n+      + \"/** @implements {goog.disposable.IDisposable}\\n * @constructor */\\n\"\n       + \"goog.Disposable = goog.abstractMethod;\"\n+      + \"/** @override */\"\n       + \"goog.Disposable.prototype.dispose = goog.abstractMethod;\"\n       + \"/** @param {goog.Disposable} fn */\"\n       + \"goog.Disposable.prototype.registerDisposable = goog.abstractMethod;\"\n-      + \"/** @implements {goog.Disposable}\\n * @constructor */\"\n-      + \"goog.SubDisposable = function() {};\"\n-      + \"/** @inheritDoc */ \"\n-      + \"goog.SubDisposable.prototype.dispose = function() {};\"\n-      + \"/** @inheritDoc */\"\n-      + \"goog.SubDisposable.prototype.registerDisposable = function() {};\"\n       + \"goog.events = {};\"\n-      + \"/** @extends {goog.SubDisposable}\\n *  @constructor */\"\n+      + \"/** @extends {goog.Disposable}\\n *  @constructor */\"\n       + \"goog.events.EventHandler = function() {};\"\n       + \"goog.events.EventHandler.prototype.removeAll = function() {};\";\n \n \n   @Override\n   public CompilerPass getProcessor(Compiler compiler) {\n-    CheckEventfulObjectDisposal compilerPass = new CheckEventfulObjectDisposal(compiler, policy);\n+    CheckEventfulObjectDisposal compilerPass =\n+        new CheckEventfulObjectDisposal(compiler, policy);\n \n     return compilerPass;\n   }\n \n   public void testNoEventHandler() {\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() {  };\"\n         + \"goog.inherits(test, goog.Disposable);\"\n         + \"var testObj = new test();\";\n \n   public void testNotFreed1() {\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { this.eh = new goog.events.EventHandler(); };\"\n         + \"goog.inherits(test, goog.Disposable);\"\n         + \"var testObj = new test();\";\n-    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_NOT_DISPOSED, true);\n+    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_NOT_DISPOSED,\n+        true);\n   }\n \n   public void testLocal() {\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { var eh = new goog.events.EventHandler();\\n\"\n         + \"};\\n\"\n         + \"goog.inherits(test, goog.Disposable);\"\n   public void testLocalAggressive() {\n     policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { var eh = new goog.events.EventHandler();\\n\"\n         + \"};\\n\"\n         + \"goog.inherits(test, goog.Disposable);\"\n         + \"var testObj = new test();\";\n-    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_PURELY_LOCAL, true);\n+    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_PURELY_LOCAL,\n+        true);\n   }\n \n   public void testFreedLocal1() {\n     policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { var eh = new goog.events.EventHandler();\"\n         + \"eh.dispose(); };\"\n         + \"goog.inherits(test, goog.Disposable);\"\n     testSame(js);\n   }\n \n+  public void testEventhandlerRemoveAll1() {\n+    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n+        + \"var test = function() { this.eh = new goog.events.EventHandler(); };\"\n+        + \"test.prototype.free = function() { this.eh.removeAll(); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n+  public void testEventhandlerRemoveAll2() {\n+    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n+    String js = CLOSURE_DEFS\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n+        + \"var test = function() { var eh = new goog.events.EventHandler();\"\n+        + \"eh.removeAll(); };\"\n+        + \"goog.inherits(test, goog.Disposable);\"\n+        + \"var testObj = new test();\";\n+    testSame(js);\n+  }\n+\n   public void testFreedLocal2() {\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { var eh = new goog.events.EventHandler();\"\n         + \"this.registerDisposable(eh); };\"\n         + \"goog.inherits(test, goog.Disposable);\"\n   public void testFreedLocal2Aggressive() {\n     policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { var eh = new goog.events.EventHandler();\"\n         + \"this.registerDisposable(eh); };\"\n         + \"goog.inherits(test, goog.Disposable);\"\n         + \"var testObj = new test();\";\n-    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_PURELY_LOCAL, true);\n+    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_PURELY_LOCAL,\n+        true);\n   }\n \n   public void testLocalLive1() {\n     policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { var eh = new goog.events.EventHandler();\"\n         + \"this.eh = eh;\"\n         + \"eh.dispose(); };\"\n   public void testLocalLive2() {\n     policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { var eh = new goog.events.EventHandler();\"\n         + \"this.eh = eh;\"\n         + \"this.eh.dispose(); };\"\n   public void testLocalLive3() {\n     policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { var eh = new goog.events.EventHandler();\"\n         + \"this.ehs = [];\"\n         + \"this.ehs[0] = eh;\"\n \n   public void testFreedDispose() {\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { this.eh = new goog.events.EventHandler();\"\n         + \"this.eh.dispose(); };\"\n         + \"goog.inherits(test, goog.Disposable);\"\n \n   public void testFreedGoogDispose1() {\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { this.eh = new goog.events.EventHandler();\"\n         + \"goog.dispose(this.eh); };\"\n         + \"goog.inherits(test, goog.Disposable);\"\n \n   public void testNotAllFreedGoogDispose() {\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() {\"\n         + \"this.eh1 = new goog.events.EventHandler();\"\n         + \"this.eh2 = new goog.events.EventHandler();\"\n         + \"goog.dispose(this.eh1, this.eh2); };\"\n         + \"goog.inherits(test, goog.Disposable);\"\n         + \"var testObj = new test();\";\n-    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_NOT_DISPOSED, true);\n+    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_NOT_DISPOSED,\n+        true);\n   }\n \n   public void testFreedGoogDisposeAll() {\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { \"\n         + \"this.eh1 = new goog.events.EventHandler();\"\n         + \"this.eh2 = new goog.events.EventHandler();\"\n \n   public void testFreedRegisterDisposable() {\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { this.eh = new goog.events.EventHandler();\"\n         + \"this.registerDisposable(this.eh); };\"\n         + \"goog.inherits(test, goog.Disposable);\"\n \n   public void testFreedRemoveAll() {\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { this.eh = new goog.events.EventHandler();\"\n         + \"this.eh.removeAll(); };\"\n         + \"goog.inherits(test, goog.Disposable);\"\n \n   public void testPrivateInheritance() {\n     String js = CLOSURE_DEFS\n-        + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+        + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n         + \"var test = function() { \"\n         + \"/** @private */ this.eh = new goog.events.EventHandler();\"\n         + \"this.eh.removeAll(); };\"\n         + \"this.eh.dispose();\"\n         + \"};\"\n         + \"var testObj = new test();\";\n-    testSame(js, CheckEventfulObjectDisposal.OVERWRITE_PRIVATE_EVENTFUL_OBJECT, true);\n+    testSame(js, CheckEventfulObjectDisposal.OVERWRITE_PRIVATE_EVENTFUL_OBJECT,\n+        true);\n   }\n \n   public void testCustomDispose1() {\n         + \"};\"\n         + \"var x = new goog.events.EventHandler();\"\n         + \"customDispose(OBJ, x);\";\n-    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_PURELY_LOCAL, true);\n+    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_PURELY_LOCAL,\n+        true);\n   }\n }\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n       + \"goog.dispose = function(x) {};\"\n       + \"goog.disposeAll = function(var_args) {};\"\n       + \"/** @return {*} */ goog.asserts.assert = function(x) { return x; };\"\n+      + \"goog.disposable = {};\"\n       + \"/** @interface */\\n\"\n-      + \"goog.Disposable = function() {};\"\n-      + \"goog.Disposable.prototype.dispose = function() {};\"\n+      + \"goog.disposable.IDisposable = function() {};\"\n+      + \"goog.disposable.IDisposable.prototype.dispose;\"\n+      + \"/** @implements {goog.disposable.IDisposable}\\n * @constructor */\\n\"\n+      + \"goog.Disposable = goog.abstractMethod;\"\n+      + \"/** @override */\"\n+      + \"goog.Disposable.prototype.dispose = goog.abstractMethod;\"\n       + \"/** @param {goog.Disposable} fn */\"\n-      + \"goog.Disposable.prototype.registerDisposable = function(fn) {};\"\n-      + \"/** @implements {goog.Disposable}\\n * @constructor */\"\n-      + \"goog.SubDisposable = function() {};\"\n-      + \"/** @inheritDoc */ \"\n-      + \"goog.SubDisposable.prototype.dispose = function() {};\"\n-      + \"/** @inheritDoc */\"\n-      + \"goog.SubDisposable.prototype.registerDisposable = function() {};\"\n+      + \"goog.Disposable.prototype.registerDisposable = goog.abstractMethod;\"\n       + \"goog.events = {};\"\n-      + \"/** @extends {goog.SubDisposable}\\n *  @constructor */\"\n+      + \"/** @extends {goog.Disposable}\\n *  @constructor */\"\n       + \"goog.events.EventHandler = function() {};\"\n-      + \"goog.events.EventHandler.prototype.removeAll = function() {};\"\n-      + \"/** @extends {goog.SubDisposable}\\n * @constructor */\"\n+      + \"/** @extends {goog.Disposable}\\n * @constructor */\"\n       + \"var test = function() { this.eh = new goog.events.EventHandler(); };\"\n       + \"goog.inherits(test, goog.Disposable);\"\n       + \"var testObj = new test();\";\n \n     test(options, js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_NOT_DISPOSED);\n \n-    options.setWarningLevel(DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL, CheckLevel.OFF);\n+    options.setWarningLevel(DiagnosticGroups.CHECK_EVENTFUL_OBJECT_DISPOSAL,\n+        CheckLevel.OFF);\n     testSame(options, js);\n   }\n \n   public void testDuplicateVariablesInExterns() {\n     CompilerOptions options = createCompilerOptions();\n     options.checkSymbols = true;\n-    externs = ImmutableList.of(\n-        SourceFile.fromCode(\"externs\",\n-            \"var externs = {}; /** @suppress {duplicate} */ var externs = {};\"));\n+    externs = ImmutableList.of(SourceFile.fromCode(\"externs\",\n+        \"var externs = {}; /** @suppress {duplicate} */ var externs = {};\"));\n     testSame(options, \"\");\n   }\n \n \n   public void testCheckProvidesWarning() {\n     CompilerOptions options = createCompilerOptions();\n-    options.setWarningLevel(DiagnosticGroups.CHECK_PROVIDES, CheckLevel.WARNING);\n+    options.setWarningLevel(DiagnosticGroups.CHECK_PROVIDES,\n+        CheckLevel.WARNING);\n     options.setCheckProvides(CheckLevel.WARNING);\n     test(options,\n         \"/** @constructor */\\n\" +\n         \"function f() { var arguments; }\",\n-        DiagnosticType.warning(\"JSC_MISSING_PROVIDE\", \"missing goog.provide(''{0}'')\"));\n+        DiagnosticType\n+        .warning(\"JSC_MISSING_PROVIDE\", \"missing goog.provide(''{0}'')\"));\n   }\n \n   public void testSuppressCheckProvidesWarning() {\n     CompilerOptions options = createCompilerOptions();\n-    options.setWarningLevel(DiagnosticGroups.CHECK_PROVIDES, CheckLevel.WARNING);\n+    options.setWarningLevel(DiagnosticGroups.CHECK_PROVIDES,\n+        CheckLevel.WARNING);\n     options.setCheckProvides(CheckLevel.WARNING);\n     testSame(options,\n         \"/** @constructor\\n\" +", "timestamp": 1374798922, "metainfo": ""}