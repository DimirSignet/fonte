{"sha": "6059136434ee327b5a5bf13b30fdd69b1198196e", "log": "cloning trees won't work in this pass, because it's a reference counter. reference counters keep track of references. :) i'm surprised that this is the first time this has happened.  R=johnlenz DELTA=81  (30 added, 16 deleted, 35 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5546   ", "commit": "\n--- a/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n+++ b/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n   /**\n    * Populates the provided replacement list by appending copies of\n    * subtrees that have side effects.\n-   */\n-  static final class CopySideEffectSubexpressions\n+   *\n+   * It is OK if this class tears up the original tree, because\n+   * we're going to throw the tree out anyway.\n+   */\n+  static final class GetReplacementSideEffectSubexpressions\n       implements SideEffectAccumulator {\n     private final AbstractCompiler compiler;\n     private final List<Node> replacements;\n      * @param compiler - the AbstractCompiler\n      * @param replacements - list to accumulate into\n      */\n-    CopySideEffectSubexpressions(AbstractCompiler compiler,\n-                                 List<Node> replacements) {\n+    GetReplacementSideEffectSubexpressions(AbstractCompiler compiler,\n+        List<Node> replacements) {\n       this.compiler = compiler;\n       this.replacements = replacements;\n     }\n \n     @Override\n     public void keepSubTree(Node original) {\n-      replacements.add(original.cloneTree());\n+      if (original.getParent() != null) {\n+        original.detachFromParent();\n+      }\n+      replacements.add(original);\n     }\n \n     @Override\n       Node left = original.getFirstChild();\n       Node right = left.getNext();\n       Node simplifiedRight = simplifyShortCircuitBranch(right);\n-\n-      Node simplified = original.cloneNode();\n-      simplified.addChildToBack(left.cloneTree());\n-      simplified.addChildToBack(simplifiedRight);\n-      replacements.add(simplified);\n+      original.detachChildren();\n+      original.addChildToBack(left);\n+      original.addChildToBack(simplifiedRight);\n+      keepSubTree(original);\n     }\n \n     @Override\n       Node thenBranch = condition.getNext();\n       Node elseBranch = thenBranch.getNext();\n       if (thenHasSideEffects && elseHasSideEffects) {\n-        Node simplified = hook.cloneNode();\n-        simplified.addChildToBack(condition.cloneTree());\n-        simplified.addChildToBack(simplifyShortCircuitBranch(thenBranch));\n-        simplified.addChildToBack(simplifyShortCircuitBranch(elseBranch));\n-        replacements.add(simplified);\n+        hook.detachChildren();\n+        hook.addChildToBack(condition);\n+        hook.addChildToBack(simplifyShortCircuitBranch(thenBranch));\n+        hook.addChildToBack(simplifyShortCircuitBranch(elseBranch));\n+        keepSubTree(hook);\n       } else if (thenHasSideEffects || elseHasSideEffects) {\n         int type = thenHasSideEffects ? Token.AND : Token.OR;\n         Node body = thenHasSideEffects ? thenBranch : elseBranch;\n         Node simplified = new Node(\n-            type, condition.cloneTree(), simplifyShortCircuitBranch(body))\n+            type, condition.detachFromParent(),\n+            simplifyShortCircuitBranch(body))\n             .copyInformationFrom(hook);\n-        replacements.add(simplified);\n+        keepSubTree(simplified);\n       } else {\n         throw new IllegalArgumentException(\n             \"keepSimplifiedHookExpression must keep at least 1 branch\");\n           compiler, node,\n           new GatherSideEffectSubexpressionsCallback(\n               compiler,\n-              new CopySideEffectSubexpressions(compiler, parts)));\n+              new GetReplacementSideEffectSubexpressions(compiler, parts)));\n \n       Node ret = null;\n       for (Node part : parts) {\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n-import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.CopySideEffectSubexpressions;\n+import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.GetReplacementSideEffectSubexpressions;\n import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.SideEffectAccumulator;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n       } else {\n         // ... name.prototype.foo = function() { ... } ...\n         changeProxy.replaceWith(gramps, parent,\n-                                parent.getLastChild().cloneTree());\n+                                parent.getLastChild().detachFromParent());\n       }\n     }\n   }\n \n     /** The CALL node */\n     Node node;\n-\n-    /** The parent of {@code node} */\n-    Node parent;\n-\n-    /** The parent of {@code parent} */\n-    Node gramps;\n \n     /**\n      * Create a special reference node.\n      *\n      * @param name The name\n      * @param node The CALL node\n-     * @param parent The parent of {@code node}\n-     * @param gramps The parent of {@code parent}\n      */\n-    SpecialReferenceNode(JsName name, Node node, Node parent,\n-        Node gramps) {\n+    SpecialReferenceNode(JsName name, Node node) {\n       this.name = name;\n       this.node = node;\n-      this.parent = parent;\n-      this.gramps = gramps;\n     }\n \n     @Override\n     public JsName name() {\n       return name;\n+    }\n+\n+    Node getParent() {\n+      return node.getParent();\n+    }\n+\n+    Node getGramps() {\n+      return node.getParent() == null ? null : node.getParent().getParent();\n     }\n   }\n \n      * @param parent The parent of {@code node}\n      * @param gramps The parent of {@code parent}\n      */\n-    ClassDefiningFunctionNode(JsName name, Node node, Node parent,\n-        Node gramps) {\n-      super(name, node, parent, gramps);\n+    ClassDefiningFunctionNode(JsName name, Node node) {\n+      super(name, node);\n       Preconditions.checkState(node.isCall());\n     }\n \n     @Override\n     public void remove() {\n       Preconditions.checkState(node.isCall());\n+      Node parent = getParent();\n       if (parent.isExprResult()) {\n-        changeProxy.removeChild(gramps, parent);\n+        changeProxy.removeChild(getGramps(), parent);\n       } else {\n         changeProxy.replaceWith(parent, node, IR.voidNode(IR.number(0)));\n       }\n      *     node.\n      * @param gramps The parent of {@code parent}.\n      */\n-    InstanceOfCheckNode(JsName name, Node node, Node parent, Node gramps) {\n-      super(name, node, parent, gramps);\n+    InstanceOfCheckNode(JsName name, Node node) {\n+      super(name, node);\n       Preconditions.checkState(node.isQualifiedName());\n-      Preconditions.checkState(parent.isInstanceOf());\n+      Preconditions.checkState(getParent().isInstanceOf());\n     }\n \n     @Override\n     public void remove() {\n-      changeProxy.replaceWith(gramps, parent, IR.falseNode());\n+      changeProxy.replaceWith(getGramps(), getParent(), IR.falseNode());\n     }\n   }\n \n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n           JsName name = getName(ns.name, true);\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n+          refNodes.add(new ClassDefiningFunctionNode(name, n));\n         }\n       }\n     }\n           // Don't cover GETELEMs with a global root node.\n           n.isQualifiedName()) {\n         JsName checkedClass = getName(nameInfo.name, true);\n-        refNodes.add(\n-            new InstanceOfCheckNode(\n-                checkedClass, n, parent, parent.getParent()));\n+        refNodes.add(new InstanceOfCheckNode(checkedClass, n));\n         checkedClass.hasInstanceOfReference = true;\n         return;\n       }\n         compiler, n,\n         new GatherSideEffectSubexpressionsCallback(\n             compiler,\n-            new CopySideEffectSubexpressions(compiler, subexpressions)));\n+            new GetReplacementSideEffectSubexpressions(\n+                compiler, subexpressions)));\n \n     List<Node> replacements =\n         Lists.newArrayListWithExpectedSize(subexpressions.size());\n--- a/test/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallbackTest.java\n+++ b/test/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallbackTest.java\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n-import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.CopySideEffectSubexpressions;\n+import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.GetReplacementSideEffectSubexpressions;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n                                                    List<String> expected) {\n     Compiler compiler = new Compiler();\n     List<Node> replacements = Lists.newArrayList();\n-    CopySideEffectSubexpressions accumulator =\n-        new CopySideEffectSubexpressions(compiler, replacements);\n+    GetReplacementSideEffectSubexpressions accumulator =\n+        new GetReplacementSideEffectSubexpressions(compiler, replacements);\n     accumulator.keepSimplifiedShortCircuitExpression(root);\n \n     List<String> actual = Lists.newArrayList();\n                                            List<String> expected) {\n     Compiler compiler = new Compiler();\n     List<Node> replacements = Lists.newArrayList();\n-    CopySideEffectSubexpressions accumulator =\n-        new CopySideEffectSubexpressions(compiler, replacements);\n+    GetReplacementSideEffectSubexpressions accumulator =\n+        new GetReplacementSideEffectSubexpressions(compiler, replacements);\n     accumulator.keepSimplifiedHookExpression(root,\n                                              thenHasSideEffects,\n                                              elseHasSideEffects);\n--- a/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n+++ b/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n         \"}; new Bar().func();\");\n   }\n \n+  public void testDoNotChangeLocalScopeReferencedLocalScopedInstanceOf2() {\n+    test(\n+        \"function Foo() {}\" +\n+        \"var createAxis = function(f) { return window.passThru(f); };\" +\n+        \"var axis = createAxis(function(test) {\" +\n+        \"  return test instanceof Foo;\" +\n+        \"});\",\n+        \"var createAxis = function(f) { return window.passThru(f); };\" +\n+        \"createAxis(function(test) {\" +\n+        \"  return false;\" +\n+        \"});\");\n+  }\n+\n   public void testDoNotChangeInstanceOfGetElem() {\n     testSame(\"var goog = {};\" +\n         \"function f(obj, name) {\" +", "timestamp": 1348526368, "metainfo": ""}