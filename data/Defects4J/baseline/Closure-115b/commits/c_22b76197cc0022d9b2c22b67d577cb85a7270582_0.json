{"sha": "22b76197cc0022d9b2c22b67d577cb85a7270582", "log": "Better namespace filling  R=acleung DELTA=46  (38 added, 2 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3662   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n   }\n \n   /**\n+   * Get the symbols in their natural ordering.\n+   * Always returns a mutable list.\n+   */\n+  public List<Symbol> getAllSymbolsSorted() {\n+    List<Symbol> sortedSymbols = Lists.newArrayList(symbols.values());\n+    Collections.sort(sortedSymbols, getNaturalSymbolOrdering());\n+    return sortedSymbols;\n+  }\n+\n+  /**\n    * Gets the 'natural' ordering of symbols.\n    *\n    * Right now, we only guarantee that symbols in the global scope will come\n    * because that would be redundant.\n    */\n   void fillNamespaceReferences() {\n-    for (Symbol symbol : getAllSymbols()) {\n+    for (Symbol symbol : getAllSymbolsSorted()) {\n       for (Reference ref : getReferences(symbol)) {\n         Node currentNode = ref.getNode();\n         while (currentNode.getType() == Token.GETPROP) {\n           if (name != null) {\n             Symbol namespace = symbol.scope.getSlot(name);\n \n-            // Never create new symbols, because we don't want to guess at\n-            // declarations if we're not sure. If this symbol doesn't exist,\n-            // then we probably want to add a better symbol table that does\n-            // have it.\n+            if (namespace == null && symbol.scope.isGlobalScope()) {\n+              namespace = declareSymbol(name,\n+                  registry.getNativeType(JSTypeNative.UNKNOWN_TYPE),\n+                  true,\n+                  symbol.scope,\n+                  currentNode,\n+                  null /* jsdoc info */);\n+            }\n+\n             if (namespace != null) {\n               namespace.defineReferenceAt(currentNode);\n             }\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(0, refs.size());\n   }\n \n+  public void testGlobalThisReferences3() throws Exception {\n+    SymbolTable table = createSymbolTable(\"this.foo = {}; this.foo.bar = {};\");\n+\n+    Symbol global = getGlobalVar(table, \"*global*\");\n+    assertNotNull(global);\n+\n+    List<Reference> refs = table.getReferenceList(global);\n+    assertEquals(2, refs.size());\n+  }\n+\n   public void testGlobalThisPropertyReferences() throws Exception {\n     SymbolTable table = createSymbolTable(\n         \"/** @constructor */ function Foo() {} this.Foo;\");\n     assertNotNull(goog);\n     assertEquals(2, table.getReferenceList(goog).size());\n \n-    // TODO(nicksantos): We should try to create a symbol for goog.dom,\n-    // even though we can't find a declaration for it.\n     Symbol googDom = getGlobalVar(table, \"goog.dom\");\n-    assertNull(googDom);\n+    assertNotNull(googDom);\n+    assertEquals(2, table.getReferenceList(googDom).size());\n \n     Symbol googDomHelper = getGlobalVar(table, \"goog.dom.DomHelper\");\n     assertNotNull(googDomHelper);\n       }\n     }\n \n+    // Make sure that the global \"this\" is declared at the first input root.\n+    Symbol global = getGlobalVar(table, \"*global*\");\n+    assertNotNull(global);\n+    assertNotNull(global.getDeclaration());\n+    assertEquals(Token.SCRIPT, global.getDeclaration().getNode().getType());\n+\n+    List<Reference> globalRefs = table.getReferenceList(global);\n+\n+    // The main reference list should never contain the synthetic declaration\n+    // for the global root.\n+    assertFalse(globalRefs.contains(global.getDeclaration()));\n+\n     return table;\n   }\n }", "timestamp": 1320856320, "metainfo": ""}