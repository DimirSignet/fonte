{"sha": "28cacf0c4882a93f8516f16b1d99a06e50a840ef", "log": "Re-arrange type resolution to handle IIFEs better R=blickly", "commit": "\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n     return Iterators.filter(\n         getVars(), DECLARATIVELY_UNBOUND_VARS_WITHOUT_TYPES);\n   }\n+\n+  static interface TypeResolver {\n+    void resolveTypes();\n+  }\n+\n+  private TypeResolver typeResolver;\n+\n+  /** Resolve all type references. Only used on typed scopes. */\n+  void resolveTypes() {\n+    if (typeResolver != null) {\n+      typeResolver.resolveTypes();\n+      typeResolver = null;\n+    }\n+  }\n+\n+  void setTypeResolver(TypeResolver resolver) {\n+    this.typeResolver = resolver;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/TypeInferencePass.java\n+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java\n     (new NodeTraversal(\n         compiler, new FirstScopeBuildingCallback(), scopeCreator))\n         .traverseWithScope(node, topScope);\n+\n+    Preconditions.checkState(scopeCreator instanceof MemoizedScopeCreator);\n+    for (Scope s :\n+           ((MemoizedScopeCreator) scopeCreator).getAllMemoizedScopes()) {\n+      s.resolveTypes();\n+    }\n+\n     (new NodeTraversal(\n         compiler, new SecondScopeBuildingCallback(), scopeCreator))\n         .traverseWithScope(node, topScope);\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n     }\n \n     scopeBuilder.resolveStubDeclarations();\n-    scopeBuilder.resolveTypes();\n \n     // Gather the properties in each function that we found in the\n     // global scope, if that function has a @this type that we can\n           typeRegistry, newScope, delegateProxyPrototypes,\n           delegateCallingConventions);\n     }\n+\n+    newScope.setTypeResolver(scopeBuilder);\n     return newScope;\n   }\n \n   }\n \n   private abstract class AbstractScopeBuilder\n-      implements NodeTraversal.Callback {\n+      implements NodeTraversal.Callback, Scope.TypeResolver {\n \n     /**\n      * The scope that we're building.\n       deferredSetTypes.add(new DeferredSetType(node, type));\n     }\n \n-    void resolveTypes() {\n+    @Override\n+    public void resolveTypes() {\n       // Resolve types and attach them to nodes.\n       for (DeferredSetType deferred : deferredSetTypes) {\n         deferred.resolve(scope);\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"})(namespace);\" +\n         \"/** @param {namespace.Ctor} x\\n\" +\n         \"  * @return {number} */ function f(x) { return x.bar; }\",\n-        \"Bad type annotation. Unknown type namespace.Ctor\");\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n   }\n \n   public void testNotIIFE1() throws Exception {\n   }\n \n   public void testQualifiedNameInference8() throws Exception {\n-    // We may need to reshuffle name resolution order so that the @param\n-    // type resolves correctly.\n     testClosureTypesMultipleWarnings(\n         \"var ns = {}; \" +\n         \"(function() { \" +\n         \"/** @param {ns.Foo} x */ function f(x) {}\" +\n         \"f(new ns.Foo(true));\",\n         Lists.newArrayList(\n-            \"Bad type annotation. Unknown type ns.Foo\",\n             \"actual parameter 1 of ns.Foo does not match formal parameter\\n\" +\n             \"found   : boolean\\n\" +\n             \"required: number\"));", "timestamp": 1365639826, "metainfo": ""}