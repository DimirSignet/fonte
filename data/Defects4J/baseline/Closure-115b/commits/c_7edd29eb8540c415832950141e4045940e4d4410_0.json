{"sha": "7edd29eb8540c415832950141e4045940e4d4410", "log": "Remove the code to change type-resolution semantics. Fixes issue 1065", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n import com.google.common.base.Predicate;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n-import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;\n \n import java.io.Serializable;\n import java.util.Comparator;\n   abstract <T> T visit(RelationshipVisitor<T> visitor, JSType that);\n \n   /**\n-   * Force this type to resolve, even if the registry is in a lazy\n-   * resolving mode.\n-   * @see #resolve\n-   */\n-  public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) {\n-    ResolveMode oldResolveMode = registry.getResolveMode();\n-    registry.setResolveMode(ResolveMode.IMMEDIATE);\n-    JSType result = resolve(t, scope);\n-    registry.setResolveMode(oldResolveMode);\n-    return result;\n-  }\n-\n-\n-  /**\n    * Resolve this type in the given scope.\n    *\n    * The returned value must be equal to {@code this}, as defined by\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n   private final boolean tolerateUndefinedValues;\n \n   /**\n-   * The type registry has three modes, which control how type ASTs are\n-   * converted to types in {@link #createFromTypeNodes}.\n-   */\n-  public static enum ResolveMode {\n-    /**\n-     * Expressions are converted into Unknown blobs that can be\n-     * resolved into complex types.\n-     */\n-    LAZY_EXPRESSIONS,\n-\n-    /**\n-     * Expressions are evaluated. If any names in the expression point to\n-     * unknown types, then we create a proxy {@code NamedType} structure\n-     * until the type can be resolved.\n-     *\n-     * This is the legacy way of resolving ways, and may not exist in the\n-     * future.\n-     */\n-    LAZY_NAMES,\n-\n-    /**\n-     * Expressions and type names are evaluated aggressively. A warning\n-     * will be emitted if a type name fails to resolve to a real type.\n-     */\n-    IMMEDIATE\n-  }\n-\n-  private ResolveMode resolveMode = ResolveMode.LAZY_NAMES;\n-\n-  /**\n    * Constructs a new type registry populated with the built-in types.\n    */\n   public JSTypeRegistry(ErrorReporter reporter) {\n   public TemplateType getObjectIndexKey() {\n     Preconditions.checkNotNull(objectIndexTemplateKey);\n     return objectIndexTemplateKey;\n-  }\n-\n-  /**\n-   * Set the current resolving mode of the type registry.\n-   * @see ResolveMode\n-   */\n-  public void setResolveMode(ResolveMode mode) {\n-    this.resolveMode = mode;\n-  }\n-\n-  ResolveMode getResolveMode() {\n-    return resolveMode;\n   }\n \n   public ErrorReporter getErrorReporter() {\n    */\n   public JSType createFromTypeNodes(Node n, String sourceName,\n       StaticScope<JSType> scope) {\n-    if (resolveMode == ResolveMode.LAZY_EXPRESSIONS) {\n-      // If the type expression doesn't contain any names, just\n-      // resolve it anyway.\n-      boolean hasNames = hasTypeName(n);\n-      if (hasNames) {\n-        return new UnresolvedTypeExpression(this, n, sourceName);\n-      }\n-    }\n     return createFromTypeNodesInternal(n, sourceName, scope);\n   }\n \n       case Token.STRING:\n         JSType namedType = getType(scope, n.getString(), sourceName,\n             n.getLineno(), n.getCharno());\n-        if (resolveMode != ResolveMode.LAZY_NAMES) {\n-          namedType = namedType.resolveInternal(reporter, scope);\n-        }\n         if ((namedType instanceof ObjectType) &&\n             !(nonNullableTypeNames.contains(n.getString()))) {\n           Node typeList = n.getFirstChild();\n--- a/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.SimpleErrorReporter;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;\n import com.google.javascript.rhino.testing.Asserts;\n import com.google.javascript.rhino.testing.AbstractStaticScope;\n import com.google.javascript.rhino.testing.MapBasedScope;\n     assertFalse(functionType.getReturnType().isUnknownType());\n   }\n \n-  public void testTypeResolutionModes() {\n-    SimpleErrorReporter reporter = new SimpleErrorReporter();\n-\n-    JSTypeRegistry lazyExprRegistry = new JSTypeRegistry(reporter);\n-    lazyExprRegistry.setResolveMode(ResolveMode.LAZY_EXPRESSIONS);\n-\n-    JSTypeRegistry lazyNameRegistry = new JSTypeRegistry(reporter);\n-    lazyNameRegistry.setResolveMode(ResolveMode.LAZY_NAMES);\n-\n-    JSTypeRegistry immediateRegistry = new JSTypeRegistry(reporter);\n-    immediateRegistry.setResolveMode(ResolveMode.IMMEDIATE);\n-\n-    Node expr = new Node(Token.QMARK, Node.newString(\"foo\"));\n-    StaticScope<JSType> empty = MapBasedScope.emptyScope();\n-\n-    JSType type = lazyExprRegistry.createFromTypeNodes(\n-        expr, \"source.js\", empty);\n-    assertTrue(type instanceof UnresolvedTypeExpression);\n-    assertTrue(type.isUnknownType());\n-    assertEquals(\"?\", type.toString());\n-    assertNull(\"Unexpected warnings: \" + reporter.warnings(),\n-        reporter.warnings());\n-\n-    type = lazyNameRegistry.createFromTypeNodes(\n-        expr, \"source.js\", empty);\n-    assertTrue(type instanceof UnionType);\n-    assertTrue(type.isUnknownType());\n-    assertEquals(\"(foo|null)\", type.toString());\n-    assertNull(\"Unexpected warnings: \" + reporter.warnings(),\n-        reporter.warnings());\n-\n-    type = immediateRegistry.createFromTypeNodes(\n-        expr, \"source.js\", empty);\n-    assertTrue(type instanceof UnknownType);\n-    assertEquals(\"Expected warnings\", 1, reporter.warnings().size());\n-  }\n-\n-  public void testForceResolve() {\n-    SimpleErrorReporter reporter = new SimpleErrorReporter();\n-\n-    JSTypeRegistry lazyExprRegistry = new JSTypeRegistry(reporter);\n-    lazyExprRegistry.setResolveMode(ResolveMode.LAZY_EXPRESSIONS);\n-\n-    Node expr = new Node(Token.QMARK, Node.newString(\"foo\"));\n-    StaticScope<JSType> empty = MapBasedScope.emptyScope();\n-\n-    JSType type = lazyExprRegistry.createFromTypeNodes(\n-        expr, \"source.js\", empty);\n-    assertFalse(type.isResolved());\n-    assertTrue(type.forceResolve(reporter, empty).isResolved());\n-    assertEquals(\"Expected warnings\", 1, reporter.warnings().size());\n-  }\n-\n-  public void testAllTypeResolvesImmediately() {\n-    JSTypeRegistry lazyExprRegistry = new JSTypeRegistry(\n-        new SimpleErrorReporter());\n-    lazyExprRegistry.setResolveMode(ResolveMode.LAZY_EXPRESSIONS);\n-\n-    Node expr = new Node(Token.STAR);\n-    JSType type = lazyExprRegistry.createFromTypeNodes(\n-        expr, \"source.js\", MapBasedScope.emptyScope());\n-    assertTrue(type instanceof AllType);\n-  }\n-\n   private void assertTypeEquals(JSType a, JSType b) {\n     Asserts.assertTypeEquals(a, b);\n   }", "timestamp": 1376453731, "metainfo": ""}