{"sha": "5e1a997d5d74cb4000339fa3680627fdfdbe1563", "log": "Java readability ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=52400888", "commit": "\n--- a/src/com/google/javascript/jscomp/MinimizedCondition.java\n+++ b/src/com/google/javascript/jscomp/MinimizedCondition.java\n import java.util.Collections;\n import java.util.Comparator;\n \n-/** A class that represents a minimized conditional expression.\n- *  Depending on the context, a leading NOT node in front of the conditional\n- *  may or may not be counted as a cost, so this class provides ways to\n- *  access minimized versions of both of those ASTs.\n+/**\n+ * A class that represents a minimized conditional expression.\n+ * This is a conditional expression that has been massaged according to\n+ * DeMorgan's laws in order to minimize the length of the source\n+ * representation.\n+ * <p>\n+ * Depending on the context, a leading NOT node in front of the conditional\n+ * may or may not be counted as a cost, so this class provides ways to\n+ * access minimized versions of both of those abstract syntax trees (ASTs).\n  *\n- *  @author blickly@google.com (Ben Lickly)\n+ * @author blickly@google.com (Ben Lickly)\n  */\n class MinimizedCondition {\n \n     return this;\n   }\n \n-  /** Remove the passed condition node from the AST, and then return a\n-   *  MinimizedCondition that represents the condition node after\n-   *  minimization.\n+  /**\n+   * Remove the passed condition node from the AST, and then return a\n+   * MinimizedCondition that represents the condition node after\n+   * minimization.\n    */\n   static MinimizedCondition fromConditionNode(Node n) {\n-    MinimizedCondition minCond;\n     switch (n.getType()) {\n       case Token.NOT:\n       case Token.AND:\n     }\n   }\n \n-  /** Return the shorter representation of the original condition node.\n+  /**\n+   * Return the shorter representation of the original condition node.\n+   * <p>\n+   * Depending on the context, this may require to either penalize or\n+   * not the existance of a leading NOT node.\n+   * <ul><li>When {@code style} is {@code PREFER_UNNEGATED}, simply try to\n+   * minimize the total length of the conditional.</li>\n+   * <li>When {@code style} is {@code ALLOW_LEADING_NOT}, prefer the right side\n+   * in cases such as:\n+   * <br><code>\n+   *    !x || !y || z  ==>  !(x && y && !z)\n+   * </code><br>\n+   * This is useful in contexts such as IFs or HOOKs where subsequent\n+   * optimizations can efficiently deal with leading NOTs.\n+   * </li></ul>\n    *\n-   * @param style Whether to count a leading NOT in doing the minimization.\n-   *  i.e. Prefer the right side in cases such as:\n-   *    !x || !y || z  ==>  !(x && y && !z)\n-   *  This is useful in contexts such as IFs or HOOKs where subsequent\n-   *  optimizations can efficiently deal with leading NOTs.\n-   *\n-   *  @return The minimized condition MeasuredNode, with equivalent semantics\n-   *    to that passed to #fromConditionNode().\n+   * @return the minimized condition MeasuredNode, with equivalent semantics\n+   *   to that passed to {@link #fromConditionNode}.\n    */\n   MeasuredNode getMinimized(MinimizationStyle style) {\n     if (style == MinimizationStyle.PREFER_UNNEGATED\n     }\n   }\n \n-  /** Return a MeasuredNode of the given condition node, without minimizing\n+  /**\n+   * Return a MeasuredNode of the given condition node, without minimizing\n    * the result.\n+   * <p>\n+   * Since a MinimizedCondition necessarily must contain two trees, this\n+   * method sets the negative side to a {@link Token#SCRIPT} node (never valid\n+   * inside an expression) with an unreasonably high length so that it will\n+   * never be chosen by {@link #getMinimized}.\n    *\n-   *  @param n The conditional expression tree to minimize.\n-   *   This must be removed from the tree before being passed in connected.\n-   *  @return A MinimizedCondition object representing that tree.\n+   * @param n the conditional expression tree to minimize.\n+   *  This must be connected to the AST, and will be swapped\n+   *  with a placeholder node during minimization.\n+   * @return a MinimizedCondition object representing that tree.\n    */\n   static MinimizedCondition unoptimized(Node n) {\n     Preconditions.checkNotNull(n.getParent());\n     Node placeholder = swapWithPlaceholderNode(n);\n     MeasuredNode pos = new MeasuredNode(n, 0, false);\n-    // In the unoptimized case, we want to always return the positive side,\n-    // so we set the negative side to a SCRIPT node (never valid inside an\n-    // expression) with an unreasonably high length so that it's never chosen.\n     MeasuredNode neg = new MeasuredNode(IR.script(), Integer.MAX_VALUE, true);\n     return new MinimizedCondition(pos, neg).setPlaceholder(placeholder);\n   }\n \n-  /** Remove the given node from the AST, and replace it with a placeholder\n-   *  SCRIPT node.\n-   *  @return The new placeholder node.\n+  /**\n+   * Remove the given node from the AST, and replace it with a placeholder\n+   * SCRIPT node.\n+   * @return the new placeholder node.\n    */\n   private static Node swapWithPlaceholderNode(Node n) {\n     Preconditions.checkNotNull(n.getParent());\n     return placeholder;\n   }\n \n-  /** Minimize the condition at the given node.\n+  /**\n+   * Minimize the condition at the given node.\n    *\n-   *  @param n The conditional expression tree to minimize.\n-   *   This must be removed from the tree before being passed in connected.\n-   *  @return A MinimizedCondition object representing that tree.\n+   * @param n the conditional expression tree to minimize.\n+   *  This must be connected to the AST, and will be swapped\n+   *  with a placeholder node during minimization.\n+   * @return a MinimizedCondition object representing that tree.\n    */\n   private static MinimizedCondition computeMinimizedCondition(Node n) {\n     Preconditions.checkArgument(n.getParent() == null);\n \n     private MeasuredNode negate() {\n       this.change();\n-      int complementOperator;\n       switch (node.getType()) {\n+        case Token.EQ:\n+          node.setType(Token.NE);\n+          return this;\n+        case Token.NE:\n+          node.setType(Token.EQ);\n+          return this;\n+        case Token.SHEQ:\n+          node.setType(Token.SHNE);\n+          return this;\n+        case Token.SHNE:\n+          node.setType(Token.SHEQ);\n+          return this;\n         default:\n           return this.addNot();\n-        // Otherwise a binary operator with a complement.\n-        case Token.EQ:\n-          complementOperator = Token.NE;\n-          break;\n-        case Token.NE:\n-          complementOperator = Token.EQ;\n-          break;\n-        case Token.SHEQ:\n-          complementOperator = Token.SHNE;\n-          break;\n-        case Token.SHNE:\n-          complementOperator = Token.SHEQ;\n-          break;\n-      }\n-      // Clone entire tree and just change operator.\n-      node.setType(complementOperator);\n-      return this;\n+      }\n     }\n \n     private MeasuredNode change() {\n       return this;\n     }\n \n-    /** Estimate the number of characters in the textual representation of\n+    /**\n+     *  Estimate the number of characters in the textual representation of\n      *  the given node and that will be devoted to negation or parentheses.\n      *  Since these are the only characters that flipping a condition\n      *  according to De Morgan's rule can affect, these are the only ones\n      *  we count.\n      *  Not nodes are counted by the NOT node itself, whereas\n      *  parentheses around an expression are counted by the parent node.\n-     *  @param n The node to be checked.\n-     *  @return The number of negations and parentheses in the node.\n+     *  @param n the node to be checked.\n+     *  @return the number of negations and parentheses in the node.\n      */\n     private static int estimateCostOneLevel(Node n) {\n       int cost = 0;\n \n   }\n \n-}\n+}\n--- a/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n+++ b/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n \n   private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n   private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n-  private static final boolean DEFAULT_AGGRESSIVE_MINIMIZE_CONDITIONS = true;\n \n   private final boolean late;\n-  private final boolean aggressiveMinimization;\n-\n-  static final Predicate<Node> DONT_TRAVERSE_FUNCTIONS_PREDICATE\n-      = new Predicate<Node>() {\n-    @Override\n-    public boolean apply(Node input) {\n-      return !input.isFunction();\n-    }\n-  };\n \n   /**\n    * @param late When late is false, this mean we are currently running before\n    * do anything to minimize for size.\n    */\n   PeepholeMinimizeConditions(boolean late) {\n-    this(late, DEFAULT_AGGRESSIVE_MINIMIZE_CONDITIONS);\n-  }\n-\n-  PeepholeMinimizeConditions(boolean late, boolean aggressive) {\n     this.late = late;\n-    this.aggressiveMinimization = aggressive;\n-  }\n-\n-  /**\n-   * Tries apply our various peephole minimizations on the passed in node.\n+  }\n+\n+  /**\n+   * Tries to apply our various peephole minimizations on the passed in node.\n    */\n   @Override\n   @SuppressWarnings(\"fallthrough\")\n    * necessary.\n    */\n   private Node tryMinimizeExprResult(Node n) {\n-    MinimizedCondition minCond = (aggressiveMinimization) ?\n-      MinimizedCondition.fromConditionNode(n.getFirstChild()) :\n-        MinimizedCondition.unoptimized(n.getFirstChild());\n+    MinimizedCondition minCond =\n+        MinimizedCondition.fromConditionNode(n.getFirstChild());\n     MinimizedCondition.MeasuredNode mNode =\n         minCond.getMinimized(MinimizationStyle.ALLOW_LEADING_NOT);\n     Node placeholder = minCond.getPlaceholder();\n    * necessary.\n    */\n   private Node tryMinimizeHook(Node n) {\n-    MinimizedCondition minCond = (aggressiveMinimization) ?\n-      MinimizedCondition.fromConditionNode(n.getFirstChild()) :\n-        MinimizedCondition.unoptimized(n.getFirstChild());\n+    MinimizedCondition minCond =\n+      MinimizedCondition.fromConditionNode(n.getFirstChild());\n     MinimizedCondition.MeasuredNode mNode =\n         minCond.getMinimized(MinimizationStyle.ALLOW_LEADING_NOT);\n     Node placeholder = minCond.getPlaceholder();\n     Node thenBranch = originalCond.getNext();\n     Node elseBranch = thenBranch.getNext();\n \n-    MinimizedCondition minCond = (aggressiveMinimization) ?\n-        MinimizedCondition.fromConditionNode(originalCond) :\n-          MinimizedCondition.unoptimized(originalCond);\n+    MinimizedCondition minCond =\n+        MinimizedCondition.fromConditionNode(originalCond);\n     originalCond = null;  // originalCond was mutated and should not be used.\n \n     Node placeholder = minCond.getPlaceholder();\n     };\n \n     return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,\n-        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n+        NodeUtil.MATCH_NOT_FUNCTION);\n   }\n \n   /**\n    */\n   private Node tryMinimizeCondition(Node n) {\n     n = performConditionSubstitutions(n);\n-    if (aggressiveMinimization) {\n-      MinimizedCondition minCond = MinimizedCondition.fromConditionNode(n);\n-      return replaceNode(\n-          minCond.getPlaceholder(),\n-          minCond.getMinimized(MinimizationStyle.PREFER_UNNEGATED));\n-    } else {\n-      return n;\n-    }\n+    MinimizedCondition minCond = MinimizedCondition.fromConditionNode(n);\n+    return replaceNode(\n+        minCond.getPlaceholder(),\n+        minCond.getMinimized(MinimizationStyle.PREFER_UNNEGATED));\n   }\n \n   private Node replaceNode(Node lhs, MinimizedCondition.MeasuredNode rhs) {\n    *   Returns the replacement for n, or the original if no change was made\n    */\n   private Node performConditionSubstitutions(Node n) {\n-    if (!aggressiveMinimization && n.isNot()) {\n-      return simpleDemorgan(n);\n-    }\n-\n     Node parent = n.getParent();\n \n     switch (n.getType()) {\n   }\n \n   /**\n-   *  Perform a heuristic-based application of De Morgan's Laws, trying to\n-   *  push NOT nodes further down the AST toward the leaves.\n-   */\n-  private Node simpleDemorgan(Node n) {\n-    Node parent = n.getParent();\n-    Node first = n.getFirstChild();\n-    switch (first.getType()) {\n-      case Token.NOT: {\n-        Node newRoot = first.removeFirstChild();\n-        parent.replaceChild(n, newRoot);\n-        reportCodeChange();\n-        // No need to traverse, tryMinimizeCondition is called on the\n-        // NOT children are handled below.\n-        return newRoot;\n-      }\n-      case Token.AND:\n-      case Token.OR: {\n-        // !(!x && !y) --> x || y\n-        // !(!x || !y) --> x && y\n-        // !(!x && y) --> x || !y\n-        // !(!x || y) --> x && !y\n-        // !(x && !y) --> !x || y\n-        // !(x || !y) --> !x && y\n-        // !(x && y) --> !x || !y\n-        // !(x || y) --> !x && !y\n-        Node leftParent = first.getFirstChild();\n-        Node rightParent = first.getLastChild();\n-        Node left, right;\n-\n-        // Check special case when such transformation cannot reduce\n-        // due to the added ()\n-        // It only occurs when both of expressions are not NOT expressions\n-        if (!leftParent.isNot()\n-            && !rightParent.isNot()) {\n-          // If an expression has higher precedence than && or ||,\n-          // but lower precedence than NOT, an additional () is needed\n-          // Thus we do not preceed\n-          int opPrecedence = NodeUtil.precedence(first.getType());\n-          if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE)\n-              && isHigherPrecedence(leftParent, opPrecedence))\n-              || (isLowerPrecedence(rightParent, NOT_PRECEDENCE)\n-                  && isHigherPrecedence(rightParent, opPrecedence))) {\n-            return n;\n-          }\n-        }\n-\n-        if (leftParent.isNot()) {\n-          left = leftParent.removeFirstChild();\n-        } else {\n-          leftParent.detachFromParent();\n-          left = IR.not(leftParent).srcref(leftParent);\n-        }\n-        if (rightParent.isNot()) {\n-          right = rightParent.removeFirstChild();\n-        } else {\n-          rightParent.detachFromParent();\n-          right = IR.not(rightParent).srcref(rightParent);\n-        }\n-\n-        int newOp = (first.isAnd()) ? Token.OR : Token.AND;\n-        Node newRoot = new Node(newOp, left, right);\n-        parent.replaceChild(n, newRoot);\n-        reportCodeChange();\n-        // No need to traverse, tryMinimizeCondition is called on the\n-        // AND and OR children below.\n-        return newRoot;\n-      }\n-\n-      default:\n-        TernaryValue nVal = NodeUtil.getPureBooleanValue(first);\n-        if (nVal != TernaryValue.UNKNOWN) {\n-          boolean result = nVal.not().toBoolean(true);\n-          int equivalentResult = result ? 1 : 0;\n-          return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n-        }\n-    }\n-    // No need to traverse, tryMinimizeCondition is called on the NOT\n-    // children in the general case in the main post-order traversal.\n-    return n;\n-  }\n-\n-  /**\n    * Replaces a node with a number node if the new number node is not equivalent\n    * to the current node.\n    *\n--- a/test/com/google/javascript/jscomp/MinimizedConditionTest.java\n+++ b/test/com/google/javascript/jscomp/MinimizedConditionTest.java\n /**\n  * Tests for {@link MinimizedCondition} in isolation.\n  * Tests for the containing PeepholeMinimizeConditions pass are in\n- * PeepholeMinimizeConditionsTest.\n+ * {@link PeepholeMinimizeConditionsTest}.\n  *\n  * @author blickly@google.com (Ben Lickly)\n  */\n     minCond(\"!(x && y)\", \"!x || !y\", \"!(x && y)\");\n   }\n \n-  public void testMinimizeDemorgan() {\n+  public void testMinimizeDemorganSimple() {\n     minCond(\"!(x&&y)\", \"!x||!y\", \"!(x&&y)\");\n     minCond(\"!(x||y)\", \"!x&&!y\", \"!(x||y)\");\n     minCond(\"!x||!y\", \"!x||!y\", \"!(x&&y)\");\n     minCond(\"!x&&!y\", \"!x&&!y\", \"!(x||y)\");\n     minCond(\"!(x && y && z)\", \"!(x && y && z)\", \"!(x && y && z)\");\n-  }\n-\n-  public void testMinimizeDemorgan2() {\n     minCond(\"(!a||!b)&&c\", \"(!a||!b)&&c\", \"!(a&&b||!c)\");\n-  }\n-\n-  public void testMinimizeDemorgan3() {\n     minCond(\"(!a||!b)&&(c||d)\", \"!(a&&b||!c&&!d)\", \"!(a&&b||!c&&!d)\");\n   }\n \n-  public void testMinimizeDemorgan4() {\n+  public void testMinimizeBug8494751() {\n     minCond(\n         \"x && (y===2 || !f()) && (y===3 || !h())\",\n         \"x && !((y!==2 && f()) || (y!==3 && h()))\",\n         \"!(!x || (y!==2 && f()) || (y!==3 && h()))\");\n   }\n \n-  public void testMinimizeDemorgan5() {\n+  public void testMinimizeComplementableOperator() {\n     minCond(\n         \"0===c && (2===a || 1===a)\",\n         \"0===c && (2===a || 1===a)\",\n         \"!(0!==c || 2!==a && 1!==a)\");\n-  }\n-\n-  public void testMinimizeDemorgan6() {\n-    minCond(\"!((x,y)&&z)\", \"(x,!y)||!z\", \"!((x,y)&&z)\");\n   }\n \n   public void testMinimizeHook() {\n \n   public void testMinimizeComma() {\n     minCond(\"!(inc(), test())\", \"inc(), !test()\", \"!(inc(), test())\");\n+    minCond(\"!((x,y)&&z)\", \"(x,!y)||!z\", \"!((x,y)&&z)\");\n   }\n \n }\n--- a/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n public class PeepholeMinimizeConditionsTest extends CompilerTestCase {\n \n   private boolean late = true;\n-  private boolean aggressive = true;\n \n   // TODO(user): Remove this when we no longer need to do string comparison.\n   private PeepholeMinimizeConditionsTest(boolean compareAsTree) {\n   @Override\n   public void setUp() throws Exception {\n     late = true;\n-    aggressive = true;\n     super.setUp();\n     enableLineNumberCheck(true);\n     disableNormalize();\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass(\n-        compiler, new PeepholeMinimizeConditions(late, aggressive));\n+        compiler, new PeepholeMinimizeConditions(late));\n     peepholePass.setRetraverseOnChange(false);\n     return peepholePass;\n   }", "timestamp": 1379463782, "metainfo": ""}