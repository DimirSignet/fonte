{"sha": "b8c52bf5e76948ee8d561fa55a36cc6c9f5d0c68", "log": "Fix a null pointer exception in FunctionType.  Fix a bug in @export generation.  Remove references to StringUtil.  Only create one ParserConfig per compilation process.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n \n import com.google.common.base.Supplier;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n+import com.google.javascript.jscomp.parsing.Config;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n-\n \n /**\n  * An abstract compiler, to help remove the circular dependency of\n   abstract boolean isIdeMode();\n \n   /**\n+   * Returns the parser configuration.\n+   */\n+  abstract Config getParserConfig();\n+\n+  /**\n    * Returns true if type checking is enabled.\n    */\n   abstract boolean isTypeCheckingEnabled();\n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n \n import javax.annotation.Nullable;\n import com.google.common.base.Preconditions;\n-import com.google.common.base.StringUtil;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n     this.compiler = compiler;\n     this.moduleGraph = moduleGraph;\n \n-    if (!StringUtil.isEmpty(unaliasableGlobals) &&\n-        !StringUtil.isEmpty(aliasableGlobals)) {\n+    if (!Strings.isEmpty(unaliasableGlobals) &&\n+        !Strings.isEmpty(aliasableGlobals)) {\n       throw new IllegalArgumentException(\n           \"Cannot pass in both unaliasable and aliasable globals; you must \" +\n           \"choose one or the other.\");\n     }\n \n-    if (!StringUtil.isEmpty(unaliasableGlobals)) {\n+    if (!Strings.isEmpty(unaliasableGlobals)) {\n       this.unaliasableGlobals.addAll(\n           Arrays.asList(unaliasableGlobals.split(\",\")));\n     }\n \n-    if (!StringUtil.isEmpty(aliasableGlobals)) {\n+    if (!Strings.isEmpty(aliasableGlobals)) {\n       this.aliasableGlobals.addAll(Arrays.asList(aliasableGlobals.split(\",\")));\n     }\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n+import com.google.javascript.jscomp.parsing.Config;\n+import com.google.javascript.jscomp.parsing.ParserRunner;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n   CodingConvention defaultCodingConvention = new GoogleCodingConvention();\n \n   private JSTypeRegistry typeRegistry;\n+  private Config parserConfig = null;\n \n   private ReverseAbstractInterpreter abstractInterpreter;\n   private final TypeValidator typeValidator;\n   }\n \n   @Override\n+  Config getParserConfig() {\n+    if (parserConfig == null) {\n+      parserConfig = ParserRunner.createConfig(\n+          getTypeRegistry(), isIdeMode());\n+    }\n+    return parserConfig;\n+  }\n+\n+  @Override\n   public boolean isTypeCheckingEnabled() {\n     return options_.checkTypes;\n   }\n--- a/src/com/google/javascript/jscomp/GenerateExports.java\n+++ b/src/com/google/javascript/jscomp/GenerateExports.java\n \n       Node expression = new Node(Token.EXPR_RESULT, call);\n       annotate(expression);\n-      context.getScriptNode().addChildAfter(expression,\n-          context.getContextNode());\n+\n+      // It's important that any class-building calls (goog.inherits)\n+      // come right after the class definition, so move the export after that.\n+      Node insertionPoint = context.getContextNode().getNext();\n+      CodingConvention convention = compiler.getCodingConvention();\n+      while (insertionPoint != null &&\n+          NodeUtil.isExprCall(insertionPoint) &&\n+          convention.getClassesDefinedByCall(insertionPoint) == null) {\n+        insertionPoint = insertionPoint.getNext();\n+      }\n+\n+      if (insertionPoint == null) {\n+        context.getScriptNode().addChildToBack(expression);\n+      } else {\n+        context.getScriptNode().addChildBefore(expression, insertionPoint);\n+      }\n       compiler.reportCodeChange();\n     }\n   }\n--- a/src/com/google/javascript/jscomp/JsAst.java\n+++ b/src/com/google/javascript/jscomp/JsAst.java\n       String sourceStr) {\n     try {\n       logger_.fine(\"Parsing: \" + sourceName);\n-      root = ParserRunner.parse(sourceName, sourceStr, compiler.isIdeMode(),\n-          compiler.getTypeRegistry(),\n+      root = ParserRunner.parse(sourceName, sourceStr,\n+          compiler.getParserConfig(),\n           compiler.getDefaultErrorReporter(),\n           logger_);\n     } catch (IOException e) {\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n \n import static com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE;\n \n-import com.google.common.base.StringUtil;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.SourceExcerptProvider.ExcerptFormatter;\n import com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt;\n \n         // nice spaces for the line number\n         int spaces = numberLength - Integer.toString(lineNumber).length();\n-        builder.append(StringUtil.repeat(\" \", spaces));\n+        builder.append(Strings.repeat(\" \", spaces));\n         builder.append(lineNumber);\n         builder.append(\"| \");\n \n--- a/src/com/google/javascript/jscomp/LocaleUtil.java\n+++ b/src/com/google/javascript/jscomp/LocaleUtil.java\n  */\n \n package com.google.javascript.jscomp;\n-\n-import com.google.common.base.StringUtil;\n \n import java.util.Locale;\n import java.util.regex.Matcher;\n     // subsequent text.\n     matcher.find();\n \n-    String language = StringUtil.makeSafe(matcher.group(1));\n-    String country = StringUtil.makeSafe(matcher.group(2));\n-    String variant = StringUtil.makeSafe(matcher.group(3));\n+    String language = Strings.makeSafe(matcher.group(1));\n+    String country = Strings.makeSafe(matcher.group(2));\n+    String variant = Strings.makeSafe(matcher.group(3));\n \n     return new Locale(language, country, variant);\n   }\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.base.StringUtil;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     Node root2 = compiler.parseSyntheticCode(source);\n     if (compiler.hasHaltingErrors()) {\n       compiler.report(JSError.make(CANNOT_PARSE_GENERATED_CODE,\n-              StringUtil.truncateAtMaxLength(source, 100, true)));\n+              Strings.truncateAtMaxLength(source, 100, true)));\n       return null;\n     }\n \n     String source2 = compiler.toSource(root2);\n     if (!source.equals(source2)) {\n       compiler.report(JSError.make(GENERATED_BAD_CODE,\n-              StringUtil.truncateAtMaxLength(source, 100, true),\n-              StringUtil.truncateAtMaxLength(source2, 100, true)));\n+              Strings.truncateAtMaxLength(source, 100, true),\n+              Strings.truncateAtMaxLength(source2, 100, true)));\n     }\n \n     return root2;\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/Strings.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Guava code that will eventually be open-sourced properly. Package-private\n+ * until they're able to do that. A lot of these methods are discouraged\n+ * anyways.\n+ *\n+*\n+ */\n+class Strings {\n+  private Strings() {} // All static\n+\n+  /**\n+   * Returns {@code true} if the given string is either null or the empty string\n+   * (\"\").\n+   *\n+   * @param string the string reference to check\n+   * @return {@code true} if {@code string} is either null or the empty string\n+   */\n+  static boolean isEmpty(@Nullable String string) {\n+    return string == null || string.isEmpty();\n+  }\n+\n+  /**\n+   * Returns the given string if it is non-null; the empty string otherwise.\n+   *\n+   * @param string the string to test and possibly return\n+   * @return {@code string} itself if it is non-null; {@code \"\"} if it is null\n+   */\n+  static String makeSafe(@Nullable String string) {\n+    return (string == null) ? \"\" : string;\n+  }\n+\n+  /**\n+   * Returns a string consisting of the input string concatenated a given number\n+   * of times. For example, {@code repeat(\"hey\", 3)} returns the string {@code\n+   * \"heyheyhey\"}.\n+   *\n+   * @param string any non-null string\n+   * @param count the number of times to repeat it; a nonnegative integer\n+   * @return a string containing {@code string} repeated {@code count} times\n+   *     (the empty string if {@code count} is zero)\n+   * @throws IllegalArgumentException if {@code count} is negative\n+   */\n+  static String repeat(String string, int count) {\n+    // If this multiplication overflows, a NegativeArraySizeException or\n+    // OutOfMemoryError is not far behind\n+    StringBuilder builder = new StringBuilder(string.length() * count);\n+    for (int i = 0; i < count; i++) {\n+      builder.append(string);\n+    }\n+    return builder.toString();\n+  }\n+  /**\n+   * If this given string is of length {@code maxLength} or less, it will\n+   * be returned as-is.\n+   * Otherwise it will be trucated to {@code maxLength}, regardless of whether\n+   * there are any space characters in the String. If an ellipsis is requested\n+   * to be appended to the truncated String, the String will be truncated so\n+   * that the ellipsis will also fit within maxLength.\n+   * If no truncation was necessary, no ellipsis will be added.\n+   * @param source the String to truncate if necessary\n+   * @param maxLength the maximum number of characters to keep\n+   * @param addEllipsis if true, and if the String had to be truncated,\n+   *     add \"...\" to the end of the String before returning. Additionally,\n+   *     the ellipsis will only be added if maxLength is greater than 3.\n+   * @return the original string if it's length is less than or equal to\n+   *     maxLength, otherwise a truncated string as mentioned above\n+   */\n+  static String truncateAtMaxLength(String source, int maxLength,\n+      boolean addEllipsis) {\n+\n+    if (source.length() <= maxLength) {\n+      return source;\n+    }\n+    if (addEllipsis && maxLength > 3) {\n+      return unicodePreservingSubstring(source, 0, maxLength - 3) + \"...\";\n+    }\n+    return unicodePreservingSubstring(source, 0, maxLength);\n+  }\n+\n+  /**\n+   * Normalizes {@code index} such that it respects Unicode character\n+   * boundaries in {@code str}.\n+   *\n+   * <p>If {@code index} is the low surrogate of a unicode character,\n+   * the method returns {@code index - 1}. Otherwise, {@code index} is\n+   * returned.\n+   *\n+   * <p>In the case in which {@code index} falls in an invalid surrogate pair\n+   * (e.g. consecutive low surrogates, consecutive high surrogates), or if\n+   * if it is not a valid index into {@code str}, the original value of\n+   * {@code index} is returned.\n+   *\n+   * @param str the String\n+   * @param index the index to be normalized\n+   * @return a normalized index that does not split a Unicode character\n+   */\n+  private static int unicodePreservingIndex(String str, int index) {\n+    if (index > 0 && index < str.length()) {\n+      if (Character.isHighSurrogate(str.charAt(index - 1)) &&\n+          Character.isLowSurrogate(str.charAt(index))) {\n+        return index - 1;\n+      }\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Returns a substring of {@code str} that respects Unicode character\n+   * boundaries.\n+   *\n+   * <p>The string will never be split between a [high, low] surrogate pair,\n+   * as defined by {@link Character#isHighSurrogate} and\n+   * {@link Character#isLowSurrogate}.\n+   *\n+   * <p>If {@code begin} or {@code end} are the low surrogate of a unicode\n+   * character, it will be offset by -1.\n+   *\n+   * <p>This behavior guarantees that\n+   * {@code str.equals(StringUtil.unicodePreservingSubstring(str, 0, n) +\n+   *     StringUtil.unicodePreservingSubstring(str, n, str.length())) } is\n+   * true for all {@code n}.\n+   * </pre>\n+   *\n+   * <p>This means that unlike {@link String#substring(int, int)}, the length of\n+   * the returned substring may not necessarily be equivalent to\n+   * {@code end - begin}.\n+   *\n+   * @param str the original String\n+   * @param begin the beginning index, inclusive\n+   * @param end the ending index, exclusive\n+   * @return the specified substring, possibly adjusted in order to not\n+   *   split unicode surrogate pairs\n+   * @throws IndexOutOfBoundsException if the {@code begin} is negative,\n+   *   or {@code end} is larger than the length of {@code str}, or\n+   *   {@code begin} is larger than {@code end}\n+   */\n+  private static String unicodePreservingSubstring(\n+      String str, int begin, int end) {\n+    return str.substring(unicodePreservingIndex(str, begin),\n+        unicodePreservingIndex(str, end));\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n \n   @Override\n   void add(Node n, Context context) {\n-    if (n.getParent().getType() == Token.BLOCK\n-        || n.getParent().getType() == Token.SCRIPT) {\n+    Node parent = n.getParent();\n+    if (parent.getType() == Token.BLOCK || parent.getType() == Token.SCRIPT) {\n       if (n.getType() == Token.FUNCTION) {\n         add(getFunctionAnnotation(n));\n       } else if (n.getType() == Token.EXPR_RESULT\n     //     NAME param1\n     //     NAME param2\n     Node fnNode = funType.getSource();\n-    Node paramNode = NodeUtil.getFnParameters(fnNode).getFirstChild();\n+    if (fnNode != null) {\n+      Node paramNode = NodeUtil.getFnParameters(fnNode).getFirstChild();\n \n-    // Param types\n-    for (Node n : funType.getParameters()) {\n-      // Skip any parameters for which we do not have a name.\n-      if (paramNode == null) {\n-        break;\n+      // Param types\n+      for (Node n : funType.getParameters()) {\n+        // Bail out if the paramNode is not there.\n+        if (paramNode == null) {\n+          break;\n+        }\n+        sb.append(\" * @param {\" + n.getJSType() + \"} \");\n+        sb.append(paramNode.getString());\n+        sb.append(\"\\n\");\n+        paramNode = paramNode.getNext();\n       }\n-      sb.append(\" * @param {\" + n.getJSType() + \"} \");\n-      sb.append(paramNode.getString());\n-      sb.append(\"\\n\");\n-      paramNode = paramNode.getNext();\n     }\n \n     // Return type\n       }\n     }\n \n-    if (fnNode.getBooleanProp(Node.IS_DISPATCHER)) {\n+    if (fnNode != null && fnNode.getBooleanProp(Node.IS_DISPATCHER)) {\n       sb.append(\" * @javadispatch\\n\");\n     }\n \n--- a/src/com/google/javascript/jscomp/VerboseMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/VerboseMessageFormatter.java\n  */\n package com.google.javascript.jscomp;\n \n-import com.google.common.base.StringUtil;\n import com.google.javascript.jscomp.CheckLevel;\n \n /**\n       lineSource = sourceRegion.getSourceExcerpt();\n     }\n     return String.format(\"%s at %s line %s %s\", description,\n-        (StringUtil.isEmpty(sourceName) ? \"(unknown source)\" : sourceName),\n+        (Strings.isEmpty(sourceName) ? \"(unknown source)\" : sourceName),\n         ((lineNumber < 0) ? String.valueOf(lineNumber) : \"(unknown line)\"),\n         ((lineSource != null) ? \":\\n\\n\" + lineSource : \".\"));\n   }\n--- a/src/com/google/javascript/jscomp/parsing/Config.java\n+++ b/src/com/google/javascript/jscomp/parsing/Config.java\n  *\n *\n  */\n-class Config {\n+public class Config {\n \n   /**\n    * Central registry for type info.\n   final boolean parseJsDocDocumentation;\n \n   /**\n+   * Whether we're in ide mode.\n+   */\n+  final boolean isIdeMode;\n+\n+  /**\n    * Recognized JSDoc annotations, mapped from their name to their internal\n    * representation.\n    */\n    */\n \n   Config(JSTypeRegistry registry, Set<String> annotationWhitelist,\n-      boolean parseJsDocDocumentation) {\n+      boolean isIdeMode) {\n     this.registry = registry;\n     this.annotationNames = buildAnnotationNames(annotationWhitelist);\n-    this.parseJsDocDocumentation = parseJsDocDocumentation;\n+    this.parseJsDocDocumentation = isIdeMode;\n+    this.isIdeMode = isIdeMode;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n+++ b/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n   // Should never need to instantiate class of static methods.\n   private ParserRunner() {}\n \n+  public static Config createConfig(\n+      JSTypeRegistry typeRegistry, boolean isIdeMode) {\n+    return new Config(\n+        typeRegistry, getAnnotationNames(), isIdeMode);\n+  }\n+\n   /**\n    * Gets a list of extra annotations that are OK, even if the parser\n    * doesn't have handlers for them built-in.\n    */\n   public static Node parse(String sourceName,\n                            String sourceString,\n-                           boolean isIdeMode,\n-                           JSTypeRegistry typeRegistry,\n+                           Config config,\n                            ErrorReporter errorReporter,\n                            Logger logger) throws IOException {\n-    initAnnotationNames();\n-\n     Context cx = Context.enter();\n     cx.setErrorReporter(errorReporter);\n     cx.setLanguageVersion(Context.VERSION_1_5);\n     compilerEnv.setRecordingComments(true);\n     compilerEnv.setRecordingLocalJsDocComments(true);\n     compilerEnv.setWarnTrailingComma(true);\n-    if (isIdeMode) {\n+    if (config.isIdeMode) {\n       compilerEnv.setReservedKeywordAsIdentifier(true);\n       compilerEnv.setAllowMemberExprAsFunctionName(true);\n     }\n     }\n     Node root = null;\n     if (astRoot != null) {\n-      Config config = new Config(\n-          typeRegistry, annotationNames, isIdeMode);\n       root = IRFactory.transformTree(\n           astRoot, sourceString, config, errorReporter);\n       root.setIsSyntheticBlock(true);\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   }\n \n   /**\n-   * Gets the source node.\n+   * Gets the source node or null if this is an unknown function.\n    */\n   public Node getSource() {\n     return source;\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n         \" */\\n\" +\n         \"a.Foo.prototype.foo = function() {\\n\" +\n         \"}\");\n+  }\n+  \n+  public void testU2UFunctionTypeAnnotation() {\n+    assertTypeAnnotations(\n+        \"/** @type {!Function} */ var x = function() {}\",\n+        \"/**\\n * @constructor\\n */\\nvar x = function() {\\n}\");\n   }\n \n   private void assertPrettyPrint(String js, String expected) {\n--- a/test/com/google/javascript/jscomp/GenerateExportsTest.java\n+++ b/test/com/google/javascript/jscomp/GenerateExportsTest.java\n     test(\"(function() { /** @export */var FOO = 5 })()\",\n          null, FindExportableNodes.NON_GLOBAL_ERROR);\n   }\n+\n+  public void testExportSubclass() {\n+    test(\"var goog = {}; function F() {}\" +\n+         \"/** @export */ function G() {} goog.inherits(G, F);\",\n+         \"var goog = {}; function F() {}\" +\n+         \"function G() {} goog.inherits(G, F); google_exportSymbol('G', G);\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n     Node script = null;\n     try {\n       script = ParserRunner.parse(\n-          \"input\", string, true, registry,\n+          \"input\", string, ParserRunner.createConfig(registry, true),\n           testErrorReporter, Logger.getAnonymousLogger());\n     } catch (IOException e) {\n       throw new RuntimeException(e);\n     Node script = null;\n     try {\n       script = ParserRunner.parse(\n-          \"input\", string,  true, registry,\n+          \"input\", string, ParserRunner.createConfig(registry, true),\n           testErrorReporter, Logger.getAnonymousLogger());\n     } catch (IOException e) {\n       throw new RuntimeException(e);", "timestamp": 1266003624, "metainfo": ""}