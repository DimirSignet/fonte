{"sha": "4ff5d0b989360d785c63978faf8eed6284e030e1", "log": "Make Peephole and UnreachableCodeElimination only work on functions that have changed since the last run. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44109570", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n \n   private LifeCycleStage stage = LifeCycleStage.RAW;\n \n+  // For passes that traverse a list of functions rather than the AST.\n+  // If false, the pass will analyze all functions, even those that didn't\n+  // change since the last time it ran.\n+  // Intended for use by the compiler only; not accessed by compiler users.\n+  protected boolean analyzeChangedFunsOnly = true;\n+\n   // TODO(nicksantos): Decide if all of these are really necessary.\n   // Many of them are just accessors that should be passed to the\n   // CompilerPass's constructor.\n    */\n   abstract void removeChangeHandler(CodeChangeHandler handler);\n \n+  /** Let the PhaseOptimizer know which scope a pass is currently analyzing */\n+  abstract void setScope(Node n);\n+\n+  /** Returns the root of the source tree, ignoring externs */\n+  abstract Node getJsRoot();\n+\n+  /** True iff a function changed since the last time a pass was run */\n+  abstract boolean hasScopeChanged(Node n);\n+\n+  /** Passes that do cross-scope modifications use this (eg, InlineVariables) */\n+  abstract void reportChangeToScope(Node n);\n+\n+  /** Returns the containing function (or the top level node) for n */\n+  abstract Node getEnclosingScope(Node n);\n+\n   /**\n    * Returns true if compiling in IDE mode.\n    */\n   /**\n    * Gets the error manager.\n    */\n-  abstract public ErrorManager getErrorManager();\n+  public abstract ErrorManager getErrorManager();\n \n   /**\n    * Set the current life-cycle state.\n--- a/src/com/google/javascript/jscomp/CodeChangeHandler.java\n+++ b/src/com/google/javascript/jscomp/CodeChangeHandler.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.rhino.Node;\n-\n /**\n  * A simple listener for code change events.\n- * Records whether the code has changed since the last reset.\n  * @author nicksantos@google.com (Nick Santos)\n  * @author dimvar@google.com (Dimitris Vardoulakis)\n  */\n-class CodeChangeHandler {\n-  private boolean hasChanged = false;\n-\n+interface CodeChangeHandler {\n   /** Report a change to some unspecified node of the AST. */\n-  public void reportChange() {\n-    hasChanged = true;\n-  }\n-\n-  /** Report a change to a specific function in the AST. */\n-  public void reportChangedFun(Node n) {\n-    hasChanged = true;\n-  }\n-\n-  /** Report that a function node has been removed from the AST */\n-  public void reportDeletedFun(Node n) {\n-    hasChanged = true;\n-  }\n-\n-  void reset() {\n-    hasChanged = false;\n-  }\n-\n-  boolean hasCodeChanged() {\n-    return hasChanged;\n-  }\n+  public void reportChange();\n }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n \n   private ReverseAbstractInterpreter abstractInterpreter;\n   private TypeValidator typeValidator;\n+  // The compiler can ask phaseOptimizer for things like which pass is currently\n+  // running, or which functions have been changed by optimizations\n+  private PhaseOptimizer phaseOptimizer = null;\n \n   public PerformanceTracker tracker;\n \n \n     // We are currently only interested in check-passes for progress reporting\n     // as it is used for IDEs, that's why the maximum progress is set to 1.0.\n-    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,\n+    phaseOptimizer = new PhaseOptimizer(this, tracker,\n         new PhaseOptimizer.ProgressRange(getProgress(), 1.0));\n     if (options.devMode == DevMode.EVERY_PASS) {\n       phaseOptimizer.setSanityCheck(sanityCheck);\n     }\n \n     runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n+    phaseOptimizer = null;\n   }\n \n   private void externExports() {\n     // unmodified local names.\n     normalize();\n \n-    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n+    phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n     if (options.devMode == DevMode.EVERY_PASS) {\n       phaseOptimizer.setSanityCheck(sanityCheck);\n     }\n     }\n     phaseOptimizer.consume(getPassConfig().getOptimizations());\n     phaseOptimizer.process(externsRoot, jsRoot);\n+    phaseOptimizer = null;\n   }\n \n   @Override\n     endPass();\n   }\n \n-  protected final CodeChangeHandler recentChange = new CodeChangeHandler();\n+  protected final RecentChange recentChange = new RecentChange();\n   private final List<CodeChangeHandler> codeChangeHandlers =\n       Lists.<CodeChangeHandler>newArrayList();\n \n   @Override\n   void removeChangeHandler(CodeChangeHandler handler) {\n     codeChangeHandlers.remove(handler);\n+  }\n+\n+  @Override\n+  void setScope(Node n) {\n+    if (phaseOptimizer != null) {\n+      phaseOptimizer.setScope(n);\n+    }\n+  }\n+\n+  @Override\n+  Node getJsRoot() {\n+    return jsRoot;\n+  }\n+\n+  @Override\n+  boolean hasScopeChanged(Node n) {\n+    if (phaseOptimizer != null) {\n+      return phaseOptimizer.hasScopeChanged(n);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  void reportChangeToScope(Node n) {\n+    if (phaseOptimizer != null) {\n+      phaseOptimizer.reportChangeToScope(n);\n+      phaseOptimizer.startCrossScopeReporting();\n+      reportCodeChange();\n+      phaseOptimizer.endCrossScopeReporting();\n+    } else {\n+      reportCodeChange();\n+    }\n+  }\n+\n+  /**\n+   * Some tests don't want to call the compiler \"wholesale,\" they may not want\n+   * to call check and/or optimize. With this method, tests can execute custom\n+   * optimization loops.\n+   */\n+  @VisibleForTesting\n+  void setPhaseOptimizer(PhaseOptimizer po) {\n+    this.phaseOptimizer = po;\n+  }\n+\n+  @Override\n+  Node getEnclosingScope(Node n) {\n+    while (n != jsRoot) {\n+      n = n.getParent();\n+      if (n.isFunction()) { return n; }\n+    }\n+    return n;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/ForbiddenChange.java\n+++ b/src/com/google/javascript/jscomp/ForbiddenChange.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.rhino.Node;\n-\n /**\n  * A change handler that throws an exception if any changes are made.\n  * @author nicksantos@google.com (Nick Santos)\n  * @author dimvar@google.com (Dimitris Vardoulakis)\n  */\n-final class ForbiddenChange extends CodeChangeHandler {\n-\n+final class ForbiddenChange implements CodeChangeHandler {\n   @Override\n   public void reportChange() {\n     throw new IllegalStateException(\"Code changes forbidden\");\n   }\n-\n-  @Override\n-  public void reportChangedFun(Node n) {\n-    throw new IllegalStateException(\"Code changes forbidden\");\n-  }\n-\n-  @Override\n-  public void reportDeletedFun(Node n) {\n-    throw new IllegalStateException(\"Code changes forbidden\");\n-  }\n }\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n         }\n \n         fn.remove();\n-        compiler.reportCodeChange();\n       }\n     }\n   }\n   }\n \n   /** NamedFunction implementation of the Function interface */\n-  private static class NamedFunction implements Function {\n+  private class NamedFunction implements Function {\n     private final Node fn;\n \n     public NamedFunction(Node fn) {\n \n     @Override\n     public void remove() {\n+      compiler.reportChangeToScope(fn);\n       NodeUtil.removeChild(fn.getParent(), fn);\n     }\n \n   }\n \n   /** FunctionVar implementation of the Function interface */\n-  private static class FunctionVar implements Function {\n+  private class FunctionVar implements Function {\n     private final Node var;\n \n     public FunctionVar(Node var) {\n \n     @Override\n     public void remove() {\n+      compiler.reportChangeToScope(var);\n       NodeUtil.removeChild(var.getParent(), var);\n     }\n \n   }\n \n   /** FunctionExpression implementation of the Function interface */\n-  private static class FunctionExpression implements Function {\n+  private class FunctionExpression implements Function {\n     private final Node fn;\n     private final String fakeName;\n \n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n      * Do the actual work of inlining a single declaration into a single\n      * reference.\n      */\n-    private void inline(Var v, Reference declaration,\n-                        Reference init, Reference reference) {\n+    private void inline(Var v, Reference decl, Reference init, Reference ref) {\n       Node value = init.getAssignedValue();\n       Preconditions.checkState(value != null);\n       // Check for function declarations before the value is moved in the AST.\n       boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value);\n \n-      inlineValue(v, reference, value.detachFromParent());\n-      if (declaration != init) {\n+      // decl and ref may be in different scopes, report change for both\n+      compiler.reportChangeToScope(compiler.getEnclosingScope(decl.getNode()));\n+      compiler.reportChangeToScope(compiler.getEnclosingScope(ref.getNode()));\n+\n+      inlineValue(v, ref, value.detachFromParent());\n+      if (decl != init) {\n         Node expressRoot = init.getGrandparent();\n         Preconditions.checkState(expressRoot.isExprResult());\n         NodeUtil.removeChild(expressRoot.getParent(), expressRoot);\n       }\n-\n       // Function declarations have already been removed.\n       if (!isFunctionDeclaration) {\n-        removeDeclaration(declaration);\n-      } else {\n-        compiler.reportCodeChange();\n+        removeDeclaration(decl);\n       }\n     }\n \n     /**\n      * Remove the given VAR declaration.\n      */\n-    private void removeDeclaration(Reference declaration) {\n-      Node varNode = declaration.getParent();\n-      Node grandparent = declaration.getGrandparent();\n-\n-      varNode.removeChild(declaration.getNode());\n-\n+    private void removeDeclaration(Reference decl) {\n+      Node varNode = decl.getParent();\n+      Node grandparent = decl.getGrandparent();\n+\n+      compiler.reportChangeToScope(compiler.getEnclosingScope(decl.getNode()));\n+      varNode.removeChild(decl.getNode());\n       // Remove var node if empty\n       if (!varNode.hasChildren()) {\n         Preconditions.checkState(varNode.isVar());\n         NodeUtil.removeChild(grandparent, varNode);\n       }\n-\n-      compiler.reportCodeChange();\n     }\n \n     /**\n      *     to re-parent.\n      */\n     private void inlineValue(Var v, Reference ref, Node value) {\n+      compiler.reportChangeToScope(compiler.getEnclosingScope(ref.getNode()));\n       if (ref.isSimpleAssignmentToName()) {\n         // This is the initial assignment.\n         ref.getGrandparent().replaceChild(ref.getParent(), value);\n       } else {\n         ref.getParent().replaceChild(ref.getNode(), value);\n       }\n-\n       blacklistVarReferencesInTree(value, v.scope);\n-      compiler.reportCodeChange();\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n   /** Possible callback for scope entry and exist **/\n   private ScopedCallback scopeCallback;\n \n-  /**\n-   * Callback\n+  /** Callback for passes that iterate over a list of functions */\n+  public interface FunctionCallback {\n+    void visit(AbstractCompiler compiler, Node fnRoot);\n+  }\n+\n+  /**\n+   * Callback for tree-based traversals\n    */\n   public interface Callback {\n     /**\n      * <p>Visits a node in pre order (before visiting its children) and decides\n      * whether this node's children should be traversed. If children are\n      * traversed, they will be visited by\n-     * {@link #visit(NodeTraversal, Node, Node)} in post order.</p>\n+     * {@link #visit(NodeTraversal, Node, Node)} in postorder.</p>\n      * <p>Implementations can have side effects (e.g. modifying the parse\n      * tree).</p>\n      * @return whether the children of this node should be visited\n     boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent);\n \n     /**\n-     * <p>Visits a node in post order (after its children have been visited).\n+     * <p>Visits a node in postorder (after its children have been visited).\n      * A node is visited only if all its parents should be traversed\n      * ({@link #shouldTraverse(NodeTraversal, Node, Node)}).</p>\n      * <p>Implementations can have side effects (e.g. modifying the parse\n   }\n \n   /**\n-   * Abstract callback to visit all nodes in post order.\n+   * Abstract callback to visit all nodes in postorder.\n    */\n   public abstract static class AbstractPostOrderCallback implements Callback {\n     @Override\n     }\n   }\n \n-  /**\n-   * Abstract scoped callback to visit all nodes in post order.\n+  /** Abstract callback to visit all nodes in preorder. */\n+  public abstract static class AbstractPreOrderCallback implements Callback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {}\n+  }\n+\n+  /**\n+   * Abstract scoped callback to visit all nodes in postorder.\n    */\n   public abstract static class AbstractScopedCallback\n       implements ScopedCallback {\n       sourceName = \"\";\n       curNode = root;\n       pushScope(root);\n+      // null parent ensures that the shallow callbacks will traverse root\n       traverseBranch(root, null);\n       popScope();\n     } catch (Exception unexpectedException) {\n     }\n   }\n \n-  /**\n-   * Gets the compiler.\n-   */\n-  public Compiler getCompiler() {\n-    // TODO(nicksantos): Remove this type cast. This is just temporary\n-    // while refactoring.\n-    return (Compiler) compiler;\n+  public AbstractCompiler getCompiler() {\n+    return compiler;\n   }\n \n   /**\n     Node cur = curNode;\n     while (cur != null) {\n       int line = cur.getLineno();\n-      if (line >=0) {\n+      if (line >= 0) {\n         return line;\n       }\n       cur = cur.getParent();\n   /** Returns the node currently being traversed. */\n   public Node getCurrentNode() {\n     return curNode;\n+  }\n+\n+  /**\n+   * Traversal for passes that work only on changed functions.\n+   * Suppose a loopable pass P1 uses this traversal.\n+   * Then, if a function doesn't change between two runs of P1, it won't look at\n+   * the function the second time.\n+   * (We're assuming that P1 runs to a fixpoint, o/w we may miss optimizations.)\n+   */\n+  public static void traverseChangedFunctions(\n+      AbstractCompiler compiler, FunctionCallback callback) {\n+    final AbstractCompiler comp = compiler;\n+    final FunctionCallback cb = callback;\n+    final Node jsRoot = comp.getJsRoot();\n+    if (comp.hasScopeChanged(jsRoot)) {\n+      cb.visit(comp, jsRoot);\n+    }\n+    traverse(comp, jsRoot,\n+        new AbstractPreOrderCallback() {\n+          @Override\n+          public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {\n+            if (n.isFunction() && comp.hasScopeChanged(n)) {\n+              cb.visit(comp, n);\n+            }\n+            return true;\n+          }\n+        });\n   }\n \n   /**\n   /**\n    * Traverses a branch.\n    */\n-  @SuppressWarnings(\"fallthrough\")\n   private void traverseBranch(Node n, Node parent) {\n     int type = n.getType();\n     if (type == Token.SCRIPT) {\n     }\n \n     curNode = n;\n-    if (!callback.shouldTraverse(this, n, parent)) return;\n-\n-    switch (type) {\n-      case Token.FUNCTION:\n-        traverseFunction(n, parent);\n-        break;\n-\n-      default:\n-        for (Node child = n.getFirstChild(); child != null; ) {\n-          // child could be replaced, in which case our child node\n-          // would no longer point to the true next\n-          Node next = child.getNext();\n-          traverseBranch(child, n);\n-          child = next;\n-        }\n-        break;\n+    if (!callback.shouldTraverse(this, n, parent)) {\n+      return;\n+    }\n+\n+    if (type == Token.FUNCTION) {\n+      traverseFunction(n, parent);\n+    } else {\n+      for (Node child = n.getFirstChild(); child != null; ) {\n+        // child could be replaced, in which case our child node\n+        // would no longer point to the true next\n+        Node next = child.getNext();\n+        traverseBranch(child, n);\n+        child = next;\n+      }\n     }\n \n     curNode = n;\n     callback.visit(this, n, parent);\n   }\n \n-  /**\n-   * Traverses a function.\n-   */\n+  /** Traverses a function. */\n   private void traverseFunction(Node n, Node parent) {\n     Preconditions.checkState(n.getChildCount() == 3);\n     Preconditions.checkState(n.isFunction());\n     traverseBranch(args, n);\n \n     // Body\n-    Preconditions.checkState(body.getNext() == null &&\n-            body.isBlock(), body);\n+    Preconditions.checkState(body.getNext() == null && body.isBlock(), body);\n     traverseBranch(body, n);\n \n     popScope();\n   /** Creates a new scope (e.g. when entering a function). */\n   private void pushScope(Node node) {\n     Preconditions.checkState(curNode != null);\n+    compiler.setScope(node);\n     scopeRoots.push(node);\n     cfgs.push(null);\n     if (scopeCallback != null) {\n   /** Creates a new scope (e.g. when entering a function). */\n   private void pushScope(Scope s) {\n     Preconditions.checkState(curNode != null);\n+    compiler.setScope(s.getRootNode());\n     scopes.push(s);\n     cfgs.push(null);\n     if (scopeCallback != null) {\n       scopeRoots.pop();\n     }\n     cfgs.pop();\n+    if (!scopes.isEmpty()) {\n+      compiler.setScope(scopes.peek().getRootNode());\n+    }\n   }\n \n   /** Gets the current scope. */\n   /** Reports a diagnostic (error or warning) */\n   public void report(Node n, DiagnosticType diagnosticType,\n       String... arguments) {\n-    JSError error = JSError.make(getBestSourceFileName(n),\n-        n, diagnosticType, arguments);\n+    JSError error = JSError.make(\n+        getBestSourceFileName(n), n, diagnosticType, arguments);\n     compiler.report(error);\n   }\n \n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n+import com.google.javascript.jscomp.NodeTraversal.FunctionCallback;\n import com.google.javascript.rhino.Node;\n-\n-import java.util.ArrayList;\n \n /**\n  * A compiler pass to run various peephole optimizations (e.g. constant folding,\n  * @author dcc@google.com (Devin Coughlin)\n  * @author acleung@google.com (Alan Leung)(\n  */\n-class PeepholeOptimizationsPass\n-    implements CompilerPass {\n+class PeepholeOptimizationsPass implements CompilerPass {\n   private AbstractCompiler compiler;\n \n   // Use an array here for faster iteration compared to ImmutableSet\n   private final AbstractPeepholeOptimization[] peepholeOptimizations;\n \n-  // Track whether the a scope has been modified so that it can be revisited\n-  // immediately.\n-  private StateStack traversalState = new StateStack();\n-\n-  private boolean retraverseOnChange = true;\n-\n-  private static class ScopeState {\n-    boolean changed;\n-    boolean traverseChildScopes;\n-    ScopeState() {\n-      reset();\n-    }\n-\n-    void reset() {\n-      changed = false;\n-      traverseChildScopes = true;\n-    }\n-  }\n-\n-  private static class StateStack {\n-    private ArrayList<ScopeState> states = Lists.newArrayList();\n-    private int currentDepth = 0;\n-\n-    StateStack() {\n-      states.add(new ScopeState());\n-    }\n-\n-    ScopeState peek() {\n-      return states.get(currentDepth);\n-    }\n-\n-    void push() {\n-      currentDepth++;\n-      if (states.size() <= currentDepth) {\n-        states.add(new ScopeState());\n-      } else {\n-        states.get(currentDepth).reset();\n-      }\n-    }\n-\n-    void pop() {\n-      currentDepth--;\n-    }\n-  }\n-\n-  private class PeepholeChangeHandler extends CodeChangeHandler {\n-    @Override\n-    public void reportChange() {\n-      traversalState.peek().changed = true;\n-    }\n-  }\n+  private boolean retraverseOnChange;\n+  private RecentChange handler;\n \n   /**\n    * Creates a peephole optimization pass that runs the given\n       AbstractPeepholeOptimization... optimizations) {\n     this.compiler = compiler;\n     this.peepholeOptimizations = optimizations;\n+    this.retraverseOnChange = true;\n+    this.handler = new RecentChange();\n   }\n \n-  PeepholeOptimizationsPass setRetraverseOnChange(boolean retraverse) {\n+  void setRetraverseOnChange(boolean retraverse) {\n     this.retraverseOnChange = retraverse;\n-    return this;\n   }\n \n   public AbstractCompiler getCompiler() {\n \n   @Override\n   public void process(Node externs, Node root) {\n-    PeepholeChangeHandler handler = new PeepholeChangeHandler();\n     compiler.addChangeHandler(handler);\n     beginTraversal();\n-    traverse(root);\n+    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {\n+        @Override\n+        public void visit(AbstractCompiler compiler, Node root) {\n+          if (root.isFunction()) {\n+            root = root.getLastChild();\n+          }\n+          do {\n+            handler.reset();\n+            NodeTraversal.traverse(compiler, root, new PeepCallback());\n+          } while (retraverseOnChange && handler.hasCodeChanged());\n+        }\n+      });\n     endTraversal();\n     compiler.removeChangeHandler(handler);\n   }\n \n-  private void traverse(Node node) {\n-    // The goal here is to avoid retraversing\n-    // the entire AST to catch newly created opportunities.\n-    // So we track whether a \"unit of code\" has changed,\n-    // and revisit immediately.\n-    if (!shouldVisit(node)) {\n-      return;\n+  private class PeepCallback extends AbstractShallowCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      Node currentNode = n, newNode;\n+      boolean codeChanged = false;\n+      do {\n+        codeChanged = false;\n+        for (AbstractPeepholeOptimization optim : peepholeOptimizations) {\n+          newNode = optim.optimizeSubtree(currentNode);\n+          if (newNode != currentNode) {\n+            codeChanged = true;\n+            currentNode = newNode;\n+          }\n+          if (currentNode == null) {\n+            return;\n+          }\n+        }\n+      } while(codeChanged);\n     }\n-\n-    int visits = 0;\n-    do {\n-      Node c = node.getFirstChild();\n-      while (c != null) {\n-        Node next = c.getNext();\n-        traverse(c);\n-        c = next;\n-      }\n-\n-      visit(node);\n-      visits++;\n-\n-      Preconditions.checkState(visits < 10000, \"too many interations\");\n-    } while (shouldRetraverse(node));\n-\n-    exitNode(node);\n-  }\n-\n-  private boolean shouldRetraverse(Node node) {\n-    if (retraverseOnChange\n-        && node.getParent() != null\n-        && (node.isFunction() || node.isScript())) {\n-      ScopeState state = traversalState.peek();\n-      if (state.changed) {\n-        // prepare to re-visit the scope:\n-        // when revisiting, only visit the immediate scope\n-        // this reduces the cost of getting to a fixed\n-        // point in global scope.\n-        state.changed = false;\n-        state.traverseChildScopes = false;\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  private boolean shouldVisit(Node node) {\n-    if (node.isFunction() || node.isScript()) {\n-      ScopeState previous = traversalState.peek();\n-      if (!previous.traverseChildScopes) {\n-        return false;\n-      }\n-      traversalState.push();\n-    }\n-    return true;\n-  }\n-\n-  private void exitNode(Node node) {\n-    if (node.isFunction() || node.isScript()) {\n-      traversalState.pop();\n-    }\n-  }\n-\n-  public void visit(Node n) {\n-    Node currentVersionOfNode = n;\n-    boolean somethingChanged = false;\n-\n-    do {\n-      somethingChanged = false;\n-      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n-        Node newVersionOfNode =\n-            optimization.optimizeSubtree(currentVersionOfNode);\n-\n-        if (newVersionOfNode != currentVersionOfNode) {\n-          somethingChanged = true;\n-\n-          currentVersionOfNode = newVersionOfNode;\n-        }\n-\n-        if (currentVersionOfNode == null) {\n-          return;\n-        }\n-      }\n-    } while(somethingChanged);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/PerformanceTracker.java\n+++ b/src/com/google/javascript/jscomp/PerformanceTracker.java\n \n   // Keeps track of AST changes and computes code size estimation\n   // if there is any.\n-  private final CodeChangeHandler codeChange = new CodeChangeHandler();\n+  private final RecentChange codeChange = new RecentChange();\n \n   private int initCodeSize = 0;\n   private int initGzCodeSize = 0;\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n import com.google.javascript.rhino.Node;\n \n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n import java.util.logging.Logger;\n \n /**\n  * Optimizes the order of compiler passes.\n  * @author nicksantos@google.com (Nick Santos)\n+ * @author dimvar@google.com (Dimitris Vardoulakis)\n  */\n class PhaseOptimizer implements CompilerPass {\n \n \n   private final AbstractCompiler compiler;\n   private final PerformanceTracker tracker;\n-  private boolean loopMutex = false;\n+  private boolean inLoop;\n   private PassFactory sanityCheck = null;\n   private boolean printAstHashcodes = false;\n \n   private static List<List<String>> loopsRun = Lists.newArrayList();\n \n   private final ProgressRange progressRange;\n+\n+  // These fields are used during optimization loops.\n+  // They are declared here for two reasons:\n+  // 1) Loop and ScopedChangeHandler can communicate via shared state\n+  // 2) Compiler talks to PhaseOptimizer, not Loop or ScopedChangeHandler\n+  private NamedPass currentPass;\n+  // For each pass, remember the time at the end of the pass's last run.\n+  private Map<NamedPass, Integer> lastRuns;\n+  private Node currentScope;\n+  // Starts at 0, increases as \"interesting\" things happen.\n+  // Nothing happens at time START_TIME, the first pass starts at time 1.\n+  // The correctness of scope-change tracking relies on Node/getIntProp\n+  // returning 0 if the custom attribute on a node hasn't been set.\n+  private int timestamp;\n+  // The time of the last change made to the program by any pass.\n+  private int lastChange;\n+  private static final int START_TIME = 0;\n+  private Node jsRoot;\n+  // Compiler/reportChangeToScope must call reportCodeChange to update all\n+  // change handlers. This flag prevents double update in ScopedChangeHandler.\n+  private boolean crossScopeReporting;\n \n   /**\n    * @param compiler the compiler that owns/creates this.\n     this.compiler = compiler;\n     this.tracker = tracker;\n     this.progressRange = progressRange;\n+    this.inLoop = false;\n+    this.crossScopeReporting = false;\n+    this.timestamp = this.lastChange = START_TIME;\n   }\n \n   /**\n   }\n \n   /**\n-   * Sets the hashcode of the AST to be logged every pass. Intended for development.\n+   * Sets the hashcode of the AST to be logged every pass.\n+   * Intended for development.\n    */\n   void setPrintAstHashcodes(boolean printAstHashcodes) {\n     this.printAstHashcodes = printAstHashcodes;\n       progress = progressRange.initialValue;\n     }\n \n+    jsRoot = root;\n     for (CompilerPass pass : passes) {\n       pass.process(externs, root);\n       if (hasHaltingErrors()) {\n     }\n   }\n \n+  /** {@code n} is either a function or the top-level node of the AST */\n+  void setScope(Node n) {\n+    currentScope = n;\n+  }\n+\n+  boolean hasScopeChanged(Node n) {\n+    // Outside loops we don't track changed scopes, so we visit them all.\n+    if (!inLoop) {\n+      return true;\n+    }\n+    int timeOfLastRun = lastRuns.get(currentPass);\n+    // A pass looks at all functions when it first runs\n+    return timeOfLastRun == START_TIME\n+        || n.getChangeTime() > timeOfLastRun;\n+  }\n+\n+  void reportChangeToScope(Node n) {\n+    lastChange = timestamp;\n+    n.setChangeTime(timestamp);\n+    // Every code change happens at a different time\n+    timestamp++;\n+  }\n+\n+  // This method and the next one are used so that we don't falsely report the\n+  // current scope as changed when reportChangeToScope is called from Compiler.\n+  void startCrossScopeReporting() {\n+    crossScopeReporting = true;\n+  }\n+\n+  void endCrossScopeReporting() {\n+    crossScopeReporting = false;\n+  }\n+\n+  private class ScopedChangeHandler implements CodeChangeHandler {\n+    private int lastCodeChangeQuery;\n+\n+    ScopedChangeHandler() {\n+      this.lastCodeChangeQuery = timestamp;\n+    }\n+\n+    @Override\n+    public void reportChange() {\n+      if (crossScopeReporting) {\n+        // This call was caused by Compiler/reportChangeToScope, do nothing\n+        return;\n+      }\n+      lastChange = timestamp;\n+      currentScope.setChangeTime(timestamp);\n+      // Every code change happens at a different time\n+      timestamp++;\n+    }\n+\n+    private boolean hasCodeChangedSinceLastCall() {\n+      boolean result = lastChange > lastCodeChangeQuery;\n+      lastCodeChangeQuery = timestamp;\n+      // The next call to the method will happen at a different time\n+      timestamp++;\n+      return result;\n+    }\n+  }\n+\n   /**\n    * Runs a set of compiler passes until they reach a fixed point.\n    *\n   class Loop implements CompilerPass {\n     private final List<NamedPass> myPasses = Lists.newArrayList();\n     private final Set<String> myNames = Sets.newHashSet();\n-    private CodeChangeHandler recentChange = new CodeChangeHandler();\n+    private ScopedChangeHandler scopeHandler;\n \n     void addLoopedPass(PassFactory factory) {\n       String name = factory.getName();\n \n     @Override\n     public void process(Node externs, Node root) {\n-      Preconditions.checkState(!loopMutex, \"Nested loops are forbidden\");\n-      loopMutex = true;\n+      Preconditions.checkState(!inLoop, \"Nested loops are forbidden\");\n+      inLoop = true;\n       if (randomizeLoops) {\n         randomizePasses();\n       } else {\n         optimizePasses();\n       }\n \n-      compiler.addChangeHandler(recentChange);\n+      // Set up function-change tracking\n+      scopeHandler = new ScopedChangeHandler();\n+      compiler.addChangeHandler(scopeHandler);\n+      currentScope = root;\n+      // lastRuns is initialized before each loop. This way, when a pass is run\n+      // in the 2nd loop for the 1st time, it looks at all scopes.\n+      lastRuns = new HashMap<NamedPass, Integer>();\n+      for (NamedPass pass : myPasses) {\n+        lastRuns.put(pass, START_TIME);\n+      }\n       // Contains a pass iff it made changes the last time it was run.\n       Set<NamedPass> madeChanges = new HashSet<NamedPass>();\n       // Contains a pass iff it was run during the last inner loop.\n           }\n           lastIterMadeChanges = false;\n           for (NamedPass pass : myPasses) {\n-            recentChange.reset();\n             if ((s == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER &&\n                 !runInPrevIter.contains(pass)) ||\n                 (s == State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER &&\n                     madeChanges.contains(pass))) {\n+              timestamp++;\n+              currentPass = pass;\n               pass.process(externs, root);\n               runInPrevIter.add(pass);\n+              lastRuns.put(pass, timestamp);\n               if (hasHaltingErrors()) {\n                 return;\n-              } else if (recentChange.hasCodeChanged()) {\n+              } else if (scopeHandler.hasCodeChangedSinceLastCall()) {\n                 madeChanges.add(pass);\n                 lastIterMadeChanges = true;\n               } else {\n           }\n         }\n       } finally {\n-        loopMutex = false;\n-        compiler.removeChangeHandler(recentChange);\n+        inLoop = false;\n+        compiler.removeChangeHandler(scopeHandler);\n       }\n     }\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/RecentChange.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Records whether the code has changed since the last reset.\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+final class RecentChange implements CodeChangeHandler {\n+  private boolean hasChanged = false;\n+\n+  @Override\n+  public void reportChange() {\n+    hasChanged = true;\n+  }\n+\n+  public boolean hasCodeChanged() {\n+    return hasChanged;\n+  }\n+\n+  public void reset() {\n+    hasChanged = false;\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n     }\n \n     public String getInputName() {\n-      if (input == null)\n+      if (input == null) {\n         return \"<non-file>\";\n-      else\n-        return input.getName();\n+      }\n+      return input.getName();\n     }\n \n     public boolean isNoShadow() {\n    */\n   public boolean isDeclared(String name, boolean recurse) {\n     Scope scope = this;\n-    if (scope.vars.containsKey(name))\n+    if (scope.vars.containsKey(name)) {\n       return true;\n-\n+    }\n     if (scope.parent != null && recurse) {\n       return scope.parent.isDeclared(name, recurse);\n     }\n    * Returns whether this is a local scope (i.e. not the global scope).\n    */\n   public boolean isLocal() {\n-    return !isGlobal();\n+    return parent != null;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n \n import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n-import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n-import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.NodeTraversal.FunctionCallback;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.jscomp.graph.GraphReachability;\n // These things don't require reachability info, consider making them their own\n // pass or putting them in some other, more related pass.\n \n-class UnreachableCodeElimination extends AbstractPostOrderCallback\n-    implements CompilerPass, ScopedCallback  {\n+class UnreachableCodeElimination implements CompilerPass {\n   private static final Logger logger =\n     Logger.getLogger(UnreachableCodeElimination.class.getName());\n-\n   private final AbstractCompiler compiler;\n   private final boolean removeNoOpStatements;\n   private boolean codeChanged;\n   }\n \n   @Override\n-  public void exitScope(NodeTraversal t) {\n-    Scope scope = t.getScope();\n-    Node root = scope.getRootNode();\n-\n-    // Computes the control flow graph.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n-    cfa.process(null, root);\n-    ControlFlowGraph<Node> cfg = cfa.getCfg();\n-\n-    new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n-        .compute(cfg.getEntry().getValue());\n-\n-    if (scope.isLocal()) {\n-      root = root.getLastChild();\n-    }\n-\n-    do {\n-      codeChanged = false;\n-      NodeTraversal.traverse(compiler, root, new EliminationPass(cfg));\n-    } while (codeChanged);\n-  }\n-\n-  @Override\n-  public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, this);\n+  public void process(Node externs, Node toplevel) {\n+    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {\n+        @Override\n+        public void visit(AbstractCompiler compiler, Node root) {\n+          // Computes the control flow graph.\n+          ControlFlowAnalysis cfa =\n+              new ControlFlowAnalysis(compiler, false, false);\n+          cfa.process(null, root);\n+          ControlFlowGraph<Node> cfg = cfa.getCfg();\n+          new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n+              .compute(cfg.getEntry().getValue());\n+          if (root.isFunction()) {\n+            root = root.getLastChild();\n+          }\n+          do {\n+            codeChanged = false;\n+            NodeTraversal.traverse(compiler, root, new EliminationPass(cfg));\n+          } while (codeChanged);\n+        }\n+      });\n   }\n \n   private class EliminationPass extends AbstractShallowCallback {\n       NodeUtil.removeChild(n.getParent(), n);\n     }\n   }\n-\n-  @Override\n-  public void visit(NodeTraversal t, Node n, Node parent) {}\n-\n-  @Override\n-  public void enterScope(NodeTraversal t) {}\n }\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n                                   // See comments in IRFactory about this.\n       INFERRED_FUNCTION  = 55,    // Marks a function whose parameter types\n                                   // have been inferred.\n-      LAST_PROP          = 55;\n+      CHANGE_TIME        = 56,    // For passes that work only on changed funs.\n+      LAST_PROP          = 56;    // Unused in the compiler, but keep for Rhino.\n \n   public static final int   // flags for INCRDECR_PROP\n       DECR_FLAG = 0x1,\n         case LENGTH:    return \"length\";\n         case SLASH_V:   return \"slash_v\";\n         case INFERRED_FUNCTION:   return \"inferred\";\n+        case CHANGE_TIME: return \"change_time\";\n         default:\n-          throw new IllegalStateException(\"unexpect prop id \" + propType);\n+          throw new IllegalStateException(\"unexpected prop id \" + propType);\n       }\n   }\n \n     }\n \n     @Override\n-    boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n-      boolean equivalent = super.isEquivalentTo(node, compareJsType, recurse);\n-      if (equivalent) {\n+    boolean isEquivalentTo(\n+        Node node, boolean compareJsType, boolean recur, boolean shallow) {\n+      boolean equiv = super.isEquivalentTo(node, compareJsType, recur, shallow);\n+      if (equiv) {\n         double thisValue = getDouble();\n         double thatValue = ((NumberNode) node).getDouble();\n         if (thisValue == thatValue) {\n           // detect the difference between 0.0 and -0.0.\n-          return (thisValue != 0.0) || (1/thisValue == 1/thatValue);\n+          return (thisValue != 0.0) || (1 / thisValue == 1 / thatValue);\n         }\n       }\n       return false;\n     }\n \n     @Override\n-    boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n-      return (super.isEquivalentTo(node, compareJsType, recurse)\n+    boolean isEquivalentTo(\n+        Node node, boolean compareJsType, boolean recur, boolean shallow) {\n+      return (super.isEquivalentTo(node, compareJsType, recur, shallow)\n           && this.str.equals(((StringNode) node).str));\n     }\n \n     int getIntValue();\n   }\n \n-  private static abstract class AbstractPropListItem\n+  private abstract static class AbstractPropListItem\n       implements PropListItem, Serializable {\n     private static final long serialVersionUID = 1L;\n \n    */\n   public void removeChild(Node child) {\n     Node prev = getChildBefore(child);\n-    if (prev == null)\n-        first = first.next;\n-    else\n-        prev.next = child.next;\n-    if (child == last) last = prev;\n+    if (prev == null) {\n+      first = first.next;\n+    } else {\n+      prev.next = child.next;\n+    }\n+    if (child == last) {\n+      last = prev;\n+    }\n     child.next = null;\n     child.parent = null;\n   }\n     newChild.next = child.next;\n     newChild.parent = this;\n     if (child == first) {\n-        first = newChild;\n+      first = newChild;\n     } else {\n-        Node prev = getChildBefore(child);\n-        prev.next = newChild;\n-    }\n-    if (child == last)\n-        last = newChild;\n+      Node prev = getChildBefore(child);\n+      prev.next = newChild;\n+    }\n+    if (child == last) {\n+      last = newChild;\n+    }\n     child.next = null;\n     child.parent = null;\n   }\n     newChild.next = child.next;\n     newChild.parent = this;\n     prevChild.next = newChild;\n-    if (child == last)\n-        last = newChild;\n+    if (child == last) {\n+      last = newChild;\n+    }\n     child.next = null;\n     child.parent = null;\n   }\n \n         @Override\n         public Node next() {\n-          if (!hasNext()) throw new NoSuchElementException();\n+          if (!hasNext()) {\n+            throw new NoSuchElementException();\n+          }\n           Node n = cur;\n           cur = cur.getParent();\n           return n;\n \n   public int getChildCount() {\n     int c = 0;\n-    for (Node n = first; n != null; n = n.next)\n+    for (Node n = first; n != null; n = n.next) {\n       c++;\n-\n+    }\n     return c;\n   }\n \n    * testing. Returns null if the nodes are equivalent.\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n-    if (!isEquivalentTo(node2, false, false)) {\n+    if (!isEquivalentTo(node2, false, false, false)) {\n       return new NodeMismatch(this, node2);\n     }\n \n    */\n   NodeMismatch checkTreeTypeAwareEqualsImpl(Node node2) {\n     // Do a non-recursive equivalents check.\n-    if (!isEquivalentTo(node2, true, false)) {\n+    if (!isEquivalentTo(node2, true, false, false)) {\n       return new NodeMismatch(this, node2);\n     }\n \n \n   /** Returns true if this node is equivalent semantically to another */\n   public boolean isEquivalentTo(Node node) {\n-    return isEquivalentTo(node, false, true);\n+    return isEquivalentTo(node, false, true, false);\n+  }\n+\n+  /** Checks equivalence without going into inner functions */\n+  public boolean isEquivalentToShallow(Node node) {\n+    return isEquivalentTo(node, false, true, true);\n   }\n \n   /**\n    * the types are equivalent.\n    */\n   public boolean isEquivalentToTyped(Node node) {\n-    return isEquivalentTo(node, true, true);\n+    return isEquivalentTo(node, true, true, false);\n   }\n \n   /**\n    * @param compareJsType Whether to compare the JSTypes of the nodes.\n-   * @param recurse Whether to compare the children of the current node, if\n+   * @param recur Whether to compare the children of the current node, if\n    *    not only the the count of the children are compared.\n+   * @param shallow If true, the method doesn't recur into inner functions.\n    * @return Whether this node is equivalent semantically to the provided node.\n    */\n-  boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n+  boolean isEquivalentTo(\n+      Node node, boolean compareJsType, boolean recur, boolean shallow) {\n     if (type != node.getType()\n         || getChildCount() != node.getChildCount()\n         || this.getClass() != node.getClass()) {\n       }\n     }\n \n-    if (recurse) {\n+    if (recur) {\n       Node n, n2;\n       for (n = first, n2 = node.first;\n            n != null;\n            n = n.next, n2 = n2.next) {\n-        if (!n.isEquivalentTo(n2, compareJsType, true)) {\n+        if (!n.isEquivalentTo(\n+            n2, compareJsType, !(shallow && n.isFunction()), shallow)) {\n           return false;\n         }\n       }\n \n     Node child = prev.next;\n     prev.next = child.next;\n-    if (child == last) last = prev;\n+    if (child == last) {\n+      last = prev;\n+    }\n     child.next = null;\n     child.parent = null;\n     return child;\n       return this;\n   }\n \n+  /** This node was last changed at {@code time} */\n+  public void setChangeTime(int time) {\n+    putIntProp(CHANGE_TIME, time);\n+  }\n+\n+  /** Returns the time of the last change for this node */\n+  public int getChangeTime() {\n+    return getIntProp(CHANGE_TIME);\n+  }\n+\n   /**\n    * Sets whether this node is a variable length argument node. This\n    * method is meaningful only on {@link Token#NAME} nodes\n   // We want a value of 0 to mean \"global state changes and\n   // unknown locality of result\".\n \n-  final public static int FLAG_GLOBAL_STATE_UNMODIFIED = 1;\n-  final public static int FLAG_THIS_UNMODIFIED = 2;\n-  final public static int FLAG_ARGUMENTS_UNMODIFIED = 4;\n-  final public static int FLAG_NO_THROWS = 8;\n-  final public static int FLAG_LOCAL_RESULTS = 16;\n-\n-  final public static int SIDE_EFFECTS_FLAGS_MASK = 31;\n-\n-  final public static int SIDE_EFFECTS_ALL = 0;\n-  final public static int NO_SIDE_EFFECTS =\n+  public static final int FLAG_GLOBAL_STATE_UNMODIFIED = 1;\n+  public static final int FLAG_THIS_UNMODIFIED = 2;\n+  public static final int FLAG_ARGUMENTS_UNMODIFIED = 4;\n+  public static final int FLAG_NO_THROWS = 8;\n+  public static final int FLAG_LOCAL_RESULTS = 16;\n+\n+  public static final int SIDE_EFFECTS_FLAGS_MASK = 31;\n+\n+  public static final int SIDE_EFFECTS_ALL = 0;\n+  public static final int NO_SIDE_EFFECTS =\n     FLAG_GLOBAL_STATE_UNMODIFIED\n     | FLAG_THIS_UNMODIFIED\n     | FLAG_ARGUMENTS_UNMODIFIED\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPreOrderCallback;\n import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n import com.google.javascript.rhino.Node;\n import junit.framework.TestCase;\n \n import java.io.IOException;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * <p>Base class for testing JS compiler classes that change\n     test(compiler, expected, error, warning, null);\n   }\n \n+  private Map<Node, Node> findCorrespondingNodes(Node n1, Node n2) {\n+    Preconditions.checkState(n1.isEquivalentTo(n2));\n+    Map<Node, Node> correspondingNodes = new HashMap<Node, Node>();\n+    correspondingNodes.put(n1, n2);\n+    correspondingNodesHelper(correspondingNodes, n1, n2);\n+    return correspondingNodes;\n+  }\n+\n+  private void correspondingNodesHelper(Map<Node, Node> map, Node n1, Node n2) {\n+    if (n1.isFunction()) {\n+      map.put(n1, n2);\n+    }\n+    for (Node child1 = n1.getFirstChild(), child2 = n2.getFirstChild();\n+         child1 != null;\n+         child1 = child1.getNext(), child2 = child2.getNext()) {\n+      correspondingNodesHelper(map, child1, child2);\n+    }\n+  }\n \n   /**\n    * Verifies that the compiler pass's JS output matches the expected output\n   private void test(Compiler compiler, String[] expected,\n                     DiagnosticType error, DiagnosticType warning,\n                     String description) {\n-    CodeChangeHandler recentChange = new  CodeChangeHandler();\n+    RecentChange recentChange = new RecentChange();\n     compiler.addChangeHandler(recentChange);\n \n     Node root = compiler.parseInputs();\n     Node rootClone = root.cloneTree();\n     Node externsRootClone = rootClone.getFirstChild();\n     Node mainRootClone = rootClone.getLastChild();\n+    final Map<Node, Node> nodeMap =\n+        findCorrespondingNodes(mainRoot, mainRootClone);\n \n     int numRepetitions = getNumRepetitions();\n     ErrorManager[] errorManagers = new ErrorManager[numRepetitions];\n       boolean codeChange = !mainRootClone.isEquivalentTo(mainRoot);\n       boolean externsChange = !externsRootClone.isEquivalentTo(externsRoot);\n \n-      // Generally, externs should not be change by the compiler passes.\n+      // Generally, externs should not be changed by the compiler passes.\n       if (externsChange && !allowExternsChanges) {\n         String explanation = externsRootClone.checkTreeEquals(externsRoot);\n         fail(\"Unexpected changes to externs\" +\n         assertTrue(\"compiler.reportCodeChange() should have been called\",\n             hasCodeChanged);\n       }\n+\n+      // If a scope is marked as changed, it should not be shallow-equivalent\n+      // to its corresponding cloned scope. The converse is false b/c we don't\n+      // track changes to scopes by non-loopable passes.\n+      if (mainRoot.getChangeTime() != 0) {\n+        assertFalse(mainRoot.isEquivalentToShallow(nodeMap.get(mainRoot)));\n+      }\n+      NodeTraversal.traverse(compiler, mainRoot,\n+          new AbstractPreOrderCallback() {\n+            @Override\n+            public final boolean shouldTraverse(\n+                NodeTraversal t, Node n, Node p) {\n+              if (n.isFunction() &&\n+                  n.getChangeTime() != 0 && nodeMap.containsKey(n)) {\n+                assertFalse(n.isEquivalentToShallow(nodeMap.get(n)));\n+              }\n+              return true;\n+            }\n+          });\n \n       if (expected != null) {\n         if (compareAsTree) {\n \n       // Verify normalization is not invalidated.\n       Node normalizeCheckRootClone = root.cloneTree();\n-      Node normalizeCheckExternsRootClone = normalizeCheckRootClone.getFirstChild();\n+      Node normalizeCheckExternsRootClone =\n+          normalizeCheckRootClone.getFirstChild();\n       Node normalizeCheckMainRootClone = normalizeCheckRootClone.getLastChild();\n       new PrepareAst(compiler).process(\n           normalizeCheckExternsRootClone, normalizeCheckMainRootClone);\n--- a/test/com/google/javascript/jscomp/ExpandJqueryAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ExpandJqueryAliasesTest.java\n public class ExpandJqueryAliasesTest extends CompilerTestCase {\n   private JqueryCodingConvention conv = new JqueryCodingConvention();\n \n-  final DiagnosticType NAME_ERROR =\n+  static final DiagnosticType NAME_ERROR =\n       ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_NAME_ERROR;\n \n-  final DiagnosticType INVALID_LIT_ERROR =\n+  static final DiagnosticType INVALID_LIT_ERROR =\n       ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_LIT_ERROR;\n \n-  final DiagnosticType USELESS_EACH_ERROR =\n+  static final DiagnosticType USELESS_EACH_ERROR =\n       ExpandJqueryAliases.JQUERY_USELESS_EACH_EXPANSION;\n \n   public ExpandJqueryAliasesTest() {}\n         \"jQuery.b = 'test2';}\");\n \n     // Test extend call where first argument includes a method call\n-    testSame(setupCode+\"obj2.meth=function() { return { a:{} }; };\" +\n+    testSame(setupCode + \"obj2.meth=function() { return { a:{} }; };\" +\n         \"jQuery.extend(obj2.meth().a, {a: 'test'});\");\n \n     // Test extend call where returned object is used\n   public void testJqueryExpandedEachExpansion() {\n     String setupCode = \"var jQuery={};\" +\n         \"jQuery.expandedEach=function(vals, callback){};\";\n+    String resultCode =\n+        \"var jQuery={ expandedEach: function(vals, callback){} };\";\n \n     testSame(setupCode);\n \n     // Test expansion with object literal\n     test(setupCode + \"jQuery.expandedEach({'a': 1, 'b': 2, 'c': 8},\" +\n         \"function(key, val) { var a = key; jQuery[key] = val; });\",\n-        setupCode + \"(function(){ var a = 'a'; jQuery.a = 1 })();\" +\n+        resultCode + \"(function(){ var a = 'a'; jQuery.a = 1 })();\" +\n         \"(function(){ var a = 'b'; jQuery.b = 2 })();\" +\n         \"(function(){ var a = 'c'; jQuery.c = 8 })();\");\n \n     // string literal value should become a property name.\n     test(setupCode + \"jQuery.expandedEach(['a', 'b', 'c'],\" +\n         \"function(key, val){ jQuery[val] = key; });\",\n-        setupCode + \"(function(){ jQuery.a = 0; })();\" +\n+        resultCode + \"(function(){ jQuery.a = 0; })();\" +\n         \"(function(){ jQuery.b = 1; })();\" +\n         \"(function(){ jQuery.c = 2 })();\");\n \n     // Test expansion with object literal using 'this' keyword\n     test(setupCode + \"jQuery.expandedEach({'a': 1, 'b': 2, 'c': 8},\" +\n         \"function(key, val) { var a = key; jQuery[key] = this; });\",\n-        setupCode + \"(function(){ var a = 'a'; jQuery.a = 1 })();\" +\n+        resultCode + \"(function(){ var a = 'a'; jQuery.a = 1 })();\" +\n         \"(function(){ var a = 'b'; jQuery.b = 2 })();\" +\n         \"(function(){ var a = 'c'; jQuery.c = 8 })();\");\n \n     // Test expansion with array literal using 'this' keyword\n     test(setupCode + \"jQuery.expandedEach(['a', 'b', 'c'],\" +\n         \"function(key, val){ jQuery[this] = key; });\",\n-        setupCode + \"(function(){ jQuery.a = 0; })();\" +\n+        resultCode + \"(function(){ jQuery.a = 0; })();\" +\n         \"(function(){ jQuery.b = 1; })();\" +\n         \"(function(){ jQuery.c = 2 })();\");\n \n     // test nested function using argument name to shadow callback name\n     test(setupCode + \"jQuery.expandedEach(['a'], function(key,val) {\" +\n         \"jQuery[val] = key; (function(key) { jQuery[key] = 1;})('test'); })\",\n-        setupCode + \"(function(){ jQuery.a = 0;\" +\n+        resultCode + \"(function(){ jQuery.a = 0;\" +\n          \"(function(key){ jQuery[key] = 1})('test') })()\");\n \n     // test nested function using var name to shadow callback name\n     test(setupCode + \"jQuery.expandedEach(['a'], function(key,val) {\" +\n         \"jQuery[val] = key; (function(key) { var val = 2;\" +\n         \"jQuery[key] = val;})('test');})\",\n-        setupCode + \"(function(){\" +\n+        resultCode + \"(function(){\" +\n         \"jQuery.a=0;\" +\n         \"(function(key){var val = 2; jQuery[key] = val;})('test')})()\");\n \n         \"jQuery[val] = key; (function(key1) {\" +\n         \"function key() {}; key();\" +\n         \"})('test');})\",\n-        setupCode + \"(function(){\" +\n+        resultCode + \"(function(){\" +\n         \"jQuery.a=0;(function(key1) {\" +\n-        \"function key() {}; key(); })('test')})()\");\n+        \"function key() {} key(); })('test')})()\");\n \n     // test using return val\n     test(setupCode + \"alert(jQuery.expandedEach(['a'],\" +\n         \"function(key,val) { jQuery[val] = key;})[0])\",\n-        setupCode + \"alert((function(){\" +\n+        resultCode + \"alert((function(){\" +\n         \"(function(){ jQuery.a = 0;})(); return ['a']})()[0]);\");\n \n     // Loop object is a variable. Test that warning is raised.\n-    testSame(setupCode + \"var a = ['a'];\" +\n-        \"jQuery.expandedEach(a, function(key,val){ jQuery[key]=val; })\",\n-        INVALID_LIT_ERROR);\n+    String testCode = \"var a = ['a'];\" +\n+        \"jQuery.expandedEach(a, function(key,val){ jQuery[key]=val; })\";\n+    test(setupCode + testCode, resultCode + testCode, null, INVALID_LIT_ERROR);\n \n     // Invalid property name. Test that warning is raised.\n-    testSame(setupCode + \"var obj2={};\" +\n+    test(setupCode + \"var obj2={};\" +\n         \"jQuery.expandedEach(['foo','bar'], function(i, name) {\" +\n-        \"obj2[ '[object ' + name + ']' ] = 'a';});\", NAME_ERROR, true);\n+        \"obj2[ '[object ' + name + ']' ] = 'a';});\",\n+        resultCode + \"var obj2={};\" +\n+        \"jQuery.expandedEach(['foo','bar'], function(i, name) {\" +\n+        \"obj2[ '[object foo]' ] = 'a';});\",\n+        null, USELESS_EACH_ERROR);\n \n     // Useless expansion (key not used). Test that warning is raised.\n-    testSame(setupCode + \"var obj2={};\" +\n-        \"jQuery.expandedEach(['foo','bar'], function(i, name) {\" +\n-        \"obj2[i] = 1;});\", USELESS_EACH_ERROR, false);\n+    testCode =\n+        \"var obj2={}; jQuery.expandedEach(['foo','bar'], function(i, name) {\" +\n+        \"obj2[i] = 1;});\";\n+    test(setupCode + testCode, resultCode + testCode, null, USELESS_EACH_ERROR);\n   }\n }\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n       char letter = (char) ('d' + i);\n \n       // skip i,j,o (reserved)\n-      if (letter >= 'i') letter++;\n-      if (letter >= 'j') letter++;\n-      if (letter >= 'o') letter++;\n+      if (letter >= 'i') {\n+        letter++;\n+      }\n+      if (letter >= 'j') {\n+        letter++;\n+      }\n+      if (letter >= 'o') {\n+        letter++;\n+      }\n \n       expected += \"a.argz = function() {arguments};\";\n       expected += \"function \" + letter + \"(c){}\";\n       char letter = (char) ('d' + i);\n \n       // skip i,j,o (reserved)\n-      if (letter >= 'i') letter++;\n-      if (letter >= 'j') letter++;\n-      if (letter >= 'o') letter++;\n+      if (letter >= 'i') {\n+        letter++;\n+      }\n+      if (letter >= 'j') {\n+        letter++;\n+      }\n+      if (letter >= 'o') {\n+        letter++;\n+      }\n \n       expected += letter + \"(q);\";\n     }\n     assertTrue(p.matcher(output.toString()).matches());\n   }\n \n+  // isEquivalentTo returns false for alpha-equivalent nodes\n+  public void testIsEquivalentTo() {\n+    String[] input1 = {\"function f(z) { return z; }\"};\n+    String[] input2 = {\"function f(y) { return y; }\"};\n+    CompilerOptions options = new CompilerOptions();\n+    Node out1 = parse(input1, options, false);\n+    Node out2 = parse(input2, options, false);\n+    assertFalse(out1.isEquivalentTo(out2));\n+  }\n+\n   /** Creates a CompilerOptions object with google coding conventions. */\n   @Override\n   protected CompilerOptions createCompilerOptions() {\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/MultiPassTest.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+\n+/**\n+ */\n+\n+/**\n+ * This file contains the only tests that use the infrastructure in\n+ * CompilerTestCase to run multiple passes. The other files that use\n+ * CompilerTestCase test a single pass.\n+ */\n+public class MultiPassTest extends CompilerTestCase {\n+  private List<PassFactory> passes;\n+\n+  public MultiPassTest() {}\n+\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    PhaseOptimizer po = new PhaseOptimizer(compiler, null, null);\n+    po.consume(passes);\n+    compiler.setPhaseOptimizer(po);\n+    return po;\n+  }\n+\n+  public void testInlineVarsAndPeephole() {\n+    passes = Lists.newLinkedList();\n+    addInlineVariables();\n+    addPeephole();\n+    test(\"function f() { var x = 1; return x + 5; }\",\n+        \"function f() { return 6; }\");\n+  }\n+\n+  public void testInlineVarsAndDeadCodeElim() {\n+    passes = Lists.newLinkedList();\n+    addDeadCodeElimination();\n+    addInlineVariables();\n+    test(\"function f() { var x = 1; return x; x = 3; }\",\n+        \"function f() { return 1; }\");\n+  }\n+\n+  public void testTopScopeChange() {\n+    passes = Lists.newLinkedList();\n+    addInlineVariables();\n+    addPeephole();\n+    test(\"var x = 1, y = x, z = x + y;\", \"var z = 2;\");\n+  }\n+\n+  private void addDeadCodeElimination() {\n+    passes.add(new PassFactory(\"removeUnreachableCode\", false) {\n+        @Override\n+        protected CompilerPass create(AbstractCompiler compiler) {\n+          return new UnreachableCodeElimination(compiler, true);\n+        }\n+      });\n+  }\n+\n+  private void addInlineVariables() {\n+    passes.add(new PassFactory(\"inlineVariables\", false) {\n+        @Override\n+        protected CompilerPass create(AbstractCompiler compiler) {\n+          return new InlineVariables(compiler, InlineVariables.Mode.ALL, true);\n+        }\n+      });\n+  }\n+\n+  private void addPeephole() {\n+    passes.add(new PassFactory(\"peepholeOptimizations\", false) {\n+        @Override\n+        protected CompilerPass create(AbstractCompiler compiler) {\n+          final boolean late = false;\n+          return new PeepholeOptimizationsPass(compiler,\n+              new PeepholeSubstituteAlternateSyntax(late),\n+              new PeepholeReplaceKnownMethods(late),\n+              new PeepholeRemoveDeadCode(),\n+              new PeepholeFoldConstants(late),\n+              new PeepholeCollectPropertyAssignments());\n+        }\n+      });\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n \n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n-    CompilerPass peepholePass =\n-      new PeepholeOptimizationsPass(compiler,\n-          new PeepholeSubstituteAlternateSyntax(late))\n-      .setRetraverseOnChange(false);\n-\n+    PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass(\n+        compiler, new PeepholeSubstituteAlternateSyntax(late));\n+    peepholePass.setRetraverseOnChange(false);\n     return peepholePass;\n   }\n \n     // Don't fold really long regexp literals, because Opera 9.2's\n     // regexp parser will explode.\n     String longRegexp = \"\";\n-    for (int i = 0; i < 200; i++) longRegexp += \"x\";\n+    for (int i = 0; i < 200; i++) {\n+      longRegexp += \"x\";\n+    }\n     foldSame(\"x = RegExp(\\\"\" + longRegexp + \"\\\")\");\n \n     // Shouldn't fold RegExp unnormalized because\n--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n  */\n public class PhaseOptimizerTest extends TestCase {\n   private final List<String> passesRun = Lists.newArrayList();\n+  private final Node dummyRoot = new Node(Token.BLOCK);\n   private PhaseOptimizer optimizer;\n   private Compiler compiler;\n   private PerformanceTracker tracker;\n     passesRun.clear();\n     compiler = new Compiler();\n     compiler.initCompilerOptionsIfTesting();\n-    tracker = new PerformanceTracker(\n-        new Node(Token.BLOCK), TracerMode.TIMING_ONLY);\n+    tracker = new PerformanceTracker(dummyRoot, TracerMode.TIMING_ONLY);\n     optimizer = new PhaseOptimizer(compiler, tracker, null);\n   }\n \n   public void testNotInfiniteLoop() {\n     Loop loop = optimizer.addFixedPointLoop();\n     addLoopedPass(loop, \"x\", PhaseOptimizer.MAX_LOOPS - 1);\n-    optimizer.process(null, null);\n+    optimizer.process(null, dummyRoot);\n     assertEquals(\"There should be no errors.\", 0, compiler.getErrorCount());\n   }\n \n     Loop loop = optimizer.addFixedPointLoop();\n     addLoopedPass(loop, \"x\", PhaseOptimizer.MAX_LOOPS + 1);\n     try {\n-      optimizer.process(null, null);\n+      optimizer.process(null, dummyRoot);\n       fail(\"Expected RuntimeException\");\n     } catch (RuntimeException e) {\n       assertTrue(e.getMessage().contains(PhaseOptimizer.OPTIMIZE_LOOP_ERROR));\n     try {\n       addLoopedPass(loop, \"x\", 1);\n       fail(\"Expected exception\");\n-    } catch (IllegalArgumentException e) {}\n+    } catch (IllegalArgumentException e) {\n+      return;\n+    }\n   }\n \n   public void testPassOrdering() {\n       addLoopedPass(\n           loop, optimalOrder.remove(random.nextInt(optimalOrder.size())), 0);\n     }\n-    optimizer.process(null, null);\n+    optimizer.process(null, dummyRoot);\n     assertEquals(PhaseOptimizer.OPTIMAL_ORDER, passesRun);\n   }\n \n     addOneTimePass(\"x2\");\n     addOneTimePass(\"x3\");\n     addOneTimePass(\"x4\");\n-    optimizer.process(null, null);\n+    optimizer.process(null, dummyRoot);\n     assertEquals(4, progressList.size());\n     assertEquals(25, Math.round(progressList.get(0)));\n     assertEquals(50, Math.round(progressList.get(1)));\n   }\n \n   public void assertPasses(String ... names) {\n-    optimizer.process(null, null);\n+    optimizer.process(null, dummyRoot);\n     assertEquals(Lists.newArrayList(names), passesRun);\n   }\n \n--- a/test/com/google/javascript/jscomp/SourceInformationAnnotatorTest.java\n+++ b/test/com/google/javascript/jscomp/SourceInformationAnnotatorTest.java\n     name.putProp(Node.ORIGINALNAME_PROP, \"bar\");\n     root.addChildToBack(name);\n \n-    NodeTraversal.traverse(null, root,\n+    NodeTraversal.traverse(new Compiler(), root,\n         new SourceInformationAnnotator(\"\", false));\n     assertEquals(name.getProp(Node.ORIGINALNAME_PROP), \"bar\");\n   }", "timestamp": 1363798094, "metainfo": ""}