{"sha": "aadf06cb0d2c1cbd76c802f8d63b31c0eec60608", "log": "Remove unused Node annotation IS_VAR_ARGS_PARAM, IS_OPTIONAL_PARAM  R=nicksantos DELTA=68  (1 added, 58 deleted, 9 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5557   ", "commit": "\n--- a/src/com/google/javascript/jscomp/GenerateExports.java\n+++ b/src/com/google/javascript/jscomp/GenerateExports.java\n     Map<String, GenerateNodeContext> exports = findExportableNodes\n         .getExports();\n \n+    CodingConvention convention = compiler.getCodingConvention();\n     for (Map.Entry<String, GenerateNodeContext> entry : exports.entrySet()) {\n       String export = entry.getKey();\n       GenerateNodeContext context = entry.getValue();\n         // exportSymbol(publicPath, object);\n         call = IR.call(\n             NodeUtil.newQualifiedNameNode(\n-                compiler.getCodingConvention(), exportSymbolFunction,\n+                convention, exportSymbolFunction,\n                 context.getNode(), export),\n             IR.string(export),\n             NodeUtil.newQualifiedNameNode(\n-                compiler.getCodingConvention(), export,\n+                convention, export,\n                 context.getNode(), export));\n       } else {\n         // exportProperty(object, publicName, symbol);\n         String property = getPropertyName(node);\n         call = IR.call(\n             NodeUtil.newQualifiedNameNode(\n-                compiler.getCodingConvention(), exportPropertyFunction,\n+                convention, exportPropertyFunction,\n                 context.getNode(), exportPropertyFunction),\n             NodeUtil.newQualifiedNameNode(\n-                compiler.getCodingConvention(), parent,\n+                convention, parent,\n                 context.getNode(), exportPropertyFunction),\n             IR.string(property),\n             NodeUtil.newQualifiedNameNode(\n-                compiler.getCodingConvention(), export,\n+                convention, export,\n                 context.getNode(), exportPropertyFunction));\n       }\n \n       // It's important that any class-building calls (goog.inherits)\n       // come right after the class definition, so move the export after that.\n       Node insertionPoint = context.getContextNode().getNext();\n-      CodingConvention convention = compiler.getCodingConvention();\n       while (insertionPoint != null &&\n           NodeUtil.isExprCall(insertionPoint) &&\n           convention.getClassesDefinedByCall(\n \n   private void annotate(Node node) {\n     NodeTraversal.traverse(\n-        compiler, node, new PrepareAst.PrepareAnnotations(compiler));\n+        compiler, node, new PrepareAst.PrepareAnnotations());\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n \n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.IR;\n-import com.google.javascript.rhino.JSDocInfo;\n-import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n       // performed.\n       if (externs != null) {\n         NodeTraversal.traverse(\n-            compiler, externs, new PrepareAnnotations(compiler));\n+            compiler, externs, new PrepareAnnotations());\n       }\n       if (root != null) {\n         NodeTraversal.traverse(\n-            compiler, root, new PrepareAnnotations(compiler));\n+            compiler, root, new PrepareAnnotations());\n       }\n     }\n   }\n   static class PrepareAnnotations\n       implements NodeTraversal.Callback {\n \n-    private final CodingConvention convention;\n-\n-    PrepareAnnotations(AbstractCompiler compiler) {\n-      this.convention = compiler.getCodingConvention();\n+    PrepareAnnotations() {\n     }\n \n     @Override\n           break;\n \n         case Token.FUNCTION:\n-          annotateFunctions(n, parent);\n           annotateDispatchers(n, parent);\n           break;\n       }\n         value.setJSDocInfo(key.getJSDocInfo());\n       }\n     }\n-\n-    /**\n-     * Annotate optional and var_arg function parameters.\n-     */\n-    private void annotateFunctions(Node n, Node parent) {\n-      JSDocInfo fnInfo = NodeUtil.getFunctionJSDocInfo(n);\n-\n-      // Compute which function parameters are optional and\n-      // which are var_args.\n-      Node args = n.getFirstChild().getNext();\n-      for (Node arg = args.getFirstChild();\n-           arg != null;\n-           arg = arg.getNext()) {\n-        String argName = arg.getString();\n-        JSTypeExpression typeExpr = fnInfo == null ?\n-            null : fnInfo.getParameterType(argName);\n-\n-        if (convention.isOptionalParameter(arg) ||\n-            typeExpr != null && typeExpr.isOptionalArg()) {\n-          arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n-        }\n-        if (convention.isVarArgsParameter(arg) ||\n-            typeExpr != null && typeExpr.isVarArgs()) {\n-          arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n-        }\n-      }\n-    }\n   }\n }\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n                                   // flags\n       // Coding convention props\n       IS_CONSTANT_NAME   = 43,    // The variable or property is constant.\n-      IS_OPTIONAL_PARAM  = 44,    // The parameter is optional.\n-      IS_VAR_ARGS_PARAM  = 45,    // The parameter is a var_args.\n       IS_NAMESPACE       = 46,    // The variable creates a namespace.\n       IS_DISPATCHER      = 47,    // The function is a dispatcher function,\n                                   // probably generated from Java code, and\n         case SIDE_EFFECT_FLAGS:  return \"side_effect_flags\";\n \n         case IS_CONSTANT_NAME:   return \"is_constant_name\";\n-        case IS_OPTIONAL_PARAM:  return \"is_optional_param\";\n-        case IS_VAR_ARGS_PARAM:  return \"is_var_args_param\";\n         case IS_NAMESPACE:       return \"is_namespace\";\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";", "timestamp": 1348607132, "metainfo": ""}