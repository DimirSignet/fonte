{"sha": "d71162d4337d5d12efe41d2debf7e565c2e8b871", "log": "Detect when the prototype property of a @struct constructor is assigned to an unannotated object literal.  R=nicksantos DELTA=30  (17 added, 2 deleted, 11 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5718   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n             JSType rvalueType = rvalue.getJSType();\n             validator.expectObject(t, rvalue, rvalueType,\n                 OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n+            // Only assign structs to the prototype of a @struct constructor\n+            if (functionType.makesStructs() && !rvalueType.isStruct()) {\n+              String funName = functionType.getTypeOfThis().toString();\n+              compiler.report(t.makeError(assign, CONFLICTING_EXTENDED_TYPE,\n+                                          \"struct\", funName));\n+            }\n             return;\n           }\n         }\n             t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                         \"constructor\", functionPrivateName));\n       } else {\n-        if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n-            baseConstructor != null) {\n-          if (functionType.makesStructs() && !baseConstructor.makesStructs()) {\n+        if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE)) {\n+          ObjectType proto = functionType.getPrototype();\n+          if (functionType.makesStructs() && !proto.isStruct()) {\n             compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                                         \"struct\", functionPrivateName));\n-          } else if (functionType.makesDicts() &&\n-                     !baseConstructor.makesDicts()) {\n+          } else if (functionType.makesDicts() && !proto.isDict()) {\n             compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                                         \"dict\", functionPrivateName));\n           }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n         setPrototype(\n             new PrototypeObjectType(\n                 registry,\n-                this.getReferenceName() + \".prototype\",\n+                getReferenceName() + \".prototype\",\n                 registry.getNativeObjectType(OBJECT_TYPE),\n                 isNativeObjectType(), null, null),\n             null);\n     if (baseType.hasReferenceName() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType()) {\n-\n       baseType = new PrototypeObjectType(\n-          registry, this.getReferenceName() + \".prototype\", baseType);\n+          registry, getReferenceName() + \".prototype\", baseType);\n     }\n     setPrototype(baseType, propertyNode);\n   }\n             objType.isEquivalentTo(prototypeSlot.getType())) {\n           return true;\n         }\n-        this.setPrototypeBasedOn(objType, propertyNode);\n+        setPrototypeBasedOn(objType, propertyNode);\n         return true;\n       } else {\n         return false;\n \n       // Check for the degenerate case, but double check\n       // that there's not a cycle.\n-      boolean isSubtypeOfThat = this.isSubtype(that);\n+      boolean isSubtypeOfThat = isSubtype(that);\n       boolean isSubtypeOfThis = that.isSubtype(this);\n       if (isSubtypeOfThat && !isSubtypeOfThis) {\n         return leastSuper ? that : this;\n     FunctionType ctor = this;\n \n     if (isInterface()) {\n-      return getTopDefiningInterface(this.getInstanceType(), propertyName);\n+      return getTopDefiningInterface(getInstanceType(), propertyName);\n     }\n \n     ObjectType topInstanceType = null;\n         // Any function can be assigned to an interface function.\n         return true;\n       }\n-      if (this.isInterface()) {\n+      if (isInterface()) {\n         // An interface function cannot be assigned to anything.\n         return false;\n       }\n       // TODO(nicksantos): fix this.\n       boolean treatThisTypesAsCovariant =\n         // If either one of these is a ctor, skip 'this' checking.\n-        this.isConstructor() || other.isConstructor() ||\n+        isConstructor() || other.isConstructor() ||\n \n         // An interface 'this'-type is non-restrictive.\n         // In practical terms, if C implements I, and I has a method m,\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n               \"dicts can only extend dicts\");\n   }\n \n+  public void testConstructorType12() throws Exception {\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Bar() {}\\n\" +\n+              \"Bar.prototype = {};\\n\",\n+              \"Bar cannot extend this type; \" +\n+              \"structs can only extend structs\");\n+  }\n+\n   public void testBadStruct() throws Exception {\n     testTypes(\"/** @struct */function Struct1() {}\",\n               \"@struct used without @constructor for Struct1\");", "timestamp": 1351272547, "metainfo": ""}