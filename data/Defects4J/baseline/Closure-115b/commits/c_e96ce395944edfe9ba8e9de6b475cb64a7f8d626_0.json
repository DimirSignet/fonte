{"sha": "e96ce395944edfe9ba8e9de6b475cb64a7f8d626", "log": "Fix 8-year old bug in CodeGenerator.  Rather than try to optimize the AST as it is being printed, simply print the AST as-is. Additionally, create an optimization in PeepholeSubstituteAlternateSyntax that rotates associative operators to the left to get rid of unnecessary parens at the AST level.  Fixes issue 1062 ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=51094530", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n       // the IN_FOR_INIT_CLAUSE one.\n       Context rhsContext = getContextForNoInOperator(context);\n \n-      // Handle associativity.\n-      // e.g. if the parse tree is a * (b * c),\n-      // we can simply generate a * b * c.\n-      if (last.getType() == type &&\n-          NodeUtil.isAssociative(type)) {\n-        addExpr(first, p, context);\n-        cc.addOp(opstr, true);\n-        addExpr(last, p, rhsContext);\n-      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n+      if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n         // Assignments are the only right-associative binary operators\n         addExpr(first, p, context);\n         cc.addOp(opstr, true);\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n       case Token.ARRAYLIT:\n         return tryMinimizeArrayLiteral(node);\n \n+      case Token.MUL:\n+      case Token.AND:\n+      case Token.OR:\n+      case Token.BITOR:\n+      case Token.BITXOR:\n+      case Token.BITAND:\n+        return tryRotateAssociativeOperator(node);\n+\n       default:\n         return node; //Nothing changed\n     }\n+  }\n+\n+  private Node tryRotateAssociativeOperator(Node n) {\n+    if (!late) {\n+      return n;\n+    }\n+    Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));\n+    Node rhs = n.getLastChild();\n+    if (n.getType() == rhs.getType()) {\n+      Node parent = n.getParent();\n+      Node first = n.getFirstChild().detachFromParent();\n+      Node second = rhs.getFirstChild().detachFromParent();\n+      Node third = rhs.getLastChild().detachFromParent();\n+      Node newLhs = new Node(n.getType(), first, second)\n+          .copyInformationFrom(n);\n+      Node newRoot = new Node(rhs.getType(), newLhs, third)\n+          .copyInformationFrom(rhs);\n+      parent.replaceChild(n, newRoot);\n+      reportCodeChange();\n+      return newRoot;\n+    }\n+    return n;\n   }\n \n   private Node tryFoldSimpleFunctionCall(Node n) {\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n     assertPrint(\"var a,b,c,d;a || (b&& c) && (a || d)\",\n         \"var a,b,c,d;a||b&&c&&(a||d)\");\n     assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n-        \"var a,b,c;a||b||c;a*b*c;a|b|c\");\n+        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\");\n     assertPrint(\"var a,b,c; a / b / c;a / (b / c); a - (b - c);\",\n         \"var a,b,c;a/b/c;a/(b/c);a-(b-c)\");\n+\n+    // Nested assignments\n     assertPrint(\"var a,b; a = b = 3;\",\n         \"var a,b;a=b=3\");\n     assertPrint(\"var a,b,c,d; a = (b = c = (d = 3));\",\n         \"var a={};for(var i=(\\\"length\\\"in a)+1;i;);\");\n     assertPrint(\"var a={};for (var i = (\\\"length\\\" in a|| \\\"size\\\" in a);;);\",\n         \"var a={};for(var i=(\\\"length\\\"in a)||(\\\"size\\\"in a);;);\");\n-    assertPrint(\"var a={};for (var i = a || a || (\\\"size\\\" in a);;);\",\n+    assertPrint(\"var a={};for (var i = (a || a) || (\\\"size\\\" in a);;);\",\n         \"var a={};for(var i=a||a||(\\\"size\\\"in a);;);\");\n \n     // Test works with unary operators and calls.\n     assertPrintSame(\"x={foo:2}\");\n     assertPrint(\"x={function:2}\", \"x={\\\"function\\\":2}\");\n   }\n+\n+  public void testIssue1062() {\n+    assertPrintSame(\"3*(4%3*5)\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n     args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n     test(\"function f(p) {\" +\n          \" var x;\" +\n-         \" return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);\" +\n+         \" return ((x=p.id) && (x=parseInt(x.substr(1)))) && x>0;\" +\n          \"}\",\n          \"function f(b) {\" +\n          \" var a;\" +\n-         \" return ((a=b.id) && (a=parseInt(a.substr(1))) && 0<a);\" +\n+         \" return ((a=b.id) && (a=parseInt(a.substr(1)))) && 0<a;\" +\n          \"}\");\n   }\n \n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     CompilerOptions options = createCompilerOptions();\n     options.foldConstants = true;\n     test(options,\n-        \"if (x < 1 || x > 1 || 1 < x || 1 > x) { alert(x) }\",\n-        \"   (1 > x || 1 < x || 1 < x || 1 > x) && alert(x) \");\n+        \"if (((x < 1 || x > 1) || 1 < x) || 1 > x) { alert(x) }\",\n+        \"   (((1 > x || 1 < x) || 1 < x) || 1 > x) && alert(x) \");\n   }\n \n   public void testsyntheticBlockOnDeadAssignments() {\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     test(\"(goog$partial(f))(a)\", \"f(a)\");\n     test(\"(goog$partial(f,a))(b)\", \"f(a,b)\");\n     test(\"(goog$partial(f,a,b))(c)\", \"f(a,b,c)\");\n-\n     // Don't rewrite if the bind isn't the immediate call target\n     testSame(\"(goog$bind(f)).call(g)\");\n   }\n     testSame(\"var a = String({valueOf: function() { return 1; }});\");\n   }\n \n+  public void testAssocitivity() {\n+    test(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n+        \"var a,b,c; (a || b) || c; (a * b) * c; (a | b) | c\");\n+    testSame(\"var a,b,c; a % (b % c); a / (b / c); a - (b - c);\");\n+  }\n+\n   private static class StringCompareTestCase extends CompilerTestCase {\n \n     StringCompareTestCase() {\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n     parse(\"try {} catch (/** @type {Error} */ e) {}\");\n   }\n \n+  public void testParsingAssociativity() {\n+    assertNodeEquality(parse(\"x * y * z\"), parse(\"(x * y) * z\"));\n+    assertNodeEquality(parse(\"x + y + z\"), parse(\"(x + y) + z\"));\n+    assertNodeEquality(parse(\"x | y | z\"), parse(\"(x | y) | z\"));\n+    assertNodeEquality(parse(\"x & y & z\"), parse(\"(x & y) & z\"));\n+    assertNodeEquality(parse(\"x ^ y ^ z\"), parse(\"(x ^ y) ^ z\"));\n+    // TODO(blickly): Fix rhino to parse || and && left-associatively.\n+    assertNodeEquality(parse(\"x || y || z\"), parse(\"x || (y || z)\"));\n+    assertNodeEquality(parse(\"x && y && z\"), parse(\"x && (y && z)\"));\n+  }\n+\n   /**\n    * Verify that the given code has the given parse errors.\n    * @return If in IDE mode, returns a partial tree.", "timestamp": 1377024956, "metainfo": ""}