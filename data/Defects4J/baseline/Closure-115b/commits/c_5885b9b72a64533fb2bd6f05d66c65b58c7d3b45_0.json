{"sha": "5885b9b72a64533fb2bd6f05d66c65b58c7d3b45", "log": "Change on 2010/05/21 by nicksantos          Add a messagebundle to compileroptions.          R=johnlenz         DELTA=65  (53 added, 7 deleted, 5 changed)  Change on 2010/05/21 by johnlenz          Automated g4 rollback of changelist 15608158.          *** Reason for rollback ***            Incorrectly inlines into loops.          *** Original change description ***          Enable flow sensitive inlining in open source world.          R=acleung         DELTA=2  (0 added, 2 deleted, 0 changed)  Change on 2010/05/21 by johnlenz          Automated g4 rollback of changelist 15557333.          *** Reason for rollback ***            Flow sensitive inlining incorrectly inlines into loops.          *** Original change description ***          Automated g4 rollback of changelist 15443639.          *** Reason for rollback ***            Fixed by 15522083          *** Original change description ***          Automated g4 rollback of changelist 15380611.          *** Reason for rollback ***          see attached bug          *** Original change description ***          Enable Flow Sensitive Inlining by default. Passes GMail automation test.          R=acleung         DELTA=1  (0 added, 0 deleted, 1 changed)  Change on 2010/05/21 by acleung          Automated g4 rollback of changelist 15093982.          *** Reason for rollback ***            Because third time is a charm.          *** Original change description ***          Automated g4 rollback of changelist 15093106.          *** Reason for rollback ***          breaks caribou b/c of new warnings.          *** Original change description ***          Make unreachable code detection a bit smarter.          R=johnlenz         DELTA=77  (70 added, 3 deleted, 4 changed)  Change on 2010/05/21 by nicksantos          Create a shortcut mode for the deps file parser, and turn it on         by default.         Also, add tracers to deps generator.          R=agrieve         DELTA=171  (117 added, 44 deleted, 10 changed)  Change on 2010/05/21 by acleung          Make ExtractPrototypeMemberDeclarations skip over devirtualized prototype methods          R=avd         DELTA=80  (80 added, 0 deleted, 0 changed)  Change on 2010/05/21 by robbyw          Attach ScopedAliases to the closurePass flag.          R=nicksantos         DELTA=13  (13 added, 0 deleted, 0 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=11001   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckUnreachableCode.java\n+++ b/src/com/google/javascript/jscomp/CheckUnreachableCode.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Predicate;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.graph.GraphNode;\n import com.google.javascript.jscomp.graph.GraphReachability;\n-import com.google.javascript.jscomp.graph.GraphNode;\n+import com.google.javascript.jscomp.graph.GraphReachability.EdgeTuple;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     this.compiler = compiler;\n     this.level = level;\n   }\n-\n+  \n   @Override\n   public void enterScope(NodeTraversal t) {\n     new GraphReachability<Node, ControlFlowGraph.Branch>(\n-        t.getControlFlowGraph()).compute(\n+        t.getControlFlowGraph(), new ReachablePredicate()).compute(\n             t.getControlFlowGraph().getEntry().getValue());\n   }\n \n     }\n     return true;\n   }\n-\n+  \n   @Override\n   public void exitScope(NodeTraversal t) {\n   }\n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n   }\n-}\n+  \n+  private final class ReachablePredicate implements\n+      Predicate<EdgeTuple<Node, ControlFlowGraph.Branch>> {\n+\n+    @Override\n+    public boolean apply(EdgeTuple<Node, Branch> input) {\n+      Branch branch = input.edge;\n+      if (!branch.isConditional()) {\n+        return true;\n+      }\n+      Node predecessor = input.sourceNode;\n+      Node condition = NodeUtil.getConditionExpression(predecessor);\n+      \n+      // TODO(user): Handle more complicated expression like true == true,\n+      // etc....\n+      if (condition != null && NodeUtil.isImmutableValue(condition)) {\n+        return NodeUtil.getBooleanValue(condition) ==\n+            (branch == Branch.ON_TRUE);\n+      }\n+      return true;\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n     options.optimizeArgumentsArray = true;\n     options.removeUnusedVars = true;\n     options.removeUnusedVarsInGlobalScope = false;\n-    options.flowSensitiveInlineVariables = true;\n \n     // Allows annotations that are not standard.\n     options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,\n     options.labelRenaming = true;\n     options.removeDeadCode = true;\n     options.optimizeArgumentsArray = true;\n-    options.flowSensitiveInlineVariables = true;\n \n     // All the advance optimizations.\n     options.reserveRawExports = true;\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   //--------------------------------\n \n   boolean manageClosureDependencies = false;\n+\n+  /** Returns localized replacement for MSG_* variables */\n+  // Transient so that clients don't have to implement Serializable.\n+  public transient MessageBundle messageBundle = null;\n \n   //--------------------------------\n   // Checks\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   protected List<PassFactory> getChecks() {\n     List<PassFactory> checks = Lists.newArrayList();\n \n+    if (options.closurePass) {\n+      checks.add(closureGoogScopeAliases);\n+    }\n+\n     if (options.nameAnonymousFunctionsOnly) {\n       if (options.anonymousFunctionNaming ==\n           AnonymousFunctionNamingPolicy.MAPPED) {\n     if (options.closurePass) {\n       checks.add(closureReplaceGetCssName);\n     }\n+\n+    // i18n\n+    // If you want to customize the compiler to use a different i18n pass,\n+    // you can create a PassConfig that calls replacePassFactory\n+    // to replace this.\n+    checks.add(options.messageBundle != null ?\n+        replaceMessages : createEmptyPass(\"replaceMessages\"));\n \n     // Defines in code always need to be processed.\n     checks.add(processDefines);\n           exportedNames = pass.getExportedVariableNames();\n         }\n       };\n+    }\n+  };\n+\n+  /**\n+   * The default i18n pass.\n+   * A lot of the options are not configurable, because ReplaceMessages\n+   * has a lot of legacy logic.\n+   */\n+  private final PassFactory replaceMessages =\n+      new PassFactory(\"replaceMessages\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new ReplaceMessages(compiler,\n+          options.messageBundle,\n+          /* warn about message dupes */\n+          true,\n+          /* allow messages with goog.getMsg */\n+          JsMessage.Style.getFromParams(true, false),\n+          /* if we can't find a translation, don't worry about it. */\n+          false);\n+    }\n+  };\n+\n+  /** Applies aliases and inlines goog.scope. */\n+  final PassFactory closureGoogScopeAliases =\n+      new PassFactory(\"processGoogScopeAliases\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ScopedAliases(compiler);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n+++ b/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n       delta = PER_EXTRACTION_INSTANCE_OVERHEAD + PER_PROTOTYPE_MEMBER_DELTA;\n \n       for (Node cur = head.node.getNext(); cur != null; cur = cur.getNext()) {\n+        \n+        // We can skip over any named functions because they have no effect on\n+        // the control flow. In fact, they are lifted to the beginning of the\n+        // block. This happens a lot when devirtualization breaks the whole\n+        // chain.\n+        if (NodeUtil.isFunction(cur)) {\n+          continue;\n+        }\n+        \n         PrototypeMemberDeclaration prototypeMember =\n             PrototypeMemberDeclaration.extractDeclaration(cur);\n         if (prototypeMember == null || !head.isSameClass(prototypeMember)) {\n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n             DiagnosticGroup.forType(TypeCheck.INEXISTENT_PROPERTY)));\n   }\n \n+  /**\n+   * Insert the given pass factory before the factory of the given name.\n+   */\n   final static void addPassFactoryBefore(\n       List<PassFactory> factoryList, PassFactory factory, String passName) {\n+    factoryList.add(\n+        findPassIndexByName(factoryList, passName), factory);\n+  }\n+\n+  /**\n+   * Find a pass factory with the same name as the given one, and replace it.\n+   */\n+  final static void replacePassFactory(\n+      List<PassFactory> factoryList, PassFactory factory) {\n+    factoryList.set(\n+        findPassIndexByName(factoryList, factory.getName()), factory);\n+  }\n+\n+  /**\n+   * Throws an exception if no pass with the given name exists.\n+   */\n+  private static int findPassIndexByName(\n+      List<PassFactory> factoryList, String name) {\n     for (int i = 0; i < factoryList.size(); i++) {\n-      if (factoryList.get(i).getName().equals(passName)) {\n-        factoryList.add(i, factory);\n-        return;\n+      if (factoryList.get(i).getName().equals(name)) {\n+        return i;\n       }\n     }\n \n     throw new IllegalArgumentException(\n-        \"No factory named '\" + passName + \"' in the factory list\");\n+        \"No factory named '\" + name + \"' in the factory list\");\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/SourceFile.java\n+++ b/src/com/google/javascript/jscomp/SourceFile.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Charsets;\n+import com.google.common.io.CharStreams;\n import com.google.common.io.Files;\n \n-import com.google.common.io.CharStreams;\n-import com.google.common.annotations.VisibleForTesting;\n-\n import java.io.File;\n+import java.io.FileReader;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.Reader;\n+import java.io.StringReader;\n import java.nio.charset.Charset;\n \n /**\n     return code;\n   }\n \n+  /**\n+   * Gets a reader for the code in this source file.\n+   */\n+  public Reader getCodeReader() throws IOException {\n+    return new StringReader(getCode());\n+  }\n+\n   @VisibleForTesting\n   String getCodeNoCache() {\n     return code;\n   public void clearCachedSource() {\n     // By default, do nothing.  Not all kinds of SourceFiles can regenerate\n     // code.\n+  }\n+\n+  boolean hasSourceInMemory() {\n+    return code != null;\n   }\n \n   /** Returns a unique name for the source file. */\n       return cachedCode;\n     }\n \n+    /**\n+     * Gets a reader for the code in this source file.\n+     */\n+    public Reader getCodeReader() throws IOException {\n+      if (hasSourceInMemory()) {\n+        return super.getCodeReader();\n+      } else {\n+        // If we haven't pulled the code into memory yet, don't.\n+        return new FileReader(file);\n+      }\n+    }\n+\n     // Flush the cached code after the compile; we can read it off disk\n     // if we need it again.\n     @Override\n--- a/src/com/google/javascript/jscomp/deps/DepsFileParser.java\n+++ b/src/com/google/javascript/jscomp/deps/DepsFileParser.java\n \n package com.google.javascript.jscomp.deps;\n \n+import com.google.common.base.CharMatcher;\n import com.google.common.base.Charsets;\n import com.google.common.collect.Lists;\n import com.google.common.io.Files;\n import com.google.javascript.jscomp.ErrorManager;\n \n import java.io.File;\n+import java.io.FileReader;\n import java.io.IOException;\n+import java.io.Reader;\n import java.io.StringReader;\n import java.util.List;\n import java.util.logging.Level;\n    * @throws IOException Thrown if the file could not be read.\n    */\n   public List<DependencyInfo> parseFile(String filePath) throws IOException {\n-    return parseFile(filePath, Files.toString(new File(filePath), Charsets.UTF_8));\n+    return parseFileReader(filePath, new FileReader(filePath));\n   }\n \n   /**\n    * @return A list of DependencyInfo objects.\n    */\n   public List<DependencyInfo> parseFile(String filePath, String fileContents) {\n+    return parseFileReader(filePath, new StringReader(fileContents));\n+  }\n+\n+\n+  /**\n+   * Parses the file from the given reader and returns a list of\n+   * dependency information that it contained.\n+   *\n+   * @param filePath Path to the file to parse.\n+   * @param reader A reader for the file.\n+   * @return A list of DependencyInfo objects.\n+   */\n+  public List<DependencyInfo> parseFileReader(String filePath, Reader reader) {\n     depInfos = Lists.newArrayList();\n     logger.info(\"Parsing Dep: \" + filePath);\n-    doParse(filePath, new StringReader(fileContents));\n-\n+    doParse(filePath, reader);\n     return depInfos;\n   }\n \n    */\n   @Override\n   protected boolean parseLine(String line) throws ParseException {\n+    boolean hasDependencies = false;\n+\n     // Quick sanity check that will catch most cases. This is a performance\n     // win for people with a lot of JS.\n-    if (line.indexOf(\"addDependency\") == -1) {\n-      return true;\n+    if (line.indexOf(\"addDependency\") != -1) {\n+      depMatcher.reset(line);\n+      // See if the line looks like: goog.addDependency(...)\n+      if (depMatcher.matches()) {\n+        hasDependencies = true;\n+        String addDependencyParams = depMatcher.group(1);\n+        depArgsMatch.reset(addDependencyParams);\n+        // Extract the three parameters.\n+        if (!depArgsMatch.matches()) {\n+          // Although we could recover, we mark this as fatal since there should\n+          // not be problems with generated deps.js files.\n+          throw new ParseException(\"Invalid arguments to goog.addDependency(). Found: \"\n+              + addDependencyParams, true);\n+        }\n+        // Parse the file path.\n+        String path = parseJsString(depArgsMatch.group(1));\n+        DependencyInfo depInfo = new SimpleDependencyInfo(path, filePath,\n+            // Parse the provides.\n+            parseJsStringArray(depArgsMatch.group(2)),\n+            // Parse the requires.\n+            parseJsStringArray(depArgsMatch.group(3)));\n+\n+        if (logger.isLoggable(Level.FINE)) {\n+          logger.fine(\"Found dep: \" + depInfo);\n+        }\n+        depInfos.add(depInfo);\n+      }\n     }\n \n-    depMatcher.reset(line);\n-    // See if the line looks like: goog.addDependency(...)\n-    if (depMatcher.matches()) {\n-      String addDependencyParams = depMatcher.group(1);\n-      depArgsMatch.reset(addDependencyParams);\n-      // Extract the three parameters.\n-      if (!depArgsMatch.matches()) {\n-        // Although we could recover, we mark this as fatal since there should\n-        // not be problems with generated deps.js files.\n-        throw new ParseException(\"Invalid arguments to goog.addDependency(). Found: \"\n-            + addDependencyParams, true);\n-      }\n-      // Parse the file path.\n-      String path = parseJsString(depArgsMatch.group(1));\n-      DependencyInfo depInfo = new SimpleDependencyInfo(path, filePath,\n-          // Parse the provides.\n-          parseJsStringArray(depArgsMatch.group(2)),\n-          // Parse the requires.\n-          parseJsStringArray(depArgsMatch.group(3)));\n-\n-      if (logger.isLoggable(Level.FINE)) {\n-        logger.fine(\"Found dep: \" + depInfo);\n-      }\n-      depInfos.add(depInfo);\n-    }\n-\n-    return true;\n+    return !shortcutMode || hasDependencies ||\n+        CharMatcher.WHITESPACE.matchesAllOf(line);\n   }\n }\n--- a/src/com/google/javascript/jscomp/deps/JsFileLineParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFileLineParser.java\n       \"DEPS_PARSE_WARNING\", \"{0}\\n{1}\");\n   static final DiagnosticType PARSE_ERROR = DiagnosticType.error(\n       \"DEPS_PARSE_ERROR\", \"{0}\\n{1}\");\n+\n+  boolean shortcutMode = false;\n \n   /**\n    * Thrown by base classes to signify a problem parsing a line.\n    */\n   public JsFileLineParser(ErrorManager errorManager) {\n     this.errorManager = errorManager;\n+  }\n+\n+  /**\n+   * In shortcut mode, the file line parser can stop reading early if\n+   * it thinks it found enough information.\n+   *\n+   * For example, many parsers assume that dependency information never\n+   * shows up after \"real\" code.\n+   */\n+  public void setShortcutMode(boolean mode) {\n+    this.shortcutMode = mode;\n   }\n \n   public boolean didParseSucceed() {\n           }\n \n           if (!revisedLine.isEmpty()) {\n-            if (!parseLine(revisedLine)) {\n+            // This check for shortcut mode should be redundant, but\n+            // it's done for safety reasons.\n+            if (!parseLine(revisedLine) && shortcutMode) {\n               break;\n             }\n           }\n--- a/src/com/google/javascript/jscomp/deps/JsFileParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFileParser.java\n   private List<String> provides;\n   private List<String> requires;\n \n-  private boolean shortcutMode = false;\n-\n   /**\n    * Constructor\n    *\n    */\n   public JsFileParser(ErrorManager errorManager) {\n     super(errorManager);\n-  }\n-\n-  public void setShortcutMode(boolean mode) {\n-    this.shortcutMode = mode;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/graph/GraphReachability.java\n+++ b/src/com/google/javascript/jscomp/graph/GraphReachability.java\n package com.google.javascript.jscomp.graph;\n \n import com.google.common.base.Preconditions;\n-import com.google.javascript.jscomp.graph.Annotation;\n-import com.google.javascript.jscomp.graph.DiGraph;\n+import com.google.common.base.Predicate;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n-import com.google.javascript.jscomp.graph.GraphNode;\n \n /**\n  * Computes all the reachable nodes. Upon execution of {@link #compute(Object)},\n   // FixedPointGraphTraversal accepts them.\n   private final DiGraph<N, E> graph;\n \n+  private final Predicate<EdgeTuple<N, E>> edgePredicate;\n+\n   public GraphReachability(DiGraph<N, E> graph) {\n+    this(graph, null);\n+  }\n+\n+  /**\n+   * @param graph The graph.\n+   * @param edgePredicate Given the predecessor P of the a node S and the edge\n+   *      coming from P to S, this predicate should return true if S is\n+   *      reachable from P using the edge.\n+   */\n+  public GraphReachability(DiGraph<N, E> graph,\n+                           Predicate<EdgeTuple<N, E>> edgePredicate) {\n     this.graph = graph;\n+    this.edgePredicate = edgePredicate;\n   }\n \n   public void compute(N entry) {\n \n   @Override\n   public boolean traverseEdge(N source, E e, N destination) {\n-    if (graph.getNode(source).getAnnotation() == REACHABLE) {\n+    if (graph.getNode(source).getAnnotation() == REACHABLE &&\n+        (edgePredicate == null ||\n+            edgePredicate.apply(new EdgeTuple<N, E>(source, e, destination)))) {\n       GraphNode<N, E> destNode = graph.getNode(destination);\n       if (destNode.getAnnotation() != REACHABLE) {\n         destNode.setAnnotation(REACHABLE);\n   }\n \n   public static final Annotation REACHABLE = new Annotation() {};\n+\n+  /**\n+   * Represents Source Node, Edge and Destination Node.\n+   */\n+  public static final class EdgeTuple<N, E> {\n+    public final N sourceNode;\n+    public final E edge;\n+    public final N destNode;\n+    public EdgeTuple(N sourceNode, E edge, N destNode) {\n+      this.sourceNode = sourceNode;\n+      this.edge = edge;\n+      this.destNode = destNode;\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CheckUnreachableCodeTest.java\n+++ b/test/com/google/javascript/jscomp/CheckUnreachableCodeTest.java\n     testSame(\"function f() {try { if (value instanceof type) return true; } \" +\n              \"catch (e) { }}\");\n   }\n-  \n+\n+  public void testFalseCondition() {\n+    assertUnreachable(\"if(false) { }\");\n+    assertUnreachable(\"if(0) { }\");\n+  }\n+\n+  public void testUnreachableLoop() {\n+    assertUnreachable(\"while(false) {}\");\n+  }\n+\n+  public void testInfiniteLoop() {\n+    testSame(\"while (true) { foo(); break; }\");\n+\n+    // TODO(user): Have a infinite loop warning instead.\n+    assertUnreachable(\"while(true) {} foo()\");\n+  }\n+\n   private void assertUnreachable(String js) {\n     test(js, js, CheckUnreachableCode.UNREACHABLE_CODE);\n   }\n--- a/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java\n+++ b/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java\n         \"b.y.f = 1;\" +\n         \"b.y.g = 1;\");\n   }\n+  \n+  public void testWithDevirtualization() {\n+    extract(\n+        \"x.prototype.a = 1;\" +\n+        \"x.prototype.b = 1;\" +\n+        \"function devirtualize1() { }\" +\n+        \"x.prototype.c = 1;\" +\n+        \"x.prototype.d = 1;\" +\n+        \"x.prototype.e = 1;\" +\n+        \"x.prototype.f = 1;\" +\n+        \"x.prototype.g = 1;\",\n+        \n+        loadPrototype(\"x\") +\n+        TMP + \".a = 1;\" +\n+        TMP + \".b = 1;\" +\n+        \"function devirtualize1() { }\" +\n+        TMP + \".c = 1;\" +\n+        TMP + \".d = 1;\" +\n+        TMP + \".e = 1;\" +\n+        TMP + \".f = 1;\" +\n+        TMP + \".g = 1;\");\n+    \n+    extract(\n+        \"x.prototype.a = 1;\" +\n+        \"x.prototype.b = 1;\" +\n+        \"function devirtualize1() { }\" +\n+        \"x.prototype.c = 1;\" +\n+        \"x.prototype.d = 1;\" +\n+        \"function devirtualize2() { }\" +\n+        \"x.prototype.e = 1;\" +\n+        \"x.prototype.f = 1;\" +\n+        \"function devirtualize3() { }\" +\n+        \"x.prototype.g = 1;\",\n+        \n+        loadPrototype(\"x\") +\n+        TMP + \".a = 1;\" +\n+        TMP + \".b = 1;\" +\n+        \"function devirtualize1() { }\" +\n+        TMP + \".c = 1;\" +\n+        TMP + \".d = 1;\" +\n+        \"function devirtualize2() { }\" +\n+        TMP + \".e = 1;\" +\n+        TMP + \".f = 1;\" +\n+        \"function devirtualize3() { }\" +\n+        TMP + \".g = 1;\");\n+  }\n \n   public String loadPrototype(String qName) {\n     return TMP + \" = \" + qName + \".prototype;\";\n--- a/test/com/google/javascript/jscomp/deps/DepsFileParserTest.java\n+++ b/test/com/google/javascript/jscomp/deps/DepsFileParserTest.java\n   private DepsFileParser parser;\n   private ErrorManager errorManager;\n   private static final String SRC_PATH = \"/path/1.js\";\n+  private final List<String> EMPTY = Collections.emptyList();\n \n   @Override\n   public void setUp() {\n     errorManager = new PrintStreamErrorManager(System.err);\n     parser = new DepsFileParser(errorManager);\n+    parser.setShortcutMode(true);\n   }\n \n   /**\n         + \"goog.addDependency(\\\"yes4\\\", [], [ \\\"a\\\",'b' , 'c' ]); //no new line at eof\";\n \n     List<DependencyInfo> result = parser.parseFile(SRC_PATH, CONTENTS);\n-    List<String> EMPTY = Collections.emptyList();\n     ImmutableList<DependencyInfo> EXPECTED = ImmutableList.<DependencyInfo>of(\n         new SimpleDependencyInfo(\"yes1\", SRC_PATH, EMPTY, EMPTY),\n         new SimpleDependencyInfo(\"yes2\", SRC_PATH, EMPTY, EMPTY),\n     assertEquals(1, errorManager.getErrorCount());\n     assertEquals(0, errorManager.getWarningCount());\n   }\n+\n+  public void testShortcutMode() {\n+    List<DependencyInfo> result = parser.parseFile(SRC_PATH,\n+        \"goog.addDependency('yes1', [], []); \\n\" +\n+        \"foo();\\n\" +\n+        \"goog.addDependency('no1', [], []);\");\n+    ImmutableList<DependencyInfo> EXPECTED = ImmutableList.<DependencyInfo>of(\n+        new SimpleDependencyInfo(\"yes1\", SRC_PATH, EMPTY, EMPTY));\n+    assertEquals(EXPECTED, result);\n+  }\n+\n+  public void testNoShortcutMode() {\n+    parser.setShortcutMode(false);\n+    List<DependencyInfo> result = parser.parseFile(SRC_PATH,\n+        \"goog.addDependency('yes1', [], []); \\n\" +\n+        \"foo();\\n\" +\n+        \"goog.addDependency('yes2', [], []);\");\n+    ImmutableList<DependencyInfo> EXPECTED = ImmutableList.<DependencyInfo>of(\n+        new SimpleDependencyInfo(\"yes1\", SRC_PATH, EMPTY, EMPTY),\n+        new SimpleDependencyInfo(\"yes2\", SRC_PATH, EMPTY, EMPTY));\n+    assertEquals(EXPECTED, result);\n+  }\n }", "timestamp": 1274477236, "metainfo": ""}