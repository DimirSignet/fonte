{"sha": "22092ec4cb5af712b9a60f81ec78e2cac2f051b9", "log": "This fixes cases of x == x, which is equivalent to isNaN() for floats or doubles. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=47805426", "commit": "\n--- a/lib/rhino/src/org/mozilla/javascript/IRFactory.java\n+++ b/lib/rhino/src/org/mozilla/javascript/IRFactory.java\n             return ALWAYS_TRUE_BOOLEAN;\n           case Token.NUMBER: {\n             double num = node.getDouble();\n-            if (num == num && num != 0.0) {\n+            if (!Double.isNaN(num) && num != 0.0) {\n                 return ALWAYS_TRUE_BOOLEAN;\n             } else {\n                 return ALWAYS_FALSE_BOOLEAN;\n--- a/lib/rhino/src/org/mozilla/javascript/Interpreter.java\n+++ b/lib/rhino/src/org/mozilla/javascript/Interpreter.java\n             return false;\n         } else if (x == UniqueTag.DOUBLE_MARK) {\n             double d = frame.sDbl[i];\n-            return d == d && d != 0.0;\n+            return !Double.isNaN(d) && d != 0.0;\n         } else if (x == null || x == Undefined.instance) {\n             return false;\n         } else if (x instanceof Number) {\n             double d = ((Number)x).doubleValue();\n-            return (d == d && d != 0.0);\n+            return (!Double.isNaN(d) && d != 0.0);\n         } else if (x instanceof Boolean) {\n             return ((Boolean)x).booleanValue();\n         } else {\n--- a/lib/rhino/src/org/mozilla/javascript/NativeArray.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeArray.java\n     }\n \n     private static long toArrayIndex(double d) {\n-        if (d == d) {\n+        if (!Double.isNaN(d)) {\n             long index = ScriptRuntime.toUint32(d);\n             if (index == d && index != 4294967295L) {\n                 return index;\n--- a/lib/rhino/src/org/mozilla/javascript/NativeDate.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeDate.java\n                 Object tv = ScriptRuntime.toPrimitive(o, ScriptRuntime.NumberClass);\n                 if (tv instanceof Number) {\n                     double d = ((Number) tv).doubleValue();\n-                    if (d != d || Double.isInfinite(d)) {\n+                    if (Double.isNaN(d) || Double.isInfinite(d)) {\n                         return null;\n                     }\n                 }\n           case Id_toString:\n           case Id_toTimeString:\n           case Id_toDateString:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 return date_format(t, id);\n             }\n             return js_NaN_date_str;\n           case Id_toLocaleString:\n           case Id_toLocaleTimeString:\n           case Id_toLocaleDateString:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 return toLocale_helper(t, id);\n             }\n             return js_NaN_date_str;\n \n           case Id_toUTCString:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 return js_toUTCString(t);\n             }\n             return js_NaN_date_str;\n           case Id_getYear:\n           case Id_getFullYear:\n           case Id_getUTCFullYear:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 if (id != Id_getUTCFullYear) t = LocalTime(t);\n                 t = YearFromTime(t);\n                 if (id == Id_getYear) {\n \n           case Id_getMonth:\n           case Id_getUTCMonth:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 if (id == Id_getMonth) t = LocalTime(t);\n                 t = MonthFromTime(t);\n             }\n \n           case Id_getDate:\n           case Id_getUTCDate:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 if (id == Id_getDate) t = LocalTime(t);\n                 t = DateFromTime(t);\n             }\n \n           case Id_getDay:\n           case Id_getUTCDay:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 if (id == Id_getDay) t = LocalTime(t);\n                 t = WeekDay(t);\n             }\n \n           case Id_getHours:\n           case Id_getUTCHours:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 if (id == Id_getHours) t = LocalTime(t);\n                 t = HourFromTime(t);\n             }\n \n           case Id_getMinutes:\n           case Id_getUTCMinutes:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 if (id == Id_getMinutes) t = LocalTime(t);\n                 t = MinFromTime(t);\n             }\n \n           case Id_getSeconds:\n           case Id_getUTCSeconds:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 if (id == Id_getSeconds) t = LocalTime(t);\n                 t = SecFromTime(t);\n             }\n \n           case Id_getMilliseconds:\n           case Id_getUTCMilliseconds:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 if (id == Id_getMilliseconds) t = LocalTime(t);\n                 t = msFromTime(t);\n             }\n             return ScriptRuntime.wrapNumber(t);\n \n           case Id_getTimezoneOffset:\n-            if (t == t) {\n+            if (!Double.isNaN(t)) {\n                 t = (t - LocalTime(t)) / msPerMinute;\n             }\n             return ScriptRuntime.wrapNumber(t);\n             {\n                 double year = ScriptRuntime.toNumber(args, 0);\n \n-                if (year != year || Double.isInfinite(year)) {\n+                if (Double.isNaN(year) || Double.isInfinite(year)) {\n                     t = ScriptRuntime.NaN;\n                 } else {\n-                    if (t != t) {\n+                    if (Double.isNaN(t)) {\n                         t = 0;\n                     } else {\n                         t = LocalTime(t);\n     }\n \n     private String toISOString() {\n-        if (date == date) {\n+        if (!Double.isNaN(date)) {\n             synchronized (isoFormat) {\n                 return isoFormat.format(new Date((long) date));\n             }\n \n     private static double TimeClip(double d)\n     {\n-        if (d != d ||\n+        if (Double.isNaN(d) ||\n             d == Double.POSITIVE_INFINITY ||\n             d == Double.NEGATIVE_INFINITY ||\n             Math.abs(d) > HalfTimeDomain)\n         for (loop = 0; loop < MAXARGS; loop++) {\n             if (loop < args.length) {\n                 d = ScriptRuntime.toNumber(args[loop]);\n-                if (d != d || Double.isInfinite(d)) {\n+                if (Double.isNaN(d) || Double.isInfinite(d)) {\n                     return ScriptRuntime.NaN;\n                 }\n                 array[loop] = ScriptRuntime.toInteger(args[loop]);\n         double result;\n \n         /* just return NaN if the date is already NaN */\n-        if (date != date)\n+        if (Double.isNaN(date))\n             return date;\n \n         /* Satisfy the ECMA rule that if a function is called with\n \n         /* return NaN if date is NaN and we're not setting the year,\n          * If we are, use 0 as the time. */\n-        if (date != date) {\n+        if (Double.isNaN(date)) {\n             if (args.length < 3) {\n                 return ScriptRuntime.NaN;\n             } else {\n--- a/lib/rhino/src/org/mozilla/javascript/NativeGlobal.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeGlobal.java\n                         result = false;\n                     } else {\n                         double d = ScriptRuntime.toNumber(args[0]);\n-                        result = (d == d\n+                        result = (!Double.isNaN(d)\n                                   && d != Double.POSITIVE_INFINITY\n                                   && d != Double.NEGATIVE_INFINITY);\n                     }\n                         result = true;\n                     } else {\n                         double d = ScriptRuntime.toNumber(args[0]);\n-                        result = (d != d);\n+                        result = (Double.isNaN(d));\n                     }\n                     return ScriptRuntime.wrapBoolean(result);\n                 }\n         int mask = URL_XALPHAS | URL_XPALPHAS | URL_PATH;\n         if (args.length > 1) { // the 'mask' argument.  Non-ECMA.\n             double d = ScriptRuntime.toNumber(args[1]);\n-            if (d != d || ((mask = (int) d) != d) ||\n+            if (Double.isNaN(d) || ((mask = (int) d) != d) ||\n                 0 != (mask & ~(URL_XALPHAS | URL_XPALPHAS | URL_PATH)))\n             {\n                 throw Context.reportRuntimeError0(\"msg.bad.esc.mask\");\n--- a/lib/rhino/src/org/mozilla/javascript/NativeJSON.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeJSON.java\n \n         if (value instanceof Number) {\n             double d = ((Number) value).doubleValue();\n-            if (d == d && d != Double.POSITIVE_INFINITY &&\n+            if (!Double.isNaN(d) && d != Double.POSITIVE_INFINITY &&\n                 d != Double.NEGATIVE_INFINITY)\n             {\n                 return ScriptRuntime.toString(value);\n--- a/lib/rhino/src/org/mozilla/javascript/NativeMath.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeMath.java\n             case Id_acos:\n             case Id_asin:\n                 x = ScriptRuntime.toNumber(args, 0);\n-                if (x == x && -1.0 <= x && x <= 1.0) {\n+                if (!Double.isNaN(x) && -1.0 <= x && x <= 1.0) {\n                     x = (methodId == Id_acos) ? Math.acos(x) : Math.asin(x);\n                 } else {\n                     x = Double.NaN;\n                     ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n                 for (int i = 0; i != args.length; ++i) {\n                     double d = ScriptRuntime.toNumber(args[i]);\n-                    if (d != d) {\n+                    if (Double.isNaN(d)) {\n                         x = d; // NaN\n                         break;\n                     }\n \n             case Id_round:\n                 x = ScriptRuntime.toNumber(args, 0);\n-                if (x == x && x != Double.POSITIVE_INFINITY\n+                if (!Double.isNaN(x) && x != Double.POSITIVE_INFINITY\n                     && x != Double.NEGATIVE_INFINITY)\n                 {\n                     // Round only finite x\n     // See Ecma 15.8.2.13\n     private double js_pow(double x, double y) {\n         double result;\n-        if (y != y) {\n+        if (Double.isNaN(y)) {\n             // y is NaN, result is always NaN\n             result = y;\n         } else if (y == 0) {\n             }\n         } else {\n             result = Math.pow(x, y);\n-            if (result != result) {\n+            if (Double.isNaN(result)) {\n                 // Check for broken Java implementations that gives NaN\n                 // when they should return something else\n                 if (y == Double.POSITIVE_INFINITY) {\n--- a/lib/rhino/src/org/mozilla/javascript/NativeString.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeString.java\n         String search = ScriptRuntime.toString(args, 0);\n         double end = ScriptRuntime.toNumber(args, 1);\n \n-        if (end != end || end > target.length())\n+        if (Double.isNaN(end) || end > target.length())\n             end = target.length();\n         else if (end < 0)\n             end = 0;\n--- a/lib/rhino/src/org/mozilla/javascript/ScriptRuntime.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ScriptRuntime.java\n \n     public static Number wrapNumber(double x)\n     {\n-        if (x != x) {\n+        if (Double.isNaN(x)) {\n             return ScriptRuntime.NaNobj;\n         }\n         return new Double(x);\n                 return ((CharSequence) val).length() != 0;\n             if (val instanceof Number) {\n                 double d = ((Number) val).doubleValue();\n-                return (d == d && d != 0.0);\n+                return (!Double.isNaN(d) && d != 0.0);\n             }\n             if (val instanceof Scriptable) {\n                 if (val instanceof ScriptableObject &&\n     }\n \n     public static String numberToString(double d, int base) {\n-        if (d != d)\n+        if (Double.isNaN(d))\n             return \"NaN\";\n         if (d == Double.POSITIVE_INFINITY)\n             return \"Infinity\";\n     // convenience method\n     public static double toInteger(double d) {\n         // if it's NaN\n-        if (d != d)\n+        if (Double.isNaN(d))\n             return +0.0;\n \n         if (d == 0.0 ||\n             return id;\n         }\n \n-        if (d != d\n+        if (Double.isNaN(d)\n             || d == Double.POSITIVE_INFINITY\n             || d == Double.NEGATIVE_INFINITY)\n         {\n             return l & 0xffffffffL;\n         }\n \n-        if (d != d\n+        if (Double.isNaN(d)\n             || d == Double.POSITIVE_INFINITY\n             || d == Double.NEGATIVE_INFINITY)\n         {\n             return (char)i;\n         }\n \n-        if (d != d\n+        if (Double.isNaN(d)\n             || d == Double.POSITIVE_INFINITY\n             || d == Double.NEGATIVE_INFINITY)\n         {\n             }\n             // NaN check\n             double d = ((Number)x).doubleValue();\n-            return d == d;\n+            return !Double.isNaN(d);\n         }\n         if (x == null || x == Undefined.instance) {\n             return false;\n--- a/lib/rhino/src/org/mozilla/javascript/optimizer/Codegen.java\n+++ b/lib/rhino/src/org/mozilla/javascript/optimizer/Codegen.java\n                     \"org/mozilla/javascript/optimizer/OptRuntime\",\n                     \"minusOneObj\", \"Ljava/lang/Double;\");\n \n-        } else if (num != num) {\n+        } else if (Double.isNaN(num)) {\n             cfw.add(ByteCode.GETSTATIC,\n                     \"org/mozilla/javascript/ScriptRuntime\",\n                     \"NaNobj\", \"Ljava/lang/Double;\");\n--- a/lib/rhino/src/org/mozilla/javascript/optimizer/OptRuntime.java\n+++ b/lib/rhino/src/org/mozilla/javascript/optimizer/OptRuntime.java\n             return oneObj;\n         } else if (num == -1.0) {\n             return minusOneObj;\n-        } else if (num != num) {\n+        } else if (Double.isNaN(num)) {\n             return NaNobj;\n         }\n         return new Double(num);", "timestamp": 1370906729, "metainfo": ""}