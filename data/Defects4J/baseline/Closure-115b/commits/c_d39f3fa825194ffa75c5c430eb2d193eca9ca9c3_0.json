{"sha": "d39f3fa825194ffa75c5c430eb2d193eca9ca9c3", "log": "Automated g4 rollback.  *** Reason for rollback ***  The underlying bugs in DisambiguateProperties were fixed separately.  *** Original change description ***  Automated g4 rollback.  *** Reason for rollback ***  breaks disambiugateproperties  *** Original change description ***  The infimum() relation on enum types is deeply disturbing, because now you can have subsets of enums. wow.  R=johnlenz DELTA=161  (149 added, 4 deleted, 8 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2683   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n     return primitiveType;\n   }\n \n+  /**\n+   * Returns the infimum of a enum element type and another type, or null\n+   * if the infimum is empty.\n+   *\n+   * This can be a little bit weird. For example, suppose you have an enum\n+   * of {(string|number)}, and you want the greatest subtype of the enum\n+   * and a {number}.\n+   *\n+   * The infimum is non-empty. But at the same time, we don't really have\n+   * a name for this infimum. It's equivalent to \"elements of this enum that\n+   * are numbers\".\n+   *\n+   * The best we can do is make up a new type. This is similar to what\n+   * we do in UnionType#meet, which kind-of-sort-of makes sense, because\n+   * an EnumElementType is a union of instances of a type.\n+   */\n+  JSType meet(JSType that) {\n+    JSType meetPrimitive = primitiveType.getGreatestSubtype(that);\n+    if (meetPrimitive.isEmptyType()) {\n+      return null;\n+    } else {\n+      return new EnumElementType(registry, meetPrimitive, name);\n+    }\n+  }\n+\n   @Override\n   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n     primitiveType = primitiveType.resolve(t, scope);\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n       return ((UnionType) thisType).meet(thatType);\n     } else if (thatType.isUnionType()) {\n       return ((UnionType) thatType).meet(thisType);\n-    } else if (thisType.isObject() && thatType.isObject()) {\n+    }\n+\n+    if (thisType instanceof EnumElementType) {\n+      JSType inf = ((EnumElementType) thisType).meet(thatType);\n+      if (inf != null) {\n+        return inf;\n+      }\n+    } else if (thatType instanceof EnumElementType) {\n+      JSType inf = ((EnumElementType) thatType).meet(thisType);\n+      if (inf != null) {\n+        return inf;\n+      }\n+    }\n+\n+    if (thisType.isObject() && thatType.isObject()) {\n       return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     }\n     return thisType.getNativeType(JSTypeNative.NO_TYPE);\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n     }\n \n     // other prototype based objects\n-    if (that != null) {\n-      if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n-        // If unsure, say 'yes', to avoid spurious warnings.\n-        // TODO(user): resolve the prototype chain completely in all cases,\n-        // to avoid guessing.\n-        return true;\n-      }\n-      return this.isImplicitPrototype(thatObj);\n-    }\n-\n-    return false;\n+    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n+      // If unsure, say 'yes', to avoid spurious warnings.\n+      // TODO(user): resolve the prototype chain completely in all cases,\n+      // to avoid guessing.\n+      return true;\n+    }\n+    return this.isImplicitPrototype(thatObj);\n   }\n \n   private boolean implicitPrototypeChainIsUnknown() {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"inconsistent return type\\n\" +\n         \"found   : MyEnum.<number>\\n\" +\n         \"required: string\");\n+  }\n+\n+  public void testEnum42() throws Exception {\n+    testTypes(\n+        \"/** @param {number} x */ function f(x) {}\" +\n+        \"/** @enum {Object} */ var MyEnum = {FOO: {newProperty: 1, b: 2}};\" +\n+        \"f(MyEnum.FOO.newProperty);\");\n   }\n \n   public void testAliasedEnum1() throws Exception {\n--- /dev/null\n+++ b/test/com/google/javascript/rhino/jstype/EnumElementTypeTest.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+\n+\n+/**\n+ * Tests for EnumElementTypes.\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class EnumElementTypeTest extends BaseJSTypeTestCase {\n+  public void testSubtypeRelation() throws Exception {\n+    EnumElementType typeA = registry.createEnumType(\n+        \"typeA\", NUMBER_TYPE).getElementsType();\n+    EnumElementType typeB = registry.createEnumType(\n+        \"typeB\", NUMBER_TYPE).getElementsType();\n+\n+    assertFalse(typeA.isSubtype(typeB));\n+    assertFalse(typeB.isSubtype(typeA));\n+\n+    assertFalse(NUMBER_TYPE.isSubtype(typeB));\n+    assertFalse(NUMBER_TYPE.isSubtype(typeA));\n+\n+    assertTrue(typeA.isSubtype(NUMBER_TYPE));\n+    assertTrue(typeB.isSubtype(NUMBER_TYPE));\n+  }\n+\n+  public void testMeet() throws Exception {\n+    EnumElementType typeA = registry.createEnumType(\n+        \"typeA\", createUnionType(NUMBER_TYPE, STRING_TYPE)).getElementsType();\n+\n+    JSType stringsOfA = typeA.getGreatestSubtype(STRING_TYPE);\n+    assertFalse(stringsOfA.isEmptyType());\n+    assertEquals(\"typeA.<string>\", stringsOfA.toString());\n+    assertTrue(stringsOfA.isSubtype(typeA));\n+\n+    JSType numbersOfA = NUMBER_TYPE.getGreatestSubtype(typeA);\n+    assertFalse(numbersOfA.isEmptyType());\n+    assertEquals(\"typeA.<number>\", numbersOfA.toString());\n+    assertTrue(numbersOfA.isSubtype(typeA));\n+  }\n+}\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     verifySubtypeChain(typeChain);\n   }\n \n+  public void testAnonymousObjectChain() throws Exception {\n+    List<JSType> typeChain = Lists.newArrayList(\n+        ALL_TYPE,\n+        createNullableType(OBJECT_TYPE),\n+        OBJECT_TYPE,\n+        registry.createAnonymousObjectType(),\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n+  public void testAnonymousEnumElementChain() throws Exception {\n+    ObjectType enumElemType = registry.createEnumType(\n+        \"typeB\", registry.createAnonymousObjectType()).getElementsType();\n+    List<JSType> typeChain = Lists.newArrayList(\n+        ALL_TYPE,\n+        createNullableType(OBJECT_TYPE),\n+        OBJECT_TYPE,\n+        enumElemType,\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n   /**\n    * Tests that the given chain of types has a total ordering defined\n    * by the subtype relationship, with types at the top of the lattice", "timestamp": 1311186561, "metainfo": ""}