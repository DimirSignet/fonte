{"sha": "a7f99cbb3ba646de8e19f0248099dad9cf0432a6", "log": "Alternate proposal for handling IIFEs Fixes issue 61  R=dimvar DELTA=243  (149 added, 31 deleted, 63 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5594   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n         }\n         @Override\n         public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n-          makeTypeInference(compiler).inferTypes(scriptRoot);\n+          makeTypeInference(compiler).inferAllScopes(scriptRoot);\n         }\n       };\n     }\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n  */\n \n package com.google.javascript.jscomp;\n-\n-import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS;\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n   private final int depth;\n   private final Node rootNode;\n \n-  /** The type of {@code this} in the current scope. */\n-  private final ObjectType thisType;\n-\n   /** Whether this is a bottom scope for the purposes of type inference. */\n   private final boolean isBottom;\n \n \n     this.parent = parent;\n     this.rootNode = rootNode;\n-    JSType nodeType = rootNode.getJSType();\n-    if (nodeType != null && nodeType.isFunctionType()) {\n-      thisType = nodeType.toMaybeFunctionType().getTypeOfThis();\n-    } else {\n-      thisType = parent.thisType;\n-    }\n     this.isBottom = false;\n     this.depth = parent.depth + 1;\n   }\n \n-\n-  /**\n-   * Creates a global Scope.\n-   * @param rootNode  Typically the global BLOCK node.\n-   */\n-  Scope(Node rootNode, AbstractCompiler compiler) {\n+  /**\n+   * Creates a empty Scope (bottom of the lattice).\n+   * @param rootNode Typically a FUNCTION node or the global BLOCK node.\n+   * @param isBottom Whether this is the bottom of a lattice. Otherwise,\n+   *     it must be a global scope.\n+   */\n+  private Scope(Node rootNode, boolean isBottom) {\n     this.parent = null;\n     this.rootNode = rootNode;\n-    thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n-    this.isBottom = false;\n+    this.isBottom = isBottom;\n     this.depth = 0;\n   }\n \n-  /**\n-   * Creates a empty Scope (bottom of the lattice).\n-   * @param rootNode Typically a FUNCTION node or the global BLOCK node.\n-   * @param thisType the type of {@code this} in this scope\n-   */\n-  Scope(Node rootNode, ObjectType thisType) {\n-    this.parent = null;\n-    this.rootNode = rootNode;\n-    this.thisType = thisType;\n-    this.isBottom = true;\n-    this.depth = 0;\n+  static Scope createGlobalScope(Node rootNode) {\n+    return new Scope(rootNode, false);\n+  }\n+\n+  static Scope createLatticeBottom(Node rootNode) {\n+    return new Scope(rootNode, true);\n   }\n \n   /** The depth of the scope. The global scope has depth 0. */\n    */\n   @Override\n   public ObjectType getTypeOfThis() {\n-    return thisType;\n+    if (isGlobal()) {\n+      return ObjectType.cast(rootNode.getJSType());\n+    }\n+\n+    Preconditions.checkState(rootNode.isFunction());\n+    JSType nodeType = rootNode.getJSType();\n+    if (nodeType != null && nodeType.isFunctionType()) {\n+      return nodeType.toMaybeFunctionType().getTypeOfThis();\n+    } else {\n+      return parent.getTypeOfThis();\n+    }\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n   public Scope createScope(Node n, Scope parent) {\n     inputId = null;\n     if (parent == null) {\n-      scope = new Scope(n, compiler);\n+      scope = Scope.createGlobalScope(n);\n     } else {\n       scope = new Scope(parent, n);\n     }\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n   private final JSTypeRegistry typeRegistry;\n   private Scope topScope;\n \n-  private ScopeCreator scopeCreator;\n+  private MemoizedScopeCreator scopeCreator;\n \n   private final CheckLevel reportMissingOverride;\n   private final CheckLevel reportUnknownTypes;\n       ReverseAbstractInterpreter reverseInterpreter,\n       JSTypeRegistry typeRegistry,\n       Scope topScope,\n-      ScopeCreator scopeCreator,\n+      MemoizedScopeCreator scopeCreator,\n       CheckLevel reportMissingOverride,\n       CheckLevel reportUnknownTypes) {\n     this.compiler = compiler;\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n   private final FlowScope bottomScope;\n   private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n \n+  // For convenience\n+  private final ObjectType unknownType;\n+\n   TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                 ReverseAbstractInterpreter reverseInterpreter,\n                 Scope functionScope,\n     this.compiler = compiler;\n     this.registry = compiler.getTypeRegistry();\n     this.reverseInterpreter = reverseInterpreter;\n+    this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE);\n+\n     this.syntacticScope = functionScope;\n+    inferArguments(functionScope);\n+\n     this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n     this.assertionFunctionsMap = assertionFunctionsMap;\n \n     }\n \n     this.bottomScope = LinkedFlowScope.createEntryLattice(\n-        new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis()));\n+        Scope.createLatticeBottom(functionScope.getRootNode()));\n+  }\n+\n+  /**\n+   * Infers all of a function's arguments if their types aren't declared.\n+   */\n+  private void inferArguments(Scope functionScope) {\n+    Node functionNode = functionScope.getRootNode();\n+    Node astParameters = functionNode.getFirstChild().getNext();\n+    FunctionType functionType =\n+        JSType.toMaybeFunctionType(functionNode.getJSType());\n+    if (functionType != null) {\n+      Node parameterTypes = functionType.getParametersNode();\n+      if (parameterTypes != null) {\n+        Node parameterTypeNode = parameterTypes.getFirstChild();\n+        for (Node astParameter : astParameters.children()) {\n+          if (parameterTypeNode == null) {\n+            return;\n+          }\n+\n+          Var var = functionScope.getVar(astParameter.getString());\n+          Preconditions.checkNotNull(var);\n+          if (var.isTypeInferred() &&\n+              var.getType() == unknownType &&\n+              parameterTypeNode.getJSType() != null) {\n+            JSType newType = parameterTypeNode.getJSType();\n+            var.setType(newType);\n+            astParameter.setJSType(newType);\n+          }\n+\n+          parameterTypeNode = parameterTypeNode.getNext();\n+        }\n+      }\n+    }\n   }\n \n   @Override\n         String qualifiedName = left.getQualifiedName();\n         if (qualifiedName != null) {\n           scope.inferQualifiedSlot(left, qualifiedName,\n-              leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType,\n+              leftType == null ? unknownType : leftType,\n               resultType);\n         }\n \n         if (!unflowable && !nonLocalInferredSlot) {\n           type = var.getType();\n           if (type == null) {\n-            type = getNativeType(UNKNOWN_TYPE);\n+            type = unknownType;\n           }\n         }\n       }\n         JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(\n             name, rawValueType);\n         if (valueType == null) {\n-          valueType = getNativeType(UNKNOWN_TYPE);\n+          valueType = unknownType;\n         }\n         objectType.defineInferredProperty(memberName, valueType, name);\n \n           }\n \n           scope.inferQualifiedSlot(name, qKeyName,\n-              oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType,\n+              oldType == null ? unknownType : oldType,\n               valueType);\n         }\n       } else {\n-        n.setJSType(getNativeType(UNKNOWN_TYPE));\n+        n.setJSType(unknownType);\n       }\n     }\n     return scope;\n     JSType leftType = left.getJSType();\n     JSType rightType = right.getJSType();\n \n-    JSType type = getNativeType(UNKNOWN_TYPE);\n+    JSType type = unknownType;\n     if (leftType != null && rightType != null) {\n       boolean leftIsUnknown = leftType.isUnknownType();\n       boolean rightIsUnknown = rightType.isUnknownType();\n       if (leftIsUnknown && rightIsUnknown) {\n-        type = getNativeType(UNKNOWN_TYPE);\n+        type = unknownType;\n       } else if ((!leftIsUnknown && leftType.isString()) ||\n                  (!rightIsUnknown && rightType.isString())) {\n         type = getNativeType(STRING_TYPE);\n       } else if (leftIsUnknown || rightIsUnknown) {\n-        type = getNativeType(UNKNOWN_TYPE);\n+        type = unknownType;\n       } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) {\n         type = getNativeType(NUMBER_TYPE);\n       } else {\n             iArgumentType.isFunctionType() &&\n             iArgument.getJSDocInfo() == null) {\n           iArgument.setJSType(restrictedParameter);\n-          iArgument.putBooleanProp(Node.INFERRED_FUNCTION, true);\n         }\n       }\n       i++;\n     if (constructorType != null) {\n       constructorType = constructorType.restrictByNotNullOrUndefined();\n       if (constructorType.isUnknownType()) {\n-        type = getNativeType(UNKNOWN_TYPE);\n+        type = unknownType;\n       } else {\n         FunctionType ct = constructorType.toMaybeFunctionType();\n         if (ct == null && constructorType instanceof FunctionType) {\n     // 2) A globally declared qualified name (which is in the FlowScope)\n     // 3) A property on the owner type (which is on objType)\n     // 4) A name in the type registry (as a last resort)\n-    JSType unknownType = getNativeType(UNKNOWN_TYPE);\n     JSType propertyType = null;\n     boolean isLocallyInferred = false;\n \n     }\n \n     if (propertyType == null) {\n-      return getNativeType(UNKNOWN_TYPE);\n+      return unknownType;\n     } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) {\n       // If the type has been checked in this scope,\n       // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n       // halting the compilation but we should log this and analyze to track\n       // down why it happens. This is not critical and will be resolved over\n       // time as the type checker is extended.\n-      return getNativeType(UNKNOWN_TYPE);\n+      return unknownType;\n     } else {\n       return jsType;\n     }\n--- a/src/com/google/javascript/jscomp/TypeInferencePass.java\n+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java\n   private final AbstractCompiler compiler;\n   private final ReverseAbstractInterpreter reverseInterpreter;\n   private Scope topScope;\n-  private ScopeCreator scopeCreator;\n+  private MemoizedScopeCreator scopeCreator;\n   private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n \n   TypeInferencePass(AbstractCompiler compiler,\n       ReverseAbstractInterpreter reverseInterpreter,\n-      Scope topScope, ScopeCreator scopeCreator) {\n+      Scope topScope, MemoizedScopeCreator scopeCreator) {\n     this.compiler = compiler;\n     this.reverseInterpreter = reverseInterpreter;\n     this.topScope = topScope;\n     Preconditions.checkState(\n         externsRoot == null || externsAndJs.hasChild(externsRoot));\n \n-    inferTypes(externsAndJs);\n+    inferAllScopes(externsAndJs);\n   }\n \n   /** Entry point for type inference when running over part of the tree. */\n-  void inferTypes(Node node) {\n-    NodeTraversal inferTypes = new NodeTraversal(\n-        compiler, new TypeInferringCallback(), scopeCreator);\n-    inferTypes.traverseWithScope(node, topScope);\n+  void inferAllScopes(Node node) {\n+    // Type analysis happens in two major phases.\n+    // 1) Finding all the symbols.\n+    // 2) Propagating all the inferred types.\n+    //\n+    // The order of this analysis is non-obvious. In a complete inference\n+    // system, we may need to backtrack arbitrarily far. But the compile-time\n+    // costs would be unacceptable.\n+    //\n+    // We do one pass where we do typed scope creation for all scopes\n+    // in pre-order.\n+    //\n+    // Then we do a second pass where we do all type inference\n+    // (type propagation) in pre-order.\n+    //\n+    // We use a memoized scope creator so that we never create a scope\n+    // more than once.\n+    //\n+    // This will allow us to handle cases like:\n+    // var ns = {};\n+    // (function() { /** JSDoc */ ns.method = function() {}; })();\n+    // ns.method();\n+    // In this code, we need to build the symbol table for the inner scope in\n+    // order to propagate the type of ns.method in the outer scope.\n+    (new NodeTraversal(\n+        compiler, new FirstScopeBuildingCallback(), scopeCreator))\n+        .traverseWithScope(node, topScope);\n+    (new NodeTraversal(\n+        compiler, new SecondScopeBuildingCallback(), scopeCreator))\n+        .traverseWithScope(node, topScope);\n   }\n \n-  void inferTypes(NodeTraversal t, Node n, Scope scope) {\n+  void inferScope(Node n, Scope scope) {\n     TypeInference typeInference =\n         new TypeInference(\n             compiler, computeCfg(n), reverseInterpreter, scope,\n       compiler.getTypeRegistry().resolveTypesInScope(scope);\n \n     } catch (DataFlowAnalysis.MaxIterationsExceededException e) {\n-      compiler.report(t.makeError(n, DATAFLOW_ERROR));\n+      compiler.report(JSError.make(n.getSourceFileName(), n, DATAFLOW_ERROR));\n     }\n   }\n \n-  private class TypeInferringCallback extends AbstractScopedCallback {\n+  private class FirstScopeBuildingCallback extends AbstractScopedCallback {\n     @Override\n     public void enterScope(NodeTraversal t) {\n-      inferTypes(t, t.getCurrentNode(), t.getScope());\n+      t.getScope();\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      // Do nothing\n+    }\n+  }\n+\n+  private class SecondScopeBuildingCallback extends AbstractScopedCallback {\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      inferScope(t.getScope().getRootNode(), t.getScope());\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n   private final Map<Node, AstFunctionContents> functionAnalysisResults =\n       Maps.newHashMap();\n \n+  // For convenience\n+  private final ObjectType unknownType;\n+\n   /**\n    * Defer attachment of types to nodes until all type names\n    * have been resolved. Then, we can resolve the type and attach it.\n     this.codingConvention = codingConvention;\n     this.typeRegistry = compiler.getTypeRegistry();\n     this.typeParsingErrorReporter = typeRegistry.getErrorReporter();\n+    this.unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n   }\n \n   /**\n     Scope newScope = null;\n     AbstractScopeBuilder scopeBuilder = null;\n     if (parent == null) {\n+      JSType globalThis =\n+          typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n+\n+      // Mark the main root, the externs root, and the src root\n+      // with the global this type.\n+      root.setJSType(globalThis);\n+      root.getFirstChild().setJSType(globalThis);\n+      root.getLastChild().setJSType(globalThis);\n+\n       // Run a first-order analysis over the syntax tree.\n       (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))\n           .process(root.getFirstChild(), root.getLastChild());\n     NodeTraversal.traverse(\n         compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));\n \n-    Scope s = new Scope(root, compiler);\n+    Scope s = Scope.createGlobalScope(root);\n     declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n     declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);\n     declareNativeFunctionType(s, DATE_FUNCTION_TYPE);\n         } else {\n           type = lendsVar.getType();\n           if (type == null) {\n-            type = typeRegistry.getNativeType(UNKNOWN_TYPE);\n+            type = unknownType;\n           }\n           if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n             compiler.report(\n       JSType type = getDeclaredType(sourceName, info, name, value);\n       if (type == null) {\n         // The variable's type will be inferred.\n-        type = name.isFromExterns() ?\n-            getNativeType(UNKNOWN_TYPE) : null;\n+        type = name.isFromExterns() ? unknownType : null;\n       }\n       defineSlot(name, var, type);\n     }\n             }\n           }\n \n-          FunctionType overriddenPropType = null;\n+          FunctionType overriddenType = null;\n           if (ownerType != null && propName != null) {\n-            overriddenPropType =\n-                findOverriddenFunction(ownerType, propName);\n+            overriddenType = findOverriddenFunction(ownerType, propName);\n           }\n \n           FunctionTypeBuilder builder =\n               new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                   scope)\n               .setContents(getFunctionAnalysisResults(fnRoot))\n-              .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n+              .inferFromOverriddenFunction(overriddenType, parametersNode)\n               .inferTemplateTypeName(info)\n               .inferReturnType(info)\n               .inferInheritance(info);\n         // If we see a stub property, make sure to register this property\n         // in the type registry.\n         ObjectType ownerType = getObjectSlot(ownerName);\n-        ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n         defineSlot(n, parent, unknownType, true);\n \n         if (ownerType != null &&\n       // TODO(nicksantos|user): This is a terrible, terrible hack\n       // to bail out on recursive typedefs. We'll eventually need\n       // to handle these properly.\n-      typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));\n+      typeRegistry.declareType(typedef, unknownType);\n \n       JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n       if (realType == null) {\n     private void declareArguments(Node functionNode) {\n       Node astParameters = functionNode.getFirstChild().getNext();\n       Node body = astParameters.getNext();\n-      boolean isFnTypeInferred = functionNode.getBooleanProp(\n-          Node.INFERRED_FUNCTION);\n       FunctionType functionType =\n           JSType.toMaybeFunctionType(functionNode.getJSType());\n       if (functionType != null) {\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n+            JSType paramType = jsDocParameter == null ?\n+                unknownType : jsDocParameter.getJSType();\n+            if (paramType == null) {\n+              paramType = unknownType;\n+            }\n+\n+            defineSlot(astParameter, functionNode, paramType,\n+                // inferred iff this is the unknown type.\n+                unknownType == paramType);\n             if (jsDocParameter != null) {\n-              defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), isFnTypeInferred);\n               jsDocParameter = jsDocParameter.getNext();\n-            } else {\n-              defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n         }\n--- a/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n+++ b/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.ObjectType;\n \n import junit.framework.TestCase;\n \n       Lists.newArrayList(INPUT1, INPUT2, INPUT3), Lists.newArrayList(EXTERN1));\n   private final Map<Var, ReferenceCollection> globalMap = Maps.newHashMap();\n   private final Node root = new Node(Token.BLOCK);\n-  private final Scope globalScope = new Scope(root, (ObjectType) null);\n+  private final Scope globalScope = Scope.createGlobalScope(root);\n   private Node scriptRoot = new Node(Token.SCRIPT);\n \n   // In the initial setUp we have 3 references to var1 (one in each input) and\n   }\n \n   public void testUpdateReferencesWithGlobalScope() {\n-    Scope newGlobalScope = new Scope(root, (ObjectType) null);\n+    Scope newGlobalScope = Scope.createGlobalScope(root);\n     map.updateReferencesWithGlobalScope(newGlobalScope);\n     ReferenceCollection references =\n         map.getReferences(globalScope.getVar(VAR1));\n--- a/test/com/google/javascript/jscomp/InferJSDocInfoTest.java\n+++ b/test/com/google/javascript/jscomp/InferJSDocInfoTest.java\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n-import com.google.javascript.jscomp.ScopeCreator;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n     return new CompilerPass() {\n       @Override\n       public void process(Node externs, Node root) {\n-        ScopeCreator scopeCreator =\n+        MemoizedScopeCreator scopeCreator =\n             new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n         Scope topScope = scopeCreator.createScope(root.getParent(), null);\n         (new TypeInferencePass(\n--- a/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java\n+++ b/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java\n   public void setUp() throws Exception {\n     super.setUp();\n \n-    globalScope = new Scope(blockNode, compiler);\n+    globalScope = Scope.createGlobalScope(blockNode);\n     globalScope.declare(\"globalA\", null, null, null);\n     globalScope.declare(\"globalB\", null, null, null);\n \n--- a/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n     script.setInputId(new InputId(\"test\"));\n     assertEquals(0, compiler.getErrorCount());\n     Scope scope = new SyntacticScopeCreator(compiler).createScope(\n-        n, new Scope(script, compiler));\n+        n, Scope.createGlobalScope(script));\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     cfa.process(null, n);\n     ControlFlowGraph<Node> cfg = cfa.getCfg();\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n   public void testTypeCheckStandaloneAST() throws Exception {\n     Node n = compiler.parseTestCode(\"function Foo() { }\");\n     typeCheck(n);\n-    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);\n+    MemoizedScopeCreator scopeCreator =\n+        new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n     Scope topScope = scopeCreator.createScope(n, null);\n \n     Node second = compiler.parseTestCode(\"new Foo\");\n--- a/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java\n+++ b/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java\n   }\n \n   public FlowScope newScope() {\n-    Scope globalScope = new Scope(new Node(Token.EMPTY), compiler);\n+    Scope globalScope = Scope.createGlobalScope(new Node(Token.EMPTY));\n     functionScope = new Scope(globalScope, new Node(Token.EMPTY));\n     return LinkedFlowScope.createEntryLattice(functionScope);\n   }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"initializing variable\\n\" +\n         \"found   : Boolean\\n\" +\n         \"required: boolean\");\n+  }\n+\n+  public void testIssue61() throws Exception {\n+    testTypes(\n+        \"var ns = {};\" +\n+        \"(function() {\" +\n+        \"  /** @param {string} b */\" +\n+        \"  ns.a = function(b) {};\" +\n+        \"})();\" +\n+        \"function d() {\" +\n+        \"  ns.a(123);\" +\n+        \"}\",\n+        \"actual parameter 1 of ns.a does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testIssue61b() throws Exception {\n+    testTypes(\n+        \"var ns = {};\" +\n+        \"(function() {\" +\n+        \"  /** @param {string} b */\" +\n+        \"  ns.a = function(b) {};\" +\n+        \"})();\" +\n+        \"ns.a(123);\",\n+        \"actual parameter 1 of ns.a does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n   }\n \n   public void testIssue86() throws Exception {\n \n   public void testQualifiedNameInference6() throws Exception {\n     testTypes(\n-        \"var ns = {}; \" +\n+        \"/** @const */ var ns = {}; \" +\n         \"/** @param {number} x */ ns.foo = function(x) {};\" +\n         \"(function() { \" +\n         \"    ns.foo = function(x) {};\" +\n-        \"    ns.foo(true); })();\",\n+        \"    ns.foo(true); \" +\n+        \"})();\",\n         \"actual parameter 1 of ns.foo does not match formal parameter\\n\" +\n         \"found   : boolean\\n\" +\n         \"required: number\");\n   }\n \n   public void testQualifiedNameInference8() throws Exception {\n-    testTypes(\n+    // We may need to reshuffle name resolution order so that the @param\n+    // type resolves correctly.\n+    testClosureTypesMultipleWarnings(\n         \"var ns = {}; \" +\n         \"(function() { \" +\n         \"  /** @constructor \\n * @param {number} x */ \" +\n         \"})();\" +\n         \"/** @param {ns.Foo} x */ function f(x) {}\" +\n         \"f(new ns.Foo(true));\",\n-        \"Bad type annotation. Unknown type ns.Foo\");\n+        Lists.newArrayList(\n+            \"Bad type annotation. Unknown type ns.Foo\",\n+            \"actual parameter 1 of ns.Foo does not match formal parameter\\n\" +\n+            \"found   : boolean\\n\" +\n+            \"required: number\"));\n   }\n \n   public void testQualifiedNameInference9() throws Exception {\n   public void testTypeCheckStandaloneAST() throws Exception {\n     Node n = compiler.parseTestCode(\"function Foo() { }\");\n     typeCheck(n);\n-    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);\n+    MemoizedScopeCreator scopeCreator = new MemoizedScopeCreator(\n+        new TypedScopeCreator(compiler));\n     Scope topScope = scopeCreator.createScope(n, null);\n \n     Node second = compiler.parseTestCode(\"new Foo\");\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.jscomp.Scope.Var;\n-import com.google.javascript.jscomp.ScopeCreator;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.EnumType;\n     return new CompilerPass() {\n       @Override\n       public void process(Node externs, Node root) {\n-        ScopeCreator scopeCreator =\n+        MemoizedScopeCreator scopeCreator =\n             new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n         Scope topScope = scopeCreator.createScope(root.getParent(), null);\n         (new TypeInferencePass(", "timestamp": 1349374699, "metainfo": ""}