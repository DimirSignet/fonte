{"sha": "733106a944368f9f4e152d9d27066574fe33906b", "log": "Clean up the comparison functions to use ternaries properly.  R=johnlenz DELTA=149  (16 added, 56 deleted, 77 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5815   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n    */\n   @SuppressWarnings(\"fallthrough\")\n   private Node tryFoldComparison(Node n, Node left, Node right) {\n+    TernaryValue result = evaluateComparison(n.getType(), left, right);\n+    if (result == TernaryValue.UNKNOWN) {\n+      return n;\n+    }\n+\n+    Node newNode = NodeUtil.booleanNode(result.toBoolean(true));\n+    n.getParent().replaceChild(n, newNode);\n+    reportCodeChange();\n+\n+    return newNode;\n+  }\n+\n+  static TernaryValue evaluateComparison(int op, Node left, Node right) {\n     boolean leftLiteral = NodeUtil.isLiteralValue(left, true);\n     boolean rightLiteral = NodeUtil.isLiteralValue(right, true);\n \n     if (!leftLiteral || !rightLiteral) {\n       // We only handle literal operands for LT and GT.\n-      if (n.getType() != Token.GT && n.getType() != Token.LT) {\n-        return n;\n-      }\n-    }\n-\n-    int op = n.getType();\n-    boolean result;\n+      if (op != Token.GT && op != Token.LT) {\n+        return TernaryValue.UNKNOWN;\n+      }\n+    }\n \n     boolean undefinedRight = NodeUtil.isUndefined(right) && rightLiteral;\n     boolean nullRight = right.isNull();\n     switch (lhType) {\n       case Token.VOID:\n         if (!leftLiteral) {\n-          return n;\n+          return TernaryValue.UNKNOWN;\n         } else if (!rightLiteral) {\n-          return n;\n+          return TernaryValue.UNKNOWN;\n         } else {\n-          result = compareToUndefined(right, op);\n-        }\n-        break;\n+          return TernaryValue.forBoolean(compareToUndefined(right, op));\n+        }\n+\n       case Token.NULL:\n         if (rightLiteral && isEqualityOp(op)) {\n-          result = compareToNull(right, op);\n-          break;\n+          return TernaryValue.forBoolean(compareToNull(right, op));\n         }\n         // fallthrough\n       case Token.TRUE:\n       case Token.FALSE:\n         if (undefinedRight) {\n-          result = compareToUndefined(left, op);\n-          break;\n+          return TernaryValue.forBoolean(compareToUndefined(left, op));\n         }\n         if (rhType != Token.TRUE &&\n             rhType != Token.FALSE &&\n             rhType != Token.NULL) {\n-          return n;\n+          return TernaryValue.UNKNOWN;\n         }\n         switch (op) {\n           case Token.SHEQ:\n           case Token.EQ:\n-            result = lhType == rhType;\n-            break;\n+            return TernaryValue.forBoolean(lhType == rhType);\n \n           case Token.SHNE:\n           case Token.NE:\n-            result = lhType != rhType;\n-            break;\n+            return TernaryValue.forBoolean(lhType != rhType);\n \n           case Token.GE:\n           case Token.LE:\n           case Token.GT:\n           case Token.LT:\n-            Boolean compareResult = compareAsNumbers(op, left, right);\n-            if (compareResult != null) {\n-              result = compareResult;\n-            } else {\n-              return n;\n-            }\n-            break;\n-\n-          default:\n-            return n;  // we only handle == and != here\n-        }\n-        break;\n+            return compareAsNumbers(op, left, right);\n+        }\n+        return TernaryValue.UNKNOWN;\n \n       case Token.THIS:\n         if (!right.isThis()) {\n-          return n;\n+          return TernaryValue.UNKNOWN;\n         }\n         switch (op) {\n           case Token.SHEQ:\n           case Token.EQ:\n-            result = true;\n-            break;\n+            return TernaryValue.TRUE;\n \n           case Token.SHNE:\n           case Token.NE:\n-            result = false;\n-            break;\n-\n-          // We can only handle == and != here.\n-          // GT, LT, GE, LE depend on the type of \"this\" and how it will\n-          // be converted to number.  The results are different depending on\n-          // whether it is a string, NaN or other number value.\n-          default:\n-            return n;\n-        }\n-        break;\n+            return TernaryValue.FALSE;\n+        }\n+\n+        // We can only handle == and != here.\n+        // GT, LT, GE, LE depend on the type of \"this\" and how it will\n+        // be converted to number.  The results are different depending on\n+        // whether it is a string, NaN or other number value.\n+        return TernaryValue.UNKNOWN;\n \n       case Token.STRING:\n         if (undefinedRight) {\n-          result = compareToUndefined(left, op);\n-          break;\n+          return TernaryValue.forBoolean(compareToUndefined(left, op));\n         }\n         if (nullRight && isEqualityOp(op)) {\n-          result = compareToNull(left, op);\n-          break;\n+          return TernaryValue.forBoolean(compareToNull(left, op));\n         }\n         if (Token.STRING != right.getType()) {\n-          return n;  // Only eval if they are the same type\n-        }\n-\n-        TernaryValue ternary = TernaryValue.UNKNOWN;\n+          return TernaryValue.UNKNOWN;  // Only eval if they are the same type\n+        }\n+\n         switch (op) {\n           case Token.SHEQ:\n           case Token.EQ:\n-            ternary = areStringsEqual(left.getString(), right.getString());\n-            break;\n+            return areStringsEqual(left.getString(), right.getString());\n \n           case Token.SHNE:\n           case Token.NE:\n-            ternary =\n-                areStringsEqual(left.getString(), right.getString()).not();\n-            break;\n-        }\n-\n-        if (ternary == TernaryValue.UNKNOWN) {\n-          return n;\n-        }\n-        result = ternary.toBoolean(true);\n-        break;\n+            return areStringsEqual(left.getString(), right.getString()).not();\n+        }\n+\n+        return TernaryValue.UNKNOWN;\n \n       case Token.NUMBER:\n         if (undefinedRight) {\n-          result = compareToUndefined(left, op);\n-          break;\n+          return TernaryValue.forBoolean(compareToUndefined(left, op));\n         }\n         if (nullRight && isEqualityOp(op)) {\n-          result = compareToNull(left, op);\n-          break;\n+          return TernaryValue.forBoolean(compareToNull(left, op));\n         }\n         if (Token.NUMBER != right.getType()) {\n-          return n;  // Only eval if they are the same type\n-        }\n-        Boolean compareResult = compareAsNumbers(op, left, right);\n-        if (compareResult != null) {\n-          result = compareResult;\n-        } else {\n-          return null;\n-        }\n-        break;\n+          return TernaryValue.UNKNOWN;  // Only eval if they are the same type\n+        }\n+        return compareAsNumbers(op, left, right);\n \n       case Token.NAME:\n         if (leftLiteral && undefinedRight) {\n-          result = compareToUndefined(left, op);\n-          break;\n+          return TernaryValue.forBoolean(compareToUndefined(left, op));\n         }\n \n         if (rightLiteral) {\n           boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n           if (undefinedLeft) {\n-            result = compareToUndefined(right, op);\n-            break;\n+            return TernaryValue.forBoolean(compareToUndefined(right, op));\n           }\n           if (leftLiteral && nullRight && isEqualityOp(op)) {\n-            result = compareToNull(left, op);\n-            break;\n+            return TernaryValue.forBoolean(compareToNull(left, op));\n           }\n         }\n \n         if (Token.NAME != right.getType()) {\n-          return n;  // Only eval if they are the same type\n+          return TernaryValue.UNKNOWN;  // Only eval if they are the same type\n         }\n         String ln = left.getString();\n         String rn = right.getString();\n         if (!ln.equals(rn)) {\n-          return n;  // Not the same value name.\n+          return TernaryValue.UNKNOWN;  // Not the same value name.\n         }\n \n         switch (op) {\n           // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n           case Token.LT:\n           case Token.GT:\n-            result = false;\n-            break;\n-          default:\n-            return n;  // don't handle that op\n-        }\n-        break;\n+            return TernaryValue.FALSE;\n+        }\n+\n+        return TernaryValue.UNKNOWN;  // don't handle that op\n \n       case Token.NEG:\n         if (leftLiteral) {\n           if (undefinedRight) {\n-            result = compareToUndefined(left, op);\n-            break;\n+            return TernaryValue.forBoolean(compareToUndefined(left, op));\n           }\n           if (nullRight && isEqualityOp(op)) {\n-            result = compareToNull(left, op);\n-            break;\n+            return TernaryValue.forBoolean(compareToNull(left, op));\n           }\n         }\n         // Nothing else for now.\n-        return n;\n+        return TernaryValue.UNKNOWN;\n \n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n       case Token.FUNCTION:\n         if (leftLiteral) {\n           if (undefinedRight) {\n-            result = compareToUndefined(left, op);\n-            break;\n+            return TernaryValue.forBoolean(compareToUndefined(left, op));\n           }\n           if (nullRight && isEqualityOp(op)) {\n-            result = compareToNull(left, op);\n-            break;\n+            return TernaryValue.forBoolean(compareToNull(left, op));\n           }\n         }\n         // ignore the rest for now.\n-        return n;\n+        return TernaryValue.UNKNOWN;\n \n       default:\n         // assert, this should cover all consts\n-        return n;\n-    }\n-\n-    Node newNode = NodeUtil.booleanNode(result);\n-    n.getParent().replaceChild(n, newNode);\n-    reportCodeChange();\n-\n-    return newNode;\n+        return TernaryValue.UNKNOWN;\n+    }\n   }\n \n   /** Returns whether two JS strings are equal. */\n-  private TernaryValue areStringsEqual(String a, String b) {\n+  private static TernaryValue areStringsEqual(String a, String b) {\n     // In JS, browsers parse \\v differently. So do not consider strings\n     // equal if one contains \\v.\n     if (a.indexOf('\\u000B') != -1 ||\n   /**\n    * @return Translate NOT expressions into TRUE or FALSE when possible.\n    */\n-  private int getNormalizedNodeType(Node n) {\n+  private static int getNormalizedNodeType(Node n) {\n     int type = n.getType();\n     if (type == Token.NOT) {\n       TernaryValue value = NodeUtil.getPureBooleanValue(n);\n   }\n \n   /**\n-   * The result of the comparison as a Boolean or null if the\n+   * The result of the comparison, or UNKNOWN if the\n    * result could not be determined.\n    */\n-  private Boolean compareAsNumbers(int op, Node left, Node right) {\n+  private static TernaryValue compareAsNumbers(int op, Node left, Node right) {\n     Double leftValue = NodeUtil.getNumberValue(left);\n     if (leftValue == null) {\n-      return null;\n+      return TernaryValue.UNKNOWN;\n     }\n     Double rightValue = NodeUtil.getNumberValue(right);\n     if (rightValue == null) {\n-      return null;\n+      return TernaryValue.UNKNOWN;\n     }\n \n     double lv = leftValue;\n     double rv = rightValue;\n \n-    Boolean result;\n     switch (op) {\n       case Token.SHEQ:\n       case Token.EQ:\n         Preconditions.checkState(\n             left.isNumber() && right.isNumber());\n-        result = lv == rv;\n-        break;\n+        return TernaryValue.forBoolean(lv == rv);\n       case Token.SHNE:\n       case Token.NE:\n         Preconditions.checkState(\n             left.isNumber() && right.isNumber());\n-        result = lv != rv;\n-        break;\n-      case Token.LE: result = lv <= rv; break;\n-      case Token.LT: result = lv <  rv; break;\n-      case Token.GE: result = lv >= rv; break;\n-      case Token.GT: result = lv >  rv; break;\n+        return TernaryValue.forBoolean(lv != rv);\n+      case Token.LE:\n+        return TernaryValue.forBoolean(lv <= rv);\n+      case Token.LT:\n+        return TernaryValue.forBoolean(lv <  rv);\n+      case Token.GE:\n+        return TernaryValue.forBoolean(lv >= rv);\n+      case Token.GT:\n+        return TernaryValue.forBoolean(lv >  rv);\n       default:\n-        return null;  // don't handle that op\n-    }\n-    return result;\n+        return TernaryValue.UNKNOWN;  // don't handle that op\n+    }\n   }\n \n   /**\n    * @param op The boolean op to compare with\n    * @return Whether the boolean op is true or false\n    */\n-  private boolean compareToUndefined(Node value, int op) {\n+  private static boolean compareToUndefined(Node value, int op) {\n     Preconditions.checkState(NodeUtil.isLiteralValue(value, true));\n     boolean valueUndefined = NodeUtil.isUndefined(value);\n     boolean valueNull = (Token.NULL == value.getType());\n     }\n   }\n \n-  private boolean isEqualityOp(int op) {\n+  private static boolean isEqualityOp(int op) {\n     switch (op) {\n       case Token.EQ:\n       case Token.NE:\n    * @param op The boolean op to compare with\n    * @return Whether the boolean op is true or false\n    */\n-  private boolean compareToNull(Node value, int op) {\n+  private static boolean compareToNull(Node value, int op) {\n     boolean valueUndefined = NodeUtil.isUndefined(value);\n     boolean valueNull = (Token.NULL == value.getType());\n     boolean equivalent = valueUndefined || valueNull;", "timestamp": 1352940930, "metainfo": ""}