{"sha": "46d3d902f88cf364aafab4e6ae0cf9d8ea22d497", "log": "Smarter minimization of conditional expressions.  Rather than the old heuristic which always tried to push NOT nodes down toward the leaves of the AST, this new algorithm constructs two ASTs for each condition (negated an unnegated) and chooses between them depending on the context. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46230236", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * 14 call, member () [] .\n    */\n   static int precedence(int type) {\n+    int precedence = precedenceWithDefault(type);\n+    if (precedence != -1) {\n+      return precedence;\n+    }\n+    throw new Error(\"Unknown precedence for \" +\n+        Token.name(type) + \" (type \" + type + \")\");\n+  }\n+\n+  static int precedenceWithDefault(int type) {\n     switch (type) {\n       case Token.COMMA:  return 0;\n       case Token.ASSIGN_BITOR:\n       case Token.CAST:\n         return 16;\n \n-      default: throw new Error(\"Unknown precedence for \" +\n-                               Token.name(type) +\n-                               \" (type \" + type + \")\");\n+      default:\n+        // Statements are lower precedence than expressions.\n+        return -1;\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n \n+import java.util.Collections;\n+import java.util.Comparator;\n import java.util.regex.Pattern;\n \n /**\n \n   private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n   private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n-  private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n   private static final CodeGenerator REGEXP_ESCAPER =\n       CodeGenerator.forCostEstimation(\n           null /* blow up if we try to produce code */);\n       // with MinimizeExitPoints.\n \n       case Token.NOT:\n-        tryMinimizeCondition(node.getFirstChild());\n+        tryMinimizeCondition(node.getFirstChild(), true);\n         return tryMinimizeNot(node);\n \n       case Token.IF:\n-        tryMinimizeCondition(node.getFirstChild());\n+        tryMinimizeCondition(node.getFirstChild(), false);\n         return tryMinimizeIf(node);\n \n       case Token.EXPR_RESULT:\n-        tryMinimizeCondition(node.getFirstChild());\n+        tryMinimizeCondition(node.getFirstChild(), true);\n         return node;\n \n       case Token.HOOK:\n-        tryMinimizeCondition(node.getFirstChild());\n-        return node;\n+        tryMinimizeCondition(node.getFirstChild(), false);\n+        return tryMinimizeHook(node);\n \n       case Token.WHILE:\n       case Token.DO:\n-        tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n+        tryMinimizeCondition(NodeUtil.getConditionExpression(node), true);\n         return node;\n \n       case Token.FOR:\n         if (!NodeUtil.isForIn(node)) {\n           tryJoinForCondition(node);\n-          tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n+          tryMinimizeCondition(NodeUtil.getConditionExpression(node), true);\n         }\n         return node;\n \n   }\n \n   /**\n+   * Try flipping HOOKs that have negated conditions.\n+   *\n+   * Returns the replacement for n or the original if no replacement was\n+   * necessary.\n+   */\n+  private Node tryMinimizeHook(Node n) {\n+    Node cond = n.getFirstChild();\n+    if (cond.isNot()) {\n+      Node thenBranch = cond.getNext();\n+      n.replaceChild(cond, cond.removeFirstChild());\n+      n.removeChild(thenBranch);\n+      n.addChildToBack(thenBranch);\n+      reportCodeChange();\n+    }\n+    return n;\n+  }\n+\n+  /**\n    * Try turning IF nodes into smaller HOOKs\n    *\n    * Returns the replacement for n or the original if no replacement was\n   }\n \n   /**\n-   * Whether the node type has higher precedence than \"precedence\"\n-   */\n-  private static boolean isHigherPrecedence(Node n, final int precedence) {\n-    return NodeUtil.precedence(n.getType()) > precedence;\n-  }\n-  /**\n    * Does the expression contain a property assignment?\n    */\n   private static boolean isPropertyAssignmentInExpression(Node n) {\n \n     return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,\n         DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n+  }\n+\n+  private Node tryMinimizeCondition(Node n, boolean countLeadingNot) {\n+    n = tryMinimizeConditionOld(n);\n+    return demorganMinimizeCondition(n, countLeadingNot);\n+  }\n+\n+  /**\n+   *  Minimize the given conditional node according to De Morgan's Laws.\n+   *    !(x && !y)  ==> !x || y\n+   *    (!a || !b || !c || !d)  ==>  !(a && b && c && d)\n+   *  etc.\n+   *\n+   * @param countLeadingNot When this is false, do not count a leading\n+   *  NOT in doing the minimization. i.e. Allow minimizations such as:\n+   *    (!x || !y || z)  ==>  !(x && y && !z)\n+   *  This is useful in contexts such as IFs or HOOKs where subsequent\n+   *  optimizations can efficiently deal with leading NOTs.\n+   *\n+   * @param n The conditional node.\n+   * @return The minimized version of n, or n if no minimization was possible.\n+   */\n+  private Node demorganMinimizeCondition(Node n, boolean countLeadingNot) {\n+    MinimizedCondition minCond = MinimizedCondition.fromConditionNode(n);\n+    if (countLeadingNot ||\n+         minCond.getLength() <= minCond.getNegativeLength()) {\n+      return maybeReplaceNode(n, minCond.getNode());\n+    } else {\n+      return maybeReplaceNode(n,\n+          new Node(Token.NOT, minCond.getNegatedNode()));\n+    }\n+  }\n+\n+  private Node maybeReplaceNode(Node lhs, Node rhs) {\n+    if (lhs.isEquivalentTo(rhs)) {\n+      return lhs;\n+    }\n+    Node parent = lhs.getParent();\n+    parent.replaceChild(lhs, rhs);\n+    reportCodeChange();\n+    return rhs;\n+  }\n+\n+  /** A class that represents a minimized conditional expression.\n+   *  Depending on the context, either the original conditional, or the\n+   *  negation of the original conditional may be needed, so this class\n+   *  provides ways to access minimized versions of both of those ASTs.\n+   */\n+  static class MinimizedCondition {\n+    private final Node positive;\n+    private final Node negative;\n+\n+    private MinimizedCondition(Node p, Node n) {\n+      Preconditions.checkArgument(p.getParent() == null);\n+      Preconditions.checkArgument(n.getParent() == null);\n+      positive = p;\n+      negative = n;\n+    }\n+\n+    /** Minimize the condition at the given node.\n+     *\n+     *  @param n The conditional expression tree to minimize.\n+     *   This may be still connected to a tree and will be cloned as necessary.\n+     *  @return A MinimizedCondition object representing that tree.\n+     */\n+    static MinimizedCondition fromConditionNode(Node n) {\n+      switch (n.getType()) {\n+        case Token.NOT: {\n+          MinimizedCondition subtree = fromConditionNode(n.getFirstChild());\n+          ImmutableSet<Node> positiveAsts = ImmutableSet.of(\n+              negate(subtree.positive.cloneTree()),\n+              subtree.negative.cloneTree());\n+          ImmutableSet<Node> negativeAsts = ImmutableSet.of(\n+              negate(subtree.negative),\n+              subtree.positive);\n+          return new MinimizedCondition(\n+              Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n+              Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n+        }\n+        case Token.AND:\n+        case Token.OR: {\n+          int opType = n.getType();\n+          int complementType = opType == Token.AND ? Token.OR : Token.AND;\n+          MinimizedCondition leftSubtree = fromConditionNode(n.getFirstChild());\n+          MinimizedCondition rightSubtree = fromConditionNode(n.getLastChild());\n+          ImmutableSet<Node> positiveAsts = ImmutableSet.of(\n+              new Node(opType,\n+                  leftSubtree.positive.cloneTree(),\n+                  rightSubtree.positive.cloneTree()).srcref(n),\n+              negate(new Node(complementType,\n+                  leftSubtree.negative.cloneTree(),\n+                  rightSubtree.negative.cloneTree()).srcref(n)));\n+          ImmutableSet<Node> negativeAsts = ImmutableSet.of(\n+              negate(new Node(opType,\n+                  leftSubtree.positive,\n+                  rightSubtree.positive).srcref(n)),\n+              new Node(complementType,\n+                  leftSubtree.negative,\n+                  rightSubtree.negative).srcref(n));\n+          return new MinimizedCondition(\n+              Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n+              Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n+        }\n+        default:\n+          return new MinimizedCondition(n.cloneTree(), negate(n.cloneTree()));\n+      }\n+    }\n+\n+    Node getNode() {\n+      return positive;\n+    }\n+\n+    Node getNegatedNode() {\n+      return negative;\n+    }\n+\n+    int getLength() {\n+      return length(positive);\n+    }\n+\n+    int getNegativeLength() {\n+      return length(negative);\n+    }\n+\n+    private static Node negate(Node node) {\n+      Preconditions.checkArgument(node.getParent() == null);\n+      int complementOperator;\n+      switch (node.getType()) {\n+        default:\n+          return new Node(Token.NOT, node).srcref(node);\n+        case Token.NOT:\n+          return node.removeFirstChild();\n+        // Otherwise a binary operator with a complement.\n+        case Token.EQ:\n+          complementOperator = Token.NE;\n+          break;\n+        case Token.NE:\n+          complementOperator = Token.EQ;\n+          break;\n+        case Token.SHEQ:\n+          complementOperator = Token.SHNE;\n+          break;\n+        case Token.SHNE:\n+          complementOperator = Token.SHEQ;\n+          break;\n+      }\n+      // Clone entire tree and just change operator.\n+      node.setType(complementOperator);\n+      return node;\n+    }\n+\n+    private static final Comparator<Node> AST_LENGTH_COMPARATOR =\n+        new Comparator<Node>() {\n+      @Override\n+      public int compare(Node o1, Node o2) {\n+        return length(o1) - length(o2);\n+      }\n+    };\n+\n+    /** Return the number of characters in the textual representation of\n+     *  the given tree that will be devoted to negation, or parentheses.\n+     *  Since these are the only characters that flipping a condition\n+     *  according to De Morgan's rule can affect, these are the only ones\n+     *  we count.\n+     *  @param node The tree whose length should be checked.\n+     *  @return The number of negations and parentheses in the tree.\n+     */\n+    static int length(Node node) {\n+      int result = 0;\n+      if (node.isNot()) {\n+        result++;  // One negation needed.\n+      }\n+      for (Node n = node.getFirstChild(); n != null; n = n.getNext()) {\n+        if (NodeUtil.precedenceWithDefault(n.getType())\n+            < NodeUtil.precedenceWithDefault(node.getType())) {\n+          result += 2;  // One pair of parentheses needed.\n+        }\n+        result += length(n);\n+      }\n+      return result;\n+    }\n+\n   }\n \n   /**\n    *\n    *   Returns the replacement for n, or the original if no change was made\n    */\n-  private Node tryMinimizeCondition(Node n) {\n+  private Node tryMinimizeConditionOld(Node n) {\n     Node parent = n.getParent();\n \n     switch (n.getType()) {\n-      case Token.NOT:\n-        Node first = n.getFirstChild();\n-        switch (first.getType()) {\n-          case Token.NOT: {\n-              Node newRoot = first.removeFirstChild();\n-              parent.replaceChild(n, newRoot);\n-              reportCodeChange();\n-              // No need to traverse, tryMinimizeCondition is called on the\n-              // NOT children are handled below.\n-              return newRoot;\n-            }\n-          case Token.AND:\n-          case Token.OR: {\n-              // !(!x && !y) --> x || y\n-              // !(!x || !y) --> x && y\n-              // !(!x && y) --> x || !y\n-              // !(!x || y) --> x && !y\n-              // !(x && !y) --> !x || y\n-              // !(x || !y) --> !x && y\n-              // !(x && y) --> !x || !y\n-              // !(x || y) --> !x && !y\n-              Node leftParent = first.getFirstChild();\n-              Node rightParent = first.getLastChild();\n-              Node left, right;\n-\n-              // Check special case when such transformation cannot reduce\n-              // due to the added ()\n-              // It only occurs when both of expressions are not NOT expressions\n-              if (!leftParent.isNot()\n-                  && !rightParent.isNot()) {\n-                // If an expression has higher precedence than && or ||,\n-                // but lower precedence than NOT, an additional () is needed\n-                // Thus we do not preceed\n-                int opPrecedence = NodeUtil.precedence(first.getType());\n-                if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE)\n-                    && isHigherPrecedence(leftParent, opPrecedence))\n-                    || (isLowerPrecedence(rightParent, NOT_PRECEDENCE)\n-                    && isHigherPrecedence(rightParent, opPrecedence))) {\n-                  return n;\n-                }\n-              }\n-\n-              if (leftParent.isNot()) {\n-                left = leftParent.removeFirstChild();\n-              } else {\n-                leftParent.detachFromParent();\n-                left = IR.not(leftParent).srcref(leftParent);\n-              }\n-              if (rightParent.isNot()) {\n-                right = rightParent.removeFirstChild();\n-              } else {\n-                rightParent.detachFromParent();\n-                right = IR.not(rightParent).srcref(rightParent);\n-              }\n-\n-              int newOp = (first.isAnd()) ? Token.OR : Token.AND;\n-              Node newRoot = new Node(newOp, left, right);\n-              parent.replaceChild(n, newRoot);\n-              reportCodeChange();\n-              // No need to traverse, tryMinimizeCondition is called on the\n-              // AND and OR children below.\n-              return newRoot;\n-            }\n-\n-           default:\n-             TernaryValue nVal = NodeUtil.getPureBooleanValue(first);\n-             if (nVal != TernaryValue.UNKNOWN) {\n-               boolean result = nVal.not().toBoolean(true);\n-               int equivalentResult = result ? 1 : 0;\n-               return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n-             }\n-        }\n-        // No need to traverse, tryMinimizeCondition is called on the NOT\n-        // children in the general case in the main post-order traversal.\n-        return n;\n-\n       case Token.OR:\n       case Token.AND: {\n         Node left = n.getFirstChild();\n \n         // Because the expression is in a boolean context minimize\n         // the children, this can't be done in the general case.\n-        left = tryMinimizeCondition(left);\n-        right = tryMinimizeCondition(right);\n+        left = tryMinimizeConditionOld(left);\n+        right = tryMinimizeConditionOld(right);\n \n         // Remove useless conditionals\n         // Handle four cases:\n         // Because the expression is in a boolean context minimize\n         // the result children, this can't be done in the general case.\n         // The condition is handled in the general case in #optimizeSubtree\n-        trueNode = tryMinimizeCondition(trueNode);\n-        falseNode = tryMinimizeCondition(falseNode);\n+        trueNode = tryMinimizeConditionOld(trueNode);\n+        falseNode = tryMinimizeConditionOld(falseNode);\n \n         // Handle four cases:\n         //   x ? true : false --> x\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n \n   // TODO(user): This is same as fold() except it uses string comparison. Any\n   // test that needs tell us where a folding is constructing an invalid AST.\n-  private void assertResultString(String js, String expected) {\n+  private static void assertResultString(String js, String expected) {\n     PeepholeIntegrationTest scTest = new PeepholeIntegrationTest(false);\n \n     scTest.disableNormalize();\n          \"x=cond?2:3\");\n \n     fold(\"x?void 0:y()\", \"x||y()\");\n-    fold(\"!x?void 0:y()\", \"(!x)||y()\");\n+    fold(\"!x?void 0:y()\", \"x&&y()\");\n     fold(\"x?y():void 0\", \"x&&y()\");\n   }\n \n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n  */\n \n package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.MinimizedCondition;\n+import com.google.javascript.rhino.Node;\n \n /**\n  * Tests for {@link PeepholeSubstituteAlternateSyntax} in isolation.\n     fold(\"while(!((x,y)&&z)) foo()\", \"while(!(x,y)||!z) foo()\");\n   }\n \n+  public void testMinimizeDemorganRemoveLeadingNot() {\n+    fold(\"if(!(!a||!b)&&c) foo()\", \"((a&&b)&&c)&&foo()\");\n+    fold(\"if(!(x&&y)) foo()\", \"x&&y||foo()\");\n+    fold(\"if(!(x||y)) foo()\", \"(x||y)||foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan1() {\n+    fold(\"if(!a&&!b)foo()\", \"(a||b)||foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan3() {\n+    fold(\"if((!a||!b)&&(c||d)) foo()\", \"(a&&b||!c&&!d)||foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan5() {\n+    fold(\"if((!a||!b)&&c) foo()\", \"(a&&b||!c)||foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan11() {\n+    fold(\"if (x && (y===2 || !f()) && (y===3 || !h())) foo()\",\n+         \"(!x || y!==2 && f() || y!==3 && h()) || foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan20() {\n+    fold(\"if (0===c && (2===a || 1===a)) f(); else g()\",\n+         \"if (0!==c || 2!==a && 1!==a) g(); else f()\");\n+    fold(\"if (0!==c || 2!==a && 1!==a) g(); else f()\",\n+         \"(0!==c || 2!==a && 1!==a) ? g() : f()\");\n+  }\n+\n+  public void testSwapHook() {\n+    fold(\"!x ? foo() : bar()\",\n+         \"x ? bar() : foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan21() {\n+    fold(\"if (0===c && (2===a || 1===a)) f()\",\n+         \"(0!==c || 2!==a && 1!==a) || f()\");\n+  }\n+\n+  public void testMinimizeAndOr1() {\n+    fold(\"if ((!a || !b) && (d || e)) f()\", \"(a&&b || !d&&!e) || f()\");\n+  }\n+\n+  public Node parseExpr(String input) {\n+    Node block = parseExpectedJs(input);\n+    Node script = block.getFirstChild();\n+    Node exprResult = script.getFirstChild();\n+    return exprResult.getFirstChild();\n+  }\n+\n+  public void minimizeCond(String input, String positive, String negative) {\n+    Node inputNode = parseExpr(input);\n+    MinimizedCondition result = PeepholeSubstituteAlternateSyntax\n+        .MinimizedCondition.fromConditionNode(inputNode);\n+    Node positiveNode = parseExpr(positive);\n+    Node negativeNode = parseExpr(negative);\n+    if (!result.getNode().isEquivalentTo(positiveNode)) {\n+      fail(\"Not equal:\\n\" + result.getNode().toStringTree()\n+          + \"and:\\n\" + positiveNode.toStringTree());\n+    }\n+    if (!result.getNegatedNode().isEquivalentTo(negativeNode)) {\n+      fail(\"Not equal:\\n\" + result.getNegatedNode().toStringTree()\n+          + \"and:\\n\" + negativeNode.toStringTree());\n+    }\n+  }\n+\n+  public void testTryMinimizeCondition1() {\n+    minimizeCond(\"x\", \"x\", \"!x\");\n+  }\n+\n+  public void testTryMinimizeCondition2() {\n+    minimizeCond(\"!x\", \"!x\", \"x\");\n+  }\n+\n+  public void testTryMinimizeCondition3() {\n+    minimizeCond(\"x || y\", \"x || y\", \"!x && !y\");\n+  }\n+\n+  public void testTryMinimizeCondition4() {\n+    minimizeCond(\"x && y\", \"x && y\", \"!x || !y\");\n+  }\n+\n+  public void testTryMinimizeCondition5() {\n+    minimizeCond(\"w && x && y && z\", \"w && x && y && z\", \"!(w && x && y && z)\");\n+  }\n+\n+  public void testMinimizeCondDemorgan() {\n+    minimizeCond(\"x && (y===2 || !f()) && (y===3 || !h())\",\n+        \"x && !((y!==2 && f()) || (y!==3 && h()))\",\n+        \"!x || (y!==2 && f()) || (y!==3 && h())\");\n+  }\n+\n   public void testMinimizeForCondition() {\n     // This test uses constant folding logic, so is only here for completeness.\n     // These could be simplified to \"for(;;) ...\"", "timestamp": 1367882262, "metainfo": ""}