{"sha": "072fa2d047573d2d1f0187ba4bf76b1afa75031c", "log": "When a property of a named object literal is declared, declare the qualified name of that property.  R=johnlenz DELTA=82  (58 added, 3 deleted, 21 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=546   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n      */\n     void processObjectLitProperties(\n         NodeTraversal t, Node objLit, ObjectType objLitType) {\n-      for (Node name = objLit.getFirstChild(); name != null;\n-           name = name.getNext()) {\n-        Node value = name.getFirstChild();\n-        String memberName = NodeUtil.getObjectLitKeyName(name);\n+      for (Node keyNode = objLit.getFirstChild(); keyNode != null;\n+           keyNode = keyNode.getNext()) {\n+        Node value = keyNode.getFirstChild();\n+        String memberName = NodeUtil.getObjectLitKeyName(keyNode);\n+        JSDocInfo info = keyNode.getJSDocInfo();\n         JSType valueType = getDeclaredPropType(\n-            t, name.getJSDocInfo(), name, value);\n+            t, info, keyNode, value);\n         JSType keyType = NodeUtil.getObjectLitKeyTypeFromValueType(\n-            name, valueType);\n+            keyNode, valueType);\n         if (keyType != null) {\n-          name.setJSType(keyType);\n-          // TODO(nicksantos): Even if the type of the object literal is null,\n-          // we may want to declare its properties in the current scope.\n+          // Try to declare this property in the current scope if it\n+          // has an authoritative name.\n+          String qualifiedName = getBestLValueName(keyNode);\n+          if (qualifiedName != null) {\n+            defineSlot(keyNode, objLit, qualifiedName, keyType, false);\n+          } else {\n+            setDeferredType(keyNode, keyType);\n+          }\n+\n           if (objLitType != null) {\n+            // Declare this property on its object literal.\n             boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n             objLitType.defineDeclaredProperty(\n-                memberName, keyType, isExtern, name);\n+                memberName, keyType, isExtern, keyNode);\n           }\n         }\n       }\n               ObjectType ownerType = ObjectType.cast(var.getType());\n               if (ownerType != null) {\n                 String propName = lvalueNode.getLastChild().getString();\n-                overriddenPropType = findOverriddenFunction(ownerType, propName);\n+                overriddenPropType =\n+                    findOverriddenFunction(ownerType, propName);\n               }\n             }\n           }\n       Preconditions.checkArgument(inferred || type != null);\n \n       // Only allow declarations of NAMEs and qualfied names.\n-      boolean shouldDeclareOnGlobalThis = false;\n+      // Object literal keys will have to compute their names themselves.\n       if (n.getType() == Token.NAME) {\n         Preconditions.checkArgument(\n             parent.getType() == Token.FUNCTION ||\n             parent.getType() == Token.VAR ||\n             parent.getType() == Token.LP ||\n             parent.getType() == Token.CATCH);\n-        shouldDeclareOnGlobalThis = scope.isGlobal() &&\n-            (parent.getType() == Token.VAR ||\n-             parent.getType() == Token.FUNCTION);\n       } else {\n         Preconditions.checkArgument(\n             n.getType() == Token.GETPROP &&\n             (parent.getType() == Token.ASSIGN ||\n              parent.getType() == Token.EXPR_RESULT));\n       }\n-      String variableName = n.getQualifiedName();\n+      defineSlot(n, parent, n.getQualifiedName(), type, inferred);\n+    }\n+\n+\n+    /**\n+     * Defines a symbol in the current scope.\n+     *\n+     * @param n the defining NAME or GETPROP or object literal key node.\n+     * @param parent the {@code n}'s parent.\n+     * @param name The name that this should be known by.\n+     * @param type the variable's type. It may be {@code null} if\n+     *     {@code inferred} is {@code true}.\n+     * @param inferred Whether the type is inferred or declared.\n+     */\n+    void defineSlot(Node n, Node parent, String variableName,\n+        JSType type, boolean inferred) {\n       Preconditions.checkArgument(!variableName.isEmpty());\n+\n+      boolean shouldDeclareOnGlobalThis =\n+          n.getType() == Token.NAME && scope.isGlobal() &&\n+          (parent.getType() == Token.VAR ||\n+           parent.getType() == Token.FUNCTION);\n \n       // If n is a property, then we should really declare it in the\n       // scope where the root object appears. This helps out people\n \n   /** Get the name of the given l-value node. */\n   private static String getBestLValueName(@Nullable Node lValue) {\n-    return lValue == null ? null : lValue.getQualifiedName();\n+    if (lValue == null || lValue.getParent() == null) {\n+      return null;\n+    }\n+    if (NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {\n+      Node owner = getBestLValue(lValue.getParent());\n+      if (owner != null) {\n+        String ownerName = getBestLValueName(owner);\n+        if (ownerName != null) {\n+          return ownerName + \".\" + NodeUtil.getObjectLitKeyName(lValue);\n+        }\n+      }\n+      return null;\n+    }\n+    return lValue.getQualifiedName();\n   }\n }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"/** @return {string} */\\n\" +\n         \"var f = function() {\\n\" +\n         \"  return x.a;\\n\" +\n-        \"}\");  // would like this to be an error.\n+        \"}\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n   }\n \n   public void testQualifiedNameReduction5c() throws Exception {\n         \"/** @param {number} x */ goog.foo = function(x) {};\" +\n         \"/** @param {number} x */ goog.foo = function(x) {};\",\n         \"variable goog.foo redefined with type function (number): undefined, \" +\n-        \"original definition at [testcode]:1 with type function (number): undefined\");\n+        \"original definition at [testcode]:1 \" +\n+        \"with type function (number): undefined\");\n   }\n \n   public void testDuplicateStaticMethodDecl2() throws Exception {\n   public void testConstructorAlias8() throws Exception {\n     testTypes(\n         \"var goog = {};\" +\n-        \"/**\\n * @param {number} x \\n * @constructor */ goog.Foo = function(x) {};\" +\n-        \"/**\\n * @param {number} x \\n * @constructor */ goog.FooAlias = goog.Foo;\" +\n+        \"/**\\n * @param {number} x \\n * @constructor */ \" +\n+        \"goog.Foo = function(x) {};\" +\n+        \"/**\\n * @param {number} x \\n * @constructor */ \" +\n+        \"goog.FooAlias = goog.Foo;\" +\n         \"/** @return {number} */ function foo() { \" +\n         \"  return new goog.FooAlias(1); }\",\n         \"inconsistent return type\\n\" +\n   public void testConstructorAlias9() throws Exception {\n     testTypes(\n         \"var goog = {};\" +\n-        \"/**\\n * @param {number} x \\n * @constructor */ goog.Foo = function(x) {};\" +\n+        \"/**\\n * @param {number} x \\n * @constructor */ \" +\n+        \"goog.Foo = function(x) {};\" +\n         \"/** @constructor */ goog.FooAlias = goog.Foo;\" +\n         \"/** @return {number} */ function foo() { \" +\n         \"  return new goog.FooAlias(1); }\",\n \n   public void testConstructorAlias10() throws Exception {\n     testTypes(\n-        \"/**\\n * @param {number} x \\n * @constructor */ var Foo = function(x) {};\" +\n+        \"/**\\n * @param {number} x \\n * @constructor */ \" +\n+        \"var Foo = function(x) {};\" +\n         \"/** @constructor */ var FooAlias = Foo;\" +\n         \"/** @return {number} */ function foo() { \" +\n         \"  return new FooAlias(1); }\",\n         \"/** @return {number} */ F.prototype.foo = function() {return 3; };\" +\n         \"/** @constructor \\n * @extends {F} \\n * @implements {I} */ \" +\n         \"function G() {}\" +\n-        \"/** @return {number} \\n * @override */ G.prototype.bar = G.prototype.foo;\" +\n+        \"/** @return {number} \\n * @override */ \" +\n+        \"G.prototype.bar = G.prototype.foo;\" +\n         \"/** @return {string} */ function f() { return new G().bar(); }\",\n         \"inconsistent return type\\n\" +\n         \"found   : number\\n\" +\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n     assertEquals(\"number\", foo.getPropertyType(\"Bar\").toString());\n     assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n-  }  \n+  }\n \n   public void testInferredProperty2() {\n     testSame(\"var foo = { Bar: 3 };\");\n     assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n     assertEquals(\"number\", foo.getPropertyType(\"Bar\").toString());\n     assertTrue(foo.isPropertyTypeInferred(\"Bar\"));\n-  }  \n+  }\n \n   public void testInferredProperty2b() {\n     testSame(\"var foo = { /** @type {number} */ Bar: 3 };\");\n     assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n     assertEquals(\"number\", foo.getPropertyType(\"Bar\").toString());\n     assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n-  }  \n+  }\n \n   public void testInferredProperty2c() {\n     testSame(\"var foo = { /** @return {number} */ Bar: 3 };\");\n     assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n     assertEquals(\"function (): number\", foo.getPropertyType(\"Bar\").toString());\n     assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n-  }  \n+  }\n \n   public void testInferredProperty3() {\n     testSame(\"var foo = { /** @type {number} */ get Bar() { return 3 } };\");\n     assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n     assertEquals(\"?\", foo.getPropertyType(\"Bar\").toString());\n     assertTrue(foo.isPropertyTypeInferred(\"Bar\"));\n-  }  \n+  }\n \n   public void testInferredProperty5() {\n     testSame(\"var foo = { /** @return {number} */ get Bar() { return 3 } };\");\n     assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n     assertEquals(\"number\", foo.getPropertyType(\"Bar\").toString());\n     assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n-  }   \n+  }\n \n   public void testPrototypeInit() {\n     testSame(\"/** @constructor */ var Foo = function() {};\" +\n     assertTrue(iPrototype.isFunctionPrototypeType());\n \n     assertEquals(\"number\", iPrototype.getPropertyType(\"bar\").toString());\n-    \n+\n     // should be: \"function (this:I): undefined\"\n     assertEquals(\"function (): undefined\",\n         iPrototype.getPropertyType(\"baz\").toString());\n \n-    // should not be null \n+    // should not be null\n     assertNull(globalScope.getVar(\"I.prototype\"));\n     // assertEquals(iPrototype, globalScope.getVar(\"I.prototype\").getType());\n   }\n \n     assertEquals(\n         // should be: \"function (this:Foo, number): ?\"\n-        \"function (number): ?\",  \n+        \"function (number): ?\",\n         proto.getPropertyType(\"bar\").toString());\n   }\n \n     assertEquals(\n         \"{y: number, z: number}\",\n         xType.toString());\n+  }\n+\n+  public void testDeclaredObjectLitProperty5() throws Exception {\n+    testSame(\"var x = {/** @type {number} */ prop: 3};\" +\n+             \"function f() { var y = x.prop; }\");\n+    JSType yType = lastLocalScope.getVar(\"y\").getType();\n+    assertEquals(\"number\", yType.toString());\n   }\n \n   public void testBadCtorInit1() throws Exception {", "timestamp": 1297917512, "metainfo": ""}