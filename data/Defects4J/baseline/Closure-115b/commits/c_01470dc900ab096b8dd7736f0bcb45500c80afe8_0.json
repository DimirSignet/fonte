{"sha": "01470dc900ab096b8dd7736f0bcb45500c80afe8", "log": "Make conditional optimizers mutually exclusive.  Don't allow heuristic-based condition minimization to be turned on at the same time as new MinimizedCondition algorithm. When aggressiveMinimization is off (as is now the default), this CL should be a no-op. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46586423", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n+++ b/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n    *   Returns the replacement for n, or the original if no change was made\n    */\n   private Node performConditionSubstitutions(Node n) {\n+    if (!aggressiveMinimization && n.isNot()) {\n+      return simpleDemorgan(n);\n+    }\n+\n     Node parent = n.getParent();\n \n     switch (n.getType()) {\n-      case Token.NOT:\n-        Node first = n.getFirstChild();\n-        switch (first.getType()) {\n-          case Token.NOT: {\n-              Node newRoot = first.removeFirstChild();\n-              parent.replaceChild(n, newRoot);\n-              reportCodeChange();\n-              // No need to traverse, tryMinimizeCondition is called on the\n-              // NOT children are handled below.\n-              return newRoot;\n-            }\n-          case Token.AND:\n-          case Token.OR: {\n-              // !(!x && !y) --> x || y\n-              // !(!x || !y) --> x && y\n-              // !(!x && y) --> x || !y\n-              // !(!x || y) --> x && !y\n-              // !(x && !y) --> !x || y\n-              // !(x || !y) --> !x && y\n-              // !(x && y) --> !x || !y\n-              // !(x || y) --> !x && !y\n-              Node leftParent = first.getFirstChild();\n-              Node rightParent = first.getLastChild();\n-              Node left, right;\n-\n-              // Check special case when such transformation cannot reduce\n-              // due to the added ()\n-              // It only occurs when both of expressions are not NOT expressions\n-              if (!leftParent.isNot()\n-                  && !rightParent.isNot()) {\n-                // If an expression has higher precedence than && or ||,\n-                // but lower precedence than NOT, an additional () is needed\n-                // Thus we do not preceed\n-                int opPrecedence = NodeUtil.precedence(first.getType());\n-                if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE)\n-                    && isHigherPrecedence(leftParent, opPrecedence))\n-                    || (isLowerPrecedence(rightParent, NOT_PRECEDENCE)\n-                    && isHigherPrecedence(rightParent, opPrecedence))) {\n-                  return n;\n-                }\n-              }\n-\n-              if (leftParent.isNot()) {\n-                left = leftParent.removeFirstChild();\n-              } else {\n-                leftParent.detachFromParent();\n-                left = IR.not(leftParent).srcref(leftParent);\n-              }\n-              if (rightParent.isNot()) {\n-                right = rightParent.removeFirstChild();\n-              } else {\n-                rightParent.detachFromParent();\n-                right = IR.not(rightParent).srcref(rightParent);\n-              }\n-\n-              int newOp = (first.isAnd()) ? Token.OR : Token.AND;\n-              Node newRoot = new Node(newOp, left, right);\n-              parent.replaceChild(n, newRoot);\n-              reportCodeChange();\n-              // No need to traverse, tryMinimizeCondition is called on the\n-              // AND and OR children below.\n-              return newRoot;\n-            }\n-\n-           default:\n-             TernaryValue nVal = NodeUtil.getPureBooleanValue(first);\n-             if (nVal != TernaryValue.UNKNOWN) {\n-               boolean result = nVal.not().toBoolean(true);\n-               int equivalentResult = result ? 1 : 0;\n-               return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n-             }\n-        }\n-        // No need to traverse, tryMinimizeCondition is called on the NOT\n-        // children in the general case in the main post-order traversal.\n-        return n;\n       case Token.OR:\n       case Token.AND: {\n         Node left = n.getFirstChild();\n   }\n \n   /**\n+   *  Perform a heuristic-based application of De Morgan's Laws, trying to\n+   *  push NOT nodes further down the AST toward the leaves.\n+   */\n+  private Node simpleDemorgan(Node n) {\n+    Node parent = n.getParent();\n+    Node first = n.getFirstChild();\n+    switch (first.getType()) {\n+      case Token.NOT: {\n+        Node newRoot = first.removeFirstChild();\n+        parent.replaceChild(n, newRoot);\n+        reportCodeChange();\n+        // No need to traverse, tryMinimizeCondition is called on the\n+        // NOT children are handled below.\n+        return newRoot;\n+      }\n+      case Token.AND:\n+      case Token.OR: {\n+        // !(!x && !y) --> x || y\n+        // !(!x || !y) --> x && y\n+        // !(!x && y) --> x || !y\n+        // !(!x || y) --> x && !y\n+        // !(x && !y) --> !x || y\n+        // !(x || !y) --> !x && y\n+        // !(x && y) --> !x || !y\n+        // !(x || y) --> !x && !y\n+        Node leftParent = first.getFirstChild();\n+        Node rightParent = first.getLastChild();\n+        Node left, right;\n+\n+        // Check special case when such transformation cannot reduce\n+        // due to the added ()\n+        // It only occurs when both of expressions are not NOT expressions\n+        if (!leftParent.isNot()\n+            && !rightParent.isNot()) {\n+          // If an expression has higher precedence than && or ||,\n+          // but lower precedence than NOT, an additional () is needed\n+          // Thus we do not preceed\n+          int opPrecedence = NodeUtil.precedence(first.getType());\n+          if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE)\n+              && isHigherPrecedence(leftParent, opPrecedence))\n+              || (isLowerPrecedence(rightParent, NOT_PRECEDENCE)\n+                  && isHigherPrecedence(rightParent, opPrecedence))) {\n+            return n;\n+          }\n+        }\n+\n+        if (leftParent.isNot()) {\n+          left = leftParent.removeFirstChild();\n+        } else {\n+          leftParent.detachFromParent();\n+          left = IR.not(leftParent).srcref(leftParent);\n+        }\n+        if (rightParent.isNot()) {\n+          right = rightParent.removeFirstChild();\n+        } else {\n+          rightParent.detachFromParent();\n+          right = IR.not(rightParent).srcref(rightParent);\n+        }\n+\n+        int newOp = (first.isAnd()) ? Token.OR : Token.AND;\n+        Node newRoot = new Node(newOp, left, right);\n+        parent.replaceChild(n, newRoot);\n+        reportCodeChange();\n+        // No need to traverse, tryMinimizeCondition is called on the\n+        // AND and OR children below.\n+        return newRoot;\n+      }\n+\n+      default:\n+        TernaryValue nVal = NodeUtil.getPureBooleanValue(first);\n+        if (nVal != TernaryValue.UNKNOWN) {\n+          boolean result = nVal.not().toBoolean(true);\n+          int equivalentResult = result ? 1 : 0;\n+          return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n+        }\n+    }\n+    // No need to traverse, tryMinimizeCondition is called on the NOT\n+    // children in the general case in the main post-order traversal.\n+    return n;\n+  }\n+\n+  /**\n    * Replaces a node with a number node if the new number node is not equivalent\n    * to the current node.\n    *", "timestamp": 1368581572, "metainfo": ""}