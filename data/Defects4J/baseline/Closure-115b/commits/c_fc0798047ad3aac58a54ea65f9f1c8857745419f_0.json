{"sha": "fc0798047ad3aac58a54ea65f9f1c8857745419f", "log": "Add toMaybeFunctionType/toMaybeEnumElementType. wow, nullability is annoying!  R=johnlenz DELTA=318  (79 added, 48 deleted, 191 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3074   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n           if (lValueType != null && lValueType.isConstructor()) {\n             // If a.b is a constructor, then everything in this function\n             // belongs to the \"a.b\" type.\n-            return ((FunctionType) lValueType).getInstanceType();\n+            return (lValueType.toMaybeFunctionType()).getInstanceType();\n           } else {\n             // If a.b is not a constructor, then treat this as a method\n             // of whatever type is on \"a\".\n     if (type == null || type.isUnknownType()) {\n       return type;\n     } else if (type.isConstructor()) {\n-      return ((FunctionType) type).getInstanceType();\n+      return (type.toMaybeFunctionType()).getInstanceType();\n     } else if (type.isFunctionPrototypeType()) {\n       FunctionType owner = ((FunctionPrototypeType) type).getOwnerFunction();\n       if (owner.isConstructor()) {\n--- a/src/com/google/javascript/jscomp/CheckMissingReturn.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingReturn.java\n    * @return If a return type is expected, returns it. Otherwise returns null.\n    */\n   private JSType explicitReturnExpected(Node scope) {\n-    JSType scopeType = scope.getJSType();\n+    FunctionType scopeType = JSType.toMaybeFunctionType(scope.getJSType());\n \n-    if (!(scopeType instanceof FunctionType)) {\n+    if (scopeType == null) {\n       return null;\n     }\n \n       return null;\n     }\n \n-    JSType returnType = ((FunctionType) scopeType).getReturnType();\n+    JSType returnType = scopeType.getReturnType();\n \n     if (returnType == null) {\n       return null;\n--- a/src/com/google/javascript/jscomp/CheckPropertyOrder.java\n+++ b/src/com/google/javascript/jscomp/CheckPropertyOrder.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n import java.util.Collections;\n     }\n \n     if (func != null) {\n-      FunctionType funcType = (FunctionType) func.getJSType();\n+      FunctionType funcType = JSType.toMaybeFunctionType(func.getJSType());\n       checkConstructor(\n           func, (funcType != null) ? funcType.getInstanceType() : null,\n           t.getSourceName(), funcName);\n--- a/src/com/google/javascript/jscomp/ConcreteType.java\n+++ b/src/com/google/javascript/jscomp/ConcreteType.java\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.StaticScope;\n \n     /** Returns the JSType of this function. */\n     public FunctionType getJSType() {\n-      return (FunctionType) declaration.getJSType();\n+      return JSType.toMaybeFunctionType(declaration.getJSType());\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n    * NO_TYPE.\n    */\n   private void fixFunctionType(Node functionNode) {\n-    FunctionType type = (FunctionType) functionNode.getJSType();\n+    FunctionType type = JSType.toMaybeFunctionType(functionNode.getJSType());\n     if (type != null) {\n       JSTypeRegistry typeRegistry = compiler.getTypeRegistry();\n \n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n import com.google.javascript.jscomp.graph.UnionFind;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.EnumElementType;\n import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n       for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n         addInvalidatingType(alt);\n       }\n-    } else if (type instanceof EnumElementType) {\n-      addInvalidatingType(((EnumElementType) type).getPrimitiveType());\n+    } else if (type.isEnumElementType()) {\n+      addInvalidatingType(type.toMaybeEnumElementType().getPrimitiveType());\n     } else {\n       typeSystem.addInvalidatingType(type);\n       ObjectType objType = ObjectType.cast(type);\n           types.addAll(getTypesToSkipForTypeNonUnion(type));\n         }\n         return ImmutableSet.copyOf(types);\n-      } else if (type instanceof EnumElementType) {\n+      } else if (type.isEnumElementType()) {\n         return getTypesToSkipForType(\n-            ((EnumElementType) type).getPrimitiveType());\n+            type.toMaybeEnumElementType().getPrimitiveType());\n       }\n       return ImmutableSet.copyOf(getTypesToSkipForTypeNonUnion(type));\n     }\n     }\n \n     @Override public ObjectType getTypeWithProperty(String field, JSType type) {\n-      if (type instanceof EnumElementType) {\n+      if (type == null) {\n+        return null;\n+      }\n+\n+      if (type.isEnumElementType()) {\n         return getTypeWithProperty(\n-            field, ((EnumElementType) type).getPrimitiveType());\n+            field, type.toMaybeEnumElementType().getPrimitiveType());\n       }\n \n       if (!(type instanceof ObjectType)) {\n       ObjectType objType = ObjectType.cast(type);\n       if (objType != null) {\n         FunctionType constructor;\n-        if (objType instanceof FunctionType) {\n-          constructor = (FunctionType) objType;\n+        if (objType.isFunctionType()) {\n+          constructor = objType.toMaybeFunctionType();\n         } else if (objType instanceof FunctionPrototypeType) {\n           constructor = ((FunctionPrototypeType) objType).getOwnerFunction();\n         } else {\n           cType = maybeAddAutoboxes(cType, alt, prop);\n         }\n         return cType;\n-      } else if (jsType instanceof EnumElementType) {\n+      } else if (jsType.isEnumElementType()) {\n         return maybeAddAutoboxes(\n-            cType, ((EnumElementType) jsType).getPrimitiveType(), prop);\n+            cType, jsType.toMaybeEnumElementType().getPrimitiveType(), prop);\n       }\n \n       if (jsType.autoboxesTo() != null) {\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n     private void checkForFunctionsWithUnknownTypes(Node function) {\n       Preconditions.checkArgument(NodeUtil.isFunction(function));\n \n-      FunctionType functionType = (FunctionType) function.getJSType();\n+      FunctionType functionType =\n+          JSType.toMaybeFunctionType(function.getJSType());\n \n       if (functionType == null) {\n         // No type information is available (CheckTypes was probably not run)\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n       String ownerTypeName = owner.getQualifiedName();\n       Var ownerVar = scope.getVar(ownerTypeName);\n       JSType ownerType = ownerVar == null ? null : ownerVar.getType();\n-      FunctionType ownerFnType = ownerType instanceof FunctionType ?\n-          (FunctionType) ownerType : null;\n+      FunctionType ownerFnType = JSType.toMaybeFunctionType(ownerType);\n       ObjectType instType =\n           ownerFnType == null || ownerFnType.isOrdinaryFunction() ?\n           null : ownerFnType.getInstanceType();\n--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java\n+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.EnumType;\n-import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n         objType.setJSDocInfo(docInfo);\n \n         if (objType.isConstructor() || objType.isInterface()) {\n-          ((FunctionType) objType).getInstanceType().setJSDocInfo(\n+          objType.toMaybeFunctionType(objType).getInstanceType().setJSDocInfo(\n               docInfo);\n         } else if (objType instanceof EnumType) {\n           ((EnumType) objType).getElementsType().setJSDocInfo(docInfo);\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n         // A.C() -> A.B(). However, this is not important in module code motion\n         // and will be ignored (for now).\n       }\n-      if (type.isFunctionType() && type.isConstructor()) {\n+      if (type.isConstructor()) {\n         return recordClassConstructorOrInterface(\n-            name, (FunctionType) type, n, parent, parent.getParent(), rValue);\n+            name, type.toMaybeFunctionType(),\n+            n, parent, parent.getParent(), rValue);\n       } else {\n         Name symbol = graph.defineNameIfNotExists(name, isExtern);\n         symbol.setType(type);\n       FunctionType classType = null;\n       String className = null;\n \n-      if (constructor instanceof FunctionType && constructor.isConstructor()) {\n+      if (constructor != null && constructor.isConstructor()) {\n         // Case where the class has been properly declared with @constructor\n-        classType = (FunctionType) constructor;\n+        classType = constructor.toMaybeFunctionType();\n         className = classType.getReferenceName();\n       } else {\n         // We'll guess it is a constructor even if it didn't have @constructor\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n         case Token.GET:\n           // GET must always return a function type.\n           if (valueType.isFunctionType()) {\n-            FunctionType fntype = ((FunctionType) valueType);\n+            FunctionType fntype = valueType.toMaybeFunctionType();\n             valueType = fntype.getReturnType();\n           } else {\n             return null;\n         case Token.SET:\n           if (valueType.isFunctionType()) {\n             // SET must always return a function type.\n-            FunctionType fntype = ((FunctionType) valueType);\n+            FunctionType fntype = valueType.toMaybeFunctionType();\n             Node param = fntype.getParametersNode().getFirstChild();\n             // SET function must always have one parameter.\n             valueType = param.getJSType();\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n       if (inExterns) {\n         JSType jstype = node.getJSType();\n         boolean knownLocalResult = false;\n-        if (jstype != null && jstype.isFunctionType()) {\n-          FunctionType functionType = (FunctionType) jstype;\n+        FunctionType functionType = JSType.toMaybeFunctionType(jstype);\n+        if (functionType != null) {\n           JSType jstypeReturn = functionType.getReturnType();\n           if (isLocalValueType(jstypeReturn, true)) {\n             knownLocalResult = true;\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n     }\n \n     private void visitFunction(NodeTraversal t, Node n) {\n-      FunctionType funType = (FunctionType) n.getJSType();\n-      if (!funType.isConstructor()) {\n+      FunctionType funType = n.getJSType().toMaybeFunctionType();\n+      if (funType != null && !funType.isConstructor()) {\n         return;\n       }\n \n      * Insert checks for the parameters of the function.\n      */\n     private void visitFunction(NodeTraversal t, Node n) {\n-      FunctionType funType = (FunctionType) n.getJSType();\n+      FunctionType funType = JSType.toMaybeFunctionType(n.getJSType());\n       Node block = n.getLastChild();\n       Node paramName = NodeUtil.getFunctionParameters(n).getFirstChild();\n       Node insertionPoint = null;\n \n     private void visitReturn(NodeTraversal t, Node n) {\n       Node function = t.getEnclosingFunction();\n-      FunctionType funType = (FunctionType) function.getJSType();\n+      FunctionType funType = function.getJSType().toMaybeFunctionType();\n \n       Node retValue = n.getFirstChild();\n       if (retValue == null) {\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.StaticReference;\n     this.parent = parent;\n     this.rootNode = rootNode;\n     JSType nodeType = rootNode.getJSType();\n-    if (nodeType != null && nodeType instanceof FunctionType) {\n-      thisType = ((FunctionType) nodeType).getTypeOfThis();\n+    if (nodeType != null && nodeType.isFunctionType()) {\n+      thisType = nodeType.toMaybeFunctionType().getTypeOfThis();\n     } else {\n       thisType = parent.thisType;\n     }\n--- a/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n     JSType rightType = right.getJSType();\n     ObjectType targetType =\n         typeRegistry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n-    if (rightType instanceof FunctionType) {\n-      targetType = (FunctionType) rightType;\n+    if (rightType != null && rightType.isFunctionType()) {\n+      targetType = rightType.toMaybeFunctionType();\n     }\n     Visitor<JSType> visitor;\n     if (outcome) {\n \n     @Override\n     public JSType caseUnknownType() {\n-      if (target instanceof FunctionType) {\n-        FunctionType funcTarget = (FunctionType) target;\n-        if (funcTarget.hasInstanceType()) {\n-          return funcTarget.getInstanceType();\n-        }\n+      FunctionType funcTarget = JSType.toMaybeFunctionType(target);\n+      if (funcTarget != null && funcTarget.hasInstanceType()) {\n+        return funcTarget.getInstanceType();\n       }\n       return getNativeType(UNKNOWN_TYPE);\n     }\n         return type;\n       }\n \n-      FunctionType funcTarget = (FunctionType) target;\n+      FunctionType funcTarget = target.toMaybeFunctionType();\n       if (funcTarget.hasInstanceType()) {\n         return type.getGreatestSubtype(funcTarget.getInstanceType());\n       }\n         return type;\n       }\n \n-      FunctionType funcTarget = (FunctionType) target;\n+      FunctionType funcTarget = target.toMaybeFunctionType();\n       if (funcTarget.hasInstanceType()) {\n         if (type.isSubtype(funcTarget.getInstanceType())) {\n           return null;\n         return type;\n       }\n \n-      FunctionType funcTarget = (FunctionType) target;\n+      FunctionType funcTarget = target.toMaybeFunctionType();\n       if (funcTarget.hasInstanceType()) {\n         return type.getRestrictedUnion(funcTarget.getInstanceType());\n       }\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n             }\n \n             if (type.isFunction()) {\n-              if (lhs.getJSType() == null\n-                  || !(lhs.getJSType() instanceof FunctionType)) {\n+              JSType lhsType = lhs.getJSType();\n+              if (lhsType == null) {\n                 break;\n               }\n-              ConcreteType retType = createType(((FunctionType)\n-                  lhs.getJSType().restrictByNotNullOrUndefined())\n-                  .getReturnType());\n+              FunctionType funType =\n+                  lhsType.restrictByNotNullOrUndefined().toMaybeFunctionType();\n+              if (funType == null) {\n+                break;\n+              }\n+              ConcreteType retType = createType(funType.getReturnType());\n               retType = createUnionWithSubTypes(retType);\n               ConcreteType newret = type.toFunction().getReturnSlot()\n                   .getType().unionWith(retType);\n           actions.addAll(getImplicitActionsFromCall(n, alt));\n         }\n         return actions;\n-      } else if (!(recvType instanceof FunctionType)) {\n+      } else if (!(recvType.isFunctionType())) {\n         return Lists.<Action>newArrayList();\n       }\n \n       String prop = receiver.getLastChild().getString();\n       if (objType != null &&\n           (objType.isPropertyInExterns(prop)) &&\n-          ((FunctionType) recvType).getParameters() != null) {\n+          (recvType.toMaybeFunctionType()).getParameters() != null) {\n         List<Action> actions = Lists.newArrayList();\n \n         // Look for a function type in the argument list.\n         Iterator<Node> paramIter =\n-            ((FunctionType) recvType).getParameters().iterator();\n+            (recvType.toMaybeFunctionType()).getParameters().iterator();\n         Iterator<Node> argumentIter = n.children().iterator();\n         argumentIter.next(); // Skip the function name.\n         while (paramIter.hasNext() && argumentIter.hasNext()) {\n           Node arg = argumentIter.next();\n           Node param = paramIter.next();\n-          if (arg.getJSType() instanceof FunctionType) {\n+          if (arg.getJSType() != null && arg.getJSType().isFunctionType()) {\n             actions.addAll(getImplicitActionsFromArgument(\n                 arg,\n-                ((FunctionType) arg.getJSType()).getTypeOfThis(),\n+                arg.getJSType().toMaybeFunctionType().getTypeOfThis(),\n                 param.getJSType()));\n           }\n         }\n               getImplicitActionsFromArgument(arg, thisType, paramAlt));\n         }\n         return actions;\n-      } else if (paramType instanceof FunctionType) {\n+      } else if (paramType.isFunctionType()) {\n         return Lists.<Action>newArrayList(createExternFunctionCall(\n-            arg, thisType, (FunctionType) paramType));\n+            arg, thisType, paramType.toMaybeFunctionType()));\n       } else {\n         return Lists.<Action>newArrayList(createExternFunctionCall(\n             arg, thisType, null));\n           thisType = ((FunctionPrototypeType) jsType)\n               .getOwnerFunction().getInstanceType();\n         }\n-        FunctionType callType = null;\n-        if (propType instanceof FunctionType) {\n-          callType = (FunctionType) propType;\n-        }\n+        FunctionType callType = propType.toMaybeFunctionType();\n         Action action = createExternFunctionCall(\n             fnNode, thisType, callType);\n         return Lists.<Action>newArrayList(action);\n     }\n \n     if (jsType.isFunctionType()) {\n-      if (getConcreteFunction((FunctionType) jsType) != null) {\n-        return getConcreteFunction((FunctionType) jsType);\n+      if (getConcreteFunction(jsType.toMaybeFunctionType()) != null) {\n+        return getConcreteFunction(jsType.toMaybeFunctionType());\n       }\n       // Since we don't have a declaration, it's not concrete.\n       return ConcreteType.ALL;\n       functionFromDeclaration.put(decl,\n           funType = new ConcreteFunctionType(this, decl, parent));\n       if (decl.getJSType() != null) {\n-        functionFromJSType.put((FunctionType) decl.getJSType(), funType);\n+        functionFromJSType.put(decl.getJSType().toMaybeFunctionType(), funType);\n       }\n     }\n     return funType;\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n     switch (n.getType()) {\n       case Token.FUNCTION:\n         // normal type checking\n-        final TypeCheck outerThis = this;\n         final Scope outerScope = t.getScope();\n-        final FunctionType functionType = (FunctionType) n.getJSType();\n         final String functionPrivateName = n.getFirstChild().getString();\n         if (functionPrivateName != null && functionPrivateName.length() > 0 &&\n             outerScope.isDeclared(functionPrivateName, false) &&\n \n       // object.prototype = ...;\n       if (property.equals(\"prototype\")) {\n-        if (objectJsType instanceof FunctionType) {\n-          FunctionType functionType = (FunctionType) objectJsType;\n+        if (objectJsType != null && objectJsType.isFunctionType()) {\n+          FunctionType functionType = objectJsType.toMaybeFunctionType();\n           if (functionType.isConstructor()) {\n             JSType rvalueType = rvalue.getJSType();\n             validator.expectObject(t, rvalue, rvalueType,\n         String property2 = NodeUtil.getStringValue(object.getLastChild());\n \n         if (\"prototype\".equals(property2)) {\n-          JSType jsType = object2.getJSType();\n-          if (jsType instanceof FunctionType) {\n-            FunctionType functionType = (FunctionType) jsType;\n+          JSType jsType = getJSType(object2);\n+          if (jsType.isFunctionType()) {\n+            FunctionType functionType = jsType.toMaybeFunctionType();\n             if (functionType.isConstructor() || functionType.isInterface()) {\n               checkDeclaredPropertyInheritance(\n                   t, assign, functionType, property, info, getJSType(rvalue));\n    */\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n-    FunctionType type = getFunctionType(constructor);\n-    if (type != null && type.isConstructor()) {\n-      visitParameterList(t, n, type);\n-      ensureTyped(t, n, type.getInstanceType());\n+    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n+    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n+      FunctionType fnType = type.toMaybeFunctionType();\n+      if (fnType != null) {\n+        visitParameterList(t, n, fnType);\n+        ensureTyped(t, n, fnType.getInstanceType());\n+      } else {\n+        ensureTyped(t, n);\n+      }\n     } else {\n       // TODO(user): add support for namespaced objects.\n       if (constructor.getType() != Token.GETPROP) {\n    * @param n The node being visited.\n    */\n   private void visitFunction(NodeTraversal t, Node n) {\n-    FunctionType functionType = (FunctionType) n.getJSType();\n+    FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());\n     String functionPrivateName = n.getFirstChild().getString();\n     if (functionType.isConstructor()) {\n       FunctionType baseConstructor = functionType.\n \n     // A couple of types can be called as if they were functions.\n     // If it is a function type, then validate parameters.\n-    if (childType instanceof FunctionType) {\n-      FunctionType functionType = (FunctionType) childType;\n+    if (childType.isFunctionType()) {\n+      FunctionType functionType = childType.toMaybeFunctionType();\n \n       boolean isExtern = false;\n       JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n     }\n     JSType jsType = getJSType(function);\n \n-    if (jsType instanceof FunctionType) {\n-      FunctionType functionType = (FunctionType) jsType;\n+    if (jsType.isFunctionType()) {\n+      FunctionType functionType = jsType.toMaybeFunctionType();\n \n       JSType returnType = functionType.getReturnType();\n \n       return getNativeType(UNKNOWN_TYPE);\n     } else {\n       return jsType;\n-    }\n-  }\n-\n-  /**\n-   * Gets the type of the node or {@code null} if the node's type is not a\n-   * function.\n-   */\n-  private FunctionType getFunctionType(Node n) {\n-    JSType type = getJSType(n).restrictByNotNullOrUndefined();\n-    if (type.isUnknownType()) {\n-      return typeRegistry.getNativeFunctionType(U2U_CONSTRUCTOR_TYPE);\n-    } else if (type instanceof FunctionType) {\n-      return (FunctionType) type;\n-    } else {\n-      return null;\n     }\n   }\n \n   private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n     // Make sure FUNCTION nodes always get function type.\n     Preconditions.checkState(n.getType() != Token.FUNCTION ||\n-            type instanceof FunctionType ||\n+            type.isFunctionType() ||\n             type.isUnknownType());\n     JSDocInfo info = n.getJSDocInfo();\n     if (info != null) {\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     Node left = n.getFirstChild();\n     JSType functionType = getJSType(left).restrictByNotNullOrUndefined();\n     if (functionType != null) {\n-      if (functionType instanceof FunctionType) {\n-        FunctionType fnType = (FunctionType) functionType;\n+      if (functionType.isFunctionType()) {\n+        FunctionType fnType = functionType.toMaybeFunctionType();\n         n.setJSType(fnType.getReturnType());\n         updateTypeOfParameters(n, fnType);\n         updateTypeOfThisOnClosure(n, fnType);\n         return;\n       }\n \n-      JSType iParameterType = iParameter.getJSType();\n+      JSType iParameterType = getJSType(iParameter);\n       Node iArgument = n.getChildAtIndex(i + 1);\n       JSType iArgumentType = getJSType(iArgument);\n       inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType);\n \n-      if (iParameterType instanceof FunctionType) {\n-        FunctionType iParameterFnType = (FunctionType) iParameterType;\n+      if (iParameterType.isFunctionType()) {\n+        FunctionType iParameterFnType = iParameterType.toMaybeFunctionType();\n \n         if (iArgument.getType() == Token.FUNCTION &&\n-            iArgumentType instanceof FunctionType &&\n+            iArgumentType.isFunctionType() &&\n             iArgument.getJSDocInfo() == null) {\n           iArgument.setJSType(iParameterFnType);\n         }\n         for (Node jParameter : fnType.getParameters()) {\n           JSType jParameterType =\n               getJSType(jParameter).restrictByNotNullOrUndefined();\n-          if (jParameterType instanceof FunctionType) {\n-            FunctionType jParameterFnType = (FunctionType) jParameterType;\n+          if (jParameterType.isFunctionType()) {\n+            FunctionType jParameterFnType = jParameterType.toMaybeFunctionType();\n             if (jParameterFnType.getTypeOfThis().equals(iParameterType)) {\n               foundTemplateTypeOfThisParameter = true;\n               // Find the actual type of the this argument.\n               Node jArgument = n.getChildAtIndex(j + 1);\n               JSType jArgumentType = getJSType(jArgument);\n               if (jArgument.getType() == Token.FUNCTION &&\n-                  jArgumentType instanceof FunctionType) {\n+                  jArgumentType.isFunctionType()) {\n                 if (iArgumentType != null &&\n                     // null and undefined get filtered out above.\n                     !iArgumentType.isNoType()) {\n                   // If it's an function expression, update the type of this\n                   // using the actual type of T.\n-                  FunctionType jArgumentFnType = (FunctionType) jArgumentType;\n+                  FunctionType jArgumentFnType = jArgumentType.toMaybeFunctionType();\n                   if (jArgumentFnType.getTypeOfThis().isUnknownType()) {\n                     // The new type will be picked up when we traverse the inner\n                     // function.\n       constructorType = constructorType.restrictByNotNullOrUndefined();\n       if (constructorType.isUnknownType()) {\n         type = getNativeType(UNKNOWN_TYPE);\n-      } else if (constructorType instanceof FunctionType) {\n-        FunctionType ct = (FunctionType) constructorType;\n-        if (ct.isConstructor()) {\n+      } else {\n+        FunctionType ct = constructorType.toMaybeFunctionType();\n+        if (ct == null && constructorType instanceof FunctionType) {\n+          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n+          // return null. But NoObjectType implements the FunctionType\n+          // interface, precisely because it can validly construct objects.\n+          ct = (FunctionType) constructorType;\n+        }\n+        if (ct != null && ct.isConstructor()) {\n           type = ct.getInstanceType();\n         }\n       }\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n     }\n \n     mismatches.add(new TypeMismatch(found, required, error));\n-    if (found instanceof FunctionType &&\n-        required instanceof FunctionType) {\n-      FunctionType fnTypeA = ((FunctionType) found);\n-      FunctionType fnTypeB = ((FunctionType) required);\n+    if (found.isFunctionType() &&\n+        required.isFunctionType()) {\n+      FunctionType fnTypeA = found.toMaybeFunctionType();\n+      FunctionType fnTypeB = required.toMaybeFunctionType();\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n       return type.toString();\n     } else if (qualifiedName != null) {\n       return qualifiedName;\n-    } else if (type instanceof FunctionType) {\n+    } else if (type.isFunctionType()) {\n       // Don't show complex function names.\n       return \"function\";\n     } else {\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n \n   private String getTypeAnnotation(Node node) {\n     JSType type = node.getJSType();\n-    if (type instanceof FunctionType) {\n+    if (type == null) {\n+      return \"\";\n+    } else if (type.isFunctionType()) {\n       return getFunctionAnnotation(node);\n-    } else if (type != null && !type.isUnknownType()\n+    } else if (!type.isUnknownType()\n         && !type.isEmptyType() && !type.isVoidType() &&\n         !type.isFunctionPrototypeType()) {\n       return \"/** @type {\" + node.getJSType() + \"} */\\n\";\n       return \"\";\n     }\n \n-    FunctionType funType = (FunctionType) fnNode.getJSType();\n+    FunctionType funType = type.toMaybeFunctionType();\n \n     // We need to use the child nodes of the function as the nodes for the\n     // parameters of the function type do not have the real parameter names.\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n     // build properties on.\n     for (Node functionNode : scopeBuilder.nonExternFunctions) {\n       JSType type = functionNode.getJSType();\n-      if (type != null && type instanceof FunctionType) {\n-        FunctionType fnType = (FunctionType) type;\n+      if (type != null && type.isFunctionType()) {\n+        FunctionType fnType = type.toMaybeFunctionType();\n         ObjectType fnThisType = fnType.getTypeOfThis();\n         if (!fnThisType.isUnknownType()) {\n           NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n       // Global ctor aliases should be registered with the type registry.\n       if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n         Var var = scope.getVar(rValue.getQualifiedName());\n-        if (var != null && var.getType() instanceof FunctionType) {\n-          FunctionType aliasedType  = (FunctionType) var.getType();\n+        if (var != null && var.getType() != null &&\n+            var.getType().isFunctionType()) {\n+          FunctionType aliasedType  = var.getType().toMaybeFunctionType();\n           if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&\n               !aliasedType.isNativeObjectType()) {\n             functionType = aliasedType;\n           // Known to be not null since we have the FUNCTION token there.\n           type = type.restrictByNotNullOrUndefined();\n           if (type.isFunctionType()) {\n-            functionType = (FunctionType) type;\n+            functionType = type.toMaybeFunctionType();\n             functionType.setJSDocInfo(info);\n           }\n         }\n       // First, check to see if the property is implemented\n       // on a superclass.\n       JSType propType = ownerType.getPropertyType(propName);\n-      if (propType instanceof FunctionType) {\n-        return (FunctionType) propType;\n+      if (propType != null && propType.isFunctionType()) {\n+        return propType.toMaybeFunctionType();\n       } else {\n         // If it's not, then check to see if it's implemented\n         // on an implemented interface.\n         for (ObjectType iface :\n                  ownerType.getCtorImplementedInterfaces()) {\n           propType = iface.getPropertyType(propName);\n-          if (propType instanceof FunctionType) {\n-            return (FunctionType) propType;\n+          if (propType != null && propType.isFunctionType()) {\n+            return propType.toMaybeFunctionType();\n           }\n         }\n       }\n         }\n \n         // We need to do some additional work for constructors and interfaces.\n-        if (type instanceof FunctionType &&\n+        FunctionType fnType = JSType.toMaybeFunctionType(type);\n+        if (fnType != null &&\n             // We don't want to look at empty function types.\n             !type.isEmptyType()) {\n-          FunctionType fnType = (FunctionType) type;\n           if ((fnType.isConstructor() || fnType.isInterface()) &&\n               !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n             // Declare var.prototype in the scope chain.\n       }\n \n       if (isGlobalVar && \"Window\".equals(variableName)\n-          && type instanceof FunctionType\n+          && type != null\n+          && type.isFunctionType()\n           && type.isConstructor()) {\n         FunctionType globalThisCtor =\n             typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor();\n         globalThisCtor.getInstanceType().clearCachedValues();\n         globalThisCtor.getPrototype().clearCachedValues();\n         globalThisCtor\n-            .setPrototypeBasedOn(((FunctionType) type).getInstanceType());\n+            .setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType());\n       }\n     }\n \n         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n       } else if (rValue != null && rValue.getType() == Token.FUNCTION &&\n           shouldUseFunctionLiteralType(\n-              (FunctionType) rValue.getJSType(), info, lValue)) {\n+              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n         return rValue.getJSType();\n       } else if (info != null) {\n         if (info.hasEnumParameterType()) {\n     private FunctionType getFunctionType(@Nullable Var v) {\n       JSType t = v == null ? null : v.getType();\n       ObjectType o = t == null ? null : t.dereference();\n-      return o instanceof FunctionType ? ((FunctionType) o) : null;\n+      return JSType.toMaybeFunctionType(o);\n     }\n \n     /**\n       } else if (rhsValue != null &&\n           rhsValue.getType() == Token.TRUE) {\n         // We declare these for delegate proxy method properties.\n-        ObjectType ownerType = getObjectSlot(ownerName);\n-        if (ownerType instanceof FunctionType) {\n-          JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();\n+        FunctionType ownerType =\n+            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n+        if (ownerType != null) {\n+          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n           String delegateName = codingConvention.getDelegateSuperclassName();\n           JSType delegateType = delegateName == null ?\n               null : typeRegistry.getType(delegateName);\n           if (delegateType != null &&\n               ownerTypeOfThis.isSubtype(delegateType)) {\n-            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),\n-                true);\n+            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n           }\n         }\n       }\n     private void declareArguments(Node functionNode) {\n       Node astParameters = functionNode.getFirstChild().getNext();\n       Node body = astParameters.getNext();\n-      FunctionType functionType = (FunctionType) functionNode.getJSType();\n+      FunctionType functionType =\n+          JSType.toMaybeFunctionType(functionNode.getJSType());\n       if (functionType != null) {\n         Node jsDocParameters = functionType.getParametersNode();\n         if (jsDocParameters != null) {\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n   }\n \n   @Override\n-  public boolean isEnumElementType() {\n-    return true;\n+  public EnumElementType toMaybeEnumElementType() {\n+    return this;\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   }\n \n   @Override\n-  public boolean isFunctionType() {\n-    return true;\n+  public FunctionType toMaybeFunctionType() {\n+    return this;\n   }\n \n   @Override\n         return this;\n       }\n \n-      FunctionType other = null;\n-      if (that instanceof FunctionType) {\n-        other = (FunctionType) that;\n-      }\n+      FunctionType other = that.toMaybeFunctionType();\n \n       // If these are ordinary functions, then merge them.\n       // Don't do this if any of the params/return\n    */\n   @Override\n   public boolean isEquivalentTo(JSType otherType) {\n-    if (!(otherType instanceof FunctionType)) {\n-      return false;\n-    }\n-    FunctionType that = (FunctionType) otherType;\n-    if (!that.isFunctionType()) {\n+    FunctionType that =\n+        JSType.toMaybeFunctionType(otherType.toMaybeFunctionType());\n+    if (that == null) {\n       return false;\n     }\n     if (this.isConstructor()) {\n     }\n \n     if (that.isFunctionType()) {\n-      if (((FunctionType) that).isInterface()) {\n+      FunctionType other = that.toMaybeFunctionType();\n+      if (other.isInterface()) {\n         // Any function can be assigned to an interface function.\n         return true;\n       }\n       // this as an error. It also screws up out standard method\n       // for aliasing constructors. Let's punt on all this for now.\n       // TODO(nicksantos): fix this.\n-      FunctionType other = (FunctionType) that;\n       boolean treatThisTypesAsCovariant =\n         // If either one of these is a ctor, skip 'this' checking.\n         this.isConstructor() || other.isConstructor() ||\n \n     if (subTypes != null) {\n       for (int i = 0; i < subTypes.size(); i++) {\n-        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+        subTypes.set(\n+            i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope)));\n       }\n     }\n \n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n     return null;\n   }\n \n-  public boolean isFunctionType() {\n-    return false;\n-  }\n-\n-  public boolean isEnumElementType() {\n-    return false;\n+  /** Returns true if toMaybeFunctionType returns a non-null FunctionType. */\n+  public final boolean isFunctionType() {\n+    return toMaybeFunctionType() != null;\n+  }\n+\n+  /**\n+   * Downcasts this to a FunctionType, or returns null if this is not\n+   * a function.\n+   *\n+   * For the purposes of this function, we define a MaybeFunctionType as any\n+   * type in the sub-lattice\n+   * { x | LEAST_FUNCTION_TYPE <= x <= GREATEST_FUNCTION_TYPE }\n+   * This definition excludes bottom types like NoType and NoObjectType.\n+   *\n+   * This definition is somewhat arbitrary and axiomatic, but this is the\n+   * definition that makes the most sense for the most callers.\n+   */\n+  public FunctionType toMaybeFunctionType() {\n+    return null;\n+  }\n+\n+  /**\n+   * Null-safe version of toMaybeFunctionType().\n+   */\n+  public static FunctionType toMaybeFunctionType(JSType type) {\n+    return type == null ? null : type.toMaybeFunctionType();\n+  }\n+\n+  public final boolean isEnumElementType() {\n+    return toMaybeEnumElementType() != null;\n+  }\n+\n+  /**\n+   * Downcasts this to an EnumElementType, or returns null if this is not an EnumElementType.\n+   */\n+  public EnumElementType toMaybeEnumElementType() {\n+    return null;\n   }\n \n   public boolean isEnumType() {\n \n   /**\n    * Whether this type is an Instance object of some constructor.\n+   * Does not necessarily mean this is an {@link InstanceObjectType}.\n    */\n   public boolean isInstanceType() {\n     return false;\n       return thatType.toMaybeUnionType().meet(thisType);\n     }\n \n-    if (thisType instanceof EnumElementType) {\n-      JSType inf = ((EnumElementType) thisType).meet(thatType);\n+    if (thisType.isEnumElementType()) {\n+      JSType inf = thisType.toMaybeEnumElementType().meet(thatType);\n       if (inf != null) {\n         return inf;\n       }\n-    } else if (thatType instanceof EnumElementType) {\n-      JSType inf = ((EnumElementType) thatType).meet(thisType);\n+    } else if (thatType.isEnumElementType()) {\n+      JSType inf = thatType.toMaybeEnumElementType().meet(thisType);\n       if (inf != null) {\n         return inf;\n       }\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n                                     StaticScope<JSType> enclosing) {\n     JSType value = lookupViaProperties(t, enclosing);\n     // last component of the chain\n-    if ((value instanceof FunctionType) &&\n-        (value.isConstructor() || value.isInterface())) {\n-      FunctionType functionType = (FunctionType) value;\n+    if (value != null && (value.isConstructor() || value.isInterface())) {\n+      FunctionType functionType = value.toMaybeFunctionType();\n       setReferencedAndResolvedType(\n           functionType.getInstanceType(), t, enclosing);\n     } else if (value instanceof EnumType) {\n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n   }\n \n   @Override\n-  public boolean isFunctionType() {\n-    return false;\n+  public FunctionType toMaybeFunctionType() {\n+    return null;\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public boolean isEnumElementType() {\n-    return referencedType.isEnumElementType();\n-  }\n-\n-  @Override\n   public boolean isConstructor() {\n     return referencedType.isConstructor();\n   }\n   @Override\n   public UnionType toMaybeUnionType() {\n     return referencedType.toMaybeUnionType();\n+  }\n+\n+  @Override\n+  public FunctionType toMaybeFunctionType() {\n+    return referencedType.toMaybeFunctionType();\n+  }\n+\n+  @Override\n+  public EnumElementType toMaybeEnumElementType() {\n+    return referencedType.toMaybeEnumElementType();\n   }\n \n   @Override", "timestamp": 1313685511, "metainfo": ""}