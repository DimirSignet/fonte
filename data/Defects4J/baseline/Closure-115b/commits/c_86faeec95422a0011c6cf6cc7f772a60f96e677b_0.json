{"sha": "86faeec95422a0011c6cf6cc7f772a60f96e677b", "log": "Add stable renaming support for ReplaceStrings.  R=mwr,nicksantos DELTA=85  (77 added, 0 deleted, 8 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5690   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.SourcePosition;\n import java.io.Serializable;\n+import java.text.ParseException;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n   /** Configuration strings */\n   List<String> replaceStringsFunctionDescriptions;\n+\n   String replaceStringsPlaceholderToken;\n   // A list of strings that should not be used as replacements\n   Set<String> replaceStringsReservedStrings;\n+  // A previous map of replacements to strings.\n+  VariableMap replaceStringsInputMap;\n \n   /** List of properties that we report invalidation errors for. */\n   Map<String, CheckLevel> propertyInvalidationErrors;\n     this.replaceStringsReservedStrings = replaceStringsReservedStrings;\n   }\n \n+  public void setReplaceStringsInputMapSerialized(byte[] serializedMap)\n+      throws ParseException {\n+    this.replaceStringsInputMap = VariableMap.fromBytes(serializedMap);\n+  }\n+\n   public void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n   }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n               compiler,\n               options.replaceStringsPlaceholderToken,\n               options.replaceStringsFunctionDescriptions,\n-              options.replaceStringsReservedStrings);\n+              options.replaceStringsReservedStrings,\n+              options.replaceStringsInputMap);\n           pass.process(externs, root);\n           stringMap = pass.getStringMap();\n         }\n--- a/src/com/google/javascript/jscomp/ReplaceStrings.java\n+++ b/src/com/google/javascript/jscomp/ReplaceStrings.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n    *     function($,,,)\n    *   or\n    *     class.prototype.method($,,,)\n-   * @param reservedNames A set of names that should not be used as replacement\n+   * @param blacklisted A set of names that should not be used as replacement\n    *     strings.  Useful to prevent unwanted strings for appearing in the\n    *     final output.\n    * where '$' is used to indicate which parameter should be replaced.\n   ReplaceStrings(\n       AbstractCompiler compiler, String placeholderToken,\n       List<String> functionsToInspect,\n-      Set<String> reservedNames) {\n+      Set<String> blacklisted,\n+      VariableMap previousMappings) {\n     this.compiler = compiler;\n     this.placeholderToken = placeholderToken.isEmpty()\n         ? DEFAULT_PLACEHOLDER_TOKEN : placeholderToken;\n     this.registry = compiler.getTypeRegistry();\n+\n+    Iterable<String> reservedNames = blacklisted;\n+    if (previousMappings != null) {\n+      Set<String> previous =\n+          previousMappings.getOriginalNameToNewNameMap().keySet();\n+      reservedNames = Iterables.concat(blacklisted, previous);\n+      initMapping(previousMappings, blacklisted);\n+    }\n     this.nameGenerator = createNameGenerator(reservedNames);\n \n     // Initialize the map of functions to inspect for renaming candidates.\n     parseConfiguration(functionsToInspect);\n   }\n \n+  private void initMapping(\n+      VariableMap previousVarMap, Set<String> reservedNames) {\n+    Map<String,String> previous = previousVarMap.getOriginalNameToNewNameMap();\n+    for (Map.Entry<String,String> entry : previous.entrySet()) {\n+      String key = entry.getKey();\n+      if (!reservedNames.contains(key)) {\n+        String value = entry.getValue();\n+        results.put(value, new Result(value, key));\n+      }\n+    }\n+  }\n+\n+  static final Predicate<Result> USED_RESULTS = new Predicate<Result>() {\n+    @Override\n+    public boolean apply(Result result) {\n+      // The list of locations may be empty if the map\n+      // was pre-populated from a previous map.\n+      return !result.replacementLocations.isEmpty();\n+    }\n+  };\n+\n   // Get the list of all replacements performed.\n   List<Result> getResult() {\n-    return ImmutableList.copyOf(results.values());\n+    return ImmutableList.copyOf(\n+        Iterables.filter(results.values(), USED_RESULTS));\n   }\n \n   // Get the list of replaces as a VariableMap\n   VariableMap getStringMap() {\n     Map<String, String> map = Maps.newHashMap();\n-    for (Result result : results.values()) {\n+    for (Result result : Iterables.filter(results.values(), USED_RESULTS)) {\n       map.put(result.replacement, result.original);\n     }\n \n    * Use a name generate to create names so the names overlap with the names\n    * used for variable and properties.\n    */\n-  private static NameGenerator createNameGenerator(Set<String> reservedNames) {\n+  private static NameGenerator createNameGenerator(Iterable<String> reserved) {\n     final String namePrefix = \"\";\n     final char[] reservedChars = new char[0];\n     return new NameGenerator(\n-        ImmutableSet.copyOf(reservedNames), namePrefix, reservedChars);\n+        ImmutableSet.copyOf(reserved), namePrefix, reservedChars);\n   }\n }\n--- a/test/com/google/javascript/jscomp/ReplaceStringsTest.java\n+++ b/test/com/google/javascript/jscomp/ReplaceStringsTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.ReplaceStrings.Result;\n public class ReplaceStringsTest extends CompilerTestCase {\n   private ReplaceStrings pass;\n   private Set<String> reserved;\n+  private VariableMap previous;\n \n   private final static String EXTERNS =\n     \"var goog = {};\\n\" +\n     super.enableLineNumberCheck(false);\n     super.enableTypeCheck(CheckLevel.OFF);\n     reserved = Collections.emptySet();\n+    previous = null;\n   }\n \n   @Override\n         \"goog.debug.Logger.getLogger(?)\",\n         \"goog.debug.Logger.prototype.info(?)\"\n         );\n-    pass = new ReplaceStrings(compiler, \"`\", names, reserved);\n+    pass = new ReplaceStrings(compiler, \"`\", names, reserved, previous);\n \n     return new CompilerPass() {\n         @Override\n     return 1;\n   }\n \n+  public void testStable1() {\n+    previous = VariableMap.fromMap(ImmutableMap.of(\"previous\",\"xyz\"));\n+    testDebugStrings(\n+        \"Error('xyz');\",\n+        \"Error('previous');\",\n+        (new String[] { \"previous\", \"xyz\" }));\n+    reserved = ImmutableSet.of(\"a\", \"b\", \"previous\");\n+    testDebugStrings(\n+        \"Error('xyz');\",\n+        \"Error('c');\",\n+        (new String[] { \"c\", \"xyz\" }));\n+  }\n+\n+  public void testStable2() {\n+    // Two things happen here:\n+    // 1) a previously used name \"a\" is not used for another string, \"b\" is\n+    // chosen instead.\n+    // 2) a previously used name \"a\" is dropped from the output map if\n+    // it isn't used.\n+    previous = VariableMap.fromMap(ImmutableMap.of(\"a\",\"unused\"));\n+    testDebugStrings(\n+        \"Error('xyz');\",\n+        \"Error('b');\",\n+        (new String[] { \"b\", \"xyz\" }));\n+  }\n+\n   public void testThrowError1() {\n     testDebugStrings(\n         \"throw Error('xyz');\",\n         \"throw Error('a');\",\n         (new String[] { \"a\", \"xyz\" }));\n+    previous = VariableMap.fromMap(ImmutableMap.of(\"previous\",\"xyz\"));\n+    testDebugStrings(\n+        \"throw Error('xyz');\",\n+        \"throw Error('previous');\",\n+        (new String[] { \"previous\", \"xyz\" }));\n   }\n \n   public void testThrowError2() {", "timestamp": 1350922713, "metainfo": ""}