{"sha": "0ab589113877249aaa4a74d29d135920a3534e08", "log": "Further improve performance of MinimizeConditions.  Keep track of which trees are changed/unchanged when building the minimized condition trees, and use this information instead of calling the expensive Node.isEquivalentTo() method to determine if there are changes to the AST. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46692215", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n+++ b/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n       // with MinimizeExitPoints.\n \n       case Token.NOT:\n-        tryMinimizeCondition(node.getFirstChild(), true);\n+        tryMinimizeCondition(node.getFirstChild());\n         return tryMinimizeNot(node);\n \n       case Token.IF:\n         return tryMinimizeIf(node);\n \n       case Token.EXPR_RESULT:\n-        tryMinimizeCondition(node.getFirstChild(), false);\n-        return node;\n+        performConditionSubstitutions(node.getFirstChild());\n+        return tryMinimizeExprResult(node);\n \n       case Token.HOOK:\n-        tryMinimizeCondition(node.getFirstChild(), false);\n+        performConditionSubstitutions(node.getFirstChild());\n         return tryMinimizeHook(node);\n \n       case Token.WHILE:\n       case Token.DO:\n-        tryMinimizeCondition(NodeUtil.getConditionExpression(node), true);\n+        tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n         return node;\n \n       case Token.FOR:\n         if (!NodeUtil.isForIn(node)) {\n           tryJoinForCondition(node);\n-          tryMinimizeCondition(NodeUtil.getConditionExpression(node), true);\n+          tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n         }\n         return node;\n \n     return newOperator;\n   }\n \n+\n+  /**\n+   * Try to remove leading NOTs from EXPR_RESULTS.\n+   *\n+   * Returns the replacement for n or the original if no replacement was\n+   * necessary.\n+   */\n+  private Node tryMinimizeExprResult(Node node) {\n+    Node originalCond = node.getFirstChild();\n+    MinimizedCondition minCond = (aggressiveMinimization) ?\n+        MinimizedCondition.fromConditionNode(originalCond) :\n+          MinimizedCondition.unoptimized(originalCond);\n+    MinimizedCondition.MeasuredNode mNode =\n+        minCond.getShorterRepresentation(false);\n+    if (mNode.node.isNot()) {\n+      // Remove the leading NOT in the EXPR_RESULT.\n+      node.replaceChild(originalCond, mNode.node.removeFirstChild());\n+      reportCodeChange();\n+    } else {\n+      maybeReplaceNode(originalCond, mNode);\n+    }\n+    return node;\n+  }\n+\n   /**\n    * Try flipping HOOKs that have negated conditions.\n    *\n    * necessary.\n    */\n   private Node tryMinimizeHook(Node n) {\n-    Node cond = n.getFirstChild();\n-    if (cond.isNot()) {\n-      Node thenBranch = cond.getNext();\n-      n.replaceChild(cond, cond.removeFirstChild());\n+    Node originalCond = n.getFirstChild();\n+    MinimizedCondition minCond = (aggressiveMinimization) ?\n+        MinimizedCondition.fromConditionNode(originalCond) :\n+          MinimizedCondition.unoptimized(originalCond);\n+    MinimizedCondition.MeasuredNode mNode =\n+        minCond.getShorterRepresentation(false);\n+    if (mNode.node.isNot()) {\n+      // Swap the HOOK\n+      Node thenBranch = originalCond.getNext();\n+      n.replaceChild(originalCond, mNode.node.removeFirstChild());\n       n.removeChild(thenBranch);\n       n.addChildToBack(thenBranch);\n       reportCodeChange();\n+    } else {\n+      maybeReplaceNode(originalCond, mNode);\n     }\n     return n;\n   }\n     Node thenBranch = originalCond.getNext();\n     Node elseBranch = thenBranch.getNext();\n \n-\n-    Node unnegatedCond;\n-    Node shortCond;\n+    MinimizedCondition.MeasuredNode unnegatedCond;\n+    MinimizedCondition.MeasuredNode shortCond;\n     if (aggressiveMinimization) {\n       MinimizedCondition minCond = MinimizedCondition\n           .fromConditionNode(originalCond);\n       unnegatedCond = minCond.getShorterRepresentation(true);\n       shortCond = minCond.getShorterRepresentation(false);\n     } else {\n-      unnegatedCond = originalCond;\n-      shortCond = originalCond;\n+      unnegatedCond = new MinimizedCondition.MeasuredNode(\n+          originalCond, 0, false);\n+      shortCond = unnegatedCond;\n     }\n \n     if (elseBranch == null) {\n           return n;\n         }\n \n-        if (shortCond.isNot()) {\n+        if (shortCond.node.isNot()) {\n           // if(!x)bar(); -> x||bar();\n           Node or = IR.or(\n-              shortCond.removeFirstChild(),\n+              shortCond.node.removeFirstChild(),\n               expr.removeFirstChild()).srcref(n);\n           Node newExpr = NodeUtil.newExpr(or);\n           parent.replaceChild(n, newExpr);\n \n           return newExpr;\n         }\n-        Preconditions.checkState(shortCond.isEquivalentTo(unnegatedCond));\n+        // True, but removed for performance reasons.\n+        // Preconditions.checkState(shortCond.isEquivalentTo(unnegatedCond));\n \n         // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedence(shortCond, AND_PRECEDENCE) &&\n+        if (isLowerPrecedence(shortCond.node, AND_PRECEDENCE) &&\n             isLowerPrecedence(expr.getFirstChild(),\n                 AND_PRECEDENCE)) {\n           // One additional set of parentheses is worth the change even if\n         }\n \n         n.removeChild(originalCond);\n-        Node and = IR.and(shortCond, expr.removeFirstChild()).srcref(n);\n+        Node and = IR.and(shortCond.node, expr.removeFirstChild()).srcref(n);\n         Node newExpr = NodeUtil.newExpr(and);\n         parent.replaceChild(n, newExpr);\n         reportCodeChange();\n             Node innerElseBranch = innerThenBranch.getNext();\n \n             if (innerElseBranch == null &&\n-                 !(isLowerPrecedence(unnegatedCond, AND_PRECEDENCE) &&\n+                 !(isLowerPrecedence(unnegatedCond.node, AND_PRECEDENCE) &&\n                    isLowerPrecedence(innerCond, AND_PRECEDENCE))) {\n               n.detachChildren();\n               n.addChildToBack(\n                   IR.and(\n-                      unnegatedCond,\n+                      unnegatedCond.node,\n                       innerCond.detachFromParent())\n                       .srcref(originalCond));\n               n.addChildrenToBack(innerThenBranch.detachFromParent());\n \n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n-    if (shortCond.isNot() && !consumesDanglingElse(elseBranch)) {\n-      n.replaceChild(originalCond, shortCond.removeFirstChild());\n+    if (shortCond.node.isNot() && !consumesDanglingElse(elseBranch)) {\n+      n.replaceChild(originalCond, shortCond.node.removeFirstChild());\n       n.removeChild(thenBranch);\n       n.addChildToBack(thenBranch);\n       reportCodeChange();\n       // can be converted to \"return undefined;\" or some variant, but\n       // that does not help code size.\n       Node returnNode = IR.returnNode(\n-                            IR.hook(shortCond, thenExpr, elseExpr)\n+                            IR.hook(shortCond.node, thenExpr, elseExpr)\n                                 .srcref(n));\n       parent.replaceChild(n, returnNode);\n       reportCodeChange();\n             Node elseExpr = elseOp.getLastChild();\n             elseOp.removeChild(elseExpr);\n \n-            Node hookNode = IR.hook(shortCond, thenExpr, elseExpr).srcref(n);\n+            Node hookNode = IR.hook(shortCond.node, thenExpr, elseExpr).srcref(n);\n             Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                               .srcref(thenOp);\n             Node expr = NodeUtil.newExpr(assign);\n       thenOp.detachFromParent();\n       elseOp.detachFromParent();\n       Node expr = IR.exprResult(\n-          IR.hook(shortCond, thenOp, elseOp).srcref(n));\n+          IR.hook(shortCond.node, thenOp, elseOp).srcref(n));\n       parent.replaceChild(n, expr);\n       reportCodeChange();\n       return expr;\n         Node thenExpr = name1.removeChildren();\n         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n         originalCond.detachFromParent();\n-        Node hookNode = IR.hook(shortCond, thenExpr, elseExpr)\n+        Node hookNode = IR.hook(shortCond.node, thenExpr, elseExpr)\n                             .srcref(n);\n         var.detachFromParent();\n         name1.addChildrenToBack(hookNode);\n         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n         Node elseExpr = name2.removeChildren();\n         originalCond.detachFromParent();\n-        Node hookNode = IR.hook(shortCond, thenExpr, elseExpr)\n+        Node hookNode = IR.hook(shortCond.node, thenExpr, elseExpr)\n                             .srcref(n);\n         var.detachFromParent();\n         name2.addChildrenToBack(hookNode);\n    *\n    * @return The replacement for n, or the original if no change was made.\n    */\n-  private Node tryMinimizeCondition(Node n, boolean countLeadingNot) {\n+  private Node tryMinimizeCondition(Node n) {\n     n = performConditionSubstitutions(n);\n     if (aggressiveMinimization) {\n-      return demorganMinimizeCondition(n, countLeadingNot);\n+      MinimizedCondition minCond = MinimizedCondition.fromConditionNode(n);\n+      return maybeReplaceNode(n, minCond.getShorterRepresentation(true));\n     } else {\n       return n;\n     }\n   }\n \n-  /**\n-   *  Minimize the given conditional node according to De Morgan's Laws.\n-   *    !(x && !y)  ==> !x || y\n-   *    (!a || !b || !c || !d)  ==>  !(a && b && c && d)\n-   *  etc.\n-   *\n-   * @param countLeadingNot When this is false, do not count a leading\n-   *  NOT in doing the minimization. i.e. Allow minimizations such as:\n-   *    (!x || !y || z)  ==>  !(x && y && !z)\n-   *  This is useful in contexts such as IFs or HOOKs where subsequent\n-   *  optimizations can efficiently deal with leading NOTs.\n-   *\n-   * @param n The conditional node.\n-   * @return The minimized version of n, or n if no minimization was possible.\n-   */\n-  private Node demorganMinimizeCondition(Node n, boolean countLeadingNot) {\n-    MinimizedCondition minCond = MinimizedCondition.fromConditionNode(n);\n-    Node newNode = minCond.getShorterRepresentation(countLeadingNot);\n-    return maybeReplaceNode(n, newNode);\n-  }\n-\n-  private Node maybeReplaceNode(Node lhs, Node rhs) {\n-    if (lhs.isEquivalentTo(rhs)) {\n+  private Node maybeReplaceNode(Node lhs, MinimizedCondition.MeasuredNode rhs) {\n+    if (!rhs.changed) {\n       return lhs;\n     }\n+    // Removed for performance reasons.\n+    // Preconditions.checkState(!lhs.isEquivalentTo(rhs.node));\n     Node parent = lhs.getParent();\n-    parent.replaceChild(lhs, rhs);\n+    parent.replaceChild(lhs, rhs.node);\n     reportCodeChange();\n-    return rhs;\n+    return rhs.node;\n   }\n \n   /** A class that represents a minimized conditional expression.\n     static class MeasuredNode {\n       Node node;\n       int length;\n-\n-      MeasuredNode(Node n, int len) {\n+      boolean changed;\n+\n+      MeasuredNode(Node n, int len, boolean ch) {\n         node = n;\n         length = len;\n+        changed = ch;\n       }\n \n       private MeasuredNode negate() {\n+        return addNot().change();\n+      }\n+\n+      private MeasuredNode change() {\n+        this.changed = true;\n+        return this;\n+      }\n+\n+      private MeasuredNode addNot() {\n         int complementOperator;\n         switch (node.getType()) {\n           default:\n           case Token.NOT:\n             length -= estimateCostOneLevel(node);\n             node = node.removeFirstChild();\n+            this.changed = true;\n             return this;\n           // Otherwise a binary operator with a complement.\n           case Token.EQ:\n         }\n         // Clone entire tree and just change operator.\n         node.setType(complementOperator);\n+        this.changed = true;\n         return this;\n       }\n \n       }\n \n       MeasuredNode cloneTree() {\n-        return new MeasuredNode(node.cloneTree(), length);\n+        return new MeasuredNode(node.cloneTree(), length, changed);\n       }\n \n       static MeasuredNode addNode(int opType, Node infoSource,\n           MeasuredNode l, MeasuredNode r) {\n         Node newNode = new Node(opType, l.node, r.node).srcref(infoSource);\n         int newCost = estimateCostOneLevel(newNode) + l.length + r.length;\n-        return new MeasuredNode(newNode, newCost);\n+        return new MeasuredNode(newNode, newCost, l.changed || r.changed);\n       }\n     }\n     private final MeasuredNode positive;\n     private final MeasuredNode negative;\n \n     private MinimizedCondition(MeasuredNode p, MeasuredNode n) {\n-      //Preconditions.checkArgument(p.getParent() == null);\n-      //Preconditions.checkArgument(n.getParent() == null);\n+      Preconditions.checkArgument(p.node.getParent() == null);\n+      Preconditions.checkArgument(n.node.getParent() == null);\n+      Preconditions.checkState(n.changed);\n       positive = p;\n       negative = n;\n     }\n         case Token.NOT: {\n           MinimizedCondition subtree = fromConditionNode(n.getFirstChild());\n           ImmutableSet<MeasuredNode> positiveAsts = ImmutableSet.of(\n-              subtree.positive.cloneTree().negate(),\n+              subtree.positive.cloneTree().addNot(),\n               subtree.negative.cloneTree());\n+          subtree.positive.changed = true;\n           ImmutableSet<MeasuredNode> negativeAsts = ImmutableSet.of(\n               subtree.negative.negate(),\n-              subtree.positive);\n+              subtree.positive.change());\n           return new MinimizedCondition(\n               Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n               Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n               Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n         }\n         default:\n-          MeasuredNode pos = new MeasuredNode(n.cloneTree(), 0);\n-          MeasuredNode neg = pos.cloneTree().negate();\n-          return new MinimizedCondition(pos, neg);\n-      }\n+          return unoptimized(n);\n+      }\n+    }\n+\n+    static MinimizedCondition unoptimized(Node n) {\n+      MeasuredNode pos = new MeasuredNode(n.cloneTree(), 0, false);\n+      MeasuredNode neg = pos.cloneTree().negate();\n+      return new MinimizedCondition(pos, neg);\n     }\n \n     Node getNode() {\n \n     Node getNegatedNode() {\n       return negative.node;\n-    }\n-\n-    int getLength() {\n-      return positive.length;\n-    }\n-\n-    int getNegativeLength() {\n-      return negative.length;\n     }\n \n     /** Return the shorter representation of the original condition node.\n      *  This is useful in contexts such as IFs or HOOKs where subsequent\n      *  optimizations can efficiently deal with leading NOTs.\n      *\n-     *  @return The minimized condition Node, equivalent to that\n-     *    passed to #fromConditionNode().\n+     *  @return The minimized condition MeasuredNode, with equivalent value\n+     *    to that passed to #fromConditionNode().\n      */\n-    Node getShorterRepresentation(boolean countLeadingNot) {\n-      if (countLeadingNot || getLength() <= getNegativeLength()) {\n-       return getNode();\n+    MeasuredNode getShorterRepresentation(boolean countLeadingNot) {\n+     if (countLeadingNot || positive.length <= negative.length) {\n+       return positive;\n      } else {\n-       return new Node(Token.NOT, getNegatedNode());\n+       return negative.negate();\n      }\n     }\n \n--- a/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n   }\n \n   public void testMinimizeExprResult() {\n-    fold(\"!x||!y\", \"!(x&&y)\");\n-    fold(\"if(!(x&&!y)) foo()\", \"!(x&&!y||!foo())\");\n-    fold(\"if(!x||y) foo()\", \"!(x&&!y||!foo())\");\n+    fold(\"!x||!y\", \"x&&y\");\n+    fold(\"if(!(x&&!y)) foo()\", \"x&&!y||!foo()\");\n+    fold(\"if(!x||y) foo()\", \"x&&!y||!foo()\");\n   }\n \n   public void testMinimizeDemorgan21() {", "timestamp": 1368659666, "metainfo": ""}