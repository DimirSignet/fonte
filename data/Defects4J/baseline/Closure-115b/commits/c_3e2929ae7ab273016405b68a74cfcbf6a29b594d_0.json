{"sha": "3e2929ae7ab273016405b68a74cfcbf6a29b594d", "log": "Fix incorrect attachment of jsdoc comments to nodes. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=47056594", "commit": "\n--- /dev/null\n+++ b/lib/rhino/src/org/mozilla/javascript/AttachJsDocs.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n+\n+package org.mozilla.javascript;\n+\n+import org.mozilla.javascript.ast.*;\n+\n+import java.util.List;\n+\n+/**\n+ * After parsing is done and the jsdocs are collected, this class takes the AST\n+ * and the jsdocs and attaches the jsdocs to the appropriate AST nodes.\n+ * <p>\n+ * The jsdoc comments are not part of the syntax of JavaScript, so we cannot\n+ * give parse errors for misplaced jsdocs. We should not modify the grammar\n+ * recognized by the parser in order to attach jsdocs.\n+ * On the other hand, in Closure-style JavaScript the placement of jsdocs is\n+ * syntax-driven; there is intuitively some grammar that dictates where in the\n+ * AST each comment should be attached. In most cases, a comment C should be\n+ * attached to the topmost AST node that follows C in the source program.\n+ * For example, in this code:\n+ * some_jsdoc bar(baz);\n+ * the comment gets attached to the call node, not to bar.\n+ * There are some exceptions, eg, some infix expressions such as +:\n+ * some_jsdoc 2 + 3;\n+ * In this code, the comment gets attached to 2, not to +.\n+ * <p>\n+ * For legacy reasons, we distinguish between two operators with different\n+ * precedence rules.\n+ * CAST: a jsdoc followed by a left paren\n+ * JSDOC: a jsdoc not followed by a left paren\n+ * Some operators have higher precedence than JSDOC but lower than CAST;\n+ * see the method betweenJsdocAndCast.\n+ * For example, in this code\n+ * some_jsdoc obj.exp\n+ * the jsdoc is attached to GETPROP, and in this code\n+ * some_jsdoc (obj).exp\n+ * the jsdoc is attached to obj.\n+ * <p>\n+ * Algorithmically, we want to make a single pass over the AST and attach all\n+ * comments, not start from the root and search for each comment.\n+ * This is possible b/c the parser hands us the list of comments sorted by their\n+ * starting position. So, when we attach a comment C, we know that the next one\n+ * can't go to the nodes we already rejected for C.\n+ *\n+ */\n+public class AttachJsDocs {\n+\n+  private Comment currentJsdoc;\n+  private int capos; // The absolute (starting) position of currentJsdoc\n+  private boolean attachOnlyToParen = false;\n+  // In some cases we recur to the left child of a node N looking for a paren.\n+  // If we don't find a paren, we save N's info here to attach the jsdoc to N.\n+  private AstNode possibleJsdocTarget;\n+  private int possibleApos;\n+\n+  // A pair of a node and its absolute position\n+  private static class NodePos {\n+    AstNode n;\n+    int apos;\n+\n+    NodePos(AstNode n, int apos) {\n+      this.n = n;\n+      this.apos = apos;\n+    }\n+  }\n+\n+  /** @param napos The absolute position of n. */\n+  private boolean finishesAfterJsdoc(AstNode n, int napos) {\n+    return capos < napos + n.getLength() - 1;\n+  }\n+\n+  /**\n+   * Returns the leftmost right sibling of n that satisfies finishesAfterJsdoc,\n+   * o/w null.\n+   * @param parapos The absolute position of n's parent.\n+   */\n+  private AstNode siblingFinishesAfterJsdoc(AstNode n, int parapos) {\n+    AstNode next = (AstNode) n.getNext();\n+    while (next != null) {\n+      if (finishesAfterJsdoc(next, parapos + next.getPosition())) {\n+        break;\n+      }\n+      next = (AstNode) next.getNext();\n+    }\n+    return next;\n+  }\n+\n+  /** Attaches the comments to the AST. */\n+  public void attachComments(AstRoot root, List<Comment> comments) {\n+    if (comments == null) {\n+      return;\n+    }\n+\n+    AstNode n = root;\n+    int napos = root.getPosition();\n+    int parapos = 0;\n+    int lastcapos = -1;\n+\n+    // At each loop entry, n is some AST node, napos is its absolute position,\n+    // and parapos is the absolute position of its parent.\n+    for (Comment c : comments) {\n+      currentJsdoc = c;\n+      // The parser doesn't attach comments to nodes, so this call isn't slow.\n+      capos = currentJsdoc.getAbsolutePosition();\n+      // The list of comments should be sorted.\n+      if (capos <= lastcapos) {\n+        throw new RuntimeException(\"The list of jsdoc comments isn't sorted.\");\n+      }\n+      lastcapos = capos;\n+\n+      while (n != root) {\n+        // Check if the next comment should be attached to n.\n+        if (finishesAfterJsdoc(n, napos)) {\n+          break;\n+        }\n+        // Check if n's parent contains the comment. If so, check if it can be\n+        // attached to one of n's right siblings.\n+        AstNode tmp;\n+        tmp = n.getParent();\n+        if (tmp != null && finishesAfterJsdoc(tmp, parapos)) {\n+          tmp = siblingFinishesAfterJsdoc(n, parapos);\n+          if (tmp != null) {\n+            n = tmp;\n+            break;\n+          }\n+        }\n+        // Otherwise, go to n's parent and keep looking.\n+        n = n.getParent();\n+        napos = parapos;\n+        parapos = n == root ? 0 : napos - n.getPosition();\n+      }\n+      // At this point, n satisfies finishesAfterJsdoc, so the comment should be\n+      // attached to n or its descendants. This call never returns null.\n+      NodePos np = attachComment(n, parapos);\n+      n = np.n;\n+      napos = np.apos;\n+      parapos = n == root ? 0 : napos - n.getPosition();\n+    }\n+  }\n+\n+  /**\n+   * Tries to attach currentJsdoc to n or one of its descendants.\n+   * If the jsdoc starts after n, we return null.\n+   * If the jsdoc is attached, we return the node on which it was attached.\n+   * Last, if it was contained in n but didn't get attached, we return some node\n+   * close to where the comment would get attached.\n+   *\n+   * The node that gets returned from this function is where the search for\n+   * attaching the next comment will start from.\n+   *\n+   * A comment never gets attached to a node that appears before it in the code.\n+   *\n+   * @param parapos n's parent's absolute position; we calculate it manually\n+   *        b/c it's slow to call getAbsolutePosition for every node.\n+   */\n+  private NodePos attachComment(AstNode n, int parapos) {\n+    int napos = parapos + n.getPosition();\n+\n+    if (finishesAfterJsdoc(n, napos)) {\n+      if (capos < napos && !attachToChildren(n, napos)) {\n+        return setJsdoc(n, napos);\n+      }\n+      // n contains the jsdoc, recur to the children\n+    } else {\n+      return null;\n+    }\n+\n+    int ntype = n.getType();\n+    NodePos res;\n+\n+    // All the cases can assume that the jsdoc appears inside or before n,\n+    // not after n, so they all return a non-null result.\n+    switch (ntype) {\n+      // Statements first, then expressions.\n+\n+      // We don't need to handle nodes that don't contain other nodes here; they\n+      // can't contain a jsdoc.\n+      // These are: FALSE, NAME, NULL, NUMBER, REGEXP, STRING, THIS, TRUE.\n+\n+      case Token.BREAK:\n+      case Token.CONTINUE:\n+        return new NodePos(n, napos);\n+\n+      case Token.CASE:\n+        SwitchCase cas = (SwitchCase) n;\n+        if (!cas.isDefault()) {\n+          res = attachComment(cas.getExpression(), napos);\n+          if (res != null) {\n+            return res;\n+          }\n+        }\n+        if (cas.getStatements() != null) {\n+          for (AstNode stm : cas.getStatements()) {\n+            res = attachComment(stm, napos);\n+            if (res != null) {\n+              return res;\n+            }\n+          }\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.DO:\n+        DoLoop dl = (DoLoop) n;\n+        res = attachComment(dl.getBody(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        if (capos < dl.getWhilePosition()) {\n+            return new NodePos(n, napos);\n+        }\n+        res = attachComment(dl.getCondition(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.EXPR_RESULT:\n+      case Token.EXPR_VOID:\n+        if (n instanceof ExpressionStatement) {\n+          res = attachComment(((ExpressionStatement) n).getExpression(), napos);\n+        } else /* instanceof LabeledStatement */ {\n+          res = attachComment(((LabeledStatement) n).getStatement(), napos);\n+        }\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.FOR:\n+        Loop loop = (Loop) n;\n+        if (n instanceof ForInLoop) {\n+          res = attachForInHeader((ForInLoop) loop, napos);\n+        } else {\n+          res = attachForLoopHeader((ForLoop) loop, napos);\n+        }\n+        if (res != null) {\n+          return res;\n+        }\n+        res = attachComment(loop.getBody(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.IF:\n+        IfStatement ifstm = (IfStatement) n;\n+        res = attachComment(ifstm.getCondition(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        res = attachComment(ifstm.getThenPart(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        if (capos < ifstm.getElsePosition()) {\n+          return new NodePos(n, napos);\n+        }\n+        res = attachComment(ifstm.getElsePart(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.FUNCTION:\n+        FunctionNode fun = (FunctionNode) n;\n+        Name nam = fun.getFunctionName();\n+        if (nam != null) {\n+          res = attachComment(nam, napos);\n+          if (res != null) {\n+            return res;\n+          }\n+        }\n+        for (AstNode param : fun.getParams()) {\n+          res = attachComment(param, napos);\n+          if (res != null) {\n+            return res;\n+          }\n+        }\n+        res = attachComment(fun.getBody(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.RETURN:\n+        res = attachComment(((ReturnStatement) n).getReturnValue(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.SWITCH:\n+        SwitchStatement sw = (SwitchStatement) n;\n+        res = attachComment(sw.getExpression(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        for (SwitchCase c : sw.getCases()) {\n+          res = attachComment(c, napos);\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.THROW:\n+        res = attachComment(((ThrowStatement ) n).getExpression(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.TRY:\n+        TryStatement t = (TryStatement) n;\n+        res = attachComment(t.getTryBlock(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        for (CatchClause cc : t.getCatchClauses()) {\n+          int catchstart = napos + cc.getPosition();\n+          if (capos < catchstart) {\n+            return new NodePos(n, napos);\n+          }\n+          res = attachComment(cc.getVarName(), catchstart);\n+          if (res != null) {\n+            return res;\n+          }\n+          res = attachComment(cc.getBody(), catchstart);\n+          if (res != null) {\n+            return res;\n+          }\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.VAR:\n+        if (n instanceof VariableDeclaration) {\n+          for (VariableInitializer vi :\n+                   ((VariableDeclaration) n).getVariables()) {\n+            res = attachComment(vi, napos);\n+            if (res != null) {\n+              return res;\n+            }\n+          }\n+        } else /* n instanceof VariableInitializer */{\n+          res = attachComment(((VariableInitializer) n).getInitializer(),\n+                              napos);\n+          if (res != null) {\n+            return res;\n+          }\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.WHILE:\n+        WhileLoop wh = (WhileLoop) n;\n+        res = attachComment(wh.getCondition(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        if (capos < wh.getRp()) {\n+          return new NodePos(n, napos);\n+        }\n+        res = attachComment(wh.getBody(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.WITH:\n+        WithStatement w = (WithStatement) n;\n+        res = attachComment(w.getExpression(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        if (capos < w.getRp()) {\n+          return new NodePos(n, napos);\n+        }\n+        res = attachComment(w.getStatement(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.ADD:\n+      case Token.AND:\n+      case Token.ASSIGN:\n+      case Token.ASSIGN_ADD:\n+      case Token.ASSIGN_BITAND:\n+      case Token.ASSIGN_BITOR:\n+      case Token.ASSIGN_BITXOR:\n+      case Token.ASSIGN_DIV:\n+      case Token.ASSIGN_LSH:\n+      case Token.ASSIGN_MOD:\n+      case Token.ASSIGN_MUL:\n+      case Token.ASSIGN_RSH:\n+      case Token.ASSIGN_SUB:\n+      case Token.ASSIGN_URSH:\n+      case Token.BITAND:\n+      case Token.BITOR:\n+      case Token.BITXOR:\n+      case Token.COLON:\n+      case Token.COMMA:\n+      case Token.DIV:\n+      case Token.EQ:\n+      case Token.GE:\n+      case Token.GET:\n+      case Token.GETPROP:\n+      case Token.GT:\n+      case Token.IN:\n+      case Token.INSTANCEOF:\n+      case Token.LE:\n+      case Token.LSH:\n+      case Token.LT:\n+      case Token.MOD:\n+      case Token.MUL:\n+      case Token.NE:\n+      case Token.OR:\n+      case Token.RSH:\n+      case Token.SET:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+      case Token.SUB:\n+      case Token.URSH:\n+        InfixExpression ie = (InfixExpression) n;\n+        res = attachComment(ie.getLeft(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        if (capos < ie.getOperatorPosition()) {\n+          return new NodePos(n, napos);\n+        }\n+        res = attachComment(ie.getRight(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.ARRAYLIT:\n+        for (AstNode elm : ((ArrayLiteral) n).getElements()) {\n+          res = attachComment(elm, napos);\n+          if (res != null) {\n+            return res;\n+          }\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.BITNOT:\n+      case Token.DEC:\n+      case Token.DELPROP:\n+      case Token.INC:\n+      case Token.NEG:\n+      case Token.NOT:\n+      case Token.POS:\n+      case Token.TYPEOF:\n+      case Token.VOID:\n+        UnaryExpression ue = (UnaryExpression) n;\n+        res = attachComment(ue.getOperand(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.CALL:\n+      case Token.NEW:\n+        FunctionCall call = (FunctionCall) n;\n+        res = attachComment(call.getTarget(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        if (capos < call.getLp()) {\n+          return new NodePos(n, napos);\n+        }\n+        for (AstNode param : call.getArguments()) {\n+          res = attachComment(param, napos);\n+          if (res != null) {\n+            return res;\n+          }\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.GETELEM:\n+        ElementGet elm = (ElementGet) n;\n+        res = attachComment(elm.getTarget(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        if (capos < elm.getLb()) {\n+          return new NodePos(n, napos);\n+        }\n+        res = attachComment(elm.getElement(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.HOOK:\n+        ConditionalExpression hook = (ConditionalExpression) n;\n+        res = attachComment(hook.getTestExpression(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        if (capos < hook.getQuestionMarkPosition()) {\n+          return new NodePos(n, napos);\n+        }\n+        res = attachComment(hook.getTrueExpression(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        if (capos < hook.getColonPosition()) {\n+          return new NodePos(n, napos);\n+        }\n+        res = attachComment(hook.getFalseExpression(), napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.LP:\n+        res = attachComment(((ParenthesizedExpression) n).getExpression(),\n+                            napos);\n+        if (res != null) {\n+          return res;\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.OBJECTLIT:\n+        for (InfixExpression prop : ((ObjectLiteral) n).getElements()) {\n+          res = attachComment(prop, napos);\n+          if (res != null) {\n+            return res;\n+          }\n+        }\n+        return new NodePos(n, napos);\n+\n+      case Token.BLOCK:\n+      case Token.SCRIPT:\n+        AstNode kid = (AstNode) n.getFirstChild();\n+        while (kid != null) {\n+          res = attachComment(kid, napos);\n+          if (res != null) {\n+            return res;\n+          }\n+          kid = (AstNode) kid.getNext();\n+        }\n+        return new NodePos(n, napos);\n+\n+      default:\n+        throw new RuntimeException(\n+            \"Can't attach jsdoc to unknown node: \" + ntype);\n+    }\n+  }\n+\n+  private NodePos attachForInHeader(ForInLoop fi, int fipos) {\n+    if (capos < fi.getLp()) {\n+      return new NodePos(fi, fipos);\n+    }\n+    NodePos res = attachComment(fi.getIterator(), fipos);\n+    if (res != null) {\n+      return res;\n+    }\n+    if (capos < fi.getInPosition()) {\n+      return new NodePos(fi, fipos);\n+    }\n+    res = attachComment(fi.getIteratedObject(), fipos);\n+    if (res != null) {\n+      return res;\n+    }\n+    if (capos < fi.getRp()) {\n+      return new NodePos(fi, fipos);\n+    }\n+    return null;\n+  }\n+\n+  private NodePos attachForLoopHeader(ForLoop fl, int flpos) {\n+    if (capos < fl.getLp()) {\n+      return new NodePos(fl, flpos);\n+    }\n+    NodePos res = attachComment(fl.getInitializer(), flpos);\n+    if (res != null) {\n+      return res;\n+    }\n+    res = attachComment(fl.getCondition(), flpos);\n+    if (res != null) {\n+      return res;\n+    }\n+    res = attachComment(fl.getIncrement(), flpos);\n+    if (res != null) {\n+      return res;\n+    }\n+    if (capos < fl.getRp()) {\n+      return new NodePos(fl, flpos);\n+    }\n+    return null;\n+  }\n+\n+  // Returns true iff n binds tighter than non-cast jsdocs & looser than casts.\n+  private boolean betweenJsdocAndCast(AstNode n) {\n+    int ntype = n.getType();\n+    return (ntype == Token.GETPROP || ntype == Token.GETELEM ||\n+        ntype == Token.CALL ||\n+        n instanceof Assignment ||\n+        ((ntype == Token.INC || ntype == Token.DEC) &&\n+            ((UnaryExpression) n).isPostfix()));\n+  }\n+\n+  private boolean attachToChildren(AstNode n, int napos) {\n+    int ntype = n.getType();\n+    if (betweenJsdocAndCast(n)) {\n+      if (!attachOnlyToParen) {\n+        attachOnlyToParen = true;\n+        possibleJsdocTarget = n;\n+        possibleApos = napos;\n+      }\n+      return true;\n+    }\n+    if (ntype == Token.SCRIPT ||\n+        ntype == Token.HOOK ||\n+        ntype == Token.RETURN ||\n+        n instanceof ExpressionStatement ||\n+        n instanceof InfixExpression) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private NodePos setJsdoc(AstNode n, int napos) {\n+    int ntype = n.getType();\n+\n+    if (attachOnlyToParen) {\n+      attachOnlyToParen = false;\n+      if (ntype != Token.LP) {\n+        possibleJsdocTarget.setJsDocNode(currentJsdoc);\n+        return new NodePos(possibleJsdocTarget, possibleApos);\n+      }\n+    } else {\n+      switch (ntype) {\n+        // For most stms, it doesn't make sense to attach a comment on them.\n+        case Token.BLOCK:\n+        case Token.CASE:\n+        case Token.DO:\n+        case Token.FOR:\n+        case Token.IF:\n+        case Token.SWITCH:\n+        case Token.THROW:\n+        case Token.WHILE:\n+          return new NodePos(n, napos);\n+\n+        case Token.VAR:\n+          if (n instanceof VariableInitializer) {\n+            AstNode n2 = ((VariableInitializer) n).getTarget();\n+            n2.setJsDocNode(currentJsdoc);\n+            return new NodePos(n2, napos + n2.getPosition());\n+          }\n+          break;\n+      }\n+    }\n+    n.setJsDocNode(currentJsdoc);\n+    return new NodePos(n, napos);\n+  }\n+}\n--- a/lib/rhino/src/org/mozilla/javascript/Parser.java\n+++ b/lib/rhino/src/org/mozilla/javascript/Parser.java\n     private int syntaxErrorCount;\n \n     private List<Comment> scannedComments;\n-    private Comment currentJsDocComment;\n+    private List<Comment> jsdocs;\n \n     protected int nestingOfFunction;\n     private LabeledStatement currentLabel;\n     private void recordComment(int lineno, String comment) {\n         if (scannedComments == null) {\n             scannedComments = new ArrayList<Comment>();\n+            jsdocs = new ArrayList<Comment>();\n         }\n         Comment commentNode = new Comment(ts.tokenBeg,\n                                           ts.getTokenLength(),\n                                           comment);\n         if (ts.commentType == Token.CommentType.JSDOC &&\n             compilerEnv.isRecordingLocalJsDocComments()) {\n-            currentJsDocComment = commentNode;\n+            jsdocs.add(commentNode);\n         }\n         commentNode.setLineno(lineno);\n         scannedComments.add(commentNode);\n     }\n-\n-    private Comment getAndResetJsDoc() {\n-        Comment saved = currentJsDocComment;\n-        currentJsDocComment = null;\n-        return saved;\n-    }\n-\n \n     private int getNumberOfEols(String comment) {\n       int lines = 0;\n         }\n         this.ts = new TokenStream(this, null, sourceString, lineno);\n         try {\n-            return parse();\n+            AstRoot r = parse();\n+            new AttachJsDocs().attachComments(r, jsdocs);\n+            return r;\n         } catch (IOException iox) {\n             // Should never happen\n             throw new IllegalStateException();\n         try {\n             this.sourceURI = sourceURI;\n             ts = new TokenStream(this, sourceReader, null, lineno);\n-            return parse();\n+            AstRoot r = parse();\n+            new AttachJsDocs().attachComments(r, jsdocs);\n+            return r;\n         } finally {\n             parseFinished = true;\n         }\n         }\n \n         int end = ts.tokenEnd;\n-        getAndResetJsDoc();\n         if (!isExpressionClosure && mustMatchToken(Token.RC, \"msg.no.brace.after.body\"))\n             end = ts.tokenEnd;\n         pn.setLength(end - pos);\n                 destructuring.put(pname, expr);\n             } else {\n                 if (mustMatchToken(Token.NAME, \"msg.no.parm\")) {\n-                    Name paramNameNode = createNameNode();\n-                    Comment jsdocNodeForName = getAndResetJsDoc();\n-                    if (jsdocNodeForName != null) {\n-                      paramNameNode.setJsDocNode(jsdocNodeForName);\n-                    }\n-                    fnNode.addParam(paramNameNode);\n+                    fnNode.addParam(createNameNode());\n                     String paramName = ts.getString();\n                     defineSymbol(Token.LP, paramName);\n                     if (this.inUseStrictDirective) {\n         fnNode.setFunctionType(type);\n         if (lpPos != -1)\n             fnNode.setLp(lpPos - functionSourceStart);\n-\n-        fnNode.setJsDocNode(getAndResetJsDoc());\n \n         PerFunctionVariables savedVars = new PerFunctionVariables(fnNode);\n         try {\n         if (currentToken != Token.TRY) codeBug();\n         consumeToken();\n \n-        // Pull out JSDoc info and reset it before recursing.\n-        Comment jsdocNode = getAndResetJsDoc();\n-\n         int tryPos = ts.tokenBeg, lineno = ts.lineno, finallyPos = -1;\n         if (peekToken() != Token.LC) {\n             reportError(\"msg.no.brace.try\");\n                 mustMatchToken(Token.NAME, \"msg.bad.catchcond\");\n \n                 Name varName = createNameNode();\n-                Comment jsdocNodeForName = getAndResetJsDoc();\n-                if (jsdocNodeForName != null) {\n-                  varName.setJsDocNode(jsdocNodeForName);\n-                }\n                 String varNameString = varName.getIdentifier();\n                 if (inUseStrictDirective) {\n                     if (\"eval\".equals(varNameString) ||\n             pn.setFinallyPosition(finallyPos - tryPos);\n         }\n         pn.setLineno(lineno);\n-\n-        if (jsdocNode != null) {\n-            pn.setJsDocNode(jsdocNode);\n-        }\n-\n         return pn;\n     }\n \n         if (currentToken != Token.WITH) codeBug();\n         consumeToken();\n \n-        Comment withComment = getAndResetJsDoc();\n-\n         int lineno = ts.lineno, pos = ts.tokenBeg, lp = -1, rp = -1;\n         if (mustMatchToken(Token.LP, \"msg.no.paren.with\"))\n             lp = ts.tokenBeg;\n         AstNode body = statement();\n \n         WithStatement pn = new WithStatement(pos, getNodeEnd(body) - pos);\n-        pn.setJsDocNode(withComment);\n         pn.setExpression(obj);\n         pn.setStatement(body);\n         pn.setParens(lp, rp);\n         VariableDeclaration pn = new VariableDeclaration(pos);\n         pn.setType(declType);\n         pn.setLineno(ts.lineno);\n-        Comment varjsdocNode = getAndResetJsDoc();\n-        if (varjsdocNode != null) {\n-            pn.setJsDocNode(varjsdocNode);\n-        }\n         // Example:\n         // var foo = {a: 1, b: 2}, bar = [3, 4];\n         // var {b: s2, a: s1} = foo, x = 6, y, [s3, s4] = bar;\n             }\n \n             int lineno = ts.lineno;\n-\n-            Comment jsdocNode = getAndResetJsDoc();\n-\n             AstNode init = null;\n             if (matchToken(Token.ASSIGN)) {\n                 init = assignExpr();\n             }\n             vi.setInitializer(init);\n             vi.setType(declType);\n-            vi.setJsDocNode(jsdocNode);\n             vi.setLineno(lineno);\n             pn.addVariable(vi);\n \n         tt = peekToken();\n         if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {\n             consumeToken();\n-\n-            // Pull out JSDoc info and reset it before recursing.\n-            Comment jsdocNode = getAndResetJsDoc();\n-\n             markDestructuring(pn);\n             int opPos = ts.tokenBeg;\n-\n             pn = new Assignment(tt, pn, assignExpr(), opPos);\n-\n-            if (jsdocNode != null) {\n-                pn.setJsDocNode(jsdocNode);\n-            }\n-        } else if (tt == Token.SEMI) {\n-            // This may be dead code added intentionally, for JSDoc purposes.\n-            // For example: /** @type Number */ C.prototype.x;\n-            if (currentJsDocComment != null) {\n-                pn.setJsDocNode(getAndResetJsDoc());\n-            }\n         }\n         return pn;\n     }\n         boolean wasInForInit = inForInit;\n         inForInit = false;\n         try {\n-            Comment jsdocNode = getAndResetJsDoc();\n             int lineno = ts.lineno;\n             int begin = ts.tokenBeg;\n             AstNode e = expr();\n             if (peekToken() == Token.FOR) {\n                 return generatorExpression(e, begin);\n             }\n-            ParenthesizedExpression pn = new ParenthesizedExpression(e);\n-            if (jsdocNode == null) {\n-                jsdocNode = getAndResetJsDoc();\n-            }\n-            if (jsdocNode != null) {\n-                pn.setJsDocNode(jsdocNode);\n-            }\n             mustMatchToken(Token.RP, \"msg.no.paren\");\n-            pn.setLength(ts.tokenEnd - pn.getPosition());\n+            ParenthesizedExpression pn = new ParenthesizedExpression(\n+                begin, ts.tokenEnd - begin, e);\n             pn.setLineno(lineno);\n             return pn;\n         } finally {\n             getterNames = new HashSet<String>();\n             setterNames = new HashSet<String>();\n         }\n-        Comment objJsdocNode = getAndResetJsDoc();\n \n       commaLoop:\n         for (;;) {\n             String propertyName = null;\n             int entryKind = PROP_ENTRY;\n             int tt = peekToken();\n-            Comment jsdocNode = getAndResetJsDoc();\n             switch(tt) {\n               case Token.NAME:\n                   Name name = createNameNode();\n                           propertyName = ts.getString();\n                           ObjectProperty objectProp = getterSetterProperty(\n                                   ppos, pname, isGet);\n-                          pname.setJsDocNode(jsdocNode);\n                           elems.add(objectProp);\n                       }\n                   } else {\n-                      name.setJsDocNode(jsdocNode);\n                       elems.add(plainProperty(name, tt));\n                   }\n                   break;\n                       propertyName = null;\n                   } else {\n                       propertyName = ts.getString();\n-                      pname.setJsDocNode(jsdocNode);\n                       elems.add(plainProperty(pname, tt));\n                   }\n                   break;\n                 }\n             }\n \n-            // Eat any dangling jsdoc in the property.\n-            getAndResetJsDoc();\n-\n             if (matchToken(Token.COMMA)) {\n                 afterComma = ts.tokenEnd;\n             } else {\n \n         mustMatchToken(Token.RC, \"msg.no.brace.prop\");\n         ObjectLiteral pn = new ObjectLiteral(pos, ts.tokenEnd - pos);\n-        if (objJsdocNode != null) {\n-            pn.setJsDocNode(objJsdocNode);\n-        }\n         pn.setElements(elems);\n         pn.setLineno(lineno);\n         return pn;\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n           FunctionNode fnNode = (FunctionNode) node;\n           valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n           break;\n-        // Object literal properties and catch declarations are valid.\n+        // Object literal properties, catch declarations and variable\n+        // initializers are valid.\n         case com.google.javascript.rhino.head.Token.NAME:\n-          valid = node.getParent() instanceof ObjectProperty\n-              || node.getParent() instanceof CatchClause\n-              || node.getParent() instanceof FunctionNode;\n+          AstNode parent = node.getParent();\n+          valid = parent instanceof ObjectProperty\n+              || parent instanceof CatchClause\n+              || parent instanceof FunctionNode\n+              || (parent instanceof VariableInitializer &&\n+                  node == ((VariableInitializer) parent).getTarget());\n           break;\n         // Object literal properties are valid\n         case com.google.javascript.rhino.head.Token.GET:\n--- a/test/com/google/javascript/jscomp/ChainCallsTest.java\n+++ b/test/com/google/javascript/jscomp/ChainCallsTest.java\n         + \"Foo.prototype.bar = function() { return this; };\\n\"\n         + \"/** @constructor\\n@extends {Foo} */ function Baz() {}\\n\"\n         + \"Baz.prototype.bar = function() {};\\n\"\n-        + \"(/** @type {Foo} */ new Baz()).bar();\\n\"\n-        + \"(/** @type {Foo} */ new Baz()).bar();\\n\");\n+        + \"/** @type {Foo} */ (new Baz()).bar();\\n\"\n+        + \"/** @type {Foo} */ (new Baz()).bar();\\n\");\n   }\n \n   public void testSimpleDefinitionFinder() {\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n \n     String code = \"\" +\n         \"console.log(\" +\n-            \"/** @type {function():!string} */ ((new x())['abc'])() );\";\n+            \"/** @type {function():!string} */ ((new x())['abc'])());\";\n     String result = \"\" +\n         \"console.log((new x()).abc());\";\n     test(options, code, result);\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\n import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n \n   public void testBug1942972() throws Exception {\n     testTypes(\n-        \"var google = {\\n\"+\n+        \"var google = {\\n\" +\n         \"  gears: {\\n\" +\n         \"    factory: {},\\n\" +\n         \"    workerPool: {}\\n\" +\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ ({})\");\n \n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n-        \"/** @type {Foo} */ var x = (/** @type {Foo} */ y)\");\n+        \"/** @type {Foo} */ var x = /** @type {Foo} */ (y)\");\n   }\n \n   public void testNestedCasts() throws Exception {\n--- a/test/com/google/javascript/jscomp/TightenTypesTest.java\n+++ b/test/com/google/javascript/jscomp/TightenTypesTest.java\n   public void testRestrictToCast() {\n     testSame(\"/** @constructor */ function Foo() {};\\n\"\n              + \"var a = [];\\n\"\n-             + \"var foo = (/** @type {Foo} */ a[0]);\\n\"\n+             + \"var foo = /** @type {Foo} */ (a[0]);\\n\"\n              + \"var u = a[0];\\n\"\n              + \"new Foo\");\n \n     testSame(\"/** @constructor \\n @implements Int */ function Foo() {};\\n\"\n              + \"/** @interface */ function Int() {};\\n\"\n              + \"var a = [];\\n\"\n-             + \"var foo = (/** @type {Int} */ a[0]);\\n\"\n+             + \"var foo = /** @type {Int} */ (a[0]);\\n\"\n              + \"new Foo\");\n \n     assertType(\"Foo\", getType(\"foo\"));\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n               \" * @implements {Foo}\\n\" +\n               \" */\" +\n               \"function Bar(){ this.x = 123; }\\n\" +\n-              \"var z = /** @type {Foo} */(new Bar)['x'];\");\n+              \"var z = /** @type {Foo} */(new Bar())['x'];\");\n   }\n \n   public void testGetelemStruct7() throws Exception {\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ (y)\");\n \n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n-        \"/** @type {Foo} */ var x = (/** @type {Foo} */ y)\");\n+        \"/** @type {Foo} */ var x = /** @type {Foo} */ (y)\");\n   }\n \n   public void testCast17b() throws Exception {\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n   public void testObjectLiteral6() {\n     testNewParser(\"({1: true})\",\n       \"SCRIPT 1 [source_file: FileName.js] [length: 11]\\n\" +\n-      \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 10]\\n\" +\n+      \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 11]\\n\" +\n       \"        OBJECTLIT 1 [source_file: FileName.js] [length: 9]\\n\" +\n       \"            STRING_KEY 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n       \"                TRUE 1 [source_file: FileName.js] [length: 4]\\n\");\n \n     testNewParser(\"({get 1() {}})\",\n         \"SCRIPT 1 [source_file: FileName.js] [length: 14]\\n\" +\n-        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 13]\\n\" +\n+        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\\n\" +\n         \"        OBJECTLIT 1 [source_file: FileName.js] [length: 12]\\n\" +\n         \"            GETTER_DEF 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n         \"                FUNCTION  1 [source_file: FileName.js] [length: 6]\\n\" +\n \n     testNewParser(\"({set 1(a) {}})\",\n         \"SCRIPT 1 [source_file: FileName.js] [length: 15]\\n\" +\n-        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\\n\" +\n+        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 15]\\n\" +\n         \"        OBJECTLIT 1 [source_file: FileName.js] [length: 13]\\n\" +\n         \"            SETTER_DEF 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n         \"                FUNCTION  1 [source_file: FileName.js] [length: 7]\\n\" +\n     mode = LanguageMode.ECMASCRIPT5;\n     testNewParser(\"({get a() {}})\",\n         \"SCRIPT 1 [source_file: FileName.js] [length: 14]\\n\" +\n-        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 13]\\n\" +\n+        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\\n\" +\n         \"        OBJECTLIT 1 [source_file: FileName.js] [length: 12]\\n\" +\n         \"            GETTER_DEF a 1 [source_file: FileName.js] [length: 1]\\n\" +\n         \"                FUNCTION  1 [source_file: FileName.js] [length: 6]\\n\" +\n     mode = LanguageMode.ECMASCRIPT5;\n     testNewParser(\"({set a(x) {}})\",\n         \"SCRIPT 1 [source_file: FileName.js] [length: 15]\\n\" +\n-        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\\n\" +\n+        \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 15]\\n\" +\n         \"        OBJECTLIT 1 [source_file: FileName.js] [length: 13]\\n\" +\n         \"            SETTER_DEF a 1 [source_file: FileName.js] [length: 1]\\n\" +\n         \"                FUNCTION  1 [source_file: FileName.js] [length: 7]\\n\" +\n     Node bTest = aTest.getNext();\n \n     assertNodePosition(1, 0, ifStmt);\n-    assertNodePosition(2, 7, orTest);\n-    assertNodePosition(2, 7, andTest);\n+    assertNodePosition(2, 5, orTest);\n+    assertNodePosition(2, 6, andTest);\n     assertNodePosition(2, 7, aTest);\n     assertNodePosition(4, 3, bTest);\n     assertNodePosition(5, 2, cTest);\n \n     assertNodePosition(1, 0, ifStmt);\n \n-    assertNodePosition(2, 8, eqTest);\n-    assertNodePosition(7, 8, notEqTest);\n+    assertNodePosition(2, 7, eqTest);\n+    assertNodePosition(7, 7, notEqTest);\n \n     assertNodePosition(2, 8, bitOrTest);\n     assertNodePosition(5, 8, bitAndTest);\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n \n     assertEquals(Token.GETELEM, call.getType());\n     assertEquals(3, call.getLineno());\n-    assertEquals(2, call.getCharno());\n+    assertEquals(1, call.getCharno());\n   }\n \n   public void testLinenoCharnoForComparison() throws Exception {\n   public void testJSDocAttachment3() {\n     Node assignNode = parse(\n         \"/** @type number */goog.FOO = 5;\").getFirstChild().getFirstChild();\n-\n-    // ASSIGN\n     assertEquals(Token.ASSIGN, assignNode.getType());\n     JSDocInfo info = assignNode.getJSDocInfo();\n     assertNotNull(info);\n \n   public void testJSDocAttachment4() {\n     Node varNode = parse(\n-        \"var a, /** @define {number} */b = 5;\").getFirstChild();\n+        \"var a, /** @define {number} */ b = 5;\").getFirstChild();\n \n     // ASSIGN\n     assertEquals(Token.VAR, varNode.getType());\n     assertEquals(Token.EXPR_RESULT, exprCall.getType());\n     assertNull(exprCall.getNext().getJSDocInfo());\n     assertNotNull(exprCall.getFirstChild().getJSDocInfo());\n+  }\n+\n+  public void testJSDocAttachment17() {\n+    Node fn =\n+        parse(\n+            \"function f() { \" +\n+            \"  return /** @type {string} */ (g(1 /** @desc x */));\" +\n+            \"};\").getFirstChild();\n+    assertEquals(Token.FUNCTION, fn.getType());\n+    Node cast = fn.getLastChild().getFirstChild().getFirstChild();\n+    assertEquals(Token.CAST, cast.getType());\n+  }\n+\n+  public void testJSDocAttachment18() {\n+    Node fn =\n+        parse(\n+            \"function f() { \" +\n+            \"  var x = /** @type {string} */ (y);\" +\n+            \"};\").getFirstChild();\n+    assertEquals(Token.FUNCTION, fn.getType());\n+    Node cast =\n+        fn.getLastChild().getFirstChild().getFirstChild().getFirstChild();\n+    assertEquals(Token.CAST, cast.getType());\n   }\n \n   public void testInlineJSDocAttachment1() {\n   }\n \n   public void testMisplacedTypeAnnotation2() {\n-    // missing parenthese for the cast.\n+    // missing parentheses for the cast.\n     parse(\n         \"var o = /** @type {string} */ getValue();\",\n         MISPLACED_TYPE_ANNOTATION);\n   }\n \n   public void testMisplacedTypeAnnotation3() {\n-    // missing parenthese for the cast.\n+    // missing parentheses for the cast.\n     parse(\n         \"var o = 1 + /** @type {string} */ value;\",\n         MISPLACED_TYPE_ANNOTATION);\n   }\n \n   public void testMisplacedTypeAnnotation4() {\n-    // missing parenthese for the cast.\n+    // missing parentheses for the cast.\n     parse(\n         \"var o = /** @type {!Array.<string>} */ ['hello', 'you'];\",\n         MISPLACED_TYPE_ANNOTATION);\n   }\n \n   public void testMisplacedTypeAnnotation5() {\n-    // missing parenthese for the cast.\n+    // missing parentheses for the cast.\n     parse(\n         \"var o = (/** @type {!Foo} */ {});\",\n         MISPLACED_TYPE_ANNOTATION);", "timestamp": 1369360191, "metainfo": ""}