{"sha": "5524adbda991632656059566b69cc2771ba42b7d", "log": "Rename a couple of AST nodes: DEFAULT becomes DEFAULT_CASE LP becomes PARAM_LIST GET becomes GETTER_DEF SET becomes SETTER_DEF  R=nicksantos DELTA=215  (40 added, 5 deleted, 170 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3695   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasStrings.java\n+++ b/src/com/google/javascript/jscomp/AliasStrings.java\n         case Token.FOR:\n         case Token.SWITCH:\n         case Token.CASE:\n-        case Token.DEFAULT:\n+        case Token.DEFAULT_CASE:\n         case Token.BLOCK:\n         case Token.SCRIPT:\n         case Token.FUNCTION:\n--- a/src/com/google/javascript/jscomp/AstParallelizer.java\n+++ b/src/com/google/javascript/jscomp/AstParallelizer.java\n       public Node get() {\n         return new Node(Token.FUNCTION,\n             Node.newString(Token.NAME, TEMP_NAME),\n-            new Node(Token.LP), new Node(Token.BLOCK));\n+            new Node(Token.PARAM_LIST), new Node(Token.BLOCK));\n       }\n     };\n     return new AstParallelizer(\n--- a/src/com/google/javascript/jscomp/AstValidator.java\n+++ b/src/com/google/javascript/jscomp/AstValidator.java\n   }\n \n   private void validateParameters(Node n) {\n-    validateNodeType(Token.LP, n);\n+    validateNodeType(Token.PARAM_LIST, n);\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n       validateName(c);\n     }\n     int defaults = 0;\n     for (Node c = n.getFirstChild().getNext(); c != null; c = c.getNext()) {\n       validateSwitchMember(n.getLastChild());\n-      if (c.isDefault()) {\n+      if (c.isDefaultCase()) {\n         defaults++;\n       }\n     }\n       case Token.CASE:\n         validateCase(n);\n         return;\n-      case Token.DEFAULT:\n+      case Token.DEFAULT_CASE:\n         validateDefault(n);\n         return;\n       default:\n   }\n \n   private void validateDefault(Node n) {\n-    validateNodeType(Token.DEFAULT, n);\n+    validateNodeType(Token.DEFAULT_CASE, n);\n     validateChildCount(n, 1);\n     validateSyntheticBlock(n.getLastChild());\n   }\n \n   private void validateObjectLitKey(Node n) {\n     switch (n.getType()) {\n-      case Token.GET:\n+      case Token.GETTER_DEF:\n         validateObjectLitGetKey(n);\n         return;\n-      case Token.SET:\n+      case Token.SETTER_DEF:\n         validateObjectLitSetKey(n);\n         return;\n       case Token.STRING:\n   }\n \n   private void validateObjectLitGetKey(Node n) {\n-    validateNodeType(Token.GET, n);\n+    validateNodeType(Token.GETTER_DEF, n);\n     validateChildCount(n, 1);\n     validateObjectLiteralKeyName(n);\n     Node function = n.getFirstChild();\n   }\n \n   private void validateObjectLitSetKey(Node n) {\n-    validateNodeType(Token.SET, n);\n+    validateNodeType(Token.SETTER_DEF, n);\n     validateChildCount(n, 1);\n     validateObjectLiteralKeyName(n);\n     Node function = n.getFirstChild();\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n           continue NEXT_VAR_PAIR;\n         }\n \n-        if (v1.getParentNode().isLP() &&\n-            v2.getParentNode().isLP()) {\n+        if (v1.getParentNode().isParamList() &&\n+            v2.getParentNode().isParamList()) {\n           interferenceGraph.connectIfNotFound(v1, null, v2);\n           continue NEXT_VAR_PAIR;\n         }\n     private static boolean isAssignTo(Var var, Node n, Node parent) {\n       if (n.isName() && var.getName().equals(n.getString()) &&\n           parent != null) {\n-        if (parent.isLP()) {\n+        if (parent.isParamList()) {\n           // In a function declaration, the formal parameters are assigned.\n           return true;\n         } else if (parent.isVar()) {\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         add(\"]\");\n         break;\n \n-      case Token.LP:\n+      case Token.PARAM_LIST:\n         add(\"(\");\n         addList(first);\n         add(\")\");\n         }\n         break;\n \n-      case Token.GET:\n-      case Token.SET:\n+      case Token.GETTER_DEF:\n+      case Token.SETTER_DEF:\n         Preconditions.checkState(n.getParent().isObjectLit());\n         Preconditions.checkState(childCount == 1);\n         Preconditions.checkState(first.isFunction());\n \n         // Get methods are unnamed\n         Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n-        if (type == Token.GET) {\n+        if (type == Token.GETTER_DEF) {\n           // Get methods have no parameters.\n           Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n           add(\"get \");\n             cc.listSeparator();\n           }\n \n-          if (c.isGet() || c.isSet()) {\n+          if (c.isGetterDef() || c.isSetterDef()) {\n             add(c);\n           } else {\n             Preconditions.checkState(c.isString());\n         addCaseBody(last);\n         break;\n \n-      case Token.DEFAULT:\n+      case Token.DEFAULT_CASE:\n         Preconditions.checkState(childCount == 1);\n         add(\"default\");\n         addCaseBody(first);\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n       nextKey = key.getNext();\n \n       // A get or a set can not be rewritten as a VAR.\n-      if (key.isGet() || key.isSet()) {\n+      if (key.isGetterDef() || key.isSetterDef()) {\n         continue;\n       }\n \n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n       case Token.CASE:\n         handleCase(n);\n         return;\n-      case Token.DEFAULT:\n+      case Token.DEFAULT_CASE:\n         handleDefault(n);\n         return;\n       case Token.BLOCK:\n     } else { // No more CASE found, go back and search for a DEFAULT.\n       Node parent = node.getParent();\n       Node deflt = getNextSiblingOfType(\n-        parent.getFirstChild().getNext(), Token.DEFAULT);\n+        parent.getFirstChild().getNext(), Token.DEFAULT_CASE);\n       if (deflt != null) { // Has a DEFAULT\n         createEdge(node, Branch.ON_FALSE, deflt);\n       } else { // No DEFAULT found, go to the follow of the SWITCH.\n     // Synthetic blocks\n     if (parent != null) {\n       switch (parent.getType()) {\n-        case Token.DEFAULT:\n+        case Token.DEFAULT_CASE:\n         case Token.CASE:\n         case Token.TRY:\n           break;\n       case Token.IF:\n         return computeFollowNode(fromNode, parent, cfa);\n       case Token.CASE:\n-      case Token.DEFAULT:\n+      case Token.DEFAULT_CASE:\n         // After the body of a CASE, the control goes to the body of the next\n         // case, without having to go to the case condition.\n         if (parent.getNext() != null) {\n           if (parent.getNext().isCase()) {\n             return parent.getNext().getFirstChild().getNext();\n-          } else if (parent.getNext().isDefault()) {\n+          } else if (parent.getNext().isDefaultCase()) {\n             return parent.getNext().getFirstChild();\n           } else {\n             Preconditions.checkState(false, \"Not reachable\");\n--- a/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n+++ b/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     switch (n.getType()) {\n-      case Token.GET:\n-      case Token.SET:\n+      case Token.GETTER_DEF:\n+      case Token.SETTER_DEF:\n       case Token.STRING:\n         if (NodeUtil.isObjectLitKey(n, parent) &&\n             NodeUtil.isValidPropertyName(n.getString())) {\n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n         if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&\n             value.isFunction()) {\n           Node valueParent = value.getParent();\n-          if (valueParent.isGet()\n-              || valueParent.isSet()) {\n+          if (valueParent.isGetterDef()\n+              || valueParent.isSetterDef()) {\n             // TODO(johnlenz): a GET or SET can't be deferred like a normal\n             // FUNCTION property definition as a mix-in would get the result\n             // of a GET instead of the function itself.\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n     } else if (NodeUtil.isObjectLitKey(n, parent)) {\n       return new ObjectLiteralPropertyDefinition(parent, n, n.getFirstChild(),\n           isExtern);\n-    } else if (parent.isLP()) {\n+    } else if (parent.isParamList()) {\n       Node function = parent.getParent();\n       return new FunctionArgumentDefinition(function, n, isExtern);\n     }\n       return true;\n     } else if (NodeUtil.isObjectLitKey(n, parent)) {\n       return true;\n-    } else if (parent.isLP()) {\n+    } else if (parent.isParamList()) {\n       return true;\n     }\n     return false;\n       // flexibility.\n \n       switch (name.getType()) {\n-        case Token.SET:\n-        case Token.GET:\n+        case Token.SETTER_DEF:\n+        case Token.GETTER_DEF:\n         case Token.STRING:\n           // TODO(johnlenz): return a GETELEM for quoted strings.\n           return new Node(Token.GETPROP,\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n         case Token.BLOCK:\n         case Token.LABEL:\n         case Token.CASE:\n-        case Token.DEFAULT:\n+        case Token.DEFAULT_CASE:\n           return null;\n       }\n       child = parent;\n--- a/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n+++ b/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n       Node block = new Node(Token.BLOCK);\n       Node func = new Node(Token.FUNCTION,\n            Node.newString(Token.NAME, \"\"),\n-           new Node(Token.LP, Node.newString(Token.NAME, prototypeAlias)),\n+           new Node(Token.PARAM_LIST, Node.newString(Token.NAME, prototypeAlias)),\n            block);\n \n       Node call = new Node(Token.CALL,func,\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n             // Make sure that the name node is purely a read.\n             if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n                 || parent.isVar() || parent.isInc() ||\n-                parent.isDec() || parent.isLP() ||\n+                parent.isDec() || parent.isParamList() ||\n                 parent.isCatch()) {\n               return;\n             }\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n    */\n   FunctionTypeBuilder inferParameterTypes(JSDocInfo info) {\n     // Create a fake args parent.\n-    Node lp = new Node(Token.LP);\n+    Node lp = new Node(Token.PARAM_LIST);\n     for (String name : info.getParameterNames()) {\n       lp.addChildToBack(Node.newString(Token.NAME, name));\n     }\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n       boolean isPropAssign = false;\n \n       switch (n.getType()) {\n-        case Token.GET:\n-        case Token.SET:\n+        case Token.GETTER_DEF:\n+        case Token.SETTER_DEF:\n         case Token.STRING:\n           // This may be a key in an object literal declaration.\n           name = null;\n             case Token.STRING:\n               type = getValueType(n.getFirstChild());\n               break;\n-            case Token.GET:\n+            case Token.GETTER_DEF:\n               type = Name.Type.GET;\n               break;\n-            case Token.SET:\n+            case Token.SETTER_DEF:\n               type = Name.Type.SET;\n               break;\n             default:\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n         // Also, ES5 getters/setters aren't handled by this pass.\n         for (Node child = val.getFirstChild(); child != null;\n              child = child.getNext()) {\n-          if (child.isGet() ||\n-              child.isSet()) {\n+          if (child.isGetterDef() ||\n+              child.isSetterDef()) {\n             // ES5 get/set not supported.\n             return false;\n           }\n--- a/src/com/google/javascript/jscomp/JsMessageVisitor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java\n         case Token.NAME:\n           // This is okay. The function has a name, but it is empty.\n           break;\n-        case Token.LP:\n+        case Token.PARAM_LIST:\n           // Parse the placeholder names from the function argument list.\n           for (Node argumentNode : fnChild.children()) {\n             if (argumentNode.isName()) {\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n         }\n         break;\n \n-      case Token.LP: {\n+      case Token.PARAM_LIST: {\n           Renamer renamer = nameStack.peek().forChildScope();\n \n           // Add the function parameters\n         nameStack.pop();\n         break;\n \n-      case Token.LP:\n+      case Token.PARAM_LIST:\n         // Note: The parameters and function body variables live in the\n         // same scope, we introduce the scope when in the \"shouldTraverse\"\n         // visit of LP, but remove it when when we exit the function above.\n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n               case Token.STRING:\n                 addPossibleSignature(key.getString(), key.getFirstChild(), t);\n                 break;\n-              case Token.SET:\n-              case Token.GET:\n+              case Token.SETTER_DEF:\n+              case Token.GETTER_DEF:\n                 nonMethodProperties.add(key.getString());\n                 break;\n               default:\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n   }\n \n   private boolean isParameter(Var v) {\n-    return v.getParentNode().isLP();\n+    return v.getParentNode().isParamList();\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     // Check for the form { 'x' : function() { } }\n     Node parent = n.getParent();\n     switch (parent.getType()) {\n-      case Token.SET:\n-      case Token.GET:\n+      case Token.SETTER_DEF:\n+      case Token.GETTER_DEF:\n       case Token.STRING:\n         // Return the name of the literal's key.\n         return parent.getString();\n       case Token.HOOK:\n       case Token.IF:\n       case Token.IN:\n-      case Token.LP:\n+      case Token.PARAM_LIST:\n       case Token.NUMBER:\n       case Token.OR:\n       case Token.THIS:\n       case Token.CATCH:\n       case Token.SWITCH:\n       case Token.CASE:\n-      case Token.DEFAULT:\n+      case Token.DEFAULT_CASE:\n         return true;\n       default:\n         return false;\n       case Token.SWITCH:\n       case Token.CASE:\n         return parent.getFirstChild() != n;\n-      case Token.DEFAULT:\n+      case Token.DEFAULT_CASE:\n         return true;\n       default:\n         Preconditions.checkState(isControlStructure(parent));\n \n   /** Whether the node is part of a switch statement. */\n   static boolean isSwitchCase(Node n) {\n-    return n.isCase() || n.isDefault();\n+    return n.isCase() || n.isDefaultCase();\n   }\n \n   /**\n         || (parent.isFunction() && parent.getFirstChild() == n)\n         || parent.isDec()\n         || parent.isInc()\n-        || parent.isLP()\n+        || parent.isParamList()\n         || parent.isCatch();\n   }\n \n     switch (node.getType()) {\n       case Token.STRING:\n         return parent.isObjectLit();\n-      case Token.GET:\n-      case Token.SET:\n+      case Token.GETTER_DEF:\n+      case Token.SETTER_DEF:\n         return true;\n     }\n     return false;\n   static String getObjectLitKeyName(Node key) {\n     switch (key.getType()) {\n       case Token.STRING:\n-      case Token.GET:\n-      case Token.SET:\n+      case Token.GETTER_DEF:\n+      case Token.SETTER_DEF:\n         return key.getString();\n     }\n     throw new IllegalStateException(\"Unexpected node type: \" + key);\n   static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) {\n     if (valueType != null) {\n       switch (key.getType()) {\n-        case Token.GET:\n+        case Token.GETTER_DEF:\n           // GET must always return a function type.\n           if (valueType.isFunctionType()) {\n             FunctionType fntype = valueType.toMaybeFunctionType();\n             return null;\n           }\n           break;\n-        case Token.SET:\n+        case Token.SETTER_DEF:\n           if (valueType.isFunctionType()) {\n             // SET must always return a function type.\n             FunctionType fntype = valueType.toMaybeFunctionType();\n    */\n   static boolean isGetOrSetKey(Node node) {\n     switch (node.getType()) {\n-      case Token.GET:\n-      case Token.SET:\n+      case Token.GETTER_DEF:\n+      case Token.SETTER_DEF:\n         return true;\n     }\n     return false;\n   /** Creates function name(params_0, ..., params_n) { body }. */\n   public static Node newFunctionNode(String name, List<Node> params,\n       Node body, int lineno, int charno) {\n-    Node parameterParen = new Node(Token.LP, lineno, charno);\n+    Node parameterParen = new Node(Token.PARAM_LIST, lineno, charno);\n     for (Node param : params) {\n       parameterParen.addChildToBack(param);\n     }\n     }\n     return lValue.getQualifiedName();\n   }\n+\n+  /**\n+   * @returns false iff the result of the expression is not consumed.\n+   */\n+  static boolean isExpressionResultUsed(Node expr) {\n+    // TODO(johnlenz): consider sharing some code with trySimpleUnusedResult.\n+    Node parent = expr.getParent();\n+    switch (parent.getType()) {\n+      case Token.EXPR_RESULT:\n+        return false;\n+      case Token.HOOK:\n+      case Token.AND:\n+      case Token.OR:\n+        return (expr == parent.getFirstChild())\n+            ? true : isExpressionResultUsed(parent);\n+      case Token.COMMA:\n+        return (expr == parent.getFirstChild())\n+            ? false : isExpressionResultUsed(parent);\n+      case Token.FOR:\n+        if (!NodeUtil.isForIn(parent)) {\n+          // Only an expression whose result is in the condition part of the\n+          // expression is used.\n+          return (parent.getChildAtIndex(1) == expr);\n+        }\n+        break;\n+    }\n+    return true;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n \n         case Token.NAME:\n         case Token.STRING:\n-        case Token.GET:\n-        case Token.SET:\n+        case Token.GETTER_DEF:\n+        case Token.SETTER_DEF:\n           if (!compiler.getLifeCycleStage().isNormalizedObfuscated()) {\n             annotateConstantsByConvention(n, parent);\n           }\n       Preconditions.checkState(\n           n.isName()\n           || n.isString()\n-          || n.isGet()\n-          || n.isSet());\n+          || n.isGetterDef()\n+          || n.isSetterDef());\n \n       // There are only two cases where a string token\n       // may be a variable reference: The right side of a GETPROP\n--- a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n+++ b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n   private boolean tryReplaceArguments(Scope scope) {\n \n     Node parametersList = scope.getRootNode().getFirstChild().getNext();\n-    Preconditions.checkState(parametersList.isLP());\n+    Preconditions.checkState(parametersList.isParamList());\n \n     // Keep track of rather this function modified the AST and needs to be\n     // reported back to the compiler later.\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     for (Node c = left.getFirstChild(); c != null; c = c.getNext()) {\n       if (c.getString().equals(right.getString())) {\n         switch (c.getType()) {\n-          case Token.SET:\n+          case Token.SETTER_DEF:\n             continue;\n-          case Token.GET:\n+          case Token.GETTER_DEF:\n           case Token.STRING:\n             if (value != null && mayHaveSideEffects(value)) {\n               // The previously found value had side-effects\n     }\n \n     Node replacement = value.detachFromParent();\n-    if (key.isGet()){\n+    if (key.isGetterDef()){\n       replacement = new Node(Token.CALL, replacement);\n       replacement.putBooleanProp(Node.FREE_CALL, true);\n     }\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n \n     // The first child is the switch conditions skip it when looking for cases.\n     for (Node c = n.getFirstChild().getNext(); c != null; c = c.getNext()) {\n-      if (c.isDefault()) {\n+      if (c.isDefaultCase()) {\n         // Remove cases that fall-through to the default case\n         Node caseToRemove = lastNonRemovable.getNext();\n         for (Node next; caseToRemove != c; caseToRemove = next) {\n \n     Node executingCase = caseNode;\n     while (executingCase != null) {\n-      Preconditions.checkState(executingCase.isDefault()\n+      Preconditions.checkState(executingCase.isDefaultCase()\n           || executingCase.isCase());\n       // We only expect a DEFAULT case if the case we are checking is the\n       // DEFAULT case.  Otherwise we assume the DEFAULT case has already\n       // been removed.\n       Preconditions.checkState(caseNode == executingCase\n-          || executingCase.getType() != Token.DEFAULT);\n+          || !executingCase.isDefaultCase());\n       Node block = executingCase.getLastChild();\n       Preconditions.checkState(block.isBlock());\n       if (block.hasChildren()) {\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n       Node parent = getParent();\n       Node grandparent = parent.getParent();\n       return DECLARATION_PARENTS.contains(parent.getType()) ||\n-          parent.isLP() &&\n+          parent.isParamList() &&\n           grandparent.isFunction();\n     }\n \n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n       Preconditions.checkState(\n           toRemove.isVar() ||\n           toRemove.isFunction() ||\n-          toRemove.isLP() &&\n+          toRemove.isParamList() &&\n           parent.isFunction(),\n           \"We should only declare vars and functions and function args\");\n \n-      if (toRemove.isLP() &&\n+      if (toRemove.isParamList() &&\n           parent.isFunction()) {\n         // Don't remove function arguments here. That's a special case\n         // that's taken care of in removeUnreferencedFunctionArgs.\n--- a/src/com/google/javascript/jscomp/ReplaceMessages.java\n+++ b/src/com/google/javascript/jscomp/ReplaceMessages.java\n     Node nameNode = functionNode.getFirstChild();\n     checkNode(nameNode, Token.NAME);\n     Node argListNode = nameNode.getNext();\n-    checkNode(argListNode, Token.LP);\n+    checkNode(argListNode, Token.PARAM_LIST);\n     Node oldBlockNode = argListNode.getNext();\n     checkNode(oldBlockNode, Token.BLOCK);\n \n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n       // Arguments of external functions should not count as name\n       // definitions.  They are placeholder names for documentation\n       // purposes only which are not reachable from anywhere.\n-      if (inExterns && node.isName() && parent.isLP()) {\n+      if (inExterns && node.isName() && parent.isParamList()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/StrictModeCheck.java\n+++ b/src/com/google/javascript/jscomp/StrictModeCheck.java\n       case Token.CATCH:\n         return true;\n \n-      case Token.LP:\n+      case Token.PARAM_LIST:\n         return n.getParent().getParent().isFunction();\n \n       default:\n       if (!noCajaChecks && key.getString().endsWith(\"__\")) {\n         t.report(key, ILLEGAL_NAME);\n       }\n-      if (key.getType() != Token.SET) {\n+      if (key.getType() != Token.SETTER_DEF) {\n         // normal property and getter cases\n         if (getters.contains(key.getString())) {\n           t.report(key, DUPLICATE_OBJECT_KEY);\n           getters.add(key.getString());\n         }\n       }\n-      if (key.getType() != Token.GET) {\n+      if (key.getType() != Token.GETTER_DEF) {\n         // normal property and setter cases\n         if (setters.contains(key.getString())) {\n           t.report(key, DUPLICATE_OBJECT_KEY);\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n       }\n \n       // Args: Declare function variables\n-      Preconditions.checkState(args.isLP());\n+      Preconditions.checkState(args.isParamList());\n       for (Node a = args.getFirstChild(); a != null;\n            a = a.getNext()) {\n         Preconditions.checkState(a.isName());\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n         typeable = visitName(t, n, parent);\n         break;\n \n-      case Token.LP:\n+      case Token.PARAM_LIST:\n         // If this is under a FUNCTION node, it is a parameter list and can be\n         // ignored here.\n         if (parent.getType() != Token.FUNCTION) {\n         }\n         break;\n \n-      case Token.GET:\n-      case Token.SET:\n+      case Token.GETTER_DEF:\n+      case Token.SETTER_DEF:\n         // Object literal keys are handled with OBJECTLIT\n         break;\n \n       case Token.EXPR_RESULT:\n       case Token.BLOCK:\n       case Token.EMPTY:\n-      case Token.DEFAULT:\n+      case Token.DEFAULT_CASE:\n       case Token.CONTINUE:\n       case Token.DEBUGGER:\n       case Token.THROW:\n     int parentNodeType = parent.getType();\n     if (parentNodeType == Token.FUNCTION ||\n         parentNodeType == Token.CATCH ||\n-        parentNodeType == Token.LP ||\n+        parentNodeType == Token.PARAM_LIST ||\n         parentNodeType == Token.VAR) {\n       return false;\n     }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n         n.setJSType(getNativeType(NUMBER_TYPE));\n         break;\n \n-      case Token.LP:\n+      case Token.PARAM_LIST:\n         scope = traverse(n.getFirstChild(), scope);\n         n.setJSType(getJSType(n.getFirstChild()));\n         break;\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n         Preconditions.checkArgument(\n             parent.isFunction() ||\n             parent.isVar() ||\n-            parent.isLP() ||\n+            parent.isParamList() ||\n             parent.isCatch());\n       } else {\n         Preconditions.checkArgument(\n     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n == scope.getRootNode()) return;\n \n-      if (n.isLP() && parent == scope.getRootNode()) {\n+      if (n.isParamList() && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n         switch (parent.getType()) {\n           case Token.VAR:\n           case Token.FUNCTION:\n-          case Token.LP:\n+          case Token.PARAM_LIST:\n             // These are okay.\n             break;\n           case Token.GETPROP:\n--- a/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n+++ b/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n    * <pre>\n    *    Token.VAR (for a variable declaration)\n    *    Token.FUNCTION (for a function declaration)\n-   *    Token.LP (for a function formal parameter)\n+   *    Token.PARAM_LIST (for a function formal parameter)\n    * </pre>\n    *\n    * The returned visibility will be one of:\n \n     Preconditions.checkArgument(parent.isVar()\n         || parent.isFunction()\n-        || parent.isLP());\n+        || parent.isParamList());\n \n     return visibilityByDeclaringNameNode.get(declaringNameNode);\n   }\n   private static boolean variableIsParameter(Var variable) {\n     Node variableParent = variable.getParentNode();\n \n-    return variableParent != null && variableParent.isLP();\n+    return variableParent != null && variableParent.isParamList();\n   }\n }\n--- a/src/com/google/javascript/jscomp/jsonml/Reader.java\n+++ b/src/com/google/javascript/jscomp/jsonml/Reader.java\n    */\n   private void transformGetterProp(JsonML element, Node parent)\n       throws JsonMLException {\n-    transformProp(Token.GET, element, parent);\n+    transformProp(Token.GETTER_DEF, element, parent);\n   }\n \n   /*\n    */\n   private void transformSetterProp(JsonML element, Node parent)\n       throws JsonMLException {\n-    transformProp(Token.SET, element, parent);\n+    transformProp(Token.SETTER_DEF, element, parent);\n   }\n \n   private void transformProp(int tokenType, JsonML element, Node parent)\n \n   private void transformDefaultCase(JsonML element, Node parent)\n       throws JsonMLException {\n-    Node node = createNode(Token.DEFAULT, element);\n+    Node node = createNode(Token.DEFAULT_CASE, element);\n     parent.addChildToBack(node);\n \n     // the first child represent body\n   private void transformParamDecl(JsonML element, Node parent)\n       throws JsonMLException {\n     // formal arguments should be wrapped by LP node\n-    Node node = createNode(Token.LP, element);\n+    Node node = createNode(Token.PARAM_LIST, element);\n     parent.addChildToBack(node);\n \n     transformAllChildren(element, node);\n--- a/src/com/google/javascript/jscomp/jsonml/Writer.java\n+++ b/src/com/google/javascript/jscomp/jsonml/Writer.java\n       case Token.CASE:\n         processCase(node, currentParent, TagType.Case);\n         break;\n-      case Token.DEFAULT:\n+      case Token.DEFAULT_CASE:\n         processCase(node, currentParent, TagType.DefaultCase);\n         break;\n       case Token.WHILE:\n           item = new JsonML(TagType.DataProp);\n           name = key.getDouble();\n           break;\n-        case Token.GET:\n+        case Token.GETTER_DEF:\n           item = new JsonML(TagType.GetterProp);\n           name = key.getString();\n           break;\n-        case Token.SET:\n+        case Token.SETTER_DEF:\n           item = new JsonML(TagType.SetterProp);\n           name = key.getString();\n           break;\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n       }\n \n       node.addChildToBack(newName);\n-      Node lp = newNode(Token.LP);\n+      Node lp = newNode(Token.PARAM_LIST);\n       // The left paren's complicated because it's not represented by an\n       // AstNode, so there's nothing that has the actual line number that it\n       // appeared on.  We know the paren has to appear on the same line as the\n         Node key = transformAsString(el.getLeft());\n         Node value = transform(el.getRight());\n         if (el.isGetter()) {\n-          key.setType(Token.GET);\n+          key.setType(Token.GETTER_DEF);\n           Preconditions.checkState(value.isFunction());\n           if (getFnParamNode(value).hasChildren()) {\n             reportGetterParam(el.getLeft());\n           }\n         } else if (el.isSetter()) {\n-          key.setType(Token.SET);\n+          key.setType(Token.SETTER_DEF);\n           Preconditions.checkState(value.isFunction());\n           if (!getFnParamNode(value).hasOneChild()) {\n             reportSetterParam(el.getLeft());\n     Node processSwitchCase(SwitchCase caseNode) {\n       Node node;\n       if (caseNode.isDefault()) {\n-        node = newNode(Token.DEFAULT);\n+        node = newNode(Token.DEFAULT_CASE);\n       } else {\n         AstNode expr = caseNode.getExpression();\n         node = newNode(Token.CASE, transform(expr));\n         return Token.TRY;\n       // The LP represents a parameter list\n       case com.google.javascript.jscomp.mozilla.rhino.Token.LP:\n-        return Token.LP;\n+        return Token.PARAM_LIST;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA:\n         return Token.COMMA;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN:\n       case com.google.javascript.jscomp.mozilla.rhino.Token.CASE:\n         return Token.CASE;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT:\n-        return Token.DEFAULT;\n+        return Token.DEFAULT_CASE;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE:\n         return Token.WHILE;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.DO:\n       case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT:\n         return Token.SCRIPT;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.GET:\n-        return Token.GET;\n+        return Token.GETTER_DEF;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.SET:\n-        return Token.SET;\n+        return Token.SETTER_DEF;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.CONST:\n         return Token.CONST;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n   // has to happen during type resolution. Rather than duplicate the\n   // order-checking in two places, we just do all of it in type resolution.\n   private Node parseParametersType(JsDocToken token) {\n-    Node paramsType = newNode(Token.LP);\n+    Node paramsType = newNode(Token.PARAM_LIST);\n     boolean isVarArgs = false;\n     Node paramType = null;\n     if (token != JsDocToken.RP) {\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       case Token.IN:              return \"in\";\n       case Token.INSTANCEOF:      return \"instanceof\";\n       case Token.TRY:             return \"try\";\n-      case Token.LP:              return \"lp\";\n+      case Token.PARAM_LIST:      return \"lp\";\n       case Token.COMMA:           return \"comma\";\n       case Token.ASSIGN:          return \"assign\";\n       case Token.ASSIGN_BITOR:    return \"assign_bitor\";\n       case Token.IF:              return \"if\";\n       case Token.SWITCH:          return \"switch\";\n       case Token.CASE:            return \"case\";\n-      case Token.DEFAULT:         return \"default\";\n+      case Token.DEFAULT_CASE:    return \"default\";\n       case Token.WHILE:           return \"while\";\n       case Token.DO:              return \"do\";\n       case Token.FOR:             return \"for\";\n     return this.getType() == Token.DEC;\n   }\n \n-  public boolean isDefault() {\n-    return this.getType() == Token.DEFAULT;\n+  public boolean isDefaultCase() {\n+    return this.getType() == Token.DEFAULT_CASE;\n   }\n \n   public boolean isDo() {\n     return this.getType() == Token.FUNCTION;\n   }\n \n-  public boolean isGet() {\n-    return this.getType() == Token.GET;\n+  public boolean isGetterDef() {\n+    return this.getType() == Token.GETTER_DEF;\n   }\n \n   public boolean isGetElem() {\n     return this.getType() == Token.LABEL_NAME;\n   }\n \n-  public boolean isLP() {\n-    return this.getType() == Token.LP;\n-  }\n-\n   public boolean isName() {\n     return this.getType() == Token.NAME;\n   }\n     return this.getType() == Token.OR;\n   }\n \n+  public boolean isParamList() {\n+    return this.getType() == Token.PARAM_LIST;\n+  }\n+\n   public boolean isRegExp() {\n     return this.getType() == Token.REGEXP;\n   }\n     return this.getType() == Token.SCRIPT;\n   }\n \n-  public boolean isSet() {\n-    return this.getType() == Token.SET;\n+  public boolean isSetterDef() {\n+    return this.getType() == Token.SETTER_DEF;\n   }\n \n   public boolean isString() {\n   public boolean isVoid() {\n     return this.getType() == Token.VOID;\n   }\n-\n }\n--- a/src/com/google/javascript/rhino/Token.java\n+++ b/src/com/google/javascript/rhino/Token.java\n         OBJECTLIT      = 64, // object literal\n \n         TRY            = 77,\n-        LP             = 83,  // left and right parentheses\n+        PARAM_LIST     = 83,\n         COMMA          = 85,  // comma operator\n \n         ASSIGN         = 86,  // simple assignment  (=)\n         ASSIGN_DIV     = 96,  // /=\n         ASSIGN_MOD     = 97,  // %=\n \n-        HOOK           = 98, // conditional (?:)\n+        HOOK           = 98,  // conditional (?:)\n         OR             = 100, // logical or (||)\n         AND            = 101, // logical and (&&)\n-        INC            = 102, // increment/decrement (++ --)\n-        DEC            = 103,\n+        INC            = 102, // increment (++)\n+        DEC            = 103, // decrement (--)\n         FUNCTION       = 105, // function keyword\n         IF             = 108, // if keyword\n         SWITCH         = 110, // switch keyword\n         CASE           = 111, // case keyword\n-        DEFAULT        = 112, // default keyword\n+        DEFAULT_CASE   = 112, // default keyword\n         WHILE          = 113, // while keyword\n         DO             = 114, // do keyword\n         FOR            = 115, // for keyword\n         EXPR_RESULT    = 130, // expression statement in scripts\n         SCRIPT         = 132, // top-level node for entire script\n \n-        GET            = 147,  // JS 1.5 get pseudo keyword\n-        SET            = 148,  // JS 1.5 set pseudo keyword\n+        GETTER_DEF     = 147,\n+        SETTER_DEF     = 148,\n \n         CONST          = 149,  // JS 1.5 const keyword\n         DEBUGGER       = 152,\n         LB             = 308,  // left brackets\n         LC             = 309,  // left curly braces\n         COLON          = 310;\n+\n+    // Transitional definitions\n+    // TODO(johnlenz): remove these\n+    public final static int\n+         DEFAULT        = DEFAULT_CASE,\n+         GET            = GETTER_DEF,\n+         LP             = PARAM_LIST,\n+         SET            = SETTER_DEF;\n \n   public static String name(int token) {\n         switch (token) {\n           case ARRAYLIT:        return \"ARRAYLIT\";\n           case OBJECTLIT:       return \"OBJECTLIT\";\n           case TRY:             return \"TRY\";\n-          case LP:              return \"LP\";\n+          case PARAM_LIST:      return \"PARAM_LIST\";\n           case COMMA:           return \"COMMA\";\n           case ASSIGN:          return \"ASSIGN\";\n           case ASSIGN_BITOR:    return \"ASSIGN_BITOR\";\n           case IF:              return \"IF\";\n           case SWITCH:          return \"SWITCH\";\n           case CASE:            return \"CASE\";\n-          case DEFAULT:         return \"DEFAULT\";\n+          case DEFAULT_CASE:    return \"DEFAULT_CASE\";\n           case WHILE:           return \"WHILE\";\n           case DO:              return \"DO\";\n           case FOR:             return \"FOR\";\n           case LABEL:           return \"LABEL\";\n           case EXPR_RESULT:     return \"EXPR_RESULT\";\n           case SCRIPT:          return \"SCRIPT\";\n-          case GET:             return \"GET\";\n-          case SET:             return \"SET\";\n+          case GETTER_DEF:      return \"GETTER_DEF\";\n+          case SETTER_DEF:      return \"SETTER_DEF\";\n           case CONST:           return \"CONST\";\n           case DEBUGGER:        return \"DEBUGGER\";\n           case ANNOTATION:      return \"ANNOTATION\";\n--- a/src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java\n public class FunctionParamBuilder {\n \n   private final JSTypeRegistry registry;\n-  private final Node root = new Node(Token.LP);\n+  private final Node root = new Node(Token.PARAM_LIST);\n \n   public FunctionParamBuilder(JSTypeRegistry registry) {\n     this.registry = registry;\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n         Token.FUNCTION == source.getType());\n     Preconditions.checkArgument(name != null);\n     this.source = source;\n-    this.call = new ArrowType(registry, new Node(Token.LP), null);\n+    this.call = new ArrowType(registry, new Node(Token.PARAM_LIST), null);\n     this.kind = Kind.INTERFACE;\n     this.typeOfThis = new InstanceObjectType(registry, this);\n   }\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n \n         FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this);\n \n-        if (current.getType() == Token.LP) {\n+        if (current.getType() == Token.PARAM_LIST) {\n           Node args = current.getFirstChild();\n           for (Node arg = current.getFirstChild(); arg != null;\n                arg = arg.getNext()) {\n--- a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n   private ClosureCodingConvention conv = new ClosureCodingConvention();\n \n   public void testVarAndOptionalParams() {\n-    Node args = new Node(Token.LP,\n+    Node args = new Node(Token.PARAM_LIST,\n         Node.newString(Token.NAME, \"a\"),\n         Node.newString(Token.NAME, \"b\"));\n-    Node optArgs = new Node(Token.LP,\n+    Node optArgs = new Node(Token.PARAM_LIST,\n         Node.newString(Token.NAME, \"opt_a\"),\n         Node.newString(Token.NAME, \"opt_b\"));\n \n \n     Node nodeA = new Node(Token.FUNCTION);\n     FunctionType ctorA = registry.createConstructorType(\"A\", nodeA,\n-        new Node(Token.LP), null);\n+        new Node(Token.PARAM_LIST), null);\n \n     Node nodeB = new Node(Token.FUNCTION);\n     FunctionType ctorB = registry.createConstructorType(\"B\", nodeB,\n-        new Node(Token.LP), null);\n+        new Node(Token.PARAM_LIST), null);\n \n     conv.applySubclassRelationship(ctorA, ctorB, SubclassType.INHERITS);\n \n--- a/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n+++ b/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n   /** Creates a fake function with the given description. */\n   private ConcreteFunctionType createFunction(\n       String name, String... paramNames) {\n-    Node args = new Node(Token.LP);\n+    Node args = new Node(Token.PARAM_LIST);\n     for (int i = 0; i < paramNames.length; ++i) {\n       args.addChildToBack(Node.newString(Token.NAME, paramNames[i]));\n     }\n--- a/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n     // Transfer between cases and default.\n     assertDownEdge(cfg, Token.SWITCH, Token.CASE, Branch.UNCOND);\n     assertCrossEdge(cfg, Token.CASE, Token.CASE, Branch.ON_FALSE);\n-    assertCrossEdge(cfg, Token.CASE, Token.DEFAULT, Branch.ON_FALSE);\n+    assertCrossEdge(cfg, Token.CASE, Token.DEFAULT_CASE, Branch.ON_FALSE);\n     // Within each case.\n     assertDownEdge(cfg, Token.CASE, Token.BLOCK, Branch.ON_TRUE);\n     assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND);\n     String src = \"var x; switch(x){ default: break; case 1: break; }\";\n     ControlFlowGraph<Node> cfg = createCfg(src);\n     assertDownEdge(cfg, Token.SWITCH, Token.CASE, Branch.UNCOND);\n-    assertCrossEdge(cfg, Token.CASE, Token.DEFAULT, Branch.ON_FALSE);\n+    assertCrossEdge(cfg, Token.CASE, Token.DEFAULT_CASE, Branch.ON_FALSE);\n   }\n \n   public void testSwitchDefaultInMiddle() {\n     ControlFlowGraph<Node> cfg = createCfg(src);\n     assertDownEdge(cfg, Token.SWITCH, Token.CASE, Branch.UNCOND);\n     assertCrossEdge(cfg, Token.CASE, Token.CASE, Branch.ON_FALSE);\n-    assertCrossEdge(cfg, Token.CASE, Token.DEFAULT, Branch.ON_FALSE);\n+    assertCrossEdge(cfg, Token.CASE, Token.DEFAULT_CASE, Branch.ON_FALSE);\n   }\n \n   public void testSwitchEmpty() {\n       \"  node0 -> node1 [weight=1];\\n\" +\n       \"  node2 [label=\\\"NAME\\\"];\\n\" +\n       \"  node1 -> node2 [weight=1];\\n\" +\n-      \"  node3 [label=\\\"LP\\\"];\\n\" +\n+      \"  node3 [label=\\\"PARAM_LIST\\\"];\\n\" +\n       \"  node1 -> node3 [weight=1];\\n\" +\n       \"  node4 [label=\\\"BLOCK\\\"];\\n\" +\n       \"  node1 -> node4 [weight=1];\\n\" +\n       \"  node0 -> node1 [weight=1];\\n\" +\n       \"  node2 [label=\\\"NAME\\\"];\\n\" +\n       \"  node1 -> node2 [weight=1];\\n\" +\n-      \"  node3 [label=\\\"LP\\\"];\\n\" +\n+      \"  node3 [label=\\\"PARAM_LIST\\\"];\\n\" +\n       \"  node1 -> node3 [weight=1];\\n\" +\n       \"  node4 [label=\\\"BLOCK\\\"];\\n\" +\n       \"  node1 -> node4 [weight=1];\\n\" +\n         + \"  node2 -> node3 [weight=1];\\n\"\n         + \"  node4 [label=\\\"NAME\\\"];\\n\"\n         + \"  node3 -> node4 [weight=1];\\n\"\n-        + \"  node5 [label=\\\"LP\\\"];\\n\"\n+        + \"  node5 [label=\\\"PARAM_LIST\\\"];\\n\"\n         + \"  node3 -> node5 [weight=1];\\n\"\n         + \"  node6 [label=\\\"BLOCK\\\"];\\n\"\n         + \"  node3 -> node6 [weight=1];\\n\"\n       \"  node0 -> node4 [weight=1];\\n\" +\n       \"  node5 [label=\\\"NAME\\\"];\\n\" +\n       \"  node4 -> node5 [weight=1];\\n\" +\n-      \"  node6 [label=\\\"LP\\\"];\\n\" +\n+      \"  node6 [label=\\\"PARAM_LIST\\\"];\\n\" +\n       \"  node4 -> node6 [weight=1];\\n\" +\n       \"  node7 [label=\\\"BLOCK\\\"];\\n\" +\n       \"  node4 -> node7 [weight=1];\\n\" +\n       \"  node0 -> node4 [weight=1];\\n\" +\n       \"  node5 [label=\\\"NAME\\\"];\\n\" +\n       \"  node4 -> node5 [weight=1];\\n\" +\n-      \"  node6 [label=\\\"LP\\\"];\\n\" +\n+      \"  node6 [label=\\\"PARAM_LIST\\\"];\\n\" +\n       \"  node4 -> node6 [weight=1];\\n\" +\n       \"  node7 [label=\\\"BLOCK\\\"];\\n\" +\n       \"  node4 -> node7 [weight=1];\\n\" +\n         \"  node2 -> node4 [weight=1];\\n\" +\n         \"  node5 [label=\\\"NAME\\\"];\\n\" +\n         \"  node4 -> node5 [weight=1];\\n\" +\n-        \"  node6 [label=\\\"LP\\\"];\\n\" +\n+        \"  node6 [label=\\\"PARAM_LIST\\\"];\\n\" +\n         \"  node4 -> node6 [weight=1];\\n\" +\n         \"  node7 [label=\\\"BLOCK\\\"];\\n\" +\n         \"  node4 -> node7 [weight=1];\\n\" +\n--- a/test/com/google/javascript/jscomp/DefaultCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/DefaultCodingConventionTest.java\n   private CodingConvention conv = CodingConventions.getDefault();\n \n   public void testVarAndOptionalParams() {\n-    Node args = new Node(Token.LP,\n+    Node args = new Node(Token.PARAM_LIST,\n         Node.newString(Token.NAME, \"a\"),\n         Node.newString(Token.NAME, \"b\"));\n-    Node optArgs = new Node(Token.LP,\n+    Node optArgs = new Node(Token.PARAM_LIST,\n         Node.newString(Token.NAME, \"opt_a\"),\n         Node.newString(Token.NAME, \"opt_b\"));\n \n--- a/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java\n   private GoogleCodingConvention conv = new GoogleCodingConvention();\n \n   public void testVarAndOptionalParams() {\n-    Node args = new Node(Token.LP,\n+    Node args = new Node(Token.PARAM_LIST,\n         Node.newString(Token.NAME, \"a\"),\n         Node.newString(Token.NAME, \"b\"));\n-    Node optArgs = new Node(Token.LP,\n+    Node optArgs = new Node(Token.PARAM_LIST,\n         Node.newString(Token.NAME, \"opt_a\"),\n         Node.newString(Token.NAME, \"opt_b\"));\n \n--- a/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n+++ b/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n     // TODO(johnlenz): Add support for quoted properties\n     checkDefinitionsInJs(\n       \"({get a() {}}); o.a\",\n-      ImmutableSet.of(\"DEF GET null -> FUNCTION\",\n+      ImmutableSet.of(\"DEF GETTER_DEF null -> FUNCTION\",\n                       \"USE GETPROP o.a -> [FUNCTION]\"));\n   }\n \n     checkDefinitionsInJs(\n       \"({set a(b) {}}); o.a\",\n       ImmutableSet.of(\"DEF NAME b -> <null>\",\n-                      \"DEF SET null -> FUNCTION\",\n+                      \"DEF SETTER_DEF null -> FUNCTION\",\n                       \"USE GETPROP o.a -> [FUNCTION]\"));\n   }\n \n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n \n     assertEquals(2, refs.size());\n     assertEquals(x.getDeclaration(), refs.get(0));\n-    assertEquals(Token.LP, refs.get(0).getNode().getParent().getType());\n+    assertEquals(Token.PARAM_LIST, refs.get(0).getNode().getParent().getType());\n     assertEquals(Token.RETURN, refs.get(1).getNode().getParent().getType());\n   }\n \n--- a/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java\n \n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (n.getParent().isLP()\n+        if (n.getParent().isParamList()\n             && parameterName.equals(n.getString())) {\n \n           foundNode[0] = n;\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n         \"SCRIPT 1 [source_file: FileName.js] [length: 14]\\n\" +\n         \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 13]\\n\" +\n         \"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 12]\\n\" +\n-        \"            GET 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n+        \"            GETTER_DEF 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n         \"                FUNCTION  1 [source_file: FileName.js] [length: 6]\\n\" +\n         \"                    NAME  1 [source_file: FileName.js]\\n\" +\n-        \"                    LP 1 [source_file: FileName.js]\\n\" +\n+        \"                    PARAM_LIST 1 [source_file: FileName.js]\\n\" +\n         \"                    BLOCK 1 [source_file: FileName.js] [length: 2]\\n\");\n   }\n \n         \"SCRIPT 1 [source_file: FileName.js] [length: 15]\\n\" +\n         \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\\n\" +\n         \"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 13]\\n\" +\n-        \"            SET 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n+        \"            SETTER_DEF 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\\n\" +\n         \"                FUNCTION  1 [source_file: FileName.js] [length: 7]\\n\" +\n         \"                    NAME  1 [source_file: FileName.js]\\n\" +\n-        \"                    LP 1 [source_file: FileName.js]\\n\" +\n+        \"                    PARAM_LIST 1 [source_file: FileName.js]\\n\" +\n         \"                        NAME a 1 [source_file: FileName.js] [length: 1]\\n\" +\n         \"                    BLOCK 1 [source_file: FileName.js] [length: 2]\\n\");\n   }\n         \"SCRIPT 1 [source_file: FileName.js] [length: 14]\\n\" +\n         \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 13]\\n\" +\n         \"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 12]\\n\" +\n-        \"            GET a 1 [source_file: FileName.js] [length: 1]\\n\" +\n+        \"            GETTER_DEF a 1 [source_file: FileName.js] [length: 1]\\n\" +\n         \"                FUNCTION  1 [source_file: FileName.js] [length: 6]\\n\" +\n         \"                    NAME  1 [source_file: FileName.js]\\n\" +\n-        \"                    LP 1 [source_file: FileName.js]\\n\" +\n+        \"                    PARAM_LIST 1 [source_file: FileName.js]\\n\" +\n         \"                    BLOCK 1 [source_file: FileName.js] [length: 2]\\n\");\n   }\n \n         \"SCRIPT 1 [source_file: FileName.js] [length: 15]\\n\" +\n         \"    EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\\n\" +\n         \"        OBJECTLIT 1 [parenthesized: true] [source_file: FileName.js] [length: 13]\\n\" +\n-        \"            SET a 1 [source_file: FileName.js] [length: 1]\\n\" +\n+        \"            SETTER_DEF a 1 [source_file: FileName.js] [length: 1]\\n\" +\n         \"                FUNCTION  1 [source_file: FileName.js] [length: 7]\\n\" +\n         \"                    NAME  1 [source_file: FileName.js]\\n\" +\n-        \"                    LP 1 [source_file: FileName.js]\\n\" +\n+        \"                    PARAM_LIST 1 [source_file: FileName.js]\\n\" +\n         \"                        NAME x 1 [source_file: FileName.js] [length: 1]\\n\" +\n         \"                    BLOCK 1 [source_file: FileName.js] [length: 2]\\n\");\n   }\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n         .withReturnType(NUMBER_TYPE)\n         .build();\n     dateMethod = new FunctionBuilder(registry)\n-        .withParamsNode(new Node(Token.LP))\n+        .withParamsNode(new Node(Token.PARAM_LIST))\n         .withReturnType(NUMBER_TYPE)\n         .withTypeOfThis(DATE_TYPE)\n         .build();\n   public void testSupertypeOfProxiedFunctionTypes() {\n     ObjectType fn1 =\n         new FunctionBuilder(registry)\n-        .withParamsNode(new Node(Token.LP))\n+        .withParamsNode(new Node(Token.PARAM_LIST))\n         .withReturnType(NUMBER_TYPE)\n         .build();\n     ObjectType fn2 =\n         new FunctionBuilder(registry)\n-        .withParamsNode(new Node(Token.LP))\n+        .withParamsNode(new Node(Token.PARAM_LIST))\n         .withReturnType(STRING_TYPE)\n         .build();\n     ObjectType p1 = new ProxyObjectType(registry, fn1);\n     ObjectType p2 = new ProxyObjectType(registry, fn2);\n     ObjectType supremum =\n         new FunctionBuilder(registry)\n-        .withParamsNode(new Node(Token.LP))\n+        .withParamsNode(new Node(Token.PARAM_LIST))\n         .withReturnType(registry.createUnionType(STRING_TYPE, NUMBER_TYPE))\n         .build();\n ", "timestamp": 1321058561, "metainfo": ""}