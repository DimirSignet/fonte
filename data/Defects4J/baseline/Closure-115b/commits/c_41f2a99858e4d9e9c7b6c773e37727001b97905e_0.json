{"sha": "41f2a99858e4d9e9c7b6c773e37727001b97905e", "log": "Move MinimizedCondition to its own class ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=48266702", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/MinimizedCondition.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+\n+/** A class that represents a minimized conditional expression.\n+ *  Depending on the context, a leading NOT node in front of the conditional\n+ *  may or may not be counted as a cost, so this class provides ways to\n+ *  access minimized versions of both of those ASTs.\n+ *\n+ *  @author blickly@google.com (Ben Lickly)\n+ */\n+class MinimizedCondition {\n+\n+  /** Definitions of the style of minimization preferred. */\n+  enum MinimizationStyle {\n+    /** Compute the length of the minimized condition as including\n+     *  any leading NOT node, if present. */\n+    PREFER_UNNEGATED,\n+    /** Compute the length of the minimized condition without penalizing\n+     *  a leading NOT node, if present. */\n+    ALLOW_LEADING_NOT;\n+  }\n+\n+  /** A representation equivalent to the original condition. */\n+  private final MeasuredNode positive;\n+  /** A representation equivalent to the negation of the original condition. */\n+  private final MeasuredNode negative;\n+\n+  /** A placeholder at the same AST location as the original condition */\n+  private Node placeholder;\n+\n+  private MinimizedCondition(MeasuredNode p, MeasuredNode n) {\n+    Preconditions.checkArgument(p.node.getParent() == null);\n+    Preconditions.checkArgument(n.node.getParent() == null);\n+    positive = p;\n+    negative = n.change();\n+  }\n+\n+  Node getPlaceholder() {\n+    return placeholder;\n+  }\n+\n+  MinimizedCondition setPlaceholder(Node placeholder) {\n+    this.placeholder = placeholder;\n+    return this;\n+  }\n+\n+  /** Remove the passed condition node from the AST, and then return a\n+   *  MinimizedCondition that represents the condition node after\n+   *  minimization.\n+   */\n+  static MinimizedCondition fromConditionNode(Node n) {\n+    MinimizedCondition minCond;\n+    switch (n.getType()) {\n+      case Token.NOT:\n+      case Token.AND:\n+      case Token.OR:\n+      case Token.HOOK:\n+      case Token.COMMA:\n+        Node placeholder = swapWithPlaceholderNode(n);\n+        return computeMinimizedCondition(n).setPlaceholder(placeholder);\n+      default:\n+        return unoptimized(n);\n+    }\n+  }\n+\n+  /** Return the shorter representation of the original condition node.\n+   *\n+   * @param style Whether to count a leading NOT in doing the minimization.\n+   *  i.e. Prefer the right side in cases such as:\n+   *    !x || !y || z  ==>  !(x && y && !z)\n+   *  This is useful in contexts such as IFs or HOOKs where subsequent\n+   *  optimizations can efficiently deal with leading NOTs.\n+   *\n+   *  @return The minimized condition MeasuredNode, with equivalent semantics\n+   *    to that passed to #fromConditionNode().\n+   */\n+  MeasuredNode getMinimized(MinimizationStyle style) {\n+    if (style == MinimizationStyle.PREFER_UNNEGATED\n+        || positive.node.isNot()\n+        || positive.length <= negative.length) {\n+      return positive;\n+    } else {\n+      return negative.addNot();\n+    }\n+  }\n+\n+  /** Return a MeasuredNode of the given condition node, without minimizing\n+   * the result.\n+   *\n+   *  @param n The conditional expression tree to minimize.\n+   *   This must be removed from the tree before being passed in connected.\n+   *  @return A MinimizedCondition object representing that tree.\n+   */\n+  static MinimizedCondition unoptimized(Node n) {\n+    Preconditions.checkNotNull(n.getParent());\n+    Node placeholder = swapWithPlaceholderNode(n);\n+    MeasuredNode pos = new MeasuredNode(n, 0, false);\n+    // In the unoptimized case, we want to always return the positive side,\n+    // so we set the negative side to a SCRIPT node (never valid inside an\n+    // expression) with an unreasonably high length so that it's never chosen.\n+    MeasuredNode neg = new MeasuredNode(IR.script(), Integer.MAX_VALUE, true);\n+    return new MinimizedCondition(pos, neg).setPlaceholder(placeholder);\n+  }\n+\n+  /** Remove the given node from the AST, and replace it with a placeholder\n+   *  SCRIPT node.\n+   *  @return The new placeholder node.\n+   */\n+  private static Node swapWithPlaceholderNode(Node n) {\n+    Preconditions.checkNotNull(n.getParent());\n+    Node placeholder = IR.script();\n+    n.getParent().replaceChild(n, placeholder);\n+    return placeholder;\n+  }\n+\n+  /** Minimize the condition at the given node.\n+   *\n+   *  @param n The conditional expression tree to minimize.\n+   *   This must be removed from the tree before being passed in connected.\n+   *  @return A MinimizedCondition object representing that tree.\n+   */\n+  private static MinimizedCondition computeMinimizedCondition(Node n) {\n+    Preconditions.checkArgument(n.getParent() == null);\n+    switch (n.getType()) {\n+      case Token.NOT: {\n+        MinimizedCondition subtree =\n+            computeMinimizedCondition(n.getFirstChild().detachFromParent());\n+        ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n+            subtree.positive.cloneTree().addNot(),\n+            subtree.negative.cloneTree());\n+        ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n+            subtree.negative.negate(),\n+            subtree.positive);\n+        return new MinimizedCondition(\n+            Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n+            Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n+      }\n+      case Token.AND:\n+      case Token.OR: {\n+        int opType = n.getType();\n+        int complementType = opType == Token.AND ? Token.OR : Token.AND;\n+        MinimizedCondition leftSubtree =\n+            computeMinimizedCondition(n.getFirstChild().detachFromParent());\n+        MinimizedCondition rightSubtree =\n+            computeMinimizedCondition(n.getLastChild().detachFromParent());\n+        ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n+            MeasuredNode.addNode(new Node(opType).srcref(n),\n+                leftSubtree.positive.cloneTree(),\n+                rightSubtree.positive.cloneTree()),\n+            MeasuredNode.addNode(new Node(complementType).srcref(n),\n+                leftSubtree.negative.cloneTree(),\n+                rightSubtree.negative.cloneTree()).negate());\n+        ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n+            MeasuredNode.addNode(new Node(opType).srcref(n),\n+                leftSubtree.positive,\n+                rightSubtree.positive).negate(),\n+            MeasuredNode.addNode(new Node(complementType).srcref(n),\n+                leftSubtree.negative,\n+                rightSubtree.negative));\n+        return new MinimizedCondition(\n+            Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n+            Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n+      }\n+      case Token.HOOK: {\n+        Node cond = n.getFirstChild();\n+        Node thenNode = cond.getNext();\n+        Node elseNode = thenNode.getNext();\n+        MinimizedCondition thenSubtree =\n+            computeMinimizedCondition(thenNode.detachFromParent());\n+        MinimizedCondition elseSubtree =\n+            computeMinimizedCondition(elseNode.detachFromParent());\n+        MeasuredNode posTree = MeasuredNode.addNode(\n+            new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n+            thenSubtree.positive,\n+            elseSubtree.positive);\n+        MeasuredNode negTree = MeasuredNode.addNode(\n+            new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n+            thenSubtree.negative,\n+            elseSubtree.negative);\n+        return new MinimizedCondition(posTree, negTree);\n+      }\n+      case Token.COMMA: {\n+        Node lhs = n.getFirstChild();\n+        MinimizedCondition rhsSubtree =\n+            computeMinimizedCondition(lhs.getNext().detachFromParent());\n+        MeasuredNode posTree = MeasuredNode.addNode(\n+            new Node(Token.COMMA, lhs.cloneTree()).srcref(n),\n+            rhsSubtree.positive);\n+        MeasuredNode negTree = MeasuredNode.addNode(\n+            new Node(Token.COMMA, lhs.cloneTree()).srcref(n),\n+            rhsSubtree.negative);\n+        return new MinimizedCondition(posTree, negTree);\n+      }\n+      default: {\n+        MeasuredNode pos = new MeasuredNode(n, 0, false);\n+        MeasuredNode neg = pos.cloneTree().negate();\n+        return new MinimizedCondition(pos, neg);\n+      }\n+    }\n+  }\n+\n+  private static final Comparator<MeasuredNode> AST_LENGTH_COMPARATOR =\n+      new Comparator<MeasuredNode>() {\n+    @Override\n+    public int compare(MeasuredNode o1, MeasuredNode o2) {\n+      return o1.length - o2.length;\n+    }\n+  };\n+\n+  /** An AST-node along with some additional metadata. */\n+  static class MeasuredNode {\n+    private Node node;\n+    private int length;\n+    private boolean changed;\n+\n+    Node getNode() {\n+      return node;\n+    }\n+\n+    boolean isChanged() {\n+      return changed;\n+    }\n+\n+    MeasuredNode(Node n, int len, boolean ch) {\n+      node = n;\n+      length = len;\n+      changed = ch;\n+    }\n+\n+    private MeasuredNode negate() {\n+      this.change();\n+      int complementOperator;\n+      switch (node.getType()) {\n+        default:\n+          return this.addNot();\n+        // Otherwise a binary operator with a complement.\n+        case Token.EQ:\n+          complementOperator = Token.NE;\n+          break;\n+        case Token.NE:\n+          complementOperator = Token.EQ;\n+          break;\n+        case Token.SHEQ:\n+          complementOperator = Token.SHNE;\n+          break;\n+        case Token.SHNE:\n+          complementOperator = Token.SHEQ;\n+          break;\n+      }\n+      // Clone entire tree and just change operator.\n+      node.setType(complementOperator);\n+      return this;\n+    }\n+\n+    private MeasuredNode change() {\n+      this.changed = true;\n+      return this;\n+    }\n+\n+    private MeasuredNode addNot() {\n+      node = new Node(Token.NOT, node).srcref(node);\n+      length += estimateCostOneLevel(node);\n+      return this;\n+    }\n+\n+    /** Estimate the number of characters in the textual representation of\n+     *  the given node and that will be devoted to negation or parentheses.\n+     *  Since these are the only characters that flipping a condition\n+     *  according to De Morgan's rule can affect, these are the only ones\n+     *  we count.\n+     *  Not nodes are counted by the NOT node itself, whereas\n+     *  parentheses around an expression are counted by the parent node.\n+     *  @param n The node to be checked.\n+     *  @return The number of negations and parentheses in the node.\n+     */\n+    private static int estimateCostOneLevel(Node n) {\n+      int cost = 0;\n+      if (n.isNot()) {\n+        cost++;  // A negation is needed.\n+      }\n+      int parentPrecedence = NodeUtil.precedence(n.getType());\n+      for (Node child = n.getFirstChild();\n+          child != null; child = child.getNext()) {\n+        if (PeepholeMinimizeConditions.isLowerPrecedence(child, parentPrecedence)) {\n+          cost += 2;  // A pair of parenthesis is needed.\n+        }\n+      }\n+      return cost;\n+    }\n+\n+    private MeasuredNode cloneTree() {\n+      return new MeasuredNode(node.cloneTree(), length, changed);\n+    }\n+\n+    private static MeasuredNode addNode(Node parent, MeasuredNode... children) {\n+      int cost = 0;\n+      boolean changed = false;\n+      for (MeasuredNode child : children) {\n+        parent.addChildrenToBack(child.node);\n+        cost += child.length;\n+        changed = changed || child.changed;\n+      }\n+      cost += estimateCostOneLevel(parent);\n+      return new MeasuredNode(parent, cost, changed);\n+    }\n+\n+  }\n+\n+}\n--- a/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n+++ b/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n-import com.google.common.collect.ImmutableList;\n+import com.google.javascript.jscomp.MinimizedCondition.MinimizationStyle;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n-\n-import java.util.Collections;\n-import java.util.Comparator;\n \n /**\n  * A peephole optimization that minimizes conditional expressions\n    * Returns the replacement for n or the original if no replacement was\n    * necessary.\n    */\n-  private Node tryMinimizeExprResult(Node node) {\n-    Node originalCond = node.getFirstChild();\n-    Node placeholder = IR.script();\n-    node.replaceChild(originalCond, placeholder);\n+  private Node tryMinimizeExprResult(Node n) {\n     MinimizedCondition minCond = (aggressiveMinimization) ?\n-        MinimizedCondition.fromConditionNode(originalCond) :\n-          MinimizedCondition.unoptimized(originalCond);\n+      MinimizedCondition.fromConditionNode(n.getFirstChild()) :\n+        MinimizedCondition.unoptimized(n.getFirstChild());\n     MinimizedCondition.MeasuredNode mNode =\n-        minCond.getShorterRepresentation(false);\n-    if (mNode.node.isNot()) {\n+        minCond.getMinimized(MinimizationStyle.ALLOW_LEADING_NOT);\n+    Node placeholder = minCond.getPlaceholder();\n+    if (mNode.getNode().isNot()) {\n       // Remove the leading NOT in the EXPR_RESULT.\n-      node.replaceChild(placeholder, mNode.node.removeFirstChild());\n+      n.replaceChild(placeholder, mNode.getNode().removeFirstChild());\n       reportCodeChange();\n     } else {\n       replaceNode(placeholder, mNode);\n     }\n-    return node;\n+    return n;\n   }\n \n   /**\n    * necessary.\n    */\n   private Node tryMinimizeHook(Node n) {\n-    Node originalCond = n.getFirstChild();\n-    Node placeholder = IR.script();\n-    n.replaceChild(originalCond, placeholder);\n     MinimizedCondition minCond = (aggressiveMinimization) ?\n-        MinimizedCondition.fromConditionNode(originalCond) :\n-          MinimizedCondition.unoptimized(originalCond);\n+      MinimizedCondition.fromConditionNode(n.getFirstChild()) :\n+        MinimizedCondition.unoptimized(n.getFirstChild());\n     MinimizedCondition.MeasuredNode mNode =\n-        minCond.getShorterRepresentation(false);\n-    if (mNode.node.isNot()) {\n+        minCond.getMinimized(MinimizationStyle.ALLOW_LEADING_NOT);\n+    Node placeholder = minCond.getPlaceholder();\n+    if (mNode.getNode().isNot()) {\n       // Swap the HOOK\n       Node thenBranch = n.getFirstChild().getNext();\n-      n.replaceChild(placeholder, mNode.node.removeFirstChild());\n+      n.replaceChild(placeholder, mNode.getNode().removeFirstChild());\n       n.removeChild(thenBranch);\n       n.addChildToBack(thenBranch);\n       reportCodeChange();\n     Node thenBranch = originalCond.getNext();\n     Node elseBranch = thenBranch.getNext();\n \n-    Node placeholder = IR.script().srcref(originalCond);\n-    n.replaceChild(originalCond, placeholder);\n+    MinimizedCondition minCond = (aggressiveMinimization) ?\n+        MinimizedCondition.fromConditionNode(originalCond) :\n+          MinimizedCondition.unoptimized(originalCond);\n+    originalCond = null;  // originalCond was mutated and should not be used.\n+\n+    Node placeholder = minCond.getPlaceholder();\n \n     MinimizedCondition.MeasuredNode unnegatedCond;\n     MinimizedCondition.MeasuredNode shortCond;\n-    if (aggressiveMinimization) {\n-      MinimizedCondition minCond = MinimizedCondition\n-          .fromConditionNode(originalCond);\n-      // Compute two minimized representations. The first representation counts\n-      // a leading NOT node, and the second ignores a leading NOT node.\n-      // If we can fold the if statement into a HOOK or boolean operation,\n-      // then the NOT node does not matter, and we prefer the second condition.\n-      // If we cannot fold the if statement, then we prefer the first condition.\n-      unnegatedCond = minCond.getShorterRepresentation(true);\n-      shortCond = minCond.getShorterRepresentation(false);\n-    } else {\n-      unnegatedCond = new MinimizedCondition.MeasuredNode(\n-          originalCond, 0, false);\n-      shortCond = unnegatedCond;\n-    }\n-    originalCond = null;\n+    // Compute two minimized representations. The first representation counts\n+    // a leading NOT node, and the second ignores a leading NOT node.\n+    // If we can fold the if statement into a HOOK or boolean operation,\n+    // then the NOT node does not matter, and we prefer the second condition.\n+    // If we cannot fold the if statement, then we prefer the first condition.\n+    unnegatedCond = minCond.getMinimized(MinimizationStyle.PREFER_UNNEGATED);\n+    shortCond = minCond.getMinimized(MinimizationStyle.ALLOW_LEADING_NOT);\n \n     if (elseBranch == null) {\n       if (isFoldableExpressBlock(thenBranch)) {\n           return n;\n         }\n \n-        if (shortCond.node.isNot()) {\n+        if (shortCond.getNode().isNot()) {\n           // if(!x)bar(); -> x||bar();\n           Node or = IR.or(\n-              shortCond.node.removeFirstChild(),\n+              shortCond.getNode().removeFirstChild(),\n               expr.removeFirstChild()).srcref(n);\n           Node newExpr = NodeUtil.newExpr(or);\n           parent.replaceChild(n, newExpr);\n         // Preconditions.checkState(shortCond.isEquivalentTo(unnegatedCond));\n \n         // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedence(shortCond.node, AND_PRECEDENCE) &&\n+        if (isLowerPrecedence(shortCond.getNode(), AND_PRECEDENCE) &&\n             isLowerPrecedence(expr.getFirstChild(),\n                 AND_PRECEDENCE)) {\n           // One additional set of parentheses is worth the change even if\n         }\n \n         n.removeChild(placeholder);\n-        Node and = IR.and(shortCond.node, expr.removeFirstChild()).srcref(n);\n+        Node and = IR.and(shortCond.getNode(), expr.removeFirstChild()).srcref(n);\n         Node newExpr = NodeUtil.newExpr(and);\n         parent.replaceChild(n, newExpr);\n         reportCodeChange();\n             Node innerElseBranch = innerThenBranch.getNext();\n \n             if (innerElseBranch == null &&\n-                 !(isLowerPrecedence(unnegatedCond.node, AND_PRECEDENCE) &&\n+                 !(isLowerPrecedence(unnegatedCond.getNode(), AND_PRECEDENCE) &&\n                    isLowerPrecedence(innerCond, AND_PRECEDENCE))) {\n               n.detachChildren();\n               n.addChildToBack(\n                   IR.and(\n-                      unnegatedCond.node,\n+                      unnegatedCond.getNode(),\n                       innerCond.detachFromParent())\n                       .srcref(placeholder));\n               n.addChildrenToBack(innerThenBranch.detachFromParent());\n \n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n-    if (shortCond.node.isNot() && !consumesDanglingElse(elseBranch)) {\n-      n.replaceChild(placeholder, shortCond.node.removeFirstChild());\n+    if (shortCond.getNode().isNot() && !consumesDanglingElse(elseBranch)) {\n+      n.replaceChild(placeholder, shortCond.getNode().removeFirstChild());\n       n.removeChild(thenBranch);\n       n.addChildToBack(thenBranch);\n       reportCodeChange();\n       // can be converted to \"return undefined;\" or some variant, but\n       // that does not help code size.\n       Node returnNode = IR.returnNode(\n-                            IR.hook(shortCond.node, thenExpr, elseExpr)\n+                            IR.hook(shortCond.getNode(), thenExpr, elseExpr)\n                                 .srcref(n));\n       parent.replaceChild(n, returnNode);\n       reportCodeChange();\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n               !mayEffectMutableState(lhs) &&\n-              (!mayHaveSideEffects(unnegatedCond.node) ||\n+              (!mayHaveSideEffects(unnegatedCond.getNode()) ||\n                   (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n \n             n.removeChild(placeholder);\n             Node elseExpr = elseOp.getLastChild();\n             elseOp.removeChild(elseExpr);\n \n-            Node hookNode = IR.hook(shortCond.node, thenExpr, elseExpr).srcref(n);\n+            Node hookNode = IR.hook(shortCond.getNode(), thenExpr, elseExpr)\n+                .srcref(n);\n             Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                               .srcref(thenOp);\n             Node expr = NodeUtil.newExpr(assign);\n       thenOp.detachFromParent();\n       elseOp.detachFromParent();\n       Node expr = IR.exprResult(\n-          IR.hook(shortCond.node, thenOp, elseOp).srcref(n));\n+          IR.hook(shortCond.getNode(), thenOp, elseOp).srcref(n));\n       parent.replaceChild(n, expr);\n       reportCodeChange();\n       return expr;\n         Node thenExpr = name1.removeChildren();\n         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n         placeholder.detachFromParent();\n-        Node hookNode = IR.hook(shortCond.node, thenExpr, elseExpr)\n+        Node hookNode = IR.hook(shortCond.getNode(), thenExpr, elseExpr)\n                             .srcref(n);\n         var.detachFromParent();\n         name1.addChildrenToBack(hookNode);\n         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n         Node elseExpr = name2.removeChildren();\n         placeholder.detachFromParent();\n-        Node hookNode = IR.hook(shortCond.node, thenExpr, elseExpr)\n+        Node hookNode = IR.hook(shortCond.getNode(), thenExpr, elseExpr)\n                             .srcref(n);\n         var.detachFromParent();\n         name2.addChildrenToBack(hookNode);\n   /**\n    * Whether the node type has lower precedence than \"precedence\"\n    */\n-  private static boolean isLowerPrecedence(Node n, final int precedence) {\n+  static boolean isLowerPrecedence(Node n, final int precedence) {\n     return NodeUtil.precedence(n.getType()) < precedence;\n   }\n \n   private Node tryMinimizeCondition(Node n) {\n     n = performConditionSubstitutions(n);\n     if (aggressiveMinimization) {\n-      Node placeholder = IR.script();\n-      n.getParent().replaceChild(n, placeholder);\n       MinimizedCondition minCond = MinimizedCondition.fromConditionNode(n);\n-      return replaceNode(placeholder,\n-          minCond.getShorterRepresentation(true));\n+      return replaceNode(\n+          minCond.getPlaceholder(),\n+          minCond.getMinimized(MinimizationStyle.PREFER_UNNEGATED));\n     } else {\n       return n;\n     }\n \n   private Node replaceNode(Node lhs, MinimizedCondition.MeasuredNode rhs) {\n     Node parent = lhs.getParent();\n-    parent.replaceChild(lhs, rhs.node);\n-    if (rhs.changed) {\n+    parent.replaceChild(lhs, rhs.getNode());\n+    if (rhs.isChanged()) {\n       reportCodeChange();\n     }\n-    return rhs.node;\n-  }\n-\n-  /** A class that represents a minimized conditional expression.\n-   *  Depending on the context, either the original conditional, or the\n-   *  negation of the original conditional may be needed, so this class\n-   *  provides ways to access minimized versions of both of those ASTs.\n-   */\n-  static class MinimizedCondition {\n-    static class MeasuredNode {\n-      Node node;\n-      int length;\n-      boolean changed;\n-\n-      MeasuredNode(Node n, int len, boolean ch) {\n-        node = n;\n-        length = len;\n-        changed = ch;\n-      }\n-\n-      private MeasuredNode negate() {\n-        this.change();\n-        int complementOperator;\n-        switch (node.getType()) {\n-          default:\n-            return this.addNot();\n-          // Otherwise a binary operator with a complement.\n-          case Token.EQ:\n-            complementOperator = Token.NE;\n-            break;\n-          case Token.NE:\n-            complementOperator = Token.EQ;\n-            break;\n-          case Token.SHEQ:\n-            complementOperator = Token.SHNE;\n-            break;\n-          case Token.SHNE:\n-            complementOperator = Token.SHEQ;\n-            break;\n-        }\n-        // Clone entire tree and just change operator.\n-        node.setType(complementOperator);\n-        return this;\n-      }\n-\n-      private MeasuredNode change() {\n-        this.changed = true;\n-        return this;\n-      }\n-\n-      private MeasuredNode addNot() {\n-        node = new Node(Token.NOT, node).srcref(node);\n-        length += estimateCostOneLevel(node);\n-        return this;\n-      }\n-\n-      /** Estimate the number of characters in the textual representation of\n-       *  the given node and that will be devoted to negation or parentheses.\n-       *  Since these are the only characters that flipping a condition\n-       *  according to De Morgan's rule can affect, these are the only ones\n-       *  we count.\n-       *  Not nodes are counted by the NOT node itself, whereas\n-       *  parentheses around an expression are counted by the parent node.\n-       *  @param n The node to be checked.\n-       *  @return The number of negations and parentheses in the node.\n-       */\n-      private static int estimateCostOneLevel(Node n) {\n-        int cost = 0;\n-        if (n.isNot()) {\n-          cost++;  // A negation is needed.\n-        }\n-        int parentPrecedence = NodeUtil.precedence(n.getType());\n-        for (Node child = n.getFirstChild();\n-            child != null; child = child.getNext()) {\n-          if (isLowerPrecedence(child, parentPrecedence)) {\n-            cost += 2;  // A pair of parenthesis is needed.\n-          }\n-        }\n-        return cost;\n-      }\n-\n-      MeasuredNode cloneTree() {\n-        return new MeasuredNode(node.cloneTree(), length, changed);\n-      }\n-\n-      static MeasuredNode addNode(Node parent, MeasuredNode... children) {\n-        int cost = 0;\n-        boolean changed = false;\n-        for (MeasuredNode child : children) {\n-          parent.addChildrenToBack(child.node);\n-          cost += child.length;\n-          changed = changed || child.changed;\n-        }\n-        cost += estimateCostOneLevel(parent);\n-        return new MeasuredNode(parent, cost, changed);\n-      }\n-\n-    }\n-    private final MeasuredNode positive;\n-    private final MeasuredNode negative;\n-\n-    private MinimizedCondition(MeasuredNode p, MeasuredNode n) {\n-      Preconditions.checkArgument(p.node.getParent() == null);\n-      Preconditions.checkArgument(n.node.getParent() == null);\n-      positive = p;\n-      negative = n.change();\n-    }\n-\n-    static MinimizedCondition fromConditionNode(Node n) {\n-      switch (n.getType()) {\n-        case Token.NOT:\n-        case Token.AND:\n-        case Token.OR:\n-        case Token.HOOK:\n-        case Token.COMMA:\n-          return computeMinimizedCondition(n);\n-        default:\n-          return unoptimized(n);\n-      }\n-    }\n-\n-    /** Minimize the condition at the given node.\n-     *\n-     *  @param n The conditional expression tree to minimize.\n-     *   This must be removed from the tree before being passed in connected.\n-     *  @return A MinimizedCondition object representing that tree.\n-     */\n-    private static MinimizedCondition computeMinimizedCondition(Node n) {\n-      Preconditions.checkArgument(n.getParent() == null);\n-      switch (n.getType()) {\n-        case Token.NOT: {\n-          MinimizedCondition subtree =\n-              computeMinimizedCondition(n.getFirstChild().detachFromParent());\n-          ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n-              subtree.positive.cloneTree().addNot(),\n-              subtree.negative.cloneTree());\n-          ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n-              subtree.negative.negate(),\n-              subtree.positive);\n-          return new MinimizedCondition(\n-              Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n-              Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n-        }\n-        case Token.AND:\n-        case Token.OR: {\n-          int opType = n.getType();\n-          int complementType = opType == Token.AND ? Token.OR : Token.AND;\n-          MinimizedCondition leftSubtree =\n-              computeMinimizedCondition(n.getFirstChild().detachFromParent());\n-          MinimizedCondition rightSubtree =\n-              computeMinimizedCondition(n.getLastChild().detachFromParent());\n-          ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n-              MeasuredNode.addNode(new Node(opType).srcref(n),\n-                  leftSubtree.positive.cloneTree(),\n-                  rightSubtree.positive.cloneTree()),\n-              MeasuredNode.addNode(new Node(complementType).srcref(n),\n-                  leftSubtree.negative.cloneTree(),\n-                  rightSubtree.negative.cloneTree()).negate());\n-          ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n-              MeasuredNode.addNode(new Node(opType).srcref(n),\n-                  leftSubtree.positive,\n-                  rightSubtree.positive).negate(),\n-              MeasuredNode.addNode(new Node(complementType).srcref(n),\n-                  leftSubtree.negative,\n-                  rightSubtree.negative));\n-          return new MinimizedCondition(\n-              Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n-              Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n-        }\n-        case Token.HOOK: {\n-          Node cond = n.getFirstChild();\n-          Node thenNode = cond.getNext();\n-          Node elseNode = thenNode.getNext();\n-          MinimizedCondition thenSubtree =\n-              computeMinimizedCondition(thenNode.detachFromParent());\n-          MinimizedCondition elseSubtree =\n-              computeMinimizedCondition(elseNode.detachFromParent());\n-          MeasuredNode posTree = MeasuredNode.addNode(\n-              new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n-              thenSubtree.positive,\n-              elseSubtree.positive);\n-          MeasuredNode negTree = MeasuredNode.addNode(\n-              new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n-              thenSubtree.negative,\n-              elseSubtree.negative);\n-          return new MinimizedCondition(posTree, negTree);\n-        }\n-        case Token.COMMA: {\n-          Node lhs = n.getFirstChild();\n-          MinimizedCondition rhsSubtree =\n-              computeMinimizedCondition(lhs.getNext().detachFromParent());\n-          MeasuredNode posTree = MeasuredNode.addNode(\n-              new Node(Token.COMMA, lhs.cloneTree()).srcref(n),\n-              rhsSubtree.positive);\n-          MeasuredNode negTree = MeasuredNode.addNode(\n-              new Node(Token.COMMA, lhs.cloneTree()).srcref(n),\n-              rhsSubtree.negative);\n-          return new MinimizedCondition(posTree, negTree);\n-        }\n-        default: {\n-          MeasuredNode pos = new MeasuredNode(n, 0, false);\n-          MeasuredNode neg = pos.cloneTree().negate();\n-          return new MinimizedCondition(pos, neg);\n-        }\n-      }\n-    }\n-\n-    /** Return a MeasuredNode of the given condition node, without minimizing\n-     * the result.\n-    *\n-    *  @param n The conditional expression tree to minimize.\n-    *   This must be removed from the tree before being passed in connected.\n-    *  @return A MinimizedCondition object representing that tree.\n-    */\n-    static MinimizedCondition unoptimized(Node n) {\n-      Preconditions.checkArgument(n.getParent() == null);\n-      MeasuredNode pos = new MeasuredNode(n, 0, false);\n-      // In the unoptimized case, we want to always return the positive side,\n-      // so we set the negative side to a SCRIPT node (never valid inside an\n-      // expression) with an unreasonably high length so that it's never chosen.\n-      MeasuredNode neg = new MeasuredNode(IR.script(), Integer.MAX_VALUE, true);\n-      return new MinimizedCondition(pos, neg);\n-    }\n-\n-    /** Return the shorter representation of the original condition node.\n-     *\n-     * @param countLeadingNot When this is false, do not count a leading\n-     *  NOT in doing the minimization.\n-     *  i.e. Prefer the right side in cases such as:\n-     *    !x || !y || z  ==>  !(x && y && !z)\n-     *  This is useful in contexts such as IFs or HOOKs where subsequent\n-     *  optimizations can efficiently deal with leading NOTs.\n-     *\n-     *  @return The minimized condition MeasuredNode, with equivalent value\n-     *    to that passed to #fromConditionNode().\n-     */\n-    MeasuredNode getShorterRepresentation(boolean countLeadingNot) {\n-     if (countLeadingNot || positive.node.isNot()\n-         || positive.length <= negative.length) {\n-       return positive;\n-     } else {\n-       return negative.addNot();\n-     }\n-    }\n-\n-    private static final Comparator<MeasuredNode> AST_LENGTH_COMPARATOR =\n-        new Comparator<MeasuredNode>() {\n-      @Override\n-      public int compare(MeasuredNode o1, MeasuredNode o2) {\n-        return o1.length - o2.length;\n-      }\n-    };\n-\n+    return rhs.getNode();\n   }\n \n   /**\n \n     return n;\n   }\n-\n }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/MinimizedConditionTest.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.MinimizedCondition.MinimizationStyle;\n+import com.google.javascript.rhino.Node;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.List;\n+\n+/**\n+ * Tests for {@link MinimizedCondition} in isolation.\n+ * Tests for the containing PeepholeMinimizeConditions pass are in\n+ * PeepholeMinimizeConditionsTest.\n+ *\n+ * @author blickly@google.com (Ben Lickly)\n+ */\n+public class MinimizedConditionTest extends TestCase {\n+\n+  private static Node parseExpr(String code) {\n+    Compiler compiler = new Compiler();\n+    List<SourceFile> input =\n+        Lists.newArrayList(SourceFile.fromCode(\"code\", code));\n+    List<SourceFile> externs = Lists.newArrayList();\n+    compiler.init(externs, input, new CompilerOptions());\n+    Node root = compiler.parseInputs();\n+    assertTrue(\"Unexpected parse error(s): \" +\n+        Joiner.on(\"\\n\").join(compiler.getErrors()), root != null);\n+    Node externsRoot = root.getFirstChild();\n+    Node mainRoot = externsRoot.getNext();\n+    Node script = mainRoot.getFirstChild();\n+    Node exprResult = script.getFirstChild();\n+    return exprResult.getFirstChild();\n+  }\n+\n+  private static void minCond(String input, String positive, String negative) {\n+    Node inputNode = parseExpr(input);\n+    MinimizedCondition result = MinimizedCondition.fromConditionNode(inputNode);\n+    Node positiveNode = parseExpr(positive);\n+    Node negativeNode = parseExpr(negative);\n+    // With counting the leading NOT node:\n+    Node positiveResult =\n+        result.getMinimized(MinimizationStyle.PREFER_UNNEGATED).getNode();\n+    // Without counting the leading NOT node:\n+    Node negativeResult =\n+        result.getMinimized(MinimizationStyle.ALLOW_LEADING_NOT).getNode();\n+    if (!positiveResult.isEquivalentTo(positiveNode)) {\n+      fail(\"Not equal:\\n\" + positiveResult.toStringTree()\n+          + \"and:\\n\" + positiveNode.toStringTree());\n+    }\n+    if (!negativeResult.isEquivalentTo(negativeNode)) {\n+      fail(\"Not equal:\\n\" + negativeResult.toStringTree()\n+          + \"and:\\n\" + negativeNode.toStringTree());\n+    }\n+  }\n+\n+  public void testTryMinimizeCondSimple() {\n+    minCond(\"x\", \"x\", \"x\");\n+    minCond(\"!x\", \"!x\", \"!x\");\n+    minCond(\"!!x\", \"x\", \"x\");\n+    minCond(\"!(x && y)\", \"!x || !y\", \"!(x && y)\");\n+  }\n+\n+  public void testMinimizeDemorgan() {\n+    minCond(\"!(x&&y)\", \"!x||!y\", \"!(x&&y)\");\n+    minCond(\"!(x||y)\", \"!x&&!y\", \"!(x||y)\");\n+    minCond(\"!x||!y\", \"!x||!y\", \"!(x&&y)\");\n+    minCond(\"!x&&!y\", \"!x&&!y\", \"!(x||y)\");\n+    minCond(\"!(x && y && z)\", \"!(x && y && z)\", \"!(x && y && z)\");\n+  }\n+\n+  public void testMinimizeDemorgan2() {\n+    minCond(\"(!a||!b)&&c\", \"(!a||!b)&&c\", \"!(a&&b||!c)\");\n+  }\n+\n+  public void testMinimizeDemorgan3() {\n+    minCond(\"(!a||!b)&&(c||d)\", \"!(a&&b||!c&&!d)\", \"!(a&&b||!c&&!d)\");\n+  }\n+\n+  public void testMinimizeDemorgan4() {\n+    minCond(\n+        \"x && (y===2 || !f()) && (y===3 || !h())\",\n+        \"x && !((y!==2 && f()) || (y!==3 && h()))\",\n+        \"!(!x || (y!==2 && f()) || (y!==3 && h()))\");\n+  }\n+\n+  public void testMinimizeDemorgan5() {\n+    minCond(\n+        \"0===c && (2===a || 1===a)\",\n+        \"0===c && (2===a || 1===a)\",\n+        \"!(0!==c || 2!==a && 1!==a)\");\n+  }\n+\n+  public void testMinimizeDemorgan6() {\n+    minCond(\"!((x,y)&&z)\", \"(x,!y)||!z\", \"!((x,y)&&z)\");\n+  }\n+\n+  public void testMinimizeHook() {\n+    minCond(\"!(x ? y : z)\", \"(x ? !y : !z)\",  \"!(x ? y : z)\");\n+  }\n+\n+  public void testMinimizeComma() {\n+    minCond(\"!(inc(), test())\", \"inc(), !test()\", \"!(inc(), test())\");\n+  }\n+\n+}\n--- a/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.jscomp.PeepholeMinimizeConditions.MinimizedCondition;\n-import com.google.javascript.rhino.Node;\n-\n /**\n  * Tests for {@link PeepholeMinimizeConditions} in isolation.\n  * Tests for the interaction of multiple peephole passes are in\n     test(js, expected);\n   }\n \n-  void assertResultString(String js, String expected) {\n+  private static void assertResultString(String js, String expected) {\n     assertResultString(js, expected, false);\n   }\n \n   // TODO(user): This is same as fold() except it uses string comparison. Any\n   // test that needs tell us where a folding is constructing an invalid AST.\n-  void assertResultString(String js, String expected, boolean normalize) {\n+  private static void assertResultString(String js, String expected,\n+      boolean normalize) {\n     PeepholeMinimizeConditionsTest scTest\n         = new PeepholeMinimizeConditionsTest(false);\n \n     fold(\"if ((!a || !b) && (d || e)) f()\", \"(a&&b || !d&&!e) || f()\");\n   }\n \n-  public Node parseExpr(String input) {\n-    Node block = parseExpectedJs(input);\n-    Node script = block.getFirstChild();\n-    Node exprResult = script.getFirstChild();\n-    return exprResult.getFirstChild();\n-  }\n-\n-  public void minimizeCond(String input, String positive, String negative) {\n-    Node inputNode = parseExpr(input);\n-    MinimizedCondition result = PeepholeMinimizeConditions\n-        .MinimizedCondition.fromConditionNode(inputNode.detachFromParent());\n-    Node positiveNode = parseExpr(positive);\n-    Node negativeNode = parseExpr(negative);\n-    // With counting the leading NOT node:\n-    Node positiveResult = result.getShorterRepresentation(true).node;\n-    // Without counting the leading NOT node:\n-    Node negativeResult = result.getShorterRepresentation(false).node;\n-    if (!positiveResult.isEquivalentTo(positiveNode)) {\n-      fail(\"Not equal:\\n\" + positiveResult.toStringTree()\n-          + \"and:\\n\" + positiveNode.toStringTree());\n-    }\n-    if (!negativeResult.isEquivalentTo(negativeNode)) {\n-      fail(\"Not equal:\\n\" + negativeResult.toStringTree()\n-          + \"and:\\n\" + negativeNode.toStringTree());\n-    }\n-  }\n-\n-  public void testTryMinimizeCondition1() {\n-    minimizeCond(\"x\", \"x\", \"x\");\n-  }\n-\n-  public void testTryMinimizeCondition2() {\n-    minimizeCond(\"!x\", \"!x\", \"!x\");\n-  }\n-\n-  public void testTryMinimizeCondition3() {\n-    minimizeCond(\"!(x || y)\", \"!x && !y\", \"!(x || y)\");\n-  }\n-\n-  public void testTryMinimizeCondition4() {\n-    minimizeCond(\"!(x && y)\", \"!x || !y\", \"!(x && y)\");\n-  }\n-\n-  public void testTryMinimizeCondition5() {\n-    minimizeCond(\"!(x && y && z)\", \"!(x && y && z)\", \"!(x && y && z)\");\n-  }\n-\n-  public void testMinimizeCondDemorgan() {\n-    minimizeCond(\"x && (y===2 || !f()) && (y===3 || !h())\",\n-        \"x && !((y!==2 && f()) || (y!==3 && h()))\",\n-        \"!(!x || (y!==2 && f()) || (y!==3 && h()))\");\n-  }\n-\n   public void testMinimizeForCondition() {\n     // This test uses constant folding logic, so is only here for completeness.\n     // These could be simplified to \"for(;;) ...\"", "timestamp": 1371775368, "metainfo": ""}