{"sha": "0dcb6c9c4145839c667faecaedb9411a8a5b8ce0", "log": "Fix a bug in @const checking where it wouldn't detect @const when a class doesn't assign a value that it declared, but a subclass does  R=zhuyi DELTA=78  (62 added, 10 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2231   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n-import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n-import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n-import com.google.common.collect.Multimap;\n-import com.google.common.collect.HashMultimap;\n \n /**\n  * A compiler pass that checks that the programmer has obeyed all the access\n       ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n     String propertyName = getprop.getLastChild().getString();\n \n+    boolean isConstant = isPropertyDeclaredConstant(objectType, propertyName);\n+\n     // Check whether constant properties are reassigned\n-    if (objectType != null) {\n+    if (isConstant) {\n       ObjectType oType = objectType;\n       while (oType != null) {\n         if (oType.hasReferenceName()) {\n         oType = oType.getImplicitPrototype();\n       }\n \n-      JSDocInfo info = objectType.getOwnPropertyJSDocInfo(propertyName);\n-      if (info != null && info.isConstant()\n-          && objectType.hasReferenceName()) {\n-        initializedConstantProperties.put(objectType.getReferenceName(),\n-            propertyName);\n-      }\n+      Preconditions.checkState(objectType.hasReferenceName());\n+      initializedConstantProperties.put(objectType.getReferenceName(),\n+          propertyName);\n \n       // Add the prototype when we're looking at an instance object\n       if (objectType.isInstanceType()) {\n         ObjectType prototype = objectType.getImplicitPrototype();\n         if (prototype != null) {\n-          JSDocInfo prototypeInfo\n-            = prototype.getOwnPropertyJSDocInfo(propertyName);\n-          if (prototypeInfo != null && prototypeInfo.isConstant()\n+          if (prototype.hasProperty(propertyName)\n               && prototype.hasReferenceName()) {\n             initializedConstantProperties.put(prototype.getReferenceName(),\n                 propertyName);\n   }\n \n   /**\n+   * Returns if a property is declared constant.\n+   */\n+  private static boolean isPropertyDeclaredConstant(\n+      ObjectType objectType, String prop) {\n+    for (;\n+         // Only objects with reference names can have constant properties.\n+         objectType != null && objectType.hasReferenceName();\n+\n+         objectType = objectType.getImplicitPrototype()) {\n+      JSDocInfo docInfo = objectType.getOwnPropertyJSDocInfo(prop);\n+      if (docInfo != null && docInfo.isConstant()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n    * Returns the deprecation reason for the property if it is marked\n    * as being deprecated. Returns empty string if the property is deprecated\n    * but no reason was given. Returns null if the property is not deprecated.\n--- a/test/com/google/javascript/jscomp/CheckAccessControlsTest.java\n+++ b/test/com/google/javascript/jscomp/CheckAccessControlsTest.java\n         \"/** @const */ Foo.prototype.prop;\");\n   }\n \n+  public void testConstantProperty11() {\n+    test(\"/** @constructor */ function Foo() {}\" +\n+        \"/** @const */ Foo.prototype.bar;\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function SubFoo() { this.bar = 5; this.bar = 6; }\",\n+        null , CONST_PROPERTY_REASSIGNED_VALUE);\n+  }\n+\n+  public void testConstantProperty12() {\n+    testSame(\"/** @constructor */ function Foo() {}\" +\n+        \"/** @const */ Foo.prototype.bar;\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function SubFoo() { this.bar = 5; }\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function SubFoo2() { this.bar = 5; }\");\n+  }\n+\n+  public void testConstantProperty13() {\n+    test(\"/** @constructor */ function Foo() {}\" +\n+        \"/** @const */ Foo.prototype.bar;\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */ function SubFoo() { this.bar = 5; }\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {SubFoo}\\n\" +\n+        \" */ function SubSubFoo() { this.bar = 5; }\",\n+        null , CONST_PROPERTY_REASSIGNED_VALUE);\n+  }\n+\n   public void testSuppressConstantProperty() {\n     testSame(\"/** @constructor */ function A() {\" +\n         \"/** @const */ this.bar = 3;}\" +", "timestamp": 1307660566, "metainfo": ""}