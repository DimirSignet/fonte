{"sha": "e3846e53c66f4d63c7f4789832db35207727191e", "log": "Disambiguate private properties by file to enable additional optimizations. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44423021", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * Where to save debug report for compute function side effects.\n    */\n   String debugFunctionSideEffectsPath;\n+\n+  /**\n+   * Rename private properties to disambiguate between unrelated fields based on\n+   * the coding convention.\n+   */\n+  boolean disambiguatePrivateProperties;\n \n   /**\n    * Rename properties to disambiguate between unrelated fields based on\n     this.debugFunctionSideEffectsPath = debugFunctionSideEffectsPath;\n   }\n \n+  /**\n+   * @return Whether disambiguate private properties is enabled.\n+   */\n+  public boolean isDisambiguatePrivateProperties() {\n+    return disambiguatePrivateProperties;\n+  }\n+\n+  /**\n+   * @param value Whether to enable private property disambiguation based on\n+   * the coding convention.\n+   */\n+  public void setDisambiguatePrivateProperties(boolean value) {\n+    this.disambiguatePrivateProperties = value;\n+  }\n+\n   public void setDisambiguateProperties(boolean disambiguateProperties) {\n     this.disambiguateProperties = disambiguateProperties;\n   }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       passes.add(closureCodeRemoval);\n     }\n \n+    // Property disambiguation should only run once and needs to be done\n+    // soon after type checking, both so that it can make use of type\n+    // information and so that other passes can take advantage of the renamed\n+    // properties.\n+    if (options.disambiguatePrivateProperties) {\n+      passes.add(disambiguatePrivateProperties);\n+    }\n+\n     // Collapsing properties can undo constant inlining, so we do this before\n     // the main optimization loop.\n     if (options.collapseProperties) {\n     }\n   };\n \n-  /** Devirtualize property names based on type information. */\n+  /** Disambiguate property names based on the coding convention. */\n+  final PassFactory disambiguatePrivateProperties =\n+      new PassFactory(\"disambiguatePrivateProperties\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n+      return new DisambiguatePrivateProperties(compiler);\n+    }\n+  };\n+\n+  /** Disambiguate property names based on type information. */\n   final PassFactory disambiguateProperties =\n       new PassFactory(\"disambiguateProperties\", true) {\n     @Override\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/DisambiguatePrivateProperties.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Disambiguate properties by file, when they are private by naming convention.\n+ */\n+class DisambiguatePrivateProperties\n+   implements NodeTraversal.Callback, CompilerPass {\n+\n+  private final AbstractCompiler compiler;\n+  private String fileid;\n+  private int id = 0;\n+\n+  DisambiguatePrivateProperties(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  @Override\n+  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+    if (n.isScript()) {\n+      this.fileid = \"$\" + this.id++;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    switch (n.getType()) {\n+      case Token.GETPROP:\n+        maybeRename(n.getLastChild());\n+        break;\n+      case Token.STRING_KEY:\n+      case Token.GETTER_DEF:\n+      case Token.SETTER_DEF:\n+        maybeRename(n);\n+        break;\n+    }\n+  }\n+\n+  private void maybeRename(Node n) {\n+    CodingConvention convention = compiler.getCodingConvention();\n+    String prop = n.getString();\n+    if (!n.getBooleanProp(Node.QUOTED_PROP) && convention.isPrivate(prop)) {\n+      n.setString(prop + fileid);\n+      compiler.reportCodeChange();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/DisambiguatePrivatePropertiesTest.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit test for the Compiler DisambiguatPrivateeProperties pass.\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class DisambiguatePrivatePropertiesTest extends CompilerTestCase {\n+\n+  private boolean useGoogleCodingConvention = true;\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new DisambiguatePrivateProperties(compiler);\n+  }\n+\n+  @Override\n+  protected CodingConvention getCodingConvention() {\n+    if (useGoogleCodingConvention) {\n+      return new GoogleCodingConvention();\n+    } else {\n+      return new ClosureCodingConvention();\n+    }\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    useGoogleCodingConvention = true;\n+  }\n+\n+  public void testNoRenaming1() {\n+    useGoogleCodingConvention = true;\n+\n+    // Not variables\n+    testSame(\"var x_\");\n+\n+    // Not standard props\n+    testSame(\"x.prop\");\n+\n+    // Not annotated props (we don't use type information)\n+    testSame(\"var x = {};\\n/** @private */ x.prop;\");\n+\n+\n+    // Not quoted props\n+    testSame(\"({})['prop_'];\");\n+    testSame(\"({'prop_': 1});\");\n+    testSame(\"({get 'prop_'(){ return 1} });\");\n+    testSame(\"({set 'prop_'(a){this.a = 1} });\");\n+\n+    useGoogleCodingConvention = false;\n+\n+    // Not when the coding convention doesn't understand it.\n+    testSame(\"({}).prop_;\");\n+    testSame(\"({prop_: 1});\");\n+    testSame(\"({get prop_(){ return 1} });\");\n+    testSame(\"({set prop_(a){this.a = 1} });\");\n+  }\n+\n+  public void testRenaming1() {\n+    useGoogleCodingConvention = true;\n+\n+    test(\n+        \"({}).prop_;\",\n+        \"({}).prop_$0;\");\n+\n+    test(\n+        \"({prop_: 1});\",\n+        \"({prop_$0: 1});\");\n+\n+    test(\n+        \"({get prop_(){ return 1} });\",\n+        \"({get prop_$0(){ return 1} });\");\n+\n+    test(\n+        \"({set prop_(a){this.a = 1} });\",\n+        \"({set prop_$0(a){this.a = 1} });\");\n+\n+  }\n+}", "timestamp": 1364340501, "metainfo": ""}