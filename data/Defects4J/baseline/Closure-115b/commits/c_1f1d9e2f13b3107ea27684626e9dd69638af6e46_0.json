{"sha": "1f1d9e2f13b3107ea27684626e9dd69638af6e46", "log": "Fill references to 'this' in the symbol table.  R=acleung DELTA=190  (136 added, 15 deleted, 39 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3212   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   }\n \n   public SymbolTable buildKnownSymbolTable() {\n-    SymbolTable symbolTable = new SymbolTable();\n+    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());\n \n     MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();\n     if (typedScopeCreator != null) {\n     }\n \n     symbolTable.fillNamespaceReferences();\n+    symbolTable.fillThisReferences(this, externsRoot, jsRoot);\n     symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n \n     return symbolTable;\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.SimpleReference;\n import com.google.javascript.rhino.jstype.SimpleSlot;\n  */\n public final class SymbolTable\n     implements StaticSymbolTable<SymbolTable.Symbol, SymbolTable.Reference> {\n+  /**\n+   * The name we use for the JavaScript built-in Global object.  It's\n+   * anonymous in JavaScript, so we have to give it an invalid identifier\n+   * to avoid conflicts with user-defined property names.\n+   */\n+  public static final String GLOBAL_THIS = \"*global*\";\n \n   /**\n    * All symbols in the program, uniquely identified by the node where\n \n   private SymbolScope globalScope = null;\n \n+  private final JSTypeRegistry registry;\n+\n   /**\n    * Clients should get a symbol table by asking the compiler at the end\n    * of a compilation job.\n    */\n-  SymbolTable() {}\n+  SymbolTable(JSTypeRegistry registry) {\n+    this.registry = registry;\n+  }\n \n   @Override\n   public Iterable<Reference> getReferences(Symbol symbol) {\n     if (scope.isPropertyScope()) {\n       JSType type = scope.getTypeOfThis();\n       if (type != null) {\n-        if (type.isNominalConstructor()) {\n+        if (type.isGlobalThisType()) {\n+          return globalScope.getSlot(GLOBAL_THIS);\n+        } else if (type.isNominalConstructor()) {\n           return getSymbolDeclaredBy(type.toMaybeFunctionType());\n         } else if (type.isFunctionPrototypeType()) {\n           return getSymbolForInstancesOf(\n   }\n \n   /**\n+   * Fill in references to \"this\" variables.\n+   */\n+  void fillThisReferences(\n+      AbstractCompiler compiler, Node externs, Node root) {\n+    (new ThisRefCollector(compiler)).process(externs, root);\n+  }\n+\n+  /**\n    * Given a scope from another symbol table, returns the {@code SymbolScope}\n    * rooted at the same node. Creates one if it doesn't exist yet.\n    */\n     public boolean isPropertyScope() {\n       return getRootNode() == null;\n     }\n+\n+    public boolean isLexicalScope() {\n+      return getRootNode() != null;\n+    }\n   }\n \n   private class PropertyRefCollector\n           compiler,\n           Lists.newArrayList(externs, root),\n           this);\n+    }\n+\n+    private void maybeDefineReference(Node n, Symbol ownerSymbol) {\n+      String propName = n.getLastChild().getString();\n+\n+      // getPropertyScope() will be null in some rare cases where there\n+      // are no extern declarations for built-in types (like Function).\n+      if (ownerSymbol != null && ownerSymbol.getPropertyScope() != null) {\n+        Symbol prop = ownerSymbol.getPropertyScope().getSlot(propName);\n+        if (prop != null) {\n+          prop.defineReferenceAt(n);\n+        }\n+      }\n     }\n \n     @Override\n           return;\n         }\n \n-        String propName = n.getLastChild().getString();\n-        if (owner.isNominalConstructor()) {\n-          Symbol sym = getSymbolDeclaredBy(owner.toMaybeFunctionType());\n-          if (sym == null || sym.getPropertyScope() == null) {\n-            // This will happen in some rare cases where there are no\n-            // extern declarations for built-in types (like Function).\n-            return;\n+        if (owner.isGlobalThisType()) {\n+          Symbol sym = globalScope.getSlot(n.getLastChild().getString());\n+          if (sym != null) {\n+            sym.defineReferenceAt(n);\n           }\n-\n-          Symbol prop = sym.getPropertyScope().getSlot(propName);\n-          if (prop != null) {\n-            prop.defineReferenceAt(n);\n-          }\n+        } else if (owner.isNominalConstructor()) {\n+          maybeDefineReference(\n+              n, getSymbolDeclaredBy(owner.toMaybeFunctionType()));\n         } else {\n           for (Symbol ctor : getAllSymbolsForType(owner)) {\n-            Symbol sym = getSymbolForInstancesOf(ctor);\n-            if (sym != null) {\n-              Symbol prop = sym.getPropertyScope().getSlot(propName);\n-              if (prop != null) {\n-                prop.defineReferenceAt(n);\n-              }\n-            }\n+            maybeDefineReference(n, getSymbolForInstancesOf(ctor));\n           }\n         }\n       }\n     }\n   }\n+\n+  private class ThisRefCollector\n+      extends NodeTraversal.AbstractPostOrderCallback\n+      implements CompilerPass {\n+    private final AbstractCompiler compiler;\n+\n+    ThisRefCollector(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node root) {\n+      NodeTraversal.traverseRoots(\n+          compiler,\n+          Lists.newArrayList(externs, root),\n+          this);\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() != Token.THIS) {\n+        return;\n+      }\n+\n+      JSType type = n.getJSType();\n+      if (type == null) {\n+        return;\n+      }\n+\n+      // declare the global this at the first place it's used.\n+      if (type.isGlobalThisType() &&\n+          globalScope.getSlot(GLOBAL_THIS) == null) {\n+        declareSymbol(\n+            GLOBAL_THIS,\n+            registry.getNativeType(JSTypeNative.GLOBAL_THIS),\n+            false /* declared */,\n+            globalScope,\n+            n);\n+      }\n+\n+      Symbol s = getOnlySymbolForType(type);\n+      if (s != null) {\n+        s.defineReferenceAt(n);\n+      }\n+    }\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n    */\n   public UnionType toMaybeUnionType() {\n     return null;\n+  }\n+\n+  /** Returns true if this is a global this type. */\n+  public final boolean isGlobalThisType() {\n+    return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS);\n   }\n \n   /** Returns true if toMaybeFunctionType returns a non-null FunctionType. */\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(1, getVars(table).size());\n   }\n \n+  public void testGlobalThisReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"var x = this; function f() { return this + this + this; }\");\n+\n+    Symbol global = getGlobalVar(table, \"*global*\");\n+    assertNotNull(global);\n+\n+    List<Reference> refs = Lists.newArrayList(table.getReferences(global));\n+    assertEquals(1, refs.size());\n+  }\n+\n+  public void testGlobalThisPropertyReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ function Foo() {} this.Foo;\");\n+\n+    Symbol foo = getGlobalVar(table, \"Foo\");\n+    assertNotNull(foo);\n+\n+    List<Reference> refs = Lists.newArrayList(table.getReferences(foo));\n+    assertEquals(2, refs.size());\n+  }\n+\n   public void testGlobalVarReferences() throws Exception {\n     SymbolTable table = createSymbolTable(\n         \"/** @type {number} */ var x = 5; x = 6;\");\n     assertEquals(x.getDeclaration(), refs.get(0));\n     assertEquals(Token.LP, refs.get(0).getNode().getParent().getType());\n     assertEquals(Token.RETURN, refs.get(1).getNode().getParent().getType());\n+  }\n+\n+  public void testLocalThisReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ function F() { this.foo = 3; this.bar = 5; }\");\n+\n+    Symbol f = getGlobalVar(table, \"F\");\n+    assertNotNull(f);\n+\n+    List<Reference> refs = Lists.newArrayList(table.getReferences(f));\n+\n+    // 1 declaration and 2 local refs\n+    assertEquals(3, refs.size());\n   }\n \n   public void testNamespacedReferences() throws Exception {\n     List<Symbol> result = Lists.newArrayList();\n     for (Symbol symbol : table.getAllSymbols()) {\n       if (symbol.getDeclaration() != null &&\n-          !symbol.getDeclaration().getSourceFile().isExtern()) {\n+          !symbol.getDeclaration().getNode().isFromExterns()) {\n         result.add(symbol);\n       }\n     }", "timestamp": 1315423872, "metainfo": ""}