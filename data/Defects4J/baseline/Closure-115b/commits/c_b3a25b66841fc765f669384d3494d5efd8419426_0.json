{"sha": "b3a25b66841fc765f669384d3494d5efd8419426", "log": "Renaming @angularInject to @ngInject per request from AngularJS devs.  R=johnlenz,nicksantos DELTA=65 (0 added, 0 deleted, 65 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6188   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AngularPass.java\n+++ b/src/com/google/javascript/jscomp/AngularPass.java\n /**\n  * Compiler pass for AngularJS-specific needs. Generates {@code $inject} \\\n  * properties for functions (class constructors, wrappers, etc) annotated with\n- * @angularInject.\n+ * @ngInject.\n  *\n  * <p>For example, the following code:</p>\n  * <pre>{@code\n  *\n- * /** @angularInject * /\n+ * /** @ngInject * /\n  * function Controller(dependency1, dependency2) {\n  *   // do something\n  * }\n  * like:\n  * <pre>{@code\n  *\n- * /** @angularInject * /\n+ * /** @ngInject * /\n  * var filter = function(a, b) {};\n  *\n  * var ns = {};\n- * /** @angularInject * /\n+ * /** @ngInject * /\n  * ns.method = function(a,b,c) {};\n  *\n- * /** @angularInject * /\n+ * /** @ngInject * /\n  * var shorthand = ns.method2 = function(a,b,c,) {}\n  *\n  * }</pre>\n class AngularPass extends AbstractPostOrderCallback implements CompilerPass {\n   final AbstractCompiler compiler;\n \n-  /** Nodes annotated with @angularInject */\n+  /** Nodes annotated with @ngInject */\n   private List<NodeContext> injectables = new ArrayList<NodeContext>();\n \n   public AngularPass(AbstractCompiler compiler) {\n \n   static final DiagnosticType INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR =\n       DiagnosticType.error(\"JSC_INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR\",\n-          \"@angularInject only applies to functions defined in blocks or \" +\n+          \"@ngInject only applies to functions defined in blocks or \" +\n           \"global scope.\");\n \n   static final DiagnosticType INJECT_NON_FUNCTION_ERROR =\n       DiagnosticType.error(\"JSC_INJECT_NON_FUNCTION_ERROR\",\n-          \"@angularInject can only be used when defining a function or \" +\n+          \"@ngInject can only be used when defining a function or \" +\n           \"assigning a function expression.\");\n \n   static final DiagnosticType FUNCTION_NAME_ERROR =\n       DiagnosticType.error(\"JSC_FUNCTION_NAME_ERROR\",\n-          \"Unable to determine target function name for @angularInject.\");\n+          \"Unable to determine target function name for @ngInject.\");\n \n   @Override\n   public void process(Node externs, Node root) {\n-    // Traverses AST looking for nodes annotated with @angularInject.\n+    // Traverses AST looking for nodes annotated with @ngInject.\n     NodeTraversal.traverse(compiler, root, this);\n     CodingConvention convention = compiler.getCodingConvention();\n     boolean codeChanged = false;\n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     JSDocInfo docInfo = n.getJSDocInfo();\n-    if (docInfo != null && docInfo.isAngularInject()) {\n+    if (docInfo != null && docInfo.isNgInject()) {\n       addNode(n, t);\n     }\n   }\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n     @Option(name = \"--angular_pass\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Generate $inject properties for AngularJS for functions \"\n-        + \"annotated with @angularInject\")\n+        + \"annotated with @ngInject\")\n     private boolean angular_pass = false;\n \n     @Option(name = \"--output_manifest\",\n--- a/src/com/google/javascript/jscomp/parsing/Annotation.java\n+++ b/src/com/google/javascript/jscomp/parsing/Annotation.java\n  * @author nicksantos@google.com (Nick Santos)\n  */\n enum Annotation {\n-  ANGULAR_INJECT,\n+  NG_INJECT,\n   AUTHOR,\n   CONSISTENTIDGENERATOR,\n   CONSTANT,\n \n   static final Map<String, Annotation> recognizedAnnotations =\n       new ImmutableMap.Builder<String, Annotation>().\n-      put(\"angularInject\", Annotation.ANGULAR_INJECT).\n+      put(\"ngInject\", Annotation.NG_INJECT).\n       put(\"argument\", Annotation.PARAM).\n       put(\"author\", Annotation.AUTHOR).\n       put(\"consistentIdGenerator\", Annotation.CONSISTENTIDGENERATOR).\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n               jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n \n               switch (annotation) {\n-                case ANGULAR_INJECT:\n-                  if (jsdocBuilder.isAngularInjectRecorded()) {\n-                    parser.addParserWarning(\"msg.jsdoc.angularinject.extra\",\n+                case NG_INJECT:\n+                  if (jsdocBuilder.isNgInjectRecorded()) {\n+                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n                       stream.getLineno(), stream.getCharno());\n                   } else {\n-                    jsdocBuilder.recordAngularInject(true);\n+                    jsdocBuilder.recordNgInject(true);\n                   }\n                   token = eatTokensUntilEOL();\n                   continue retry;\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n     Set<String> suppressions = null;\n     Set<String> modifies = null;\n     String lendsName = null;\n-    boolean angularInject = false;\n+    boolean ngInject = false;\n   }\n \n   private static final class LazilyInitializedDocumentation {\n   }\n \n   /**\n-   * Returns whether JSDoc is annotated with {@code @angularInject} annotation.\n-   */\n-  public boolean isAngularInject() {\n-    return (info == null) ? false : info.angularInject;\n-  }\n-\n-  void setAngularInject(boolean angularInject) {\n+   * Returns whether JSDoc is annotated with {@code @ngInject} annotation.\n+   */\n+  public boolean isNgInject() {\n+    return (info == null) ? false : info.ngInject;\n+  }\n+\n+  void setNgInject(boolean ngInject) {\n     lazyInitInfo();\n-    info.angularInject = angularInject;\n+    info.ngInject = ngInject;\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n   }\n \n   /**\n-   * Returns whether current JSDoc is annotated with {@code @angularInject}.\n-   */\n-  public boolean isAngularInjectRecorded() {\n-    return currentInfo.isAngularInject();\n+   * Returns whether current JSDoc is annotated with {@code @ngInject}.\n+   */\n+  public boolean isNgInjectRecorded() {\n+    return currentInfo.isNgInject();\n   }\n \n   /**\n    * Records that we'd like to add {@code $inject} property inferred from\n    * parameters.\n    */\n-  public boolean recordAngularInject(boolean angularInject) {\n-    if (!isAngularInjectRecorded()) {\n-      currentInfo.setAngularInject(angularInject);\n+  public boolean recordNgInject(boolean ngInject) {\n+    if (!isNgInjectRecorded()) {\n+      currentInfo.setNgInject(ngInject);\n       populated = true;\n       return true;\n     } else {\n--- a/test/com/google/javascript/jscomp/AngularPassTest.java\n+++ b/test/com/google/javascript/jscomp/AngularPassTest.java\n     return getOptions(options);\n   }\n \n-  public void testAngularInjectAddsInjectToFunctions() throws Exception {\n-    test(\n-        \"/** @angularInject */\" +\n+  public void testNgInjectAddsInjectToFunctions() throws Exception {\n+    test(\n+        \"/** @ngInject */\" +\n         \"function fn(a, b) {}\",\n \n         \"function fn(a, b) {}\\n\" +\n     );\n   }\n \n-  public void testAngularInjectAddsInjectToProps() throws Exception {\n-    test(\n-        \"var ns = {};\\n\" +\n-        \"/** @angularInject */\" +\n+  public void testNgInjectAddsInjectToProps() throws Exception {\n+    test(\n+        \"var ns = {};\\n\" +\n+        \"/** @ngInject */\" +\n         \"ns.fn = function (a, b) {}\",\n \n         \"var ns = {};\\n\" +\n     );\n   }\n \n-  public void testAngularInjectAddsInjectToNestedProps() throws Exception {\n+  public void testNgInjectAddsInjectToNestedProps() throws Exception {\n     test(\n         \"var ns = {}; ns.subns = {};\\n\" +\n-        \"/** @angularInject */\" +\n+        \"/** @ngInject */\" +\n         \"ns.subns.fn = function (a, b) {}\",\n \n         \"var ns = {};ns.subns = {};\\n\" +\n     );\n   }\n \n-  public void testAngularInjectAddsInjectToVars() throws Exception {\n-    test(\n-        \"/** @angularInject */\" +\n+  public void testNgInjectAddsInjectToVars() throws Exception {\n+    test(\n+        \"/** @ngInject */\" +\n         \"var fn = function (a, b) {}\",\n \n         \"var fn = function (a, b) {};\\n\" +\n     );\n   }\n \n-  public void testAngularInjectAddsInjectToVarsWithChainedAssignment()\n+  public void testNgInjectAddsInjectToVarsWithChainedAssignment()\n       throws Exception {\n     test(\n         \"var ns = {};\\n\" +\n-        \"/** @angularInject */\" +\n+        \"/** @ngInject */\" +\n         \"var fn = ns.func = function (a, b) {}\",\n \n         \"var ns = {}; var fn = ns.func = function (a, b) {};\\n\" +\n     );\n   }\n \n-  public void testAngularInjectInBlock() throws Exception {\n-    test(\n-        \"(function() {\" +\n-        \"var ns = {};\\n\" +\n-        \"/** @angularInject */\" +\n+  public void testNgInjectInBlock() throws Exception {\n+    test(\n+        \"(function() {\" +\n+        \"var ns = {};\\n\" +\n+        \"/** @ngInject */\" +\n         \"var fn = ns.func = function (a, b) {}\" +\n         \"})()\",\n \n     );\n   }\n \n-  public void testAngularInjectAddsToTheRightBlock() throws Exception {\n+  public void testNgInjectAddsToTheRightBlock() throws Exception {\n     test(\n         \"var fn = 10;\\n\" +\n         \"(function() {\" +\n         \"var ns = {};\\n\" +\n-        \"/** @angularInject */\" +\n+        \"/** @ngInject */\" +\n         \"var fn = ns.func = function (a, b) {}\" +\n         \"})()\",\n \n     );\n   }\n \n-  public void testAngularInjectInNonBlock() throws Exception {\n+  public void testNgInjectInNonBlock() throws Exception {\n     test(\n         \"function fake(){}; var ns = {};\" +\n         \"fake(\" +\n-        \"/** @angularInject */\" +\n+        \"/** @ngInject */\" +\n         \"ns.func = function (a, b) {}\" +\n         \")\",\n         null,\n     );\n \n     test(\n-        \"/** @angularInject */(\" +\n+        \"/** @ngInject */(\" +\n         \"function (a, b) {}\" +\n         \")\",\n         null,\n     );\n   }\n \n-  public void testAngularInjectNonFunction() throws Exception {\n-    test(\n-        \"/** @angularInject */\" +\n+  public void testNgInjectNonFunction() throws Exception {\n+    test(\n+        \"/** @ngInject */\" +\n         \"var a = 10\",\n         null,\n         AngularPass.INJECT_NON_FUNCTION_ERROR\n     );\n \n     test(\n-        \"/** @angularInject */\" +\n+        \"/** @ngInject */\" +\n         \"var x\",\n         null,\n         AngularPass.INJECT_NON_FUNCTION_ERROR\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n \n   public void testAngularPassOff() {\n     testSame(createCompilerOptions(),\n-        \"/** @angularInject */ function f() {} \" +\n-        \"/** @angularInject */ function g(a){} \" +\n-        \"/** @angularInject */ var b = function f(a) {} \");\n+        \"/** @ngInject */ function f() {} \" +\n+        \"/** @ngInject */ function g(a){} \" +\n+        \"/** @ngInject */ var b = function f(a) {} \");\n   }\n \n   public void testAngularPassOn() {\n     CompilerOptions options = createCompilerOptions();\n     options.angularPass = true;\n     test(options,\n-        \"/** @angularInject */ function f() {} \" +\n-        \"/** @angularInject */ function g(a){} \" +\n-        \"/** @angularInject */ var b = function f(a, b, c) {} \",\n+        \"/** @ngInject */ function f() {} \" +\n+        \"/** @ngInject */ function g(a){} \" +\n+        \"/** @ngInject */ var b = function f(a, b, c) {} \",\n \n         \"function f() {} \" +\n         \"function g(a) {} g.$inject=['a'];\" +\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n   public void testWhitelistedAnnotations() {\n     parse(\n       \"* @addon \\n\" +\n-      \"* @angularInject \\n\" +\n+      \"* @ngInject \\n\" +\n       \"* @augments \\n\" +\n       \"* @base \\n\" +\n       \"* @borrows \\n\" +\n     assertEquals(comment, info.getOriginalCommentString());\n   }\n \n-  public void testParseAngularInject1() throws Exception {\n-    assertTrue(parse(\"@angularInject*/\").isAngularInject());\n-  }\n-\n-  public void testParseAngularInject2() throws Exception {\n-    parse(\"@angularInject \\n@angularInject*/\", \"extra @angularInject tag\");\n+  public void testParseNgInject1() throws Exception {\n+    assertTrue(parse(\"@ngInject*/\").isNgInject());\n+  }\n+\n+  public void testParseNgInject2() throws Exception {\n+    parse(\"@ngInject \\n@ngInject*/\", \"extra @ngInject tag\");\n   }\n \n   /**", "timestamp": 1359148731, "metainfo": ""}