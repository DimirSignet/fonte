{"sha": "52c26fec6092b9c19b42acf0d68afc7056b17e75", "log": "LANG-839 ArrayUtils removeElements methods use unnecessary HashSet Replace HashSet with BitSet (less memory; faster)  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n \n import java.lang.reflect.Array;\n import java.util.Arrays;\n+import java.util.BitSet;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.Map;\n \n import org.apache.commons.lang3.builder.EqualsBuilder;\n                 count.increment();\n             }\n         }\n-        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        BitSet toRemove = new BitSet();\n         for (Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n             T v = e.getKey();\n             int found = 0;\n                 if (found < 0) {\n                     break;\n                 }\n-                toRemove.add(found++);\n+                toRemove.set(found++);\n             }\n         }\n         @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n                 count.increment();\n             }\n         }\n-        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        BitSet toRemove = new BitSet();\n         for (Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) {\n             Byte v = e.getKey();\n             int found = 0;\n                 if (found < 0) {\n                     break;\n                 }\n-                toRemove.add(found++);\n+                toRemove.set(found++);\n             }\n         }\n         return (byte[]) removeAll((Object)array, extractIndices(toRemove));\n                 count.increment();\n             }\n         }\n-        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        BitSet toRemove = new BitSet();\n         for (Map.Entry<Short, MutableInt> e : occurrences.entrySet()) {\n             Short v = e.getKey();\n             int found = 0;\n                 if (found < 0) {\n                     break;\n                 }\n-                toRemove.add(found++);\n+                toRemove.set(found++);\n             }\n         }\n         return (short[]) removeAll((Object)array, extractIndices(toRemove));\n                 count.increment();\n             }\n         }\n-        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        BitSet toRemove = new BitSet();\n         for (Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) {\n             Integer v = e.getKey();\n             int found = 0;\n                 if (found < 0) {\n                     break;\n                 }\n-                toRemove.add(found++);\n+                toRemove.set(found++);\n             }\n         }\n         return (int[]) removeAll((Object)array, extractIndices(toRemove));\n                 count.increment();\n             }\n         }\n-        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        BitSet toRemove = new BitSet();\n         for (Map.Entry<Character, MutableInt> e : occurrences.entrySet()) {\n             Character v = e.getKey();\n             int found = 0;\n                 if (found < 0) {\n                     break;\n                 }\n-                toRemove.add(found++);\n+                toRemove.set(found++);\n             }\n         }\n         return (char[]) removeAll((Object)array, extractIndices(toRemove));\n                 count.increment();\n             }\n         }\n-        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        BitSet toRemove = new BitSet();\n         for (Map.Entry<Long, MutableInt> e : occurrences.entrySet()) {\n             Long v = e.getKey();\n             int found = 0;\n                 if (found < 0) {\n                     break;\n                 }\n-                toRemove.add(found++);\n+                toRemove.set(found++);\n             }\n         }\n         return (long[]) removeAll((Object)array, extractIndices(toRemove));\n                 count.increment();\n             }\n         }\n-        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        BitSet toRemove = new BitSet();\n         for (Map.Entry<Float, MutableInt> e : occurrences.entrySet()) {\n             Float v = e.getKey();\n             int found = 0;\n                 if (found < 0) {\n                     break;\n                 }\n-                toRemove.add(found++);\n+                toRemove.set(found++);\n             }\n         }\n         return (float[]) removeAll((Object)array, extractIndices(toRemove));\n                 count.increment();\n             }\n         }\n-        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        BitSet toRemove = new BitSet();\n         for (Map.Entry<Double, MutableInt> e : occurrences.entrySet()) {\n             Double v = e.getKey();\n             int found = 0;\n                 if (found < 0) {\n                     break;\n                 }\n-                toRemove.add(found++);\n+                toRemove.set(found++);\n             }\n         }\n         return (double[]) removeAll((Object)array, extractIndices(toRemove));\n                 count.increment();\n             }\n         }\n-        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        BitSet toRemove = new BitSet();\n         for (Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {\n             Boolean v = e.getKey();\n             int found = 0;\n                 if (found < 0) {\n                     break;\n                 }\n-                toRemove.add(found++);\n+                toRemove.set(found++);\n             }\n         }\n         return (boolean[]) removeAll((Object)array, extractIndices(toRemove));\n     }\n \n     /**\n-     * Extract a set of Integer indices into an int[].\n-     * @param coll {@code HashSet} of {@code Integer}\n+     * Extract a set of BitSet indices into an int[].\n+     * @param coll Bitset\n      * @return int[]\n-     * @since 3.0.1\n-     */\n-    private static int[] extractIndices(HashSet<Integer> coll) {\n-        int[] result = new int[coll.size()];\n+     */\n+    private static int[] extractIndices(BitSet coll) {\n+        int[] result = new int[coll.cardinality()];\n         int i = 0;\n-        for (Integer index : coll) {\n-            result[i++] = index.intValue();\n+        int j=0;\n+        while((j=coll.nextSetBit(j)) != -1) {\n+            result[i++] = j++;            \n         }\n         return result;\n     }", "timestamp": 1349745973, "metainfo": ""}