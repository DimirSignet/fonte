{"sha": "d195200972e385713c449abc9d35da6b90a3297d", "log": "ws only  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n \n         /*\n            The difference between this impl. and the previous is that, rather\n-           than creating and retaining a matrix of size s.length()+1 by t.length()+1,\n-           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,\n+           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,\n+           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,\n            is the 'current working' distance array that maintains the newest distance cost\n            counts as we iterate through the characters of String s.  Each time we increment\n            the index of String t we are comparing, d is copied to p, the second int[].  Doing so\n             m = t.length();\n         }\n \n-        int p[] = new int[n+1]; //'previous' cost array, horizontally\n-        int d[] = new int[n+1]; // cost array, horizontally\n+        int p[] = new int[n + 1]; //'previous' cost array, horizontally\n+        int d[] = new int[n + 1]; // cost array, horizontally\n         int _d[]; //placeholder to assist in swapping p and d\n \n         // indexes into strings s and t\n \n         int cost; // cost\n \n-        for (i = 0; i<=n; i++) {\n+        for (i = 0; i <= n; i++) {\n             p[i] = i;\n         }\n \n-        for (j = 1; j<=m; j++) {\n-            t_j = t.charAt(j-1);\n+        for (j = 1; j <= m; j++) {\n+            t_j = t.charAt(j - 1);\n             d[0] = j;\n \n-            for (i=1; i<=n; i++) {\n-                cost = s.charAt(i-1)==t_j ? 0 : 1;\n+            for (i = 1; i <= n; i++) {\n+                cost = s.charAt(i - 1) == t_j ? 0 : 1;\n                 // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n-                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);\n+                d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);\n             }\n \n             // copy current distance counts to 'previous row' distance counts\n      * @throws IllegalArgumentException if either String input {@code null} or negative threshold\n      */\n     public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {\n-        if(s == null || t == null) {\n+        if (s == null || t == null) {\n             throw new IllegalArgumentException(\"Strings must not be null\");\n         }\n-        if(threshold < 0) {\n+        if (threshold < 0) {\n             throw new IllegalArgumentException(\"Threshold must not be negative\");\n         }\n \n         This implementation only computes the distance if it's less than or equal to the\n         threshold value, returning -1 if it's greater.  The advantage is performance: unbounded\n         distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only \n-        computing a diagonal stripe of width 2k+1 of the cost table.\n+        computing a diagonal stripe of width 2k + 1 of the cost table.\n         It is also possible to use this to compute the unbounded Levenshtein distance by starting\n         the threshold at 1 and doubling each time until the distance is found; this is O(dm), where\n         d is the distance.\n         int m = t.length(); // length of t\n \n         // if one string is empty, the edit distance is necessarily the length of the other\n-        if(n == 0) {\n-            return m <= threshold? m : -1;\n-        } else if(m == 0) {\n-            return n <= threshold? n : -1;\n-        }\n-\n-        if(n > m) {\n+        if (n == 0) {\n+            return m <= threshold ? m : -1;\n+        } else if (m == 0) {\n+            return n <= threshold ? n : -1;\n+        }\n+\n+        if (n > m) {\n             // swap the two strings to consume less memory\n             CharSequence tmp = s;\n             s = t;\n             m = t.length();\n         }\n \n-        int p[] = new int[n+1]; // 'previous' cost array, horizontally\n-        int d[] = new int[n+1]; // cost array, horizontally\n+        int p[] = new int[n + 1]; // 'previous' cost array, horizontally\n+        int d[] = new int[n + 1]; // cost array, horizontally\n         int _d[]; // placeholder to assist in swapping p and d\n \n         // fill in starting table values\n         int boundary = Math.min(n, threshold) + 1;\n-        for(int i = 0; i < boundary; i++) {\n+        for (int i = 0; i < boundary; i++) {\n             p[i] = i;\n         }\n         // these fills ensure that the value above the rightmost entry of our \n         Arrays.fill(d, Integer.MAX_VALUE);\n \n         // iterates through t\n-        for(int j = 1; j <= m; j++) {\n-            char t_j = t.charAt(j-1); // jth character of t\n+        for (int j = 1; j <= m; j++) {\n+            char t_j = t.charAt(j - 1); // jth character of t\n             d[0] = j;\n \n             // compute stripe indices, constrain to array size\n             int max = Math.min(n, j + threshold);\n \n             // the stripe may lead off of the table if s and t are of different sizes\n-            if(min > max) {\n+            if (min > max) {\n                 return -1;\n             }\n \n             // ignore entry left of leftmost\n-            if(min > 1) {\n-                d[min-1] = Integer.MAX_VALUE;\n+            if (min > 1) {\n+                d[min - 1] = Integer.MAX_VALUE;\n             }\n \n             // iterates through [min, max] in s\n-            for(int i = min; i <= max; i++) {\n-                if(s.charAt(i-1) == t_j) {\n+            for (int i = min; i <= max; i++) {\n+                if (s.charAt(i - 1) == t_j) {\n                     // diagonally left and up\n-                    d[i] = p[i-1];\n+                    d[i] = p[i - 1];\n                 } else {\n                     // 1 + minimum of cell to the left, to the top, diagonally left and up\n-                    d[i] = 1 + Math.min(Math.min(d[i-1], p[i]), p[i-1]);\n+                    d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\n                 }\n             }\n \n \n         // if p[n] is greater than the threshold, there's no guarantee on it being the correct\n         // distance\n-        if(p[n] <= threshold) {\n+        if (p[n] <= threshold) {\n             return p[n];\n         } else {\n             return -1;", "timestamp": 1308240680, "metainfo": ""}