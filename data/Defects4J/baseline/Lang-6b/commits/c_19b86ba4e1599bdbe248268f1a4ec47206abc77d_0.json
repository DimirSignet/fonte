{"sha": "19b86ba4e1599bdbe248268f1a4ec47206abc77d", "log": "LANG-828 FastDateParser does not handle non-Gregorian calendars properly   ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n import java.text.DateFormatSymbols;\n import java.text.ParseException;\n import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Calendar;\n  * <p>Timing tests indicate this class is as about as fast as SimpleDateFormat\n  * in single thread applications and about 25% faster in multi-thread applications.</p>\n  *\n+ * <p>Note that the code only handles Gregorian calendars. The following non-Gregorian\n+ * calendars use SimpleDateFormat internally, and so will be slower:\n+ * <ul>\n+ * <li>ja_JP_TH - Japanese Imperial</li>\n+ * <li>th_TH (any variant) - Thai Buddhist</li>\n+ * </ul>\n+ * </p>\n  * @since 3.2\n  */\n public class FastDateParser implements DateParser, Serializable {\n         if(!patternMatcher.lookingAt()) {\n             throw new IllegalArgumentException(\"Invalid pattern\");\n         }\n-        \n+\n+        String localeName = locale.toString();\n+        // These locales don't use the Gregorian calendar\n+        // See http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html\n+        if (localeName.equals(\"ja_JP_JP\") || localeName.startsWith(\"th_TH\")) {\n+            collector.add(new SimpleDateFormatStrategy());\n+            strategies= collector.toArray(new Strategy[collector.size()]);\n+            parsePattern= Pattern.compile(\"(.*+)\");\n+            return;\n+        }\n+\n         currentFormatField= patternMatcher.group();\n         Strategy currentStrategy= getStrategy(currentFormatField);\n         for(;;) {\n         }        \n     }\n \n+\n+    /**\n+     * Dummy strategy which delegates to SimpleDateFormat.\n+     */\n+    private static class SimpleDateFormatStrategy implements Strategy {\n+\n+        @Override\n+        public boolean isNumber() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n+            String pat = parser.pattern;\n+            Locale loc = parser.locale;\n+            SimpleDateFormat sdf = new SimpleDateFormat(pat, loc);\n+            try {\n+                Date d = sdf.parse(value);\n+                cal.setTime(d);\n+            } catch (ParseException e) {\n+                throw new IllegalArgumentException(\n+                        \"Unexpected error using pattern \" + pat + \" with locale \" + loc.toString(), e);\n+            }\n+        }\n+\n+        @Override\n+        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n+            return false;\n+        }\n+        \n+    }\n+\n     private static final Strategy ERA_STRATEGY = new TextStrategy(Calendar.ERA);\n     private static final Strategy DAY_OF_WEEK_STRATEGY = new TextStrategy(Calendar.DAY_OF_WEEK);\n     private static final Strategy AM_PM_STRATEGY = new TextStrategy(Calendar.AM_PM);\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n-\n import java.io.Serializable;\n import java.text.ParseException;\n import java.text.SimpleDateFormat;\n import java.util.Map;\n import java.util.TimeZone;\n \n+import junit.framework.Assert;\n+\n import org.apache.commons.lang3.SerializationUtils;\n import org.junit.Test;\n \n     public void testParses() throws Exception {\n         for(Locale locale : Locale.getAvailableLocales()) {\n             for(TimeZone tz : new TimeZone[]{NEW_YORK, GMT}) {\n-                Calendar cal = Calendar.getInstance(tz);                \n-                cal.clear();\n-                cal.set(2003, 1, 10);\n-                Date in = cal.getTime();\n-                for(String format : new String[]{LONG_FORMAT, SHORT_FORMAT}) {\n-                    SimpleDateFormat sdf = new SimpleDateFormat(LONG_FORMAT, locale);\n-                    String fmt = sdf.format(in);\n-                    Date out = sdf.parse(fmt);\n-                    assertEquals(locale.toString()+\" \"+ format+ \" \"+tz.getID(), in, out);                \n+                Calendar cal = Calendar.getInstance(tz);\n+                for(int year : new int[]{2003, 1940, 1868, 1867, 0, -1940}) {\n+                    // http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html\n+                    if (year < 1868 && locale.toString().equals(\"ja_JP_JP\")) {\n+                        continue; // Japanese imperial calendar does not support eras before 1868\n+                    }\n+                    cal.clear();\n+                    if (year < 0) {\n+                        cal.set(-year, 1, 10);\n+                        cal.set(Calendar.ERA, GregorianCalendar.BC);\n+                    } else {\n+                        cal.set(year, 1, 10);\n+                    }\n+                    Date in = cal.getTime();\n+                    for(String format : new String[]{LONG_FORMAT, SHORT_FORMAT}) {\n+                        SimpleDateFormat sdf = new SimpleDateFormat(format, locale);\n+                        if (format.equals(SHORT_FORMAT)) {\n+                            if (year < 1930) {\n+                                sdf.set2DigitYearStart(cal.getTime());\n+                            }\n+                        }\n+                        String fmt = sdf.format(in);\n+                        try {\n+                            Date out = sdf.parse(fmt);\n+                            \n+                            assertEquals(locale.toString()+\" \"+year+\" \"+ format+ \" \"+tz.getID(), in, out);\n+                        } catch (ParseException pe) {\n+                            System.out.println(fmt+\" \"+locale.toString()+\" \"+year+\" \"+ format+ \" \"+tz.getID());\n+                            throw pe;\n+                        }\n+                    }\n                 }\n             }\n         }\n         if (eraBC) {\n             cal.set(Calendar.ERA, GregorianCalendar.BC);\n         }\n+        boolean failed = false;\n         for(Locale locale : Locale.getAvailableLocales()) {\n+            // ja_JP_JP cannot handle dates before 1868 properly\n+            if (eraBC && format.equals(SHORT_FORMAT) && locale.toString().equals(\"ja_JP_JP\")) {\n+                continue;\n+            }\n             SimpleDateFormat sdf = new SimpleDateFormat(format, locale);\n             DateParser fdf = getInstance(format, locale);\n \n             try {\n                 checkParse(locale, cal, sdf, fdf);\n             } catch(ParseException ex) {\n+                failed = true;\n                 // TODO: are these Java bugs?\n                 // ja_JP_JP, th_TH, and th_TH_TH fail with both eras because the generated era name does not match\n                 // ja_JP_JP fails with era BC because it converts to -2002\n                 System.out.println(\"Locale \"+locale+ \" failed with \"+format+\" era \"+(eraBC?\"BC\":\"AD\")+\"\\n\" + trimMessage(ex.toString()));\n             }\n+        }\n+        if (failed) {\n+            Assert.fail(\"One or more tests failed, see above\");\n         }\n     }\n ", "timestamp": 1348590740, "metainfo": ""}