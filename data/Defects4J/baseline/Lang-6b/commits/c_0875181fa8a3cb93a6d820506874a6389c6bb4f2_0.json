{"sha": "0875181fa8a3cb93a6d820506874a6389c6bb4f2", "log": "[LANG-501] Added BackgroundInitializer class with JUnit tests.  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/concurrent/BackgroundInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * <p>\n+ * A class that allows complex initialization operations in a background task.\n+ * </p>\n+ * <p>\n+ * Applications often have to do some expensive initialization steps when they\n+ * are started, e.g. constructing a connection to a database, reading a\n+ * configuration file, etc. Doing these things in parallel can enhance\n+ * performance as the CPU load can be improved. However, when access to the\n+ * resources initialized in a background thread is actually required,\n+ * synchronization has to be performed to ensure that their initialization is\n+ * complete.\n+ * </p>\n+ * <p>\n+ * This abstract base class provides support for this use case. A concrete\n+ * subclass must implement the {@link #initialize()} method. Here an arbitrary\n+ * initialization can be implemented, and a result object can be returned. With\n+ * this method in place the basic usage of this class is as follows (where\n+ * {@code MyBackgroundInitializer} is a concrete subclass):\n+ *\n+ * <pre>\n+ * MyBackgroundInitializer initializer = new MyBackgroundInitializer();\n+ * initializer.start();\n+ * // Now do some other things. Initialization runs in a parallel thread\n+ * ...\n+ * // Wait for the end of initialization and access the result object\n+ * Object result = initializer.get();\n+ * </pre>\n+ *\n+ * </p>\n+ * <p>\n+ * After the construction of a {@code BackgroundInitializer} object its\n+ * {@link #start()} method has to be called. This starts the background\n+ * processing. The application can now continue to do other things. When it\n+ * needs access to the object produced by the {@code BackgroundInitializer} it\n+ * calls its {@link #get()} method. If initialization is already complete,\n+ * {@link #get()} returns the result object immediately. Otherwise it blocks\n+ * until the result object is fully constructed.\n+ * </p>\n+ * <p>\n+ * {@code BackgroundInitializer} is a thin wrapper around a {@code Future}\n+ * object and uses an {@code ExecutorService} for running the background\n+ * initialization task. It is possible to pass in an {@code ExecutorService} at\n+ * construction time or set one using {@code setExternalExecutor()} before\n+ * {@code start()} was called. Then this object is used to spawn the background\n+ * task. If no {@code ExecutorService} has been provided, {@code\n+ * BackgroundInitializer} creates a temporary {@code ExecutorService} and\n+ * destroys it when initialization is complete.\n+ * </p>\n+ * <p>\n+ * The methods provided by {@code BackgroundInitializer} provide for minimal\n+ * interaction with the wrapped {@code Future} object. It is also possible to\n+ * obtain the {@code Future} object directly. Then the enhanced functionality\n+ * offered by {@code Future} can be used, e.g. to check whether the background\n+ * operation is complete or to cancel the operation.\n+ * </p>\n+ *\n+ * @version $Id$\n+ * @param <T> the type of the object managed by this initializer class\n+ */\n+public abstract class BackgroundInitializer<T> {\n+    /** The external executor service for executing tasks. */\n+    private ExecutorService externalExecutor;\n+\n+    /** A reference to the executor service that is actually used. */\n+    private ExecutorService executor;\n+\n+    /** Stores the handle to the background task. */\n+    private Future<T> future;\n+\n+    /**\n+     * Creates a new instance of {@code BackgroundInitializer}. No external\n+     * {@code ExecutorService} is used.\n+     */\n+    protected BackgroundInitializer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code BackgroundInitializer} and initializes\n+     * it with the given {@code ExecutorService}. If the {@code ExecutorService}\n+     * is not null, the background task for initializing this object will be\n+     * scheduled at this service. Otherwise a new temporary {@code\n+     * ExecutorService} is created.\n+     *\n+     * @param exec an external {@code ExecutorService} to be used for task\n+     * execution\n+     */\n+    protected BackgroundInitializer(ExecutorService exec) {\n+        setExternalExecutor(exec);\n+    }\n+\n+    /**\n+     * Returns the external {@code ExecutorService} to be used by this class.\n+     *\n+     * @return the {@code ExecutorService}\n+     */\n+    public final synchronized ExecutorService getExternalExecutor() {\n+        return externalExecutor;\n+    }\n+\n+    /**\n+     * Returns a flag whether this {@code BackgroundInitializer} has already\n+     * been started.\n+     *\n+     * @return a flag whether the {@link #start()} method has already been\n+     * called\n+     */\n+    public synchronized boolean isStarted() {\n+        return future != null;\n+    }\n+\n+    /**\n+     * Sets an {@code ExecutorService} to be used by this class. The {@code\n+     * ExecutorService} passed to this method is used for executing the\n+     * background task. Thus it is possible to re-use an already existing\n+     * {@code ExecutorService} or to use a specially configured one. If no\n+     * {@code ExecutorService} is set, this instance creates a temporary one and\n+     * destroys it after background initialization is complete. Note that this\n+     * method must be called before {@link #start()}; otherwise an exception is\n+     * thrown.\n+     *\n+     * @param externalExecutor the {@code ExecutorService} to be used\n+     * @throws IllegalStateException if this initializer has already been\n+     * started\n+     */\n+    public final synchronized void setExternalExecutor(\n+            ExecutorService externalExecutor) {\n+        if (isStarted()) {\n+            throw new IllegalStateException(\n+                    \"Cannot set ExecutorService after start()!\");\n+        }\n+\n+        this.externalExecutor = externalExecutor;\n+    }\n+\n+    /**\n+     * Starts the background initialization. With this method the initializer\n+     * becomes active and invokes the {@link #initialize()} method in a\n+     * background task. A {@code BackgroundInitializer} can be started exactly\n+     * once. The return value of this method determines whether the start was\n+     * successful: only the first invocation of this method returns <b>true</b>,\n+     * following invocations will return <b>false</b>.\n+     *\n+     * @return a flag whether the initializer could be started successfully\n+     */\n+    public synchronized boolean start() {\n+        // Not yet started?\n+        if (!isStarted()) {\n+\n+            // Determine the executor to use and whether a temporary one has to\n+            // be created\n+            ExecutorService tempExec;\n+            executor = getExternalExecutor();\n+            if (executor == null) {\n+                executor = tempExec = createExecutor();\n+            } else {\n+                tempExec = null;\n+            }\n+\n+            future = executor.submit(createTask(tempExec));\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Returns the result of the background initialization. This method blocks\n+     * until initialization is complete. If the background processing caused a\n+     * runtime exception, it is directly thrown by this method. Checked\n+     * exceptions, including {@code InterruptedException} are wrapped in a\n+     * {@link ConcurrentException}. Calling this method before {@link #start()}\n+     * was called causes an {@code IllegalStateException} exception to be\n+     * thrown.\n+     *\n+     * @return the object produced by this initializer\n+     * @throws ConcurrentException if a checked exception occurred during\n+     * background processing\n+     * @throws IllegalStateException if {@link #start()} has not been called\n+     */\n+    public T get() throws ConcurrentException {\n+        try {\n+            return getFuture().get();\n+        } catch (ExecutionException execex) {\n+            ConcurrentUtils.handleCause(execex);\n+            return null; // should not be reached\n+        } catch (InterruptedException iex) {\n+            // reset interrupted state\n+            Thread.currentThread().interrupt();\n+            throw new ConcurrentException(iex);\n+        }\n+    }\n+\n+    /**\n+     * Returns the {@code Future} object that was created when {@link #start()}\n+     * was called. Therefore this method can only be called after {@code\n+     * start()}.\n+     *\n+     * @return the {@code Future} object wrapped by this initializer\n+     * @throws IllegalStateException if {@link #start()} has not been called\n+     */\n+    public synchronized Future<T> getFuture() {\n+        if (future == null) {\n+            throw new IllegalStateException(\"start() must be called first!\");\n+        }\n+\n+        return future;\n+    }\n+\n+    /**\n+     * Returns the {@code ExecutorService} that is actually used for executing\n+     * the background task. This method can be called after {@link #start()}\n+     * (before {@code start()} it returns <b>null</b>). If an external executor\n+     * was set, this is also the active executor. Otherwise this method returns\n+     * the temporary executor that was created by this object.\n+     *\n+     * @return the {@code ExecutorService} for executing the background task\n+     */\n+    protected synchronized final ExecutorService getActiveExecutor() {\n+        return executor;\n+    }\n+\n+    /**\n+     * Returns the number of background tasks to be created for this\n+     * initializer. This information is evaluated when a temporary {@code\n+     * ExecutorService} is created. This base implementation returns 1. Derived\n+     * classes that do more complex background processing can override it. This\n+     * method is called from a synchronized block by the {@link #start()}\n+     * method. Therefore overriding methods should be careful with obtaining\n+     * other locks and return as fast as possible.\n+     *\n+     * @return the number of background tasks required by this initializer\n+     */\n+    protected int getTaskCount() {\n+        return 1;\n+    }\n+\n+    /**\n+     * Performs the initialization. This method is called in a background task\n+     * when this {@code BackgroundInitializer} is started. It must be\n+     * implemented by a concrete subclass. An implementation is free to perform\n+     * arbitrary initialization. The object returned by this method can be\n+     * queried using the {@link #get()} method.\n+     *\n+     * @return a result object\n+     * @throws Exception if an error occurs\n+     */\n+    protected abstract T initialize() throws Exception;\n+\n+    /**\n+     * Creates a task for the background initialization. The {@code Callable}\n+     * object returned by this method is passed to the {@code ExecutorService}.\n+     * This implementation returns a task that invokes the {@link #initialize()}\n+     * method. If a temporary {@code ExecutorService} is used, it is destroyed\n+     * at the end of the task.\n+     *\n+     * @param execDestory the {@code ExecutorService} to be destroyed by the\n+     * task\n+     * @return a task for the background initialization\n+     */\n+    private Callable<T> createTask(ExecutorService execDestroy) {\n+        return new InitializationTask(execDestroy);\n+    }\n+\n+    /**\n+     * Creates the {@code ExecutorService} to be used. This method is called if\n+     * no {@code ExecutorService} was provided at construction time.\n+     *\n+     * @return the {@code ExecutorService} to be used\n+     */\n+    private ExecutorService createExecutor() {\n+        return Executors.newFixedThreadPool(getTaskCount());\n+    }\n+\n+    private class InitializationTask implements Callable<T> {\n+        /** Stores the executor service to be destroyed at the end. */\n+        private final ExecutorService executor;\n+\n+        /**\n+         * Creates a new instance of {@code InitializationTask} and initializes\n+         * it with the {@code ExecutorService} to be destroyed at the end.\n+         *\n+         * @param exec the {@code ExecutorService}\n+         */\n+        public InitializationTask(ExecutorService exec) {\n+            executor = exec;\n+        }\n+\n+        /**\n+         * Initiates initialization and returns the result.\n+         *\n+         * @return the result object\n+         * @throws Exception if an error occurs\n+         */\n+        public T call() throws Exception {\n+            try {\n+                return initialize();\n+            } finally {\n+                if (executor != null) {\n+                    executor.shutdown();\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/concurrent/BackgroundInitializerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.concurrent;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import junit.framework.TestCase;\n+\n+public class BackgroundInitializerTest extends TestCase {\n+    /**\n+     * Helper method for checking whether the initialize() method was correctly\n+     * called. start() must already have been invoked.\n+     *\n+     * @param init the initializer to test\n+     */\n+    private void checkInitialize(BackgroundInitializerTestImpl init) {\n+        try {\n+            Integer result = init.get();\n+            assertEquals(\"Wrong result\", 1, result.intValue());\n+            assertEquals(\"Wrong number of invocations\", 1, init.initializeCalls);\n+            assertNotNull(\"No future\", init.getFuture());\n+        } catch (ConcurrentException cex) {\n+            fail(\"Unexpected exception: \" + cex);\n+        }\n+    }\n+\n+    /**\n+     * Tests whether initialize() is invoked.\n+     */\n+    public void testInitialize() throws ConcurrentException {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        init.start();\n+        checkInitialize(init);\n+    }\n+\n+    /**\n+     * Tries to obtain the executor before start(). It should not have been\n+     * initialized yet.\n+     */\n+    public void testGetActiveExecutorBeforeStart() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        assertNull(\"Got an executor\", init.getActiveExecutor());\n+    }\n+\n+    /**\n+     * Tests whether an external executor is correctly detected.\n+     */\n+    public void testGetActiveExecutorExternal() {\n+        ExecutorService exec = Executors.newSingleThreadExecutor();\n+        try {\n+            BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n+                    exec);\n+            init.start();\n+            assertSame(\"Wrong executor\", exec, init.getActiveExecutor());\n+            checkInitialize(init);\n+        } finally {\n+            exec.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Tests getActiveExecutor() for a temporary executor.\n+     */\n+    public void testGetActiveExecutorTemp() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        init.start();\n+        assertNotNull(\"No active executor\", init.getActiveExecutor());\n+        checkInitialize(init);\n+    }\n+\n+    /**\n+     * Tests the execution of the background task if a temporary executor has to\n+     * be created.\n+     */\n+    public void testInitializeTempExecutor() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        assertTrue(\"Wrong result of start()\", init.start());\n+        checkInitialize(init);\n+        assertTrue(\"Executor not shutdown\", init.getActiveExecutor()\n+                .isShutdown());\n+    }\n+\n+    /**\n+     * Tests whether an external executor can be set using the\n+     * setExternalExecutor() method.\n+     */\n+    public void testSetExternalExecutor() throws Exception {\n+        ExecutorService exec = Executors.newCachedThreadPool();\n+        try {\n+            BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+            init.setExternalExecutor(exec);\n+            assertEquals(\"Wrong executor service\", exec, init\n+                    .getExternalExecutor());\n+            assertTrue(\"Wrong result of start()\", init.start());\n+            assertSame(\"Wrong active executor\", exec, init.getActiveExecutor());\n+            checkInitialize(init);\n+            assertFalse(\"Executor was shutdown\", exec.isShutdown());\n+        } finally {\n+            exec.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Tests that setting an executor after start() causes an exception.\n+     */\n+    public void testSetExternalExecutorAfterStart() throws ConcurrentException {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        init.start();\n+        try {\n+            init.setExternalExecutor(Executors.newSingleThreadExecutor());\n+            fail(\"Could set executor after start()!\");\n+        } catch (IllegalStateException istex) {\n+            init.get();\n+        }\n+    }\n+\n+    /**\n+     * Tests invoking start() multiple times. Only the first invocation should\n+     * have an effect.\n+     */\n+    public void testStartMultipleTimes() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        assertTrue(\"Wrong result for start()\", init.start());\n+        for (int i = 0; i < 10; i++) {\n+            assertFalse(\"Could start again\", init.start());\n+        }\n+        checkInitialize(init);\n+    }\n+\n+    /**\n+     * Tests calling get() before start(). This should cause an exception.\n+     */\n+    public void testGetBeforeStart() throws ConcurrentException {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        try {\n+            init.get();\n+            fail(\"Could call get() before start()!\");\n+        } catch (IllegalStateException istex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests the get() method if background processing causes a runtime\n+     * exception.\n+     */\n+    public void testGetRuntimeException() throws Exception {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        RuntimeException rex = new RuntimeException();\n+        init.ex = rex;\n+        init.start();\n+        try {\n+            init.get();\n+            fail(\"Exception not thrown!\");\n+        } catch (Exception ex) {\n+            assertEquals(\"Runtime exception not thrown\", rex, ex);\n+        }\n+    }\n+\n+    /**\n+     * Tests the get() method if background processing causes a checked\n+     * exception.\n+     */\n+    public void testGetCheckedException() throws Exception {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        Exception ex = new Exception();\n+        init.ex = ex;\n+        init.start();\n+        try {\n+            init.get();\n+            fail(\"Exception not thrown!\");\n+        } catch (ConcurrentException cex) {\n+            assertEquals(\"Exception not thrown\", ex, cex.getCause());\n+        }\n+    }\n+\n+    /**\n+     * Tests the get() method if waiting for the initialization is interrupted.\n+     */\n+    public void testGetInterruptedException() throws Exception {\n+        ExecutorService exec = Executors.newSingleThreadExecutor();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n+                exec);\n+        final CountDownLatch latch1 = new CountDownLatch(1);\n+        init.shouldSleep = true;\n+        init.start();\n+        final AtomicReference<InterruptedException> iex = new AtomicReference<InterruptedException>();\n+        Thread getThread = new Thread() {\n+            @Override\n+            public void run() {\n+                try {\n+                    init.get();\n+                } catch (ConcurrentException cex) {\n+                    if (cex.getCause() instanceof InterruptedException) {\n+                        iex.set((InterruptedException) cex.getCause());\n+                    }\n+                } finally {\n+                    assertTrue(\"Thread not interrupted\", isInterrupted());\n+                    latch1.countDown();\n+                }\n+            }\n+        };\n+        getThread.start();\n+        getThread.interrupt();\n+        latch1.await();\n+        exec.shutdownNow();\n+        exec.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS);\n+        assertNotNull(\"No interrupted exception\", iex.get());\n+    }\n+\n+    /**\n+     * Tests isStarted() before start() was called.\n+     */\n+    public void testIsStartedFalse() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        assertFalse(\"Already started\", init.isStarted());\n+    }\n+\n+    /**\n+     * Tests isStarted() after start().\n+     */\n+    public void testIsStartedTrue() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        init.start();\n+        assertTrue(\"Not started\", init.isStarted());\n+    }\n+\n+    /**\n+     * Tests isStarted() after the background task has finished.\n+     */\n+    public void testIsStartedAfterGet() {\n+        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        init.start();\n+        checkInitialize(init);\n+        assertTrue(\"Not started\", init.isStarted());\n+    }\n+\n+    /**\n+     * A concrete implementation of BackgroundInitializer. It also overloads\n+     * some methods that simplify testing.\n+     */\n+    private static class BackgroundInitializerTestImpl extends\n+            BackgroundInitializer<Integer> {\n+        /** An exception to be thrown by initialize(). */\n+        Exception ex;\n+\n+        /** A flag whether the background task should sleep a while. */\n+        boolean shouldSleep;\n+\n+        /** The number of invocations of initialize(). */\n+        volatile int initializeCalls;\n+\n+        public BackgroundInitializerTestImpl() {\n+            super();\n+        }\n+\n+        public BackgroundInitializerTestImpl(ExecutorService exec) {\n+            super(exec);\n+        }\n+\n+        /**\n+         * Records this invocation. Optionally throws an exception or sleeps a\n+         * while.\n+         */\n+        @Override\n+        protected Integer initialize() throws Exception {\n+            if (ex != null) {\n+                throw ex;\n+            }\n+            if (shouldSleep) {\n+                Thread.sleep(60000L);\n+            }\n+            return ++initializeCalls;\n+        }\n+    }\n+}", "timestamp": 1257018532, "metainfo": ""}