{"sha": "fc4e904c1cd8eabecf5ed90eb5e75c541c48281d", "log": "LANG-801:  Add Conversion utility to convert between data types on byte level  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/Conversion.java\n+/*******************************************************************************\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *******************************************************************************/\n+package org.apache.commons.lang3;\n+\n+import java.lang.IllegalArgumentException;\n+import java.lang.Long;\n+\n+\n+/**\n+ * <p>\n+ * Static methods to convert a type into another, with endianness and bit ordering awareness.\n+ * </p>\n+ * <p>\n+ * The methods names follow a naming rule:\n+ * </p>\n+ * \n+ * <pre>\n+ * &ltsource type&gt[source endianness][source bit ordering]To&ltdestination type&gt[destination endianness][destination bit ordering]\n+ * Source/Destination type fields: either of the following. An 's' added at the end indicate an array\n+ *  - \"bool\"\n+ *  - \"byte\"\n+ *  - \"int\"\n+ *  - \"long\"\n+ *  - \"Hex\": a String containing hexadecimal digits\n+ *  - \"HexDigit\": a Char containing a hexadecimal digit\n+ * Endianness field: little endian is the default, in this case the field is absent. In case of big endian, the field is \"Be\".\n+ * Bit ordering: Lsb0 is the default, in this case the field is absent. In case of Msb0, the field is \"M0\".\n+ * \n+ * Example: intBeM0ToHex convert an int with big endian byte order and Msb0 bit order into its hexadecimal string representation\n+ * </pre>\n+ * <p>\n+ * Most of the methods provide only default encoding for destination, this limits the number of\n+ * ways to do one thing. Unless you are dealing with data from/to outside of the JVM platform,\n+ * you should not need to use \"Be\" and \"M0\" methods.\n+ * </p>\n+ * <p>\n+ * Development status: work on going, only a part of the little endian, Lsb0 methods implemented\n+ * so far.\n+ * </p>\n+ * \n+ * @since Lang 3.2\n+ * @version $Id$\n+ */\n+\n+public class Conversion {\n+    /**\n+     * <p>\n+     * Converts a hexadecimal digit into an int using the default (Lsb0) bit ordering.\n+     * </p>\n+     * <p>\n+     * '1' is converted to 1\n+     * </p>\n+     * \n+     * @param hexDigit the hexadecimal digit to convert\n+     * @return an int equals to <code>hexDigit</code>\n+     */\n+    public static int hexDigitToInt(char hexDigit) {\n+        switch (hexDigit) {\n+        case '0':\n+            return 0;\n+        case '1':\n+            return 1;\n+        case '2':\n+            return 2;\n+        case '3':\n+            return 3;\n+        case '4':\n+            return 4;\n+        case '5':\n+            return 5;\n+        case '6':\n+            return 6;\n+        case '7':\n+            return 7;\n+        case '8':\n+            return 8;\n+        case '9':\n+            return 9;\n+        case 'a':// fall through\n+        case 'A':\n+            return 10;\n+        case 'b':// fall through\n+        case 'B':\n+            return 11;\n+        case 'c':// fall through\n+        case 'C':\n+            return 12;\n+        case 'd':// fall through\n+        case 'D':\n+            return 13;\n+        case 'e':// fall through\n+        case 'E':\n+            return 14;\n+        case 'f':// fall through\n+        case 'F':\n+            return 15;\n+        default:\n+            throw new IllegalArgumentException(\"Cannot interpret '\"\n+                + hexDigit\n+                + \"' as a hexadecimal digit\");\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a hexadecimal digit into an int using the Msb0 bit ordering.\n+     * </p>\n+     * <p>\n+     * '1' is converted to 8\n+     * </p>\n+     * \n+     * @param hexDigit the hexadecimal digit to convert\n+     * @return an int equals to <code>hexDigit</code>\n+     */\n+    public static int hexDigitM0ToInt(char hexDigit) {\n+        switch (hexDigit) {\n+        case '0':\n+            return 0x0;\n+        case '1':\n+            return 0x8;\n+        case '2':\n+            return 0x4;\n+        case '3':\n+            return 0xC;\n+        case '4':\n+            return 0x2;\n+        case '5':\n+            return 0xA;\n+        case '6':\n+            return 0x6;\n+        case '7':\n+            return 0xE;\n+        case '8':\n+            return 0x1;\n+        case '9':\n+            return 0x9;\n+        case 'a':// fall through\n+        case 'A':\n+            return 0x5;\n+        case 'b':// fall through\n+        case 'B':\n+            return 0xD;\n+        case 'c':// fall through\n+        case 'C':\n+            return 0x3;\n+        case 'd':// fall through\n+        case 'D':\n+            return 0xB;\n+        case 'e':// fall through\n+        case 'E':\n+            return 0x7;\n+        case 'f':// fall through\n+        case 'F':\n+            return 0xF;\n+        default:\n+            throw new IllegalArgumentException(\"Cannot interpret '\"\n+                + hexDigit\n+                + \"' as a hexadecimal digit\");\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a hexadecimal digit into binary using the default (Lsb0) bit ordering.\n+     * </p>\n+     * <p>\n+     * '1' is converted as follow: (1, 0, 0, 0)\n+     * </p>\n+     * \n+     * @param hexDigit the hexadecimal digit to convert\n+     * @return a boolean array with the binary representation of <code>hexDigit</code>\n+     */\n+    public static boolean[] hexDigitToBools(char hexDigit) {\n+        switch (hexDigit) {\n+        case '0':\n+            return new boolean[]{false, false, false, false};\n+        case '1':\n+            return new boolean[]{true, false, false, false};\n+        case '2':\n+            return new boolean[]{false, true, false, false};\n+        case '3':\n+            return new boolean[]{true, true, false, false};\n+        case '4':\n+            return new boolean[]{false, false, true, false};\n+        case '5':\n+            return new boolean[]{true, false, true, false};\n+        case '6':\n+            return new boolean[]{false, true, true, false};\n+        case '7':\n+            return new boolean[]{true, true, true, false};\n+        case '8':\n+            return new boolean[]{false, false, false, true};\n+        case '9':\n+            return new boolean[]{true, false, false, true};\n+        case 'a':// fall through\n+        case 'A':\n+            return new boolean[]{false, true, false, true};\n+        case 'b':// fall through\n+        case 'B':\n+            return new boolean[]{true, true, false, true};\n+        case 'c':// fall through\n+        case 'C':\n+            return new boolean[]{false, false, true, true};\n+        case 'd':// fall through\n+        case 'D':\n+            return new boolean[]{true, false, true, true};\n+        case 'e':// fall through\n+        case 'E':\n+            return new boolean[]{false, true, true, true};\n+        case 'f':// fall through\n+        case 'F':\n+            return new boolean[]{true, true, true, true};\n+        default:\n+            throw new IllegalArgumentException(\"Cannot interpret '\"\n+                + hexDigit\n+                + \"' as a hexadecimal digit\");\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a hexadecimal digit into binary using the Msb0 bit ordering.\n+     * </p>\n+     * <p>\n+     * '1' is converted as follow: (0, 0, 0, 1)\n+     * </p>\n+     * \n+     * @param hexDigit the hexadecimal digit to convert\n+     * @return a boolean array with the binary representation of <code>hexDigit</code>\n+     */\n+    public static boolean[] hexDigitM0ToBools(char hexDigit) {\n+        switch (hexDigit) {\n+        case '0':\n+            return new boolean[]{false, false, false, false};\n+        case '1':\n+            return new boolean[]{false, false, false, true};\n+        case '2':\n+            return new boolean[]{false, false, true, false};\n+        case '3':\n+            return new boolean[]{false, false, true, true};\n+        case '4':\n+            return new boolean[]{false, true, false, false};\n+        case '5':\n+            return new boolean[]{false, true, false, true};\n+        case '6':\n+            return new boolean[]{false, true, true, false};\n+        case '7':\n+            return new boolean[]{false, true, true, true};\n+        case '8':\n+            return new boolean[]{true, false, false, false};\n+        case '9':\n+            return new boolean[]{true, false, false, true};\n+        case 'a':// fall through\n+        case 'A':\n+            return new boolean[]{true, false, true, false};\n+        case 'b':// fall through\n+        case 'B':\n+            return new boolean[]{true, false, true, true};\n+        case 'c':// fall through\n+        case 'C':\n+            return new boolean[]{true, true, false, false};\n+        case 'd':// fall through\n+        case 'D':\n+            return new boolean[]{true, true, false, true};\n+        case 'e':// fall through\n+        case 'E':\n+            return new boolean[]{true, true, true, false};\n+        case 'f':// fall through\n+        case 'F':\n+            return new boolean[]{true, true, true, true};\n+        default:\n+            throw new IllegalArgumentException(\"Cannot interpret '\"\n+                + hexDigit\n+                + \"' as a hexadecimal digit\");\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a boolean array to a hexadecimal digit using the default (Lsb0) bit ordering.\n+     * </p>\n+     * <p>\n+     * (1, 0, 0, 0) is converted as follow: '1'\n+     * </p>\n+     * \n+     * @param src the boolean array to convert\n+     * @return a hexadecimal digit representing the selected bits\n+     */\n+    public static char boolsToHexDigit(boolean[] src) {\n+        return boolsToHexDigit(src, 0);\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a boolean array to a hexadecimal digit using the default (Lsb0) bit ordering.\n+     * </p>\n+     * <p>\n+     * (1, 0, 0, 0) is converted as follow: '1'\n+     * </p>\n+     * \n+     * @param src the boolean array to convert\n+     * @param srcPos the position of the lsb to start the conversion\n+     * @return a hexadecimal digit representing the selected bits\n+     */\n+    public static char boolsToHexDigit(boolean[] src, int srcPos) {\n+        if (src.length > srcPos + 3 && src[srcPos + 3]) {\n+            if (src.length > srcPos + 2 && src[srcPos + 2]) {\n+                if (src.length > srcPos + 1 && src[srcPos + 1]) {\n+                    if (src[srcPos]) return 'F';\n+                    else return 'E';\n+                } else {\n+                    if (src[srcPos]) return 'D';\n+                    else return 'C';\n+                }\n+            } else {\n+                if (src.length > srcPos + 1 && src[srcPos + 1]) {\n+                    if (src[srcPos]) return 'B';\n+                    else return 'A';\n+                } else {\n+                    if (src[srcPos]) return '9';\n+                    else return '8';\n+                }\n+            }\n+        } else {\n+            if (src.length > srcPos + 2 && src[srcPos + 2]) {\n+                if (src.length > srcPos + 1 && src[srcPos + 1]) {\n+                    if (src[srcPos]) return '7';\n+                    else return '6';\n+                } else {\n+                    if (src[srcPos]) return '5';\n+                    else return '4';\n+                }\n+            } else {\n+                if (src.length > srcPos + 1 && src[srcPos + 1]) {\n+                    if (src[srcPos]) return '3';\n+                    else return '2';\n+                } else {\n+                    if (src[srcPos]) return '1';\n+                    else return '0';\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a boolean array to a hexadecimal digit using the Msb0 bit ordering.\n+     * </p>\n+     * <p>\n+     * (1, 0, 0, 0) is converted as follow: '8'\n+     * </p>\n+     * \n+     * @param src the boolean array to convert\n+     * @return a hexadecimal digit representing the selected bits\n+     * @warning src.length must be >= 4.\n+     */\n+    public static char boolsToHexDigitM0_4bits(boolean[] src) {\n+        return boolsToHexDigitM0_4bits(src, 0);\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a boolean array to a hexadecimal digit using the Msb0 bit ordering.\n+     * </p>\n+     * <p>\n+     * (1, 0, 0, 0) is converted as follow: '8' (1,0,0,1,1,0,1,0) with srcPos = 3 is converted\n+     * to 'D'\n+     * </p>\n+     * \n+     * @param src the boolean array to convert\n+     * @param srcPos the position of the lsb to start the conversion\n+     * @return a hexadecimal digit representing the selected bits\n+     * @warning src.length must be 8 at most.\n+     * @warning srcPos+4 must be <= src.length.\n+     */\n+    public static char boolsToHexDigitM0_4bits(boolean[] src, int srcPos) {\n+        if (src.length > 8)\n+            throw new IllegalArgumentException(\"src.length>8: src.length=\" + src.length);\n+        if (src.length - srcPos < 4)\n+            throw new IllegalArgumentException(\"src.length-srcPos<4: src.length=\"\n+                + src.length\n+                + \", srcPos=\"\n+                + srcPos);\n+        if (src[srcPos + 3]) {\n+            if (src[srcPos + 2]) {\n+                if (src[srcPos + 1]) {\n+                    if (src[srcPos]) return 'F';\n+                    else return '7';\n+                } else {\n+                    if (src[srcPos]) return 'B';\n+                    else return '3';\n+                }\n+            } else {\n+                if (src[srcPos + 1]) {\n+                    if (src[srcPos]) return 'D';\n+                    else return '5';\n+                } else {\n+                    if (src[srcPos]) return '9';\n+                    else return '1';\n+                }\n+            }\n+        } else {\n+            if (src[srcPos + 2]) {\n+                if (src[srcPos + 1]) {\n+                    if (src[srcPos]) return 'E';\n+                    else return '6';\n+                } else {\n+                    if (src[srcPos]) return 'A';\n+                    else return '2';\n+                }\n+            } else {\n+                if (src[srcPos + 1]) {\n+                    if (src[srcPos]) return 'C';\n+                    else return '4';\n+                } else {\n+                    if (src[srcPos]) return '8';\n+                    else return '0';\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts the first 4 bits of a boolean array in big endian Msb0 bit ordering to a\n+     * hexadecimal digit.\n+     * </p>\n+     * <p>\n+     * (1, 0, 0, 0) is converted as follow: '8' (1,0,0,0,0,0,0,0, 0,0,0,0,0,1,0,0) is converted\n+     * to '4'\n+     * </p>\n+     * \n+     * @param src the boolean array to convert\n+     * @return a hexadecimal digit representing the selected bits\n+     */\n+    public static char boolsBeM0ToHexDigit(boolean[] src) {\n+        return boolsBeM0ToHexDigit(src, 0);\n+    }\n+\n+    /**\n+     * <p>\n+     * Converta a part of a boolean array in big endian Msb0 bit ordering to a hexadecimal\n+     * digit.\n+     * </p>\n+     * <p>\n+     * (1, 0, 0, 0) with srcPos = 0 is converted as follow: '8' (1,0,0,0,0,0,0,0,\n+     * 0,0,0,1,0,1,0,0) with srcPos = 2 is converted to '5'\n+     * </p>\n+     * \n+     * @param src the boolean array to convert\n+     * @param srcPos the position of the lsb to start the conversion\n+     * @return a hexadecimal digit representing the selected bits\n+     */\n+    public static char boolsBeM0ToHexDigit(boolean[] src, int srcPos) {\n+        int beSrcPos = src.length - 1 - srcPos;\n+        int srcLen = Math.min(4, beSrcPos + 1);\n+        boolean[] paddedSrc = new boolean[4];\n+        System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);\n+        src = paddedSrc;\n+        srcPos = 0;\n+        if (src[srcPos]) {\n+            if (src.length > srcPos + 1 && src[srcPos + 1]) {\n+                if (src.length > srcPos + 2 && src[srcPos + 2]) {\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) return 'F';\n+                    else return 'E';\n+                } else {\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) return 'D';\n+                    else return 'C';\n+                }\n+            } else {\n+                if (src.length > srcPos + 2 && src[srcPos + 2]) {\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) return 'B';\n+                    else return 'A';\n+                } else {\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) return '9';\n+                    else return '8';\n+                }\n+            }\n+        } else {\n+            if (src.length > srcPos + 1 && src[srcPos + 1]) {\n+                if (src.length > srcPos + 2 && src[srcPos + 2]) {\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) return '7';\n+                    else return '6';\n+                } else {\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) return '5';\n+                    else return '4';\n+                }\n+            } else {\n+                if (src.length > srcPos + 2 && src[srcPos + 2]) {\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) return '3';\n+                    else return '2';\n+                } else {\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) return '1';\n+                    else return '0';\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts the 4 lsb of an int to a hexadecimal digit.\n+     * </p>\n+     * <p>\n+     * 0 returns '0'\n+     * </p>\n+     * <p>\n+     * 1 returns '1'\n+     * </p>\n+     * <p>\n+     * 10 returns 'A' and so on...\n+     * </p>\n+     * \n+     * @param nibble the int to convert, value outside of the range [0:15] are not allowed.\n+     * @return a hexadecimal digit representing the 4 lsb of <code>nibble</code>\n+     */\n+    public static char intToHexDigit(int nibble) {\n+        switch (nibble) {\n+        case 0x0:\n+            return '0';\n+        case 0x1:\n+            return '1';\n+        case 0x2:\n+            return '2';\n+        case 0x3:\n+            return '3';\n+        case 0x4:\n+            return '4';\n+        case 0x5:\n+            return '5';\n+        case 0x6:\n+            return '6';\n+        case 0x7:\n+            return '7';\n+        case 0x8:\n+            return '8';\n+        case 0x9:\n+            return '9';\n+        case 0xA:\n+            return 'A';\n+        case 0xB:\n+            return 'B';\n+        case 0xC:\n+            return 'C';\n+        case 0xD:\n+            return 'D';\n+        case 0xE:\n+            return 'E';\n+        case 0xF:\n+            return 'F';\n+        default:\n+            throw new java.lang.IllegalArgumentException(\"nibble value not between 0 and 15: \"\n+                + nibble);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts the 4 lsb of an int to a hexadecimal digit encoded using the Msb0 bit ordering.\n+     * </p>\n+     * <p>\n+     * 0 returns '0'\n+     * </p>\n+     * <p>\n+     * 1 returns '8'\n+     * </p>\n+     * <p>\n+     * 10 returns '5' and so on...\n+     * </p>\n+     * \n+     * @param nibble the int to convert, value outside of the range [0:15] are not allowed.\n+     * @return a hexadecimal digit representing the 4 lsb of <code>nibble</code>\n+     */\n+    public static char intToHexDigitM0(int nibble) {\n+        switch (nibble) {\n+        case 0x0:\n+            return '0';\n+        case 0x1:\n+            return '8';\n+        case 0x2:\n+            return '4';\n+        case 0x3:\n+            return 'C';\n+        case 0x4:\n+            return '2';\n+        case 0x5:\n+            return 'A';\n+        case 0x6:\n+            return '6';\n+        case 0x7:\n+            return 'E';\n+        case 0x8:\n+            return '1';\n+        case 0x9:\n+            return '9';\n+        case 0xA:\n+            return '5';\n+        case 0xB:\n+            return 'D';\n+        case 0xC:\n+            return '3';\n+        case 0xD:\n+            return 'B';\n+        case 0xE:\n+            return '7';\n+        case 0xF:\n+            return 'F';\n+        default:\n+            throw new java.lang.IllegalArgumentException(\"nibble value not between 0 and 15: \"\n+                + nibble);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of int into a long using the default (little endian, Lsb0) byte and bit\n+     * ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in int unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination long\n+     * @param dstPos the position of the lsb, in bits, in the result long\n+     * @param nInts the number of int to convert\n+     * @return a long containing the selected bits\n+     */\n+    public static long intsToLong(int[] src, int srcPos, long dstInit, int dstPos, int nInts) {\n+        if (0 == nInts) return dstInit;\n+        long out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nInts; i++ ) {\n+            shift = i * 32 + dstPos;\n+            long bits = ((0xffffffffL & src[i + srcPos]) << shift);\n+            long mask = (0xffffffffL << shift);\n+            out = ((out & ~mask) | bits);\n+        }\n+        if (shift >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nInts-1)*32+dstPos is greather or equal to than 64\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of short into a long using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in short unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination long\n+     * @param dstPos the position of the lsb, in bits, in the result long\n+     * @param nShorts the number of short to convert\n+     * @return a long containing the selected bits\n+     */\n+    public static long shortsToLong(short[] src, int srcPos, long dstInit, int dstPos,\n+        int nShorts) {\n+        if (0 == nShorts) return dstInit;\n+        long out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nShorts; i++ ) {\n+            shift = i * 16 + dstPos;\n+            long bits = ((0xffffL & src[i + srcPos]) << shift);\n+            long mask = (0xffffL << shift);\n+            out = ((out & ~mask) | bits);\n+        }\n+        if (shift >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nShorts-1)*16+dstPos is greather or equal to than 64\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of short into a int using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in short unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination int\n+     * @param dstPos the position of the lsb, in bits, in the result int\n+     * @param nShorts the number of short to convert\n+     * @return a int containing the selected bits\n+     */\n+    public static int shortsToInt(short[] src, int srcPos, int dstInit, int dstPos, int nShorts) {\n+        if (0 == nShorts) return dstInit;\n+        int out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nShorts; i++ ) {\n+            shift = i * 16 + dstPos;\n+            int bits = ((0xffff & src[i + srcPos]) << shift);\n+            int mask = (0xffff << shift);\n+            out = ((out & ~mask) | bits);\n+        }\n+        if (shift >= 32)\n+            throw new IllegalArgumentException(\n+                \"(nShorts-1)*16+dstPos is greather or equal to than 32\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of byte into a long using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in byte unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination long\n+     * @param dstPos the position of the lsb, in bits, in the result long\n+     * @param nBytes the number of byte to convert\n+     * @return a long containing the selected bits\n+     */\n+    public static long bytesToLong(byte[] src, int srcPos, long dstInit, int dstPos, int nBytes) {\n+        if (0 == nBytes) return dstInit;\n+        long out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nBytes; i++ ) {\n+            shift = i * 8 + dstPos;\n+            long bits = ((0xffL & src[i + srcPos]) << shift);\n+            long mask = (0xffL << shift);\n+            out = ((out & ~mask) | bits);\n+        }\n+        if (shift >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nBytes-1)*8+dstPos is greather or equal to than 64\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of byte into a int using the default (little endian, Lsb0) byte and bit\n+     * ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in byte unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination int\n+     * @param dstPos the position of the lsb, in bits, in the result int\n+     * @param nBytes the number of byte to convert\n+     * @return a int containing the selected bits\n+     */\n+    public static int bytesToInt(byte[] src, int srcPos, int dstInit, int dstPos, int nBytes) {\n+        if (0 == nBytes) return dstInit;\n+        int out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nBytes; i++ ) {\n+            shift = i * 8 + dstPos;\n+            int bits = ((0xff & src[i + srcPos]) << shift);\n+            int mask = (0xff << shift);\n+            out = ((out & ~mask) | bits);\n+        }\n+        if (shift >= 32)\n+            throw new IllegalArgumentException(\n+                \"(nBytes-1)*8+dstPos is greather or equal to than 32\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of byte into a short using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in byte unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination short\n+     * @param dstPos the position of the lsb, in bits, in the result short\n+     * @param nBytes the number of byte to convert\n+     * @return a short containing the selected bits\n+     */\n+    public static short bytesToShort(byte[] src, int srcPos, short dstInit, int dstPos,\n+        int nBytes) {\n+        if (0 == nBytes) return dstInit;\n+        short out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nBytes; i++ ) {\n+            shift = i * 8 + dstPos;\n+            short bits = (short)(((short)(0xff & src[i + srcPos])) << shift);\n+            short mask = (short)(((short)0xff) << shift);\n+            out = (short)((out & ~mask) | bits);\n+        }\n+        if (shift >= 16)\n+            throw new IllegalArgumentException(\n+                \"(nBytes-1)*8+dstPos is greather or equal to than 16\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of Char into a long using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in Char unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination long\n+     * @param dstPos the position of the lsb, in bits, in the result long\n+     * @param nHexs the number of Char to convert\n+     * @return a long containing the selected bits\n+     */\n+    public static long hexsToLong(String src, int srcPos, long dstInit, int dstPos, int nHexs) {\n+        if (0 == nHexs) return dstInit;\n+        long out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nHexs; i++ ) {\n+            shift = i * 4 + dstPos;\n+            long bits = ((0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift);\n+            long mask = (0xfL << shift);\n+            out = ((out & ~mask) | bits);\n+        }\n+        if (shift >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+dstPos is greather or equal to than 64\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of Char into a int using the default (little endian, Lsb0) byte and bit\n+     * ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in Char unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination int\n+     * @param dstPos the position of the lsb, in bits, in the result int\n+     * @param nHexs the number of Char to convert\n+     * @return a int containing the selected bits\n+     */\n+    public static int hexsToInt(String src, int srcPos, int dstInit, int dstPos, int nHexs) {\n+        if (0 == nHexs) return dstInit;\n+        int out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nHexs; i++ ) {\n+            shift = i * 4 + dstPos;\n+            int bits = ((0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift);\n+            int mask = (0xf << shift);\n+            out = ((out & ~mask) | bits);\n+        }\n+        if (shift >= 32)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+dstPos is greather or equal to than 32\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of Char into a short using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in Char unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination short\n+     * @param dstPos the position of the lsb, in bits, in the result short\n+     * @param nHexs the number of Char to convert\n+     * @return a short containing the selected bits\n+     */\n+    public static short hexsToShort(String src, int srcPos, short dstInit, int dstPos, int nHexs) {\n+        if (0 == nHexs) return dstInit;\n+        short out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nHexs; i++ ) {\n+            shift = i * 4 + dstPos;\n+            short bits = (short)(((short)(0xf & hexDigitToInt(src.charAt(i + srcPos)))) << shift);\n+            short mask = (short)(((short)0xf) << shift);\n+            out = (short)((out & ~mask) | bits);\n+        }\n+        if (shift >= 16)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+dstPos is greather or equal to than 16\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of Char into a byte using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in Char unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination byte\n+     * @param dstPos the position of the lsb, in bits, in the result byte\n+     * @param nHexs the number of Char to convert\n+     * @return a byte containing the selected bits\n+     */\n+    public static byte hexsToByte(String src, int srcPos, byte dstInit, int dstPos, int nHexs) {\n+        if (0 == nHexs) return dstInit;\n+        byte out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nHexs; i++ ) {\n+            shift = i * 4 + dstPos;\n+            byte bits = (byte)(((byte)(0xf & hexDigitToInt(src.charAt(i + srcPos)))) << shift);\n+            byte mask = (byte)(((byte)0xf) << shift);\n+            out = (byte)((out & ~mask) | bits);\n+        }\n+        if (shift >= 8)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+dstPos is greather or equal to than 8\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of boolean into a long using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in boolean unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination long\n+     * @param dstPos the position of the lsb, in bits, in the result long\n+     * @param nBools the number of boolean to convert\n+     * @return a long containing the selected bits\n+     */\n+    public static long boolsToLong(boolean[] src, int srcPos, long dstInit, int dstPos,\n+        int nBools) {\n+        if (0 == nBools) return dstInit;\n+        long out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nBools; i++ ) {\n+            shift = i * 1 + dstPos;\n+            long bits = ((0x1L & ((src[i + srcPos]) ? 1 : 0)) << shift);\n+            long mask = (0x1L << shift);\n+            out = ((out & ~mask) | bits);\n+        }\n+        if (shift >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nBools-1)*1+dstPos is greather or equal to than 64\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of boolean into a int using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in boolean unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination int\n+     * @param dstPos the position of the lsb, in bits, in the result int\n+     * @param nBools the number of boolean to convert\n+     * @return a int containing the selected bits\n+     */\n+    public static int boolsToInt(boolean[] src, int srcPos, int dstInit, int dstPos, int nBools) {\n+        if (0 == nBools) return dstInit;\n+        int out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nBools; i++ ) {\n+            shift = i * 1 + dstPos;\n+            int bits = ((0x1 & ((src[i + srcPos]) ? 1 : 0)) << shift);\n+            int mask = (0x1 << shift);\n+            out = ((out & ~mask) | bits);\n+        }\n+        if (shift >= 32)\n+            throw new IllegalArgumentException(\n+                \"(nBools-1)*1+dstPos is greather or equal to than 32\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of boolean into a short using the default (little endian, Lsb0) byte\n+     * and bit ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in boolean unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination short\n+     * @param dstPos the position of the lsb, in bits, in the result short\n+     * @param nBools the number of boolean to convert\n+     * @return a short containing the selected bits\n+     */\n+    public static short boolsToShort(boolean[] src, int srcPos, short dstInit, int dstPos,\n+        int nBools) {\n+        if (0 == nBools) return dstInit;\n+        short out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nBools; i++ ) {\n+            shift = i * 1 + dstPos;\n+            short bits = (short)(((short)(0x1 & ((src[i + srcPos]) ? 1 : 0))) << shift);\n+            short mask = (short)(((short)0x1) << shift);\n+            out = (short)((out & ~mask) | bits);\n+        }\n+        if (shift >= 16)\n+            throw new IllegalArgumentException(\n+                \"(nBools-1)*1+dstPos is greather or equal to than 16\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts an array of boolean into a byte using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int array to convert\n+     * @param srcPos the position in <code>src</code>, in boolean unit, from where to start the\n+     *            conversion\n+     * @param dstInit initial value of the destination byte\n+     * @param dstPos the position of the lsb, in bits, in the result byte\n+     * @param nBools the number of boolean to convert\n+     * @return a byte containing the selected bits\n+     */\n+    public static byte boolsToByte(boolean[] src, int srcPos, byte dstInit, int dstPos,\n+        int nBools) {\n+        if (0 == nBools) return dstInit;\n+        byte out = dstInit;\n+        int shift = 0;\n+        for (int i = 0; i < nBools; i++ ) {\n+            shift = i * 1 + dstPos;\n+            byte bits = (byte)(((byte)(0x1 & ((src[i + srcPos]) ? 1 : 0))) << shift);\n+            byte mask = (byte)(((byte)0x1) << shift);\n+            out = (byte)((out & ~mask) | bits);\n+        }\n+        if (shift >= 8)\n+            throw new IllegalArgumentException(\n+                \"(nBools-1)*1+dstPos is greather or equal to than 8\");\n+        return out;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a long into an array of int using the default (little endian, Lsb0) byte and bit\n+     * ordering.\n+     * </p>\n+     * \n+     * @param src the long to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dst the destination array\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nInts the number of int to copy to <code>dst</code>. must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static int[] longToInts(long src, int srcPos, int[] dst, int dstPos, int nInts) {\n+        if (0 == nInts) return dst;\n+        int shift = 0;\n+        assert ((nInts - 1) * 32 < 64 - srcPos);\n+        for (int i = 0; i < nInts; i++ ) {\n+            shift = i * 32 + srcPos;\n+            Long bits = (long)(0xffffffff & (src >> shift));\n+            dst[dstPos + i] = bits.intValue();\n+        }\n+        return dst;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a long into an array of short using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the long to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dst the destination array\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nShorts the number of short to copy to <code>dst</code>. must be smaller or equal\n+     *            to the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static short[] longToShorts(long src, int srcPos, short[] dst, int dstPos,\n+        int nShorts) {\n+        if (0 == nShorts) return dst;\n+        int shift = 0;\n+        assert ((nShorts - 1) * 16 < 64 - srcPos);\n+        for (int i = 0; i < nShorts; i++ ) {\n+            shift = i * 16 + srcPos;\n+            Long bits = (long)(0xffff & (src >> shift));\n+            dst[dstPos + i] = bits.shortValue();\n+        }\n+        return dst;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a int into an array of short using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dst the destination array\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nShorts the number of short to copy to <code>dst</code>. must be smaller or equal\n+     *            to the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static short[] intToShorts(int src, int srcPos, short[] dst, int dstPos, int nShorts) {\n+        if (0 == nShorts) return dst;\n+        int shift = 0;\n+        assert ((nShorts - 1) * 16 < 32 - srcPos);\n+        for (int i = 0; i < nShorts; i++ ) {\n+            shift = i * 16 + srcPos;\n+            Integer bits = (int)(0xffff & (src >> shift));\n+            dst[dstPos + i] = bits.shortValue();\n+        }\n+        return dst;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a long into an array of byte using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the long to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dst the destination array\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nBytes the number of byte to copy to <code>dst</code>. must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static byte[] longToBytes(long src, int srcPos, byte[] dst, int dstPos, int nBytes) {\n+        if (0 == nBytes) return dst;\n+        int shift = 0;\n+        assert ((nBytes - 1) * 8 < 64 - srcPos);\n+        for (int i = 0; i < nBytes; i++ ) {\n+            shift = i * 8 + srcPos;\n+            Long bits = (long)(0xff & (src >> shift));\n+            dst[dstPos + i] = bits.byteValue();\n+        }\n+        return dst;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a int into an array of byte using the default (little endian, Lsb0) byte and bit\n+     * ordering.\n+     * </p>\n+     * \n+     * @param src the int to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dst the destination array\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nBytes the number of byte to copy to <code>dst</code>. must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static byte[] intToBytes(int src, int srcPos, byte[] dst, int dstPos, int nBytes) {\n+        if (0 == nBytes) return dst;\n+        int shift = 0;\n+        assert ((nBytes - 1) * 8 < 32 - srcPos);\n+        for (int i = 0; i < nBytes; i++ ) {\n+            shift = i * 8 + srcPos;\n+            Integer bits = (int)(0xff & (src >> shift));\n+            dst[dstPos + i] = bits.byteValue();\n+        }\n+        return dst;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a short into an array of byte using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the short to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dst the destination array\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nBytes the number of byte to copy to <code>dst</code>. must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static byte[] shortToBytes(short src, int srcPos, byte[] dst, int dstPos, int nBytes) {\n+        if (0 == nBytes) return dst;\n+        int shift = 0;\n+        assert ((nBytes - 1) * 8 < 16 - srcPos);\n+        for (int i = 0; i < nBytes; i++ ) {\n+            shift = i * 8 + srcPos;\n+            Short bits = (short)(0xff & (src >> shift));\n+            dst[dstPos + i] = bits.byteValue();\n+        }\n+        return dst;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a long into an array of Char using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the long to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dstInit the initial value for the result String\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nHexs the number of Char to copy to <code>dst</code>. must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static String longToHexs(long src, int srcPos, String dstInit, int dstPos, int nHexs) {\n+        if (0 == nHexs) return dstInit;\n+        StringBuffer sb = new StringBuffer(dstInit);\n+        int shift = 0;\n+        assert ((nHexs - 1) * 4 < 64 - srcPos);\n+        for (int i = 0; i < nHexs; i++ ) {\n+            shift = i * 4 + srcPos;\n+            int bits = (int)(0xF & (src >> shift));\n+            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a int into an array of Char using the default (little endian, Lsb0) byte and bit\n+     * ordering.\n+     * </p>\n+     * \n+     * @param src the int to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dstInit the initial value for the result String\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nHexs the number of Char to copy to <code>dst</code>. must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static String intToHexs(int src, int srcPos, String dstInit, int dstPos, int nHexs) {\n+        if (0 == nHexs) return dstInit;\n+        StringBuffer sb = new StringBuffer(dstInit);\n+        int shift = 0;\n+        assert ((nHexs - 1) * 4 < 32 - srcPos);\n+        for (int i = 0; i < nHexs; i++ ) {\n+            shift = i * 4 + srcPos;\n+            int bits = 0xF & (src >> shift);\n+            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a short into an array of Char using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the short to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dstInit the initial value for the result String\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nHexs the number of Char to copy to <code>dst</code>. must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static String shortToHexs(short src, int srcPos, String dstInit, int dstPos,\n+        int nHexs) {\n+        if (0 == nHexs) return dstInit;\n+        StringBuffer sb = new StringBuffer(dstInit);\n+        int shift = 0;\n+        assert ((nHexs - 1) * 4 < 16 - srcPos);\n+        for (int i = 0; i < nHexs; i++ ) {\n+            shift = i * 4 + srcPos;\n+            int bits = 0xF & (src >> shift);\n+            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a byte into an array of Char using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the byte to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dstInit the initial value for the result String\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nHexs the number of Char to copy to <code>dst</code>. must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static String byteToHexs(byte src, int srcPos, String dstInit, int dstPos, int nHexs) {\n+        if (0 == nHexs) return dstInit;\n+        StringBuffer sb = new StringBuffer(dstInit);\n+        int shift = 0;\n+        assert ((nHexs - 1) * 4 < 8 - srcPos);\n+        for (int i = 0; i < nHexs; i++ ) {\n+            shift = i * 4 + srcPos;\n+            int bits = 0xF & (src >> shift);\n+            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a long into an array of boolean using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the long to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dst the destination array\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nBools the number of boolean to copy to <code>dst</code>. must be smaller or equal\n+     *            to the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static boolean[] longToBools(long src, int srcPos, boolean[] dst, int dstPos,\n+        int nBools) {\n+        if (0 == nBools) return dst;\n+        int shift = 0;\n+        assert ((nBools - 1) * 1 < 64 - srcPos);\n+        for (int i = 0; i < nBools; i++ ) {\n+            shift = i * 1 + srcPos;\n+            Long bits = (long)(0x1 & (src >> shift));\n+            dst[dstPos + i] = (bits != 0);\n+        }\n+        return dst;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a int into an array of boolean using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the int to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dst the destination array\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nBools the number of boolean to copy to <code>dst</code>. must be smaller or equal\n+     *            to the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static boolean[] intToBools(int src, int srcPos, boolean[] dst, int dstPos,\n+        int nBools) {\n+        if (0 == nBools) return dst;\n+        int shift = 0;\n+        assert ((nBools - 1) * 1 < 32 - srcPos);\n+        for (int i = 0; i < nBools; i++ ) {\n+            shift = i * 1 + srcPos;\n+            Integer bits = (int)(0x1 & (src >> shift));\n+            dst[dstPos + i] = (bits != 0);\n+        }\n+        return dst;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a short into an array of boolean using the default (little endian, Lsb0) byte\n+     * and bit ordering.\n+     * </p>\n+     * \n+     * @param src the short to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dst the destination array\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nBools the number of boolean to copy to <code>dst</code>. must be smaller or equal\n+     *            to the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static boolean[] shortToBools(short src, int srcPos, boolean[] dst, int dstPos,\n+        int nBools) {\n+        if (0 == nBools) return dst;\n+        int shift = 0;\n+        assert ((nBools - 1) * 1 < 16 - srcPos);\n+        for (int i = 0; i < nBools; i++ ) {\n+            shift = i * 1 + srcPos;\n+            Short bits = (short)(0x1 & (src >> shift));\n+            dst[dstPos + i] = (bits != 0);\n+        }\n+        return dst;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts a byte into an array of boolean using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the byte to convert\n+     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     *            conversion\n+     * @param dst the destination array\n+     * @param dstPos the position in <code>dst</code> where to copy the result\n+     * @param nBools the number of boolean to copy to <code>dst</code>. must be smaller or equal\n+     *            to the width of the input (from srcPos to msb)\n+     * @return <code>dst</code>\n+     */\n+    public static boolean[] byteToBools(byte src, int srcPos, boolean[] dst, int dstPos,\n+        int nBools) {\n+        if (0 == nBools) return dst;\n+        int shift = 0;\n+        assert ((nBools - 1) * 1 < 8 - srcPos);\n+        for (int i = 0; i < nBools; i++ ) {\n+            shift = i * 1 + srcPos;\n+            Byte bits = (byte)(0x1 & (src >> shift));\n+            dst[dstPos + i] = (bits != 0);\n+        }\n+        return dst;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/ConversionTest.java\n+/*******************************************************************************\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *******************************************************************************/\n+package org.apache.commons.lang3;\n+\n+import junit.framework.TestCase;\n+import java.lang.Throwable;\n+import java.lang.reflect.Method;\n+\n+\n+/**\n+ * Unit tests {@link Conversion}.\n+ * \n+ * @version $Id$\n+ */\n+\n+public class ConversionTest extends TestCase {\n+\n+    /**\n+     * convert an hexadecimal digit into an int using the default (Lsb0) bit ordering.\n+     * <p>\n+     * '1' is converted to 1\n+     * \n+     * @param hexDigit the hexadecimal digit to convert\n+     * @return an int equals to <code>hexDigit</code>\n+     */\n+    public void testHexDigitToInt() throws Exception {\n+        assertEquals(0, Conversion.hexDigitToInt('0'));\n+        assertEquals(1, Conversion.hexDigitToInt('1'));\n+        assertEquals(2, Conversion.hexDigitToInt('2'));\n+        assertEquals(3, Conversion.hexDigitToInt('3'));\n+        assertEquals(4, Conversion.hexDigitToInt('4'));\n+        assertEquals(5, Conversion.hexDigitToInt('5'));\n+        assertEquals(6, Conversion.hexDigitToInt('6'));\n+        assertEquals(7, Conversion.hexDigitToInt('7'));\n+        assertEquals(8, Conversion.hexDigitToInt('8'));\n+        assertEquals(9, Conversion.hexDigitToInt('9'));\n+        assertEquals(10, Conversion.hexDigitToInt('A'));\n+        assertEquals(10, Conversion.hexDigitToInt('a'));\n+        assertEquals(11, Conversion.hexDigitToInt('B'));\n+        assertEquals(11, Conversion.hexDigitToInt('b'));\n+        assertEquals(12, Conversion.hexDigitToInt('C'));\n+        assertEquals(12, Conversion.hexDigitToInt('c'));\n+        assertEquals(13, Conversion.hexDigitToInt('D'));\n+        assertEquals(13, Conversion.hexDigitToInt('d'));\n+        assertEquals(14, Conversion.hexDigitToInt('E'));\n+        assertEquals(14, Conversion.hexDigitToInt('e'));\n+        assertEquals(15, Conversion.hexDigitToInt('F'));\n+        assertEquals(15, Conversion.hexDigitToInt('f'));\n+    }\n+\n+    /**\n+     * convert an hexadecimal digit into an int using the Msb0 bit ordering.\n+     * <p>\n+     * '1' is converted to 8\n+     * \n+     * @param hexDigit the hexadecimal digit to convert\n+     * @return an int equals to <code>hexDigit</code>\n+     */\n+    public void testHexDigitM0ToInt() throws Exception {\n+        assertEquals(0x0, Conversion.hexDigitM0ToInt('0'));\n+        assertEquals(0x8, Conversion.hexDigitM0ToInt('1'));\n+        assertEquals(0x4, Conversion.hexDigitM0ToInt('2'));\n+        assertEquals(0xC, Conversion.hexDigitM0ToInt('3'));\n+        assertEquals(0x2, Conversion.hexDigitM0ToInt('4'));\n+        assertEquals(0xA, Conversion.hexDigitM0ToInt('5'));\n+        assertEquals(0x6, Conversion.hexDigitM0ToInt('6'));\n+        assertEquals(0xE, Conversion.hexDigitM0ToInt('7'));\n+        assertEquals(0x1, Conversion.hexDigitM0ToInt('8'));\n+        assertEquals(0x9, Conversion.hexDigitM0ToInt('9'));\n+        assertEquals(0x5, Conversion.hexDigitM0ToInt('A'));\n+        assertEquals(0x5, Conversion.hexDigitM0ToInt('a'));\n+        assertEquals(0xD, Conversion.hexDigitM0ToInt('B'));\n+        assertEquals(0xD, Conversion.hexDigitM0ToInt('b'));\n+        assertEquals(0x3, Conversion.hexDigitM0ToInt('C'));\n+        assertEquals(0x3, Conversion.hexDigitM0ToInt('c'));\n+        assertEquals(0xB, Conversion.hexDigitM0ToInt('D'));\n+        assertEquals(0xB, Conversion.hexDigitM0ToInt('d'));\n+        assertEquals(0x7, Conversion.hexDigitM0ToInt('E'));\n+        assertEquals(0x7, Conversion.hexDigitM0ToInt('e'));\n+        assertEquals(0xF, Conversion.hexDigitM0ToInt('F'));\n+        assertEquals(0xF, Conversion.hexDigitM0ToInt('f'));\n+    }\n+\n+    /**\n+     * convert an hexadecimal digit into binary using the default (Lsb0) bit ordering.\n+     * <p>\n+     * '1' is converted as follow: (1, 0, 0, 0)\n+     * \n+     * @param hexDigit the hexadecimal digit to convert\n+     * @return a boolean array with the binary representation of <code>hexDigit</code>\n+     */\n+    public void testHexDigitToBools() throws Exception {\n+        assertArrayEquals(\n+            new boolean[]{false, false, false, false}, Conversion.hexDigitToBools('0'));\n+        assertArrayEquals(\n+            new boolean[]{true, false, false, false}, Conversion.hexDigitToBools('1'));\n+        assertArrayEquals(\n+            new boolean[]{false, true, false, false}, Conversion.hexDigitToBools('2'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, false, false}, Conversion.hexDigitToBools('3'));\n+        assertArrayEquals(\n+            new boolean[]{false, false, true, false}, Conversion.hexDigitToBools('4'));\n+        assertArrayEquals(\n+            new boolean[]{true, false, true, false}, Conversion.hexDigitToBools('5'));\n+        assertArrayEquals(\n+            new boolean[]{false, true, true, false}, Conversion.hexDigitToBools('6'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, true, false}, Conversion.hexDigitToBools('7'));\n+        assertArrayEquals(\n+            new boolean[]{false, false, false, true}, Conversion.hexDigitToBools('8'));\n+        assertArrayEquals(\n+            new boolean[]{true, false, false, true}, Conversion.hexDigitToBools('9'));\n+        assertArrayEquals(\n+            new boolean[]{false, true, false, true}, Conversion.hexDigitToBools('A'));\n+        assertArrayEquals(\n+            new boolean[]{false, true, false, true}, Conversion.hexDigitToBools('a'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, false, true}, Conversion.hexDigitToBools('B'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, false, true}, Conversion.hexDigitToBools('b'));\n+        assertArrayEquals(\n+            new boolean[]{false, false, true, true}, Conversion.hexDigitToBools('C'));\n+        assertArrayEquals(\n+            new boolean[]{false, false, true, true}, Conversion.hexDigitToBools('c'));\n+        assertArrayEquals(\n+            new boolean[]{true, false, true, true}, Conversion.hexDigitToBools('D'));\n+        assertArrayEquals(\n+            new boolean[]{true, false, true, true}, Conversion.hexDigitToBools('d'));\n+        assertArrayEquals(\n+            new boolean[]{false, true, true, true}, Conversion.hexDigitToBools('E'));\n+        assertArrayEquals(\n+            new boolean[]{false, true, true, true}, Conversion.hexDigitToBools('e'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, true, true}, Conversion.hexDigitToBools('F'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, true, true}, Conversion.hexDigitToBools('f'));\n+    }\n+\n+    /**\n+     * Convert an hexadecimal digit into binary using the Msb0 bit ordering.\n+     * <p>\n+     * '1' is converted as follow: (0, 0, 0, 1)\n+     * \n+     * @param hexDigit the hexadecimal digit to convert\n+     * @return a boolean array with the binary representation of <code>hexDigit</code>\n+     */\n+    public static boolean[] hexDigitM0ToBools(char hexDigit) {\n+        switch (hexDigit) {\n+        case '0':\n+            return new boolean[]{false, false, false, false};\n+        case '1':\n+            return new boolean[]{false, false, false, true};\n+        case '2':\n+            return new boolean[]{false, false, true, false};\n+        case '3':\n+            return new boolean[]{false, false, true, true};\n+        case '4':\n+            return new boolean[]{false, true, false, false};\n+        case '5':\n+            return new boolean[]{false, true, false, true};\n+        case '6':\n+            return new boolean[]{false, true, true, false};\n+        case '7':\n+            return new boolean[]{false, true, true, true};\n+        case '8':\n+            return new boolean[]{true, false, false, false};\n+        case '9':\n+            return new boolean[]{true, false, false, true};\n+        case 'a':// fall through\n+        case 'A':\n+            return new boolean[]{true, false, true, false};\n+        case 'b':// fall through\n+        case 'B':\n+            return new boolean[]{true, false, true, true};\n+        case 'c':// fall through\n+        case 'C':\n+            return new boolean[]{true, true, false, false};\n+        case 'd':// fall through\n+        case 'D':\n+            return new boolean[]{true, true, false, true};\n+        case 'e':// fall through\n+        case 'E':\n+            return new boolean[]{true, true, true, false};\n+        case 'f':// fall through\n+        case 'F':\n+            return new boolean[]{true, true, true, true};\n+        default:\n+            throw new IllegalArgumentException(\"Cannot interpret '\"\n+                + hexDigit\n+                + \"' as an hexadecimal digit\");\n+        }\n+    }\n+\n+    public void testHexDigitM0ToBools() throws Exception {\n+        assertArrayEquals(\n+            new boolean[]{false, false, false, false}, Conversion.hexDigitM0ToBools('0'));\n+        assertArrayEquals(\n+            new boolean[]{false, false, false, true}, Conversion.hexDigitM0ToBools('1'));\n+        assertArrayEquals(\n+            new boolean[]{false, false, true, false}, Conversion.hexDigitM0ToBools('2'));\n+        assertArrayEquals(\n+            new boolean[]{false, false, true, true}, Conversion.hexDigitM0ToBools('3'));\n+        assertArrayEquals(\n+            new boolean[]{false, true, false, false}, Conversion.hexDigitM0ToBools('4'));\n+        assertArrayEquals(\n+            new boolean[]{false, true, false, true}, Conversion.hexDigitM0ToBools('5'));\n+        assertArrayEquals(\n+            new boolean[]{false, true, true, false}, Conversion.hexDigitM0ToBools('6'));\n+        assertArrayEquals(\n+            new boolean[]{false, true, true, true}, Conversion.hexDigitM0ToBools('7'));\n+        assertArrayEquals(\n+            new boolean[]{true, false, false, false}, Conversion.hexDigitM0ToBools('8'));\n+        assertArrayEquals(\n+            new boolean[]{true, false, false, true}, Conversion.hexDigitM0ToBools('9'));\n+        assertArrayEquals(\n+            new boolean[]{true, false, true, false}, Conversion.hexDigitM0ToBools('A'));\n+        assertArrayEquals(\n+            new boolean[]{true, false, true, false}, Conversion.hexDigitM0ToBools('a'));\n+        assertArrayEquals(\n+            new boolean[]{true, false, true, true}, Conversion.hexDigitM0ToBools('B'));\n+        assertArrayEquals(\n+            new boolean[]{true, false, true, true}, Conversion.hexDigitM0ToBools('b'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, false, false}, Conversion.hexDigitM0ToBools('C'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, false, false}, Conversion.hexDigitM0ToBools('c'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, false, true}, Conversion.hexDigitM0ToBools('D'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, false, true}, Conversion.hexDigitM0ToBools('d'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, true, false}, Conversion.hexDigitM0ToBools('E'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, true, false}, Conversion.hexDigitM0ToBools('e'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, true, true}, Conversion.hexDigitM0ToBools('F'));\n+        assertArrayEquals(\n+            new boolean[]{true, true, true, true}, Conversion.hexDigitM0ToBools('f'));\n+    }\n+\n+    /**\n+     * Convert a boolean array to an hexadecimal digit using the default (Lsb0) bit ordering.\n+     * <p>\n+     * (1, 0, 0, 0) is converted as follow: '1'\n+     * \n+     * @param src the boolean array to convert\n+     * @return an hexadecimal digit representing the selected bits\n+     */\n+    public void testBoolsToHexDigit() throws Exception {\n+        assertEquals('0', Conversion.boolsToHexDigit(new boolean[]{false, false, false, false}));\n+        assertEquals('1', Conversion.boolsToHexDigit(new boolean[]{true, false, false, false}));\n+        assertEquals('2', Conversion.boolsToHexDigit(new boolean[]{false, true, false, false}));\n+        assertEquals('3', Conversion.boolsToHexDigit(new boolean[]{true, true, false, false}));\n+        assertEquals('4', Conversion.boolsToHexDigit(new boolean[]{false, false, true, false}));\n+        assertEquals('5', Conversion.boolsToHexDigit(new boolean[]{true, false, true, false}));\n+        assertEquals('6', Conversion.boolsToHexDigit(new boolean[]{false, true, true, false}));\n+        assertEquals('7', Conversion.boolsToHexDigit(new boolean[]{true, true, true, false}));\n+        assertEquals('8', Conversion.boolsToHexDigit(new boolean[]{false, false, false, true}));\n+        assertEquals('9', Conversion.boolsToHexDigit(new boolean[]{true, false, false, true}));\n+        assertEquals('A', Conversion.boolsToHexDigit(new boolean[]{false, true, false, true}));\n+        assertEquals('B', Conversion.boolsToHexDigit(new boolean[]{true, true, false, true}));\n+        assertEquals('C', Conversion.boolsToHexDigit(new boolean[]{false, false, true, true}));\n+        assertEquals('D', Conversion.boolsToHexDigit(new boolean[]{true, false, true, true}));\n+        assertEquals('E', Conversion.boolsToHexDigit(new boolean[]{false, true, true, true}));\n+        assertEquals('F', Conversion.boolsToHexDigit(new boolean[]{true, true, true, true}));\n+    }\n+\n+    /**\n+     * Convert a boolean array to an hexadecimal digit using the default (Lsb0) bit ordering.\n+     * <p>\n+     * (1, 0, 0, 0) is converted as follow: '1'\n+     * \n+     * @param src the boolean array to convert\n+     * @param srcPos the position of the lsb to start the conversion\n+     * @return an hexadecimal digit representing the selected bits\n+     */\n+    public void testBoolsToHexDigit_2args() throws Exception {\n+        boolean[] shortArray = new boolean[]{false, true, true};\n+        assertEquals('6', Conversion.boolsToHexDigit(shortArray, 0));\n+        assertEquals('3', Conversion.boolsToHexDigit(shortArray, 1));\n+        assertEquals('1', Conversion.boolsToHexDigit(shortArray, 2));\n+        boolean[] longArray = new boolean[]{true, false, true, false, false, true, true};\n+        assertEquals('5', Conversion.boolsToHexDigit(longArray, 0));\n+        assertEquals('2', Conversion.boolsToHexDigit(longArray, 1));\n+        assertEquals('9', Conversion.boolsToHexDigit(longArray, 2));\n+        assertEquals('C', Conversion.boolsToHexDigit(longArray, 3));\n+        assertEquals('6', Conversion.boolsToHexDigit(longArray, 4));\n+        assertEquals('3', Conversion.boolsToHexDigit(longArray, 5));\n+        assertEquals('1', Conversion.boolsToHexDigit(longArray, 6));\n+    }\n+\n+    /**\n+     * Convert a boolean array to an hexadecimal digit using the Msb0 bit ordering.\n+     * <p>\n+     * (1, 0, 0, 0) is converted as follow: '8'\n+     * \n+     * @param src the boolean array to convert\n+     * @return an hexadecimal digit representing the selected bits\n+     * @warning src.length must be >= 4.\n+     */\n+    public void testBoolsToHexDigitM0_bits() throws Exception {\n+        assertEquals(\n+            '0', Conversion.boolsToHexDigitM0_4bits(new boolean[]{false, false, false, false}));\n+        assertEquals(\n+            '1', Conversion.boolsToHexDigitM0_4bits(new boolean[]{false, false, false, true}));\n+        assertEquals(\n+            '2', Conversion.boolsToHexDigitM0_4bits(new boolean[]{false, false, true, false}));\n+        assertEquals(\n+            '3', Conversion.boolsToHexDigitM0_4bits(new boolean[]{false, false, true, true}));\n+        assertEquals(\n+            '4', Conversion.boolsToHexDigitM0_4bits(new boolean[]{false, true, false, false}));\n+        assertEquals(\n+            '5', Conversion.boolsToHexDigitM0_4bits(new boolean[]{false, true, false, true}));\n+        assertEquals(\n+            '6', Conversion.boolsToHexDigitM0_4bits(new boolean[]{false, true, true, false}));\n+        assertEquals(\n+            '7', Conversion.boolsToHexDigitM0_4bits(new boolean[]{false, true, true, true}));\n+        assertEquals(\n+            '8', Conversion.boolsToHexDigitM0_4bits(new boolean[]{true, false, false, false}));\n+        assertEquals(\n+            '9', Conversion.boolsToHexDigitM0_4bits(new boolean[]{true, false, false, true}));\n+        assertEquals(\n+            'A', Conversion.boolsToHexDigitM0_4bits(new boolean[]{true, false, true, false}));\n+        assertEquals(\n+            'B', Conversion.boolsToHexDigitM0_4bits(new boolean[]{true, false, true, true}));\n+        assertEquals(\n+            'C', Conversion.boolsToHexDigitM0_4bits(new boolean[]{true, true, false, false}));\n+        assertEquals(\n+            'D', Conversion.boolsToHexDigitM0_4bits(new boolean[]{true, true, false, true}));\n+        assertEquals(\n+            'E', Conversion.boolsToHexDigitM0_4bits(new boolean[]{true, true, true, false}));\n+        assertEquals(\n+            'F', Conversion.boolsToHexDigitM0_4bits(new boolean[]{true, true, true, true}));\n+    }\n+\n+    /**\n+     * Convert a boolean array to an hexadecimal digit using the Msb0 bit ordering.\n+     * <p>\n+     * (1, 0, 0, 0) is converted as follow: '8' (1,0,0,1,1,0,1,0) with srcPos = 3 is converted\n+     * to 'D'\n+     * \n+     * @param src the boolean array to convert\n+     * @param srcPos the position of the lsb to start the conversion\n+     * @return an hexadecimal digit representing the selected bits\n+     * @warning src.length must be 8 at most.\n+     * @warning srcPos+4 must be <= src.length.\n+     */\n+    public void testBoolsToHexDigitM0_4bits_2args() throws Exception {\n+        // boolean[] shortArray = new boolean[]{true,true,false};\n+        // assertEquals('6', Conversion.boolsToHexDigitM0(shortArray,0));\n+        // assertEquals('3', Conversion.boolsToHexDigitM0(shortArray,1));\n+        // assertEquals('1', Conversion.boolsToHexDigitM0(shortArray,2));\n+        boolean[] shortArray = new boolean[]{true, true, false, true};\n+        assertEquals('D', Conversion.boolsToHexDigitM0_4bits(shortArray, 0));\n+        boolean[] longArray = new boolean[]{true, false, true, false, false, true, true};\n+        assertEquals('A', Conversion.boolsToHexDigitM0_4bits(longArray, 0));\n+        assertEquals('4', Conversion.boolsToHexDigitM0_4bits(longArray, 1));\n+        assertEquals('9', Conversion.boolsToHexDigitM0_4bits(longArray, 2));\n+        assertEquals('3', Conversion.boolsToHexDigitM0_4bits(longArray, 3));\n+        // assertEquals('6', Conversion.boolsToHexDigitM0(longArray,4));\n+        // assertEquals('3', Conversion.boolsToHexDigitM0(longArray,5));\n+        // assertEquals('1', Conversion.boolsToHexDigitM0(longArray,6));\n+        boolean[] maxLengthArray = new boolean[]{\n+            true, false, true, false, false, true, true, true};\n+        assertEquals('A', Conversion.boolsToHexDigitM0_4bits(maxLengthArray, 0));\n+        assertEquals('4', Conversion.boolsToHexDigitM0_4bits(maxLengthArray, 1));\n+        assertEquals('9', Conversion.boolsToHexDigitM0_4bits(maxLengthArray, 2));\n+        assertEquals('3', Conversion.boolsToHexDigitM0_4bits(maxLengthArray, 3));\n+        assertEquals('7', Conversion.boolsToHexDigitM0_4bits(maxLengthArray, 4));\n+        // assertEquals('7', Conversion.boolsToHexDigitM0(longArray,5));\n+        // assertEquals('3', Conversion.boolsToHexDigitM0(longArray,6));\n+        // assertEquals('1', Conversion.boolsToHexDigitM0(longArray,7));\n+        boolean[] javaDocCheck = new boolean[]{\n+            true, false, false, true, true, false, true, false};\n+        assertEquals('D', Conversion.boolsToHexDigitM0_4bits(javaDocCheck, 3));\n+\n+    }\n+\n+    /**\n+     * Convert the first 4 bits of a boolean array in big endian Msb0 bit ordering to an\n+     * hexadecimal digit.\n+     * <p>\n+     * (1, 0, 0, 0) is converted as follow: '8' (1,0,0,0,0,0,0,0, 0,0,0,0,0,1,0,0) is converted\n+     * to '4'\n+     * \n+     * @param src the boolean array to convert\n+     * @return an hexadecimal digit representing the selected bits\n+     */\n+    public void testBoolsBeM0ToHexDigit() throws Exception {\n+        assertEquals(\n+            '0', Conversion.boolsBeM0ToHexDigit(new boolean[]{false, false, false, false}));\n+        assertEquals(\n+            '1', Conversion.boolsBeM0ToHexDigit(new boolean[]{false, false, false, true}));\n+        assertEquals(\n+            '2', Conversion.boolsBeM0ToHexDigit(new boolean[]{false, false, true, false}));\n+        assertEquals(\n+            '3', Conversion.boolsBeM0ToHexDigit(new boolean[]{false, false, true, true}));\n+        assertEquals(\n+            '4', Conversion.boolsBeM0ToHexDigit(new boolean[]{false, true, false, false}));\n+        assertEquals(\n+            '5', Conversion.boolsBeM0ToHexDigit(new boolean[]{false, true, false, true}));\n+        assertEquals(\n+            '6', Conversion.boolsBeM0ToHexDigit(new boolean[]{false, true, true, false}));\n+        assertEquals(\n+            '7', Conversion.boolsBeM0ToHexDigit(new boolean[]{false, true, true, true}));\n+        assertEquals(\n+            '8', Conversion.boolsBeM0ToHexDigit(new boolean[]{true, false, false, false}));\n+        assertEquals(\n+            '9', Conversion.boolsBeM0ToHexDigit(new boolean[]{true, false, false, true}));\n+        assertEquals(\n+            'A', Conversion.boolsBeM0ToHexDigit(new boolean[]{true, false, true, false}));\n+        assertEquals(\n+            'B', Conversion.boolsBeM0ToHexDigit(new boolean[]{true, false, true, true}));\n+        assertEquals(\n+            'C', Conversion.boolsBeM0ToHexDigit(new boolean[]{true, true, false, false}));\n+        assertEquals(\n+            'D', Conversion.boolsBeM0ToHexDigit(new boolean[]{true, true, false, true}));\n+        assertEquals(\n+            'E', Conversion.boolsBeM0ToHexDigit(new boolean[]{true, true, true, false}));\n+        assertEquals('F', Conversion.boolsBeM0ToHexDigit(new boolean[]{true, true, true, true}));\n+        assertEquals(\n+            '4',\n+            Conversion.boolsBeM0ToHexDigit(new boolean[]{\n+                true, false, false, false, false, false, false, false, false, false, false,\n+                false, false, true, false, false}));\n+    }\n+\n+    /**\n+     * Convert a part of a boolean array in big endian Msb0 bit ordering to an hexadecimal\n+     * digit.\n+     * <p>\n+     * (1, 0, 0, 0) with srcPos = 0 is converted as follow: '8' (1,0,0,0,0,0,0,0,\n+     * 0,0,0,1,0,1,0,0) with srcPos = 2 is converted to '5'\n+     * \n+     * @param src the boolean array to convert\n+     * @param srcPos the position of the lsb to start the conversion\n+     * @return an hexadecimal digit representing the selected bits\n+     */\n+    public void testBoolsBeM0ToHexDigit_2args() throws Exception {\n+        assertEquals(\n+            '5',\n+            Conversion.boolsBeM0ToHexDigit(new boolean[]{\n+                true, false, false, false, false, false, false, false, false, false, false,\n+                true, false, true, false, false}, 2));\n+\n+        boolean[] shortArray = new boolean[]{true, true, false};\n+        assertEquals('6', Conversion.boolsBeM0ToHexDigit(shortArray, 0));\n+        assertEquals('3', Conversion.boolsBeM0ToHexDigit(shortArray, 1));\n+        assertEquals('1', Conversion.boolsBeM0ToHexDigit(shortArray, 2));\n+        boolean[] shortArray2 = new boolean[]{true, true, true, false, false, true, false, true};\n+        assertEquals('5', Conversion.boolsBeM0ToHexDigit(shortArray2, 0));\n+        assertEquals('2', Conversion.boolsBeM0ToHexDigit(shortArray2, 1));\n+        assertEquals('9', Conversion.boolsBeM0ToHexDigit(shortArray2, 2));\n+        assertEquals('C', Conversion.boolsBeM0ToHexDigit(shortArray2, 3));\n+        assertEquals('E', Conversion.boolsBeM0ToHexDigit(shortArray2, 4));\n+        assertEquals('7', Conversion.boolsBeM0ToHexDigit(shortArray2, 5));\n+        assertEquals('3', Conversion.boolsBeM0ToHexDigit(shortArray2, 6));\n+        assertEquals('1', Conversion.boolsBeM0ToHexDigit(shortArray2, 7));\n+        boolean[] multiBytesArray = new boolean[]{\n+            true, true, false, false, true, false, true, false, true, true, true, false, false,\n+            true, false, true};\n+        assertEquals('5', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 0));\n+        assertEquals('2', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 1));\n+        assertEquals('9', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 2));\n+        assertEquals('C', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 3));\n+        assertEquals('E', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 4));\n+        assertEquals('7', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 5));\n+        assertEquals('B', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 6));\n+        assertEquals('5', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 7));\n+\n+        assertEquals('A', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 8));\n+        assertEquals('5', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 9));\n+        assertEquals('2', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 10));\n+        assertEquals('9', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 11));\n+        assertEquals('C', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 12));\n+        assertEquals('6', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 13));\n+        assertEquals('3', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 14));\n+        assertEquals('1', Conversion.boolsBeM0ToHexDigit(multiBytesArray, 15));\n+\n+    }\n+\n+    /**\n+     * Convert the 4 lsb of an int to an hexadecimal digit.\n+     * <p>\n+     * 0 returns '0'\n+     * <p>\n+     * 1 returns '1'\n+     * <p>\n+     * 10 returns 'A' and so on...\n+     * \n+     * @param nibble the int to convert, value outside of the range [0:15] are not allowed.\n+     * @return an hexadecimal digit representing the 4 lsb of <code>nibble</code>\n+     */\n+    public void testIntToHexDigit() throws Exception {\n+        assertEquals('0', Conversion.intToHexDigit(0));\n+        assertEquals('1', Conversion.intToHexDigit(1));\n+        assertEquals('2', Conversion.intToHexDigit(2));\n+        assertEquals('3', Conversion.intToHexDigit(3));\n+        assertEquals('4', Conversion.intToHexDigit(4));\n+        assertEquals('5', Conversion.intToHexDigit(5));\n+        assertEquals('6', Conversion.intToHexDigit(6));\n+        assertEquals('7', Conversion.intToHexDigit(7));\n+        assertEquals('8', Conversion.intToHexDigit(8));\n+        assertEquals('9', Conversion.intToHexDigit(9));\n+        assertEquals('A', Conversion.intToHexDigit(10));\n+        assertEquals('B', Conversion.intToHexDigit(11));\n+        assertEquals('C', Conversion.intToHexDigit(12));\n+        assertEquals('D', Conversion.intToHexDigit(13));\n+        assertEquals('E', Conversion.intToHexDigit(14));\n+        assertEquals('F', Conversion.intToHexDigit(15));\n+    }\n+\n+    /**\n+     * Convert the 4 lsb of an int to an hexadecimal digit encoded using the Msb0 bit ordering.\n+     * <p>\n+     * 0 returns '0'\n+     * <p>\n+     * 1 returns '8'\n+     * <p>\n+     * 10 returns '5' and so on...\n+     * \n+     * @param nibble the int to convert, value outside of the range [0:15] are not allowed.\n+     * @return an hexadecimal digit representing the 4 lsb of <code>nibble</code>\n+     */\n+    public void testIntToHexDigitM0() throws Exception {\n+        assertEquals('0', Conversion.intToHexDigitM0(0));\n+        assertEquals('8', Conversion.intToHexDigitM0(1));\n+        assertEquals('4', Conversion.intToHexDigitM0(2));\n+        assertEquals('C', Conversion.intToHexDigitM0(3));\n+        assertEquals('2', Conversion.intToHexDigitM0(4));\n+        assertEquals('A', Conversion.intToHexDigitM0(5));\n+        assertEquals('6', Conversion.intToHexDigitM0(6));\n+        assertEquals('E', Conversion.intToHexDigitM0(7));\n+        assertEquals('1', Conversion.intToHexDigitM0(8));\n+        assertEquals('9', Conversion.intToHexDigitM0(9));\n+        assertEquals('5', Conversion.intToHexDigitM0(10));\n+        assertEquals('D', Conversion.intToHexDigitM0(11));\n+        assertEquals('3', Conversion.intToHexDigitM0(12));\n+        assertEquals('B', Conversion.intToHexDigitM0(13));\n+        assertEquals('7', Conversion.intToHexDigitM0(14));\n+        assertEquals('F', Conversion.intToHexDigitM0(15));\n+    }\n+\n+    static String dbgPrint(long[] src) {\n+        StringBuilder sb = new StringBuilder();\n+        for (long e : src) {\n+            sb.append(\"0x\").append(Long.toHexString(e)).append(',');\n+        }\n+        String out = sb.toString();\n+        return out.substring(0, out.length() - 1);\n+    }\n+\n+    static void assertArrayEquals(long[] expected, long[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; i++ ) {\n+            try {\n+                assertEquals(expected[i], actual[i]);\n+            } catch (Throwable e) {\n+                String msg = \"Mismatch at index \"\n+                    + i\n+                    + \" between:\\n\"\n+                    + dbgPrint(expected)\n+                    + \" and\\n\"\n+                    + dbgPrint(actual);\n+                TestCase.fail(msg + \"\\n\" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    static String dbgPrint(int[] src) {\n+        StringBuilder sb = new StringBuilder();\n+        for (int e : src) {\n+            sb.append(\"0x\").append(Long.toHexString(e)).append(',');\n+        }\n+        String out = sb.toString();\n+        return out.substring(0, out.length() - 1);\n+    }\n+\n+    static void assertArrayEquals(int[] expected, int[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; i++ ) {\n+            try {\n+                assertEquals(expected[i], actual[i]);\n+            } catch (Throwable e) {\n+                String msg = \"Mismatch at index \"\n+                    + i\n+                    + \" between:\\n\"\n+                    + dbgPrint(expected)\n+                    + \" and\\n\"\n+                    + dbgPrint(actual);\n+                TestCase.fail(msg + \"\\n\" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    static String dbgPrint(short[] src) {\n+        StringBuilder sb = new StringBuilder();\n+        for (short e : src) {\n+            sb.append(\"0x\").append(Long.toHexString(e)).append(',');\n+        }\n+        String out = sb.toString();\n+        return out.substring(0, out.length() - 1);\n+    }\n+\n+    static void assertArrayEquals(short[] expected, short[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; i++ ) {\n+            try {\n+                assertEquals(expected[i], actual[i]);\n+            } catch (Throwable e) {\n+                String msg = \"Mismatch at index \"\n+                    + i\n+                    + \" between:\\n\"\n+                    + dbgPrint(expected)\n+                    + \" and\\n\"\n+                    + dbgPrint(actual);\n+                TestCase.fail(msg + \"\\n\" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    static String dbgPrint(byte[] src) {\n+        StringBuilder sb = new StringBuilder();\n+        for (byte e : src) {\n+            sb.append(\"0x\").append(Long.toHexString(e)).append(',');\n+        }\n+        String out = sb.toString();\n+        return out.substring(0, out.length() - 1);\n+    }\n+\n+    static void assertArrayEquals(byte[] expected, byte[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; i++ ) {\n+            try {\n+                assertEquals(expected[i], actual[i]);\n+            } catch (Throwable e) {\n+                String msg = \"Mismatch at index \"\n+                    + i\n+                    + \" between:\\n\"\n+                    + dbgPrint(expected)\n+                    + \" and\\n\"\n+                    + dbgPrint(actual);\n+                TestCase.fail(msg + \"\\n\" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    static String dbgPrint(boolean[] src) {\n+        StringBuilder sb = new StringBuilder();\n+        for (boolean e : src) {\n+            if (e) sb.append(\"1,\");\n+            else sb.append(\"0,\");\n+        }\n+        String out = sb.toString();\n+        return out.substring(0, out.length() - 1);\n+    }\n+\n+    static void assertArrayEquals(boolean[] expected, boolean[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; i++ ) {\n+            try {\n+                assertEquals(expected[i], actual[i]);\n+            } catch (Throwable e) {\n+                String msg = \"Mismatch at index \"\n+                    + i\n+                    + \" between:\\n\"\n+                    + dbgPrint(expected)\n+                    + \" and\\n\"\n+                    + dbgPrint(actual);\n+                TestCase.fail(msg + \"\\n\" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void testIntsToLong() throws Exception {\n+        int[] src = new int[]{0xCDF1F0C1, 0x0F123456, 0x78000000};\n+        assertEquals(0x0000000000000000L, Conversion.intsToLong(src, 0, 0L, 0, 0));\n+        assertEquals(0x0000000000000000L, Conversion.intsToLong(src, 1, 0L, 0, 0));\n+        assertEquals(0x00000000CDF1F0C1L, Conversion.intsToLong(src, 0, 0L, 0, 1));\n+        assertEquals(0x0F123456CDF1F0C1L, Conversion.intsToLong(src, 0, 0L, 0, 2));\n+        assertEquals(0x000000000F123456L, Conversion.intsToLong(src, 1, 0L, 0, 1));\n+        assertEquals(\n+            0x123456789ABCDEF0L, Conversion.intsToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));\n+        assertEquals(\n+            0x1234567878000000L, Conversion.intsToLong(src, 2, 0x123456789ABCDEF0L, 0, 1));\n+        // assertEquals(0x0F12345678000000L,Conversion.intsToLong(src,1,0x123456789ABCDEF0L,32,2));\n+    }\n+\n+    public void testShortsToLong() throws Exception {\n+        // TODO: implement this test. This is somehow low priority since intsToLong and\n+        // bytesToLong are tested\n+    }\n+\n+    public void testBytesToLong() throws Exception {\n+        byte[] src = new byte[]{\n+            (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34,\n+            (byte)0x56, (byte)0x78};\n+        assertEquals(0x0000000000000000L, Conversion.bytesToLong(src, 0, 0L, 0, 0));\n+        assertEquals(0x00000000000000CDL, Conversion.bytesToLong(src, 0, 0L, 0, 1));\n+        assertEquals(0x00000000C1F0F1CDL, Conversion.bytesToLong(src, 0, 0L, 0, 4));\n+        assertEquals(0x000000000FC1F0F1L, Conversion.bytesToLong(src, 1, 0L, 0, 4));\n+        assertEquals(\n+            0x123456789ABCDEF0L, Conversion.bytesToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));\n+        assertEquals(\n+            0x12345678CDBCDEF0L, Conversion.bytesToLong(src, 0, 0x123456789ABCDEF0L, 24, 1));\n+        // assertEquals(0x123456789A7856F0L,Conversion.bytesToLong(src,7,0x123456789ABCDEF0L,8,2));\n+    }\n+\n+    public void testShortsToInt() throws Exception {\n+        short[] src = new short[]{\n+            (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800};\n+        assertEquals(0x00000000, Conversion.shortsToInt(src, 0, 0, 0, 0));\n+        assertEquals(0x0000CDF1, Conversion.shortsToInt(src, 0, 0, 0, 1));\n+        assertEquals(0xF0C1CDF1, Conversion.shortsToInt(src, 0, 0, 0, 2));\n+        assertEquals(0x0F12F0C1, Conversion.shortsToInt(src, 1, 0, 0, 2));\n+        assertEquals(0x12345678, Conversion.shortsToInt(src, 0, 0x12345678, 0, 0));\n+        assertEquals(0xCDF15678, Conversion.shortsToInt(src, 0, 0x12345678, 16, 1));\n+        // assertEquals(0x34567800,Conversion.shortsToInt(src, 3, 0x12345678, 16, 2));\n+\n+    }\n+\n+    public void testBytesToInt() throws Exception {\n+        byte[] src = new byte[]{\n+            (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34,\n+            (byte)0x56, (byte)0x78};\n+        assertEquals(0x00000000, Conversion.bytesToInt(src, 0, 0, 0, 0));\n+        assertEquals(0x000000CD, Conversion.bytesToInt(src, 0, 0, 0, 1));\n+        assertEquals(0xC1F0F1CD, Conversion.bytesToInt(src, 0, 0, 0, 4));\n+        assertEquals(0x0FC1F0F1, Conversion.bytesToInt(src, 1, 0, 0, 4));\n+        assertEquals(0x12345678, Conversion.bytesToInt(src, 0, 0x12345678, 0, 0));\n+        assertEquals(0xCD345678, Conversion.bytesToInt(src, 0, 0x12345678, 24, 1));\n+        // assertEquals(0x56341278,Conversion.bytesToInt(src, 5, 0x01234567, 8, 4));\n+    }\n+\n+    public void testBytesToShort() throws Exception {\n+        byte[] src = new byte[]{\n+            (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34,\n+            (byte)0x56, (byte)0x78};\n+        assertEquals((short)0x0000, Conversion.bytesToShort(src, 0, (short)0, 0, 0));\n+        assertEquals((short)0x00CD, Conversion.bytesToShort(src, 0, (short)0, 0, 1));\n+        assertEquals((short)0xF1CD, Conversion.bytesToShort(src, 0, (short)0, 0, 2));\n+        assertEquals((short)0xF0F1, Conversion.bytesToShort(src, 1, (short)0, 0, 2));\n+        assertEquals((short)0x1234, Conversion.bytesToShort(src, 0, (short)0x1234, 0, 0));\n+        assertEquals((short)0xCD34, Conversion.bytesToShort(src, 0, (short)0x1234, 8, 1));\n+        // assertEquals((short)0x5678,Conversion.bytesToShort(src, 7, (short) 0x0123, 8, 2));\n+    }\n+\n+    public void testHexsToLong() throws Exception {\n+        String src = \"CDF1F0C10F12345678\";\n+        assertEquals(0x0000000000000000L, Conversion.hexsToLong(src, 0, 0L, 0, 0));\n+        assertEquals(0x000000000000000CL, Conversion.hexsToLong(src, 0, 0L, 0, 1));\n+        assertEquals(0x000000001C0F1FDCL, Conversion.hexsToLong(src, 0, 0L, 0, 8));\n+        assertEquals(0x0000000001C0F1FDL, Conversion.hexsToLong(src, 1, 0L, 0, 8));\n+        assertEquals(\n+            0x123456798ABCDEF0L, Conversion.hexsToLong(src, 0, 0x123456798ABCDEF0L, 0, 0));\n+        assertEquals(\n+            0x1234567876BCDEF0L, Conversion.hexsToLong(src, 15, 0x123456798ABCDEF0L, 24, 3));\n+    }\n+\n+    public void testHexsToInt() throws Exception {\n+        String src = \"CDF1F0C10F12345678\";\n+        assertEquals(0x00000000, Conversion.hexsToInt(src, 0, 0, 0, 0));\n+        assertEquals(0x0000000C, Conversion.hexsToInt(src, 0, 0, 0, 1));\n+        assertEquals(0x1C0F1FDC, Conversion.hexsToInt(src, 0, 0, 0, 8));\n+        assertEquals(0x01C0F1FD, Conversion.hexsToInt(src, 1, 0, 0, 8));\n+        assertEquals(0x12345679, Conversion.hexsToInt(src, 0, 0x12345679, 0, 0));\n+        assertEquals(0x87645679, Conversion.hexsToInt(src, 15, 0x12345679, 20, 3));\n+    }\n+\n+    public void testHexsToShort() throws Exception {\n+        String src = \"CDF1F0C10F12345678\";\n+        assertEquals((short)0x0000, Conversion.hexsToShort(src, 0, (short)0, 0, 0));\n+        assertEquals((short)0x000C, Conversion.hexsToShort(src, 0, (short)0, 0, 1));\n+        assertEquals((short)0x1FDC, Conversion.hexsToShort(src, 0, (short)0, 0, 4));\n+        assertEquals((short)0xF1FD, Conversion.hexsToShort(src, 1, (short)0, 0, 4));\n+        assertEquals((short)0x1234, Conversion.hexsToShort(src, 0, (short)0x1234, 0, 0));\n+        assertEquals((short)0x8764, Conversion.hexsToShort(src, 15, (short)0x1234, 4, 3));\n+    }\n+\n+    public void testHexsToByte() throws Exception {\n+        String src = \"CDF1F0C10F12345678\";\n+        assertEquals((byte)0x00, Conversion.hexsToByte(src, 0, (byte)0, 0, 0));\n+        assertEquals((byte)0x0C, Conversion.hexsToByte(src, 0, (byte)0, 0, 1));\n+        assertEquals((byte)0xDC, Conversion.hexsToByte(src, 0, (byte)0, 0, 2));\n+        assertEquals((byte)0xFD, Conversion.hexsToByte(src, 1, (byte)0, 0, 2));\n+        assertEquals((byte)0x34, Conversion.hexsToByte(src, 0, (byte)0x34, 0, 0));\n+        assertEquals((byte)0x84, Conversion.hexsToByte(src, 17, (byte)0x34, 4, 1));\n+    }\n+\n+    public void testBoolsToLong() throws Exception {\n+        boolean[] src = new boolean[]{\n+            false, false, true, true, true, false, true, true, true, true, true, true, true,\n+            false, false, false, true, true, true, true, false, false, false, false, false,\n+            false, true, true, true, false, false, false, false, false, false, false, true,\n+            true, true, true, true, false, false, false, false, true, false, false, true, true,\n+            false, false, false, false, true, false, true, false, true, false, false, true,\n+            true, false, true, true, true, false, false, false, false, true};// conversion of\n+                                                                             // \"CDF1F0C10F12345678\"\n+                                                                             // by hexsToBools\n+\n+        assertEquals(0x0000000000000000L, Conversion.boolsToLong(src, 0, 0L, 0, 0));\n+        assertEquals(0x000000000000000CL, Conversion.boolsToLong(src, 0, 0L, 0, 1 * 4));\n+        assertEquals(0x000000001C0F1FDCL, Conversion.boolsToLong(src, 0, 0L, 0, 8 * 4));\n+        assertEquals(0x0000000001C0F1FDL, Conversion.boolsToLong(src, 1 * 4, 0L, 0, 8 * 4));\n+        assertEquals(\n+            0x123456798ABCDEF0L, Conversion.boolsToLong(src, 0, 0x123456798ABCDEF0L, 0, 0));\n+        assertEquals(\n+            0x1234567876BCDEF0L,\n+            Conversion.boolsToLong(src, 15 * 4, 0x123456798ABCDEF0L, 24, 3 * 4));\n+    }\n+\n+    public void testBoolsToInt() throws Exception {\n+        boolean[] src = new boolean[]{\n+            false, false, true, true, true, false, true, true, true, true, true, true, true,\n+            false, false, false, true, true, true, true, false, false, false, false, false,\n+            false, true, true, true, false, false, false, false, false, false, false, true,\n+            true, true, true, true, false, false, false, false, true, false, false, true, true,\n+            false, false, false, false, true, false, true, false, true, false, false, true,\n+            true, false, true, true, true, false, false, false, false, true};// conversion of\n+                                                                             // \"CDF1F0C10F12345678\"\n+                                                                             // by hexsToBools\n+        assertEquals(0x00000000, Conversion.boolsToInt(src, 0 * 4, 0, 0, 0 * 4));\n+        assertEquals(0x0000000C, Conversion.boolsToInt(src, 0 * 4, 0, 0, 1 * 4));\n+        assertEquals(0x1C0F1FDC, Conversion.boolsToInt(src, 0 * 4, 0, 0, 8 * 4));\n+        assertEquals(0x01C0F1FD, Conversion.boolsToInt(src, 1 * 4, 0, 0, 8 * 4));\n+        assertEquals(0x12345679, Conversion.boolsToInt(src, 0 * 4, 0x12345679, 0, 0 * 4));\n+        assertEquals(0x87645679, Conversion.boolsToInt(src, 15 * 4, 0x12345679, 20, 3 * 4));\n+    }\n+\n+    public void testBoolsToShort() throws Exception {\n+        boolean[] src = new boolean[]{\n+            false, false, true, true, true, false, true, true, true, true, true, true, true,\n+            false, false, false, true, true, true, true, false, false, false, false, false,\n+            false, true, true, true, false, false, false, false, false, false, false, true,\n+            true, true, true, true, false, false, false, false, true, false, false, true, true,\n+            false, false, false, false, true, false, true, false, true, false, false, true,\n+            true, false, true, true, true, false, false, false, false, true};// conversion of\n+                                                                             // \"CDF1F0C10F12345678\"\n+                                                                             // by hexsToBools\n+        assertEquals((short)0x0000, Conversion.boolsToShort(src, 0 * 4, (short)0, 0, 0 * 4));\n+        assertEquals((short)0x000C, Conversion.boolsToShort(src, 0 * 4, (short)0, 0, 1 * 4));\n+        assertEquals((short)0x1FDC, Conversion.boolsToShort(src, 0 * 4, (short)0, 0, 4 * 4));\n+        assertEquals((short)0xF1FD, Conversion.boolsToShort(src, 1 * 4, (short)0, 0, 4 * 4));\n+        assertEquals(\n+            (short)0x1234, Conversion.boolsToShort(src, 0 * 4, (short)0x1234, 0, 0 * 4));\n+        assertEquals(\n+            (short)0x8764, Conversion.boolsToShort(src, 15 * 4, (short)0x1234, 4, 3 * 4));\n+    }\n+\n+    public void testBoolsToByte() throws Exception {\n+        boolean[] src = new boolean[]{\n+            false, false, true, true, true, false, true, true, true, true, true, true, true,\n+            false, false, false, true, true, true, true, false, false, false, false, false,\n+            false, true, true, true, false, false, false, false, false, false, false, true,\n+            true, true, true, true, false, false, false, false, true, false, false, true, true,\n+            false, false, false, false, true, false, true, false, true, false, false, true,\n+            true, false, true, true, true, false, false, false, false, true};// conversion of\n+                                                                             // \"CDF1F0C10F12345678\"\n+                                                                             // by hexsToBools\n+        assertEquals((byte)0x00, Conversion.boolsToByte(src, 0 * 4, (byte)0, 0, 0 * 4));\n+        assertEquals((byte)0x0C, Conversion.boolsToByte(src, 0 * 4, (byte)0, 0, 1 * 4));\n+        assertEquals((byte)0xDC, Conversion.boolsToByte(src, 0 * 4, (byte)0, 0, 2 * 4));\n+        assertEquals((byte)0xFD, Conversion.boolsToByte(src, 1 * 4, (byte)0, 0, 2 * 4));\n+        assertEquals((byte)0x34, Conversion.boolsToByte(src, 0 * 4, (byte)0x34, 0, 0 * 4));\n+        assertEquals((byte)0x84, Conversion.boolsToByte(src, 17 * 4, (byte)0x34, 4, 1 * 4));\n+    }\n+\n+    public void testLongToInts() throws Exception {\n+        assertArrayEquals(\n+            new int[]{}, Conversion.longToInts(0x0000000000000000L, 0, new int[]{}, 0, 0));\n+        assertArrayEquals(\n+            new int[]{}, Conversion.longToInts(0x0000000000000000L, 100, new int[]{}, 0, 0));\n+        assertArrayEquals(\n+            new int[]{}, Conversion.longToInts(0x0000000000000000L, 0, new int[]{}, 100, 0));\n+        assertArrayEquals(\n+            new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},\n+            Conversion.longToInts(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 0));\n+        assertArrayEquals(\n+            new int[]{0x90ABCDEF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},\n+            Conversion.longToInts(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new int[]{0x90ABCDEF, 0x12345678, 0xFFFFFFFF, 0xFFFFFFFF},\n+            Conversion.longToInts(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 0, 2));\n+        // assertArrayEquals(new\n+        // int[]{0x90ABCDEF,0x12345678,0x90ABCDEF,0x12345678},Conversion.longToInts(0x1234567890ABCDEFL,\n+        // 0,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion\n+        // assertArrayEquals(new\n+        // int[]{0xFFFFFFFF,0x90ABCDEF,0x12345678,0x90ABCDEF},Conversion.longToInts(0x1234567890ABCDEFL,\n+        // 0,new int[]{-1,-1,-1,-1},1,3));\n+        assertArrayEquals(\n+            new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0x12345678},\n+            Conversion.longToInts(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 2, 2));\n+        assertArrayEquals(\n+            new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0xFFFFFFFF},\n+            Conversion.longToInts(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF},\n+            Conversion.longToInts(0x1234567890ABCDEFL, 0, new int[]{-1, -1, -1, -1}, 3, 1));\n+        assertArrayEquals(\n+            new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x4855E6F7, 0xFFFFFFFF},\n+            Conversion.longToInts(0x1234567890ABCDEFL, 1, new int[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x242AF37B, 0xFFFFFFFF},\n+            Conversion.longToInts(0x1234567890ABCDEFL, 2, new int[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x121579BD, 0xFFFFFFFF},\n+            Conversion.longToInts(0x1234567890ABCDEFL, 3, new int[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new int[]{0xFFFFFFFF, 0xFFFFFFFF, 0x890ABCDE, 0xFFFFFFFF},\n+            Conversion.longToInts(0x1234567890ABCDEFL, 4, new int[]{-1, -1, -1, -1}, 2, 1));\n+        // assertArrayEquals(new\n+        // int[]{0x4855E6F7,0x091A2B3C,0x4855E6F7,0x091A2B3C},Conversion.longToInts(0x1234567890ABCDEFL,\n+        // 1,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion\n+        assertArrayEquals(\n+            new int[]{0x091A2B3C},\n+            Conversion.longToInts(0x1234567890ABCDEFL, 33, new int[]{0}, 0, 1));\n+    }\n+\n+    public void testLongToShorts() throws Exception {\n+        assertArrayEquals(\n+            new short[]{}, Conversion.longToShorts(0x0000000000000000L, 0, new short[]{}, 0, 0));\n+        assertArrayEquals(\n+            new short[]{},\n+            Conversion.longToShorts(0x0000000000000000L, 100, new short[]{}, 0, 0));\n+        assertArrayEquals(\n+            new short[]{},\n+            Conversion.longToShorts(0x0000000000000000L, 0, new short[]{}, 100, 0));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xFFFF, (short)0xFFFF},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 0));\n+        assertArrayEquals(\n+            new short[]{(short)0xCDEF, (short)0xFFFF, (short)0xFFFF, (short)0xFFFF},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xCDEF, (short)0x90AB, (short)0xFFFF, (short)0xFFFF},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 2));\n+        assertArrayEquals(\n+            new short[]{(short)0xCDEF, (short)0x90AB, (short)0x5678, (short)0xFFFF},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 3));\n+        assertArrayEquals(\n+            new short[]{(short)0xCDEF, (short)0x90AB, (short)0x5678, (short)0x1234},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 0, 4));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xCDEF, (short)0x90AB, (short)0x5678},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 1, 3));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xCDEF, (short)0x90AB},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 2, 2));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xCDEF, (short)0xFFFF},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xFFFF, (short)0xCDEF},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 0, new short[]{-1, -1, -1, -1}, 3, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xE6F7, (short)0xFFFF},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 1, new short[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xF37B, (short)0xFFFF},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 2, new short[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x79BD, (short)0xFFFF},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 3, new short[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xBCDE, (short)0xFFFF},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 4, new short[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xE6F7, (short)0x4855, (short)0x2B3C, (short)0x091A},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 1, new short[]{-1, -1, -1, -1}, 0, 4));\n+        assertArrayEquals(\n+            new short[]{(short)0x2B3C},\n+            Conversion.longToShorts(0x1234567890ABCDEFL, 33, new short[]{0}, 0, 1));\n+    }\n+\n+    public void testIntToShorts() throws Exception {\n+        assertArrayEquals(\n+            new short[]{}, Conversion.intToShorts(0x00000000, 0, new short[]{}, 0, 0));\n+        assertArrayEquals(\n+            new short[]{}, Conversion.intToShorts(0x00000000, 100, new short[]{}, 0, 0));\n+        assertArrayEquals(\n+            new short[]{}, Conversion.intToShorts(0x00000000, 0, new short[]{}, 100, 0));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xFFFF, (short)0xFFFF},\n+            Conversion.intToShorts(0x12345678, 0, new short[]{-1, -1, -1, -1}, 0, 0));\n+        assertArrayEquals(\n+            new short[]{(short)0x5678, (short)0xFFFF, (short)0xFFFF, (short)0xFFFF},\n+            Conversion.intToShorts(0x12345678, 0, new short[]{-1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0x5678, (short)0x1234, (short)0xFFFF, (short)0xFFFF},\n+            Conversion.intToShorts(0x12345678, 0, new short[]{-1, -1, -1, -1}, 0, 2));\n+        // assertArrayEquals(new\n+        // short[]{(short)0x5678,(short)0x1234,(short)0x5678,(short)0xFFFF},Conversion.intToShorts(0x12345678,\n+        // 0,new short[]{-1,-1,-1,-1},0,3));//rejected by assertion\n+        // assertArrayEquals(new\n+        // short[]{(short)0x5678,(short)0x1234,(short)0x5678,(short)0x1234},Conversion.intToShorts(0x12345678,\n+        // 0,new short[]{-1,-1,-1,-1},0,4));\n+        // assertArrayEquals(new\n+        // short[]{(short)0xFFFF,(short)0x5678,(short)0x1234,(short)0x5678},Conversion.intToShorts(0x12345678,\n+        // 0,new short[]{-1,-1,-1,-1},1,3));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x5678, (short)0x1234},\n+            Conversion.intToShorts(0x12345678, 0, new short[]{-1, -1, -1, -1}, 2, 2));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x5678, (short)0xFFFF},\n+            Conversion.intToShorts(0x12345678, 0, new short[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0xFFFF, (short)0x5678},\n+            Conversion.intToShorts(0x12345678, 0, new short[]{-1, -1, -1, -1}, 3, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x2B3C, (short)0xFFFF},\n+            Conversion.intToShorts(0x12345678, 1, new short[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x159E, (short)0xFFFF},\n+            Conversion.intToShorts(0x12345678, 2, new short[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x8ACF, (short)0xFFFF},\n+            Conversion.intToShorts(0x12345678, 3, new short[]{-1, -1, -1, -1}, 2, 1));\n+        assertArrayEquals(\n+            new short[]{(short)0xFFFF, (short)0xFFFF, (short)0x4567, (short)0xFFFF},\n+            Conversion.intToShorts(0x12345678, 4, new short[]{-1, -1, -1, -1}, 2, 1));\n+        // assertArrayEquals(new\n+        // short[]{(short)0xE6F7,(short)0x4855,(short)0x2B3C,(short)0x091A},Conversion.intToShorts(0x12345678,\n+        // 1,new short[]{-1,-1,-1,-1},0,4));//rejected by assertion\n+        // assertArrayEquals(new short[]{(short)0x2B3C},Conversion.intToShorts(0x12345678,33,new\n+        // short[]{0},0,1));//rejected by assertion\n+        assertArrayEquals(\n+            new short[]{(short)0x091A},\n+            Conversion.intToShorts(0x12345678, 17, new short[]{0}, 0, 1));\n+    }\n+\n+    public void testLongToBytes() throws Exception {\n+        assertArrayEquals(\n+            new byte[]{}, Conversion.longToBytes(0x0000000000000000L, 0, new byte[]{}, 0, 0));\n+        assertArrayEquals(\n+            new byte[]{}, Conversion.longToBytes(0x0000000000000000L, 100, new byte[]{}, 0, 0));\n+        assertArrayEquals(\n+            new byte[]{}, Conversion.longToBytes(0x0000000000000000L, 0, new byte[]{}, 100, 0));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 0));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xEF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xEF, (byte)0xCD, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 2));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 4));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0x78, (byte)0x56,\n+                (byte)0x34, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 7));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0x78, (byte)0x56,\n+                (byte)0x34, (byte)0x12, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 8));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 2));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xAB,\n+                (byte)0x90, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 4));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xAB,\n+                (byte)0x90, (byte)0x78, (byte)0x56, (byte)0x34, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 7));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xAB,\n+                (byte)0x90, (byte)0x78, (byte)0x56, (byte)0x34, (byte)0x12},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 8));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xF7, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 1, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0x7B, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 2, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0x6F, (byte)0x5E, (byte)0x85,\n+                (byte)0xC4, (byte)0xB3, (byte)0xA2, (byte)0x91, (byte)0x00},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 5, new byte[]{\n+                -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 8));\n+        // assertArrayEquals(new\n+        // byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0x85,(byte)0xC4,(byte)0xB3,(byte)0xA2,(byte)0x91,(byte)0x00,(byte)0x00},Conversion.longToBytes(0x1234567890ABCDEFL,13,new\n+        // byte[]{-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1},3,8));//rejected by assertion\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0x5E, (byte)0x85, (byte)0xC4,\n+                (byte)0xB3, (byte)0xA2, (byte)0x91, (byte)0x00, (byte)0xFF},\n+            Conversion.longToBytes(0x1234567890ABCDEFL, 13, new byte[]{\n+                -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 7));\n+    }\n+\n+    public void testIntToBytes() throws Exception {\n+        assertArrayEquals(\n+            new byte[]{}, Conversion.intToBytes(0x00000000, 0, new byte[]{}, 0, 0));\n+        assertArrayEquals(\n+            new byte[]{}, Conversion.intToBytes(0x00000000, 100, new byte[]{}, 0, 0));\n+        assertArrayEquals(\n+            new byte[]{}, Conversion.intToBytes(0x00000000, 0, new byte[]{}, 100, 0));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.intToBytes(0x90ABCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 0));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xEF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.intToBytes(0x90ABCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xEF, (byte)0xCD, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.intToBytes(0x90ABCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 2));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xEF, (byte)0xCD, (byte)0xAB, (byte)0x90, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.intToBytes(0x90ABCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 4));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.intToBytes(0x90ABCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.intToBytes(0x90ABCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 2));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xAB,\n+                (byte)0x90, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.intToBytes(0x90ABCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 4));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xF7, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.intToBytes(0x90ABCDEF, 1, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0x7B, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.intToBytes(0x90ABCDEF, 2, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0x6F, (byte)0x5E, (byte)0x85,\n+                (byte)0xFC, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.intToBytes(0x90ABCDEF, 5, new byte[]{\n+                -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 4));\n+        // assertArrayEquals(new\n+        // byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0x85,(byte)0xFC,(byte)0x00,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF},Conversion.intToBytes(0x90ABCDEF,13,new\n+        // byte[]{-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1},3,4));//rejected by assertion\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0x5E, (byte)0x85, (byte)0xFC,\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF},\n+            Conversion.intToBytes(0x90ABCDEF, 13, new byte[]{\n+                -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, 3, 3));\n+    }\n+\n+    public void testShortToBytes() throws Exception {\n+        assertArrayEquals(\n+            new byte[]{}, Conversion.shortToBytes((short)0x0000, 0, new byte[]{}, 0, 0));\n+        assertArrayEquals(\n+            new byte[]{}, Conversion.shortToBytes((short)0x0000, 100, new byte[]{}, 0, 0));\n+        assertArrayEquals(\n+            new byte[]{}, Conversion.shortToBytes((short)0x0000, 0, new byte[]{}, 100, 0));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF}, Conversion.shortToBytes((short)0xCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1}, 0, 0));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xEF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF}, Conversion.shortToBytes((short)0xCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xEF, (byte)0xCD, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF}, Conversion.shortToBytes((short)0xCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1}, 0, 2));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF}, Conversion.shortToBytes((short)0xCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1}, 3, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xEF, (byte)0xCD, (byte)0xFF,\n+                (byte)0xFF}, Conversion.shortToBytes((short)0xCDEF, 0, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1}, 3, 2));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xF7, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF}, Conversion.shortToBytes((short)0xCDEF, 1, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0x7B, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF}, Conversion.shortToBytes((short)0xCDEF, 2, new byte[]{\n+                -1, -1, -1, -1, -1, -1, -1}, 0, 1));\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0x6F, (byte)0xFE, (byte)0xFF,\n+                (byte)0xFF}, Conversion.shortToBytes((short)0xCDEF, 5, new byte[]{\n+                -1, 0, -1, -1, -1, -1, -1}, 3, 2));\n+        // assertArrayEquals(new\n+        // byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0xFF,(byte)0xFF,(byte)0xFF},Conversion.shortToBytes((short)0xCDEF,13,new\n+        // byte[]{-1, 0,-1,-1,-1,-1,-1},3,2));//rejected by assertion\n+        assertArrayEquals(\n+            new byte[]{\n+                (byte)0xFF, (byte)0x00, (byte)0xFF, (byte)0xFE, (byte)0xFF, (byte)0xFF,\n+                (byte)0xFF}, Conversion.shortToBytes((short)0xCDEF, 13, new byte[]{\n+                -1, 0, -1, -1, -1, -1, -1}, 3, 1));\n+    }\n+\n+    public void testLongToHexs() throws Exception {\n+        assertEquals(\"\", Conversion.longToHexs(0x0000000000000000L, 0, \"\", 0, 0));\n+        assertEquals(\"\", Conversion.longToHexs(0x0000000000000000L, 100, \"\", 0, 0));\n+        assertEquals(\"\", Conversion.longToHexs(0x0000000000000000L, 0, \"\", 100, 0));\n+        assertEquals(\n+            \"FFFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 0));\n+        assertEquals(\n+            \"3FFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDE3L, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 1));\n+        assertEquals(\n+            \"FEFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 2));\n+        assertEquals(\n+            \"FEDCFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 4));\n+        assertEquals(\n+            \"FEDCBA098765432FFFFFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 15));\n+        assertEquals(\n+            \"FEDCBA0987654321FFFFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 16));\n+        assertEquals(\n+            \"FFF3FFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDE3L, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 1));\n+        assertEquals(\n+            \"FFFFEFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 2));\n+        assertEquals(\n+            \"FFFFEDCFFFFFFFFFFFFFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 4));\n+        assertEquals(\n+            \"FFFFEDCBA098765432FFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 15));\n+        assertEquals(\n+            \"FFFFEDCBA0987654321FFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 16));\n+        assertEquals(\n+            \"7FFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 1, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 1));\n+        assertEquals(\n+            \"BFFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 2, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 1));\n+        assertEquals(\n+            \"FFFDB975121FCA86420FFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 3, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 16));\n+        // assertEquals(\"FFFFFFFFFFFFFFFFFFFFFFFF\",Conversion.longToHexs(0x1234567890ABCDEFL,4,\"FFFFFFFFFFFFFFFFFFFFFFFF\",3,16));//rejected\n+        // by assertion\n+        assertEquals(\n+            \"FFFEDCBA0987654321FFFFFF\",\n+            Conversion.longToHexs(0x1234567890ABCDEFL, 4, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 15));\n+    }\n+\n+    public void testIntToHexs() throws Exception {\n+        assertEquals(\"\", Conversion.intToHexs(0x00000000, 0, \"\", 0, 0));\n+        assertEquals(\"\", Conversion.intToHexs(0x00000000, 100, \"\", 0, 0));\n+        assertEquals(\"\", Conversion.intToHexs(0x00000000, 0, \"\", 100, 0));\n+        assertEquals(\n+            \"FFFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 0));\n+        assertEquals(\n+            \"3FFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDE3, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 1));\n+        assertEquals(\n+            \"FEFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 2));\n+        assertEquals(\n+            \"FEDCFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 4));\n+        assertEquals(\n+            \"FEDCBA0FFFFFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 7));\n+        assertEquals(\n+            \"FEDCBA09FFFFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 8));\n+        assertEquals(\n+            \"FFF3FFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDE3, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 1));\n+        assertEquals(\n+            \"FFFFEFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 2));\n+        assertEquals(\n+            \"FFFFEDCFFFFFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 4));\n+        assertEquals(\n+            \"FFFFEDCBA0FFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 7));\n+        assertEquals(\n+            \"FFFFEDCBA09FFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 8));\n+        assertEquals(\n+            \"7FFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 1, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 1));\n+        assertEquals(\n+            \"BFFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 2, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 1));\n+        assertEquals(\n+            \"FFFDB97512FFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 3, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 8));\n+        // assertEquals(\"FFFFFFFFFFFFFFFFFFFFFFFF\",Conversion.intToHexs(0x90ABCDEF,\n+        // 4,\"FFFFFFFFFFFFFFFFFFFFFFFF\",3,8));//rejected by assertion\n+        assertEquals(\n+            \"FFFEDCBA09FFFFFFFFFFFFFF\",\n+            Conversion.intToHexs(0x90ABCDEF, 4, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 7));\n+    }\n+\n+    public void testShortToHexs() throws Exception {\n+        assertEquals(\"\", Conversion.shortToHexs((short)0x0000, 0, \"\", 0, 0));\n+        assertEquals(\"\", Conversion.shortToHexs((short)0x0000, 100, \"\", 0, 0));\n+        assertEquals(\"\", Conversion.shortToHexs((short)0x0000, 0, \"\", 100, 0));\n+        assertEquals(\n+            \"FFFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.shortToHexs((short)0xCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 0));\n+        assertEquals(\n+            \"3FFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.shortToHexs((short)0xCDE3, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 1));\n+        assertEquals(\n+            \"FEFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.shortToHexs((short)0xCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 2));\n+        assertEquals(\n+            \"FEDFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.shortToHexs((short)0xCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 3));\n+        assertEquals(\n+            \"FEDCFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.shortToHexs((short)0xCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 4));\n+        assertEquals(\n+            \"FFF3FFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.shortToHexs((short)0xCDE3, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 1));\n+        assertEquals(\n+            \"FFFFEFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.shortToHexs((short)0xCDEF, 0, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 2));\n+        assertEquals(\n+            \"7FFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.shortToHexs((short)0xCDEF, 1, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 1));\n+        assertEquals(\n+            \"BFFFFFFFFFFFFFFFFFFFFFFF\",\n+            Conversion.shortToHexs((short)0xCDEF, 2, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 0, 1));\n+        assertEquals(\n+            \"FFFDB9FFFFFFFFFFFFFFFFFF\",\n+            Conversion.shortToHexs((short)0xCDEF, 3, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 4));\n+        // assertEquals(\"FFFFFFFFFFFFFFFFFFFFFFFF\",Conversion.shortToHexs((short)0xCDEF,\n+        // 4,\"FFFFFFFFFFFFFFFFFFFFFFFF\",3,4));//rejected by assertion\n+        assertEquals(\n+            \"FFFEDCFFFFFFFFFFFFFFFFFF\",\n+            Conversion.shortToHexs((short)0xCDEF, 4, \"FFFFFFFFFFFFFFFFFFFFFFFF\", 3, 3));\n+    }\n+\n+    public void testByteToHexs() throws Exception {\n+        assertEquals(\"\", Conversion.byteToHexs((byte)0x00, 0, \"\", 0, 0));\n+        assertEquals(\"\", Conversion.byteToHexs((byte)0x00, 100, \"\", 0, 0));\n+        assertEquals(\"\", Conversion.byteToHexs((byte)0x00, 0, \"\", 100, 0));\n+        assertEquals(\"00000\", Conversion.byteToHexs((byte)0xEF, 0, \"00000\", 0, 0));\n+        assertEquals(\"F0000\", Conversion.byteToHexs((byte)0xEF, 0, \"00000\", 0, 1));\n+        assertEquals(\"FE000\", Conversion.byteToHexs((byte)0xEF, 0, \"00000\", 0, 2));\n+        assertEquals(\"000F0\", Conversion.byteToHexs((byte)0xEF, 0, \"00000\", 3, 1));\n+        assertEquals(\"000FE\", Conversion.byteToHexs((byte)0xEF, 0, \"00000\", 3, 2));\n+        assertEquals(\"70000\", Conversion.byteToHexs((byte)0xEF, 1, \"00000\", 0, 1));\n+        assertEquals(\"B0000\", Conversion.byteToHexs((byte)0xEF, 2, \"00000\", 0, 1));\n+        assertEquals(\"000DF\", Conversion.byteToHexs((byte)0xEF, 3, \"00000\", 3, 2));\n+        // assertEquals(\"00000\",Conversion.byteToHexs((byte)0xEF, 4,\"00000\",3,2));//rejected by\n+        // assertion\n+        assertEquals(\"000E0\", Conversion.byteToHexs((byte)0xEF, 4, \"00000\", 3, 1));\n+    }\n+\n+    public void testLongToBools() throws Exception {\n+        assertArrayEquals(\n+            new boolean[]{},\n+            Conversion.longToBools(0x0000000000000000L, 0, new boolean[]{}, 0, 0));\n+        assertArrayEquals(\n+            new boolean[]{},\n+            Conversion.longToBools(0x0000000000000000L, 100, new boolean[]{}, 0, 0));\n+        assertArrayEquals(\n+            new boolean[]{},\n+            Conversion.longToBools(0x0000000000000000L, 0, new boolean[]{}, 100, 0));\n+        assertArrayEquals(\n+            new boolean[69],\n+            Conversion.longToBools(0x1234567890ABCDEFL, 0, new boolean[69], 0, 0));\n+\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false},\n+            Conversion.longToBools(0x1234567890ABCDEFL, 0, new boolean[69], 0, 1));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false},\n+            Conversion.longToBools(0x1234567890ABCDEFL, 0, new boolean[69], 0, 2));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, true, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false},\n+            Conversion.longToBools(0x1234567890ABCDEFL, 0, new boolean[69], 0, 3));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, true, true, false, true, true, true, true, false, true, true,\n+                false, false, true, true, true, true, false, true, false, true, false, true,\n+                false, false, false, false, true, false, false, true, false, false, false,\n+                true, true, true, true, false, false, true, true, false, true, false, true,\n+                false, false, false, true, false, true, true, false, false, false, true, false,\n+                false, true, false, false, false, false, false, false, false, false},\n+            Conversion.longToBools(0x1234567890ABCDEFL, 0, new boolean[69], 0, 63));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, true, true, false, true, true, true, true, false, true, true,\n+                false, false, true, true, true, true, false, true, false, true, false, true,\n+                false, false, false, false, true, false, false, true, false, false, false,\n+                true, true, true, true, false, false, true, true, false, true, false, true,\n+                false, false, false, true, false, true, true, false, false, false, true, false,\n+                false, true, false, false, false, false, false, false, false, false},\n+            Conversion.longToBools(0x1234567890ABCDEFL, 0, new boolean[69], 0, 64));\n+        assertArrayEquals(\n+            new boolean[]{\n+                false, false, true, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false},\n+            Conversion.longToBools(0x1234567890ABCDEFL, 0, new boolean[69], 2, 1));\n+        assertArrayEquals(\n+            new boolean[]{\n+                false, false, true, true, true, true, false, true, true, true, true, false,\n+                true, true, false, false, true, true, true, true, false, true, false, true,\n+                false, true, false, false, false, false, true, false, false, true, false,\n+                false, false, true, true, true, true, false, false, true, true, false, true,\n+                false, true, false, false, false, true, false, true, true, false, false, false,\n+                true, false, false, true, false, false, false, false, false, false},\n+            Conversion.longToBools(0x1234567890ABCDEFL, 0, new boolean[69], 2, 64));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, true, false, true, true, true, true, false, true, true, false,\n+                false, true, true, true, true, false, true, false, true, false, true, false,\n+                false, false, false, true, false, false, true, false, false, false, true, true,\n+                true, true, false, false, true, true, false, true, false, true, false, false,\n+                false, true, false, true, true, false, false, false, true, false, false, true,\n+                false, false, false, false, false, false, false, false, false},\n+            Conversion.longToBools(0x1234567890ABCDEFL, 1, new boolean[69], 0, 63));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, false, true, true, true, true, false, true, true, false, false,\n+                true, true, true, true, false, true, false, true, false, true, false, false,\n+                false, false, true, false, false, true, false, false, false, true, true, true,\n+                true, false, false, true, true, false, true, false, true, false, false, false,\n+                true, false, true, true, false, false, false, true, false, false, true, false,\n+                false, false, false, false, false, false, false, false, false},\n+            Conversion.longToBools(0x1234567890ABCDEFL, 2, new boolean[69], 0, 62));\n+\n+        // assertArrayEquals(new boolean[]{false,false,false, true, true, false, true, true,\n+        // true, true, false, true, true, false, false, true, true, true, true, false, true,\n+        // false, true, false, true, false, false, false, false, true, false, false, true,\n+        // false, false, false, true, true, true, true, false, false, true, true, false, true,\n+        // false, true, false, false, false, true, false, true, true, false, false, false, true,\n+        // false, false, true, false, false, false\n+        // ,false,false,false,false},Conversion.longToBools(0x1234567890ABCDEFL, 2,new\n+        // boolean[69], 3, 63));//rejected by assertion\n+        assertArrayEquals(\n+            new boolean[]{\n+                false, false, false, true, true, false, true, true, true, true, false, true,\n+                true, false, false, true, true, true, true, false, true, false, true, false,\n+                true, false, false, false, false, true, false, false, true, false, false,\n+                false, true, true, true, true, false, false, true, true, false, true, false,\n+                true, false, false, false, true, false, true, true, false, false, false, true,\n+                false, false, true, false, false, false, false, false, false, false},\n+            Conversion.longToBools(0x1234567890ABCDEFL, 2, new boolean[69], 3, 62));\n+    }\n+\n+    public void testIntToBools() throws Exception {\n+        assertArrayEquals(\n+            new boolean[]{}, Conversion.intToBools(0x00000000, 0, new boolean[]{}, 0, 0));\n+        assertArrayEquals(\n+            new boolean[]{}, Conversion.intToBools(0x00000000, 100, new boolean[]{}, 0, 0));\n+        assertArrayEquals(\n+            new boolean[]{}, Conversion.intToBools(0x00000000, 0, new boolean[]{}, 100, 0));\n+        assertArrayEquals(\n+            new boolean[69], Conversion.intToBools(0x90ABCDEF, 0, new boolean[69], 0, 0));\n+        assertArrayEquals(new boolean[]{\n+            true, false, false, false, false, false, false, false, false, false, false, false,\n+            false, false, false, false, false, false, false, false, false, false, false, false,\n+            false, false, false, false, false, false, false, false, false, false, false, false,\n+            false}, Conversion.intToBools(0x90ABCDEF, 0, new boolean[37], 0, 1));\n+        assertArrayEquals(new boolean[]{\n+            true, true, false, false, false, false, false, false, false, false, false, false,\n+            false, false, false, false, false, false, false, false, false, false, false, false,\n+            false, false, false, false, false, false, false, false, false, false, false, false,\n+            false}, Conversion.intToBools(0x90ABCDEF, 0, new boolean[37], 0, 2));\n+        assertArrayEquals(new boolean[]{\n+            true, true, true, false, false, false, false, false, false, false, false, false,\n+            false, false, false, false, false, false, false, false, false, false, false, false,\n+            false, false, false, false, false, false, false, false, false, false, false, false,\n+            false}, Conversion.intToBools(0x90ABCDEF, 0, new boolean[37], 0, 3));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, true, true, false, true, true, true, true, false, true, true,\n+                false, false, true, true, true, true, false, true, false, true, false, true,\n+                false, false, false, false, true, false, false, false, false, false, false,\n+                false, false}, Conversion.intToBools(0x90ABCDEF, 0, new boolean[37], 0, 31));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, true, true, false, true, true, true, true, false, true, true,\n+                false, false, true, true, true, true, false, true, false, true, false, true,\n+                false, false, false, false, true, false, false, true, false, false, false,\n+                false, false}, Conversion.intToBools(0x90ABCDEF, 0, new boolean[37], 0, 32));\n+        assertArrayEquals(new boolean[]{\n+            false, false, true, false, false, false, false, false, false, false, false, false,\n+            false, false, false, false, false, false, false, false, false, false, false, false,\n+            false, false, false, false, false, false, false, false, false, false, false, false,\n+            false}, Conversion.intToBools(0x90ABCDEF, 0, new boolean[37], 2, 1));\n+        assertArrayEquals(\n+            new boolean[]{\n+                false, false, true, true, true, true, false, true, true, true, true, false,\n+                true, true, false, false, true, true, true, true, false, true, false, true,\n+                false, true, false, false, false, false, true, false, false, true, false,\n+                false, false}, Conversion.intToBools(0x90ABCDEF, 0, new boolean[37], 2, 32));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, true, false, true, true, true, true, false, true, true, false,\n+                false, true, true, true, true, false, true, false, true, false, true, false,\n+                false, false, false, true, false, false, true, false, false, false, false,\n+                false, false}, Conversion.intToBools(0x90ABCDEF, 1, new boolean[37], 0, 31));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, false, true, true, true, true, false, true, true, false, false,\n+                true, true, true, true, false, true, false, true, false, true, false, false,\n+                false, false, true, false, false, true, false, false, false, false, false,\n+                false, false}, Conversion.intToBools(0x90ABCDEF, 2, new boolean[37], 0, 30));\n+        // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true,\n+        // true, true, false, true, true, false, false, true, true, true, true, false, true,\n+        // false, true, false, true, false, false, false, false, true, false, false, false,\n+        // false, false, false, false},Conversion.intToBools(0x90ABCDEF, 2,new boolean[37],\n+        // 3,31));//rejected by assertion\n+        assertArrayEquals(\n+            new boolean[]{\n+                false, false, false, true, true, false, true, true, true, true, false, true,\n+                true, false, false, true, true, true, true, false, true, false, true, false,\n+                true, false, false, false, false, true, false, false, true, false, false,\n+                false, false}, Conversion.intToBools(0x90ABCDEF, 2, new boolean[37], 3, 30));\n+    }\n+\n+    public void testShortToBools() throws Exception {\n+        assertArrayEquals(\n+            new boolean[]{}, Conversion.shortToBools((short)0x0000, 0, new boolean[]{}, 0, 0));\n+        assertArrayEquals(\n+            new boolean[]{}, Conversion.shortToBools((short)0x0000, 100, new boolean[]{}, 0, 0));\n+        assertArrayEquals(\n+            new boolean[]{}, Conversion.shortToBools((short)0x0000, 0, new boolean[]{}, 100, 0));\n+        assertArrayEquals(\n+            new boolean[69], Conversion.shortToBools((short)0xCDEF, 0, new boolean[69], 0, 0));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, false, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false},\n+            Conversion.shortToBools((short)0xCDEF, 0, new boolean[21], 0, 1));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, false, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false},\n+            Conversion.shortToBools((short)0xCDEF, 0, new boolean[21], 0, 2));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, true, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false},\n+            Conversion.shortToBools((short)0xCDEF, 0, new boolean[21], 0, 3));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, true, true, false, true, true, true, true, false, true, true,\n+                false, false, true, false, false, false, false, false, false},\n+            Conversion.shortToBools((short)0xCDEF, 0, new boolean[21], 0, 15));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, true, true, false, true, true, true, true, false, true, true,\n+                false, false, true, true, false, false, false, false, false},\n+            Conversion.shortToBools((short)0xCDEF, 0, new boolean[21], 0, 16));\n+        assertArrayEquals(\n+            new boolean[]{\n+                false, false, true, false, false, false, false, false, false, false, false,\n+                false, false, false, false, false, false, false, false, false, false},\n+            Conversion.shortToBools((short)0xCDEF, 0, new boolean[21], 2, 1));\n+        assertArrayEquals(\n+            new boolean[]{\n+                false, false, true, true, true, true, false, true, true, true, true, false,\n+                true, true, false, false, true, true, false, false, false},\n+            Conversion.shortToBools((short)0xCDEF, 0, new boolean[21], 2, 16));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, true, false, true, true, true, true, false, true, true, false,\n+                false, true, true, false, false, false, false, false, false},\n+            Conversion.shortToBools((short)0xCDEF, 1, new boolean[21], 0, 15));\n+        assertArrayEquals(\n+            new boolean[]{\n+                true, true, false, true, true, true, true, false, true, true, false, false,\n+                true, true, false, false, false, false, false, false, false},\n+            Conversion.shortToBools((short)0xCDEF, 2, new boolean[21], 0, 14));\n+        // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true,\n+        // true, true, false, true, true, false, false, true, false, false, false, false,\n+        // false},Conversion.shortToBools((short)0xCDEF, 2,new boolean[21], 3,15));//rejected by\n+        // assertion\n+        assertArrayEquals(\n+            new boolean[]{\n+                false, false, false, true, true, false, true, true, true, true, false, true,\n+                true, false, false, true, true, false, false, false, false},\n+            Conversion.shortToBools((short)0xCDEF, 2, new boolean[21], 3, 14));\n+    }\n+\n+    public void testByteToBools() throws Exception {\n+        assertArrayEquals(\n+            new boolean[]{}, Conversion.byteToBools((byte)0x00, 0, new boolean[]{}, 0, 0));\n+        assertArrayEquals(\n+            new boolean[]{}, Conversion.byteToBools((byte)0x00, 100, new boolean[]{}, 0, 0));\n+        assertArrayEquals(\n+            new boolean[]{}, Conversion.byteToBools((byte)0x00, 0, new boolean[]{}, 100, 0));\n+        assertArrayEquals(\n+            new boolean[69], Conversion.byteToBools((byte)0xEF, 0, new boolean[69], 0, 0));\n+        assertArrayEquals(new boolean[]{\n+            true, false, false, false, false, false, false, false, false, false, false, false,\n+            false}, Conversion.byteToBools((byte)0x95, 0, new boolean[13], 0, 1));\n+        assertArrayEquals(new boolean[]{\n+            true, false, false, false, false, false, false, false, false, false, false, false,\n+            false}, Conversion.byteToBools((byte)0x95, 0, new boolean[13], 0, 2));\n+        assertArrayEquals(new boolean[]{\n+            true, false, true, false, false, false, false, false, false, false, false, false,\n+            false}, Conversion.byteToBools((byte)0x95, 0, new boolean[13], 0, 3));\n+        assertArrayEquals(new boolean[]{\n+            true, false, true, false, true, false, false, false, false, false, false, false,\n+            false}, Conversion.byteToBools((byte)0x95, 0, new boolean[13], 0, 7));\n+        assertArrayEquals(new boolean[]{\n+            true, false, true, false, true, false, false, true, false, false, false, false,\n+            false}, Conversion.byteToBools((byte)0x95, 0, new boolean[13], 0, 8));\n+        assertArrayEquals(new boolean[]{\n+            false, false, true, false, false, false, false, false, false, false, false, false,\n+            false}, Conversion.byteToBools((byte)0x95, 0, new boolean[13], 2, 1));\n+        assertArrayEquals(new boolean[]{\n+            false, false, true, false, true, false, true, false, false, true, false, false,\n+            false}, Conversion.byteToBools((byte)0x95, 0, new boolean[13], 2, 8));\n+        assertArrayEquals(new boolean[]{\n+            false, true, false, true, false, false, true, false, false, false, false, false,\n+            false}, Conversion.byteToBools((byte)0x95, 1, new boolean[13], 0, 7));\n+        assertArrayEquals(new boolean[]{\n+            true, false, true, false, false, true, false, false, false, false, false, false,\n+            false}, Conversion.byteToBools((byte)0x95, 2, new boolean[13], 0, 6));\n+        // assertArrayEquals(new boolean[]{false, false, false, true, true, false, true, true,\n+        // false, false, false, false, false},Conversion.byteToBools((byte)0x95, 2,new\n+        // boolean[13], 3, 7));//rejected by assertion\n+        assertArrayEquals(new boolean[]{\n+            false, false, false, true, false, true, false, false, true, false, false, false,\n+            false}, Conversion.byteToBools((byte)0x95, 2, new boolean[13], 3, 6));\n+    }\n+\n+    boolean hasMethod(String methodName) {\n+        Method[] methods = this.getClass().getMethods();\n+        for (Method m : methods) {\n+            if (m.getName().equals(methodName)) return true;\n+        }\n+        return false;\n+    }\n+\n+    public void testTestsToCheckImplemented() throws Exception {\n+        if (!hasMethod(\"testIntsToLong\")) fail(\"test testIntsToLong not implemented\");\n+        if (!hasMethod(\"testShortsToLong\")) fail(\"test testShortsToLong not implemented\");\n+        if (!hasMethod(\"testShortsToInt\")) fail(\"test testShortsToInt not implemented\");\n+        if (!hasMethod(\"testBytesToLong\")) fail(\"test testBytesToLong not implemented\");\n+        if (!hasMethod(\"testBytesToInt\")) fail(\"test testBytesToInt not implemented\");\n+        if (!hasMethod(\"testBytesToShort\")) fail(\"test testBytesToShort not implemented\");\n+        if (!hasMethod(\"testHexsToLong\")) fail(\"test testHexsToLong not implemented\");\n+        if (!hasMethod(\"testHexsToInt\")) fail(\"test testHexsToInt not implemented\");\n+        if (!hasMethod(\"testHexsToShort\")) fail(\"test testHexsToShort not implemented\");\n+        if (!hasMethod(\"testHexsToByte\")) fail(\"test testHexsToByte not implemented\");\n+        if (!hasMethod(\"testBoolsToLong\")) fail(\"test testBoolsToLong not implemented\");\n+        if (!hasMethod(\"testBoolsToInt\")) fail(\"test testBoolsToInt not implemented\");\n+        if (!hasMethod(\"testBoolsToShort\")) fail(\"test testBoolsToShort not implemented\");\n+        if (!hasMethod(\"testBoolsToByte\")) fail(\"test testBoolsToByte not implemented\");\n+        if (!hasMethod(\"testLongToInts\")) fail(\"test testLongToInts not implemented\");\n+        if (!hasMethod(\"testLongToShorts\")) fail(\"test testLongToShorts not implemented\");\n+        if (!hasMethod(\"testIntToShorts\")) fail(\"test testIntToShorts not implemented\");\n+        if (!hasMethod(\"testLongToBytes\")) fail(\"test testLongToBytes not implemented\");\n+        if (!hasMethod(\"testIntToBytes\")) fail(\"test testIntToBytes not implemented\");\n+        if (!hasMethod(\"testShortToBytes\")) fail(\"test testShortToBytes not implemented\");\n+        if (!hasMethod(\"testLongToHexs\")) fail(\"test testLongToHexs not implemented\");\n+        if (!hasMethod(\"testIntToHexs\")) fail(\"test testIntToHexs not implemented\");\n+        if (!hasMethod(\"testShortToHexs\")) fail(\"test testShortToHexs not implemented\");\n+        if (!hasMethod(\"testByteToHexs\")) fail(\"test testByteToHexs not implemented\");\n+        if (!hasMethod(\"testLongToBools\")) fail(\"test testLongToBools not implemented\");\n+        if (!hasMethod(\"testIntToBools\")) fail(\"test testIntToBools not implemented\");\n+        if (!hasMethod(\"testShortToBools\")) fail(\"test testShortToBools not implemented\");\n+        if (!hasMethod(\"testByteToBools\")) fail(\"test testByteToBools not implemented\");\n+    }\n+\n+}", "timestamp": 1348769348, "metainfo": ""}