{"sha": "5a333944433722399313c3e10b552eb1aff9599b", "log": "[LANG-609] Added AtomicSafeInitializer class. Thanks to alexander dot apanasovich at gmail dot com for the proposal.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/AtomicSafeInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * <p>\n+ * A specialized {@code ConcurrentInitializer} implementation which is similar\n+ * to {@link AtomicInitializer}, but ensures that the {@link #initialize()}\n+ * method is called only once.\n+ * </p>\n+ * <p>\n+ * As {@link AtomicInitializer} this class is based on atomic variables, so it\n+ * can create an object under concurrent access without synchronization.\n+ * However, it implements an additional check to guarantee that the\n+ * {@link #initialize()} method which actually creates the object cannot be\n+ * called multiple times.\n+ * </p>\n+ * <p>\n+ * Because of this additional check this implementation is slightly less\n+ * efficient than {@link AtomicInitializer}, but if the object creation in the\n+ * {@code initialize()} method is expensive or if multiple invocations of\n+ * {@code initialize()} are problematic, it is the better alternative.\n+ * </p>\n+ * <p>\n+ * From its semantics this class has the same properties as\n+ * {@link LazyInitializer}. It is a &quot;save&quot; implementation of the lazy\n+ * initializer pattern. Comparing both classes in terms of efficiency is\n+ * difficult because which one is faster depends on multiple factors. Because\n+ * {@code AtomicSafeInitializer} does not use synchronization at all it probably\n+ * outruns {@link LazyInitializer}, at least under low or moderate concurrent\n+ * access. Developers should run their own benchmarks on the expected target\n+ * platform to decide which implementation is suitable for their specific use\n+ * case.\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ * @param <T> the type of the object managed by this initializer class\n+ */\n+public abstract class AtomicSafeInitializer<T> implements\n+        ConcurrentInitializer<T> {\n+    /** A guard which ensures that initialize() is called only once. */\n+    private final AtomicReference<AtomicSafeInitializer<T>> factory =\n+            new AtomicReference<AtomicSafeInitializer<T>>();\n+\n+    /** Holds the reference to the managed object. */\n+    private final AtomicReference<T> reference = new AtomicReference<T>();\n+\n+    /**\n+     * Get (and initialize, if not initialized yet) the required object\n+     *\n+     * @return lazily initialized object\n+     */\n+    public final T get() throws ConcurrentException {\n+        T result;\n+\n+        while ((result = reference.get()) == null) {\n+            if (factory.compareAndSet(null, this)) {\n+                reference.set(initialize());\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Creates and initializes the object managed by this\n+     * {@code AtomicInitializer}. This method is called by {@link #get()} when\n+     * the managed object is not available yet. An implementation can focus on\n+     * the creation of the object. No synchronization is needed, as this is\n+     * already handled by {@code get()}. This method is guaranteed to be called\n+     * only once.\n+     *\n+     * @return the managed data object\n+     * @throws ConcurrentException if an error occurs during object creation\n+     */\n+    protected abstract T initialize() throws ConcurrentException;\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/AtomicSafeInitializerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for {@code AtomicSafeInitializer}.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class AtomicSafeInitializerTest extends\n+        AbstractConcurrentInitializerTest {\n+    /** The instance to be tested. */\n+    private AtomicSafeInitializerTestImpl initializer;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        initializer = new AtomicSafeInitializerTestImpl();\n+    }\n+\n+    /**\n+     * Returns the initializer to be tested.\n+     *\n+     * @return the {@code AtomicSafeInitializer} under test\n+     */\n+    @Override\n+    protected ConcurrentInitializer<Object> createInitializer() {\n+        return initializer;\n+    }\n+\n+    /**\n+     * Tests that initialize() is called only once.\n+     */\n+    @Test\n+    public void testNumberOfInitializeInvocations() throws ConcurrentException,\n+            InterruptedException {\n+        testGetConcurrent();\n+        assertEquals(\"Wrong number of invocations\", 1,\n+                initializer.initCounter.get());\n+    }\n+\n+    /**\n+     * A concrete test implementation of {@code AtomicSafeInitializer}. This\n+     * implementation also counts the number of invocations of the initialize()\n+     * method.\n+     */\n+    private static class AtomicSafeInitializerTestImpl extends\n+            AtomicSafeInitializer<Object> {\n+        /** A counter for initialize() invocations. */\n+        final AtomicInteger initCounter = new AtomicInteger();\n+\n+        @Override\n+        protected Object initialize() throws ConcurrentException {\n+            initCounter.incrementAndGet();\n+            return new Object();\n+        }\n+    }\n+}", "timestamp": 1286636178, "metainfo": ""}