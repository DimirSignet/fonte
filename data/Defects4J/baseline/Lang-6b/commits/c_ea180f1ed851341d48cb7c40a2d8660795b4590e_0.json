{"sha": "ea180f1ed851341d48cb7c40a2d8660795b4590e", "log": "Document exceptions. Use IllegalArgumentException instead of assert. Throw IllegalArgumentException for empty arrays.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/Conversion.java\n+++ b/src/main/java/org/apache/commons/lang3/Conversion.java\n      * </p>\n      * \n      * @param hexDigit the hexadecimal digit to convert\n-     * @return an int equals to <code>hexDigit</code>\n+     * @return an int equals to {@code hexDigit}\n+     * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n      */\n     public static int hexDigitToInt(char hexDigit) {\n         final int digit = Character.digit(hexDigit, 16);\n      * </p>\n      * \n      * @param hexDigit the hexadecimal digit to convert\n-     * @return an int equals to <code>hexDigit</code>\n+     * @return an int equals to {@code hexDigit}\n+     * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n      */\n     public static int hexDigitM0ToInt(char hexDigit) {\n         switch (hexDigit) {\n      * </p>\n      * \n      * @param hexDigit the hexadecimal digit to convert\n-     * @return a boolean array with the binary representation of <code>hexDigit</code>\n+     * @return a boolean array with the binary representation of {@code hexDigit}\n+     * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n      */\n     public static boolean[] hexDigitToBools(char hexDigit) {\n         switch (hexDigit) {\n      * </p>\n      * \n      * @param hexDigit the hexadecimal digit to convert\n-     * @return a boolean array with the binary representation of <code>hexDigit</code>\n+     * @return a boolean array with the binary representation of {@code hexDigit}\n+     * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n      */\n     public static boolean[] hexDigitM0ToBools(char hexDigit) {\n         switch (hexDigit) {\n      * \n      * @param src the boolean array to convert\n      * @return a hexadecimal digit representing the selected bits\n+     * @throws IllegalArgumentException if {@code src} is empty \n+     * @throws NullPointerException  if {@code src} is {@code null}\n      */\n     public static char boolsToHexDigit(boolean[] src) {\n         return boolsToHexDigit(src, 0);\n      * @param src the boolean array to convert\n      * @param srcPos the position of the lsb to start the conversion\n      * @return a hexadecimal digit representing the selected bits\n+     * @throws IllegalArgumentException if {@code src} is empty \n+     * @throws NullPointerException  if {@code src} is {@code null}\n      */\n     public static char boolsToHexDigit(boolean[] src, int srcPos) {\n+        if (src.length == 0)\n+            throw new IllegalArgumentException(\"Cannot convert empty array.\");\n         if (src.length > srcPos + 3 && src[srcPos + 3]) {\n             if (src.length > srcPos + 2 && src[srcPos + 2]) {\n                 if (src.length > srcPos + 1 && src[srcPos + 1]) {\n      * \n      * @param src the boolean array to convert\n      * @return a hexadecimal digit representing the selected bits\n-     * @warning src.length must be >= 4.\n+     * @throws IllegalArgumentException if {@code src} is empty, {@code src.length < 4} or {@code src.length > 8} \n+     * @throws NullPointerException  if {@code src} is {@code null}\n      */\n     public static char boolsToHexDigitM0_4bits(boolean[] src) {\n         return boolsToHexDigitM0_4bits(src, 0);\n      * @param src the boolean array to convert\n      * @param srcPos the position of the lsb to start the conversion\n      * @return a hexadecimal digit representing the selected bits\n-     * @warning src.length must be 8 at most.\n-     * @warning srcPos+4 must be <= src.length.\n+     * @throws IllegalArgumentException if {@code src} is empty, {@code src.length > 8} or {@code src.length - srcPos < 4}  \n+     * @throws NullPointerException  if {@code src} is {@code null}\n      */\n     public static char boolsToHexDigitM0_4bits(boolean[] src, int srcPos) {\n         if (src.length > 8)\n      * \n      * @param src the boolean array to convert\n      * @return a hexadecimal digit representing the selected bits\n+     * @throws IllegalArgumentException if {@code src} is empty\n+     * @throws NullPointerException  if {@code src} is {@code null}\n      */\n     public static char boolsBeM0ToHexDigit(boolean[] src) {\n         return boolsBeM0ToHexDigit(src, 0);\n      * @param src the boolean array to convert\n      * @param srcPos the position of the lsb to start the conversion\n      * @return a hexadecimal digit representing the selected bits\n+     * @throws IllegalArgumentException if {@code src} is empty\n+     * @throws NullPointerException  if {@code src} is {@code null}\n      */\n     public static char boolsBeM0ToHexDigit(boolean[] src, int srcPos) {\n+        if (src.length == 0)\n+            throw new IllegalArgumentException(\"Cannot convert empty array.\");\n         int beSrcPos = src.length - 1 - srcPos;\n         int srcLen = Math.min(4, beSrcPos + 1);\n         boolean[] paddedSrc = new boolean[4];\n      * 10 returns 'A' and so on...\n      * </p>\n      * \n-     * @param nibble the int to convert, value outside of the range [0:15] are not allowed.\n-     * @return a hexadecimal digit representing the 4 lsb of <code>nibble</code>\n+     * @param nibble the int to convert\n+     * @return a hexadecimal digit representing the 4 lsb of {@code nibble}\n+     * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}   \n      */\n     public static char intToHexDigit(int nibble) {\n         char c = Character.forDigit(nibble, 16);\n-        if (c == Character.MIN_VALUE) {\n+        if (c == Character.MIN_VALUE)\n             throw new IllegalArgumentException(\"nibble value not between 0 and 15: \" + nibble);\n-        }\n         return c;\n     }\n \n      * 10 returns '5' and so on...\n      * </p>\n      * \n-     * @param nibble the int to convert, value outside of the range [0:15] are not allowed.\n-     * @return a hexadecimal digit representing the 4 lsb of <code>nibble</code>\n+     * @param nibble the int to convert\n+     * @return a hexadecimal digit representing the 4 lsb of {@code nibble}\n+     * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}   \n      */\n     public static char intToHexDigitM0(int nibble) {\n         switch (nibble) {\n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in int unit, from where to start the\n+     * @param srcPos the position in {@code src}, in int unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination long\n      * @param dstPos the position of the lsb, in bits, in the result long\n      * @param nInts the number of int to convert\n      * @return a long containing the selected bits\n+     * @throws IllegalArgumentException if {@code (nInts-1)*32+dstPos >= 64}   \n      */\n     public static long intsToLong(int[] src, int srcPos, long dstInit, int dstPos, int nInts) {\n-        if (0 == nInts) return dstInit;\n+        if (0 == nInts)\n+            return dstInit;\n+        if ((nInts-1)*32+dstPos >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nInts-1)*32+dstPos is greather or equal to than 64\");\n         long out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nInts; i++ ) {\n             long mask = (0xffffffffL << shift);\n             out = ((out & ~mask) | bits);\n         }\n-        if (shift >= 64)\n-            throw new IllegalArgumentException(\n-                \"(nInts-1)*32+dstPos is greather or equal to than 64\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in short unit, from where to start the\n+     * @param srcPos the position in {@code src}, in short unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination long\n      * @param dstPos the position of the lsb, in bits, in the result long\n      * @param nShorts the number of short to convert\n      * @return a long containing the selected bits\n+     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 64}   \n      */\n     public static long shortsToLong(short[] src, int srcPos, long dstInit, int dstPos,\n         int nShorts) {\n-        if (0 == nShorts) return dstInit;\n+        if (0 == nShorts) \n+            return dstInit;\n+        if ((nShorts-1)*16+dstPos >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nShorts-1)*16+dstPos is greather or equal to than 64\");\n         long out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nShorts; i++ ) {\n             long mask = 0xffffL << shift;\n             out = (out & ~mask) | bits;\n         }\n-        if (shift >= 64)\n-            throw new IllegalArgumentException(\n-                \"(nShorts-1)*16+dstPos is greather or equal to than 64\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in short unit, from where to start the\n+     * @param srcPos the position in {@code src}, in short unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination int\n      * @param dstPos the position of the lsb, in bits, in the result int\n      * @param nShorts the number of short to convert\n      * @return a int containing the selected bits\n+     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 32}   \n      */\n     public static int shortsToInt(short[] src, int srcPos, int dstInit, int dstPos, int nShorts) {\n-        if (0 == nShorts) return dstInit;\n+        if (0 == nShorts) \n+            return dstInit;\n+        if ((nShorts-1)*16+dstPos >= 32)\n+            throw new IllegalArgumentException(\n+                \"(nShorts-1)*16+dstPos is greather or equal to than 32\");\n         int out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nShorts; i++ ) {\n             int mask = 0xffff << shift;\n             out = (out & ~mask) | bits;\n         }\n-        if (shift >= 32)\n-            throw new IllegalArgumentException(\n-                \"(nShorts-1)*16+dstPos is greather or equal to than 32\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in byte unit, from where to start the\n+     * @param srcPos the position in {@code src}, in byte unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination long\n      * @param dstPos the position of the lsb, in bits, in the result long\n      * @param nBytes the number of byte to convert\n      * @return a long containing the selected bits\n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 64}   \n      */\n     public static long bytesToLong(byte[] src, int srcPos, long dstInit, int dstPos, int nBytes) {\n-        if (0 == nBytes) return dstInit;\n+        if (0 == nBytes) \n+            return dstInit;\n+        if ((nBytes-1)*8+dstPos >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nBytes-1)*8+dstPos is greather or equal to than 64\");\n         long out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             long mask = 0xffL << shift;\n             out = (out & ~mask) | bits;\n         }\n-        if (shift >= 64)\n-            throw new IllegalArgumentException(\n-                \"(nBytes-1)*8+dstPos is greather or equal to than 64\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in byte unit, from where to start the\n+     * @param srcPos the position in {@code src}, in byte unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination int\n      * @param dstPos the position of the lsb, in bits, in the result int\n      * @param nBytes the number of byte to convert\n      * @return a int containing the selected bits\n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 32}   \n      */\n     public static int bytesToInt(byte[] src, int srcPos, int dstInit, int dstPos, int nBytes) {\n-        if (0 == nBytes) return dstInit;\n+        if (0 == nBytes) \n+            return dstInit;\n+        if ((nBytes-1)*8+dstPos >= 32)\n+            throw new IllegalArgumentException(\n+                \"(nBytes-1)*8+dstPos is greather or equal to than 32\");\n         int out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             int mask = 0xff << shift;\n             out = (out & ~mask) | bits;\n         }\n-        if (shift >= 32)\n-            throw new IllegalArgumentException(\n-                \"(nBytes-1)*8+dstPos is greather or equal to than 32\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in byte unit, from where to start the\n+     * @param srcPos the position in {@code src}, in byte unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination short\n      * @param dstPos the position of the lsb, in bits, in the result short\n      * @param nBytes the number of byte to convert\n      * @return a short containing the selected bits\n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 16}   \n      */\n     public static short bytesToShort(byte[] src, int srcPos, short dstInit, int dstPos,\n         int nBytes) {\n-        if (0 == nBytes) return dstInit;\n+        if (0 == nBytes) \n+            return dstInit;\n+        if ((nBytes-1)*8+dstPos >= 16)\n+            throw new IllegalArgumentException(\n+                \"(nBytes-1)*8+dstPos is greather or equal to than 16\");\n         short out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             int mask = 0xff << shift;\n             out = (short)((out & ~mask) | bits);\n         }\n-        if (shift >= 16)\n-            throw new IllegalArgumentException(\n-                \"(nBytes-1)*8+dstPos is greather or equal to than 16\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in Char unit, from where to start the\n+     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination long\n      * @param dstPos the position of the lsb, in bits, in the result long\n      * @param nHexs the number of Char to convert\n      * @return a long containing the selected bits\n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 64}   \n      */\n     public static long hexsToLong(String src, int srcPos, long dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs) return dstInit;\n+        if (0 == nHexs)\n+            return dstInit;\n+        if ((nHexs-1)*4+dstPos >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+dstPos is greather or equal to than 64\");\n         long out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n             long mask = 0xfL << shift;\n             out = (out & ~mask) | bits;\n         }\n-        if (shift >= 64)\n-            throw new IllegalArgumentException(\n-                \"(nHexs-1)*4+dstPos is greather or equal to than 64\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in Char unit, from where to start the\n+     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination int\n      * @param dstPos the position of the lsb, in bits, in the result int\n      * @param nHexs the number of Char to convert\n      * @return a int containing the selected bits\n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 32}   \n      */\n     public static int hexsToInt(String src, int srcPos, int dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs) return dstInit;\n+        if (0 == nHexs) \n+            return dstInit;\n+        if ((nHexs-1)*4+dstPos >= 32)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+dstPos is greather or equal to than 32\");\n         int out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n             int mask = 0xf << shift;\n             out = (out & ~mask) | bits;\n         }\n-        if (shift >= 32)\n-            throw new IllegalArgumentException(\n-                \"(nHexs-1)*4+dstPos is greather or equal to than 32\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in Char unit, from where to start the\n+     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination short\n      * @param dstPos the position of the lsb, in bits, in the result short\n      * @param nHexs the number of Char to convert\n      * @return a short containing the selected bits\n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 16}   \n      */\n     public static short hexsToShort(String src, int srcPos, short dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs) return dstInit;\n+        if (0 == nHexs) \n+            return dstInit;\n+        if ((nHexs-1)*4+dstPos >= 16)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+dstPos is greather or equal to than 16\");\n         short out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n             int mask = 0xf << shift;\n             out = (short)((out & ~mask) | bits);\n         }\n-        if (shift >= 16)\n-            throw new IllegalArgumentException(\n-                \"(nHexs-1)*4+dstPos is greather or equal to than 16\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in Char unit, from where to start the\n+     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination byte\n      * @param dstPos the position of the lsb, in bits, in the result byte\n      * @param nHexs the number of Char to convert\n      * @return a byte containing the selected bits\n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 8}   \n      */\n     public static byte hexsToByte(String src, int srcPos, byte dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs) return dstInit;\n+        if (0 == nHexs) \n+            return dstInit;\n+        if ((nHexs-1)*4+dstPos >= 8)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+dstPos is greather or equal to than 8\");\n         byte out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n             int mask = 0xf << shift;\n             out = (byte)((out & ~mask) | bits);\n         }\n-        if (shift >= 8)\n-            throw new IllegalArgumentException(\n-                \"(nHexs-1)*4+dstPos is greather or equal to than 8\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in boolean unit, from where to start the\n+     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination long\n      * @param dstPos the position of the lsb, in bits, in the result long\n      * @param nBools the number of boolean to convert\n      * @return a long containing the selected bits\n+     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 64}   \n      */\n     public static long boolsToLong(boolean[] src, int srcPos, long dstInit, int dstPos,\n         int nBools) {\n-        if (0 == nBools) return dstInit;\n+        if (0 == nBools) \n+            return dstInit;\n+        if (nBools-1+dstPos >= 64)\n+            throw new IllegalArgumentException(\n+                \"nBools-1+dstPos is greather or equal to than 64\");\n         long out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             long mask = 0x1L << shift;\n             out = (out & ~mask) | bits;\n         }\n-        if (shift >= 64)\n-            throw new IllegalArgumentException(\n-                \"(nBools-1)*1+dstPos is greather or equal to than 64\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in boolean unit, from where to start the\n+     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination int\n      * @param dstPos the position of the lsb, in bits, in the result int\n      * @param nBools the number of boolean to convert\n      * @return a int containing the selected bits\n+     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 32}   \n      */\n     public static int boolsToInt(boolean[] src, int srcPos, int dstInit, int dstPos, int nBools) {\n-        if (0 == nBools) return dstInit;\n+        if (0 == nBools)\n+            return dstInit;\n+        if (nBools-1+dstPos >= 32)\n+            throw new IllegalArgumentException(\n+                \"nBools-1+dstPos is greather or equal to than 32\");\n         int out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             int mask = 0x1 << shift;\n             out = (out & ~mask) | bits;\n         }\n-        if (shift >= 32)\n-            throw new IllegalArgumentException(\n-                \"(nBools-1)*1+dstPos is greather or equal to than 32\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in boolean unit, from where to start the\n+     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination short\n      * @param dstPos the position of the lsb, in bits, in the result short\n      * @param nBools the number of boolean to convert\n      * @return a short containing the selected bits\n+     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 16}   \n      */\n     public static short boolsToShort(boolean[] src, int srcPos, short dstInit, int dstPos,\n         int nBools) {\n-        if (0 == nBools) return dstInit;\n+        if (0 == nBools)\n+            return dstInit;\n+        if (nBools-1+dstPos >= 16)\n+            throw new IllegalArgumentException(\n+                \"nBools-1+dstPos is greather or equal to than 16\");\n         short out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             int mask = 0x1 << shift;\n             out = (short)((out & ~mask) | bits);\n         }\n-        if (shift >= 16)\n-            throw new IllegalArgumentException(\n-                \"(nBools-1)*1+dstPos is greather or equal to than 16\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the int array to convert\n-     * @param srcPos the position in <code>src</code>, in boolean unit, from where to start the\n+     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n      *            conversion\n      * @param dstInit initial value of the destination byte\n      * @param dstPos the position of the lsb, in bits, in the result byte\n      * @param nBools the number of boolean to convert\n      * @return a byte containing the selected bits\n+     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 8}   \n      */\n     public static byte boolsToByte(boolean[] src, int srcPos, byte dstInit, int dstPos,\n         int nBools) {\n-        if (0 == nBools) return dstInit;\n+        if (0 == nBools)\n+            return dstInit;\n+        if (nBools-1+dstPos >= 8)\n+            throw new IllegalArgumentException(\n+                \"nBools-1+dstPos is greather or equal to than 8\");\n         byte out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             int mask = 0x1 << shift;\n             out = (byte)((out & ~mask) | bits);\n         }\n-        if (shift >= 8)\n-            throw new IllegalArgumentException(\n-                \"(nBools-1)*1+dstPos is greather or equal to than 8\");\n         return out;\n     }\n \n      * </p>\n      * \n      * @param src the long to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dst the destination array\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nInts the number of int to copy to <code>dst</code>. must be smaller or equal to\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nInts the number of int to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code (nInts-1)*32+srcPos >= 64}   \n      */\n     public static int[] longToInts(long src, int srcPos, int[] dst, int dstPos, int nInts) {\n-        if (0 == nInts) return dst;\n-        int shift = 0;\n-        assert ((nInts - 1) * 32 < 64 - srcPos);\n+        if (0 == nInts)\n+            return dst;\n+        if ((nInts - 1) * 32 + srcPos >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nInts-1)*32+srcPos is greather or equal to than 64\");\n+        int shift = 0;\n         for (int i = 0; i < nInts; i++ ) {\n             shift = i * 32 + srcPos;\n             dst[dstPos + i] = (int)(0xffffffff & (src >> shift));\n      * </p>\n      * \n      * @param src the long to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dst the destination array\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nShorts the number of short to copy to <code>dst</code>. must be smaller or equal\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nShorts the number of short to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 64}   \n      */\n     public static short[] longToShorts(long src, int srcPos, short[] dst, int dstPos,\n         int nShorts) {\n-        if (0 == nShorts) return dst;\n-        int shift = 0;\n-        assert ((nShorts - 1) * 16 < 64 - srcPos);\n+        if (0 == nShorts)\n+            return dst;\n+        if ((nShorts - 1) * 16 + srcPos >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nShorts-1)*16+srcPos is greather or equal to than 64\");\n+        int shift = 0;\n         for (int i = 0; i < nShorts; i++ ) {\n             shift = i * 16 + srcPos;\n             dst[dstPos + i] = (short)(0xffff & (src >> shift));\n      * </p>\n      * \n      * @param src the int to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dst the destination array\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nShorts the number of short to copy to <code>dst</code>. must be smaller or equal\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nShorts the number of short to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 32}   \n      */\n     public static short[] intToShorts(int src, int srcPos, short[] dst, int dstPos, int nShorts) {\n-        if (0 == nShorts) return dst;\n-        int shift = 0;\n-        assert ((nShorts - 1) * 16 < 32 - srcPos);\n+        if (0 == nShorts) \n+            return dst;\n+        if ((nShorts - 1) * 16 + srcPos >= 32)\n+            throw new IllegalArgumentException(\n+                \"(nShorts-1)*16+srcPos is greather or equal to than 32\");\n+        int shift = 0;\n         for (int i = 0; i < nShorts; i++ ) {\n             shift = i * 16 + srcPos;\n             dst[dstPos + i] = (short)(0xffff & (src >> shift));\n      * </p>\n      * \n      * @param src the long to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dst the destination array\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nBytes the number of byte to copy to <code>dst</code>. must be smaller or equal to\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nBytes the number of byte to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 64}   \n      */\n     public static byte[] longToBytes(long src, int srcPos, byte[] dst, int dstPos, int nBytes) {\n-        if (0 == nBytes) return dst;\n-        int shift = 0;\n-        assert ((nBytes - 1) * 8 < 64 - srcPos);\n+        if (0 == nBytes)\n+            return dst;\n+        if ((nBytes - 1) * 8 + srcPos >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nBytes-1)*8+srcPos is greather or equal to than 64\");\n+        int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             shift = i * 8 + srcPos;\n             dst[dstPos + i] = (byte)(0xff & (src >> shift));\n      * </p>\n      * \n      * @param src the int to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dst the destination array\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nBytes the number of byte to copy to <code>dst</code>. must be smaller or equal to\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nBytes the number of byte to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 32}   \n      */\n     public static byte[] intToBytes(int src, int srcPos, byte[] dst, int dstPos, int nBytes) {\n-        if (0 == nBytes) return dst;\n-        int shift = 0;\n-        assert ((nBytes - 1) * 8 < 32 - srcPos);\n+        if (0 == nBytes)\n+            return dst;\n+        if ((nBytes - 1) * 8 + srcPos >= 32)\n+            throw new IllegalArgumentException(\n+                \"(nBytes-1)*8+srcPos is greather or equal to than 32\");\n+        int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             shift = i * 8 + srcPos;\n             dst[dstPos + i] = (byte)(0xff & (src >> shift));\n      * </p>\n      * \n      * @param src the short to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dst the destination array\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nBytes the number of byte to copy to <code>dst</code>. must be smaller or equal to\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nBytes the number of byte to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 16}   \n      */\n     public static byte[] shortToBytes(short src, int srcPos, byte[] dst, int dstPos, int nBytes) {\n-        if (0 == nBytes) return dst;\n-        int shift = 0;\n-        assert ((nBytes - 1) * 8 < 16 - srcPos);\n+        if (0 == nBytes)\n+            return dst;\n+        if ((nBytes - 1) * 8 + srcPos >= 16)\n+            throw new IllegalArgumentException(\n+                \"(nBytes-1)*8+srcPos is greather or equal to than 16\");\n+        int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             shift = i * 8 + srcPos;\n             dst[dstPos + i] = (byte)(0xff & (src >> shift));\n      * </p>\n      * \n      * @param src the long to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dstInit the initial value for the result String\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nHexs the number of Char to copy to <code>dst</code>. must be smaller or equal to\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nHexs the number of Char to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 64}   \n      */\n     public static String longToHexs(long src, int srcPos, String dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs) return dstInit;\n+        if (0 == nHexs)\n+            return dstInit;\n+        if ((nHexs - 1) * 4 + srcPos >= 64)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+srcPos is greather or equal to than 64\");\n         StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n-        assert ((nHexs - 1) * 4 < 64 - srcPos);\n         for (int i = 0; i < nHexs; i++ ) {\n             shift = i * 4 + srcPos;\n             int bits = (int)(0xF & (src >> shift));\n      * </p>\n      * \n      * @param src the int to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dstInit the initial value for the result String\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nHexs the number of Char to copy to <code>dst</code>. must be smaller or equal to\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nHexs the number of Char to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 32}   \n      */\n     public static String intToHexs(int src, int srcPos, String dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs) return dstInit;\n+        if (0 == nHexs)\n+            return dstInit;\n+        if ((nHexs - 1) * 4 + srcPos >= 32)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+srcPos is greather or equal to than 32\");\n         StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n-        assert ((nHexs - 1) * 4 < 32 - srcPos);\n         for (int i = 0; i < nHexs; i++ ) {\n             shift = i * 4 + srcPos;\n             int bits = 0xF & (src >> shift);\n      * </p>\n      * \n      * @param src the short to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dstInit the initial value for the result String\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nHexs the number of Char to copy to <code>dst</code>. must be smaller or equal to\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nHexs the number of Char to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 16}   \n      */\n     public static String shortToHexs(short src, int srcPos, String dstInit, int dstPos,\n         int nHexs) {\n-        if (0 == nHexs) return dstInit;\n+        if (0 == nHexs)\n+            return dstInit;\n+        if ((nHexs - 1) * 4 + srcPos >= 16)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+srcPos is greather or equal to than 16\");\n         StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n-        assert ((nHexs - 1) * 4 < 16 - srcPos);\n         for (int i = 0; i < nHexs; i++ ) {\n             shift = i * 4 + srcPos;\n             int bits = 0xF & (src >> shift);\n      * </p>\n      * \n      * @param src the byte to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dstInit the initial value for the result String\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nHexs the number of Char to copy to <code>dst</code>. must be smaller or equal to\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nHexs the number of Char to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 8}   \n      */\n     public static String byteToHexs(byte src, int srcPos, String dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs) return dstInit;\n+        if (0 == nHexs)\n+            return dstInit;\n+        if ((nHexs - 1) * 4 + srcPos >= 8)\n+            throw new IllegalArgumentException(\n+                \"(nHexs-1)*4+srcPos is greather or equal to than 8\");\n         StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n-        assert ((nHexs - 1) * 4 < 8 - srcPos);\n         for (int i = 0; i < nHexs; i++ ) {\n             shift = i * 4 + srcPos;\n             int bits = 0xF & (src >> shift);\n      * </p>\n      * \n      * @param src the long to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dst the destination array\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nBools the number of boolean to copy to <code>dst</code>. must be smaller or equal\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nBools the number of boolean to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 64}   \n      */\n     public static boolean[] longToBools(long src, int srcPos, boolean[] dst, int dstPos,\n         int nBools) {\n-        if (0 == nBools) return dst;\n-        int shift = 0;\n-        assert ((nBools - 1) * 1 < 64 - srcPos);\n+        if (0 == nBools)\n+            return dst;\n+        if (nBools - 1 + srcPos >= 64)\n+            throw new IllegalArgumentException(\n+                \"nBools-1+srcPos is greather or equal to than 64\");\n+        int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             shift = i * 1 + srcPos;\n             dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);\n      * </p>\n      * \n      * @param src the int to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dst the destination array\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nBools the number of boolean to copy to <code>dst</code>. must be smaller or equal\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nBools the number of boolean to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 32}   \n      */\n     public static boolean[] intToBools(int src, int srcPos, boolean[] dst, int dstPos,\n         int nBools) {\n-        if (0 == nBools) return dst;\n-        int shift = 0;\n-        assert ((nBools - 1) * 1 < 32 - srcPos);\n+        if (0 == nBools)\n+            return dst;\n+        if (nBools - 1 + srcPos >= 32)\n+            throw new IllegalArgumentException(\n+                \"nBools-1+srcPos is greather or equal to than 32\");\n+        int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             shift = i * 1 + srcPos;\n             dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);\n      * </p>\n      * \n      * @param src the short to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dst the destination array\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nBools the number of boolean to copy to <code>dst</code>. must be smaller or equal\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nBools the number of boolean to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 16}   \n      */\n     public static boolean[] shortToBools(short src, int srcPos, boolean[] dst, int dstPos,\n         int nBools) {\n-        if (0 == nBools) return dst;\n+        if (0 == nBools)\n+            return dst;\n+        if (nBools - 1 + srcPos >= 16)\n+            throw new IllegalArgumentException(\n+                \"nBools-1+srcPos is greather or equal to than 16\");\n         int shift = 0;\n         assert ((nBools - 1) * 1 < 16 - srcPos);\n         for (int i = 0; i < nBools; i++ ) {\n      * </p>\n      * \n      * @param src the byte to convert\n-     * @param srcPos the position in <code>src</code>, in bits, from where to start the\n+     * @param srcPos the position in {@code src}, in bits, from where to start the\n      *            conversion\n      * @param dst the destination array\n-     * @param dstPos the position in <code>dst</code> where to copy the result\n-     * @param nBools the number of boolean to copy to <code>dst</code>. must be smaller or equal\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nBools the number of boolean to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n-     * @return <code>dst</code>\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 8}   \n      */\n     public static boolean[] byteToBools(byte src, int srcPos, boolean[] dst, int dstPos,\n         int nBools) {\n-        if (0 == nBools) return dst;\n-        int shift = 0;\n-        assert ((nBools - 1) * 1 < 8 - srcPos);\n+        if (0 == nBools)\n+            return dst;\n+        if (nBools - 1 + srcPos >= 8)\n+            throw new IllegalArgumentException(\n+                \"nBools-1+srcPos is greather or equal to than 8\");\n+        int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             shift = i * 1 + srcPos;\n             dst[dstPos + i] = ((0x1 & (src >> shift)) != 0);\n--- a/src/test/java/org/apache/commons/lang3/ConversionTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ConversionTest.java\n         assertEquals('1', Conversion.boolsToHexDigit(new boolean[]{true}));\n         assertEquals('f', Conversion.boolsToHexDigit(new boolean[]{true, true, true, true, true}));\n         try {\n-            assertEquals('0', Conversion.boolsToHexDigit(new boolean[]{}));\n-            fail(\"Thrown \" + ArrayIndexOutOfBoundsException.class.getName() + \" expected\");\n-        } catch (final ArrayIndexOutOfBoundsException e) {\n+            Conversion.boolsToHexDigit(new boolean[]{});\n+            fail(\"Thrown \" + IllegalArgumentException.class.getName() + \" expected\");\n+        } catch (final IllegalArgumentException e) {\n             // OK\n         }\n     }\n             'e', Conversion.boolsToHexDigitM0_4bits(new boolean[]{true, true, true, false}));\n         assertEquals(\n             'f', Conversion.boolsToHexDigitM0_4bits(new boolean[]{true, true, true, true}));\n+        try {\n+            Conversion.boolsToHexDigitM0_4bits(new boolean[]{});\n+            fail(\"Thrown \" + IllegalArgumentException.class.getName() + \" expected\");\n+        } catch (final IllegalArgumentException e) {\n+            // OK\n+        }\n     }\n \n     /**\n             Conversion.boolsBeM0ToHexDigit(new boolean[]{\n                 true, false, false, false, false, false, false, false, false, false, false,\n                 false, false, true, false, false}));\n+        try {\n+            Conversion.boolsBeM0ToHexDigit(new boolean[]{});\n+            fail(\"Thrown \" + IllegalArgumentException.class.getName() + \" expected\");\n+        } catch (final IllegalArgumentException e) {\n+            // OK\n+        }\n     }\n \n     /**", "timestamp": 1349263551, "metainfo": ""}