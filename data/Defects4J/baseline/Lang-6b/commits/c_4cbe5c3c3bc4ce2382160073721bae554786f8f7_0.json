{"sha": "4cbe5c3c3bc4ce2382160073721bae554786f8f7", "log": "LANG-799 - DateUtils#parseDate uses default locale; add Locale support  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n import java.util.Calendar;\n import java.util.Date;\n import java.util.Iterator;\n+import java.util.Locale;\n import java.util.NoSuchElementException;\n \n /**\n      * @throws ParseException if none of the date patterns were suitable (or there were none)\n      */\n     public static Date parseDate(String str, String... parsePatterns) throws ParseException {\n-        return parseDateWithLeniency(str, parsePatterns, true);\n+        return parseDate(str, null, parsePatterns);\n     }\n     \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Parses a string representing a date by trying a variety of different parsers,\n+     * using the default date format symbols for the given locale.</p>\n+     * \n+     * <p>The parse will try each parse pattern in turn.\n+     * A parse is only deemed successful if it parses the whole of the input string.\n+     * If no parse patterns match, a ParseException is thrown.</p>\n+     * The parser will be lenient toward the parsed date.\n+     * \n+     * @param str  the date to parse, not null\n+     * @param locale the locale whose date format symbols should be used. If <code>null</code>,\n+     * the system locale is used (as per {@link #parseDate(String, String...)}).\n+     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n+     * @return the parsed date\n+     * @throws IllegalArgumentException if the date string or pattern array is null\n+     * @throws ParseException if none of the date patterns were suitable (or there were none)\n+     * @since 3.2\n+     */\n+    public static Date parseDate(String str, Locale locale, String... parsePatterns) throws ParseException {\n+        return parseDateWithLeniency(str, locale, parsePatterns, true);\n+    }    \n+\n   //-----------------------------------------------------------------------\n     /**\n      * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n      * @since 2.5\n      */\n     public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException {\n-        return parseDateWithLeniency(str, parsePatterns, false);\n-    }\n-\n-    /**\n-     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n+        return parseDateStrictly(str, null, parsePatterns);\n+    }\n+\n+    /**\n+     * <p>Parses a string representing a date by trying a variety of different parsers,\n+     * using the default date format symbols for the given locale..</p>\n      * \n      * <p>The parse will try each parse pattern in turn.\n      * A parse is only deemed successful if it parses the whole of the input string.\n      * If no parse patterns match, a ParseException is thrown.</p>\n+     * The parser parses strictly - it does not allow for dates such as \"February 942, 1996\". \n      * \n      * @param str  the date to parse, not null\n+     * @param locale the locale whose date format symbols should be used. If <code>null</code>,\n+     * the system locale is used (as per {@link #parseDateStrictly(String, String...)}).\n+     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n+     * @return the parsed date\n+     * @throws IllegalArgumentException if the date string or pattern array is null\n+     * @throws ParseException if none of the date patterns were suitable\n+     * @since 3.2\n+     */\n+    public static Date parseDateStrictly(String str, Locale locale, String... parsePatterns) throws ParseException {\n+        return parseDateWithLeniency(str, null, parsePatterns, false);\n+    }    \n+\n+    /**\n+     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n+     * \n+     * <p>The parse will try each parse pattern in turn.\n+     * A parse is only deemed successful if it parses the whole of the input string.\n+     * If no parse patterns match, a ParseException is thrown.</p>\n+     * \n+     * @param str  the date to parse, not null\n+     * @param locale the locale to use when interpretting the pattern, can be null in which\n+     * case the default system locale is used\n      * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n      * @param lenient Specify whether or not date/time parsing is to be lenient.\n      * @return the parsed date\n      * @see java.util.Calender#isLenient()\n      */\n     private static Date parseDateWithLeniency(\n-            String str, String[] parsePatterns, boolean lenient) throws ParseException {\n+            String str, Locale locale, String[] parsePatterns, boolean lenient) throws ParseException {\n         if (str == null || parsePatterns == null) {\n             throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n         }\n         \n-        SimpleDateFormat parser = new SimpleDateFormat();\n+        SimpleDateFormat parser;\n+        if (locale == null) {\n+            parser = new SimpleDateFormat();\n+        } else {\n+            parser = new SimpleDateFormat(\"\", locale);\n+        }\n+        \n         parser.setLenient(lenient);\n         ParsePosition pos = new ParsePosition(0);\n         for (String parsePattern : parsePatterns) {\n--- a/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n  */\n package org.apache.commons.lang3.time;\n \n-import org.junit.Test;\n-import org.junit.Before;\n-import static org.junit.Assert.*;\n import static org.apache.commons.lang3.JavaVersion.JAVA_1_4;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.Modifier;\n import java.text.DateFormat;\n import java.text.ParseException;\n import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.GregorianCalendar;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Locale;\n import java.util.NoSuchElementException;\n+import java.util.Set;\n import java.util.TimeZone;\n \n import junit.framework.AssertionFailedError;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n import org.apache.commons.lang3.SystemUtils;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n \n /**\n  * Unit tests {@link org.apache.commons.lang3.time.DateUtils}.\n             Locale.setDefault(dflt);            \n         }\n     }\n+    \n+    /**\n+     * Tests that an IllegalArgumentException is thrown if the\n+     * locale supplied is not supported by the DateFormat class\n+     * hierarchy. Note: this test is likely to pass without testing\n+     * the behaviour, as typically all locales are supported.\n+     * \n+     * @throws Exception\n+     */\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testParseBadLocale() throws Exception {\n+        Set<Locale> availableLocales = new HashSet<Locale>(\n+                Arrays.asList(Locale.getAvailableLocales()));\n+        \n+        Set<Locale> dateLocales = new HashSet<Locale>(\n+                Arrays.asList(DateFormat.getAvailableLocales()));\n+\n+        Set<Locale> intersection = new HashSet<Locale>(availableLocales);\n+        intersection.retainAll(dateLocales);\n+        availableLocales.removeAll(intersection);\n+        \n+        // availableLocales now contains only those Locales that are\n+        // not supported by the DateFormat class hierarchy. Could be\n+        // empty, in which case we skip the test.\n+        assumeTrue(availableLocales.size() > 0);\n+        \n+        Locale invalidLocale = availableLocales.iterator().next();\n+        \n+        String[] parsers = {\"yyyy\"};        \n+        DateUtils.parseDate(\"foo\", invalidLocale, parsers);         \n+    }\n+    \n+    /**\n+     * Retrieves a non-system locale date pattern string and attempts\n+     * to use it.\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void testParseNonSystemLocale() throws Exception {\n+        // Retrieve standard long form date pattern\n+        String localPattern = getLongDateFormatForLocale(Locale.getDefault());\n+        assumeTrue(localPattern != null);\n+        \n+        // Find a pattern from another locale that doesn't match\n+        String nonMatchingPattern = null;        \n+        Locale foreignLocale = null;\n+        for (Locale locale : DateFormat.getAvailableLocales()) {\n+            String foreignPattern = getLongDateFormatForLocale(locale);\n+            if (foreignPattern != null && !foreignPattern.equals(localPattern)) {\n+                getLongDateFormatForLocale(locale);\n+                nonMatchingPattern = foreignPattern;\n+                foreignLocale = locale;\n+                break;\n+            }\n+        }\n+        \n+        // There is a slim chance that we can't find a date string that\n+        // differs from the system default. Skip test in that case.\n+        assumeTrue(nonMatchingPattern != null && foreignLocale != null);\n+        \n+        Date testDate = new Date();\n+        SimpleDateFormat sdf = new SimpleDateFormat(\"\", foreignLocale);\n+        sdf.applyLocalizedPattern(nonMatchingPattern);\n+        String testDateString = sdf.format(testDate);\n+        \n+        Date resultDate = DateUtils.parseDate(testDateString, foreignLocale, \n+                new String[] {nonMatchingPattern});\n+        \n+        assertTrue(DateUtils.isSameDay(testDate, resultDate));\n+    }\n+    \n+    /**\n+     * Retrieves the long date format pattern string for the supplied\n+     * locale.\n+     * \n+     * @param locale the locale to retrieve the pattern for\n+     * @return the long date pattern string, or <code>null</code> if\n+     * not found\n+     */\n+    private String getLongDateFormatForLocale(Locale locale) {\n+        if (! ArrayUtils.contains(DateFormat.getAvailableLocales(), locale)) {\n+            return null;            \n+        }\n+        \n+        DateFormat localFormat = DateFormat.getDateInstance(DateFormat.LONG, \n+                locale);\n+        if (!(localFormat instanceof SimpleDateFormat)) {\n+            return null;\n+        }\n+        \n+        return ((SimpleDateFormat) localFormat).toLocalizedPattern();        \n+    }\n \n     /**\n      * This checks that this is a 7 element iterator of Calendar objects", "timestamp": 1348320150, "metainfo": ""}