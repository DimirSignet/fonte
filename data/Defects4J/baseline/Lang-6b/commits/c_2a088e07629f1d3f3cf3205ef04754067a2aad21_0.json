{"sha": "2a088e07629f1d3f3cf3205ef04754067a2aad21", "log": "Simplify code paths where a statement is unnecessarily nested within an else clause. Also flip some if/else statements when tests can be expressed more clearly.  ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n     public static boolean containsAny(String str, String searchChars) {\n         if (searchChars == null) {\n             return false;\n-        } else {\n-            return containsAny(str, searchChars.toCharArray());\n-        }\n+        }\n+        return containsAny(str, searchChars.toCharArray());\n     }\n \n     // IndexOfAnyBut chars\n         }\n         if (str.length() <= len) {\n             return str;\n-        } else {\n-            return str.substring(0, len);\n-        }\n+        }\n+        return str.substring(0, len);\n     }\n \n     /**\n         }\n         if (str.length() <= len) {\n             return str;\n-        } else {\n-            return str.substring(str.length() - len);\n-        }\n+        }\n+        return str.substring(str.length() - len);\n     }\n \n     /**\n         }\n         if (str.length() <= (pos + len)) {\n             return str.substring(pos);\n-        } else {\n-            return str.substring(pos, pos + len);\n-        }\n+        }\n+        return str.substring(pos, pos + len);\n     }\n \n     // SubStringAfter/SubStringBefore\n             list.add(str.substring(start, end));\n             pos = end + closeLen;\n         }\n-        if (list.size() > 0) {\n-            return (String[]) list.toArray(new String [list.size()]);\n-        } else {\n+        if (list.isEmpty()) {\n             return null;\n-        }\n+        } \n+        return (String[]) list.toArray(new String [list.size()]);\n     }\n \n     // Nested extraction\n                 }\n                 start = ++i;\n                 continue;\n-            } else {\n-                lastMatch = false;\n-            }\n+            }\n+            lastMatch = false;\n             match = true;\n             i++;\n         }\n                     }\n                     start = ++i;\n                     continue;\n-                } else {\n-                    lastMatch = false;\n                 }\n+                lastMatch = false;\n                 match = true;\n                 i++;\n             }\n                     }\n                     start = ++i;\n                     continue;\n-                } else {\n-                    lastMatch = false;\n                 }\n+                lastMatch = false;\n                 match = true;\n                 i++;\n             }\n                     }\n                     start = ++i;\n                     continue;\n-                } else {\n-                    lastMatch = false;\n                 }\n+                lastMatch = false;\n                 match = true;\n                 i++;\n             }\n         }\n         if (modified) {\n             return buf.toString();\n-        } else {\n-            return str;\n-        }\n+        }\n+        return str;\n     }\n \n     // Overlay\n             char ch = str.charAt(0);\n             if (ch == CharUtils.CR || ch == CharUtils.LF) {\n                 return EMPTY;\n-            } else {\n-                return str;\n-            }\n+            }\n+            return str;\n         }\n \n         int lastIdx = str.length() - 1;\n         String sub = str.substring(str.length() - sep.length());\n         if (sep.equals(sub)) {\n             return str.substring(0, str.length() - sep.length());\n-        } else {\n-            return str;\n-        }\n+        }\n+        return str;\n     }\n \n     /**\n      */\n     public static String prechomp(String str, String sep) {\n         int idx = str.indexOf(sep);\n-        if (idx != -1) {\n-            return str.substring(idx + sep.length());\n-        } else {\n+        if (idx == -1) {\n             return str;\n-        }\n+        }             \n+        return str.substring(idx + sep.length());\n     }\n \n     /**\n      */\n     public static String getPrechomp(String str, String sep) {\n         int idx = str.indexOf(sep);\n-        if (idx != -1) {\n-            return str.substring(0, idx + sep.length());\n-        } else {\n+        if (idx == -1) {\n             return EMPTY;\n-        }\n+        } \n+        return str.substring(0, idx + sep.length());\n     }\n \n     // Chopping\n             // shortest string and didn't find a match, but the string lengths \n             // vary, so return the length of the shortest string.\n             return shortestStrLen;\n-        } else {\n-            return firstDiff;\n-        }\n+        }\n+        return firstDiff;\n     }\n     \n     /**\n             // all strings were identical\n             if (strs[0] == null) {\n                 return EMPTY;\n-            } else {\n-                return strs[0];\n-            }\n+            }\n+            return strs[0];\n         } else if (smallestIndexOfDiff == 0) {\n             // there were no common initial characters\n             return EMPTY;", "timestamp": 1202328605, "metainfo": ""}