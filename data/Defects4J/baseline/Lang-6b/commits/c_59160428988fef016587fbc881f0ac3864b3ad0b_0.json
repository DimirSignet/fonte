{"sha": "59160428988fef016587fbc881f0ac3864b3ad0b", "log": "Applying the copy of the HashCodeBuilder code to stop cyclic references over to EqualsBuilder per LANG-606 and Oliver Sauder's patch  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n \n import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.Pair;\n \n /**\n  * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>\n  * @author Gary Gregory\n  * @author Pete Gieser\n  * @author Arun Mammen Thomas\n+ * @author Oliver Sauder\n  * @since 1.0\n  * @version $Id$\n  */\n public class EqualsBuilder {\n+    \n+    /**\n+     * <p>\n+     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n+     * </p>\n+     * \n+     * @since 3.0\n+     */\n+    private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\n+\n+    /*\n+     * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n+     * we are in the process of calculating.\n+     * \n+     * So we generate a one-to-one mapping from the original object to a new object.\n+     * \n+     * Now HashSet uses equals() to determine if two elements with the same hashcode really\n+     * are equal, so we also need to ensure that the replacement objects are only equal\n+     * if the original objects are identical.\n+     * \n+     * The original implementation (2.4 and before) used the System.indentityHashCode()\n+     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\n+     *  \n+     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\n+     * to disambiguate the duplicate ids.\n+     */\n+\n+    /**\n+     * <p>\n+     * Returns the registry of object pairs being traversed by the reflection\n+     * methods in the current thread.\n+     * </p>\n+     * \n+     * @return Set the registry of objects being traversed\n+     * @since 3.0\n+     */\n+    static Set<Pair<IDKey, IDKey>> getRegistry() {\n+        return REGISTRY.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Converters value pair into a register pair.\n+     * </p>\n+     * \n+     * @param lhs <code>this</code> object\n+     * @param rhs the other object\n+     * \n+     * @return\n+     */\n+    static Pair<IDKey, IDKey> getRegisterPair(Object lhs, Object rhs) {\n+        IDKey left = new IDKey(lhs);\n+        IDKey right = new IDKey(rhs);\n+        return new Pair<IDKey, IDKey>(left, right);\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object pair.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * Objects might be swapped therefore a check is needed if the object pair\n+     * is registered in given or swapped order.\n+     * </p>\n+     * \n+     * @param lhs <code>this</code> object to lookup in registry\n+     * @param rhs the other object to lookup on registry\n+     * @return boolean <code>true</code> if the registry contains the given object.\n+     * @since 3.0\n+     */\n+    static boolean isRegistered(Object lhs, Object rhs) {\n+        Set<Pair<IDKey, IDKey>> registry = getRegistry();\n+        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+        Pair<IDKey, IDKey> swappedPair = new Pair<IDKey, IDKey>(pair.right,\n+                pair.left);\n+\n+        return registry != null\n+                && (registry.contains(pair) || registry.contains(swappedPair));\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object pair.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param lhs <code>this</code> object to register\n+     * @param rhs the other object to register\n+     */\n+    static void register(Object lhs, Object rhs) {\n+        synchronized (HashCodeBuilder.class) {\n+            if (getRegistry() == null) {\n+                REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());\n+            }\n+        }\n+\n+        Set<Pair<IDKey, IDKey>> registry = getRegistry();\n+        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+        registry.add(pair);\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object pair.\n+     * </p>\n+     * \n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     * \n+     * @param lhs <code>this</code> object to unregister\n+     * @param rhs the other object to unregister\n+     * @since 3.0\n+     */\n+    static void unregister(Object lhs, Object rhs) {\n+        Set<Pair<IDKey, IDKey>> registry = getRegistry();\n+        if (registry != null) {\n+            Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+            registry.remove(pair);\n+            synchronized (HashCodeBuilder.class) {\n+                //read again\n+                registry = getRegistry();\n+                if (registry != null && registry.isEmpty()) {\n+                    REGISTRY.remove();\n+                }\n+            }\n+        }\n+    }\n     \n     /**\n      * If the fields tested are equals.\n         EqualsBuilder builder,\n         boolean useTransients,\n         String[] excludeFields) {\n-        Field[] fields = clazz.getDeclaredFields();\n-        AccessibleObject.setAccessible(fields, true);\n-        for (int i = 0; i < fields.length && builder.isEquals; i++) {\n-            Field f = fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName())\n-                && (f.getName().indexOf('$') == -1)\n-                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                && (!Modifier.isStatic(f.getModifiers()))) {\n-                try {\n-                    builder.append(f.get(lhs), f.get(rhs));\n-                } catch (IllegalAccessException e) {\n-                    //this can't happen. Would get a Security exception instead\n-                    //throw a runtime exception in case the impossible happens.\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+        \n+        if (isRegistered(lhs, rhs)) {\n+            return;\n+        }\n+        \n+        try {\n+            register(lhs, rhs);\n+            Field[] fields = clazz.getDeclaredFields();\n+            AccessibleObject.setAccessible(fields, true);\n+            for (int i = 0; i < fields.length && builder.isEquals; i++) {\n+                Field f = fields[i];\n+                if (!ArrayUtils.contains(excludeFields, f.getName())\n+                    && (f.getName().indexOf('$') == -1)\n+                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                    && (!Modifier.isStatic(f.getModifiers()))) {\n+                    try {\n+                        builder.append(f.get(lhs), f.get(rhs));\n+                    } catch (IllegalAccessException e) {\n+                        //this can't happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n                 }\n             }\n+        } finally {\n+            unregister(lhs, rhs);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/builder/EqualsBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/EqualsBuilderTest.java\n  * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @author Maarten Coene\n+ * @author Oliver Sauder\n  * @version $Id$\n  */\n public class EqualsBuilderTest extends TestCase {\n             this.three = new TestObject(three);\n         }\n     }\n+    \n+    /**\n+     * Test cyclical object references which cause a StackOverflowException if\n+     * not handled properly. s. LANG-606\n+     */\n+    public void testCyclicalObjectReferences() {\n+        TestObjectReference refX1 = new TestObjectReference(1);\n+        TestObjectReference x1 = new TestObjectReference(1);\n+        x1.setObjectReference(refX1);\n+        refX1.setObjectReference(x1);\n+\n+        TestObjectReference refX2 = new TestObjectReference(1);\n+        TestObjectReference x2 = new TestObjectReference(1);\n+        x2.setObjectReference(refX2);\n+        refX2.setObjectReference(x2);\n+\n+        TestObjectReference refX3 = new TestObjectReference(2);\n+        TestObjectReference x3 = new TestObjectReference(2);\n+        x3.setObjectReference(refX3);\n+        refX3.setObjectReference(x3);\n+\n+        assertTrue(x1.equals(x2));\n+        assertNull(EqualsBuilder.getRegistry());\n+        assertFalse(x1.equals(x3));\n+        assertNull(EqualsBuilder.getRegistry());\n+        assertFalse(x2.equals(x3));\n+        assertNull(EqualsBuilder.getRegistry());\n+    }\n+\n+    static class TestObjectReference {\n+        @SuppressWarnings(\"unused\")\n+        private TestObjectReference reference;\n+        @SuppressWarnings(\"unused\")\n+        private TestObject one;\n+\n+        public TestObjectReference(int one) {\n+            this.one = new TestObject(one);\n+        }\n+\n+        public void setObjectReference(TestObjectReference reference) {\n+            this.reference = reference;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return EqualsBuilder.reflectionEquals(this, obj);\n+        }\n+    }\n }\n+", "timestamp": 1269116217, "metainfo": ""}