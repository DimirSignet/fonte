{"sha": "98b9a8769492221c87057e9c957f92bfaf011f50", "log": "Checkstyle and trailing spaces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * <p>\n  * Assists in implementing {@link Object#hashCode()} methods.\n  * </p>\n- * \n+ *\n  * <p>\n  * This class enables a good <code>hashCode</code> method to be built for any class. It follows the rules laid out in\n  * the book <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a> by Joshua Bloch. Writing a\n  * good <code>hashCode</code> method is actually quite difficult. This class aims to simplify the process.\n  * </p>\n- * \n+ *\n  * <p>\n- * The following is the approach taken. When appending a data field, the current total is multiplied by the \n- * multiplier then a relevant value \n- * for that data type is added. For example, if the current hashCode is 17, and the multiplier is 37, then \n- * appending the integer 45 will create a hashcode of 674, namely 17 * 37 + 45. \n+ * The following is the approach taken. When appending a data field, the current total is multiplied by the\n+ * multiplier then a relevant value\n+ * for that data type is added. For example, if the current hashCode is 17, and the multiplier is 37, then\n+ * appending the integer 45 will create a hashcode of 674, namely 17 * 37 + 45.\n  * </p>\n- * \n+ *\n  * <p>\n  * All relevant fields from the object should be included in the <code>hashCode</code> method. Derived fields may be\n  * excluded. In general, any field used in the <code>equals</code> method must be used in the <code>hashCode</code>\n  * <p>\n  * To use this class write code as follows:\n  * </p>\n- * \n+ *\n  * <pre>\n  * public class Person {\n  *   String name;\n  *   }\n  * }\n  * </pre>\n- * \n+ *\n  * <p>\n  * If required, the superclass <code>hashCode()</code> can be added using {@link #appendSuper}.\n  * </p>\n- * \n+ *\n  * <p>\n  * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are\n  * usually private, the method, <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code>\n  * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions\n  * are set up correctly. It is also slower than testing explicitly.\n  * </p>\n- * \n+ *\n  * <p>\n  * A typical invocation for this method would look like:\n  * </p>\n- * \n+ *\n  * <pre>\n  * public int hashCode() {\n  *   return HashCodeBuilder.reflectionHashCode(this);\n  * }\n  * </pre>\n- * \n+ *\n  * @author Apache Software Foundation\n  * @author Gary Gregory\n  * @author Pete Gieser\n      * <p>\n      * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n      * </p>\n-     * \n+     *\n      * @since 2.3\n      */\n     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\n     /*\n      * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n      * we are in the process of calculating.\n-     * \n+     *\n      * So we generate a one-to-one mapping from the original object to a new object.\n-     * \n+     *\n      * Now HashSet uses equals() to determine if two elements with the same hashcode really\n      * are equal, so we also need to ensure that the replacement objects are only equal\n      * if the original objects are identical.\n-     * \n+     *\n      * The original implementation (2.4 and before) used the System.indentityHashCode()\n      * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\n-     *  \n+     *\n      * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\n      * to disambiguate the duplicate ids.\n      */\n-    \n+\n     /**\n      * <p>\n      * Returns the registry of objects being traversed by the reflection methods in the current thread.\n      * </p>\n-     * \n+     *\n      * @return Set the registry of objects being traversed\n      * @since 2.3\n      */\n      * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n      * infinite loops.\n      * </p>\n-     * \n+     *\n      * @param value\n      *            The object to lookup in the registry.\n      * @return boolean <code>true</code> if the registry contains the given object.\n      * <p>\n      * Appends the fields and values defined by the given object of the given <code>Class</code>.\n      * </p>\n-     * \n+     *\n      * @param object\n      *            the object to append details of\n      * @param clazz\n      * <p>\n      * This method uses reflection to build a valid hash code.\n      * </p>\n-     * \n+     *\n      * <p>\n      * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n      * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n      * also not as efficient as testing explicitly.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n      * <code>Object</code>.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Static fields will not be tested. Superclass fields will be included.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n      * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n      * </p>\n-     * \n+     *\n      * @param initialNonZeroOddNumber\n      *            a non-zero, odd number used as the initial value\n      * @param multiplierNonZeroOddNumber\n      * <p>\n      * This method uses reflection to build a valid hash code.\n      * </p>\n-     * \n+     *\n      * <p>\n      * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n      * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n      * also not as efficient as testing explicitly.\n      * </p>\n-     * \n+     *\n      * <p>\n      * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n      * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Static fields will not be tested. Superclass fields will be included.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n      * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n      * </p>\n-     * \n+     *\n      * @param initialNonZeroOddNumber\n      *            a non-zero, odd number used as the initial value\n      * @param multiplierNonZeroOddNumber\n     /**\n      * Calls {@link #reflectionHashCode(int, int, Object, boolean, Class, String[])} with excludeFields set to\n      * <code>null</code>.\n-     * \n+     *\n+     * @param <T>\n+     *            the type of the object involved\n      * @param initialNonZeroOddNumber\n      *            a non-zero, odd number used as the initial value\n      * @param multiplierNonZeroOddNumber\n      * <p>\n      * This method uses reflection to build a valid hash code.\n      * </p>\n-     * \n+     *\n      * <p>\n      * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n      * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n      * also not as efficient as testing explicitly.\n      * </p>\n-     * \n+     *\n      * <p>\n      * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n      * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Static fields will not be included. Superclass fields will be included up to and including the specified\n      * superclass. A null superclass is treated as java.lang.Object.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n      * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n      * </p>\n-     * \n+     *\n+     * @param <T>\n+     *            the type of the object involved\n      * @param initialNonZeroOddNumber\n      *            a non-zero, odd number used as the initial value\n      * @param multiplierNonZeroOddNumber\n      * <p>\n      * This method uses reflection to build a valid hash code.\n      * </p>\n-     * \n+     *\n      * <p>\n      * This constructor uses two hard coded choices for the constants needed to build a hash code.\n      * </p>\n-     * \n+     *\n      * <p>\n      * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n      * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n      * also not as efficient as testing explicitly.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n      * <code>Object</code>.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Static fields will not be tested. Superclass fields will be included.\n      * </p>\n-     * \n+     *\n      * @param object\n      *            the Object to create a <code>hashCode</code> for\n      * @return int hash code\n      * <p>\n      * This method uses reflection to build a valid hash code.\n      * </p>\n-     * \n+     *\n      * <p>\n      * This constructor uses two hard coded choices for the constants needed to build a hash code.\n      * </p>\n-     * \n+     *\n      * <p>\n      * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n      * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n      * also not as efficient as testing explicitly.\n      * </p>\n-     * \n+     *\n      * <P>\n      * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n      * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Static fields will not be tested. Superclass fields will be included.\n      * </p>\n-     * \n+     *\n      * @param object\n      *            the Object to create a <code>hashCode</code> for\n      * @param testTransients\n      * <p>\n      * This method uses reflection to build a valid hash code.\n      * </p>\n-     * \n+     *\n      * <p>\n      * This constructor uses two hard coded choices for the constants needed to build a hash code.\n      * </p>\n-     * \n+     *\n      * <p>\n      * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n      * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n      * also not as efficient as testing explicitly.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n      * <code>Object</code>.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Static fields will not be tested. Superclass fields will be included.\n      * </p>\n-     * \n+     *\n      * @param object\n      *            the Object to create a <code>hashCode</code> for\n      * @param excludeFields\n      * <p>\n      * This method uses reflection to build a valid hash code.\n      * </p>\n-     * \n+     *\n      * <p>\n      * This constructor uses two hard coded choices for the constants needed to build a hash code.\n      * </p>\n-     * \n+     *\n      * <p>\n      * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n      * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n      * also not as efficient as testing explicitly.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n      * <code>Object</code>.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Static fields will not be tested. Superclass fields will be included.\n      * </p>\n-     * \n+     *\n      * @param object\n      *            the Object to create a <code>hashCode</code> for\n      * @param excludeFields\n      * <p>\n      * Registers the given object. Used by the reflection methods to avoid infinite loops.\n      * </p>\n-     * \n+     *\n      * @param value\n      *            The object to register.\n      */\n      * <p>\n      * Unregisters the given object.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Used by the reflection methods to avoid infinite loops.\n-     * \n+     *\n      * @param value\n      *            The object to unregister.\n      * @since 2.3\n      * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n      * however this is not vital.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Prime numbers are preferred, especially for the multiplier.\n      * </p>\n-     * \n+     *\n      * @param initialNonZeroOddNumber\n      *            a non-zero, odd number used as the initial value\n      * @param multiplierNonZeroOddNumber\n      * <p>\n      * This is in accordance with the <quote>Effective Java</quote> design.\n      * </p>\n-     * \n+     *\n      * @param value\n      *            the boolean to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>boolean</code> array.\n      * </p>\n-     * \n+     *\n      * @param array\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>byte</code>.\n      * </p>\n-     * \n+     *\n      * @param value\n      *            the byte to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>byte</code> array.\n      * </p>\n-     * \n+     *\n      * @param array\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>char</code>.\n      * </p>\n-     * \n+     *\n      * @param value\n      *            the char to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>char</code> array.\n      * </p>\n-     * \n+     *\n      * @param array\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>double</code>.\n      * </p>\n-     * \n+     *\n      * @param value\n      *            the double to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>double</code> array.\n      * </p>\n-     * \n+     *\n      * @param array\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>float</code>.\n      * </p>\n-     * \n+     *\n      * @param value\n      *            the float to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>float</code> array.\n      * </p>\n-     * \n+     *\n      * @param array\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for an <code>int</code>.\n      * </p>\n-     * \n+     *\n      * @param value\n      *            the int to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for an <code>int</code> array.\n      * </p>\n-     * \n+     *\n      * @param array\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>long</code>.\n      * </p>\n-     * \n+     *\n      * @param value\n      *            the long to add to the <code>hashCode</code>\n      * @return this\n      */\n-    // NOTE: This method uses >> and not >>> as Effective Java and \n-    //       Long.hashCode do. Ideally we should switch to >>> at \n-    //       some stage. There are backwards compat issues, so \n+    // NOTE: This method uses >> and not >>> as Effective Java and\n+    //       Long.hashCode do. Ideally we should switch to >>> at\n+    //       some stage. There are backwards compat issues, so\n     //       that will have to wait for the time being. cf LANG-342.\n     public HashCodeBuilder append(long value) {\n         iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n      * <p>\n      * Append a <code>hashCode</code> for a <code>long</code> array.\n      * </p>\n-     * \n+     *\n      * @param array\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for an <code>Object</code>.\n      * </p>\n-     * \n+     *\n      * @param object\n      *            the Object to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for an <code>Object</code> array.\n      * </p>\n-     * \n+     *\n      * @param array\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>short</code>.\n      * </p>\n-     * \n+     *\n      * @param value\n      *            the short to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Append a <code>hashCode</code> for a <code>short</code> array.\n      * </p>\n-     * \n+     *\n      * @param array\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      * <p>\n      * Adds the result of super.hashCode() to this builder.\n      * </p>\n-     * \n+     *\n      * @param superHashCode\n      *            the result of calling <code>super.hashCode()</code>\n      * @return this HashCodeBuilder, used to chain calls.\n      * <p>\n      * Return the computed <code>hashCode</code>.\n      * </p>\n-     * \n+     *\n      * @return <code>hashCode</code> based on the fields appended\n      */\n     public int toHashCode() {\n         return iTotal;\n     }\n-    \n+\n     /**\n      * Returns the computed <code>hashCode</code>.\n-     * \n+     *\n      * @return <code>hashCode</code> based on the fields appended\n-     * \n+     *\n      * @since 3.0\n      */\n     public Integer build() {\n \n     /**\n      * <p>\n-     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelyhood \n-     * of bugs in mis-calling toHashCode() and the unlikelyness of it mattering what the hashCode for \n+     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelyhood\n+     * of bugs in mis-calling toHashCode() and the unlikelyness of it mattering what the hashCode for\n      * HashCodeBuilder itself is.\n-     * \n+     *\n      * @return <code>hashCode</code> based on the fields appended\n      * @since 2.5\n      */", "timestamp": 1300552865, "metainfo": ""}