{"sha": "d39af69e50655cc3c162ef252b77dddf6b851a42", "log": "[LANG-812] Permit bitvector generation for Enums with > 64 values; plus some test corrections  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/EnumUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/EnumUtils.java\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.EnumSet;\n import java.util.LinkedHashMap;\n import java.util.List;\n  */\n public class EnumUtils {\n \n+    private static final String NULL_ELEMENTS_NOT_PERMITTED = \"null elements not permitted\";\n+    private static final String CANNOT_STORE_S_S_VALUES_IN_S_BITS = \"Cannot store %s %s values in %s bits\";\n+    private static final String S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE = \"%s does not seem to be an Enum type\";\n+    private static final String ENUM_CLASS_MUST_BE_DEFINED = \"EnumClass must be defined.\";\n+\n     /**\n      * This constructor is public to permit tools that require a JavaBean\n      * instance to operate.\n      * would create a value greater than a long can hold.</p>\n      *\n      * @param enumClass the class of the enum we are working with, not {@code null}\n-     * @param values    the values we want to convert, not {@code null}\n-     * @param <E>       the type of the enumeration\n-     * @return a long whose binary value represents the given set of enum values.\n+     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n+     * @param <E>       the type of the enumeration\n+     * @return a long whose value provides a binary representation of the given set of enum values.\n      * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n-     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n+     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values,\n+     *                                  or if any {@code values} {@code null}\n      * @since 3.0.1\n+     * @see #generateBitVectors(Class, Iterable)\n      */\n     public static <E extends Enum<E>> long generateBitVector(Class<E> enumClass, Iterable<E> values) {\n         checkBitVectorable(enumClass);\n         Validate.notNull(values);\n         long total = 0;\n         for (E constant : values) {\n+            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n             total |= 1 << constant.ordinal();\n         }\n         return total;\n+    }\n+\n+    /**\n+     * <p>Creates a bit vector representation of the given subset of an Enum using as many {@code long}s as needed.</p>\n+     *\n+     * <p>This generates a value that is usable by {@link EnumUtils#processBitVectors}.</p>\n+     *\n+     * <p>Use this method if you have more than 64 values in your Enum.</p>\n+     *\n+     * @param enumClass the class of the enum we are working with, not {@code null}\n+     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n+     * @param <E>       the type of the enumeration\n+     * @return a long[] whose values provide a binary representation of the given set of enum values\n+     *         with least significant digits rightmost.\n+     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n+     * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}\n+     * @since 3.2\n+     */\n+    public static <E extends Enum<E>> long[] generateBitVectors(Class<E> enumClass, Iterable<E> values) {\n+        asEnum(enumClass);\n+        Validate.notNull(values);\n+        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n+        for (E constant : values) {\n+            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n+            condensed.add(constant);\n+        }\n+        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n+        for (E value : condensed) {\n+            result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n+        }\n+        ArrayUtils.reverse(result);\n+        return result;\n     }\n \n     /**\n      * @param enumClass the class of the enum we are working with, not {@code null}\n      * @param values    the values we want to convert, not {@code null}\n      * @param <E>       the type of the enumeration\n-     * @return a long whose binary value represents the given set of enum values.\n+     * @return a long whose value provides a binary representation of the given set of enum values.\n      * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n      * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n      * @since 3.0.1\n+     * @see #generateBitVectors(Class, Iterable)\n      */\n     public static <E extends Enum<E>> long generateBitVector(Class<E> enumClass, E... values) {\n         Validate.noNullElements(values);\n         return generateBitVector(enumClass, Arrays.<E> asList(values));\n+    }\n+\n+    /**\n+     * <p>Creates a bit vector representation of the given subset of an Enum using as many {@code long}s as needed.</p>\n+     *\n+     * <p>This generates a value that is usable by {@link EnumUtils#processBitVectors}.</p>\n+     *\n+     * <p>Use this method if you have more than 64 values in your Enum.</p>\n+     *\n+     * @param enumClass the class of the enum we are working with, not {@code null}\n+     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}\n+     * @param <E>       the type of the enumeration\n+     * @return a long[] whose values provide a binary representation of the given set of enum values\n+     *         with least significant digits rightmost.\n+     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}\n+     * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}\n+     * @since 3.2\n+     */\n+    public static <E extends Enum<E>> long[] generateBitVectors(Class<E> enumClass, E... values) {\n+        asEnum(enumClass);\n+        Validate.noNullElements(values);\n+        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n+        Collections.addAll(condensed, values);\n+        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n+        for (E value : condensed) {\n+            result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n+        }\n+        ArrayUtils.reverse(result);\n+        return result;\n     }\n \n     /**\n      * @since 3.0.1\n      */\n     public static <E extends Enum<E>> EnumSet<E> processBitVector(Class<E> enumClass, long value) {\n-        final E[] constants = checkBitVectorable(enumClass).getEnumConstants();\n-        final EnumSet<E> results = EnumSet.noneOf(enumClass);\n-        for (E constant : constants) {\n-            if ((value & 1 << constant.ordinal()) != 0) {\n+        checkBitVectorable(enumClass).getEnumConstants();\n+        return processBitVectors(enumClass, value);\n+    }\n+\n+    /**\n+     * <p>Convert a {@code long[]} created by {@link EnumUtils#generateBitVectors} into the set of\n+     * enum values that it represents.</p>\n+     *\n+     * <p>If you store this value, beware any changes to the enum that would affect ordinal values.</p>\n+     * @param enumClass the class of the enum we are working with, not {@code null}\n+     * @param values     the long[] bearing the representation of a set of enum values, least significant digits rightmost, not {@code null}\n+     * @param <E>       the type of the enumeration\n+     * @return a set of enum values\n+     * @throws NullPointerException if {@code enumClass} is {@code null}\n+     * @throws IllegalArgumentException if {@code enumClass} is not an enum class\n+     * @since 3.2\n+     */\n+    public static <E extends Enum<E>> EnumSet<E> processBitVectors(Class<E> enumClass, long... values) {\n+        final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass));\n+        values = ArrayUtils.clone(Validate.notNull(values));\n+        ArrayUtils.reverse(values);\n+        for (E constant : enumClass.getEnumConstants()) {\n+            int block = constant.ordinal() / Long.SIZE;\n+            if (block < values.length && (values[block] & 1 << (constant.ordinal() % Long.SIZE)) != 0) {\n                 results.add(constant);\n             }\n         }\n      * @since 3.0.1\n      */\n     private static <E extends Enum<E>> Class<E> checkBitVectorable(Class<E> enumClass) {\n-        Validate.notNull(enumClass, \"EnumClass must be defined.\");\n-\n-        final E[] constants = enumClass.getEnumConstants();\n-        Validate.isTrue(constants != null, \"%s does not seem to be an Enum type\", enumClass);\n-        Validate.isTrue(constants.length <= Long.SIZE, \"Cannot store %s %s values in %s bits\", constants.length,\n+        final E[] constants = asEnum(enumClass).getEnumConstants();\n+        Validate.isTrue(constants.length <= Long.SIZE, CANNOT_STORE_S_S_VALUES_IN_S_BITS, constants.length,\n             enumClass.getSimpleName(), Long.SIZE);\n \n         return enumClass;\n     }\n+\n+    /**\n+     * Validate {@code enumClass}.\n+     * @param <E> the type of the enumeration\n+     * @param enumClass to check\n+     * @return {@code enumClass}\n+     * @throws NullPointerException if {@code enumClass} is {@code null}\n+     * @throws IllegalArgumentException if {@code enumClass} is not an enum class\n+     * @since 3.2\n+     */\n+    private static <E extends Enum<E>> Class<E> asEnum(Class<E> enumClass) {\n+        Validate.notNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED);\n+        Validate.isTrue(enumClass.isEnum(), S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE, enumClass);\n+        return enumClass;\n+    }\n }\n--- a/src/test/java/org/apache/commons/lang3/EnumUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/EnumUtilsTest.java\n import static org.junit.Assert.assertTrue;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.EnumSet;\n import java.util.List;\n import java.util.Map;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n /**\n     }\n \n     @Test(expected=NullPointerException.class)\n+    public void test_generateBitVectors_nullClass() {\n+        EnumUtils.generateBitVectors(null, EnumSet.of(Traffic.RED));\n+    }\n+    \n+    @Test(expected=NullPointerException.class)\n     public void test_generateBitVector_nullIterable() {\n-        EnumUtils.generateBitVector(null, (Iterable<Traffic>) null);\n-    }\n-\n+        EnumUtils.generateBitVector(Traffic.class, (Iterable<Traffic>) null);\n+    }\n+\n+    @Test(expected=NullPointerException.class)\n+    public void test_generateBitVectors_nullIterable() {\n+        EnumUtils.generateBitVectors(null, (Iterable<Traffic>) null);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void test_generateBitVector_nullElement() {\n+        EnumUtils.generateBitVector(Traffic.class, Arrays.asList(Traffic.RED, null));\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void test_generateBitVectors_nullElement() {\n+        EnumUtils.generateBitVectors(Traffic.class, Arrays.asList(Traffic.RED, null));\n+    }\n+    \n     @Test(expected=NullPointerException.class)\n     public void test_generateBitVector_nullClassWithArray() {\n         EnumUtils.generateBitVector(null, Traffic.RED);\n     }\n     \n     @Test(expected=NullPointerException.class)\n+    public void test_generateBitVectors_nullClassWithArray() {\n+        EnumUtils.generateBitVectors(null, Traffic.RED);\n+    }\n+    \n+    @Test(expected=NullPointerException.class)\n     public void test_generateBitVector_nullArray() {\n-        EnumUtils.generateBitVector(null, (Traffic[]) null);\n-    }\n-\n+        EnumUtils.generateBitVector(Traffic.class, (Traffic[]) null);\n+    }\n+\n+    @Test(expected=NullPointerException.class)\n+    public void test_generateBitVectors_nullArray() {\n+        EnumUtils.generateBitVectors(Traffic.class, (Traffic[]) null);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void test_generateBitVector_nullArrayElement() {\n+        EnumUtils.generateBitVector(Traffic.class, Traffic.RED, null);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void test_generateBitVectors_nullArrayElement() {\n+        EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, null);\n+    }\n+    \n     @Test(expected=IllegalArgumentException.class)\n     public void test_generateBitVector_longClass() {\n         EnumUtils.generateBitVector(TooMany.class, EnumSet.of(TooMany.A1));\n     \n     @SuppressWarnings(\"unchecked\")\n     @Test(expected=IllegalArgumentException.class)\n+    public void test_generateBitVectors_nonEnumClass() {\n+        @SuppressWarnings(\"rawtypes\")\n+        Class rawType = Object.class;\n+        @SuppressWarnings(\"rawtypes\")\n+        List rawList = new ArrayList();\n+        EnumUtils.generateBitVectors(rawType, rawList);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n     public void test_generateBitVector_nonEnumClassWithArray() {\n         @SuppressWarnings(\"rawtypes\")\n         Class rawType = Object.class;\n         EnumUtils.generateBitVector(rawType);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void test_generateBitVectors_nonEnumClassWithArray() {\n+        @SuppressWarnings(\"rawtypes\")\n+        Class rawType = Object.class;\n+        EnumUtils.generateBitVectors(rawType);\n     }\n     \n     @Test\n         assertEquals(5L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.GREEN)));\n         assertEquals(6L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.AMBER, Traffic.GREEN)));\n         assertEquals(7L, EnumUtils.generateBitVector(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN)));\n+    }\n+\n+    @Test\n+    public void test_generateBitVectors() {\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.noneOf(Traffic.class)), 0L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED)), 1L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.AMBER)), 2L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.GREEN)), 4L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER)), 3L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED, Traffic.GREEN)), 5L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.AMBER, Traffic.GREEN)), 6L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN)), 7L);\n     }\n \n     @Test\n         assertEquals(7L, EnumUtils.generateBitVector(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN));\n     }\n     \n+    @Test\n+    public void test_generateBitVectorsFromArray() {\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class), 0L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED), 1L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER), 2L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.GREEN), 4L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER), 3L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.GREEN), 5L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.AMBER, Traffic.GREEN), 6L);\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN), 7L);\n+        //gracefully handles duplicates:\n+        assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN), 7L);\n+    }\n+\n+    private void assertArrayEquals(long[] actual, long... expected) {\n+        Assert.assertArrayEquals(expected, actual);\n+    }\n+\n     @Test(expected=NullPointerException.class)\n     public void test_processBitVector_nullClass() {\n         final Class<Traffic> empty = null;\n         EnumUtils.processBitVector(empty, 0L);\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n-    public void test_processBitVector_longClass() {\n-        EnumUtils.processBitVector(TooMany.class, 0L);\n+    @Test(expected=NullPointerException.class)\n+    public void test_processBitVectors_nullClass() {\n+        final Class<Traffic> empty = null;\n+        EnumUtils.processBitVectors(empty, 0L);\n     }\n \n     @Test\n         assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVector(Traffic.class, 6L));\n         assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVector(Traffic.class, 7L));\n     }\n+\n+    @Test\n+    public void test_processBitVectors() {\n+        assertEquals(EnumSet.noneOf(Traffic.class), EnumUtils.processBitVectors(Traffic.class, 0L));\n+        assertEquals(EnumSet.of(Traffic.RED), EnumUtils.processBitVectors(Traffic.class, 1L));\n+        assertEquals(EnumSet.of(Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 2L));\n+        assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 3L));\n+        assertEquals(EnumSet.of(Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 4L));\n+        assertEquals(EnumSet.of(Traffic.RED, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 5L));\n+        assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 6L));\n+        assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 7L));\n+\n+        assertEquals(EnumSet.noneOf(Traffic.class), EnumUtils.processBitVectors(Traffic.class, 0L, 0L));\n+        assertEquals(EnumSet.of(Traffic.RED), EnumUtils.processBitVectors(Traffic.class, 0L, 1L));\n+        assertEquals(EnumSet.of(Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 0L, 2L));\n+        assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 0L, 3L));\n+        assertEquals(EnumSet.of(Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 4L));\n+        assertEquals(EnumSet.of(Traffic.RED, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 5L));\n+        assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 6L));\n+        assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 0L, 7L));\n+\n+        // demonstrate tolerance of irrelevant high-order digits:\n+        assertEquals(EnumSet.noneOf(Traffic.class), EnumUtils.processBitVectors(Traffic.class, 666L, 0L));\n+        assertEquals(EnumSet.of(Traffic.RED), EnumUtils.processBitVectors(Traffic.class, 666L, 1L));\n+        assertEquals(EnumSet.of(Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 666L, 2L));\n+        assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER), EnumUtils.processBitVectors(Traffic.class, 666L, 3L));\n+        assertEquals(EnumSet.of(Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 4L));\n+        assertEquals(EnumSet.of(Traffic.RED, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 5L));\n+        assertEquals(EnumSet.of(Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 6L));\n+        assertEquals(EnumSet.of(Traffic.RED, Traffic.AMBER, Traffic.GREEN), EnumUtils.processBitVectors(Traffic.class, 666L, 7L));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void test_processBitVector_longClass() {\n+        EnumUtils.processBitVector(TooMany.class, 0L);\n+    }\n+    \n+    public void test_processBitVectors_longClass() {\n+        assertEquals(EnumSet.noneOf(TooMany.class), EnumUtils.processBitVectors(TooMany.class, 0L));\n+        assertEquals(EnumSet.of(TooMany.A), EnumUtils.processBitVectors(TooMany.class, 1L));\n+        assertEquals(EnumSet.of(TooMany.B), EnumUtils.processBitVectors(TooMany.class, 2L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.B), EnumUtils.processBitVectors(TooMany.class, 3L));\n+        assertEquals(EnumSet.of(TooMany.C), EnumUtils.processBitVectors(TooMany.class, 4L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 5L));\n+        assertEquals(EnumSet.of(TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 6L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 7L));\n+\n+        assertEquals(EnumSet.noneOf(TooMany.class), EnumUtils.processBitVectors(TooMany.class, 0L, 0L));\n+        assertEquals(EnumSet.of(TooMany.A), EnumUtils.processBitVectors(TooMany.class, 0L, 1L));\n+        assertEquals(EnumSet.of(TooMany.B), EnumUtils.processBitVectors(TooMany.class, 0L, 2L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.B), EnumUtils.processBitVectors(TooMany.class, 0L, 3L));\n+        assertEquals(EnumSet.of(TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 4L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 5L));\n+        assertEquals(EnumSet.of(TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 6L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 7L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C), EnumUtils.processBitVectors(TooMany.class, 0L, 7L));\n+\n+        assertEquals(EnumSet.of(TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 0L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 1L));\n+        assertEquals(EnumSet.of(TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 2L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 3L));\n+        assertEquals(EnumSet.of(TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 4L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 5L));\n+        assertEquals(EnumSet.of(TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 6L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 7L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 1L, 7L));\n+\n+        // demonstrate tolerance of irrelevant high-order digits:\n+        assertEquals(EnumSet.of(TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 0L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 1L));\n+        assertEquals(EnumSet.of(TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 2L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 3L));\n+        assertEquals(EnumSet.of(TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 4L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 5L));\n+        assertEquals(EnumSet.of(TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 6L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 7L));\n+        assertEquals(EnumSet.of(TooMany.A, TooMany.B, TooMany.C, TooMany.M2), EnumUtils.processBitVectors(TooMany.class, 9L, 7L));\n+    }\n+\n }\n \n enum Traffic {", "timestamp": 1342210454, "metainfo": ""}