{"sha": "beab55ac6f74326d6c6d4602286f88f47125dd53", "log": "Add missing @Override.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/CharRange.java\n+++ b/src/main/java/org/apache/commons/lang3/CharRange.java\n      * @return an iterator to the chars represented by this range\n      * @since 2.5\n      */\n+    @Override\n     public Iterator<Character> iterator() {\n         return new CharacterIterator(this);\n     }\n          *\n          * @return {@code true} if the iterator has yet to reach the character date\n          */\n+        @Override\n         public boolean hasNext() {\n             return hasNext;\n         }\n          *\n          * @return {@code Character} for the next character\n          */\n+        @Override\n         public Character next() {\n             if (hasNext == false) {\n                 throw new NoSuchElementException();\n          * @throws UnsupportedOperationException\n          * @see java.util.Iterator#remove()\n          */\n+        @Override\n         public void remove() {\n             throw new UnsupportedOperationException();\n         }\n--- a/src/main/java/org/apache/commons/lang3/Range.java\n+++ b/src/main/java/org/apache/commons/lang3/Range.java\n          * @param obj2 right hand side of comparison\n          * @return negative, 0, positive comparison value\n          */\n+        @Override\n         public int compare(Object obj1, Object obj2) {\n             return ((Comparable) obj1).compareTo(obj2);\n         }\n--- a/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n      * @see #toComparison()\n      * @since 3.0\n      */\n+    @Override\n     public Integer build() {\n         return Integer.valueOf(toComparison());\n     }\n--- a/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n      *\n      * @since 3.0\n      */\n+    @Override\n     public Boolean build() {\n         return Boolean.valueOf(isEquals());\n     }\n--- a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n      *\n      * @since 3.0\n      */\n+    @Override\n     public Integer build() {\n         return Integer.valueOf(toHashCode());\n     }\n--- a/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java\n      *\n      * @since 3.0\n      */\n+    @Override\n     public String build() {\n         return toString();\n     }\n--- a/src/main/java/org/apache/commons/lang3/concurrent/AtomicInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/AtomicInitializer.java\n      * @throws ConcurrentException if an error occurred during initialization of\n      * the object\n      */\n+    @Override\n     public T get() throws ConcurrentException {\n         T result = reference.get();\n \n--- a/src/main/java/org/apache/commons/lang3/concurrent/AtomicSafeInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/AtomicSafeInitializer.java\n      * @throws ConcurrentException if the initialization of the object causes an\n      * exception\n      */\n+    @Override\n     public final T get() throws ConcurrentException {\n         T result;\n \n--- a/src/main/java/org/apache/commons/lang3/concurrent/BackgroundInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/BackgroundInitializer.java\n      * background processing\n      * @throws IllegalStateException if {@link #start()} has not been called\n      */\n+    @Override\n     public T get() throws ConcurrentException {\n         try {\n             return getFuture().get();\n          * @return the result object\n          * @throws Exception if an error occurs\n          */\n+        @Override\n         public T call() throws Exception {\n             try {\n                 return initialize();\n--- a/src/main/java/org/apache/commons/lang3/concurrent/BasicThreadFactory.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/BasicThreadFactory.java\n      * @param r the {@code Runnable} to be executed by the new thread\n      * @return the newly created thread\n      */\n+    @Override\n     public Thread newThread(Runnable r) {\n         Thread t = getWrappedFactory().newThread(r);\n         initializeThread(t);\n          *\n          * @return the new {@code BasicThreadFactory}\n          */\n+        @Override\n         public BasicThreadFactory build() {\n             BasicThreadFactory factory = new BasicThreadFactory(this);\n             reset();\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n          * the constant object managed by this {@code Future} implementation is\n          * always available.\n          */\n+        @Override\n         public boolean isDone() {\n             return true;\n         }\n         /**\n          * {@inheritDoc} This implementation just returns the constant value.\n          */\n+        @Override\n         public T get() {\n             return value;\n         }\n          * {@inheritDoc} This implementation just returns the constant value; it\n          * does not block, therefore the timeout has no meaning.\n          */\n+        @Override\n         public T get(long timeout, TimeUnit unit) {\n             return value;\n         }\n          * {@inheritDoc} This implementation always returns <b>false</b>; there\n          * is no background process which could be cancelled.\n          */\n+        @Override\n         public boolean isCancelled() {\n             return false;\n         }\n          * {@inheritDoc} The cancel operation is not supported. This\n          * implementation always returns <b>false</b>.\n          */\n+        @Override\n         public boolean cancel(boolean mayInterruptIfRunning) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConstantInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConstantInitializer.java\n      * @return the object managed by this initializer\n      * @throws ConcurrentException if an error occurs\n      */\n+    @Override\n     public T get() throws ConcurrentException {\n         return getObject();\n     }\n--- a/src/main/java/org/apache/commons/lang3/concurrent/LazyInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/LazyInitializer.java\n      * @throws ConcurrentException if an error occurred during initialization of\n      * the object\n      */\n+    @Override\n     public T get() throws ConcurrentException {\n         // use a temporary variable to reduce the number of reads of the\n         // volatile field\n--- a/src/main/java/org/apache/commons/lang3/concurrent/TimedSemaphore.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/TimedSemaphore.java\n      */\n     protected ScheduledFuture<?> startTimer() {\n         return getExecutorService().scheduleAtFixedRate(new Runnable() {\n+            @Override\n             public void run() {\n                 endOfPeriod();\n             }\n--- a/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n          * @return the result of the method call\n          * @throws Throwable if an error occurs\n          */\n+        @Override\n         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n             for (L listener : listeners) {\n                 method.invoke(listener, args);\n--- a/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n          * @return the result of the method call\n          * @throws Throwable if an error occurs\n          */\n+        @Override\n         public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable {\n             if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) {\n                 if (hasMatchingParametersMethod(method)) {\n--- a/src/main/java/org/apache/commons/lang3/exception/ContextedException.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/ContextedException.java\n      * @param value  information needed to understand exception, may be {@code null}\n      * @return {@code this}, for method chaining, not {@code null}\n      */\n+    @Override\n     public ContextedException addContextValue(String label, Object value) {        \n         exceptionContext.addContextValue(label, value);\n         return this;\n      * @param value  information needed to understand exception, may be {@code null}\n      * @return {@code this}, for method chaining, not {@code null}\n      */\n+    @Override\n     public ContextedException setContextValue(String label, Object value) {        \n         exceptionContext.setContextValue(label, value);\n         return this;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public List<Object> getContextValues(String label) {\n         return this.exceptionContext.getContextValues(label);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Object getFirstContextValue(String label) {\n         return this.exceptionContext.getFirstContextValue(label);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public List<Pair<String, Object>> getContextEntries() {\n         return this.exceptionContext.getContextEntries();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Set<String> getContextLabels() {\n         return exceptionContext.getContextLabels();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public String getFormattedExceptionMessage(String baseMessage) {\n         return exceptionContext.getFormattedExceptionMessage(baseMessage);\n     }\n--- a/src/main/java/org/apache/commons/lang3/exception/ContextedRuntimeException.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/ContextedRuntimeException.java\n      * @param value  information needed to understand exception, may be {@code null}\n      * @return {@code this}, for method chaining, not {@code null}\n      */\n+    @Override\n     public ContextedRuntimeException addContextValue(String label, Object value) {        \n         exceptionContext.addContextValue(label, value);\n         return this;\n      * @param value  information needed to understand exception, may be {@code null}\n      * @return {@code this}, for method chaining, not {@code null}\n      */\n+    @Override\n     public ContextedRuntimeException setContextValue(String label, Object value) {        \n         exceptionContext.setContextValue(label, value);\n         return this;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public List<Object> getContextValues(String label) {\n         return this.exceptionContext.getContextValues(label);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Object getFirstContextValue(String label) {\n         return this.exceptionContext.getFirstContextValue(label);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public List<Pair<String, Object>> getContextEntries() {\n         return this.exceptionContext.getContextEntries();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Set<String> getContextLabels() {\n         return exceptionContext.getContextLabels();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public String getFormattedExceptionMessage(String baseMessage) {\n         return exceptionContext.getFormattedExceptionMessage(baseMessage);\n     }\n--- a/src/main/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public DefaultExceptionContext addContextValue(String label, Object value) {\n         contextValues.add(new ImmutablePair<String, Object>(label, value));\n         return this;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public DefaultExceptionContext setContextValue(String label, Object value) {\n         for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext();) {\n             final Pair<String, Object> p = iter.next();\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public List<Object> getContextValues(String label) {\n         final List<Object> values = new ArrayList<Object>();\n         for (final Pair<String, Object> pair : contextValues) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Object getFirstContextValue(String label) {\n         for (final Pair<String, Object> pair : contextValues) {\n             if (StringUtils.equals(label, pair.getKey())) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Set<String> getContextLabels() {\n         final Set<String> labels = new HashSet<String>();\n         for (final Pair<String, Object> pair : contextValues) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public List<Pair<String, Object>> getContextEntries() {\n         return contextValues;\n     }\n      * @param baseMessage  the base exception message <b>without</b> context information appended\n      * @return the exception message <b>with</b> context information appended, never null\n      */\n+    @Override\n     public String getFormattedExceptionMessage(String baseMessage){\n         StringBuilder buffer = new StringBuilder(256);\n         if (baseMessage != null) {\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n      * @throws ClassCastException if the object is not a <code>Fraction</code>\n      * @throws NullPointerException if the object is <code>null</code>\n      */\n+    @Override\n     public int compareTo(Fraction other) {\n         if (this==other) {\n             return 0;\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableBoolean.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableBoolean.java\n      * \n      * @return the value as a Boolean, never null\n      */\n+    @Override\n     public Boolean getValue() {\n         return Boolean.valueOf(this.value);\n     }\n      * @param value  the value to set, not null\n      * @throws NullPointerException if the object is null\n      */\n+    @Override\n     public void setValue(Boolean value) {\n         this.value = value.booleanValue();\n     }\n      * @return negative if this is less, zero if equal, positive if greater\n      *  where false is less than true\n      */\n+    @Override\n     public int compareTo(MutableBoolean other) {\n         boolean anotherVal = other.value;\n         return value == anotherVal ? 0 : (value ? 1 : -1);\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableByte.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableByte.java\n      * \n      * @return the value as a Byte, never null\n      */\n+    @Override\n     public Byte getValue() {\n         return Byte.valueOf(this.value);\n     }\n      * @param value  the value to set, not null\n      * @throws NullPointerException if the object is null\n      */\n+    @Override\n     public void setValue(Number value) {\n         this.value = value.byteValue();\n     }\n      * @param other  the other mutable to compare to, not null\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n+    @Override\n     public int compareTo(MutableByte other) {\n         byte anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableDouble.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableDouble.java\n      * \n      * @return the value as a Double, never null\n      */\n+    @Override\n     public Double getValue() {\n         return Double.valueOf(this.value);\n     }\n      * @param value  the value to set, not null\n      * @throws NullPointerException if the object is null\n      */\n+    @Override\n     public void setValue(Number value) {\n         this.value = value.doubleValue();\n     }\n      * @param other  the other mutable to compare to, not null\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n+    @Override\n     public int compareTo(MutableDouble other) {\n         double anotherVal = other.value;\n         return Double.compare(value, anotherVal);\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableFloat.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableFloat.java\n      * \n      * @return the value as a Float, never null\n      */\n+    @Override\n     public Float getValue() {\n         return Float.valueOf(this.value);\n     }\n      * @param value  the value to set, not null\n      * @throws NullPointerException if the object is null\n      */\n+    @Override\n     public void setValue(Number value) {\n         this.value = value.floatValue();\n     }\n      * @param other  the other mutable to compare to, not null\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n+    @Override\n     public int compareTo(MutableFloat other) {\n         float anotherVal = other.value;\n         return Float.compare(value, anotherVal);\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableInt.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableInt.java\n      * \n      * @return the value as a Integer, never null\n      */\n+    @Override\n     public Integer getValue() {\n         return Integer.valueOf(this.value);\n     }\n      * @param value  the value to set, not null\n      * @throws NullPointerException if the object is null\n      */\n+    @Override\n     public void setValue(Number value) {\n         this.value = value.intValue();\n     }\n      * @param other  the other mutable to compare to, not null\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n+    @Override\n     public int compareTo(MutableInt other) {\n         int anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableLong.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableLong.java\n      * \n      * @return the value as a Long, never null\n      */\n+    @Override\n     public Long getValue() {\n         return Long.valueOf(this.value);\n     }\n      * @param value  the value to set, not null\n      * @throws NullPointerException if the object is null\n      */\n+    @Override\n     public void setValue(Number value) {\n         this.value = value.longValue();\n     }\n      * @param other  the other mutable to compare to, not null\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n+    @Override\n     public int compareTo(MutableLong other) {\n         long anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableObject.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableObject.java\n      * \n      * @return the value, may be null\n      */\n+    @Override\n     public T getValue() {\n         return this.value;\n     }\n      * \n      * @param value  the value to set\n      */\n+    @Override\n     public void setValue(T value) {\n         this.value = value;\n     }\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableShort.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableShort.java\n      * \n      * @return the value as a Short, never null\n      */\n+    @Override\n     public Short getValue() {\n         return Short.valueOf(this.value);\n     }\n      * @param value  the value to set, not null\n      * @throws NullPointerException if the object is null\n      */\n+    @Override\n     public void setValue(Number value) {\n         this.value = value.shortValue();\n     }\n      * @param other  the other mutable to compare to, not null\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n+    @Override\n     public int compareTo(MutableShort other) {\n         short anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n--- a/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n      *\n      * @return the length\n      */\n+    @Override\n     public int length() {\n         return size;\n     }\n      * @return the character at the index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n+    @Override\n     public char charAt(int index) {\n         if (index < 0 || index >= length()) {\n             throw new StringIndexOutOfBoundsException(index);\n      * @return this, to enable chaining\n      * @since 3.0\n      */\n+    @Override\n     public StrBuilder append(CharSequence seq) {\n         if (seq == null) {\n             return appendNull();\n      * @return this, to enable chaining\n      * @since 3.0\n      */\n+    @Override\n     public StrBuilder append(CharSequence seq, int startIndex, int length) {\n         if (seq == null) {\n             return appendNull();\n      * @return this, to enable chaining\n      * @since 3.0\n      */\n+    @Override\n     public StrBuilder append(char ch) {\n         int len = length();\n         ensureCapacity(len + 1);\n      * {@inheritDoc}\n      * @since 3.0\n      */\n+    @Override\n     public CharSequence subSequence(int startIndex, int endIndex) {\n       if (startIndex < 0) {\n           throw new StringIndexOutOfBoundsException(startIndex);\n--- a/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n      *\n      * @return true if there are more tokens\n      */\n+    @Override\n     public boolean hasNext() {\n         checkTokenized();\n         return tokenPos < tokens.length;\n      * @return the next String token\n      * @throws NoSuchElementException if there are no more elements\n      */\n+    @Override\n     public String next() {\n         if (hasNext()) {\n             return tokens[tokenPos++];\n      *\n      * @return the next token index\n      */\n+    @Override\n     public int nextIndex() {\n         return tokenPos;\n     }\n      *\n      * @return true if there are previous tokens\n      */\n+    @Override\n     public boolean hasPrevious() {\n         checkTokenized();\n         return tokenPos > 0;\n      *\n      * @return the previous token\n      */\n+    @Override\n     public String previous() {\n         if (hasPrevious()) {\n             return tokens[--tokenPos];\n      *\n      * @return the previous token index\n      */\n+    @Override\n     public int previousIndex() {\n         return tokenPos - 1;\n     }\n      *\n      * @throws UnsupportedOperationException always\n      */\n+    @Override\n     public void remove() {\n         throw new UnsupportedOperationException(\"remove() is unsupported\");\n     }\n      * @param obj this parameter ignored.\n      * @throws UnsupportedOperationException always\n      */\n+    @Override\n     public void set(String obj) {\n         throw new UnsupportedOperationException(\"set() is unsupported\");\n     }\n      * @param obj this parameter ignored.\n      * @throws UnsupportedOperationException always\n      */\n+    @Override\n     public void add(String obj) {\n         throw new UnsupportedOperationException(\"add() is unsupported\");\n     }\n--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n          *\n          * @return <code>true</code> if the iterator has yet to reach the end date\n          */\n+        @Override\n         public boolean hasNext() {\n             return spot.before(endFinal);\n         }\n          *\n          * @return Object calendar for the next date\n          */\n+        @Override\n         public Calendar next() {\n             if (spot.equals(endFinal)) {\n                 throw new NoSuchElementException();\n          * @throws UnsupportedOperationException\n          * @see java.util.Iterator#remove()\n          */\n+        @Override\n         public void remove() {\n             throw new UnsupportedOperationException();\n         }\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n      * @return the formatted string\n      * @since 2.1\n      */\n+    @Override\n     public String format(long millis) {\n         return format(new Date(millis));\n     }\n      * @param date  the date to format\n      * @return the formatted string\n      */\n+    @Override\n     public String format(Date date) {\n         return printer.format(date);\n     }\n      * @param calendar  the calendar to format\n      * @return the formatted string\n      */\n+    @Override\n     public String format(Calendar calendar) {\n         return printer.format(calendar);\n     }\n      * @return the specified string buffer\n      * @since 2.1\n      */\n+    @Override\n     public StringBuffer format(long millis, StringBuffer buf) {\n         return printer.format(millis, buf);\n     }\n      * @param buf  the buffer to format into\n      * @return the specified string buffer\n      */\n+    @Override\n     public StringBuffer format(Date date, StringBuffer buf) {\n         return printer.format(date, buf);\n     }\n      * @param buf  the buffer to format into\n      * @return the specified string buffer\n      */\n+    @Override\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         return printer.format(calendar, buf);\n     }\n     /* (non-Javadoc)\n      * @see DateParser#parse(java.lang.String)\n      */\n+    @Override\n     public Date parse(String source) throws ParseException {\n         return parser.parse(source);\n     }\n     /* (non-Javadoc)\n      * @see DateParser#parse(java.lang.String, java.text.ParsePosition)\n      */\n+    @Override\n     public Date parse(String source, ParsePosition pos) {\n             return parser.parse(source, pos);\n     }\n      *\n      * @return the pattern, {@link java.text.SimpleDateFormat} compatible\n      */\n+    @Override\n     public String getPattern() {\n         return printer.getPattern();\n     }\n      *\n      * @return the time zone\n      */\n+    @Override\n     public TimeZone getTimeZone() {\n         return printer.getTimeZone();\n     }\n      *\n      * @return the locale\n      */\n+    @Override\n     public Locale getLocale() {\n         return printer.getLocale();\n     }\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DateParser#getPattern()\n      */\n+    @Override\n     public String getPattern() {\n         return pattern;\n     }\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DateParser#getTimeZone()\n      */\n+    @Override\n     public TimeZone getTimeZone() {\n         return timeZone;\n     }\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DateParser#getLocale()\n      */\n+    @Override\n     public Locale getLocale() {\n         return locale;\n     }\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DateParser#parseObject(java.lang.String)\n      */\n+    @Override\n     public Object parseObject(String source) throws ParseException {\n         return parse(source);\n     }\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DateParser#parse(java.lang.String)\n      */\n+    @Override\n     public Date parse(String source) throws ParseException {\n         Date date= parse(source, new ParsePosition(0));\n         if(date==null) {\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DateParser#parseObject(java.lang.String, java.text.ParsePosition)\n      */\n+    @Override\n     public Object parseObject(String source, ParsePosition pos) {\n         return parse(source, pos);\n     }\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DateParser#parse(java.lang.String, java.text.ParsePosition)\n      */\n+    @Override\n     public Date parse(String source, ParsePosition pos) {\n         int offset= pos.getIndex();\n         Matcher matcher= parsePattern.matcher(source.substring(offset));\n      * ignore case comparison of keys\n      */\n     private static final Comparator<KeyValue> IGNORE_CASE_COMPARATOR = new Comparator<KeyValue> () {\n+        @Override\n         public int compare(KeyValue left, KeyValue right) {\n             return left.key.compareToIgnoreCase(right.key);\n         }        \n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public boolean isNumber() {\n             char c= formatField.charAt(0);\n             if(c=='\\'') {\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n             escapeRegex(regex, formatField, true);\n             return false;\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n         }\n     }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public boolean isNumber() {\n             return false;\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n             regex.append('(');\n             for(KeyValue textKeyValue : parser.getDisplayNames(field)) {\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n             KeyValue[] textKeyValues= parser.getDisplayNames(field);\n             int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR);\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public boolean isNumber() {\n             return true;\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n             if(parser.isNextNumber()) {\n                 regex.append(\"(\\\\d{\").append(parser.getFieldWidth()).append(\"}+)\");\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n             cal.set(field, modify(Integer.parseInt(value)));\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public boolean isNumber() {\n             return false;\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n             regex.append(validTimeZoneChars);\n             return true;\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n             TimeZone tz;\n             if(value.charAt(0)=='+' || value.charAt(0)=='-') {\n     private static final Strategy TEXT_MONTH_STRATEGY = new TextStrategy(Calendar.MONTH);\n     \n     private static final Strategy NUMBER_MONTH_STRATEGY = new NumberStrategy(Calendar.MONTH) {\n+        @Override\n         public int modify(int iValue) {\n             return iValue-1;            \n         }\n     private static final Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY = new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH);\n     private static final Strategy HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY);\n     private static final Strategy MODULO_HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY) {\n+        @Override\n         public int modify(int iValue) {\n             return iValue%24;            \n         }\n     };\n     private static final Strategy MODULO_HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR) {\n+        @Override\n         public int modify(int iValue) {\n             return iValue%12;            \n         }\n--- a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\n      * @param pos  the position - ignored\n      * @return the buffer passed in\n      */\n+    @Override\n     public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n         if (obj instanceof Date) {\n             return format((Date) obj, toAppendTo);\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DatePrinter#format(long)\n      */\n+    @Override\n     public String format(long millis) {\n         return format(new Date(millis));\n     }\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Date)\n      */\n+    @Override\n     public String format(Date date) {\n         Calendar c = new GregorianCalendar(mTimeZone, mLocale);  // hard code GregorianCalendar\n         c.setTime(date);\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Calendar)\n      */\n+    @Override\n     public String format(Calendar calendar) {\n         return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DatePrinter#format(long, java.lang.StringBuffer)\n      */\n+    @Override\n     public StringBuffer format(long millis, StringBuffer buf) {\n         return format(new Date(millis), buf);\n     }\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Date, java.lang.StringBuffer)\n      */\n+    @Override\n     public StringBuffer format(Date date, StringBuffer buf) {\n         Calendar c = new GregorianCalendar(mTimeZone, mLocale);  // hard code GregorianCalendar\n         c.setTime(date);\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Calendar, java.lang.StringBuffer)\n      */\n+    @Override\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         return applyRules(calendar, buf);\n     }\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DatePrinter#getPattern()\n      */\n+    @Override\n     public String getPattern() {\n         return mPattern;\n     }\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DatePrinter#getTimeZone()\n      */\n+    @Override\n     public TimeZone getTimeZone() {\n         return mTimeZone;\n     }\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DatePrinter#getLocale()\n      */\n+    @Override\n     public Locale getLocale() {\n         return mLocale;\n     }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return 1;\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             buffer.append(mValue);\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return mValue.length();\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             buffer.append(mValue);\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             int max = 0;\n             for (int i=mValues.length; --i >= 0; ) {\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             buffer.append(mValues[calendar.get(mField)]);\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return 4;\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             appendTo(buffer, calendar.get(mField));\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public final void appendTo(StringBuffer buffer, int value) {\n             if (value < 10) {\n                 buffer.append((char)(value + '0'));\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return 2;\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public final void appendTo(StringBuffer buffer, int value) {\n             if (value < 10) {\n                 buffer.append((char)(value + '0'));\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return 4;\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             appendTo(buffer, calendar.get(mField));\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public final void appendTo(StringBuffer buffer, int value) {\n             if (value < 100) {\n                 for (int i = mSize; --i >= 2; ) {\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return 2;\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             appendTo(buffer, calendar.get(mField));\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public final void appendTo(StringBuffer buffer, int value) {\n             if (value < 100) {\n                 buffer.append((char)(value / 10 + '0'));\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return 2;\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public final void appendTo(StringBuffer buffer, int value) {\n             buffer.append((char)(value / 10 + '0'));\n             buffer.append((char)(value % 10 + '0'));\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return 2;\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public final void appendTo(StringBuffer buffer, int value) {\n             buffer.append((char)(value / 10 + '0'));\n             buffer.append((char)(value % 10 + '0'));\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return mRule.estimateLength();\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             int value = calendar.get(Calendar.HOUR);\n             if (value == 0) {\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, int value) {\n             mRule.appendTo(buffer, value);\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return mRule.estimateLength();\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             int value = calendar.get(Calendar.HOUR_OF_DAY);\n             if (value == 0) {\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, int value) {\n             mRule.appendTo(buffer, value);\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return Math.max(mStandard.length(), mDaylight.length());\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n                 buffer.append(mDaylight);\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public int estimateLength() {\n             return 5;\n         }\n         /**\n          * {@inheritDoc}\n          */\n+        @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n \n--- a/src/main/java/org/apache/commons/lang3/tuple/ImmutablePair.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/ImmutablePair.java\n      * @return never\n      * @throws UnsupportedOperationException as this operation is not supported\n      */\n+    @Override\n     public R setValue(R value) {\n         throw new UnsupportedOperationException();\n     }\n--- a/src/main/java/org/apache/commons/lang3/tuple/MutablePair.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/MutablePair.java\n      * @param value  the right value to set, not null\n      * @return the old value for the right element\n      */\n+    @Override\n     public R setValue(R value) {\n         R result = getRight();\n         setRight(value);\n--- a/src/main/java/org/apache/commons/lang3/tuple/Pair.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/Pair.java\n      * \n      * @return the left element as the key, may be null\n      */\n+    @Override\n     public final L getKey() {\n         return getLeft();\n     }\n      * \n      * @return the right element as the value, may be null\n      */\n+    @Override\n     public R getValue() {\n         return getRight();\n     }\n      * @param other  the other pair, not null\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n+    @Override\n     public int compareTo(Pair<L, R> other) {\n       return new CompareToBuilder().append(getLeft(), other.getLeft())\n               .append(getRight(), other.getRight()).toComparison();\n--- a/src/main/java/org/apache/commons/lang3/tuple/Triple.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/Triple.java\n      * @param other  the other triple, not null\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n+    @Override\n     public int compareTo(Triple<L, M, R> other) {\n       return new CompareToBuilder().append(getLeft(), other.getLeft())\n           .append(getMiddle(), other.getMiddle())\n--- a/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest.java\n \n         InvocationHandler generatedTestInvocationHandler = new InvocationHandler() {\n \n+            @Override\n             public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                 if (\"equals\".equals(method.getName()) && method.getParameterTypes().length == 1) {\n                     return Boolean.valueOf(proxy == args[0]);\n--- a/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n         } catch (IllegalArgumentException ex) {}\n         \n         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() {\n+            @Override\n             public Object getKey() {\n                 return \"foo\";\n             }\n+            @Override\n             public Object getValue() {\n                 return \"bar\";\n             }\n+            @Override\n             public Object setValue(Object value) {\n                 throw new UnsupportedOperationException();\n             }\n--- a/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n             this.value = value;\n         }\n \n+        @Override\n         public char charAt(int arg0) {\n             return value.charAt(arg0);\n         }\n \n+        @Override\n         public int length() {\n             return value.length();\n         }\n \n+        @Override\n         public CharSequence subSequence(int arg0, int arg1) {\n             return value.subSequence(arg0, arg1);\n         }\n \n     static final class CharSequenceComparator implements Comparator<CharSequence> {\n \n+        @Override\n         public int compare(CharSequence o1, CharSequence o2) {\n             return o1.toString().compareTo(o2.toString());\n         }\n--- a/src/test/java/org/apache/commons/lang3/RangeTest.java\n+++ b/src/test/java/org/apache/commons/lang3/RangeTest.java\n     public void testComparableConstructors() {\n         Comparable c = \n             new Comparable() { \n+                @Override\n                 public int compareTo(Object other) {\n                     return 1;\n                 }\n     @Test\n     public void testIsWithCompare(){\n         Comparator<Integer> c = new Comparator<Integer>(){\n+            @Override\n             public int compare(Integer o1, Integer o2) {\n                 return 0; // all integers are equal\n             }\n     public void testBetweenWithCompare(){\n         // TODO add tests with a better comparator\n         Comparator<Integer> c = new Comparator<Integer>(){\n+            @Override\n             public int compare(Integer o1, Integer o2) {\n                 return 0; // all integers are equal\n             }\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n             this.seq = seq;\n         }\n \n+        @Override\n         public char charAt(int index) {\n             return seq.charAt(index);\n         }\n \n+        @Override\n         public int length() {\n             return seq.length();\n         }\n \n+        @Override\n         public CharSequence subSequence(int start, int end) {\n             return new CustomCharSequence(seq.subSequence(start, end));\n         }\n             return seq.equals(other.seq);\n         }\n \n+        @Override\n         public String toString() {\n             return seq.toString();\n         }\n--- a/src/test/java/org/apache/commons/lang3/builder/CompareToBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/CompareToBuilderTest.java\n         public int getA() {\n             return a;\n         }\n+        @Override\n         public int compareTo(TestObject rhs) {\n             return a < rhs.a ? -1 : a > rhs.a ? +1 : 0;\n         }\n--- a/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderConcurrencyTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderConcurrencyTest.java\n         final ExecutorService threadPool = Executors.newFixedThreadPool(2);\n         // Consumes toStrings\n         Callable<Integer> consumer = new Callable<Integer>() {\n+            @Override\n             public Integer call() {\n                 for (int i = 0; i < REPEAT; i++) {\n                     String s = ReflectionToStringBuilder.toString(holder);\n         };\n         // Produces changes in the list\n         Callable<Integer> producer = new Callable<Integer>() {\n+            @Override\n             public Integer call() {\n                 for (int i = 0; i < DATA_SIZE; i++) {\n                     list.remove(list.get(0));\n--- a/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderMutateInspectConcurrencyTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderMutateInspectConcurrencyTest.java\n             this.testFixture = testFixture;\n         }\n \n+        @Override\n         public void run() {\n             if (random.nextBoolean()) {\n                 testFixture.add();\n             this.testFixture = testFixture;\n         }\n \n+        @Override\n         public void run() {\n             ReflectionToStringBuilder.toString(testFixture);\n         }\n--- a/src/test/java/org/apache/commons/lang3/builder/ToStringStyleConcurrencyTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ToStringStyleConcurrencyTest.java\n         final ExecutorService threadPool = Executors.newFixedThreadPool(2);\n         // Consumes toStrings\n         Callable<Integer> consumer = new Callable<Integer>() {\n+            @Override\n             public Integer call() {\n                 for (int i = 0; i < REPEAT; i++) {\n                     // Calls ToStringStyle\n--- a/src/test/java/org/apache/commons/lang3/concurrent/CallableBackgroundInitializerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/CallableBackgroundInitializerTest.java\n         /**\n          * Records this invocation and returns the test result.\n          */\n+        @Override\n         public Integer call() throws Exception {\n             callCount++;\n             return RESULT;\n--- a/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n+++ b/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n         EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);\n         listenerSupport.addListener(new VetoableChangeListener() {\n             \n+            @Override\n             public void vetoableChange(PropertyChangeEvent e) {\n             }\n         });\n     {\n         listenerSupport.addListener(new VetoableChangeListener()\n         {\n+            @Override\n             public void vetoableChange(PropertyChangeEvent e)\n             {\n                 listenerSupport.removeListener(this);\n     {\n         return new VetoableChangeListener()\n         {\n+            @Override\n             public void vetoableChange(PropertyChangeEvent e)\n             {\n                 calledListeners.add(this);\n--- a/src/test/java/org/apache/commons/lang3/event/EventUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/event/EventUtilsTest.java\n         {\n             EventUtils.addEventListener(src, PropertyChangeListener.class, new PropertyChangeListener()\n             {\n+                @Override\n                 public void propertyChange(PropertyChangeEvent e)\n                 {\n                     // Do nothing!\n             return count == null ? 0 : count.intValue();\n         }\n \n+        @Override\n         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n         {\n             Integer count = eventCounts.get(method.getName());\n--- a/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java\n     }\n \n     private static class TestMutable implements Mutable<Object> {\n+        @Override\n         public Object getValue() {\n             return null;\n         }\n \n+        @Override\n         public void setValue(Object value) {\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java\n      */\n     private static class LowerCaseFormatFactory implements FormatFactory {\n         private static final Format LOWER_INSTANCE = new LowerCaseFormat();\n+        @Override\n         public Format getFormat(String name, String arguments, Locale locale) {\n             return LOWER_INSTANCE;\n         }\n      */\n     private static class UpperCaseFormatFactory implements FormatFactory {\n         private static final Format UPPER_INSTANCE = new UpperCaseFormat();\n+        @Override\n         public Format getFormat(String name, String arguments, Locale locale) {\n             return UPPER_INSTANCE;\n         }\n      * {@link FormatFactory} implementation to override date format \"short\" to \"default\".\n      */\n     private static class OverrideShortDateFormatFactory implements FormatFactory {\n+        @Override\n         public Format getFormat(String name, String arguments, Locale locale) {\n             return !\"short\".equals(arguments) ? null\n                     : locale == null ? DateFormat\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n         \n         for(int i= 0; i<NTHREADS; ++i) {\n             pool.submit(new Runnable() {\n+                @Override\n                 public void run() {\n                     for(int i= 0; i<NROUNDS; ++i) {\n                         try {", "timestamp": 1333648419, "metainfo": ""}