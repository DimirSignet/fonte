{"sha": "47ee02b66475081d691d6e9bd6ec7a60378f8ac0", "log": "Refactoring FastDateFormat per LANG-462 to use the FormatCache class created for an upcoming DateParser functionality. I've kept FormatCache package-private for now.   ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n import java.text.FieldPosition;\n import java.text.Format;\n import java.text.ParsePosition;\n-import java.text.SimpleDateFormat;\n import java.util.ArrayList;\n import java.util.Calendar;\n import java.util.Date;\n-import java.util.GregorianCalendar;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Locale;\n-import java.util.Map;\n import java.util.TimeZone;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n \n import org.apache.commons.lang3.Validate;\n \n      */\n     public static final int SHORT = DateFormat.SHORT;\n \n-    //@GuardedBy(\"this\")\n-    private static String cDefaultPattern; // lazily initialised by getInstance()\n-\n-    private static final Map<FastDateFormat, FastDateFormat> cInstanceCache =\n-        new HashMap<FastDateFormat, FastDateFormat>(7);\n-    private static final Map<Object, FastDateFormat> cDateInstanceCache = new HashMap<Object, FastDateFormat>(7);\n-    private static final Map<Object, FastDateFormat> cTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\n-    private static final Map<Object, FastDateFormat> cDateTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\n-    private static final Map<Object, String> cTimeZoneDisplayCache = new HashMap<Object, String>(7);\n+    private static final FormatCache<FastDateFormat> cache= new FormatCache<FastDateFormat>() {\n+        @Override\n+        protected FastDateFormat createInstance(String pattern,    TimeZone timeZone, Locale locale) {\n+            return new FastDateFormat(pattern, timeZone, locale);\n+        }\n+    };\n+\n+    private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache =\n+        new ConcurrentHashMap<TimeZoneDisplayKey, String>(7);\n \n     /**\n      * The pattern.\n      */\n     private final TimeZone mTimeZone;\n     /**\n-     * Whether the time zone overrides any on Calendars.\n-     */\n-    private final boolean mTimeZoneForced;\n-    /**\n      * The locale.\n      */\n     private final Locale mLocale;\n-    /**\n-     * Whether the locale overrides the default.\n-     */\n-    private final boolean mLocaleForced;\n     /**\n      * The parsed rules.\n      */\n      * @return a date/time formatter\n      */\n     public static FastDateFormat getInstance() {\n-        return getInstance(getDefaultPattern(), null, null);\n+        return cache.getDateTimeInstance(SHORT, SHORT, null, null);\n     }\n \n     /**\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n     public static FastDateFormat getInstance(String pattern) {\n-        return getInstance(pattern, null, null);\n+        return cache.getInstance(pattern, null, null);\n     }\n \n     /**\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n     public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\n-        return getInstance(pattern, timeZone, null);\n+        return cache.getInstance(pattern, timeZone, null);\n     }\n \n     /**\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n     public static FastDateFormat getInstance(String pattern, Locale locale) {\n-        return getInstance(pattern, null, locale);\n+        return cache.getInstance(pattern, null, locale);\n     }\n \n     /**\n      * @throws IllegalArgumentException if pattern is invalid\n      *  or <code>null</code>\n      */\n-    public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n-        FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\n-        FastDateFormat format = cInstanceCache.get(emptyFormat);\n-        if (format == null) {\n-            format = emptyFormat;\n-            format.init();  // convert shell format into usable one\n-            cInstanceCache.put(format, format);  // this is OK!\n-        }\n-        return format;\n+    public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n+        return cache.getInstance(pattern, timeZone, locale);\n     }\n \n     //-----------------------------------------------------------------------\n      * @since 2.1\n      */\n     public static FastDateFormat getDateInstance(int style) {\n-        return getDateInstance(style, null, null);\n+        return cache.getDateTimeInstance(style, null, null, null);\n     }\n \n     /**\n      * @since 2.1\n      */\n     public static FastDateFormat getDateInstance(int style, Locale locale) {\n-        return getDateInstance(style, null, locale);\n+        return cache.getDateTimeInstance(style, null, null, locale);\n     }\n \n     /**\n      * @since 2.1\n      */\n     public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {\n-        return getDateInstance(style, timeZone, null);\n-    }\n+        return cache.getDateTimeInstance(style, null, timeZone, null);\n+    }\n+    \n     /**\n      * <p>Gets a date formatter instance using the specified style, time\n      * zone and locale.</p>\n      * @throws IllegalArgumentException if the Locale has no date\n      *  pattern defined\n      */\n-    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n-        Object key = Integer.valueOf(style);\n-        if (timeZone != null) {\n-            key = new Pair(key, timeZone);\n-        }\n-\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n-        }\n-\n-        key = new Pair(key, locale);\n-\n-        FastDateFormat format = cDateInstanceCache.get(key);\n-        if (format == null) {\n-            try {\n-                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n-                String pattern = formatter.toPattern();\n-                format = getInstance(pattern, timeZone, locale);\n-                cDateInstanceCache.put(key, format);\n-\n-            } catch (ClassCastException ex) {\n-                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n-            }\n-        }\n-        return format;\n+    public static FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n+        return cache.getDateTimeInstance(style, null, timeZone, locale);\n     }\n \n     //-----------------------------------------------------------------------\n      * @since 2.1\n      */\n     public static FastDateFormat getTimeInstance(int style) {\n-        return getTimeInstance(style, null, null);\n+        return cache.getDateTimeInstance(null, style, null, null);\n     }\n \n     /**\n      * @since 2.1\n      */\n     public static FastDateFormat getTimeInstance(int style, Locale locale) {\n-        return getTimeInstance(style, null, locale);\n+        return cache.getDateTimeInstance(null, style, null, locale);\n     }\n \n     /**\n      * @since 2.1\n      */\n     public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {\n-        return getTimeInstance(style, timeZone, null);\n+        return cache.getDateTimeInstance(null, style, timeZone, null);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the Locale has no time\n      *  pattern defined\n      */\n-    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n-        Object key = Integer.valueOf(style);\n-        if (timeZone != null) {\n-            key = new Pair(key, timeZone);\n-        }\n-        if (locale != null) {\n-            key = new Pair(key, locale);\n-        }\n-\n-        FastDateFormat format = cTimeInstanceCache.get(key);\n-        if (format == null) {\n-            if (locale == null) {\n-                locale = Locale.getDefault();\n-            }\n-\n-            try {\n-                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);\n-                String pattern = formatter.toPattern();\n-                format = getInstance(pattern, timeZone, locale);\n-                cTimeInstanceCache.put(key, format);\n-\n-            } catch (ClassCastException ex) {\n-                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n-            }\n-        }\n-        return format;\n+    public static FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n+        return cache.getDateTimeInstance(null, style, timeZone, locale);\n     }\n \n     //-----------------------------------------------------------------------\n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getDateTimeInstance(\n-            int dateStyle, int timeStyle) {\n-        return getDateTimeInstance(dateStyle, timeStyle, null, null);\n+    public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {\n+        return cache.getDateTimeInstance(dateStyle, timeStyle, null, null);\n     }\n \n     /**\n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getDateTimeInstance(\n-            int dateStyle, int timeStyle, Locale locale) {\n-        return getDateTimeInstance(dateStyle, timeStyle, null, locale);\n+    public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {\n+        return cache.getDateTimeInstance(dateStyle, timeStyle, null, locale);\n     }\n \n     /**\n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getDateTimeInstance(\n-            int dateStyle, int timeStyle, TimeZone timeZone) {\n+    public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {\n         return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);\n     }\n     /**\n      * @throws IllegalArgumentException if the Locale has no date/time\n      *  pattern defined\n      */\n-    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,\n-            Locale locale) {\n-\n-        Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));\n-        if (timeZone != null) {\n-            key = new Pair(key, timeZone);\n-        }\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n-        }\n-        key = new Pair(key, locale);\n-\n-        FastDateFormat format = cDateTimeInstanceCache.get(key);\n-        if (format == null) {\n-            try {\n-                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n-                        locale);\n-                String pattern = formatter.toPattern();\n-                format = getInstance(pattern, timeZone, locale);\n-                cDateTimeInstanceCache.put(key, format);\n-\n-            } catch (ClassCastException ex) {\n-                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n-            }\n-        }\n-        return format;\n+    public static FastDateFormat getDateTimeInstance(\n+            int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {\n+        return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);\n     }\n \n     //-----------------------------------------------------------------------\n      * @param locale  the locale to use\n      * @return the textual name of the time zone\n      */\n-    static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n-        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n+    static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n+        TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n         String value = cTimeZoneDisplayCache.get(key);\n         if (value == null) {\n             // This is a very slow call, so cache the results.\n             value = tz.getDisplayName(daylight, style, locale);\n-            cTimeZoneDisplayCache.put(key, value);\n+            String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n+            if (prior != null) {\n+                value= prior;\n+            }\n         }\n         return value;\n-    }\n-\n-    /**\n-     * <p>Gets the default pattern.</p>\n-     *\n-     * @return the default pattern\n-     */\n-    private static synchronized String getDefaultPattern() {\n-        if (cDefaultPattern == null) {\n-            cDefaultPattern = new SimpleDateFormat().toPattern();\n-        }\n-        return cDefaultPattern;\n     }\n \n     // Constructor\n     /**\n      * <p>Constructs a new FastDateFormat.</p>\n      *\n-     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n-     *  pattern\n-     * @param timeZone  time zone to use, <code>null</code> means use\n-     *  default for <code>Date</code> and value within for\n-     *  <code>Calendar</code>\n-     * @param locale  locale, <code>null</code> means use system\n-     *  default\n-     * @throws IllegalArgumentException if pattern is invalid or\n-     *  <code>null</code>\n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone  non-null time zone to use\n+     * @param locale  non-null locale to use\n+     * @throws NullPointerException if pattern, timeZone, or locale is null.\n      */\n     protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n-        super();\n-        if (pattern == null) {\n-            throw new IllegalArgumentException(\"The pattern must not be null\");\n-        }\n         mPattern = pattern;\n-\n-        mTimeZoneForced = (timeZone != null);\n-        if (timeZone == null) {\n-            timeZone = TimeZone.getDefault();\n-        }\n         mTimeZone = timeZone;\n-\n-        mLocaleForced = (locale != null);\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n-        }\n         mLocale = locale;\n+\n+        init();\n     }\n \n     /**\n      * <p>Initializes the instance for first use.</p>\n      */\n-    protected void init() {\n+    private void init() {\n         List<Rule> rulesList = parsePattern();\n         mRules = rulesList.toArray(new Rule[rulesList.size()]);\n \n                 break;\n             case 'z': // time zone (text)\n                 if (tokenLen >= 4) {\n-                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n+                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                 } else {\n-                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n+                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                 }\n                 break;\n             case 'Z': // time zone (value)\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n+        Calendar c = Calendar.getInstance(mTimeZone, mLocale);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n      * @return the specified string buffer\n      */\n     public StringBuffer format(Date date, StringBuffer buf) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+        Calendar c = Calendar.getInstance(mTimeZone, mLocale);\n         c.setTime(date);\n         return applyRules(c, buf);\n     }\n      * @return the specified string buffer\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n-        if (mTimeZoneForced) {\n-            calendar.getTimeInMillis(); /// LANG-538\n-            calendar = (Calendar) calendar.clone();\n-            calendar.setTimeZone(mTimeZone);\n-        }\n         return applyRules(calendar, buf);\n     }\n \n      * @return the specified string buffer\n      */\n     protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n-        Rule[] rules = mRules;\n-        int len = mRules.length;\n-        for (int i = 0; i < len; i++) {\n-            rules[i].appendTo(buf, calendar);\n+        for (Rule rule : mRules) {\n+            rule.appendTo(buf, calendar);\n         }\n         return buf;\n     }\n     /**\n      * <p>Gets the time zone used by this formatter.</p>\n      *\n-     * <p>This zone is always used for <code>Date</code> formatting.\n-     * If a <code>Calendar</code> is passed in to be formatted, the\n-     * time zone on that may be used depending on\n-     * {@link #getTimeZoneOverridesCalendar()}.</p>\n+     * <p>This zone is always used for <code>Date</code> formatting. </p>\n      *\n      * @return the time zone\n      */\n     public TimeZone getTimeZone() {\n         return mTimeZone;\n-    }\n-\n-    /**\n-     * <p>Returns <code>true</code> if the time zone of the\n-     * calendar overrides the time zone of the formatter.</p>\n-     *\n-     * @return <code>true</code> if time zone of formatter\n-     *  overridden for calendars\n-     */\n-    public boolean getTimeZoneOverridesCalendar() {\n-        return mTimeZoneForced;\n     }\n \n     /**\n             return false;\n         }\n         FastDateFormat other = (FastDateFormat) obj;\n-        if (\n-            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&\n-            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&\n-            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&\n-            (mTimeZoneForced == other.mTimeZoneForced) &&\n-            (mLocaleForced == other.mLocaleForced)\n-            ) {\n-            return true;\n-        }\n-        return false;\n+        return mPattern.equals(other.mPattern)\n+            && mTimeZone.equals(other.mTimeZone) \n+            && mLocale.equals(other.mLocale);\n     }\n \n     /**\n      */\n     @Override\n     public int hashCode() {\n-        int total = 0;\n-        total += mPattern.hashCode();\n-        total += mTimeZone.hashCode();\n-        total += (mTimeZoneForced ? 1 : 0);\n-        total += mLocale.hashCode();\n-        total += (mLocaleForced ? 1 : 0);\n-        return total;\n+        return mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode());\n     }\n \n     /**\n      */\n     private static class TimeZoneNameRule implements Rule {\n         private final TimeZone mTimeZone;\n-        private final boolean mTimeZoneForced;\n-        private final Locale mLocale;\n-        private final int mStyle;\n         private final String mStandard;\n         private final String mDaylight;\n \n          * Constructs an instance of <code>TimeZoneNameRule</code> with the specified properties.\n          *\n          * @param timeZone the time zone\n-         * @param timeZoneForced if <code>true</code> the time zone is forced into standard and daylight\n          * @param locale the locale\n          * @param style the style\n          */\n-        TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {\n+        TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n             mTimeZone = timeZone;\n-            mTimeZoneForced = timeZoneForced;\n-            mLocale = locale;\n-            mStyle = style;\n-\n-            if (timeZoneForced) {\n-                mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n-                mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n+\n+            mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n+            mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return Math.max(mStandard.length(), mDaylight.length());\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n+                buffer.append(mDaylight);\n             } else {\n-                mStandard = null;\n-                mDaylight = null;\n-            }\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            if (mTimeZoneForced) {\n-                return Math.max(mStandard.length(), mDaylight.length());\n-            } else if (mStyle == TimeZone.SHORT) {\n-                return 4;\n-            } else {\n-                return 40;\n-            }\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            if (mTimeZoneForced) {\n-                if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n-                    buffer.append(mDaylight);\n-                } else {\n-                    buffer.append(mStandard);\n-                }\n-            } else {\n-                TimeZone timeZone = calendar.getTimeZone();\n-                if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n-                    buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));\n-                } else {\n-                    buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));\n-                }\n+                buffer.append(mStandard);\n             }\n         }\n     }\n          */\n         @Override\n         public int hashCode() {\n-            return mStyle * 31 + mLocale.hashCode();\n+            return (mStyle * 31 + mLocale.hashCode() ) * 31 + mTimeZone.hashCode();\n         }\n \n         /**\n             return false;\n         }\n     }\n-\n-    // ----------------------------------------------------------------------\n-    /**\n-     * <p>Helper class for creating compound objects.</p>\n-     *\n-     * <p>One use for this class is to create a hashtable key\n-     * out of multiple objects.</p>\n-     */\n-    private static class Pair {\n-        private final Object mObj1;\n-        private final Object mObj2;\n-\n-        /**\n-         * Constructs an instance of <code>Pair</code> to hold the specified objects.\n-         * @param obj1 one object in the pair\n-         * @param obj2 second object in the pair\n-         */\n-        public Pair(Object obj1, Object obj2) {\n-            mObj1 = obj1;\n-            mObj2 = obj2;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (this == obj) {\n-                return true;\n-            }\n-\n-            if (!(obj instanceof Pair)) {\n-                return false;\n-            }\n-\n-            Pair key = (Pair)obj;\n-\n-            return\n-                (mObj1 == null ?\n-                 key.mObj1 == null : mObj1.equals(key.mObj1)) &&\n-                (mObj2 == null ?\n-                 key.mObj2 == null : mObj2.equals(key.mObj2));\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        @Override\n-        public int hashCode() {\n-            return\n-                (mObj1 == null ? 0 : mObj1.hashCode()) +\n-                (mObj2 == null ? 0 : mObj2.hashCode());\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        @Override\n-        public String toString() {\n-            return \"[\" + mObj1 + ':' + mObj2 + ']';\n-        }\n-    }\n-\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/time/FormatCache.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import java.text.DateFormat;\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+/**\n+ * <p>FormatCache is a cache and factory for {@link Format}s.</p>\n+ * \n+ * @since 3.0\n+ * @version $Id: FormatCache 892161 2009-12-18 07:21:10Z  $\n+ */\n+abstract class FormatCache<F extends Format> {\n+    /**\n+     * No date or no time.  Used in same parameters as DateFormat.SHORT or DateFormat.LONG\n+     */\n+    static final int NONE= -1;\n+    \n+    private final ConcurrentMap<MultipartKey, F> cInstanceCache \n+        = new ConcurrentHashMap<MultipartKey, F>(7);\n+    \n+    private final ConcurrentMap<MultipartKey, String> cDateTimeInstanceCache \n+        = new ConcurrentHashMap<MultipartKey, String>(7);\n+\n+    /**\n+     * <p>Gets a formatter instance using the default pattern in the\n+     * default timezone and locale.</p>\n+     * \n+     * @return a date/time formatter\n+     */\n+    public F getInstance() {\n+        return getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, TimeZone.getDefault(), Locale.getDefault());\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern, time zone\n+     * and locale.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param timeZone  the non-null time zone\n+     * @param locale  the non-null locale\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     *  or <code>null</code>\n+     */\n+    public F getInstance(String pattern, TimeZone timeZone, Locale locale) {\n+        if (pattern == null) {\n+            throw new NullPointerException(\"pattern must not be null\");\n+        }\n+        if (timeZone == null) {\n+            timeZone = TimeZone.getDefault();\n+        }\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        MultipartKey key = new MultipartKey(pattern, timeZone, locale);\n+        F format = cInstanceCache.get(key);\n+        if (format == null) {           \n+            format = createInstance(pattern, timeZone, locale);\n+            F previousValue= cInstanceCache.putIfAbsent(key, format);\n+            if (previousValue != null) {\n+                // another thread snuck in and did the same work\n+                // we should return the instance that is in ConcurrentMap\n+                format= previousValue;              \n+            }\n+        }\n+        return format;\n+    }\n+    \n+    /**\n+     * <p>Create a format instance using the specified pattern, time zone\n+     * and locale.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern, this will not be null.\n+     * @param timeZone  time zone, this will not be null.\n+     * @param locale  locale, this will not be null.\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     *  or <code>null</code>\n+     */\n+    abstract protected F createInstance(String pattern, TimeZone timeZone, Locale locale);\n+        \n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style,\n+     * time zone and locale.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     */\n+    public F getDateTimeInstance(Integer dateStyle, Integer timeStyle, TimeZone timeZone, Locale locale) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n+\n+        String pattern = cDateTimeInstanceCache.get(key);\n+        if (pattern == null) {\n+            try {\n+                DateFormat formatter;\n+                if (dateStyle == null) {\n+                    formatter = DateFormat.getTimeInstance(timeStyle, locale);                    \n+                }\n+                else if (timeStyle == null) {\n+                    formatter = DateFormat.getDateInstance(dateStyle, locale);                    \n+                }\n+                else {\n+                    formatter = DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);\n+                }\n+                pattern = ((SimpleDateFormat)formatter).toPattern();\n+                String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n+                if (previous != null) {\n+                    // even though it doesn't matter if another thread put the pattern\n+                    // it's still good practice to return the String instance that is\n+                    // actually in the ConcurrentMap\n+                    pattern= previous;\n+                }\n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n+            }\n+        }\n+        \n+        return getInstance(pattern, timeZone, locale);\n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Helper class to hold multi-part Map keys</p>\n+     */\n+    private static class MultipartKey {\n+        private final Object[] keys;\n+        private int hashCode;\n+\n+        /**\n+         * Constructs an instance of <code>MultipartKey</code> to hold the specified objects.\n+         * @param keys the set of objects that make up the key.  Each key may be null.\n+         */\n+        public MultipartKey(Object... keys) {\n+            this.keys = keys;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if ( obj instanceof MultipartKey == false ) {\n+                return false;\n+            }\n+            return Arrays.equals(keys, ((MultipartKey)obj).keys);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int hashCode() {\n+            if(hashCode==0) {\n+                int rc= 0;\n+                for(Object key : keys) {\n+                    if(key!=null) {\n+                        rc= rc*7 + key.hashCode();\n+                    }\n+                }\n+                hashCode= rc;\n+            }\n+            return hashCode;\n+        }\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n         assertEquals(\"MM/DD/yyyy\", format1.getPattern());\n         assertEquals(TimeZone.getDefault(), format1.getTimeZone());\n         assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n-        assertEquals(false, format1.getTimeZoneOverridesCalendar());\n-        assertEquals(false, format2.getTimeZoneOverridesCalendar());\n     }\n \n     public void test_getInstance_String_TimeZone() {\n \n             assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n             assertEquals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n-            assertEquals(true, format1.getTimeZoneOverridesCalendar());\n             assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n-            assertEquals(false, format2.getTimeZoneOverridesCalendar());\n             assertSame(format3, format4);\n             assertTrue(format3 != format5); // -- junit 3.8 version -- assertFalse(format3 == format5);\n             assertTrue(format4 != format6); // -- junit 3.8 version -- assertFalse(format3 == format5);\n             assertEquals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n             assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n             assertEquals(TimeZone.getDefault(), format3.getTimeZone());\n-            assertEquals(true, format1.getTimeZoneOverridesCalendar());\n-            assertEquals(false, format2.getTimeZoneOverridesCalendar());\n-            assertEquals(true, format3.getTimeZoneOverridesCalendar());\n             assertEquals(Locale.GERMANY, format1.getLocale());\n             assertEquals(Locale.GERMANY, format2.getLocale());\n             assertEquals(Locale.GERMANY, format3.getLocale());\n         try {\n             Locale.setDefault(Locale.US);\n             TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n-            FastDateFormat fdf = null;\n-            SimpleDateFormat sdf = null;\n \n             GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n             GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);\n             long millis1 = date1.getTime();\n             long millis2 = date2.getTime();\n \n-            fdf = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n-            sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n+            FastDateFormat fdf = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n+            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n             assertEquals(sdf.format(date1), fdf.format(date1));\n             assertEquals(\"2003-01-10T15:33:20\", fdf.format(date1));\n             assertEquals(\"2003-01-10T15:33:20\", fdf.format(cal1));\n             assertEquals(\"-0500\", fdf.format(cal1));\n             assertEquals(\"-0500\", fdf.format(millis1));\n \n-            fdf = FastDateFormat.getInstance(\"Z\");\n             assertEquals(\"-0400\", fdf.format(date2));\n             assertEquals(\"-0400\", fdf.format(cal2));\n             assertEquals(\"-0400\", fdf.format(millis2));\n             assertEquals(\"-05:00\", fdf.format(cal1));\n             assertEquals(\"-05:00\", fdf.format(millis1));\n \n-            fdf = FastDateFormat.getInstance(\"ZZ\");\n             assertEquals(\"-04:00\", fdf.format(date2));\n             assertEquals(\"-04:00\", fdf.format(cal2));\n             assertEquals(\"-04:00\", fdf.format(millis2));\n             fdf = FastDateFormat.getInstance(pattern);\n             sdf = new SimpleDateFormat(pattern);\n             assertEquals(sdf.format(date1), fdf.format(date1));\n-            assertEquals(sdf.format(date2), fdf.format(date2));\n-\n+            assertEquals(sdf.format(date2), fdf.format(date2));            \n         } finally {\n             Locale.setDefault(realDefaultLocale);\n             TimeZone.setDefault(realDefaultZone);\n         }\n     }\n-\n+    \n     /**\n      * Test case for {@link FastDateFormat#getDateInstance(int, java.util.Locale)}.\n      */\n      * testLowYearPadding showed that the date was buggy\n      * This test confirms it, getting 366 back as a date\n      */\n-     // TODO: Fix this problem\n     public void testSimpleDate() {\n         Calendar cal = Calendar.getInstance();\n         FastDateFormat format = FastDateFormat.getInstance(\"yyyy/MM/dd\");\n     }\n \n     public void testLang538() {\n-        final String dateTime = \"2009-10-16T16:42:16.000Z\";\n-\n         // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n         // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n         GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n         cal.set(2009, 9, 16, 8, 42, 16);\n \n         FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n-        assertEquals(\"dateTime\", dateTime, format.format(cal));\n+        assertEquals(\"dateTime\", \"2009-10-16T16:42:16.000Z\", format.format(cal.getTime()));\n+        assertEquals(\"dateTime\", \"2009-10-16T08:42:16.000Z\", format.format(cal));\n     }\n \n     public void testLang645() {", "timestamp": 1303282276, "metainfo": ""}