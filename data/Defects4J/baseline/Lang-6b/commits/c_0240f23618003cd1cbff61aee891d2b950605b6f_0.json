{"sha": "0240f23618003cd1cbff61aee891d2b950605b6f", "log": "Moving indexOf(String, int) and indexOf(String, int, int) over to CharSequence. LANG-687. This, plus the same happening for the String, String, int variant will open up a lot of methods.   ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n     // IndexOf\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Finds the first index within a String, handling {@code null}.\n-     * This method uses {@link String#indexOf(int)}.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") String will return {@code INDEX_NOT_FOUND (-1)}.</p>\n+     * <p>Finds the first index within a CharSequence, handling {@code null}.\n+     * This method uses {@link String#indexOf(int, int)} if possible.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") CharSequence will return {@code INDEX_NOT_FOUND (-1)}.</p>\n      *\n      * <pre>\n      * StringUtils.indexOf(null, *)         = -1\n      * StringUtils.indexOf(\"aabaabaa\", 'b') = 2\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param seq  the CharSequence to check, may be null\n      * @param searchChar  the character to find\n      * @return the first index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int indexOf(String str, int searchChar) {\n-        if (isEmpty(str)) {\n+    public static int indexOf(CharSequence seq, int searchChar) {\n+        if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.indexOf(searchChar);\n-    }\n-\n-    /**\n-     * <p>Finds the first index within a String from a start position,\n+        return StringUtils.indexOfSequence(seq, searchChar, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a CharSequence from a start position,\n      * handling {@code null}.\n-     * This method uses {@link String#indexOf(int, int)}.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") String will return {@code (INDEX_NOT_FOUND) -1}.\n+     * This method uses {@link String#indexOf(int, int)} if possible.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") CharSequence will return {@code (INDEX_NOT_FOUND) -1}.\n      * A negative start position is treated as zero.\n      * A start position greater than the string length returns {@code -1}.</p>\n      *\n      * StringUtils.indexOf(\"aabaabaa\", 'b', -1) = 2\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param seq  the CharSequence to check, may be null\n      * @param searchChar  the character to find\n      * @param startPos  the start position, negative treated as zero\n      * @return the first index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int indexOf(String str, int searchChar, int startPos) {\n-        if (isEmpty(str)) {\n+    public static int indexOf(CharSequence seq, int searchChar, int startPos) {\n+        if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.indexOf(searchChar, startPos);\n+        return StringUtils.indexOfSequence(seq, searchChar, startPos);\n     }\n \n     /**\n         return cs == null ? null : cs.subSequence(start, cs.length());\n     }\n \n+    // Used by the indexOf(CharSequence methods) as a green implementation of indexOf\n+    static int indexOfSequence(CharSequence cs, int searchChar, int start) {\n+        if (cs instanceof String) {\n+            return ((String) cs).indexOf(searchChar, start);\n+        } else {\n+            int sz = cs.length();\n+            if ( start < 0 ) {\n+                start = 0;\n+            }\n+            for ( int i=start; i < sz; i++ ) {\n+                if ( cs.charAt(i) == searchChar) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+    }\n+    // Used by the indexOf(CharSequence methods) as a green implementation of indexOf\n+    static int indexOfSequence(CharSequence cs, CharSequence searchChar, int start) {\n+        if (cs instanceof String && searchChar instanceof String) {\n+            // TODO: Do we assume searchChar is usually relatively small; \n+            //       If so then calling toString() on it is better than reverting to \n+            //       the green implementation in the else block\n+            return ((String) cs).indexOf( (String) searchChar, start);\n+        } else {\n+            // TODO: Implement rather than convert to String\n+            return cs.toString().indexOf(searchChar.toString(), start);\n+        }\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n         assertEquals(-1, StringUtils.indexOf(\"\", ' '));\n         assertEquals(0, StringUtils.indexOf(\"aabaabaa\", 'a'));\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b'));\n+\n+        assertEquals(2, StringUtils.indexOf(new StringBuilder(\"aabaabaa\"), 'b'));\n     }\n \n     public void testIndexOf_charInt() {\n         assertEquals(5, StringUtils.indexOf(\"aabaabaa\", 'b', 3));\n         assertEquals(-1, StringUtils.indexOf(\"aabaabaa\", 'b', 9));\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b', -1));\n+\n+        assertEquals(5, StringUtils.indexOf(new StringBuilder(\"aabaabaa\"), 'b', 3));\n     }\n \n     public void testIndexOf_String() {", "timestamp": 1300255892, "metainfo": ""}