{"sha": "675f93fa3d0bbc0be914d307eb54a9273f413940", "log": "[LANG-762] Handle or document ReflectionToStringBuilder and ToStringBuilder for collections that are not thread safe. Better Javadocs. See Phil's comments in the Jira.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java\n  * <p>\n  * Assists in implementing {@link Object#toString()} methods using reflection.\n  * </p>\n- *\n  * <p>\n  * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\n  * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\n  * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\n  * set up correctly.\n  * </p>\n- *\n+ * <p>\n+ * Using reflection to access (private) fields circumvents any synchronization protection guarding access to these\n+ * fields. If a toString method cannot safely read a field, you should exclude it from the toString method, or use\n+ * synchronization consistent with the class' lock management around the invocation of the method. Take special care to\n+ * exclude non-thread-safe collection classes, because these classes may throw ConcurrentModificationException if\n+ * modified while the toString method is executing.\n+ * </p>\n  * <p>\n  * A typical invocation for this method would look like:\n  * </p>\n- *\n  * <pre>\n  * public String toString() {\n- *   return ReflectionToStringBuilder.toString(this);\n- * }</pre>\n- *\n- *\n- *\n+ *     return ReflectionToStringBuilder.toString(this);\n+ * }\n+ * </pre>\n  * <p>\n  * You can also use the builder to debug 3rd party objects:\n  * </p>\n- *\n  * <pre>\n- * System.out.println(\"An object: \" + ReflectionToStringBuilder.toString(anObject));</pre>\n- *\n- *\n- *\n+ * System.out.println(&quot;An object: &quot; + ReflectionToStringBuilder.toString(anObject));\n+ * </pre>\n  * <p>\n  * A subclass can control field output by overriding the methods:\n  * <ul>\n  * </ul>\n  * </p>\n  * <p>\n- * For example, this method does <i>not</i> include the <code>password</code> field in the returned\n- * <code>String</code>:\n- * </p>\n- *\n+ * For example, this method does <i>not</i> include the <code>password</code> field in the returned <code>String</code>:\n+ * </p>\n  * <pre>\n  * public String toString() {\n  *     return (new ReflectionToStringBuilder(this) {\n  *         protected boolean accept(Field f) {\n- *             return super.accept(f) && !f.getName().equals(\"password\");\n+ *             return super.accept(f) &amp;&amp; !f.getName().equals(&quot;password&quot;);\n  *         }\n  *     }).toString();\n- * }</pre>\n- *\n- *\n- *\n- * <p>\n- * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the\n- * constructor.\n- * </p>\n- *\n+ * }\n+ * </pre>\n+ * <p>\n+ * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the constructor.\n+ * </p>\n+ * \n  * @since 2.0\n  * @version $Id$\n  */", "timestamp": 1320905673, "metainfo": ""}