{"sha": "2c60f024aa4742d633d25cfa5dcdd590bdb9d059", "log": "Code clean-up for CheckStyle.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/Conversion.java\n+++ b/src/main/java/org/apache/commons/lang3/Conversion.java\n package org.apache.commons.lang3;\n \n import java.util.UUID;\n+\n \n /**\n  * <p>\n      */\n     public static int hexDigitToInt(char hexDigit) {\n         final int digit = Character.digit(hexDigit, 16);\n-        if (digit < 0) { \n+        if (digit < 0) {\n             throw new IllegalArgumentException(\"Cannot interpret '\"\n                 + hexDigit\n                 + \"' as a hexadecimal digit\");\n      * \n      * @param src the boolean array to convert\n      * @return a hexadecimal digit representing the selected bits\n-     * @throws IllegalArgumentException if {@code src} is empty \n-     * @throws NullPointerException  if {@code src} is {@code null}\n+     * @throws IllegalArgumentException if {@code src} is empty\n+     * @throws NullPointerException if {@code src} is {@code null}\n      */\n     public static char boolsToHexDigit(boolean[] src) {\n         return boolsToHexDigit(src, 0);\n      * @param src the boolean array to convert\n      * @param srcPos the position of the lsb to start the conversion\n      * @return a hexadecimal digit representing the selected bits\n-     * @throws IllegalArgumentException if {@code src} is empty \n-     * @throws NullPointerException  if {@code src} is {@code null}\n+     * @throws IllegalArgumentException if {@code src} is empty\n+     * @throws NullPointerException if {@code src} is {@code null}\n      */\n     public static char boolsToHexDigit(boolean[] src, int srcPos) {\n-        if (src.length == 0)\n+        if (src.length == 0) {\n             throw new IllegalArgumentException(\"Cannot convert empty array.\");\n+        }\n         if (src.length > srcPos + 3 && src[srcPos + 3]) {\n             if (src.length > srcPos + 2 && src[srcPos + 2]) {\n                 if (src.length > srcPos + 1 && src[srcPos + 1]) {\n-                    if (src[srcPos]) return 'f';\n-                    else return 'e';\n+                    if (src[srcPos]) {\n+                        return 'f';\n+                    } else {\n+                        return 'e';\n+                    }\n                 } else {\n-                    if (src[srcPos]) return 'd';\n-                    else return 'c';\n+                    if (src[srcPos]) {\n+                        return 'd';\n+                    } else {\n+                        return 'c';\n+                    }\n                 }\n             } else {\n                 if (src.length > srcPos + 1 && src[srcPos + 1]) {\n-                    if (src[srcPos]) return 'b';\n-                    else return 'a';\n+                    if (src[srcPos]) {\n+                        return 'b';\n+                    } else {\n+                        return 'a';\n+                    }\n                 } else {\n-                    if (src[srcPos]) return '9';\n-                    else return '8';\n+                    if (src[srcPos]) {\n+                        return '9';\n+                    } else {\n+                        return '8';\n+                    }\n                 }\n             }\n         } else {\n             if (src.length > srcPos + 2 && src[srcPos + 2]) {\n                 if (src.length > srcPos + 1 && src[srcPos + 1]) {\n-                    if (src[srcPos]) return '7';\n-                    else return '6';\n+                    if (src[srcPos]) {\n+                        return '7';\n+                    } else {\n+                        return '6';\n+                    }\n                 } else {\n-                    if (src[srcPos]) return '5';\n-                    else return '4';\n+                    if (src[srcPos]) {\n+                        return '5';\n+                    } else {\n+                        return '4';\n+                    }\n                 }\n             } else {\n                 if (src.length > srcPos + 1 && src[srcPos + 1]) {\n-                    if (src[srcPos]) return '3';\n-                    else return '2';\n+                    if (src[srcPos]) {\n+                        return '3';\n+                    } else {\n+                        return '2';\n+                    }\n                 } else {\n-                    if (src[srcPos]) return '1';\n-                    else return '0';\n+                    if (src[srcPos]) {\n+                        return '1';\n+                    } else {\n+                        return '0';\n+                    }\n                 }\n             }\n         }\n      * \n      * @param src the boolean array to convert\n      * @return a hexadecimal digit representing the selected bits\n-     * @throws IllegalArgumentException if {@code src} is empty, {@code src.length < 4} or {@code src.length > 8} \n-     * @throws NullPointerException  if {@code src} is {@code null}\n+     * @throws IllegalArgumentException if {@code src} is empty, {@code src.length < 4} or\n+     *             {@code src.length > 8}\n+     * @throws NullPointerException if {@code src} is {@code null}\n      */\n     public static char boolsToHexDigitM0_4bits(boolean[] src) {\n         return boolsToHexDigitM0_4bits(src, 0);\n      * @param src the boolean array to convert\n      * @param srcPos the position of the lsb to start the conversion\n      * @return a hexadecimal digit representing the selected bits\n-     * @throws IllegalArgumentException if {@code src} is empty, {@code src.length > 8} or {@code src.length - srcPos < 4}  \n-     * @throws NullPointerException  if {@code src} is {@code null}\n+     * @throws IllegalArgumentException if {@code src} is empty, {@code src.length > 8} or\n+     *             {@code src.length - srcPos < 4}\n+     * @throws NullPointerException if {@code src} is {@code null}\n      */\n     public static char boolsToHexDigitM0_4bits(boolean[] src, int srcPos) {\n-        if (src.length > 8)\n+        if (src.length > 8) {\n             throw new IllegalArgumentException(\"src.length>8: src.length=\" + src.length);\n-        if (src.length - srcPos < 4)\n+        }\n+        if (src.length - srcPos < 4) {\n             throw new IllegalArgumentException(\"src.length-srcPos<4: src.length=\"\n                 + src.length\n                 + \", srcPos=\"\n                 + srcPos);\n+        }\n         if (src[srcPos + 3]) {\n             if (src[srcPos + 2]) {\n                 if (src[srcPos + 1]) {\n-                    if (src[srcPos]) return 'f';\n-                    else return '7';\n+                    if (src[srcPos]) {\n+                        return 'f';\n+                    } else {\n+                        return '7';\n+                    }\n                 } else {\n-                    if (src[srcPos]) return 'b';\n-                    else return '3';\n+                    if (src[srcPos]) {\n+                        return 'b';\n+                    } else {\n+                        return '3';\n+                    }\n                 }\n             } else {\n                 if (src[srcPos + 1]) {\n-                    if (src[srcPos]) return 'd';\n-                    else return '5';\n+                    if (src[srcPos]) {\n+                        return 'd';\n+                    } else {\n+                        return '5';\n+                    }\n                 } else {\n-                    if (src[srcPos]) return '9';\n-                    else return '1';\n+                    if (src[srcPos]) {\n+                        return '9';\n+                    } else {\n+                        return '1';\n+                    }\n                 }\n             }\n         } else {\n             if (src[srcPos + 2]) {\n                 if (src[srcPos + 1]) {\n-                    if (src[srcPos]) return 'e';\n-                    else return '6';\n+                    if (src[srcPos]) {\n+                        return 'e';\n+                    } else {\n+                        return '6';\n+                    }\n                 } else {\n-                    if (src[srcPos]) return 'a';\n-                    else return '2';\n+                    if (src[srcPos]) {\n+                        return 'a';\n+                    } else {\n+                        return '2';\n+                    }\n                 }\n             } else {\n                 if (src[srcPos + 1]) {\n-                    if (src[srcPos]) return 'c';\n-                    else return '4';\n+                    if (src[srcPos]) {\n+                        return 'c';\n+                    } else {\n+                        return '4';\n+                    }\n                 } else {\n-                    if (src[srcPos]) return '8';\n-                    else return '0';\n+                    if (src[srcPos]) {\n+                        return '8';\n+                    } else {\n+                        return '0';\n+                    }\n                 }\n             }\n         }\n      * @param src the boolean array to convert\n      * @return a hexadecimal digit representing the selected bits\n      * @throws IllegalArgumentException if {@code src} is empty\n-     * @throws NullPointerException  if {@code src} is {@code null}\n+     * @throws NullPointerException if {@code src} is {@code null}\n      */\n     public static char boolsBeM0ToHexDigit(boolean[] src) {\n         return boolsBeM0ToHexDigit(src, 0);\n      * @param srcPos the position of the lsb to start the conversion\n      * @return a hexadecimal digit representing the selected bits\n      * @throws IllegalArgumentException if {@code src} is empty\n-     * @throws NullPointerException  if {@code src} is {@code null}\n+     * @throws NullPointerException if {@code src} is {@code null}\n      */\n     public static char boolsBeM0ToHexDigit(boolean[] src, int srcPos) {\n-        if (src.length == 0)\n+        if (src.length == 0) {\n             throw new IllegalArgumentException(\"Cannot convert empty array.\");\n+        }\n         int beSrcPos = src.length - 1 - srcPos;\n         int srcLen = Math.min(4, beSrcPos + 1);\n         boolean[] paddedSrc = new boolean[4];\n         if (src[srcPos]) {\n             if (src.length > srcPos + 1 && src[srcPos + 1]) {\n                 if (src.length > srcPos + 2 && src[srcPos + 2]) {\n-                    if (src.length > srcPos + 3 && src[srcPos + 3]) return 'f';\n-                    else return 'e';\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) {\n+                        return 'f';\n+                    } else {\n+                        return 'e';\n+                    }\n                 } else {\n-                    if (src.length > srcPos + 3 && src[srcPos + 3]) return 'd';\n-                    else return 'c';\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) {\n+                        return 'd';\n+                    } else {\n+                        return 'c';\n+                    }\n                 }\n             } else {\n                 if (src.length > srcPos + 2 && src[srcPos + 2]) {\n-                    if (src.length > srcPos + 3 && src[srcPos + 3]) return 'b';\n-                    else return 'a';\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) {\n+                        return 'b';\n+                    } else {\n+                        return 'a';\n+                    }\n                 } else {\n-                    if (src.length > srcPos + 3 && src[srcPos + 3]) return '9';\n-                    else return '8';\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) {\n+                        return '9';\n+                    } else {\n+                        return '8';\n+                    }\n                 }\n             }\n         } else {\n             if (src.length > srcPos + 1 && src[srcPos + 1]) {\n                 if (src.length > srcPos + 2 && src[srcPos + 2]) {\n-                    if (src.length > srcPos + 3 && src[srcPos + 3]) return '7';\n-                    else return '6';\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) {\n+                        return '7';\n+                    } else {\n+                        return '6';\n+                    }\n                 } else {\n-                    if (src.length > srcPos + 3 && src[srcPos + 3]) return '5';\n-                    else return '4';\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) {\n+                        return '5';\n+                    } else {\n+                        return '4';\n+                    }\n                 }\n             } else {\n                 if (src.length > srcPos + 2 && src[srcPos + 2]) {\n-                    if (src.length > srcPos + 3 && src[srcPos + 3]) return '3';\n-                    else return '2';\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) {\n+                        return '3';\n+                    } else {\n+                        return '2';\n+                    }\n                 } else {\n-                    if (src.length > srcPos + 3 && src[srcPos + 3]) return '1';\n-                    else return '0';\n+                    if (src.length > srcPos + 3 && src[srcPos + 3]) {\n+                        return '1';\n+                    } else {\n+                        return '0';\n+                    }\n                 }\n             }\n         }\n      * \n      * @param nibble the int to convert\n      * @return a hexadecimal digit representing the 4 lsb of {@code nibble}\n-     * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}   \n+     * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}\n      */\n     public static char intToHexDigit(int nibble) {\n         char c = Character.forDigit(nibble, 16);\n-        if (c == Character.MIN_VALUE)\n+        if (c == Character.MIN_VALUE) {\n             throw new IllegalArgumentException(\"nibble value not between 0 and 15: \" + nibble);\n+        }\n         return c;\n     }\n \n      * \n      * @param nibble the int to convert\n      * @return a hexadecimal digit representing the 4 lsb of {@code nibble}\n-     * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}   \n+     * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}\n      */\n     public static char intToHexDigitM0(int nibble) {\n         switch (nibble) {\n      * @param dstPos the position of the lsb, in bits, in the result long\n      * @param nInts the number of ints to convert\n      * @return a long containing the selected bits\n-     * @throws IllegalArgumentException if {@code (nInts-1)*32+dstPos >= 64}   \n+     * @throws IllegalArgumentException if {@code (nInts-1)*32+dstPos >= 64}\n      */\n     public static long intsToLong(int[] src, int srcPos, long dstInit, int dstPos, int nInts) {\n-        if (0 == nInts)\n-            return dstInit;\n-        if ((nInts-1)*32+dstPos >= 64)\n+        if (0 == nInts) {\n+            return dstInit;\n+        }\n+        if ((nInts - 1) * 32 + dstPos >= 64) {\n             throw new IllegalArgumentException(\n                 \"(nInts-1)*32+dstPos is greather or equal to than 64\");\n+        }\n         long out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nInts; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result long\n      * @param nShorts the number of shorts to convert\n      * @return a long containing the selected bits\n-     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 64}   \n+     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 64}\n      */\n     public static long shortsToLong(short[] src, int srcPos, long dstInit, int dstPos,\n         int nShorts) {\n-        if (0 == nShorts) \n-            return dstInit;\n-        if ((nShorts-1)*16+dstPos >= 64)\n+        if (0 == nShorts) {\n+            return dstInit;\n+        }\n+        if ((nShorts - 1) * 16 + dstPos >= 64) {\n             throw new IllegalArgumentException(\n                 \"(nShorts-1)*16+dstPos is greather or equal to than 64\");\n+        }\n         long out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nShorts; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result int\n      * @param nShorts the number of shorts to convert\n      * @return a int containing the selected bits\n-     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 32}   \n+     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 32}\n      */\n     public static int shortsToInt(short[] src, int srcPos, int dstInit, int dstPos, int nShorts) {\n-        if (0 == nShorts) \n-            return dstInit;\n-        if ((nShorts-1)*16+dstPos >= 32)\n+        if (0 == nShorts) {\n+            return dstInit;\n+        }\n+        if ((nShorts - 1) * 16 + dstPos >= 32) {\n             throw new IllegalArgumentException(\n                 \"(nShorts-1)*16+dstPos is greather or equal to than 32\");\n+        }\n         int out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nShorts; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result long\n      * @param nBytes the number of bytes to convert\n      * @return a long containing the selected bits\n-     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 64}   \n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 64}\n      */\n     public static long bytesToLong(byte[] src, int srcPos, long dstInit, int dstPos, int nBytes) {\n-        if (0 == nBytes) \n-            return dstInit;\n-        if ((nBytes-1)*8+dstPos >= 64)\n+        if (0 == nBytes) {\n+            return dstInit;\n+        }\n+        if ((nBytes - 1) * 8 + dstPos >= 64) {\n             throw new IllegalArgumentException(\n                 \"(nBytes-1)*8+dstPos is greather or equal to than 64\");\n+        }\n         long out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result int\n      * @param nBytes the number of bytes to convert\n      * @return a int containing the selected bits\n-     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 32}   \n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 32}\n      */\n     public static int bytesToInt(byte[] src, int srcPos, int dstInit, int dstPos, int nBytes) {\n-        if (0 == nBytes) \n-            return dstInit;\n-        if ((nBytes-1)*8+dstPos >= 32)\n+        if (0 == nBytes) {\n+            return dstInit;\n+        }\n+        if ((nBytes - 1) * 8 + dstPos >= 32) {\n             throw new IllegalArgumentException(\n                 \"(nBytes-1)*8+dstPos is greather or equal to than 32\");\n+        }\n         int out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result short\n      * @param nBytes the number of bytes to convert\n      * @return a short containing the selected bits\n-     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 16}   \n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 16}\n      */\n     public static short bytesToShort(byte[] src, int srcPos, short dstInit, int dstPos,\n         int nBytes) {\n-        if (0 == nBytes) \n-            return dstInit;\n-        if ((nBytes-1)*8+dstPos >= 16)\n+        if (0 == nBytes) {\n+            return dstInit;\n+        }\n+        if ((nBytes - 1) * 8 + dstPos >= 16) {\n             throw new IllegalArgumentException(\n                 \"(nBytes-1)*8+dstPos is greather or equal to than 16\");\n+        }\n         short out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result long\n      * @param nHexs the number of Chars to convert\n      * @return a long containing the selected bits\n-     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 64}   \n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 64}\n      */\n     public static long hexsToLong(String src, int srcPos, long dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs)\n-            return dstInit;\n-        if ((nHexs-1)*4+dstPos >= 64)\n+        if (0 == nHexs) {\n+            return dstInit;\n+        }\n+        if ((nHexs - 1) * 4 + dstPos >= 64) {\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+dstPos is greather or equal to than 64\");\n+        }\n         long out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result int\n      * @param nHexs the number of Chars to convert\n      * @return a int containing the selected bits\n-     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 32}   \n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 32}\n      */\n     public static int hexsToInt(String src, int srcPos, int dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs) \n-            return dstInit;\n-        if ((nHexs-1)*4+dstPos >= 32)\n+        if (0 == nHexs) {\n+            return dstInit;\n+        }\n+        if ((nHexs - 1) * 4 + dstPos >= 32) {\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+dstPos is greather or equal to than 32\");\n+        }\n         int out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result short\n      * @param nHexs the number of Chars to convert\n      * @return a short containing the selected bits\n-     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 16}   \n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 16}\n      */\n     public static short hexsToShort(String src, int srcPos, short dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs) \n-            return dstInit;\n-        if ((nHexs-1)*4+dstPos >= 16)\n+        if (0 == nHexs) {\n+            return dstInit;\n+        }\n+        if ((nHexs - 1) * 4 + dstPos >= 16) {\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+dstPos is greather or equal to than 16\");\n+        }\n         short out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result byte\n      * @param nHexs the number of Chars to convert\n      * @return a byte containing the selected bits\n-     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 8}   \n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 8}\n      */\n     public static byte hexsToByte(String src, int srcPos, byte dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs) \n-            return dstInit;\n-        if ((nHexs-1)*4+dstPos >= 8)\n+        if (0 == nHexs) {\n+            return dstInit;\n+        }\n+        if ((nHexs - 1) * 4 + dstPos >= 8) {\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+dstPos is greather or equal to than 8\");\n+        }\n         byte out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result long\n      * @param nBools the number of booleans to convert\n      * @return a long containing the selected bits\n-     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 64}   \n+     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 64}\n      */\n     public static long boolsToLong(boolean[] src, int srcPos, long dstInit, int dstPos,\n         int nBools) {\n-        if (0 == nBools) \n-            return dstInit;\n-        if (nBools-1+dstPos >= 64)\n+        if (0 == nBools) {\n+            return dstInit;\n+        }\n+        if (nBools - 1 + dstPos >= 64) {\n             throw new IllegalArgumentException(\n                 \"nBools-1+dstPos is greather or equal to than 64\");\n+        }\n         long out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result int\n      * @param nBools the number of booleans to convert\n      * @return a int containing the selected bits\n-     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 32}   \n+     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 32}\n      */\n     public static int boolsToInt(boolean[] src, int srcPos, int dstInit, int dstPos, int nBools) {\n-        if (0 == nBools)\n-            return dstInit;\n-        if (nBools-1+dstPos >= 32)\n+        if (0 == nBools) {\n+            return dstInit;\n+        }\n+        if (nBools - 1 + dstPos >= 32) {\n             throw new IllegalArgumentException(\n                 \"nBools-1+dstPos is greather or equal to than 32\");\n+        }\n         int out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result short\n      * @param nBools the number of booleans to convert\n      * @return a short containing the selected bits\n-     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 16}   \n+     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 16}\n      */\n     public static short boolsToShort(boolean[] src, int srcPos, short dstInit, int dstPos,\n         int nBools) {\n-        if (0 == nBools)\n-            return dstInit;\n-        if (nBools-1+dstPos >= 16)\n+        if (0 == nBools) {\n+            return dstInit;\n+        }\n+        if (nBools - 1 + dstPos >= 16) {\n             throw new IllegalArgumentException(\n                 \"nBools-1+dstPos is greather or equal to than 16\");\n+        }\n         short out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n      * @param dstPos the position of the lsb, in bits, in the result byte\n      * @param nBools the number of booleans to convert\n      * @return a byte containing the selected bits\n-     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 8}   \n+     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 8}\n      */\n     public static byte boolsToByte(boolean[] src, int srcPos, byte dstInit, int dstPos,\n         int nBools) {\n-        if (0 == nBools)\n-            return dstInit;\n-        if (nBools-1+dstPos >= 8)\n-            throw new IllegalArgumentException(\n-                \"nBools-1+dstPos is greather or equal to than 8\");\n+        if (0 == nBools) {\n+            return dstInit;\n+        }\n+        if (nBools - 1 + dstPos >= 8) {\n+            throw new IllegalArgumentException(\"nBools-1+dstPos is greather or equal to than 8\");\n+        }\n         byte out = dstInit;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n      * </p>\n      * \n      * @param src the long to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nInts the number of ints to copy to {@code dst}, must be smaller or equal to\n-     *            the width of the input (from srcPos to msb)\n+     * @param nInts the number of ints to copy to {@code dst}, must be smaller or equal to the\n+     *            width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code (nInts-1)*32+srcPos >= 64}   \n+     * @throws IllegalArgumentException if {@code (nInts-1)*32+srcPos >= 64}\n      */\n     public static int[] longToInts(long src, int srcPos, int[] dst, int dstPos, int nInts) {\n-        if (0 == nInts)\n+        if (0 == nInts) {\n             return dst;\n-        if ((nInts - 1) * 32 + srcPos >= 64)\n+        }\n+        if ((nInts - 1) * 32 + srcPos >= 64) {\n             throw new IllegalArgumentException(\n                 \"(nInts-1)*32+srcPos is greather or equal to than 64\");\n+        }\n         int shift = 0;\n         for (int i = 0; i < nInts; i++ ) {\n             shift = i * 32 + srcPos;\n      * </p>\n      * \n      * @param src the long to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal\n-     *            to the width of the input (from srcPos to msb)\n+     * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 64}   \n+     * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 64}\n      */\n     public static short[] longToShorts(long src, int srcPos, short[] dst, int dstPos,\n         int nShorts) {\n-        if (0 == nShorts)\n+        if (0 == nShorts) {\n             return dst;\n-        if ((nShorts - 1) * 16 + srcPos >= 64)\n+        }\n+        if ((nShorts - 1) * 16 + srcPos >= 64) {\n             throw new IllegalArgumentException(\n                 \"(nShorts-1)*16+srcPos is greather or equal to than 64\");\n+        }\n         int shift = 0;\n         for (int i = 0; i < nShorts; i++ ) {\n             shift = i * 16 + srcPos;\n      * </p>\n      * \n      * @param src the int to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal\n-     *            to the width of the input (from srcPos to msb)\n+     * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 32}   \n+     * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 32}\n      */\n     public static short[] intToShorts(int src, int srcPos, short[] dst, int dstPos, int nShorts) {\n-        if (0 == nShorts) \n+        if (0 == nShorts) {\n             return dst;\n-        if ((nShorts - 1) * 16 + srcPos >= 32)\n+        }\n+        if ((nShorts - 1) * 16 + srcPos >= 32) {\n             throw new IllegalArgumentException(\n                 \"(nShorts-1)*16+srcPos is greather or equal to than 32\");\n+        }\n         int shift = 0;\n         for (int i = 0; i < nShorts; i++ ) {\n             shift = i * 16 + srcPos;\n      * </p>\n      * \n      * @param src the long to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to\n-     *            the width of the input (from srcPos to msb)\n+     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n+     *            width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 64}   \n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 64}\n      */\n     public static byte[] longToBytes(long src, int srcPos, byte[] dst, int dstPos, int nBytes) {\n-        if (0 == nBytes)\n+        if (0 == nBytes) {\n             return dst;\n-        if ((nBytes - 1) * 8 + srcPos >= 64)\n+        }\n+        if ((nBytes - 1) * 8 + srcPos >= 64) {\n             throw new IllegalArgumentException(\n                 \"(nBytes-1)*8+srcPos is greather or equal to than 64\");\n+        }\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             shift = i * 8 + srcPos;\n      * </p>\n      * \n      * @param src the int to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to\n-     *            the width of the input (from srcPos to msb)\n+     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n+     *            width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 32}   \n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 32}\n      */\n     public static byte[] intToBytes(int src, int srcPos, byte[] dst, int dstPos, int nBytes) {\n-        if (0 == nBytes)\n+        if (0 == nBytes) {\n             return dst;\n-        if ((nBytes - 1) * 8 + srcPos >= 32)\n+        }\n+        if ((nBytes - 1) * 8 + srcPos >= 32) {\n             throw new IllegalArgumentException(\n                 \"(nBytes-1)*8+srcPos is greather or equal to than 32\");\n+        }\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             shift = i * 8 + srcPos;\n      * </p>\n      * \n      * @param src the short to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to\n-     *            the width of the input (from srcPos to msb)\n+     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n+     *            width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 16}   \n+     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 16}\n      */\n     public static byte[] shortToBytes(short src, int srcPos, byte[] dst, int dstPos, int nBytes) {\n-        if (0 == nBytes)\n+        if (0 == nBytes) {\n             return dst;\n-        if ((nBytes - 1) * 8 + srcPos >= 16)\n+        }\n+        if ((nBytes - 1) * 8 + srcPos >= 16) {\n             throw new IllegalArgumentException(\n                 \"(nBytes-1)*8+srcPos is greather or equal to than 16\");\n+        }\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             shift = i * 8 + srcPos;\n      * </p>\n      * \n      * @param src the long to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dstInit the initial value for the result String\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to\n-     *            the width of the input (from srcPos to msb)\n+     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n+     *            width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 64}   \n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 64}\n      */\n     public static String longToHexs(long src, int srcPos, String dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs)\n-            return dstInit;\n-        if ((nHexs - 1) * 4 + srcPos >= 64)\n+        if (0 == nHexs) {\n+            return dstInit;\n+        }\n+        if ((nHexs - 1) * 4 + srcPos >= 64) {\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+srcPos is greather or equal to than 64\");\n+        }\n         StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n      * </p>\n      * \n      * @param src the int to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dstInit the initial value for the result String\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to\n-     *            the width of the input (from srcPos to msb)\n+     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n+     *            width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 32}   \n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 32}\n      */\n     public static String intToHexs(int src, int srcPos, String dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs)\n-            return dstInit;\n-        if ((nHexs - 1) * 4 + srcPos >= 32)\n+        if (0 == nHexs) {\n+            return dstInit;\n+        }\n+        if ((nHexs - 1) * 4 + srcPos >= 32) {\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+srcPos is greather or equal to than 32\");\n+        }\n         StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n      * </p>\n      * \n      * @param src the short to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dstInit the initial value for the result String\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to\n-     *            the width of the input (from srcPos to msb)\n+     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n+     *            width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 16}   \n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 16}\n      */\n     public static String shortToHexs(short src, int srcPos, String dstInit, int dstPos,\n         int nHexs) {\n-        if (0 == nHexs)\n-            return dstInit;\n-        if ((nHexs - 1) * 4 + srcPos >= 16)\n+        if (0 == nHexs) {\n+            return dstInit;\n+        }\n+        if ((nHexs - 1) * 4 + srcPos >= 16) {\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+srcPos is greather or equal to than 16\");\n+        }\n         StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n      * </p>\n      * \n      * @param src the byte to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dstInit the initial value for the result String\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to\n-     *            the width of the input (from srcPos to msb)\n+     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n+     *            width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 8}   \n+     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 8}\n      */\n     public static String byteToHexs(byte src, int srcPos, String dstInit, int dstPos, int nHexs) {\n-        if (0 == nHexs)\n-            return dstInit;\n-        if ((nHexs - 1) * 4 + srcPos >= 8)\n+        if (0 == nHexs) {\n+            return dstInit;\n+        }\n+        if ((nHexs - 1) * 4 + srcPos >= 8) {\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+srcPos is greather or equal to than 8\");\n+        }\n         StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n         for (int i = 0; i < nHexs; i++ ) {\n      * </p>\n      * \n      * @param src the long to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal\n-     *            to the width of the input (from srcPos to msb)\n+     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 64}   \n+     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 64}\n      */\n     public static boolean[] longToBools(long src, int srcPos, boolean[] dst, int dstPos,\n         int nBools) {\n-        if (0 == nBools)\n+        if (0 == nBools) {\n             return dst;\n-        if (nBools - 1 + srcPos >= 64)\n+        }\n+        if (nBools - 1 + srcPos >= 64) {\n             throw new IllegalArgumentException(\n                 \"nBools-1+srcPos is greather or equal to than 64\");\n+        }\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             shift = i * 1 + srcPos;\n      * </p>\n      * \n      * @param src the int to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal\n-     *            to the width of the input (from srcPos to msb)\n+     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 32}   \n+     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 32}\n      */\n     public static boolean[] intToBools(int src, int srcPos, boolean[] dst, int dstPos,\n         int nBools) {\n-        if (0 == nBools)\n+        if (0 == nBools) {\n             return dst;\n-        if (nBools - 1 + srcPos >= 32)\n+        }\n+        if (nBools - 1 + srcPos >= 32) {\n             throw new IllegalArgumentException(\n                 \"nBools-1+srcPos is greather or equal to than 32\");\n+        }\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             shift = i * 1 + srcPos;\n      * </p>\n      * \n      * @param src the short to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal\n-     *            to the width of the input (from srcPos to msb)\n+     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 16}   \n+     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 16}\n      */\n     public static boolean[] shortToBools(short src, int srcPos, boolean[] dst, int dstPos,\n         int nBools) {\n-        if (0 == nBools)\n+        if (0 == nBools) {\n             return dst;\n-        if (nBools - 1 + srcPos >= 16)\n+        }\n+        if (nBools - 1 + srcPos >= 16) {\n             throw new IllegalArgumentException(\n                 \"nBools-1+srcPos is greather or equal to than 16\");\n+        }\n         int shift = 0;\n         assert ((nBools - 1) * 1 < 16 - srcPos);\n         for (int i = 0; i < nBools; i++ ) {\n      * </p>\n      * \n      * @param src the byte to convert\n-     * @param srcPos the position in {@code src}, in bits, from where to start the\n-     *            conversion\n+     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal\n-     *            to the width of the input (from srcPos to msb)\n+     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 8}   \n+     * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 8}\n      */\n     public static boolean[] byteToBools(byte src, int srcPos, boolean[] dst, int dstPos,\n         int nBools) {\n-        if (0 == nBools)\n+        if (0 == nBools) {\n             return dst;\n-        if (nBools - 1 + srcPos >= 8)\n-            throw new IllegalArgumentException(\n-                \"nBools-1+srcPos is greather or equal to than 8\");\n+        }\n+        if (nBools - 1 + srcPos >= 8) {\n+            throw new IllegalArgumentException(\"nBools-1+srcPos is greather or equal to than 8\");\n+        }\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             shift = i * 1 + srcPos;\n \n     /**\n      * <p>\n-     * Converts UUID into an array of byte using the default (little endian, Lsb0) byte and\n-     * bit ordering.\n+     * Converts UUID into an array of byte using the default (little endian, Lsb0) byte and bit\n+     * ordering.\n      * </p>\n      * \n      * @param src the UUID to convert\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to\n-     *            the width of the input (from srcPos to msb)\n+     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n+     *            width of the input (from srcPos to msb)\n      * @return {@code dst}\n-     * @throws IllegalArgumentException if {@code nBytes > 16}   \n+     * @throws IllegalArgumentException if {@code nBytes > 16}\n      */\n     public static byte[] uuidToBytes(UUID src, byte[] dst, int dstPos, int nBytes) {\n-        if (0 == nBytes)\n+        if (0 == nBytes) {\n             return dst;\n-        if (nBytes > 16 )\n+        }\n+        if (nBytes > 16) {\n             throw new IllegalArgumentException(\"nBytes is greather than 16\");\n+        }\n         longToBytes(src.getMostSignificantBits(), 0, dst, dstPos, nBytes > 8 ? 8 : nBytes);\n-        if (nBytes >= 8)\n-            longToBytes(src.getLeastSignificantBits(), 0, dst, dstPos+8, nBytes-8);\n+        if (nBytes >= 8) {\n+            longToBytes(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8);\n+        }\n         return dst;\n     }\n \n     /**\n      * <p>\n-     * Converts bytes fomr an array into a UUID using the default (little endian, Lsb0) byte and\n+     * Converts bytes from an array into a UUID using the default (little endian, Lsb0) byte and\n      * bit ordering.\n      * </p>\n      * \n      * @param src the source byte array\n      * @param srcPos the position in {@code src} where to copy the result from\n      * @return a UUID\n-     * @throws IllegalArgumentException if array does not contain at least 16 bytes beginning with {@code srcPos}   \n+     * @throws IllegalArgumentException if array does not contain at least 16 bytes beginning\n+     *             with {@code srcPos}\n      */\n     public static UUID bytesToUuid(byte[] src, int srcPos) {\n-        if (src.length-srcPos < 16 )\n+        if (src.length - srcPos < 16) {\n             throw new IllegalArgumentException(\"Need at least 16 bytes for UUID\");\n-        return new UUID(bytesToLong(src, srcPos, 0, 0, 8), bytesToLong(src, srcPos+8, 0, 0, 8));\n+        }\n+        return new UUID(\n+            bytesToLong(src, srcPos, 0, 0, 8), bytesToLong(src, srcPos + 8, 0, 0, 8));\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/ConversionTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ConversionTest.java\n  *******************************************************************************/\n package org.apache.commons.lang3;\n \n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.fail;\n \n import java.util.UUID;\n     static String dbgPrint(boolean[] src) {\n         StringBuilder sb = new StringBuilder();\n         for (boolean e : src) {\n-            if (e) sb.append(\"1,\");\n-            else sb.append(\"0,\");\n+            if (e) {\n+                sb.append(\"1,\");\n+            } else {\n+                sb.append(\"0,\");\n+            }\n         }\n         String out = sb.toString();\n         return out.substring(0, out.length() - 1);", "timestamp": 1349284660, "metainfo": ""}