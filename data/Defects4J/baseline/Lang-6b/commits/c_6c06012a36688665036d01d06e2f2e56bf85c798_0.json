{"sha": "6c06012a36688665036d01d06e2f2e56bf85c798", "log": "LANG-839 ArrayUtils removeElements methods use unnecessary HashSet Eliminate conversion of BitSet to int[]  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n             }\n         }\n         @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n-        T[] result = (T[]) removeAll((Object)array, extractIndices(toRemove));\n+        T[] result = (T[]) removeAll(array, toRemove);\n         return result;\n     }\n \n                 toRemove.set(found++);\n             }\n         }\n-        return (byte[]) removeAll((Object)array, extractIndices(toRemove));\n+        return (byte[]) removeAll(array, toRemove);\n     }\n \n     /**\n                 toRemove.set(found++);\n             }\n         }\n-        return (short[]) removeAll((Object)array, extractIndices(toRemove));\n+        return (short[]) removeAll(array, toRemove);\n     }\n \n     /**\n                 toRemove.set(found++);\n             }\n         }\n-        return (int[]) removeAll((Object)array, extractIndices(toRemove));\n+        return (int[]) removeAll(array, toRemove);\n     }\n \n     /**\n                 toRemove.set(found++);\n             }\n         }\n-        return (char[]) removeAll((Object)array, extractIndices(toRemove));\n+        return (char[]) removeAll(array, toRemove);\n     }\n \n     /**\n                 toRemove.set(found++);\n             }\n         }\n-        return (long[]) removeAll((Object)array, extractIndices(toRemove));\n+        return (long[]) removeAll(array, toRemove);\n     }\n \n     /**\n                 toRemove.set(found++);\n             }\n         }\n-        return (float[]) removeAll((Object)array, extractIndices(toRemove));\n+        return (float[]) removeAll(array, toRemove);\n     }\n \n     /**\n                 toRemove.set(found++);\n             }\n         }\n-        return (double[]) removeAll((Object)array, extractIndices(toRemove));\n+        return (double[]) removeAll(array, toRemove);\n     }\n \n     /**\n                 toRemove.set(found++);\n             }\n         }\n-        return (boolean[]) removeAll((Object)array, extractIndices(toRemove));\n+        return (boolean[]) removeAll(array, toRemove);\n     }\n \n     /**\n     }\n \n     /**\n-     * Extract a set of BitSet indices into an int[].\n-     * @param coll Bitset\n-     * @return int[]\n-     */\n-    private static int[] extractIndices(BitSet coll) {\n-        int[] result = new int[coll.cardinality()];\n-        int i = 0;\n-        int j=0;\n-        while((j=coll.nextSetBit(j)) != -1) {\n-            result[i++] = j++;            \n+     * Removes multiple array elements specified by indices.\n+     * \n+     * @param array source\n+     * @param indices to remove\n+     * @return new array of same type minus elements specified by the set bits in {@code indices}\n+     * @since 3.2\n+     */\n+    // package protected for access by unit tests\n+    static Object removeAll(Object array, BitSet indices) {\n+        final int srcLength = ArrayUtils.getLength(array);\n+        // No need to check maxIndex here, because method only currently called from removeElements()\n+        // which guarantee to generate on;y valid bit entries.\n+//        final int maxIndex = indices.length();\n+//        if (maxIndex > srcLength) { \n+//            throw new IndexOutOfBoundsException(\"Index: \" + (maxIndex-1) + \", Length: \" + srcLength);\n+//        }\n+        final int removals = indices.cardinality(); // true bits are items to remove\n+        Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);\n+        int srcIndex=0;\n+        int destIndex=0;\n+        int count;\n+        int set;\n+        while((set = indices.nextSetBit(srcIndex)) != -1){\n+            count = set - srcIndex;\n+            if (count > 0) {\n+                System.arraycopy(array, srcIndex, result, destIndex, count);\n+                destIndex += count;\n+            }\n+            srcIndex = indices.nextClearBit(set);\n+        }\n+        count = srcLength - srcIndex;\n+        if (count > 0) {\n+            System.arraycopy(array, srcIndex, result, destIndex, count);            \n         }\n         return result;\n     }\n--- a/src/test/java/org/apache/commons/lang3/HashSetvBitSetTest.java\n+++ b/src/test/java/org/apache/commons/lang3/HashSetvBitSetTest.java\n  */\n package org.apache.commons.lang3;\n \n-import java.lang.reflect.Array;\n import java.util.BitSet;\n import java.util.HashSet;\n \n         int[] output = new int[0];\n         long start = System.nanoTime();\n         for(int i = 0; i < LOOPS2; i++){\n-            output = (int[]) removeAll(array, toRemove);            \n+            output = (int[]) ArrayUtils.removeAll(array, toRemove);            \n         }\n         long end = System.nanoTime();\n         Assert.assertEquals(array.length-toRemove.cardinality(), output.length);\n         return end - start;\n     }\n     \n-    /**\n-     * Removes multiple array elements specified by indices.\n-     * \n-     * @param array source\n-     * @param indices to remove\n-     * @return new array of same type minus elements specified by the set bits in {@code indices}\n-     * @since 3.2\n-     */\n-    // package protected for access by unit tests\n-    static Object removeAll(Object array, BitSet indices) {\n-        final int srcLength = ArrayUtils.getLength(array);\n-        final int maxIndex = indices.length();\n-        if (maxIndex > srcLength) { // TODO necessary? Can check this when creating the BitSit \n-            throw new IndexOutOfBoundsException(\"Index: \" + (maxIndex-1) + \", Length: \" + srcLength);\n-        }\n-        final int removals = indices.cardinality(); // true bits are items to remove\n-        Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);\n-        int srcIndex=0;\n-        int destIndex=0;\n-        int count;\n-        int set;\n-        while((set = indices.nextSetBit(srcIndex)) != -1){\n-            count = set - srcIndex;\n-            if (count > 0) {\n-                System.arraycopy(array, srcIndex, result, destIndex, count);\n-                destIndex += count;\n-            }\n-            srcIndex = indices.nextClearBit(set);\n-        }\n-        count = srcLength - srcIndex;\n-        if (count > 0) {\n-            System.arraycopy(array, srcIndex, result, destIndex, count);            \n-        }\n-        return result;\n-    }\n }", "timestamp": 1349797025, "metainfo": ""}