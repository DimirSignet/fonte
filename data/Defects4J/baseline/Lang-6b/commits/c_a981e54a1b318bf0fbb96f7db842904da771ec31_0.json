{"sha": "a981e54a1b318bf0fbb96f7db842904da771ec31", "log": "add serialization support to EventListenerSupport  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n \n package org.apache.commons.lang3.event;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n import java.lang.reflect.Array;\n import java.lang.reflect.InvocationHandler;\n import java.lang.reflect.Method;\n import java.lang.reflect.Proxy;\n+import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n \n  * }\n  * </pre></code>\n  *\n+ * Serializing an {@link EventListenerSupport} instance will result in any\n+ * non-{@link Serializable} listeners being silently dropped.\n+ *\n  * @param <L> the type of event listener that is supported by this proxy.\n  *\n  * @since 3.0\n  * @version $Id$\n  */\n-public class EventListenerSupport<L>\n+public class EventListenerSupport<L> implements Serializable\n {\n-    /**\n-    * The list used to hold the registered listeners. This list is \n-    * intentionally a thread-safe copy-on-write-array so that traversals over\n-    * the list of listeners will be atomic.\n-    */\n-    private final List<L> listeners = new CopyOnWriteArrayList<L>();\n-    \n+    /** Serialization version */\n+    private static final long serialVersionUID = 3593265990380473632L;\n+\n+    /**\n+     * The list used to hold the registered listeners. This list is \n+     * intentionally a thread-safe copy-on-write-array so that traversals over\n+     * the list of listeners will be atomic.\n+     */\n+    private List<L> listeners = new CopyOnWriteArrayList<L>();\n+\n     /**\n      * The proxy representing the collection of listeners. Calls to this proxy \n      * object will sent to all registered listeners.\n      */\n-    private final L proxy;\n+    private transient L proxy;\n \n     /**\n      * Empty typed array for #getListeners().\n      */\n-    private final L[] prototypeArray;\n+    private transient L[] prototypeArray;\n \n     /**\n      * Creates an EventListenerSupport object which supports the specified \n      */\n     public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader)\n     {\n+        this();\n         Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n         Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n-        Validate.isTrue(listenerInterface.isInterface(), \n-            \"Class {0} is not an interface\", \n-            listenerInterface.getName());\n-        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, \n-                new Class[]{listenerInterface},\n-                new ProxyInvocationHandler()));\n-        @SuppressWarnings(\"unchecked\")\n-        final L[] prototypeArray = (L[]) Array.newInstance(listenerInterface, 0);\n-        this.prototypeArray = prototypeArray;\n+        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\n+                listenerInterface.getName());\n+        initializeTransientFields(listenerInterface, classLoader);\n+    }\n+\n+    /**\n+     * Create a new EventListenerSupport instance.\n+     * Serialization-friendly constructor.\n+     */\n+    private EventListenerSupport() {\n     }\n \n     /**\n     }\n \n     /**\n+     * Create the proxy object.\n+     * @param listenerInterface\n+     * @param classLoader\n+     */\n+    private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\n+        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, \n+                new Class[]{listenerInterface},\n+                new ProxyInvocationHandler()));\n+    }\n+\n+    /**\n+     * Serialize.\n+     * @param objectOutputStream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {\n+        ArrayList<L> serializableListeners = new ArrayList<L>();\n+\n+        // don't just rely on instanceof Serializable:\n+        ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n+        for (L listener : listeners) {\n+            try {\n+                testObjectOutputStream.writeObject(listener);\n+                serializableListeners.add(listener);\n+            } catch (IOException exception) {\n+                //recreate test stream in case of indeterminate state\n+                testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n+            }\n+        }\n+        /*\n+         * we can reconstitute everything we need from an array of our listeners,\n+         * which has the additional advantage of typically requiring less storage than a list:\n+         */\n+        objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray));\n+    }\n+\n+    /**\n+     * Deserialize.\n+     * @param objectInputStream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n+        @SuppressWarnings(\"unchecked\")\n+        L[] listeners = (L[]) objectInputStream.readObject();\n+\n+        this.listeners = new CopyOnWriteArrayList<L>(listeners);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType();\n+\n+        initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\n+    }\n+\n+    /**\n+     * Initialize transient fields.\n+     * @param listenerInterface\n+     * @param classLoader\n+     */\n+    private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\n+        createProxy(listenerInterface, classLoader);\n+        @SuppressWarnings(\"unchecked\")\n+        L[] array = (L[]) Array.newInstance(listenerInterface, 0);\n+        this.prototypeArray = array;\n+    }\n+\n+    /**\n      * An invocation handler used to dispatch the event(s) to all the listeners.\n      */\n     private class ProxyInvocationHandler implements InvocationHandler\n     {\n+        /** Serialization version */\n+        private static final long serialVersionUID = 1L;\n+\n         /**\n          * Propagates the method call to all registered listeners in place of\n          * the proxy listener object.\n--- a/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n+++ b/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n \n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.List;\n \n \n         ActionListener[] listeners = listenerSupport.getListeners();\n         assertEquals(0, listeners.length);\n+        assertEquals(ActionListener.class, listeners.getClass().getComponentType());\n         ActionListener[] empty = listeners;\n         //for fun, show that the same empty instance is used \n         assertSame(empty, listenerSupport.getListeners());\n         ActionListener listener1 = EasyMock.createNiceMock(ActionListener.class);\n         listenerSupport.addListener(listener1);\n         assertEquals(1, listenerSupport.getListeners().length);\n-        assertEquals(ActionListener.class, listenerSupport.getListeners().getClass().getComponentType());\n         ActionListener listener2 = EasyMock.createNiceMock(ActionListener.class);\n         listenerSupport.addListener(listener2);\n         assertEquals(2, listenerSupport.getListeners().length);\n         assertSame(empty, listenerSupport.getListeners());\n     }\n \n+    public void testSerialization() throws IOException, ClassNotFoundException {\n+        EventListenerSupport<ActionListener> listenerSupport = EventListenerSupport.create(ActionListener.class);\n+        listenerSupport.addListener(new ActionListener() {\n+            \n+            public void actionPerformed(ActionEvent e) {\n+            }\n+        });\n+        listenerSupport.addListener(EasyMock.createNiceMock(ActionListener.class));\n+\n+        //serialize:\n+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+        ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);\n+\n+        objectOutputStream.writeObject(listenerSupport);\n+        objectOutputStream.close();\n+\n+        //deserialize:\n+        @SuppressWarnings(\"unchecked\")\n+        EventListenerSupport<ActionListener> deserializedListenerSupport = (EventListenerSupport<ActionListener>) new ObjectInputStream(\n+                new ByteArrayInputStream(outputStream.toByteArray())).readObject();\n+\n+        //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock\n+        ActionListener[] listeners = deserializedListenerSupport.getListeners();\n+        assertEquals(ActionListener.class, listeners.getClass().getComponentType());\n+        assertEquals(1, listeners.length);\n+\n+        //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted\n+        ActionListener listener = listeners[0];\n+        ActionEvent evt = new ActionEvent(new Object(), 666, \"sit\");\n+        listener.actionPerformed(evt);\n+        EasyMock.replay(listener);\n+        deserializedListenerSupport.fire().actionPerformed(evt);\n+        EasyMock.verify(listener);\n+\n+        //remove listener and verify we get an empty array of listeners\n+        deserializedListenerSupport.removeListener(listener);\n+        assertEquals(0, deserializedListenerSupport.getListeners().length);\n+    }\n+\n     private void addDeregisterListener(final EventListenerSupport<ActionListener> listenerSupport)\n     {\n         listenerSupport.addListener(new ActionListener()", "timestamp": 1282254593, "metainfo": ""}