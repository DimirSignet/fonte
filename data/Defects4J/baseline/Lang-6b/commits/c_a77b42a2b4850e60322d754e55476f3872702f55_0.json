{"sha": "a77b42a2b4850e60322d754e55476f3872702f55", "log": "Javadoc Remove unnecessary cast  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n      * (indirectly) implemented more than once (e.g. where <code>toClass</code>\n      * specifies the interface {@link java.lang.Iterable Iterable} and\n      * <code>type</code> specifies a parameterized type that implements both\n-     * {@link java.util.Set Set} and {@link java.lang.Collection Collection}),\n+     * {@link java.util.Set Set} and {@link java.util.Collection Collection}),\n      * this method will look at the inheritance hierarchy of only one of the\n      * implementations/subclasses; the first interface encountered that isn't a\n      * subinterface to one of the others in the <code>type</code> to\n      * parameter of {@link java.util.SortedSet}, which in turn sets the\n      * parameter of {@link Set}, which in turn sets the parameter of\n      * {@link java.util.Collection}, which in turn sets the parameter of\n-     * {@link java.util.Iterable}. Since <code>TreeSet</code>'s parameter maps\n+     * {@link java.lang.Iterable}. Since <code>TreeSet</code>'s parameter maps\n      * (indirectly) to <code>Iterable</code>'s parameter, it will be able to\n      * determine that based on the super type <code>Iterable<? extends\n      * Map<Integer,? extends Collection<?>>></code>, the parameter of\n                 // check if this interface is further up the inheritance chain\n                 // than the previously found match\n                 if (isAssignable(midClass, superClass)\n-                        && isAssignable((Type) genericInterface, (Type) midClass)) {\n+                        && isAssignable(genericInterface, (Type) midClass)) {\n                     genericInterface = midType;\n                 }\n             }\n      * <p> Returns an array containing the sole type of {@link Object} if\n      * {@link TypeVariable#getBounds()} returns an empty array. Otherwise, it\n      * returns the result of <code>TypeVariable.getBounds()</code> passed into\n-     * {@link normalizeUpperBounds}. </p>\n+     * {@link #normalizeUpperBounds}. </p>\n      *\n      * @param typeVariable the subject type variable\n      * @return a non-empty array containing the bounds of the type variable.\n      * <p> Returns an array containing the sole value of {@link Object} if\n      * {@link WildcardType#getUpperBounds()} returns an empty array. Otherwise,\n      * it returns the result of <code>WildcardType.getUpperBounds()</code>\n-     * passed into {@link normalizeUpperBounds}. </p>\n+     * passed into {@link #normalizeUpperBounds}. </p>\n      *\n      * @param wildcardType the subject wildcard type\n      * @return a non-empty array containing the upper bounds of the wildcard\n      * {@link WildcardType#getLowerBounds()} returns an empty array. Otherwise,\n      * it returns the result of <code>WildcardType.getLowerBounds()</code>. </p>\n      *\n-     * @param type the subject wildcard type\n+     * @param wildcardType the subject wildcard type\n      * @return a non-empty array containing the lower bounds of the wildcard\n      * type.\n      */", "timestamp": 1279709277, "metainfo": ""}