{"sha": "775cac272207e7b93d45be3ea1766db101450bbe", "log": "LANG-839 ArrayUtils removeElements methods use unnecessary HashSet Add benchmark test to show whether Bitset is faster  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/HashSetvBitSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.util.BitSet;\n+import java.util.HashSet;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test to show whether using BitSet for removeAll() methods is faster than using HashSet.\n+ */\n+public class HashSetvBitSetTest {\n+\n+    private static final int LOOPS = 2000; // number of times to invoke methods\n+\n+    @Test\n+    public void testTimes() {\n+        timeHashSet(10); // warmup\n+        timeBitSet(10); // warmup\n+        printTimes(0);\n+        printTimes(5);\n+        printTimes(10);\n+        printTimes(200);\n+        printTimes(50);\n+        printTimes(100);\n+        printTimes(1000);\n+        printTimes(2000);\n+    }\n+    private void printTimes(int count) {\n+        long hashSet = timeHashSet(count);\n+        long bitSet = timeBitSet(count);\n+        // If percent is less than 100, then bitset is faster\n+        System.out.println(\"Ratio=\"+(bitSet*100/hashSet)+\"% count=\"+count+\" hash=\"+hashSet+\" bits=\"+bitSet);\n+    }\n+\n+    private static long timeHashSet(int count) {\n+        int [] result = new int[0];\n+        long start = System.nanoTime();\n+        for (int i = 0; i < LOOPS; i++) {\n+            result = testHashSet(count);\n+        }\n+        long elapsed = System.nanoTime() - start;\n+        Assert.assertEquals(count, result.length);\n+        return elapsed;\n+    }\n+\n+    private static long timeBitSet(int count) {\n+        int [] result = new int[0];\n+        long start = System.nanoTime();\n+        for (int i = 0; i < LOOPS; i++) {\n+            result = testBitSet(count);\n+        }\n+        long elapsed = System.nanoTime() - start;\n+        Assert.assertEquals(count, result.length);\n+        return elapsed;\n+    }\n+\n+    @SuppressWarnings(\"boxing\")\n+    private static int[] testHashSet(int count) {\n+        HashSet<Integer> toRemove = new HashSet<Integer>();\n+            int found = 0;\n+            for (int i = 0; i < count; i++) {\n+                toRemove.add(found++);\n+            }\n+            return extractIndices(toRemove);\n+        }\n+    \n+    private static int[] testBitSet(int count) {\n+        BitSet toRemove = new BitSet();\n+        int found = 0;\n+        for (int i = 0; i < count; i++) {\n+            toRemove.set(found++);\n+        }\n+        return extractIndices(toRemove);\n+    }\n+    \n+\n+    private static int[] extractIndices(HashSet<Integer> coll) {\n+        int[] result = new int[coll.size()];\n+        int i = 0;\n+        for (Integer index : coll) {\n+            result[i++] = index.intValue();\n+        }\n+        return result;\n+    }\n+\n+    private static int[] extractIndices(BitSet coll) {\n+        int[] result = new int[coll.cardinality()];\n+        int i = 0;\n+        int j=0;\n+        while((j=coll.nextSetBit(j)) != -1) {\n+            result[i++] = j++;            \n+        }\n+        return result;\n+    }\n+}", "timestamp": 1349745320, "metainfo": ""}